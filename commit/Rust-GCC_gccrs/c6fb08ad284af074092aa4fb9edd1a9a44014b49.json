{"sha": "c6fb08ad284af074092aa4fb9edd1a9a44014b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmYjA4YWQyODRhZjA3NDA5MmFhNGZiOWVkZDFhOWE0NDAxNGI0OQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-04-29T07:50:55Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-04-29T07:50:55Z"}, "message": "combine.c (combine_simplify_rtx): Adjust call to use simplify_relational_operation.\n\n2004-04-29  Paolo Bonzini  <bonzini@gnu.org>\n\n        * combine.c (combine_simplify_rtx): Adjust call to use\n        simplify_relational_operation.  Do not use SELECT_CC_MODE\n        when a comparison already has a MODE_CC mode.\n        (simplify_set): simplify_relational_operation may now\n        return another relational expression.\n        * cse.c (fold_rtx): simplify_relational_operation now\n        takes of computing the comparison mode.\n        * dojump.c (compare_from_rtx): Use simplify_relational_operation,\n        remove dead code.\n        (do_compare_rtx_and_jump): Likewise.\n        * integrate.c (subst_constants): simplify_relational_operation\n        may now return another relational expression.\n        * simplify-rtx.c (simplify_gen_relational): Move most code to\n        the new simplify_relational_operation and\n        simplify_relational_operation_1 functions.\n        (simplify_relational_operation): Rewritten.\n        (simplify_relational_operation_1): New function.\n        (simplify_ternary_operation): simplify_relational_operation\n        may now return another relational expression.\n        (simplify_rtx): Remove unnecessary temp variable.\n\nFrom-SVN: r81282", "tree": {"sha": "4be29049b780d10dd9423c8ad52d77c6929b956b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be29049b780d10dd9423c8ad52d77c6929b956b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6fb08ad284af074092aa4fb9edd1a9a44014b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6fb08ad284af074092aa4fb9edd1a9a44014b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6fb08ad284af074092aa4fb9edd1a9a44014b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6fb08ad284af074092aa4fb9edd1a9a44014b49/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6cf1ac42db0684f0c386ec9a665ddcaa12a4f1c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf1ac42db0684f0c386ec9a665ddcaa12a4f1c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf1ac42db0684f0c386ec9a665ddcaa12a4f1c9"}], "stats": {"total": 828, "additions": 407, "deletions": 421}, "files": [{"sha": "01c77f04dbfceb6a037504c21a7fc9fe2aced429", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -1,3 +1,26 @@\n+2004-04-29  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (combine_simplify_rtx): Adjust call to use\n+\tsimplify_relational_operation.  Do not use SELECT_CC_MODE\n+\twhen a comparison already has a MODE_CC mode.\n+\t(simplify_set): simplify_relational_operation may now\n+\treturn another relational expression.\n+\t* cse.c (fold_rtx): simplify_relational_operation now\n+\ttakes of computing the comparison mode.\n+\t* dojump.c (compare_from_rtx): Use simplify_relational_operation,\n+\tremove dead code.\n+\t(do_compare_rtx_and_jump): Likewise.\n+\t* integrate.c (subst_constants): simplify_relational_operation\n+\tmay now return another relational expression.\n+\t* simplify-rtx.c (simplify_gen_relational): Move most code to\n+\tthe new simplify_relational_operation and\n+\tsimplify_relational_operation_1 functions.\n+\t(simplify_relational_operation): Rewritten.\n+\t(simplify_relational_operation_1): New function.\n+\t(simplify_ternary_operation): simplify_relational_operation\n+\tmay now return another relational expression.\n+\t(simplify_rtx): Remove unnecessary temp variable. \n+\n 2004-04-29  Uros Bizjak  <uros@kss-loka.si>\n \n         * reg-stack.c (swap_to_top): New function."}, {"sha": "1d6093a516d3e5d3d7679d25d7d294e4fcfb0803", "filename": "gcc/combine.c", "status": "modified", "additions": 214, "deletions": 237, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -143,13 +143,103 @@ static int max_uid_cuid;\n \n static unsigned int combine_max_regno;\n \n-/* Record last point of death of (hard or pseudo) register n.  */\n+struct reg_stat {\n+  /* Record last point of death of (hard or pseudo) register n.  */\n+  rtx\t\t\t\tlast_death;\n \n-static rtx *reg_last_death;\n+  /* Record last point of modification of (hard or pseudo) register n.  */\n+  rtx\t\t\t\tlast_set;\n \n-/* Record last point of modification of (hard or pseudo) register n.  */\n+  /* The next group of fields allows the recording of the last value assigned\n+     to (hard or pseudo) register n.  We use this information to see if an\n+     operation being processed is redundant given a prior operation performed\n+     on the register.  For example, an `and' with a constant is redundant if\n+     all the zero bits are already known to be turned off.\n \n-static rtx *reg_last_set;\n+     We use an approach similar to that used by cse, but change it in the\n+     following ways:\n+\n+     (1) We do not want to reinitialize at each label.\n+     (2) It is useful, but not critical, to know the actual value assigned\n+         to a register.  Often just its form is helpful.\n+\n+     Therefore, we maintain the following fields:\n+\n+     last_set_value\t\tthe last value assigned\n+     last_set_label\t\trecords the value of label_tick when the\n+\t\t\t\tregister was assigned\n+     last_set_table_tick\trecords the value of label_tick when a\n+\t\t\t\tvalue using the register is assigned\n+     last_set_invalid\t\tset to nonzero when it is not valid\n+\t\t\t\tto use the value of this register in some\n+\t\t\t\tregister's value\n+\n+     To understand the usage of these tables, it is important to understand\n+     the distinction between the value in last_set_value being valid and\n+     the register being validly contained in some other expression in the\n+     table.\n+\n+     (The next two parameters are out of date).\n+\n+     reg_stat[i].last_set_value is valid if it is nonzero, and either\n+     reg_n_sets[i] is 1 or reg_stat[i].last_set_label == label_tick.\n+\n+     Register I may validly appear in any expression returned for the value\n+     of another register if reg_n_sets[i] is 1.  It may also appear in the\n+     value for register J if reg_stat[j].last_set_invalid is zero, or\n+     reg_stat[i].last_set_label < reg_stat[j].last_set_label.\n+\n+     If an expression is found in the table containing a register which may\n+     not validly appear in an expression, the register is replaced by\n+     something that won't match, (clobber (const_int 0)).  */\n+\n+  /* Record last value assigned to (hard or pseudo) register n.  */\n+\n+  rtx\t\t\t\tlast_set_value;\n+\n+  /* Record the value of label_tick when an expression involving register n\n+     is placed in last_set_value.  */\n+\n+  int\t\t\t\tlast_set_table_tick;\n+\n+  /* Record the value of label_tick when the value for register n is placed in\n+     last_set_value.  */\n+\n+  int\t\t\t\tlast_set_label;\n+\n+  /* These fields are maintained in parallel with last_set_value and are\n+     used to store the mode in which the register was last set, te bits\n+     that were known to be zero when it was last set, and the number of\n+     sign bits copies it was known to have when it was last set.  */\n+\n+  unsigned HOST_WIDE_INT\tlast_set_nonzero_bits;\n+  char\t\t\t\tlast_set_sign_bit_copies;\n+  ENUM_BITFIELD(machine_mode)\tlast_set_mode : 8; \n+\n+  /* Set nonzero if references to register n in expressions should not be\n+     used.  last_set_invalid is set nonzero when this register is being\n+     assigned to and last_set_table_tick == label_tick.  */\n+\n+  char\t\t\t\tlast_set_invalid;\n+\n+  /* Some registers that are set more than once and used in more than one\n+     basic block are nevertheless always set in similar ways.  For example,\n+     a QImode register may be loaded from memory in two places on a machine\n+     where byte loads zero extend.\n+\n+     We record in the following fields if a register has some leading bits\n+     that are always equal to the sign bit, and what we know about the\n+     nonzero bits of a register, specifically which bits are known to be\n+     zero.\n+\n+     If an entry is zero, it means that we don't know anything special.  */\n+\n+  unsigned char\t\t\tsign_bit_copies;\n+\n+  unsigned HOST_WIDE_INT\tnonzero_bits;\n+};\n+\n+static struct reg_stat *reg_stat;\n \n /* Record the cuid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n@@ -197,110 +287,23 @@ static basic_block this_basic_block;\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n \f\n-/* The next group of arrays allows the recording of the last value assigned\n-   to (hard or pseudo) register n.  We use this information to see if an\n-   operation being processed is redundant given a prior operation performed\n-   on the register.  For example, an `and' with a constant is redundant if\n-   all the zero bits are already known to be turned off.\n-\n-   We use an approach similar to that used by cse, but change it in the\n-   following ways:\n-\n-   (1) We do not want to reinitialize at each label.\n-   (2) It is useful, but not critical, to know the actual value assigned\n-       to a register.  Often just its form is helpful.\n-\n-   Therefore, we maintain the following arrays:\n-\n-   reg_last_set_value\t\tthe last value assigned\n-   reg_last_set_label\t\trecords the value of label_tick when the\n-\t\t\t\tregister was assigned\n-   reg_last_set_table_tick\trecords the value of label_tick when a\n-\t\t\t\tvalue using the register is assigned\n-   reg_last_set_invalid\t\tset to nonzero when it is not valid\n-\t\t\t\tto use the value of this register in some\n-\t\t\t\tregister's value\n-\n-   To understand the usage of these tables, it is important to understand\n-   the distinction between the value in reg_last_set_value being valid\n-   and the register being validly contained in some other expression in the\n-   table.\n-\n-   Entry I in reg_last_set_value is valid if it is nonzero, and either\n-   reg_n_sets[i] is 1 or reg_last_set_label[i] == label_tick.\n-\n-   Register I may validly appear in any expression returned for the value\n-   of another register if reg_n_sets[i] is 1.  It may also appear in the\n-   value for register J if reg_last_set_label[i] < reg_last_set_label[j] or\n-   reg_last_set_invalid[j] is zero.\n-\n-   If an expression is found in the table containing a register which may\n-   not validly appear in an expression, the register is replaced by\n-   something that won't match, (clobber (const_int 0)).\n-\n-   reg_last_set_invalid[i] is set nonzero when register I is being assigned\n-   to and reg_last_set_table_tick[i] == label_tick.  */\n-\n-/* Record last value assigned to (hard or pseudo) register n.  */\n-\n-static rtx *reg_last_set_value;\n-\n-/* Record the value of label_tick when the value for register n is placed in\n-   reg_last_set_value[n].  */\n-\n-static int *reg_last_set_label;\n-\n-/* Record the value of label_tick when an expression involving register n\n-   is placed in reg_last_set_value.  */\n-\n-static int *reg_last_set_table_tick;\n-\n-/* Set nonzero if references to register n in expressions should not be\n-   used.  */\n-\n-static char *reg_last_set_invalid;\n-\n /* Incremented for each label.  */\n \n static int label_tick;\n \n-/* Some registers that are set more than once and used in more than one\n-   basic block are nevertheless always set in similar ways.  For example,\n-   a QImode register may be loaded from memory in two places on a machine\n-   where byte loads zero extend.\n-\n-   We record in the following array what we know about the nonzero\n-   bits of a register, specifically which bits are known to be zero.\n-\n-   If an entry is zero, it means that we don't know anything special.  */\n-\n-static unsigned HOST_WIDE_INT *reg_nonzero_bits;\n-\n-/* Mode used to compute significance in reg_nonzero_bits.  It is the largest\n-   integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n+/* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n+   largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n static enum machine_mode nonzero_bits_mode;\n \n-/* Nonzero if we know that a register has some leading bits that are always\n-   equal to the sign bit.  */\n-\n-static unsigned char *reg_sign_bit_copies;\n-\n-/* Nonzero when reg_nonzero_bits and reg_sign_bit_copies can be safely used.\n-   It is zero while computing them and after combine has completed.  This\n-   former test prevents propagating values based on previously set values,\n-   which can be incorrect if a variable is modified in a loop.  */\n+/* Nonzero when reg_stat[].nonzero_bits and reg_stat[].sign_bit_copies can\n+   be safely used.  It is zero while computing them and after combine has\n+   completed.  This former test prevents propagating values based on\n+   previously set values, which can be incorrect if a variable is modified\n+   in a loop.  */\n \n static int nonzero_sign_valid;\n \n-/* These arrays are maintained in parallel with reg_last_set_value\n-   and are used to store the mode in which the register was last set,\n-   the bits that were known to be zero when it was last set, and the\n-   number of sign bits copies it was known to have when it was last set.  */\n-\n-static enum machine_mode *reg_last_set_mode;\n-static unsigned HOST_WIDE_INT *reg_last_set_nonzero_bits;\n-static char *reg_last_set_sign_bit_copies;\n \f\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.\n@@ -336,7 +339,7 @@ static int n_occurrences;\n \n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n-static void init_reg_last_arrays (void);\n+static void init_reg_last (void);\n static void setup_incoming_promotions (void);\n static void set_nonzero_bits_and_sign_copies (rtx, rtx, void *);\n static int cant_combine_insn_p (rtx);\n@@ -523,20 +526,7 @@ combine_instructions (rtx f, unsigned int nregs)\n      See comments in gen_lowpart_for_combine.  */\n   gen_lowpart = gen_lowpart_for_combine;\n \n-  reg_nonzero_bits = xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT));\n-  reg_sign_bit_copies = xcalloc (nregs, sizeof (unsigned char));\n-\n-  reg_last_death = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_value = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_table_tick = xmalloc (nregs * sizeof (int));\n-  reg_last_set_label = xmalloc (nregs * sizeof (int));\n-  reg_last_set_invalid = xmalloc (nregs * sizeof (char));\n-  reg_last_set_mode = xmalloc (nregs * sizeof (enum machine_mode));\n-  reg_last_set_nonzero_bits = xmalloc (nregs * sizeof (HOST_WIDE_INT));\n-  reg_last_set_sign_bit_copies = xmalloc (nregs * sizeof (char));\n-\n-  init_reg_last_arrays ();\n+  reg_stat = xcalloc (nregs, sizeof (struct reg_stat));\n \n   init_recog_no_volatile ();\n \n@@ -551,8 +541,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n-  /* Don't use reg_nonzero_bits when computing it.  This can cause problems\n-     when, for example, we have j <<= 1 in a loop.  */\n+  /* Don't use reg_stat[].nonzero_bits when computing it.  This can cause\n+     problems when, for example, we have j <<= 1 in a loop.  */\n \n   nonzero_sign_valid = 0;\n \n@@ -605,7 +595,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n-  init_reg_last_arrays ();\n+  init_reg_last ();\n   setup_incoming_promotions ();\n \n   FOR_EACH_BB (this_basic_block)\n@@ -768,17 +758,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   /* Clean up.  */\n   sbitmap_free (refresh_blocks);\n-  free (reg_nonzero_bits);\n-  free (reg_sign_bit_copies);\n-  free (reg_last_death);\n-  free (reg_last_set);\n-  free (reg_last_set_value);\n-  free (reg_last_set_table_tick);\n-  free (reg_last_set_label);\n-  free (reg_last_set_invalid);\n-  free (reg_last_set_mode);\n-  free (reg_last_set_nonzero_bits);\n-  free (reg_last_set_sign_bit_copies);\n+  free (reg_stat);\n   free (uid_cuid);\n \n   {\n@@ -805,22 +785,14 @@ combine_instructions (rtx f, unsigned int nregs)\n   return new_direct_jump_p;\n }\n \n-/* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n+/* Wipe the last_xxx fields of reg_stat in preparation for another pass.  */\n \n static void\n-init_reg_last_arrays (void)\n+init_reg_last (void)\n {\n-  unsigned int nregs = combine_max_regno;\n-\n-  memset (reg_last_death, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set_value, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set_table_tick, 0, nregs * sizeof (int));\n-  memset (reg_last_set_label, 0, nregs * sizeof (int));\n-  memset (reg_last_set_invalid, 0, nregs * sizeof (char));\n-  memset (reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n-  memset (reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n-  memset (reg_last_set_sign_bit_copies, 0, nregs * sizeof (char));\n+  unsigned int i;\n+  for (i = 0; i < combine_max_regno; i++)\n+    memset (reg_stat + i, 0, offsetof (struct reg_stat, sign_bit_copies));\n }\n \f\n /* Set up any promoted values for incoming argument registers.  */\n@@ -878,8 +850,8 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n-\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_sign_bit_copies[REGNO (x)] = 1;\n+\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n \t  return;\n \t}\n \n@@ -901,7 +873,7 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than a word and SRC is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_nonzero_bits because some\n+\t     sign-extend it for use in reg_stat[].nonzero_bits because some\n \t     machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n@@ -920,18 +892,18 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #endif\n \n \t  /* Don't call nonzero_bits if it cannot change anything.  */\n-\t  if (reg_nonzero_bits[REGNO (x)] != ~(unsigned HOST_WIDE_INT) 0)\n-\t    reg_nonzero_bits[REGNO (x)]\n+\t  if (reg_stat[REGNO (x)].nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n+\t    reg_stat[REGNO (x)].nonzero_bits\n \t      |= nonzero_bits (src, nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-\t  if (reg_sign_bit_copies[REGNO (x)] == 0\n-\t      || reg_sign_bit_copies[REGNO (x)] > num)\n-\t    reg_sign_bit_copies[REGNO (x)] = num;\n+\t  if (reg_stat[REGNO (x)].sign_bit_copies == 0\n+\t      || reg_stat[REGNO (x)].sign_bit_copies > num)\n+\t    reg_stat[REGNO (x)].sign_bit_copies = num;\n \t}\n       else\n \t{\n-\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_sign_bit_copies[REGNO (x)] = 1;\n+\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n \t}\n     }\n }\n@@ -1101,7 +1073,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t does not use any registers whose values alter in between.  However,\n \t If the insns are adjacent, a use can't cross a set even though we\n \t think it might (this can happen for a sequence of insns each setting\n-\t the same destination; reg_last_set of that register might point to\n+\t the same destination; last_set of that register might point to\n \t a NOTE).  If INSN has a REG_EQUIV note, the register is always\n \t equivalent to the memory so the substitution is valid even if there\n \t are intervening stores.  Also, don't move a volatile asm or\n@@ -2331,18 +2303,18 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (GET_CODE (temp) == REG\n-\t\t  && reg_nonzero_bits[REGNO (temp)] != 0\n+\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (reg_nonzero_bits[REGNO (temp)]\n+\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (GET_CODE (temp) == REG\n-\t\t      && reg_nonzero_bits[REGNO (temp)] != 0\n+\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (reg_nonzero_bits[REGNO (temp)]\n+\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -2783,9 +2755,10 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  REG_N_SETS (regno)--;\n       }\n \n-    /* Update reg_nonzero_bits et al for any changes that may have been made\n-       to this insn.  The order of set_nonzero_bits_and_sign_copies() is\n-       important.  Because newi2pat can affect nonzero_bits of newpat */\n+    /* Update reg_stat[].nonzero_bits et al for any changes that may have\n+       been made to this insn.  The order of\n+       set_nonzero_bits_and_sign_copies() is important.  Because newi2pat\n+       can affect nonzero_bits of newpat */\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n     note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n@@ -4994,23 +4967,23 @@ simplify_set (rtx x)\n       rtx op0, op1, tmp;\n       int other_changed = 0;\n       enum machine_mode compare_mode = GET_MODE (dest);\n-      enum machine_mode tmp_mode;\n \n       if (GET_CODE (src) == COMPARE)\n \top0 = XEXP (src, 0), op1 = XEXP (src, 1);\n       else\n \top0 = src, op1 = const0_rtx;\n \n-      /* Check whether the comparison is known at compile time.  */\n-      if (GET_MODE (op0) != VOIDmode)\n-\ttmp_mode = GET_MODE (op0);\n-      else if (GET_MODE (op1) != VOIDmode)\n-\ttmp_mode = GET_MODE (op1);\n+      tmp = simplify_relational_operation (old_code, compare_mode, VOIDmode,\n+\t\t\t\t\t   op0, op1);\n+      if (!tmp)\n+        new_code = old_code;\n+      else if (!CONSTANT_P (tmp))\n+        {\n+          new_code = GET_CODE (tmp);\n+          op0 = XEXP (tmp, 0);\n+          op1 = XEXP (tmp, 1);\n+        }\n       else\n-\ttmp_mode = compare_mode;\n-      tmp = simplify_const_relational_operation (old_code, tmp_mode,\n-\t\t\t\t\t\t op0, op1);\n-      if (tmp != NULL_RTX)\n \t{\n \t  rtx pat = PATTERN (other_insn);\n \t  undobuf.other_insn = other_insn;\n@@ -5031,12 +5004,15 @@ simplify_set (rtx x)\n \t}\n \n       /* Simplify our comparison, if possible.  */\n-      new_code = simplify_comparison (old_code, &op0, &op1);\n+      new_code = simplify_comparison (new_code, &op0, &op1);\n \n #ifdef SELECT_CC_MODE\n       /* If this machine has CC modes other than CCmode, check to see if we\n \t need to use a different CC mode here.  */\n-      compare_mode = SELECT_CC_MODE (new_code, op0, op1);\n+      if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+\tcompare_mode = GET_MODE (op0);\n+      else\n+\tcompare_mode = SELECT_CC_MODE (new_code, op0, op1);\n \n #ifndef HAVE_cc0\n       /* If the mode changed, we have to change SET_DEST, the mode in the\n@@ -8168,17 +8144,17 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n \t value.  Otherwise, use the previously-computed global nonzero bits\n \t for this register.  */\n \n-      if (reg_last_set_value[REGNO (x)] != 0\n-\t  && (reg_last_set_mode[REGNO (x)] == mode\n-\t      || (GET_MODE_CLASS (reg_last_set_mode[REGNO (x)]) == MODE_INT\n+      if (reg_stat[REGNO (x)].last_set_value != 0\n+\t  && (reg_stat[REGNO (x)].last_set_mode == mode\n+\t      || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n \t\t  && GET_MODE_CLASS (mode) == MODE_INT))\n-\t  && (reg_last_set_label[REGNO (x)] == label_tick\n+\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n-\treturn reg_last_set_nonzero_bits[REGNO (x)] & nonzero;\n+\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\treturn reg_stat[REGNO (x)].last_set_nonzero_bits & nonzero;\n \n       tem = get_last_value (x);\n \n@@ -8187,8 +8163,8 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than MODE and TEM is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_nonzero_bits because some\n-\t     machines (maybe most) will actually do the sign-extension\n+\t     sign-extend it for use in reg_stat[].nonzero_bits because\n+\t     some machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n \t     ??? For 2.5, try to tighten up the MD files in this regard\n@@ -8206,9 +8182,9 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #endif\n \t  return nonzero_bits_with_known (tem, mode) & nonzero;\n \t}\n-      else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n+      else if (nonzero_sign_valid && reg_stat[REGNO (x)].nonzero_bits)\n \t{\n-\t  unsigned HOST_WIDE_INT mask = reg_nonzero_bits[REGNO (x)];\n+\t  unsigned HOST_WIDE_INT mask = reg_stat[REGNO (x)].nonzero_bits;\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) < mode_width)\n \t    /* We don't know anything about the upper bits.  */\n@@ -8664,23 +8640,23 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n \treturn GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;\n #endif\n \n-      if (reg_last_set_value[REGNO (x)] != 0\n-\t  && reg_last_set_mode[REGNO (x)] == mode\n-\t  && (reg_last_set_label[REGNO (x)] == label_tick\n+      if (reg_stat[REGNO (x)].last_set_value != 0\n+\t  && reg_stat[REGNO (x)].last_set_mode == mode\n+\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n-\treturn reg_last_set_sign_bit_copies[REGNO (x)];\n+\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\treturn reg_stat[REGNO (x)].last_set_sign_bit_copies;\n \n       tem = get_last_value (x);\n       if (tem != 0)\n \treturn num_sign_bit_copies_with_known (tem, mode);\n \n-      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0\n+      if (nonzero_sign_valid && reg_stat[REGNO (x)].sign_bit_copies != 0\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) == bitwidth)\n-\treturn reg_sign_bit_copies[REGNO (x)];\n+\treturn reg_stat[REGNO (x)].sign_bit_copies;\n       break;\n \n     case MEM:\n@@ -11364,7 +11340,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value\n-   being stored into reg_last_set_value.  Sets reg_last_set_table_tick\n+   being stored into last_set_value.  Sets last_set_table_tick\n    for each register mentioned.  Similar to mention_regs in cse.c  */\n \n static void\n@@ -11383,7 +11359,7 @@ update_table_tick (rtx x)\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n-\treg_last_set_table_tick[r] = label_tick;\n+\treg_stat[r].last_set_table_tick = label_tick;\n \n       return;\n     }\n@@ -11431,8 +11407,9 @@ update_table_tick (rtx x)\n \n /* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we\n    are saying that the register is clobbered and we no longer know its\n-   value.  If INSN is zero, don't update reg_last_set; this is only permitted\n-   with VALUE also zero and is used to invalidate the register.  */\n+   value.  If INSN is zero, don't update reg_stat[].last_set; this is\n+   only permitted with VALUE also zero and is used to invalidate the\n+   register.  */\n \n static void\n record_value_for_reg (rtx reg, rtx insn, rtx value)\n@@ -11476,13 +11453,13 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   for (i = regno; i < endregno; i++)\n     {\n       if (insn)\n-\treg_last_set[i] = insn;\n+\treg_stat[i].last_set = insn;\n \n-      reg_last_set_value[i] = 0;\n-      reg_last_set_mode[i] = 0;\n-      reg_last_set_nonzero_bits[i] = 0;\n-      reg_last_set_sign_bit_copies[i] = 0;\n-      reg_last_death[i] = 0;\n+      reg_stat[i].last_set_value = 0;\n+      reg_stat[i].last_set_mode = 0;\n+      reg_stat[i].last_set_nonzero_bits = 0;\n+      reg_stat[i].last_set_sign_bit_copies = 0;\n+      reg_stat[i].last_death = 0;\n     }\n \n   /* Mark registers that are being referenced in this value.  */\n@@ -11498,40 +11475,40 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      reg_last_set_label[i] = label_tick;\n-      if (value && reg_last_set_table_tick[i] == label_tick)\n-\treg_last_set_invalid[i] = 1;\n+      reg_stat[i].last_set_label = label_tick;\n+      if (value && reg_stat[i].last_set_table_tick == label_tick)\n+\treg_stat[i].last_set_invalid = 1;\n       else\n-\treg_last_set_invalid[i] = 0;\n+\treg_stat[i].last_set_invalid = 0;\n     }\n \n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n   if (value && ! get_last_value_validate (&value, insn,\n-\t\t\t\t\t  reg_last_set_label[regno], 0))\n+\t\t\t\t\t  reg_stat[regno].last_set_label, 0))\n     {\n       value = copy_rtx (value);\n       if (! get_last_value_validate (&value, insn,\n-\t\t\t\t     reg_last_set_label[regno], 1))\n+\t\t\t\t     reg_stat[regno].last_set_label, 1))\n \tvalue = 0;\n     }\n \n   /* For the main register being modified, update the value, the mode, the\n      nonzero bits, and the number of sign bit copies.  */\n \n-  reg_last_set_value[regno] = value;\n+  reg_stat[regno].last_set_value = value;\n \n   if (value)\n     {\n       enum machine_mode mode = GET_MODE (reg);\n       subst_low_cuid = INSN_CUID (insn);\n-      reg_last_set_mode[regno] = mode;\n+      reg_stat[regno].last_set_mode = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \tmode = nonzero_bits_mode;\n-      reg_last_set_nonzero_bits[regno] = nonzero_bits (value, mode);\n-      reg_last_set_sign_bit_copies[regno]\n+      reg_stat[regno].last_set_nonzero_bits = nonzero_bits (value, mode);\n+      reg_stat[regno].last_set_sign_bit_copies\n \t= num_sign_bit_copies (value, GET_MODE (reg));\n     }\n }\n@@ -11576,11 +11553,11 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n    for the things done by INSN.  This is the last thing done in processing\n    INSN in the combiner loop.\n \n-   We update reg_last_set, reg_last_set_value, reg_last_set_mode,\n-   reg_last_set_nonzero_bits, reg_last_set_sign_bit_copies, reg_last_death,\n-   and also the similar information mem_last_set (which insn most recently\n-   modified memory) and last_call_cuid (which insn was the most recent\n-   subroutine call).  */\n+   We update reg_stat[], in particular fields last_set, last_set_value,\n+   last_set_mode, last_set_nonzero_bits, last_set_sign_bit_copies,\n+   last_death, and also the similar information mem_last_set (which insn\n+   most recently modified memory) and last_call_cuid (which insn was the\n+   most recent subroutine call).  */\n \n static void\n record_dead_and_set_regs (rtx insn)\n@@ -11600,7 +11577,7 @@ record_dead_and_set_regs (rtx insn)\n \t\t       : 1);\n \n \t  for (i = regno; i < endregno; i++)\n-\t    reg_last_death[i] = insn;\n+\t    reg_stat[i].last_death = insn;\n \t}\n       else if (REG_NOTE_KIND (link) == REG_INC)\n \trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n@@ -11611,11 +11588,11 @@ record_dead_and_set_regs (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  {\n-\t    reg_last_set_value[i] = 0;\n-\t    reg_last_set_mode[i] = 0;\n-\t    reg_last_set_nonzero_bits[i] = 0;\n-\t    reg_last_set_sign_bit_copies[i] = 0;\n-\t    reg_last_death[i] = 0;\n+\t    reg_stat[i].last_set_value = 0;\n+\t    reg_stat[i].last_set_mode = 0;\n+\t    reg_stat[i].last_set_nonzero_bits = 0;\n+\t    reg_stat[i].last_set_sign_bit_copies = 0;\n+\t    reg_stat[i].last_death = 0;\n \t  }\n \n       last_call_cuid = mem_last_set = INSN_CUID (insn);\n@@ -11663,10 +11640,10 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      if (reg_last_set[regno] == insn)\n+      if (reg_stat[regno].last_set == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n-\t    reg_last_set_nonzero_bits[regno] &= GET_MODE_MASK (mode);\n+\t    reg_stat[regno].last_set_nonzero_bits &= GET_MODE_MASK (mode);\n \t}\n \n       if (GET_CODE (SET_SRC (set)) == REG)\n@@ -11736,14 +11713,14 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n-\tif (reg_last_set_invalid[j]\n+\tif (reg_stat[j].last_set_invalid\n \t    /* If this is a pseudo-register that was only set once and not\n \t       live at the beginning of the function, it is always valid.  */\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n \t\t       (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))\n-\t\t&& reg_last_set_label[j] > tick))\n+\t\t&& reg_stat[j].last_set_label > tick))\n \t  {\n \t    if (replace)\n \t      *loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n@@ -11835,7 +11812,7 @@ get_last_value (rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  value = reg_last_set_value[regno];\n+  value = reg_stat[regno].last_set_value;\n \n   /* If we don't have a value, or if it isn't for this basic block and\n      it's either a hard register, set more than once, or it's a live\n@@ -11848,7 +11825,7 @@ get_last_value (rtx x)\n      block.  */\n \n   if (value == 0\n-      || (reg_last_set_label[regno] != label_tick\n+      || (reg_stat[regno].last_set_label != label_tick\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || (REGNO_REG_SET_P\n@@ -11857,20 +11834,20 @@ get_last_value (rtx x)\n \n   /* If the value was set in a later insn than the ones we are processing,\n      we can't use it even if the register was only set once.  */\n-  if (INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)\n+  if (INSN_CUID (reg_stat[regno].last_set) >= subst_low_cuid)\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */\n-  if (get_last_value_validate (&value, reg_last_set[regno],\n-\t\t\t       reg_last_set_label[regno], 0))\n+  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n+\t\t\t       reg_stat[regno].last_set_label, 0))\n     return value;\n \n   /* Otherwise, make a copy and replace any invalid register with\n      (clobber (const_int 0)).  If that fails for some reason, return 0.  */\n \n   value = copy_rtx (value);\n-  if (get_last_value_validate (&value, reg_last_set[regno],\n-\t\t\t       reg_last_set_label[regno], 1))\n+  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n+\t\t\t       reg_stat[regno].last_set_label, 1))\n     return value;\n \n   return 0;\n@@ -11899,8 +11876,8 @@ use_crosses_set_p (rtx x, int from_cuid)\n \treturn 1;\n #endif\n       for (; regno < endreg; regno++)\n-\tif (reg_last_set[regno]\n-\t    && INSN_CUID (reg_last_set[regno]) > from_cuid)\n+\tif (reg_stat[regno].last_set\n+\t    && INSN_CUID (reg_stat[regno].last_set) > from_cuid)\n \t  return 1;\n       return 0;\n     }\n@@ -12160,7 +12137,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = reg_last_death[regno];\n+      rtx where_dead = reg_stat[regno].last_death;\n       rtx before_dead, after_dead;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n@@ -12187,7 +12164,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t  rtx note = remove_death (regno, where_dead);\n \n \t  /* It is possible for the call above to return 0.  This can occur\n-\t     when reg_last_death points to I2 or I1 that we combined with.\n+\t     when last_death points to I2 or I1 that we combined with.\n \t     In that case make a new note.\n \n \t     We must also check for the case where X is a hard register\n@@ -12794,14 +12771,14 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))\n \t\t{\n \t\t  /* Unless the register previously died in PLACE, clear\n-\t\t     reg_last_death.  [I no longer understand why this is\n+\t\t     last_death.  [I no longer understand why this is\n \t\t     being done.] */\n-\t\t  if (reg_last_death[regno] != place)\n-\t\t    reg_last_death[regno] = 0;\n+\t\t  if (reg_stat[regno].last_death != place)\n+\t\t    reg_stat[regno].last_death = 0;\n \t\t  place = 0;\n \t\t}\n \t      else\n-\t\treg_last_death[regno] = place;\n+\t\treg_stat[regno].last_death = place;\n \n \t      /* If this is a death note for a hard reg that is occupying\n \t\t multiple registers, ensure that we are still using all"}, {"sha": "e155db98fea95713f4529423f95530a50bcdeaad", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -3924,21 +3924,11 @@ fold_rtx (rtx x, rtx insn)\n \t    }\n \t}\n \n-      new = simplify_relational_operation (code, mode,\n-\t\t\t\t\t   (mode_arg0 != VOIDmode\n-\t\t\t\t\t    ? mode_arg0\n-\t\t\t\t\t    : (GET_MODE (const_arg0\n-\t\t\t\t\t\t\t ? const_arg0\n-\t\t\t\t\t\t\t : folded_arg0)\n-\t\t\t\t\t       != VOIDmode)\n-\t\t\t\t\t    ? GET_MODE (const_arg0\n-\t\t\t\t\t\t\t? const_arg0\n-\t\t\t\t\t\t\t: folded_arg0)\n-\t\t\t\t\t    : GET_MODE (const_arg1\n-\t\t\t\t\t\t\t? const_arg1\n-\t\t\t\t\t\t\t: folded_arg1)),\n-\t\t\t\t\t   const_arg0 ? const_arg0 : folded_arg0,\n-\t\t\t\t\t   const_arg1 ? const_arg1 : folded_arg1);\n+      {\n+\trtx op0 = const_arg0 ? const_arg0 : folded_arg0;\n+\trtx op1 = const_arg1 ? const_arg1 : folded_arg1;\n+        new = simplify_relational_operation (code, mode, mode_arg0, op0, op1);\n+      }\n       break;\n \n     case RTX_BIN_ARITH:"}, {"sha": "7f76c5e752f7c4540ae66829b3a334c2987881bd", "filename": "gcc/dojump.c", "status": "modified", "additions": 27, "deletions": 61, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -820,7 +820,6 @@ rtx\n compare_from_rtx (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t  enum machine_mode mode, rtx size)\n {\n-  enum rtx_code ucode;\n   rtx tem;\n \n   /* If one operand is constant, make it the second one.  Only do this\n@@ -842,32 +841,19 @@ compare_from_rtx (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \n   do_pending_stack_adjust ();\n \n-  ucode = unsignedp ? unsigned_condition (code) : code;\n-  tem = simplify_const_relational_operation (ucode, mode, op0, op1);\n-  if (tem != 0)\n-    return tem;\n-\n-#if 0\n-  /* There's no need to do this now that combine.c can eliminate lots of\n-     sign extensions.  This can be less efficient in certain cases on other\n-     machines.  */\n-\n-  /* If this is a signed equality comparison, we can do it as an\n-     unsigned comparison since zero-extension is cheaper than sign\n-     extension and comparisons with zero are done as unsigned.  This is\n-     the case even on machines that can do fast sign extension, since\n-     zero-extension is easier to combine with other operations than\n-     sign-extension is.  If we are comparing against a constant, we must\n-     convert it to what it would look like unsigned.  */\n-  if ((code == EQ || code == NE) && ! unsignedp\n-      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n+  code = unsignedp ? unsigned_condition (code) : code;\n+  if (0 != (tem = simplify_relational_operation (code, mode, VOIDmode,\n+\t\t\t\t\t\t op0, op1)))\n     {\n-      if (GET_CODE (op1) == CONST_INT\n-          && (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))\n-        op1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n-      unsignedp = 1;\n+      if (CONSTANT_P (tem))\n+\treturn tem;\n+\n+      code = GET_CODE (tem);\n+      mode = GET_MODE (tem);\n+      op0 = XEXP (tem, 0);\n+      op1 = XEXP (tem, 1);\n+      unsignedp = (code == GTU || code == LTU || code == GEU || code == LEU);\n     }\n-#endif\n \n   emit_cmp_insn (op0, op1, code, size, mode, unsignedp);\n \n@@ -889,7 +875,6 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t\t enum machine_mode mode, rtx size, rtx if_false_label,\n \t\t\t rtx if_true_label)\n {\n-  enum rtx_code ucode;\n   rtx tem;\n   int dummy_true_label = 0;\n \n@@ -921,44 +906,25 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \n   do_pending_stack_adjust ();\n \n-  ucode = unsignedp ? unsigned_condition (code) : code;\n-  tem = simplify_const_relational_operation (ucode, mode, op0, op1);\n-  if (tem != 0)\n+  code = unsignedp ? unsigned_condition (code) : code;\n+  if (0 != (tem = simplify_relational_operation (code, mode, VOIDmode,\n+\t\t\t\t\t\t op0, op1)))\n     {\n-      if (tem == const_true_rtx)\n-        {\n-          if (if_true_label)\n-            emit_jump (if_true_label);\n-        }\n-      else\n-        {\n-          if (if_false_label)\n-            emit_jump (if_false_label);\n-        }\n-      return;\n-    }\n+      if (CONSTANT_P (tem))\n+\t{\n+\t  rtx label = (tem == const0_rtx || tem == CONST0_RTX (mode))\n+\t\t      ? if_false_label : if_true_label;\n+\t  if (label)\n+\t    emit_jump (label);\n+\t  return;\n+\t}\n \n-#if 0\n-  /* There's no need to do this now that combine.c can eliminate lots of\n-     sign extensions.  This can be less efficient in certain cases on other\n-     machines.  */\n-\n-  /* If this is a signed equality comparison, we can do it as an\n-     unsigned comparison since zero-extension is cheaper than sign\n-     extension and comparisons with zero are done as unsigned.  This is\n-     the case even on machines that can do fast sign extension, since\n-     zero-extension is easier to combine with other operations than\n-     sign-extension is.  If we are comparing against a constant, we must\n-     convert it to what it would look like unsigned.  */\n-  if ((code == EQ || code == NE) && ! unsignedp\n-      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      if (GET_CODE (op1) == CONST_INT\n-          && (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))\n-        op1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n-      unsignedp = 1;\n+      code = GET_CODE (tem);\n+      mode = GET_MODE (tem);\n+      op0 = XEXP (tem, 0);\n+      op1 = XEXP (tem, 1);\n+      unsignedp = (code == GTU || code == LTU || code == GEU || code == LEU);\n     }\n-#endif\n \n   if (! if_true_label)\n     {"}, {"sha": "3a58f2cda04c4ee696cc74362fa39893e0d97621", "filename": "gcc/integrate.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -2738,6 +2738,7 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \n \t  if (op_mode == VOIDmode)\n \t    op_mode = GET_MODE (XEXP (x, 1));\n+\n \t  new = simplify_relational_operation (code, GET_MODE (x), op_mode,\n \t\t\t\t\t       XEXP (x, 0), XEXP (x, 1));\n \t  break;\n@@ -2766,15 +2767,18 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \t      {\n \t\t/* We have compare of two VOIDmode constants for which\n \t\t   we recorded the comparison mode.  */\n-\t\trtx temp =\n-\t\t  simplify_const_relational_operation (GET_CODE (op0),\n-\t\t\t\t\t\t       map->compare_mode,\n-\t\t\t\t\t\t       XEXP (op0, 0),\n-\t\t\t\t\t\t       XEXP (op0, 1));\n-\n-\t\tif (temp == const0_rtx)\n+\t\trtx tem =\n+\t\t  simplify_gen_relational (GET_CODE (op0), GET_MODE (op0),\n+\t\t\t\t\t   map->compare_mode, XEXP (op0, 0),\n+\t\t\t\t\t   XEXP (op0, 1));\n+\n+\t\tif (GET_CODE (tem) != CONST_INT)\n+\t\t  new = simplify_ternary_operation (code, GET_MODE (x),\n+\t\t\t\t  \t\t    op0_mode, tem, XEXP (x, 1),\n+\t\t\t\t\t\t    XEXP (x, 2));\n+\t\telse if (tem == const0_rtx)\n \t\t  new = XEXP (x, 2);\n-\t\telse if (temp == const1_rtx)\n+\t\telse\n \t\t  new = XEXP (x, 1);\n \t      }\n \t  }"}, {"sha": "5895bb9068678ddc14b31acd41b0048bd563a546", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 126, "deletions": 100, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6fb08ad284af074092aa4fb9edd1a9a44014b49/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=c6fb08ad284af074092aa4fb9edd1a9a44014b49", "patch": "@@ -58,6 +58,8 @@ static rtx simplify_immed_subreg (enum machine_mode, rtx, enum machine_mode,\n \t\t\t\t  unsigned int);\n static rtx simplify_associative_operation (enum rtx_code, enum machine_mode,\n \t\t\t\t\t   rtx, rtx);\n+static rtx simplify_relational_operation_1 (enum rtx_code, enum machine_mode,\n+\t\t\t\t\t    enum machine_mode, rtx, rtx);\n \f\n /* Negate a CONST_INT rtx, truncating (because a conversion from a\n    maximally negative number can overflow).  */\n@@ -221,57 +223,19 @@ simplify_gen_ternary (enum rtx_code code, enum machine_mode mode,\n \n   return gen_rtx_fmt_eee (code, mode, op0, op1, op2);\n }\n-\f\n+\n /* Likewise, for relational operations.\n-   CMP_MODE specifies mode comparison is done in.\n-  */\n+   CMP_MODE specifies mode comparison is done in.  */\n \n rtx\n simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n \t\t\t enum machine_mode cmp_mode, rtx op0, rtx op1)\n {\n   rtx tem;\n \n-  if (cmp_mode == VOIDmode)\n-    cmp_mode = GET_MODE (op0);\n-  if (cmp_mode == VOIDmode)\n-    cmp_mode = GET_MODE (op1);\n-\n-  if (cmp_mode != VOIDmode)\n-    {\n-      tem = simplify_relational_operation (code, mode, cmp_mode, op0, op1);\n-      if (tem)\n-\treturn tem;\n-    }\n-\n-  /* For the following tests, ensure const0_rtx is op1.  */\n-  if (swap_commutative_operands_p (op0, op1)\n-      || (op0 == const0_rtx && op1 != const0_rtx))\n-    tem = op0, op0 = op1, op1 = tem, code = swap_condition (code);\n-\n-  /* If op0 is a compare, extract the comparison arguments from it.  */\n-  if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n-    return simplify_gen_relational (code, mode, VOIDmode,\n-\t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n-\n-  /* If op0 is a comparison, extract the comparison arguments form it.  */\n-  if (COMPARISON_P (op0) && op1 == const0_rtx)\n-    {\n-      if (code == NE)\n-\t{\n-\t  if (GET_MODE (op0) == mode)\n-\t    return op0;\n-\t  return simplify_gen_relational (GET_CODE (op0), mode, VOIDmode,\n-\t\t\t\t\t  XEXP (op0, 0), XEXP (op0, 1));\n-\t}\n-      else if (code == EQ)\n-\t{\n-\t  enum rtx_code new = reversed_comparison_code (op0, NULL_RTX);\n-\t  if (new != UNKNOWN)\n-\t    return simplify_gen_relational (new, mode, VOIDmode,\n-\t\t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n-        }\n-    }\n+  if (0 != (tem = simplify_relational_operation (code, mode, cmp_mode,\n+\t\t\t\t\t\t op0, op1)))\n+    return tem;\n \n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n@@ -1201,7 +1165,6 @@ simplify_associative_operation (enum rtx_code code, enum machine_mode mode,\n \n    Don't use this for relational operations such as EQ or LT.\n    Use simplify_relational_operation instead.  */\n-\n rtx\n simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t   rtx op0, rtx op1)\n@@ -2662,10 +2625,102 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n }\n \n /* Like simplify_binary_operation except used for relational operators.\n-   MODE is the mode of the operands, not that of the result.  If MODE\n-   is VOIDmode, both operands must also be VOIDmode and we compare the\n-   operands in \"infinite precision\".\n+   MODE is the mode of the result. If MODE is VOIDmode, both operands must\n+   also be VOIDmode.\n+\n+   CMP_MODE specifies in which mode the comparison is done in, so it is\n+   the mode of the operands.  If CMP_MODE is VOIDmode, it is taken from\n+   the operands or, if both are VOIDmode, the operands are compared in\n+   \"infinite precision\".  */\n+rtx\n+simplify_relational_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t       enum machine_mode cmp_mode, rtx op0, rtx op1)\n+{\n+  rtx tem, trueop0, trueop1;\n+\n+  if (cmp_mode == VOIDmode)\n+    cmp_mode = GET_MODE (op0);\n+  if (cmp_mode == VOIDmode)\n+    cmp_mode = GET_MODE (op1);\n+\n+  tem = simplify_const_relational_operation (code, cmp_mode, op0, op1);\n+  if (tem)\n+    {\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t{\n+          if (tem == const0_rtx)\n+            return CONST0_RTX (mode);\n+          else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t    {\n+\t      REAL_VALUE_TYPE val;\n+\t      val = FLOAT_STORE_FLAG_VALUE (mode);\n+\t      return CONST_DOUBLE_FROM_REAL_VALUE (val, mode);\n+\t    }\n+\t}\n+#endif\n+\n+      return tem;\n+    }\n+\n+  /* For the following tests, ensure const0_rtx is op1.  */\n+  if (swap_commutative_operands_p (op0, op1)\n+      || (op0 == const0_rtx && op1 != const0_rtx))\n+    tem = op0, op0 = op1, op1 = tem, code = swap_condition (code);\n+\n+  /* If op0 is a compare, extract the comparison arguments from it.  */\n+  if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n+    return simplify_relational_operation (code, mode, VOIDmode,\n+\t\t\t\t          XEXP (op0, 0), XEXP (op0, 1));\n+\n+  if (mode == VOIDmode\n+      || GET_MODE_CLASS (cmp_mode) == MODE_CC\n+      || CC0_P (op0))\n+    return NULL_RTX;\n+\n+  trueop0 = avoid_constant_pool_reference (op0);\n+  trueop1 = avoid_constant_pool_reference (op1);\n+  return simplify_relational_operation_1 (code, mode, cmp_mode,\n+\t\t  \t\t\t  trueop0, trueop1);\n+}\n+\n+/* This part of simplify_relational_operation is only used when CMP_MODE\n+   is not in class MODE_CC (i.e. it is a real comparison).\n+\n+   MODE is the mode of the result, while CMP_MODE specifies in which\n+   mode the comparison is done in, so it is the mode of the operands.  */\n+rtx\n+simplify_relational_operation_1 (enum rtx_code code, enum machine_mode mode,\n+\t\t\t\t enum machine_mode cmp_mode, rtx op0, rtx op1)\n+{\n+  if (GET_CODE (op1) == CONST_INT)\n+    {\n+      if (INTVAL (op1) == 0 && COMPARISON_P (op0))\n+\t{\n+\t  /* If op0 is a comparison, extract the comparison arguments form it.  */\n+\t  if (code == NE)\n+\t    {\n+\t      if (GET_MODE (op0) == cmp_mode)\n+\t\treturn simplify_rtx (op0);\n+\t      else\n+\t\treturn simplify_gen_relational (GET_CODE (op0), mode, VOIDmode,\n+\t\t\t\t\t        XEXP (op0, 0), XEXP (op0, 1));\n+\t    }\n+\t  else if (code == EQ)\n+\t    {\n+\t      enum rtx_code new = reversed_comparison_code (op0, NULL_RTX);\n+\t      if (new != UNKNOWN)\n+\t        return simplify_gen_relational (new, mode, VOIDmode,\n+\t\t\t\t\t        XEXP (op0, 0), XEXP (op0, 1));\n+\t    }\n+\t}\n+    }\n \n+  return NULL_RTX;\n+}\n+\n+/* Check if the given comparison (done in the given MODE) is actually a\n+   tautology or a contradiction.\n    If no simplification is possible, this function returns zero.\n    Otherwise, it returns either const_true_rtx or const0_rtx.  */\n \n@@ -2954,36 +3009,6 @@ simplify_const_relational_operation (enum rtx_code code,\n       abort ();\n     }\n }\n-\n-/* Like simplify_binary_operation except used for relational operators.\n-   MODE is the mode of the result, and CMP_MODE is the mode of the operands.\n-   If CMP_MODE is VOIDmode, both operands must also be VOIDmode and we\n-   compare the operands in \"infinite precision\".  */\n-\n-rtx\n-simplify_relational_operation (enum rtx_code code,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t       enum machine_mode cmp_mode, rtx op0, rtx op1)\n-{\n-  rtx tmp;\n-\n-  tmp = simplify_const_relational_operation (code, cmp_mode, op0, op1);\n-  if (tmp)\n-    {\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  if (tmp == const0_rtx)\n-\t    return CONST0_RTX (mode);\n-\t  return CONST_DOUBLE_FROM_REAL_VALUE (FLOAT_STORE_FLAG_VALUE (mode),\n-\t\t\t\t\t       mode);\n-\t}\n-#endif\n-      return tmp;\n-    }\n-\n-  return NULL_RTX;\n-}\n \f\n /* Simplify CODE, an operation with result mode MODE and three operands,\n    OP0, OP1, and OP2.  OP0_MODE was the mode of OP0 before it became\n@@ -3078,20 +3103,6 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t\t\t\t? GET_MODE (XEXP (op0, 1))\n \t\t\t\t\t: GET_MODE (XEXP (op0, 0)));\n \t  rtx temp;\n-\t  if (cmp_mode == VOIDmode)\n-\t    cmp_mode = op0_mode;\n-\t  temp = simplify_const_relational_operation (GET_CODE (op0),\n-\t\t\t\t\t\t      cmp_mode,\n-\t\t\t\t\t\t      XEXP (op0, 0),\n-\t\t\t\t\t\t      XEXP (op0, 1));\n-\n-\t  /* See if any simplifications were possible.  */\n-\t  if (temp == const0_rtx)\n-\t    return op2;\n-\t  else if (temp == const_true_rtx)\n-\t    return op1;\n-\t  else if (temp)\n-\t    abort ();\n \n \t  /* Look for happy constants in op1 and op2.  */\n \t  if (GET_CODE (op1) == CONST_INT && GET_CODE (op2) == CONST_INT)\n@@ -3112,7 +3123,23 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t      else\n \t\tbreak;\n \n-\t      return gen_rtx_fmt_ee (code, mode, XEXP (op0, 0), XEXP (op0, 1));\n+\t      return simplify_gen_relational (code, op0_mode, cmp_mode,\n+\t\t\t\t\t      XEXP (op0, 0), XEXP (op0, 1));\n+\t    }\n+\n+\t  if (cmp_mode == VOIDmode)\n+\t    cmp_mode = op0_mode;\n+\t  temp = simplify_relational_operation (GET_CODE (op0), op0_mode,\n+\t\t\t  \t\t\tcmp_mode, XEXP (op0, 0),\n+\t\t\t\t\t\tXEXP (op0, 1));\n+\n+\t  /* See if any simplifications were possible.  */\n+\t  if (temp)\n+\t    {\n+\t      if (GET_CODE (temp) == CONST_INT)\n+\t\treturn temp == const0_rtx ? op2 : op1;\n+\t      else if (temp)\n+\t        return gen_rtx_IF_THEN_ELSE (mode, temp, op1, op2);\n \t    }\n \t}\n       break;\n@@ -3721,7 +3748,6 @@ simplify_rtx (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n-  rtx temp;\n \n   switch (GET_RTX_CLASS (code))\n     {\n@@ -3745,13 +3771,13 @@ simplify_rtx (rtx x)\n \n     case RTX_COMPARE:\n     case RTX_COMM_COMPARE:\n-      temp = simplify_relational_operation (code, mode,\n-\t\t\t\t\t    ((GET_MODE (XEXP (x, 0))\n-\t\t\t\t\t      != VOIDmode)\n-\t\t\t\t\t     ? GET_MODE (XEXP (x, 0))\n-\t\t\t\t\t     : GET_MODE (XEXP (x, 1))),\n-\t\t\t\t\t    XEXP (x, 0), XEXP (x, 1));\n-      return temp;\n+      return simplify_relational_operation (code, mode,\n+                                            ((GET_MODE (XEXP (x, 0))\n+                                             != VOIDmode)\n+                                            ? GET_MODE (XEXP (x, 0))\n+                                            : GET_MODE (XEXP (x, 1))),\n+                                            XEXP (x, 0),\n+                                            XEXP (x, 1));\n \n     case RTX_EXTRA:\n       if (code == SUBREG)"}]}