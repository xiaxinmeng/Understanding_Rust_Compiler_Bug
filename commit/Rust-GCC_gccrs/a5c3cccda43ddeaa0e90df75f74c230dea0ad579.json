{"sha": "a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjM2NjY2RhNDNkZGVhYTBlOTBkZjc1Zjc0YzIzMGRlYTBhZDU3OQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-10-30T22:29:00Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-10-30T22:29:00Z"}, "message": "cppfiles.c (stack_include_file): Check for stacked contexts here.\n\n\t* cppfiles.c (stack_include_file): Check for stacked contexts\n\there.\n\t* cpphash.h (_cpp_do__Pragma): New prototype.\n\t* cppinit.c (cpp_reader_init): Add _Pragma keyword to hash table.\n\n\t* cpplex.c (skip_escaped_newlines): Only process trigraphs and\n\tescaped newlines if !(buffer->from_stage3).\n\t(_cpp_lex_token): Warn about missing newlines iff\n\t!buffer->from_stage3.\n\n\t* cpplib.c (get__Pragma_string, destringize,\n\t_cpp_do__Pragma): New functions.\n\t(run_directive): Set output_line for _Pragma to avoid line\n\tmarkers in output.  Set from_stage3 and prevent macro expansion\n\tfor _Pragma and command-line options.  Check buffer exhaustion.\n\t(cpp_push_buffer): Don't check for stacked macro contexts, as\n\tthis is perfectly legitimate for _Pragma.  Move the check to\n\tstack_include_file instead. Set from_stage3 iff buffer is\n\tpreprocessed input.\n\n\t* cpplib.h (struct cpp_buffer): Make warned_cplusplus_comments\n\tunsigned. New boolean from_stage3.\n\t(struct spec_nodes): Add n__Pragma.\n\n\t* cppmacro.c (enter_macro_context): Flip sense of return value.\n\t(_cpp_get_token): Handle _Pragma operator.\n\nFrom-SVN: r37147", "tree": {"sha": "aea40a1085df8546a232c08b4db9f87353674441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aea40a1085df8546a232c08b4db9f87353674441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/comments", "author": null, "committer": null, "parents": [{"sha": "dbdaea4110d5c97ba1addef900516eea7846a2c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbdaea4110d5c97ba1addef900516eea7846a2c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbdaea4110d5c97ba1addef900516eea7846a2c0"}], "stats": {"total": 279, "additions": 206, "deletions": 73}, "files": [{"sha": "0cc78dbcfa4e56a804acb26f65b997bc484a9764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -1,3 +1,32 @@\n+2000-10-30  Neil Booth  <neilb@earthling.net>\n+\n+\t* cppfiles.c (stack_include_file): Check for stacked contexts\n+\there.\n+\t* cpphash.h (_cpp_do__Pragma): New prototype.\n+\t* cppinit.c (cpp_reader_init): Add _Pragma keyword to hash table.\n+\n+\t* cpplex.c (skip_escaped_newlines): Only process trigraphs and\n+\tescaped newlines if !(buffer->from_stage3).\n+\t(_cpp_lex_token): Warn about missing newlines iff\n+\t!buffer->from_stage3.\n+\n+\t* cpplib.c (get__Pragma_string, destringize,\n+\t_cpp_do__Pragma): New functions.\n+\t(run_directive): Set output_line for _Pragma to avoid line\n+\tmarkers in output.  Set from_stage3 and prevent macro expansion\n+\tfor _Pragma and command-line options.  Check buffer exhaustion.\n+\t(cpp_push_buffer): Don't check for stacked macro contexts, as\n+\tthis is perfectly legitimate for _Pragma.  Move the check to\n+\tstack_include_file instead. Set from_stage3 iff buffer is\n+\tpreprocessed input.\n+\n+\t* cpplib.h (struct cpp_buffer): Make warned_cplusplus_comments\n+\tunsigned. New boolean from_stage3.\n+\t(struct spec_nodes): Add n__Pragma.\n+\n+\t* cppmacro.c (enter_macro_context): Flip sense of return value.\n+\t(_cpp_get_token): Handle _Pragma operator.\n+\n 2000-10-30  Phil Edwards  <pme@sources.redhat.com>\n \n \t* gcc.texi:  The C++ standard isn't \"draft\" anymore."}, {"sha": "1009fa784a1f7c1f7bef2415caad6a6c8a391b62", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -206,6 +206,9 @@ stack_include_file (pfile, inc)\n {\n   cpp_buffer *fp;\n \n+  if (pfile->context->prev)\n+    cpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n+\n   if (DO_NOT_REREAD (inc))\n     return 0;\n "}, {"sha": "a1c859de66aca3d940013e64fa37fe461f00e4a9", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -203,6 +203,7 @@ extern void _cpp_unlock_pool\t\tPARAMS ((cpp_pool *));\n extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\n extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));\n extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n+extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));"}, {"sha": "512a0ff151fe89d4ec359dd8bcfcc6ad0c10c837", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -487,6 +487,7 @@ cpp_reader_init (pfile)\n   s = &pfile->spec_nodes;\n   s->n_L                = cpp_lookup (pfile, DSC(\"L\"));\n   s->n_defined\t\t= cpp_lookup (pfile, DSC(\"defined\"));\n+  s->n__Pragma\t\t= cpp_lookup (pfile, DSC(\"_Pragma\"));\n   s->n__STRICT_ANSI__   = cpp_lookup (pfile, DSC(\"__STRICT_ANSI__\"));\n   s->n__CHAR_UNSIGNED__ = cpp_lookup (pfile, DSC(\"__CHAR_UNSIGNED__\"));\n   s->n__VA_ARGS__       = cpp_lookup (pfile, DSC(\"__VA_ARGS__\"));"}, {"sha": "43e090bf6fd01b31a438e790ec759e88773b47e9", "filename": "gcc/cpplex.c", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -181,71 +181,77 @@ trigraph_ok (pfile, from_char)\n \n /* Skips any escaped newlines introduced by NEXT, which is either a\n    '?' or a '\\\\'.  Returns the next character, which will also have\n-   been placed in buffer->read_ahead.  */\n+   been placed in buffer->read_ahead.  This routine performs\n+   preprocessing stages 1 and 2 of the ISO C standard.  */\n static cppchar_t\n skip_escaped_newlines (buffer, next)\n      cpp_buffer *buffer;\n      cppchar_t next;\n {\n-  cppchar_t next1;\n-  const unsigned char *saved_cur;\n-  int space;\n-\n-  do\n+  /* Only do this if we apply stages 1 and 2.  */\n+  if (!buffer->from_stage3)\n     {\n-      if (buffer->cur == buffer->rlimit)\n-\tbreak;\n-      \n-      SAVE_STATE ();\n-      if (next == '?')\n+      cppchar_t next1;\n+      const unsigned char *saved_cur;\n+      int space;\n+\n+      do\n \t{\n-\t  next1 = *buffer->cur++;\n-\t  if (next1 != '?' || buffer->cur == buffer->rlimit)\n+\t  if (buffer->cur == buffer->rlimit)\n+\t    break;\n+      \n+\t  SAVE_STATE ();\n+\t  if (next == '?')\n \t    {\n-\t      RESTORE_STATE ();\n-\t      break;\n+\t      next1 = *buffer->cur++;\n+\t      if (next1 != '?' || buffer->cur == buffer->rlimit)\n+\t\t{\n+\t\t  RESTORE_STATE ();\n+\t\t  break;\n+\t\t}\n+\n+\t      next1 = *buffer->cur++;\n+\t      if (!_cpp_trigraph_map[next1]\n+\t\t  || !trigraph_ok (buffer->pfile, next1))\n+\t\t{\n+\t\t  RESTORE_STATE ();\n+\t\t  break;\n+\t\t}\n+\n+\t      /* We have a full trigraph here.  */\n+\t      next = _cpp_trigraph_map[next1];\n+\t      if (next != '\\\\' || buffer->cur == buffer->rlimit)\n+\t\tbreak;\n+\t      SAVE_STATE ();\n+\t    }\n+\n+\t  /* We have a backslash, and room for at least one more character.  */\n+\t  space = 0;\n+\t  do\n+\t    {\n+\t      next1 = *buffer->cur++;\n+\t      if (!is_nvspace (next1))\n+\t\tbreak;\n+\t      space = 1;\n \t    }\n+\t  while (buffer->cur < buffer->rlimit);\n \n-\t  next1 = *buffer->cur++;\n-\t  if (!_cpp_trigraph_map[next1] || !trigraph_ok (buffer->pfile, next1))\n+\t  if (!is_vspace (next1))\n \t    {\n \t      RESTORE_STATE ();\n \t      break;\n \t    }\n \n-\t  /* We have a full trigraph here.  */\n-\t  next = _cpp_trigraph_map[next1];\n-\t  if (next != '\\\\' || buffer->cur == buffer->rlimit)\n-\t    break;\n-\t  SAVE_STATE ();\n-\t}\n+\t  if (space)\n+\t    cpp_warning (buffer->pfile,\n+\t\t\t \"backslash and newline separated by space\");\n \n-      /* We have a backslash, and room for at least one more character.  */\n-      space = 0;\n-      do\n-\t{\n-\t  next1 = *buffer->cur++;\n-\t  if (!is_nvspace (next1))\n-\t    break;\n-\t  space = 1;\n-\t}\n-      while (buffer->cur < buffer->rlimit);\n-\n-      if (!is_vspace (next1))\n-\t{\n-\t  RESTORE_STATE ();\n-\t  break;\n+\t  next = handle_newline (buffer, next1);\n+\t  if (next == EOF)\n+\t    cpp_pedwarn (buffer->pfile, \"backslash-newline at end of file\");\n \t}\n-\n-      if (space)\n-\tcpp_warning (buffer->pfile,\n-\t\t     \"backslash and newline separated by space\");\n-\n-      next = handle_newline (buffer, next1);\n-      if (next == EOF)\n-\tcpp_pedwarn (buffer->pfile, \"backslash-newline at end of file\");\n+      while (next == '\\\\' || next == '?');\n     }\n-  while (next == '\\\\' || next == '?');\n \n   buffer->read_ahead = next;\n   return next;\n@@ -863,8 +869,8 @@ _cpp_lex_token (pfile, result)\n     {\n     case EOF:\n       /* Non-empty files should end in a newline.  Ignore for command\n-\t line - we get e.g. -A options with no trailing \\n.  */\n-      if (pfile->lexer_pos.col != 0 && pfile->done_initializing)\n+\t line and _Pragma buffers.  */\n+      if (pfile->lexer_pos.col != 0 && !buffer->from_stage3)\n \tcpp_pedwarn (pfile, \"no newline at end of file\");\n       pfile->state.skip_newlines = 1;\n       result->type = CPP_EOF;"}, {"sha": "12fa982885639c1cf64206043b4b92a8bad706fa", "filename": "gcc/cpplib.c", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -99,6 +99,9 @@ static void do_pragma_once\tPARAMS ((cpp_reader *));\n static void do_pragma_poison\tPARAMS ((cpp_reader *));\n static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n+static int get__Pragma_string\tPARAMS ((cpp_reader *, cpp_token *));\n+static unsigned char *destringize\tPARAMS ((const cpp_string *,\n+\t\t\t\t\t\t unsigned int *));\n static int parse_answer PARAMS ((cpp_reader *, struct answer **, int));\n static cpp_hashnode *parse_assertion PARAMS ((cpp_reader *, struct answer **,\n \t\t\t\t\t      int));\n@@ -345,23 +348,35 @@ run_directive (pfile, dir_no, buf, count, name)\n      size_t count;\n      const char *name;\n {\n-  if (cpp_push_buffer (pfile, (const U_CHAR *)buf, count) != NULL)\n+  if (cpp_push_buffer (pfile, (const U_CHAR *) buf, count) != NULL)\n     {\n       const struct directive *dir = &dtable[dir_no];\n \n       if (name)\n \tCPP_BUFFER (pfile)->nominal_fname = name;\n       else\n \tCPP_BUFFER (pfile)->nominal_fname = _(\"<command line>\");\n-      CPP_BUFFER (pfile)->lineno = (unsigned int)-1;\n \n+      /* A kludge to avoid line markers for _Pragma.  */\n+      if (dir_no == T_PRAGMA)\n+\tpfile->lexer_pos.output_line = CPP_BUFFER (pfile)->prev->lineno;\n+\n+      /* For _Pragma, the text is passed through preprocessing stage 3\n+\t only, i.e. no trigraphs, no escaped newline removal, and no\n+\t macro expansion.  Do the same for command-line directives.  */\n+      pfile->buffer->from_stage3 = 1;\n       pfile->state.in_directive = 1;\n       pfile->directive = dir;\n+      pfile->state.prevent_expansion++;\n       (void) (*dir->handler) (pfile);\n+      pfile->state.prevent_expansion--;\n       pfile->directive = 0;\n       pfile->state.in_directive = 0;\n \n       skip_rest_of_line (pfile);\n+      if (pfile->buffer->cur != pfile->buffer->rlimit)\n+\tcpp_error (pfile, \"extra text after end of #%s directive\",\n+\t\t   dtable[dir_no].name);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1069,6 +1084,68 @@ do_pragma_dependency (pfile)\n     }\n }\n \n+/* Check syntax is \"(string-literal)\".  Returns 0 on success.  */\n+static int\n+get__Pragma_string (pfile, string)\n+     cpp_reader *pfile;\n+     cpp_token *string;\n+{\n+  cpp_token paren;\n+\n+  cpp_get_token (pfile, &paren);\n+  if (paren.type != CPP_OPEN_PAREN)\n+    return 1;\n+\n+  cpp_get_token (pfile, string);\n+  if (string->type != CPP_STRING && string->type != CPP_WSTRING)\n+    return 1;\n+\n+  cpp_get_token (pfile, &paren);\n+  return paren.type != CPP_CLOSE_PAREN;\n+}\n+\n+/* Returns a malloced buffer containing a destringized cpp_string by\n+   removing the first \\ of \\\" and \\\\ sequences.  */\n+static unsigned char *\n+destringize (in, len)\n+     const cpp_string *in;\n+     unsigned int *len;\n+{\n+  const unsigned char *src, *limit;\n+  unsigned char *dest, *result;\n+\n+  dest = result = (unsigned char *) xmalloc (in->len);\n+  for (src = in->text, limit = src + in->len; src < limit;)\n+    {\n+      /* We know there is a character following the backslash.  */\n+      if (*src == '\\\\' && (src[1] == '\\\\' || src[1] == '\"'))\n+\tsrc++;\n+      *dest++ = *src++;\n+    }\n+\n+  *len = dest - result;\n+  return result;\n+}\n+\n+void\n+_cpp_do__Pragma (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_token string;\n+  unsigned char *buffer;\n+  unsigned int len;\n+\n+  if (get__Pragma_string (pfile, &string))\n+    {\n+      cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n+      return;\n+    }\n+\n+  buffer = destringize (&string.val.str, &len);\n+  run_directive (pfile, T_PRAGMA, (char *) buffer, len, _(\"<_Pragma>\"));\n+  free ((PTR) buffer);\n+}\n+\n /* Just ignore #sccs, on systems where we define it at all.  */\n #ifdef SCCS_DIRECTIVE\n static void\n@@ -1626,12 +1703,6 @@ cpp_push_buffer (pfile, buffer, length)\n       return NULL;\n     }\n \n-  if (pfile->context->prev)\n-    {\n-      cpp_ice (pfile, \"buffer pushed with contexts stacked\");\n-      skip_rest_of_line (pfile);\n-    }\n-\n   new = xobnew (pfile->buffer_ob, cpp_buffer);\n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n@@ -1641,6 +1712,8 @@ cpp_push_buffer (pfile, buffer, length)\n   new->rlimit = buffer + length;\n   new->prev = buf;\n   new->pfile = pfile;\n+  /* Preprocessed files don't do trigraph and escaped newline processing.  */\n+  new->from_stage3 = CPP_OPTION (pfile, preprocessed);\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;"}, {"sha": "de7a1a54caa770c7eb4e70b8661dc30a36e040d0", "filename": "gcc/cpplib.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -287,7 +287,12 @@ struct cpp_buffer\n      The warning happens only for C89 extended mode with -pedantic on,\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n-  char warned_cplusplus_comments;\n+  unsigned char warned_cplusplus_comments;\n+\n+  /* True if we don't process trigraphs and escaped newlines.  True\n+     for preprocessed input, command line directives, and _Pragma\n+     buffers.  */\n+  unsigned char from_stage3;\n };\n \n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n@@ -509,6 +514,7 @@ struct spec_nodes\n {\n   cpp_hashnode *n_L;\t\t\t/* L\"str\" */\n   cpp_hashnode *n_defined;\t\t/* defined operator */\n+  cpp_hashnode *n__Pragma;\t\t/* _Pragma operator */\n   cpp_hashnode *n__STRICT_ANSI__;\t/* STDC_0_IN_SYSTEM_HEADERS */\n   cpp_hashnode *n__CHAR_UNSIGNED__;\t/* plain char is unsigned */\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */"}, {"sha": "484ce037a55bf7e3241cfbd851d4603d1ad398fb", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c3cccda43ddeaa0e90df75f74c230dea0ad579/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=a5c3cccda43ddeaa0e90df75f74c230dea0ad579", "patch": "@@ -689,7 +689,8 @@ funlike_invocation_p (pfile, node, list)\n \n /* Push the context of a macro onto the context stack.  TOKEN is the\n    macro name.  If we can successfully start expanding the macro,\n-   TOKEN is replaced with the first token of the expansion.  */\n+   TOKEN is replaced with the first token of the expansion, and we\n+   return non-zero.  */\n static int\n enter_macro_context (pfile, token)\n      cpp_reader *pfile;\n@@ -704,7 +705,7 @@ enter_macro_context (pfile, token)\n   if (macro->disabled)\n     {\n       token->flags |= NO_EXPAND;\n-      return 1;\n+      return 0;\n     }\n \n   /* Save the position of the outermost macro invocation.  */\n@@ -718,7 +719,7 @@ enter_macro_context (pfile, token)\n     {\n       if (!pfile->context->prev)\n \tunlock_pools (pfile);\n-      return 1;\n+      return 0;\n     }\n \n   /* Now push its context.  */\n@@ -740,7 +741,7 @@ enter_macro_context (pfile, token)\n   /* Disable the macro within its expansion.  */\n   macro->disabled = 1;\n \n-  return 0;\n+  return 1;\n }\n \n /* Move to the next context.  Create one if there is none.  */\n@@ -922,6 +923,7 @@ _cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n {\n+ next_token:\n   for (;;)\n     {\n       cpp_context *context = pfile->context;\n@@ -959,22 +961,34 @@ _cpp_get_token (pfile, token)\n       if (token->flags & PASTE_LEFT)\n \tpaste_all_tokens (pfile, token);\n \n-      if (token->type != CPP_NAME\n-\t  || token->val.node->type != NT_MACRO\n-\t  || pfile->state.prevent_expansion\n-\t  || token->flags & NO_EXPAND)\n+      if (token->type != CPP_NAME)\n \tbreak;\n \n-      /* Macros, built-in or not, invalidate controlling macros.  */\n-      pfile->mi_state = MI_FAILED;\n-\n-      if (token->val.node->flags & NODE_BUILTIN)\n+      /* Handle macros and the _Pragma operator.  */\n+      if (token->val.node->type == NT_MACRO\n+\t  && !pfile->state.prevent_expansion\n+\t  && !(token->flags & NO_EXPAND))\n \t{\n-\t  builtin_macro (pfile, token);\n-\t  break;\n+\t  /* Macros invalidate controlling macros.  */\n+\t  pfile->mi_state = MI_FAILED;\n+\n+\t  if (token->val.node->flags & NODE_BUILTIN)\n+\t    {\n+\t      builtin_macro (pfile, token);\n+\t      break;\n+\t    }\n+\n+\t  if (enter_macro_context (pfile, token))\n+\t    continue;\n \t}\n-      else if (enter_macro_context (pfile, token))\n+\n+      if (token->val.node != pfile->spec_nodes.n__Pragma)\n \tbreak;\n+\n+      /* Invalidate controlling macros.  */\n+      pfile->mi_state = MI_FAILED;\n+      _cpp_do__Pragma (pfile);\n+      goto next_token;\n     }\n }\n "}]}