{"sha": "2523d721cfc861a3abea6e97736446c99ba8b52d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUyM2Q3MjFjZmM4NjFhM2FiZWE2ZTk3NzM2NDQ2Yzk5YmE4YjUyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-04-04T09:45:13Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-04-04T09:45:13Z"}, "message": "ipa: Fix wrong code with failed propagation to builtin_constant_p [PR93940]\n\nthis patch fixes wrong code on a testcase where inline predicts\nbuiltin_constant_p to be true but we fail to optimize its parameter to constant\nbecuase FRE is not run and the value is passed by an aggregate.\n\nThis patch makes the inline predicates to disable aggregate tracking\nwhen FRE is not going to be run and similarly value range when VRP is not\ngoing to be run.\n\nThis is just partial fix.  Even with it we can arrange FRE/VRP to fail and\nproduce wrong code, unforutnately.\n\nI think for GCC11 I will need to implement transformation in ipa-inline\nbut this is bit hard to do: predicates only tracks that value will be constant\nand do not track what constant to be.\n\nOptimizing builtin_constant_p in a conditional is not going to do good job\nwhen the value is used later in a place that expects it to be constant.\nThis is pre-existing problem that is not limited to inline tracking. For example,\nFRE may do the transofrm at one place but not in another due to alias oracle\nwalking limits.\n\nSo I am not sure what full fix would be :(\n\ngcc/ChangeLog:\n\n2020-04-04  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/93940\n\t* ipa-fnsummary.c (vrp_will_run_p): New function.\n\t(fre_will_run_p): New function.\n\t(evaluate_properties_for_edge): Use it.\n\t* ipa-inline.c (can_inline_edge_by_limits_p): Do not inline\n\t!optimize_debug to optimize_debug.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-04  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* g++.dg/tree-ssa/pr93940.C: New test.", "tree": {"sha": "8b52b83c53e7df5b14c69c2ca29034409d3f0304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b52b83c53e7df5b14c69c2ca29034409d3f0304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2523d721cfc861a3abea6e97736446c99ba8b52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2523d721cfc861a3abea6e97736446c99ba8b52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2523d721cfc861a3abea6e97736446c99ba8b52d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2523d721cfc861a3abea6e97736446c99ba8b52d/comments", "author": null, "committer": null, "parents": [{"sha": "bab8d9625f4cdeaf9bb45e28ab62abe47c3827f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab8d9625f4cdeaf9bb45e28ab62abe47c3827f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab8d9625f4cdeaf9bb45e28ab62abe47c3827f9"}], "stats": {"total": 83, "additions": 76, "deletions": 7}, "files": [{"sha": "d96c8e9b03c2d85b1d1b560a0e5bbfd9d66a3583", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=2523d721cfc861a3abea6e97736446c99ba8b52d", "patch": "@@ -503,6 +503,32 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n     *ret_nonspec_clause = nonspec_clause;\n }\n \n+/* Return true if VRP will be exectued on the function.\n+   We do not want to anticipate optimizations that will not happen.\n+\n+   FIXME: This can be confused with -fdisable and debug counters and thus\n+   it should not be used for correctness (only to make heuristics work).\n+   This means that inliner should do its own optimizations of expressions\n+   that it predicts to be constant so wrong code can not be triggered by\n+   builtin_constant_p.  */\n+\n+static bool\n+vrp_will_run_p (struct cgraph_node *node)\n+{\n+  return (opt_for_fn (node->decl, optimize)\n+\t  && !opt_for_fn (node->decl, optimize_debug)\n+\t  && opt_for_fn (node->decl, flag_tree_vrp));\n+}\n+\n+/* Similarly about FRE.  */\n+\n+static bool\n+fre_will_run_p (struct cgraph_node *node)\n+{\n+  return (opt_for_fn (node->decl, optimize)\n+\t  && !opt_for_fn (node->decl, optimize_debug)\n+\t  && opt_for_fn (node->decl, flag_tree_fre));\n+}\n \n /* Work out what conditions might be true at invocation of E.\n    Compute costs for inlined edge if INLINE_P is true.\n@@ -594,6 +620,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \n \t\t/* If we failed to get simple constant, try value range.  */\n \t\tif ((!cst || TREE_CODE (cst) != INTEGER_CST)\n+\t\t    && vrp_will_run_p (caller)\n \t\t    && ipa_is_param_used_by_ipa_predicates (callee_pi, i))\n \t\t  {\n \t\t    value_range vr \n@@ -609,14 +636,17 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t  }\n \n \t\t/* Determine known aggregate values.  */\n-\t\tipa_agg_value_set agg\n-\t\t    = ipa_agg_value_set_from_jfunc (caller_parms_info,\n-\t\t\t\t\t\t    caller, &jf->agg);\n-\t\tif (agg.items.length ())\n+\t\tif (vrp_will_run_p (caller))\n \t\t  {\n-\t\t    if (!known_aggs_ptr->length ())\n-\t\t      vec_safe_grow_cleared (known_aggs_ptr, count);\n-\t\t    (*known_aggs_ptr)[i] = agg;\n+\t\t    ipa_agg_value_set agg\n+\t\t\t= ipa_agg_value_set_from_jfunc (caller_parms_info,\n+\t\t\t\t\t\t\tcaller, &jf->agg);\n+\t\t    if (agg.items.length ())\n+\t\t      {\n+\t\t\tif (!known_aggs_ptr->length ())\n+\t\t\t  vec_safe_grow_cleared (known_aggs_ptr, count);\n+\t\t\t(*known_aggs_ptr)[i] = agg;\n+\t\t      }\n \t\t  }\n \t      }\n "}, {"sha": "f71443feff7ede97477d19bb79d7b6c98a4734c4", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2523d721cfc861a3abea6e97736446c99ba8b52d", "patch": "@@ -485,6 +485,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n      else if (check_match (flag_wrapv)\n \t      || check_match (flag_trapv)\n \t      || check_match (flag_pcc_struct_return)\n+\t      || check_maybe_down (optimize_debug)\n \t      /* When caller or callee does FP math, be sure FP codegen flags\n \t\t compatible.  */\n \t      || ((caller_info->fp_expressions && callee_info->fp_expressions)"}, {"sha": "b656aad3ef81b2d0a56b4a339cc4aaa2aa2e73d8", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr93940.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93940.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2523d721cfc861a3abea6e97736446c99ba8b52d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93940.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93940.C?ref=2523d721cfc861a3abea6e97736446c99ba8b52d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Og --coverage -pthread -fdump-tree-optimized -std=c++17\" } */\n+using uint16_t = unsigned short;\n+\n+struct a {\n+    uint16_t b = 0;\n+};\n+struct c {\n+    short d;\n+};\n+class e {\n+public:\n+    void f();\n+    void init_session(c);\n+};\n+\n+auto htons = [](uint16_t s) {\n+    if (__builtin_constant_p(s)) {\n+        return uint16_t(uint16_t(s >> 8) | uint16_t(s << 8));\n+    }\n+    return uint16_t(uint16_t(s >> 8) | uint16_t(s << 8));\n+};\n+\n+struct g {\n+    e h;\n+    void i(a k) {\n+        h.f();\n+        auto j = c();\n+        j.d = htons(k.b);\n+        h.init_session(j);\n+    }\n+};\n+\n+void test() {\n+    g().i({});\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"builtin_unreachable\" \"optimized\"} } */"}]}