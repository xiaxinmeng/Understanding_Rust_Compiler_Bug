{"sha": "01a92e704282e69fc3ec7d817637b8074454168d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFhOTJlNzA0MjgyZTY5ZmMzZWM3ZDgxNzYzN2I4MDc0NDU0MTY4ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-11T17:36:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-11T17:36:35Z"}, "message": "ipa-prop.c (ipa_binfo_from_known_type_jfunc): In LTO do not walk non-polymorphic types.\n\n\n\t* ipa-prop.c (ipa_binfo_from_known_type_jfunc): In LTO do not walk\n\tnon-polymorphic types.\n\t* ipa-cp.c (ipa_get_jf_ancestor_result): Likewise.\n\t* ipa-devirt.c (types_same_for_odr): Do not explode when one\n\tof types is not polymorphic.\n\nFrom-SVN: r212466", "tree": {"sha": "cc8b8a6e54f1d43a8820123980f3ef960194ad28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc8b8a6e54f1d43a8820123980f3ef960194ad28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01a92e704282e69fc3ec7d817637b8074454168d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a92e704282e69fc3ec7d817637b8074454168d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01a92e704282e69fc3ec7d817637b8074454168d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a92e704282e69fc3ec7d817637b8074454168d/comments", "author": null, "committer": null, "parents": [{"sha": "12b308fa865bb6ac7f30671e332ec17926556da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12b308fa865bb6ac7f30671e332ec17926556da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12b308fa865bb6ac7f30671e332ec17926556da4"}], "stats": {"total": 48, "additions": 48, "deletions": 0}, "files": [{"sha": "8bc3edffb98c9d36f02f92ad41c59f08412d4832", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01a92e704282e69fc3ec7d817637b8074454168d", "patch": "@@ -1,3 +1,11 @@\n+2014-07-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-prop.c (ipa_binfo_from_known_type_jfunc): In LTO do not walk\n+\tnon-polymorphic types.\n+\t* ipa-cp.c (ipa_get_jf_ancestor_result): Likewise.\n+\t* ipa-devirt.c (types_same_for_odr): Do not explode when one\n+\tof types is not polymorphic.\n+\n 2014-07-11  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-constraints.c (remove_inheritance_pseudos): Process"}, {"sha": "224b03aa3b595ecfc973e0e66c0cbf0a3139e5d4", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=01a92e704282e69fc3ec7d817637b8074454168d", "patch": "@@ -789,6 +789,19 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n     {\n       if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n \treturn NULL;\n+      /* FIXME: At LTO we can't propagate to non-polymorphic type, because\n+\t we have no ODR equivalency on those.  This should be fixed by\n+\t propagating on types rather than binfos that would make type\n+\t matching here unnecesary.  */\n+      if (in_lto_p\n+\t  && (TREE_CODE (ipa_get_jf_ancestor_type (jfunc)) != RECORD_TYPE\n+\t      || !TYPE_BINFO (ipa_get_jf_ancestor_type (jfunc))\n+\t      || !BINFO_VTABLE (TYPE_BINFO (ipa_get_jf_ancestor_type (jfunc)))))\n+\t{\n+\t  if (!ipa_get_jf_ancestor_offset (jfunc))\n+\t    return input;\n+\t  return NULL;\n+\t}\n       return get_binfo_at_offset (input,\n \t\t\t\t  ipa_get_jf_ancestor_offset (jfunc),\n \t\t\t\t  ipa_get_jf_ancestor_type (jfunc));"}, {"sha": "82b064bbe6d00dbf53db7ed9bcf66af8cc3eb83e", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=01a92e704282e69fc3ec7d817637b8074454168d", "patch": "@@ -341,6 +341,20 @@ types_same_for_odr (const_tree type1, const_tree type2)\n       || type_in_anonymous_namespace_p (type2))\n     return false;\n \n+  /* See if types are obvoiusly different (i.e. different codes\n+     or polymorphis wrt non-polymorphic).  This is not strictly correct\n+     for ODR violating programs, but we can't do better without streaming\n+     ODR names.  */\n+  if (TREE_CODE (type1) != TREE_CODE (type2))\n+    return false;\n+  if (TREE_CODE (type1) == RECORD_TYPE\n+      && (TYPE_BINFO (type1) == NULL_TREE) != (TYPE_BINFO (type1) == NULL_TREE))\n+    return false;\n+  if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)\n+      && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)\n+\t != (BINFO_VTABLE (TYPE_BINFO (type2)) == NULL_TREE))\n+    return false;\n+\n   /* At the moment we have no way to establish ODR equivlaence at LTO\n      other than comparing virtual table pointrs of polymorphic types.\n      Eventually we should start saving mangled names in TYPE_NAME."}, {"sha": "9ed9e5b82ad00d7f21c7be94d323474387519652", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a92e704282e69fc3ec7d817637b8074454168d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=01a92e704282e69fc3ec7d817637b8074454168d", "patch": "@@ -560,6 +560,19 @@ ipa_binfo_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n \n   if (!base_binfo)\n     return NULL_TREE;\n+  /* FIXME: At LTO we can't propagate to non-polymorphic type, because\n+     we have no ODR equivalency on those.  This should be fixed by\n+     propagating on types rather than binfos that would make type\n+     matching here unnecesary.  */\n+  if (in_lto_p\n+      && (TREE_CODE (jfunc->value.known_type.component_type) != RECORD_TYPE\n+\t  || !TYPE_BINFO (jfunc->value.known_type.component_type)\n+\t  || !BINFO_VTABLE (TYPE_BINFO (jfunc->value.known_type.component_type))))\n+    {\n+      if (!jfunc->value.known_type.offset)\n+\treturn base_binfo;\n+      return NULL;\n+    }\n   return get_binfo_at_offset (base_binfo,\n \t\t\t      jfunc->value.known_type.offset,\n \t\t\t      jfunc->value.known_type.component_type);"}]}