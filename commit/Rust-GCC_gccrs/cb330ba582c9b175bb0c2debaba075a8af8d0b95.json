{"sha": "cb330ba582c9b175bb0c2debaba075a8af8d0b95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IzMzBiYTU4MmM5YjE3NWJiMGMyZGViYWJhMDc1YThhZjhkMGI5NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-01-09T20:10:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-01-09T20:10:23Z"}, "message": "re PR tree-optimization/78899 (Vestorized loop with optmized mask stores motion is completely deleted after r242520.)\n\n\tPR tree-optimization/78899\n\t* tree-if-conv.c (version_loop_for_if_conversion): Instead of\n\treturning bool return struct loop *, NULL for failure and the new\n\tloop on success.\n\t(versionable_outer_loop_p): Don't version outer loop if it has\n\tdont_vectorized bit set.\n\t(tree_if_conversion): When versioning outer loop, ensure\n\ttree_if_conversion is performed also on the inner loop of the\n\tnon-vectorizable outer loop copy.\n\t* tree-vectorizer.c (set_uid_loop_bbs): Formatting fix.  Fold\n\tLOOP_VECTORIZED in inner loop of the scalar outer loop and\n\tprevent vectorization of it.\n\t(vectorize_loops): For outer + inner LOOP_VECTORIZED, ensure\n\tthe outer loop vectorization of the non-scalar version is attempted\n\tbefore vectorization of the inner loop in scalar version.  If\n\touter LOOP_VECTORIZED guarded loop is not vectorized, prevent\n\tvectorization of its inner loop.\n\t* tree-vect-loop-manip.c (rename_variables_in_bb): If outer_loop\n\thas 2 inner loops, rename also on edges from bb whose single pred\n\tis outer_loop->header.  Fix typo in function comment.\n\n\t* gcc.target/i386/pr78899.c: New test.\n\t* gcc.dg/pr71077.c: New test.\n\nFrom-SVN: r244238", "tree": {"sha": "6dd4df32ad5eb0ca2c76ee47cb1d2ae5a80687ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dd4df32ad5eb0ca2c76ee47cb1d2ae5a80687ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb330ba582c9b175bb0c2debaba075a8af8d0b95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb330ba582c9b175bb0c2debaba075a8af8d0b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb330ba582c9b175bb0c2debaba075a8af8d0b95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb330ba582c9b175bb0c2debaba075a8af8d0b95/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47d5beb478d39937b8068410101241ae806adc25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d5beb478d39937b8068410101241ae806adc25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d5beb478d39937b8068410101241ae806adc25"}], "stats": {"total": 219, "additions": 201, "deletions": 18}, "files": [{"sha": "443a4731b5c327f0f48e5bb584f3b2c12c9f5b03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -1,3 +1,26 @@\n+2017-01-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78899\n+\t* tree-if-conv.c (version_loop_for_if_conversion): Instead of\n+\treturning bool return struct loop *, NULL for failure and the new\n+\tloop on success.\n+\t(versionable_outer_loop_p): Don't version outer loop if it has\n+\tdont_vectorized bit set.\n+\t(tree_if_conversion): When versioning outer loop, ensure\n+\ttree_if_conversion is performed also on the inner loop of the\n+\tnon-vectorizable outer loop copy.\n+\t* tree-vectorizer.c (set_uid_loop_bbs): Formatting fix.  Fold\n+\tLOOP_VECTORIZED in inner loop of the scalar outer loop and\n+\tprevent vectorization of it.\n+\t(vectorize_loops): For outer + inner LOOP_VECTORIZED, ensure\n+\tthe outer loop vectorization of the non-scalar version is attempted\n+\tbefore vectorization of the inner loop in scalar version.  If\n+\touter LOOP_VECTORIZED guarded loop is not vectorized, prevent\n+\tvectorization of its inner loop.\n+\t* tree-vect-loop-manip.c (rename_variables_in_bb): If outer_loop\n+\thas 2 inner loops, rename also on edges from bb whose single pred\n+\tis outer_loop->header.  Fix typo in function comment.\n+\n 2017-01-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR bootstrap/79033"}, {"sha": "6167ad9a2a0c4c8502af7daf4bdaed49c60dd02b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -1,3 +1,9 @@\n+2017-01-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78899\n+\t* gcc.target/i386/pr78899.c: New test.\n+\t* gcc.dg/pr71077.c: New test.\n+\n 2017-01-09  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/78365"}, {"sha": "db83bc35d6bf081bd82e1560caecd24193e676ef", "filename": "gcc/testsuite/gcc.dg/pr71077.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71077.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71077.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71077.c?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -0,0 +1,14 @@\n+/* PR c++/71077  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-additional-options \"-mavx2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+void\n+foo (int *a, int n)\n+{\n+  int b, c;\n+  for (b = 0; b < n; b++)\n+    for (c = 0; c < 32; c++)\n+      if ((b & 1U) << c)\n+\ta[b + c] = 0;\n+}"}, {"sha": "f22f31d54c505da363115a241ae7203eb92b1e75", "filename": "gcc/testsuite/gcc.target/i386/pr78899.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78899.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78899.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78899.c?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -0,0 +1,27 @@\n+/* PR tree-optimization/78899 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fopenmp-simd -mavx2 -mno-avx512f\" } */\n+\n+#define N 1024\n+#define M 4\n+int p1[N], p2[N], p3[N], c[N];\n+\n+void\n+foo (int n)\n+{\n+  int i, k;\n+  for (k = 0; k < n / M; k++)\n+    {\n+    #pragma omp simd\n+      for (i = 0; i < M; i++)\n+\tif (c[k * M + i])\n+\t  {\n+\t    p1[k * M + i] += 1;\n+\t    p2[k * M + i] = p3[k * M + i] + 2;\n+\t  }\n+    }\n+}\n+\n+/* Ensure the loop is vectorized.  */\n+/* { dg-final { scan-assembler \"vpmaskmov\" } } */\n+/* { dg-final { scan-assembler \"vpadd\" } } */"}, {"sha": "c12987e55de3c53fbacc1eb4dbacfdf7a1607784", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -2535,7 +2535,7 @@ combine_blocks (struct loop *loop)\n    loop to execute.  The vectorizer pass will fold this\n    internal call into either true or false.  */\n \n-static bool\n+static struct loop *\n version_loop_for_if_conversion (struct loop *loop)\n {\n   basic_block cond_bb;\n@@ -2566,15 +2566,15 @@ version_loop_for_if_conversion (struct loop *loop)\n     ifc_bbs[i]->aux = saved_preds[i];\n \n   if (new_loop == NULL)\n-    return false;\n+    return NULL;\n \n   new_loop->dont_vectorize = true;\n   new_loop->force_vectorize = false;\n   gsi = gsi_last_bb (cond_bb);\n   gimple_call_set_arg (g, 1, build_int_cst (integer_type_node, new_loop->num));\n   gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n   update_ssa (TODO_update_ssa);\n-  return true;\n+  return new_loop;\n }\n \n /* Return true when LOOP satisfies the follow conditions that will\n@@ -2594,6 +2594,7 @@ static bool\n versionable_outer_loop_p (struct loop *loop)\n {\n   if (!loop_outer (loop)\n+      || loop->dont_vectorize\n       || !loop->inner\n       || loop->inner->next\n       || !single_exit (loop)\n@@ -2602,7 +2603,7 @@ versionable_outer_loop_p (struct loop *loop)\n       || !single_pred_p (loop->latch)\n       || !single_pred_p (loop->inner->latch))\n     return false;\n-  \n+\n   basic_block outer_exit = single_pred (loop->latch);\n   basic_block inner_exit = single_pred (loop->inner->latch);\n \n@@ -2789,7 +2790,10 @@ tree_if_conversion (struct loop *loop)\n {\n   unsigned int todo = 0;\n   bool aggressive_if_conv;\n+  struct loop *rloop;\n \n+ again:\n+  rloop = NULL;\n   ifc_bbs = NULL;\n   any_pred_load_store = false;\n   any_complicated_phi = false;\n@@ -2829,8 +2833,31 @@ tree_if_conversion (struct loop *loop)\n       struct loop *vloop\n \t= (versionable_outer_loop_p (loop_outer (loop))\n \t   ? loop_outer (loop) : loop);\n-      if (!version_loop_for_if_conversion (vloop))\n+      struct loop *nloop = version_loop_for_if_conversion (vloop);\n+      if (nloop == NULL)\n \tgoto cleanup;\n+      if (vloop != loop)\n+\t{\n+\t  /* If versionable_outer_loop_p decided to version the\n+\t     outer loop, version also the inner loop of the non-vectorized\n+\t     loop copy.  So we transform:\n+\t      loop1\n+\t\tloop2\n+\t     into:\n+\t      if (LOOP_VECTORIZED (1, 3))\n+\t\t{\n+\t\t  loop1\n+\t\t    loop2\n+\t\t}\n+\t      else\n+\t\tloop3 (copy of loop1)\n+\t\t  if (LOOP_VECTORIZED (4, 5))\n+\t\t    loop4 (copy of loop2)\n+\t\t  else\n+\t\t    loop5 (copy of loop4)  */\n+\t  gcc_assert (nloop->inner && nloop->inner->next == NULL);\n+\t  rloop = nloop->inner;\n+\t}\n     }\n \n   /* Now all statements are if-convertible.  Combine all the basic\n@@ -2854,6 +2881,11 @@ tree_if_conversion (struct loop *loop)\n       free (ifc_bbs);\n       ifc_bbs = NULL;\n     }\n+  if (rloop != NULL)\n+    {\n+      loop = rloop;\n+      goto again;\n+    }\n \n   return todo;\n }"}, {"sha": "935cd75e554ccf64e4f9b613163eeff29f8ba29b", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -71,7 +71,7 @@ rename_use_op (use_operand_p op_p)\n }\n \n \n-/* Renames the variables in basic block BB.  Allow renaming  of PHI argumnets\n+/* Renames the variables in basic block BB.  Allow renaming  of PHI arguments\n    on edges incoming from outer-block header if RENAME_FROM_OUTER_LOOP is\n    true.  */\n \n@@ -102,9 +102,25 @@ rename_variables_in_bb (basic_block bb, bool rename_from_outer_loop)\n \n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      if (!flow_bb_inside_loop_p (loop, e->src)\n-\t  && (!rename_from_outer_loop || e->src != outer_loop->header))\n-\tcontinue;\n+      if (!flow_bb_inside_loop_p (loop, e->src))\n+\t{\n+\t  if (!rename_from_outer_loop)\n+\t    continue;\n+\t  if (e->src != outer_loop->header)\n+\t    {\n+\t      if (outer_loop->inner->next)\n+\t\t{\n+\t\t  /* If outer_loop has 2 inner loops, allow there to\n+\t\t     be an extra basic block which decides which of the\n+\t\t     two loops to use using LOOP_VECTORIZED.  */\n+\t\t  if (!single_pred_p (e->src)\n+\t\t      || single_pred (e->src) != outer_loop->header)\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\t    }\n+\t}\n       for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n         rename_use_op (PHI_ARG_DEF_PTR_FROM_EDGE (gsi.phi (), e));"}, {"sha": "a4cead78793f3a54c669f179aeafc7c6e027ca22", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb330ba582c9b175bb0c2debaba075a8af8d0b95/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=cb330ba582c9b175bb0c2debaba075a8af8d0b95", "patch": "@@ -465,6 +465,7 @@ fold_loop_vectorized_call (gimple *g, tree value)\n       update_stmt (use_stmt);\n     }\n }\n+\n /* Set the uids of all the statements in basic blocks inside loop\n    represented by LOOP_VINFO. LOOP_VECTORIZED_CALL is the internal\n    call guarding the loop which has been if converted.  */\n@@ -477,9 +478,22 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   struct loop *scalar_loop = get_loop (cfun, tree_to_shwi (arg));\n \n   LOOP_VINFO_SCALAR_LOOP (loop_vinfo) = scalar_loop;\n-  gcc_checking_assert (vect_loop_vectorized_call\n-\t\t       (LOOP_VINFO_SCALAR_LOOP (loop_vinfo))\n+  gcc_checking_assert (vect_loop_vectorized_call (scalar_loop)\n \t\t       == loop_vectorized_call);\n+  /* If we are going to vectorize outer loop, prevent vectorization\n+     of the inner loop in the scalar loop - either the scalar loop is\n+     thrown away, so it is a wasted work, or is used only for\n+     a few iterations.  */\n+  if (scalar_loop->inner)\n+    {\n+      gimple *g = vect_loop_vectorized_call (scalar_loop->inner);\n+      if (g)\n+\t{\n+\t  arg = gimple_call_arg (g, 0);\n+\t  get_loop (cfun, tree_to_shwi (arg))->dont_vectorize = true;\n+\t  fold_loop_vectorized_call (g, boolean_false_node);\n+\t}\n+    }\n   bbs = get_loop_body (scalar_loop);\n   for (i = 0; i < scalar_loop->num_nodes; i++)\n     {\n@@ -534,14 +548,59 @@ vectorize_loops (void)\n      only over initial loops skipping newly generated ones.  */\n   FOR_EACH_LOOP (loop, 0)\n     if (loop->dont_vectorize)\n-      any_ifcvt_loops = true;\n-    else if ((flag_tree_loop_vectorize\n-\t      && optimize_loop_nest_for_speed_p (loop))\n-\t     || loop->force_vectorize)\n       {\n-\tloop_vec_info loop_vinfo, orig_loop_vinfo = NULL;\n-\tgimple *loop_vectorized_call = vect_loop_vectorized_call (loop);\n-vectorize_epilogue:\n+\tany_ifcvt_loops = true;\n+\t/* If-conversion sometimes versions both the outer loop\n+\t   (for the case when outer loop vectorization might be\n+\t   desirable) as well as the inner loop in the scalar version\n+\t   of the loop.  So we have:\n+\t    if (LOOP_VECTORIZED (1, 3))\n+\t      {\n+\t\tloop1\n+\t\t  loop2\n+\t      }\n+\t    else\n+\t      loop3 (copy of loop1)\n+\t\tif (LOOP_VECTORIZED (4, 5))\n+\t\t  loop4 (copy of loop2)\n+\t\telse\n+\t\t  loop5 (copy of loop4)\n+\t   If FOR_EACH_LOOP gives us loop3 first (which has\n+\t   dont_vectorize set), make sure to process loop1 before loop4;\n+\t   so that we can prevent vectorization of loop4 if loop1\n+\t   is successfully vectorized.  */\n+\tif (loop->inner)\n+\t  {\n+\t    gimple *loop_vectorized_call\n+\t      = vect_loop_vectorized_call (loop);\n+\t    if (loop_vectorized_call\n+\t\t&& vect_loop_vectorized_call (loop->inner))\n+\t      {\n+\t\ttree arg = gimple_call_arg (loop_vectorized_call, 0);\n+\t\tstruct loop *vector_loop\n+\t\t  = get_loop (cfun, tree_to_shwi (arg));\n+\t\tif (vector_loop && vector_loop != loop)\n+\t\t  {\n+\t\t    loop = vector_loop;\n+\t\t    /* Make sure we don't vectorize it twice.  */\n+\t\t    loop->dont_vectorize = true;\n+\t\t    goto try_vectorize;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\tloop_vec_info loop_vinfo, orig_loop_vinfo;\n+\tgimple *loop_vectorized_call;\n+       try_vectorize:\n+\tif (!((flag_tree_loop_vectorize\n+\t       && optimize_loop_nest_for_speed_p (loop))\n+\t      || loop->force_vectorize))\n+\t  continue;\n+\torig_loop_vinfo = NULL;\n+\tloop_vectorized_call = vect_loop_vectorized_call (loop);\n+       vectorize_epilogue:\n \tvect_location = find_loop_location (loop);\n         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n \t    && dump_enabled_p ())\n@@ -595,6 +654,12 @@ vectorize_loops (void)\n \t\t    ret |= TODO_cleanup_cfg;\n \t\t  }\n \t      }\n+\t    /* If outer loop vectorization fails for LOOP_VECTORIZED guarded\n+\t       loop, don't vectorize its inner loop; we'll attempt to\n+\t       vectorize LOOP_VECTORIZED guarded inner loop of the scalar\n+\t       loop version.  */\n+\t    if (loop_vectorized_call && loop->inner)\n+\t      loop->inner->dont_vectorize = true;\n \t    continue;\n \t  }\n "}]}