{"sha": "bfab355012ca0f5219da8beb04f2fdaf757d34b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhYjM1NTAxMmNhMGY1MjE5ZGE4YmViMDRmMmZkYWY3NTdkMzRiNw==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-19T16:25:48Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-01-15T10:37:44Z"}, "message": "arm: Auto-vectorization for MVE: vshr\n\nThis patch enables MVE vshr instructions for auto-vectorization.  New\nMVE patterns are introduced that take a vector of constants as second\noperand, all constants being equal.\n\nThe existing mve_vshrq_n_<supf><mode> is kept, as it takes a single\nimmediate as second operand, and is used by arm_mve.h.\n\nThe vashr<mode>3 and vlshr<mode>3 expanders are moved fron neon.md to\nvec-common.md, updated to rely on the normal expansion scheme to\ngenerate shifts by immediate.\n\n2020-12-03  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/mve.md (mve_vshrq_n_s<mode>_imm): New entry.\n\t(mve_vshrq_n_u<mode>_imm): Likewise.\n\t* config/arm/neon.md (vashr<mode>3, vlshr<mode>3): Move to ...\n\t* config/arm/vec-common.md: ... here.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vshr.c: Add tests for vshr.", "tree": {"sha": "a82d4863be7568fb2360e959eacd99c8f59c438b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a82d4863be7568fb2360e959eacd99c8f59c438b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfab355012ca0f5219da8beb04f2fdaf757d34b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfab355012ca0f5219da8beb04f2fdaf757d34b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfab355012ca0f5219da8beb04f2fdaf757d34b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfab355012ca0f5219da8beb04f2fdaf757d34b7/comments", "author": null, "committer": null, "parents": [{"sha": "7432f255b70811dafaf325d94036ac580891de69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7432f255b70811dafaf325d94036ac580891de69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7432f255b70811dafaf325d94036ac580891de69"}], "stats": {"total": 165, "additions": 130, "deletions": 35}, "files": [{"sha": "62ff12365ab3f92f177704927d230fefc415f1cb", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=bfab355012ca0f5219da8beb04f2fdaf757d34b7", "patch": "@@ -763,6 +763,7 @@\n ;;\n ;; [vshrq_n_s, vshrq_n_u])\n ;;\n+;; Version that takes an immediate as operand 2.\n (define_insn \"mve_vshrq_n_<supf><mode>\"\n   [\n    (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n@@ -775,6 +776,39 @@\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n+;; Versions that take constant vectors as operand 2 (with all elements\n+;; equal).\n+(define_insn \"mve_vshrq_n_s<mode>_imm\"\n+  [\n+   (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n+\t(ashiftrt:MVE_2 (match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n+\t\t\t(match_operand:MVE_2 2 \"imm_for_neon_rshift_operand\" \"i\")))\n+  ]\n+  \"TARGET_HAVE_MVE\"\n+  {\n+    return neon_output_shift_immediate (\"vshr\", 's', &operands[2],\n+\t\t\t\t\t<MODE>mode,\n+\t\t\t\t\tVALID_NEON_QREG_MODE (<MODE>mode),\n+\t\t\t\t\ttrue);\n+  }\n+  [(set_attr \"type\" \"mve_move\")\n+])\n+(define_insn \"mve_vshrq_n_u<mode>_imm\"\n+  [\n+   (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n+\t(lshiftrt:MVE_2 (match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n+\t\t\t(match_operand:MVE_2 2 \"imm_for_neon_rshift_operand\" \"i\")))\n+  ]\n+  \"TARGET_HAVE_MVE\"\n+  {\n+    return neon_output_shift_immediate (\"vshr\", 'u', &operands[2],\n+\t\t\t\t\t<MODE>mode,\n+\t\t\t\t\tVALID_NEON_QREG_MODE (<MODE>mode),\n+\t\t\t\t\ttrue);\n+  }\n+  [(set_attr \"type\" \"mve_move\")\n+])\n+\n ;;\n ;; [vcvtq_n_from_f_s, vcvtq_n_from_f_u])\n ;;"}, {"sha": "e904db97ea7bd4cb0f32199038ace3d334ffb8f9", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=bfab355012ca0f5219da8beb04f2fdaf757d34b7", "patch": "@@ -899,40 +899,6 @@\n   [(set_attr \"type\" \"neon_shift_reg<q>\")]\n )\n \n-(define_expand \"vashr<mode>3\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n-\t(ashiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\")\n-\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\")))]\n-  \"TARGET_NEON\"\n-{\n-  if (s_register_operand (operands[2], <MODE>mode))\n-    {\n-      rtx neg = gen_reg_rtx (<MODE>mode);\n-      emit_insn (gen_neon_neg<mode>2 (neg, operands[2]));\n-      emit_insn (gen_ashl<mode>3_signed (operands[0], operands[1], neg));\n-    }\n-  else\n-    emit_insn (gen_vashr<mode>3_imm (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_expand \"vlshr<mode>3\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n-\t(lshiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\")\n-\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\")))]\n-  \"TARGET_NEON\"\n-{\n-  if (s_register_operand (operands[2], <MODE>mode))\n-    {\n-      rtx neg = gen_reg_rtx (<MODE>mode);\n-      emit_insn (gen_neon_neg<mode>2 (neg, operands[2]));\n-      emit_insn (gen_ashl<mode>3_unsigned (operands[0], operands[1], neg));\n-    }\n-  else\n-    emit_insn (gen_vlshr<mode>3_imm (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n ;; 64-bit shifts\n \n ;; This pattern loads a 32-bit shift count into a 64-bit NEON register,"}, {"sha": "ff448da126b2250605d772ad423c70c16b753338", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=bfab355012ca0f5219da8beb04f2fdaf757d34b7", "patch": "@@ -259,4 +259,40 @@\n {\n   emit_insn (gen_mve_vshlq_u<mode> (operands[0], operands[1], operands[2]));\n   DONE;\n-})\n\\ No newline at end of file\n+})\n+\n+;; When operand 2 is an immediate, use the normal expansion to match\n+;; gen_vashr<mode>3_imm for Neon and gen_mve_vshrq_n_s<mode>_imm for\n+;; MVE.\n+(define_expand \"vashr<mode>3\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n+\t(ashiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\")\n+\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (s_register_operand (operands[2], <MODE>mode))\n+    {\n+      rtx neg = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_mve_vshlq_s<mode> (operands[0], operands[1], neg));\n+      DONE;\n+    }\n+})\n+\n+;; When operand 2 is an immediate, use the normal expansion to match\n+;; gen_vashr<mode>3_imm for Neon and gen_mve_vshrq_n_u<mode>_imm for\n+;; MVE.\n+(define_expand \"vlshr<mode>3\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n+\t(lshiftrt:VDQIW (match_operand:VDQIW 1 \"s_register_operand\")\n+\t\t\t(match_operand:VDQIW 2 \"imm_rshift_or_reg_neon\")))]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (s_register_operand (operands[2], <MODE>mode))\n+    {\n+      rtx neg = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_neg<mode>2 (neg, operands[2]));\n+      emit_insn (gen_mve_vshlq_u<mode> (operands[0], operands[1], neg));\n+      DONE;\n+    }\n+})"}, {"sha": "d4e658c2c4e79a5f33744e2c8dee14fb80a76931", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vshr.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfab355012ca0f5219da8beb04f2fdaf757d34b7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshr.c?ref=bfab355012ca0f5219da8beb04f2fdaf757d34b7", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP b[i];\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define FUNC_IMM(SIGN, TYPE, BITS, NB, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS ## x ## NB (TYPE##BITS##_t * __restrict__ dest, TYPE##BITS##_t *a) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i<NB; i++) {\t\t\t\t\t\t\\\n+      dest[i] = a[i] OP 5;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* 64-bit vectors.  */\n+FUNC(s, int, 32, 2, >>, vshr)\n+FUNC(u, uint, 32, 2, >>, vshr)\n+FUNC(s, int, 16, 4, >>, vshr)\n+FUNC(u, uint, 16, 4, >>, vshr)\n+FUNC(s, int, 8, 8, >>, vshr)\n+FUNC(u, uint, 8, 8, >>, vshr)\n+\n+/* 128-bit vectors.  */\n+FUNC(s, int, 32, 4, >>, vshr)\n+FUNC(u, uint, 32, 4, >>, vshr)\n+FUNC(s, int, 16, 8, >>, vshr)\n+FUNC(u, uint, 16, 8, >>, vshr)\n+FUNC(s, int, 8, 16, >>, vshr)\n+FUNC(u, uint, 8, 16, >>, vshr)\n+\n+/* 64-bit vectors.  */\n+FUNC_IMM(s, int, 32, 2, >>, vshrimm)\n+FUNC_IMM(u, uint, 32, 2, >>, vshrimm)\n+FUNC_IMM(s, int, 16, 4, >>, vshrimm)\n+FUNC_IMM(u, uint, 16, 4, >>, vshrimm)\n+FUNC_IMM(s, int, 8, 8, >>, vshrimm)\n+FUNC_IMM(u, uint, 8, 8, >>, vshrimm)\n+\n+/* 128-bit vectors.  */\n+FUNC_IMM(s, int, 32, 4, >>, vshrimm)\n+FUNC_IMM(u, uint, 32, 4, >>, vshrimm)\n+FUNC_IMM(s, int, 16, 8, >>, vshrimm)\n+FUNC_IMM(u, uint, 16, 8, >>, vshrimm)\n+FUNC_IMM(s, int, 8, 16, >>, vshrimm)\n+FUNC_IMM(u, uint, 8, 16, >>, vshrimm)\n+\n+/* MVE has only 128-bit vectors, so we can vectorize only half of the\n+   functions above.  */\n+/* { dg-final { scan-assembler-times {vshr.s[0-9]+\\tq[0-9]+, q[0-9]+} 3 } } */\n+/* { dg-final { scan-assembler-times {vshr.u[0-9]+\\tq[0-9]+, q[0-9]+} 3 } } */"}]}