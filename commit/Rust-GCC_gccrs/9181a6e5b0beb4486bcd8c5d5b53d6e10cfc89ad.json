{"sha": "9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4MWE2ZTViMGJlYjQ0ODZiY2Q4YzVkNWI1M2Q2ZTEwY2ZjODlhZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2011-08-18T14:56:36Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2011-08-18T14:56:36Z"}, "message": "re PR rtl-optimization/50107 ([IRA, i386] allocates registers in very non-optimal way)\n\n2011-08-17  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/50107\n\t* ira-int.h (ira_hard_reg_not_in_set_p): Remove.\n\t(ira_hard_reg_in_set_p): New.\n\n\t* ira-color.c (calculate_saved_nregs): New.\n\t(assign_hard_reg): Use it.  Set up allocated_hard_reg_p for all\n\thard regs.\n\t(allocno_reload_assign, fast_allocation): Use\n\tira_hard_reg_set_intersection_p instead of\n\tira_hard_reg_not_in_set_p.\n\n\t* ira.c (setup_reg_renumber): Use\n\tira_hard_reg_set_intersection_p instead of\n\tira_hard_reg_not_in_set_p.\n\t(setup_allocno_assignment_flags, calculate_allocation_cost): Use\n\tira_hard_reg_in_set_p instead of ira_hard_reg_not_in_set_p.\n\n\t* ira-costs.c (ira_tune_allocno_costs): Use\n\tira_hard_reg_set_intersection_p instead of\n\tira_hard_reg_not_in_set_p.\n\nFrom-SVN: r177865", "tree": {"sha": "7665fff80006b4ee0895413a6c4f561a0d006144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7665fff80006b4ee0895413a6c4f561a0d006144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99114bbfa1de1c286fffef4b0dff20a360066e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99114bbfa1de1c286fffef4b0dff20a360066e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99114bbfa1de1c286fffef4b0dff20a360066e2a"}], "stats": {"total": 100, "additions": 72, "deletions": 28}, "files": [{"sha": "41c3db20a36dabaf26466a4b4ae923ea2f149e85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "patch": "@@ -1,3 +1,26 @@\n+2011-08-17  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/50107\n+\t* ira-int.h (ira_hard_reg_not_in_set_p): Remove.\n+\t(ira_hard_reg_in_set_p): New.\n+\n+\t* ira-color.c (calculate_saved_nregs): New.\n+\t(assign_hard_reg): Use it.  Set up allocated_hard_reg_p for all\n+\thard regs.\n+\t(allocno_reload_assign, fast_allocation): Use\n+\tira_hard_reg_set_intersection_p instead of\n+\tira_hard_reg_not_in_set_p.\n+\n+\t* ira.c (setup_reg_renumber): Use\n+\tira_hard_reg_set_intersection_p instead of\n+\tira_hard_reg_not_in_set_p.\n+\t(setup_allocno_assignment_flags, calculate_allocation_cost): Use\n+\tira_hard_reg_in_set_p instead of ira_hard_reg_not_in_set_p.\n+\n+\t* ira-costs.c (ira_tune_allocno_costs): Use\n+\tira_hard_reg_set_intersection_p instead of\n+\tira_hard_reg_not_in_set_p.\n+\n 2011-08-18  H.J. Lu  <hongjiu.lu@intel.com>\n \t    Igor Zamyatin <igor.zamyatin@intel.com>\n "}, {"sha": "eb87b0e419b5459edfe12efe527a6ada793edd0f", "filename": "gcc/ira-color.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "patch": "@@ -1519,6 +1519,26 @@ check_hard_reg_p (ira_allocno_t a, int hard_regno,\n     }\n   return j == nregs;\n }\n+#ifndef HONOR_REG_ALLOC_ORDER\n+\n+/* Return number of registers needed to be saved and restored at\n+   function prologue/epilogue if we allocate HARD_REGNO to hold value\n+   of MODE.  */\n+static int\n+calculate_saved_nregs (int hard_regno, enum machine_mode mode)\n+{\n+  int i;\n+  int nregs = 0;\n+\n+  ira_assert (hard_regno >= 0);\n+  for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n+    if (!allocated_hardreg_p[hard_regno + i]\n+\t&& !TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + i)\n+\t&& !LOCAL_REGNO (hard_regno + i))\n+      nregs++;\n+  return nregs;\n+}\n+#endif\n \n /* Choose a hard register for allocno A.  If RETRY_P is TRUE, it means\n    that the function called from function\n@@ -1547,7 +1567,7 @@ static bool\n assign_hard_reg (ira_allocno_t a, bool retry_p)\n {\n   HARD_REG_SET conflicting_regs[2], profitable_hard_regs[2];\n-  int i, j, hard_regno, best_hard_regno, class_size;\n+  int i, j, hard_regno, best_hard_regno, class_size, saved_nregs;\n   int cost, mem_cost, min_cost, full_cost, min_full_cost, nwords, word;\n   int *a_costs;\n   enum reg_class aclass;\n@@ -1716,16 +1736,14 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n       cost = costs[i];\n       full_cost = full_costs[i];\n #ifndef HONOR_REG_ALLOC_ORDER\n-      if (! allocated_hardreg_p[hard_regno]\n-\t  && ira_hard_reg_not_in_set_p (hard_regno, mode, call_used_reg_set)\n-\t  && !LOCAL_REGNO (hard_regno))\n+      if ((saved_nregs = calculate_saved_nregs (hard_regno, mode)) != 0)\n \t/* We need to save/restore the hard register in\n \t   epilogue/prologue.  Therefore we increase the cost.  */\n \t{\n-\t  /* ??? If only part is call clobbered.  */\n \t  rclass = REGNO_REG_CLASS (hard_regno);\n-\t  add_cost = (ira_memory_move_cost[mode][rclass][0]\n-\t\t      + ira_memory_move_cost[mode][rclass][1] - 1);\n+\t  add_cost = ((ira_memory_move_cost[mode][rclass][0]\n+\t\t       + ira_memory_move_cost[mode][rclass][1])\n+\t\t      * saved_nregs / hard_regno_nregs[hard_regno][mode] - 1);\n \t  cost += add_cost;\n \t  full_cost += add_cost;\n \t}\n@@ -1748,7 +1766,10 @@ assign_hard_reg (ira_allocno_t a, bool retry_p)\n     }\n  fail:\n   if (best_hard_regno >= 0)\n-    allocated_hardreg_p[best_hard_regno] = true;\n+    {\n+      for (i = hard_regno_nregs[best_hard_regno][mode] - 1; i >= 0; i--)\n+\tallocated_hardreg_p[best_hard_regno + 1] = true;\n+    }\n   ALLOCNO_HARD_REGNO (a) = best_hard_regno;\n   ALLOCNO_ASSIGNED_P (a) = true;\n   if (best_hard_regno >= 0)\n@@ -3975,8 +3996,8 @@ allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n \t       : ALLOCNO_HARD_REG_COSTS (a)[ira_class_hard_reg_index\n \t\t\t\t\t    [aclass][hard_regno]]));\n       if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n-\t  && ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t  call_used_reg_set))\n+\t  && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n+\t\t\t\t\t      call_used_reg_set))\n \t{\n \t  ira_assert (flag_caller_saves);\n \t  caller_save_needed = 1;\n@@ -4467,7 +4488,7 @@ fast_allocation (void)\n \t      && hard_regno <= LAST_STACK_REG)\n \t    continue;\n #endif\n-\t  if (!ira_hard_reg_not_in_set_p (hard_regno, mode, conflict_hard_regs)\n+\t  if (ira_hard_reg_set_intersection_p (hard_regno, mode, conflict_hard_regs)\n \t      || (TEST_HARD_REG_BIT\n \t\t  (ira_prohibited_class_mode_regs[aclass][mode], hard_regno)))\n \t    continue;"}, {"sha": "12d3ed67fa7612dbbec2427f989a10eff9ecb6cb", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "patch": "@@ -2072,9 +2072,9 @@ ira_tune_allocno_costs (void)\n \t      skip_p = false;\n \t      FOR_EACH_ALLOCNO_OBJECT (a, obj, oi)\n \t\t{\n-\t\t  if (! ira_hard_reg_not_in_set_p (regno, mode,\n-\t\t\t\t\t\t   OBJECT_CONFLICT_HARD_REGS\n-\t\t\t\t\t\t   (obj)))\n+\t\t  if (ira_hard_reg_set_intersection_p (regno, mode,\n+\t\t\t\t\t\t       OBJECT_CONFLICT_HARD_REGS\n+\t\t\t\t\t\t       (obj)))\n \t\t    {\n \t\t      skip_p = true;\n \t\t      break;\n@@ -2084,7 +2084,7 @@ ira_tune_allocno_costs (void)\n \t\tcontinue;\n \t      rclass = REGNO_REG_CLASS (regno);\n \t      cost = 0;\n-\t      if (! ira_hard_reg_not_in_set_p (regno, mode, call_used_reg_set)\n+\t      if (ira_hard_reg_set_intersection_p (regno, mode, call_used_reg_set)\n \t\t  || HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)\n \t\t\t * (ira_memory_move_cost[mode][rclass][0]"}, {"sha": "1db9b411e0b160007e719385025d90fd3addda75", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "patch": "@@ -1323,17 +1323,17 @@ hard_reg_set_size (HARD_REG_SET set)\n }\n \n /* The function returns TRUE if hard registers starting with\n-   HARD_REGNO and containing value of MODE are not in set\n+   HARD_REGNO and containing value of MODE are fully in set\n    HARD_REGSET.  */\n static inline bool\n-ira_hard_reg_not_in_set_p (int hard_regno, enum machine_mode mode,\n-\t\t\t   HARD_REG_SET hard_regset)\n+ira_hard_reg_in_set_p (int hard_regno, enum machine_mode mode,\n+\t\t       HARD_REG_SET hard_regset)\n {\n   int i;\n \n   ira_assert (hard_regno >= 0);\n   for (i = hard_regno_nregs[hard_regno][mode] - 1; i >= 0; i--)\n-    if (TEST_HARD_REG_BIT (hard_regset, hard_regno + i))\n+    if (!TEST_HARD_REG_BIT (hard_regset, hard_regno + i))\n       return false;\n   return true;\n }"}, {"sha": "e4be8b52f714d9d7dc9b177a0a9296114933dae6", "filename": "gcc/ira.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=9181a6e5b0beb4486bcd8c5d5b53d6e10cfc89ad", "patch": "@@ -1953,8 +1953,8 @@ setup_reg_renumber (void)\n \t\t\t\t      reg_class_contents[pclass]);\n \t    }\n \t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0\n-\t      && ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t      call_used_reg_set))\n+\t      && ira_hard_reg_set_intersection_p (hard_regno, ALLOCNO_MODE (a),\n+\t\t\t\t\t\t  call_used_reg_set))\n \t    {\n \t      ira_assert (!optimize || flag_caller_saves\n \t\t\t  || regno >= ira_reg_equiv_len\n@@ -1992,10 +1992,10 @@ setup_allocno_assignment_flags (void)\n \t\t\t\t|| ALLOCNO_EMIT_DATA (a)->mem_optimized_dest_p\n \t\t\t\t|| (ALLOCNO_MEMORY_COST (a)\n \t\t\t\t    - ALLOCNO_CLASS_COST (a)) < 0);\n-      ira_assert (hard_regno < 0\n-\t\t  || ! ira_hard_reg_not_in_set_p (hard_regno, ALLOCNO_MODE (a),\n-\t\t\t\t\t\t  reg_class_contents\n-\t\t\t\t\t\t  [ALLOCNO_CLASS (a)]));\n+      ira_assert\n+\t(hard_regno < 0\n+\t || ira_hard_reg_in_set_p (hard_regno, ALLOCNO_MODE (a),\n+\t\t\t\t   reg_class_contents[ALLOCNO_CLASS (a)]));\n     }\n }\n \n@@ -2013,9 +2013,9 @@ calculate_allocation_cost (void)\n     {\n       hard_regno = ALLOCNO_HARD_REGNO (a);\n       ira_assert (hard_regno < 0\n-\t\t  || ! ira_hard_reg_not_in_set_p\n-\t\t       (hard_regno, ALLOCNO_MODE (a),\n-\t\t\treg_class_contents[ALLOCNO_CLASS (a)]));\n+\t\t  || (ira_hard_reg_in_set_p\n+\t\t      (hard_regno, ALLOCNO_MODE (a),\n+\t\t       reg_class_contents[ALLOCNO_CLASS (a)])));\n       if (hard_regno < 0)\n \t{\n \t  cost = ALLOCNO_MEMORY_COST (a);"}]}