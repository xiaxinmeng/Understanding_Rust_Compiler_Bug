{"sha": "3721b9e1ee8b73b2e299fb2ce80568a35578e728", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcyMWI5ZTFlZThiNzNiMmUyOTlmYjJjZTgwNTY4YTM1NTc4ZTcyOA==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2006-12-21T22:29:08Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2006-12-21T22:29:08Z"}, "message": "re PR libgomp/28209 (None of the GOMP_* environment variables are documented)\n\n2006-12-21  Daniel Franke  <franke.daniel@gmail.com>\n\n\tPR libgomp/28209\n\t* libgomp.texi: New file.\n\t* configure.ac: Add --enable-generated-files-in-srcdir option.\n\t* Makefile.am: Add info, dvi, pdf, html targets. On request, copy\n\tfiles to srcdir.\n\t* Makefile.in: Regenerated.\n\t* config.h.in: Regenerated.\n\t* testsuite/Makefile.in: Regenerated.\n\t* NOTES: Removed.\n\nFrom-SVN: r120122", "tree": {"sha": "431fe1679a89a4f2c4ce0e099c1c53dd39131c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/431fe1679a89a4f2c4ce0e099c1c53dd39131c0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3721b9e1ee8b73b2e299fb2ce80568a35578e728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3721b9e1ee8b73b2e299fb2ce80568a35578e728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3721b9e1ee8b73b2e299fb2ce80568a35578e728", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3721b9e1ee8b73b2e299fb2ce80568a35578e728/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9d207d9ac31509bbf6db4035b3784c74b47d669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d207d9ac31509bbf6db4035b3784c74b47d669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d207d9ac31509bbf6db4035b3784c74b47d669"}], "stats": {"total": 1928, "additions": 1615, "deletions": 313}, "files": [{"sha": "cf2efab41252bd5538b60cffe6d188fdd8291741", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -1,3 +1,15 @@\n+2006-12-21  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\tPR libgomp/28209\n+\t* libgomp.texi: New file.\n+\t* configure.ac: Add --enable-generated-files-in-srcdir option.\n+\t* Makefile.am: Add info, dvi, pdf, html targets. On request, copy\n+\tfiles to srcdir.\n+\t* Makefile.in: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* testsuite/Makefile.in: Regenerated.\n+\t* NOTES: Removed.\n+\n 2006-12-04  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR libgomp/29949"}, {"sha": "ee2669c952f7ad6bb2a51369f2c246779555a0eb", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -50,7 +50,35 @@ fortran.o: libgomp_f.h\n env.lo: libgomp_f.h\n env.o: libgomp_f.h\n \n+\n # No install-html target\n .PHONY: install-html\n install-html:\n \n+\n+# Automake Documentation:\n+# If your package has Texinfo files in many directories, you can use the\n+# variable TEXINFO_TEX to tell Automake where to find the canonical\n+# `texinfo.tex' for your package. The value of this variable should be\n+# the relative path from the current `Makefile.am' to `texinfo.tex'.\n+TEXINFO_TEX   = ../gcc/doc/include/texinfo.tex\n+\n+# Defines info, dvi, pdf and html targets\n+MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n+info_TEXINFOS = libgomp.texi\n+\n+# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n+if GENINSRC\n+STAMP_GENINSRC = stamp-geninsrc\n+else\n+STAMP_GENINSRC =\n+endif\n+\n+all-local: $(STAMP_GENINSRC)\n+\n+stamp-geninsrc: libgomp.info\n+\t-cp -p $(top_builddir)/libgomp.info $(srcdir)/libgomp.info\n+\ttouch $@\n+\n+CLEANFILES = stamp-geninsrc libgomp.info\n+MAINTAINERCLEANFILES = $(srcdir)/libgomp.info"}, {"sha": "ad8820e5ea67d78c923d669ea0216077e6f683cf", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 203, "deletions": 26, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -51,6 +51,7 @@ ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n \t$(top_srcdir)/../config/enable.m4 \\\n \t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n \t$(top_srcdir)/../config/stdint.m4 \\\n \t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/acinclude.m4 \\\n \t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n@@ -68,7 +69,7 @@ am__vpath_adj = case $$p in \\\n     *) f=$$p;; \\\n   esac;\n am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(fincludedir)\" \"$(DESTDIR)$(libsubincludedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibdir)\"\n toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n@@ -98,6 +99,18 @@ MULTIDIRS =\n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n+INFO_DEPS = libgomp.info\n+am__TEXINFO_TEX_DIR = $(srcdir)/../gcc/doc/include\n+DVIS = libgomp.dvi\n+PDFS = libgomp.pdf\n+PSS = libgomp.ps\n+HTMLS = libgomp.html\n+TEXINFOS = libgomp.texi\n+TEXI2DVI = texi2dvi\n+TEXI2PDF = $(TEXI2DVI) --pdf --batch\n+MAKEINFOHTML = $(MAKEINFO) --html\n+AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)\n+DVIPS = dvips\n RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \thtml-recursive info-recursive install-data-recursive \\\n \tinstall-exec-recursive install-info-recursive \\\n@@ -148,6 +161,9 @@ EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n FC = @FC@\n FCFLAGS = @FCFLAGS@\n+GENINSRC_FALSE = @GENINSRC_FALSE@\n+GENINSRC_TRUE = @GENINSRC_TRUE@\n+GREP = @GREP@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_SCRIPT = @INSTALL_SCRIPT@\n@@ -190,11 +206,8 @@ USE_FORTRAN_TRUE = @USE_FORTRAN_TRUE@\n VERSION = @VERSION@\n XCFLAGS = @XCFLAGS@\n XLDFLAGS = @XLDFLAGS@\n-ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_FC = @ac_ct_FC@\n-ac_ct_RANLIB = @ac_ct_RANLIB@\n-ac_ct_STRIP = @ac_ct_STRIP@\n am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n am__include = @am__include@\n@@ -210,6 +223,9 @@ build_os = @build_os@\n build_vendor = @build_vendor@\n config_path = @config_path@\n datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n enable_shared = @enable_shared@\n enable_static = @enable_static@\n exec_prefix = @exec_prefix@\n@@ -218,20 +234,24 @@ host_alias = @host_alias@\n host_cpu = @host_cpu@\n host_os = @host_os@\n host_vendor = @host_vendor@\n+htmldir = @htmldir@\n includedir = @includedir@\n infodir = @infodir@\n install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n libtool_VERSION = @libtool_VERSION@\n link_gomp = @link_gomp@\n+localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n mkdir_p = @mkdir_p@\n multi_basedir = @multi_basedir@\n oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n prefix = @prefix@\n program_transform_name = @program_transform_name@\n+psdir = @psdir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n sysconfdir = @sysconfdir@\n@@ -266,11 +286,28 @@ libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n nodist_noinst_HEADERS = libgomp_f.h\n nodist_libsubinclude_HEADERS = omp.h\n @USE_FORTRAN_TRUE@nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod\n+\n+# Automake Documentation:\n+# If your package has Texinfo files in many directories, you can use the\n+# variable TEXINFO_TEX to tell Automake where to find the canonical\n+# `texinfo.tex' for your package. The value of this variable should be\n+# the relative path from the current `Makefile.am' to `texinfo.tex'.\n+TEXINFO_TEX = ../gcc/doc/include/texinfo.tex\n+\n+# Defines info, dvi, pdf and html targets\n+MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n+info_TEXINFOS = libgomp.texi\n+@GENINSRC_FALSE@STAMP_GENINSRC = \n+\n+# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n+@GENINSRC_TRUE@STAMP_GENINSRC = stamp-geninsrc\n+CLEANFILES = stamp-geninsrc libgomp.info\n+MAINTAINERCLEANFILES = $(srcdir)/libgomp.info\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n \n .SUFFIXES:\n-.SUFFIXES: .c .lo .o .obj\n+.SUFFIXES: .c .dvi .lo .o .obj .ps\n am--refresh:\n \t@:\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n@@ -434,7 +471,101 @@ distclean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n maintainer-clean-multi:\n \t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+\n+libgomp.info: libgomp.texi \n+\trestore=: && backupdir=\"$(am__leading_dot)am$$$$\" && \\\n+\trm -rf $$backupdir && mkdir $$backupdir && \\\n+\tif ($(MAKEINFO) --version) >/dev/null 2>&1; then \\\n+\t  for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \\\n+\t    if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \\\n+\t  done; \\\n+\telse :; fi && \\\n+\tif $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \\\n+\t -o $@ `test -f 'libgomp.texi' || echo '$(srcdir)/'`libgomp.texi; \\\n+\tthen \\\n+\t  rc=0; \\\n+\telse \\\n+\t  rc=$$?; \\\n+\t  $$restore $$backupdir/* `echo \"./$@\" | sed 's|[^/]*$$||'`; \\\n+\tfi; \\\n+\trm -rf $$backupdir; exit $$rc\n+\n+libgomp.dvi: libgomp.texi  \n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \\\n+\t$(TEXI2DVI) -o $@ `test -f 'libgomp.texi' || echo '$(srcdir)/'`libgomp.texi\n+\n+libgomp.pdf: libgomp.texi  \n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \\\n+\t$(TEXI2PDF) -o $@ `test -f 'libgomp.texi' || echo '$(srcdir)/'`libgomp.texi\n+\n+libgomp.html: libgomp.texi  \n+\trm -rf $(@:.html=.htp)\n+\tif $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \\\n+\t -o $(@:.html=.htp) `test -f 'libgomp.texi' || echo '$(srcdir)/'`libgomp.texi; \\\n+\tthen \\\n+\t  rm -rf $@; \\\n+\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n+\t    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \\\n+\telse \\\n+\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n+\t    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \\\n+\t  exit 1; \\\n+\tfi\n+.dvi.ps:\n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\t$(DVIPS) -o $@ $<\n+\n uninstall-info-am:\n+\t@$(PRE_UNINSTALL)\n+\t@if (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n+\t  list='$(INFO_DEPS)'; \\\n+\t  for file in $$list; do \\\n+\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n+\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" --remove \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n+\t  done; \\\n+\telse :; fi\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(INFO_DEPS)'; \\\n+\tfor file in $$list; do \\\n+\t  relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t  relfile_i=`echo \"$$relfile\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  (if cd \"$(DESTDIR)$(infodir)\"; then \\\n+\t     echo \" cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]\"; \\\n+\t     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \\\n+\t   else :; fi); \\\n+\tdone\n+\n+dist-info: $(INFO_DEPS)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n+\tlist='$(INFO_DEPS)'; \\\n+\tfor base in $$list; do \\\n+\t  case $$base in \\\n+\t    $(srcdir)/*) base=`echo \"$$base\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+\t  esac; \\\n+\t  if test -f $$base; then d=.; else d=$(srcdir); fi; \\\n+\t  for file in $$d/$$base*; do \\\n+\t    relfile=`expr \"$$file\" : \"$$d/\\(.*\\)\"`; \\\n+\t    test -f $(distdir)/$$relfile || \\\n+\t      cp -p $$file $(distdir)/$$relfile; \\\n+\t  done; \\\n+\tdone\n+\n+mostlyclean-aminfo:\n+\t-rm -rf libgomp.aux libgomp.cp libgomp.cps libgomp.fn libgomp.fns libgomp.ky \\\n+\t  libgomp.kys libgomp.log libgomp.pg libgomp.pgs libgomp.tmp \\\n+\t  libgomp.toc libgomp.tp libgomp.tps libgomp.vr libgomp.vrs \\\n+\t  libgomp.dvi libgomp.pdf libgomp.ps libgomp.html\n+\n+maintainer-clean-aminfo:\n+\t@list='$(INFO_DEPS)'; for i in $$list; do \\\n+\t  i_i=`echo \"$$i\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  echo \" rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]\"; \\\n+\t  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \\\n+\tdone\n install-nodist_fincludeHEADERS: $(nodist_finclude_HEADERS)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(fincludedir)\" || $(mkdir_p) \"$(DESTDIR)$(fincludedir)\"\n@@ -664,6 +795,9 @@ distdir: $(DISTFILES)\n \t      || exit 1; \\\n \t  fi; \\\n \tdone\n+\t$(MAKE) $(AM_MAKEFLAGS) \\\n+\t  top_distdir=\"$(top_distdir)\" distdir=\"$(distdir)\" \\\n+\t  dist-info\n \t-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \\; -o \\\n \t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n \t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n@@ -763,10 +897,11 @@ distcleancheck: distclean\n \t       exit 1; } >&2\n check-am: all-am\n check: check-recursive\n-all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS) config.h\n+all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) all-multi $(HEADERS) \\\n+\t\tconfig.h all-local\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(fincludedir)\" \"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(fincludedir)\" \"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n \t  test -z \"$$dir\" || $(mkdir_p) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -786,13 +921,15 @@ install-strip:\n mostlyclean-generic:\n \n clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n \n distclean-generic:\n \t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n+\t-test -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n clean: clean-multi clean-recursive\n \n clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n@@ -807,22 +944,54 @@ distclean-am: clean-am distclean-compile distclean-generic \\\n \n dvi: dvi-recursive\n \n-dvi-am:\n+dvi-am: $(DVIS)\n \n html: html-recursive\n \n+html-am: $(HTMLS)\n+\n info: info-recursive\n \n-info-am:\n+info-am: $(INFO_DEPS)\n \n-install-data-am: install-nodist_fincludeHEADERS \\\n+install-data-am: install-info-am install-nodist_fincludeHEADERS \\\n \tinstall-nodist_libsubincludeHEADERS\n \n install-exec-am: install-multi install-nodist_toolexeclibHEADERS \\\n \tinstall-toolexeclibLTLIBRARIES\n \n install-info: install-info-recursive\n \n+install-info-am: $(INFO_DEPS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(infodir)\" || $(mkdir_p) \"$(DESTDIR)$(infodir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n+\tlist='$(INFO_DEPS)'; \\\n+\tfor file in $$list; do \\\n+\t  case $$file in \\\n+\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+\t  esac; \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  file_i=`echo \"$$file\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \\\n+                       $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \\\n+\t    if test -f $$ifile; then \\\n+\t      relfile=`echo \"$$ifile\" | sed 's|^.*/||'`; \\\n+\t      echo \" $(INSTALL_DATA) '$$ifile' '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n+\t      $(INSTALL_DATA) \"$$ifile\" \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n+\t    else : ; fi; \\\n+\t  done; \\\n+\tdone\n+\t@$(POST_INSTALL)\n+\t@if (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n+\t  list='$(INFO_DEPS)'; \\\n+\t  for file in $$list; do \\\n+\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'\";\\\n+\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(infodir)/$$relfile\" || :;\\\n+\t  done; \\\n+\telse : ; fi\n install-man:\n \n installcheck-am:\n@@ -832,20 +1001,21 @@ maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n \t-rm -rf $(top_srcdir)/autom4te.cache\n \t-rm -rf ./$(DEPDIR)\n \t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n+maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n+\tmaintainer-clean-generic\n \n mostlyclean: mostlyclean-multi mostlyclean-recursive\n \n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n+mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool\n \n pdf: pdf-recursive\n \n-pdf-am:\n+pdf-am: $(PDFS)\n \n ps: ps-recursive\n \n-ps-am:\n+ps-am: $(PSS)\n \n uninstall-am: uninstall-info-am uninstall-nodist_fincludeHEADERS \\\n \tuninstall-nodist_libsubincludeHEADERS \\\n@@ -854,11 +1024,12 @@ uninstall-am: uninstall-info-am uninstall-nodist_fincludeHEADERS \\\n \n uninstall-info: uninstall-info-recursive\n \n-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am all-multi \\\n-\tam--refresh check check-am clean clean-generic clean-libtool \\\n-\tclean-multi clean-recursive clean-toolexeclibLTLIBRARIES ctags \\\n-\tctags-recursive dist dist-all dist-bzip2 dist-gzip dist-shar \\\n-\tdist-tarZ dist-zip distcheck distclean distclean-compile \\\n+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am all-local \\\n+\tall-multi am--refresh check check-am clean clean-generic \\\n+\tclean-libtool clean-multi clean-recursive \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive dist \\\n+\tdist-all dist-bzip2 dist-gzip dist-info dist-shar dist-tarZ \\\n+\tdist-zip distcheck distclean distclean-compile \\\n \tdistclean-generic distclean-hdr distclean-libtool \\\n \tdistclean-multi distclean-recursive distclean-tags \\\n \tdistcleancheck distdir distuninstallcheck dvi dvi-am html \\\n@@ -870,12 +1041,12 @@ uninstall-info: uninstall-info-recursive\n \tinstall-nodist_toolexeclibHEADERS install-strip \\\n \tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n \tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi \\\n-\tmaintainer-clean-recursive mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool mostlyclean-multi \\\n-\tmostlyclean-recursive pdf pdf-am ps ps-am tags tags-recursive \\\n-\tuninstall uninstall-am uninstall-info-am \\\n-\tuninstall-nodist_fincludeHEADERS \\\n+\tmaintainer-clean-aminfo maintainer-clean-generic \\\n+\tmaintainer-clean-multi maintainer-clean-recursive mostlyclean \\\n+\tmostlyclean-aminfo mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool mostlyclean-multi mostlyclean-recursive \\\n+\tpdf pdf-am ps ps-am tags tags-recursive uninstall uninstall-am \\\n+\tuninstall-info-am uninstall-nodist_fincludeHEADERS \\\n \tuninstall-nodist_libsubincludeHEADERS \\\n \tuninstall-nodist_toolexeclibHEADERS \\\n \tuninstall-toolexeclibLTLIBRARIES\n@@ -893,6 +1064,12 @@ env.o: libgomp_f.h\n # No install-html target\n .PHONY: install-html\n install-html:\n+\n+all-local: $(STAMP_GENINSRC)\n+\n+stamp-geninsrc: libgomp.info\n+\t-cp -p $(top_builddir)/libgomp.info $(srcdir)/libgomp.info\n+\ttouch $@\n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "753363c49d669434a4d6f81195bc7d146f6a5fb3", "filename": "libgomp/NOTES", "status": "removed", "additions": 0, "deletions": 279, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d207d9ac31509bbf6db4035b3784c74b47d669/libgomp%2FNOTES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d207d9ac31509bbf6db4035b3784c74b47d669/libgomp%2FNOTES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FNOTES?ref=e9d207d9ac31509bbf6db4035b3784c74b47d669", "patch": "@@ -1,279 +0,0 @@\n-Notes on the external ABI presented by libgomp.  This ought to get\n-transformed into proper documentation at some point.\n-\n-Implementing MASTER construct\n-\n-\tif (omp_get_thread_num () == 0)\n-\t  block\n-\n-\tAlternately, we generate two copies of the parallel subfunction\n-\tand only include this in the version run by the master thread.\n-\tSurely that's not worthwhile though...\n-\n-Implementing CRITICAL construct\n-\n-\tWithout a specified name,\n-\n-\tvoid GOMP_critical_start (void);\n-\tvoid GOMP_critical_end (void);\n-\n-\tso that we don't get COPY relocations from libgomp to the main\n-\tapplication.\n-\n-\tWith a specified name, use omp_set_lock and omp_unset_lock with\n-\tname being transformed into a variable declared like\n-\n-\t\tomp_lock_t gomp_critical_user_<name>\n-\t\t\t__attribute__((common))\n-\n-\tIdeally the ABI would specify that all zero is a valid unlocked\n-\tstate, and so we wouldn't actually need to initialize this at\n-\tstartup.\n-\n-Implementing ATOMIC construct\n-\n-\tThe target should implement the __sync builtins.\n-\n-\tFailing that we could add\n-\n-\tvoid GOMP_atomic_enter (void)\n-\tvoid GOMP_atomic_exit (void)\n-\n-\twhich reuses the regular lock code, but with yet another lock\n-\tobject private to the library.\n-\n-Implementing FLUSH construct\n-\n-\tExpands to the __sync_synchronize builtin.\n-\n-Implementing BARRIER construct\n-\n-\tvoid GOMP_barrier (void)\n-\n-Implementing THREADPRIVATE construct\n-\n-\tIn _most_ cases we can map this directly to __thread.  Except\n-\tthat OMP allows constructors for C++ objects.  We can either\n-\trefuse to support this (how often is it used?) or we can \n-\timplement something akin to .ctors.\n-\n-\tEven more ideally, this ctor feature is handled by extensions\n-\tto the main pthreads library.  Failing that, we can have a set\n-\tof entry points to register ctor functions to be called.\n-\n-Implementing PRIVATE clause\n-\n-\tIn association with a PARALLEL, or within the lexical extent\n-\tof a PARALLEL block, the variable becomes a local variable in\n-\tthe parallel subfunction.\n-\n-\tIn association with FOR or SECTIONS blocks, create a new\n-\tautomatic variable within the current function.  This preserves\n-\tthe semantic of new variable creation.\n-\n-Implementing FIRSTPRIVATE, LASTPRIVATE, COPYIN, COPYPRIVATE clauses\n-\n-\tSeems simple enough for PARALLEL blocks.  Create a private \n-\tstruct for communicating between parent and subfunction.\n-\tIn the parent, copy in values for scalar and \"small\" structs;\n-\tcopy in addresses for others TREE_ADDRESSABLE types.  In the \n-\tsubfunction, copy the value into the local variable.\n-\n-\tNot clear at all what to do with bare FOR or SECTION blocks.\n-\tThe only thing I can figure is that we do something like\n-\n-\n-\t\t#pragma omp for firstprivate(x) lastprivate(y)\n-\t\tfor (int i = 0; i < n; ++i)\n-\t\t  body;\n-\n-\t\t=>\n-\n-\t\t{\n-\t\t  int x = x, y;\n-\n-\t\t  // for stuff\n-\n-\t\t  if (i == n)\n-\t\t    y = y;\n-\t\t}\n-\n-\twhere the \"x=x\" and \"y=y\" assignments actually have different\n-\tuids for the two variables, i.e. not something you could write\n-\tdirectly in C.  Presumably this only makes sense if the \"outer\"\n-\tx and y are global variables.\n-\n-\tCOPYPRIVATE would work the same way, except the structure \n-\tbroadcast would have to happen via SINGLE machinery instead.\n-\n-Implementing REDUCTION clause\n-\n-\tThe private struct mentioned above should have a pointer to\n-\tan array of the type of the variable, indexed by the thread's\n-\tteam_id.  The thread stores its final value into the array,\n-\tand after the barrier the master thread iterates over the\n-\tarray to collect the values.\n-\n-Implementing PARALLEL construct\n-\n-\t#pragma omp parallel\n-\t{\n-\t  body;\n-\t}\n-\n-\t=>\n-\n-\tvoid subfunction (void *data)\n-\t{\n-\t  use data;\n-\t  body;\n-\t}\n-\n-\tsetup data;\n-\tGOMP_parallel_start (subfunction, &data, num_threads);\n-\tsubfunction (&data);\n-\tGOMP_parallel_end ();\n-\n-  void GOMP_parallel_start (void (*fn)(void *), void *data,\n-\t\t\t    unsigned num_threads)\n-\n-\tThe FN argument is the subfunction to be run in parallel.\n-\n-\tThe DATA argument is a pointer to a structure used to \n-\tcommunicate data in and out of the subfunction, as discussed\n-\tabove wrt FIRSTPRIVATE et al.\n-\n-\tThe NUM_THREADS argument is 1 if an IF clause is present\n-\tand false, or the value of the NUM_THREADS clause, if\n-\tpresent, or 0.\n-\n-\tThe function needs to create the appropriate number of\n-\tthreads and/or launch them from the dock.  It needs to\n-\tcreate the team structure and assign team ids.\n-\n-  void GOMP_parallel_end (void)\n-\n-\tTears down the team and return us to the previous\n-\tomp_in_parallel() state.\n-\n-Implementing FOR construct\n-\n-\t#pragma omp parallel for\n-\tfor (i = lb; i <= ub; i++)\n-\t  body;\n-\n-\t=>\n-\n-\tvoid subfunction (void *data)\n-\t{\n-\t  long _s0, _e0;\n-\t  while (GOMP_loop_static_next (&_s0, &_e0))\n-\t    {\n-\t      long _e1 = _e0, i;\n-\t      for (i = _s0; i < _e1; i++)\n-\t\tbody;\n-\t    }\n-\t  GOMP_loop_end_nowait ();\n-\t}\n-\n-\tGOMP_parallel_loop_static (subfunction, NULL, 0, lb, ub+1, 1, 0);\n-\tsubfunction (NULL);\n-\tGOMP_parallel_end ();\n-\n-\t#pragma omp for schedule(runtime)\n-\tfor (i = 0; i < n; i++)\n-\t  body;\n-\n-\t=>\n-\n-\t{\n-\t  long i, _s0, _e0;\n-\t  if (GOMP_loop_runtime_start (0, n, 1, &_s0, &_e0))\n-\t    do {\n-\t      long _e1 = _e0;\n-\t      for (i = _s0, i < _e0; i++)\n-\t        body;\n-\t    } while (GOMP_loop_runtime_next (&_s0, _&e0));\n-\t  GOMP_loop_end ();\n-\t}\n-\n-\tNote that while it looks like there is trickyness to propagating\n-\ta non-constant STEP, there isn't really.  We're explicitly allowed\n-\tto evaluate it as many times as we want, and any variables involved\n-\tshould automatically be handled as PRIVATE or SHARED like any other\n-\tvariables.  So the expression should remain evaluable in the \n-\tsubfunction.  We can also pull it into a local variable if we like,\n-\tbut since its supposed to remain unchanged, we can also not if we like.\n-\n-\tIf we have SCHEDULE(STATIC), and no ORDERED, then we ought to be\n-\table to get away with no work-sharing context at all, since we can\n-\tsimply perform the arithmetic directly in each thread to divide up\n-\tthe iterations.  Which would mean that we wouldn't need to call any\n-\tof these routines.\n-\n-\tThere are separate routines for handling loops with an ORDERED\n-\tclause.  Bookkeeping for that is non-trivial...\n-\n-Implementing ORDERED construct\n-\n-\tvoid GOMP_ordered_start (void)\n-\tvoid GOMP_ordered_end (void)\n-\n-Implementing SECTIONS construct\n-\n-\t#pragma omp sections\n-\t{\n-\t  #pragma omp section\n-\t  stmt1;\n-\t  #pragma omp section\n-\t  stmt2;\n-\t  #pragma omp section\n-\t  stmt3;\n-\t}\n-\n-\t=>\n-\t\n-\tfor (i = GOMP_sections_start (3); i != 0; i = GOMP_sections_next ())\n-\t  switch (i)\n-\t    {\n-\t    case 1:\n-\t      stmt1;\n-\t      break;\n-\t    case 2:\n-\t      stmt2;\n-\t      break;\n-\t    case 3:\n-\t      stmt3;\n-\t      break;\n-\t    }\n-\tGOMP_barrier ();\n-\n-Implementing SINGLE construct\n-\n-\t#pragma omp single\n-\t{\n-\t  body;\n-\t}\n-\n-\t=>\n-\n-\tif (GOMP_single_start ())\n-\t  body;\n-\tGOMP_barrier ();\n-\n-\n-\t#pragma omp single copyprivate(x)\n-\tbody;\n-\n-\t=>\n-\n-\tdatap = GOMP_single_copy_start ();\n-\tif (datap == NULL)\n-\t  {\n-\t    body;\n-\t    data.x = x;\n-\t    GOMP_single_copy_end (&data);\n-\t  }\n-\telse\n-\t  x = datap->x;\n-\tGOMP_barrier ();"}, {"sha": "0f33b00fdcb1b59dcc90eaf2d8be8c86b2e5d235", "filename": "libgomp/config.h.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -78,19 +78,19 @@\n /* Define to the version of this package. */\n #undef PACKAGE_VERSION\n \n-/* The size of a `char', as computed by sizeof. */\n+/* The size of `char', as computed by sizeof. */\n #undef SIZEOF_CHAR\n \n-/* The size of a `int', as computed by sizeof. */\n+/* The size of `int', as computed by sizeof. */\n #undef SIZEOF_INT\n \n-/* The size of a `long', as computed by sizeof. */\n+/* The size of `long', as computed by sizeof. */\n #undef SIZEOF_LONG\n \n-/* The size of a `short', as computed by sizeof. */\n+/* The size of `short', as computed by sizeof. */\n #undef SIZEOF_SHORT\n \n-/* The size of a `void *', as computed by sizeof. */\n+/* The size of `void *', as computed by sizeof. */\n #undef SIZEOF_VOID_P\n \n /* Define to 1 if you have the ANSI C header files. */"}, {"sha": "e42faccc3919cd1300d09d013ec93f5fed0e2dc7", "filename": "libgomp/configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -21,6 +21,20 @@ LIBGOMP_ENABLE(linux-futex, default, ,\n   permit yes|no|default)\n AC_MSG_RESULT($enable_linux_futex)\n \n+# We would like our source tree to be readonly. However when releases or\n+# pre-releases are generated, the flex/bison generated files as well as the\n+# various formats of manuals need to be included along with the rest of the\n+# sources.  Therefore we have --enable-generated-files-in-srcdir to do \n+# just that.\n+AC_MSG_CHECKING([for --enable-generated-files-in-srcdir])\n+LIBGOMP_ENABLE(generated-files-in-srcdir, no, ,\n+   [put copies of generated files in source dir intended for creating source \n+    tarballs for users without texinfo bison or flex.],\n+   permit yes|no)\n+AC_MSG_RESULT($enable_generated_files_in_srcdir)\n+AM_CONDITIONAL(GENINSRC, test \"$enable_generated_files_in_srcdir\" = yes)\n+\n+\n # -------\n # -------\n "}, {"sha": "77cf0942a7f7badee5f62044e1b684bea9f5a8bc", "filename": "libgomp/libgomp.texi", "status": "added", "additions": 1342, "deletions": 0, "changes": 1342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -0,0 +1,1342 @@\n+\\input texinfo @c -*-texinfo-*-\n+\n+@c %**start of header\n+@setfilename libgomp.info\n+@settitle GNU libgomp\n+@c %**end of header\n+\n+\n+@copying\n+Copyright @copyright{} 2006 Free Software Foundation, Inc.\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.1 or\n+any later version published by the Free Software Foundation; with the\n+Invariant Sections being ``GNU General Public License'' and ``Funding\n+Free Software'', the Front-Cover\n+texts being (a) (see below), and with the Back-Cover Texts being (b)\n+(see below).  A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n+\n+(a) The FSF's Front-Cover Text is:\n+\n+     A GNU Manual\n+\n+(b) The FSF's Back-Cover Text is:\n+\n+     You have freedom to copy and modify this GNU Manual, like GNU\n+     software.  Copies published by the Free Software Foundation raise\n+     funds for GNU development.\n+@end copying\n+\n+@ifinfo\n+@dircategory GNU Libraries\n+@direntry\n+* libgomp: (libgomp).                    GNU OpenMP runtime library\n+@end direntry\n+\n+This manual documents the GNU implementation of the OpenMP API for \n+multi-platform shared-memory parallel programming in C/C++ and Fortran.\n+\n+Published by the Free Software Foundation\n+51 Franklin Street, Fifth Floor\n+Boston, MA 02110-1301 USA\n+\n+@insertcopying\n+@end ifinfo\n+\n+\n+@setchapternewpage odd\n+\n+@titlepage\n+@title The GNU OpenMP Implementation\n+@page\n+@vskip 0pt plus 1filll\n+@comment For the @value{version-GCC} Version*\n+@sp 1\n+Published by the Free Software Foundation @*\n+51 Franklin Street, Fifth Floor@*\n+Boston, MA 02110-1301, USA@*\n+@sp 1\n+@insertcopying\n+@end titlepage\n+\n+@summarycontents\n+@contents\n+@page\n+\n+\n+@node Top\n+@top Introduction\n+@cindex Introduction\n+\n+This manual documents the usage of libgomp, the GNU implementation of the \n+@uref{http://www.openmp.org, OpenMP} Application Programming Interface (API)\n+for multi-platform shared-memory parallel programming in C/C++ and Fortran.\n+\n+\n+\n+@comment\n+@comment  When you add a new menu item, please keep the right hand\n+@comment  aligned to the same column.  Do not use tabs.  This provides\n+@comment  better formatting.\n+@comment\n+@menu\n+* Enabling OpenMP::            How to enable OpenMP for your applications.\n+* Runtime Library Routines::   The OpenMP runtime application programming \n+                               interface.\n+* Environment Variables::      Influencing runtime behavior with environment \n+                               variables.\n+* The libgomp ABI::            Notes on the external ABI presented by libgomp.\n+* Reporting Bugs::             How to report bugs in GNU OpenMP.\n+* Copying::                    GNU general public license says\n+                               how you can copy and share libgomp.\n+* GNU Free Documentation License::\n+                               How you can copy and share this manual.\n+* Funding::                    How to help assure continued work for free \n+                               software.\n+* Index::                      Index of this documentation.\n+@end menu\n+\n+\n+@c ---------------------------------------------------------------------\n+@c Enabling OpenMP\n+@c ---------------------------------------------------------------------\n+\n+@node Enabling OpenMP\n+@chapter Enabling OpenMP\n+\n+To activate the OpenMP extensions for C/C++ and Fortran, the compile-time \n+flag @command{-fopenmp} must be specified. This enables the OpenMP directive\n+@code{#pragma omp} in C/C++ and @code{!$omp} directives in free form, \n+@code{c$omp}, @code{*$omp} and @code{!$omp} directives in fixed form, \n+@code{!$} conditional compilation sentinels in free form and @code{c$},\n+@code{*$} and @code{!$} sentinels in fixed form, for Fortran. The flag also\n+arranges for automatic linking of the OpenMP runtime library \n+(@ref{Runtime Library Routines}).\n+\n+A complete description of all OpenMP directives accepted may be found in \n+the @uref{http://www.openmp.org, OpenMP Application Program Interface} manual,\n+version 2.5.\n+\n+\n+@c ---------------------------------------------------------------------\n+@c Runtime Library Routines\n+@c ---------------------------------------------------------------------\n+\n+@node Runtime Library Routines\n+@chapter Runtime Library Routines\n+\n+The runtime routines described here are defined by section 3 of the OpenMP \n+specifications in version 2.5.\n+\n+Control threads, processors and the parallel environment.\n+\n+@menu\n+* omp_get_dynamic::          Dynamic teams setting\n+* omp_get_max_threads::      Maximum number of threads\n+* omp_get_nested::           Nested parallel regions\n+* omp_get_num_procs::        Number of processors online\n+* omp_get_num_threads::      Size of the active team\n+* omp_get_thread_num::       Current thread ID\n+* omp_in_parallel::          Whether a parallel region is active\n+* omp_set_dynamic::          Enable/disable dynamic teams\n+* omp_set_nested::           Enable/disable nested parallel regions\n+* omp_set_num_threads::      Set upper team size limit\n+@end menu\n+\n+Initialize, set, test, unset and destroy simple and nested locks.\n+\n+@menu\n+* omp_init_lock::            Initialize simple lock\n+* omp_set_lock::             Wait for and set simple lock\n+* omp_test_lock::            Test and set simple lock if available\n+* omp_unset_lock::           Unset simple lock\n+* omp_destroy_lock::         Destroy simple lock\n+* omp_init_nest_lock::       Initialize nested lock\n+* omp_set_nest_lock::        Wait for and set simple lock\n+* omp_test_nest_lock::       Test and set nested lock if available\n+* omp_unset_nest_lock::      Unset nested lock\n+* omp_destroy_nest_lock::    Destroy nested lock\n+@end menu\n+\n+Portable, thread-based, wall clock timer.\n+\n+@menu\n+* omp_get_wtick::            Get timer precision.\n+* omp_get_wtime::            Elapsed wall clock time.\n+@end menu\n+\n+@node omp_get_dynamic\n+@section @code{omp_get_dynamic} -- Dynamic teams setting\n+@table @asis\n+@item @emph{Description}:\n+This function returns @code{true} if enabled, @code{false} otherwise. \n+Here, @code{true} and @code{false} represent their language-specific \n+counterparts.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_dynamic();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{logical function omp_get_dynamic()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_set_dynamic}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.8.\n+@end table\n+\n+\n+\n+@node omp_get_max_threads\n+@section @code{omp_get_max_threads} -- Maximum number of threads\n+@table @asis\n+@item @emph{Description}:\n+Return the maximum number of threads used for parallel regions that do\n+not use the clause @code{num_threads}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_max_threads();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_max_threads()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_set_num_threads}, @ref{omp_set_dynamic}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.3.\n+@end table\n+\n+\n+\n+@node omp_get_nested\n+@section @code{omp_get_nested} -- Nested parallel regions\n+@table @asis\n+@item @emph{Description}:\n+This function returns @code{true} if nested parallel regions are\n+enabled, @code{false} otherwise. Here, @code{true} and @code{false} \n+represent their language-specific counterparts.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_nested();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_nested()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_set_nested}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.10.\n+@end table\n+\n+\n+\n+@node omp_get_num_procs\n+@section @code{omp_get_num_procs} -- Number of processors online\n+@table @asis\n+@item @emph{Description}:\n+Returns the number of processors online.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_num_procs();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_num_procs()}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.5.\n+@end table\n+\n+\n+\n+@node omp_get_num_threads\n+@section @code{omp_get_num_threads} -- Size of the active team\n+@table @asis\n+@item @emph{Description}:\n+The number of threads in the current team. In a sequential section of \n+the program @code{omp_get_num_threads} returns 1.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_num_threads();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_num_threads()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_get_max_threads}, @ref{omp_set_num_threads}, @ref{OMP_NUM_THREADS}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.2.\n+@end table\n+\n+\n+\n+@node omp_get_thread_num \n+@section @code{omp_get_thread_num} -- Current thread ID\n+@table @asis\n+@item @emph{Description}:\n+Unique thread identification number. In a sequential parts of the program, \n+@code{omp_get_thread_num} always returns 0. In parallel regions the return\n+value varies from 0 to @code{omp_get_max_threads}-1 inclusive. The return \n+value of the master thread of a team is always 0.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_get_thread_num();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_get_thread_num()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_get_max_threads}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.4.\n+@end table\n+\n+\n+\n+@node omp_in_parallel\n+@section @code{omp_in_parallel} -- Whether a parallel region is active\n+@table @asis\n+@item @emph{Description}:\n+This function returns @code{true} if currently running in parallel, \n+@code{false} otherwise. Here, @code{true} and @code{false} represent \n+their language-specific counterparts.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_in_parallel();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{logical function omp_in_parallel()}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.6.\n+@end table\n+\n+\n+@node omp_set_dynamic\n+@section @code{omp_set_dynamic} -- Enable/disable dynamic teams\n+@table @asis\n+@item @emph{Description}:\n+Enable or disable the dynamic adjustment of the number of threads \n+within a team. The function takes the language-specific equivalent\n+of @code{true} and @code{false}, where @code{true} enables dynamic \n+adjustment of team sizes and @code{false} disables it.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_set_dynamic(set)}\n+@item                   @tab @code{integer, intent(in) :: set}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OMP_DYNAMIC}, @ref{omp_get_dynamic}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.7.\n+@end table\n+\n+\n+\n+@node omp_set_nested\n+@section @code{omp_set_nested} -- Enable/disable nested parallel regions\n+@table @asis\n+@item @emph{Description}:\n+Enable or disable nested parallel regions, i. e. whether team members\n+are allowed to create new teams. The function takes the language-specific \n+equivalent of @code{true} and @code{false}, where @code{true} enables \n+dynamic adjustment of team sizes and @code{false} disables it.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_set_dynamic(set)}\n+@item                   @tab @code{integer, intent(in) :: set}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OMP_NESTED}, @ref{omp_get_nested}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.9.\n+@end table\n+\n+\n+\n+@node omp_set_num_threads\n+@section @code{omp_set_num_threads} -- Set upper team size limit\n+@table @asis\n+@item @emph{Description}:\n+Specifies the number of threads used by default in subsequent parallel \n+sections, if those do not specify a @code{num_threads} clause. The \n+argument of @code{omp_set_num_threads} shall be a positive integer. \n+\n+If the argument is negative integer or zero, the application will crash or\n+stop, respectively. An enhancement request was filed,\n+@uref{http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29949, PR29949}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_set_num_threads(int);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_set_num_threads(set)}\n+@item                   @tab @code{integer, intent(in) :: set}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{OMP_NUM_THREADS}, @ref{omp_get_num_threads}, @ref{omp_get_max_threads}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.2.1.\n+@end table\n+\n+\n+\n+@node omp_init_lock\n+@section @code{omp_init_lock} -- Initialize simple lock\n+@table @asis\n+@item @emph{Description}:\n+Initialize a simple lock. After initialization, the lock is in \n+an unlocked state.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_init_lock(omp_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_init_lock(lock)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_destroy_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.1.\n+@end table\n+\n+\n+\n+@node omp_set_lock\n+@section @code{omp_set_lock} -- Wait for and set simple lock\n+@table @asis\n+@item @emph{Description}:\n+Before setting a simple lock, the lock variable must be initialized by \n+@code{omp_init_lock}. The calling thread is blocked until the lock \n+is available. If the lock is already held by the current thread, \n+a deadlock occurs.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_set_lock(omp_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_set_lock(lock)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_init_lock}, @ref{omp_test_lock}, @ref{omp_unset_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.3.\n+@end table\n+\n+\n+\n+@node omp_test_lock\n+@section @code{omp_test_lock} -- Test and set simple lock if available\n+@table @asis\n+@item @emph{Description}:\n+Before setting a simple lock, the lock variable must be initialized by \n+@code{omp_init_lock}. Contrary to @code{omp_set_lock}, @code{omp_test_lock} \n+does not block if the lock is not available. This function returns \n+@code{true} upon success,@code{false} otherwise. Here, @code{true} and \n+@code{false} represent their language-specific counterparts.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_test_lock(omp_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_test_lock(lock)}\n+@item                   @tab @code{logical(omp_logical_kind) :: omp_test_lock}\n+@item                   @tab @code{integer(omp_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_init_lock}, @ref{omp_set_lock}, @ref{omp_set_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.5.\n+@end table\n+\n+\n+\n+@node omp_unset_lock\n+@section @code{omp_unset_lock} -- Unset simple lock\n+@table @asis\n+@item @emph{Description}:\n+A simple lock about to be unset must have been locked by @code{omp_set_lock}\n+or @code{omp_test_lock} before. In addition, the lock must be held by the \n+thread calling @code{omp_unset_lock}. Then, the lock becomes unlocked. If one \n+ore more threads attempted to set the lock before, one of them is chosen to, \n+again, set the lock for itself.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_unset_lock(omp_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_unset_lock(lock)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_set_lock}, @ref{omp_test_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.4.\n+@end table\n+\n+\n+\n+@node omp_destroy_lock\n+@section @code{omp_destroy_lock} -- Destroy simple lock\n+@table @asis\n+@item @emph{Description}:\n+Destroy a simple lock. In order to be destroyed, a simple lock must be \n+in the unlocked state. \n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_destroy_lock(omp_lock_t *);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_destroy_lock(lock)}\n+@item                   @tab @code{integer(omp_lock_kind), intent(inout) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_init_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.2.\n+@end table\n+\n+\n+\n+@node omp_init_nest_lock\n+@section @code{omp_init_nest_lock} -- Initialize nested lock\n+@table @asis\n+@item @emph{Description}:\n+Initialize a nested lock. After initialization, the lock is in \n+an unlocked state and the nesting count is set to zero.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_init_nest_lock(omp_nest_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_init_nest_lock(lock)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_destroy_nest_lock}\n+\n+@item @emph{Reference}:\n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.1.\n+@end table\n+\n+\n+@node omp_set_nest_lock\n+@section @code{omp_set_nest_lock} -- Wait for and set simple lock\n+@table @asis\n+@item @emph{Description}:\n+Before setting a nested lock, the lock variable must be initialized by \n+@code{omp_init_nest_lock}. The calling thread is blocked until the lock \n+is available. If the lock is already held by the current thread, the \n+nesting count for the lock in incremented.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_set_nest_lock(omp_nest_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_set_nest_lock(lock)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_init_nest_lock}, @ref{omp_unset_nest_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.3.\n+@end table\n+\n+\n+\n+@node omp_test_nest_lock\n+@section @code{omp_test_nest_lock} -- Test and set nested lock if available\n+@table @asis\n+@item @emph{Description}:\n+Before setting a nested lock, the lock variable must be initialized by \n+@code{omp_init_nest_lock}. Contrary to @code{omp_set_nest_lock}, \n+@code{omp_test_nest_lock} does not block if the lock is not available. \n+If the lock is already held by the current thread, the new nesting count \n+is returned. Otherwise, the return value equals zero.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int omp_test_nest_lock(omp_nest_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function omp_test_nest_lock(lock)}\n+@item                   @tab @code{integer(omp_integer_kind) :: omp_test_nest_lock}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@end multitable\n+\n+\n+@item @emph{See also}:\n+@ref{omp_init_lock}, @ref{omp_set_lock}, @ref{omp_set_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.5.\n+@end table\n+\n+\n+\n+@node omp_unset_nest_lock\n+@section @code{omp_unset_nest_lock} -- Unset nested lock\n+@table @asis\n+@item @emph{Description}:\n+A nested lock about to be unset must have been locked by @code{omp_set_nested_lock}\n+or @code{omp_test_nested_lock} before. In addition, the lock must be held by the \n+thread calling @code{omp_unset_nested_lock}. If the nesting count drops to zero, the \n+lock becomes unlocked. If one ore more threads attempted to set the lock before, \n+one of them is chosen to, again, set the lock for itself.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_unset_nest_lock(omp_nest_lock_t *lock);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_unset_nest_lock(lock)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(out) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_set_nest_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.4.\n+@end table\n+\n+\n+\n+@node omp_destroy_nest_lock\n+@section @code{omp_destroy_nest_lock} -- Destroy nested lock\n+@table @asis\n+@item @emph{Description}:\n+Destroy a nested lock. In order to be destroyed, a nested lock must be \n+in the unlocked state and its nesting count must equal zero.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void omp_destroy_nest_lock(omp_nest_lock_t *);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine omp_destroy_nest_lock(lock)}\n+@item                   @tab @code{integer(omp_nest_lock_kind), intent(inout) :: lock}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_init_lock}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.3.2.\n+@end table\n+\n+\n+\n+@node omp_get_wtick\n+@section @code{omp_get_wtick} -- Get timer precision\n+@table @asis\n+@item @emph{Description}:\n+Gets the timer precision, i. e. the number of seconds between two \n+successive clock ticks.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{double omp_get_wtick();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{double precision function omp_get_wtick()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_get_wtime}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.4.2.\n+@end table\n+\n+\n+\n+@node omp_get_wtime\n+@section @code{omp_get_wtime} -- Elapsed wall clock time\n+@table @asis\n+@item @emph{Description}:\n+Elapsed wall clock time in seconds. The time is measured per thread, no \n+guarantee can bee made that two distinct threads measure the same time.\n+Time is measured from some \"time in the past\". On POSIX compliant systems \n+the seconds since the Epoch (00:00:00 UTC, January 1, 1970) are returned.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{double omp_get_wtime();}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{double precision function omp_get_wtime()}\n+@end multitable\n+\n+@item @emph{See also}:\n+@ref{omp_get_wtick}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 3.4.1.\n+@end table\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c Environment Variables\n+@c ---------------------------------------------------------------------\n+\n+@node Environment Variables\n+@chapter Environment Variables\n+\n+The variables @env{OMP_DYNAMIC}, @env{OMP_NESTED}, @env{OMP_NUM_THREADS} and \n+@env{OMP_SCHEDULE} are defined by section 4 of the OpenMP specifications in \n+version 2.5, while @env{GOMP_CPU_AFFINITY} and @env{GOMP_STACKSIZE} are GNU \n+extensions.\n+\n+@menu\n+* OMP_DYNAMIC::        Dynamic adjustment of threads\n+* OMP_NESTED::         Nested parallel regions\n+* OMP_NUM_THREADS::    Specifies the number of threads to use\n+* OMP_SCHEDULE::       How threads are scheduled\n+* GOMP_CPU_AFFINITY::  Bind threads to specific CPUs\n+* GOMP_STACKSIZE::     Set default thread stack size\n+@end menu\n+\n+\n+@node OMP_DYNAMIC\n+@section @env{OMP_DYNAMIC} -- Dynamic adjustment of threads\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Enable or disable the dynamic adjustment of the number of threads \n+within a team. The value of this environment variable shall be \n+@code{TRUE} or @code{FALSE}.\n+\n+@item @emph{See also}:\n+@ref{omp_set_dynamic}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 4.3\n+@end table\n+\n+\n+\n+@node OMP_NESTED\n+@section @env{OMP_NESTED} -- Nested parallel regions\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Enable or disable nested parallel regions, i. e. whether team members\n+are allowed to create new teams. The value of this environment variable \n+shall be @code{TRUE} or @code{FALSE}.\n+\n+@item @emph{See also}:\n+@ref{omp_set_nested}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 4.4\n+@end table\n+\n+\n+\n+@node OMP_NUM_THREADS\n+@section @env{OMP_NUM_THREADS} -- Specifies the number of threads to use\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Specifies the number of threads to use in parallel regions. If undefined\n+one thread per CPU online is used. The value of this variable shall be \n+positive integer. \n+\n+@item @emph{See also}:\n+@ref{omp_set_num_threads}\n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 4.2\n+@end table\n+\n+\n+\n+@node OMP_SCHEDULE\n+@section @env{OMP_SCHEDULE} -- How threads are scheduled\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Allows to specify @code{schedule type} and @code{chunk size}. \n+The value of the variable shall have the form: @code{type[,chunk]} where\n+@code{type} is one of @code{static}, @code{dynamic} or @code{guided}. \n+The optional @code{chunk size} shall be a positive integer. \n+\n+@item @emph{Reference}: \n+@uref{http://www.openmp.org/, OpenMP specifications v2.5}, section 4.1\n+@end table\n+\n+\n+\n+@node GOMP_CPU_AFFINITY\n+@section @env{GOMP_CPU_AFFINITY} -- Bind threads to specific CPUs\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+A patch for this extension has been submitted, but was not yet applied at the\n+time of writing.\n+\n+@item @emph{Reference}: \n+@uref{http://gcc.gnu.org/ml/gcc-patches/2006-05/msg00982.html, \n+GCC Patches Mailinglist}\n+@uref{http://gcc.gnu.org/ml/gcc-patches/2006-05/msg01133.html,\n+GCC Patches Mailinglist}\n+@end table\n+\n+\n+\n+@node GOMP_STACKSIZE\n+@section @env{GOMP_STACKSIZE} -- Set default thread stack size\n+@cindex Environment Variable\n+@table @asis\n+@item @emph{Description}:\n+Set the default thread stack size in kilobytes. This is in opposition \n+to @code{pthread_attr_setstacksize} which gets the number of bytes as an \n+argument. If the stacksize can not be set due to system constraints, an \n+error is reported and the initial stacksize is left unchanged.\n+\n+@item @emph{Reference}: \n+@uref{http://gcc.gnu.org/ml/gcc-patches/2006-06/msg00493.html, \n+GCC Patches Mailinglist}, \n+@uref{http://gcc.gnu.org/ml/gcc-patches/2006-06/msg00496.html,\n+GCC Patches Mailinglist}\n+@end table\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c The libgomp ABI\n+@c ---------------------------------------------------------------------\n+\n+@node The libgomp ABI\n+@chapter The libgomp ABI\n+\n+The following sections present notes on the external ABI as \n+presented by libgomp. Only maintainers should need them.\n+\n+@menu\n+* Implementing MASTER construct::\n+* Implementing CRITICAL construct::\n+* Implementing ATOMIC construct::\n+* Implementing FLUSH construct::\n+* Implementing BARRIER construct::\n+* Implementing THREADPRIVATE construct::\n+* Implementing PRIVATE clause::\n+* Implementing FIRSTPRIVATE LASTPRIVATE COPYIN and COPYPRIVATE clauses::\n+* Implementing REDUCTION clause::\n+* Implementing PARALLEL construct::\n+* Implementing FOR construct::\n+* Implementing ORDERED construct::\n+* Implementing SECTIONS construct::\n+* Implementing SINGLE construct::\n+@end menu\n+\n+\n+@node Implementing MASTER construct\n+@section Implementing MASTER construct\n+\n+@smallexample\n+if (omp_get_thread_num () == 0)\n+  block\n+@end smallexample\n+\n+Alternately, we generate two copies of the parallel subfunction\n+and only include this in the version run by the master thread.\n+Surely that's not worthwhile though...\n+\n+\n+\n+@node Implementing CRITICAL construct\n+@section Implementing CRITICAL construct\n+\n+Without a specified name,\n+\n+@smallexample\n+  void GOMP_critical_start (void);\n+  void GOMP_critical_end (void);\n+@end smallexample\n+\n+so that we don't get COPY relocations from libgomp to the main\n+application.\n+\n+With a specified name, use omp_set_lock and omp_unset_lock with\n+name being transformed into a variable declared like\n+\n+@smallexample\n+  omp_lock_t gomp_critical_user_<name> __attribute__((common))\n+@end smallexample\n+\n+Ideally the ABI would specify that all zero is a valid unlocked\n+state, and so we wouldn't actually need to initialize this at\n+startup.\n+\n+\n+\n+@node Implementing ATOMIC construct\n+@section Implementing ATOMIC construct\n+\n+The target should implement the @code{__sync} builtins.\n+\n+Failing that we could add\n+\n+@smallexample\n+  void GOMP_atomic_enter (void)\n+  void GOMP_atomic_exit (void)\n+@end smallexample\n+\n+which reuses the regular lock code, but with yet another lock\n+object private to the library.\n+\n+\n+\n+@node Implementing FLUSH construct\n+@section Implementing FLUSH construct\n+\n+Expands to the @code{__sync_synchronize} builtin.\n+\n+\n+\n+@node Implementing BARRIER construct\n+@section Implementing BARRIER construct\n+\n+@smallexample\n+  void GOMP_barrier (void)\n+@end smallexample\n+\n+\n+@node Implementing THREADPRIVATE construct\n+@section Implementing THREADPRIVATE construct\n+\n+In _most_ cases we can map this directly to @code{__thread}.  Except\n+that OMP allows constructors for C++ objects.  We can either\n+refuse to support this (how often is it used?) or we can \n+implement something akin to .ctors.\n+\n+Even more ideally, this ctor feature is handled by extensions\n+to the main pthreads library.  Failing that, we can have a set\n+of entry points to register ctor functions to be called.\n+\n+\n+\n+@node Implementing PRIVATE clause\n+@section Implementing PRIVATE clause\n+\n+In association with a PARALLEL, or within the lexical extent\n+of a PARALLEL block, the variable becomes a local variable in\n+the parallel subfunction.\n+\n+In association with FOR or SECTIONS blocks, create a new\n+automatic variable within the current function.  This preserves\n+the semantic of new variable creation.\n+\n+\n+\n+@node Implementing FIRSTPRIVATE LASTPRIVATE COPYIN and COPYPRIVATE clauses\n+@section Implementing FIRSTPRIVATE LASTPRIVATE COPYIN and COPYPRIVATE clauses\n+\n+Seems simple enough for PARALLEL blocks.  Create a private \n+struct for communicating between parent and subfunction.\n+In the parent, copy in values for scalar and \"small\" structs;\n+copy in addresses for others TREE_ADDRESSABLE types.  In the \n+subfunction, copy the value into the local variable.\n+\n+Not clear at all what to do with bare FOR or SECTION blocks.\n+The only thing I can figure is that we do something like\n+\n+@smallexample\n+#pragma omp for firstprivate(x) lastprivate(y)\n+for (int i = 0; i < n; ++i)\n+  body;\n+@end smallexample\n+\n+which becomes\n+\n+@smallexample\n+@{\n+  int x = x, y;\n+\n+  // for stuff\n+\n+  if (i == n)\n+    y = y;\n+@}\n+@end smallexample\n+\n+where the \"x=x\" and \"y=y\" assignments actually have different\n+uids for the two variables, i.e. not something you could write\n+directly in C.  Presumably this only makes sense if the \"outer\"\n+x and y are global variables.\n+\n+COPYPRIVATE would work the same way, except the structure \n+broadcast would have to happen via SINGLE machinery instead.\n+\n+\n+\n+@node Implementing REDUCTION clause\n+@section Implementing REDUCTION clause\n+\n+The private struct mentioned in the previous section should have \n+a pointer to an array of the type of the variable, indexed by the \n+thread's @var{team_id}.  The thread stores its final value into the \n+array, and after the barrier the master thread iterates over the\n+array to collect the values.\n+\n+\n+@node Implementing PARALLEL construct\n+@section Implementing PARALLEL construct\n+\n+@smallexample\n+  #pragma omp parallel\n+  @{\n+    body;\n+  @}\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  void subfunction (void *data)\n+  @{\n+    use data;\n+    body;\n+  @}\n+\n+  setup data;\n+  GOMP_parallel_start (subfunction, &data, num_threads);\n+  subfunction (&data);\n+  GOMP_parallel_end ();\n+@end smallexample\n+\n+@smallexample\n+  void GOMP_parallel_start (void (*fn)(void *), void *data, unsigned num_threads)\n+@end smallexample\n+\n+The @var{FN} argument is the subfunction to be run in parallel.\n+\n+The @var{DATA} argument is a pointer to a structure used to \n+communicate data in and out of the subfunction, as discussed\n+above wrt FIRSTPRIVATE et al.\n+\n+The @var{NUM_THREADS} argument is 1 if an IF clause is present\n+and false, or the value of the NUM_THREADS clause, if\n+present, or 0.\n+\n+The function needs to create the appropriate number of\n+threads and/or launch them from the dock.  It needs to\n+create the team structure and assign team ids.\n+\n+@smallexample\n+  void GOMP_parallel_end (void)\n+@end smallexample\n+\n+Tears down the team and returns us to the previous @code{omp_in_parallel()} state.\n+\n+\n+\n+@node Implementing FOR construct\n+@section Implementing FOR construct\n+\n+@smallexample\n+  #pragma omp parallel for\n+  for (i = lb; i <= ub; i++)\n+    body;\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  void subfunction (void *data)\n+  @{\n+    long _s0, _e0;\n+    while (GOMP_loop_static_next (&_s0, &_e0))\n+    @{\n+      long _e1 = _e0, i;\n+      for (i = _s0; i < _e1; i++)\n+        body;\n+    @}\n+    GOMP_loop_end_nowait ();\n+  @}\n+\n+  GOMP_parallel_loop_static (subfunction, NULL, 0, lb, ub+1, 1, 0);\n+  subfunction (NULL);\n+  GOMP_parallel_end ();\n+@end smallexample\n+\n+@smallexample\n+  #pragma omp for schedule(runtime)\n+  for (i = 0; i < n; i++)\n+    body;\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  @{\n+    long i, _s0, _e0;\n+    if (GOMP_loop_runtime_start (0, n, 1, &_s0, &_e0))\n+      do @{\n+        long _e1 = _e0;\n+        for (i = _s0, i < _e0; i++)\n+          body;\n+      @} while (GOMP_loop_runtime_next (&_s0, _&e0));\n+    GOMP_loop_end ();\n+  @}\n+@end smallexample\n+\n+Note that while it looks like there is trickyness to propagating\n+a non-constant STEP, there isn't really.  We're explicitly allowed\n+to evaluate it as many times as we want, and any variables involved\n+should automatically be handled as PRIVATE or SHARED like any other\n+variables.  So the expression should remain evaluable in the \n+subfunction.  We can also pull it into a local variable if we like,\n+but since its supposed to remain unchanged, we can also not if we like.\n+\n+If we have SCHEDULE(STATIC), and no ORDERED, then we ought to be\n+able to get away with no work-sharing context at all, since we can\n+simply perform the arithmetic directly in each thread to divide up\n+the iterations.  Which would mean that we wouldn't need to call any\n+of these routines.\n+\n+There are separate routines for handling loops with an ORDERED\n+clause.  Bookkeeping for that is non-trivial...\n+\n+\n+\n+@node Implementing ORDERED construct\n+@section Implementing ORDERED construct\n+\n+@smallexample\n+  void GOMP_ordered_start (void)\n+  void GOMP_ordered_end (void)\n+@end smallexample\n+\n+\n+\n+@node Implementing SECTIONS construct\n+@section Implementing SECTIONS construct\n+\n+A block as \n+\n+@smallexample\n+  #pragma omp sections\n+  @{\n+    #pragma omp section\n+    stmt1;\n+    #pragma omp section\n+    stmt2;\n+    #pragma omp section\n+    stmt3;\n+  @}\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  for (i = GOMP_sections_start (3); i != 0; i = GOMP_sections_next ())\n+    switch (i)\n+      @{\n+      case 1:\n+        stmt1;\n+        break;\n+      case 2:\n+        stmt2;\n+        break;\n+      case 3:\n+        stmt3;\n+        break;\n+      @}\n+  GOMP_barrier ();\n+@end smallexample\n+\n+\n+@node Implementing SINGLE construct\n+@section Implementing SINGLE construct\n+\n+A block like \n+\n+@smallexample\n+  #pragma omp single\n+  @{\n+    body;\n+  @}\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  if (GOMP_single_start ())\n+    body;\n+  GOMP_barrier ();\n+@end smallexample\n+\n+while \n+\n+@smallexample\n+  #pragma omp single copyprivate(x)\n+    body;\n+@end smallexample\n+\n+becomes\n+\n+@smallexample\n+  datap = GOMP_single_copy_start ();\n+  if (datap == NULL)\n+    @{\n+      body;\n+      data.x = x;\n+      GOMP_single_copy_end (&data);\n+    @}\n+  else\n+    x = datap->x;\n+  GOMP_barrier ();\n+@end smallexample\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c \n+@c ---------------------------------------------------------------------\n+\n+@node Reporting Bugs\n+@chapter Reporting Bugs\n+\n+Bugs in the GNU OpenMP implementation should be reported via \n+@uref{http://gcc.gnu.org/bugzilla/, bugzilla}. In all cases, please add \n+\"openmp\" to the keywords field in the bug report.\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c GNU General Public License\n+@c ---------------------------------------------------------------------\n+\n+@include gpl.texi\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c GNU Free Documentation License\n+@c ---------------------------------------------------------------------\n+\n+@include fdl.texi\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c Funding Free Software\n+@c ---------------------------------------------------------------------\n+\n+@include funding.texi\n+\n+@c ---------------------------------------------------------------------\n+@c Index\n+@c ---------------------------------------------------------------------\n+\n+@node Index\n+@unnumbered Index\n+\n+@printindex cp\n+\n+@bye"}, {"sha": "df20ea48da321a46262229094ae48d2f4a646341", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3721b9e1ee8b73b2e299fb2ce80568a35578e728/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=3721b9e1ee8b73b2e299fb2ce80568a35578e728", "patch": "@@ -42,6 +42,7 @@ ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n \t$(top_srcdir)/../config/enable.m4 \\\n \t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n \t$(top_srcdir)/../config/stdint.m4 \\\n \t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/acinclude.m4 \\\n \t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n@@ -79,6 +80,9 @@ EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n FC = @FC@\n FCFLAGS = @FCFLAGS@\n+GENINSRC_FALSE = @GENINSRC_FALSE@\n+GENINSRC_TRUE = @GENINSRC_TRUE@\n+GREP = @GREP@\n INSTALL_DATA = @INSTALL_DATA@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_SCRIPT = @INSTALL_SCRIPT@\n@@ -121,11 +125,8 @@ USE_FORTRAN_TRUE = @USE_FORTRAN_TRUE@\n VERSION = @VERSION@\n XCFLAGS = @XCFLAGS@\n XLDFLAGS = @XLDFLAGS@\n-ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_FC = @ac_ct_FC@\n-ac_ct_RANLIB = @ac_ct_RANLIB@\n-ac_ct_STRIP = @ac_ct_STRIP@\n am__fastdepCC_FALSE = @am__fastdepCC_FALSE@\n am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n am__include = @am__include@\n@@ -141,6 +142,9 @@ build_os = @build_os@\n build_vendor = @build_vendor@\n config_path = @config_path@\n datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n enable_shared = @enable_shared@\n enable_static = @enable_static@\n exec_prefix = @exec_prefix@\n@@ -149,20 +153,24 @@ host_alias = @host_alias@\n host_cpu = @host_cpu@\n host_os = @host_os@\n host_vendor = @host_vendor@\n+htmldir = @htmldir@\n includedir = @includedir@\n infodir = @infodir@\n install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n libtool_VERSION = @libtool_VERSION@\n link_gomp = @link_gomp@\n+localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n mkdir_p = @mkdir_p@\n multi_basedir = @multi_basedir@\n oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n prefix = @prefix@\n program_transform_name = @program_transform_name@\n+psdir = @psdir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n sysconfdir = @sysconfdir@"}]}