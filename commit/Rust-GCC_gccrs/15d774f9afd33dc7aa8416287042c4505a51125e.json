{"sha": "15d774f9afd33dc7aa8416287042c4505a51125e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkNzc0ZjlhZmQzM2RjN2FhODQxNjI4NzA0MmM0NTA1YTUxMTI1ZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-06-06T02:04:04Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-06-06T02:04:04Z"}, "message": "re PR fortran/43945 ([OOP] Derived type with GENERIC: resolved to the wrong specific TBP)\n\n2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n\t    Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/43945\n\t* resolve.c (get_declared_from_expr): Move to before\n\tresolve_typebound_generic_call.  Make new_ref and class_ref\n\tignorable if set to NULL.\n\t(resolve_typebound_generic_call): Once we have resolved the\n\tgeneric call, check that the specific instance is that which\n\tis bound to the declared type.\n\t(resolve_typebound_function,resolve_typebound_subroutine): Avoid\n\tfreeing 'class_ref->next' twice.\n\n\n2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43945\n\t* gfortran.dg/generic_23.f03: New test.\n\nCo-Authored-By: Janus Weil <janus@gcc.gnu.org>\n\nFrom-SVN: r160335", "tree": {"sha": "3ac06ccabe555ccafd68cc9dee3337b2822206ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ac06ccabe555ccafd68cc9dee3337b2822206ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15d774f9afd33dc7aa8416287042c4505a51125e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d774f9afd33dc7aa8416287042c4505a51125e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15d774f9afd33dc7aa8416287042c4505a51125e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15d774f9afd33dc7aa8416287042c4505a51125e/comments", "author": null, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be69e91b791430f1263c2817b250207e7768b74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be69e91b791430f1263c2817b250207e7768b74a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be69e91b791430f1263c2817b250207e7768b74a"}], "stats": {"total": 183, "additions": 141, "deletions": 42}, "files": [{"sha": "9b517100fafa30ba15275bab0f459415a4416dfe", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=15d774f9afd33dc7aa8416287042c4505a51125e", "patch": "@@ -1,3 +1,16 @@\n+2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/43945\n+\t* resolve.c (get_declared_from_expr): Move to before\n+\tresolve_typebound_generic_call.  Make new_ref and class_ref\n+\tignorable if set to NULL.\n+\t(resolve_typebound_generic_call): Once we have resolved the\n+\tgeneric call, check that the specific instance is that which\n+\tis bound to the declared type.\n+\t(resolve_typebound_function,resolve_typebound_subroutine): Avoid\n+\tfreeing 'class_ref->next' twice.\n+\n 2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/43895"}, {"sha": "7e5a4f9577372b30a6ab9863262b77de94dc710d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=15d774f9afd33dc7aa8416287042c4505a51125e", "patch": "@@ -5160,6 +5160,43 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n }\n \n \n+/* Get the ultimate declared type from an expression.  In addition,\n+   return the last class/derived type reference and the copy of the\n+   reference list.  */\n+static gfc_symbol*\n+get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n+\t\t\tgfc_expr *e)\n+{\n+  gfc_symbol *declared;\n+  gfc_ref *ref;\n+\n+  declared = NULL;\n+  if (class_ref)\n+    *class_ref = NULL;\n+  if (new_ref)\n+    *new_ref = gfc_copy_ref (e->ref);\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type != REF_COMPONENT)\n+\tcontinue;\n+\n+      if (ref->u.c.component->ts.type == BT_CLASS\n+\t    || ref->u.c.component->ts.type == BT_DERIVED)\n+\t{\n+\t  declared = ref->u.c.component->ts.u.derived;\n+\t  if (class_ref)\n+\t    *class_ref = ref;\n+\t}\n+    }\n+\n+  if (declared == NULL)\n+    declared = e->symtree->n.sym->ts.u.derived;\n+\n+  return declared;\n+}\n+\n+\n /* Given an EXPR_COMPCALL calling a GENERIC typebound procedure, figure out\n    which of the specific bindings (if any) matches the arglist and transform\n    the expression into a call of that binding.  */\n@@ -5169,6 +5206,8 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n {\n   gfc_typebound_proc* genproc;\n   const char* genname;\n+  gfc_symtree *st;\n+  gfc_symbol *derived;\n \n   gcc_assert (e->expr_type == EXPR_COMPCALL);\n   genname = e->value.compcall.name;\n@@ -5236,6 +5275,19 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n   return FAILURE;\n \n success:\n+  /* Make sure that we have the right specific instance for the name.  */\n+  genname = e->value.compcall.tbp->u.specific->name;\n+\n+  /* Is the symtree name a \"unique name\".  */\n+  if (*genname == '@')\n+    genname = e->value.compcall.tbp->u.specific->n.sym->name;\n+\n+  derived = get_declared_from_expr (NULL, NULL, e);\n+\n+  st = gfc_find_typebound_proc (derived, NULL, genname, false, &e->where);\n+  if (st)\n+    e->value.compcall.tbp = st->n.tb;\n+\n   return SUCCESS;\n }\n \n@@ -5343,38 +5395,6 @@ resolve_compcall (gfc_expr* e, const char **name)\n }\n \n \n-/* Get the ultimate declared type from an expression.  In addition,\n-   return the last class/derived type reference and the copy of the\n-   reference list.  */\n-static gfc_symbol*\n-get_declared_from_expr (gfc_ref **class_ref, gfc_ref **new_ref,\n-\t\t\tgfc_expr *e)\n-{\n-  gfc_symbol *declared;\n-  gfc_ref *ref;\n-\n-  declared = NULL;\n-  *class_ref = NULL;\n-  *new_ref = gfc_copy_ref (e->ref);\n-  for (ref = *new_ref; ref; ref = ref->next)\n-    {\n-      if (ref->type != REF_COMPONENT)\n-\tcontinue;\n-\n-      if (ref->u.c.component->ts.type == BT_CLASS\n-\t    || ref->u.c.component->ts.type == BT_DERIVED)\n-\t{\n-\t  declared = ref->u.c.component->ts.u.derived;\n-\t  *class_ref = ref;\n-\t}\n-    }\n-\n-  if (declared == NULL)\n-    declared = e->symtree->n.sym->ts.u.derived;\n-\n-  return declared;\n-}\n-\n \n /* Resolve a typebound function, or 'method'. First separate all\n    the non-CLASS references by calling resolve_compcall directly.  */\n@@ -5423,11 +5443,8 @@ resolve_typebound_function (gfc_expr* e)\n   e->value.function.esym = NULL;\n   e->symtree = st;\n \n-  if (class_ref)  \n-    {\n-      gfc_free_ref_list (class_ref->next);\n-      e->ref = new_ref;\n-    }\n+  if (new_ref)  \n+    e->ref = new_ref;\n \n   /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n   gfc_add_component_ref (e, \"$vptr\");\n@@ -5496,11 +5513,8 @@ resolve_typebound_subroutine (gfc_code *code)\n   code->expr1->value.function.esym = NULL;\n   code->expr1->symtree = st;\n \n-  if (class_ref)  \n-    {\n-      gfc_free_ref_list (class_ref->next);\n-      code->expr1->ref = new_ref;\n-    }\n+  if (new_ref)\n+    code->expr1->ref = new_ref;\n \n   /* '$vptr' points to the vtab, which contains the procedure pointers.  */\n   gfc_add_component_ref (code->expr1, \"$vptr\");"}, {"sha": "e84da1929d9ead97326185602d4e053ec96c0893", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15d774f9afd33dc7aa8416287042c4505a51125e", "patch": "@@ -1,3 +1,8 @@\n+2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43945\n+\t* gfortran.dg/generic_23.f03: New test.\n+\n 2010-06-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/43895"}, {"sha": "eab185b483dc79b37a57639966308c65d21ff0a1", "filename": "gcc/testsuite/gfortran.dg/generic_23.f03", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_23.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15d774f9afd33dc7aa8416287042c4505a51125e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_23.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_23.f03?ref=15d774f9afd33dc7aa8416287042c4505a51125e", "patch": "@@ -0,0 +1,67 @@\n+! { dg-do run }\n+! Test the fix for PR43945 in which the over-ridding of 'doit' and\n+! 'getit' in type 'foo2' was missed in the specific binding to 'do' and 'get'.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+! and reported to clf by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+module foo_mod\n+  type foo\n+    integer :: i\n+  contains\n+    procedure, pass(a) :: doit\n+    procedure, pass(a) :: getit\n+    generic, public :: do  => doit\n+    generic, public :: get => getit\n+  end type foo\n+  private doit,getit\n+contains\n+  subroutine  doit(a)\n+    class(foo) :: a\n+    a%i = 1\n+    write(*,*) 'FOO%DOIT base version'\n+  end subroutine doit\n+  function getit(a) result(res)\n+    class(foo) :: a\n+    integer :: res\n+    res = a%i\n+  end function getit\n+end module foo_mod\n+\n+module foo2_mod\n+  use foo_mod\n+  type, extends(foo) :: foo2\n+    integer :: j\n+  contains\n+    procedure, pass(a) :: doit  => doit2\n+    procedure, pass(a) :: getit => getit2\n+!!$    generic, public :: do  => doit\n+!!$    generic, public :: get => getit\n+  end type foo2\n+  private doit2, getit2\n+\n+contains\n+\n+  subroutine  doit2(a)\n+    class(foo2) :: a\n+    a%i = 2\n+    a%j = 3\n+  end subroutine doit2\n+  function getit2(a) result(res)\n+    class(foo2) :: a\n+    integer :: res\n+    res = a%j\n+  end function getit2\n+end module foo2_mod\n+\n+program testd15\n+  use foo2_mod\n+  type(foo2) :: af2\n+\n+  call af2%do()\n+  if (af2%i .ne. 2) call abort\n+  if (af2%get() .ne. 3) call abort\n+\n+end program testd15\n+\n+! { dg-final { cleanup-modules \"foo_mod foo2_mod\" } }"}]}