{"sha": "5d709b0013a3d180de93f3349233637c281215b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3MDliMDAxM2EzZDE4MGRlOTNmMzM0OTIzMzYzN2MyODEyMTViMg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-09-10T23:56:31Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-09-10T23:56:31Z"}, "message": "c-common.h (struct c_fileinfo): Comment moved here from cp-tree.h.\n\n\t* c-common.h (struct c_fileinfo): Comment moved here from cp-tree.h.\n\t(extract_interface_info): Delete prototype.\n\t* c-decl.c (extract_interface_info): Delete stub.\n\t* c-lex.c (get_fileinfo): Initialize file_info_tree here, if\n\tit's not already been done ...\n\t(init_c_lex): ... not here.\n\t(fe_file_change): Don't call extract_interface_info.\ncp:\n\t* cp-tree.h (interface_only, interface_unknown): Delete declarations;\n\tcomment explaining them moved to c-common.h.\n\t* lex.c (interface_only, interface_unknown, extract_interface_info):\n\tDelete definitions.\n\t(cxx_finish): Don't reset interface_unknown.\n\t(handle_pragma_interface): Don't set interface_only and\n\tinterface_unknown; just the like-named fields in finfo.\n\t(handle_pragma_implementation): Adjust comment.\n\t* decl2.c (cp_finish_file): Don't reset interface_only and\n\tinterface_unknown.\n\t* method.c (synthesize_method): Don't reset interface_unknown or\n\tcall extract_interface_info.\n\t* pt.c (pop_tinst_level): Don't call extract_interface_info.\n\t* decl.c (start_cleanup_fn): Don't save or restore interface_only\n\tand interface_unknown.\n\t(make_rtl_for_nonlocal_decl): Call get_fileinfo on input_filename\n\tand use the result instead of the interface_only/interface_unknown\n\tglobals.\n\t(start_preparsed_function): Likewise.\n\t* lex.c (cxx_make_type): Likewise.\n\t* semantics.c (begin_class_definition): Likewise.\n\t(expand_body): Don't call extract_interface_info.\n\nFrom-SVN: r87329", "tree": {"sha": "3e13669d72ea210ff0fa0fd5c941453f47b0432e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e13669d72ea210ff0fa0fd5c941453f47b0432e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d709b0013a3d180de93f3349233637c281215b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d709b0013a3d180de93f3349233637c281215b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d709b0013a3d180de93f3349233637c281215b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d709b0013a3d180de93f3349233637c281215b2/comments", "author": null, "committer": null, "parents": [{"sha": "616aeba2bb37e55c24cc65a861e12c08e18e3943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616aeba2bb37e55c24cc65a861e12c08e18e3943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/616aeba2bb37e55c24cc65a861e12c08e18e3943"}], "stats": {"total": 165, "additions": 77, "deletions": 88}, "files": [{"sha": "56450cb17d61b62261e881fe18044bacd5a41ad7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -1,3 +1,13 @@\n+2004-09-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-common.h (struct c_fileinfo): Comment moved here from cp-tree.h.\n+\t(extract_interface_info): Delete prototype.\n+\t* c-decl.c (extract_interface_info): Delete stub.\n+\t* c-lex.c (get_fileinfo): Initialize file_info_tree here, if\n+\tit's not already been done ...\n+\t(init_c_lex): ... not here.\n+\t(fe_file_change): Don't call extract_interface_info\n+.\n 2004-09-11  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-tree.h (struct c_declspecs): Remove typedef_decl.  Add\n@@ -38,10 +48,10 @@\n \tstring.  Don't expect stub names to be in the identifier hash table.\n \tDo call strip_name_encoding before looking up entry in ID hash table.\n \t* config/t-darwin (darwin.o): Add target.h to dependencies.\n-\t\n+\n \t* gcc/config/rs6000/rs6000.c (print_operand): Use fputs instead\n \tof fprintf for register names.\n-\t\n+\n \t* output.h (unlikely_section_label): Delete declaration.\n \t(unlikely_text_section_name): Likewise.\n \t* varasm.c (unlikely_section_label_printed): Make static."}, {"sha": "46e843b00047dc9e5039ca50afb82b24444506f1", "filename": "gcc/c-common.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -820,10 +820,6 @@ extern tree decl_constant_value (tree);\n /* Handle increment and decrement of boolean types.  */\n extern tree boolean_increment (enum tree_code, tree);\n \n-/* Hook currently used only by the C++ front end to reset internal state\n-   after entering or leaving a header file.  */\n-extern void extract_interface_info (void);\n-\n extern int case_compare (splay_tree_key, splay_tree_key);\n \n extern tree c_add_case_label (splay_tree, tree, tree, tree, tree);\n@@ -859,7 +855,14 @@ extern GTY(()) int pending_lang_change;\n struct c_fileinfo\n {\n   int time;\t/* Time spent in the file.  */\n-  short interface_only;\t\t/* Flags - used only by C++ */\n+\n+  /* Flags used only by C++.\n+     INTERFACE_ONLY nonzero means that we are in an \"interface\" section\n+     of the compiler.  INTERFACE_UNKNOWN nonzero means we cannot trust\n+     the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN is zero and\n+     INTERFACE_ONLY is zero, it means that we are responsible for\n+     exporting definitions that others might need.  */\n+  short interface_only;\n   short interface_unknown;\n };\n "}, {"sha": "acec3899937f14a30d83deff5fa5f0dc9ecbc5f9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -6591,13 +6591,6 @@ anon_aggr_type_p (tree ARG_UNUSED (node))\n   return 0;\n }\n \n-/* Dummy function in place of callback used by C++.  */\n-\n-void\n-extract_interface_info (void)\n-{\n-}\n-\n /* Return the global value of T as a symbol.  */\n \n tree"}, {"sha": "5a2d947be05f820f5648f405ecf22d69f90750b2", "filename": "gcc/c-lex.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -82,10 +82,8 @@ init_c_lex (void)\n   struct cpp_callbacks *cb;\n   struct c_fileinfo *toplevel;\n \n-  /* Set up filename timing.  Must happen before cpp_read_main_file.  */\n-  file_info_tree = splay_tree_new ((splay_tree_compare_fn)strcmp,\n-\t\t\t\t   0,\n-\t\t\t\t   (splay_tree_delete_value_fn)free);\n+  /* The get_fileinfo data structure must be initialized before\n+     cpp_read_main_file is called.  */\n   toplevel = get_fileinfo (\"<top level>\");\n   if (flag_detailed_statistics)\n     {\n@@ -118,6 +116,11 @@ get_fileinfo (const char *name)\n   splay_tree_node n;\n   struct c_fileinfo *fi;\n \n+  if (!file_info_tree)\n+    file_info_tree = splay_tree_new ((splay_tree_compare_fn)strcmp,\n+\t\t\t\t     0,\n+\t\t\t\t     (splay_tree_delete_value_fn)free);\n+\n   n = splay_tree_lookup (file_info_tree, (splay_tree_key) name);\n   if (n)\n     return (struct c_fileinfo *) n->value;\n@@ -266,9 +269,6 @@ fe_file_change (const struct line_map *new_map)\n   input_filename = new_map->to_file;\n   input_line = new_map->to_line;\n #endif\n-\n-  /* Hook for C++.  */\n-  extract_interface_info ();\n }\n \n static void"}, {"sha": "8e1f434f17583b558d3440b0d84272b155ec7556", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -1,6 +1,31 @@\n+2004-09-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cp-tree.h (interface_only, interface_unknown): Delete declarations;\n+\tcomment explaining them moved to c-common.h.\n+\t* lex.c (interface_only, interface_unknown, extract_interface_info):\n+\tDelete definitions.\n+\t(cxx_finish): Don't reset interface_unknown.\n+\t(handle_pragma_interface): Don't set interface_only and\n+\tinterface_unknown; just the like-named fields in finfo.\n+\t(handle_pragma_implementation): Adjust comment.\n+\t* decl2.c (cp_finish_file): Don't reset interface_only and\n+\tinterface_unknown.\n+\t* method.c (synthesize_method): Don't reset interface_unknown or\n+\tcall extract_interface_info.\n+\t* pt.c (pop_tinst_level): Don't call extract_interface_info.\n+\t* decl.c (start_cleanup_fn): Don't save or restore interface_only\n+\tand interface_unknown.\n+\t(make_rtl_for_nonlocal_decl): Call get_fileinfo on input_filename\n+\tand use the result instead of the interface_only/interface_unknown\n+\tglobals.\n+\t(start_preparsed_function): Likewise.\n+\t* lex.c (cxx_make_type): Likewise.\n+\t* semantics.c (begin_class_definition): Likewise.\n+\t(expand_body): Don't call extract_interface_info.\n+\n 2004-09-10  Ziemowit Laski  <zlaski@apple.com>\n \n-        * decl.c (objc_mark_locals_volatile): Make description of \n+\t* decl.c (objc_mark_locals_volatile): Make description of\n \troutine more descriptive; only mark VAR_DECLs at each\n \tbinding level.\n "}, {"sha": "aa25658c18599a4def02c5dc1b54f50691844bab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -813,13 +813,6 @@ struct language_function GTY(())\n #define error_operand_p(NODE)\t\t\t\t\t\\\n   ((NODE) == error_mark_node \t\t\t\t\t\\\n    || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n-\n-/* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n-   section of the compiler.  INTERFACE_UNKNOWN nonzero means\n-   we cannot trust the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN\n-   is zero and INTERFACE_ONLY is zero, it means that we are responsible\n-   for exporting definitions that others might need.  */\n-extern int interface_only, interface_unknown;\n \f\n /* C++ language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,"}, {"sha": "97b5a1a03579bdc04ba820505c5bba55d9e37fdc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -4599,10 +4599,11 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n     {\n       /* Fool with the linkage of static consts according to #pragma\n \t interface.  */\n-      if (!interface_unknown && !TREE_PUBLIC (decl))\n+      struct c_fileinfo *finfo = get_fileinfo (input_filename);\n+      if (!finfo->interface_unknown && !TREE_PUBLIC (decl))\n \t{\n \t  TREE_PUBLIC (decl) = 1;\n-\t  DECL_EXTERNAL (decl) = interface_only;\n+\t  DECL_EXTERNAL (decl) = finfo->interface_only;\n \t}\n \n       defer_p = 1;\n@@ -5060,8 +5061,6 @@ static GTY(()) int start_cleanup_cnt;\n static tree\n start_cleanup_fn (void)\n {\n-  int old_interface_only = interface_only;\n-  int old_interface_unknown = interface_unknown;\n   char name[32];\n   tree parmtypes;\n   tree fntype;\n@@ -5072,9 +5071,6 @@ start_cleanup_fn (void)\n   /* No need to mangle this.  */\n   push_lang_context (lang_name_c);\n \n-  interface_only = 0;\n-  interface_unknown = 1;\n-\n   /* Build the parameter-types.  */\n   parmtypes = void_list_node;\n   /* Functions passed to __cxa_atexit take an additional parameter.\n@@ -5114,9 +5110,6 @@ start_cleanup_fn (void)\n   pushdecl (fndecl);\n   start_preparsed_function (fndecl, NULL_TREE, SF_PRE_PARSED);\n \n-  interface_unknown = old_interface_unknown;\n-  interface_only = old_interface_only;\n-\n   pop_lang_context ();\n \n   return current_function_decl;\n@@ -9698,6 +9691,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   int doing_friend = 0;\n   struct cp_binding_level *bl;\n   tree current_function_parms;\n+  struct c_fileinfo *finfo = get_fileinfo (input_filename);\n \n   /* Sanity check.  */\n   gcc_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE);\n@@ -9924,15 +9918,15 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      This only affects inlines and template instantiations.  */\n-  else if (interface_unknown == 0\n+  else if (finfo->interface_unknown == 0\n \t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))\n     {\n       if (DECL_DECLARED_INLINE_P (decl1)\n \t  || DECL_TEMPLATE_INSTANTIATION (decl1)\n \t  || processing_template_decl)\n \t{\n \t  DECL_EXTERNAL (decl1)\n-\t    = (interface_only\n+\t    = (finfo->interface_only\n \t       || (DECL_DECLARED_INLINE_P (decl1)\n \t\t   && ! flag_implement_inlines\n \t\t   && !DECL_VINDEX (decl1)));\n@@ -9950,14 +9944,15 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       if (!DECL_EXTERNAL (decl1))\n \tmark_needed (decl1);\n     }\n-  else if (interface_unknown && interface_only\n+  else if (finfo->interface_unknown && finfo->interface_only\n \t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))\n     {\n       /* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma\n-\t interface, we will have interface_only set but not\n-\t interface_known.  In that case, we don't want to use the normal\n-\t heuristics because someone will supply a #pragma implementation\n-\t elsewhere, and deducing it here would produce a conflict.  */\n+\t interface, we will have both finfo->interface_unknown and\n+\t finfo->interface_only set.  In that case, we don't want to\n+\t use the normal heuristics because someone will supply a\n+\t #pragma implementation elsewhere, and deducing it here would\n+\t produce a conflict.  */\n       comdat_linkage (decl1);\n       DECL_EXTERNAL (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;"}, {"sha": "92233c7cd288c60b89d3e229903d4260cd28f1f4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -2750,9 +2750,6 @@ cp_finish_file (void)\n   input_line -= 1;\n #endif\n \n-  interface_unknown = 1;\n-  interface_only = 0;\n-\n   /* We now have to write out all the stuff we put off writing out.\n      These include:\n "}, {"sha": "6157b7f10ff94aa0378e92576e01dbc51d8ddd11", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -81,12 +81,6 @@ struct impl_files\n \n static struct impl_files *impl_file_chain;\n \n-\f\n-int interface_only;\t\t/* whether or not current file is only for\n-\t\t\t\t   interface definitions.  */\n-int interface_unknown;\t\t/* whether or not we know this class\n-\t\t\t\t   to behave according to #pragma interface.  */\n-\n \f\n void\n cxx_finish (void)\n@@ -360,8 +354,6 @@ cxx_init (void)\n   TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n   ridpointers[RID_NULL] = null_node;\n \n-  interface_unknown = 1;\n-\n   /* The fact that G++ uses COMDAT for many entities (inline\n      functions, template instantiations, virtual tables, etc.) mean\n      that it is fundamentally unreliable to try to make decisions\n@@ -387,19 +379,6 @@ cxx_init (void)\n   return true;\n }\n \f\n-/* Helper function to load global variables with interface\n-   information.  */\n-\n-void\n-extract_interface_info (void)\n-{\n-  struct c_fileinfo *finfo;\n-\n-  finfo = get_fileinfo (input_filename);\n-  interface_only = finfo->interface_only;\n-  interface_unknown = finfo->interface_unknown;\n-}\n-\n /* Return nonzero if S is not considered part of an\n    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */\n \n@@ -504,23 +483,21 @@ handle_pragma_interface (cpp_reader* dfile ATTRIBUTE_UNUSED )\n \tmain_input_filename = input_filename;\n     }\n \n-  interface_only = interface_strcmp (main_filename);\n+  finfo->interface_only = interface_strcmp (main_filename);\n   /* If MULTIPLE_SYMBOL_SPACES is set, we cannot assume that we can see\n      a definition in another file.  */\n-  if (!MULTIPLE_SYMBOL_SPACES || !interface_only)\n-    interface_unknown = 0;\n-\n-  finfo->interface_only = interface_only;\n-  finfo->interface_unknown = interface_unknown;\n+  if (!MULTIPLE_SYMBOL_SPACES || !finfo->interface_only)\n+    finfo->interface_unknown = 0;\n }\n \n /* Note that we have seen a #pragma implementation for the key MAIN_FILENAME.\n    We used to only allow this at toplevel, but that restriction was buggy\n    in older compilers and it seems reasonable to allow it in the headers\n    themselves, too.  It only needs to precede the matching #p interface.\n \n-   We don't touch interface_only or interface_unknown; the user must specify\n-   a matching #p interface for this to have any effect.  */\n+   We don't touch finfo->interface_only or finfo->interface_unknown;\n+   the user must specify a matching #p interface for this to have\n+   any effect.  */\n \n static void\n handle_pragma_implementation (cpp_reader* dfile ATTRIBUTE_UNUSED )\n@@ -791,8 +768,9 @@ cxx_make_type (enum tree_code code)\n   /* Set up some flags that give proper default behavior.  */\n   if (IS_AGGR_TYPE_CODE (code))\n     {\n-      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n-      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+      struct c_fileinfo *finfo = get_fileinfo (input_filename);\n+      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, finfo->interface_unknown);\n+      CLASSTYPE_INTERFACE_ONLY (t) = finfo->interface_only;\n     }\n   else\n     /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,"}, {"sha": "b28746b6dfc34a51f3c221f01554cccff78bc66c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -725,7 +725,6 @@ synthesize_method (tree fndecl)\n      function.  */\n   DECL_SOURCE_LOCATION (fndecl) = input_location;\n \n-  interface_unknown = 1;\n   start_preparsed_function (fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   stmt = begin_function_body ();\n \n@@ -755,7 +754,6 @@ synthesize_method (tree fndecl)\n   finish_function_body (stmt);\n   expand_or_defer_fn (finish_function (0));\n \n-  extract_interface_info ();\n   if (! context)\n     pop_from_top_level ();\n   else if (nested)"}, {"sha": "3bdcf06830ceac7261142d8c2a1dae13eeae81b2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -4966,8 +4966,6 @@ pop_tinst_level (void)\n   /* Restore the filename and line number stashed away when we started\n      this instantiation.  */\n   input_location = TINST_LOCATION (old);\n-  extract_interface_info ();\n-  \n   current_tinst_level = TREE_CHAIN (old);\n   --tinst_depth;\n   ++tinst_level_tick;"}, {"sha": "bdf1439a9d33d8975b068b500f3a05dba561ebab", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d709b0013a3d180de93f3349233637c281215b2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5d709b0013a3d180de93f3349233637c281215b2", "patch": "@@ -2106,9 +2106,10 @@ begin_class_definition (tree t)\n      before.  */\n   if (! TYPE_ANONYMOUS_P (t))\n     {\n-      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+      struct c_fileinfo *finfo = get_fileinfo (input_filename);\n+      CLASSTYPE_INTERFACE_ONLY (t) = finfo->interface_only;\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n-\t(t, interface_unknown);\n+\t(t, finfo->interface_unknown);\n     }\n   reset_specialization();\n   \n@@ -2897,8 +2898,6 @@ expand_body (tree fn)\n \n   current_function_decl = saved_function;\n \n-  extract_interface_info ();\n-\n   if (DECL_CLONED_FUNCTION_P (fn))\n     {\n       /* If this is a clone, go through the other clones now and mark"}]}