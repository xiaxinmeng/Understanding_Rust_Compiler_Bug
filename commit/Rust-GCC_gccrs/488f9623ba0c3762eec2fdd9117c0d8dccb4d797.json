{"sha": "488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4Zjk2MjNiYTBjMzc2MmVlYzJmZGQ5MTE3YzBkOGRjY2I0ZDc5Nw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-03-04T09:57:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T09:57:07Z"}, "message": "exp_ch6.adb (Expand_N_Subprogram_Body): Avoid trying to unnest generic subprograms.\n\n2015-03-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Avoid trying to unnest\n\tgeneric subprograms.\n\t* exp_unst.adb (Check_Dynamic_Type): Handle record types properly\n\t(Note_Uplevel_Reference): Ignore uplevel references to non-types\n\t(Get_Level): Consider only subprograms, not blocks.\n\t(Visit_Node): Set proper condition for generating ARECnF entity.\n\tIgnore indirect calls. Ignore calls to subprograms\n\toutside our nest.\n\t(Unnest_Subprogram): Minor changes in dealing with ARECnF entity.\n\t(Add_Form_To_Spec): Properly set Last_Entity field.\n\t(Unnest_Subprogram): Set current subprogram scope for analyze calls.\n\tHandle case of no uplevel refs in outer subprogram\n\tDon't mark uplevel entities as aliased.\n\tDon't deal with calls with no ARECnF requirement.\n\n2015-03-04  Robert Dewar  <dewar@adacore.com>\n\n\t* s-valrea.adb (Scan_Real): Remove redundant tests from scaling loops.\n\t* s-imgdec.adb (Set_Decimal_Digits): Remove redundant Max\n\toperation in computing LZ.\n\t* sem_attr.adb: Minor typo fix\n\nFrom-SVN: r221177", "tree": {"sha": "dcfb567eda62825a89f603f5277d157664b3fc05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcfb567eda62825a89f603f5277d157664b3fc05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/comments", "author": null, "committer": null, "parents": [{"sha": "b6a56408a630f3fe20b4664520302adab8bd10a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a56408a630f3fe20b4664520302adab8bd10a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a56408a630f3fe20b4664520302adab8bd10a6"}], "stats": {"total": 416, "additions": 272, "deletions": 144}, "files": [{"sha": "4ac44b3ca3184b4ca8a877167ac3aa2b67b5ad87", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -1,3 +1,27 @@\n+2015-03-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): Avoid trying to unnest\n+\tgeneric subprograms.\n+\t* exp_unst.adb (Check_Dynamic_Type): Handle record types properly\n+\t(Note_Uplevel_Reference): Ignore uplevel references to non-types\n+\t(Get_Level): Consider only subprograms, not blocks.\n+\t(Visit_Node): Set proper condition for generating ARECnF entity.\n+\tIgnore indirect calls. Ignore calls to subprograms\n+\toutside our nest.\n+\t(Unnest_Subprogram): Minor changes in dealing with ARECnF entity.\n+\t(Add_Form_To_Spec): Properly set Last_Entity field.\n+\t(Unnest_Subprogram): Set current subprogram scope for analyze calls.\n+\tHandle case of no uplevel refs in outer subprogram\n+\tDon't mark uplevel entities as aliased.\n+\tDon't deal with calls with no ARECnF requirement.\n+\n+2015-03-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-valrea.adb (Scan_Real): Remove redundant tests from scaling loops.\n+\t* s-imgdec.adb (Set_Decimal_Digits): Remove redundant Max\n+\toperation in computing LZ.\n+\t* sem_attr.adb: Minor typo fix\n+\n 2015-03-04  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch7.adb: Minor reformatting."}, {"sha": "de360abf4c9e9561795885d75b5e265f9a93742a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -5345,7 +5345,19 @@ package body Exp_Ch6 is\n       --  with nested subprograms, do the unnesting operation now.\n \n       if Opt.Unnest_Subprogram_Mode\n-        and then Is_Library_Level_Entity (Spec_Id)\n+\n+        --  We are only interested in subprograms (not generic subprograms)\n+\n+        and then Is_Subprogram (Spec_Id)\n+\n+        --  Only deal with outer level subprograms. Nested subprograms are\n+        --  handled as part of dealing with the outer level subprogram in\n+        --  which they are nested.\n+\n+        and then Enclosing_Subprogram (Spec_Id) = Empty\n+\n+        --  We are only interested in subprograms that have nested subprograms\n+\n         and then Has_Nested_Subprogram (Spec_Id)\n       then\n          Unnest_Subprogram (Spec_Id, N);"}, {"sha": "9bb83e43554c2ae861cd13d99756e0039cf20353", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 219, "deletions": 131, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -33,8 +33,9 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n+with Sinput;   use Sinput;\n with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n+with Sem_Ch8;  use Sem_Ch8;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -187,8 +188,8 @@ package body Exp_Unst is\n \n                begin\n                   C := First_Component_Or_Discriminant (T);\n-                  while Present (T) loop\n-                     if Check_Dynamic_Type (C) then\n+                  while Present (C) loop\n+                     if Check_Dynamic_Type (Etype (C)) then\n                         DT := True;\n                      end if;\n \n@@ -269,6 +270,12 @@ package body Exp_Unst is\n \n    procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id) is\n    begin\n+      --  Nothing to do if reference has no entity field\n+\n+      if Nkind (N) not in N_Entity then\n+         return;\n+      end if;\n+\n       --  Establish list if first call for Uplevel_References\n \n       if No (Uplevel_References (Subp)) then\n@@ -279,8 +286,7 @@ package body Exp_Unst is\n       --  the list. The first is the actual reference, the second is the\n       --  enclosing subprogram at the point of reference\n \n-      Append_Elmt\n-        (N, Uplevel_References (Subp));\n+      Append_Elmt (N, Uplevel_References (Subp));\n \n       if Is_Subprogram (Current_Scope) then\n          Append_Elmt (Current_Scope, Uplevel_References (Subp));\n@@ -349,14 +355,15 @@ package body Exp_Unst is\n       function Get_Level (Sub : Entity_Id) return Nat is\n          Lev : Nat;\n          S   : Entity_Id;\n+\n       begin\n          Lev := 1;\n          S   := Sub;\n          loop\n             if S = Subp then\n                return Lev;\n             else\n-               S := Enclosing_Dynamic_Scope (S);\n+               S := Enclosing_Subprogram (S);\n                Lev := Lev + 1;\n             end if;\n          end loop;\n@@ -407,7 +414,8 @@ package body Exp_Unst is\n          ----------------\n \n          function Visit_Node (N : Node_Id) return Traverse_Result is\n-            Ent : Entity_Id;\n+            Ent  : Entity_Id;\n+            Csub : Entity_Id;\n \n             function Find_Current_Subprogram return Entity_Id;\n             --  Finds the current subprogram containing the call N\n@@ -439,14 +447,51 @@ package body Exp_Unst is\n          begin\n             --  Record a call\n \n-            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n+            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call)\n+\n+              --  We are only interested in direct calls, not indirect calls\n+              --  (where Name (N) is an explicit dereference) at least for now!\n+\n+              and then Nkind (Name (N)) in N_Has_Entity\n+            then\n                Ent := Entity (Name (N));\n-               Calls.Append ((N, Find_Current_Subprogram, Ent));\n \n-            --  Record a subprogram\n+               --  We are only interested in calls to subprograms nested\n+               --  within Subp. Calls to Subp itself or to subprograms that\n+               --  are outside the nested structure do not affect us.\n+\n+               if Scope_Within (Ent, Subp) then\n+\n+                  --  For now, ignore calls to generic instances. Seems to be\n+                  --  some problem there which we will investigate later ???\n+\n+                  if Original_Location (Sloc (Ent)) /= Sloc (Ent)\n+                    or else Is_Generic_Instance (Ent)\n+                  then\n+                     null;\n+\n+                  --  Here we have a call to keep and analyze\n+\n+                  else\n+                     Csub := Find_Current_Subprogram;\n+\n+                     --  Both caller and callee must be subprograms (we ignore\n+                     --  generic subprograms).\n+\n+                     if Is_Subprogram (Csub) and then Is_Subprogram (Ent) then\n+                        Calls.Append ((N, Find_Current_Subprogram, Ent));\n+                     end if;\n+                  end if;\n+               end if;\n+\n+            --  Record a subprogram. We record a subprogram body that acts as\n+            --  a spec. Otherwise we record a subprogram declaration, providing\n+            --  that it has a corresponding body we can get hold of. The case\n+            --  of no corresponding body being available is ignored for now.\n \n             elsif (Nkind (N) = N_Subprogram_Body and then Acts_As_Spec (N))\n-              or else Nkind (N) = N_Subprogram_Declaration\n+              or else (Nkind (N) = N_Subprogram_Declaration\n+                        and then Present (Corresponding_Body (N)))\n             then\n                Subps.Increment_Last;\n \n@@ -463,6 +508,7 @@ package body Exp_Unst is\n                      STJ.Bod := N;\n                   else\n                      STJ.Bod := Parent (Parent (Corresponding_Body (N)));\n+\n                      pragma Assert (Nkind (STJ.Bod) = N_Subprogram_Body);\n                   end if;\n \n@@ -552,14 +598,27 @@ package body Exp_Unst is\n             ARS : constant String     := AREC_String (STJ.Lev);\n \n          begin\n-            if STJ.Ent = Subp then\n-               STJ.ARECnF := Empty;\n-            else\n+            --  First we create the ARECnF entity for the additional formal\n+            --  for all subprograms requiring that an activation record pointer\n+            --  be passed. This is true of all subprograms that have uplevel\n+            --  references, and whose enclosing subprogram also has uplevel\n+            --  references.\n+\n+            if Has_Uplevel_Reference (STJ.Ent)\n+              and then STJ.Ent /= Subp\n+              and then Has_Uplevel_Reference (Enclosing_Subprogram (STJ.Ent))\n+            then\n                STJ.ARECnF :=\n                  Make_Defining_Identifier (Loc,\n                    Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n+            else\n+               STJ.ARECnF := Empty;\n             end if;\n \n+            --  Now define the AREC entities for the activation record. This\n+            --  is needed for any subprogram that has nested subprograms and\n+            --  has uplevel references.\n+\n             if Has_Nested_Subprogram (STJ.Ent)\n               and then Has_Uplevel_Reference (STJ.Ent)\n             then\n@@ -580,8 +639,7 @@ package body Exp_Unst is\n                STJ.ARECnU  := Empty;\n             end if;\n \n-            --  Define uplink component entity if inner nesting case and also\n-            --  the extra formal entity.\n+            --  Define uplink component entity if inner nesting case\n \n             if Has_Uplevel_Reference (STJ.Ent) and then STJ.Lev > 1 then\n                declare\n@@ -590,14 +648,10 @@ package body Exp_Unst is\n                   STJ.ARECnU :=\n                     Make_Defining_Identifier (Loc,\n                       Chars => Name_Find_Str (ARS1 & \"U\"));\n-                  STJ.ARECnF :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => Name_Find_Str (ARS1 & \"F\"));\n                end;\n \n             else\n                STJ.ARECnU := Empty;\n-               STJ.ARECnF := Empty;\n             end if;\n          end;\n       end loop;\n@@ -614,9 +668,10 @@ package body Exp_Unst is\n \n             begin\n                --  First add the extra formal if needed. This applies to all\n-               --  nested subprograms that have uplevel references.\n+               --  nested subprograms that require an activation record to be\n+               --  passed, as indicated by ARECnF being defined.\n \n-               if STJ.Lev > 1 and then Has_Uplevel_Reference (STJ.Ent) then\n+               if Present (STJ.ARECnF) then\n \n                   --  Here we need the extra formal. We do the expansion and\n                   --  analysis of this manually, since it is fairly simple,\n@@ -649,6 +704,7 @@ package body Exp_Unst is\n                      begin\n                         if No (First_Entity (Sub)) then\n                            Set_First_Entity (Sub, F);\n+                           Set_Last_Entity (Sub, F);\n \n                         else\n                            declare\n@@ -657,9 +713,14 @@ package body Exp_Unst is\n                               if No (LastF) then\n                                  Set_Next_Entity (F, First_Entity (Sub));\n                                  Set_First_Entity (Sub, F);\n+\n                               else\n                                  Set_Next_Entity (F, Next_Entity (LastF));\n                                  Set_Next_Entity (LastF, F);\n+\n+                                 if Last_Entity (Sub) = LastF then\n+                                    Set_Last_Entity (Sub, F);\n+                                 end if;\n                               end if;\n                            end;\n                         end if;\n@@ -760,11 +821,13 @@ package body Exp_Unst is\n \n                      Clist := Empty_List;\n \n-                     --  If not top level, include ARECnU : ARECnPT := ARECnF\n-                     --  where n is one less than the current level and the\n-                     --  entity ARECnPT comes from the enclosing subprogram.\n+                     --  If we are in a subprogram that has a static link that\n+                     --  ias passed in (as indicated by ARECnF being deinfed),\n+                     --  then include ARECnU : ARECnPT := ARECnF where n is\n+                     --  one less than the current level and the entity ARECnPT\n+                     --  comes from the enclosing subprogram.\n \n-                     if STJ.Lev > 1 then\n+                     if Present (STJ.ARECnF) then\n                         declare\n                            STJE : Subp_Entry\n                                     renames Subps.Table (Enclosing_Subp (J));\n@@ -852,23 +915,27 @@ package body Exp_Unst is\n                        New_List\n                          (Decl_ARECnT, Decl_ARECn, Decl_ARECnPT, Decl_ARECnP));\n \n-                     --  Analyze the newly inserted declarations. Note that\n-                     --  we do not need to establish the relevant scope stack\n-                     --  entries here, because we have already set the correct\n-                     --  entity references, so no name resolution is required.\n+                     --  Analyze the newly inserted declarations. Note that we\n+                     --  do not need to establish the whole scope stack, since\n+                     --  we have already set all entity fields (so there will\n+                     --  be no searching of upper scopes to resolve names). But\n+                     --  we do set the scope of the current subprogram, so that\n+                     --  newly created entities go in the right entity chain.\n \n                      --  We analyze with all checks suppressed (since we do\n                      --  not expect any exceptions, and also we temporarily\n                      --  turn off Unested_Subprogram_Mode to avoid trying to\n                      --  mark uplevel references (not needed at this stage,\n                      --  and in fact causes a bit of recursive chaos).\n \n+                     Push_Scope (STJ.Ent);\n                      Opt.Unnest_Subprogram_Mode := False;\n                      Analyze (Decl_ARECnT,  Suppress => All_Checks);\n                      Analyze (Decl_ARECn,   Suppress => All_Checks);\n                      Analyze (Decl_ARECnPT, Suppress => All_Checks);\n                      Analyze (Decl_ARECnP,  Suppress => All_Checks);\n                      Opt.Unnest_Subprogram_Mode := True;\n+                     Pop_Scope;\n \n                      --  Next step, for each uplevel referenced entity, add\n                      --  assignment operations to set the comoponent in the\n@@ -883,14 +950,15 @@ package body Exp_Unst is\n                            Asn : Node_Id;\n \n                         begin\n-                           Set_Aliased_Present (Dec);\n-                           Set_Is_Aliased (Ent);\n-\n                            --  For parameters, we insert the assignment right\n                            --  after the declaration of ARECnP. For all other\n                            --  entities, we insert the assignment immediately\n                            --  after the declaration of the entity.\n \n+                           --  Note: we don't need to mark the entity as being\n+                           --  aliased, because the address attribute will mark\n+                           --  it as Address_Taken, and that is good enough.\n+\n                            if Is_Formal (Ent) then\n                               Ins := Decl_ARECnP;\n                            else\n@@ -917,11 +985,12 @@ package body Exp_Unst is\n \n                            Insert_After (Ins, Asn);\n \n-                           --  Analyze the assignment statement. Again, we do\n-                           --  not need to establish the relevant scope stack\n-                           --  entries here, because we have already set the\n-                           --  correct entity references, so no name resolution\n-                           --  is required.\n+                           --  Analyze the assignment statement. We do not need\n+                           --  to establish the relevant scope stack entries\n+                           --  here, because we have already set the correct\n+                           --  entity references, so no name resolution is\n+                           --  required, and no new entities are created, so\n+                           --  we don't even need to set the current scope.\n \n                            --  We analyze with all checks suppressed (since\n                            --  we do not expect any exceptions, and also we\n@@ -1010,6 +1079,13 @@ package body Exp_Unst is\n                         SI   : SI_Type;\n \n                      begin\n+                        --  Push the current scope, so that the pointer type\n+                        --  Tnn, and any subsidiary entities resulting from\n+                        --  the analysis of the rewritten reference, go in the\n+                        --  right entity chain.\n+\n+                        Push_Scope (STJR.Ent);\n+\n                         --  First insert declaration for pointer type\n \n                         --    type Tnn is access all typ;\n@@ -1087,6 +1163,8 @@ package body Exp_Unst is\n                         --  need to establish the relevant scope stack entries\n                         --  here, because we have already set all the correct\n                         --  entity references, so no name resolution is needed.\n+                        --  We have already set the current scope, so that any\n+                        --  new entities created will be in the right scope.\n \n                         --  We analyze with all checks suppressed (since we do\n                         --  not expect any exceptions, and also we temporarily\n@@ -1097,6 +1175,7 @@ package body Exp_Unst is\n                         Opt.Unnest_Subprogram_Mode := False;\n                         Analyze_And_Resolve (Ref, Typ, Suppress => All_Checks);\n                         Opt.Unnest_Subprogram_Mode := True;\n+                        Pop_Scope;\n                      end;\n \n                   <<Continue>>\n@@ -1114,130 +1193,139 @@ package body Exp_Unst is\n       Adjust_Calls : for J in Calls.First .. Calls.Last loop\n \n          --  Process a single call, we are only interested in a call to a\n-         --  subprogram that actually need a pointer to an activation record,\n+         --  subprogram that actually needs a pointer to an activation record,\n          --  as indicated by the ARECnF entity being set. This excludes the\n          --  top level subprogram, and any subprogram not having uplevel refs.\n \n-         declare\n+         Adjust_One_Call : declare\n             CTJ : Call_Entry renames Calls.Table (J);\n+            STF : Subp_Entry renames Subps.Table (Subp_Index (CTJ.From));\n+            STT : Subp_Entry renames Subps.Table (Subp_Index (CTJ.To));\n+\n+            Loc : constant Source_Ptr := Sloc (CTJ.N);\n+\n+            Extra  : Node_Id;\n+            ExtraP : Node_Id;\n+            SubX   : SI_Type;\n+            Act    : Node_Id;\n \n          begin\n-            if Has_Uplevel_Reference (CTJ.To) and then CTJ.To /= Subp then\n-               declare\n-                  CTJ : Call_Entry renames Calls.Table (J);\n-                  STF : Subp_Entry renames Subps.Table (Subp_Index (CTJ.From));\n-                  STT : Subp_Entry renames Subps.Table (Subp_Index (CTJ.To));\n+            if Present (STT.ARECnF) then\n \n-                  Loc : constant Source_Ptr := Sloc (CTJ.N);\n+               --  CTJ.N is a call to a subprogram which may require\n+               --  a pointer to an activation record. The subprogram\n+               --  containing the call is CTJ.From and the subprogram being\n+               --  called is CTJ.To, so we have a call from level STF.Lev to\n+               --  level STT.Lev.\n \n-                  Extra  : Node_Id;\n-                  ExtraP : Node_Id;\n-                  SubX   : SI_Type;\n-                  Act    : Node_Id;\n+               --  There are three possibilities:\n \n-               begin\n-                  --  CTJ.N is a call to a subprogram which may require\n-                  --  a pointer to an activation record. The subprogram\n-                  --  containing the call is CTJ.From and the subprogram being\n-                  --  called is CTJ.To, so we have a call from level STF.Lev to\n-                  --  level STT.Lev.\n+               --  For a call to the same level, we just pass the activation\n+               --  record passed to the calling subprogram.\n \n-                  --  There are three possibilities:\n+               if STF.Lev = STT.Lev then\n+                  Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n \n-                  --  For a call to the same level, we just pass the activation\n-                  --  record passed to the calling subprogram.\n+               --  For a call that goes down a level, we pass a pointer\n+               --  to the activation record constructed wtihin the caller\n+               --  (which may be the outer level subprogram, but also may\n+               --  be a more deeply nested caller).\n \n-                  if STF.Lev = STT.Lev then\n-                     Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n+               elsif STT.Lev = STF.Lev + 1 then\n+                  Extra := New_Occurrence_Of (STF.ARECnP, Loc);\n \n-                  --  For a call that goes down a level, we pass a pointer\n-                  --  to the activation record constructed wtihin the caller\n-                  --  (which may be the outer level subprogram, but also may\n-                  --  be a more deeply nested caller).\n+                  --  Otherwise we must have an upcall (STT.Lev < STF.LEV),\n+                  --  since it is not possible to do a downcall of more than\n+                  --  one level.\n \n-                  elsif STT.Lev = STF.Lev + 1 then\n-                     Extra := New_Occurrence_Of (STF.ARECnP, Loc);\n+                  --  For a call from level STF.Lev to level STT.Lev, we\n+                  --  have to find the activation record needed by the\n+                  --  callee. This is as follows:\n \n-                     --  Otherwise we must have an upcall (STT.Lev < STF.LEV),\n-                     --  since it is not possible to do a downcall of more than\n-                     --  one level.\n+                  --    ARECaF.ARECbU.ARECcU....ARECm\n \n-                     --  For a call from level STF.Lev to level STT.Lev, we\n-                     --  have to find the activation record needed by the\n-                     --  callee. This is as follows:\n+                  --  where a,b,c .. m =\n+                  --    STF.Lev - 1,  STF.Lev - 2, STF.Lev - 3 .. STT.Lev\n \n-                     --    ARECaF.ARECbU.ARECcU....ARECm\n+               else\n+                  pragma Assert (STT.Lev < STF.Lev);\n \n-                     --  where a,b,c .. m =\n-                     --    STF.Lev - 1,  STF.Lev - 2, STF.Lev - 3 .. STT.Lev\n+                  Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n+                  SubX := Subp_Index (CTJ.From);\n+                  for K in reverse STT.Lev .. STF.Lev - 1 loop\n+                     SubX := Enclosing_Subp (SubX);\n+                     Extra :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix        => Extra,\n+                         Selector_Name =>\n+                           New_Occurrence_Of\n+                             (Subps.Table (SubX).ARECnU, Loc));\n+                  end loop;\n+               end if;\n \n-                  else\n-                     pragma Assert (STT.Lev < STF.Lev);\n-\n-                     Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n-                     SubX := Subp_Index (CTJ.From);\n-                     for K in reverse STT.Lev .. STF.Lev - 1 loop\n-                        SubX := Enclosing_Subp (SubX);\n-                        Extra :=\n-                          Make_Selected_Component (Loc,\n-                            Prefix        => Extra,\n-                            Selector_Name =>\n-                              New_Occurrence_Of\n-                                (Subps.Table (SubX).ARECnU, Loc));\n-                     end loop;\n-                  end if;\n+               --  Extra is the additional parameter to be added. Build a\n+               --  parameter association that we can append to the actuals.\n \n-                  --  Extra is the additional parameter to be added. Build a\n-                  --  parameter association that we can append to the actuals.\n+               ExtraP :=\n+                 Make_Parameter_Association (Loc,\n+                   Selector_Name             =>\n+                     New_Occurrence_Of (STT.ARECnF, Loc),\n+                   Explicit_Actual_Parameter => Extra);\n \n-                  ExtraP :=\n-                    Make_Parameter_Association (Loc,\n-                      Selector_Name             =>\n-                        New_Occurrence_Of (STT.ARECnF, Loc),\n-                      Explicit_Actual_Parameter => Extra);\n+               if No (Parameter_Associations (CTJ.N)) then\n+                  Set_Parameter_Associations (CTJ.N, Empty_List);\n+               end if;\n \n-                  if No (Parameter_Associations (CTJ.N)) then\n-                     Set_Parameter_Associations (CTJ.N, Empty_List);\n-                  end if;\n+               Append (ExtraP, Parameter_Associations (CTJ.N));\n \n-                  Append (ExtraP, Parameter_Associations (CTJ.N));\n+               --  We need to deal with the actual parameter chain as well.\n+               --  The newly added parameter is always the last actual.\n \n-                  --  We need to deal with the actual parameter chain as well.\n-                  --  The newly added parameter is always the last actual.\n+               Act := First_Named_Actual (CTJ.N);\n \n-                  Act := First_Named_Actual (CTJ.N);\n+               if No (Act) then\n+                  Set_First_Named_Actual (CTJ.N, Extra);\n \n-                  if No (Act) then\n-                     Set_First_Named_Actual (CTJ.N, Extra);\n+               --  Here we must follow the chain and append the new entry\n \n-                  --  Here we must follow the chain and append the new entry\n+               else\n+                  loop\n+                     declare\n+                        PAN : Node_Id;\n+                        NNA : Node_Id;\n \n-                  else\n-                     while Present (Next_Named_Actual (Act)) loop\n-                        Act := Next_Named_Actual (Act);\n-                     end loop;\n+                     begin\n+                        PAN := Parent (Act);\n+                        pragma Assert (Nkind (PAN) = N_Parameter_Association);\n+                        NNA := Next_Named_Actual (PAN);\n \n-                     Set_Next_Named_Actual (Act, Extra);\n-                  end if;\n+                        if No (NNA) then\n+                           Set_Next_Named_Actual (PAN, Extra);\n+                           exit;\n+                        end if;\n \n-                  --  Analyze and resolve the new actual. We do not need to\n-                  --  establish the relevant scope stack entries here, because\n-                  --  we have already set all the correct entity references, so\n-                  --  no name resolution is needed.\n-\n-                  --  We analyze with all checks suppressed (since we do not\n-                  --  expect any exceptions, and also we temporarily turn off\n-                  --  Unested_Subprogram_Mode to avoid trying to mark uplevel\n-                  --  references (not needed at this stage, and in fact causes\n-                  --  a bit of recursive chaos).\n-\n-                  Opt.Unnest_Subprogram_Mode := False;\n-                  Analyze_And_Resolve\n-                    (Extra, Etype (STT.ARECnF), Suppress => All_Checks);\n-                  Opt.Unnest_Subprogram_Mode := True;\n-               end;\n+                        Act := NNA;\n+                     end;\n+                  end loop;\n+               end if;\n+\n+               --  Analyze and resolve the new actual. We do not need to\n+               --  establish the relevant scope stack entries here, because\n+               --  we have already set all the correct entity references, so\n+               --  no name resolution is needed.\n+\n+               --  We analyze with all checks suppressed (since we do not\n+               --  expect any exceptions, and also we temporarily turn off\n+               --  Unested_Subprogram_Mode to avoid trying to mark uplevel\n+               --  references (not needed at this stage, and in fact causes\n+               --  a bit of recursive chaos).\n+\n+               Opt.Unnest_Subprogram_Mode := False;\n+               Analyze_And_Resolve\n+                 (Extra, Etype (STT.ARECnF), Suppress => All_Checks);\n+               Opt.Unnest_Subprogram_Mode := True;\n             end if;\n-         end;\n+         end Adjust_One_Call;\n       end loop Adjust_Calls;\n \n       return;"}, {"sha": "abdee54920aeab735eea1c354a4f1ac9a5680d70", "filename": "gcc/ada/s-imgdec.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fs-imgdec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fs-imgdec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-imgdec.adb?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -319,9 +319,11 @@ package body System.Img_Dec is\n                DA : Natural := Digits_After_Point;\n                --  Digits remaining to output after point\n \n-               LZ : constant Integer :=\n-                      Integer'Max (0, Integer'Min (DA, -Digits_Before_Point));\n-               --  Number of leading zeroes after point\n+               LZ : constant Integer := Integer'Min (DA, -Digits_Before_Point);\n+               --  Number of leading zeroes after point. Note: there used to be\n+               --  a Max of this result with zero, but that's redundant, since\n+               --  we know DA is positive, and because of the test above, we\n+               --  know that -Digits_Before_Point >= 0.\n \n             begin\n                Set_Zeroes (LZ);"}, {"sha": "7284e6007f6cdb2633e35305e05c3569178925b2", "filename": "gcc/ada/s-valrea.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valrea.adb?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -347,19 +347,21 @@ package body System.Val_Real is\n             Scale := Scale - Maxpow;\n          end loop;\n \n-         if Scale > 0 then\n-            Uval := Uval * Powten (Scale);\n-         end if;\n+         --  Note that we still know that Scale > 0, since the loop\n+         --  above leaves Scale in the range 1 .. Maxpow.\n+\n+         Uval := Uval * Powten (Scale);\n \n       elsif Scale < 0 then\n          while (-Scale) > Maxpow loop\n             Uval := Uval / Powten (Maxpow);\n             Scale := Scale + Maxpow;\n          end loop;\n \n-         if Scale < 0 then\n-            Uval := Uval / Powten (-Scale);\n-         end if;\n+         --  Note that we still know that Scale < 0, since the loop\n+         --  above leaves Scale in the range -Maxpow .. -1.\n+\n+         Uval := Uval / Powten (-Scale);\n       end if;\n \n       --  Here is where we check for a bad based number"}, {"sha": "21040ab97e8cc78d1ab97e55715e3a534fcc123a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/488f9623ba0c3762eec2fdd9117c0d8dccb4d797/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=488f9623ba0c3762eec2fdd9117c0d8dccb4d797", "patch": "@@ -247,7 +247,7 @@ package body Sem_Attr is\n       --  Common processing for attributes 'Old and 'Result. The routine checks\n       --  that the attribute appears in a postcondition-like aspect or pragma\n       --  associated with a suitable subprogram or a body. Flag Legal is set\n-      --  when the above criterias are met. Spec_Id denotes the entity of the\n+      --  when the above criteria are met. Spec_Id denotes the entity of the\n       --  subprogram [body] or Empty if the attribute is illegal.\n \n       procedure Bad_Attribute_For_Predicate;"}]}