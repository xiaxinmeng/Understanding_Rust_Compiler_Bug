{"sha": "ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4ZjZjNjkwMzJiOWEwN2IzMDM2YTI1MTRiZDU5MzUzYjJhMzJjMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-21T23:54:16Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-21T23:54:16Z"}, "message": "tree-loop-linear.c (linear_transform_loops): Use single_exit accessor functions.\n\n\t* tree-loop-linear.c (linear_transform_loops): Use single_exit accessor\n\tfunctions.\n\t* tree-ssa-loop-niter.c (loop_only_exit_p): Ditto.\n\t* cfgloopmanip.c (update_single_exits_after_duplication,\n\tupdate_single_exit_for_duplicated_loop, loop_version): Ditto.\n\t* tree-scalar-evolution.c (get_loop_exit_condition,\n\tget_exit_conditions_rec, loop_closed_phi_def,\n\tnumber_of_iterations_in_loop, scev_const_prop): Ditto.\n\t* tree-ssa-loop-ivopts.c (single_dom_exit): Ditto.\n\t* modulo-sched.c (generate_prolog_epilog, loop_canon_p, sms_schedule):\n\tDitto.\n\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):\n\tDitto.\n\t* tree-vectorizer.c (slpeel_update_phis_for_duplicate_loop,\n\tslpeel_update_phi_nodes_for_guard1, slpeel_update_phi_nodes_for_guard2,\n\tslpeel_make_loop_iterate_ntimes,\n\tslpeel_tree_duplicate_loop_to_edge_cfg, slpeel_can_duplicate_loop_p,\n\tslpeel_verify_cfg_after_peeling, slpeel_tree_peel_loop_to_edge):\n\tDitto.\n\t* tree-if-conv.c (if_convertible_loop_p): Ditto.\n\t* tree-vect-analyze.c (vect_analyze_operations, vect_stmt_relevant_p,\n\tvect_analyze_loop_form): Ditto.\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest, exit_phi_for_loop_p,\n\tcan_convert_to_perfect_nest, perfect_nestify): Ditto.\n\t* tree-vect-transform.c (vect_create_epilog_for_reduction,\n\tvect_update_ivs_after_vectorizer, vect_do_peeling_for_loop_bound,\n\tvect_transform_loop): Ditto.\n\t* cfgloop.c (mark_single_exit_loops, verify_loop_structure): Ditto.\n\t(single_exit, set_single_exit): New functions.\n\t* cfgloop.h (struct loop): Rename single_exit field to single_exit_.\n\t(single_exit, set_single_exit): Declare.\n\t* doc/loop.texi: Undocument single_exit field.  Document single_exit\n\taccessor function.\n\nFrom-SVN: r119075", "tree": {"sha": "bf6b0974fc31405c052970da079d8c6c75d72a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf6b0974fc31405c052970da079d8c6c75d72a63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/comments", "author": null, "committer": null, "parents": [{"sha": "bf8dbe38637ce885c1b7af763f7728955083195e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf8dbe38637ce885c1b7af763f7728955083195e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf8dbe38637ce885c1b7af763f7728955083195e"}], "stats": {"total": 236, "additions": 147, "deletions": 89}, "files": [{"sha": "1ed3890c8e4c4934d85d899c8236b74b638f06b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -1,3 +1,39 @@\n+2006-11-22  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-loop-linear.c (linear_transform_loops): Use single_exit accessor\n+\tfunctions.\n+\t* tree-ssa-loop-niter.c (loop_only_exit_p): Ditto.\n+\t* cfgloopmanip.c (update_single_exits_after_duplication,\n+\tupdate_single_exit_for_duplicated_loop, loop_version): Ditto.\n+\t* tree-scalar-evolution.c (get_loop_exit_condition,\n+\tget_exit_conditions_rec, loop_closed_phi_def,\n+\tnumber_of_iterations_in_loop, scev_const_prop): Ditto.\n+\t* tree-ssa-loop-ivopts.c (single_dom_exit): Ditto.\n+\t* modulo-sched.c (generate_prolog_epilog, loop_canon_p, sms_schedule):\n+\tDitto.\n+\t* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):\n+\tDitto.\n+\t* tree-vectorizer.c (slpeel_update_phis_for_duplicate_loop,\n+\tslpeel_update_phi_nodes_for_guard1, slpeel_update_phi_nodes_for_guard2,\n+\tslpeel_make_loop_iterate_ntimes,\n+\tslpeel_tree_duplicate_loop_to_edge_cfg, slpeel_can_duplicate_loop_p,\n+\tslpeel_verify_cfg_after_peeling, slpeel_tree_peel_loop_to_edge):\n+\tDitto.\n+\t* tree-if-conv.c (if_convertible_loop_p): Ditto.\n+\t* tree-vect-analyze.c (vect_analyze_operations, vect_stmt_relevant_p,\n+\tvect_analyze_loop_form): Ditto.\n+\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest, exit_phi_for_loop_p,\n+\tcan_convert_to_perfect_nest, perfect_nestify): Ditto.\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction,\n+\tvect_update_ivs_after_vectorizer, vect_do_peeling_for_loop_bound,\n+\tvect_transform_loop): Ditto.\n+\t* cfgloop.c (mark_single_exit_loops, verify_loop_structure): Ditto.\n+\t(single_exit, set_single_exit): New functions.\n+\t* cfgloop.h (struct loop): Rename single_exit field to single_exit_.\n+\t(single_exit, set_single_exit): Declare.\n+\t* doc/loop.texi: Undocument single_exit field.  Document single_exit\n+\taccessor function.\n+\n 2006-11-22  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/29902"}, {"sha": "b168b9792b8467f6b77c9bcc159cd43105aeee66", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -251,7 +251,7 @@ mark_single_exit_loops (struct loops *loops)\n     {\n       loop = loops->parray[i];\n       if (loop)\n-\tloop->single_exit = NULL;\n+\tset_single_exit (loop, NULL);\n     }\n \n   FOR_EACH_BB (bb)\n@@ -273,10 +273,10 @@ mark_single_exit_loops (struct loops *loops)\n \t    {\n \t      /* If we have already seen an exit, mark this by the edge that\n \t\t surely does not occur as any exit.  */\n-\t      if (loop->single_exit)\n-\t\tloop->single_exit = single_succ_edge (ENTRY_BLOCK_PTR);\n+\t      if (single_exit (loop))\n+\t\tset_single_exit (loop, single_succ_edge (ENTRY_BLOCK_PTR));\n \t      else\n-\t\tloop->single_exit = e;\n+\t\tset_single_exit (loop, e);\n \t    }\n \t}\n     }\n@@ -287,8 +287,8 @@ mark_single_exit_loops (struct loops *loops)\n       if (!loop)\n \tcontinue;\n \n-      if (loop->single_exit == single_succ_edge (ENTRY_BLOCK_PTR))\n-\tloop->single_exit = NULL;\n+      if (single_exit (loop) == single_succ_edge (ENTRY_BLOCK_PTR))\n+\tset_single_exit (loop, NULL);\n     }\n \n   loops->state |= LOOPS_HAVE_MARKED_SINGLE_EXITS;\n@@ -1142,12 +1142,12 @@ verify_loop_structure (struct loops *loops)\n \t\t   loop = loop->outer)\n \t\t{\n \t\t  sizes[loop->num]++;\n-\t\t  if (loop->single_exit\n-\t\t      && loop->single_exit != e)\n+\t\t  if (single_exit (loop)\n+\t\t      && single_exit (loop) != e)\n \t\t    {\n \t\t      error (\"wrong single exit %d->%d recorded for loop %d\",\n-\t\t\t     loop->single_exit->src->index,\n-\t\t\t     loop->single_exit->dest->index,\n+\t\t\t     single_exit (loop)->src->index,\n+\t\t\t     single_exit (loop)->dest->index,\n \t\t\t     loop->num);\n \t\t      error (\"right exit is %d->%d\",\n \t\t\t     e->src->index, e->dest->index);\n@@ -1164,19 +1164,19 @@ verify_loop_structure (struct loops *loops)\n \t    continue;\n \n \t  if (sizes[i] == 1\n-\t      && !loop->single_exit)\n+\t      && !single_exit (loop))\n \t    {\n \t      error (\"single exit not recorded for loop %d\", loop->num);\n \t      err = 1;\n \t    }\n \n \t  if (sizes[i] != 1\n-\t      && loop->single_exit)\n+\t      && single_exit (loop))\n \t    {\n \t      error (\"loop %d should not have single exit (%d -> %d)\",\n \t\t     loop->num,\n-\t\t     loop->single_exit->src->index,\n-\t\t     loop->single_exit->dest->index);\n+\t\t     single_exit (loop)->src->index,\n+\t\t     single_exit (loop)->dest->index);\n \t      err = 1;\n \t    }\n \t}\n@@ -1216,3 +1216,20 @@ loop_exit_edge_p (const struct loop *loop, edge e)\n   return (flow_bb_inside_loop_p (loop, e->src)\n \t  && !flow_bb_inside_loop_p (loop, e->dest));\n }\n+\n+/* Returns the single exit edge of LOOP, or NULL if LOOP has either no exit\n+   or more than one exit.  */\n+\n+edge\n+single_exit (const struct loop *loop)\n+{\n+  return loop->single_exit_;\n+}\n+\n+/* Records E as a single exit edge of LOOP.  */\n+\n+void\n+set_single_exit (struct loop *loop, edge e)\n+{\n+  loop->single_exit_ = e;\n+}"}, {"sha": "aa648c256293da301c9f7d5295b26605e8e6f69b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -143,8 +143,9 @@ struct loop\n   struct nb_iter_bound *bounds;\n \n   /* If not NULL, loop has just single exit edge stored here (edges to the\n-     EXIT_BLOCK_PTR do not count.  */\n-  edge single_exit;\n+     EXIT_BLOCK_PTR do not count.  Do not use direcly, this field should\n+     only be accessed via single_exit/set_single_exit functions.  */\n+  edge single_exit_;\n \n   /* True when the loop does not carry data dependences, and\n      consequently the iterations can be executed in any order.  False\n@@ -219,6 +220,8 @@ extern basic_block *get_loop_body (const struct loop *);\n extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);\n+edge single_exit (const struct loop *);\n+void set_single_exit (struct loop *, edge);\n extern unsigned num_loop_branches (const struct loop *);\n \n extern edge loop_preheader_edge (const struct loop *);"}, {"sha": "63cab6073b7898c31eae668f19deb46fd088c710", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -766,11 +766,11 @@ update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n \n   for (; loop->outer; loop = loop->outer)\n     {\n-      if (!loop->single_exit)\n+      if (!single_exit (loop))\n \tcontinue;\n \n-      if (loop->single_exit->src->flags & BB_DUPLICATED)\n-\tloop->single_exit = NULL;\n+      if (single_exit (loop)->src->flags & BB_DUPLICATED)\n+\tset_single_exit (loop, NULL);\n     }\n \n   for (i = 0; i < nbbs; i++)\n@@ -784,7 +784,7 @@ update_single_exit_for_duplicated_loop (struct loop *loop)\n {\n   struct loop *copy = loop->copy;\n   basic_block src, dest;\n-  edge exit = loop->single_exit;\n+  edge exit = single_exit (loop);\n \n   if (!exit)\n     return;\n@@ -796,7 +796,7 @@ update_single_exit_for_duplicated_loop (struct loop *loop)\n \n   exit = find_edge (src, dest);\n   gcc_assert (exit != NULL);\n-  copy->single_exit = exit;\n+  set_single_exit (copy, exit);\n }\n \n /* Updates single exit information for copies of ORIG_LOOPS and their subloops.\n@@ -1336,9 +1336,9 @@ loop_version (struct loops *loops, struct loop * loop,\n \t\t   cond_bb, true_edge, false_edge,\n \t\t   false /* Do not redirect all edges.  */);\n \n-  exit = loop->single_exit;\n+  exit = single_exit (loop);\n   if (exit)\n-    nloop->single_exit = find_edge (get_bb_copy (exit->src), exit->dest);\n+    set_single_exit (nloop, find_edge (get_bb_copy (exit->src), exit->dest));\n \n   /* loopify redirected latch_edge. Update its PENDING_STMTS.  */\n   lv_flush_pending_stmts (latch_edge);"}, {"sha": "642a52374d4575fabf37abdf6d445e12f3895504", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -104,8 +104,8 @@ flag is not set for blocks and edges that belong to natural loops that\n are in such an irreducible region (but it is set for the entry and exit\n edges of such a loop, if they lead to/from this region).\n @item @code{LOOPS_HAVE_MARKED_SINGLE_EXITS}: If a loop has exactly one\n-exit edge, this edge is stored in @code{single_exit} field of the loop\n-structure.  @code{NULL} is stored there otherwise.\n+exit edge, this edge is recorded in the loop structure.  @code{single_exit}\n+function can be used to retrieve this edge.\n @end itemize\n \n These properties may also be computed/enforced later, using functions\n@@ -140,9 +140,6 @@ the basic blocks of the sub-loops).\n number of super-loops of the loop.\n @item @code{outer}, @code{inner}, @code{next}: The super-loop, the first\n sub-loop, and the sibling of the loop in the loops tree.\n-@item @code{single_exit}: The exit edge of the loop, if the loop has\n-exactly one exit and the loops were analyzed with\n-LOOPS_HAVE_MARKED_SINGLE_EXITS.\n @end itemize\n \n There are other fields in the loop structures, many of them used only by\n@@ -176,6 +173,9 @@ with @code{EDGE_LOOP_EXIT} flag.\n @code{get_loop_body_in_bfs_order}: Enumerates the basic blocks in the\n loop in depth-first search order in reversed CFG, ordered by dominance\n relation, and breath-first search order, respectively.\n+@item @code{single_exit}: Returns the single exit edge of the loop, or\n+@code{NULL} if the loop has more than one exit.  You can only use this\n+function if LOOPS_HAVE_MARKED_SINGLE_EXITS property is used.\n @item @code{get_loop_exit_edges}: Enumerates the exit edges of a loop.\n @item @code{just_once_each_iteration_p}: Returns true if the basic block\n is executed exactly once during each iteration of a loop (that is, it"}, {"sha": "f4fce423243a438e3e301e4f60a245c8ce95a8e2", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -1875,7 +1875,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t\t     type,\n \t\t\t\t\t     new_ivs,\n \t\t\t\t\t     invariants, MIN_EXPR, &stmts);\n-      exit = temp->single_exit;\n+      exit = single_exit (temp);\n       exitcond = get_loop_exit_condition (temp);\n       bb = bb_for_stmt (exitcond);\n       bsi = bsi_start (bb);\n@@ -2211,7 +2211,7 @@ exit_phi_for_loop_p (struct loop *loop, tree stmt)\n   \n   if (TREE_CODE (stmt) != PHI_NODE\n       || PHI_NUM_ARGS (stmt) != 1\n-      || bb_for_stmt (stmt) != loop->single_exit->dest)\n+      || bb_for_stmt (stmt) != single_exit (loop)->dest)\n     return false;\n   \n   return true;\n@@ -2387,7 +2387,7 @@ can_convert_to_perfect_nest (struct loop *loop)\n   /* We also need to make sure the loop exit only has simple copy phis in it,\n      otherwise we don't know how to transform it into a perfect nest right\n      now.  */\n-  exitdest = loop->single_exit->dest;\n+  exitdest = single_exit (loop)->dest;\n   \n   for (phi = phi_nodes (exitdest); phi; phi = PHI_CHAIN (phi))\n     if (PHI_NUM_ARGS (phi) != 1)\n@@ -2463,8 +2463,8 @@ perfect_nestify (struct loops *loops,\n   htab_t replacements = NULL;\n \n   /* Create the new loop.  */\n-  olddest = loop->single_exit->dest;\n-  preheaderbb = split_edge (loop->single_exit);\n+  olddest = single_exit (loop)->dest;\n+  preheaderbb = split_edge (single_exit (loop));\n   headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   \n   /* Push the exit phi nodes that we are moving.  */\n@@ -2517,14 +2517,14 @@ perfect_nestify (struct loops *loops,\n   newloop = duplicate_loop (loops, loop, olddest->loop_father);  \n   newloop->header = headerbb;\n   newloop->latch = latchbb;\n-  newloop->single_exit = e;\n+  set_single_exit (newloop, e);\n   add_bb_to_loop (latchbb, newloop);\n   add_bb_to_loop (bodybb, newloop);\n   add_bb_to_loop (headerbb, newloop);\n   set_immediate_dominator (CDI_DOMINATORS, bodybb, headerbb);\n   set_immediate_dominator (CDI_DOMINATORS, headerbb, preheaderbb);\n   set_immediate_dominator (CDI_DOMINATORS, preheaderbb, \n-\t\t\t   loop->single_exit->src);\n+\t\t\t   single_exit (loop)->src);\n   set_immediate_dominator (CDI_DOMINATORS, latchbb, bodybb);\n   set_immediate_dominator (CDI_DOMINATORS, olddest, bodybb);\n   /* Create the new iv.  */"}, {"sha": "a7dae15e0151069b235535c3ee197beb7abcfd7f", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -755,8 +755,8 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_r\n     duplicate_insns_of_cycles (ps, i + 1, last_stage, 0);\n \n   /* Put the epilogue on the exit edge.  */\n-  gcc_assert (loop->single_exit);\n-  e = loop->single_exit;\n+  gcc_assert (single_exit (loop));\n+  e = single_exit (loop);\n   split_edge_and_insert (e, get_insns());\n   end_sequence ();\n }\n@@ -814,7 +814,7 @@ loop_canon_p (struct loop *loop)\n   if (loop->inner || ! loop->outer)\n     return false;\n \n-  if (!loop->single_exit)\n+  if (!single_exit (loop))\n     {\n       if (dump_file)\n \t{\n@@ -943,14 +943,14 @@ sms_schedule (void)\n \n       get_ebb_head_tail (bb, bb, &head, &tail);\n       latch_edge = loop_latch_edge (loop);\n-      gcc_assert (loop->single_exit);\n-      if (loop->single_exit->count)\n-\ttrip_count = latch_edge->count / loop->single_exit->count;\n+      gcc_assert (single_exit (loop));\n+      if (single_exit (loop)->count)\n+\ttrip_count = latch_edge->count / single_exit (loop)->count;\n \n       /* Perfrom SMS only on loops that their average count is above threshold.  */\n \n       if ( latch_edge->count\n-          && (latch_edge->count < loop->single_exit->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n+          && (latch_edge->count < single_exit (loop)->count * SMS_LOOP_AVERAGE_COUNT_THRESHOLD))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1037,9 +1037,9 @@ sms_schedule (void)\n       get_ebb_head_tail (loop->header, loop->header, &head, &tail);\n \n       latch_edge = loop_latch_edge (loop);\n-      gcc_assert (loop->single_exit);\n-      if (loop->single_exit->count)\n-\ttrip_count = latch_edge->count / loop->single_exit->count;\n+      gcc_assert (single_exit (loop));\n+      if (single_exit (loop)->count)\n+\ttrip_count = latch_edge->count / single_exit (loop)->count;\n \n       if (dump_file)\n \t{"}, {"sha": "7ccb48c927374a3939edd07b16392459f8b2cce1", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -521,7 +521,7 @@ if_convertible_loop_p (struct loop *loop, bool for_vectorizer ATTRIBUTE_UNUSED)\n     }\n \n   /* More than one loop exit is too much to handle.  */\n-  if (!loop->single_exit)\n+  if (!single_exit (loop))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"multiple exits\\n\");"}, {"sha": "89bd1e83da4a1e8603ca3c5db280c69e8aa229ff", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -270,15 +270,15 @@ linear_transform_loops (struct loops *loops)\n                 ...\n                }\n            } */\n-      if (!loop_nest || !loop_nest->inner || !loop_nest->single_exit)\n+      if (!loop_nest || !loop_nest->inner || !single_exit (loop_nest))\n \tcontinue;\n       VEC_truncate (tree, oldivs, 0);\n       VEC_truncate (tree, invariants, 0);\n       depth = 1;\n       for (temp = loop_nest->inner; temp; temp = temp->inner)\n \t{\n \t  /* If we have a sibling loop or multiple exit edges, jump ship.  */\n-\t  if (temp->next || !temp->single_exit)\n+\t  if (temp->next || !single_exit (temp))\n \t    {\n \t      problem = true;\n \t      break;"}, {"sha": "d4570a571e3ed38fb735006fedb9f5460e5ed0a1", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -966,8 +966,7 @@ tree\n get_loop_exit_condition (struct loop *loop)\n {\n   tree res = NULL_TREE;\n-  edge exit_edge = loop->single_exit;\n-\n+  edge exit_edge = single_exit (loop);\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(get_loop_exit_condition \\n  \");\n@@ -1003,7 +1002,7 @@ get_exit_conditions_rec (struct loop *loop,\n   get_exit_conditions_rec (loop->inner, exit_conditions);\n   get_exit_conditions_rec (loop->next, exit_conditions);\n   \n-  if (loop->single_exit)\n+  if (single_exit (loop))\n     {\n       tree loop_condition = get_loop_exit_condition (loop);\n       \n@@ -2107,7 +2106,7 @@ loop_closed_phi_def (tree var)\n     return NULL_TREE;\n \n   loop = loop_containing_stmt (SSA_NAME_DEF_STMT (var));\n-  exit = loop->single_exit;\n+  exit = single_exit (loop);\n   if (!exit)\n     return NULL_TREE;\n \n@@ -2485,7 +2484,7 @@ number_of_iterations_in_loop (struct loop *loop)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(number_of_iterations_in_loop\\n\");\n   \n-  exit = loop->single_exit;\n+  exit = single_exit (loop);\n   if (!exit)\n     goto end;\n \n@@ -2961,7 +2960,7 @@ scev_const_prop (void)\n \n       /* If we do not know exact number of iterations of the loop, we cannot\n \t replace the final value.  */\n-      exit = loop->single_exit;\n+      exit = single_exit (loop);\n       if (!exit)\n \tcontinue;\n "}, {"sha": "46e153176830a1a05a712ae65b7818bcf51d5a14", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -283,7 +283,7 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n   niter = number_of_iterations_in_loop (loop);\n   if (TREE_CODE (niter) == INTEGER_CST)\n     {\n-      exit = loop->single_exit;\n+      exit = single_exit (loop);\n       if (!just_once_each_iteration_p (loop, exit->src))\n \treturn false;\n \n@@ -297,7 +297,7 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n     {\n       /* If the loop has more than one exit, try checking all of them\n \t for # of iterations determinable through scev.  */\n-      if (!loop->single_exit)\n+      if (!single_exit (loop))\n \tniter = find_loop_niter (loop, &exit);\n \n       /* Finally if everything else fails, try brute force evaluation.  */"}, {"sha": "0842fd09dda86bf89308072299726f2ebb9b78fe", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -349,7 +349,7 @@ iv_cand (struct ivopts_data *data, unsigned i)\n edge\n single_dom_exit (struct loop *loop)\n {\n-  edge exit = loop->single_exit;\n+  edge exit = single_exit (loop);\n \n   if (!exit)\n     return NULL;"}, {"sha": "6fad5c3f9eb92f067671f9751da25cfc1d51acbb", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -1006,7 +1006,7 @@ loop_only_exit_p (struct loop *loop, edge exit)\n   unsigned i;\n   tree call;\n \n-  if (exit != loop->single_exit)\n+  if (exit != single_exit (loop))\n     return false;\n \n   body = get_loop_body (loop);"}, {"sha": "190e7dc8badc731fcb1026fd0e9afbfefb342713", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -384,7 +384,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n                      \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n-      if (!slpeel_can_duplicate_loop_p (loop, loop->single_exit))\n+      if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n             fprintf (vect_dump,\n@@ -1522,7 +1522,7 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n \t      /* We expect all such uses to be in the loop exit phis\n \t\t (because of loop closed form)   */\n \t      gcc_assert (TREE_CODE (USE_STMT (use_p)) == PHI_NODE);\n-\t      gcc_assert (bb == loop->single_exit->dest);\n+\t      gcc_assert (bb == single_exit (loop)->dest);\n \n               *live_p = true;\n \t    }\n@@ -1873,13 +1873,13 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n   \n-  if (!loop->single_exit \n+  if (!single_exit (loop) \n       || loop->num_nodes != 2\n       || EDGE_COUNT (loop->header->preds) != 2)\n     {\n       if (vect_print_dump_info (REPORT_BAD_FORM_LOOPS))\n         {\n-          if (!loop->single_exit)\n+          if (!single_exit (loop))\n             fprintf (vect_dump, \"not vectorized: multiple exits.\");\n           else if (loop->num_nodes != 2)\n             fprintf (vect_dump, \"not vectorized: too many BBs in loop.\");\n@@ -1903,9 +1903,9 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n \n   /* Make sure there exists a single-predecessor exit bb:  */\n-  if (!single_pred_p (loop->single_exit->dest))\n+  if (!single_pred_p (single_exit (loop)->dest))\n     {\n-      edge e = loop->single_exit;\n+      edge e = single_exit (loop);\n       if (!(e->flags & EDGE_ABNORMAL))\n \t{\n \t  split_loop_exit_edge (e);"}, {"sha": "b57208e21827c93d69f2c412d7d723c452f7eb56", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -995,9 +995,9 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   /* 2.1 Create new loop-exit-phi to preserve loop-closed form:\n         v_out1 = phi <v_loop>  */\n \n-  exit_bb = loop->single_exit->dest;\n+  exit_bb = single_exit (loop)->dest;\n   new_phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n-  SET_PHI_ARG_DEF (new_phi, loop->single_exit->dest_idx, vect_def);\n+  SET_PHI_ARG_DEF (new_phi, single_exit (loop)->dest_idx, vect_def);\n   exit_bsi = bsi_start (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n@@ -3325,7 +3325,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \t\t\t\t  edge update_e)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block exit_bb = loop->single_exit->dest;\n+  basic_block exit_bb = single_exit (loop)->dest;\n   tree phi, phi1;\n   basic_block update_bb = update_e->dest;\n \n@@ -3436,7 +3436,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \t\t\t\t   &ratio_mult_vf_name, ratio);\n \n   loop_num  = loop->num; \n-  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, loop->single_exit,\n+  new_loop = slpeel_tree_peel_loop_to_edge (loop, loops, single_exit (loop),\n \t\t\t\t\t    ratio_mult_vf_name, ni_name, false);\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n@@ -3451,7 +3451,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n      is on the path where the LOOP IVs are used and need to be updated.  */\n \n   preheader = loop_preheader_edge (new_loop)->src;\n-  if (EDGE_PRED (preheader, 0)->src == loop->single_exit->dest)\n+  if (EDGE_PRED (preheader, 0)->src == single_exit (loop)->dest)\n     update_e = EDGE_PRED (preheader, 0);\n   else\n     update_e = EDGE_PRED (preheader, 1);\n@@ -3842,10 +3842,10 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t here by adding a new (empty) block on the exit-edge of the loop,\n \t with the proper loop-exit phis to maintain loop-closed-form.  **/\n       \n-      merge_bb = loop->single_exit->dest;\n+      merge_bb = single_exit (loop)->dest;\n       gcc_assert (EDGE_COUNT (merge_bb->preds) == 2);\n-      new_exit_bb = split_edge (loop->single_exit);\n-      new_exit_e = loop->single_exit;\n+      new_exit_bb = split_edge (single_exit (loop));\n+      new_exit_e = single_exit (loop);\n       e = EDGE_SUCC (new_exit_bb, 0);\n \n       for (orig_phi = phi_nodes (merge_bb); orig_phi; "}, {"sha": "7fa5d668e2432ab472561f6791efabed5255af1e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f6c69032b9a07b3036a2514bd59353b2a32c3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ac8f6c69032b9a07b3036a2514bd59353b2a32c3", "patch": "@@ -279,7 +279,7 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n   tree def;\n   edge orig_loop_latch = loop_latch_edge (orig_loop);\n   edge orig_entry_e = loop_preheader_edge (orig_loop);\n-  edge new_loop_exit_e = new_loop->single_exit;\n+  edge new_loop_exit_e = single_exit (new_loop);\n   edge new_loop_entry_e = loop_preheader_edge (new_loop);\n   edge entry_arg_e = (after ? orig_loop_latch : orig_entry_e);\n \n@@ -519,7 +519,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n   tree name;\n \n   /* Create new bb between loop and new_merge_bb.  */\n-  *new_exit_bb = split_edge (loop->single_exit);\n+  *new_exit_bb = split_edge (single_exit (loop));\n \n   new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n \n@@ -564,7 +564,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n                                  *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n+      add_phi_arg (new_phi, loop_arg, single_exit (loop));\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n@@ -644,7 +644,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n   tree arg;\n \n   /* Create new bb between loop and new_merge_bb.  */\n-  *new_exit_bb = split_edge (loop->single_exit);\n+  *new_exit_bb = split_edge (single_exit (loop));\n \n   new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n \n@@ -709,7 +709,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n                                  *new_exit_bb);\n \n       /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n-      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n+      add_phi_arg (new_phi, loop_arg, single_exit (loop));\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n@@ -766,12 +766,12 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n {\n   tree indx_before_incr, indx_after_incr, cond_stmt, cond;\n   tree orig_cond;\n-  edge exit_edge = loop->single_exit;\n+  edge exit_edge = single_exit (loop);\n   block_stmt_iterator loop_cond_bsi;\n   block_stmt_iterator incr_bsi;\n   bool insert_after;\n   tree begin_label = tree_block_label (loop->latch);\n-  tree exit_label = tree_block_label (loop->single_exit->dest);\n+  tree exit_label = tree_block_label (single_exit (loop)->dest);\n   tree init = build_int_cst (TREE_TYPE (niters), 0);\n   tree step = build_int_cst (TREE_TYPE (niters), 1);\n   tree then_label;\n@@ -832,8 +832,9 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   bool was_imm_dom;\n   basic_block exit_dest; \n   tree phi, phi_arg;\n+  edge exit, new_exit;\n \n-  at_exit = (e == loop->single_exit); \n+  at_exit = (e == single_exit (loop)); \n   if (!at_exit && e != loop_preheader_edge (loop))\n     return NULL;\n \n@@ -854,22 +855,24 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n       return NULL;\n     }\n \n-  exit_dest = loop->single_exit->dest;\n+  exit_dest = single_exit (loop)->dest;\n   was_imm_dom = (get_immediate_dominator (CDI_DOMINATORS, \n \t\t\t\t\t  exit_dest) == loop->header ? \n \t\t true : false);\n \n   new_bbs = XNEWVEC (basic_block, loop->num_nodes);\n \n+  exit = single_exit (loop);\n   copy_bbs (bbs, loop->num_nodes, new_bbs,\n-\t    &loop->single_exit, 1, &new_loop->single_exit, NULL,\n+\t    &exit, 1, &new_exit, NULL,\n \t    e->src);\n+  set_single_exit (new_loop, new_exit);\n \n   /* Duplicating phi args at exit bbs as coming \n      also from exit of duplicated loop.  */\n   for (phi = phi_nodes (exit_dest); phi; phi = PHI_CHAIN (phi))\n     {\n-      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, loop->single_exit);\n+      phi_arg = PHI_ARG_DEF_FROM_EDGE (phi, single_exit (loop));\n       if (phi_arg)\n \t{\n \t  edge new_loop_exit_edge;\n@@ -969,7 +972,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n bool\n slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n {\n-  edge exit_e = loop->single_exit;\n+  edge exit_e = single_exit (loop);\n   edge entry_e = loop_preheader_edge (loop);\n   tree orig_cond = get_loop_exit_condition (loop);\n   block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n@@ -983,7 +986,7 @@ slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n       || !loop->outer\n       || loop->num_nodes != 2\n       || !empty_block_p (loop->latch)\n-      || !loop->single_exit\n+      || !single_exit (loop)\n       /* Verify that new loop exit condition can be trivially modified.  */\n       || (!orig_cond || orig_cond != bsi_stmt (loop_exit_bsi))\n       || (e != exit_e && e != entry_e))\n@@ -997,7 +1000,7 @@ void\n slpeel_verify_cfg_after_peeling (struct loop *first_loop,\n                                  struct loop *second_loop)\n {\n-  basic_block loop1_exit_bb = first_loop->single_exit->dest;\n+  basic_block loop1_exit_bb = single_exit (first_loop)->dest;\n   basic_block loop2_entry_bb = loop_preheader_edge (second_loop)->src;\n   basic_block loop1_entry_bb = loop_preheader_edge (first_loop)->src;\n \n@@ -1076,7 +1079,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n   basic_block new_exit_bb;\n-  edge exit_e = loop->single_exit;\n+  edge exit_e = single_exit (loop);\n   LOC loop_loc;\n   \n   if (!slpeel_can_duplicate_loop_p (loop, e))\n@@ -1155,7 +1158,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n    */\n \n   bb_before_first_loop = split_edge (loop_preheader_edge (first_loop));\n-  bb_before_second_loop = split_edge (first_loop->single_exit);\n+  bb_before_second_loop = split_edge (single_exit (first_loop));\n \n   pre_condition =\n     fold_build2 (LE_EXPR, boolean_type_node, first_niters, \n@@ -1194,7 +1197,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n    */\n \n   bb_between_loops = new_exit_bb;\n-  bb_after_second_loop = split_edge (second_loop->single_exit);\n+  bb_after_second_loop = split_edge (single_exit (second_loop));\n \n   pre_condition = \n \tfold_build2 (EQ_EXPR, boolean_type_node, first_niters, niters);"}]}