{"sha": "50714e797cc4cfea26a05bb4d740bf75fa36aab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3MTRlNzk3Y2M0Y2ZlYTI2YTA1YmI0ZDc0MGJmNzVmYTM2YWFiMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-12-16T15:51:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-16T15:51:21Z"}, "message": "class.c (resolve_address_of_overloaded_function): Do conversion to correct type here, rather than ...\n\n\t* class.c (resolve_address_of_overloaded_function): Do conversion\n\tto correct type here, rather than ...\n\t(instantiate_type): Here.\n\t* cp-tree.h (DECL_TEMPLATE_PARM_P): New macro.\n\t(DECL_TEMPLATE_TEMPLATE_PARM_P): Use it.\n\t(decl_template_parm_p): Remove.\n\t* decl.c (pushdecl): Don't set DECL_CONTEXT for a template\n\tparamter.\n\t* lex.c (do_identifier): Use DECL_TEMPLATE_PARM_P.\n\t(push_inline_template_parms_recursive): Set it.\n\t(decl_template_parm_p): Remove.\n\t(check_template_shadow): Use DECL_TEMPLATE_PARM_P.\n\t(process_template_parm): Set it.\n\nFrom-SVN: r24344", "tree": {"sha": "9ba08fcbc1251b50b01a06eebf94cfd3de9e82ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ba08fcbc1251b50b01a06eebf94cfd3de9e82ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50714e797cc4cfea26a05bb4d740bf75fa36aab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50714e797cc4cfea26a05bb4d740bf75fa36aab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50714e797cc4cfea26a05bb4d740bf75fa36aab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50714e797cc4cfea26a05bb4d740bf75fa36aab0/comments", "author": null, "committer": null, "parents": [{"sha": "05c32e169c2f0d30db29a198693c3e6a7a08c4ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05c32e169c2f0d30db29a198693c3e6a7a08c4ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05c32e169c2f0d30db29a198693c3e6a7a08c4ff"}], "stats": {"total": 167, "additions": 97, "deletions": 70}, "files": [{"sha": "6a05c558766639a0bf334f79c744515381abc411", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -1,3 +1,20 @@\n+1998-12-16  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (resolve_address_of_overloaded_function): Do conversion\n+\tto correct type here, rather than ...\n+\t(instantiate_type): Here.\n+\n+\t* cp-tree.h (DECL_TEMPLATE_PARM_P): New macro.\n+\t(DECL_TEMPLATE_TEMPLATE_PARM_P): Use it.\n+\t(decl_template_parm_p): Remove.\n+\t* decl.c (pushdecl): Don't set DECL_CONTEXT for a template\n+\tparamter. \n+\t* lex.c (do_identifier): Use DECL_TEMPLATE_PARM_P.\n+\t(push_inline_template_parms_recursive): Set it.\n+\t(decl_template_parm_p): Remove.\n+\t(check_template_shadow): Use DECL_TEMPLATE_PARM_P.\n+\t(process_template_parm): Set it.\n+\t\n Wed Dec 16 16:33:58 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* lang-specs.h (default_compilers): Pass -MD, -MMD and -MG to cc1plus"}, {"sha": "694ac0b22ba3ec682cae363520d1fc0670bfa43a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -5025,6 +5025,7 @@ resolve_address_of_overloaded_function (target_type,\n      are the TREE_PURPOSE, not the TREE_VALUE, in this list, for easy\n      interoperability with most_specialized_instantiation.  */\n   tree matches = NULL_TREE;\n+  tree fn;\n \n   /* By the time we get here, we should be seeing only real\n      pointer-to-member types, not the internal POINTER_TYPE to\n@@ -5212,8 +5213,20 @@ resolve_address_of_overloaded_function (target_type,\n       return error_mark_node;\n     }\n \n-  /* Good, exactly one match.  */\n-  return TREE_PURPOSE (matches);\n+  /* Good, exactly one match.  Now, convert it to the correct type.  */\n+  fn = TREE_PURPOSE (matches);\n+\n+  if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n+    return build_unary_op (ADDR_EXPR, fn, 0);\n+  else\n+    {\n+      /* The target must be a REFERENCE_TYPE.  Above, build_unary_op\n+\t will mark the function as addressed, but here we must do it\n+\t explicitly.  */\n+      mark_addressable (fn);\n+\n+      return fn;\n+    }\n }\n \n /* This function will instantiate the type of the expression given in\n@@ -5291,33 +5304,31 @@ instantiate_type (lhstype, rhs, complain)\n     case COMPONENT_REF:\n       {\n \ttree field = TREE_OPERAND (rhs, 1);\n-\tif (TREE_CODE (field) == TREE_LIST)\n-\t  {\n-\t    tree function = instantiate_type (lhstype, field, complain);\n-\t    if (function == error_mark_node)\n-\t      return error_mark_node;\n-\t    my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 185);\n+\ttree r;\n+\n+\tmy_friendly_assert (TREE_CODE (field) == TREE_LIST, 0);\n \n-\t    if (! DECL_STATIC_FUNCTION_P (function))\n+\tr = instantiate_type (lhstype, field, complain);\n+\n+\tif (r != error_mark_node && TYPE_PTRMEMFUNC_P (lhstype))\n+\t  {\n+\t    tree t = TYPE_PTRMEMFUNC_OBJECT_TYPE (lhstype);\n+\t    tree fn = TREE_VALUE (field);\n+\t    if (TREE_CODE (fn) == OVERLOAD)\n+\t      fn = OVL_FUNCTION (fn);\n+\t    if (TREE_CODE (fn) == FUNCTION_DECL)\n \t      {\n-\t\ttree t = TREE_TYPE (TREE_OPERAND (rhs, 0));\n-\t\tif (TYPE_MAIN_VARIANT (t) == current_class_type)\n-\t\t  t = constructor_name (t);\n-\n-\t\tcp_error (\"object-dependent reference to `%D' can only be used in a call\",\n-\t\t\t  function);\n-\t\tcp_error (\"  to form a pointer to member function, say `&%T::%D'\",\n-\t\t\t  t, DECL_NAME (function));\n-\t\treturn error_mark_node;\n+\t\tcp_error (\"object-dependent reference `%E' can only be used in a call\",\n+\t\t\t  DECL_NAME (fn));\n+\t\tcp_error (\"  to form a pointer to member function, say `&%T::%E'\",\n+\t\t\t  t, DECL_NAME (fn));\n \t      }\n-\n-\t    mark_used (function);\n-\t    return function;\n+\t    else\n+\t      cp_error (\"object-dependent reference can only be used in a call\");\n+\t    return error_mark_node;\n \t  }\n-\n-\t/* I could not trigger this code. MvL */\n-\tmy_friendly_abort (980326);\n-\treturn rhs;\n+\t\n+\treturn r;\n       }\n \n     case OFFSET_REF:\n@@ -5469,27 +5480,7 @@ instantiate_type (lhstype, rhs, complain)\n       return rhs;\n       \n     case ADDR_EXPR:\n-      {\n-\ttree fn = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n-\tif (fn == error_mark_node)\n-\t  return error_mark_node;\n-\tmark_addressable (fn);\n-\tTREE_OPERAND (rhs, 0) = fn;\n-\tTREE_CONSTANT (rhs) = staticp (fn);\n-\tif (TYPE_PTRMEMFUNC_P (lhstype))\n-\t  {\n-\t    /* We must use the POINTER_TYPE to METHOD_TYPE on RHS here\n-\t       so that build_ptrmemfunc knows that RHS we have is not\n-\t       already a pointer-to-member constant.  Instead, it is\n-\t       just a ADDR_EXPR over a FUNCTION_DECL.  */\n-\t    TREE_TYPE (rhs) = TYPE_PTRMEMFUNC_FN_TYPE (lhstype);\n-\t    rhs = build_ptrmemfunc (TREE_TYPE (rhs), rhs, 0);\n-\t  }\n-\telse\n-\t  /* Here, things our simple; we have exactly what we need.  */\n-\t  TREE_TYPE (rhs) = lhstype;\n-      }\n-      return rhs;\n+      return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n \n     case ENTRY_VALUE_EXPR:\n       my_friendly_abort (184);"}, {"sha": "cb55b0635dac129ce00fc00eeb5bffa121434334", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -65,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n \n    Usage of DECL_LANG_FLAG_?:\n    0: DECL_ERROR_REPORTED (in VAR_DECL).\n+      DECL_TEMPLATE_PARM_P (in CONST_DECL, TYPE_DECL, or TEMPLATE_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n@@ -1832,11 +1833,12 @@ extern int flag_new_for_scope;\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE(NODE)\n #define DECL_TEMPLATE_INJECT(NODE)\tDECL_INITIAL(NODE)\n \n-/* Nonzero for TEMPLATE_DECL nodes that represents template template\n-   parameters */\n+/* Nonzero for a DECL which is actually a template parameter.  */\n+#define DECL_TEMPLATE_PARM_P(NODE) \\\n+  DECL_LANG_FLAG_0 (NODE)\n+\n #define DECL_TEMPLATE_TEMPLATE_PARM_P(NODE) \\\n-  (TREE_CODE (NODE) == TEMPLATE_DECL && TREE_TYPE (NODE) \\\n-   && TREE_CODE (TREE_TYPE (NODE)) == TEMPLATE_TEMPLATE_PARM)\n+  (TREE_CODE (NODE) == TEMPLATE_DECL && DECL_TEMPLATE_PARM_P (NODE))\n \n #define DECL_FUNCTION_TEMPLATE_P(NODE)  \\\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n@@ -3070,7 +3072,6 @@ extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n extern int template_parms_equal                 PROTO((tree, tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n-extern int decl_template_parm_p\t\t\tPROTO((tree));\n extern int template_class_depth                 PROTO((tree));\n extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));"}, {"sha": "79c38f4323fc6bd3fda6bc503a17b47b77193e9c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -3514,15 +3514,23 @@ pushdecl (x)\n   register tree name = DECL_ASSEMBLER_NAME (x);\n   int need_new_binding = 1;\n \n-  if (current_function_decl && x != current_function_decl\n-      /* A local declaration for a function doesn't constitute nesting.  */\n-      && (TREE_CODE (x) != FUNCTION_DECL || DECL_INITIAL (x))\n-      /* Don't change DECL_CONTEXT of virtual methods.  */\n-      && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n-      && !DECL_CONTEXT (x))\n-    DECL_CONTEXT (x) = current_function_decl;\n-  if (!DECL_CONTEXT (x))\n-    DECL_CONTEXT (x) = FROB_CONTEXT (current_namespace);\n+  if (DECL_TEMPLATE_PARM_P (x))\n+    /* Template parameters have no context; they are not X::T even\n+       when declared within a class or namespace.  */\n+    ;\n+  else\n+    {\n+      if (current_function_decl && x != current_function_decl\n+\t  /* A local declaration for a function doesn't constitute\n+             nesting.  */\n+\t  && (TREE_CODE (x) != FUNCTION_DECL || DECL_INITIAL (x))\n+\t  /* Don't change DECL_CONTEXT of virtual methods.  */\n+\t  && (TREE_CODE (x) != FUNCTION_DECL || !DECL_VIRTUAL_P (x))\n+\t  && !DECL_CONTEXT (x))\n+\tDECL_CONTEXT (x) = current_function_decl;\n+      if (!DECL_CONTEXT (x))\n+\tDECL_CONTEXT (x) = FROB_CONTEXT (current_namespace);\n+    }\n \n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use.  */"}, {"sha": "d3b01a9452091057a2037dca539f66e1c83eb84c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -3051,16 +3051,7 @@ do_identifier (token, parsing, args)\n \t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n-      if (!processing_template_decl\n-\t  /* Really, if we're processing a template, we just want to\n-\t     resolve template parameters, and not enumeration\n-\t     constants.  But, they're hard to tell apart.  (Note that\n-\t     a non-type template parameter may have enumeration type.)\n-\t     Fortunately, there's no harm in resolving *global*\n-\t     enumeration constants, since they can't depend on\n-\t     template parameters.  */\n-\t  || (TREE_CODE (CP_DECL_CONTEXT (id)) == NAMESPACE_DECL\n-\t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_PARM_INDEX))\n+      if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n \tid = DECL_INITIAL (id);\n     }\n   else"}, {"sha": "dfe99c7b22d5c39db540a0a842f113fd35658c8d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/shadow1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fshadow1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714e797cc4cfea26a05bb4d740bf75fa36aab0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fshadow1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fshadow1.C?ref=50714e797cc4cfea26a05bb4d740bf75fa36aab0", "patch": "@@ -0,0 +1,19 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S {\n+  typedef T X;\n+\n+  class C {\n+    typedef T X;\n+  };\n+};\n+\n+template <int I>\n+struct S2 {\n+  enum { A = I };\n+\n+  void f() {\n+    int A;\n+  }\n+};"}]}