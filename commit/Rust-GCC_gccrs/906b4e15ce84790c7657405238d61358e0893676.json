{"sha": "906b4e15ce84790c7657405238d61358e0893676", "node_id": "C_kwDOANBUbNoAKDkwNmI0ZTE1Y2U4NDc5MGM3NjU3NDA1MjM4ZDYxMzU4ZTA4OTM2NzY", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2021-12-26T19:18:01Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2021-12-28T22:27:48Z"}, "message": "Fortran: Emit correct types for CHARACTER(C_CHAR), VALUE arguments\n\nMake the front-end emit the right type for CHARACTER(C_CHAR), VALUE\narguments to BIND(C) procedures. They are scalar integers of C type\nchar, and should be emitted as such. They are not strings or arrays,\nand are not promoted to C int, either.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/103828\n\t* trans-decl.c (generate_local_decl): Do not call\n\tgfc_conv_scalar_char_value(), but check the type tree.\n\t* trans-expr.c (gfc_conv_scalar_char_value): Rename to\n\tconv_scalar_char_value, do not alter type tree.\n\t(gfc_conv_procedure_call): Adjust call to renamed\n\tconv_scalar_char_value() function.\n\t* trans-types.c (gfc_sym_type): Take care of\n\tCHARACTER(C_CHAR), VALUE arguments.\n\t* trans.h (gfc_conv_scalar_char_value): Remove prototype.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/103828\n\t* gfortran.dg/c_char_tests_3.f90: New file.\n\t* gfortran.dg/c_char_tests_3_c.c: New file.\n\t* gfortran.dg/c_char_tests_4.f90: New file.\n\t* gfortran.dg/c_char_tests_5.f90: New file.", "tree": {"sha": "17a80e1edc78ee4a0c647e91bfd76c0e3f8bf232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17a80e1edc78ee4a0c647e91bfd76c0e3f8bf232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/906b4e15ce84790c7657405238d61358e0893676", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906b4e15ce84790c7657405238d61358e0893676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906b4e15ce84790c7657405238d61358e0893676", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906b4e15ce84790c7657405238d61358e0893676/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db25655fa5dd23bba684ec7db628643c19e64d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db25655fa5dd23bba684ec7db628643c19e64d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db25655fa5dd23bba684ec7db628643c19e64d6a"}], "stats": {"total": 312, "additions": 255, "deletions": 57}, "files": [{"sha": "d288af5aa10745b49871807e12774a9ccb7de138", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -6001,15 +6001,20 @@ generate_local_decl (gfc_symbol * sym)\n \n   if (sym->attr.dummy == 1)\n     {\n-      /* Modify the tree type for scalar character dummy arguments of bind(c)\n-\t procedures if they are passed by value.  The tree type for them will\n-\t be promoted to INTEGER_TYPE for the middle end, which appears to be\n-\t what C would do with characters passed by-value.  The value attribute\n-         implies the dummy is a scalar.  */\n+      /* The tree type for scalar character dummy arguments of BIND(C)\n+\t procedures, if they are passed by value, should be unsigned char.\n+\t The value attribute implies the dummy is a scalar.  */\n       if (sym->attr.value == 1 && sym->backend_decl != NULL\n \t  && sym->ts.type == BT_CHARACTER && sym->ts.is_c_interop\n \t  && sym->ns->proc_name != NULL && sym->ns->proc_name->attr.is_bind_c)\n-\tgfc_conv_scalar_char_value (sym, NULL, NULL);\n+\t{\n+\t  /* We used to modify the tree here. Now it is done earlier in\n+\t     the front-end, so we only check it here to avoid regressions.  */\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (sym->backend_decl)) == INTEGER_TYPE);\n+\t  gcc_assert (TYPE_UNSIGNED (TREE_TYPE (sym->backend_decl)) == 1);\n+\t  gcc_assert (TYPE_PRECISION (TREE_TYPE (sym->backend_decl)) == CHAR_TYPE_SIZE);\n+\t  gcc_assert (DECL_BY_REFERENCE (sym->backend_decl) == 0);\n+\t}\n \n       /* Unused procedure passed as dummy argument.  */\n       if (sym->attr.flavor == FL_PROCEDURE)"}, {"sha": "80c669f50fbbd801a5bf6c106c8aff9804187686", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-stmt.h\"\n #include \"dependency.h\"\n #include \"gimplify.h\"\n+#include \"tm.h\"\t\t/* For CHAR_TYPE_SIZE.  */\n \n \n /* Calculate the number of characters in a string.  */\n@@ -3972,63 +3973,50 @@ gfc_string_to_single_character (tree len, tree str, int kind)\n }\n \n \n-void\n-gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n+static void\n+conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n {\n+  gcc_assert (expr);\n \n+  /* We used to modify the tree here. Now it is done earlier in\n+     the front-end, so we only check it here to avoid regressions.  */\n   if (sym->backend_decl)\n     {\n-      /* This becomes the nominal_type in\n-\t function.c:assign_parm_find_data_types.  */\n-      TREE_TYPE (sym->backend_decl) = unsigned_char_type_node;\n-      /* This becomes the passed_type in\n-\t function.c:assign_parm_find_data_types.  C promotes char to\n-\t integer for argument passing.  */\n-      DECL_ARG_TYPE (sym->backend_decl) = unsigned_type_node;\n-\n-      DECL_BY_REFERENCE (sym->backend_decl) = 0;\n+      gcc_assert (TREE_CODE (TREE_TYPE (sym->backend_decl)) == INTEGER_TYPE);\n+      gcc_assert (TYPE_UNSIGNED (TREE_TYPE (sym->backend_decl)) == 1);\n+      gcc_assert (TYPE_PRECISION (TREE_TYPE (sym->backend_decl)) == CHAR_TYPE_SIZE);\n+      gcc_assert (DECL_BY_REFERENCE (sym->backend_decl) == 0);\n     }\n \n-  if (expr != NULL)\n+  /* If we have a constant character expression, make it into an\n+      integer of type C char.  */\n+  if ((*expr)->expr_type == EXPR_CONSTANT)\n     {\n-      /* If we have a constant character expression, make it into an\n-\t integer.  */\n-      if ((*expr)->expr_type == EXPR_CONSTANT)\n-        {\n-\t  gfc_typespec ts;\n-          gfc_clear_ts (&ts);\n+      gfc_typespec ts;\n+      gfc_clear_ts (&ts);\n \n-\t  *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n-\t\t\t\t    (int)(*expr)->value.character.string[0]);\n-\t  if ((*expr)->ts.kind != gfc_c_int_kind)\n-\t    {\n-  \t      /* The expr needs to be compatible with a C int.  If the\n-\t\t conversion fails, then the 2 causes an ICE.  */\n-\t      ts.type = BT_INTEGER;\n-\t      ts.kind = gfc_c_int_kind;\n-\t      gfc_convert_type (*expr, &ts, 2);\n-\t    }\n+      *expr = gfc_get_int_expr (gfc_default_character_kind, NULL,\n+\t\t\t\t(*expr)->value.character.string[0]);\n+    }\n+  else if (se != NULL && (*expr)->expr_type == EXPR_VARIABLE)\n+    {\n+      if ((*expr)->ref == NULL)\n+\t{\n+\t  se->expr = gfc_string_to_single_character\n+\t    (build_int_cst (integer_type_node, 1),\n+\t      gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n+\t\t\t\t  gfc_get_symbol_decl\n+\t\t\t\t  ((*expr)->symtree->n.sym)),\n+\t      (*expr)->ts.kind);\n \t}\n-      else if (se != NULL && (*expr)->expr_type == EXPR_VARIABLE)\n-        {\n-\t  if ((*expr)->ref == NULL)\n-\t    {\n-\t      se->expr = gfc_string_to_single_character\n-\t\t(build_int_cst (integer_type_node, 1),\n-\t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n-\t\t\t\t      gfc_get_symbol_decl\n-\t\t\t\t      ((*expr)->symtree->n.sym)),\n-\t\t (*expr)->ts.kind);\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_conv_variable (se, *expr);\n-\t      se->expr = gfc_string_to_single_character\n-\t\t(build_int_cst (integer_type_node, 1),\n-\t\t gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n-\t\t\t\t      se->expr),\n-\t\t (*expr)->ts.kind);\n-\t    }\n+      else\n+\t{\n+\t  gfc_conv_variable (se, *expr);\n+\t  se->expr = gfc_string_to_single_character\n+\t    (build_int_cst (integer_type_node, 1),\n+\t      gfc_build_addr_expr (gfc_get_pchar_type ((*expr)->ts.kind),\n+\t\t\t\t  se->expr),\n+\t      (*expr)->ts.kind);\n \t}\n     }\n }\n@@ -6341,7 +6329,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      && fsym->ns->proc_name->attr.is_bind_c)\n \t\t    {\n \t\t      parmse.expr = NULL;\n-\t\t      gfc_conv_scalar_char_value (fsym, &parmse, &e);\n+\t\t      conv_scalar_char_value (fsym, &parmse, &e);\n \t\t      if (parmse.expr == NULL)\n \t\t\tgfc_conv_expr (&parmse, e);\n \t\t    }"}, {"sha": "6262d52657fa571ea7f77ace6860ac333a1415a2", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -2262,7 +2262,7 @@ gfc_sym_type (gfc_symbol * sym, bool is_bind_c)\n \n   if (sym->ts.type == BT_CHARACTER\n       && ((sym->attr.function && sym->attr.is_bind_c)\n-\t  || (sym->attr.result\n+\t  || ((sym->attr.result || sym->attr.value)\n \t      && sym->ns->proc_name\n \t      && sym->ns->proc_name->attr.is_bind_c)\n \t  || (sym->ts.deferred && (!sym->ts.u.cl"}, {"sha": "f78d5025047e5c2eba17be796a0ce2e3f9c7d911", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -508,7 +508,6 @@ void gfc_conv_expr_type (gfc_se * se, gfc_expr *, tree);\n tree gfc_get_character_len_in_bytes (tree);\n tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n tree gfc_get_ultimate_alloc_ptr_comps_caf_token (gfc_se *, gfc_expr *);\n-void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);\n tree gfc_string_to_single_character (tree len, tree str, int kind);\n tree gfc_get_tree_for_caf_expr (gfc_expr *);\n void gfc_get_caf_token_offset (gfc_se*, tree *, tree *, tree, tree, gfc_expr *);"}, {"sha": "9fc07144ed007db75ceb1074d1b5d462a62d57ec", "filename": "gcc/testsuite/gfortran.dg/c_char_tests_3.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3.f90?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+! { dg-additional-sources c_char_tests_3_c.c }\n+!\n+! PR fortran/103828\n+! Check that we can pass many function args as C char, which are interoperable\n+! with both INTEGER(C_SIGNED_CHAR) and CHARACTER(C_CHAR).\n+\n+subroutine test_int (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c)\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  integer(c_signed_char), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+\n+  if (a /= iachar('a')) stop 1\n+  if (b /= iachar('b')) stop 2\n+  if (c /= iachar('c')) stop 3\n+  if (d /= iachar('d')) stop 4\n+  if (e /= iachar('e')) stop 5\n+  if (f /= iachar('f')) stop 6\n+  if (g /= iachar('g')) stop 7\n+  if (h /= iachar('h')) stop 8\n+  if (i /= iachar('i')) stop 9\n+  if (j /= iachar('j')) stop 10\n+  if (k /= iachar('k')) stop 11\n+  if (l /= iachar('l')) stop 12\n+  if (m /= iachar('m')) stop 13\n+  if (n /= iachar('n')) stop 14\n+  if (o /= iachar('o')) stop 15\n+end subroutine\n+\n+subroutine test_char (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c)\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  character(kind=c_char, len=1), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+\n+  if (a /= 'a') stop 101\n+  if (b /= 'b') stop 102\n+  if (c /= 'c') stop 103\n+  if (d /= 'd') stop 104\n+  if (e /= 'e') stop 105\n+  if (f /= 'f') stop 106\n+  if (g /= 'g') stop 107\n+  if (h /= 'h') stop 108\n+  if (i /= 'i') stop 109\n+  if (j /= 'j') stop 110\n+  if (k /= 'k') stop 111\n+  if (l /= 'l') stop 112\n+  if (m /= 'm') stop 113\n+  if (n /= 'n') stop 114\n+  if (o /= 'o') stop 115\n+end subroutine\n+"}, {"sha": "1c86a549165cf67ad469bc626362b968f06c56aa", "filename": "gcc/testsuite/gfortran.dg/c_char_tests_3_c.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_3_c.c?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -0,0 +1,16 @@\n+void test_char (char, char, char, char, char,\n+\t\tchar, char, char, char, char,\n+\t\tchar, char, char, char, char);\n+\n+void test_int (char, char, char, char, char,\n+\t       char, char, char, char, char,\n+\t       char, char, char, char, char);\n+\n+int main (void) {\n+  test_char ('a', 'b', 'c', 'd', 'e',\n+\t     'f', 'g', 'h', 'i', 'j',\n+\t     'k', 'l', 'm', 'n', 'o');\n+  test_int ('a', 'b', 'c', 'd', 'e',\n+\t    'f', 'g', 'h', 'i', 'j',\n+\t    'k', 'l', 'm', 'n', 'o');\n+}"}, {"sha": "512948a2a3f8928a466c42cf95f428b6fe4cefac", "filename": "gcc/testsuite/gfortran.dg/c_char_tests_4.f90", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_4.f90?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -0,0 +1,90 @@\n+! { dg-do run }\n+!\n+! PR fortran/103828\n+! Check that we can pass many function args as C char, which are interoperable\n+! with both INTEGER(C_SIGNED_CHAR) and CHARACTER(C_CHAR).\n+\n+program test\n+  use, intrinsic :: iso_c_binding, only : c_signed_char, c_char\n+  implicit none\n+\n+  interface\n+    ! In order to perform this test, we cheat and pretend to give each function\n+    ! the other one's prototype. It should still work, because all arguments\n+    ! are interoperable with C char.\n+\n+    subroutine test1 (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c, name='test_int')\n+      import c_char\n+      character(kind=c_char, len=1), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+    end subroutine test1\n+\n+    subroutine test2 (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c, name='test_char')\n+      import c_signed_char\n+      integer(kind=c_signed_char), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+    end subroutine test2\n+\n+  end interface\n+\n+  call test1('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o')\n+  call test2(ichar('a', kind=c_signed_char), &\n+             ichar('b', kind=c_signed_char), &\n+             ichar('c', kind=c_signed_char), &\n+             ichar('d', kind=c_signed_char), &\n+             ichar('e', kind=c_signed_char), &\n+             ichar('f', kind=c_signed_char), &\n+             ichar('g', kind=c_signed_char), &\n+             ichar('h', kind=c_signed_char), &\n+             ichar('i', kind=c_signed_char), &\n+             ichar('j', kind=c_signed_char), &\n+             ichar('k', kind=c_signed_char), &\n+             ichar('l', kind=c_signed_char), &\n+             ichar('m', kind=c_signed_char), &\n+             ichar('n', kind=c_signed_char), &\n+             ichar('o', kind=c_signed_char))\n+\n+end program test\n+\n+subroutine test_int (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c)\n+  use, intrinsic :: iso_c_binding, only : c_signed_char\n+  implicit none\n+  integer(c_signed_char), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+\n+  if (a /= iachar('a')) stop 1\n+  if (b /= iachar('b')) stop 2\n+  if (c /= iachar('c')) stop 3\n+  if (d /= iachar('d')) stop 4\n+  if (e /= iachar('e')) stop 5\n+  if (f /= iachar('f')) stop 6\n+  if (g /= iachar('g')) stop 7\n+  if (h /= iachar('h')) stop 8\n+  if (i /= iachar('i')) stop 9\n+  if (j /= iachar('j')) stop 10\n+  if (k /= iachar('k')) stop 11\n+  if (l /= iachar('l')) stop 12\n+  if (m /= iachar('m')) stop 13\n+  if (n /= iachar('n')) stop 14\n+  if (o /= iachar('o')) stop 15\n+end subroutine\n+\n+subroutine test_char (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) bind(c)\n+  use, intrinsic :: iso_c_binding, only : c_char\n+  implicit none\n+  character(kind=c_char, len=1), value :: a, b, c, d, e, f, g, h, i, j, k, l, m, n, o\n+\n+  if (a /= 'a') stop 101\n+  if (b /= 'b') stop 102\n+  if (c /= 'c') stop 103\n+  if (d /= 'd') stop 104\n+  if (e /= 'e') stop 105\n+  if (f /= 'f') stop 106\n+  if (g /= 'g') stop 107\n+  if (h /= 'h') stop 108\n+  if (i /= 'i') stop 109\n+  if (j /= 'j') stop 110\n+  if (k /= 'k') stop 111\n+  if (l /= 'l') stop 112\n+  if (m /= 'm') stop 113\n+  if (n /= 'n') stop 114\n+  if (o /= 'o') stop 115\n+end subroutine\n+"}, {"sha": "c7a1c6e8c2bc4935104aa1288bbf671fb2dfb128", "filename": "gcc/testsuite/gfortran.dg/c_char_tests_5.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906b4e15ce84790c7657405238d61358e0893676/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_char_tests_5.f90?ref=906b4e15ce84790c7657405238d61358e0893676", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! { dg-options \"-fbackslash\" }\n+!\n+! PR fortran/103828\n+! Check that we can C char with non-ASCII values, which are interoperable\n+! with both INTEGER(C_SIGNED_CHAR) and CHARACTER(C_CHAR).\n+\n+program test\n+  use, intrinsic :: iso_c_binding, only : c_signed_char, c_char\n+  implicit none\n+\n+  interface\n+    ! In order to perform this test, we cheat and pretend to give each function\n+    ! the other one's prototype. It should still work, because all arguments\n+    ! are interoperable with C char.\n+\n+    subroutine test1 (a) bind(c, name='test_int')\n+      import c_char\n+      character(kind=c_char, len=1), value :: a\n+    end subroutine test1\n+\n+    subroutine test2 (a) bind(c, name='test_char')\n+      import c_signed_char\n+      integer(kind=c_signed_char), value :: a\n+    end subroutine test2\n+\n+  end interface\n+\n+  call test1('\\xA3')\n+  call test2(-93_c_signed_char)\n+\n+end program test\n+\n+subroutine test_int (a) bind(c)\n+  use, intrinsic :: iso_c_binding, only : c_signed_char\n+  implicit none\n+  integer(c_signed_char), value :: a\n+\n+  if (a /= iachar('\\xA3', kind=c_signed_char)) stop 1\n+end subroutine\n+\n+subroutine test_char (a) bind(c)\n+  use, intrinsic :: iso_c_binding, only : c_char\n+  implicit none\n+  character(kind=c_char, len=1), value :: a\n+\n+  if (a /= '\\xA3') stop 101\n+end subroutine\n+"}]}