{"sha": "2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ2OThkM2JiN2YxYjc3NjFiMzViMzEzMjZhMDMyNmNlMzc1ZWY4ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-12T10:38:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-12T10:38:05Z"}, "message": "re PR tree-optimization/45232 (tree reassociation introduces undefined overflow)\n\n2010-08-12  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/45232\n\t* tree-ssa-reassoc.c (can_reassociate_p): Disable re-association\n\tfor types with undefined overflow.\n\t(reassociate_bb): Allow re-associating of bit and min/max\n\toperations for types with undefined overflow.\n\t* tree-ssa-forwprop.c (associate_plusminus): New function.\n\t(tree_ssa_forward_propagate_single_use_vars): Call it.\n\n\t* gcc.dg/tree-ssa/pr44133.c: Adjust warning location.\n\t* gcc.dg/tree-ssa/loop-7.c: Adjust.\n\t* gcc.dg/tree-ssa/reassoc-1.c: XFAIL.\n\t* gcc.dg/tree-ssa/reassoc-20.c: Add reassoc-1.c variant with\n\tunsigned arithmetic.\n\t* gcc.dg/tree-ssa/reassoc-14.c: Use unsigned arithmetic.\n\t* gcc.dg/tree-ssa/reassoc-15.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-18.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-2.c: XFAIL.\n\t* gcc.dg/tree-ssa/reassoc-21.c: Add reassoc-2.c variant with\n\tunsigned arithmetic.\n\t* gcc.dg/tree-ssa/reassoc-6.c: XFAIL.\n\t* gcc.dg/tree-ssa/reassoc-22.c: Add reassoc-6.c variant with\n\tunsigned arithmetic.\n\t* gcc.dg/tree-ssa/reassoc-7.c: Use unsigned arithmetic.\n\t* gcc.dg/tree-ssa/reassoc-9.c: XFAIL.\n\t* gcc.dg/tree-ssa/reassoc-23.c: Add reassoc-9.c variant with\n\tunsigned arithmetic.\n\t* gcc.dg/tree-ssa/ssa-pre-2.c: Adjust.\n\t* gcc.dg/tree-ssa/negate.c: Adjust.\n\t* gcc.dg/vect/vect-1.c: Adjust.\n\t* gfortran.dg/reassoc_6.f: XFAIL.\n\nFrom-SVN: r163190", "tree": {"sha": "0b5ac0be840f1c9c145ded9acd7debd5de9e9e84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b5ac0be840f1c9c145ded9acd7debd5de9e9e84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1be38ccb1b4a2208403ffe980073d6ed2bb61490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be38ccb1b4a2208403ffe980073d6ed2bb61490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be38ccb1b4a2208403ffe980073d6ed2bb61490"}], "stats": {"total": 519, "additions": 475, "deletions": 44}, "files": [{"sha": "8e062b9d55aa4c4d4377c8d3c9fe9ee0810b76fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,3 +1,13 @@\n+2010-08-12  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45232\n+\t* tree-ssa-reassoc.c (can_reassociate_p): Disable re-association\n+\tfor types with undefined overflow.\n+\t(reassociate_bb): Allow re-associating of bit and min/max\n+\toperations for types with undefined overflow.\n+\t* tree-ssa-forwprop.c (associate_plusminus): New function.\n+\t(tree_ssa_forward_propagate_single_use_vars): Call it.\n+\n 2010-08-12  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow.h (struct ptr_info_def): Add align and misalign fields."}, {"sha": "28a6805ffe513074bd7b10506d094caee93296c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,3 +1,29 @@\n+2010-08-12  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/45232\n+\t* gcc.dg/tree-ssa/pr44133.c: Adjust warning location.\n+\t* gcc.dg/tree-ssa/loop-7.c: Adjust.\n+\t* gcc.dg/tree-ssa/reassoc-1.c: XFAIL.\n+\t* gcc.dg/tree-ssa/reassoc-20.c: Add reassoc-1.c variant with\n+\tunsigned arithmetic.\n+\t* gcc.dg/tree-ssa/reassoc-14.c: Use unsigned arithmetic.\n+\t* gcc.dg/tree-ssa/reassoc-15.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-18.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-2.c: XFAIL.\n+\t* gcc.dg/tree-ssa/reassoc-21.c: Add reassoc-2.c variant with\n+\tunsigned arithmetic.\n+\t* gcc.dg/tree-ssa/reassoc-6.c: XFAIL.\n+\t* gcc.dg/tree-ssa/reassoc-22.c: Add reassoc-6.c variant with\n+\tunsigned arithmetic.\n+\t* gcc.dg/tree-ssa/reassoc-7.c: Use unsigned arithmetic.\n+\t* gcc.dg/tree-ssa/reassoc-9.c: XFAIL.\n+\t* gcc.dg/tree-ssa/reassoc-23.c: Add reassoc-9.c variant with\n+\tunsigned arithmetic.\n+\t* gcc.dg/tree-ssa/ssa-pre-2.c: Adjust.\n+\t* gcc.dg/tree-ssa/negate.c: Adjust.\n+\t* gcc.dg/vect/vect-1.c: Adjust.\n+\t* gfortran.dg/reassoc_6.f: XFAIL.\n+\n 2010-08-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/45259"}, {"sha": "ab4a5026f2e3340ed7b943e57a638bf9c6b019a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-7.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -31,5 +31,5 @@ int xxx (void)\n    Calls to cst_fun2 and pure_fun2 should not be, since calling\n    with k = 0 may be invalid.  */\n \n-/* { dg-final { scan-tree-dump-times \"Moving statement\" 3 \"lim1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Moving statement\" 2 \"lim1\" } } */\n /* { dg-final { cleanup-tree-dump \"lim\\[1-2\\]\" } } */"}, {"sha": "12e2cdf712709f5e3032f181dffe85a45537d97a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/negate.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnegate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnegate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnegate.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -8,13 +8,20 @@ int f (int a, int b)\n   return y;\n }\n \n+/* We tested for reassociation to -(a + b) on the following which\n+   isn't a transform that makes things cheaper.  With reassoc\n+   no longer applying to types with undefined overflow we lost\n+   this transform.\n+\n int g (int a, int b)\n {\n   int x = -a;\n   int y = x - b;\n   return y;\n }\n \n-/* There should be two additions now.  */\n-/* { dg-final { scan-tree-dump-times \"\\\\+\" 2 \"reassoc1\"} } */\n+*/\n+\n+/* There should be an addition now.  */\n+/* { dg-final { scan-tree-dump-times \"\\\\+\" 1 \"reassoc1\"} } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "d3d0fe3a98624a263e2c7fc4a620627602d3159d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr44133.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44133.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44133.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr44133.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -6,6 +6,6 @@ struct S { int i, j; };\n int foo (int l)\n {\n   struct S s;\n-  s.j = l - 22;   /* { dg-warning \".s\\.i. is used uninitialized\" } */\n-  return s.i + s.j;\n+  s.j = l - 22;\n+  return s.i + s.j;   /* { dg-warning \".s\\.i. is used uninitialized\" } */\n }"}, {"sha": "43ccd8eaab14d25dffdf7b0e5c45326b48bb1f04", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */ \n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n int a, b, c, d;\n extern int printf (const char *, ...);\n int main(void)\n@@ -14,6 +15,10 @@ int main(void)\n   printf (\"%d %d\\n\", e, f);\n }\n \n-/* { dg-final { scan-tree-dump-times \"b.._. \\\\\\+ a.._.\" 1 \"optimized\"} } */\n-/* { dg-final { scan-tree-dump-times \" \\\\\\+ \" 2 \"optimized\"} } */\n+/* We cannot reassociate these expressions because of undefined signed\n+   integer overflow.  Instead the value-numberer has to be extended\n+   to canonicalize these expressions.  */\n+\n+/* { dg-final { scan-tree-dump-times \"b.._. \\\\\\+ a.._.\" 1 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\+ \" 2 \"optimized\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5b57160bcd675d8a2b912bbe5b6e703e99ab60d0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-14.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-14.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,19 +1,21 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n \n-int test1 (int x, int y, int z, int weight)\n+unsigned int test1 (unsigned int x, unsigned int y, unsigned int z,\n+\t\t    unsigned int weight)\n {\n-  int tmp1 = x * weight;\n-  int tmp2 = y * weight;\n-  int tmp3 = (x - y) * weight;\n+  unsigned int tmp1 = x * weight;\n+  unsigned int tmp2 = y * weight;\n+  unsigned int tmp3 = (x - y) * weight;\n   return tmp1 + (tmp2 + tmp3);\n }\n \n-int test2 (int x, int y, int z, int weight)\n+unsigned int test2 (unsigned int x, unsigned int y, unsigned int z,\n+\t\t    unsigned int weight)\n {\n-  int tmp1 = x * weight;\n-  int tmp2 = y * weight * weight;\n-  int tmp3 = z * weight * weight * weight;\n+  unsigned int tmp1 = x * weight;\n+  unsigned int tmp2 = y * weight * weight;\n+  unsigned int tmp3 = z * weight * weight * weight;\n   return tmp1 + tmp2 + tmp3;\n }\n "}, {"sha": "df6fd52136fab99c9de1f6ad8bb2f8fb8e9103c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-15.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-15.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,14 +1,16 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n \n-int test3 (int x, int y, int z, int weight, int w1, int w2, int w3)\n+unsigned int test3 (unsigned int x, unsigned int y, unsigned int z,\n+\t\t    unsigned int weight,\n+\t\t    unsigned int w1, unsigned int w2, unsigned int w3)\n {\n-  int wtmp1 = w1 * weight;\n-  int wtmp2 = w2 * weight;\n-  int wtmp3 = w3 * weight;\n-  int tmp1 = x * wtmp1;\n-  int tmp2 = y * wtmp2;\n-  int tmp3 = z * wtmp3;\n+  unsigned int wtmp1 = w1 * weight;\n+  unsigned int wtmp2 = w2 * weight;\n+  unsigned int wtmp3 = w3 * weight;\n+  unsigned int tmp1 = x * wtmp1;\n+  unsigned int tmp2 = y * wtmp2;\n+  unsigned int tmp3 = z * wtmp3;\n   return tmp1 + tmp2 + tmp3;\n }\n "}, {"sha": "ab7fe295aa36874addbf88ba25196c08bf04c015", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-18.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-18.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,10 +1,10 @@\n /* { dg-do compile } */\n /* { dg-options \"-O -fdump-tree-reassoc1\" } */\n \n-int\n-ETree_nFactorEntriesInFront (int b, int m)\n+unsigned int\n+ETree_nFactorEntriesInFront (unsigned int b, unsigned int m)\n {\n-  int nent = b*b + 2*b*m;\n+  unsigned int nent = b*b + 2*b*m;\n   return nent;\n }\n "}, {"sha": "c5787ab5a5b4331a1b84cb6bad226f1ec286f51d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n int f (int a0,int a1,int a2,int a3,int a4) \n { \n int b0, b1, b2, b3, b4,e; \n@@ -13,5 +14,7 @@ int b0, b1, b2, b3, b4,e;\n   return e;\n }\n \n-/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" } } */\n+/* We can't reassociate the expressions due to undefined signed overflow.  */\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1cfb9809393c2d9fd3cd58c537101b2cf92fa339", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-20.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-20.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned int a, b, c, d;\n+extern int printf (const char *, ...);\n+int main(void)\n+{\n+  unsigned int e;\n+  unsigned int f;\n+  /* We should be able to transform these into the same expression, and only have two additions.  */\n+  e = a + b;\n+  e = e + c;\n+  f = c + a;\n+  f = f + b;\n+  printf (\"%d %d\\n\", e, f);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"b.._. \\\\\\+ a.._.\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\\\+ \" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e02de1b473170ab03e4b2b35abb4d9eaae9350f0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-21.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-21.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned int f (unsigned int a0, unsigned int a1, unsigned int a2,\n+\t\tunsigned int a3, unsigned int a4) \n+{ \n+  unsigned int b0, b1, b2, b3, b4, e; \n+  /* this can be optimized to four additions... */ \n+  b4 = a4 + a3 + a2 + a1 + a0; \n+  b3 = a3 + a2 + a1 + a0; \n+  b2 = a2 + a1 + a0; \n+  b1 = a1 + a0; \n+  /* This is actually 0 */\n+  e = b4 - b3 + b2 - b1 - a4 - a2;\n+  return e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7eb97f45622faa0d50da763d118eafaa402ccd58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-22.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-22.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+unsigned int foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d)\n+{\n+  /* Should be transformed into a + c + 8 */\n+  unsigned int e = a + 3;\n+  unsigned int f = c + 5;\n+  unsigned int g = e + f;\n+  return g;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ 8\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "65aee7237ac64e0a63c23bf8a1964865b89498a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-23.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-23.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+unsigned int\n+foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d,\n+    unsigned int e, unsigned int f, unsigned int g, unsigned int h)\n+{\n+  /* Should be transformed into e = 20 */\n+  unsigned int i = (a + 9) + (c + 8);\n+  unsigned int j = (-c + 1) + (-a + 2);\n+\n+  e = i + j;\n+  return e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"= 20\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "480f7c0161d3d1701c38e7d711ad7c24880cb36e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-6.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -9,5 +9,7 @@ int main(int a, int b, int c, int d)\n   return g;\n }\n \n-/* { dg-final { scan-tree-dump-times \"\\\\\\+ 8\" 1 \"reassoc1\"} } */\n+/* We cannot re-associate the additions due to undefined signed overflow.  */\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ 8\" 1 \"reassoc1\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "ee9b80fd9c3d6e6813a54a6c6dea33643e7c4577", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-7.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1,12 +1,16 @@\n /* { dg-do compile } */ \n /* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n-int main(int a, int b, int c, int d, int e, int f, int g, int h)\n+\n+unsigned int\n+foo(unsigned int a, unsigned int b, unsigned int c, unsigned int d,\n+    unsigned int e, unsigned int f, unsigned int g, unsigned int h)\n {\n   /* Should be transformed into a + c + d + e + g + 15 */\n-  int i = (a + 9) + (c + d);\n-  int j = (e + 4) + (2 + g);\n+  unsigned int i = (a + 9) + (c + d);\n+  unsigned int j = (e + 4) + (2 + g);\n   e = i + j;\n   return e;\n }\n+\n /* { dg-final { scan-tree-dump-times \"\\\\\\+ 15\" 1 \"reassoc1\"} } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "d09303ccfdee7789a5cdb7879e8b9d25f2312784", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-9.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -10,5 +10,9 @@ int main(int a, int b, int c, int d, int e, int f, int g, int h)\n   e = i + j;\n   return e;\n }\n-/* { dg-final { scan-tree-dump-times \"= 20\" 1 \"reassoc1\"} } */\n+\n+/* We can always re-associate to a final constant but the current\n+   implementation does not allow easy roll-back without IL changes.  */\n+\n+/* { dg-final { scan-tree-dump-times \"= 20\" 1 \"reassoc1\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "311f127812b2a827578ff3a24205740d8fa0b3d6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -16,7 +16,9 @@ int motion_test1(int data, int data_0, int data_3, int v)\n \treturn v * t * u;\n }\n /* We should eliminate one computation of data_0 + data_3 along the \n-   main path, and one computation of v * i along the main path, causing \n-   two eliminations. */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n+   main path.  We cannot re-associate v * t * u due to undefined\n+   signed overflow so we do not eliminate one computation of v * i along\n+   the main path. */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "182b85b9353edd37b576dcb225515941bbf63907", "filename": "gcc/testsuite/gcc.dg/vect/vect-1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -26,16 +26,15 @@ foo (int n)\n   char image[N][N];\n   char block[N][N];\n \n-  /* Not vectorizable yet (cross-iteration cycle).  */\n+  /* Vectorizable.  */\n   diff = 0;\n   for (i = 0; i < N; i++) {\n     diff += (cb[i] - cc[i]);\n   }\n   ibar (&diff);\n \n \n-  /* Not vectorizable yet (outer-loop: not attempted. \n-     inner-loop: cross iteration cycle; multi-dimensional arrays).  */\n+  /* Vectorizable.  */\n   diff = 0;\n   for (i = 0; i < N; i++) {\n     for (i = 0; i < N; i++) {\n@@ -86,6 +85,6 @@ foo (int n)\n   fbar (a);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" { target vect_extract_even_odd_wide } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_extract_even_odd_wide } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 6 loops\" 1 \"vect\" { target vect_extract_even_odd_wide } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 5 loops\" 1 \"vect\" { xfail vect_extract_even_odd_wide } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "97a5de8a74827c4b8d41444b5cb38d5eab9b89bd", "filename": "gcc/testsuite/gfortran.dg/reassoc_6.f", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_6.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_6.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_6.f?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -16,5 +16,7 @@ subroutine test(nb,nx,r2)\n         return\n         end\n ! Verify that offset of the first element is simplified\n-! { dg-final { scan-tree-dump-not \"~\" \"optimized\" } }\n+! While we understand to combine x + ~x IVOPTs now messes things\n+! up by hiding that operation in casts to unsigned.\n+! { dg-final { scan-tree-dump-not \"~\" \"optimized\" { xfail *-*-* } } }\n ! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "5bf41e82eb31a96e25c5f077ba7a685b6b99f823", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1357,6 +1357,287 @@ simplify_bitwise_and (gimple_stmt_iterator *gsi, gimple stmt)\n   return;\n }\n \n+\n+/* Perform re-associations of the plus or minus statement STMT that are\n+   always permitted.  */\n+\n+static void\n+associate_plusminus (gimple stmt)\n+{\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  gimple_stmt_iterator gsi;\n+  bool changed;\n+\n+  /* We can't reassociate at all for saturating types.  */\n+  if (TYPE_SATURATING (TREE_TYPE (rhs1)))\n+    return;\n+\n+  /* First contract negates.  */\n+  do\n+    {\n+      changed = false;\n+\n+      /* A +- (-B) -> A -+ B.  */\n+      if (TREE_CODE (rhs2) == SSA_NAME)\n+\t{\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (rhs2);\n+\t  if (is_gimple_assign (def_stmt)\n+\t      && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR)\n+\t    {\n+\t      code = (code == MINUS_EXPR) ? PLUS_EXPR : MINUS_EXPR;\n+\t      gimple_assign_set_rhs_code (stmt, code);\n+\t      rhs2 = gimple_assign_rhs1 (def_stmt);\n+\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t      gimple_set_modified (stmt, true);\n+\t      changed = true;\n+\t    }\n+\t}\n+\n+      /* (-A) + B -> B - A.  */\n+      if (TREE_CODE (rhs1) == SSA_NAME\n+\t  && code == PLUS_EXPR)\n+\t{\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (rhs1);\n+\t  if (is_gimple_assign (def_stmt)\n+\t      && gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR)\n+\t    {\n+\t      code = MINUS_EXPR;\n+\t      gimple_assign_set_rhs_code (stmt, code);\n+\t      rhs1 = rhs2;\n+\t      gimple_assign_set_rhs1 (stmt, rhs1);\n+\t      rhs2 = gimple_assign_rhs1 (def_stmt);\n+\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t      gimple_set_modified (stmt, true);\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+  while (changed);\n+\n+  /* We can't reassociate floating-point or fixed-point plus or minus\n+     because of saturation to +-Inf.  */\n+  if (FLOAT_TYPE_P (TREE_TYPE (rhs1))\n+      || FIXED_POINT_TYPE_P (TREE_TYPE (rhs1)))\n+    goto out;\n+\n+  /* Second match patterns that allow contracting a plus-minus pair\n+     irrespective of overflow issues.\n+\n+\t(A +- B) - A       ->  +- B\n+\t(A +- B) -+ B      ->  A\n+\t(CST +- A) +- CST  ->  CST +- A\n+\t(A + CST) +- CST   ->  A + CST\n+\t~A + A             ->  -1\n+\t~A + 1             ->  -A \n+\tA - (A +- B)       ->  -+ B\n+\tA +- (B +- A)      ->  +- B\n+\tCST +- (CST +- A)  ->  CST +- A\n+\tCST +- (A +- CST)  ->  CST +- A\n+\tA + ~A             ->  -1\n+\n+     via commutating the addition and contracting operations to zero\n+     by reassociation.  */\n+\n+  gsi = gsi_for_stmt (stmt);\n+  if (TREE_CODE (rhs1) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (rhs1);\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  enum tree_code def_code = gimple_assign_rhs_code (def_stmt);\n+\t  if (def_code == PLUS_EXPR\n+\t      || def_code == MINUS_EXPR)\n+\t    {\n+\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      tree def_rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t      if (operand_equal_p (def_rhs1, rhs2, 0)\n+\t\t  && code == MINUS_EXPR)\n+\t\t{\n+\t\t  /* (A +- B) - A -> +- B.  */\n+\t\t  code = ((def_code == PLUS_EXPR)\n+\t\t\t  ? TREE_CODE (def_rhs2) : NEGATE_EXPR);\n+\t\t  rhs1 = def_rhs2;\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else if (operand_equal_p (def_rhs2, rhs2, 0)\n+\t\t       && code != def_code)\n+\t\t{\n+\t\t  /* (A +- B) -+ B -> A.  */\n+\t\t  code = TREE_CODE (def_rhs1);\n+\t\t  rhs1 = def_rhs1;\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else if (TREE_CODE (rhs2) == INTEGER_CST\n+\t\t       && TREE_CODE (def_rhs1) == INTEGER_CST)\n+\t\t{\n+\t\t  /* (CST +- A) +- CST -> CST +- A.  */\n+\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs1),\n+\t\t\t\t\t  def_rhs1, rhs2);\n+\t\t  if (cst && !TREE_OVERFLOW (cst))\n+\t\t    {\n+\t\t      code = def_code;\n+\t\t      gimple_assign_set_rhs_code (stmt, code);\n+\t\t      rhs1 = cst;\n+\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n+\t\t      rhs2 = def_rhs2;\n+\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t\t      gimple_set_modified (stmt, true);\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (rhs2) == INTEGER_CST\n+\t\t       && TREE_CODE (def_rhs2) == INTEGER_CST\n+\t\t       && def_code == PLUS_EXPR)\n+\t\t{\n+\t\t  /* (A + CST) +- CST -> A + CST.  */\n+\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs1),\n+\t\t\t\t\t  def_rhs2, rhs2);\n+\t\t  if (cst && !TREE_OVERFLOW (cst))\n+\t\t    {\n+\t\t      code = PLUS_EXPR;\n+\t\t      gimple_assign_set_rhs_code (stmt, code);\n+\t\t      rhs1 = def_rhs1;\n+\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n+\t\t      rhs2 = cst;\n+\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t\t      gimple_set_modified (stmt, true);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (def_code == BIT_NOT_EXPR\n+\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (rhs1)))\n+\t    {\n+\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      if (code == PLUS_EXPR\n+\t\t  && operand_equal_p (def_rhs1, rhs2, 0))\n+\t\t{\n+\t\t  /* ~A + A -> -1.  */\n+\t\t  code = INTEGER_CST;\n+\t\t  rhs1 = build_int_cst (TREE_TYPE (rhs2), -1);\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else if (code == PLUS_EXPR\n+\t\t       && integer_onep (rhs1))\n+\t\t{\n+\t\t  /* ~A + 1 -> -A.  */\n+\t\t  code = NEGATE_EXPR;\n+\t\t  rhs1 = def_rhs1;\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (rhs2 && TREE_CODE (rhs2) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (rhs2);\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  enum tree_code def_code = gimple_assign_rhs_code (def_stmt);\n+\t  if (def_code == PLUS_EXPR\n+\t      || def_code == MINUS_EXPR)\n+\t    {\n+\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      tree def_rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t      if (operand_equal_p (def_rhs1, rhs1, 0)\n+\t\t  && code == MINUS_EXPR)\n+\t\t{\n+\t\t  /* A - (A +- B) -> -+ B.  */\n+\t\t  code = ((def_code == PLUS_EXPR)\n+\t\t\t  ? NEGATE_EXPR : TREE_CODE (def_rhs2));\n+\t\t  rhs1 = def_rhs2;\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else if (operand_equal_p (def_rhs2, rhs1, 0)\n+\t\t       && code != def_code)\n+\t\t{\n+\t\t  /* A +- (B +- A) -> +- B.  */\n+\t\t  code = ((code == PLUS_EXPR)\n+\t\t\t  ? TREE_CODE (def_rhs1) : NEGATE_EXPR);\n+\t\t  rhs1 = def_rhs1;\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t      else if (TREE_CODE (rhs1) == INTEGER_CST\n+\t\t       && TREE_CODE (def_rhs1) == INTEGER_CST)\n+\t\t{\n+\t\t  /* CST +- (CST +- A) -> CST +- A.  */\n+\t\t  tree cst = fold_binary (code, TREE_TYPE (rhs2),\n+\t\t\t\t\t  rhs1, def_rhs1);\n+\t\t  if (cst && !TREE_OVERFLOW (cst))\n+\t\t    {\n+\t\t      code = (code == def_code ? PLUS_EXPR : MINUS_EXPR);\n+\t\t      gimple_assign_set_rhs_code (stmt, code);\n+\t\t      rhs1 = cst;\n+\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n+\t\t      rhs2 = def_rhs2;\n+\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t\t      gimple_set_modified (stmt, true);\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (rhs1) == INTEGER_CST\n+\t\t       && TREE_CODE (def_rhs2) == INTEGER_CST)\n+\t\t{\n+\t\t  /* CST +- (A +- CST) -> CST +- A.  */\n+\t\t  tree cst = fold_binary (def_code == code\n+\t\t\t\t\t  ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t\t\t  TREE_TYPE (rhs2),\n+\t\t\t\t\t  rhs1, def_rhs2);\n+\t\t  if (cst && !TREE_OVERFLOW (cst))\n+\t\t    {\n+\t\t      rhs1 = cst;\n+\t\t      gimple_assign_set_rhs1 (stmt, rhs1);\n+\t\t      rhs2 = def_rhs1;\n+\t\t      gimple_assign_set_rhs2 (stmt, rhs2);\n+\t\t      gimple_set_modified (stmt, true);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (def_code == BIT_NOT_EXPR\n+\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (rhs2)))\n+\t    {\n+\t      tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t      if (code == PLUS_EXPR\n+\t\t  && operand_equal_p (def_rhs1, rhs1, 0))\n+\t\t{\n+\t\t  /* A + ~A -> -1.  */\n+\t\t  code = INTEGER_CST;\n+\t\t  rhs1 = build_int_cst (TREE_TYPE (rhs1), -1);\n+\t\t  rhs2 = NULL_TREE;\n+\t\t  gimple_assign_set_rhs_with_ops (&gsi, code, rhs1, NULL_TREE);\n+\t\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t\t  gimple_set_modified (stmt, true);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+out:\n+  if (gimple_modified_p (stmt))\n+    {\n+      fold_stmt_inplace (stmt);\n+      update_stmt (stmt);\n+    }\n+}\n+\n /* Main entry point for the forward propagation optimizer.  */\n \n static unsigned int\n@@ -1478,6 +1759,12 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t\t  simplify_bitwise_and (&gsi, stmt);\n \t\t  gsi_next (&gsi);\n \t\t}\n+\t      else if (gimple_assign_rhs_code (stmt) == PLUS_EXPR\n+\t\t       || gimple_assign_rhs_code (stmt) == MINUS_EXPR)\n+\t\t{\n+\t\t  associate_plusminus (stmt);\n+\t\t  gsi_next (&gsi);\n+\t\t}\n \t      else\n \t\tgsi_next (&gsi);\n \t    }"}, {"sha": "adc5a8dcf677e028583ea9d51e2b4eab818a4bd3", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d698d3bb7f1b7761b35b31326a0326ce375ef8e/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=2d698d3bb7f1b7761b35b31326a0326ce375ef8e", "patch": "@@ -1949,7 +1949,7 @@ static bool\n can_reassociate_p (tree op)\n {\n   tree type = TREE_TYPE (op);\n-  if (INTEGRAL_TYPE_P (type)\n+  if ((INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_WRAPS (type))\n       || NON_SAT_FIXED_POINT_TYPE_P (type)\n       || (flag_associative_math && FLOAT_TYPE_P (type)))\n     return true;\n@@ -2065,9 +2065,16 @@ reassociate_bb (basic_block bb)\n \t  rhs1 = gimple_assign_rhs1 (stmt);\n \t  rhs2 = gimple_assign_rhs2 (stmt);\n \n-\t  if (!can_reassociate_p (lhs)\n-\t      || !can_reassociate_p (rhs1)\n-\t      || !can_reassociate_p (rhs2))\n+\t  /* For non-bit or min/max operations we can't associate\n+\t     all types.  Verify that here.  */\n+\t  if (rhs_code != BIT_IOR_EXPR\n+\t      && rhs_code != BIT_AND_EXPR\n+\t      && rhs_code != BIT_XOR_EXPR\n+\t      && rhs_code != MIN_EXPR\n+\t      && rhs_code != MAX_EXPR\n+\t      && (!can_reassociate_p (lhs)\n+\t\t  || !can_reassociate_p (rhs1)\n+\t\t  || !can_reassociate_p (rhs2)))\n \t    continue;\n \n \t  if (associative_tree_code (rhs_code))"}]}