{"sha": "f1b7bc164cb370b15c6e62d65120e6494729ac0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiN2JjMTY0Y2IzNzBiMTVjNmU2MmQ2NTEyMGU2NDk0NzI5YWMwYw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-11-17T14:53:29Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-11-17T14:53:29Z"}, "message": "combine: Add added_notes_insn\n\nThis patch makes combine reconsider insns it added notes to.  This\nmatters for example if the note is a REG_DEAD; without the note the\nsetter of the register has to be kept around in the result of\ncombinations, so it cannot be a 2->1 combination, and the cost of\nthe result is higher than without that extra set, so try_combine may\nrefuse the combination with the set, but allow it without the set.\n\nThis fixes a regression for powerpc: pr69946.c has started to fail\nafter the bitfield expansion changes.  GCC used to generate\n\n        lwz 3,0(9)\n        rlwinm 3,3,12,20,23\n        ori 3,3,0x11\n        rotldi 3,3,52\n        bl bar\n\nbut now it does\n\n        lwz 3,0(9)\n        rldicr 3,3,32,3\n        srdi 3,3,48\n        ori 3,3,0x110\n        sldi 3,3,48\n        bl bar\n\n(an instruction too many).  After this patch it is\n\n        lwz 3,0(9)\n        rlwinm 3,3,16,16,19\n        ori 3,3,0x110\n        sldi 3,3,48\n        bl bar\n\n(the testcase still does not pass, it looks for very specific insns).\n\n\n\t* combine.c (added_notes_insn): New.\n\t(try_combine): Handle added_notes_insn like added_links_insn.\n\tRewrite return value code.\n\t(distribute_notes): Set added_notes_insn to the earliest insn we added\n\ta note to.\n\nFrom-SVN: r254875", "tree": {"sha": "5e9aaec9a490509e5915b56f470e26eacc2d6f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e9aaec9a490509e5915b56f470e26eacc2d6f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1b7bc164cb370b15c6e62d65120e6494729ac0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b7bc164cb370b15c6e62d65120e6494729ac0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b7bc164cb370b15c6e62d65120e6494729ac0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b7bc164cb370b15c6e62d65120e6494729ac0c/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58b46683bd70c20c2543d60ca28af4dec4ec0443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b46683bd70c20c2543d60ca28af4dec4ec0443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b46683bd70c20c2543d60ca28af4dec4ec0443"}], "stats": {"total": 40, "additions": 33, "deletions": 7}, "files": [{"sha": "c8e169044ef5eb9a078a7e633cb7b6a586b74a9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1b7bc164cb370b15c6e62d65120e6494729ac0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1b7bc164cb370b15c6e62d65120e6494729ac0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1b7bc164cb370b15c6e62d65120e6494729ac0c", "patch": "@@ -1,3 +1,11 @@\n+2017-11-17  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* combine.c (added_notes_insn): New.\n+\t(try_combine): Handle added_notes_insn like added_links_insn.\n+\tRewrite return value code.\n+\t(distribute_notes): Set added_notes_insn to the earliest insn we added\n+\ta note to.\n+\n 2017-11-17  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/82621"}, {"sha": "ab515436fc857fcef354058d0535efb85e3a1887", "filename": "gcc/combine.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1b7bc164cb370b15c6e62d65120e6494729ac0c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1b7bc164cb370b15c6e62d65120e6494729ac0c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f1b7bc164cb370b15c6e62d65120e6494729ac0c", "patch": "@@ -302,6 +302,10 @@ static HARD_REG_SET newpat_used_regs;\n \n static rtx_insn *added_links_insn;\n \n+/* And similarly, for notes.  */\n+\n+static rtx_insn *added_notes_insn;\n+\n /* Basic block in which we are performing combines.  */\n static basic_block this_basic_block;\n static bool optimize_this_for_speed_p;\n@@ -2790,6 +2794,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n     std::swap (i1, i2);\n \n   added_links_insn = 0;\n+  added_notes_insn = 0;\n \n   /* First check for one important special case that the code below will\n      not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL\n@@ -4752,12 +4757,13 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   combine_successes++;\n   undo_commit ();\n \n-  if (added_links_insn\n-      && (newi2pat == 0 || DF_INSN_LUID (added_links_insn) < DF_INSN_LUID (i2))\n-      && DF_INSN_LUID (added_links_insn) < DF_INSN_LUID (i3))\n-    return added_links_insn;\n-  else\n-    return newi2pat ? i2 : i3;\n+  rtx_insn *ret = newi2pat ? i2 : i3;\n+  if (added_links_insn && DF_INSN_LUID (added_links_insn) < DF_INSN_LUID (ret))\n+    ret = added_links_insn;\n+  if (added_notes_insn && DF_INSN_LUID (added_notes_insn) < DF_INSN_LUID (ret))\n+    ret = added_notes_insn;\n+\n+  return ret;\n }\n \f\n /* Get a marker for undoing to the current state.  */\n@@ -14628,10 +14634,22 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t{\n \t  XEXP (note, 1) = REG_NOTES (place);\n \t  REG_NOTES (place) = note;\n+\n+\t  /* Set added_notes_insn to the earliest insn we added a note to.  */\n+\t  if (added_notes_insn == 0\n+\t      || DF_INSN_LUID (added_notes_insn) > DF_INSN_LUID (place))\n+\t    added_notes_insn = place;\n \t}\n \n       if (place2)\n-\tadd_shallow_copy_of_reg_note (place2, note);\n+\t{\n+\t  add_shallow_copy_of_reg_note (place2, note);\n+\n+\t  /* Set added_notes_insn to the earliest insn we added a note to.  */\n+\t  if (added_notes_insn == 0\n+\t      || DF_INSN_LUID (added_notes_insn) > DF_INSN_LUID (place2))\n+\t    added_notes_insn = place2;\n+\t}\n     }\n }\n \f"}]}