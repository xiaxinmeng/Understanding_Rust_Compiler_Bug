{"sha": "5165f1258bb2b110382156d62f46627e3e81654c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2NWYxMjU4YmIyYjExMDM4MjE1NmQ2MmY0NjYyN2UzZTgxNjU0Yw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-12-21T01:29:27Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-12-21T01:29:27Z"}, "message": "cp-demangle.h: Add comment explaining what to do to avoid overrunning string.\n\n\t* cp-demangle.h: Add comment explaining what to do to avoid\n\toverrunning string.\n\t(d_check_char): New.\n\t(d_next_char): Don't advance past trailing '\\0'.\n\t* cp-demangle.c (cplus_demangle_mangled_name): Use d_check_char.\n\t(d_nested_name): Likewise.\n\t(d_special_name): Likewise.\n\t(d_call_offset): Likewise.\n\t(d_function_type): Likewise.\n\t(d_array_type): Likewise.\n\t(d_pointer_to_member_type): Likewise.\n\t(d_template_param): Likewise.\n\t(d_template_args): Likewise.\n\t(d_template_arg): Likewise.\n\t(d_expr_primary): Likewise.\n\t(d_local_name): Likewise.\n\t(d_substitution): Likewise.\n\t(d_ctor_dtor_name): Use d_advance rather than d_next_char.\n\t* testsuite/test-demangle.c: Include sys/mman.h.\n\t(MAP_ANONYMOUS): Define.\n\t(protect_end): New.\n\t(main): Use protect_end.\n\t* testsuite/demangle-expected: Add testcases for overrunning\n\tthe end of the string.\n\nFrom-SVN: r120097", "tree": {"sha": "8bbefa55fbcb69174085aaec3d70bd9faf6d986a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bbefa55fbcb69174085aaec3d70bd9faf6d986a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5165f1258bb2b110382156d62f46627e3e81654c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5165f1258bb2b110382156d62f46627e3e81654c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5165f1258bb2b110382156d62f46627e3e81654c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5165f1258bb2b110382156d62f46627e3e81654c/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad338ade26ba9eefa5aad0ded33e26c3feeb8b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad338ade26ba9eefa5aad0ded33e26c3feeb8b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad338ade26ba9eefa5aad0ded33e26c3feeb8b8e"}], "stats": {"total": 170, "additions": 136, "deletions": 34}, "files": [{"sha": "e72f84520d1aef682c83b49acd289239f906c277", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=5165f1258bb2b110382156d62f46627e3e81654c", "patch": "@@ -1,3 +1,30 @@\n+2006-12-20  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* cp-demangle.h: Add comment explaining what to do to avoid\n+\toverrunning string.\n+\t(d_check_char): New.\n+\t(d_next_char): Don't advance past trailing '\\0'.\n+\t* cp-demangle.c (cplus_demangle_mangled_name): Use d_check_char.\n+\t(d_nested_name): Likewise.\n+\t(d_special_name): Likewise.\n+\t(d_call_offset): Likewise.\n+\t(d_function_type): Likewise.\n+\t(d_array_type): Likewise.\n+\t(d_pointer_to_member_type): Likewise.\n+\t(d_template_param): Likewise.\n+\t(d_template_args): Likewise.\n+\t(d_template_arg): Likewise.\n+\t(d_expr_primary): Likewise.\n+\t(d_local_name): Likewise.\n+\t(d_substitution): Likewise.\n+\t(d_ctor_dtor_name): Use d_advance rather than d_next_char.\n+\t* testsuite/test-demangle.c: Include sys/mman.h.\n+\t(MAP_ANONYMOUS): Define.\n+\t(protect_end): New.\n+\t(main): Use protect_end.\n+\t* testsuite/demangle-expected: Add testcases for overrunning\n+\tthe end of the string.\n+\n 2006-11-30  Andrew Stubbs  <andrew.stubbs@st.com>\n             J\"orn Rennecke <joern.rennecke@st.com>\n "}, {"sha": "ac1dfe56071a207dc0fdd29fcf6d25470ad0cb80", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=5165f1258bb2b110382156d62f46627e3e81654c", "patch": "@@ -913,9 +913,9 @@ CP_STATIC_IF_GLIBCPP_V3\n struct demangle_component *\n cplus_demangle_mangled_name (struct d_info *di, int top_level)\n {\n-  if (d_next_char (di) != '_')\n+  if (! d_check_char (di, '_'))\n     return NULL;\n-  if (d_next_char (di) != 'Z')\n+  if (! d_check_char (di, 'Z'))\n     return NULL;\n   return d_encoding (di, top_level);\n }\n@@ -1123,7 +1123,7 @@ d_nested_name (struct d_info *di)\n   struct demangle_component *ret;\n   struct demangle_component **pret;\n \n-  if (d_next_char (di) != 'N')\n+  if (! d_check_char (di, 'N'))\n     return NULL;\n \n   pret = d_cv_qualifiers (di, &ret, 1);\n@@ -1134,7 +1134,7 @@ d_nested_name (struct d_info *di)\n   if (*pret == NULL)\n     return NULL;\n \n-  if (d_next_char (di) != 'E')\n+  if (! d_check_char (di, 'E'))\n     return NULL;\n \n   return ret;\n@@ -1449,11 +1449,8 @@ d_operator_name (struct d_info *di)\n static struct demangle_component *\n d_special_name (struct d_info *di)\n {\n-  char c;\n-\n   di->expansion += 20;\n-  c = d_next_char (di);\n-  if (c == 'T')\n+  if (d_check_char (di, 'T'))\n     {\n       switch (d_next_char (di))\n \t{\n@@ -1502,7 +1499,7 @@ d_special_name (struct d_info *di)\n \t    offset = d_number (di);\n \t    if (offset < 0)\n \t      return NULL;\n-\t    if (d_next_char (di) != '_')\n+\t    if (! d_check_char (di, '_'))\n \t      return NULL;\n \t    base_type = cplus_demangle_type (di);\n \t    /* We don't display the offset.  FIXME: We should display\n@@ -1523,7 +1520,7 @@ d_special_name (struct d_info *di)\n \t  return NULL;\n \t}\n     }\n-  else if (c == 'G')\n+  else if (d_check_char (di, 'G'))\n     {\n       switch (d_next_char (di))\n \t{\n@@ -1570,14 +1567,14 @@ d_call_offset (struct d_info *di, int c)\n   else if (c == 'v')\n     {\n       d_number (di);\n-      if (d_next_char (di) != '_')\n+      if (! d_check_char (di, '_'))\n \treturn 0;\n       d_number (di);\n     }\n   else\n     return 0;\n \n-  if (d_next_char (di) != '_')\n+  if (! d_check_char (di, '_'))\n     return 0;\n \n   return 1;\n@@ -1601,13 +1598,13 @@ d_ctor_dtor_name (struct d_info *di)\n       else if (di->last_name->type == DEMANGLE_COMPONENT_SUB_STD)\n \tdi->expansion += di->last_name->u.s_string.len;\n     }\n-  switch (d_next_char (di))\n+  switch (d_peek_char (di))\n     {\n     case 'C':\n       {\n \tenum gnu_v3_ctor_kinds kind;\n \n-\tswitch (d_next_char (di))\n+\tswitch (d_peek_next_char (di))\n \t  {\n \t  case '1':\n \t    kind = gnu_v3_complete_object_ctor;\n@@ -1621,14 +1618,15 @@ d_ctor_dtor_name (struct d_info *di)\n \t  default:\n \t    return NULL;\n \t  }\n+\td_advance (di, 2);\n \treturn d_make_ctor (di, kind, di->last_name);\n       }\n \n     case 'D':\n       {\n \tenum gnu_v3_dtor_kinds kind;\n \n-\tswitch (d_next_char (di))\n+\tswitch (d_peek_next_char (di))\n \t  {\n \t  case '0':\n \t    kind = gnu_v3_deleting_dtor;\n@@ -1642,6 +1640,7 @@ d_ctor_dtor_name (struct d_info *di)\n \t  default:\n \t    return NULL;\n \t  }\n+\td_advance (di, 2);\n \treturn d_make_dtor (di, kind, di->last_name);\n       }\n \n@@ -1925,7 +1924,7 @@ d_function_type (struct d_info *di)\n {\n   struct demangle_component *ret;\n \n-  if (d_next_char (di) != 'F')\n+  if (! d_check_char (di, 'F'))\n     return NULL;\n   if (d_peek_char (di) == 'Y')\n     {\n@@ -1934,7 +1933,7 @@ d_function_type (struct d_info *di)\n       d_advance (di, 1);\n     }\n   ret = d_bare_function_type (di, 1);\n-  if (d_next_char (di) != 'E')\n+  if (! d_check_char (di, 'E'))\n     return NULL;\n   return ret;\n }\n@@ -2021,7 +2020,7 @@ d_array_type (struct d_info *di)\n   char peek;\n   struct demangle_component *dim;\n \n-  if (d_next_char (di) != 'A')\n+  if (! d_check_char (di, 'A'))\n     return NULL;\n \n   peek = d_peek_char (di);\n@@ -2049,7 +2048,7 @@ d_array_type (struct d_info *di)\n \treturn NULL;\n     }\n \n-  if (d_next_char (di) != '_')\n+  if (! d_check_char (di, '_'))\n     return NULL;\n \n   return d_make_comp (di, DEMANGLE_COMPONENT_ARRAY_TYPE, dim,\n@@ -2065,7 +2064,7 @@ d_pointer_to_member_type (struct d_info *di)\n   struct demangle_component *mem;\n   struct demangle_component **pmem;\n \n-  if (d_next_char (di) != 'M')\n+  if (! d_check_char (di, 'M'))\n     return NULL;\n \n   cl = cplus_demangle_type (di);\n@@ -2109,7 +2108,7 @@ d_template_param (struct d_info *di)\n {\n   long param;\n \n-  if (d_next_char (di) != 'T')\n+  if (! d_check_char (di, 'T'))\n     return NULL;\n \n   if (d_peek_char (di) == '_')\n@@ -2122,7 +2121,7 @@ d_template_param (struct d_info *di)\n       param += 1;\n     }\n \n-  if (d_next_char (di) != '_')\n+  if (! d_check_char (di, '_'))\n     return NULL;\n \n   ++di->did_subs;\n@@ -2144,7 +2143,7 @@ d_template_args (struct d_info *di)\n      constructor or destructor.  */\n   hold_last_name = di->last_name;\n \n-  if (d_next_char (di) != 'I')\n+  if (! d_check_char (di, 'I'))\n     return NULL;\n \n   al = NULL;\n@@ -2189,7 +2188,7 @@ d_template_arg (struct d_info *di)\n     case 'X':\n       d_advance (di, 1);\n       ret = d_expression (di);\n-      if (d_next_char (di) != 'E')\n+      if (! d_check_char (di, 'E'))\n \treturn NULL;\n       return ret;\n \n@@ -2316,7 +2315,7 @@ d_expr_primary (struct d_info *di)\n {\n   struct demangle_component *ret;\n \n-  if (d_next_char (di) != 'L')\n+  if (! d_check_char (di, 'L'))\n     return NULL;\n   if (d_peek_char (di) == '_')\n     ret = cplus_demangle_mangled_name (di, 0);\n@@ -2362,7 +2361,7 @@ d_expr_primary (struct d_info *di)\n \t}\n       ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));\n     }\n-  if (d_next_char (di) != 'E')\n+  if (! d_check_char (di, 'E'))\n     return NULL;\n   return ret;\n }\n@@ -2376,12 +2375,12 @@ d_local_name (struct d_info *di)\n {\n   struct demangle_component *function;\n \n-  if (d_next_char (di) != 'Z')\n+  if (! d_check_char (di, 'Z'))\n     return NULL;\n \n   function = d_encoding (di, 0);\n \n-  if (d_next_char (di) != 'E')\n+  if (! d_check_char (di, 'E'))\n     return NULL;\n \n   if (d_peek_char (di) == 's')\n@@ -2486,7 +2485,7 @@ d_substitution (struct d_info *di, int prefix)\n {\n   char c;\n \n-  if (d_next_char (di) != 'S')\n+  if (! d_check_char (di, 'S'))\n     return NULL;\n \n   c = d_next_char (di);"}, {"sha": "920ca47796c55af2f0a2736033d7f6b100acc3a9", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=5165f1258bb2b110382156d62f46627e3e81654c", "patch": "@@ -123,10 +123,16 @@ struct d_info\n   int expansion;\n };\n \n+/* To avoid running past the ending '\\0', don't:\n+   - call d_peek_next_char if d_peek_char returned '\\0'\n+   - call d_advance with an 'i' that is too large\n+   - call d_check_char(di, '\\0')\n+   Everything else is safe.  */\n #define d_peek_char(di) (*((di)->n))\n #define d_peek_next_char(di) ((di)->n[1])\n #define d_advance(di, i) ((di)->n += (i))\n-#define d_next_char(di) (*((di)->n++))\n+#define d_check_char(di, c) (d_peek_char(di) == c ? ((di)->n++, 1) : 0)\n+#define d_next_char(di) (d_peek_char(di) == '\\0' ? '\\0' : *((di)->n++))\n #define d_str(di) ((di)->n)\n \n /* Functions and arrays in cp-demangle.c which are referenced by"}, {"sha": "56d9f8991557f004dab06c1be2554aaf27f1fba2", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=5165f1258bb2b110382156d62f46627e3e81654c", "patch": "@@ -3816,3 +3816,25 @@ f\n SASDASDFASDF_sdfsdf\n SASDASDFASDF_sdfsdf\n SASDASDFASDF_sdfsdf\n+# These are all cases of invalid manglings where the demangler would read\n+# past the end of the string.\n+# d_name wasn't honouring a NULL from d_substitution\n+--format=gnu-v3\n+_ZSA\n+_ZSA\n+# d_expr_primary wasn't honouring NULL from cplus_demangle_mangled_name\n+--format=gnu-v3\n+_ZN1fIL_\n+_ZN1fIL_\n+# d_operator_name was taking two characters in a row\n+--format=gnu-v3\n+_Za\n+_Za\n+# d_prefix wasn't honouring NULL from d_substitution\n+--format=gnu-v3\n+_ZNSA\n+_ZNSA\n+# d_prefix wasn't honouring NULL from d_template_param\n+--format=gnu-v3\n+_ZNT\n+_ZNT"}, {"sha": "12b07dd6476cde353693f6056c40aff83de44b12", "filename": "libiberty/testsuite/test-demangle.c", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Ftestsuite%2Ftest-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5165f1258bb2b110382156d62f46627e3e81654c/libiberty%2Ftestsuite%2Ftest-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Ftest-demangle.c?ref=5165f1258bb2b110382156d62f46627e3e81654c", "patch": "@@ -86,6 +86,50 @@ getline(buf)\n   buf->alloced = alloc;\n }\n \n+/* If we have mmap() and mprotect(), copy the string S just before a\n+   protected page, so that if the demangler runs over the end of the\n+   string we'll get a fault, and return the address of the new string.\n+   If no mmap, or it fails, or it looks too hard, just return S.  */\n+\n+#ifdef HAVE_SYS_MMAN_H\n+#include <sys/mman.h>\n+#endif\n+#if defined(MAP_ANON) && ! defined (MAP_ANONYMOUS)\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+static const char *\n+protect_end (const char * s)\n+{\n+#if defined(HAVE_MMAP) && defined (MAP_ANONYMOUS)\n+  size_t pagesize = getpagesize();\n+  static char * buf;\n+  size_t s_len = strlen (s);\n+  char * result;\n+  \n+  /* Don't try if S is too long.  */\n+  if (s_len >= pagesize)\n+    return s;\n+\n+  /* Allocate one page of allocated space followed by an unmapped\n+     page.  */\n+  if (buf == NULL)\n+    {\n+      buf = mmap (NULL, pagesize * 2, PROT_READ | PROT_WRITE,\n+\t\t  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+      if (! buf)\n+\treturn s;\n+      munmap (buf + pagesize, pagesize);\n+    }\n+  \n+  result = buf + (pagesize - s_len - 1);\n+  memcpy (result, s, s_len + 1);\n+  return result;\n+#else\n+  return s;\n+#endif\n+}\n+\n static void\n fail (lineno, opts, in, out, exp)\n      int lineno;\n@@ -150,13 +194,17 @@ main(argc, argv)\n \n   for (;;)\n     {\n+      const char *inp;\n+      \n       getline (&format);\n       if (feof (stdin))\n \tbreak;\n \n       getline (&input);\n       getline (&expect);\n \n+      inp = protect_end (input.data);\n+\n       tests++;\n \n       no_params = 0;\n@@ -237,14 +285,14 @@ main(argc, argv)\n \t    {\n \t      enum gnu_v3_ctor_kinds kc;\n \n-\t      kc = is_gnu_v3_mangled_ctor (input.data);\n+\t      kc = is_gnu_v3_mangled_ctor (inp);\n \t      sprintf (buf, \"%d\", (int) kc);\n \t    }\n \t  else\n \t    {\n \t      enum gnu_v3_dtor_kinds kd;\n \n-\t      kd = is_gnu_v3_mangled_dtor (input.data);\n+\t      kd = is_gnu_v3_mangled_dtor (inp);\n \t      sprintf (buf, \"%d\", (int) kd);\n \t    }\n \n@@ -259,7 +307,7 @@ main(argc, argv)\n \n       cplus_demangle_set_style (style);\n \n-      result = cplus_demangle (input.data,\n+      result = cplus_demangle (inp,\n \t\t\t       DMGL_PARAMS|DMGL_ANSI|DMGL_TYPES\n \t\t\t       |(ret_postfix ? DMGL_RET_POSTFIX : 0));\n \n@@ -275,7 +323,7 @@ main(argc, argv)\n       if (no_params)\n \t{\n \t  getline (&expect);\n-\t  result = cplus_demangle (input.data, DMGL_ANSI|DMGL_TYPES);\n+\t  result = cplus_demangle (inp, DMGL_ANSI|DMGL_TYPES);\n \n \t  if (result\n \t      ? strcmp (result, expect.data)"}]}