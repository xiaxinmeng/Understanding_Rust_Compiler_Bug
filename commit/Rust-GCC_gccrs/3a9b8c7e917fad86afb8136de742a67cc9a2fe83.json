{"sha": "3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5YjhjN2U5MTdmYWQ4NmFmYjgxMzZkZTc0MmE2N2NjOWEyZmU4Mw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2002-06-28T17:32:12Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-06-28T17:32:12Z"}, "message": "rs6000.c (altivec_expand_builtin): Move lvx/stv/dst builtins...\n\n2002-06-27  Aldy Hernandez  <aldyh@redhat.com>\n\n        * config/rs6000/rs6000.c (altivec_expand_builtin): Move\n        lvx/stv/dst builtins...\n        (altivec_expand_ld_builtin): ...to here.\n        (altivec_expand_st_builtin): ...here.\n        (altivec_expand_dst_builtin): ...and here (respectively).\n\nFrom-SVN: r55067", "tree": {"sha": "a9ec3ba166e956354de8ba9ebfc35d311b0a2898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9ec3ba166e956354de8ba9ebfc35d311b0a2898"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9b8c7e917fad86afb8136de742a67cc9a2fe83/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f9dc2143bf260b6436c3582dd50dbbecbc71d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9dc2143bf260b6436c3582dd50dbbecbc71d45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9dc2143bf260b6436c3582dd50dbbecbc71d45"}], "stats": {"total": 367, "additions": 181, "deletions": 186}, "files": [{"sha": "6813ca9180743b5ca40dab63212b14ef5abb5ca0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9b8c7e917fad86afb8136de742a67cc9a2fe83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9b8c7e917fad86afb8136de742a67cc9a2fe83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "patch": "@@ -1,3 +1,11 @@\n+2002-06-27  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * config/rs6000/rs6000.c (altivec_expand_builtin): Move\n+        lvx/stv/dst builtins...\n+        (altivec_expand_ld_builtin): ...to here.\n+        (altivec_expand_st_builtin): ...here.\n+        (altivec_expand_dst_builtin): ...and here (respectively).\n+\n 2002-06-28  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.h (RETURN_IN_MEMORY): Update comment."}, {"sha": "48c8748b847bccad14312be9381a870920df1fca", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 173, "deletions": 186, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9b8c7e917fad86afb8136de742a67cc9a2fe83/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9b8c7e917fad86afb8136de742a67cc9a2fe83/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3a9b8c7e917fad86afb8136de742a67cc9a2fe83", "patch": "@@ -192,6 +192,9 @@ static rtx rs6000_expand_ternop_builtin PARAMS ((enum insn_code, tree, rtx));\n static rtx rs6000_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n static void altivec_init_builtins PARAMS ((void));\n static rtx altivec_expand_builtin PARAMS ((tree, rtx, bool *));\n+static rtx altivec_expand_ld_builtin PARAMS ((tree, rtx, bool *));\n+static rtx altivec_expand_st_builtin PARAMS ((tree, rtx, bool *));\n+static rtx altivec_expand_dst_builtin PARAMS ((tree, rtx, bool *));\n static rtx altivec_expand_abs_builtin PARAMS ((enum insn_code, tree, rtx));\n static rtx altivec_expand_predicate_builtin PARAMS ((enum insn_code, const char *, tree, rtx));\n static rtx altivec_expand_stv_builtin PARAMS ((enum insn_code, tree));\n@@ -3888,189 +3891,213 @@ rs6000_expand_ternop_builtin (icode, arglist, target)\n   return target;\n }\n \n-/* Expand the builtin in EXP and store the result in TARGET.  Store\n-   true in *EXPANDEDP if we found a builtin to expand.  */\n+/* Expand the lvx builtins.  */\n static rtx\n-altivec_expand_builtin (exp, target, expandedp)\n+altivec_expand_ld_builtin (exp, target, expandedp)\n      tree exp;\n      rtx target;\n      bool *expandedp;\n {\n-  struct builtin_description *d;\n-  struct builtin_description_predicates *dp;\n-  size_t i;\n-  enum insn_code icode;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0, arg1, arg2;\n-  rtx op0, op1, op2, pat;\n-  enum machine_mode tmode, mode0, mode1, mode2;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n-\n-  *expandedp = true;\n+  tree arg0;\n+  enum machine_mode tmode, mode0;\n+  rtx pat, target, op0;\n+  enum insn_code icode;\n \n   switch (fcode)\n     {\n     case ALTIVEC_BUILTIN_LD_INTERNAL_16qi:\n       icode = CODE_FOR_altivec_lvx_16qi;\n-      arg0 = TREE_VALUE (arglist);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n-\n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-\n-      pat = GEN_FCN (icode) (target, op0);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n-\n+      break;\n     case ALTIVEC_BUILTIN_LD_INTERNAL_8hi:\n       icode = CODE_FOR_altivec_lvx_8hi;\n-      arg0 = TREE_VALUE (arglist);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n+      break;\n+    case ALTIVEC_BUILTIN_LD_INTERNAL_4si:\n+      icode = CODE_FOR_altivec_lvx_4si;\n+      break;\n+    case ALTIVEC_BUILTIN_LD_INTERNAL_4sf:\n+      icode = CODE_FOR_altivec_lvx_4sf;\n+      break;\n+    default:\n+      *expandedp = false;\n+      return NULL_RTX;\n+    }\n \n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n+  *expandedp = true;\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  arg0 = TREE_VALUE (arglist);\n+  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  tmode = insn_data[icode].operand[0].mode;\n+  mode0 = insn_data[icode].operand[1].mode;\n \n-      pat = GEN_FCN (icode) (target, op0);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n+  if (target == 0\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n \n-    case ALTIVEC_BUILTIN_LD_INTERNAL_4si:\n-      icode = CODE_FOR_altivec_lvx_4si;\n-      arg0 = TREE_VALUE (arglist);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n \n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n+  pat = GEN_FCN (icode) (target, op0);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+/* Expand the stvx builtins.  */\n+static rtx\n+altivec_expand_st_builtin (exp, target, expandedp)\n+     tree exp;\n+     rtx target;\n+     bool *expandedp;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arg0, arg1;\n+  enum machine_mode mode0, mode1;\n+  rtx pat, target, op0, op1;\n+  enum insn_code icode;\n \n-      pat = GEN_FCN (icode) (target, op0);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n+  switch (fcode)\n+    {\n+    case ALTIVEC_BUILTIN_ST_INTERNAL_16qi:\n+      icode = CODE_FOR_altivec_stvx_16qi;\n+      break;\n+    case ALTIVEC_BUILTIN_ST_INTERNAL_8hi:\n+      icode = CODE_FOR_altivec_stvx_8hi;\n+      break;\n+    case ALTIVEC_BUILTIN_ST_INTERNAL_4si:\n+      icode = CODE_FOR_altivec_stvx_4si;\n+      break;\n+    case ALTIVEC_BUILTIN_ST_INTERNAL_4sf:\n+      icode = CODE_FOR_altivec_stvx_4sf;\n+      break;\n+    default:\n+      *expandedp = false;\n+      return NULL_RTX;\n+    }\n \n-    case ALTIVEC_BUILTIN_LD_INTERNAL_4sf:\n-      icode = CODE_FOR_altivec_lvx_4sf;\n-      arg0 = TREE_VALUE (arglist);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      tmode = insn_data[icode].operand[0].mode;\n-      mode0 = insn_data[icode].operand[1].mode;\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  mode0 = insn_data[icode].operand[0].mode;\n+  mode1 = insn_data[icode].operand[1].mode;\n \n-      if (target == 0\n-\t  || GET_MODE (target) != tmode\n-\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-\ttarget = gen_reg_rtx (tmode);\n+  if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n+    op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  pat = GEN_FCN (icode) (op0, op1);\n+  if (pat)\n+    emit_insn (pat);\n \n-      pat = GEN_FCN (icode) (target, op0);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return target;\n+  *expandedp = true;\n+  return NULL_RTX;\n+}\n \n-    case ALTIVEC_BUILTIN_ST_INTERNAL_16qi:\n-      icode = CODE_FOR_altivec_stvx_16qi;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      mode0 = insn_data[icode].operand[0].mode;\n-      mode1 = insn_data[icode].operand[1].mode;\n+/* Expand the dst builtins.  */\n+static rtx\n+altivec_expand_dst_builtin (exp, target, expandedp)\n+     tree exp;\n+     rtx target;\n+     bool *expandedp;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arg0, arg1, arg2;\n+  enum machine_mode mode0, mode1, mode2;\n+  rtx pat, target, op0, op1, op2;\n+  struct builtin_description *d;\n+  int i;\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n+  *expandedp = false;\n \n-      pat = GEN_FCN (icode) (op0, op1);\n-      if (pat)\n-\temit_insn (pat);\n-      return NULL_RTX;\n+  /* Handle DST variants.  */\n+  d = (struct builtin_description *) bdesc_dst;\n+  for (i = 0; i < ARRAY_SIZE (bdesc_dst); i++, d++)\n+    if (d->code == fcode)\n+      {\n+\targ0 = TREE_VALUE (arglist);\n+\targ1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\targ2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\top0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+\top1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+\top2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+\tmode0 = insn_data[d->icode].operand[0].mode;\n+\tmode1 = insn_data[d->icode].operand[1].mode;\n+\tmode2 = insn_data[d->icode].operand[2].mode;\n \n-    case ALTIVEC_BUILTIN_ST_INTERNAL_8hi:\n-      icode = CODE_FOR_altivec_stvx_8hi;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      mode0 = insn_data[icode].operand[0].mode;\n-      mode1 = insn_data[icode].operand[1].mode;\n+\t/* Invalid arguments, bail out before generating bad rtl.  */\n+\tif (arg0 == error_mark_node\n+\t    || arg1 == error_mark_node\n+\t    || arg2 == error_mark_node)\n+\t  return const0_rtx;\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n+\tif (TREE_CODE (arg2) != INTEGER_CST\n+\t    || TREE_INT_CST_LOW (arg2) & ~0x3)\n+\t  {\n+\t    error (\"argument to `%s' must be a 2-bit unsigned literal\", d->name);\n+\t    return const0_rtx;\n+\t  }\n \n-      pat = GEN_FCN (icode) (op0, op1);\n-      if (pat)\n-\temit_insn (pat);\n-      return NULL_RTX;\n+\tif (! (*insn_data[d->icode].operand[0].predicate) (op0, mode0))\n+\t  op0 = copy_to_mode_reg (mode0, op0);\n+\tif (! (*insn_data[d->icode].operand[1].predicate) (op1, mode1))\n+\t  op1 = copy_to_mode_reg (mode1, op1);\n \n-    case ALTIVEC_BUILTIN_ST_INTERNAL_4si:\n-      icode = CODE_FOR_altivec_stvx_4si;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      mode0 = insn_data[icode].operand[0].mode;\n-      mode1 = insn_data[icode].operand[1].mode;\n+\tpat = GEN_FCN (d->icode) (op0, op1, op2);\n+\tif (pat != 0)\n+\t  emit_insn (pat);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n+\t*expandedp = true;\n+\treturn NULL_RTX;\n+      }\n \n-      pat = GEN_FCN (icode) (op0, op1);\n-      if (pat)\n-\temit_insn (pat);\n-      return NULL_RTX;\n+  return NULL_RTX;\n+}\n \n-    case ALTIVEC_BUILTIN_ST_INTERNAL_4sf:\n-      icode = CODE_FOR_altivec_stvx_4sf;\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      mode0 = insn_data[icode].operand[0].mode;\n-      mode1 = insn_data[icode].operand[1].mode;\n+/* Expand the builtin in EXP and store the result in TARGET.  Store\n+   true in *EXPANDEDP if we found a builtin to expand.  */\n+static rtx\n+altivec_expand_builtin (exp, target, expandedp)\n+     tree exp;\n+     rtx target;\n+     bool *expandedp;\n+{\n+  struct builtin_description *d;\n+  struct builtin_description_predicates *dp;\n+  size_t i;\n+  enum insn_code icode;\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1, arg2;\n+  rtx op0, op1, op2, pat;\n+  enum machine_mode tmode, mode0, mode1, mode2;\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n+  target = altivec_expand_ld_builtin (exp, target, expandedp);\n+  if (*expandedp)\n+    return target;\n \n-      pat = GEN_FCN (icode) (op0, op1);\n-      if (pat)\n-\temit_insn (pat);\n-      return NULL_RTX;\n+  target = altivec_expand_st_builtin (exp, target, expandedp);\n+  if (*expandedp)\n+    return target;\n+\n+  target = altivec_expand_dst_builtin (exp, target, expandedp);\n+  if (*expandedp)\n+    return target;\n+\n+  *expandedp = true;\n \n+  switch (fcode)\n+    {\n     case ALTIVEC_BUILTIN_STVX:\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx, arglist);\n     case ALTIVEC_BUILTIN_STVEBX:\n@@ -4081,7 +4108,7 @@ altivec_expand_builtin (exp, target, expandedp)\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvewx, arglist);\n     case ALTIVEC_BUILTIN_STVXL:\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvxl, arglist);\n-  \n+\n     case ALTIVEC_BUILTIN_MFVSCR:\n       icode = CODE_FOR_altivec_mfvscr;\n       tmode = insn_data[icode].operand[0].mode;\n@@ -4114,7 +4141,7 @@ altivec_expand_builtin (exp, target, expandedp)\n       if (pat)\n \temit_insn (pat);\n       return NULL_RTX;\n-      \n+\n     case ALTIVEC_BUILTIN_DSSALL:\n       emit_insn (gen_altivec_dssall ());\n       return NULL_RTX;\n@@ -4143,46 +4170,6 @@ altivec_expand_builtin (exp, target, expandedp)\n       return NULL_RTX;\n     }\n \n-  /* Handle DST variants.  */\n-  d = (struct builtin_description *) bdesc_dst;\n-  for (i = 0; i < ARRAY_SIZE (bdesc_dst); i++, d++)\n-    if (d->code == fcode)\n-      {\n-\targ0 = TREE_VALUE (arglist);\n-\targ1 = TREE_VALUE (TREE_CHAIN (arglist));\n-\targ2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\top0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-\top1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-\top2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n-\tmode0 = insn_data[d->icode].operand[0].mode;\n-\tmode1 = insn_data[d->icode].operand[1].mode;\n-\tmode2 = insn_data[d->icode].operand[2].mode;\n-\n-\t/* Invalid arguments, bail out before generating bad rtl.  */\n-\tif (arg0 == error_mark_node\n-\t    || arg1 == error_mark_node\n-\t    || arg2 == error_mark_node)\n-\t  return const0_rtx;\n-\n-      if (TREE_CODE (arg2) != INTEGER_CST\n-\t  || TREE_INT_CST_LOW (arg2) & ~0x3)\n-\t{\n-\t  error (\"argument to `%s' must be a 2-bit unsigned literal\", d->name);\n-\t  return const0_rtx;\n-\t}\n-\n-\tif (! (*insn_data[d->icode].operand[0].predicate) (op0, mode0))\n-\t  op0 = copy_to_mode_reg (mode0, op0);\n-\tif (! (*insn_data[d->icode].operand[1].predicate) (op1, mode1))\n-\t  op1 = copy_to_mode_reg (mode1, op1);\n-\n-\tpat = GEN_FCN (d->icode) (op0, op1, op2);\n-\tif (pat != 0)\n-\t  emit_insn (pat);\n-\n-\treturn NULL_RTX;\n-      }\n-\n   /* Expand abs* operations.  */\n   d = (struct builtin_description *) bdesc_abs;\n   for (i = 0; i < ARRAY_SIZE (bdesc_abs); i++, d++)"}]}