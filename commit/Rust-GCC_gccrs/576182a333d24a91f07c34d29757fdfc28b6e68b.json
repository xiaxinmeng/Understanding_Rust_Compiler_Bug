{"sha": "576182a333d24a91f07c34d29757fdfc28b6e68b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc2MTgyYTMzM2QyNGE5MWYwN2MzNGQyOTc1N2ZkZmMyOGI2ZTY4Yg==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:48:46Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:48:46Z"}, "message": "(untyped_call, untyped_return): New patterns.\n\nFrom-SVN: r3837", "tree": {"sha": "ab9741f0504f0fb5c8170503e127f998511afafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab9741f0504f0fb5c8170503e127f998511afafc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/576182a333d24a91f07c34d29757fdfc28b6e68b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576182a333d24a91f07c34d29757fdfc28b6e68b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576182a333d24a91f07c34d29757fdfc28b6e68b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576182a333d24a91f07c34d29757fdfc28b6e68b/comments", "author": null, "committer": null, "parents": [{"sha": "e9125c09d3795c7e490741c5c174df294b5d7cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9125c09d3795c7e490741c5c174df294b5d7cd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9125c09d3795c7e490741c5c174df294b5d7cd4"}], "stats": {"total": 194, "additions": 194, "deletions": 0}, "files": [{"sha": "c02b3384009710a6c09ec65d47ec5e639fe5a479", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576182a333d24a91f07c34d29757fdfc28b6e68b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576182a333d24a91f07c34d29757fdfc28b6e68b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=576182a333d24a91f07c34d29757fdfc28b6e68b", "patch": "@@ -4113,6 +4113,123 @@\n   \"!HALF_PIC_P ()\"\n   \"call %P1\")\n \n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand:BLK 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  rtx addr;\n+\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+\n+  /* With half-pic, force the address into a register.  */\n+  addr = XEXP (operands[0], 0);\n+  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n+    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n+\n+  operands[1] = change_address (operands[1], DImode, XEXP (operands[1], 0));\n+}\")\n+\n+(define_insn \"\"\n+  [(call (match_operand:QI 0 \"indirect_operand\" \"m\")\n+\t (const_int 0))\n+   (match_operand:DI 1 \"memory_operand\" \"o\")\n+   (match_operand 2 \"\" \"\")]\n+  \"\"\n+  \"*\n+{\n+  rtx addr = operands[1];\n+\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    {\n+      operands[0] = XEXP (operands[0], 0);\n+      output_asm_insn (AS1 (call,%*%0), operands);\n+    }\n+  else\n+    output_asm_insn (AS1 (call,%P0), operands);\n+\n+  operands[2] = gen_rtx (REG, SImode, 0);\n+  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n+\n+  operands[2] = gen_rtx (REG, SImode, 1);\n+  operands[1] = adj_offsettable_operand (addr, 4);\n+  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n+\n+  operands[1] = adj_offsettable_operand (addr, 8);\n+  return AS1 (fnsave,%1);\n+}\")\n+\n+(define_insn \"\"\n+  [(call (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t (const_int 0))\n+   (match_operand:DI 1 \"memory_operand\" \"o\")\n+   (match_operand 2 \"\" \"\")]\n+  \"!HALF_PIC_P ()\"\n+  \"*\n+{\n+  rtx addr = operands[1];\n+\n+  output_asm_insn (AS1 (call,%P0));\n+\n+  operands[2] = gen_rtx (REG, SImode, 0);\n+  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n+\n+  operands[2] = gen_rtx (REG, SImode, 1);\n+  operands[1] = adj_offsettable_operand (addr, 4);\n+  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n+\n+  operands[1] = adj_offsettable_operand (addr, 8);\n+  return AS1 (fnsave,%1);\n+}\")\n+\n+;; We use fnsave and frstor to save and restore the floating point result.\n+;; These are expensive instructions and require a large space to save the\n+;; FPU state.  An more complicated alternative is to use fnstenv to store\n+;; the FPU environment and test whether the stack top is valid.  Store the\n+;; result of the test, and if it is valid, pop and save the value.  The\n+;; untyped_return would check the test and optionally push the saved value.\n+\n+(define_expand \"untyped_return\"\n+  [(match_operand:BLK 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx valreg1 = gen_rtx (REG, SImode, 0);\n+  rtx valreg2 = gen_rtx (REG, SImode, 1);\n+  rtx result = operands[0];\n+\n+  /* Restore the FPU state.  */\n+  emit_insn (gen_update_return (change_address (result, SImode,\n+\t\t\t\t\t\tplus_constant (XEXP (result, 0),\n+\t\t\t\t\t\t\t       8))));\n+\n+  /* Reload the function value registers.  */\n+  emit_move_insn (valreg1, change_address (result, SImode, XEXP (result, 0)));\n+  emit_move_insn (valreg2,\n+\t\t  change_address (result, SImode,\n+\t\t\t\t  plus_constant (XEXP (result, 0), 4)));\n+\n+  /* Put USE insns before the return.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, valreg1));\n+  emit_insn (gen_rtx (USE, VOIDmode, valreg2));\n+\n+  /* Construct the return.  */\n+  expand_null_return ();\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"update_return\"\n+  [(unspec:SI [(match_operand:SI 0 \"memory_operand\" \"m\")] 0)]\n+  \"\"\n+  \"frstor %0\")\n+\n ;; Insn emitted into the body of a function to return from a function.\n ;; This is only done if the function's epilogue is known to be simple.\n ;; See comments for simple_386_epilogue in i386.c."}, {"sha": "87d1a2e7f866f1ea33f18782f8edb72f3f9bface", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576182a333d24a91f07c34d29757fdfc28b6e68b/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576182a333d24a91f07c34d29757fdfc28b6e68b/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=576182a333d24a91f07c34d29757fdfc28b6e68b", "patch": "@@ -2749,6 +2749,83 @@\n   return \\\"call %a1,%2%#\\\";\n }\"\n   [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand:BLK 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\n+{\n+  operands[1] = change_address (operands[1], DImode, XEXP (operands[1], 0));\n+}\")\n+\n+;; Make a call followed by two nops in case the function being called\n+;; returns a structure value and expects to skip an unimp instruction.\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_operand_address\" \"rS\"))\n+\t (const_int 0))\n+   (match_operand:DI 1 \"memory_operand\" \"o\")\n+   (match_operand 2 \"\" \"\")\n+   (clobber (reg:SI 15))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = adj_offsettable_operand (operands[1], 8);\n+  return \\\"call %a0,0\\;nop\\;nop\\;std %%o0,%1\\;st %%f0,%2\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+;; Prepare to return any type including a structure value.\n+\n+(define_expand \"untyped_return\"\n+  [(match_operand:BLK 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx valreg1 = gen_rtx (REG, DImode, 24);\n+  rtx valreg2 = gen_rtx (REG, DFmode, 32);\n+  rtx result = operands[0];\n+  rtx rtnreg = gen_rtx (REG, SImode, (leaf_function ? 15 : 31));\n+  rtx value = gen_reg_rtx (SImode);\n+\n+  /* Fetch the instruction where we will return to and see if it's an unimp\n+     instruction (the most significant 10 bits will be zero).  If so,\n+     update the return address to skip the unimp instruction.  */\n+  emit_move_insn (value,\n+\t\t  gen_rtx (MEM, SImode, plus_constant (rtnreg, 8)));\n+  emit_insn (gen_lshrsi3 (value, value, GEN_INT (22)));\n+  emit_insn (gen_update_return (rtnreg, value));\n+\n+  /* Reload the function value registers.  */\n+  emit_move_insn (valreg1, change_address (result, DImode, XEXP (result, 0)));\n+  emit_move_insn (valreg2,\n+\t\t  change_address (result, DFmode,\n+\t\t\t\t  plus_constant (XEXP (result, 0), 8)));\n+\n+  /* Put USE insns before the return.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, valreg1));\n+  emit_insn (gen_rtx (USE, VOIDmode, valreg2));\n+\n+  /* Construct the return.  */\n+  expand_null_return ();\n+\n+  DONE;\n+}\")\n+\n+;; This is a bit of a hack.  We're incrementing a fixed register (%i7),\n+;; and parts of the compiler don't want to believe that the add is needed.\n+\n+(define_insn \"update_return\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")] 0)]\n+  \"\"\n+  \"cmp %1,0\\;be,a .+8\\;add %0,4,%0\"\n+  [(set_attr \"type\" \"multi\")])\n \f\n (define_insn \"return\"\n   [(return)]"}]}