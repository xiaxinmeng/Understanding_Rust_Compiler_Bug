{"sha": "ff944b4986e98b09d1c300ad3f41ed89313aa915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5NDRiNDk4NmU5OGIwOWQxYzMwMGFkM2Y0MWVkODkzMTNhYTkxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-11-29T21:17:05Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-11-29T21:17:05Z"}, "message": "class.c (walk_subobject_offsets): Recur on binfos as well as on types.\n\n\t* class.c (walk_subobject_offsets): Recur on binfos as well as on\n\ttypes.\n\t(layout_nonempty_base_or_field): Pass it a binfo when processing a\n\tbase class.\n\t(layout_empty_base): Likewise.\n\t(build_base_field): Likewise.\n\nFrom-SVN: r59643", "tree": {"sha": "5e087c8befd91a9e9973b1c4373f15a13ed820b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e087c8befd91a9e9973b1c4373f15a13ed820b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff944b4986e98b09d1c300ad3f41ed89313aa915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff944b4986e98b09d1c300ad3f41ed89313aa915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff944b4986e98b09d1c300ad3f41ed89313aa915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff944b4986e98b09d1c300ad3f41ed89313aa915/comments", "author": null, "committer": null, "parents": [{"sha": "8ef34c0df0f3f3ede1c25d172168a5b3bd1f6572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef34c0df0f3f3ede1c25d172168a5b3bd1f6572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ef34c0df0f3f3ede1c25d172168a5b3bd1f6572"}], "stats": {"total": 145, "additions": 91, "deletions": 54}, "files": [{"sha": "d22e5386fe9dbe3907cca003f17c2c44fac57f49", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff944b4986e98b09d1c300ad3f41ed89313aa915/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff944b4986e98b09d1c300ad3f41ed89313aa915/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ff944b4986e98b09d1c300ad3f41ed89313aa915", "patch": "@@ -1,3 +1,12 @@\n+2002-11-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (walk_subobject_offsets): Recur on binfos as well as on\n+\ttypes.\n+\t(layout_nonempty_base_or_field): Pass it a binfo when processing a\n+\tbase class.\n+\t(layout_empty_base): Likewise.\n+\t(build_base_field): Likewise.\n+\t\n 2002-11-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (build_base_field): Make sure we get the canonical base"}, {"sha": "e3ea2db9da0a5269b04066c2ed582680d6c45e90", "filename": "gcc/cp/class.c", "status": "modified", "additions": 82, "deletions": 54, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff944b4986e98b09d1c300ad3f41ed89313aa915/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff944b4986e98b09d1c300ad3f41ed89313aa915/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ff944b4986e98b09d1c300ad3f41ed89313aa915", "patch": "@@ -3410,12 +3410,20 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n      int vbases_p;\n {\n   int r = 0;\n+  tree type_binfo = NULL_TREE;\n \n   /* If this OFFSET is bigger than the MAX_OFFSET, then we should\n      stop.  */\n   if (max_offset && INT_CST_LT (max_offset, offset))\n     return 0;\n \n+  if (!TYPE_P (type)) \n+    {\n+      if (abi_version_at_least (2))\n+\ttype_binfo = type;\n+      type = BINFO_TYPE (type);\n+    }\n+\n   if (CLASS_TYPE_P (type))\n     {\n       tree field;\n@@ -3432,9 +3440,13 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n \treturn r;\n \n       /* Iterate through the direct base classes of TYPE.  */\n-      for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); ++i)\n+      if (!type_binfo)\n+\ttype_binfo = TYPE_BINFO (type);\n+      for (i = 0; i < BINFO_N_BASETYPES (type_binfo); ++i)\n \t{\n-\t  binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\t  tree binfo_offset;\n+\n+\t  binfo = BINFO_BASETYPE (type_binfo, i);\n \n \t  if (abi_version_at_least (2) \n \t      && TREE_VIA_VIRTUAL (binfo))\n@@ -3445,11 +3457,25 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n \t      && !BINFO_PRIMARY_P (binfo))\n \t    continue;\n \n-\t  r = walk_subobject_offsets (BINFO_TYPE (binfo),\n+\t  if (!abi_version_at_least (2))\n+\t    binfo_offset = size_binop (PLUS_EXPR,\n+\t\t\t\t       offset,\n+\t\t\t\t       BINFO_OFFSET (binfo));\n+\t  else\n+\t    {\n+\t      tree orig_binfo;\n+\t      /* We cannot rely on BINFO_OFFSET being set for the base\n+\t\t class yet, but the offsets for direct non-virtual\n+\t\t bases can be calculated by going back to the TYPE.  */\n+\t      orig_binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\t      binfo_offset = size_binop (PLUS_EXPR,\t      \n+\t\t\t\t\t offset,\n+\t\t\t\t\t BINFO_OFFSET (orig_binfo));\n+\t    }\n+\n+\t  r = walk_subobject_offsets (binfo,\n \t\t\t\t      f,\n-\t\t\t\t      size_binop (PLUS_EXPR,\n-\t\t\t\t\t\t  offset,\n-\t\t\t\t\t\t  BINFO_OFFSET (binfo)),\n+\t\t\t\t      binfo_offset,\n \t\t\t\t      offsets,\n \t\t\t\t      max_offset,\n \t\t\t\t      (abi_version_at_least (2) \n@@ -3458,30 +3484,55 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n \t    return r;\n \t}\n \n-      /* Iterate through the virtual base classes of TYPE.  In G++\n-\t 3.2, we included virtual bases in the direct base class loop\n-\t above, which results in incorrect results; the correct\n-\t offsets for virtual bases are only known when working with\n-\t the most derived type.  */\n-      if (abi_version_at_least (2) && vbases_p)\n+      if (abi_version_at_least (2))\n \t{\n \t  tree vbase;\n \n-\t  for (vbase = CLASSTYPE_VBASECLASSES (type);\n-\t       vbase;\n-\t       vbase = TREE_CHAIN (vbase))\n+\t  /* Iterate through the virtual base classes of TYPE.  In G++\n+\t     3.2, we included virtual bases in the direct base class\n+\t     loop above, which results in incorrect results; the\n+\t     correct offsets for virtual bases are only known when\n+\t     working with the most derived type.  */\n+\t  if (vbases_p)\n+\t    for (vbase = CLASSTYPE_VBASECLASSES (type);\n+\t\t vbase;\n+\t\t vbase = TREE_CHAIN (vbase))\n+\t      {\n+\t\tbinfo = TREE_VALUE (vbase);\n+\t\tr = walk_subobject_offsets (binfo,\n+\t\t\t\t\t    f,\n+\t\t\t\t\t    size_binop (PLUS_EXPR,\n+\t\t\t\t\t\t\toffset,\n+\t\t\t\t\t\t\tBINFO_OFFSET (binfo)),\n+\t\t\t\t\t    offsets,\n+\t\t\t\t\t    max_offset,\n+\t\t\t\t\t    /*vbases_p=*/0);\n+\t\tif (r)\n+\t\t  return r;\n+\t      }\n+\t  else\n \t    {\n-\t      binfo = TREE_VALUE (vbase);\n-\t      r = walk_subobject_offsets (BINFO_TYPE (binfo),\n-\t\t\t\t\t  f,\n-\t\t\t\t\t  size_binop (PLUS_EXPR,\n-\t\t\t\t\t\t      offset,\n-\t\t\t\t\t\t      BINFO_OFFSET (binfo)),\n-\t\t\t\t\t  offsets,\n-\t\t\t\t\t  max_offset,\n-\t\t\t\t\t  /*vbases_p=*/0);\n-\t      if (r)\n-\t\treturn r;\n+\t      /* We still have to walk the primary base, if it is\n+\t\t virtual.  (If it is non-virtual, then it was walked\n+\t\t above.)  */\n+\t      vbase = get_primary_binfo (type_binfo);\n+\t      if (vbase && TREE_VIA_VIRTUAL (vbase))\n+\t\t{\n+\t\t  tree derived = type_binfo;\n+\t\t  while (BINFO_INHERITANCE_CHAIN (derived))\n+\t\t    derived = BINFO_INHERITANCE_CHAIN (derived);\n+\t\t  derived = TREE_TYPE (derived);\n+\t\t  vbase = binfo_for_vbase (TREE_TYPE (vbase), derived);\n+\n+\t\t  if (BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n+\t\t    {\n+\t\t      r = (walk_subobject_offsets \n+\t\t\t   (vbase, f, offset,\n+\t\t\t    offsets, max_offset, /*vbases_p=*/0));\n+\t\t      if (r)\n+\t\t\treturn r;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n \n@@ -3652,7 +3703,8 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t virtual base.  */\n       if (!abi_version_at_least (2) && binfo && TREE_VIA_VIRTUAL (binfo))\n \tbreak;\n-      if (layout_conflict_p (type, offset, offsets, field_p))\n+      if (layout_conflict_p (field_p ? type : binfo, offset, \n+\t\t\t     offsets, field_p))\n \t{\n \t  /* Strip off the size allocated to this field.  That puts us\n \t     at the first place we could have put the field with\n@@ -3726,7 +3778,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n-  if (layout_conflict_p (BINFO_TYPE (binfo),\n+  if (layout_conflict_p (binfo,\n \t\t\t BINFO_OFFSET (binfo),\n \t\t\t offsets, \n \t\t\t /*vbases_p=*/0))\n@@ -3737,7 +3789,7 @@ layout_empty_base (binfo, eoc, offsets, t)\n       propagate_binfo_offsets (binfo, convert (ssizetype, eoc), t);\n       while (1) \n \t{\n-\t  if (!layout_conflict_p (BINFO_TYPE (binfo),\n+\t  if (!layout_conflict_p (binfo,\n \t\t\t\t  BINFO_OFFSET (binfo), \n \t\t\t\t  offsets,\n \t\t\t\t  /*vbases_p=*/0))\n@@ -3848,35 +3900,11 @@ build_base_field (record_layout_info rli, tree binfo,\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n-  record_subobject_offsets (BINFO_TYPE (binfo), \n+  record_subobject_offsets (binfo,\n \t\t\t    BINFO_OFFSET (binfo),\n \t\t\t    offsets, \n \t\t\t    /*vbases_p=*/0);\n \n-  if (abi_version_at_least (2))\n-    {\n-      /* If BINFO has a primary virtual base that is really going to\n-\t be located at the same offset as binfo, it will have been\n-\t skipped -- but we should record empty bases from there too.  */\n-      while (true) \n-\t{\n-\t  tree b;\n-\n-\t  b = get_primary_binfo (binfo);\n-\t  if (!b)\n-\t    break;\n-\t  b = CANONICAL_BINFO (b, rli->t);\n-\t  if (BINFO_PRIMARY_BASE_OF (b) != binfo)\n-\t    break;\n-\t  if (TREE_VIA_VIRTUAL (b))\n-\t    record_subobject_offsets (BINFO_TYPE (b),\n-\t\t\t\t      BINFO_OFFSET (b),\n-\t\t\t\t      offsets,\n-\t\t\t\t      /*vbases_p=*/0);\n-\t  binfo = b;\n-\t}\n-    }\n-\n   return next_field;\n }\n "}]}