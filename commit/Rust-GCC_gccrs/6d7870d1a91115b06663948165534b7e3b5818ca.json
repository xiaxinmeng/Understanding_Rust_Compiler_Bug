{"sha": "6d7870d1a91115b06663948165534b7e3b5818ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3ODcwZDFhOTExMTViMDY2NjM5NDgxNjU1MzRiN2UzYjU4MThjYQ==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2004-04-27T05:19:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2004-04-27T05:19:49Z"}, "message": "Bug 14927\n\nBug 14927\n* config/ia64/ia64.md (movxf): New local op0.  Handle case where\noperands[0] is a SUBREG.  Handle case where operands[1] is a GR reg.\n\nFrom-SVN: r81211", "tree": {"sha": "2e27226aa9c2149cc1ddc833c47aec9be61072d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e27226aa9c2149cc1ddc833c47aec9be61072d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d7870d1a91115b06663948165534b7e3b5818ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7870d1a91115b06663948165534b7e3b5818ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7870d1a91115b06663948165534b7e3b5818ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7870d1a91115b06663948165534b7e3b5818ca/comments", "author": null, "committer": null, "parents": [{"sha": "cf90fd1b5b59b7db587f6addb0dd6c309d73cd0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf90fd1b5b59b7db587f6addb0dd6c309d73cd0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf90fd1b5b59b7db587f6addb0dd6c309d73cd0e"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "f44efd79bd701865aa590826ca63a77a1e58e81a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7870d1a91115b06663948165534b7e3b5818ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7870d1a91115b06663948165534b7e3b5818ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d7870d1a91115b06663948165534b7e3b5818ca", "patch": "@@ -1,3 +1,9 @@\n+2004-04-26  James E Wilson  <wilson@specifixinc.com>\n+\n+\tBug 14927\n+\t* config/ia64/ia64.md (movxf): New local op0.  Handle case where\n+\toperands[0] is a SUBREG.  Handle case where operands[1] is a GR reg.\n+\n 2004-04-26  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config/ia64/hpux.h: Predefine __STDCPP__ when compiling C++."}, {"sha": "07b6a612aae856da7f070a51a8aef0cc49e09c9a", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d7870d1a91115b06663948165534b7e3b5818ca/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d7870d1a91115b06663948165534b7e3b5818ca/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=6d7870d1a91115b06663948165534b7e3b5818ca", "patch": "@@ -677,12 +677,17 @@\n \t(match_operand:XF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n+  rtx op0 = operands[0];\n+\n+  if (GET_CODE (op0) == SUBREG)\n+    op0 = SUBREG_REG (op0);\n+\n   /* We must support XFmode loads into general registers for stdarg/vararg\n      and unprototyped calls.  We split them into DImode loads for convenience.\n      We don't need XFmode stores from general regs, because a stdarg/vararg\n      routine does a block store to memory of unnamed arguments.  */\n-  if (GET_CODE (operands[0]) == REG\n-      && GR_REGNO_P (REGNO (operands[0])))\n+\n+  if (GET_CODE (op0) == REG && GR_REGNO_P (REGNO (op0)))\n     {\n       /* We're hoping to transform everything that deals with XFmode\n \t quantities and GR registers early in the compiler.  */\n@@ -695,16 +700,23 @@\n \t  || (GET_CODE (operands[1]) == REG\n \t      && GR_REGNO_P (REGNO (operands[1]))))\n \t{\n-\t  emit_move_insn (gen_rtx_REG (TImode, REGNO (operands[0])),\n-\t\t\t  SUBREG_REG (operands[1]));\n+\t  rtx op1 = operands[1];\n+\n+\t  if (GET_CODE (op1) == SUBREG)\n+\t    op1 = SUBREG_REG (op1);\n+\t  else\n+\t    /* ??? Maybe we should make a SUBREG here?  */\n+\t    op1 = gen_rtx_REG (TImode, REGNO (op1));\n+\n+\t  emit_move_insn (gen_rtx_REG (TImode, REGNO (op0)), op1);\n \t  DONE;\n \t}\n \n       if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n-\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0])),\n+\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0)),\n \t\t\t  operand_subword (operands[1], 0, 0, XFmode));\n-\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (operands[0]) + 1),\n+\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0) + 1),\n \t\t\t  operand_subword (operands[1], 1, 0, XFmode));\n \t  DONE;\n \t}\n@@ -717,8 +729,8 @@\n \t{\n \t  rtx out[2];\n \n-\t  out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-\t  out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0])+1);\n+\t  out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0));\n+\t  out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0) + 1);\n \n \t  emit_move_insn (out[0], adjust_address (operands[1], DImode, 0));\n \t  emit_move_insn (out[1], adjust_address (operands[1], DImode, 8));"}]}