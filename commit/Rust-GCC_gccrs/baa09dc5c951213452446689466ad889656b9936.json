{"sha": "baa09dc5c951213452446689466ad889656b9936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFhMDlkYzVjOTUxMjEzNDUyNDQ2Njg5NDY2YWQ4ODk2NTZiOTkzNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-03-14T13:25:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-03-14T13:25:27Z"}, "message": "c-tree.h (enum c_declspec_il): New.\n\n2019-03-14  Richard Biener  <rguenther@suse.de>\n\n\tc/\n\t* c-tree.h (enum c_declspec_il): New.\n\t(struct c_declspecs): Merge gimple_p and rtl_p into declspec_il\n\tenum bitfield.\n\t* c-parser.c (c_parser_declaration_or_fndef): Adjust accordingly.\n\tPass start pass and declspec_il to c_parser_parse_gimple_body.\n\t(c_parser_declspecs): Adjust.\n\t* gimple-parser.c: Include cfg.h, cfghooks.h, cfganal.h, tree-cfg.h,\n\tgimple-iterator.h, cfgloop.h, tree-phinodes.h, tree-into-ssa.h\n\tand bitmap.h.\n\t(struct gimple_parser): New.\n\t(gimple_parser::push_edge): New method.\n\t(c_parser_gimple_parse_bb_spec): New helper.\n\t(c_parser_parse_gimple_body): Get start pass and IL specification.\n\tInitialize SSA and CFG.\n\t(c_parser_gimple_compound_statement): Handle CFG and SSA build.\n\tBuild a gimple_parser parsing state and pass it along.\n\t(c_parser_gimple_statement): Change intermittend __PHI internal\n\tfunction argument for the edge.\n\t(c_parser_gimple_or_rtl_pass_list): Handle ssa, cfg flags.\n\t(c_parser_gimple_goto_stmt): Record edges to build.\n\t(c_parser_gimple_if_stmt): Likewise.\n\t* gimple-parser.h (c_parser_parse_gimple_body): Adjust.\n\t(c_parser_gimple_or_rtl_pass_list): Likewise.\n\n\t* gimple-pretty-print.c: Include cfgloop.h.\n\t(dump_gimple_phi): Adjust.\n\t(dump_gimple_bb_header): Dump loop header for GIMPLE.\n\t(pp_cfg_jump): Adjust.\n\t(dump_implicit_edges): Dump fallthru to next block for GIMPLE as well.\n\t* tree-cfg.c (build_gimple_cfg): Remove lower_phi_internal_fn call.\n\t(lower_phi_internal_fn): Remove.\n\t(verify_gimple_call): Remove IFN_PHI special-casing.\n\t(dump_function_to_file): Dump IL state.\n\t* tree-into-ssa.c (rewrite_add_phi_arguments): Revert changes\n\tdone to deal with PHI nodes being present in non-SSA state.\n\n\t* gcc.dg/gimplefe-13.c: Adjust.\n\t* gcc.dg/gimplefe-14.c: Likewise.\n\t* gcc.dg/gimplefe-17.c: Likewise.\n\t* gcc.dg/gimplefe-18.c: Likewise.\n\t* gcc.dg/gimplefe-7.c: Likewise.\n\t* gcc.dg/torture/pr89595.c: Likewise.\n\t* gcc.dg/tree-ssa/cunroll-13.c: Likewise.\n\t* gcc.dg/tree-ssa/ivopt_mult_1g.c: Likewise.\n\t* gcc.dg/tree-ssa/ivopt_mult_2g.c: Likewise.\n\t* gcc.dg/tree-ssa/scev-3.c: Likewise.\n\t* gcc.dg/tree-ssa/scev-4.c: Likewise.\n\t* gcc.dg/tree-ssa/scev-5.c: Likewise.\n\t* gcc.dg/vect/vect-cond-arith-2.c: Likewise.\n\t* gcc.target/aarch64/sve/loop_add_6.c: Likewise.\n\nFrom-SVN: r269682", "tree": {"sha": "db95685f90a8eeb45ae9b08911a3d046e8db2389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db95685f90a8eeb45ae9b08911a3d046e8db2389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baa09dc5c951213452446689466ad889656b9936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa09dc5c951213452446689466ad889656b9936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baa09dc5c951213452446689466ad889656b9936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa09dc5c951213452446689466ad889656b9936/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27814aed3462d6bdce3c653e5e66d5e58cf4a5e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27814aed3462d6bdce3c653e5e66d5e58cf4a5e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27814aed3462d6bdce3c653e5e66d5e58cf4a5e7"}], "stats": {"total": 1146, "additions": 746, "deletions": 400}, "files": [{"sha": "58c8a28f6aa65f2c32e91312a8d343888decc329", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,3 +1,17 @@\n+2019-03-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-pretty-print.c: Include cfgloop.h.\n+\t(dump_gimple_phi): Adjust.\n+\t(dump_gimple_bb_header): Dump loop header for GIMPLE.\n+\t(pp_cfg_jump): Adjust.\n+\t(dump_implicit_edges): Dump fallthru to next block for GIMPLE as well.\n+\t* tree-cfg.c (build_gimple_cfg): Remove lower_phi_internal_fn call.\n+\t(lower_phi_internal_fn): Remove.\n+\t(verify_gimple_call): Remove IFN_PHI special-casing.\n+\t(dump_function_to_file): Dump IL state.\n+\t* tree-into-ssa.c (rewrite_add_phi_arguments): Revert changes\n+\tdone to deal with PHI nodes being present in non-SSA state.\n+\n 2019-03-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR ipa/89684"}, {"sha": "fafc6a5ce68fa7fda061966c727de205651c8023", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,3 +1,29 @@\n+2019-03-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* c-tree.h (enum c_declspec_il): New.\n+\t(struct c_declspecs): Merge gimple_p and rtl_p into declspec_il\n+\tenum bitfield.\n+\t* c-parser.c (c_parser_declaration_or_fndef): Adjust accordingly.\n+\tPass start pass and declspec_il to c_parser_parse_gimple_body.\n+\t(c_parser_declspecs): Adjust.\n+\t* gimple-parser.c: Include cfg.h, cfghooks.h, cfganal.h, tree-cfg.h,\n+\tgimple-iterator.h, cfgloop.h, tree-phinodes.h, tree-into-ssa.h\n+\tand bitmap.h.\n+\t(struct gimple_parser): New.\n+\t(gimple_parser::push_edge): New method.\n+\t(c_parser_gimple_parse_bb_spec): New helper.\n+\t(c_parser_parse_gimple_body): Get start pass and IL specification.\n+\tInitialize SSA and CFG.\n+\t(c_parser_gimple_compound_statement): Handle CFG and SSA build.\n+\tBuild a gimple_parser parsing state and pass it along.\n+\t(c_parser_gimple_statement): Change intermittend __PHI internal\n+\tfunction argument for the edge.\n+\t(c_parser_gimple_or_rtl_pass_list): Handle ssa, cfg flags.\n+\t(c_parser_gimple_goto_stmt): Record edges to build.\n+\t(c_parser_gimple_if_stmt): Likewise.\n+\t* gimple-parser.h (c_parser_parse_gimple_body): Adjust.\n+\t(c_parser_gimple_or_rtl_pass_list): Likewise.\n+\n 2019-03-11  Martin Liska  <mliska@suse.cz>\n \n \t* c-decl.c (check_for_loop_decls): Wrap an option name"}, {"sha": "741d172ff307f44030c0e70705c76e3a2e5cbd4d", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -2324,19 +2324,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n \n-      /* If the definition was marked with __GIMPLE then parse the\n-         function body as GIMPLE.  */\n-      if (specs->gimple_p)\n-\t{\n-\t  cfun->pass_startwith = specs->gimple_or_rtl_pass;\n-\t  bool saved = in_late_binary_op;\n-\t  in_late_binary_op = true;\n-\t  c_parser_parse_gimple_body (parser);\n-\t  in_late_binary_op = saved;\n-\t}\n-      /* Similarly, if it was marked with __RTL, use the RTL parser now,\n+      /* If the definition was marked with __RTL, use the RTL parser now,\n \t consuming the function body.  */\n-      else if (specs->rtl_p)\n+      if (specs->declspec_il == cdil_rtl)\n \t{\n \t  c_parser_parse_rtl_body (parser, specs->gimple_or_rtl_pass);\n \n@@ -2350,6 +2340,16 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  finish_function ();\n \t  return;\n \t}\n+      /* If the definition was marked with __GIMPLE then parse the\n+         function body as GIMPLE.  */\n+      else if (specs->declspec_il != cdil_none)\n+\t{\n+\t  bool saved = in_late_binary_op;\n+\t  in_late_binary_op = true;\n+\t  c_parser_parse_gimple_body (parser, specs->gimple_or_rtl_pass,\n+\t\t\t\t      specs->declspec_il);\n+\t  in_late_binary_op = saved;\n+\t}\n       else\n \tfnbody = c_parser_compound_statement (parser);\n       tree fndecl = current_function_decl;\n@@ -2372,8 +2372,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    add_stmt (fnbody);\n \t  finish_function ();\n \t}\n-      /* Get rid of the empty stmt list for GIMPLE.  */\n-      if (specs->gimple_p)\n+      /* Get rid of the empty stmt list for GIMPLE/RTL.  */\n+      if (specs->declspec_il != cdil_none)\n \tDECL_SAVED_TREE (fndecl) = NULL_TREE;\n \n       break;\n@@ -2882,15 +2882,15 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  if (! flag_gimple)\n \t    error_at (loc, \"%<__GIMPLE%> only valid with %<-fgimple%>\");\n \t  c_parser_consume_token (parser);\n-\t  specs->gimple_p = true;\n+\t  specs->declspec_il = cdil_gimple;\n \t  specs->locations[cdw_gimple] = loc;\n-\t  specs->gimple_or_rtl_pass = c_parser_gimple_or_rtl_pass_list (parser);\n+\t  c_parser_gimple_or_rtl_pass_list (parser, specs);\n \t  break;\n \tcase RID_RTL:\n \t  c_parser_consume_token (parser);\n-\t  specs->rtl_p = true;\n+\t  specs->declspec_il = cdil_rtl;\n \t  specs->locations[cdw_rtl] = loc;\n-\t  specs->gimple_or_rtl_pass = c_parser_gimple_or_rtl_pass_list (parser);\n+\t  c_parser_gimple_or_rtl_pass_list (parser, specs);\n \t  break;\n \tdefault:\n \t  goto out;"}, {"sha": "d6e345afb37b940e268b870ba7728968600f66ea", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -288,6 +288,14 @@ enum c_declspec_word {\n \t\t\t    enumerator.  */\n };\n \n+enum c_declspec_il {\n+  cdil_none,\n+  cdil_gimple,\t\t/* __GIMPLE  */\n+  cdil_gimple_cfg,\t/* __GIMPLE(cfg)  */\n+  cdil_gimple_ssa,\t/* __GIMPLE(ssa)  */\n+  cdil_rtl\t\t/* __RTL  */\n+};\n+\n /* A sequence of declaration specifiers in C.  When a new declaration\n    specifier is added, please update the enum c_declspec_word above\n    accordingly.  */\n@@ -326,6 +334,7 @@ struct c_declspecs {\n   /* The kind of type specifier if one has been seen, ctsk_none\n      otherwise.  */\n   ENUM_BITFIELD (c_typespec_kind) typespec_kind : 3;\n+  ENUM_BITFIELD (c_declspec_il) declspec_il : 3;\n   /* Whether any expressions in typeof specifiers may appear in\n      constant expressions.  */\n   BOOL_BITFIELD expr_const_operands : 1;\n@@ -381,10 +390,6 @@ struct c_declspecs {\n   /* Whether any alignment specifier (even with zero alignment) was\n      specified.  */\n   BOOL_BITFIELD alignas_p : 1;\n-  /* Whether any __GIMPLE specifier was specified.  */\n-  BOOL_BITFIELD gimple_p : 1;\n-  /* Whether any __RTL specifier was specified.  */\n-  BOOL_BITFIELD rtl_p : 1;\n   /* The address space that the declaration belongs to.  */\n   addr_space_t address_space;\n };"}, {"sha": "fff34606dae56aa876b54470efee98442d64b409", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 424, "deletions": 108, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -54,45 +54,133 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-ssa.h\"\n #include \"tree-dfa.h\"\n #include \"internal-fn.h\"\n+#include \"cfg.h\"\n+#include \"cfghooks.h\"\n+#include \"cfganal.h\"\n+#include \"tree-cfg.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-phinodes.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"bitmap.h\"\n+\n+\n+/* GIMPLE parser state.  */\n+\n+struct gimple_parser\n+{\n+  gimple_parser (c_parser *p) : parser (p), edges(), current_bb(NULL) {}\n+  /* c_parser is not visible here, use composition and fake inheritance\n+     via a conversion operator.  */\n+  operator c_parser *() { return parser; }\n+  c_parser *parser;\n+\n+  /* CFG build state.  */\n+  struct gimple_parser_edge\n+  {\n+    int src;\n+    int dest;\n+    int flags;\n+  };\n+  auto_vec<gimple_parser_edge> edges;\n+  basic_block current_bb;\n+\n+  void push_edge (int, int, int);\n+};\n+\n+void\n+gimple_parser::push_edge (int src, int dest, int flags)\n+{\n+  gimple_parser_edge e;\n+  e.src = src;\n+  e.dest = dest;\n+  e.flags = flags;\n+  edges.safe_push (e);\n+}\n \n \n /* Gimple parsing functions.  */\n-static bool c_parser_gimple_compound_statement (c_parser *, gimple_seq *);\n-static void c_parser_gimple_label (c_parser *, gimple_seq *);\n-static void c_parser_gimple_statement (c_parser *, gimple_seq *);\n-static struct c_expr c_parser_gimple_binary_expression (c_parser *);\n-static struct c_expr c_parser_gimple_unary_expression (c_parser *);\n-static struct c_expr c_parser_gimple_postfix_expression (c_parser *);\n-static struct c_expr c_parser_gimple_postfix_expression_after_primary (c_parser *,\n-\t\t\t\t\t\t\t\t       location_t,\n-\t\t\t\t\t\t\t\t       struct c_expr);\n-static void c_parser_gimple_declaration (c_parser *);\n-static void c_parser_gimple_goto_stmt (location_t, tree, gimple_seq *);\n-static void c_parser_gimple_if_stmt (c_parser *, gimple_seq *);\n-static void c_parser_gimple_switch_stmt (c_parser *, gimple_seq *);\n-static void c_parser_gimple_return_stmt (c_parser *, gimple_seq *);\n+static bool c_parser_gimple_compound_statement (gimple_parser &, gimple_seq *);\n+static void c_parser_gimple_label (gimple_parser &, gimple_seq *);\n+static void c_parser_gimple_statement (gimple_parser &, gimple_seq *);\n+static struct c_expr c_parser_gimple_binary_expression (gimple_parser &);\n+static struct c_expr c_parser_gimple_unary_expression (gimple_parser &);\n+static struct c_expr c_parser_gimple_postfix_expression (gimple_parser &);\n+static struct c_expr c_parser_gimple_postfix_expression_after_primary\n+\t\t\t(gimple_parser &, location_t, struct c_expr);\n+static void c_parser_gimple_declaration (gimple_parser &);\n+static void c_parser_gimple_goto_stmt (gimple_parser &, location_t,\n+\t\t\t\t       tree, gimple_seq *);\n+static void c_parser_gimple_if_stmt (gimple_parser &, gimple_seq *);\n+static void c_parser_gimple_switch_stmt (gimple_parser &, gimple_seq *);\n+static void c_parser_gimple_return_stmt (gimple_parser &, gimple_seq *);\n static void c_finish_gimple_return (location_t, tree);\n-static tree c_parser_gimple_paren_condition (c_parser *);\n-static void c_parser_gimple_expr_list (c_parser *, vec<tree> *);\n+static tree c_parser_gimple_paren_condition (gimple_parser &);\n+static void c_parser_gimple_expr_list (gimple_parser &, vec<tree> *);\n \n \n+/* See if VAL is an identifier matching __BB<num> and return <num>\n+   in *INDEX.  Return true if so.  */\n+\n+static bool\n+c_parser_gimple_parse_bb_spec (tree val, int *index)\n+{\n+  if (strncmp (IDENTIFIER_POINTER (val), \"__BB\", 4) != 0)\n+    return false;\n+  for (const char *p = IDENTIFIER_POINTER (val) + 4; *p; ++p)\n+    if (!ISDIGIT (*p))\n+      return false;\n+  *index = atoi (IDENTIFIER_POINTER (val) + 4);\n+  return *index > 0;\n+}\n+\n /* Parse the body of a function declaration marked with \"__GIMPLE\".  */\n \n void\n-c_parser_parse_gimple_body (c_parser *parser)\n+c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n+\t\t\t    enum c_declspec_il cdil)\n {\n+  gimple_parser parser (cparser);\n   gimple_seq seq = NULL;\n   gimple_seq body = NULL;\n   tree stmt = push_stmt_list ();\n   push_scope ();\n   location_t loc1 = c_parser_peek_token (parser)->location;\n \n+  cfun->pass_startwith = gimple_pass;\n   init_tree_ssa (cfun);\n \n-  if (! c_parser_gimple_compound_statement (parser, &seq))\n+  if (cdil == cdil_gimple)\n+    /* While we have SSA names in the IL we do not have a CFG built yet\n+       and PHIs are represented using a PHI internal function.  We do\n+       have lowered control flow and exception handling (well, we do not\n+       have parser support for EH yet).  But as we still have BINDs\n+       we have to go through lowering again.  */\n+    cfun->curr_properties = PROP_gimple_any;\n+  else\n+    {\n+      /* We have at least cdil_gimple_cfg.  */\n+      gimple_register_cfg_hooks ();\n+      init_empty_tree_cfg ();\n+      /* Initialize the bare loop structure - we are going to only\n+         mark headers and leave the rest to fixup.  */\n+      set_loops_for_fn (cfun, ggc_cleared_alloc<struct loops> ());\n+      init_loops_structure (cfun, loops_for_fn (cfun), 1);\n+      loops_state_set (cfun, LOOPS_NEED_FIXUP|LOOPS_MAY_HAVE_MULTIPLE_LATCHES);\n+      cfun->curr_properties\n+\t|= PROP_gimple_lcf | PROP_gimple_leh | PROP_cfg | PROP_loops;\n+      if (cdil == cdil_gimple_ssa)\n+\t{\n+\t  init_ssa_operands (cfun);\n+\t  cfun->curr_properties |= PROP_ssa;\n+\t}\n+    }\n+\n+  if (! c_parser_gimple_compound_statement (parser, &seq)\n+      && cdil == cdil_gimple)\n     {\n       gimple *ret = gimple_build_return (NULL);\n-      gimple_seq_add_stmt (&seq, ret);\n+      gimple_seq_add_stmt_without_update (&seq, ret);\n     }\n \n   tree block = pop_scope ();\n@@ -104,18 +192,87 @@ c_parser_parse_gimple_body (c_parser *parser)\n   BLOCK_CHAIN (block) = NULL_TREE;\n   TREE_ASM_WRITTEN (block) = 1;\n \n-  gbind *bind_stmt = gimple_build_bind (BIND_EXPR_VARS (stmt), NULL,\n-\t\t\t\t\tBIND_EXPR_BLOCK (stmt));\n-  gimple_bind_set_body (bind_stmt, seq);\n-  gimple_seq_add_stmt (&body, bind_stmt);\n-  gimple_set_body (current_function_decl, body);\n+  if (cdil == cdil_gimple)\n+    {\n+      gbind *bind_stmt = gimple_build_bind (BIND_EXPR_VARS (stmt), NULL,\n+\t\t\t\t\t    BIND_EXPR_BLOCK (stmt));\n+      gimple_bind_set_body (bind_stmt, seq);\n+      gimple_seq_add_stmt_without_update (&body, bind_stmt);\n+      gimple_set_body (current_function_decl, body);\n+    }\n+  else\n+    {\n+      /* Control-flow and binds are lowered, record local decls.  */\n+      for (tree var = BIND_EXPR_VARS (stmt); var; var = DECL_CHAIN (var))\n+\tif (VAR_P (var)\n+\t    && !DECL_EXTERNAL (var))\n+\t  add_local_decl (cfun, var);\n+      /* We have a CFG.  Build the edges.  */\n+      for (unsigned i = 0; i < parser.edges.length (); ++i)\n+\tmake_edge (BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].src),\n+\t\t   BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].dest),\n+\t\t   parser.edges[i].flags);\n+      /* Add edges for case labels.  */\n+      basic_block bb;\n+      FOR_EACH_BB_FN (bb, cfun)\n+\tif (EDGE_COUNT (bb->succs) == 0)\n+\t  {\n+\t    gimple *last = last_stmt (bb);\n+\t    if (gswitch *sw = safe_dyn_cast <gswitch *> (last))\n+\t      for (unsigned i = 0; i < gimple_switch_num_labels (sw); ++i)\n+\t\t{\n+\t\t  basic_block label_bb = gimple_switch_label_bb (cfun, sw, i);\n+\t\t  make_edge (bb, label_bb, 0);\n+\t\t}\n+\t  }\n+      /* Need those for loop fixup.  */\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      /* With SSA lower PHIs parsed as internal function calls and\n+\t update stmts.  */\n+      if (cdil == cdil_gimple_ssa)\n+\t{\n+\t  /* Create PHI nodes, they are parsed into __PHI internal calls.  */\n+\t  FOR_EACH_BB_FN (bb, cfun)\n+\t    for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t\t !gsi_end_p (gsi);)\n+\t      {\n+\t\tgimple *stmt = gsi_stmt (gsi);\n+\t\tif (!gimple_call_internal_p (stmt, IFN_PHI))\n+\t\t  break;\n \n-  /* While we have SSA names in the IL we do not have a CFG built yet\n-     and PHIs are represented using a PHI internal function.  We do\n-     have lowered control flow and exception handling (well, we do not\n-     have parser support for EH yet).  But as we still have BINDs\n-     we have to go through lowering again.  */\n-  cfun->curr_properties = PROP_gimple_any;\n+\t\tgphi *phi = create_phi_node (gimple_call_lhs (stmt), bb);\n+\t\tfor (unsigned i = 0; i < gimple_call_num_args (stmt); i += 2)\n+\t\t  {\n+\t\t    int srcidx = TREE_INT_CST_LOW (gimple_call_arg (stmt, i));\n+\t\t    edge e = find_edge (BASIC_BLOCK_FOR_FN (cfun, srcidx), bb);\n+\t\t    if (!e)\n+\t\t      c_parser_error (parser, \"edge not found\");\n+\t\t    else\n+\t\t      add_phi_arg (phi, gimple_call_arg (stmt, i + 1), e,\n+\t\t\t\t   UNKNOWN_LOCATION);\n+\t\t  }\n+\t\tgsi_remove (&gsi, false);\n+\t      }\n+\t  /* Fill SSA name gaps, putting them on the freelist.  */\n+\t  for (unsigned i = 1; i < num_ssa_names; ++i)\n+\t    if (!ssa_name (i))\n+\t      {\n+\t\ttree name = make_ssa_name_fn (cfun, integer_type_node, NULL, i);\n+\t\trelease_ssa_name_fn (cfun, name);\n+\t      }\n+\t  /* No explicit virtual operands (yet).  */\n+\t  bitmap_obstack_initialize (NULL);\n+\t  update_ssa (TODO_update_ssa_only_virtuals);\n+\t  bitmap_obstack_release (NULL);\n+\t  /* ???  By flushing the freelist after virtual operand SSA rewrite\n+\t     we keep the gaps available for re-use like needed for the\n+\t     PR89595 testcase but then usually virtual operands would have\n+\t     taken most of them.  The fix is obviously to make virtual\n+\t     operands explicit in the SSA IL.  */\n+\t  flush_ssaname_freelist ();\n+\t}\n+      fix_loop_structure (NULL);\n+    }\n \n   dump_function (TDI_gimple, current_function_decl);\n }\n@@ -135,7 +292,7 @@ c_parser_parse_gimple_body (c_parser *parser)\n */\n \n static bool\n-c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n {\n   bool return_p = false;\n \n@@ -180,7 +337,7 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n \t\tc_parser_consume_token (parser);\n \t\tif (c_parser_next_token_is (parser, CPP_NAME))\n \t\t  {\n-\t\t    c_parser_gimple_goto_stmt (loc,\n+\t\t    c_parser_gimple_goto_stmt (parser, loc,\n \t\t\t\t\t       c_parser_peek_token\n \t\t\t\t\t       (parser)->value,\n \t\t\t\t\t       seq);\n@@ -197,6 +354,8 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n \t      if (! c_parser_require (parser, CPP_SEMICOLON,\n \t\t\t\t      \"expected %<;%>\"))\n \t\treturn return_p;\n+\t      if (cfun->curr_properties & PROP_cfg)\n+\t\tparser.push_edge (parser.current_bb->index, EXIT_BLOCK, 0);\n \t      break;\n \t    default:\n \t      goto expr_stmt;\n@@ -208,6 +367,142 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n \t      c_parser_gimple_label (parser, seq);\n \t      break;\n \t    }\n+\t  /* Basic block specification.\n+\t     __BB (index, ...)  */\n+\t  if ((cfun->curr_properties & PROP_cfg)\n+\t      && !strcmp (IDENTIFIER_POINTER\n+\t\t\t    (c_parser_peek_token (parser)->value), \"__BB\"))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      if (! c_parser_require (parser, CPP_OPEN_PAREN,\n+\t\t\t\t      \"expected %<(%>\"))\n+\t\treturn return_p;\n+\t      if (c_parser_next_token_is_not (parser, CPP_NUMBER))\n+\t\t{\n+\t\t  c_parser_error (parser, \"expected block index\");\n+\t\t  return return_p;\n+\t\t}\n+\t      tree tnum = c_parser_peek_token (parser)->value;\n+\t      if (TREE_CODE (tnum) != INTEGER_CST)\n+\t\t{\n+\t\t  c_parser_error (parser, \"expected block index\");\n+\t\t  return return_p;\n+\t\t}\n+\t      int index = TREE_INT_CST_LOW (tnum);\n+\t      if (index < NUM_FIXED_BLOCKS\n+\t\t  || (index < last_basic_block_for_fn (cfun)\n+\t\t      && BASIC_BLOCK_FOR_FN (cfun, index) != NULL))\n+\t\t{\n+\t\t  c_parser_error (parser, \"invalid block index\");\n+\t\t  return return_p;\n+\t\t}\n+\t      int is_loop_header_of = -1;\n+\t      c_parser_consume_token (parser);\n+\t      while (c_parser_next_token_is (parser, CPP_COMMA))\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (! c_parser_next_token_is (parser, CPP_NAME))\n+\t\t    {\n+\t\t      c_parser_error (parser, \"expected block specifier\");\n+\t\t      return return_p;\n+\t\t    }\n+\t\t  /* loop_header (NUM)  */\n+\t\t  if (!strcmp (IDENTIFIER_POINTER\n+\t\t\t         (c_parser_peek_token (parser)->value),\n+\t\t\t       \"loop_header\"))\n+\t\t    {\n+\t\t      c_parser_consume_token (parser);\n+\t\t      if (! c_parser_require (parser, CPP_OPEN_PAREN,\n+\t\t\t\t\t      \"expected %<(%>\"))\n+\t\t\treturn return_p;\n+\t\t      tree loop_num;\n+\t\t      if (! c_parser_next_token_is (parser, CPP_NUMBER)\n+\t\t\t  || TREE_CODE (loop_num\n+\t\t\t\t\t  = c_parser_peek_token (parser)->value)\n+\t\t\t       != INTEGER_CST)\n+\t\t\t{\n+\t\t\t  c_parser_error (parser, \"expected loop number\");\n+\t\t\t  return return_p;\n+\t\t\t}\n+\t\t      c_parser_consume_token (parser);\n+\t\t      is_loop_header_of = TREE_INT_CST_LOW (loop_num);\n+\t\t      if (! c_parser_require (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t\t      \"expected %<)%>\"))\n+\t\t\treturn return_p;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      c_parser_error (parser, \"unknown block specifier\");\n+\t\t      return return_p;\n+\t\t    }\n+\t\t}\n+\t      if (! c_parser_require (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t      \"expected %<)%>\")\n+\t\t  || ! c_parser_require (parser, CPP_COLON,\n+\t\t\t\t\t \"expected %<:%>\"))\n+\t\treturn return_p;\n+\n+\t      /* Put stmts parsed in the current block.  */\n+\t      if (!gimple_seq_empty_p (*seq))\n+\t\t{\n+\t\t  if (!parser.current_bb)\n+\t\t    c_parser_error (parser, \"stmts without block\");\n+\t\t  else\n+\t\t    {\n+\t\t      gimple_stmt_iterator gsi\n+\t\t\t= gsi_start_bb (parser.current_bb);\n+\t\t      gsi_insert_seq_after (&gsi, *seq, GSI_CONTINUE_LINKING);\n+\t\t    }\n+\t\t  *seq = NULL;\n+\t\t}\n+\n+\t      /* Build an empty block with specified index, linking them\n+\t\t in source order.  */\n+\t      basic_block bb = alloc_block ();\n+\t      bb->index = index;\n+\t      link_block (bb, (parser.current_bb ? parser.current_bb\n+\t\t\t       : ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+\t      if (basic_block_info_for_fn (cfun)->length () <= (size_t)index)\n+\t\tvec_safe_grow_cleared (basic_block_info_for_fn (cfun),\n+\t\t\t\t       index + 1);\n+\t      SET_BASIC_BLOCK_FOR_FN (cfun, index, bb);\n+\t      if (last_basic_block_for_fn (cfun) <= index)\n+\t\tlast_basic_block_for_fn (cfun) = index + 1;\n+\t      n_basic_blocks_for_fn (cfun)++;\n+\t      if (!parser.current_bb)\n+\t\tparser.push_edge (ENTRY_BLOCK, bb->index, EDGE_FALLTHRU);\n+\n+\t      /* We leave the proper setting to fixup.  */\n+\t      struct loop *loop_father = loops_for_fn (cfun)->tree_root;\n+\t      /* If the new block is a loop header, allocate a loop\n+\t\t struct.  Fixup will take care of proper placement within\n+\t\t the loop tree.  */\n+\t      if (is_loop_header_of != -1)\n+\t\t{\n+\t\t  if (number_of_loops (cfun) > (unsigned)is_loop_header_of\n+\t\t      && get_loop (cfun, is_loop_header_of) != NULL)\n+\t\t    {\n+\t\t      c_parser_error (parser, \"duplicate loop header\");\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      struct loop *loop = alloc_loop ();\n+\t\t      loop->num = is_loop_header_of;\n+\t\t      loop->header = bb;\n+\t\t      vec_safe_grow_cleared (loops_for_fn (cfun)->larray,\n+\t\t\t\t\t     is_loop_header_of + 1);\n+\t\t      (*loops_for_fn (cfun)->larray)[is_loop_header_of] = loop;\n+\t\t      flow_loop_tree_node_add (loops_for_fn (cfun)->tree_root,\n+\t\t\t\t\t       loop);\n+\t\t    }\n+\t\t  loop_father = get_loop (cfun, is_loop_header_of);\n+\t\t}\n+\t      bb->loop_father = loop_father;\n+\n+\t      /* Stmts now go to the new block.  */\n+\t      parser.current_bb = bb;\n+\t      break;\n+\t    }\n \t  goto expr_stmt;\n \n \tcase CPP_SEMICOLON:\n@@ -217,7 +512,7 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n \t    c_parser_consume_token (parser);\n \t    gimple *nop = gimple_build_nop ();\n \t    gimple_set_location (nop, loc);\n-\t    gimple_seq_add_stmt (seq, nop);\n+\t    gimple_seq_add_stmt_without_update (seq, nop);\n \t    break;\n \t  }\n \n@@ -229,6 +524,21 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n \t}\n     }\n   c_parser_consume_token (parser);\n+\n+  /* Put stmts parsed in the current block.  */\n+  if ((cfun->curr_properties & PROP_cfg)\n+      && !gimple_seq_empty_p (*seq))\n+    {\n+      if (!parser.current_bb)\n+\tc_parser_error (parser, \"stmts without block\");\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_start_bb (parser.current_bb);\n+\t  gsi_insert_seq_after (&gsi, *seq, GSI_CONTINUE_LINKING);\n+\t}\n+      *seq = NULL;\n+    }\n+\n   return return_p;\n }\n \n@@ -260,7 +570,7 @@ c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n */\n \n static void\n-c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_statement (gimple_parser &parser, gimple_seq *seq)\n {\n   struct c_expr lhs, rhs;\n   gimple *assign = NULL;\n@@ -278,7 +588,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n     {\n       gimple *call;\n       call = gimple_build_call_from_tree (lhs.value, NULL);\n-      gimple_seq_add_stmt (seq, call);\n+      gimple_seq_add_stmt_without_update (seq, call);\n       gimple_set_location (call, loc);\n       return;\n     }\n@@ -316,7 +626,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n \t\t   && FLOAT_TYPE_P (TREE_TYPE (rhs.value)))\n \t    code = FIX_TRUNC_EXPR;\n \t  assign = gimple_build_assign (lhs.value, code, rhs.value);\n-\t  gimple_seq_add_stmt (seq, assign);\n+\t  gimple_seq_add_stmt_without_update (seq, assign);\n \t  gimple_set_location (assign, loc);\n \t  return;\n \t}\n@@ -350,7 +660,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n \t{\n \t  assign = gimple_build_assign (lhs.value, rhs.value);\n \t  gimple_set_location (assign, loc);\n-\t  gimple_seq_add_stmt (seq, assign);\n+\t  gimple_seq_add_stmt_without_update (seq, assign);\n \t}\n       return;\n \n@@ -373,13 +683,14 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n \t  if (c_parser_next_token_is (parser, CPP_NAME)\n \t      && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n \t    {\n-\t      arg = lookup_label_for_goto (loc,\n-\t\t\t\t\t   c_parser_peek_token (parser)->value);\n+\t      arg = c_parser_peek_token (parser)->value;\n \t      c_parser_consume_token (parser);\n-\n \t      if (c_parser_next_token_is (parser, CPP_COLON))\n \t\tc_parser_consume_token (parser);\n-\t      vargs.safe_push (arg);\n+\t      int src_index = -1;\n+\t      if (!c_parser_gimple_parse_bb_spec (arg, &src_index))\n+\t\tc_parser_error (parser, \"invalid source block specification\");\n+\t      vargs.safe_push (size_int (src_index));\n \t    }\n \t  else if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    c_parser_consume_token (parser);\n@@ -397,7 +708,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n       gcall *call_stmt = gimple_build_call_internal_vec (IFN_PHI, vargs);\n       gimple_call_set_lhs (call_stmt, lhs.value);\n       gimple_set_location (call_stmt, UNKNOWN_LOCATION);\n-      gimple_seq_add_stmt (seq, call_stmt);\n+      gimple_seq_add_stmt_without_update (seq, call_stmt);\n       return;\n     }\n \n@@ -412,7 +723,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n \t{\n \t  gimple *call = gimple_build_call_from_tree (rhs.value, NULL);\n \t  gimple_call_set_lhs (call, lhs.value);\n-\t  gimple_seq_add_stmt (seq, call);\n+\t  gimple_seq_add_stmt_without_update (seq, call);\n \t  gimple_set_location (call, loc);\n \t}\n       return;\n@@ -440,7 +751,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n \t\t\t\t  rhs.value, trueval.value, falseval.value);\n \t}\n       assign = gimple_build_assign (lhs.value, rhs.value);\n-      gimple_seq_add_stmt (seq, assign);\n+      gimple_seq_add_stmt_without_update (seq, assign);\n       gimple_set_location (assign, loc);\n     }\n   return;\n@@ -470,7 +781,7 @@ c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n */\n \n static c_expr\n-c_parser_gimple_binary_expression (c_parser *parser)\n+c_parser_gimple_binary_expression (gimple_parser &parser)\n {\n   /* Location of the binary operator.  */\n   struct c_expr ret, lhs, rhs;\n@@ -578,7 +889,7 @@ c_parser_gimple_binary_expression (c_parser *parser)\n */\n \n static c_expr\n-c_parser_gimple_unary_expression (c_parser *parser)\n+c_parser_gimple_unary_expression (gimple_parser &parser)\n {\n   struct c_expr ret, op;\n   location_t op_loc = c_parser_peek_token (parser)->location;\n@@ -687,7 +998,7 @@ c_parser_parse_ssa_name_id (tree id, unsigned *version, unsigned *ver_offset)\n    TYPE is the type if the SSA name is being declared.  */\n \n static tree \n-c_parser_parse_ssa_name (c_parser *parser,\n+c_parser_parse_ssa_name (gimple_parser &parser,\n \t\t\t tree id, tree type, unsigned version,\n \t\t\t unsigned ver_offset)\n {\n@@ -752,7 +1063,7 @@ c_parser_parse_ssa_name (c_parser *parser,\n      . identifier ( gimple-argument-expression-list[opt] )  */\n \n static struct c_expr\n-c_parser_gimple_call_internal (c_parser *parser)\n+c_parser_gimple_call_internal (gimple_parser &parser)\n {\n   struct c_expr expr;\n   expr.set_error ();\n@@ -812,7 +1123,7 @@ c_parser_gimple_call_internal (c_parser *parser)\n */\n \n static struct c_expr\n-c_parser_gimple_postfix_expression (c_parser *parser)\n+c_parser_gimple_postfix_expression (gimple_parser &parser)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   source_range tok_range = c_parser_peek_token (parser)->get_range ();\n@@ -1102,7 +1413,7 @@ c_parser_gimple_postfix_expression (c_parser *parser)\n    literal.  */\n \n static struct c_expr\n-c_parser_gimple_postfix_expression_after_primary (c_parser *parser,\n+c_parser_gimple_postfix_expression_after_primary (gimple_parser &parser,\n \t\t\t\t\t\t  location_t expr_loc,\n \t\t\t\t\t\t  struct c_expr expr)\n {\n@@ -1245,7 +1556,7 @@ c_parser_gimple_postfix_expression_after_primary (c_parser *parser,\n  */\n \n static void\n-c_parser_gimple_expr_list (c_parser *parser, vec<tree> *ret)\n+c_parser_gimple_expr_list (gimple_parser &parser, vec<tree> *ret)\n {\n   struct c_expr expr;\n \n@@ -1269,7 +1580,7 @@ c_parser_gimple_expr_list (c_parser *parser, vec<tree> *ret)\n */\n \n static void\n-c_parser_gimple_label (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_label (gimple_parser &parser, gimple_seq *seq)\n {\n   tree name = c_parser_peek_token (parser)->value;\n   location_t loc1 = c_parser_peek_token (parser)->location;\n@@ -1278,58 +1589,67 @@ c_parser_gimple_label (c_parser *parser, gimple_seq *seq)\n   gcc_assert (c_parser_next_token_is (parser, CPP_COLON));\n   c_parser_consume_token (parser);\n   tree label = define_label (loc1, name);\n-  gimple_seq_add_stmt (seq, gimple_build_label (label));\n+  gimple_seq_add_stmt_without_update (seq, gimple_build_label (label));\n   return;\n }\n \n /* Parse gimple/RTL pass list.\n \n    gimple-or-rtl-pass-list:\n-     startwith(\"pass-name\")\n+     startwith(\"pass-name\")[,{cfg,ssa}]\n  */\n \n-char *\n-c_parser_gimple_or_rtl_pass_list (c_parser *parser)\n+void\n+c_parser_gimple_or_rtl_pass_list (c_parser *parser, c_declspecs *specs)\n {\n   char *pass = NULL;\n \n   /* Accept __GIMPLE/__RTL.  */\n   if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n-    return NULL;\n+    return;\n   c_parser_consume_token (parser);\n \n-  if (c_parser_next_token_is (parser, CPP_NAME))\n+  while (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *op = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       c_parser_consume_token (parser);\n       if (! strcmp (op, \"startwith\"))\n \t{\n \t  if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    return NULL;\n+\t    return;\n \t  if (c_parser_next_token_is_not (parser, CPP_STRING))\n \t    {\n \t      error_at (c_parser_peek_token (parser)->location,\n \t\t\t\"expected pass name\");\n-\t      return NULL;\n+\t      return;\n \t    }\n \t  pass = xstrdup (TREE_STRING_POINTER\n \t\t\t\t(c_parser_peek_token (parser)->value));\n \t  c_parser_consume_token (parser);\n-\t  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n-\t    return NULL;\n+\t  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<(%>\"))\n+\t    return;\n \t}\n+      else if (specs->declspec_il != cdil_gimple)\n+\t/* Allow only one IL specifier and none on RTL.  */\n+\t;\n+      else if (! strcmp (op, \"cfg\"))\n+\tspecs->declspec_il = cdil_gimple_cfg;\n+      else if (! strcmp (op, \"ssa\"))\n+\tspecs->declspec_il = cdil_gimple_ssa;\n       else\n \t{\n \t  error_at (c_parser_peek_token (parser)->location,\n \t\t    \"invalid operation\");\n-\t  return NULL;\n+\t  return;\n \t}\n+     if (c_parser_next_token_is (parser, CPP_COMMA))\n+       c_parser_consume_token (parser);\n     }\n \n   if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n-    return NULL;\n+    return;\n \n-  return pass;\n+  specs->gimple_or_rtl_pass = pass;\n }\n \n /* Parse gimple local declaration.\n@@ -1371,7 +1691,7 @@ c_parser_gimple_or_rtl_pass_list (c_parser *parser)\n  */\n \n static void\n-c_parser_gimple_declaration (c_parser *parser)\n+c_parser_gimple_declaration (gimple_parser &parser)\n {\n   struct c_declarator *declarator;\n   struct c_declspecs *specs = build_null_declspecs ();\n@@ -1431,19 +1751,29 @@ c_parser_gimple_declaration (c_parser *parser)\n /* Parse gimple goto statement.  */\n \n static void\n-c_parser_gimple_goto_stmt (location_t loc, tree label, gimple_seq *seq)\n+c_parser_gimple_goto_stmt (gimple_parser &parser,\n+\t\t\t   location_t loc, tree label, gimple_seq *seq)\n {\n+  if (cfun->curr_properties & PROP_cfg)\n+    {\n+      int dest_index;\n+      if (c_parser_gimple_parse_bb_spec (label, &dest_index))\n+\t{\n+\t  parser.push_edge (parser.current_bb->index, dest_index,\n+\t\t\t    EDGE_FALLTHRU);\n+\t  return;\n+\t}\n+    }\n   tree decl = lookup_label_for_goto (loc, label);\n-  gimple_seq_add_stmt (seq, gimple_build_goto (decl));\n-  return;\n+  gimple_seq_add_stmt_without_update (seq, gimple_build_goto (decl));\n }\n \n /* Parse a parenthesized condition.\n    gimple-condition:\n      ( gimple-binary-expression )    */\n \n static tree\n-c_parser_gimple_paren_condition (c_parser *parser)\n+c_parser_gimple_paren_condition (gimple_parser &parser)\n {\n   if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return error_mark_node;\n@@ -1462,9 +1792,9 @@ c_parser_gimple_paren_condition (c_parser *parser)\n  */\n \n static void\n-c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_if_stmt (gimple_parser &parser, gimple_seq *seq)\n {\n-  tree t_label, f_label, label;\n+  tree t_label = NULL_TREE, f_label = NULL_TREE, label;\n   location_t loc;\n   c_parser_consume_token (parser);\n   tree cond = c_parser_gimple_paren_condition (parser);\n@@ -1480,7 +1810,13 @@ c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n \t}\n       label = c_parser_peek_token (parser)->value;\n       c_parser_consume_token (parser);\n-      t_label = lookup_label_for_goto (loc, label);\n+      int dest_index;\n+      if ((cfun->curr_properties & PROP_cfg)\n+\t  && c_parser_gimple_parse_bb_spec (label, &dest_index))\n+\tparser.push_edge (parser.current_bb->index, dest_index,\n+\t\t\t  EDGE_TRUE_VALUE);\n+      else\n+\tt_label = lookup_label_for_goto (loc, label);\n       if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n \treturn;\n     }\n@@ -1508,7 +1844,13 @@ c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n \t  return;\n \t}\n       label = c_parser_peek_token (parser)->value;\n-      f_label = lookup_label_for_goto (loc, label);\n+      int dest_index;\n+      if ((cfun->curr_properties & PROP_cfg)\n+\t  && c_parser_gimple_parse_bb_spec (label, &dest_index))\n+\tparser.push_edge (parser.current_bb->index, dest_index,\n+\t\t\t  EDGE_FALSE_VALUE);\n+      else\n+\tf_label = lookup_label_for_goto (loc, label);\n       c_parser_consume_token (parser);\n       if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n \treturn;\n@@ -1520,7 +1862,7 @@ c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n     }\n \n   if (cond != error_mark_node)\n-    gimple_seq_add_stmt (seq, gimple_build_cond_from_tree (cond, t_label,\n+    gimple_seq_add_stmt_without_update (seq, gimple_build_cond_from_tree (cond, t_label,\n \t\t\t\t\t\t\t   f_label));\n }\n \n@@ -1535,13 +1877,12 @@ c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n */\n \n static void\n-c_parser_gimple_switch_stmt (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_switch_stmt (gimple_parser &parser, gimple_seq *seq)\n {\n   c_expr cond_expr;\n   tree case_label, label;\n   auto_vec<tree> labels;\n   tree default_label = NULL_TREE;\n-  gimple_seq switch_body = NULL;\n   c_parser_consume_token (parser);\n \n   if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -1629,32 +1970,8 @@ c_parser_gimple_switch_stmt (c_parser *parser, gimple_seq *seq)\n \t      return;\n \t    break;\n \t  }\n-\tcase RID_GOTO:\n-\t  {\n-\t    location_t loc = c_parser_peek_token (parser)->location;\n-\t    c_parser_consume_token (parser);\n-\t    if (c_parser_next_token_is (parser, CPP_NAME))\n-\t      {\n-\t\tc_parser_gimple_goto_stmt (loc,\n-\t\t\t\t\t   c_parser_peek_token\n-\t\t\t\t\t   (parser)->value,\n-\t\t\t\t\t   &switch_body);\n-\t\tc_parser_consume_token (parser);\n-\t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n-\t\t  c_parser_consume_token (parser);\n-\t\telse\n-\t\t  {\n-\t\t    c_parser_error (parser, \"expected semicolon\");\n-\t\t    return;\n-\t\t  }\n-\t      }\n-\t    else if (! c_parser_require (parser, CPP_NAME,\n-\t\t\t\t\t \"expected label\"))\n-\t      return;\n-\t    break;\n-\t  }\n \tdefault:\n-\t  c_parser_error (parser, \"expected case label or goto statement\");\n+\t  c_parser_error (parser, \"expected case label\");\n \t  return;\n \t}\n \n@@ -1664,16 +1981,15 @@ c_parser_gimple_switch_stmt (c_parser *parser, gimple_seq *seq)\n \n   if (cond_expr.value != error_mark_node)\n     {\n-      gimple_seq_add_stmt (seq, gimple_build_switch (cond_expr.value,\n-\t\t\t\t\t\t     default_label, labels));\n-      gimple_seq_add_seq (seq, switch_body);\n+      gswitch *s = gimple_build_switch (cond_expr.value, default_label, labels);\n+      gimple_seq_add_stmt_without_update (seq, s);\n     }\n }\n \n /* Parse gimple return statement.  */\n \n static void\n-c_parser_gimple_return_stmt (c_parser *parser, gimple_seq *seq)\n+c_parser_gimple_return_stmt (gimple_parser &parser, gimple_seq *seq)\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n   gimple *ret = NULL;\n@@ -1682,7 +1998,7 @@ c_parser_gimple_return_stmt (c_parser *parser, gimple_seq *seq)\n     {\n       c_finish_gimple_return (loc, NULL_TREE);\n       ret = gimple_build_return (NULL);\n-      gimple_seq_add_stmt (seq, ret);\n+      gimple_seq_add_stmt_without_update (seq, ret);\n     }\n   else\n     {\n@@ -1692,7 +2008,7 @@ c_parser_gimple_return_stmt (c_parser *parser, gimple_seq *seq)\n \t{\n \t  c_finish_gimple_return (xloc, expr.value);\n \t  ret = gimple_build_return (expr.value);\n-\t  gimple_seq_add_stmt (seq, ret);\n+\t  gimple_seq_add_stmt_without_update (seq, ret);\n \t}\n     }\n }"}, {"sha": "383ad76875908269fc377124ac4fc0eea087e8f0", "filename": "gcc/c/gimple-parser.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fgimple-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fc%2Fgimple-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.h?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -21,7 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_GIMPLE_PARSER_H\n \n /* Gimple parsing functions.  */\n-extern void c_parser_parse_gimple_body (c_parser *);\n-extern char *c_parser_gimple_or_rtl_pass_list (c_parser *);\n+extern void c_parser_parse_gimple_body (c_parser *, char *,\n+\t\t\t\t\tenum c_declspec_il);\n+extern void c_parser_gimple_or_rtl_pass_list (c_parser *, c_declspecs *);\n \n #endif"}, {"sha": "69bae0d10d02befb46a072824b7081fffd2751c2", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"cfgloop.h\"\n \n #define INDENT(SPACE)\t\t\t\t\t\t\t\\\n   do { int i; for (i = 0; i < SPACE; i++) pp_space (buffer); } while (0)\n@@ -2221,26 +2222,19 @@ dump_gimple_phi (pretty_printer *buffer, gphi *phi, int spc, bool comment,\n     {\n       if ((flags & TDF_LINENO) && gimple_phi_arg_has_location (phi, i))\n \tdump_location (buffer, gimple_phi_arg_location (phi, i));\n+      basic_block src = gimple_phi_arg_edge (phi, i)->src;\n       if (flags & TDF_GIMPLE)\n \t{\n-\t  basic_block src = gimple_phi_arg_edge (phi, i)->src;\n-\t  gimple *stmt = first_stmt (src);\n-\t  if (!stmt || gimple_code (stmt) != GIMPLE_LABEL)\n-\t    {\n-\t      pp_string (buffer, \"bb_\");\n-\t      pp_decimal_int (buffer, src->index);\n-\t    }\n-\t  else\n-\t    dump_generic_node (buffer, gimple_label_label (as_a <glabel *> (stmt)), 0, flags,\n-\t\t\t       false);\n+\t  pp_string (buffer, \"__BB\");\n+\t  pp_decimal_int (buffer, src->index);\n \t  pp_string (buffer, \": \");\n \t}\n       dump_generic_node (buffer, gimple_phi_arg_def (phi, i), spc, flags,\n \t\t\t false);\n       if (! (flags & TDF_GIMPLE))\n \t{\n \t  pp_left_paren (buffer);\n-\t  pp_decimal_int (buffer, gimple_phi_arg_edge (phi, i)->src->index);\n+\t  pp_decimal_int (buffer, src->index);\n \t  pp_right_paren (buffer);\n \t}\n       if (i < gimple_phi_num_args (phi) - 1)\n@@ -2706,7 +2700,12 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,\n   else\n     {\n       if (flags & TDF_GIMPLE)\n-\tfprintf (outf, \"%*sbb_%d:\\n\", indent, \"\", bb->index);\n+\t{\n+\t  fprintf (outf, \"%*s__BB(%d\", indent, \"\", bb->index);\n+\t  if (bb->loop_father->header == bb)\n+\t    fprintf (outf, \",loop_header(%d)\", bb->loop_father->num);\n+\t  fprintf (outf, \"):\\n\");\n+\t}\n       else\n \tfprintf (outf, \"%*s<bb %d> %s:\\n\",\n \t\t indent, \"\", bb->index, dump_profile (bb->count));\n@@ -2759,7 +2758,7 @@ pp_cfg_jump (pretty_printer *buffer, edge e, dump_flags_t flags)\n {\n   if (flags & TDF_GIMPLE)\n     {\n-      pp_string (buffer, \"goto bb_\");\n+      pp_string (buffer, \"goto __BB\");\n       pp_decimal_int (buffer, e->dest->index);\n       pp_semicolon (buffer);\n     }\n@@ -2812,7 +2811,7 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n      goto to the dump.  */\n   e = find_fallthru_edge (bb->succs);\n \n-  if (e && e->dest != bb->next_bb)\n+  if (e && (e->dest != bb->next_bb || (flags & TDF_GIMPLE)))\n     {\n       INDENT (indent);\n "}, {"sha": "34f41e5265f17c6d9c4a6257a25fd9d3b85f385f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,3 +1,20 @@\n+2019-03-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/gimplefe-13.c: Adjust.\n+\t* gcc.dg/gimplefe-14.c: Likewise.\n+\t* gcc.dg/gimplefe-17.c: Likewise.\n+\t* gcc.dg/gimplefe-18.c: Likewise.\n+\t* gcc.dg/gimplefe-7.c: Likewise.\n+\t* gcc.dg/torture/pr89595.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-13.c: Likewise.\n+\t* gcc.dg/tree-ssa/ivopt_mult_1g.c: Likewise.\n+\t* gcc.dg/tree-ssa/ivopt_mult_2g.c: Likewise.\n+\t* gcc.dg/tree-ssa/scev-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/scev-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/scev-5.c: Likewise.\n+\t* gcc.dg/vect/vect-cond-arith-2.c: Likewise.\n+\t* gcc.target/aarch64/sve/loop_add_6.c: Likewise.\n+\n 2019-03-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR ipa/89684"}, {"sha": "dc326861c0fb7d15aa96f5edae6ec3294bc34ef1", "filename": "gcc/testsuite/gcc.dg/gimplefe-13.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,25 +1,26 @@\n /* { dg-do compile } */\n /* { dg-options \"-O -fgimple\" } */\n \n-void __GIMPLE (startwith (\"dse2\")) foo ()\n+void __GIMPLE (ssa,startwith (\"dse2\")) foo ()\n {\n   int a;\n \n-bb_2:\n-  if (a > 4)\n-    goto bb_3;\n+__BB(2):\n+  if (a_5(D) > 4)\n+    goto __BB3;\n   else\n-    goto bb_4;\n+    goto __BB4;\n \n-bb_3:\n+__BB(3):\n   a_2 = 10;\n-  goto bb_5;\n+  goto __BB5;\n \n-bb_4:\n+__BB(4):\n   a_3 = 20;\n+  goto __BB5;\n \n-bb_5:\n-  a_1 = __PHI (bb_3: a_2, bb_4: a_3);\n+__BB(5):\n+  a_1 = __PHI (__BB3: a_2, __BB4: a_3);\n   a_4 = a_1 + 4;\n \n return;"}, {"sha": "a9e9d8141f0e75a8efbea99803930dd069587017", "filename": "gcc/testsuite/gcc.dg/gimplefe-14.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,29 +1,33 @@\n /* { dg-do run } */\n /* { dg-options \"-O -fgimple\" } */\n \n-int __GIMPLE ()\n+int __GIMPLE (ssa)\n main (int argc, char * * argv)\n {\n   int a;\n \n-  bb_2:\n+  __BB(2):\n   /* Because of PR82114 we need to handle also 0 as base metal can have\n      argc == 0.  */\n   switch (argc_2(D)) {default: L2; case 0: L0; case 1: L0; case 2: L1; }\n \n+  __BB(3):\n L0:\n   a_4 = 0;\n-  goto bb_6;\n+  goto __BB6;\n \n+  __BB(4):\n L1:\n   a_3 = 3;\n-  goto bb_6;\n+  goto __BB6;\n \n+  __BB(5):\n L2:\n   a_5 = -1;\n+  goto __BB6;\n \n-  bb_6:\n-  a_1 = __PHI (L0: a_4, L1: a_3, L2: a_5);\n+  __BB(6):\n+  a_1 = __PHI (__BB3: a_4, __BB4: a_3, __BB5: a_5);\n   return a_1;\n \n }"}, {"sha": "eceefd153efbd9ce64f31f306363b0df689f9af1", "filename": "gcc/testsuite/gcc.dg/gimplefe-17.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,26 +1,31 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fgimple -fdump-tree-ssa\" } */\n+/* { dg-options \"-fgimple -fdump-tree-fixup_cfg2\" } */\n \n int \n-__GIMPLE () *\n+__GIMPLE (ssa) *\n foo ()\n {\n   int _1;\n   int j;\n   int *b;\n+\n+__BB(5):\n   _1 = 1;\n-bb1:\n+  goto __BB2;\n+\n+__BB(2):\n   if (_1)\n-    goto bb3;\n+    goto __BB4;\n   else\n-    goto bb2;\n+    goto __BB3;\n \n-bb2:\n+__BB(3):\n   b_2 = (int *)0;\n+  goto __BB4;\n \n-bb3:\n-  b_4 = __PHI (bb1: b_3(D), bb2: b_2);\n+__BB(4):\n+  b_4 = __PHI (__BB2: b_3(D), __BB3: b_2);\n   return b_4;\n }\n \n-/* { dg-final { scan-tree-dump-not \"_1_\" \"ssa\" } } */\n+/* { dg-final { scan-tree-dump-not \"_1_\" \"fixup_cfg2\" } } */"}, {"sha": "18fabbe1e6660f60e9b7b3d90e26cd961259cd9b", "filename": "gcc/testsuite/gcc.dg/gimplefe-18.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -2,23 +2,28 @@\n /* { dg-options \"-fgimple\" } */\n \n int\n-__GIMPLE () *\n+__GIMPLE (ssa) *\n foo ()\n {\n   int _1;\n   int j;\n   int *b;\n+\n+__BB(2):\n   _1 = 1;\n-bb1:\n+  goto __BB3;\n+\n+__BB(3):\n   if (_1)\n-    goto bb3;\n+    goto __BB5;\n   else\n-    goto bb2;\n+    goto __BB4;\n \n-bb2:\n+__BB(4):\n   b_2 = (int *)0;\n+  goto __BB5;\n \n-bb3:\n-  b_4 = __PHI (bb1: &j, bb2: b_2);\n+__BB(5):\n+  b_4 = __PHI (__BB3: &j, __BB4: b_2);\n   return b_4;\n }"}, {"sha": "ad34e85b502f9c0e91aed24c13a4efa31c823dbe", "filename": "gcc/testsuite/gcc.dg/gimplefe-7.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,25 +1,26 @@\n /* { dg-do compile } */\n /* { dg-options \"-fgimple\" } */\n \n-void __GIMPLE () foo ()\n+void __GIMPLE (ssa) foo ()\n {\n   int a;\n \n-bb_2:\n-  if (a > 4)\n-    goto bb_3;\n+__BB(2):\n+  if (a_5(D) > 4)\n+    goto __BB3;\n   else\n-    goto bb_4;\n+    goto __BB4;\n \n-bb_3:\n+__BB(3):\n   a_2 = 10;\n-  goto bb_5;\n+  goto __BB5;\n \n-bb_4:\n+__BB(4):\n   a_3 = 20;\n+  goto __BB5;\n \n-bb_5:\n-  a_1 = __PHI (bb_3: a_2, bb_4: a_3);\n+__BB(5):\n+  a_1 = __PHI (__BB3: a_2, __BB4: a_3);\n   a_4 = a_1 + 4;\n \n return;"}, {"sha": "f45dc98c3f07dc59a19aa4a3863f282454a38a90", "filename": "gcc/testsuite/gcc.dg/torture/pr89595.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr89595.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr89595.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr89595.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -2,33 +2,35 @@\n /* { dg-additional-options \"-fgimple\" } */\n \n int __attribute__((noipa))\n-__GIMPLE(startwith(\"dom\")) bar(int cond, int val)\n+__GIMPLE(ssa,startwith(\"dom\")) bar(int cond, int val)\n {\n   int i;\n \n+__BB(3):\n   if (0 != 0)\n-    goto bb_6;\n+    goto __BB6;\n   else\n-    goto bb_2;\n+    goto __BB2;\n \n-bb_2:\n+__BB(2):\n   if (cond_5(D) != 0)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_5;\n+    goto __BB5;\n \n-bb_4:\n+__BB(4):\n   i_6 = val_2(D);\n   i_1 = val_2(D) > 0 ? i_6 : 0;\n+  goto __BB5;\n \n-bb_5:\n-  i_3 = __PHI (bb_4: i_1, bb_2: 0);\n+__BB(5):\n+  i_3 = __PHI (__BB4: i_1, __BB2: 0);\n   return i_3;\n \n-bb_6:\n+__BB(6):\n   i_4 = 1;\n   i_9 = 2;\n-  goto bb_2;\n+  goto __BB2;\n }\n \n int main()"}, {"sha": "98cb56a8564becfc8d5cd0253fa74f23ccf1bc77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-13.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -9,7 +9,7 @@ typedef int i32;\n \n struct a {i32 a[8];i32 b;};\n \n-void __GIMPLE (startwith(\"fix_loops\"))\n+void __GIMPLE (ssa,startwith(\"fix_loops\"))\n t (struct a * a)\n {\n   i32 i;\n@@ -18,37 +18,37 @@ t (struct a * a)\n   i32 _9;\n   i32 _11;\n \n-bb_2:\n+__BB(2):\n   _11 = a_6(D)->a[0];\n   if (_11 != _Literal (i32) 0)\n-    goto bb_6;\n+    goto __BB6;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_3:\n+__BB(3):\n   return;\n \n-bb_4:\n+__BB(4):\n   _1 = _2 + _Literal (i32) 1;\n   a_6(D)->a[i_19] = _1;\n   i_8 = i_19 + _Literal (i32) 1;\n   if (i_8 <= _Literal (i32) 123455)\n-    goto bb_5;\n+    goto __BB5;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_5:\n-  i_19 = __PHI (bb_6: _Literal (i32) 1, bb_4: i_8);\n+__BB(5):\n+  i_19 = __PHI (__BB6: _Literal (i32) 1, __BB4: i_8);\n   _2 = a_6(D)->a[i_19];\n   if (_2 != _Literal (i32) 0)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_6:\n+__BB(6):\n   _9 = _11 + _Literal (i32) 1;\n   a_6(D)->a[0] = _9;\n-  goto bb_5;\n+  goto __BB5;\n }\n \n /* This testcase relies on the fact that we do not eliminate the redundant test"}, {"sha": "43554c21c0bb8eec1fc2047eaba2c2b6f74a02dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_1g.c", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_1g.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -3,7 +3,7 @@\n \n /* The test 'if (p2 > p_limit2)' can be replaced, so iv p2 can be\n  * eliminated.  */\n-long int __GIMPLE (startwith(\"fix_loops\"))\n+long int __GIMPLE (ssa,startwith(\"fix_loops\"))\n foo (long int * p, long int * p2, int N1, int N2)\n {\n   long int s;\n@@ -15,67 +15,68 @@ foo (long int * p, long int * p2, int N1, int N2)\n   long unsigned int _4;\n   long int _5;\n \n-  bb_2:\n+  __BB(2):\n   _1 = (long unsigned int) N1_10(D);\n   _2 = _1 * 8ul;\n   p_limit_12 = p_11(D) + _2;\n   _3 = (long unsigned int) N2_13(D);\n   _4 = _3 * 8ul;\n   p_limit2_15 = p2_14(D) + _4;\n   if (p_11(D) <= p_limit_12)\n-    goto bb_3;\n+    goto __BB3;\n   else\n-    goto bb_13;\n+    goto __BB13;\n \n-  bb_13:\n+  __BB(13):\n+  goto __BB9;\n \n-  bb_9:\n-  goto bb_6;\n+  __BB(9):\n+  goto __BB6;\n \n-  bb_3:\n+  __BB(3):\n   p_20 = p_11(D) + 8ul;\n   p2_23 = p2_14(D) + 8ul;\n   if (p_limit2_15 < p2_23)\n-    goto bb_14;\n+    goto __BB14;\n   else\n-    goto bb_7;\n+    goto __BB7;\n \n-  bb_14:\n-  goto bb_9;\n+  __BB(14):\n+  goto __BB9;\n \n-  bb_7:\n-  goto bb_5;\n+  __BB(7):\n+  goto __BB5;\n \n-  bb_4:\n+  __BB(4):\n   p_16 = p_26 + 8ul;\n   p2_17 = p2_27 + 8ul;\n   if (p_limit2_15 < p2_17)\n-    goto bb_11;\n+    goto __BB11;\n   else\n-    goto bb_8;\n+    goto __BB8;\n \n-  bb_11:\n-  goto bb_6;\n+  __BB(11):\n+  goto __BB6;\n \n-  bb_8:\n-  ;\n+  __BB(8):\n+  goto __BB5;\n \n-  bb_5:\n-  s_24 = __PHI (bb_7: 0l, bb_8: s_19);\n-  p_26 = __PHI (bb_7: p_20, bb_8: p_16);\n-  p2_27 = __PHI (bb_7: p2_23, bb_8: p2_17);\n+  __BB(5):\n+  s_24 = __PHI (__BB7: 0l, __BB8: s_19);\n+  p_26 = __PHI (__BB7: p_20, __BB8: p_16);\n+  p2_27 = __PHI (__BB7: p2_23, __BB8: p2_17);\n   _5 = __MEM <long int> (p_26);\n   s_19 = _5 + s_24;\n   if (p_limit_12 >= p_26)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_12;\n+    goto __BB12;\n \n-  bb_12:\n-  ;\n+  __BB(12):\n+  goto __BB6;\n \n-  bb_6:\n-  s_25 = __PHI (bb_12: s_19, bb_11: s_19, bb_9: 0l);\n+  __BB(6):\n+  s_25 = __PHI (__BB12: s_19, __BB11: s_19, __BB9: 0l);\n   return s_25;\n }\n "}, {"sha": "dd06e598f7f48e1a75eba41d626860404325259d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopt_mult_2g.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopt_mult_2g.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -3,7 +3,7 @@\n \n /* Exit tests 'i < N1' and 'p2 > p_limit2' can be replaced, so\n  * two ivs i and p2 can be eliminate.  */\n-long int __GIMPLE (startwith(\"fix_loops\"))\n+long int __GIMPLE (ssa,startwith(\"fix_loops\"))\n foo (long int * p, long int * p2, int N1, int N2)\n {\n   long int s;\n@@ -13,66 +13,67 @@ foo (long int * p, long int * p2, int N1, int N2)\n   long unsigned int _2;\n   long int _3;\n \n-  bb_2:\n+  __BB(2):\n   _1 = (long unsigned int) N2_9(D);\n   _2 = _1 * 8ul;\n   p_limit2_11 = p2_10(D) + _2;\n   if (N1_13(D) > 0)\n-    goto bb_3;\n+    goto __BB3;\n   else\n-    goto bb_13;\n+    goto __BB13;\n \n-  bb_13:\n+  __BB(13):\n+  goto __BB9;\n \n-  bb_9:\n-  goto bb_6;\n+  __BB(9):\n+  goto __BB6;\n \n-  bb_3:\n+  __BB(3):\n   p_22 = p_12(D) + 8ul;\n   p2_23 = p2_10(D) + 8ul;\n   if (p_limit2_11 < p2_23)\n-    goto bb_14;\n+    goto __BB14;\n   else\n-    goto bb_7;\n+    goto __BB7;\n \n-  bb_14:\n-  goto bb_9;\n+  __BB(14):\n+  goto __BB9;\n \n-  bb_7:\n-  goto bb_5;\n+  __BB(7):\n+  goto __BB5;\n \n-  bb_4:\n+  __BB(4):\n   p_14 = p_27 + 8ul;\n   p2_15 = p2_28 + 8ul;\n   i_16 = i_29 + 1;\n   if (p_limit2_11 < p2_15)\n-    goto bb_11;\n+    goto __BB11;\n   else\n-    goto bb_8;\n+    goto __BB8;\n \n-  bb_11:\n-  goto bb_6;\n+  __BB(11):\n+  goto __BB6;\n \n-  bb_8:\n-  ;\n+  __BB(8):\n+  goto __BB5;\n \n-  bb_5:\n-  s_25 = __PHI (bb_7: 0l, bb_8: s_18);\n-  p_27 = __PHI (bb_7: p_22, bb_8: p_14);\n-  p2_28 = __PHI (bb_7: p2_23, bb_8: p2_15);\n-  i_29 = __PHI (bb_7: 1, bb_8: i_16);\n+  __BB(5):\n+  s_25 = __PHI (__BB7: 0l, __BB8: s_18);\n+  p_27 = __PHI (__BB7: p_22, __BB8: p_14);\n+  p2_28 = __PHI (__BB7: p2_23, __BB8: p2_15);\n+  i_29 = __PHI (__BB7: 1, __BB8: i_16);\n   _3 = __MEM <long int> (p_27);\n   s_18 = _3 + s_25;\n   if (N1_13(D) > i_29)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_12;\n+    goto __BB12;\n \n-  bb_12:\n-  ;\n+  __BB(12):\n+  goto __BB6;\n \n-  bb_6:\n-  s_26 = __PHI (bb_12: s_18, bb_11: s_18, bb_9: 0l);\n+  __BB(6):\n+  s_26 = __PHI (__BB12: s_18, __BB11: s_18, __BB9: 0l);\n   return s_26;\n }\n "}, {"sha": "4babd33f5c06286260ef78498de50338bf3fed7f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-3.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-3.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -4,39 +4,39 @@\n int *a_p;\n int a[1000];\n \n-void __GIMPLE (startwith (\"loop\"))\n+void __GIMPLE (ssa,startwith (\"loop\"))\n f (int k)\n {\n   int i;\n   int * _1;\n \n-bb_2:\n+__BB(2):\n   i_5 = k_4(D);\n   if (i_5 <= 999)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_3:\n+__BB(3):\n   return;\n \n-bb_4:\n-  ;\n+__BB(4):\n+  goto __BB5;\n \n-bb_5:\n-  i_12 = __PHI (bb_6: i_9, bb_4: i_5);\n+__BB(5):\n+  i_12 = __PHI (__BB6: i_9, __BB4: i_5);\n   _1 = &a[i_12];\n   a_p = _1;\n   __MEM <int[1000]> ((int *)&a)[i_12] = 100;\n   i_9 = i_5 + i_12;\n   if (i_9 <= 999)\n-    goto bb_6;\n+    goto __BB6;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_6:\n+__BB(6):\n   ;\n-  goto bb_5;\n+  goto __BB5;\n \n }\n "}, {"sha": "57cb02134021827049df8d047f7af392d4ad64fc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-4.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-4.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -9,39 +9,39 @@ typedef struct {\n int *a_p;\n S a[1000];\n \n-void __GIMPLE (startwith (\"loop\"))\n+void __GIMPLE (ssa, startwith (\"loop\"))\n f (int k)\n {\n   int i;\n   int * _1;\n \n-bb_2:\n+__BB(2):\n   i_5 = k_4(D);\n   if (i_5 <= 999)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_3:\n+__BB(3):\n   return;\n \n-bb_4:\n-  ;\n+__BB(4):\n+  goto __BB5;\n \n-bb_5:\n-  i_12 = __PHI (bb_6: i_9, bb_4: i_5);\n+__BB(5):\n+  i_12 = __PHI (__BB6: i_9, __BB4: i_5);\n   _1 = &a[i_12].y;\n   a_p = _1;\n   __MEM <S[1000]> ((int *)&a)[i_12].y = 100;\n   i_9 = i_5 + i_12;\n   if (i_9 <= 999)\n-    goto bb_6;\n+    goto __BB6;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_6:\n+__BB(6):\n   ;\n-  goto bb_5;\n+  goto __BB5;\n \n }\n "}, {"sha": "c2feebdfc2489937affce8663124bd7dff449da8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-5.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-5.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -4,39 +4,39 @@\n int *a_p;\n int a[1000];\n \n-void __GIMPLE (startwith (\"loop\"))\n+void __GIMPLE (ssa,startwith (\"loop\"))\n f (int k)\n {\n   long long int i;\n   int * _1;\n \n-bb_2:\n+__BB(2):\n   i_5 = (long long int) k_4(D);\n   if (i_5 <= 999ll)\n-    goto bb_4;\n+    goto __BB4;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_3:\n+__BB(3):\n   return;\n \n-bb_4:\n-  ;\n+__BB(4):\n+  goto __BB5;\n \n-bb_5:\n-  i_12 = __PHI (bb_6: i_9, bb_4: i_5);\n+__BB(5):\n+  i_12 = __PHI (__BB6: i_9, __BB4: i_5);\n   _1 = &a[i_12];\n   a_p = _1;\n   __MEM <int[1000]> ((int *)&a)[i_12] = 100;\n   i_9 = i_5 + i_12;\n   if (i_9 <= 999ll)\n-    goto bb_6;\n+    goto __BB6;\n   else\n-    goto bb_3;\n+    goto __BB3;\n \n-bb_6:\n+__BB(6):\n   ;\n-  goto bb_5;\n+  goto __BB5;\n \n }\n "}, {"sha": "38994ea82a5c570b5eaba5f258979ff965ef7fc2", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-2.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-additional-options \"-fgimple -fdump-tree-optimized -ffast-math\" } */\n \n-double __GIMPLE (startwith(\"loop\"))\n+double __GIMPLE (ssa, startwith(\"loop\"))\n neg_xi (double *x)\n {\n   int i;\n@@ -13,13 +13,13 @@ neg_xi (double *x)\n   double res;\n   unsigned int ivtmp;\n \n- bb_1:\n-  goto bb_2;\n+ __BB(5):\n+  goto __BB2;\n \n- bb_2:\n-  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);\n-  i_4 = __PHI (bb_1: 0, bb_3: i_5);\n-  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);\n+ __BB(2):\n+  res_1 = __PHI (__BB5: 0.0, __BB3: res_2);\n+  i_4 = __PHI (__BB5: 0, __BB3: i_5);\n+  ivtmp_6 = __PHI (__BB5: 100U, __BB3: ivtmp_7);\n   index = (long unsigned int) i_4;\n   offset = index * 8UL;\n   xi_ptr = x_8(D) + offset;\n@@ -29,15 +29,15 @@ neg_xi (double *x)\n   i_5 = i_4 + 1;\n   ivtmp_7 = ivtmp_6 - 1U;\n   if (ivtmp_7 != 0U)\n-    goto bb_3;\n+    goto __BB3;\n   else\n-    goto bb_4;\n+    goto __BB4;\n \n- bb_3:\n-  goto bb_2;\n+ __BB(3):\n+  goto __BB2;\n \n- bb_4:\n-  res_3 = __PHI (bb_2: res_2);\n+ __BB(4):\n+  res_3 = __PHI (__BB2: res_2);\n   return res_3;\n }\n "}, {"sha": "e7416ebcded8b206024b90e22925546bbfafcd21", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_6.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -ftree-vectorize -fgimple -ffast-math\" } */\n \n-double __GIMPLE (startwith(\"loop\"))\n+double __GIMPLE (ssa, startwith(\"loop\"))\n neg_xi (double *x)\n {\n   int i;\n@@ -13,13 +13,13 @@ neg_xi (double *x)\n   double res;\n   unsigned int ivtmp;\n \n- bb_1:\n-  goto bb_2;\n+ __BB(5):\n+  goto __BB2;\n \n- bb_2:\n-  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);\n-  i_4 = __PHI (bb_1: 0, bb_3: i_5);\n-  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);\n+ __BB(2):\n+  res_1 = __PHI (__BB5: 0.0, __BB3: res_2);\n+  i_4 = __PHI (__BB5: 0, __BB3: i_5);\n+  ivtmp_6 = __PHI (__BB5: 100U, __BB3: ivtmp_7);\n   index = (long unsigned int) i_4;\n   offset = index * 8UL;\n   xi_ptr = x_8(D) + offset;\n@@ -29,15 +29,15 @@ neg_xi (double *x)\n   i_5 = i_4 + 1;\n   ivtmp_7 = ivtmp_6 - 1U;\n   if (ivtmp_7 != 0U)\n-    goto bb_3;\n+    goto __BB3;\n   else\n-    goto bb_4;\n+    goto __BB4;\n \n- bb_3:\n-  goto bb_2;\n+ __BB(3):\n+  goto __BB2;\n \n- bb_4:\n-  res_3 = __PHI (bb_2: res_2);\n+ __BB(4):\n+  res_3 = __PHI (__BB2: res_2);\n   return res_3;\n }\n "}, {"sha": "0dc94ea41d4a549319ff4a80024504eef29b1f06", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -171,7 +171,6 @@ static bool gimple_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (const gcond *, tree);\n-static void lower_phi_internal_fn ();\n \n void\n init_empty_tree_cfg_for_function (struct function *fn)\n@@ -246,7 +245,6 @@ build_gimple_cfg (gimple_seq seq)\n   discriminator_per_locus = new hash_table<locus_discrim_hasher> (13);\n   make_edges ();\n   assign_discriminators ();\n-  lower_phi_internal_fn ();\n   cleanup_dead_labels ();\n   delete discriminator_per_locus;\n   discriminator_per_locus = NULL;\n@@ -359,47 +357,6 @@ replace_loop_annotate (void)\n     }\n }\n \n-/* Lower internal PHI function from GIMPLE FE.  */\n-\n-static void\n-lower_phi_internal_fn ()\n-{\n-  basic_block bb, pred = NULL;\n-  gimple_stmt_iterator gsi;\n-  tree lhs;\n-  gphi *phi_node;\n-  gimple *stmt;\n-\n-  /* After edge creation, handle __PHI function from GIMPLE FE.  */\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n-\t{\n-\t  stmt = gsi_stmt (gsi);\n-\t  if (! gimple_call_internal_p (stmt, IFN_PHI))\n-\t    break;\n-\n-\t  lhs = gimple_call_lhs (stmt);\n-\t  phi_node = create_phi_node (lhs, bb);\n-\n-\t  /* Add arguments to the PHI node.  */\n-\t  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n-\t    {\n-\t      tree arg = gimple_call_arg (stmt, i);\n-\t      if (TREE_CODE (arg) == LABEL_DECL)\n-\t\tpred = label_to_block (cfun, arg);\n-\t      else\n-\t\t{\n-\t\t  edge e = find_edge (pred, bb);\n-\t\t  add_phi_arg (phi_node, arg, e, UNKNOWN_LOCATION);\n-\t\t}\n-\t    }\n-\n-\t  gsi_remove (&gsi, true);\n-\t}\n-    }\n-}\n-\n static unsigned int\n execute_build_cfg (void)\n {\n@@ -3337,11 +3294,6 @@ verify_gimple_call (gcall *stmt)\n \t  debug_generic_stmt (fn);\n \t  return true;\n \t}\n-      /* FIXME : for passing label as arg in internal fn PHI from GIMPLE FE*/\n-      else if (gimple_call_internal_fn (stmt) == IFN_PHI)\n-\t{\n-\t  return false;\n-\t}\n     }\n   else\n     {\n@@ -7922,7 +7874,11 @@ dump_function_to_file (tree fndecl, FILE *file, dump_flags_t flags)\n     {\n       print_generic_expr (file, TREE_TYPE (TREE_TYPE (fndecl)),\n \t\t\t  dump_flags | TDF_SLIM);\n-      fprintf (file, \" __GIMPLE ()\\n%s (\", function_name (fun));\n+      fprintf (file, \" __GIMPLE (%s)\\n%s (\",\n+\t       (fun->curr_properties & PROP_ssa) ? \"ssa\"\n+\t       : (fun->curr_properties & PROP_cfg) ? \"cfg\"\n+\t       : \"\",\n+\t       function_name (fun));\n     }\n   else\n     fprintf (file, \"%s %s(\", function_name (fun), tmclone ? \"[tm-clone] \" : \"\");"}, {"sha": "061521d20d5929e5adc2d8bf9272e4dc61074439", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa09dc5c951213452446689466ad889656b9936/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=baa09dc5c951213452446689466ad889656b9936", "patch": "@@ -1436,20 +1436,12 @@ rewrite_add_phi_arguments (basic_block bb)\n       for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n-\t  tree currdef, res, argvar;\n+\t  tree currdef, res;\n \t  location_t loc;\n \n \t  phi = gsi.phi ();\n \t  res = gimple_phi_result (phi);\n-\t  /* If we have pre-existing PHI (via the GIMPLE FE) its args may\n-\t     be different vars than existing vars and they may be constants\n-\t     as well.  Note the following supports partial SSA for PHI args.  */\n-\t  argvar = gimple_phi_arg_def (phi, e->dest_idx);\n-\t  if (argvar && ! DECL_P (argvar))\n-\t    continue;\n-\t  if (!argvar)\n-\t    argvar = SSA_NAME_VAR (res);\n-\t  currdef = get_reaching_def (argvar);\n+\t  currdef = get_reaching_def (SSA_NAME_VAR (res));\n \t  /* Virtual operand PHI args do not need a location.  */\n \t  if (virtual_operand_p (res))\n \t    loc = UNKNOWN_LOCATION;"}]}