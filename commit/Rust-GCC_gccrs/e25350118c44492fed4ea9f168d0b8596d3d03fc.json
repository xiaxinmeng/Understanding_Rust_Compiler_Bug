{"sha": "e25350118c44492fed4ea9f168d0b8596d3d03fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1MzUwMTE4YzQ0NDkyZmVkNGVhOWYxNjhkMGI4NTk2ZDNkMDNmYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-11-23T12:47:31Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-11-23T12:47:31Z"}, "message": "fold-const.c (fold_cond_expr_with_comparison): Move simplification for A == C1 ? A : C2 to below.\n\n\t* fold-const.c (fold_cond_expr_with_comparison): Move simplification\n\tfor A == C1 ? A : C2 to below.\n\t* match.pd: Move from above to here:\n\t(cond (eq (convert1? x) c1) (convert2? x) c2)\n\t  -> (cond (eq x c1) c1 c2).\n\nFrom-SVN: r242751", "tree": {"sha": "d12ecd7ecb082a700239231e770351f33b176773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d12ecd7ecb082a700239231e770351f33b176773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e25350118c44492fed4ea9f168d0b8596d3d03fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25350118c44492fed4ea9f168d0b8596d3d03fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25350118c44492fed4ea9f168d0b8596d3d03fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25350118c44492fed4ea9f168d0b8596d3d03fc/comments", "author": null, "committer": null, "parents": [{"sha": "b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c"}], "stats": {"total": 89, "additions": 49, "deletions": 40}, "files": [{"sha": "61af4e2a0660bc2564fdc9c49e1cd7c719e6df0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e25350118c44492fed4ea9f168d0b8596d3d03fc", "patch": "@@ -1,3 +1,11 @@\n+2016-11-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* fold-const.c (fold_cond_expr_with_comparison): Move simplification\n+\tfor A == C1 ? A : C2 to below.\n+\t* match.pd: Move from above to here:\n+\t(cond (eq (convert1? x) c1) (convert2? x) c2)\n+\t  -> (cond (eq x c1) c1 c2).\n+\n 2016-11-23  Bin Cheng  <bin.cheng@arm.com>\n \n \t* fold-const.c (fold_cond_expr_with_comparison): Move simplification"}, {"sha": "6517188c4c6026205731e044a5e0fde3c1011c0d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e25350118c44492fed4ea9f168d0b8596d3d03fc", "patch": "@@ -5210,19 +5210,6 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t}\n     }\n \n-  /* If this is A == C1 ? A : C2 with C1 and C2 constant integers,\n-     we simplify it into A == C1 ? C1 : C2.  */\n-\n-  if (comp_code == EQ_EXPR\n-      && INTEGRAL_TYPE_P (type)\n-      && TREE_CODE (arg01) == INTEGER_CST\n-      && TREE_CODE (arg1) != INTEGER_CST\n-      && TREE_CODE (arg2) == INTEGER_CST)\n-    {\n-      arg1 = fold_convert_loc (loc, type, arg01);\n-      return fold_build3_loc (loc, COND_EXPR, type, arg0, arg1, arg2);\n-    }\n-\n   return NULL_TREE;\n }\n "}, {"sha": "e3f85140e1ec13f496e20dfed421199e12181bc1", "filename": "gcc/match.pd", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25350118c44492fed4ea9f168d0b8596d3d03fc/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=e25350118c44492fed4ea9f168d0b8596d3d03fc", "patch": "@@ -1955,15 +1955,21 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* Simplification moved from fold_cond_expr_with_comparison.  It may also\n    be extended.  */\n-/* (cond (cmp (convert1? x) c1) (convert2? x) c2) -> (minmax (x c)) if:\n+/* This pattern implements two kinds simplification:\n+\n+   Case 1)\n+   (cond (cmp (convert1? x) c1) (convert2? x) c2) -> (minmax (x c)) if:\n      1) Conversions are type widening from smaller type.\n      2) Const c1 equals to c2 after canonicalizing comparison.\n      3) Comparison has tree code LT, LE, GT or GE.\n    This specific pattern is needed when (cmp (convert x) c) may not\n    be simplified by comparison patterns because of multiple uses of\n    x.  It also makes sense here because simplifying across multiple\n-   referred var is always benefitial for complicated cases.  */\n-(for cmp (lt le gt ge)\n+   referred var is always benefitial for complicated cases.\n+\n+   Case 2)\n+   (cond (eq (convert1? x) c1) (convert2? x) c2) -> (cond (eq x c1) c1 c2).  */\n+(for cmp (lt le gt ge eq)\n  (simplify\n   (cond (cmp@0 (convert1? @1) INTEGER_CST@3) (convert2? @1) INTEGER_CST@2)\n   (with\n@@ -1982,37 +1988,45 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t\t && (TYPE_UNSIGNED (from_type)\n \t\t     || TYPE_SIGN (c2_type) == TYPE_SIGN (from_type)))))\n        {\n-\t if (wi::to_widest (@3) == (wi::to_widest (@2) - 1))\n-\t   {\n-\t     /* X <= Y - 1 equals to X < Y.  */\n-\t     if (cmp_code == LE_EXPR)\n-\t       code = LT_EXPR;\n-\t     /* X > Y - 1 equals to X >= Y.  */\n-\t     if (cmp_code == GT_EXPR)\n-\t       code = GE_EXPR;\n-\t   }\n-\t if (wi::to_widest (@3) == (wi::to_widest (@2) + 1))\n-\t   {\n-\t     /* X < Y + 1 equals to X <= Y.  */\n-\t     if (cmp_code == LT_EXPR)\n-\t       code = LE_EXPR;\n-\t     /* X >= Y + 1 equals to X > Y.  */\n-\t     if (cmp_code == GE_EXPR)\n-\t       code = GT_EXPR;\n-\t   }\n-\t if (code != cmp_code || wi::to_widest (@2) == wi::to_widest (@3))\n+\t if (code != EQ_EXPR)\n \t   {\n-\t     if (cmp_code == LT_EXPR || cmp_code == LE_EXPR)\n-\t       code = MIN_EXPR;\n-\t     if (cmp_code == GT_EXPR || cmp_code == GE_EXPR)\n-\t       code = MAX_EXPR;\n+\t     if (wi::to_widest (@3) == (wi::to_widest (@2) - 1))\n+\t       {\n+\t\t /* X <= Y - 1 equals to X < Y.  */\n+\t\t if (cmp_code == LE_EXPR)\n+\t\t   code = LT_EXPR;\n+\t\t /* X > Y - 1 equals to X >= Y.  */\n+\t\t if (cmp_code == GT_EXPR)\n+\t\t   code = GE_EXPR;\n+\t       }\n+\t     if (wi::to_widest (@3) == (wi::to_widest (@2) + 1))\n+\t       {\n+\t\t /* X < Y + 1 equals to X <= Y.  */\n+\t\t if (cmp_code == LT_EXPR)\n+\t\t   code = LE_EXPR;\n+\t\t /* X >= Y + 1 equals to X > Y.  */\n+\t\t if (cmp_code == GE_EXPR)\n+\t\t   code = GT_EXPR;\n+\t       }\n+\t     if (code != cmp_code || wi::to_widest (@2) == wi::to_widest (@3))\n+\t       {\n+\t\t if (cmp_code == LT_EXPR || cmp_code == LE_EXPR)\n+\t\t   code = MIN_EXPR;\n+\t\t if (cmp_code == GT_EXPR || cmp_code == GE_EXPR)\n+\t\t   code = MAX_EXPR;\n+\t       }\n \t   }\n+\t /* Can do A == C1 ? A : C2  ->  A == C1 ? C1 : C2?  */\n+\t else if (!int_fits_type_p (@3, from_type))\n+\t   code = ERROR_MARK;\n        }\n    }\n    (if (code == MAX_EXPR)\n     (convert (max @1 (convert:from_type @2)))\n     (if (code == MIN_EXPR)\n-     (convert (min @1 (convert:from_type @2))))))))\n+     (convert (min @1 (convert:from_type @2)))\n+     (if (code == EQ_EXPR)\n+      (cond (cmp @1 (convert:from_type @3)) (convert:from_type @3) @2)))))))\n \n (for cnd (cond vec_cond)\n  /* A ? B : (A ? X : C) -> A ? B : C.  */"}]}