{"sha": "1f732f61ea2ac643e30b8068ee3f6737f07de271", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY3MzJmNjFlYTJhYzY0M2UzMGI4MDY4ZWUzZjY3MzdmMDdkZTI3MQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2005-02-03T00:41:35Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2005-02-03T00:41:35Z"}, "message": "gen_directive_tests: Generate tests for selector expressions.\n\n\t* gcc.test-framework/gen_directive_tests: Generate tests for\n\tselector expressions.\n\nFrom-SVN: r94642", "tree": {"sha": "cfe606a8586c46cc8160cfeae8a3fc4e6d10d2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfe606a8586c46cc8160cfeae8a3fc4e6d10d2bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f732f61ea2ac643e30b8068ee3f6737f07de271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f732f61ea2ac643e30b8068ee3f6737f07de271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f732f61ea2ac643e30b8068ee3f6737f07de271", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f732f61ea2ac643e30b8068ee3f6737f07de271/comments", "author": null, "committer": null, "parents": [{"sha": "d47fc2487f21739ef36ed6bbfc078ab2ae3b98e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47fc2487f21739ef36ed6bbfc078ab2ae3b98e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d47fc2487f21739ef36ed6bbfc078ab2ae3b98e5"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "3e1fee45ec7da227525997d73f1a583031078c62", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f732f61ea2ac643e30b8068ee3f6737f07de271/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f732f61ea2ac643e30b8068ee3f6737f07de271/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f732f61ea2ac643e30b8068ee3f6737f07de271", "patch": "@@ -1,3 +1,8 @@\n+2005-02-02  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* gcc.test-framework/gen_directive_tests: Generate tests for\n+\tselector expressions.\n+\n 2005-02-02  Matt Austern  <austern@apple.com>\n \n \tPR c++/19628"}, {"sha": "ac817dd2a34f6eda51d531c122957b525fabe55c", "filename": "gcc/testsuite/gcc.test-framework/gen_directive_tests", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f732f61ea2ac643e30b8068ee3f6737f07de271/gcc%2Ftestsuite%2Fgcc.test-framework%2Fgen_directive_tests", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f732f61ea2ac643e30b8068ee3f6737f07de271/gcc%2Ftestsuite%2Fgcc.test-framework%2Fgen_directive_tests", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.test-framework%2Fgen_directive_tests?ref=1f732f61ea2ac643e30b8068ee3f6737f07de271", "patch": "@@ -36,8 +36,10 @@ cd $1\n \n GOOD0='*-*-*'\n GOOD1=\"yes\"\n+GOOD2='empty-*-* *-*-empty *-*-*'\n BAD0='empty-empty-empty'\n BAD1=\"no\"\n+BAD2='empty-*-* *-empty-* *-*-empty'\n \n # Programs used in the tests: good compile and run, bad compile, and\n # bad run.\n@@ -441,6 +443,127 @@ three_all() {\n     done\n }\n \n+# Generate a test that uses a dg-do directive with a selector expression.\n+dgdo_progs() {\n+    WHAT=$1\n+    KIND=$2\n+    PROG=\"$3\"\n+    NAME=\"$4\"\n+    XPR=\"$5\"\n+    \n+    FILE1=${NAME}-1.c\n+    FILE2=${NAME}-2.c\n+    rm -f $FILE1\n+    touch $FILE1\n+    echo '/* { dg-do' $WHAT '{' $KIND \"$XPR\" '} } */' >> $FILE1\n+    echo \"${PROG}\" >> $FILE1\n+    echo \"${GOOD_PROG}\" > $FILE2\n+}\n+\n+# Use various selector-expressions that evaluate to TRUE in dg-do directives.\n+selector_good() {\n+    NUM=101\n+    for xpr in \\\n+        \"$GOOD0\" \\\n+        \"$GOOD1\" \\\n+        \"$GOOD2\" \\\n+        \"{ ! $BAD0 }\" \\\n+        \"{ ! $BAD1 }\" \\\n+\t\"{ ! { $BAD2 } }\" \\\n+\t\"{ ! \\\"${BAD2}\\\" }\" \\\n+        \"{ $GOOD1 || $GOOD0 }\"  \\\n+        \"{ $BAD1 || $GOOD0 }\" \\\n+        \"{ $GOOD0 && $GOOD1 }\"  \\\n+        \"{ $BAD1 || { \\\"${GOOD2}\\\" && $GOOD1 } }\" \\\n+        \"{ { $BAD0 || $GOOD0 } && $GOOD0 }\" \\\n+        \"{ $GOOD1 && { \\\"${GOOD2}\\\" || $BAD1 } }\" \\\n+        \"{ \\\"${GOOD2}\\\" && { $GOOD1 || $BAD1 } }\"\n+    do\n+        dgdo_progs compile target \"$GOOD_PROG\" \"dots${NUM}-exp-P\" \"$xpr\"\n+        dgdo_progs compile target \"$BADC_PROG\" \"dots${NUM}-exp-F\" \"$xpr\"\n+        dgdo_progs run xfail \"$GOOD_PROG\" \"doxf${NUM}-exp-XP\" \"$xpr\"\n+        dgdo_progs run xfail \"$BADR_PROG\" \"doxf${NUM}-exp-XF\" \"$xpr\"\n+        let NUM=NUM+1\n+    done\n+}\n+\n+# Use various selector-expressions that evaluate to FALSE in dg-do directives.\n+selector_bad() {\n+    NUM=101\n+    for xpr in \\\n+        \"$BAD0\" \\\n+        \"$BAD1\" \\\n+        \"$BAD2\" \\\n+        \"{ ! $GOOD0 }\" \\\n+        \"{ ! $GOOD1 }\" \\\n+\t\"{ ! { $GOOD2 } }\" \\\n+\t\"{ ! \\\"${GOOD2}\\\" }\" \\\n+        \"{ $BAD1 || $BAD0 }\" \\\n+        \"{ $BAD0 && $GOOD1 }\" \\\n+        \"{ $GOOD1 && $BAD0 }\" \\\n+        \"{ $BAD1 || { $GOOD1 && $BAD0 } }\" \\\n+        \"{ { $GOOD1 || $BAD1 } && $BAD0 }\" \\\n+        \"{ $BAD1 || { \\\"${BAD2}\\\" && $GOOD1 } }\" \\\n+        \"{ \\\"${BAD2}\\\" && { $GOOD1 || $BAD1 } }\"\n+    do\n+        dgdo_progs compile target \"$GOOD_PROG\" \"dotn${NUM}-exp-U\" \"$xpr\"\n+        dgdo_progs run xfail \"$GOOD_PROG\" \"doxp${NUM}-exp-P\" \"$xpr\"\n+        dgdo_progs run xfail \"$BADR_PROG\" \"doxp${NUM}-exp-F\" \"$xpr\"\n+        let NUM=NUM+1\n+    done\n+}\n+\n+# Write a test whose directive is too long and messy to do as one string.\n+deep_progs() {\n+    PROG=\"$1\"\n+    NAME=$2\n+    CMD1=\"$3\"\n+    CMD2=\"$4\"\n+    CMD3=\"$5\"\n+\n+    FILE1=${NAME}-1.c\n+    FILE2=${NAME}-2.c\n+    rm -f $FILE1\n+    touch $FILE1\n+    echo \"$CMD1\" \"$CMD2\" \"$CMD3\" > $FILE1\n+    echo \"$PROG\" >> $FILE1\n+    echo \"$GOOD_PROG\" > $FILE2\n+}\n+\n+# Use nested expressions in various test directives.\n+selector_deep() {\n+    GOODXPR=\"{ \\\"${GOOD2}\\\" && { ! { $BAD0 || $BAD1 } } }\"\n+    BADXPR=\"{ ! { \\\"${GOOD2}\\\" || { $GOOD1 && $BAD1 } } }\"\n+    NUM=100\n+    dgdo_progs compile target \"$GOOD_PROG\" \"dots${NUM}-exp-P\" \"$GOODXPR\"\n+    dgdo_progs compile target \"$GOOD_PROG\" \"dotn${NUM}-exp-U\" \"$BADXPR\"\n+\n+    deep_progs \"$BADC_PROG\" \"xiff-100-exp-XF\" \\\n+      '/* { dg-xfail-if \"match\" { ' \"{ $GOODXPR }\" ' } { \"*\" } { \"\" } } */'\n+    deep_progs \"$GOOD_PROG\" \"xifp-100-exp-P\" \\\n+      '/* { dg-xfail-if \"no match\" { ' \"{ $BADXPR }\" ' } { \"*\" } { \"\" } } */'\n+    deep_progs \"$BADC_PROG\" \"xifn-100-exp-U\" \\\n+      '/* { dg-skip-if \"match\" { ' \"{ $GOODXPR }\" ' } { \"*\" } { \"\" } } */'\n+    deep_progs \"$GOOD_PROG\" \"xifs-100-exp-P\" \\\n+      '/* { dg-skip-if \"match\" { ' \"{ $BADXPR }\" ' } { \"*\" } { \"\" } } */'\n+    deep_progs \"$GOOD_PROG\" \"satn-100-exp-P\" \\\n+      '/* { dg-final { scan-assembler-not \"unexpected garbage\" { target ' \\\n+      \"$GOODXPR\" ' } } } */'\n+    deep_progs \"$GOOD_PROG\" \"satn-100-exp-U\" \\\n+      '/* { dg-final { scan-assembler-not \"unexpected garbage\" { target ' \\\n+      \"$BADXPR\" ' } } } */'\n+    deep_progs \"$GOOD_PROG\" \"satf-100-exp-XP\" \\\n+      '/* { dg-final { scan-assembler-not \"unexpected garbage\" { xfail ' \\\n+      \"$GOODXPR\" ' } } } */'\n+    deep_progs \"$GOOD_PROG\" \"satp-100-exp-P\" \\\n+      '/* { dg-final { scan-assembler-not \"unexpected garbage\" { xfail ' \\\n+      \"$BADXPR\" ' } } } */'\n+}\n+\n+selector_good\n+selector_bad\n+selector_deep\n+\n one_all saxp $EXP_PASS no\n one_all saxf $EXP_XPASS no\n one_all sats $EXP_PASS no"}]}