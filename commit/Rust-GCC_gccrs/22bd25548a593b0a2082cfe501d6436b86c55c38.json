{"sha": "22bd25548a593b0a2082cfe501d6436b86c55c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiZDI1NTQ4YTU5M2IwYTIwODJjZmU1MDFkNjQzNmI4NmM1NWMzOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2002-10-21T19:05:47Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-10-21T19:05:47Z"}, "message": "920923-1.c: Prevent spurious regressions with bison 1.50 or later.\n\n\t* gcc.dg/noncompile/920923-1.c: Prevent spurious regressions with\n\tbison 1.50 or later.\n\nFrom-SVN: r58374", "tree": {"sha": "ffe3253c4e812a494bef00f0cfbc8baf316ce0ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffe3253c4e812a494bef00f0cfbc8baf316ce0ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22bd25548a593b0a2082cfe501d6436b86c55c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bd25548a593b0a2082cfe501d6436b86c55c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bd25548a593b0a2082cfe501d6436b86c55c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bd25548a593b0a2082cfe501d6436b86c55c38/comments", "author": null, "committer": null, "parents": [{"sha": "c1ddb5c8acd510e31336747809d3ac32c3827ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ddb5c8acd510e31336747809d3ac32c3827ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ddb5c8acd510e31336747809d3ac32c3827ef1"}], "stats": {"total": 91, "additions": 55, "deletions": 36}, "files": [{"sha": "4d6ffd5c5ab03eae6b37580657d94ee4ca272d91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bd25548a593b0a2082cfe501d6436b86c55c38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bd25548a593b0a2082cfe501d6436b86c55c38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22bd25548a593b0a2082cfe501d6436b86c55c38", "patch": "@@ -1,3 +1,8 @@\n+2002-10-21  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/920923-1.c: Prevent spurious regressions with\n+\tbison 1.50 or later.\n+\n 2002-10-21  Janis Johnson  <janis187@us.ibm.com>\n \n \t* g++.dg/README: Describe more test directories.\n@@ -156,15 +161,15 @@ Thu Oct 17 19:12:58 CEST 2002  Jan Hubicka  <jh@suse.cz>\n 2002-10-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/init/array6.C: New test.\n-\t\n+\n \t* g++.dg/abi/mangle13.C: Likewise.\n \t* g++.dg/abi/mangle14.C: Likewise.\n \t* g++.dg/abi/mangle15.C: Likewise.\n \n 2002-10-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/abi/empty8.C: New test.\n-\t\n+\n 2002-10-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/init/ctor1.C: New test.\n@@ -205,15 +210,15 @@ Mon Oct 14 20:37:51 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tPR c++/5661\n \t* g++.dg/ext/vlm1.C: New test.\n \t* g++.dg/ext/vlm2.C: Likewise.\n-\t\n+\n \t* g++.dg/init/array1.C: Remove invalid braces.\n \t* g++.dg/init/brace1.C: New test.\n \t* g++.dg/init/copy2.C: Likewise.\n \t* g++.dg/init/copy3.C: Likewise.\n \t* g++.old-deja/g++.ext/arrnew.C: Change WARNING to ERROR.\n \t* g++.old-deja/g++.mike/p9129.C: Add ERROR on invalid use of\n \tbraces.\n-\t\n+\n 2002-10-11  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/assembler.S: Don't use -ansi."}, {"sha": "b2bc1fdce5bf5e1fc2c3f3e3a95c633ebeeb72c9", "filename": "gcc/testsuite/gcc.dg/noncompile/920923-1.c", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bd25548a593b0a2082cfe501d6436b86c55c38/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bd25548a593b0a2082cfe501d6436b86c55c38/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F920923-1.c?ref=22bd25548a593b0a2082cfe501d6436b86c55c38", "patch": "@@ -1,35 +1,49 @@\n-typedef BYTE unsigned char;\t/* { dg-error \"syntax error|empty decl\" } */\n+/* This test case contains a large number of syntactic errors.  We\n+   believe the intent of the test is that the compiler simply not\n+   crash.  The set of error messages reported is different when the C\n+   parser is generated with bison 1.50 than 1.35.  It is not worth\n+   attempting to prevent this.  Instead, we use a single dg-error with\n+   a regexp that will match _all_ the errors indiscriminately.  The\n+   old error/warning/etc markers are kept around for reference, but\n+   disabled.\n+\n+   Revisit after new (recursive descent) parser is implemented for C.\n+   -- zw 2002-10-17  */\n+\n+/* { dg-error \".*\" \"many syntax errors\" { target *-*-* } 0 } */\n+\n+typedef BYTE unsigned char;\t/* { error \"syntax error|empty decl\" } */\n typedef int item_n;\n typedef int perm_set;\n-struct PENT { caddr_t v_addr; };/* { dg-error \"parse error|no semicolon\" } */\n+struct PENT { caddr_t v_addr; };/* { error \"parse error|no semicolon\" } */\n typedef struct PENT prec;\n typedef struct PENT *prec_t;\n prec_t mem_hash;\n-BYTE *mem_base;\t\t\t/* { dg-error \"parse error|no type\" } */\n+BYTE *mem_base;\t\t\t/* { error \"parse error|no type\" } */\n struct PTE {\n-     BYTE *p_page;\t\t/* { dg-error \"parse error|no semicolon\" } */\n+     BYTE *p_page;\t\t/* { error \"parse error|no semicolon\" } */\n      perm_set p_perms;\n-};\t\t\t\t/* { dg-error \"parse error\" } */\n+};\t\t\t\t/* { error \"parse error\" } */\n typedef struct PTE pte;\n struct PTP {\n      union {\n-\t  struct *PTP p_tablep;\t/* { dg-error \"parse error|no semicolon\" } */\n+\t  struct *PTP p_tablep;\t/* { error \"parse error|no semicolon\" } */\n \t  struct *PTE p_entry;\n-     } u;\t\t\t/* { dg-warning \"no type or storage class\" } */\n+     } u;\t\t\t/* { warning \"no type or storage class\" } */\n      int valid;\n-};\t\t\t\t/* { dg-error \"parse error\" } */\n-typedef struct PTP (u.p_tablep);/* { dg-error \"parse error\" } */\n+};\t\t\t\t/* { error \"parse error\" } */\n+typedef struct PTP (u.p_tablep);/* { error \"parse error\" } */\n int pfree=0;\n int pcount=0;\n \n void\n mmu_walk_find(va)\n-caddr_t va;\t\t\t/* { dg-error \"parse error|no type\" } */\n+caddr_t va;\t\t\t/* { error \"parse error|no type\" } */\n {\n      BYTE *page_addr;\n      if (mmu_base[Level1(va)]->valid==0x0) {\n \t  l1_base = mmu_base[Level1(va)]->(u.p_tablep) = p_alloc();\n-\t  mmu_base[Level1(va)]->valid = 0x3;\t/* { dg-error \"parse error\" } */\n+\t  mmu_base[Level1(va)]->valid = 0x3;\t/* { error \"parse error\" } */\n \t  for (idx=0; idx<LEVEL1_ENTRIES; idx++)\n \t       l1_base[idx]->valid = 0x0;\n \t  goto build_level2;\n@@ -39,43 +53,43 @@ caddr_t va;\t\t\t/* { dg-error \"parse error|no type\" } */\n      if (l1_base[Level2(va)]->valid==0x0) {\n      build_level2:\n \t  l2_base = l1_base[Level2(va)]->(u.p_tablep) = p_alloc();\n-\t  l1_base[Level2(va)]->valid = 0x3;\t/* { dg-error \"parse error\" } */\n+\t  l1_base[Level2(va)]->valid = 0x3;\t/* { error \"parse error\" } */\n \t  for (idx=0; idx<LEVEL2_ENTRIES; idx++)\n \t       l2_base[idx]->valid=0x0;\n \t  goto build_page;\n      } else\n \t  l2_base = mmu_base[Level2(va)]->(u.p_tablep);\n \n-     page_addr = l2_base[Level2(va)]->valid;/* { dg-error \"undeclared|no type\" } */\n-}\t\t\t\t/* { dg-error \"parse error\" } */\n+     page_addr = l2_base[Level2(va)]->valid;/* { error \"undeclared|no type\" } */\n+}\t\t\t\t/* { error \"parse error\" } */\n \n void *\n a_translate(va_op, v_addr)\n int va_op;\n-caddr_t v_addr;\t\t\t/* { dg-error \"parse error\" } */\n+caddr_t v_addr;\t\t\t/* { error \"parse error\" } */\n {\n      register prec_t bucket;\n-     register caddr_t p_addr;\t/* { dg-error \"syntax error\" } */\n-     bucket = mem_hash+((((v_addr)>>ITEMBITS))&hash_mask); /* { dg-error \"undeclared|for each function\" } */\n+     register caddr_t p_addr;\t/* { error \"syntax error\" } */\n+     bucket = mem_hash+((((v_addr)>>ITEMBITS))&hash_mask); /* { error \"undeclared|for each function\" } */\n      do {\n-\t  if (bucket->v_addr == ((v_addr)>>ITEMBITS) {\t/* { dg-error \"incomplete type|parse error\" } */\n+\t  if (bucket->v_addr == ((v_addr)>>ITEMBITS) {\t/* { error \"incomplete type|parse error\" } */\n \t       if(!(bucket->perm_set&va_op))\n \t\t    goto prot_fault;\n \t       return mem_base + v_addr;\n \t  }\n-     } while((bucket++)->v_addr != ((caddr_t)0));  /* { dg-error \"parse error\" } */\n+     } while((bucket++)->v_addr != ((caddr_t)0));  /* { error \"parse error\" } */\n \n  page_miss:\n-     p_addr = (--bucket)->p_addr;\t/* { dg-error \"undeclared|pointer to\" } */\n+     p_addr = (--bucket)->p_addr;\t/* { error \"undeclared|pointer to\" } */\n  page_type:\n      switch (p_addr) {\n-     case BUCKET_FULL:\t\t/* { dg-error \"undeclared\" } */\n+     case BUCKET_FULL:\t\t/* { error \"undeclared\" } */\n \t  enlarge_hash_table(mem_hash);\n-     case((caddr_t)0):\t\t/* { dg-error \"undeclared|parse error\" } */\n+     case((caddr_t)0):\t\t/* { error \"undeclared|parse error\" } */\n \t  p_addr = fill_item_entry(va_op, v_addr);\n \t  goto page_type;\n-     case((caddr_t)1):\t\t/* { dg-error \"parse error\" } */\n-     default:\t\t\t\n+     case((caddr_t)1):\t\t/* { error \"parse error\" } */\n+     default:\n \t  ((void)(((0))?0:(__eprintf(\"Failed assertion`%s'at line%d of`%s'.\\n\",\n \t\t\t\t     \"FALSE\", 327, \"b.c\"), 0)));\n      }\n@@ -90,9 +104,9 @@ int hash_size;\n      register int idx;\n      bucket = hasht;\n      for(idx=(hash_size*3)-1; idx>=0; idx--) {\n-\t  bucket->v_addr = ((caddr_t)0);/* { dg-error \"undeclared|pointer to|parse error\" } */\n-\t  bucket->p_addr = ((caddr_t)0);/* { dg-error \"pointer to|parse error\" } */\n-\t  bucket->perm_set = VA_EMPTY;\t/* { dg-error \"undeclared|pointer to\" } */\n+\t  bucket->v_addr = ((caddr_t)0);/* { error \"undeclared|pointer to|parse error\" } */\n+\t  bucket->p_addr = ((caddr_t)0);/* { error \"pointer to|parse error\" } */\n+\t  bucket->perm_set = VA_EMPTY;\t/* { error \"undeclared|pointer to\" } */\n      }\n }\n \n@@ -101,21 +115,21 @@ extern void *calloc(__SIZE_TYPE__, __SIZE_TYPE__);\n void\n init_mem()\n {\n-     mem_base = (BYTE *) calloc(1024, (1<<13)); /* { dg-error \"undeclared|parse error\" } */\n-     ((void)((mem_base != (BYTE *)0)\t/* { dg-error \"parse error\" } */\n+     mem_base = (BYTE *) calloc(1024, (1<<13)); /* { error \"undeclared|parse error\" } */\n+     ((void)((mem_base != (BYTE *)0)\t/* { error \"parse error\" } */\n \t     ? 0\n \t     : (__eprintf(\"Failed assertion`%s'at line%d of`%s'.\\n\",\n \t\t\t  \"mem_base != (BYTE *)0\", 366, \"b.c\"),\n \t\t0)));\n-     hash_num = INIT_NUM_ENTRIES * 3;\t/* { dg-error \"undeclared\" } */\n-     mem_hash = (prec_t) calloc(hash_num, sizeof(prec)); /* { dg-error \"incomplete type\" } */\n+     hash_num = INIT_NUM_ENTRIES * 3;\t/* { error \"undeclared\" } */\n+     mem_hash = (prec_t) calloc(hash_num, sizeof(prec)); /* { error \"incomplete type\" } */\n      ((void)((mem_hash != (prec_t)0)\n \t     ? 0\n \t     : (__eprintf(\"Failed assertion`%s'at line%d of`%s'.\\n\",\n \t\t\t  \"mem_hash != (prec_t)0\", 370, \"b.c\"),\n \t\t0)));\n      flush_hash(mem_hash, 32);\n-     build_ptables(mem_base, 1024*(1<<13)); /* { dg-bogus \"integer overflow\" \"int smaller than 32 bits\" { xfail \"xstormy16-*-*\" } } */\n+     build_ptables(mem_base, 1024*(1<<13)); /* { bogus \"integer overflow\" \"int smaller than 32 bits\" } */\n }\n \n struct tm {"}]}