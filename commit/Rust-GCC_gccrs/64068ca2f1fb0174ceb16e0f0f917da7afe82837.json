{"sha": "64068ca2f1fb0174ceb16e0f0f917da7afe82837", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQwNjhjYTJmMWZiMDE3NGNlYjE2ZTBmMGY5MTdkYTdhZmU4MjgzNw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-12-20T17:06:14Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-12-20T17:06:14Z"}, "message": "re PR rtl-optimization/25115 (Segmentation fault in pre_insert_copy_insn)\n\n2005-12-20  Roger Sayle  <roger@eyesopen.com>\n\t    Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR rtl-optimization/25115\n\t* gcse.c (pre_insert_copy_insn): Fall back to the sole\n\tSET in the insn if there is no SET for an\n\texpression that is equivalent to EXPR.\n\n\nCo-Authored-By: Paolo Bonzini <bonzini@gnu.org>\n\nFrom-SVN: r108855", "tree": {"sha": "82d3d092201bbbb1c8e056d0e465dbc2ca06c1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82d3d092201bbbb1c8e056d0e465dbc2ca06c1a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64068ca2f1fb0174ceb16e0f0f917da7afe82837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64068ca2f1fb0174ceb16e0f0f917da7afe82837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64068ca2f1fb0174ceb16e0f0f917da7afe82837", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64068ca2f1fb0174ceb16e0f0f917da7afe82837/comments", "author": null, "committer": null, "parents": [{"sha": "f5a7da0f62f3eed45dad990ef70a91d45a3fb5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a7da0f62f3eed45dad990ef70a91d45a3fb5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a7da0f62f3eed45dad990ef70a91d45a3fb5d3"}], "stats": {"total": 30, "additions": 25, "deletions": 5}, "files": [{"sha": "300c0f748bfe4edd4bf50c6ae814b0938f6d25a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64068ca2f1fb0174ceb16e0f0f917da7afe82837/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64068ca2f1fb0174ceb16e0f0f917da7afe82837/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64068ca2f1fb0174ceb16e0f0f917da7afe82837", "patch": "@@ -1,3 +1,11 @@\n+2005-12-20  Roger Sayle  <roger@eyesopen.com>\n+\t    Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR rtl-optimization/25115\n+\t* gcse.c (pre_insert_copy_insn): Fall back to the sole\n+\tSET in the insn if there is no SET for an\n+\texpression that is equivalent to EXPR.\n+\n 2005-12-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/24306"}, {"sha": "8e4dbecb672fef309947445e1184315e5acf5bd5", "filename": "gcc/gcse.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64068ca2f1fb0174ceb16e0f0f917da7afe82837/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64068ca2f1fb0174ceb16e0f0f917da7afe82837/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=64068ca2f1fb0174ceb16e0f0f917da7afe82837", "patch": "@@ -4219,7 +4219,7 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n   int regno = REGNO (reg);\n   int indx = expr->bitmap_index;\n   rtx pat = PATTERN (insn);\n-  rtx set, new_insn;\n+  rtx set, first_set, new_insn;\n   rtx old_reg;\n   int i;\n \n@@ -4233,17 +4233,29 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n     case PARALLEL:\n       /* Search through the parallel looking for the set whose\n \t source was the expression that we're interested in.  */\n+      first_set = NULL_RTX;\n       set = NULL_RTX;\n       for (i = 0; i < XVECLEN (pat, 0); i++)\n \t{\n \t  rtx x = XVECEXP (pat, 0, i);\n-\t  if (GET_CODE (x) == SET\n-\t      && expr_equiv_p (SET_SRC (x), expr->expr))\n+\t  if (GET_CODE (x) == SET)\n \t    {\n-\t      set = x;\n-\t      break;\n+\t      /* If the source was a REG_EQUAL or REG_EQUIV note, we\n+\t\t may not find an equivalent expression, but in this\n+\t\t case the PARALLEL will have a single set.  */\n+\t      if (first_set == NULL_RTX)\n+\t\tfirst_set = x;\n+\t      if (expr_equiv_p (SET_SRC (x), expr->expr))\n+\t        {\n+\t          set = x;\n+\t          break;\n+\t        }\n \t    }\n \t}\n+\n+      gcc_assert (first_set);\n+      if (set == NULL_RTX)\n+        set = first_set;\n       break;\n \n     default:"}]}