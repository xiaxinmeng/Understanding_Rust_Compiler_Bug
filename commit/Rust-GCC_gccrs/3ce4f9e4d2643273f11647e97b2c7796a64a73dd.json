{"sha": "3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NlNGY5ZTRkMjY0MzI3M2YxMTY0N2U5N2IyYzc3OTZhNjRhNzNkZA==", "commit": {"author": {"name": "Ed Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2011-10-26T19:30:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-10-26T19:30:59Z"}, "message": "Implement C++11 user-defined literals.\n\nlibcpp/\n\t* expr.c: (cpp_interpret_float_suffix, cpp_interpret_int_suffix,\n\tcpp_userdef_string_remove_type, cpp_userdef_string_add_type,\n\tcpp_userdef_char_remove_type, cpp_userdef_char_add_type,\n\tcpp_userdef_string_p, cpp_userdef_char_p, cpp_get_userdef_suffix): New.\n\t(cpp_classify_number): Classify unrecognized tokens as user-defined\n\tliterals.\n\t* include/cpplib.h: Add new tokens for user-defined literals.\n\t* init.c: Add new preprocessor flag (cxx11).\n\t* lex.c: (lex_string, lex_raw_string): Handle user-defined literals\n\tincluding concatenation and promotion with suffixes.\nc-family/\n\t* c-common.c (build_userdef_literal): New.\n\t* c-common.def: New tree code.\n\t* c-common.h (tree_userdef_literal): New tree struct and accessors.\n\t* c-lex.c (interpret_float): Add suffix parm.\n\t(c_lex_with_flags): Build literal tokens.\ncp/\n\t* cp-objcp-common.c: (cp_tree_size) Return size of USERDEF_LITERAL tree.\n\t* cp-tree.h: (UDLIT_OP_*, UDLIT_OPER_P): Literal operator\n\tname tools. New tree code for user-defined literals.\n\t* cxx-pretty-print.h: (pp_cxx_userdef_literal) New.\n\t* cxx-pretty-print.c: (pp_cxx_userdef_literal) New.\n\t(pp_cxx_primary_expression, pp_cxx_expression): Use it.\n\t* decl.c: (cp_tree_node_structure): Return new tree code.\n\t(duplicate_decls): Check for raw vs. template operator conflicts.\n\t(grokfndecl, grokdeclarator): New checks for literal operators.\n\t* error.c: (dump_expr): Warn about user-defined literals\n\tin C++98 mode. (dump_function_name): Pretty printing.\n\t* mangle.c: (write_literal_operator_name): New.\n\t(write_unqualified_id, write_unqualified_name): Use it.\n\t* parser.c: (cp_parser_operator): Handle operator\"\".\n\t(cp_parser_userdef_char_literal, cp_parser_userdef_numeric_literal,\n\tcp_parser_userdef_string_literal): New.\n\t(cp_parser_primary_expression): Handle new user-defined literal tokens\n\twith new functions.\n\t* semantics.c: (potential_constant_expression_1): Add\n\tuser-defined literals.\n\t* typeck.c (check_raw_literal_operator,\n\tcheck_literal_operator_args): New.\n\nFrom-SVN: r180536", "tree": {"sha": "1d0c22775480b21a84a6024b85f12710e67dd587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d0c22775480b21a84a6024b85f12710e67dd587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f808caddae18d281e190566e6f49e3417d99926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f808caddae18d281e190566e6f49e3417d99926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f808caddae18d281e190566e6f49e3417d99926"}], "stats": {"total": 1765, "additions": 1714, "deletions": 51}, "files": [{"sha": "b49e827866b09bcd74668728257ec8a2884d8bf4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1,3 +1,12 @@\n+2011-10-26  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tImplement C++11 user-defined literals.\n+\t* c-common.c (build_userdef_literal): New.\n+\t* c-common.def: New tree code.\n+\t* c-common.h (tree_userdef_literal): New tree struct and accessors.\n+\t* c-lex.c (interpret_float): Add suffix parm.\n+\t(c_lex_with_flags): Build literal tokens.\n+\n 2011-10-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50841"}, {"sha": "2eefe03f390c1f2ac5d4e1643cac58e09ea32818", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -9912,4 +9912,17 @@ c_common_init_ts (void)\n   MARK_TS_TYPED (EXCESS_PRECISION_EXPR);\n }\n \n+/* Build a user-defined numeric literal out of an integer constant type VALUE\n+   with identifier SUFFIX.  */\n+\n+tree\n+build_userdef_literal (tree suffix_id, tree value, tree num_string)\n+{\n+  tree literal = make_node (USERDEF_LITERAL);\n+  USERDEF_LITERAL_SUFFIX_ID (literal) = suffix_id;\n+  USERDEF_LITERAL_VALUE (literal) = value;\n+  USERDEF_LITERAL_NUM_STRING (literal) = num_string;\n+  return literal;\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "2a7df882d0af2cf007bb41043865d562e17a2b26", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -47,6 +47,12 @@ DEFTREECODE (C_MAYBE_CONST_EXPR, \"c_maybe_const_expr\", tcc_expression, 2)\n    evaluated.  */\n DEFTREECODE (EXCESS_PRECISION_EXPR, \"excess_precision_expr\", tcc_expression, 1)\n \n+/* Used to represent a user-defined literal.\n+   The operands are an IDENTIFIER for the suffix, the VALUE of the literal,\n+   and for numeric literals the original string representation of the\n+   number.  */\n+DEFTREECODE (USERDEF_LITERAL, \"userdef_literal\", tcc_exceptional, 3)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "be9d7295b2a35e6c7e0bfc7ec740c0d28f6f9afd", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1067,4 +1067,27 @@ c_tree_chain_next (tree t)\n   return NULL;\n }\n \n+/* A suffix-identifier value doublet that represents user-defined literals\n+   for C++-0x.  */\n+struct GTY(()) tree_userdef_literal {\n+  struct tree_base base;\n+  tree suffix_id;\n+  tree value;\n+  tree num_string;\n+};\n+\n+#define USERDEF_LITERAL_SUFFIX_ID(NODE) \\\n+  (((struct tree_userdef_literal *)USERDEF_LITERAL_CHECK (NODE))->suffix_id)\n+\n+#define USERDEF_LITERAL_VALUE(NODE) \\\n+  (((struct tree_userdef_literal *)USERDEF_LITERAL_CHECK (NODE))->value)\n+\n+#define USERDEF_LITERAL_NUM_STRING(NODE) \\\n+  (((struct tree_userdef_literal *)USERDEF_LITERAL_CHECK (NODE))->num_string)\n+\n+#define USERDEF_LITERAL_TYPE(NODE) \\\n+  (TREE_TYPE (USERDEF_LITERAL_VALUE (NODE)))\n+\n+extern tree build_userdef_literal (tree suffix_id, tree value, tree num_string);\n+\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "baee8eb9799c5a1dea02c823831c999a769a4586", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -45,7 +45,7 @@ int pending_lang_change; /* If we need to switch languages - C++ only */\n int c_header_level;\t /* depth in C headers - C++ only */\n \n static tree interpret_integer (const cpp_token *, unsigned int);\n-static tree interpret_float (const cpp_token *, unsigned int);\n+static tree interpret_float (const cpp_token *, unsigned int, const char *);\n static tree interpret_fixed (const cpp_token *, unsigned int);\n static enum integer_type_kind narrowest_unsigned_type\n \t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n@@ -314,7 +314,8 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \n     case CPP_NUMBER:\n       {\n-\tunsigned int flags = cpp_classify_number (parse_in, tok);\n+\tconst char *suffix = NULL;\n+\tunsigned int flags = cpp_classify_number (parse_in, tok, &suffix);\n \n \tswitch (flags & CPP_N_CATEGORY)\n \t  {\n@@ -332,12 +333,27 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \t    break;\n \n \t  case CPP_N_FLOATING:\n-\t    *value = interpret_float (tok, flags);\n+\t    *value = interpret_float (tok, flags, suffix);\n \t    break;\n \n \t  default:\n \t    gcc_unreachable ();\n \t  }\n+\n+\tif (flags & CPP_N_USERDEF)\n+\t  {\n+\t    tree suffix_id = get_identifier (suffix);\n+\t    int len = tok->val.str.len - strlen (suffix);\n+\t    tree num_string = build_string (len + 1,\n+\t\t\t\t\t    (const char *) tok->val.str.text);\n+\t    TREE_TYPE (num_string) = char_array_type_node;\n+\t    num_string = fix_string_type (num_string);\n+\t    char *str = CONST_CAST (char *, TREE_STRING_POINTER (num_string));\n+\t    str[len] = '\\0';\n+\t    tree literal = build_userdef_literal (suffix_id, *value,\n+\t\t\t\t\t\t  num_string);\n+\t    *value = literal;\n+\t  }\n       }\n       break;\n \n@@ -415,13 +431,45 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n       }\n       goto retry;\n \n+    case CPP_CHAR_USERDEF:\n+    case CPP_WCHAR_USERDEF:\n+    case CPP_CHAR16_USERDEF:\n+    case CPP_CHAR32_USERDEF:\n+      {\n+\ttree literal;\n+\tcpp_token temp_tok = *tok;\n+\tconst char *suffix = cpp_get_userdef_suffix (tok);\n+\ttemp_tok.val.str.len -= strlen (suffix);\n+\ttemp_tok.type = cpp_userdef_char_remove_type (type);\n+\tliteral = build_userdef_literal (get_identifier (suffix),\n+\t\t\t\t\t lex_charconst (&temp_tok), NULL_TREE);\n+\t*value = literal;\n+      }\n+      break;\n+\n     case CPP_CHAR:\n     case CPP_WCHAR:\n     case CPP_CHAR16:\n     case CPP_CHAR32:\n       *value = lex_charconst (tok);\n       break;\n \n+    case CPP_STRING_USERDEF:\n+    case CPP_WSTRING_USERDEF:\n+    case CPP_STRING16_USERDEF:\n+    case CPP_STRING32_USERDEF:\n+    case CPP_UTF8STRING_USERDEF:\n+      {\n+\ttree literal, string;\n+\tconst char *suffix = cpp_get_userdef_suffix (tok);\n+\tstring = build_string (tok->val.str.len - strlen (suffix),\n+\t\t\t       (const char *) tok->val.str.text);\n+\tliteral = build_userdef_literal (get_identifier (suffix),\n+\t\t\t\t\t string, NULL_TREE);\n+\t*value = literal;\n+      }\n+      break;\n+\n     case CPP_STRING:\n     case CPP_WSTRING:\n     case CPP_STRING16:\n@@ -621,9 +669,10 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n }\n \n /* Interpret TOKEN, a floating point number with FLAGS as classified\n-   by cpplib.  */\n+   by cpplib.  For C++0X SUFFIX may contain a user-defined literal suffix.  */\n static tree\n-interpret_float (const cpp_token *token, unsigned int flags)\n+interpret_float (const cpp_token *token, unsigned int flags,\n+\t\t const char *suffix)\n {\n   tree type;\n   tree const_type;\n@@ -702,7 +751,9 @@ interpret_float (const cpp_token *token, unsigned int flags)\n      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF\n      can't handle them.  */\n   copylen = token->val.str.len;\n-  if (flags & CPP_N_DFLOAT)\n+  if (flags & CPP_N_USERDEF)\n+    copylen -= strlen (suffix);\n+  else if (flags & CPP_N_DFLOAT)\n     copylen -= 2;\n   else\n     {"}, {"sha": "ee942cab6d6794911e02178729d39d12bee89def", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1,3 +1,29 @@\n+2011-10-26  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tImplement C++11 user-defined literals.\n+\t* cp-objcp-common.c: (cp_tree_size) Return size of USERDEF_LITERAL tree.\n+\t* cp-tree.h: (UDLIT_OP_*, UDLIT_OPER_P): Literal operator\n+\tname tools. New tree code for user-defined literals.\n+\t* cxx-pretty-print.h: (pp_cxx_userdef_literal) New.\n+\t* cxx-pretty-print.c: (pp_cxx_userdef_literal) New.\n+\t(pp_cxx_primary_expression, pp_cxx_expression): Use it.\n+\t* decl.c: (cp_tree_node_structure): Return new tree code.\n+\t(duplicate_decls): Check for raw vs. template operator conflicts.\n+\t(grokfndecl, grokdeclarator): New checks for literal operators.\n+\t* error.c: (dump_expr): Warn about user-defined literals\n+\tin C++98 mode. (dump_function_name): Pretty printing.\n+\t* mangle.c: (write_literal_operator_name): New.\n+\t(write_unqualified_id, write_unqualified_name): Use it.\n+\t* parser.c: (cp_parser_operator): Handle operator\"\".\n+\t(cp_parser_userdef_char_literal, cp_parser_userdef_numeric_literal,\n+\tcp_parser_userdef_string_literal): New.\n+\t(cp_parser_primary_expression): Handle new user-defined literal tokens\n+\twith new functions.\n+\t* semantics.c: (potential_constant_expression_1): Add\n+\tuser-defined literals.\n+\t* typeck.c (check_raw_literal_operator,\n+\tcheck_literal_operator_args): New.\n+\n 2011-10-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* typeck.c (cp_build_addr_expr_1): Use BASELINK_P."}, {"sha": "a957a0303acf66f22483294813b7e84d89fd44d2", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -100,6 +100,8 @@ cp_tree_size (enum tree_code code)\n \n     case TEMPLATE_INFO:         return sizeof (struct tree_template_info);\n \n+    case USERDEF_LITERAL:\treturn sizeof (struct tree_userdef_literal);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "cc12d154a227c8b286ac69d0a68d36e85c1e2100", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -400,7 +400,9 @@ typedef enum cpp0x_warn_str\n   /* override controls, override/final */\n   CPP0X_OVERRIDE_CONTROLS,\n   /* non-static data member initializers */\n-  CPP0X_NSDMI\n+  CPP0X_NSDMI,\n+  /* user defined literals */\n+  CPP0X_USER_DEFINED_LITERALS\n } cpp0x_warn_str;\n   \n /* The various kinds of operation used by composite_pointer_type. */\n@@ -740,6 +742,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_TRAIT_EXPR,\n   TS_CP_LAMBDA_EXPR,\n   TS_CP_TEMPLATE_INFO,\n+  TS_CP_USERDEF_LITERAL,\n   LAST_TS_CP_ENUM\n };\n \n@@ -765,6 +768,8 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     lambda_expression;\n   struct tree_template_info GTY ((tag (\"TS_CP_TEMPLATE_INFO\")))\n     template_info;\n+  struct tree_userdef_literal GTY ((tag (\"TS_CP_USERDEF_LITERAL\")))\n+    userdef_literal;\n };\n \n \f\n@@ -4228,6 +4233,17 @@ extern GTY(()) VEC(tree,gc) *local_classes;\n              LAMBDANAME_PREFIX, \\\n \t     sizeof (LAMBDANAME_PREFIX) - 1))\n \n+#define UDLIT_OP_ANSI_PREFIX \"operator\\\"\\\" \"\n+#define UDLIT_OP_ANSI_FORMAT UDLIT_OP_ANSI_PREFIX \"%s\"\n+#define UDLIT_OP_MANGLED_PREFIX \"li\"\n+#define UDLIT_OP_MANGLED_FORMAT UDLIT_OP_MANGLED_PREFIX \"%s\"\n+#define UDLIT_OPER_P(ID_NODE) \\\n+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), \\\n+             UDLIT_OP_ANSI_PREFIX, \\\n+\t     sizeof (UDLIT_OP_ANSI_PREFIX) - 1))\n+#define UDLIT_OP_SUFFIX(ID_NODE) \\\n+  (IDENTIFIER_POINTER (ID_NODE) + sizeof (UDLIT_OP_ANSI_PREFIX) - 1)\n+\n #if !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL)\n \n #define VTABLE_NAME_P(ID_NODE) (IDENTIFIER_POINTER (ID_NODE)[1] == 'v' \\\n@@ -5759,6 +5775,8 @@ extern tree convert_ptrmem\t\t\t(tree, tree, bool, bool,\n extern int lvalue_or_else\t\t\t(tree, enum lvalue_use,\n                                                  tsubst_flags_t);\n extern void check_template_keyword\t\t(tree);\n+extern bool check_raw_literal_operator\t\t(const_tree decl);\n+extern bool check_literal_operator_args\t\t(const_tree, bool *, bool *);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "55cb64b21e4b09aaf5646c46c3804e1e484e01f6", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -367,6 +367,17 @@ pp_cxx_id_expression (cxx_pretty_printer *pp, tree t)\n     pp_cxx_unqualified_id (pp, t);\n }\n \n+/* user-defined literal:\n+      literal ud-suffix  */\n+\n+void\n+pp_cxx_userdef_literal (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_constant (pp, USERDEF_LITERAL_VALUE (t));\n+  pp_cxx_id_expression (pp, USERDEF_LITERAL_SUFFIX_ID (t));\n+}\n+\n+\n /* primary-expression:\n      literal\n      this\n@@ -413,6 +424,10 @@ pp_cxx_primary_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_constant (pp, t);\n       break;\n \n+    case USERDEF_LITERAL:\n+      pp_cxx_userdef_literal (pp, t);\n+      break;\n+\n     case BASELINK:\n       t = BASELINK_FUNCTIONS (t);\n     case VAR_DECL:\n@@ -1024,6 +1039,10 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_constant (pp, t);\n       break;\n \n+    case USERDEF_LITERAL:\n+      pp_cxx_userdef_literal (pp, t);\n+      break;\n+\n     case RESULT_DECL:\n       pp_cxx_unqualified_id (pp, t);\n       break;"}, {"sha": "bb9fec1c1bd0fa54151d57251389a95b5360ab3b", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -74,5 +74,7 @@ void pp_cxx_canonical_template_parameter (cxx_pretty_printer *, tree);\n void pp_cxx_trait_expression (cxx_pretty_printer *, tree);\n void pp_cxx_va_arg_expression (cxx_pretty_printer *, tree);\n void pp_cxx_offsetof_expression (cxx_pretty_printer *, tree);\n+void pp_cxx_userdef_literal (cxx_pretty_printer *, tree);\n+\n \n #endif /* GCC_CXX_PRETTY_PRINT_H */"}, {"sha": "5ba50088684c93e4c0b32ec5ca76050e934749b9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1203,6 +1203,21 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       || TREE_TYPE (olddecl) == error_mark_node)\n     return error_mark_node;\n \n+  if (UDLIT_OPER_P (DECL_NAME (newdecl))\n+      && UDLIT_OPER_P (DECL_NAME (olddecl)))\n+    {\n+      if (TREE_CODE (newdecl) == TEMPLATE_DECL\n+\t  && TREE_CODE (olddecl) != TEMPLATE_DECL\n+\t  && check_raw_literal_operator (olddecl))\n+\terror (\"literal operator template %q+D conflicts with\"\n+\t       \" raw literal operator %qD\", newdecl, olddecl);\n+      else if (TREE_CODE (newdecl) != TEMPLATE_DECL\n+\t       && TREE_CODE (olddecl) == TEMPLATE_DECL\n+\t       && check_raw_literal_operator (newdecl))\n+\terror (\"raw literal operator %q+D conflicts with\"\n+\t       \" literal operator template %qD\", newdecl, olddecl);\n+    }\n+\n   if (DECL_P (olddecl)\n       && TREE_CODE (newdecl) == FUNCTION_DECL\n       && TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -7345,6 +7360,47 @@ grokfndecl (tree ctype,\n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl))\n       && !grok_op_properties (decl, /*complain=*/true))\n     return NULL_TREE;\n+  else if (UDLIT_OPER_P (DECL_NAME (decl)))\n+    {\n+      bool long_long_unsigned_p;\n+      bool long_double_p;\n+      const char *suffix = NULL;\n+      /* [over.literal]/6: Literal operators shall not have C linkage. */\n+      if (DECL_LANGUAGE (decl) == lang_c)\n+\t{\n+\t  error (\"literal operator with C linkage\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (DECL_NAMESPACE_SCOPE_P (decl))\n+\t{\n+\t  if (!check_literal_operator_args (decl, &long_long_unsigned_p,\n+\t\t\t\t\t    &long_double_p))\n+\t    {\n+\t      error (\"%qD has invalid argument list\", decl);\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  suffix = UDLIT_OP_SUFFIX (DECL_NAME (decl));\n+\t  if (long_long_unsigned_p)\n+\t    {\n+\t      if (cpp_interpret_int_suffix (suffix, strlen (suffix)))\n+\t\twarning (0, \"integer suffix %<%s%>\"\n+\t\t\t    \" shadowed by implementation\", suffix);\n+\t    }\n+\t  else if (long_double_p)\n+\t    {\n+\t      if (cpp_interpret_float_suffix (suffix, strlen (suffix)))\n+\t\twarning (0, \"floating point suffix %<%s%>\"\n+\t\t\t    \" shadowed by implementation\", suffix);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  error (\"%qD must be a non-member function\", decl);\n+\t  return NULL_TREE;\n+\t}\n+    }\n \n   if (funcdef_flag)\n     /* Make the init_value nonzero so pushdecl knows this is not\n@@ -8536,6 +8592,15 @@ grokdeclarator (const cp_declarator *declarator,\n       error (\"declaration of %qD as non-function\", dname);\n       return error_mark_node;\n     }\n+ \n+  if (dname\n+      && TREE_CODE (dname) == IDENTIFIER_NODE\n+      && UDLIT_OPER_P (dname)\n+      && innermost_code != cdk_function)\n+    {\n+      error (\"declaration of %qD as non-function\", dname);\n+      return error_mark_node;\n+    }\n \n   if (dname && IDENTIFIER_OPNAME_P (dname))\n     {\n@@ -13754,6 +13819,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case TRAIT_EXPR:\t\treturn TS_CP_TRAIT_EXPR;\n     case LAMBDA_EXPR:\t\treturn TS_CP_LAMBDA_EXPR;\n     case TEMPLATE_INFO:\t\treturn TS_CP_TEMPLATE_INFO;\n+    case USERDEF_LITERAL:\treturn TS_CP_USERDEF_LITERAL;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "544c4d1b7ac2972d2f230193d0a9fc706741c7d5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1534,6 +1534,8 @@ dump_function_name (tree t, int flags)\n     }\n   else if (name && IDENTIFIER_OPNAME_P (name))\n     pp_cxx_tree_identifier (cxx_pp, name);\n+  else if (name && UDLIT_OPER_P (name))\n+    pp_cxx_tree_identifier (cxx_pp, name);\n   else\n     dump_decl (name, flags);\n \n@@ -1756,6 +1758,10 @@ dump_expr (tree t, int flags)\n       pp_constant (cxx_pp, t);\n       break;\n \n+    case USERDEF_LITERAL:\n+      pp_cxx_userdef_literal (cxx_pp, t);\n+      break;\n+\n     case THROW_EXPR:\n       /* While waiting for caret diagnostics, avoid printing\n \t __cxa_allocate_exception, __cxa_throw, and the like.  */\n@@ -3233,7 +3239,7 @@ maybe_warn_cpp0x (cpp0x_warn_str str)\n \tpedwarn (input_location, OPT_pedantic,\n \t\t \"inline namespaces \"\n \t\t \"only available with -std=c++0x or -std=gnu++0x\");\n-\tbreak;\t\n+\tbreak;\n       case CPP0X_OVERRIDE_CONTROLS:\n \tpedwarn (input_location, 0,\n \t\t \"override controls (override/final) \"\n@@ -3244,8 +3250,13 @@ maybe_warn_cpp0x (cpp0x_warn_str str)\n \t\t \"non-static data member initializers \"\n \t\t \"only available with -std=c++0x or -std=gnu++0x\");\n         break;\n+      case CPP0X_USER_DEFINED_LITERALS:\n+\tpedwarn (input_location, 0,\n+\t\t \"user-defined literals \"\n+\t\t \"only available with -std=c++0x or -std=gnu++0x\");\n+\tbreak;\n       default:\n-\tgcc_unreachable();\n+\tgcc_unreachable ();\n       }\n }\n "}, {"sha": "8bc26d8b34ff0c58207cdd43c47bf2319b72c514", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -181,6 +181,7 @@ static void write_template_prefix (const tree);\n static void write_unqualified_name (const tree);\n static void write_conversion_operator_name (const tree);\n static void write_source_name (tree);\n+static void write_literal_operator_name (tree);\n static void write_unnamed_type_name (const tree);\n static void write_closure_type_name (const tree);\n static int hwint_to_ascii (unsigned HOST_WIDE_INT, const unsigned int, char *,\n@@ -1174,6 +1175,8 @@ write_unqualified_id (tree identifier)\n \t  }\n       write_string (mangled_name);\n     }\n+  else if (UDLIT_OPER_P (identifier))\n+    write_literal_operator_name (identifier);\n   else\n     write_source_name (identifier);\n }\n@@ -1227,6 +1230,8 @@ write_unqualified_name (const tree decl)\n \n \t  write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n \t}\n+      else if (UDLIT_OPER_P (DECL_NAME (decl)))\n+\twrite_literal_operator_name (DECL_NAME (decl));\n       else\n \tfound = false;\n \n@@ -1286,6 +1291,21 @@ write_source_name (tree identifier)\n   write_identifier (IDENTIFIER_POINTER (identifier));\n }\n \n+/* Write a user-defined literal operator.\n+   IDENTIFIER is an LITERAL_IDENTIFIER_NODE.  */\n+\n+static void\n+write_literal_operator_name (tree identifier)\n+{\n+  const char* suffix = UDLIT_OP_SUFFIX (identifier);\n+  char* buffer = XNEWVEC (char, strlen (UDLIT_OP_MANGLED_PREFIX)\n+\t\t\t      + strlen (suffix) + 10);\n+  sprintf (buffer, UDLIT_OP_MANGLED_FORMAT, suffix);\n+\n+  write_unsigned_number (strlen (buffer));\n+  write_identifier (buffer);\n+}\n+\n /* Encode 0 as _, and 1+ as n-1_.  */\n \n static void"}, {"sha": "840a30ddf650ab84cc0cdbcd1c4ff6da23ec9ad0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 381, "deletions": 14, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -225,6 +225,9 @@ static cp_token_cache *cp_token_cache_new\n static void cp_parser_initial_pragma\n   (cp_token *);\n \n+static tree cp_literal_operator_id\n+  (const char *);\n+\n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n #define CP_SAVED_TOKEN_STACK 5\n@@ -1762,6 +1765,12 @@ static tree cp_parser_identifier\n   (cp_parser *);\n static tree cp_parser_string_literal\n   (cp_parser *, bool, bool);\n+static tree cp_parser_userdef_char_literal\n+  (cp_parser *);\n+static tree cp_parser_userdef_string_literal\n+  (cp_token *);\n+static tree cp_parser_userdef_numeric_literal\n+  (cp_parser *);\n \n /* Basic concepts [gram.basic]  */\n \n@@ -2270,6 +2279,8 @@ static bool cp_parser_error_occurred\n   (cp_parser *);\n static bool cp_parser_allow_gnu_extensions_p\n   (cp_parser *);\n+static bool cp_parser_is_pure_string_literal\n+  (cp_token *);\n static bool cp_parser_is_string_literal\n   (cp_token *);\n static bool cp_parser_is_keyword\n@@ -2290,7 +2301,7 @@ cp_parser_parsing_tentatively (cp_parser* parser)\n /* Returns nonzero if TOKEN is a string literal.  */\n \n static bool\n-cp_parser_is_string_literal (cp_token* token)\n+cp_parser_is_pure_string_literal (cp_token* token)\n {\n   return (token->type == CPP_STRING ||\n \t  token->type == CPP_STRING16 ||\n@@ -2299,6 +2310,20 @@ cp_parser_is_string_literal (cp_token* token)\n \t  token->type == CPP_UTF8STRING);\n }\n \n+/* Returns nonzero if TOKEN is a string literal\n+   of a user-defined string literal.  */\n+\n+static bool\n+cp_parser_is_string_literal (cp_token* token)\n+{\n+  return (cp_parser_is_pure_string_literal (token) ||\n+\t  token->type == CPP_STRING_USERDEF ||\n+\t  token->type == CPP_STRING16_USERDEF ||\n+\t  token->type == CPP_STRING32_USERDEF ||\n+\t  token->type == CPP_WSTRING_USERDEF ||\n+\t  token->type == CPP_UTF8STRING_USERDEF);\n+}\n+\n /* Returns nonzero if TOKEN is the indicated KEYWORD.  */\n \n static bool\n@@ -3338,7 +3363,11 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n   struct obstack str_ob;\n   cpp_string str, istr, *strs;\n   cp_token *tok;\n-  enum cpp_ttype type;\n+  enum cpp_ttype type, curr_type;\n+  int have_suffix_p = 0;\n+  tree string_tree;\n+  tree suffix_id = NULL_TREE;\n+  bool curr_tok_is_userdef_p = false;\n \n   tok = cp_lexer_peek_token (parser->lexer);\n   if (!cp_parser_is_string_literal (tok))\n@@ -3347,7 +3376,18 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n       return error_mark_node;\n     }\n \n-  type = tok->type;\n+  if (cpp_userdef_string_p (tok->type))\n+    {\n+      string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n+      curr_type = cpp_userdef_string_remove_type (tok->type);\n+      curr_tok_is_userdef_p = true;\n+    }\n+  else\n+    {\n+      string_tree = tok->u.value;\n+      curr_type = tok->type;\n+    }\n+  type = curr_type;\n \n   /* Try to avoid the overhead of creating and destroying an obstack\n      for the common case of just one string.  */\n@@ -3356,10 +3396,19 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n     {\n       cp_lexer_consume_token (parser->lexer);\n \n-      str.text = (const unsigned char *)TREE_STRING_POINTER (tok->u.value);\n-      str.len = TREE_STRING_LENGTH (tok->u.value);\n+      str.text = (const unsigned char *)TREE_STRING_POINTER (string_tree);\n+      str.len = TREE_STRING_LENGTH (string_tree);\n       count = 1;\n \n+      if (curr_tok_is_userdef_p)\n+\t{\n+\t  suffix_id = USERDEF_LITERAL_SUFFIX_ID (tok->u.value);\n+\t  have_suffix_p = 1;\n+\t  curr_type = cpp_userdef_string_remove_type (tok->type);\n+\t}\n+      else\n+\tcurr_type = tok->type;\n+\n       strs = &str;\n     }\n   else\n@@ -3371,14 +3420,35 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  count++;\n-\t  str.text = (const unsigned char *)TREE_STRING_POINTER (tok->u.value);\n-\t  str.len = TREE_STRING_LENGTH (tok->u.value);\n+\t  str.text = (const unsigned char *)TREE_STRING_POINTER (string_tree);\n+\t  str.len = TREE_STRING_LENGTH (string_tree);\n+\n+\t  if (curr_tok_is_userdef_p)\n+\t    {\n+\t      tree curr_suffix_id = USERDEF_LITERAL_SUFFIX_ID (tok->u.value);\n+\t      if (have_suffix_p == 0)\n+\t\t{\n+\t\t  suffix_id = curr_suffix_id;\n+\t\t  have_suffix_p = 1;\n+\t\t}\n+\t      else if (have_suffix_p == 1\n+\t\t       && curr_suffix_id != suffix_id)\n+\t\t{\n+\t\t  error (\"inconsistent user-defined literal suffixes\"\n+\t\t\t \" %qD and %qD in string literal\",\n+\t\t\t suffix_id, curr_suffix_id);\n+\t\t  have_suffix_p = -1;\n+\t\t}\n+\t      curr_type = cpp_userdef_string_remove_type (tok->type);\n+\t    }\n+\t  else\n+\t    curr_type = tok->type;\n \n-\t  if (type != tok->type)\n+\t  if (type != curr_type)\n \t    {\n \t      if (type == CPP_STRING)\n-\t\ttype = tok->type;\n-\t      else if (tok->type != CPP_STRING)\n+\t\ttype = curr_type;\n+\t      else if (curr_type != CPP_STRING)\n \t\terror_at (tok->location,\n \t\t\t  \"unsupported non-standard concatenation \"\n \t\t\t  \"of string literals\");\n@@ -3387,6 +3457,18 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n \n \t  tok = cp_lexer_peek_token (parser->lexer);\n+\t  if (cpp_userdef_string_p (tok->type))\n+\t    {\n+\t      string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n+\t      curr_type = cpp_userdef_string_remove_type (tok->type);\n+\t      curr_tok_is_userdef_p = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      string_tree = tok->u.value;\n+\t      curr_type = tok->type;\n+\t      curr_tok_is_userdef_p = false;\n+\t    }\n \t}\n       while (cp_parser_is_string_literal (tok));\n \n@@ -3424,6 +3506,13 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t}\n \n       value = fix_string_type (value);\n+\n+      if (have_suffix_p)\n+\t{\n+\t  tree literal = build_userdef_literal (suffix_id, value, NULL_TREE);\n+\t  tok->u.value = literal;\n+\t  return cp_parser_userdef_string_literal (tok);\n+\t}\n     }\n   else\n     /* cpp_interpret_string has issued an error.  */\n@@ -3435,6 +3524,186 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n   return value;\n }\n \n+/* Parse a user-defined char constant.  Returns a call to a user-defined\n+   literal operator taking the character as an argument.  */\n+\n+static tree\n+cp_parser_userdef_char_literal (cp_parser *parser)\n+{\n+  cp_token *token = NULL;\n+  tree literal, suffix_id, value;\n+  tree name, decl;\n+  tree result;\n+  VEC(tree,gc) *vec;\n+\n+  token = cp_lexer_consume_token (parser->lexer);\n+  literal = token->u.value;\n+  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  value = USERDEF_LITERAL_VALUE (literal);\n+  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+\n+  /* Build up a call to the user-defined operator  */\n+  /* Lookup the name we got back from the id-expression.  */\n+  vec = make_tree_vector ();\n+  VEC_safe_push (tree, gc, vec, value);\n+  decl = lookup_function_nonclass (name, vec, /*block_p=*/false);\n+  if (!decl || decl == error_mark_node)\n+    {\n+      error (\"unable to find user-defined character literal operator %qD\",\n+\t     name);\n+      release_tree_vector (vec);\n+      return error_mark_node;\n+    }\n+  result = finish_call_expr (decl, &vec, false, true, tf_warning_or_error);\n+  release_tree_vector (vec);\n+\n+  return result;\n+}\n+\n+/* A subroutine of cp_parser_userdef_numeric_literal to\n+   create a char... template parameter pack from a string node.  */\n+\n+static tree\n+make_char_string_pack (tree value)\n+{\n+  tree charvec;\n+  tree argpack = make_node (NONTYPE_ARGUMENT_PACK);\n+  const char *str = TREE_STRING_POINTER (value);\n+  int i, len = TREE_STRING_LENGTH (value) - 1;\n+  tree argvec = make_tree_vec (1);\n+\n+  /* Fill in CHARVEC with all of the parameters.  */\n+  charvec = make_tree_vec (len);\n+  for (i = 0; i < len; ++i)\n+    TREE_VEC_ELT (charvec, i) = build_int_cst (char_type_node, str[i]);\n+\n+  /* Build the argument packs.  */\n+  SET_ARGUMENT_PACK_ARGS (argpack, charvec);\n+  TREE_TYPE (argpack) = char_type_node;\n+\n+  TREE_VEC_ELT (argvec, 0) = argpack;\n+\n+  return argvec;\n+}\n+\n+/* Parse a user-defined numeric constant.  returns a call to a user-defined\n+   literal operator.  */\n+\n+static tree\n+cp_parser_userdef_numeric_literal (cp_parser *parser)\n+{\n+  cp_token *token = NULL;\n+  tree literal, suffix_id, value, num_string;\n+  tree name, decl;\n+  tree result = error_mark_node;\n+  VEC(tree,gc) *args;\n+\n+  token = cp_lexer_consume_token (parser->lexer);\n+  literal = token->u.value;\n+  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  value = USERDEF_LITERAL_VALUE (literal);\n+  num_string = USERDEF_LITERAL_NUM_STRING (literal);\n+  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+\n+  /* Build up a call to the user-defined operator  */\n+  /* Lookup the name we got back from the id-expression.  */\n+  /* Try to find the literal operator by finishing the call expression\n+     with the numeric argument.  */\n+  args = make_tree_vector ();\n+  VEC_safe_push (tree, gc, args, value);\n+  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  if (decl && decl != error_mark_node)\n+    {\n+      result = finish_call_expr (decl, &args, false, true, tf_none);\n+      if (result != error_mark_node)\n+\t{\n+\t  release_tree_vector (args);\n+\t  return result;\n+\t}\n+    }\n+  release_tree_vector (args);\n+\n+  /* If the numeric argument didn't work, look for a raw literal\n+     operator taking a const char* argument consisting of the number\n+     in string format.  */\n+  args = make_tree_vector ();\n+  VEC_safe_push (tree, gc, args, num_string);\n+  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  if (decl && decl != error_mark_node)\n+    {\n+      result = finish_call_expr (decl, &args, false, true, tf_none);\n+      if (result != error_mark_node)\n+\t{\n+\t  release_tree_vector (args);\n+\t  return result;\n+\t}\n+    }\n+  release_tree_vector (args);\n+\n+  /* If the raw literal didn't work, look for a non-type template\n+     function with parameter pack char....  Call the function with\n+     template parameter characters representing the number.  */\n+  args = make_tree_vector ();\n+  decl = lookup_function_nonclass (name, args, /*block_p=*/false);\n+  if (decl && decl != error_mark_node)\n+    {\n+      tree tmpl_args = make_char_string_pack (num_string);\n+      decl = lookup_template_function (decl, tmpl_args);\n+      result = finish_call_expr (decl, &args, false, true, tf_none);\n+      if (result != error_mark_node)\n+\t{\n+\t  release_tree_vector (args);\n+\t  return result;\n+\t}\n+    }\n+  release_tree_vector (args);\n+\n+  if (result == error_mark_node)\n+    error (\"unable to find user-defined numeric literal operator %qD\", name);\n+\n+  return result;\n+}\n+\n+/* Parse a user-defined string constant.  Returns a call to a user-defined\n+   literal operator taking a character pointer and the length of the string\n+   as arguments.  */\n+static tree\n+cp_parser_userdef_string_literal (cp_token *token)\n+{\n+  tree literal, suffix_id, value;\n+  tree name, decl;\n+  tree result;\n+  VEC(tree,gc) *vec;\n+  int len;\n+\n+  literal = token->u.value;\n+  suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n+  name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n+  value = USERDEF_LITERAL_VALUE (literal);\n+  len = TREE_STRING_LENGTH (value) - 1;\n+\n+  /* Build up a call to the user-defined operator  */\n+  /* Lookup the name we got back from the id-expression.  */\n+  vec = make_tree_vector ();\n+  VEC_safe_push (tree, gc, vec, value);\n+  VEC_safe_push (tree, gc, vec, build_int_cst (size_type_node, len));\n+  decl = lookup_function_nonclass (name, vec, /*block_p=*/false);\n+  if (!decl || decl == error_mark_node)\n+    {\n+      error (\"unable to find user-defined string literal operator %qD\", name);\n+      release_tree_vector (vec);\n+      return error_mark_node;\n+    }\n+  result = finish_call_expr (decl, &vec, false, true, tf_none);\n+  if (result == error_mark_node)\n+    error (\"unable to find valid user-defined string literal operator %qD.\"\n+\t   \"  Possible missing length argument in string literal operator.\",\n+\t   name);\n+  release_tree_vector (vec);\n+\n+  return result;\n+}\n+\n \n /* Basic concepts [gram.basic]  */\n \n@@ -3578,12 +3847,16 @@ cp_parser_primary_expression (cp_parser *parser,\n \t   character-literal\n \t   floating-literal\n \t   string-literal\n-\t   boolean-literal  */\n+\t   boolean-literal\n+\t   pointer-literal\n+\t   user-defined-literal  */\n     case CPP_CHAR:\n     case CPP_CHAR16:\n     case CPP_CHAR32:\n     case CPP_WCHAR:\n     case CPP_NUMBER:\n+      if (TREE_CODE (token->u.value) == USERDEF_LITERAL)\n+\treturn cp_parser_userdef_numeric_literal (parser);\n       token = cp_lexer_consume_token (parser->lexer);\n       if (TREE_CODE (token->u.value) == FIXED_CST)\n \t{\n@@ -3637,11 +3910,22 @@ cp_parser_primary_expression (cp_parser *parser,\n \t}\n       return token->u.value;\n \n+    case CPP_CHAR_USERDEF:\n+    case CPP_CHAR16_USERDEF:\n+    case CPP_CHAR32_USERDEF:\n+    case CPP_WCHAR_USERDEF:\n+      return cp_parser_userdef_char_literal (parser);\n+\n     case CPP_STRING:\n     case CPP_STRING16:\n     case CPP_STRING32:\n     case CPP_WSTRING:\n     case CPP_UTF8STRING:\n+    case CPP_STRING_USERDEF:\n+    case CPP_STRING16_USERDEF:\n+    case CPP_STRING32_USERDEF:\n+    case CPP_WSTRING_USERDEF:\n+    case CPP_UTF8STRING_USERDEF:\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */\n@@ -4477,6 +4761,14 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t  /* If that didn't work, try a conversion-function-id.  */\n \t  if (!cp_parser_parse_definitely (parser))\n \t    id = cp_parser_conversion_function_id (parser);\n+\t  else if (UDLIT_OPER_P (id))\n+\t    {\n+\t      /* 17.6.3.3.5  */\n+\t      const char *name = UDLIT_OP_SUFFIX (id);\n+\t      if (name[0] != '_' && !in_system_header)\n+\t\twarning (0, \"literal operator suffixes not preceded by %<_%>\"\n+\t\t\t    \" are reserved for future standardization\");\n+\t    }\n \n \t  return id;\n \t}\n@@ -5119,7 +5411,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Restore the saved message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n \t/* `typeid' may not appear in an integral constant expression.  */\n-\tif (cp_parser_non_integral_constant_expression(parser, NIC_TYPEID))\n+\tif (cp_parser_non_integral_constant_expression (parser, NIC_TYPEID))\n \t  return error_mark_node;\n       }\n       break;\n@@ -9739,7 +10031,7 @@ cp_parser_declaration (cp_parser* parser)\n   /* If the next token is `extern' and the following token is a string\n      literal, then we have a linkage specification.  */\n   if (token1.keyword == RID_EXTERN\n-      && cp_parser_is_string_literal (&token2))\n+      && cp_parser_is_pure_string_literal (&token2))\n     cp_parser_linkage_specification (parser);\n   /* If the next token is `template', then we have either a template\n      declaration, an explicit instantiation, or an explicit\n@@ -11170,6 +11462,22 @@ cp_parser_operator_function_id (cp_parser* parser)\n   return cp_parser_operator (parser);\n }\n \n+/* Return an identifier node for a user-defined literal operator.\n+   The suffix identifier is chained to the operator name identifier.  */\n+\n+static tree\n+cp_literal_operator_id (const char* name)\n+{\n+  tree identifier;\n+  char *buffer = XNEWVEC (char, strlen (UDLIT_OP_ANSI_PREFIX)\n+\t\t\t      + strlen (name) + 10);\n+  sprintf (buffer, UDLIT_OP_ANSI_FORMAT, name);\n+  identifier = get_identifier (buffer);\n+  /*IDENTIFIER_UDLIT_OPNAME_P (identifier) = 1; If we get a flag someday. */\n+\n+  return identifier;\n+}\n+\n /* Parse an operator.\n \n    operator:\n@@ -11389,6 +11697,37 @@ cp_parser_operator (cp_parser* parser)\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n       return ansi_opname (ARRAY_REF);\n \n+    case CPP_STRING:\n+      if (cxx_dialect == cxx98)\n+\tmaybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n+      if (TREE_STRING_LENGTH (token->u.value) > 2)\n+\t{\n+\t  error (\"expected empty string after %<operator%> keyword\");\n+\t  return error_mark_node;\n+\t}\n+      /* Consume the string.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      /* Look for the suffix identifier.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_NAME)\n+\t{\n+\t  id = cp_parser_identifier (parser);\n+\t  if (id != error_mark_node)\n+\t    {\n+\t      const char *name = IDENTIFIER_POINTER (id);\n+\t      return cp_literal_operator_id (name);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  error (\"expected suffix identifier\");\n+\t  return error_mark_node;\n+\t}\n+\n+    case CPP_STRING_USERDEF:\n+      error (\"missing space between %<\\\"\\\"%> and suffix identifier\");\n+      return error_mark_node;\n+\n     default:\n       /* Anything else is an error.  */\n       break;\n@@ -20583,6 +20922,33 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   /* Finish up.  */\n   finish_template_decl (parameter_list);\n \n+  /* Check the template arguments for a literal operator template.  */\n+  if (decl\n+      && (TREE_CODE (decl) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (decl))\n+      && UDLIT_OPER_P (DECL_NAME (decl)))\n+    {\n+      bool ok = true;\n+      if (parameter_list == NULL_TREE)\n+\tok = false;\n+      else\n+\t{\n+\t  int num_parms = TREE_VEC_LENGTH (parameter_list);\n+\t  if (num_parms != 1)\n+\t    ok = false;\n+\t  else\n+\t    {\n+\t      tree parm_list = TREE_VEC_ELT (parameter_list, 0);\n+\t      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);\n+\t      if (TREE_TYPE (parm) != char_type_node\n+\t\t  || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))\n+\t\tok = false;\n+\t    }\n+\t}\n+      if (!ok)\n+\terror (\"literal operator template %qD has invalid parameter list.\"\n+\t       \"  Expected non-type template argument pack <char...>\",\n+\t       decl);\n+    }\n   /* Register member declarations.  */\n   if (member_p && !friend_p && decl && !DECL_CLASS_TEMPLATE_P (decl))\n     finish_member_declaration (decl);\n@@ -22891,7 +23257,8 @@ cp_parser_objc_interstitial_code (cp_parser* parser)\n   /* If the next token is `extern' and the following token is a string\n      literal, then we have a linkage specification.  */\n   if (token->keyword == RID_EXTERN\n-      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n+      && cp_parser_is_pure_string_literal\n+\t (cp_lexer_peek_nth_token (parser->lexer, 2)))\n     cp_parser_linkage_specification (parser);\n   /* Handle #pragma, if any.  */\n   else if (token->type == CPP_PRAGMA)"}, {"sha": "fa8ab9914c3fb459229313d36f8fb7581d8b8a8c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -7865,6 +7865,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case TEMPLATE_PARM_INDEX:\n     case TRAIT_EXPR:\n     case IDENTIFIER_NODE:\n+    case USERDEF_LITERAL:\n       /* We can see a FIELD_DECL in a pointer-to-member expression.  */\n     case FIELD_DECL:\n     case PARM_DECL:"}, {"sha": "59e1357cb0bf272f70973ce33e1a0c5da91119c7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -8356,3 +8356,121 @@ lvalue_or_else (tree ref, enum lvalue_use use, tsubst_flags_t complain)\n   return 1;\n }\n \n+/* Return true if a user-defined literal operator is a raw operator.  */\n+\n+bool\n+check_raw_literal_operator (const_tree decl)\n+{\n+  tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+  tree argtype;\n+  int arity;\n+  bool maybe_raw_p = false;\n+\n+  /* Count the number and type of arguments and check for ellipsis.  */\n+  for (argtype = argtypes, arity = 0;\n+       argtype && argtype != void_list_node;\n+       ++arity, argtype = TREE_CHAIN (argtype))\n+    {\n+      tree t = TREE_VALUE (argtype);\n+\n+      if (same_type_p (t, const_string_type_node))\n+\tmaybe_raw_p = true;\n+    }\n+  if (!argtype)\n+    return false; /* Found ellipsis.  */\n+\n+  if (!maybe_raw_p || arity != 1)\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Return true if a user-defined literal operator has one of the allowed\n+   argument types.  */\n+\n+bool\n+check_literal_operator_args (const_tree decl,\n+\t\t\t     bool *long_long_unsigned_p, bool *long_double_p)\n+{\n+  tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+  if (processing_template_decl)\n+    return (argtypes == NULL_TREE\n+\t    || same_type_p (TREE_VALUE (argtypes), void_type_node));\n+  else\n+    {\n+      tree argtype;\n+      int arity;\n+      int max_arity = 2;\n+      bool found_string_p = false;\n+      bool maybe_raw_p = false;\n+      bool found_size_p = false;\n+      tree const_wchar_ptr_type_node\n+\t   = build_pointer_type (build_type_variant (wchar_type_node, 1, 0));\n+      tree const_char16_ptr_type_node\n+\t   = build_pointer_type (build_type_variant (char16_type_node, 1, 0));\n+      tree const_char32_ptr_type_node\n+\t   = build_pointer_type (build_type_variant (char32_type_node, 1, 0));\n+\n+      *long_long_unsigned_p = false;\n+      *long_double_p = false;\n+\n+      /* Count the number and type of arguments and check for ellipsis.  */\n+      for (argtype = argtypes, arity = 0;\n+\t   argtype && argtype != void_list_node;\n+\t   argtype = TREE_CHAIN (argtype))\n+\t{\n+\t  tree t = TREE_VALUE (argtype);\n+\t  ++arity;\n+\n+\t  if (same_type_p (t, const_string_type_node))\n+\t    {\n+\t      found_string_p = true;\n+\t      maybe_raw_p = true;\n+\t    }\n+\t  else if (same_type_p (t, const_wchar_ptr_type_node))\n+\t    found_string_p = true;\n+\t  else if (same_type_p (t, const_char16_ptr_type_node))\n+\t    found_string_p = true;\n+\t  else if (same_type_p (t, const_char32_ptr_type_node))\n+\t    found_string_p = true;\n+\t  else if (same_type_p (t, size_type_node))\n+\t    {\n+\t      if (!found_string_p)\n+\t\treturn false;\n+\t      found_size_p = true;\n+\t    }\n+\t  else if (same_type_p (t, long_long_unsigned_type_node))\n+\t    {\n+\t      max_arity = 1;\n+\t      *long_long_unsigned_p = true;\n+\t    }\n+\t  else if (same_type_p (t, long_double_type_node))\n+\t    {\n+\t      max_arity = 1;\n+\t      *long_double_p = true;\n+\t    }\n+\t  else if (same_type_p (t, char_type_node))\n+\t    max_arity = 1;\n+\t  else if (same_type_p (t, wchar_type_node))\n+\t    max_arity = 1;\n+\t  else if (same_type_p (t, char16_type_node))\n+\t    max_arity = 1;\n+\t  else if (same_type_p (t, char32_type_node))\n+\t    max_arity = 1;\n+\t  else\n+\t    return false;\n+\t}\n+      if (!argtype)\n+\treturn false; /* Found ellipsis.  */\n+\n+      if (arity > max_arity)\n+\treturn false;\n+\n+      if (found_string_p && !maybe_raw_p && !found_size_p)\n+\treturn false;\n+\n+      return true;\n+    }\n+}\n+"}, {"sha": "e702ae907c2e44bdcfd05b5affd5b163a65bc74f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1,3 +1,38 @@\n+2011-10-26  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tImplement C++11 user-defined literals.\n+\t* g++.dg/cpp0x/udlit-addr.C: New.\n+\t* g++.dg/cpp0x/udlit-args.C: New.\n+\t* g++.dg/cpp0x/udlit-args-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-clink-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-concat.C: New.\n+\t* g++.dg/cpp0x/udlit-concat-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-constexpr.C: New.\n+\t* g++.dg/cpp0x/udlit-cpp98-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-declare-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-friend.C: New.\n+\t* g++.dg/cpp0x/udlit-general.C: New.\n+\t* g++.dg/cpp0x/udlit-inline.C: New.\n+\t* g++.dg/cpp0x/udlit-linkage-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-member-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-namespace.C: New.\n+\t* g++.dg/cpp0x/udlit-nofunc-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-nonempty-str-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-nospace-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-nosuffix-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-nounder-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-operator-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-raw-str.C: New.\n+\t* g++.dg/cpp0x/udlit-shadow-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-suffix-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-systemheader.C: New.\n+\t* g++.dg/cpp0x/udlit-template.C: New.\n+\t* g++.dg/cpp0x/udlit-tmpl-arg.C: New.\n+\t* g++.dg/cpp0x/udlit-tmpl-arg-neg.C: New.\n+\t* g++.dg/cpp0x/udlit-tmpl-parms.C: New.\n+\t* g++.dg/cpp0x/udlit-tmpl-parms-neg.C: New.\n+\t* g++.dg/cpp0x/udlit_system_header: New.\n+\n 2011-10-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50870"}, {"sha": "7d3286e007be4ac4baefb725e6a61c803814cc7e", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-addr.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-addr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-addr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-addr.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <cstddef>\n+\n+bool operator\"\" _yn(const char*, size_t);\n+\n+typedef bool (*pfunk)(const char*, size_t);\n+pfunk p = &operator\"\" _yn;\n+\n+bool tf = p(\"Hello,\\0 World!\", 14);"}, {"sha": "cb924a249bf612627b6a79723758cbe966f3b883", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-args-neg.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options -std=c++0x }\n+\n+#include <cstddef>\n+\n+class Foo { };\n+\n+Foo\n+operator\"\" _Foo(int *);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(unsigned long int);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(double);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(const float *, std::size_t);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(const wchar_t *, int);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(const char16_t *);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(char...);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(unsigned long long int, char);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(const char *, std::size_t, int);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(long double &);\t// { dg-error \"has invalid argument list\" }\n+\n+Foo\n+operator\"\" _Foo(std::size_t, const char16_t *);\t// { dg-error \"has invalid argument list\" }"}, {"sha": "ca2039c59d31074aa1e16da1b7761a4bab3454e0", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-args.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-args.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options -std=c++0x }\n+\n+#include <cstddef>\n+\n+class Foo { };\n+\n+Foo\n+operator\"\" _Foo(const char *);\n+\n+Foo\n+operator\"\" _Foo(unsigned long long int);\n+\n+Foo\n+operator\"\" _Foo(long double);\n+\n+Foo\n+operator\"\" _Foo(char);\n+\n+Foo\n+operator\"\" _Foo(wchar_t);\n+\n+Foo\n+operator\"\" _Foo(char16_t);\n+\n+Foo\n+operator\"\" _Foo(char32_t);\n+\n+Foo\n+operator\"\" _Foo(const char *, std::size_t);\n+\n+Foo\n+operator\"\" _Foo(const wchar_t *, std::size_t);\n+\n+Foo\n+operator\"\" _Foo(const char16_t *, std::size_t);\n+\n+Foo\n+operator\"\" _Foo(const char32_t *, std::size_t);"}, {"sha": "a80e7244afd294f9fc8953d2600e9d26346270fc", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-clink-neg.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-clink-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-clink-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-clink-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options -std=c++0x }\n+\n+extern \"C\" {\n+\n+int\n+operator\"\" _badclinkage(unsigned long long);\t// { dg-error \"operator with C linkage\" }\n+\n+}"}, {"sha": "61dc2ab02c6b52d91d2c40dc4d9dc5bb592dd43d", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-concat-neg.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <string>\n+\n+std::string operator\"\" _xxx(const char*, size_t);\n+\n+std::string operator\"\" _yyy(const char*, size_t);\n+\n+std::string concat = \"Hello, \"_xxx \"World!\"_yyy;\t// { dg-error \"inconsistent user-defined literal suffixes\" }"}, {"sha": "612bc1d1116cedc3acaf44c692ee4991974b4a2b", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-concat.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-concat.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <string>\n+\n+std::string operator\"\" _www(const char*, size_t);\n+\n+std::string concat01 = \"Hello, \" \"World!\"_www;\n+\n+std::string concat10 = \"Hello, \"_www \"World!\";\n+\n+std::string concat11 = \"Hello, \"_www \"World!\"_www;\n+\n+\n+class Tachyon { };\n+\n+Tachyon operator\"\" _fast(const char*, size_t);\n+\n+int operator\"\" _fast(const char32_t*, size_t);\n+\n+int speedy01 = \"Hello, \" U\"World!\"_fast;\n+\n+int speedy10 = \"Hello, \"_fast U\"World!\";\n+\n+int speedy11 = \"Hello, \"_fast U\"World!\"_fast;"}, {"sha": "40b0dfac53152e787cb1718fd33f65cae1c3844d", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-constexpr.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-constexpr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-constexpr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-constexpr.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr unsigned long long\n+operator\"\" _grow(unsigned long long n)\n+{ return 2 * n; }\n+\n+double buffer[25_grow];"}, {"sha": "cb78a2c9c3e3c80e6c9e4b34d9b037803e1b3028", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-cpp98-neg.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-cpp98-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-cpp98-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-cpp98-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++98\" }\n+\n+#include <cstddef>\n+\n+int\n+operator\"\" _mm(long double m)\t// { dg-warning \"user-defined literals only available with\" }\n+{ return int(1000.0L * m); }\n+\n+int in = 0.0254_mm;\t// { dg-error \"invalid suffix\" }\n+\n+int\n+operator\"\" _Q(const char *, std::size_t)\t// { dg-warning \"user-defined literals only available with\" }\n+{ return 42; }\n+\n+int x = \"Hello\"_Q;\t// { dg-error \"invalid conversion from\" }\n+\n+// { dg-error \"expected\" \"\" { target *-*-* } 15 }"}, {"sha": "7b50c017f01479570658057f082e82228ec11c14", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-declare-neg.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-declare-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//  Check that undeclared literal operator calls and literals give appropriate errors.\n+\n+int i = operator\"\" _Bar('x');  // { dg-error \"was not declared in this scope\" }\n+int j = 'x'_Bar;  // { dg-error \"unable to find user-defined character literal operator\" }\n+\n+int ii = operator\"\" _BarCharStr(\"Howdy, Pardner!\");  // { dg-error \"was not declared in this scope\" }\n+int jj = \"Howdy, Pardner!\"_BarCharStr;  // { dg-error \"unable to find user-defined string literal operator\" }\n+\n+unsigned long long iULL = operator\"\" _BarULL(666ULL);  // { dg-error \"was not declared in this scope\" }\n+unsigned long long jULL = 666_BarULL;  // { dg-error \"unable to find user-defined numeric literal operator\" }\n+\n+long double iLD = operator\"\" _BarLD(666.0L);  // { dg-error \"was not declared in this scope\" }\n+long double jLD = 666.0_BarLD;  // { dg-error \"unable to find user-defined numeric literal operator\" }"}, {"sha": "48a2a1b171d05d58056988535224d40dc8240896", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-embed-quote.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-embed-quote.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-embed-quote.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-embed-quote.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+//  Make sure embedded quotes are not a problem for string and char literals.\n+\n+#include <cstdint>\n+#include <cassert>\n+\n+int operator\"\" _embedchar(char)\n+{ return 41; };\n+\n+int operator\"\" _embedstr(const char*, std::size_t len)\n+{ return 42 + len; };\n+\n+void\n+test()\n+{\n+  int i = '\\''_embedchar;\n+\n+  int j = \"\\\"\"_embedstr;\n+  assert(j == 43);\n+\n+  int k = \"foo\\\"\"_embedstr;\n+  assert(k == 46);\n+\n+  int l = \"\\\"bar\"_embedstr;\n+  assert(l == 46);\n+}\n+\n+int\n+main()\n+{\n+  test();\n+}"}, {"sha": "b3f3ef8a604d30fe7725e9189ab4bfb625269110", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-friend.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-friend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-friend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-friend.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,28 @@\n+// { dg-options -std=c++0x }\n+\n+long double\n+operator\"\" _Hertz(long double);\n+\n+class Foo\n+{\n+public:\n+  Foo() { }\n+\n+  friend Foo operator\"\" _Bar(char);\n+\n+  friend long double\n+  operator\"\" _Hertz(long double omega)\n+  { return omega / 6.28318530717958648; }\n+};\n+\n+Foo\n+operator\"\" _Bar(char)\n+{ return Foo(); }\n+\n+Foo f1 = operator\"\" _Bar('x');\n+\n+Foo f2 = 'x'_Bar;\n+\n+long double fm1 = operator\"\" _Hertz(552.92L);\n+\n+long double fm2 = 552.92_Hertz;"}, {"sha": "9e448ac805014c58c3ce8b122684d404134d2ad7", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-general.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-general.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-general.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-general.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test simple operator declaration and definition.\n+\n+#include <cstring>\n+#include <string>\n+#include <complex>\n+#include <cassert>\n+\n+long double operator\"\" _v(long double);\n+std::string operator\"\" _w(const char16_t*, size_t);\n+unsigned operator\"\" _w(const char*);\n+\n+std::complex<double>\n+operator\"\" _i(long double y)\n+{ return std::complex<double>(0.0L, y); }\n+\n+void\n+test1()\n+{\n+  long double x = operator\"\" _v(1.2L);\n+  assert(x == 2.2L);\n+\n+  std::string s = operator\"\" _w(u\"one\", 3);\n+  assert(s == \"boo\");\n+\n+  unsigned u = operator\"\" _w(\"Hello, World!\");\n+  assert(u == 13U);\n+\n+  std::complex<double> i = operator\"\" _i(2.0);\n+  assert(i == std::complex<double>(0.0, 2.0));\n+}\n+\n+int\n+main()\n+{\n+  test1();\n+}\n+\n+long double\n+operator\"\" _v(long double x)\n+{ return x + 1.0L; }\n+\n+std::string\n+operator\"\" _w(const char16_t*, size_t)\n+{ return std::string(\"boo\"); }\n+\n+unsigned\n+operator\"\" _w(const char* str)\n+{ return strlen(str); }"}, {"sha": "75032c5767990540f98c07b6212cb7835f9cf3e7", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-inline.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-inline.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-inline.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-inline.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//  Literal operators can be inline.\n+\n+inline int\n+operator\"\" _thing1(char cc)\n+{ return 42 * cc; }\n+\n+int operator\"\" _thing2(char cc);\n+\n+class Foo\n+{\n+  int\n+  friend operator\"\" _thing2(char cc)\n+  { return 42 * cc; }\n+};\n+\n+int i = operator\"\" _thing1('x');\n+int j = 'x'_thing1;\n+\n+int iF = operator\"\" _thing2('x');\n+int jF = 'x'_thing2;"}, {"sha": "c2ecede8d48d8ed040fadd1ef914ba8d2ea5f01e", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-linkage-neg.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-linkage-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-linkage-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-linkage-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,7 @@\n+// { dg-options -std=c++0x }\n+\n+extern \"C\"_badlinkage {\t// { dg-error \"expected unqualified-id before\" }\n+\n+int foo();\n+\n+}"}, {"sha": "809df254c0e62e2bec12adc89fcf062aff293a42", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-member-neg.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-member-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++0x }\n+\n+class Foo\n+{\n+public:\n+  Foo() { }\n+  int operator\"\" _Bar(char32_t);  // { dg-error \"must be a non-member function\" }\n+};\n+\n+int i = operator\"\" _Bar(U'x');  // { dg-error \"was not declared in this scope\" }\n+int j = U'x'_Bar;  // { dg-error \"unable to find user-defined character literal operator\" }\n+\n+int\n+Foo::operator\"\" _Bar(char32_t)  // { dg-error \"must be a non-member function\" }\n+{ return 42; }"}, {"sha": "e5d54e519009601ccecb8f589cab41a8f09ccc22", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-namespace.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-namespace.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-namespace.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-namespace.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test simple operator declaration and definition in namespaces.\n+\n+#include <cmath>\n+#include <limits>\n+\n+namespace Long\n+{\n+  long double operator\"\" _LL(long double);\n+}\n+\n+namespace Short\n+{\n+  short\n+  operator\"\" _SS(long double x)\n+  { return std::fmod(x, static_cast<long double>(std::numeric_limits<short>::max())); }\n+}\n+\n+void\n+test1()\n+{\n+  long double x = Long::operator \"\" _LL(1.2L);\n+\n+  using namespace Short;\n+  short s = operator\"\" _SS(1.2L);\n+  short s2 = 1.2_SS;\n+}\n+\n+int\n+main()\n+{\n+  test1();\n+}\n+\n+namespace Long\n+{\n+  long double\n+  operator\"\" _LL(long double x)\n+  { return x + 2.0L; }\n+}"}, {"sha": "6ad79b85b1d8b1c61370d380dfb7ceb142248eaf", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nofunc-neg.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nofunc-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nofunc-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nofunc-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test error on non-function declaration.\n+\n+double operator\"\" _baddecl; // { dg-error \"as non-function\" }\n+\n+template<char...>\n+  int operator\"\" _badtmpldecl; // { dg-error \"as non-function\" }"}, {"sha": "981865f15263c7c6ec4dc0095f0bc6c44c1ee5e9", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nonempty-str-neg.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nonempty-str-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nonempty-str-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nonempty-str-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test error on non-empty string after 'operator' keyword.\n+\n+double operator\"hi\" _badword(long double); // { dg-error \"expected empty string after\" }"}, {"sha": "2b57637a9168d176c21f3f06f43ea4245295e582", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nospace-neg.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nospace-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+float operator \"\"_abc(const char*); // { dg-error \"missing space between|and suffix identifier\" }"}, {"sha": "b90635cd0fc3c0a8b5ba43df78039c2179bd08aa", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nosuffix-neg.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nosuffix-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nosuffix-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nosuffix-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++0x }\n+\n+char32_t\n+operator\"\" (char32_t C)\t// { dg-error \"expected suffix identifier\" }\n+{ return C; }"}, {"sha": "2067bbe561f912733a1dc881add318544de182b7", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-nounder-neg.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nounder-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nounder-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-nounder-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test warning on declaration without leading underscore.\n+\n+long double operator\"\" nounder(long double); // { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" }\n+\n+template<char...>\n+  int operator\"\" nounder(); // { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" }"}, {"sha": "27fdedec766a6225677e80cc47bf45a9bb65e957", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-operator-neg.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-operator-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-operator-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-operator-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//  Can't have *both* literal operator template and raw literal operator.\n+\n+int\n+operator\"\" _abc(const char*)\n+  {\n+    return 42;\n+  }\n+\n+template<char...>\n+  int\n+  operator\"\" _abc() // { dg-error \"literal operator template|conflicts with raw literal operator\" }\n+  {\n+    return 13;\n+  }\n+\n+template<char...>\n+  int\n+  operator\"\" _def()\n+  {\n+    return 12;\n+  }\n+\n+int\n+operator\"\" _def(const char*) // { dg-error \"raw literal operator|conflicts with literal operator template\" }\n+  {\n+    return 43;\n+  }\n+\n+int\n+operator\"\" _ghi(long double)\n+  {\n+    return 42;\n+  }\n+\n+template<char...>\n+  int\n+  operator\"\" _ghi() // OK\n+  {\n+    return 13;\n+  }"}, {"sha": "23633390cf0d494968d91ab9725c8ec4178647df", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-preproc-neg.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-preproc-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-preproc-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-preproc-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+int\n+operator\"\" _badpreproc(const char *str)\n+{ return 0; }\n+\n+#if 123_badpreproc  //  { dg-error \"user-defined literal in preprocessor expression\" }\n+#  error (\"user-defined literal in preprocessor expression\")  //  { dg-error \"user-defined literal in preprocessor expression\" }\n+#endif"}, {"sha": "5c399aff5990f3a56fbc6e23de3510ac52bb59c7", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-raw-op-string-neg.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op-string-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+//  Make sure handing a string to a raw literal generates a sensible error message.\n+\n+int operator\"\" _embedraw(const char*)\n+{ return 41; };\n+\n+int k = \"Boo!\"_embedraw;  //  { dg-error \"unable to find valid user-defined string literal operator\" }"}, {"sha": "3bbf19cb05c809ffaded7fd1e183fd165364b46d", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-raw-op.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-op.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do run }\r\n+// { dg-options \"-std=c++0x\" }\r\n+\r\n+#include <cassert>\r\n+#include <cstring>\r\n+\r\n+int\r\n+operator\"\" _raw_umber(const char * str)\r\n+{\r\n+  return strlen(str);\r\n+}\r\n+\r\n+int\r\n+main()\r\n+{\r\n+  int i = 0123012301230123012301230123012301230123012301230123012301230123_raw_umber;\r\n+  assert( i == 64 );\r\n+\r\n+  int j = 90123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789_raw_umber;\r\n+  assert( j == 101 );\r\n+}\r"}, {"sha": "e94410fd0619c66bd4ae2eaee8832fec7628f493", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-raw-str.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-str.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-str.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-raw-str.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++0x }\n+\n+#include <string>\n+\n+std::string operator\"\" _i18n(const char*, std::size_t);\n+\n+std::string vogon_poem = R\"V0G0N(\n+                O freddled gruntbuggly thy micturations are to me\n+                    As plured gabbleblochits on a lurgid bee.\n+                 Groop, I implore thee my foonting turlingdromes.   \n+              And hooptiously drangle me with crinkly bindlewurdles,\n+  Or I will rend thee in the gobberwarts with my blurlecruncheon, see if I don't.\n+\n+                    (by Prostetnic Vogon Jeltz; see p. 56/57)\n+)V0G0N\"_i18n;"}, {"sha": "6d38252ff2a25a4241bfd2df6d6e7222b678f1ac", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-shadow-neg.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-shadow-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-shadow-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-shadow-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options -std=c++0x }\n+\n+//  Test that the standard suffixes shadow any user-defined suffixes of the same name.\n+long double\n+operator\"\" L(long double x)  // { dg-warning \"floating point suffix|shadowed by implementation\" }\n+{ return x; }\n+\n+unsigned long long int\n+operator\"\" ULL(unsigned long long int k)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return k; }\n+\n+long double\n+operator\"\" l(long double x)  // { dg-warning \"floating point suffix|shadowed by implementation\" }\n+{ return x; }\n+\n+unsigned long long int\n+operator\"\" ull(unsigned long long int k)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return k; }\n+\n+//  Namespaces are no hiding place.\n+namespace Long\n+{\n+\n+long double\n+operator\"\" L(long double x)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return x; }\n+\n+unsigned long long int\n+operator\"\" ULL(unsigned long long int k)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return k; }\n+\n+long double\n+operator\"\" l(long double x)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return x; }\n+\n+unsigned long long int\n+operator\"\" ull(unsigned long long int k)  // { dg-warning \"integer suffix|shadowed by implementation\" }\n+{ return k; }\n+\n+}\n+\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 5 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 9 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 13 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 17 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 25 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 29 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 33 }\n+// { dg-warning \"literal operator suffixes not preceded by|are reserved for future standardization\" \"\" { target *-*-* } 37 }"}, {"sha": "56eab01d7365a9512303e0e76b09a6800dcec080", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-suffix-neg.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-suffix-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-suffix-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-suffix-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++0x }\n+\n+#include <string>\n+\n+std::string operator\"\" 5X(const char*, std::size_t);\t// { dg-error \"expected suffix identifier\" }"}, {"sha": "599c8652a147b4b5ac30443a8ddb78c377fb0cc0", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-systemheader.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-systemheader.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-systemheader.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-systemheader.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options -std=c++0x }\n+\n+#include \"udlit_system_header\""}, {"sha": "6a28f74a22b3bf88febceddd67a993983bb5b733", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-template.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-template.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-template.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-template.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+// Test user-defined literals.\n+// Test template operator declaration and definition.\n+\n+#include <cassert>\n+\n+template<char...>\n+  int operator\"\" _abc();\n+\n+template<>\n+  int\n+  operator\"\" _abc<>()\n+  { return -1; }\n+\n+template<>\n+  int\n+  operator\"\" _abc<'L','U','E'>()\n+  { return 42; }\n+\n+template<>\n+  int\n+  operator\"\" _abc<'6','6','6'>()\n+  { return 21; }\n+\n+int\n+test1()\n+{\n+  int i = operator\"\" _abc<'1','2','3'>();\n+  assert(i == 45);\n+  int universal_meaning = operator\"\" _abc<'L','U','E'>();\n+  assert(universal_meaning == 42);\n+  int b = operator\"\" _abc<'6','6','6'>();\n+  int z = operator\"\" _abc<>();\n+  assert(z == -1);\n+  int j = 123_abc;\n+  assert(j == i);\n+  int jb = 666_abc;\n+  assert(jb == b);\n+}\n+\n+int\n+main()\n+{\n+  test1();\n+}\n+\n+template<char... Chars>\n+  int operator\"\" _abc()\n+  { return 42 + sizeof...(Chars); }"}, {"sha": "e8ccb6f545d556bf623d2bc3acefa779cf698970", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-tmpl-arg-neg.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,4 @@\n+// { dg-options -std=c++0x }\n+\n+template<char...>\n+  int operator\"\" _xyz(unsigned long long);\t// { dg-error \"has invalid argument list\" }"}, {"sha": "6324823fabbb147d22edccec419aa04c17352cc6", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-tmpl-arg.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-arg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,4 @@\n+// { dg-options -std=c++0x }\n+\n+template<char...>\n+  int operator\"\" _abc();"}, {"sha": "4dab4d2f6f097c6eca9301f9316a16471621317b", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-tmpl-parms-neg.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms-neg.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+\n+class Foo { };\n+\n+template<wchar_t...>\n+  Foo operator\"\" _Foo(); // { dg-error \"literal operator template|has invalid parameter list\" }\n+\n+template<char>\n+  Foo operator\"\" _Bar(); // { dg-error \"literal operator template|has invalid parameter list\" }\n+\n+template<typename... Type>\n+  Foo operator\"\" _Bar(); // { dg-error \"literal operator template|has invalid parameter list\" }"}, {"sha": "77456737c70c79923d924011be56316d40578a10", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-tmpl-parms.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-tmpl-parms.C?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options -std=c++0x }\n+\n+class Foo { };\n+\n+template<char...>\n+  Foo operator\"\" _Foo();"}, {"sha": "d541f24f62ac77037b47b960dab9ff74d3b2b1a5", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit_system_header", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit_system_header", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit_system_header", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit_system_header?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -0,0 +1,6 @@\n+\n+#pragma GCC system_header\n+\n+char\n+operator\"\" stdsuffix(char __c)\n+{ return __c/2; }"}, {"sha": "5be923ea1f6c7da1e41300213550924efb3ad64c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1,3 +1,17 @@\n+2011-10-26  Ed Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tImplement C++11 user-defined literals.\n+\t* expr.c: (cpp_interpret_float_suffix, cpp_interpret_int_suffix,\n+\tcpp_userdef_string_remove_type, cpp_userdef_string_add_type,\n+\tcpp_userdef_char_remove_type, cpp_userdef_char_add_type,\n+\tcpp_userdef_string_p, cpp_userdef_char_p, cpp_get_userdef_suffix): New.\n+\t(cpp_classify_number): Classify unrecognized tokens as user-defined\n+\tliterals.\n+\t* include/cpplib.h: Add new tokens for user-defined literals.\n+\t* init.c: Add new preprocessor flag (cxx11).\n+\t* lex.c: (lex_string, lex_raw_string): Handle user-defined literals\n+\tincluding concatenation and promotion with suffixes.\n+\n 2011-10-24  Dodji Seketeli  <dodji@redhat.com>\n \n \t* line-map.c (linemap_macro_map_lookup): Fix logic."}, {"sha": "7bbc72d6f26ac1217a4740bd6bdbf28119d6c84f", "filename": "libcpp/expr.c", "status": "modified", "additions": 176, "deletions": 13, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1,6 +1,6 @@\n /* Parse C expressions for cpplib.\n    Copyright (C) 1987, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2004, 2008, 2009, 2010 Free Software Foundation.\n+   2002, 2004, 2008, 2009, 2010, 2011 Free Software Foundation.\n    Contributed by Per Bothner, 1994.\n \n This program is free software; you can redistribute it and/or modify it\n@@ -185,6 +185,13 @@ interpret_float_suffix (const uchar *s, size_t len)\n \t     q ? CPP_N_MD_Q : CPP_N_DEFAULT));\n }\n \n+/* Return the classification flags for a float suffix.  */\n+unsigned int\n+cpp_interpret_float_suffix (const char *s, size_t len)\n+{\n+  return interpret_float_suffix ((const unsigned char *)s, len);\n+}\n+\n /* Subroutine of cpp_classify_number.  S points to an integer suffix\n    of length LEN, possibly zero. Returns 0 for an invalid suffix, or a\n    flag vector describing the suffix.  */\n@@ -219,18 +226,153 @@ interpret_int_suffix (const uchar *s, size_t len)\n \t     : (l == 1) ? CPP_N_MEDIUM : CPP_N_LARGE));\n }\n \n+/* Return the classification flags for an int suffix.  */\n+unsigned int\n+cpp_interpret_int_suffix (const char *s, size_t len)\n+{\n+  return interpret_int_suffix ((const unsigned char *)s, len);\n+}\n+\n+/* Return the string type corresponding to the the input user-defined string\n+   literal type.  If the input type is not a user-defined string literal\n+   type return the input type.  */\n+enum cpp_ttype\n+cpp_userdef_string_remove_type (enum cpp_ttype type)\n+{\n+  if (type == CPP_STRING_USERDEF)\n+    return CPP_STRING;\n+  else if (type == CPP_WSTRING_USERDEF)\n+    return CPP_WSTRING;\n+  else if (type == CPP_STRING16_USERDEF)\n+    return CPP_STRING16;\n+  else if (type == CPP_STRING32_USERDEF)\n+    return CPP_STRING32;\n+  else if (type == CPP_UTF8STRING_USERDEF)\n+    return CPP_UTF8STRING;\n+  else\n+    return type;\n+}\n+\n+/* Return the user-defined string literal type corresponding to the input\n+   string type.  If the input type is not a string type return the input\n+   type.  */\n+enum cpp_ttype\n+cpp_userdef_string_add_type (enum cpp_ttype type)\n+{\n+  if (type == CPP_STRING)\n+    return CPP_STRING_USERDEF;\n+  else if (type == CPP_WSTRING)\n+    return CPP_WSTRING_USERDEF;\n+  else if (type == CPP_STRING16)\n+    return CPP_STRING16_USERDEF;\n+  else if (type == CPP_STRING32)\n+    return CPP_STRING32_USERDEF;\n+  else if (type == CPP_UTF8STRING)\n+    return CPP_UTF8STRING_USERDEF;\n+  else\n+    return type;\n+}\n+\n+/* Return the char type corresponding to the the input user-defined char\n+   literal type.  If the input type is not a user-defined char literal\n+   type return the input type.  */\n+enum cpp_ttype\n+cpp_userdef_char_remove_type (enum cpp_ttype type)\n+{\n+  if (type == CPP_CHAR_USERDEF)\n+    return CPP_CHAR;\n+  else if (type == CPP_WCHAR_USERDEF)\n+    return CPP_WCHAR;\n+  else if (type == CPP_CHAR16_USERDEF)\n+    return CPP_STRING16;\n+  else if (type == CPP_CHAR32_USERDEF)\n+    return CPP_STRING32;\n+  else\n+    return type;\n+}\n+\n+/* Return the user-defined char literal type corresponding to the input\n+   char type.  If the input type is not a char type return the input\n+   type.  */\n+enum cpp_ttype\n+cpp_userdef_char_add_type (enum cpp_ttype type)\n+{\n+  if (type == CPP_CHAR)\n+    return CPP_CHAR_USERDEF;\n+  else if (type == CPP_WCHAR)\n+    return CPP_WCHAR_USERDEF;\n+  else if (type == CPP_CHAR16)\n+    return CPP_CHAR16_USERDEF;\n+  else if (type == CPP_CHAR32)\n+    return CPP_CHAR32_USERDEF;\n+  else\n+    return type;\n+}\n+\n+/* Return true if the token type is a user-defined string literal.  */\n+bool\n+cpp_userdef_string_p (enum cpp_ttype type)\n+{\n+  if (type == CPP_STRING_USERDEF\n+   || type == CPP_WSTRING_USERDEF\n+   || type == CPP_STRING16_USERDEF\n+   || type == CPP_STRING32_USERDEF\n+   || type == CPP_UTF8STRING_USERDEF)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Return true if the token type is a user-defined char literal.  */\n+bool\n+cpp_userdef_char_p (enum cpp_ttype type)\n+{\n+  if (type == CPP_CHAR_USERDEF\n+   || type == CPP_WCHAR_USERDEF\n+   || type == CPP_CHAR16_USERDEF\n+   || type == CPP_CHAR32_USERDEF)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Extract the suffix from a user-defined literal string or char.  */\n+const char *\n+cpp_get_userdef_suffix (const cpp_token *tok)\n+{\n+  unsigned int len = tok->val.str.len;\n+  const char *text = (const char *)tok->val.str.text;\n+  char delim;\n+  unsigned int i;\n+  for (i = 0; i < len; ++i)\n+    if (text[i] == '\\'' || text[i] == '\"')\n+      break;\n+  if (i == len)\n+    return text + len;\n+  delim = text[i];\n+  for (i = len; i > 0; --i)\n+    if (text[i - 1] == delim)\n+      break;\n+  return text + i;\n+}\n+\n /* Categorize numeric constants according to their field (integer,\n    floating point, or invalid), radix (decimal, octal, hexadecimal),\n-   and type suffixes.  */\n+   and type suffixes.  In C++0X if UD_SUFFIX is non null it will be\n+   assigned any unrecognized suffix for a user-defined literal.  */\n unsigned int\n-cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n+cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n+\t\t     const char **ud_suffix)\n {\n   const uchar *str = token->val.str.text;\n   const uchar *limit;\n   unsigned int max_digit, result, radix;\n   enum {NOT_FLOAT = 0, AFTER_POINT, AFTER_EXPON} float_flag;\n   bool seen_digit;\n \n+  if (ud_suffix)\n+    *ud_suffix = NULL;\n+\n   /* If the lexer has done its job, length one can only be a single\n      digit.  Fast-path this very common case.  */\n   if (token->val.str.len == 1)\n@@ -361,10 +503,19 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n       result = interpret_float_suffix (str, limit - str);\n       if (result == 0)\n \t{\n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"invalid suffix \\\"%.*s\\\" on floating constant\",\n-\t\t     (int) (limit - str), str);\n-\t  return CPP_N_INVALID;\n+\t  if (CPP_OPTION (pfile, user_literals))\n+\t    {\n+\t      if (ud_suffix)\n+\t\t*ud_suffix = (const char *) str;\n+\t      result = CPP_N_LARGE | CPP_N_USERDEF;\n+\t    }\n+\t  else\n+\t    {\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t \"invalid suffix \\\"%.*s\\\" on floating constant\",\n+\t\t\t (int) (limit - str), str);\n+\t      return CPP_N_INVALID;\n+\t    }\n \t}\n \n       /* Traditional C didn't accept any floating suffixes.  */\n@@ -406,10 +557,19 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token)\n       result = interpret_int_suffix (str, limit - str);\n       if (result == 0)\n \t{\n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"invalid suffix \\\"%.*s\\\" on integer constant\",\n-\t\t     (int) (limit - str), str);\n-\t  return CPP_N_INVALID;\n+\t  if (CPP_OPTION (pfile, user_literals))\n+\t    {\n+\t      if (ud_suffix)\n+\t\t*ud_suffix = (const char *) str;\n+\t      result = CPP_N_UNSIGNED | CPP_N_LARGE | CPP_N_USERDEF;\n+\t    }\n+\t  else\n+\t    {\n+\t      cpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t \"invalid suffix \\\"%.*s\\\" on integer constant\",\n+\t\t\t (int) (limit - str), str);\n+\t      return CPP_N_INVALID;\n+\t    }\n \t}\n \n       /* Traditional C only accepted the 'L' suffix.\n@@ -539,7 +699,7 @@ cpp_interpret_integer (cpp_reader *pfile, const cpp_token *token,\n \t    }\n \t}\n \n-      if (overflow)\n+      if (overflow && !(type & CPP_N_USERDEF))\n \tcpp_error (pfile, CPP_DL_PEDWARN,\n \t\t   \"integer constant is too large for its type\");\n       /* If too big to be signed, consider it unsigned.  Only warn for\n@@ -748,7 +908,10 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n   switch (token->type)\n     {\n     case CPP_NUMBER:\n-      temp = cpp_classify_number (pfile, token);\n+      temp = cpp_classify_number (pfile, token, NULL);\n+      if (temp & CPP_N_USERDEF)\n+\tcpp_error (pfile, CPP_DL_ERROR,\n+\t\t   \"user-defined literal in preprocessor expression\");\n       switch (temp & CPP_N_CATEGORY)\n \t{\n \tcase CPP_N_FLOATING:"}, {"sha": "9582b621ab573b8b8835b79869b52871466ead5d", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -131,6 +131,16 @@ struct _cpp_file;\n   TK(OBJC_STRING,\tLITERAL) /* @\"string\" - Objective-C */\t\t\\\n   TK(HEADER_NAME,\tLITERAL) /* <stdio.h> in #include */\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  TK(CHAR_USERDEF,\tLITERAL) /* 'char'_suffix - C++-0x */\t\t\\\n+  TK(WCHAR_USERDEF,\tLITERAL) /* L'char'_suffix - C++-0x */\t\t\\\n+  TK(CHAR16_USERDEF,\tLITERAL) /* u'char'_suffix - C++-0x */\t\t\\\n+  TK(CHAR32_USERDEF,\tLITERAL) /* U'char'_suffix - C++-0x */\t\t\\\n+  TK(STRING_USERDEF,\tLITERAL) /* \"string\"_suffix - C++-0x */\t\t\\\n+  TK(WSTRING_USERDEF,\tLITERAL) /* L\"string\"_suffix - C++-0x */\t\\\n+  TK(STRING16_USERDEF,\tLITERAL) /* u\"string\"_suffix - C++-0x */\t\\\n+  TK(STRING32_USERDEF,\tLITERAL) /* U\"string\"_suffix - C++-0x */\t\\\n+  TK(UTF8STRING_USERDEF,LITERAL) /* u8\"string\"_suffix - C++-0x */\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   TK(COMMENT,\t\tLITERAL) /* Only if output comments.  */\t\\\n \t\t\t\t /* SPELL_LITERAL happens to DTRT.  */\t\\\n   TK(MACRO_ARG,\t\tNONE)\t /* Macro argument.  */\t\t\t\\\n@@ -414,6 +424,9 @@ struct cpp_options\n   /* True for traditional preprocessing.  */\n   unsigned char traditional;\n \n+  /* Nonzero for C++ 2011 Standard user-defnied literals.  */\n+  unsigned char user_literals;\n+\n   /* Holds the name of the target (execution) character set.  */\n   const char *narrow_charset;\n \n@@ -829,13 +842,22 @@ struct cpp_num\n #define CPP_N_FRACT\t0x100000 /* Fract types.  */\n #define CPP_N_ACCUM\t0x200000 /* Accum types.  */\n \n+#define CPP_N_USERDEF\t0x1000000 /* C++0x user-defined literal.  */\n+\n /* Classify a CPP_NUMBER token.  The return value is a combination of\n    the flags from the above sets.  */\n-extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *);\n+extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *,\n+\t\t\t\t     const char **);\n+\n+/* Return the classification flags for a float suffix.  */\n+extern unsigned int cpp_interpret_float_suffix (const char *, size_t);\n+\n+/* Return the classification flags for an int suffix.  */\n+extern unsigned int cpp_interpret_int_suffix (const char *, size_t);\n \n /* Evaluate a token classified as category CPP_N_INTEGER.  */\n extern cpp_num cpp_interpret_integer (cpp_reader *, const cpp_token *,\n-\t\t\t\t      unsigned int type);\n+\t\t\t\t      unsigned int);\n \n /* Sign extend a number, with PRECISION significant bits and all\n    others assumed clear, to fill out a cpp_num structure.  */\n@@ -1005,4 +1027,20 @@ extern int cpp_read_state (cpp_reader *, const char *, FILE *,\n extern void cpp_force_token_locations (cpp_reader *, source_location *);\n extern void cpp_stop_forcing_token_locations (cpp_reader *);\n \n+/* In expr.c */\n+extern enum cpp_ttype cpp_userdef_string_remove_type\n+  (enum cpp_ttype type);\n+extern enum cpp_ttype cpp_userdef_string_add_type\n+  (enum cpp_ttype type);\n+extern enum cpp_ttype cpp_userdef_char_remove_type\n+  (enum cpp_ttype type);\n+extern enum cpp_ttype cpp_userdef_char_add_type\n+  (enum cpp_ttype type);\n+extern bool cpp_userdef_string_p\n+  (enum cpp_ttype type);\n+extern bool cpp_userdef_char_p\n+  (enum cpp_ttype type);\n+extern const char * cpp_get_userdef_suffix\n+  (const cpp_token *);\n+\n #endif /* ! LIBCPP_CPPLIB_H */"}, {"sha": "99b65ba339e1c3650b52fdc1688d89af855c3f71", "filename": "libcpp/init.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -80,22 +80,23 @@ struct lang_flags\n   char digraphs;\n   char uliterals;\n   char rliterals;\n+  char user_literals;\n };\n \n static const struct lang_flags lang_defaults[] =\n-{ /*              c99 c++ xnum xid std  //   digr ulit rlit */\n-  /* GNUC89   */  { 0,  0,  1,   0,  0,   1,   1,   0,   0 },\n-  /* GNUC99   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1 },\n-  /* GNUC1X   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1 },\n-  /* STDC89   */  { 0,  0,  0,   0,  1,   0,   0,   0,   0 },\n-  /* STDC94   */  { 0,  0,  0,   0,  1,   0,   1,   0,   0 },\n-  /* STDC99   */  { 1,  0,  1,   0,  1,   1,   1,   0,   0 },\n-  /* STDC1X   */  { 1,  0,  1,   0,  1,   1,   1,   1,   0 },\n-  /* GNUCXX   */  { 0,  1,  1,   0,  0,   1,   1,   0,   0 },\n-  /* CXX98    */  { 0,  1,  1,   0,  1,   1,   1,   0,   0 },\n-  /* GNUCXX0X */  { 1,  1,  1,   0,  0,   1,   1,   1,   1 },\n-  /* CXX0X    */  { 1,  1,  1,   0,  1,   1,   1,   1,   1 },\n-  /* ASM      */  { 0,  0,  1,   0,  0,   1,   0,   0,   0 }\n+{ /*              c99 c++ xnum xid std  //   digr ulit rlit user_literals */\n+  /* GNUC89   */  { 0,  0,  1,   0,  0,   1,   1,   0,   0,    0 },\n+  /* GNUC99   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1,    0 },\n+  /* GNUC1X   */  { 1,  0,  1,   0,  0,   1,   1,   1,   1,    0 },\n+  /* STDC89   */  { 0,  0,  0,   0,  1,   0,   0,   0,   0,    0 },\n+  /* STDC94   */  { 0,  0,  0,   0,  1,   0,   1,   0,   0,    0 },\n+  /* STDC99   */  { 1,  0,  1,   0,  1,   1,   1,   0,   0,    0 },\n+  /* STDC1X   */  { 1,  0,  1,   0,  1,   1,   1,   1,   0,    0 },\n+  /* GNUCXX   */  { 0,  1,  1,   0,  0,   1,   1,   0,   0,    0 },\n+  /* CXX98    */  { 0,  1,  1,   0,  1,   1,   1,   0,   0,    0 },\n+  /* GNUCXX0X */  { 1,  1,  1,   0,  0,   1,   1,   1,   1,    1 },\n+  /* CXX0X    */  { 1,  1,  1,   0,  1,   1,   1,   1,   1,    1 },\n+  /* ASM      */  { 0,  0,  1,   0,  0,   1,   0,   0,   0,    0 }\n   /* xid should be 1 for GNUC99, STDC99, GNUCXX, CXX98, GNUCXX0X, and\n      CXX0X when no longer experimental (when all uses of identifiers\n      in the compiler have been audited for correct handling of\n@@ -120,6 +121,7 @@ cpp_set_lang (cpp_reader *pfile, enum c_lang lang)\n   CPP_OPTION (pfile, digraphs)\t\t\t = l->digraphs;\n   CPP_OPTION (pfile, uliterals)\t\t\t = l->uliterals;\n   CPP_OPTION (pfile, rliterals)\t\t\t = l->rliterals;\n+  CPP_OPTION (pfile, user_literals)\t\t = l->user_literals;\n }\n \n /* Initialize library global state.  */"}, {"sha": "fcec329d8b4970a67de3271e2476c2d8f700a2db", "filename": "libcpp/lex.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce4f9e4d2643273f11647e97b2c7796a64a73dd/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=3ce4f9e4d2643273f11647e97b2c7796a64a73dd", "patch": "@@ -1478,6 +1478,18 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n     }\n  break_outer_loop:\n \n+  if (CPP_OPTION (pfile, user_literals))\n+    {\n+      /* Grab user defined literal suffix.  */\n+      if (ISIDST (*cur))\n+\t{\n+\t  type = cpp_userdef_string_add_type (type);\n+\t  ++cur;\n+\t}\n+      while (ISIDNUM (*cur))\n+\t++cur;\n+    }\n+\n   pfile->buffer->cur = cur;\n   if (first_buff == NULL)\n     create_literal (pfile, token, base, cur - base, type);\n@@ -1581,6 +1593,19 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n     cpp_error (pfile, CPP_DL_PEDWARN, \"missing terminating %c character\",\n \t       (int) terminator);\n \n+  if (CPP_OPTION (pfile, user_literals))\n+    {\n+      /* Grab user defined literal suffix.  */\n+      if (ISIDST (*cur))\n+\t{\n+\t  type = cpp_userdef_char_add_type (type);\n+\t  type = cpp_userdef_string_add_type (type);\n+          ++cur;\n+\t}\n+      while (ISIDNUM (*cur))\n+\t++cur;\n+    }\n+\n   pfile->buffer->cur = cur;\n   create_literal (pfile, token, base, cur - base, type);\n }"}]}