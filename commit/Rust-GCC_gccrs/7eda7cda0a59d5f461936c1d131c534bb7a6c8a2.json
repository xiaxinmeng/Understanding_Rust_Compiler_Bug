{"sha": "7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VkYTdjZGEwYTU5ZDVmNDYxOTM2YzFkMTMxYzUzNGJiN2E2YzhhMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-19T06:12:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-19T06:12:12Z"}, "message": "xtensa.c (xtensa_expand_block_move): Expand block move to rtl completely.\n\n        * config/xtensa/xtensa.c (xtensa_expand_block_move): Expand block\n        move to rtl completely.\n        (struct meminsnbuf, xtensa_emit_block_move): Remove.\n        (xtensa_find_mode_for_size): Remove.\n        * config/xtensa/xtensa-protos.h (xtensa_emit_block_move): Remove.\n        * config/xtensa/xtensa.md (movmemsi_internal): Remove.\n\nFrom-SVN: r86235", "tree": {"sha": "2218dcb0a9e3fd3189003be37d9272b2773d8f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2218dcb0a9e3fd3189003be37d9272b2773d8f3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/comments", "author": null, "committer": null, "parents": [{"sha": "8804266301bdace8640830a0d2481c10917440e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8804266301bdace8640830a0d2481c10917440e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8804266301bdace8640830a0d2481c10917440e3"}], "stats": {"total": 221, "additions": 70, "deletions": 151}, "files": [{"sha": "e1d71eeab2888e9bd8795358a6f69939e4991f14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "patch": "@@ -1,3 +1,12 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/xtensa/xtensa.c (xtensa_expand_block_move): Expand block\n+\tmove to rtl completely.\n+\t(struct meminsnbuf, xtensa_emit_block_move): Remove.\n+\t(xtensa_find_mode_for_size): Remove.\n+\t* config/xtensa/xtensa-protos.h (xtensa_emit_block_move): Remove.\n+\t* config/xtensa/xtensa.md (movmemsi_internal): Remove.\n+\n 2004-08-18  Richard Henderson  <rth@redhat.com>\n \n \t* config/mcore/mcore.c (mode_from_align): Remove DImode."}, {"sha": "f50286d058f844d6c1dc881b8b6daf6dea89618d", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "patch": "@@ -69,7 +69,6 @@ extern int xtensa_expand_block_move (rtx *);\n extern void xtensa_split_operand_pair (rtx *, enum machine_mode);\n extern int xtensa_emit_move_sequence (rtx *, enum machine_mode);\n extern rtx xtensa_copy_incoming_a7 (rtx);\n-extern void xtensa_emit_block_move (rtx *, rtx *, int);\n extern void xtensa_expand_nonlocal_goto (rtx *);\n extern void xtensa_emit_loop_end (rtx, rtx *);\n extern char *xtensa_emit_call (int, rtx *);"}, {"sha": "8d9a1b7fef8a7a42f0acd8e2179232c7de676e6f", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 61, "deletions": 131, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "patch": "@@ -200,7 +200,6 @@ static rtx gen_int_relational (enum rtx_code, rtx, rtx, int *);\n static rtx gen_float_relational (enum rtx_code, rtx, rtx);\n static rtx gen_conditional_move (rtx);\n static rtx fixup_subreg_mem (rtx);\n-static enum machine_mode xtensa_find_mode_for_size (unsigned);\n static struct machine_function * xtensa_init_machine_status (void);\n static bool xtensa_return_in_msb (tree);\n static void printx (FILE *, signed int);\n@@ -1439,19 +1438,35 @@ xtensa_copy_incoming_a7 (rtx opnd)\n int\n xtensa_expand_block_move (rtx *operands)\n {\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  int bytes = INTVAL (operands[2]);\n-  int align = XINT (operands[3], 0);\n+  static const enum machine_mode mode_from_align[] =\n+  {\n+    VOIDmode, QImode, HImode, VOIDmode, SImode,\n+  };\n+\n+  rtx dst_mem = operands[0];\n+  rtx src_mem = operands[1];\n+  HOST_WIDE_INT bytes, align;\n   int num_pieces, move_ratio;\n+  rtx temp[2];\n+  enum machine_mode mode[2];\n+  int amount[2];\n+  bool active[2];\n+  int phase = 0;\n+  int next;\n+  int offset_ld = 0;\n+  int offset_st = 0;\n+  rtx x;\n \n   /* If this is not a fixed size move, just call memcpy.  */\n   if (!optimize || (GET_CODE (operands[2]) != CONST_INT))\n     return 0;\n \n+  bytes = INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n+\n   /* Anything to move?  */\n   if (bytes <= 0)\n-    return 1;\n+    return 0;\n \n   if (align > MOVE_MAX)\n     align = MOVE_MAX;\n@@ -1461,147 +1476,62 @@ xtensa_expand_block_move (rtx *operands)\n   if (optimize > 2)\n     move_ratio = LARGEST_MOVE_RATIO;\n   num_pieces = (bytes / align) + (bytes % align); /* Close enough anyway.  */\n-  if (num_pieces >= move_ratio)\n+  if (num_pieces > move_ratio)\n     return 0;\n \n-  /* Make sure the memory addresses are valid.  */\n-  operands[0] = validize_mem (dest);\n-  operands[1] = validize_mem (src);\n-\n-  emit_insn (gen_movmemsi_internal (operands[0], operands[1],\n-\t\t\t\t    operands[2], operands[3]));\n-  return 1;\n-}\n-\n-\n-/* Emit a sequence of instructions to implement a block move, trying\n-   to hide load delay slots as much as possible.  Load N values into\n-   temporary registers, store those N values, and repeat until the\n-   complete block has been moved.  N=delay_slots+1.  */\n-\n-struct meminsnbuf\n-{\n-  char template[30];\n-  rtx operands[2];\n-};\n-\n-void\n-xtensa_emit_block_move (rtx *operands, rtx *tmpregs, int delay_slots)\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  int bytes = INTVAL (operands[2]);\n-  int align = XINT (operands[3], 0);\n-  rtx from_addr = XEXP (src, 0);\n-  rtx to_addr = XEXP (dest, 0);\n-  int from_struct = MEM_IN_STRUCT_P (src);\n-  int to_struct = MEM_IN_STRUCT_P (dest);\n-  int offset = 0;\n-  int chunk_size, item_size;\n-  struct meminsnbuf *ldinsns, *stinsns;\n-  const char *ldname, *stname;\n-  enum machine_mode mode;\n-\n-  if (align > MOVE_MAX)\n-    align = MOVE_MAX;\n-  item_size = align;\n-  chunk_size = delay_slots + 1;\n+  x = XEXP (dst_mem, 0);\n+  if (!REG_P (x))\n+    {\n+      x = force_reg (Pmode, x);\n+      dst_mem = replace_equiv_address (dst_mem, x);\n+    }\n \n-  ldinsns = (struct meminsnbuf *)\n-    alloca (chunk_size * sizeof (struct meminsnbuf));\n-  stinsns = (struct meminsnbuf *)\n-    alloca (chunk_size * sizeof (struct meminsnbuf));\n+  x = XEXP (src_mem, 0);\n+  if (!REG_P (x))\n+    {\n+      x = force_reg (Pmode, x);\n+      src_mem = replace_equiv_address (src_mem, x);\n+    }\n \n-  mode = xtensa_find_mode_for_size (item_size);\n-  item_size = GET_MODE_SIZE (mode);\n-  ldname = xtensa_ld_opcodes[(int) mode];\n-  stname = xtensa_st_opcodes[(int) mode];\n+  active[0] = active[1] = false;\n \n-  while (bytes > 0)\n+  do\n     {\n-      int n;\n+      next = phase;\n+      phase ^= 1;\n \n-      for (n = 0; n < chunk_size; n++)\n+      if (bytes > 0)\n \t{\n-\t  rtx addr, mem;\n-\n-\t  if (bytes == 0)\n-\t    {\n-\t      chunk_size = n;\n-\t      break;\n-\t    }\n-\n-\t  if (bytes < item_size)\n-\t    {\n-\t      /* Find a smaller item_size which we can load & store.  */\n-\t      item_size = bytes;\n-\t      mode = xtensa_find_mode_for_size (item_size);\n-\t      item_size = GET_MODE_SIZE (mode);\n-\t      ldname = xtensa_ld_opcodes[(int) mode];\n-\t      stname = xtensa_st_opcodes[(int) mode];\n-\t    }\n-\n-\t  /* Record the load instruction opcode and operands.  */\n-\t  addr = plus_constant (from_addr, offset);\n-\t  mem = gen_rtx_MEM (mode, addr);\n-\t  if (! memory_address_p (mode, addr))\n-\t    abort ();\n-\t  MEM_IN_STRUCT_P (mem) = from_struct;\n-\t  ldinsns[n].operands[0] = tmpregs[n];\n-\t  ldinsns[n].operands[1] = mem;\n-\t  sprintf (ldinsns[n].template, \"%s\\t%%0, %%1\", ldname);\n-\n-\t  /* Record the store instruction opcode and operands.  */\n-\t  addr = plus_constant (to_addr, offset);\n-\t  mem = gen_rtx_MEM (mode, addr);\n-\t  if (! memory_address_p (mode, addr))\n-\t    abort ();\n-\t  MEM_IN_STRUCT_P (mem) = to_struct;\n-\t  stinsns[n].operands[0] = tmpregs[n];\n-\t  stinsns[n].operands[1] = mem;\n-\t  sprintf (stinsns[n].template, \"%s\\t%%0, %%1\", stname);\n-\n-\t  offset += item_size;\n-\t  bytes -= item_size;\n-\t}\n+\t  int next_amount;\n \n-      /* Now output the loads followed by the stores.  */\n-      for (n = 0; n < chunk_size; n++)\n-\toutput_asm_insn (ldinsns[n].template, ldinsns[n].operands);\n-      for (n = 0; n < chunk_size; n++)\n-\toutput_asm_insn (stinsns[n].template, stinsns[n].operands);\n-    }\n-}\n+\t  next_amount = (bytes >= 4 ? 4 : (bytes >= 2 ? 2 : 1));\n+\t  next_amount = MIN (next_amount, align);\n \n+\t  amount[next] = next_amount;\n+\t  mode[next] = mode_from_align[next_amount];\n+\t  temp[next] = gen_reg_rtx (mode[next]);\n \n-static enum machine_mode\n-xtensa_find_mode_for_size (unsigned item_size)\n-{\n-  enum machine_mode mode, tmode;\n+\t  x = adjust_address (src_mem, mode[next], offset_ld);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp[next], x));\n \n-  while (1)\n-    {\n-      mode = VOIDmode;\n-\n-      /* Find mode closest to but not bigger than item_size.  */\n-      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n-\tif (GET_MODE_SIZE (tmode) <= item_size)\n-\t  mode = tmode;\n-      if (mode == VOIDmode)\n-\tabort ();\n-\n-      item_size = GET_MODE_SIZE (mode);\n+\t  offset_ld += next_amount;\n+\t  bytes -= next_amount;\n+\t  active[next] = true;\n+\t}\n \n-      if (xtensa_ld_opcodes[(int) mode]\n-\t  && xtensa_st_opcodes[(int) mode])\n-\tbreak;\n+      if (active[phase])\n+\t{\n+\t  active[phase] = false;\n+\t  \n+\t  x = adjust_address (dst_mem, mode[phase], offset_st);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, x, temp[phase]));\n \n-      /* Cannot load & store this mode; try something smaller.  */\n-      item_size -= 1;\n+\t  offset_st += amount[phase];\n+\t}\n     }\n+  while (active[next]);\n \n-  return mode;\n+  return 1;\n }\n \n "}, {"sha": "448a892d744535d7992213b8bc27fe36824e9178", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eda7cda0a59d5f461936c1d131c534bb7a6c8a2/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=7eda7cda0a59d5f461936c1d131c534bb7a6c8a2", "patch": "@@ -1069,25 +1069,6 @@\n   DONE;\n })\n \n-(define_insn \"movmemsi_internal\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=U\")\n-\t(match_operand:BLK 1 \"memory_operand\" \"U\"))\n-   (use (match_operand:SI 2 \"arith_operand\" \"\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"=&r\"))]\n-  \"\"\n-{\n-  rtx tmpregs[2];\n-  tmpregs[0] = operands[4];\n-  tmpregs[1] = operands[5];\n-  xtensa_emit_block_move (operands, tmpregs, 1);\n-  return \"\";\n-}\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"300\")])\n-\n \f\n ;; Shift instructions.\n "}]}