{"sha": "5a691e986280aa2d53b49f95b71170ff28a76703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE2OTFlOTg2MjgwYWEyZDUzYjQ5Zjk1YjcxMTcwZmYyOGE3NjcwMw==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2009-04-17T21:11:46Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2009-04-17T21:11:46Z"}, "message": "re PR other/31567 (cc1, cc1plus, etc. don't support @file mechanism)\n\n\n\tPR 31567\n\t* gcc.c (create_at_file): New.\n\t(compile_input_file_p): New.\n\t(do_spec_1): Use @args files for %i. Use create_at_file for %o.\n\t* main.c (main): Update call to toplev_main.\n\t* toplev.c (toplev_main): Change signature. Call expandargv.\n\t* toplev.h (toplev_main): Change signature.\n\nFrom-SVN: r146292", "tree": {"sha": "77f7ad02352b14c374885d01832263369b4fe32c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77f7ad02352b14c374885d01832263369b4fe32c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a691e986280aa2d53b49f95b71170ff28a76703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a691e986280aa2d53b49f95b71170ff28a76703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a691e986280aa2d53b49f95b71170ff28a76703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a691e986280aa2d53b49f95b71170ff28a76703/comments", "author": null, "committer": null, "parents": [{"sha": "9eacf7a62a6c26d070718471112637a4400f9859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eacf7a62a6c26d070718471112637a4400f9859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eacf7a62a6c26d070718471112637a4400f9859"}], "stats": {"total": 127, "additions": 93, "deletions": 34}, "files": [{"sha": "cdf5bb0142726fb38eb32e754c02cc57047a367a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a691e986280aa2d53b49f95b71170ff28a76703", "patch": "@@ -1,3 +1,13 @@\n+2009-04-17  Rafael Avila de Espindola  <espindola@google.com>\n+\n+\tPR 31567\n+\t* gcc.c (create_at_file): New.\n+\t(compile_input_file_p): New.\n+\t(do_spec_1): Use @args files for %i. Use create_at_file for %o.\n+\t* main.c (main): Update call to toplev_main.\n+\t* toplev.c (toplev_main): Change signature. Call expandargv.\n+\t* toplev.h (toplev_main): Change signature.\n+\n 2009-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* dwarf2out.c (field_byte_offset): Use the type size as the field size"}, {"sha": "53325b23f392e33dce635b75bb0b3d73781765b7", "filename": "gcc/gcc.c", "status": "modified", "additions": 76, "deletions": 29, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=5a691e986280aa2d53b49f95b71170ff28a76703", "patch": "@@ -4741,6 +4741,49 @@ spec_path (char *path, void *data)\n   return NULL;\n }\n \n+/* Create a temporary FILE with the contents of ARGV. Add @FILE to the\n+   argument list. */\n+\n+static void\n+create_at_file (char **argv)\n+{\n+  char *temp_file = make_temp_file (\"\");\n+  char *at_argument = concat (\"@\", temp_file, NULL);\n+  FILE *f = fopen (temp_file, \"w\");\n+  int status;\n+\n+  if (f == NULL)\n+    fatal (\"could not open temporary response file %s\",\n+\t   temp_file);\n+\n+  status = writeargv (argv, f);\n+\n+  if (status)\n+    fatal (\"could not write to temporary response file %s\",\n+\t   temp_file);\n+\n+  status = fclose (f);\n+\n+  if (EOF == status)\n+    fatal (\"could not close temporary response file %s\",\n+\t   temp_file);\n+\n+  store_arg (at_argument, 0, 0);\n+\n+  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);\n+}\n+\n+/* True if we should compile INFILE. */\n+\n+static bool\n+compile_input_file_p (struct infile *infile)\n+{\n+  if ((!infile->language) || (infile->language[0] != '*'))\n+    if (infile->incompiler == input_file_compiler)\n+      return true;\n+  return false;\n+}\n+\n /* Process the sub-spec SPEC as a portion of a larger spec.\n    This is like processing a whole spec except that we do\n    not initialize at the beginning and we do not supply a\n@@ -5107,9 +5150,37 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t  case 'i':\n \t    if (combine_inputs)\n \t      {\n-\t\tfor (i = 0; (int) i < n_infiles; i++)\n-\t\t  if ((!infiles[i].language) || (infiles[i].language[0] != '*'))\n-\t\t    if (infiles[i].incompiler == input_file_compiler)\n+\t\tif (at_file_supplied)\n+\t\t  {\n+\t\t    /* We are going to expand `%i' to `@FILE', where FILE\n+\t\t       is a newly-created temporary filename.  The filenames\n+\t\t       that would usually be expanded in place of %o will be\n+\t\t       written to the temporary file.  */\n+\t\t    char **argv;\n+\t\t    int n_files = 0;\n+\t\t    int j;\n+\n+\t\t    for (i = 0; i < n_infiles; i++)\n+\t\t      if (compile_input_file_p (&infiles[i]))\n+\t\t\tn_files++;\n+\n+\t\t    argv = (char **) alloca (sizeof (char *) * (n_files + 1));\n+\n+\t\t    /* Copy the strings over.  */\n+\t\t    for (i = 0, j = 0; i < n_infiles; i++)\n+\t\t      if (compile_input_file_p (&infiles[i]))\n+\t\t\t{\n+\t\t\t  argv[j] = CONST_CAST (char *, infiles[i].name);\n+\t\t\t  infiles[i].compiled = true;\n+\t\t\t  j++;\n+\t\t\t}\n+\t\t    argv[j] = NULL;\n+\n+\t\t    create_at_file (argv);\n+\t\t  }\n+\t\telse\n+\t\t  for (i = 0; (int) i < n_infiles; i++)\n+\t\t    if (compile_input_file_p (&infiles[i]))\n \t\t      {\n \t\t\tstore_arg (infiles[i].name, 0, 0);\n \t\t\tinfiles[i].compiled = true;\n@@ -5187,14 +5258,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n                      that would usually be expanded in place of %o will be\n                      written to the temporary file.  */\n \n-                  char *temp_file = make_temp_file (\"\");\n-                  char *at_argument;\n                   char **argv;\n-                  int n_files, j, status;\n-                  FILE *f;\n-\n-                  at_argument = concat (\"@\", temp_file, NULL);\n-                  store_arg (at_argument, 0, 0);\n+                  int n_files, j;\n \n                   /* Convert OUTFILES into a form suitable for writeargv.  */\n \n@@ -5213,25 +5278,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n                       }\n                   argv[j] = NULL;\n \n-                  f = fopen (temp_file, \"w\");\n-\n-                  if (f == NULL)\n-                    fatal (\"could not open temporary response file %s\",\n-                           temp_file);\n-\n-                  status = writeargv (argv, f);\n-\n-                  if (status)\n-                    fatal (\"could not write to temporary response file %s\",\n-                           temp_file);\n-\n-                  status = fclose (f);\n-\n-                  if (EOF == status)\n-                    fatal (\"could not close temporary response file %s\",\n-                           temp_file);\n-\n-                  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);\n+\t\t  create_at_file (argv);\n                 }\n               else\n                 for (i = 0; i < max; i++)"}, {"sha": "3e6c41c39a173ba1a9ce230ffbd27dbe143ec613", "filename": "gcc/main.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmain.c?ref=5a691e986280aa2d53b49f95b71170ff28a76703", "patch": "@@ -32,5 +32,5 @@ int main (int argc, char **argv);\n int\n main (int argc, char **argv)\n {\n-  return toplev_main (argc, (const char **) argv);\n+  return toplev_main (argc, argv);\n }"}, {"sha": "bd709fc2dce98315834fe92bda56de4c5874564d", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5a691e986280aa2d53b49f95b71170ff28a76703", "patch": "@@ -2261,16 +2261,18 @@ do_compile (void)\n    It is not safe to call this function more than once.  */\n \n int\n-toplev_main (unsigned int argc, const char **argv)\n+toplev_main (int argc, char **argv)\n {\n-  save_argv = argv;\n+  expandargv (&argc, &argv);\n+\n+  save_argv = (const char **) argv;\n \n   /* Initialization of GCC's environment, and diagnostics.  */\n   general_init (argv[0]);\n \n   /* Parse the options and do minimal processing; basically just\n      enough to default flags appropriately.  */\n-  decode_options (argc, argv);\n+  decode_options (argc, (const char **) argv);\n \n   init_local_tick ();\n "}, {"sha": "15180c36f9555cfca07010ea5b604c5c4383661e", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a691e986280aa2d53b49f95b71170ff28a76703/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=5a691e986280aa2d53b49f95b71170ff28a76703", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #define skip_leading_substring(whole,  part) \\\n    (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n \n-extern int toplev_main (unsigned int, const char **);\n+extern int toplev_main (int, char **);\n extern int read_integral_parameter (const char *, const char *, const int);\n extern void strip_off_ending (char *, int);\n extern const char *trim_filename (const char *);"}]}