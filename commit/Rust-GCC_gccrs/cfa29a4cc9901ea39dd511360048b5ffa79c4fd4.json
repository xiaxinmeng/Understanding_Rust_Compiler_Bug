{"sha": "cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZhMjlhNGNjOTkwMWVhMzlkZDUxMTM2MDA0OGI1ZmZhNzljNGZkNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@act-europe.fr", "date": "2004-05-02T13:46:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-05-02T13:46:23Z"}, "message": "re PR middle-end/14988 (Analysis of ACATS cxg2006 failures at -O1)\n\n\tPR middle-end/14988\n\t* function.c (assign_stack_local_1): Use BITS_PER_UNIT alignment\n\twhen passed -2 as 'align'.\n\t(put_var_into_stack): Use 'bool' as the type for the three local\n\tpredicates.  Adjust calls to put_reg_into_stack.\n\tWhen passed a CONCAT, instruct put_reg_into_stack to use\n\ta consecutive stack slot for the second part.\n\t(put_reg_into_stack): Remove 'promoted_mode' parameter, add\n\t'consecutive_p' parameter.  Turn the three predicates into 'bool'\n\tparameters.  Retrieve the register mode from 'reg'.\n\tWhen consecutive_p is true, instruct assign_stack_local_1 to use\n\tBITS_PER_UNIT alignment.\n\t(put_addressof_into_stack): Use 'bool' as the type for the two\n\tlocal predicates. Adjust call to put_reg_into_stack.\n\nFrom-SVN: r81411", "tree": {"sha": "313c3b329517332ee278f0c94e8ae237fb8952c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/313c3b329517332ee278f0c94e8ae237fb8952c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4/comments", "author": null, "committer": null, "parents": [{"sha": "fc627530050e2fa95aa19ae67fa6e0fbad552696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc627530050e2fa95aa19ae67fa6e0fbad552696", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc627530050e2fa95aa19ae67fa6e0fbad552696"}], "stats": {"total": 82, "additions": 54, "deletions": 28}, "files": [{"sha": "91ef838033f26044a188deea2a329de19982a960", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "patch": "@@ -1,3 +1,20 @@\n+2004-05-02  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\tPR middle-end/14988\n+\t* function.c (assign_stack_local_1): Use BITS_PER_UNIT alignment\n+\twhen passed -2 as 'align'.\n+\t(put_var_into_stack): Use 'bool' as the type for the three local\n+\tpredicates.  Adjust calls to put_reg_into_stack.\n+\tWhen passed a CONCAT, instruct put_reg_into_stack to use\n+\ta consecutive stack slot for the second part.\n+\t(put_reg_into_stack): Remove 'promoted_mode' parameter, add\n+\t'consecutive_p' parameter.  Turn the three predicates into 'bool'\n+\tparameters.  Retrieve the register mode from 'reg'.\n+\tWhen consecutive_p is true, instruct assign_stack_local_1 to use\n+\tBITS_PER_UNIT alignment.\n+\t(put_addressof_into_stack): Use 'bool' as the type for the two\n+\tlocal predicates. Adjust call to put_reg_into_stack.\n+\n 2004-05-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* fold-const.c (fold_convert_const, fold): Add missing"}, {"sha": "8ce5ef5ef79c277423b99ec05f2cc09797a6a0b9", "filename": "gcc/function.c", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa29a4cc9901ea39dd511360048b5ffa79c4fd4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cfa29a4cc9901ea39dd511360048b5ffa79c4fd4", "patch": "@@ -236,7 +236,7 @@ static rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int,\n \t\t\t\t struct function *);\n static struct temp_slot *find_temp_slot_from_address (rtx);\n static void put_reg_into_stack (struct function *, rtx, tree, enum machine_mode,\n-\t\t\t\tenum machine_mode, int, unsigned int, int, htab_t);\n+\t\t\t\tunsigned int, bool, bool, bool, htab_t);\n static void schedule_fixup_var_refs (struct function *, rtx, tree, enum machine_mode,\n \t\t\t\t     htab_t);\n static void fixup_var_refs (rtx, enum machine_mode, int, rtx, htab_t);\n@@ -506,6 +506,7 @@ get_frame_size (void)\n    ALIGN controls the amount of alignment for the address of the slot:\n    0 means according to MODE,\n    -1 means use BIGGEST_ALIGNMENT and round size to multiple of that,\n+   -2 means use BITS_PER_UNIT,\n    positive specifies alignment boundary in bits.\n \n    We do not round to stack_boundary here.\n@@ -543,6 +544,8 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n       alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n       size = CEIL_ROUND (size, alignment);\n     }\n+  else if (align == -2)\n+    alignment = 1; /* BITS_PER_UNIT / BITS_PER_UNIT */\n   else\n     alignment = align / BITS_PER_UNIT;\n \n@@ -1291,9 +1294,9 @@ put_var_into_stack (tree decl, int rescan)\n   enum machine_mode promoted_mode, decl_mode;\n   struct function *function = 0;\n   tree context;\n-  int can_use_addressof;\n-  int volatilep = TREE_CODE (decl) != SAVE_EXPR && TREE_THIS_VOLATILE (decl);\n-  int usedp = (TREE_USED (decl)\n+  bool can_use_addressof_p;\n+  bool volatile_p = TREE_CODE (decl) != SAVE_EXPR && TREE_THIS_VOLATILE (decl);\n+  bool used_p = (TREE_USED (decl)\n \t       || (TREE_CODE (decl) != SAVE_EXPR && DECL_INITIAL (decl) != 0));\n \n   context = decl_function_context (decl);\n@@ -1340,7 +1343,7 @@ put_var_into_stack (tree decl, int rescan)\n   /* If this variable lives in the current function and we don't need to put it\n      in the stack for the sake of setjmp or the non-locality, try to keep it in\n      a register until we know we actually need the address.  */\n-  can_use_addressof\n+  can_use_addressof_p\n     = (function == 0\n        && ! (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl))\n        && optimize > 0\n@@ -1353,19 +1356,20 @@ put_var_into_stack (tree decl, int rescan)\n \n   /* If we can't use ADDRESSOF, make sure we see through one we already\n      generated.  */\n-  if (! can_use_addressof && GET_CODE (reg) == MEM\n+  if (! can_use_addressof_p\n+      && GET_CODE (reg) == MEM\n       && GET_CODE (XEXP (reg, 0)) == ADDRESSOF)\n     reg = XEXP (XEXP (reg, 0), 0);\n \n   /* Now we should have a value that resides in one or more pseudo regs.  */\n \n   if (GET_CODE (reg) == REG)\n     {\n-      if (can_use_addressof)\n+      if (can_use_addressof_p)\n \tgen_mem_addressof (reg, decl, rescan);\n       else\n-\tput_reg_into_stack (function, reg, TREE_TYPE (decl), promoted_mode,\n-\t\t\t    decl_mode, volatilep, 0, usedp, 0);\n+\tput_reg_into_stack (function, reg, TREE_TYPE (decl), decl_mode,\n+\t\t\t    0, volatile_p, used_p, false, 0);\n \n \t  /* If this was previously a MEM but we've removed the ADDRESSOF,\n \t     set this address into that MEM so we always use the same\n@@ -1387,14 +1391,14 @@ put_var_into_stack (tree decl, int rescan)\n #ifdef FRAME_GROWS_DOWNWARD\n       /* Since part 0 should have a lower address, do it second.  */\n       put_reg_into_stack (function, hipart, part_type, part_mode,\n-\t\t\t  part_mode, volatilep, 0, 0, 0);\n+\t\t\t  0, volatile_p, false, false, 0);\n       put_reg_into_stack (function, lopart, part_type, part_mode,\n-\t\t\t  part_mode, volatilep, 0, 0, 0);\n+\t\t\t  0, volatile_p, false, true, 0);\n #else\n       put_reg_into_stack (function, lopart, part_type, part_mode,\n-\t\t\t  part_mode, volatilep, 0, 0, 0);\n+\t\t\t  0, volatile_p, false, false, 0);\n       put_reg_into_stack (function, hipart, part_type, part_mode,\n-\t\t\t  part_mode, volatilep, 0, 0, 0);\n+\t\t\t  0, volatile_p, false, true, 0);\n #endif\n \n       /* Change the CONCAT into a combined MEM for both parts.  */\n@@ -1415,7 +1419,7 @@ put_var_into_stack (tree decl, int rescan)\n       /* Prevent sharing of rtl that might lose.  */\n       if (GET_CODE (XEXP (reg, 0)) == PLUS)\n \tXEXP (reg, 0) = copy_rtx (XEXP (reg, 0));\n-      if (usedp && rescan)\n+      if (used_p && rescan)\n \t{\n \t  schedule_fixup_var_refs (function, reg, TREE_TYPE (decl),\n \t\t\t\t   promoted_mode, 0);\n@@ -1429,20 +1433,24 @@ put_var_into_stack (tree decl, int rescan)\n \n /* Subroutine of put_var_into_stack.  This puts a single pseudo reg REG\n    into the stack frame of FUNCTION (0 means the current function).\n+   TYPE is the user-level data type of the value hold in the register.\n    DECL_MODE is the machine mode of the user-level data type.\n-   PROMOTED_MODE is the machine mode of the register.\n-   VOLATILE_P is nonzero if this is for a \"volatile\" decl.\n-   USED_P is nonzero if this reg might have already been used in an insn.  */\n+   ORIGINAL_REGNO must be set if the real regno is not visible in REG.\n+   VOLATILE_P is true if this is for a \"volatile\" decl.\n+   USED_P is true if this reg might have already been used in an insn.\n+   CONSECUTIVE_P is true if the stack slot assigned to reg must be\n+   consecutive with the previous stack slot.  */\n \n static void\n put_reg_into_stack (struct function *function, rtx reg, tree type,\n-\t\t    enum machine_mode promoted_mode,\n-\t\t    enum machine_mode decl_mode, int volatile_p,\n-\t\t    unsigned int original_regno, int used_p, htab_t ht)\n+\t\t    enum machine_mode decl_mode, unsigned int original_regno,\n+\t\t    bool volatile_p, bool used_p, bool consecutive_p,\n+\t\t    htab_t ht)\n {\n   struct function *func = function ? function : cfun;\n-  rtx new = 0;\n+  enum machine_mode mode = GET_MODE (reg);\n   unsigned int regno = original_regno;\n+  rtx new = 0;\n \n   if (regno == 0)\n     regno = REGNO (reg);\n@@ -1455,7 +1463,8 @@ put_reg_into_stack (struct function *function, rtx reg, tree type,\n     }\n \n   if (new == 0)\n-    new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode), 0, func);\n+    new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode),\n+\t\t\t\tconsecutive_p ? -2 : 0, func);\n \n   PUT_CODE (reg, MEM);\n   PUT_MODE (reg, decl_mode);\n@@ -1477,7 +1486,7 @@ put_reg_into_stack (struct function *function, rtx reg, tree type,\n     }\n \n   if (used_p)\n-    schedule_fixup_var_refs (function, reg, type, promoted_mode, ht);\n+    schedule_fixup_var_refs (function, reg, type, mode, ht);\n }\n \n /* Make sure that all refs to the variable, previously made\n@@ -2918,7 +2927,7 @@ static void\n put_addressof_into_stack (rtx r, htab_t ht)\n {\n   tree decl, type;\n-  int volatile_p, used_p;\n+  bool volatile_p, used_p;\n \n   rtx reg = XEXP (r, 0);\n \n@@ -2937,12 +2946,12 @@ put_addressof_into_stack (rtx r, htab_t ht)\n   else\n     {\n       type = NULL_TREE;\n-      volatile_p = 0;\n-      used_p = 1;\n+      volatile_p = false;\n+      used_p = true;\n     }\n \n-  put_reg_into_stack (0, reg, type, GET_MODE (reg), GET_MODE (reg),\n-\t\t      volatile_p, ADDRESSOF_REGNO (r), used_p, ht);\n+  put_reg_into_stack (0, reg, type, GET_MODE (reg), ADDRESSOF_REGNO (r),\n+\t\t      volatile_p, used_p, false, ht);\n }\n \n /* List of replacements made below in purge_addressof_1 when creating"}]}