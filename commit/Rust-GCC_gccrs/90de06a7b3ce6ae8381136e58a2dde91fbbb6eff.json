{"sha": "90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "node_id": "C_kwDOANBUbNoAKDkwZGUwNmE3YjNjZTZhZTgzODExMzZlNThhMmRkZTkxZmJiYjZlZmY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-18T15:05:13Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-11-18T15:05:13Z"}, "message": "c++: template-id ADL and partial instantiation [PR99911]\n\nHere when partially instantiating the call get<U>(T{}) with T=N::A\n(for which earlier unqualified name lookup for 'get' found nothing)\nthe arguments after substitution are no longer dependent but the callee\nstill is, so perform_koenig_lookup postpones ADL.  But then we go on to\ndiagnose the unresolved template name anyway, as if ADL was already\nperformed and failed.\n\nThis patch fixes this by avoiding the error path in question when the\ntemplate arguments of an unresolved template-id are still dependent,\nmirroring the dependence check in perform_koenig_lookup.\n\n\tPR c++/99911\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (tsubst_copy_and_build) <case CALL_EXPR>: Don't diagnose\n\tname lookup failure if the arguments to an unresolved template\n\tname are still dependent.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/fn-template24.C: New test.", "tree": {"sha": "8681379a56f7d6cf6cfc28b07f4d6cd631b94939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8681379a56f7d6cf6cfc28b07f4d6cd631b94939"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff/comments", "author": null, "committer": null, "parents": [{"sha": "6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa8e0896c6ec96eddcedb2b92502a7bbb525c03"}], "stats": {"total": 20, "additions": 19, "deletions": 1}, "files": [{"sha": "ad51c07347b543f535c7023971df63f5b0dcb457", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "patch": "@@ -20434,7 +20434,9 @@ tsubst_copy_and_build (tree t,\n \tif (function != NULL_TREE\n \t    && (identifier_p (function)\n \t\t|| (TREE_CODE (function) == TEMPLATE_ID_EXPR\n-\t\t    && identifier_p (TREE_OPERAND (function, 0))))\n+\t\t    && identifier_p (TREE_OPERAND (function, 0))\n+\t\t    && !any_dependent_template_arguments_p (TREE_OPERAND\n+\t\t\t\t\t\t\t    (function, 1))))\n \t    && !any_type_dependent_arguments_p (call_args))\n \t  {\n \t    if (TREE_CODE (function) == TEMPLATE_ID_EXPR)"}, {"sha": "b444ac6a273428f31b76e21008b2a34f47aaed26", "filename": "gcc/testsuite/g++.dg/cpp2a/fn-template24.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90de06a7b3ce6ae8381136e58a2dde91fbbb6eff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template24.C?ref=90de06a7b3ce6ae8381136e58a2dde91fbbb6eff", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/99911\n+// { dg-do compile { target c++20 } }\n+\n+namespace N {\n+  struct A { };\n+  template<class T> void get(A);\n+};\n+\n+template<class T>\n+auto f() {\n+  return []<class U>(U) { get<U>(T{}); };\n+}\n+\n+int main() {\n+  f<N::A>()(0);\n+}"}]}