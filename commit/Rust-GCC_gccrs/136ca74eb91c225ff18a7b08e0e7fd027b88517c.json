{"sha": "136ca74eb91c225ff18a7b08e0e7fd027b88517c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM2Y2E3NGViOTFjMjI1ZmYxOGE3YjA4ZTBlN2ZkMDI3Yjg4NTE3Yw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-11-09T09:11:17Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-11-09T09:11:17Z"}, "message": "GCOV: support multiple functions per a line (PR gcov-profile/48463)\n\n2017-11-09  Martin Liska  <mliska@suse.cz>\n\n\tPR gcov-profile/48463\n\t* coverage.c (coverage_begin_function): Output also end locus\n\tof a function and information whether the function is\n\tartificial.\n\t* gcov-dump.c (tag_function): Parse and print the information.\n\t* gcov.c (INCLUDE_MAP): Add include.\n\t(INCLUDE_SET): Likewise.\n\t(struct line_info): Move earlier in the source file because\n\tof vector<line_info> in function_info structure.\n\t(line_info::line_info): Likewise.\n\t(line_info::has_block): Likewise.\n\t(struct source_info): Add new member index.\n\t(source_info::get_functions_at_location): New function.\n\t(function_info::group_line_p): New function.\n\t(output_intermediate_line): New function.\n\t(output_intermediate_file): Use the mentioned function.\n\t(struct function_start): New.\n\t(struct function_start_pair_hash): Likewise.\n\t(process_file): Add code that identifies group functions.\n\tAssign lines either to global or function scope.\n\t(generate_results): Skip artificial functions.\n\t(find_source): Assign index for each source file.\n\t(read_graph_file): Read new flag artificial and end_line.\n\t(add_line_counts): Assign it either to global of function scope.\n\t(accumulate_line_counts): Isolate core of the function to\n\taccumulate_line_info and call it for both function and global\n\tscope lines.\n\t(accumulate_line_info): New function.\n\t(output_line_beginning): Fix GNU coding style.\n\t(print_source_line): New function.\n\t(output_line_details): Likewise.\n\t(output_function_details): Likewise.\n\t(output_lines): Iterate both source (global) scope and function\n\tscope.\n\t(struct function_line_start_cmp): New class.\n\t* doc/gcov.texi: Reflect changes in documentation.\n\nFrom-SVN: r254562", "tree": {"sha": "3d35f88384d1fc66a1a463a1b060b85bc366a37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d35f88384d1fc66a1a463a1b060b85bc366a37d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/136ca74eb91c225ff18a7b08e0e7fd027b88517c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136ca74eb91c225ff18a7b08e0e7fd027b88517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/136ca74eb91c225ff18a7b08e0e7fd027b88517c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/136ca74eb91c225ff18a7b08e0e7fd027b88517c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bc322a11bec51aceb463fb2336198645dca993f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bc322a11bec51aceb463fb2336198645dca993f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bc322a11bec51aceb463fb2336198645dca993f"}], "stats": {"total": 1238, "additions": 882, "deletions": 356}, "files": [{"sha": "12fbaa0ac73fe29018f3f3e1afb5d38f550c166a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -1,3 +1,42 @@\n+2017-11-09  Martin Liska  <mliska@suse.cz>\n+\n+\tPR gcov-profile/48463\n+\t* coverage.c (coverage_begin_function): Output also end locus\n+\tof a function and information whether the function is\n+\tartificial.\n+\t* gcov-dump.c (tag_function): Parse and print the information.\n+\t* gcov.c (INCLUDE_MAP): Add include.\n+\t(INCLUDE_SET): Likewise.\n+\t(struct line_info): Move earlier in the source file because\n+\tof vector<line_info> in function_info structure.\n+\t(line_info::line_info): Likewise.\n+\t(line_info::has_block): Likewise.\n+\t(struct source_info): Add new member index.\n+\t(source_info::get_functions_at_location): New function.\n+\t(function_info::group_line_p): New function.\n+\t(output_intermediate_line): New function.\n+\t(output_intermediate_file): Use the mentioned function.\n+\t(struct function_start): New.\n+\t(struct function_start_pair_hash): Likewise.\n+\t(process_file): Add code that identifies group functions.\n+\tAssign lines either to global or function scope.\n+\t(generate_results): Skip artificial functions.\n+\t(find_source): Assign index for each source file.\n+\t(read_graph_file): Read new flag artificial and end_line.\n+\t(add_line_counts): Assign it either to global of function scope.\n+\t(accumulate_line_counts): Isolate core of the function to\n+\taccumulate_line_info and call it for both function and global\n+\tscope lines.\n+\t(accumulate_line_info): New function.\n+\t(output_line_beginning): Fix GNU coding style.\n+\t(print_source_line): New function.\n+\t(output_line_details): Likewise.\n+\t(output_function_details): Likewise.\n+\t(output_lines): Iterate both source (global) scope and function\n+\tscope.\n+\t(struct function_line_start_cmp): New class.\n+\t* doc/gcov.texi: Reflect changes in documentation.\n+\n 2017-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/82837"}, {"sha": "f57897b83143be3d0355cc8cfb8d756b65988340", "filename": "gcc/coverage.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -663,8 +663,15 @@ coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)\n   gcov_write_unsigned (cfg_checksum);\n   gcov_write_string (IDENTIFIER_POINTER\n \t\t     (DECL_ASSEMBLER_NAME (current_function_decl)));\n+  gcov_write_unsigned (DECL_ARTIFICIAL (current_function_decl));\n   gcov_write_filename (xloc.file);\n   gcov_write_unsigned (xloc.line);\n+  gcov_write_unsigned (xloc.column);\n+\n+  expanded_location endloc = expand_location (cfun->function_end_locus);\n+\n+  /* Function can start in a single file and end in another one.  */\n+  gcov_write_unsigned (endloc.file == xloc.file ? endloc.line : xloc.line);\n   gcov_write_length (offset);\n \n   return !gcov_is_error ();"}, {"sha": "6f6a92c131a91f168b3a56752ecb5a467aaea94f", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 240, "deletions": 89, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -193,32 +193,63 @@ Write counts in human readable format (like 24k).\n \n @smallexample\n file:@var{source_file_name}\n-function:@var{line_number},@var{execution_count},@var{function_name}\n+function:@var{start_line_number},@var{end_line_number},@var{execution_count},@var{function_name}\n lcount:@var{line number},@var{execution_count},@var{has_unexecuted_block}\n branch:@var{line_number},@var{branch_coverage_type}\n \n Where the @var{branch_coverage_type} is\n    notexec (Branch not executed)\n    taken (Branch executed and taken)\n    nottaken (Branch executed, but not taken)\n+@end smallexample\n \n There can be multiple @var{file} entries in an intermediate gcov\n file. All entries following a @var{file} pertain to that source file\n-until the next @var{file} entry.\n-@end smallexample\n+until the next @var{file} entry.  If there are multiple functions that\n+start on a single line, then corresponding lcount is repeated multiple\n+times.\n \n Here is a sample when @option{-i} is used in conjunction with @option{-b} option:\n \n @smallexample\n-file:array.cc\n-function:11,1,_Z3sumRKSt6vectorIPiSaIS0_EE\n-function:22,1,main\n-lcount:11,1,0\n-lcount:12,1,0\n-lcount:14,1,0\n-branch:14,taken\n-lcount:26,1,0\n-branch:28,nottaken\n+file:tmp.cpp\n+function:7,7,0,_ZN3FooIcEC2Ev\n+function:7,7,1,_ZN3FooIiEC2Ev\n+function:8,8,0,_ZN3FooIcE3incEv\n+function:8,8,2,_ZN3FooIiE3incEv\n+function:18,37,1,main\n+lcount:7,0,1\n+lcount:7,1,0\n+lcount:8,0,1\n+lcount:8,2,0\n+lcount:18,1,0\n+lcount:21,1,0\n+branch:21,taken\n+branch:21,nottaken\n+lcount:23,1,0\n+branch:23,taken\n+branch:23,nottaken\n+lcount:24,1,0\n+branch:24,taken\n+branch:24,nottaken\n+lcount:25,1,0\n+lcount:27,11,0\n+branch:27,taken\n+branch:27,taken\n+lcount:28,10,0\n+lcount:30,1,1\n+branch:30,nottaken\n+branch:30,taken\n+lcount:32,1,0\n+branch:32,nottaken\n+branch:32,taken\n+lcount:33,0,1\n+branch:33,notexec\n+branch:33,notexec\n+lcount:35,1,0\n+branch:35,taken\n+branch:35,nottaken\n+lcount:36,1,0\n @end smallexample\n \n @item -k\n@@ -391,79 +422,158 @@ source file compiled with @option{-fprofile-arcs}, an accompanying\n \n Running @command{gcov} with your program's source file names as arguments\n will now produce a listing of the code along with frequency of execution\n-for each line.  For example, if your program is called @file{tmp.c}, this\n+for each line.  For example, if your program is called @file{tmp.cpp}, this\n is what you see when you use the basic @command{gcov} facility:\n \n @smallexample\n-$ gcc -fprofile-arcs -ftest-coverage tmp.c\n+$ g++ -fprofile-arcs -ftest-coverage tmp.cpp\n $ a.out\n-$ gcov tmp.c\n-File 'tmp.c'\n-Lines executed:90.00% of 10\n-Creating 'tmp.c.gcov'\n+$ gcov tmp.cpp -m\n+File 'tmp.cpp'\n+Lines executed:92.86% of 14\n+Creating 'tmp.cpp.gcov'\n @end smallexample\n \n-The file @file{tmp.c.gcov} contains output from @command{gcov}.\n+The file @file{tmp.cpp.gcov} contains output from @command{gcov}.\n Here is a sample:\n \n @smallexample\n-        -:    0:Source:tmp.c\n+        -:    0:Source:tmp.cpp\n         -:    0:Graph:tmp.gcno\n         -:    0:Data:tmp.gcda\n         -:    0:Runs:1\n         -:    0:Programs:1\n         -:    1:#include <stdio.h>\n         -:    2:\n-        -:    3:int main (void)\n-        1:    4:@{\n-        1:    5:  int i, total;\n-        -:    6:\n-        1:    7:  total = 0;\n-        -:    8:\n-       11:    9:  for (i = 0; i < 10; i++)\n-       10:   10:    total += i;\n-        -:   11:\n-        1:   12:  if (total != 45)\n-    #####:   13:    printf (\"Failure\\n\");\n-        -:   14:  else\n-        1:   15:    printf (\"Success\\n\");\n-        1:   16:  return 0;\n-        -:   17:@}\n+        -:    3:template<class T>\n+        -:    4:class Foo\n+        -:    5:@{\n+        -:    6:  public:\n+       1*:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<char>::Foo():\n+    #####:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<int>::Foo():\n+        1:    7:  Foo(): b (1000) @{@}\n+------------------\n+       2*:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<char>::inc():\n+    #####:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<int>::inc():\n+        2:    8:  void inc () @{ b++; @}\n+------------------\n+        -:    9:\n+        -:   10:  private:\n+        -:   11:  int b;\n+        -:   12:@};\n+        -:   13:\n+        -:   14:template class Foo<int>;\n+        -:   15:template class Foo<char>;\n+        -:   16:\n+        -:   17:int\n+        1:   18:main (void)\n+        -:   19:@{\n+        -:   20:  int i, total;\n+        1:   21:  Foo<int> counter;\n+        -:   22:\n+        1:   23:  counter.inc();\n+        1:   24:  counter.inc();\n+        1:   25:  total = 0;\n+        -:   26:\n+       11:   27:  for (i = 0; i < 10; i++)\n+       10:   28:    total += i;\n+        -:   29:\n+       1*:   30:  int v = total > 100 ? 1 : 2;\n+        -:   31:\n+        1:   32:  if (total != 45)\n+    #####:   33:    printf (\"Failure\\n\");\n+        -:   34:  else\n+        1:   35:    printf (\"Success\\n\");\n+        1:   36:  return 0;\n+        -:   37:@}\n @end smallexample\n \n+Note that line 7 is shown in the report multiple times.  First occurrence\n+presents total number of execution of the line and the next two belong\n+to instances of class Foo constructors.  As you can also see, line 30 contains\n+some unexecuted basic blocks and thus execution count has asterisk symbol.\n+\n When you use the @option{-a} option, you will get individual block\n counts, and the output looks like this:\n \n @smallexample\n-        -:    0:Source:tmp.c\n+        -:    0:Source:tmp.cpp\n         -:    0:Graph:tmp.gcno\n         -:    0:Data:tmp.gcda\n         -:    0:Runs:1\n         -:    0:Programs:1\n         -:    1:#include <stdio.h>\n         -:    2:\n-        -:    3:int main (void)\n-        1:    4:@{\n-        1:    4-block  0\n-        1:    5:  int i, total;\n-        -:    6:\n-        1:    7:  total = 0;\n-        -:    8:\n-       11:    9:  for (i = 0; i < 10; i++)\n-       11:    9-block  0\n-       10:   10:    total += i;\n-       10:   10-block  0\n-        -:   11:\n-        1:   12:  if (total != 45)\n-        1:   12-block  0\n-    #####:   13:    printf (\"Failure\\n\");\n-    $$$$$:   13-block  0\n-        -:   14:  else\n-        1:   15:    printf (\"Success\\n\");\n-        1:   15-block  0\n-        1:   16:  return 0;\n-        1:   16-block  0\n-        -:   17:@}\n+        -:    3:template<class T>\n+        -:    4:class Foo\n+        -:    5:@{\n+        -:    6:  public:\n+       1*:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<char>::Foo():\n+    #####:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<int>::Foo():\n+        1:    7:  Foo(): b (1000) @{@}\n+------------------\n+       2*:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<char>::inc():\n+    #####:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<int>::inc():\n+        2:    8:  void inc () @{ b++; @}\n+------------------\n+        -:    9:\n+        -:   10:  private:\n+        -:   11:  int b;\n+        -:   12:@};\n+        -:   13:\n+        -:   14:template class Foo<int>;\n+        -:   15:template class Foo<char>;\n+        -:   16:\n+        -:   17:int\n+        1:   18:main (void)\n+        -:   19:@{\n+        -:   20:  int i, total;\n+        1:   21:  Foo<int> counter;\n+        1:   21-block  0\n+        -:   22:\n+        1:   23:  counter.inc();\n+        1:   23-block  0\n+        1:   24:  counter.inc();\n+        1:   24-block  0\n+        1:   25:  total = 0;\n+        -:   26:\n+       11:   27:  for (i = 0; i < 10; i++)\n+        1:   27-block  0\n+       11:   27-block  1\n+       10:   28:    total += i;\n+       10:   28-block  0\n+        -:   29:\n+       1*:   30:  int v = total > 100 ? 1 : 2;\n+        1:   30-block  0\n+    %%%%%:   30-block  1\n+        1:   30-block  2\n+        -:   31:\n+        1:   32:  if (total != 45)\n+        1:   32-block  0\n+    #####:   33:    printf (\"Failure\\n\");\n+    %%%%%:   33-block  0\n+        -:   34:  else\n+        1:   35:    printf (\"Success\\n\");\n+        1:   35-block  0\n+        1:   36:  return 0;\n+        1:   36-block  0\n+        -:   37:@}\n @end smallexample\n \n In this mode, each basic block is only shown on one line -- the last\n@@ -477,53 +587,94 @@ block, the branch and call counts of the block will be shown, if the\n \n Because of the way GCC instruments calls, a call count can be shown\n after a line with no individual blocks.\n-As you can see, line 13 contains a basic block that was not executed.\n+As you can see, line 33 contains a basic block that was not executed.\n \n @need 450\n When you use the @option{-b} option, your output looks like this:\n \n @smallexample\n-$ gcov -b tmp.c\n-File 'tmp.c'\n-Lines executed:90.00% of 10\n-Branches executed:80.00% of 5\n-Taken at least once:80.00% of 5\n-Calls executed:50.00% of 2\n-Creating 'tmp.c.gcov'\n-@end smallexample\n-\n-Here is a sample of a resulting @file{tmp.c.gcov} file:\n-\n-@smallexample\n-        -:    0:Source:tmp.c\n+        -:    0:Source:tmp.cpp\n         -:    0:Graph:tmp.gcno\n         -:    0:Data:tmp.gcda\n         -:    0:Runs:1\n         -:    0:Programs:1\n         -:    1:#include <stdio.h>\n         -:    2:\n-        -:    3:int main (void)\n-function main called 1 returned 1 blocks executed 75%\n-        1:    4:@{\n-        1:    5:  int i, total;\n-        -:    6:\n-        1:    7:  total = 0;\n-        -:    8:\n-       11:    9:  for (i = 0; i < 10; i++)\n+        -:    3:template<class T>\n+        -:    4:class Foo\n+        -:    5:@{\n+        -:    6:  public:\n+       1*:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<char>::Foo():\n+function Foo<char>::Foo() called 0 returned 0% blocks executed 0%\n+    #####:    7:  Foo(): b (1000) @{@}\n+------------------\n+Foo<int>::Foo():\n+function Foo<int>::Foo() called 1 returned 100% blocks executed 100%\n+        1:    7:  Foo(): b (1000) @{@}\n+------------------\n+       2*:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<char>::inc():\n+function Foo<char>::inc() called 0 returned 0% blocks executed 0%\n+    #####:    8:  void inc () @{ b++; @}\n+------------------\n+Foo<int>::inc():\n+function Foo<int>::inc() called 2 returned 100% blocks executed 100%\n+        2:    8:  void inc () @{ b++; @}\n+------------------\n+        -:    9:\n+        -:   10:  private:\n+        -:   11:  int b;\n+        -:   12:@};\n+        -:   13:\n+        -:   14:template class Foo<int>;\n+        -:   15:template class Foo<char>;\n+        -:   16:\n+        -:   17:int\n+function main called 1 returned 100% blocks executed 81%\n+        1:   18:main (void)\n+        -:   19:@{\n+        -:   20:  int i, total;\n+        1:   21:  Foo<int> counter;\n+call    0 returned 100%\n+branch  1 taken 100% (fallthrough)\n+branch  2 taken 0% (throw)\n+        -:   22:\n+        1:   23:  counter.inc();\n+call    0 returned 100%\n+branch  1 taken 100% (fallthrough)\n+branch  2 taken 0% (throw)\n+        1:   24:  counter.inc();\n+call    0 returned 100%\n+branch  1 taken 100% (fallthrough)\n+branch  2 taken 0% (throw)\n+        1:   25:  total = 0;\n+        -:   26:\n+       11:   27:  for (i = 0; i < 10; i++)\n branch  0 taken 91% (fallthrough)\n branch  1 taken 9%\n-       10:   10:    total += i;\n-        -:   11:\n-        1:   12:  if (total != 45)\n+       10:   28:    total += i;\n+        -:   29:\n+       1*:   30:  int v = total > 100 ? 1 : 2;\n+branch  0 taken 0% (fallthrough)\n+branch  1 taken 100%\n+        -:   31:\n+        1:   32:  if (total != 45)\n branch  0 taken 0% (fallthrough)\n branch  1 taken 100%\n-    #####:   13:    printf (\"Failure\\n\");\n+    #####:   33:    printf (\"Failure\\n\");\n call    0 never executed\n-        -:   14:  else\n-        1:   15:    printf (\"Success\\n\");\n-call    0 called 1 returned 100%\n-        1:   16:  return 0;\n-        -:   17:@}\n+branch  1 never executed\n+branch  2 never executed\n+        -:   34:  else\n+        1:   35:    printf (\"Success\\n\");\n+call    0 returned 100%\n+branch  1 taken 100% (fallthrough)\n+branch  2 taken 0% (throw)\n+        1:   36:  return 0;\n+        -:   37:@}\n @end smallexample\n \n For each function, a line is printed showing how many times the function"}, {"sha": "c4e05cd47954617668e5d95d06b9252fce5147fe", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -308,9 +308,15 @@ tag_function (const char *filename ATTRIBUTE_UNUSED,\n \t  \n \t  name = gcov_read_string ();\n \t  printf (\", `%s'\", name ? name : \"NULL\");\n+\t  unsigned artificial = gcov_read_unsigned ();\n \t  name = gcov_read_string ();\n \t  printf (\" %s\", name ? name : \"NULL\");\n-\t  printf (\":%u\", gcov_read_unsigned ());\n+\t  unsigned line_start = gcov_read_unsigned ();\n+\t  unsigned column_start = gcov_read_unsigned ();\n+\t  unsigned line_end = gcov_read_unsigned ();\n+\t  printf (\":%u:%u:%u\", line_start, column_start, line_end);\n+\t  if (artificial)\n+\t    printf (\", artificial\");\n \t}\n     }\n }"}, {"sha": "846a232619647defb78bde94e2ce546e47f0d474", "filename": "gcc/gcov.c", "status": "modified", "additions": 589, "deletions": 266, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/136ca74eb91c225ff18a7b08e0e7fd027b88517c/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=136ca74eb91c225ff18a7b08e0e7fd027b88517c", "patch": "@@ -34,6 +34,8 @@ along with Gcov; see the file COPYING3.  If not see\n #define INCLUDE_ALGORITHM\n #define INCLUDE_VECTOR\n #define INCLUDE_STRING\n+#define INCLUDE_MAP\n+#define INCLUDE_SET\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n@@ -183,13 +185,53 @@ block_info::block_info (): succ (NULL), pred (NULL), num_succ (0), num_pred (0),\n   cycle.arc = NULL;\n }\n \n+/* Describes a single line of source.  Contains a chain of basic blocks\n+   with code on it.  */\n+\n+struct line_info\n+{\n+  /* Default constructor.  */\n+  line_info ();\n+\n+  /* Return true when NEEDLE is one of basic blocks the line belongs to.  */\n+  bool has_block (block_t *needle);\n+\n+  /* Execution count.  */\n+  gcov_type count;\n+\n+  /* Branches from blocks that end on this line.  */\n+  vector<arc_t *> branches;\n+\n+  /* blocks which start on this line.  Used in all-blocks mode.  */\n+  vector<block_t *> blocks;\n+\n+  unsigned exists : 1;\n+  unsigned unexceptional : 1;\n+  unsigned has_unexecuted_block : 1;\n+};\n+\n+line_info::line_info (): count (0), branches (), blocks (), exists (false),\n+  unexceptional (0), has_unexecuted_block (0)\n+{\n+}\n+\n+bool\n+line_info::has_block (block_t *needle)\n+{\n+  return std::find (blocks.begin (), blocks.end (), needle) != blocks.end ();\n+}\n+\n /* Describes a single function. Contains an array of basic blocks.  */\n \n typedef struct function_info\n {\n   function_info ();\n   ~function_info ();\n \n+  /* Return true when line N belongs to the function in source file SRC_IDX.\n+     The line must be defined in body of the function, can't be inlined.  */\n+  bool group_line_p (unsigned n, unsigned src_idx);\n+\n   /* Name of function.  */\n   char *name;\n   char *demangled_name;\n@@ -200,6 +242,13 @@ typedef struct function_info\n   /* The graph contains at least one fake incoming edge.  */\n   unsigned has_catch : 1;\n \n+  /* True when the function is artificial and does not exist\n+     in a source file.  */\n+  unsigned artificial : 1;\n+\n+  /* True when multiple functions start at a line in a source file.  */\n+  unsigned is_group : 1;\n+\n   /* Array of basic blocks.  Like in GCC, the entry block is\n      at blocks[0] and the exit block is at blocks[1].  */\n #define ENTRY_BLOCK (0)\n@@ -211,17 +260,39 @@ typedef struct function_info\n   gcov_type *counts;\n   unsigned num_counts;\n \n-  /* First line number & file.  */\n-  unsigned line;\n+  /* First line number.  */\n+  unsigned start_line;\n+\n+  /* First line column.  */\n+  unsigned start_column;\n+\n+  /* Last line number.  */\n+  unsigned end_line;\n+\n+  /* Index of source file where the function is defined.  */\n   unsigned src;\n \n-  /* Next function in same source file.  */\n-  struct function_info *next_file_fn;\n+  /* Vector of line information.  */\n+  vector<line_info> lines;\n \n   /* Next function.  */\n   struct function_info *next;\n } function_t;\n \n+/* Function info comparer that will sort functions according to starting\n+   line.  */\n+\n+struct function_line_start_cmp\n+{\n+  inline bool operator() (const function_info *lhs,\n+\t\t\t  const function_info *rhs)\n+    {\n+      return (lhs->start_line == rhs->start_line\n+\t      ? lhs->start_column < rhs->start_column\n+\t      : lhs->start_line < rhs->start_line);\n+    }\n+};\n+\n /* Describes coverage of a file or function.  */\n \n typedef struct coverage_info\n@@ -239,42 +310,6 @@ typedef struct coverage_info\n   char *name;\n } coverage_t;\n \n-/* Describes a single line of source. Contains a chain of basic blocks\n-   with code on it.  */\n-\n-struct line_info\n-{\n-  /* Default constructor.  */\n-  line_info ();\n-\n-  /* Return true when NEEDLE is one of basic blocks the line belongs to.  */\n-  bool has_block (block_t *needle);\n-\n-  /* Execution count.  */\n-  gcov_type count;\n-\n-  /* Branches from blocks that end on this line.  */\n-  vector<arc_t *> branches;\n-\n-  /* blocks which start on this line.  Used in all-blocks mode.  */\n-  vector<block_t *> blocks;\n-\n-  unsigned exists : 1;\n-  unsigned unexceptional : 1;\n-  unsigned has_unexecuted_block : 1;\n-};\n-\n-line_info::line_info (): count (0), branches (), blocks (), exists (false),\n-  unexceptional (0), has_unexecuted_block (0)\n-{\n-}\n-\n-bool\n-line_info::has_block (block_t *needle)\n-{\n-  return std::find (blocks.begin (), blocks.end (), needle) != blocks.end ();\n-}\n-\n /* Describes a file mentioned in the block graph.  Contains an array\n    of line info.  */\n \n@@ -283,6 +318,11 @@ struct source_info\n   /* Default constructor.  */\n   source_info ();\n \n+  vector<function_t *> get_functions_at_location (unsigned line_num) const;\n+\n+  /* Index of the source_info in sources vector.  */\n+  unsigned index;\n+\n   /* Canonical name of source file.  */\n   char *name;\n   time_t file_time;\n@@ -294,14 +334,31 @@ struct source_info\n \n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n-  function_t *functions;\n+  vector <function_t *> functions;\n };\n \n-source_info::source_info (): name (NULL), file_time (), lines (),\n-  coverage (), functions (NULL)\n+source_info::source_info (): index (0), name (NULL), file_time (),\n+  lines (), coverage (), functions ()\n {\n }\n \n+vector<function_t *>\n+source_info::get_functions_at_location (unsigned line_num) const\n+{\n+  vector<function_t *> r;\n+\n+  for (vector<function_t *>::const_iterator it = functions.begin ();\n+       it != functions.end (); it++)\n+    {\n+      if ((*it)->start_line == line_num && (*it)->src == index)\n+\tr.push_back (*it);\n+    }\n+\n+  std::sort (r.begin (), r.end (), function_line_start_cmp ());\n+\n+  return r;\n+}\n+\n class name_map\n {\n public:\n@@ -495,8 +552,9 @@ extern int main (int, char **);\n \n function_info::function_info (): name (NULL), demangled_name (NULL),\n   ident (0), lineno_checksum (0), cfg_checksum (0), has_catch (0),\n+  artificial (0), is_group (0),\n   blocks (), blocks_executed (0), counts (NULL), num_counts (0),\n-  line (0), src (0), next_file_fn (NULL), next (NULL)\n+  start_line (0), start_column (0), end_line (0), src (0), lines (), next (NULL)\n {\n }\n \n@@ -518,6 +576,11 @@ function_info::~function_info ()\n   free (name);\n }\n \n+bool function_info::group_line_p (unsigned n, unsigned src_idx)\n+{\n+  return is_group && src == src_idx && start_line <= n && n <= end_line;\n+}\n+\n /* Cycle detection!\n    There are a bajillion algorithms that do this.  Boost's function is named\n    hawick_cycles, so I used the algorithm by K. A. Hawick and H. A. James in\n@@ -889,6 +952,42 @@ process_args (int argc, char **argv)\n   return optind;\n }\n \n+/* Output intermediate LINE sitting on LINE_NUM to output file F.  */\n+\n+static void\n+output_intermediate_line (FILE *f, line_info *line, unsigned line_num)\n+{\n+  if (!line->exists)\n+    return;\n+\n+  fprintf (f, \"lcount:%u,%s,%d\\n\", line_num,\n+\t   format_gcov (line->count, 0, -1),\n+\t   line->has_unexecuted_block);\n+\n+  vector<arc_t *>::const_iterator it;\n+  if (flag_branches)\n+    for (it = line->branches.begin (); it != line->branches.end ();\n+\t it++)\n+      {\n+\tif (!(*it)->is_unconditional && !(*it)->is_call_non_return)\n+\t  {\n+\t    const char *branch_type;\n+\t    /* branch:<line_num>,<branch_coverage_type>\n+\t       branch_coverage_type\n+\t       : notexec (Branch not executed)\n+\t       : taken (Branch executed and taken)\n+\t       : nottaken (Branch executed, but not taken)\n+\t       */\n+\t    if ((*it)->src->count)\n+\t\t branch_type\n+\t\t\t= ((*it)->count > 0) ? \"taken\" : \"nottaken\";\n+\t    else\n+\t      branch_type = \"notexec\";\n+\t    fprintf (f, \"branch:%d,%s\\n\", line_num, branch_type);\n+\t  }\n+      }\n+}\n+\n /* Output the result in intermediate format used by 'lcov'.\n \n The intermediate format contains a single file named 'foo.cc.gcov',\n@@ -902,50 +1001,95 @@ file 'foo.cc.gcov' similar to the above example. */\n static void\n output_intermediate_file (FILE *gcov_file, source_info *src)\n {\n-  unsigned line_num;    /* current line number.  */\n-  const line_info *line;   /* current line info ptr.  */\n-  function_t *fn;       /* current function info ptr. */\n-\n   fprintf (gcov_file, \"file:%s\\n\", src->name);    /* source file name */\n \n-  for (fn = src->functions; fn; fn = fn->next_file_fn)\n+  std::sort (src->functions.begin (), src->functions.end (),\n+\t     function_line_start_cmp ());\n+  for (vector<function_t *>::iterator it = src->functions.begin ();\n+       it != src->functions.end (); it++)\n     {\n       /* function:<name>,<line_number>,<execution_count> */\n-      fprintf (gcov_file, \"function:%d,%s,%s\\n\", fn->line,\n-\t       format_gcov (fn->blocks[0].count, 0, -1),\n-\t       flag_demangled_names ? fn->demangled_name : fn->name);\n+      fprintf (gcov_file, \"function:%d,%d,%s,%s\\n\", (*it)->start_line,\n+\t       (*it)->end_line, format_gcov ((*it)->blocks[0].count, 0, -1),\n+\t       flag_demangled_names ? (*it)->demangled_name : (*it)->name);\n     }\n \n-  for (line_num = 1, line = &src->lines[line_num];\n-       line_num < src->lines.size ();\n-       line_num++, line++)\n+  for (unsigned line_num = 0; line_num <= src->lines.size (); line_num++)\n     {\n-      if (line->exists)\n-\tfprintf (gcov_file, \"lcount:%u,%s,%d\\n\", line_num,\n-\t\t format_gcov (line->count, 0, -1), line->has_unexecuted_block);\n-      if (flag_branches)\n-\tfor (vector<arc_t *>::const_iterator it = line->branches.begin ();\n-\t     it != line->branches.end (); it++)\n-\t  {\n-\t    if (!(*it)->is_unconditional && !(*it)->is_call_non_return)\n-\t      {\n-\t\tconst char *branch_type;\n-\t\t/* branch:<line_num>,<branch_coverage_type>\n-\t\t   branch_coverage_type\n-\t\t     : notexec (Branch not executed)\n-\t\t     : taken (Branch executed and taken)\n-\t\t     : nottaken (Branch executed, but not taken)\n-\t\t*/\n-\t\tif ((*it)->src->count)\n-\t\t  branch_type = ((*it)->count > 0) ? \"taken\" : \"nottaken\";\n-\t\telse\n-\t\t  branch_type = \"notexec\";\n-\t\tfprintf (gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n-\t      }\n-\t  }\n+      vector<function_t *> fns = src->get_functions_at_location (line_num);\n+\n+      /* Print first group functions that begin on the line.  */\n+      for (vector<function_t *>::iterator it2 = fns.begin ();\n+\t   it2 != fns.end (); it2++)\n+\t{\n+\t  vector<line_info> &lines = (*it2)->lines;\n+\t  for (unsigned i = 0; i < lines.size (); i++)\n+\t    {\n+\t      line_info *line = &lines[i];\n+\t      output_intermediate_line (gcov_file, line, line_num + i);\n+\t    }\n+\t}\n+\n+      /* Follow with lines associated with the source file.  */\n+      output_intermediate_line (gcov_file, &src->lines[line_num], line_num);\n     }\n }\n \n+/* Function start pair.  */\n+struct function_start\n+{\n+  unsigned source_file_idx;\n+  unsigned start_line;\n+};\n+\n+/* Traits class for function start hash maps below.  */\n+\n+struct function_start_pair_hash : typed_noop_remove <function_start>\n+{\n+  typedef function_start value_type;\n+  typedef function_start compare_type;\n+\n+  static hashval_t\n+  hash (const function_start &ref)\n+  {\n+    inchash::hash hstate (0);\n+    hstate.add_int (ref.source_file_idx);\n+    hstate.add_int (ref.start_line);\n+    return hstate.end ();\n+  }\n+\n+  static bool\n+  equal (const function_start &ref1, const function_start &ref2)\n+  {\n+    return (ref1.source_file_idx == ref2.source_file_idx\n+\t    && ref1.start_line == ref2.start_line);\n+  }\n+\n+  static void\n+  mark_deleted (function_start &ref)\n+  {\n+    ref.start_line = ~1U;\n+  }\n+\n+  static void\n+  mark_empty (function_start &ref)\n+  {\n+    ref.start_line = ~2U;\n+  }\n+\n+  static bool\n+  is_deleted (const function_start &ref)\n+  {\n+    return ref.start_line == ~1U;\n+  }\n+\n+  static bool\n+  is_empty (const function_start &ref)\n+  {\n+    return ref.start_line == ~2U;\n+  }\n+};\n+\n /* Process a single input file.  */\n \n static void\n@@ -959,6 +1103,28 @@ process_file (const char *file_name)\n     return;\n \n   read_count_file (fns);\n+\n+  hash_map<function_start_pair_hash, function_t *> fn_map;\n+\n+  /* Identify group functions.  */\n+  for (function_t *f = fns; f; f = f->next)\n+    if (!f->artificial)\n+      {\n+\tfunction_start needle;\n+\tneedle.source_file_idx = f->src;\n+\tneedle.start_line = f->start_line;\n+\n+\tfunction_t **slot = fn_map.get (needle);\n+\tif (slot)\n+\t  {\n+\t    gcc_assert ((*slot)->end_line == f->end_line);\n+\t    (*slot)->is_group = 1;\n+\t    f->is_group = 1;\n+\t  }\n+\telse\n+\t  fn_map.put (needle, f);\n+      }\n+\n   while (fns)\n     {\n       function_t *fn = fns;\n@@ -968,46 +1134,50 @@ process_file (const char *file_name)\n       if (fn->counts || no_data_file)\n \t{\n \t  unsigned src = fn->src;\n-\t  unsigned line = fn->line;\n \t  unsigned block_no;\n-\t  function_t *probe, **prev;\n-\n-\t  /* Now insert it into the source file's list of\n-\t     functions. Normally functions will be encountered in\n-\t     ascending order, so a simple scan is quick.  Note we're\n-\t     building this list in reverse order.  */\n-\t  for (prev = &sources[src].functions;\n-\t       (probe = *prev); prev = &probe->next_file_fn)\n-\t    if (probe->line <= line)\n-\t      break;\n-\t  fn->next_file_fn = probe;\n-\t  *prev = fn;\n \n-\t  /* Mark last line in files touched by function.  */\n-\t  for (block_no = 0; block_no != fn->blocks.size (); block_no++)\n+\t  /* Process only non-artificial functions.  */\n+\t  if (!fn->artificial)\n \t    {\n-\t      block_t *block = &fn->blocks[block_no];\n-\t      for (unsigned i = 0; i < block->locations.size (); i++)\n-\t\t{\n-\t\t  unsigned s = block->locations[i].source_file_idx;\n-\n-\t\t  /* Sort lines of locations.  */\n-\t\t  sort (block->locations[i].lines.begin (),\n-\t\t\tblock->locations[i].lines.end ());\n+\t      source_info *s = &sources[src];\n+\t      s->functions.push_back (fn);\n \n-\t\t  if (!block->locations[i].lines.empty ())\n+\t      /* Mark last line in files touched by function.  */\n+\t      for (block_no = 0; block_no != fn->blocks.size (); block_no++)\n+\t\t{\n+\t\t  block_t *block = &fn->blocks[block_no];\n+\t\t  for (unsigned i = 0; i < block->locations.size (); i++)\n \t\t    {\n-\t\t      unsigned last_line\n-\t\t\t= block->locations[i].lines.back () + 1;\n-\t\t      if (last_line > sources[s].lines.size ())\n-\t\t\tsources[s].lines.resize (last_line);\n+\t\t      /* Sort lines of locations.  */\n+\t\t      sort (block->locations[i].lines.begin (),\n+\t\t\t    block->locations[i].lines.end ());\n+\n+\t\t      if (!block->locations[i].lines.empty ())\n+\t\t\t{\n+\t\t\t  s = &sources[block->locations[i].source_file_idx];\n+\t\t\t  unsigned last_line\n+\t\t\t    = block->locations[i].lines.back ();\n+\n+\t\t\t  /* Record new lines for the function.  */\n+\t\t\t  if (last_line >= s->lines.size ())\n+\t\t\t    {\n+\t\t\t      /* Record new lines for a source file.  */\n+\t\t\t      s->lines.resize (last_line + 1);\n+\t\t\t    }\n+\t\t\t}\n \t\t    }\n+\n+\t\t  /* Allocate lines for group function, following start_line\n+\t\t     and end_line information of the function.  */\n+\t\t  if (fn->is_group)\n+\t\t    fn->lines.resize (fn->end_line - fn->start_line + 1);\n \t\t}\n+\n+\t      solve_flow_graph (fn);\n+\t      if (fn->has_catch)\n+\t\tfind_exception_blocks (fn);\n \t    }\n \n-\t  solve_flow_graph (fn);\n-\t  if (fn->has_catch)\n-\t    find_exception_blocks (fn);\n \t  *fn_end = fn;\n \t  fn_end = &fn->next;\n \t}\n@@ -1057,6 +1227,8 @@ generate_results (const char *file_name)\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n+      if (fn->artificial)\n+\tcontinue;\n \n       memset (&coverage, 0, sizeof (coverage));\n       coverage.name = flag_demangled_names ? fn->demangled_name : fn->name;\n@@ -1237,6 +1409,7 @@ find_source (const char *file_name)\n       src = &sources.back ();\n       src->name = canon;\n       src->coverage.name = src->name;\n+      src->index = idx;\n       if (source_length\n #if HAVE_DOS_BASED_FILE_SYSTEM\n \t  /* You lose if separators don't match exactly in the\n@@ -1328,15 +1501,18 @@ read_graph_file (void)\n       if (tag == GCOV_TAG_FUNCTION)\n \t{\n \t  char *function_name;\n-\t  unsigned ident, lineno;\n+\t  unsigned ident;\n \t  unsigned lineno_checksum, cfg_checksum;\n \n \t  ident = gcov_read_unsigned ();\n \t  lineno_checksum = gcov_read_unsigned ();\n \t  cfg_checksum = gcov_read_unsigned ();\n \t  function_name = xstrdup (gcov_read_string ());\n+\t  unsigned artificial = gcov_read_unsigned ();\n \t  unsigned src_idx = find_source (gcov_read_string ());\n-\t  lineno = gcov_read_unsigned ();\n+\t  unsigned start_line = gcov_read_unsigned ();\n+\t  unsigned start_column = gcov_read_unsigned ();\n+\t  unsigned end_line = gcov_read_unsigned ();\n \n \t  fn = new function_t;\n \t  fn->name = function_name;\n@@ -1350,9 +1526,11 @@ read_graph_file (void)\n \t  fn->lineno_checksum = lineno_checksum;\n \t  fn->cfg_checksum = cfg_checksum;\n \t  fn->src = src_idx;\n-\t  fn->line = lineno;\n+\t  fn->start_line = start_line;\n+\t  fn->start_column = start_column;\n+\t  fn->end_line = end_line;\n+\t  fn->artificial = artificial;\n \n-\t  fn->next_file_fn = NULL;\n \t  fn->next = NULL;\n \t  *fns_end = fn;\n \t  fns_end = &fn->next;\n@@ -2266,48 +2444,66 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n \tfn->blocks_executed++;\n       for (unsigned i = 0; i < block->locations.size (); i++)\n \t{\n-\t  source_info *src = &sources[block->locations[i].source_file_idx];\n-\n+\t  unsigned src_idx = block->locations[i].source_file_idx;\n \t  vector<unsigned> &lines = block->locations[i].lines;\n+\n+\t  block->cycle.arc = NULL;\n+\t  block->cycle.ident = ~0U;\n+\n \t  for (unsigned j = 0; j < lines.size (); j++)\n \t    {\n-\t      line = &src->lines[lines[j]];\n-\t      if (coverage)\n+\t      unsigned ln = lines[j];\n+\n+\t      /* Line belongs to a function that is in a group.  */\n+\t      if (fn->group_line_p (ln, src_idx))\n \t\t{\n-\t\t  if (!line->exists)\n-\t\t    coverage->lines++;\n-\t\t  if (!line->count && block->count)\n-\t\t    coverage->lines_executed++;\n+\t\t  gcc_assert (lines[j] - fn->start_line < fn->lines.size ());\n+\t\t  line = &(fn->lines[lines[j] - fn->start_line]);\n+\t\t  line->exists = 1;\n+\t\t  if (!block->exceptional)\n+\t\t    {\n+\t\t      line->unexceptional = 1;\n+\t\t      if (block->count == 0)\n+\t\t\tline->has_unexecuted_block = 1;\n+\t\t    }\n+\t\t  line->count += block->count;\n \t\t}\n-\t      line->exists = 1;\n-\t      if (!block->exceptional)\n+\t      else\n \t\t{\n-\t\t  line->unexceptional = 1;\n-\t\t  if (block->count == 0)\n-\t\t    line->has_unexecuted_block = 1;\n+\t\t  gcc_assert (ln < sources[src_idx].lines.size ());\n+\t\t  line = &(sources[src_idx].lines[ln]);\n+\t\t  if (coverage)\n+\t\t    {\n+\t\t      if (!line->exists)\n+\t\t\tcoverage->lines++;\n+\t\t      if (!line->count && block->count)\n+\t\t\tcoverage->lines_executed++;\n+\t\t    }\n+\t\t  line->exists = 1;\n+\t\t  if (!block->exceptional)\n+\t\t    {\n+\t\t      line->unexceptional = 1;\n+\t\t      if (block->count == 0)\n+\t\t\tline->has_unexecuted_block = 1;\n+\t\t    }\n+\t\t  line->count += block->count;\n \t\t}\n-\t      line->count += block->count;\n \t    }\n-\t}\n-      block->cycle.arc = NULL;\n-      block->cycle.ident = ~0U;\n-      has_any_line = true;\n \n-      if (!ix || ix + 1 == fn->blocks.size ())\n-\t/* Entry or exit block */;\n-      else if (line != NULL)\n-\t{\n-\t  line->blocks.push_back (block);\n+\t  has_any_line = true;\n \n-\t  if (flag_branches)\n+\t  if (!ix || ix + 1 == fn->blocks.size ())\n+\t    /* Entry or exit block.  */;\n+\t  else if (line != NULL)\n \t    {\n-\t      arc_t *arc;\n+\t      line->blocks.push_back (block);\n \n-\t      for (arc = block->succ; arc; arc = arc->succ_next)\n+\t      if (flag_branches)\n \t\t{\n-\t\t  line->branches.push_back (arc);\n-\t\t  if (coverage && !arc->is_unconditional)\n-\t\t    add_branch_counts (coverage, arc);\n+\t\t  arc_t *arc;\n+\n+\t\t  for (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t    line->branches.push_back (arc);\n \t\t}\n \t    }\n \t}\n@@ -2317,72 +2513,113 @@ add_line_counts (coverage_t *coverage, function_t *fn)\n     fnotice (stderr, \"%s:no lines for '%s'\\n\", bbg_file_name, fn->name);\n }\n \n+/* Accumulate info for LINE that belongs to SRC source file.  If ADD_COVERAGE\n+   is set to true, update source file summary.  */\n+\n+static void accumulate_line_info (line_info *line, source_info *src,\n+\t\t\t\t  bool add_coverage)\n+{\n+  if (add_coverage)\n+    for (vector<arc_info *>::iterator it = line->branches.begin ();\n+\t it != line->branches.end (); it++)\n+      add_branch_counts (&src->coverage, *it);\n+\n+  if (!line->blocks.empty ())\n+    {\n+      /* The user expects the line count to be the number of times\n+\t a line has been executed.  Simply summing the block count\n+\t will give an artificially high number.  The Right Thing\n+\t is to sum the entry counts to the graph of blocks on this\n+\t line, then find the elementary cycles of the local graph\n+\t and add the transition counts of those cycles.  */\n+      gcov_type count = 0;\n+\n+      /* Cycle detection.  */\n+      for (vector<block_t *>::iterator it = line->blocks.begin ();\n+\t   it != line->blocks.end (); it++)\n+\t{\n+\t  for (arc_t *arc = (*it)->pred; arc; arc = arc->pred_next)\n+\t    if (!line->has_block (arc->src))\n+\t      count += arc->count;\n+\t  for (arc_t *arc = (*it)->succ; arc; arc = arc->succ_next)\n+\t    arc->cs_count = arc->count;\n+\t}\n+\n+      /* Now, add the count of loops entirely on this line.  */\n+      count += get_cycles_count (*line);\n+      line->count = count;\n+    }\n+\n+  if (line->exists && add_coverage)\n+    {\n+      src->coverage.lines++;\n+      if (line->count)\n+\tsrc->coverage.lines_executed++;\n+    }\n+}\n+\n /* Accumulate the line counts of a file.  */\n \n static void\n accumulate_line_counts (source_info *src)\n {\n-  function_t *fn, *fn_p, *fn_n;\n-  unsigned ix = 0;\n-\n-  /* Reverse the function order.  */\n-  for (fn = src->functions, fn_p = NULL; fn; fn_p = fn, fn = fn_n)\n+  /* First work on group functions.  */\n+  for (vector<function_t *>::iterator it = src->functions.begin ();\n+       it != src->functions.end (); it++)\n     {\n-      fn_n = fn->next_file_fn;\n-      fn->next_file_fn = fn_p;\n+      function_info *fn = *it;\n+\n+      if (fn->src != src->index || !fn->is_group)\n+\tcontinue;\n+\n+      for (vector<line_info>::iterator it2 = fn->lines.begin ();\n+\t   it2 != fn->lines.end (); it2++)\n+\t  {\n+\t    line_info *line = &(*it2);\n+\t    accumulate_line_info (line, src, false);\n+\t  }\n     }\n-  src->functions = fn_p;\n \n-  for (vector<line_info>::reverse_iterator it = src->lines.rbegin ();\n-       it != src->lines.rend (); it++)\n-    {\n-      line_info *line = &(*it);\n-      if (!line->blocks.empty ())\n-\t{\n-\t  /* The user expects the line count to be the number of times\n-\t     a line has been executed. Simply summing the block count\n-\t     will give an artificially high number.  The Right Thing\n-\t     is to sum the entry counts to the graph of blocks on this\n-\t     line, then find the elementary cycles of the local graph\n-\t     and add the transition counts of those cycles.  */\n-\t  gcov_type count = 0;\n-\n-\t  /* Sum the entry arcs.  */\n-\t  for (vector<block_t *>::iterator it = line->blocks.begin ();\n-\t       it != line->blocks.end (); it++)\n-\t    {\n-\t      arc_t *arc;\n+  /* Work on global lines that line in source file SRC.  */\n+  for (vector<line_info>::iterator it = src->lines.begin ();\n+       it != src->lines.end (); it++)\n+    accumulate_line_info (&(*it), src, true);\n \n-\t      for (arc = (*it)->pred; arc; arc = arc->pred_next)\n-\t\tif (flag_branches)\n-\t\t  add_branch_counts (&src->coverage, arc);\n-\t    }\n+  /* If not using intermediate mode, sum lines of group functions and\n+     add them to lines that live in a source file.  */\n+  if (!flag_intermediate_format)\n+    for (vector<function_t *>::iterator it = src->functions.begin ();\n+\t it != src->functions.end (); it++)\n+      {\n+\tfunction_info *fn = *it;\n \n-\t  /* Cycle detection.  */\n-\t  for (vector<block_t *>::iterator it = line->blocks.begin ();\n-\t       it != line->blocks.end (); it++)\n-\t    {\n-\t      for (arc_t *arc = (*it)->pred; arc; arc = arc->pred_next)\n-\t\tif (!line->has_block (arc->src))\n-\t\t  count += arc->count;\n-\t      for (arc_t *arc = (*it)->succ; arc; arc = arc->succ_next)\n-\t\tarc->cs_count = arc->count;\n-\t    }\n+\tif (fn->src != src->index || !fn->is_group)\n+\t  continue;\n \n-\t  /* Now, add the count of loops entirely on this line.  */\n-\t  count += get_cycles_count (*line);\n-\t  line->count = count;\n-\t}\n+\tfor (unsigned i = 0; i < fn->lines.size (); i++)\n+\t  {\n+\t    line_info *fn_line = &fn->lines[i];\n+\t    if (fn_line->exists)\n+\t      {\n+\t\tunsigned ln = fn->start_line + i;\n+\t\tline_info *src_line = &src->lines[ln];\n \n-      if (line->exists)\n-\t{\n-\t  src->coverage.lines++;\n-\t  if (line->count)\n-\t    src->coverage.lines_executed++;\n-\t}\n+\t\tif (!src_line->exists)\n+\t\t  src->coverage.lines++;\n+\t\tif (!src_line->count && fn_line->count)\n+\t\t  src->coverage.lines_executed++;\n \n-      ix++;\n-    }\n+\t\tsrc_line->count += fn_line->count;\n+\t\tsrc_line->exists = 1;\n+\n+\t\tif (fn_line->has_unexecuted_block)\n+\t\t  src_line->has_unexecuted_block = 1;\n+\n+\t\tif (fn_line->unexceptional)\n+\t\t  src_line->unexceptional = 1;\n+\t      }\n+\t  }\n+      }\n }\n \n /* Output information about ARC number IX.  Returns nonzero if\n@@ -2500,7 +2737,8 @@ output_line_beginning (FILE *f, bool exists, bool unexceptional,\n \t      if (flag_use_colors)\n \t\t{\n \t\t  pad_count_string (s);\n-\t\t  s = SGR_SEQ (COLOR_BG_MAGENTA COLOR_SEPARATOR COLOR_FG_WHITE);\n+\t\t  s.insert (0, SGR_SEQ (COLOR_BG_MAGENTA\n+\t\t\t\t\tCOLOR_SEPARATOR COLOR_FG_WHITE));\n \t\t  s += SGR_RESET;\n \t\t}\n \t      else\n@@ -2538,6 +2776,86 @@ output_line_beginning (FILE *f, bool exists, bool unexceptional,\n   fprintf (f, \"%s:%5u\", s.c_str (), line_num);\n }\n \n+static void\n+print_source_line (FILE *f, const vector<const char *> &source_lines,\n+\t\t   unsigned line)\n+{\n+  gcc_assert (line >= 1);\n+  gcc_assert (line <= source_lines.size ());\n+\n+  fprintf (f, \":%s\\n\", source_lines[line - 1]);\n+}\n+\n+/* Output line details for LINE and print it to F file.  LINE lives on\n+   LINE_NUM.  */\n+\n+static void\n+output_line_details (FILE *f, const line_info *line, unsigned line_num)\n+{\n+  if (flag_all_blocks)\n+    {\n+      arc_t *arc;\n+      int ix, jx;\n+\n+      ix = jx = 0;\n+      for (vector<block_t *>::const_iterator it = line->blocks.begin ();\n+\t   it != line->blocks.end (); it++)\n+\t{\n+\t  if (!(*it)->is_call_return)\n+\t    {\n+\t      output_line_beginning (f, line->exists,\n+\t\t\t\t     (*it)->exceptional, false,\n+\t\t\t\t     (*it)->count, line_num,\n+\t\t\t\t     \"%%%%%\", \"$$$$$\");\n+\t      fprintf (f, \"-block %2d\", ix++);\n+\t      if (flag_verbose)\n+\t\tfprintf (f, \" (BB %u)\", (*it)->id);\n+\t      fprintf (f, \"\\n\");\n+\t    }\n+\t  if (flag_branches)\n+\t    for (arc = (*it)->succ; arc; arc = arc->succ_next)\n+\t      jx += output_branch_count (f, jx, arc);\n+\t}\n+    }\n+  else if (flag_branches)\n+    {\n+      int ix;\n+\n+      ix = 0;\n+      for (vector<arc_t *>::const_iterator it = line->branches.begin ();\n+\t   it != line->branches.end (); it++)\n+\tix += output_branch_count (f, ix, (*it));\n+    }\n+}\n+\n+/* Output detail statistics about function FN to file F.  */\n+\n+static void\n+output_function_details (FILE *f, const function_info *fn)\n+{\n+  if (!flag_branches)\n+    return;\n+\n+  arc_t *arc = fn->blocks[EXIT_BLOCK].pred;\n+  gcov_type return_count = fn->blocks[EXIT_BLOCK].count;\n+  gcov_type called_count = fn->blocks[ENTRY_BLOCK].count;\n+\n+  for (; arc; arc = arc->pred_next)\n+    if (arc->fake)\n+      return_count -= arc->count;\n+\n+  fprintf (f, \"function %s\",\n+\t   flag_demangled_names ? fn->demangled_name : fn->name);\n+  fprintf (f, \" called %s\",\n+\t   format_gcov (called_count, 0, -1));\n+  fprintf (f, \" returned %s\",\n+\t   format_gcov (return_count, called_count, 0));\n+  fprintf (f, \" blocks executed %s\",\n+\t   format_gcov (fn->blocks_executed, fn->blocks.size () - 2,\n+\t\t\t0));\n+  fprintf (f, \"\\n\");\n+}\n+\n /* Read in the source file one line at a time, and output that line to\n    the gcov file preceded by its execution count and other\n    information.  */\n@@ -2546,12 +2864,10 @@ static void\n output_lines (FILE *gcov_file, const source_info *src)\n {\n #define  DEFAULT_LINE_START \"        -:    0:\"\n+#define FN_SEPARATOR \"------------------\\n\"\n \n   FILE *source_file;\n-  unsigned line_num;\t/* current line number.  */\n-  const line_info *line;  /* current line info ptr.  */\n-  const char *retval = \"\";\t/* status of source file reading.  */\n-  function_t *fn = NULL;\n+  const char *retval;\n \n   fprintf (gcov_file, DEFAULT_LINE_START \"Source:%s\\n\", src->coverage.name);\n   if (!multiple_files)\n@@ -2565,43 +2881,40 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n   source_file = fopen (src->name, \"r\");\n   if (!source_file)\n-    {\n-      fnotice (stderr, \"Cannot open source file %s\\n\", src->name);\n-      retval = NULL;\n-    }\n+    fnotice (stderr, \"Cannot open source file %s\\n\", src->name);\n   else if (src->file_time == 0)\n     fprintf (gcov_file, DEFAULT_LINE_START \"Source is newer than graph\\n\");\n \n-  if (flag_branches)\n-    fn = src->functions;\n+  vector<const char *> source_lines;\n+  if (source_file)\n+    while ((retval = read_line (source_file)) != NULL)\n+      source_lines.push_back (xstrdup (retval));\n \n-  for (line_num = 1, line = &src->lines[line_num];\n-       line_num < src->lines.size (); line_num++, line++)\n+  unsigned line_start_group = 0;\n+  vector<function_t *> fns;\n+\n+  for (unsigned line_num = 1; line_num <= source_lines.size (); line_num++)\n     {\n-      for (; fn && fn->line == line_num; fn = fn->next_file_fn)\n+      if (line_num >= src->lines.size ())\n \t{\n-\t  arc_t *arc = fn->blocks[EXIT_BLOCK].pred;\n-\t  gcov_type return_count = fn->blocks[EXIT_BLOCK].count;\n-\t  gcov_type called_count = fn->blocks[ENTRY_BLOCK].count;\n-\n-\t  for (; arc; arc = arc->pred_next)\n-\t    if (arc->fake)\n-\t      return_count -= arc->count;\n-\n-\t  fprintf (gcov_file, \"function %s\", flag_demangled_names ?\n-                   fn->demangled_name : fn->name);\n-\t  fprintf (gcov_file, \" called %s\",\n-\t\t   format_gcov (called_count, 0, -1));\n-\t  fprintf (gcov_file, \" returned %s\",\n-\t\t   format_gcov (return_count, called_count, 0));\n-\t  fprintf (gcov_file, \" blocks executed %s\",\n-\t\t   format_gcov (fn->blocks_executed, fn->blocks.size () - 2,\n-\t\t\t\t0));\n-\t  fprintf (gcov_file, \"\\n\");\n+\t  fprintf (gcov_file, \"%9s:%5u\", \"-\", line_num);\n+\t  print_source_line (gcov_file, source_lines, line_num);\n+\t  continue;\n \t}\n \n-      if (retval)\n-\tretval = read_line (source_file);\n+      const line_info *line = &src->lines[line_num];\n+\n+      if (line_start_group == 0)\n+\t{\n+\t  fns = src->get_functions_at_location (line_num);\n+\t  if (fns.size () > 1)\n+\t    line_start_group = fns[0]->end_line;\n+\t  else if (fns.size () == 1)\n+\t    {\n+\t      function_t *fn = fns[0];\n+\t      output_function_details (gcov_file, fn);\n+\t    }\n+\t}\n \n       /* For lines which don't exist in the .bb file, print '-' before\n \t the source line.  For lines which exist but were never\n@@ -2610,54 +2923,64 @@ output_lines (FILE *gcov_file, const source_info *src)\n \t There are 16 spaces of indentation added before the source\n \t line so that tabs won't be messed up.  */\n       output_line_beginning (gcov_file, line->exists, line->unexceptional,\n-\t\t\t     line->has_unexecuted_block, line->count, line_num,\n-\t\t\t     \"=====\", \"#####\");\n-      fprintf (gcov_file, \":%s\\n\", retval ? retval : \"/*EOF*/\");\n+\t\t\t     line->has_unexecuted_block, line->count,\n+\t\t\t     line_num, \"=====\", \"#####\");\n \n-      if (flag_all_blocks)\n-\t{\n-\t  arc_t *arc;\n-\t  int ix, jx;\n+      print_source_line (gcov_file, source_lines, line_num);\n+      output_line_details (gcov_file, line, line_num);\n \n-\t  ix = jx = 0;\n-\t  for (vector<block_t *>::const_iterator it = line->blocks.begin ();\n-\t       it != line->blocks.end (); it++)\n+      if (line_start_group == line_num)\n+\t{\n+\t  for (vector<function_t *>::iterator it = fns.begin ();\n+\t       it != fns.end (); it++)\n \t    {\n-\t      if (!(*it)->is_call_return)\n+\t      function_info *fn = *it;\n+\t      vector<line_info> &lines = fn->lines;\n+\n+\t      fprintf (gcov_file, FN_SEPARATOR);\n+\n+\t      string fn_name\n+\t\t= flag_demangled_names ? fn->demangled_name : fn->name;\n+\n+\t      if (flag_use_colors)\n \t\t{\n+\t\t  fn_name.insert (0, SGR_SEQ (COLOR_FG_CYAN));\n+\t\t  fn_name += SGR_RESET;\n+\t\t}\n+\n+\t      fprintf (gcov_file, \"%s:\\n\", fn_name.c_str ());\n+\n+\t      output_function_details (gcov_file, fn);\n+\n+\t      /* Print all lines covered by the function.  */\n+\t      for (unsigned i = 0; i < lines.size (); i++)\n+\t\t{\n+\t\t  line_info *line = &lines[i];\n+\t\t  unsigned l = fn->start_line + i;\n+\n+\t\t  /* For lines which don't exist in the .bb file, print '-'\n+\t\t     before the source line.  For lines which exist but\n+\t\t     were never executed, print '#####' or '=====' before\n+\t\t     the source line.  Otherwise, print the execution count\n+\t\t     before the source line.\n+\t\t     There are 16 spaces of indentation added before the source\n+\t\t     line so that tabs won't be messed up.  */\n \t\t  output_line_beginning (gcov_file, line->exists,\n-\t\t\t\t\t (*it)->exceptional, false,\n-\t\t\t\t\t (*it)->count, line_num,\n-\t\t\t\t\t \"%%%%%\", \"$$$$$\");\n-\t\t  fprintf (gcov_file, \"-block %2d\", ix++);\n-\t\t  if (flag_verbose)\n-\t\t    fprintf (gcov_file, \" (BB %u)\", (*it)->id);\n-\t\t  fprintf (gcov_file, \"\\n\");\n+\t\t\t\t\t line->unexceptional,\n+\t\t\t\t\t line->has_unexecuted_block,\n+\t\t\t\t\t line->count,\n+\t\t\t\t\t l, \"=====\", \"#####\");\n+\n+\t\t  print_source_line (gcov_file, source_lines, l);\n+\t\t  output_line_details (gcov_file, line, l);\n \t\t}\n-\t      if (flag_branches)\n-\t\tfor (arc = (*it)->succ; arc; arc = arc->succ_next)\n-\t\t  jx += output_branch_count (gcov_file, jx, arc);\n \t    }\n-\t}\n-      else if (flag_branches)\n-\t{\n-\t  int ix;\n \n-\t  ix = 0;\n-\t  for (vector<arc_t *>::const_iterator it = line->branches.begin ();\n-\t       it != line->branches.end (); it++)\n-\t    ix += output_branch_count (gcov_file, ix, (*it));\n+\t  fprintf (gcov_file, FN_SEPARATOR);\n+\t  line_start_group = 0;\n \t}\n     }\n \n-  /* Handle all remaining source lines.  There may be lines after the\n-     last line of code.  */\n-  if (retval)\n-    {\n-      for (; (retval = read_line (source_file)); line_num++)\n-\tfprintf (gcov_file, \"%9s:%5u:%s\\n\", \"-\", line_num, retval);\n-    }\n-\n   if (source_file)\n     fclose (source_file);\n }"}]}