{"sha": "434632cea8746ceca0d253bd3283495e9ac37b3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM0NjMyY2VhODc0NmNlY2EwZDI1M2JkMzI4MzQ5NWU5YWMzN2IzZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T09:00:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T09:00:48Z"}, "message": "(Check_References.Publicly_Referenceable): A formal parameter is never publicly referenceable outside of its body.\n\n\t(Check_References.Publicly_Referenceable): A formal parameter is never\n\tpublicly referenceable outside of its body.\n\t(Check_References): For an unreferenced formal parameter in an accecpt\n\tstatement, use the same warning circuitry as for subprogram formal\n\tparameters.  \n\t(Warn_On_Unreferenced_Entity): New subprogram, taken from\n\tOutput_Unreferenced_Messages, containing the part of that routine that\n\tis now reused for entry formals as described above.\n\t(Has_Pragma_Unreferenced_Check_Spec): New function\n\t(Check_References): Clean up handling of unmodified IN OUT parameters\n\nFrom-SVN: r127471", "tree": {"sha": "49371f6991e1da2d3576087ccc0145223fa1682d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49371f6991e1da2d3576087ccc0145223fa1682d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/434632cea8746ceca0d253bd3283495e9ac37b3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434632cea8746ceca0d253bd3283495e9ac37b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/434632cea8746ceca0d253bd3283495e9ac37b3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434632cea8746ceca0d253bd3283495e9ac37b3f/comments", "author": null, "committer": null, "parents": [{"sha": "a43050d35af4a15b420b9af62a33f08d5df6b467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43050d35af4a15b420b9af62a33f08d5df6b467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a43050d35af4a15b420b9af62a33f08d5df6b467"}], "stats": {"total": 1196, "additions": 893, "deletions": 303}, "files": [{"sha": "087d8e8bec892fbbfd17b440dca1997ef629b14c", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 893, "deletions": 303, "changes": 1196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434632cea8746ceca0d253bd3283495e9ac37b3f/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434632cea8746ceca0d253bd3283495e9ac37b3f/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=434632cea8746ceca0d253bd3283495e9ac37b3f", "patch": "@@ -35,6 +35,7 @@ with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -51,6 +52,7 @@ package body Sem_Warn is\n \n    --  The following table collects Id's of entities that are potentially\n    --  unreferenced. See Check_Unset_Reference for further details.\n+   --  ??? Check_Unset_Reference has zero information about this table.\n \n    package Unreferenced_Entities is new Table.Table (\n      Table_Component_Type => Entity_Id,\n@@ -60,6 +62,14 @@ package body Sem_Warn is\n      Table_Increment      => Alloc.Unreferenced_Entities_Increment,\n      Table_Name           => \"Unreferenced_Entities\");\n \n+   package In_Out_Warnings is new Table.Table (\n+     Table_Component_Type => Entity_Id,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => Alloc.In_Out_Warnings_Initial,\n+     Table_Increment      => Alloc.In_Out_Warnings_Increment,\n+     Table_Name           => \"In_Out_Warnings\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -68,15 +78,51 @@ package body Sem_Warn is\n    --  This returns true if the entity E is declared within a generic package.\n    --  The point of this is to detect variables which are not assigned within\n    --  the generic, but might be assigned outside the package for any given\n-   --  instance. These are cases where we leave the warnings to be posted\n-   --  for the instance, when we will know more.\n+   --  instance. These are cases where we leave the warnings to be posted for\n+   --  the instance, when we will know more.\n+\n+   function Goto_Spec_Entity (E : Entity_Id) return Entity_Id;\n+   --  If E is a parameter entity for a subprogram body, then this function\n+   --  returns the corresponding spec entity, if not, E is returned unchanged.\n+\n+   function Has_Pragma_Unreferenced_Check_Spec (E : Entity_Id) return Boolean;\n+   --  Tests Has_Pragma_Unreferenced flag for entity E. If E is not a formal,\n+   --  this is simply the setting of the flag Has_Pragma_Unreferenced. If E is\n+   --  a body formal, the setting of the flag in the corresponding spec is\n+   --  also checked (and True returned if either flag is True).\n+\n+   function Never_Set_In_Source_Check_Spec (E : Entity_Id) return Boolean;\n+   --  Tests Never_Set_In_Source status for entity E. If E is not a formal,\n+   --  this is simply the setting of the flag Never_Set_In_Source. If E is\n+   --  a body formal, the setting of the flag in the corresponding spec is\n+   --  also checked (and False returned if either flag is False).\n \n    function Operand_Has_Warnings_Suppressed (N : Node_Id) return Boolean;\n    --  This function traverses the expression tree represented by the node N\n    --  and determines if any sub-operand is a reference to an entity for which\n    --  the Warnings_Off flag is set. True is returned if such an entity is\n    --  encountered, and False otherwise.\n \n+   function Referenced_Check_Spec (E : Entity_Id) return Boolean;\n+   --  Tests Referenced status for entity E. If E is not a formal, this is\n+   --  simply the setting of the flag Referenced. If E is a body formal, the\n+   --  setting of the flag in the corresponding spec is also checked (and True\n+   --  returned if either flag is True).\n+\n+   function Referenced_As_LHS_Check_Spec (E : Entity_Id) return Boolean;\n+   --  Tests Referenced_As_LHS status for entity E. If E is not a formal, this\n+   --  is simply the setting of the flag Referenced_As_LHS. If E is a body\n+   --  formal, the setting of the flag in the corresponding spec is also\n+   --  checked (and True returned if either flag is True).\n+\n+   procedure Warn_On_Unreferenced_Entity\n+     (Spec_E : Entity_Id;\n+      Body_E : Entity_Id := Empty);\n+   --  Output warnings for unreferenced entity E. For the case of an entry\n+   --  formal, Body_E is the corresponding body entity for a particular\n+   --  accept statement, and the message is posted on Body_E. In all other\n+   --  cases, Body_E is ignored and must be Empty.\n+\n    --------------------------\n    -- Check_Code_Statement --\n    --------------------------\n@@ -95,15 +141,15 @@ package body Sem_Warn is\n \n       if No (Asm_Input_Value) then\n          Error_Msg_F\n-           (\"?code statement with no inputs should usually be Volatile\", N);\n+           (\"?code statement with no inputs should usually be Volatile!\", N);\n          return;\n       end if;\n \n       Setup_Asm_Outputs (N);\n \n       if No (Asm_Output_Variable) then\n          Error_Msg_F\n-           (\"?code statement with no outputs should usually be Volatile\", N);\n+           (\"?code statement with no outputs should usually be Volatile!\", N);\n          return;\n       end if;\n \n@@ -114,9 +160,9 @@ package body Sem_Warn is\n         and then Nkind (Prev (N)) = N_Code_Statement\n       then\n          Error_Msg_F\n-           (\"?code statements in sequence should usually be Volatile\", N);\n+           (\"?code statements in sequence should usually be Volatile!\", N);\n          Error_Msg_F\n-           (\"\\?(suggest using template with multiple instructions)\", N);\n+           (\"\\?(suggest using template with multiple instructions)!\", N);\n       end if;\n    end Check_Code_Statement;\n \n@@ -131,17 +177,17 @@ package body Sem_Warn is\n    procedure Check_Infinite_Loop_Warning (Loop_Statement : Node_Id) is\n       Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n \n-      Ref : Node_Id   := Empty;\n-      --  Reference in iteration scheme to variable that may not be modified\n-      --  in loop, indicating a possible infinite loop.\n+      Ref : Node_Id := Empty;\n+      --  Reference in iteration scheme to variable that may not be modified in\n+      --  loop, indicating a possible infinite loop.\n \n       Var : Entity_Id := Empty;\n       --  Corresponding entity (entity of Ref)\n \n       procedure Find_Var (N : Node_Id);\n-      --  Inspect condition to see if it depends on a single entity\n-      --  reference. If so, Ref is set to point to the reference node,\n-      --  and Var is set to the referenced Entity.\n+      --  Inspect condition to see if it depends on a single entity reference.\n+      --  If so, Ref is set to point to the reference node, and Var is set to\n+      --  the referenced Entity.\n \n       function Has_Indirection (T : Entity_Id) return Boolean;\n       --  If the controlling variable is an access type, or is a record type\n@@ -408,12 +454,14 @@ package body Sem_Warn is\n          elsif Nkind (N) = N_Procedure_Call_Statement\n            or else Nkind (N) = N_Function_Call\n          then\n-            --  If subprogram is within the scope of the entity we are\n-            --  dealing with as the loop variable, then it could modify\n-            --  this parameter, so we abandon in this case. In the case\n-            --  of a subprogram that is not an entity we also abandon.\n+            --  If subprogram is within the scope of the entity we are dealing\n+            --  with as the loop variable, then it could modify this parameter,\n+            --  so we abandon in this case. In the case of a subprogram that is\n+            --  not an entity we also abandon. The check for no entity being\n+            --  present is a defense against previous errors.\n \n             if not Is_Entity_Name (Name (N))\n+              or else No (Entity (Name (N)))\n               or else Scope_Within (Entity (Name (N)), Scope (Var))\n             then\n                return Abandon;\n@@ -485,9 +533,9 @@ package body Sem_Warn is\n \n       if Find_Ref (Loop_Statement) = OK then\n          Error_Msg_NE\n-           (\"variable& is not modified in loop body?\", Ref, Var);\n+           (\"?variable& is not modified in loop body!\", Ref, Var);\n          Error_Msg_N\n-           (\"\\possible infinite loop\", Ref);\n+           (\"\\?possible infinite loop!\", Ref);\n       end if;\n    end Check_Infinite_Loop_Warning;\n \n@@ -499,6 +547,12 @@ package body Sem_Warn is\n       E1 : Entity_Id;\n       UR : Node_Id;\n \n+      function Body_Formal\n+        (E                : Entity_Id;\n+         Accept_Statement : Node_Id) return Entity_Id;\n+      --  For an entry formal entity from an entry declaration, find the\n+      --  corrsesponding body formal from the given accept statement.\n+\n       function Missing_Subunits return Boolean;\n       --  We suppress warnings when there are missing subunits, because this\n       --  may generate too many false positives: entities in a parent may only\n@@ -556,12 +610,53 @@ package body Sem_Warn is\n          end if;\n       end Missing_Subunits;\n \n+      -----------------\n+      -- Body_Formal --\n+      -----------------\n+\n+      function Body_Formal\n+        (E                : Entity_Id;\n+         Accept_Statement : Node_Id) return Entity_Id\n+      is\n+         Body_Param : Node_Id;\n+         Body_E     : Entity_Id;\n+\n+      begin\n+         --  Loop to find matching parameter in accept statement\n+\n+         Body_Param := First (Parameter_Specifications (Accept_Statement));\n+         while Present (Body_Param) loop\n+            Body_E := Defining_Identifier (Body_Param);\n+\n+            if Chars (Body_E) = Chars (E) then\n+               return Body_E;\n+            end if;\n+\n+            Next (Body_Param);\n+         end loop;\n+\n+         --  Should never fall through, should always find a match\n+\n+         raise Program_Error;\n+      end Body_Formal;\n+\n       ----------------------------\n       -- Output_Reference_Error --\n       ----------------------------\n \n       procedure Output_Reference_Error (M : String) is\n       begin\n+         --  Don't output message for IN OUT formal unless we have the warning\n+         --  flag specifically set. It is a bit odd to distinguish IN OUT\n+         --  formals from other cases. This distinction is historical in\n+         --  nature. Warnings for IN OUT formals were added fairly late.\n+\n+         if Ekind (E1) = E_In_Out_Parameter\n+           and then not Check_Unreferenced_Formals\n+         then\n+            return;\n+         end if;\n+\n          --  Other than accept case, post error on defining identifier\n \n          if No (Anod) then\n@@ -570,30 +665,8 @@ package body Sem_Warn is\n          --  Accept case, find body formal to post the message\n \n          else\n-            declare\n-               Parm  : Node_Id;\n-               Enod  : Node_Id;\n-               Defid : Entity_Id;\n-\n-            begin\n-               Enod := Anod;\n-\n-               if Present (Parameter_Specifications (Anod)) then\n-                  Parm := First (Parameter_Specifications (Anod));\n-                  while Present (Parm) loop\n-                     Defid := Defining_Identifier (Parm);\n+            Error_Msg_NE (M, Body_Formal (E1, Accept_Statement => Anod), E1);\n \n-                     if Chars (E1) = Chars (Defid) then\n-                        Enod := Defid;\n-                        exit;\n-                     end if;\n-\n-                     Next (Parm);\n-                  end loop;\n-               end if;\n-\n-               Error_Msg_NE (M, Enod, E1);\n-            end;\n          end if;\n       end Output_Reference_Error;\n \n@@ -606,6 +679,13 @@ package body Sem_Warn is\n          Prev : Node_Id;\n \n       begin\n+         --  A formal parameter is never referenceable outside the body of its\n+         --  subprogram or entry.\n+\n+         if Is_Formal (Ent) then\n+            return False;\n+         end if;\n+\n          --  Examine parents to look for a library level package spec. But if\n          --  we find a body or block or other similar construct along the way,\n          --  we cannot be referenced.\n@@ -627,17 +707,17 @@ package body Sem_Warn is\n                --  we will get a warning for the package entity.\n \n                --  Note that generic formal parameters are themselves not\n-               --  publicly referenceable in an instance, and warnings on\n-               --  them are useful.\n+               --  publicly referenceable in an instance, and warnings on them\n+               --  are useful.\n \n                when N_Generic_Package_Declaration =>\n                   return\n                     not Is_List_Member (Prev)\n                       or else List_Containing (Prev)\n                         /= Generic_Formal_Declarations (P);\n \n-               --  Similarly, the generic formals of a generic subprogram\n-               --  are not accessible.\n+               --  Similarly, the generic formals of a generic subprogram are\n+               --  not accessible.\n \n                when N_Generic_Subprogram_Declaration  =>\n                   if Is_List_Member (Prev)\n@@ -714,17 +794,19 @@ package body Sem_Warn is\n            and then not Warnings_Off (Etype (E1))\n            and then not Warnings_Off (Base_Type (Etype (E1)))\n          then\n-            --  We are interested in variables and out parameters, but we\n-            --  exclude protected types, too complicated to worry about.\n+            --  We are interested in variables and out/in-out parameters, but\n+            --  we exclude protected types, too complicated to worry about.\n \n             if Ekind (E1) = E_Variable\n                  or else\n-               (Ekind (E1) = E_Out_Parameter\n+                ((Ekind (E1) = E_Out_Parameter\n+                    or else Ekind (E1) = E_In_Out_Parameter)\n                   and then not Is_Protected_Type (Current_Scope))\n             then\n-               --  Post warning if this object not assigned. Note that we do\n-               --  not consider the implicit initialization of an access type\n-               --  to be the assignment of a value for this purpose.\n+               --  Case of an unassigned variable\n+\n+               --  First gather any Unset_Reference indication for E1. In the\n+               --  case of a parameter, it is the Spec_Entity that is relevant.\n \n                if Ekind (E1) = E_Out_Parameter\n                  and then Present (Spec_Entity (E1))\n@@ -737,7 +819,7 @@ package body Sem_Warn is\n                --  If the entity is an out parameter of the current subprogram\n                --  body, check the warning status of the parameter in the spec.\n \n-               if Ekind (E1) = E_Out_Parameter\n+               if Is_Formal (E1)\n                  and then Present (Spec_Entity (E1))\n                  and then Warnings_Off (Spec_Entity (E1))\n                then\n@@ -746,63 +828,15 @@ package body Sem_Warn is\n                elsif Present (UR)\n                  and then Is_Access_Type (Etype (E1))\n                then\n-\n                   --  For access types, the only time we made a UR entry was\n                   --  for a dereference, and so we post the appropriate warning\n                   --  here (note that the dereference may not be explicit in\n                   --  the source, for example in the case of a dispatching call\n                   --  with an anonymous access controlling formal, or of an\n-                  --  assignment of a pointer involving discriminant check on\n-                  --  the designated object).\n+                  --  assignment of a pointer involving discriminant check\n+                  --  on the designated object).\n \n-                  Error_Msg_NE (\"& may be null?\", UR, E1);\n-                  goto Continue;\n-\n-               elsif Never_Set_In_Source (E1)\n-                 and then not Generic_Package_Spec_Entity (E1)\n-               then\n-                  if Warn_On_No_Value_Assigned then\n-\n-                     --  Do not output complaint about never being assigned a\n-                     --  value if a pragma Unreferenced applies to the variable\n-                     --  or if it is a parameter, to the corresponding spec.\n-\n-                     if Has_Pragma_Unreferenced (E1)\n-                       or else Has_Pragma_Unreferenced_Objects (Etype (E1))\n-                       or else (Is_Formal (E1)\n-                                  and then Present (Spec_Entity (E1))\n-                                  and then\n-                                    Has_Pragma_Unreferenced (Spec_Entity (E1)))\n-                     then\n-                        null;\n-\n-                     --  Pragma Unreferenced not set, so output message\n-\n-                     else\n-                        if Referenced (E1) then\n-                           Output_Reference_Error\n-                             (\"variable& is read but never assigned?\");\n-                        else\n-                           Output_Reference_Error\n-                             (\"variable& is never read and never assigned?\");\n-                        end if;\n-\n-                        --  Deal with special case where this variable is\n-                        --  hidden by a loop variable\n-\n-                        if Ekind (E1) = E_Variable\n-                          and then Present (Hiding_Loop_Variable (E1))\n-                        then\n-                           Error_Msg_Sloc := Sloc (E1);\n-                           Error_Msg_N\n-                             (\"declaration hides &#?\",\n-                              Hiding_Loop_Variable (E1));\n-                           Error_Msg_N\n-                             (\"for loop implicitly declares loop variable?\",\n-                              Hiding_Loop_Variable (E1));\n-                        end if;\n-                     end if;\n-                  end if;\n+                  Error_Msg_NE (\"?& may be null!\", UR, E1);\n                   goto Continue;\n \n                --  Case of variable that could be a constant. Note that we\n@@ -811,8 +845,12 @@ package body Sem_Warn is\n                --  the package.\n \n                elsif Warn_On_Constant\n-                 and then Ekind (E1) = E_Variable\n-                 and then Is_True_Constant (E1)\n+                 and then ((Ekind (E1) = E_Variable\n+                              and then Has_Initial_Value (E1))\n+                             or else\n+                            Ekind (E1) = E_In_Out_Parameter)\n+                 and then Never_Set_In_Source_Check_Spec (E1)\n+                 and then not Address_Taken (E1)\n                  and then not Generic_Package_Spec_Entity (E1)\n                then\n                   --  A special case, if this variable is volatile and not\n@@ -824,44 +862,203 @@ package body Sem_Warn is\n                     and then not Is_Imported (E1)\n                   then\n                      Error_Msg_N\n-                       (\"& is not modified, volatile has no effect?\", E1);\n+                       (\"?& is not modified, volatile has no effect!\", E1);\n+\n+                  --  Another special case, Exception_Occurrence, this catches\n+                  --  the case of exception choice (and a bit more too, but not\n+                  --  worth doing more investigation here).\n+\n+                  elsif Is_RTE (Etype (E1), RE_Exception_Occurrence) then\n+                     null;\n+\n+                  --  Here we give the warning if referenced and no pragma\n+                  --  Unreferenced is present.\n+\n                   else\n-                     Error_Msg_N\n-                       (\"& is not modified, could be declared constant?\", E1);\n+                     if Ekind (E1) = E_Variable then\n+                        if Referenced_Check_Spec (E1)\n+                          and then not Has_Pragma_Unreferenced_Check_Spec (E1)\n+                        then\n+                           Error_Msg_N\n+                             (\"?& is not modified, \"\n+                              & \"could be declared constant!\",\n+                              E1);\n+                        end if;\n+\n+                     else pragma Assert (Ekind (E1) = E_In_Out_Parameter);\n+                        if Referenced_Check_Spec (E1)\n+                          and then\n+                            not Has_Pragma_Unreferenced_Check_Spec (E1)\n+                        then\n+                           --  Suppress warning if private type, since in this\n+                           --  case it may be quite reasonable for the logical\n+                           --  view to be in out, even if the implementation\n+                           --  ends up using access types.\n+\n+                           if Has_Private_Declaration (Etype (E1)) then\n+                              null;\n+\n+                           --  Suppress warning for any composite type, since\n+                           --  for composites it seems quite reasonable to pass\n+                           --  a value of the composite type and then modify\n+                           --  just a component.\n+\n+                           elsif Is_Composite_Type (Etype (E1)) then\n+                              null;\n+\n+                           --  Suppress warning for parameter of dispatching\n+                           --  operation, since it is quite reasonable to have\n+                           --  an operation that is overridden, and for some\n+                           --  subclasses needs to be IN OUT and for others\n+                           --  the parameter does not happen to be assigned.\n+\n+                           elsif Is_Dispatching_Operation\n+                             (Scope (Goto_Spec_Entity (E1)))\n+                           then\n+                              null;\n+\n+                           --  OK, looks like warning for an IN OUT parameter\n+                           --  that could be IN makes sense, but we delay the\n+                           --  output of the warning, pending possibly finding\n+                           --  out later on that the associated subprogram is\n+                           --  used as a generic actual, or its address/access\n+                           --  is taken. In these two cases, we suppress the\n+                           --  warning because the context may force use of IN\n+                           --  OUT, even if in this particular case the formal\n+                           --  is not modifed.\n+\n+                           else\n+                              In_Out_Warnings.Append (E1);\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+                  --  Other cases of a variable never set in source\n+\n+               elsif Never_Set_In_Source_Check_Spec (E1)\n+\n+                  --  No warning if warning for this case turned off\n+\n+                  and then Warn_On_No_Value_Assigned\n+\n+                  --  No warning if address taken somewhere\n+\n+                  and then not Address_Taken (E1)\n+\n+                  --  No warning if explicit initial value\n+\n+                  and then not Has_Initial_Value (E1)\n+\n+                  --  No warning for generic package spec entities, since we\n+                  --  might set them in a child unit or something like that\n+\n+                  and then not Generic_Package_Spec_Entity (E1)\n+\n+                  --  No warning if fully initialized type, except that for\n+                  --  this purpose we do not consider access types to qualify\n+                  --  as fully initialized types (relying on an access type\n+                  --  variable being null when it is never set is a bit odd!)\n+\n+                  --  Also we generate warning for an out parameter that is\n+                  --  never referenced, since again it seems odd to rely on\n+                  --  default initialization to set an out parameter value.\n+\n+                 and then (Is_Access_Type (Etype (E1))\n+                            or else Ekind (E1) = E_Out_Parameter\n+                            or else not Is_Fully_Initialized_Type (Etype (E1)))\n+               then\n+                  --  Do not output complaint about never being assigned a\n+                  --  value if a pragma Unreferenced applies to the variable\n+                  --  we are examining, or if it is a parameter, if there is\n+                  --  a pragma Unreferenced for the corresponding spec.\n+\n+                  if Has_Pragma_Unreferenced_Check_Spec (E1)\n+                    or else Has_Pragma_Unreferenced_Objects (Etype (E1))\n+                  then\n+                     null;\n+\n+                  --  Case of unreferenced formal\n+\n+                  elsif Is_Formal (E1) then\n+                     if Referenced_Check_Spec (E1) then\n+                        Output_Reference_Error\n+                          (\"?formal parameter& is read but never assigned!\");\n+                     else\n+                        Output_Reference_Error\n+                          (\"?formal parameter& is not referenced!\");\n+                     end if;\n+\n+                  --  Case of variable\n+\n+                  else\n+                     if Referenced (E1) then\n+                        Output_Reference_Error\n+                          (\"?variable& is read but never assigned!\");\n+                     else\n+                        Output_Reference_Error\n+                          (\"?variable& is never read and never assigned!\");\n+                     end if;\n+\n+                     --  Deal with special case where this variable is\n+                     --  hidden by a loop variable\n+\n+                     if Ekind (E1) = E_Variable\n+                       and then Present (Hiding_Loop_Variable (E1))\n+                     then\n+                        Error_Msg_N\n+                          (\"?for loop implicitly declares loop variable!\",\n+                           Hiding_Loop_Variable (E1));\n+\n+                        Error_Msg_Sloc := Sloc (E1);\n+                        Error_Msg_N\n+                          (\"\\?declaration hides & declared#!\",\n+                           Hiding_Loop_Variable (E1));\n+                     end if;\n                   end if;\n+\n+                  goto Continue;\n                end if;\n \n-               --  Check for unset reference, note that we exclude access\n-               --  types from this check, since access types do always have\n-               --  a null value, and that seems legitimate in this case.\n+               --  Check for unset reference\n \n                if Warn_On_No_Value_Assigned and then Present (UR) then\n \n-                  --  For other than access type, go back to original node\n-                  --  to deal with case where original unset reference\n-                  --  has been rewritten during expansion.\n+                  --  For other than access type, go back to original node to\n+                  --  deal with case where original unset reference has been\n+                  --  rewritten during expansion.\n \n-                  UR := Original_Node (UR);\n-\n-                  --  In some cases, the original node may be a type\n-                  --  conversion or qualification, and in this case\n-                  --  we want the object entity inside.\n+                  --  In some cases, the original node may be a type conversion\n+                  --  or qualification, and in this case we want the object\n+                  --  entity inside.\n \n+                  UR := Original_Node (UR);\n                   while Nkind (UR) = N_Type_Conversion\n                     or else Nkind (UR) = N_Qualified_Expression\n                   loop\n                      UR := Expression (UR);\n                   end loop;\n \n-                  --  Here we issue the warning, all checks completed If the\n-                  --  unset reference is prefix of a selected component that\n-                  --  comes from source, mention the component as well. If the\n-                  --  selected component comes from expansion, all we know is\n-                  --  that the entity is not fully initialized at the point of\n-                  --  the reference. Locate an unintialized component to get a\n-                  --  better error message.\n+                  --  Here we issue the warning, all checks completed\n+\n+                  --  If we have a return statement, this was a case of an OUT\n+                  --  parameter not being set at the time of the return. (Note:\n+                  --  it can't be N_Extended_Return_Statement, because those\n+                  --  are only for functions, and functions do not allow OUT\n+                  --  parameters.)\n+\n+                  if Nkind (UR) = N_Simple_Return_Statement then\n+                     Error_Msg_NE\n+                       (\"?OUT parameter& not set before return\", UR, E1);\n+\n+                  --  If the unset reference is prefix of a selected component\n+                  --  that comes from source, mention the component as well. If\n+                  --  the selected component comes from expansion, all we know\n+                  --  is that the entity is not fully initialized at the point\n+                  --  of the reference. Locate an unintialized component to get\n+                  --  a better error message.\n \n-                  if Nkind (Parent (UR)) = N_Selected_Component then\n+                  elsif Nkind (Parent (UR)) = N_Selected_Component then\n                      Error_Msg_Node_2 := Selector_Name (Parent (UR));\n \n                      if not Comes_From_Source (Parent (UR)) then\n@@ -873,7 +1070,7 @@ package body Sem_Warn is\n                            while Present (Comp) loop\n                               if Ekind (Comp) = E_Component\n                                 and then Nkind (Parent (Comp)) =\n-                                  N_Component_Declaration\n+                                                      N_Component_Declaration\n                                 and then No (Expression (Parent (Comp)))\n                               then\n                                  Error_Msg_Node_2 := Comp;\n@@ -885,12 +1082,24 @@ package body Sem_Warn is\n                         end;\n                      end if;\n \n-                     Error_Msg_N\n-                       (\"`&.&` may be referenced before it has a value?\",\n-                        UR);\n+                     --  Issue proper warning. This is a case of referencing\n+                     --  a variable before it has been explicitly assigned.\n+                     --  For access types, UR was only set for dereferences,\n+                     --  so the issue is that the value may be null.\n+\n+                     if Is_Access_Type (Etype (Parent (UR))) then\n+                        Error_Msg_N (\"?`&.&` may be null!\", UR);\n+                     else\n+                        Error_Msg_N\n+                          (\"?`&.&` may be referenced before it has a value!\",\n+                           UR);\n+                     end if;\n+\n+                  --  All other cases of unset reference active\n+\n                   else\n                      Error_Msg_N\n-                       (\"& may be referenced before it has a value?\",\n+                       (\"?& may be referenced before it has a value!\",\n                         UR);\n                   end if;\n \n@@ -903,7 +1112,7 @@ package body Sem_Warn is\n             --  set. The Referenced_As_LHS flag is interesting only if the\n             --  Referenced flag is not set.\n \n-            if not Referenced (E1)\n+            if not Referenced_Check_Spec (E1)\n \n                --  Check that warnings on unreferenced entities are enabled\n \n@@ -912,7 +1121,7 @@ package body Sem_Warn is\n                         (Check_Unreferenced_Formals and then Is_Formal (E1))\n                            or else\n                         (Warn_On_Modified_Unread\n-                          and then Referenced_As_LHS (E1)))\n+                          and then Referenced_As_LHS_Check_Spec (E1)))\n \n                --  Labels, and enumeration literals, and exceptions. The\n                --  warnings are also placed on local packages that cannot be\n@@ -1026,17 +1235,23 @@ package body Sem_Warn is\n                   --  We do not immediately flag the error. This is because we\n                   --  have not expanded generic bodies yet, and they may have\n                   --  the missing reference. So instead we park the entity on a\n-                  --  list, for later processing. However, for the accept case,\n-                  --  post the error right here, since we have the information\n-                  --  now in this case.\n+                  --  list, for later processing. However for the case of an\n+                  --  accept statement we want to output messages now, since\n+                  --  we know we already have all information at hand, and we\n+                  --  also want to have separate warnings for each accept\n+                  --  statement for the same entry.\n \n                   if Present (Anod) then\n-                     Output_Reference_Error (\"& is not referenced?\");\n+                     pragma Assert (Is_Formal (E1));\n+\n+                     --  The unreferenced entity is E1, but post the warning\n+                     --  on the body entity for this accept statement.\n+\n+                     Warn_On_Unreferenced_Entity\n+                       (E1, Body_Formal (E1, Accept_Statement => Anod));\n \n                   else\n-                     Unreferenced_Entities.Increment_Last;\n-                     Unreferenced_Entities.Table\n-                       (Unreferenced_Entities.Last) := E1;\n+                     Unreferenced_Entities.Append (E1);\n                   end if;\n                end if;\n \n@@ -1051,8 +1266,7 @@ package body Sem_Warn is\n               and then Instantiation_Depth (Sloc (E1)) = 0\n               and then Warn_On_Redundant_Constructs\n             then\n-               Unreferenced_Entities.Increment_Last;\n-               Unreferenced_Entities.Table (Unreferenced_Entities.Last) := E1;\n+               Unreferenced_Entities.Append (E1);\n \n                --  Force warning on entity\n \n@@ -1084,20 +1298,80 @@ package body Sem_Warn is\n    ---------------------------\n \n    procedure Check_Unset_Reference (N : Node_Id) is\n+      Typ : constant Entity_Id := Etype (N);\n+\n+      function Is_OK_Fully_Initialized return Boolean;\n+      --  This function returns true if the given node N is fully initialized\n+      --  so that the reference is safe as far as this routine is concerned.\n+      --  Safe generally means that the type of N is a fully initialized type.\n+      --  The one special case is that for access types, which are always fully\n+      --  initialized, we don't consider a dereference OK since it will surely\n+      --  be dereferencing a null value, which won't do.\n+\n+      function Prefix_Has_Dereference (Pref : Node_Id) return Boolean;\n+      --  Used to test indexed or selected component or slice to see if the\n+      --  evaluation of the prefix depends on a dereference, and if so, returns\n+      --  True, in which case we always check the prefix, even if we know that\n+      --  the referenced component is initialized. Pref is the prefix to test.\n+\n+      -----------------------------\n+      -- Is_OK_Fully_Initialized --\n+      -----------------------------\n+\n+      function Is_OK_Fully_Initialized return Boolean is\n+      begin\n+         if Is_Access_Type (Typ) and then Is_Dereferenced (N) then\n+            return False;\n+         else\n+            return Is_Fully_Initialized_Type (Typ);\n+         end if;\n+      end Is_OK_Fully_Initialized;\n+\n+      ----------------------------\n+      -- Prefix_Has_Dereference --\n+      ----------------------------\n+\n+      function Prefix_Has_Dereference (Pref : Node_Id) return Boolean is\n+      begin\n+         --  If prefix is of an access type, certainly need a dereference\n+\n+         if Is_Access_Type (Etype (Pref)) then\n+            return True;\n+\n+         --  If prefix is explicit dereference, that's a dereference for sure\n+\n+         elsif Nkind (Pref) = N_Explicit_Dereference then\n+            return True;\n+\n+            --  If prefix is itself a component reference or slice check prefix\n+\n+         elsif Nkind (Pref) = N_Slice\n+           or else Nkind (Pref) = N_Indexed_Component\n+           or else Nkind (Pref) = N_Selected_Component\n+         then\n+            return Prefix_Has_Dereference (Prefix (Pref));\n+\n+         --  All other cases do not involve a dereference\n+\n+         else\n+            return False;\n+         end if;\n+      end Prefix_Has_Dereference;\n+\n+   --  Start of processing for Check_Unset_Reference\n+\n    begin\n       --  Nothing to do if warnings suppressed\n \n       if Warning_Mode = Suppress then\n          return;\n       end if;\n \n-      --  Ignore reference to non-scalar if not from source. Almost always such\n-      --  references are bogus (e.g. calls to init procs to set default\n-      --  discriminant values).\n+      --  Ignore reference unless it comes from source. Almost always if we\n+      --  have a reference from generated code, it is bogus (e.g. calls to init\n+      --  procs to set default discriminant values).\n \n-      if not Comes_From_Source (N)\n-        and then not Is_Scalar_Type (Etype (N))\n-      then\n+      if not Comes_From_Source (N) then\n          return;\n       end if;\n \n@@ -1110,21 +1384,27 @@ package body Sem_Warn is\n       --  unset reference, we check whether N is earlier before proceeding.\n \n       case Nkind (N) is\n+\n+         --  For identifier or exanded name, examine the entity involved\n+\n          when N_Identifier | N_Expanded_Name =>\n             declare\n                E : constant Entity_Id := Entity (N);\n \n             begin\n                if (Ekind (E) = E_Variable\n-                    or else Ekind (E) = E_Out_Parameter)\n-                 and then Never_Set_In_Source (E)\n+                     or else\n+                   Ekind (E) = E_Out_Parameter)\n+                 and then Never_Set_In_Source_Check_Spec (E)\n+                 and then not Has_Initial_Value (E)\n                  and then (No (Unset_Reference (E))\n-                             or else Earlier_In_Extended_Unit\n-                               (Sloc (N),  Sloc (Unset_Reference (E))))\n+                            or else\n+                              Earlier_In_Extended_Unit\n+                                (Sloc (N),  Sloc (Unset_Reference (E))))\n                  and then not Warnings_Off (E)\n                then\n                   --  We may have an unset reference. The first test is whether\n-                  --  we are accessing a discriminant of a record or a\n+                  --  this is an access to a discriminant of a record or a\n                   --  component with default initialization. Both of these\n                   --  cases can be ignored, since the actual object that is\n                   --  referenced is definitely initialized. Note that this\n@@ -1137,21 +1417,29 @@ package body Sem_Warn is\n                   --  not the record, and still deserves an unset reference.\n \n                   if Nkind (Parent (N)) = N_Selected_Component\n-                    and not Is_Access_Type (Etype (N))\n+                    and not Is_Access_Type (Typ)\n                   then\n                      declare\n                         ES : constant Entity_Id :=\n                                Entity (Selector_Name (Parent (N)));\n-\n                      begin\n                         if Ekind (ES) = E_Discriminant\n-                          or else Present (Expression (Declaration_Node (ES)))\n+                          or else\n+                            (Present (Declaration_Node (ES))\n+                               and then\n+                             Present (Expression (Declaration_Node (ES))))\n                         then\n                            return;\n                         end if;\n                      end;\n                   end if;\n \n+                  --  Exclude fully initialized types\n+\n+                  if Is_OK_Fully_Initialized then\n+                     return;\n+                  end if;\n+\n                   --  Here we have a potential unset reference. But before we\n                   --  get worried about it, we have to make sure that the\n                   --  entity declaration is in the same procedure as the\n@@ -1187,13 +1475,12 @@ package body Sem_Warn is\n                      --  cannot be truly uninitialized, but we still want to\n                      --  warn about cases of obvious null dereference.\n \n-                     if Is_Access_Type (Etype (N)) then\n+                     if Is_Access_Type (Typ) then\n                         Access_Type_Case : declare\n                            P : Node_Id;\n \n                            function Process\n-                             (N    : Node_Id)\n-                              return Traverse_Result;\n+                             (N : Node_Id) return Traverse_Result;\n                            --  Process function for instantation of Traverse\n                            --  below. Checks if N contains reference to other\n                            --  than a dereference.\n@@ -1207,8 +1494,7 @@ package body Sem_Warn is\n                            -------------\n \n                            function Process\n-                             (N    : Node_Id)\n-                              return Traverse_Result\n+                             (N : Node_Id) return Traverse_Result\n                            is\n                            begin\n                               if Is_Entity_Name (N)\n@@ -1234,18 +1520,18 @@ package body Sem_Warn is\n                         --  Start of processing for Access_Type_Case\n \n                         begin\n-                           --  Don't bother if we are inside an instance,\n-                           --  since the compilation of the generic template\n-                           --  is where the warning should be issued.\n+                           --  Don't bother if we are inside an instance, since\n+                           --  the compilation of the generic template is where\n+                           --  the warning should be issued.\n \n                            if In_Instance then\n                               return;\n                            end if;\n \n-                           --  Don't bother if this is not the main unit.\n-                           --  If we try to give this warning for with'ed\n-                           --  units, we get some false positives, since\n-                           --  we do not record references in other units.\n+                           --  Don't bother if this is not the main unit. If we\n+                           --  try to give this warning for with'ed units, we\n+                           --  get some false positives, since we do not record\n+                           --  references in other units.\n \n                            if not In_Extended_Main_Source_Unit (E)\n                                 or else\n@@ -1301,8 +1587,8 @@ package body Sem_Warn is\n                      if Nkind (N) = N_Identifier then\n                         Set_Unset_Reference (E, N);\n \n-                     --  Otherwise it is an expanded name, so set the field\n-                     --  of the actual identifier for the reference.\n+                     --  Otherwise it is an expanded name, so set the field of\n+                     --  the actual identifier for the reference.\n \n                      else\n                         Set_Unset_Reference (E, Selector_Name (N));\n@@ -1311,25 +1597,90 @@ package body Sem_Warn is\n                end if;\n             end;\n \n+         --  Indexed component or slice\n+\n          when N_Indexed_Component | N_Slice =>\n-            Check_Unset_Reference (Prefix (N));\n \n-         when N_Selected_Component =>\n+            --  If prefix does not involve dereferencing an access type, then\n+            --  we know we are OK if the component type is fully initialized,\n+            --  since the component will have been set as part of the default\n+            --  initialization.\n \n-            if Present (Entity (Selector_Name (N)))\n-              and then Ekind (Entity (Selector_Name (N))) = E_Discriminant\n+            if not Prefix_Has_Dereference (Prefix (N))\n+              and then Is_OK_Fully_Initialized\n             then\n-               --   A discriminant is always initialized\n+               return;\n \n-               null;\n+            --  Look at prefix in access type case, or if the component is not\n+            --  fully initialized.\n \n             else\n                Check_Unset_Reference (Prefix (N));\n             end if;\n \n+         --  Record component\n+\n+         when N_Selected_Component =>\n+            declare\n+               Pref : constant Node_Id   := Prefix (N);\n+               Ent  : constant Entity_Id := Entity (Selector_Name (N));\n+\n+            begin\n+               --  If prefix involves dereferencing an access type, always\n+               --  check the prefix, since the issue then is whether this\n+               --  access value is null.\n+\n+               if Prefix_Has_Dereference (Pref) then\n+                  null;\n+\n+               --  Always go to prefix if no selector entity is set. Can this\n+               --  happen in the normal case? Not clear, but it definitely can\n+               --  happen in error cases.\n+\n+               elsif No (Ent) then\n+                  null;\n+\n+               --  For a record component, check some cases where we have\n+               --  reasonable cause to consider that the component is known to\n+               --  be or probably is initialized. In this case, we don't care\n+               --  if the prefix itself was explicitly initialized.\n+\n+               --  Discriminants are always considered initialized\n+\n+               elsif Ekind (Ent) = E_Discriminant then\n+                  return;\n+\n+               --  An explicitly initialized component is certainly initialized\n+\n+               elsif Nkind (Parent (Ent)) = N_Component_Declaration\n+                 and then Present (Expression (Parent (Ent)))\n+               then\n+                  return;\n+\n+               --  A fully initialized component is initialized\n+\n+               elsif Is_OK_Fully_Initialized then\n+                  return;\n+               end if;\n+\n+               --  If none of those cases apply, check the record type prefix\n+\n+               Check_Unset_Reference (Pref);\n+            end;\n+\n+         --  For type conversions or qualifications examine the expression\n+\n          when N_Type_Conversion | N_Qualified_Expression =>\n             Check_Unset_Reference (Expression (N));\n \n+         --  For explicit dereference, always check prefix, which will generate\n+         --  an unset reference (since this is a case of dereferencing null).\n+\n+         when N_Explicit_Dereference =>\n+            Check_Unset_Reference (Prefix (N));\n+\n+         --  All other cases are not cases of an unset reference\n+\n          when others =>\n             null;\n \n@@ -1406,7 +1757,7 @@ package body Sem_Warn is\n                      if Entity (Nam) = Pack then\n                         Error_Msg_Qual_Level := 1;\n                         Error_Msg_NE\n-                          (\"no entities of package& are referenced?\",\n+                          (\"?no entities of package& are referenced!\",\n                              Nam, Pack);\n                         Error_Msg_Qual_Level := 0;\n                      end if;\n@@ -1423,7 +1774,7 @@ package body Sem_Warn is\n          begin\n             E := First_Entity (Pack);\n             while Present (E) loop\n-               if Referenced (E) then\n+               if Referenced_Check_Spec (E) then\n                   return;\n                end if;\n \n@@ -1451,7 +1802,7 @@ package body Sem_Warn is\n             then\n                Ent := First_Entity (System_Aux_Id);\n                while Present (Ent) loop\n-                  if Referenced (Ent) then\n+                  if Referenced_Check_Spec (Ent) then\n                      return True;\n                   end if;\n \n@@ -1559,7 +1910,7 @@ package body Sem_Warn is\n \n                      else\n                         Error_Msg_N\n-                          (\"unit& is not referenced?\", Name (Item));\n+                          (\"?unit& is not referenced!\", Name (Item));\n                      end if;\n                   end if;\n \n@@ -1630,7 +1981,7 @@ package body Sem_Warn is\n \n                            else\n                               Error_Msg_N\n-                                (\"no entities of & are referenced?\",\n+                                (\"?no entities of & are referenced!\",\n                                  Name (Item));\n \n                               --  Look for renamings of this package, and flag\n@@ -1644,24 +1995,31 @@ package body Sem_Warn is\n                                 and then not Warnings_Off (Lunit)\n                               then\n                                  Error_Msg_NE\n-                                   (\"no entities of & are referenced?\",\n+                                   (\"?no entities of & are referenced!\",\n                                      Unit_Declaration_Node (Pack),\n                                        Pack);\n                               end if;\n                            end if;\n \n                            exit;\n \n-                        --  Case of next entity is referenced\n-\n-                        elsif Referenced (Ent)\n-                          or else Referenced_As_LHS (Ent)\n+                        --  Case of entity being referenced. The reference may\n+                        --  come from a limited_with_clause, in which case the\n+                        --  limited view of the entity carries the flag.\n+\n+                        elsif Referenced_Check_Spec (Ent)\n+                          or else Referenced_As_LHS_Check_Spec (Ent)\n+                          or else\n+                            (From_With_Type (Ent)\n+                              and then Is_Incomplete_Type (Ent)\n+                              and then Present (Non_Limited_View (Ent))\n+                              and then Referenced (Non_Limited_View (Ent)))\n                         then\n                            --  This means that the with is indeed fine, in that\n                            --  it is definitely needed somewhere, and we can\n-                           --  quit worrying about this one.\n+                           --  quit worrying about this one...\n \n-                           --  Except for one little detail, if either of the\n+                           --  Except for one little detail: if either of the\n                            --  flags was set during spec processing, this is\n                            --  where we complain that the with could be moved\n                            --  from the spec. If the spec contains a visible\n@@ -1676,12 +2034,12 @@ package body Sem_Warn is\n \n                            if Unreferenced_In_Spec (Item) then\n                               Error_Msg_N\n-                                (\"unit& is not referenced in spec?\",\n+                                (\"?unit& is not referenced in spec!\",\n                                  Name (Item));\n \n                            elsif No_Entities_Ref_In_Spec (Item) then\n                               Error_Msg_N\n-                                (\"no entities of & are referenced in spec?\",\n+                                (\"?no entities of & are referenced in spec!\",\n                                  Name (Item));\n \n                            else\n@@ -1694,7 +2052,7 @@ package body Sem_Warn is\n \n                            if not Is_Visible_Renaming then\n                               Error_Msg_N\n-                                (\"\\with clause might be moved to body?\",\n+                                (\"\\?with clause might be moved to body!\",\n                                  Name (Item));\n                            end if;\n \n@@ -1722,7 +2080,7 @@ package body Sem_Warn is\n                         Set_Unreferenced_In_Spec (Item);\n                      else\n                         Error_Msg_N\n-                          (\"unit& is never instantiated?\", Name (Item));\n+                          (\"?unit& is never instantiated!\", Name (Item));\n                      end if;\n \n                   --  If unit was indeed instantiated, make sure that flag is\n@@ -1731,9 +2089,9 @@ package body Sem_Warn is\n \n                   elsif Unreferenced_In_Spec (Item) then\n                      Error_Msg_N\n-                       (\"unit& is not instantiated in spec?\", Name (Item));\n+                       (\"?unit& is not instantiated in spec!\", Name (Item));\n                      Error_Msg_N\n-                       (\"\\with clause can be moved to body?\", Name (Item));\n+                       (\"\\?with clause can be moved to body!\", Name (Item));\n                   end if;\n                end if;\n             end if;\n@@ -1809,6 +2167,53 @@ package body Sem_Warn is\n       end if;\n    end Generic_Package_Spec_Entity;\n \n+   ----------------------\n+   -- Goto_Spec_Entity --\n+   ----------------------\n+\n+   function Goto_Spec_Entity (E : Entity_Id) return Entity_Id is\n+   begin\n+      if Is_Formal (E)\n+        and then Present (Spec_Entity (E))\n+      then\n+         return Spec_Entity (E);\n+      else\n+         return E;\n+      end if;\n+   end Goto_Spec_Entity;\n+\n+   ----------------------------------------\n+   -- Has_Pragma_Unreferenced_Check_Spec --\n+   ----------------------------------------\n+\n+   function Has_Pragma_Unreferenced_Check_Spec\n+     (E : Entity_Id) return Boolean\n+   is\n+   begin\n+      if Is_Formal (E) and then Present (Spec_Entity (E)) then\n+         return Has_Pragma_Unreferenced (E)\n+                  or else\n+                Has_Pragma_Unreferenced (Spec_Entity (E));\n+      else\n+         return Has_Pragma_Unreferenced (E);\n+      end if;\n+   end Has_Pragma_Unreferenced_Check_Spec;\n+\n+   ------------------------------------\n+   -- Never_Set_In_Source_Check_Spec --\n+   ------------------------------------\n+\n+   function Never_Set_In_Source_Check_Spec (E : Entity_Id) return Boolean is\n+   begin\n+      if Is_Formal (E) and then Present (Spec_Entity (E)) then\n+         return Never_Set_In_Source (E)\n+                  and then\n+                Never_Set_In_Source (Spec_Entity (E));\n+      else\n+         return Never_Set_In_Source (E);\n+      end if;\n+   end Never_Set_In_Source_Check_Spec;\n+\n    -------------------------------------\n    -- Operand_Has_Warnings_Suppressed --\n    -------------------------------------\n@@ -1856,6 +2261,72 @@ package body Sem_Warn is\n          return False;\n    end Operand_Has_Warnings_Suppressed;\n \n+   -----------------------------------------\n+   -- Output_Non_Modified_In_Out_Warnings --\n+   -----------------------------------------\n+\n+   procedure Output_Non_Modifed_In_Out_Warnings is\n+\n+      function No_Warn_On_In_Out (E : Entity_Id) return Boolean;\n+      --  Given a formal parameter entity E, determines if there is a reason to\n+      --  suppress IN OUT warnings (not modified, could be IN) for formals of\n+      --  the subprogram. We suppress these warnings if Warnings Off is set, or\n+      --  if we have seen the address of the subprogram being taken, or if the\n+      --  subprogram is used as a generic actual (in the latter cases the\n+      --  context may force use of IN OUT, even if the parameter is not\n+      --  modifies for this particular case.\n+\n+      -----------------------\n+      -- No_Warn_On_In_Out --\n+      -----------------------\n+\n+      function No_Warn_On_In_Out (E : Entity_Id) return Boolean is\n+         S : constant Entity_Id := Scope (E);\n+      begin\n+         if Warnings_Off (S) then\n+            return True;\n+         elsif Address_Taken (S) then\n+            return True;\n+         elsif Used_As_Generic_Actual (S) then\n+            return True;\n+         elsif Present (Spec_Entity (E)) then\n+            return No_Warn_On_In_Out (Spec_Entity (E));\n+         else\n+            return False;\n+         end if;\n+      end No_Warn_On_In_Out;\n+\n+   --  Start of processing for Output_Non_Modifed_In_Out_Warnings\n+\n+   begin\n+      --  Loop through entities for which a warning may be needed\n+\n+      for J in In_Out_Warnings.First .. In_Out_Warnings.Last loop\n+         declare\n+            E1 : constant Entity_Id := In_Out_Warnings.Table (J);\n+\n+         begin\n+            --  Suppress warning in specific cases (see details in comments for\n+            --  No_Warn_On_In_Out).\n+\n+            if No_Warn_On_In_Out (E1) then\n+               null;\n+\n+            --  Here we generate the warning\n+\n+            else\n+               Error_Msg_N (\"?formal parameter & is not modified!\", E1);\n+               Error_Msg_N (\"\\?mode could be IN instead of `IN OUT`!\", E1);\n+\n+               --  Kill any other warnings on this entity, since this is the\n+               --  one that should dominate any other unreferenced warning.\n+\n+               Set_Warnings_Off (E1);\n+            end if;\n+         end;\n+      end loop;\n+   end Output_Non_Modifed_In_Out_Warnings;\n+\n    ----------------------------------------\n    -- Output_Obsolescent_Entity_Warnings --\n    ----------------------------------------\n@@ -2004,119 +2475,40 @@ package body Sem_Warn is\n    ----------------------------------\n \n    procedure Output_Unreferenced_Messages is\n-      E : Entity_Id;\n-\n    begin\n       for J in Unreferenced_Entities.First ..\n                Unreferenced_Entities.Last\n       loop\n-         E := Unreferenced_Entities.Table (J);\n-\n-         if not Referenced (E) and then not Warnings_Off (E) then\n-            case Ekind (E) is\n-               when E_Variable =>\n-\n-                  --  Case of variable that is assigned but not read. We\n-                  --  suppress the message if the variable is volatile, has an\n-                  --  address clause, or is imported.\n-\n-                  if Referenced_As_LHS (E)\n-                    and then No (Address_Clause (E))\n-                    and then not Is_Volatile (E)\n-                  then\n-                     if Warn_On_Modified_Unread\n-                       and then not Is_Imported (E)\n-                       and then not Is_Return_Object (E)\n-\n-                        --  Suppress message for aliased or renamed variables,\n-                        --  since there may be other entities that read the\n-                        --  same memory location.\n-\n-                       and then not Is_Aliased (E)\n-                       and then No (Renamed_Object (E))\n-\n-                     then\n-                        Error_Msg_N\n-                          (\"variable & is assigned but never read?\", E);\n-                        Set_Last_Assignment (E, Empty);\n-                     end if;\n-\n-                  --  Normal case of neither assigned nor read\n-\n-                  else\n-                     --  We suppress the message for types for which a valid\n-                     --  pragma Unreferenced_Objects has been given, otherwise\n-                     --  we go ahead and give the message.\n-\n-                     if not Has_Pragma_Unreferenced_Objects (Etype (E)) then\n-\n-                        --  Distinguish renamed case in message\n-\n-                        if Present (Renamed_Object (E))\n-                          and then Comes_From_Source (Renamed_Object (E))\n-                        then\n-                           Error_Msg_N\n-                             (\"renamed variable & is not referenced?\", E);\n-                        else\n-                           Error_Msg_N\n-                             (\"variable & is not referenced?\", E);\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-               when E_Constant =>\n-                  if Present (Renamed_Object (E))\n-                    and then Comes_From_Source (Renamed_Object (E))\n-                  then\n-                     Error_Msg_N (\"renamed constant & is not referenced?\", E);\n-                  else\n-                     Error_Msg_N (\"constant & is not referenced?\", E);\n-                  end if;\n-\n-               when E_In_Parameter     |\n-                    E_Out_Parameter    |\n-                    E_In_Out_Parameter =>\n-\n-                  --  Do not emit message for formals of a renaming, because\n-                  --  they are never referenced explicitly.\n-\n-                  if Nkind (Original_Node (Unit_Declaration_Node (Scope (E))))\n-                    /= N_Subprogram_Renaming_Declaration\n-                  then\n-                     Error_Msg_N (\"formal parameter & is not referenced?\", E);\n-                  end if;\n-\n-               when E_Named_Integer    |\n-                    E_Named_Real       =>\n-                  Error_Msg_N (\"named number & is not referenced?\", E);\n-\n-               when E_Enumeration_Literal =>\n-                  Error_Msg_N (\"literal & is not referenced?\", E);\n-\n-               when E_Function         =>\n-                  Error_Msg_N (\"function & is not referenced?\", E);\n-\n-               when E_Procedure         =>\n-                  Error_Msg_N (\"procedure & is not referenced?\", E);\n-\n-               when E_Generic_Procedure =>\n-                  Error_Msg_N\n-                    (\"generic procedure & is never instantiated?\", E);\n+         Warn_On_Unreferenced_Entity (Unreferenced_Entities.Table (J));\n+      end loop;\n+   end Output_Unreferenced_Messages;\n \n-               when E_Generic_Function  =>\n-                  Error_Msg_N (\"generic function & is never instantiated?\", E);\n+   ---------------------------\n+   -- Referenced_Check_Spec --\n+   ---------------------------\n \n-               when Type_Kind          =>\n-                  Error_Msg_N (\"type & is not referenced?\", E);\n+   function Referenced_Check_Spec (E : Entity_Id) return Boolean is\n+   begin\n+      if Is_Formal (E) and then Present (Spec_Entity (E)) then\n+         return Referenced (E) or else Referenced (Spec_Entity (E));\n+      else\n+         return Referenced (E);\n+      end if;\n+   end Referenced_Check_Spec;\n \n-               when others =>\n-                  Error_Msg_N (\"& is not referenced?\", E);\n-            end case;\n+   ----------------------------------\n+   -- Referenced_As_LHS_Check_Spec --\n+   ----------------------------------\n \n-            Set_Warnings_Off (E);\n-         end if;\n-      end loop;\n-   end Output_Unreferenced_Messages;\n+   function Referenced_As_LHS_Check_Spec (E : Entity_Id) return Boolean is\n+   begin\n+      if Is_Formal (E) and then Present (Spec_Entity (E)) then\n+         return Referenced_As_LHS (E)\n+           or else Referenced_As_LHS (Spec_Entity (E));\n+      else\n+         return Referenced_As_LHS (E);\n+      end if;\n+   end Referenced_As_LHS_Check_Spec;\n \n    ----------------------------\n    -- Set_Dot_Warning_Switch --\n@@ -2785,6 +3177,204 @@ package body Sem_Warn is\n       end if;\n    end Warn_On_Suspicious_Index;\n \n+   --------------------------------------\n+   -- Warn_On_Unassigned_Out_Parameter --\n+   --------------------------------------\n+\n+   procedure Warn_On_Unassigned_Out_Parameter\n+     (Return_Node : Node_Id;\n+      Scope_Id    : Entity_Id)\n+   is\n+      Form  : Entity_Id;\n+      Form2 : Entity_Id;\n+\n+   begin\n+      --  Ignore if procedure or return statement does not come from source\n+\n+      if not Comes_From_Source (Scope_Id)\n+        or else not Comes_From_Source (Return_Node)\n+      then\n+         return;\n+      end if;\n+\n+      --  Loop through formals\n+\n+      Form := First_Formal (Scope_Id);\n+      while Present (Form) loop\n+\n+         --  We are only interested in OUT parameters that come from source\n+         --  and are never set in the source, and furthermore only in scalars\n+         --  since non-scalars generate too many false positives.\n+\n+         if Ekind (Form) = E_Out_Parameter\n+           and then Never_Set_In_Source_Check_Spec (Form)\n+           and then Is_Scalar_Type (Etype (Form))\n+           and then not Present (Unset_Reference (Form))\n+         then\n+            --  Before we issue the warning, an add ad hoc defence against the\n+            --  most common case of false positives with this warning which is\n+            --  the case where there is a Boolean OUT parameter that has been\n+            --  set, and whose meaning is \"ignore the values of the other\n+            --  parameters\". We can't of course reliably tell this case at\n+            --  compile time, but the following test kills a lot of false\n+            --  positives, without generating a significant number of false\n+            --  negatives (missed real warnings).\n+\n+            Form2 := First_Formal (Scope_Id);\n+            while Present (Form2) loop\n+               if Ekind (Form2) = E_Out_Parameter\n+                 and then Root_Type (Etype (Form2)) = Standard_Boolean\n+                 and then not Never_Set_In_Source_Check_Spec (Form2)\n+               then\n+                  return;\n+               end if;\n+\n+               Next_Formal (Form2);\n+            end loop;\n+\n+            --  Here all conditionas are met, record possible unset reference\n+\n+            Set_Unset_Reference (Form, Return_Node);\n+         end if;\n+\n+         Next_Formal (Form);\n+      end loop;\n+   end Warn_On_Unassigned_Out_Parameter;\n+\n+   ---------------------------------\n+   -- Warn_On_Unreferenced_Entity --\n+   ---------------------------------\n+\n+   procedure Warn_On_Unreferenced_Entity\n+     (Spec_E : Entity_Id;\n+      Body_E : Entity_Id := Empty)\n+   is\n+      E : Entity_Id := Spec_E;\n+   begin\n+      if not Referenced_Check_Spec (E) and then not Warnings_Off (E) then\n+         case Ekind (E) is\n+            when E_Variable =>\n+\n+               --  Case of variable that is assigned but not read. We\n+               --  suppress the message if the variable is volatile, has an\n+               --  address clause, or is imported.\n+\n+               if Referenced_As_LHS_Check_Spec (E)\n+                 and then No (Address_Clause (E))\n+                 and then not Is_Volatile (E)\n+               then\n+                  if Warn_On_Modified_Unread\n+                    and then not Is_Imported (E)\n+                    and then not Is_Return_Object (E)\n+\n+                     --  Suppress message for aliased or renamed variables,\n+                     --  since there may be other entities that read the\n+                     --  same memory location.\n+\n+                    and then not Is_Aliased (E)\n+                    and then No (Renamed_Object (E))\n+\n+                  then\n+                     Error_Msg_N\n+                       (\"?variable & is assigned but never read!\", E);\n+                     Set_Last_Assignment (E, Empty);\n+                  end if;\n+\n+               --  Normal case of neither assigned nor read\n+\n+               else\n+                  --  We suppress the message for types for which a valid\n+                  --  pragma Unreferenced_Objects has been given, otherwise\n+                  --  we go ahead and give the message.\n+\n+                  if not Has_Pragma_Unreferenced_Objects (Etype (E)) then\n+\n+                     --  Distinguish renamed case in message\n+\n+                     if Present (Renamed_Object (E))\n+                       and then Comes_From_Source (Renamed_Object (E))\n+                     then\n+                        Error_Msg_N\n+                          (\"?renamed variable & is not referenced!\", E);\n+                     else\n+                        Error_Msg_N\n+                          (\"?variable & is not referenced!\", E);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+            when E_Constant =>\n+               if Present (Renamed_Object (E))\n+                 and then Comes_From_Source (Renamed_Object (E))\n+               then\n+                  Error_Msg_N\n+                    (\"?renamed constant & is not referenced!\", E);\n+               else\n+                  Error_Msg_N (\"?constant & is not referenced!\", E);\n+               end if;\n+\n+            when E_In_Parameter     |\n+                 E_In_Out_Parameter =>\n+\n+               --  Do not emit message for formals of a renaming, because\n+               --  they are never referenced explicitly.\n+\n+               if Nkind (Original_Node (Unit_Declaration_Node (Scope (E))))\n+                 /= N_Subprogram_Renaming_Declaration\n+               then\n+                  --  Suppress this message for an IN OUT parameter of a\n+                  --  non-scalar type, since it is normal to have only an\n+                  --  assignment in such a case.\n+\n+                  if Ekind (E) = E_In_Parameter\n+                    or else not Referenced_As_LHS_Check_Spec (E)\n+                    or else Is_Scalar_Type (E)\n+                  then\n+                     if Present (Body_E) then\n+                        E := Body_E;\n+                     end if;\n+                     Error_Msg_NE\n+                       (\"?formal parameter & is not referenced!\", E, Spec_E);\n+                  end if;\n+               end if;\n+\n+            when E_Out_Parameter    =>\n+               null;\n+\n+            when E_Named_Integer    |\n+                 E_Named_Real       =>\n+               Error_Msg_N (\"?named number & is not referenced!\", E);\n+\n+            when E_Enumeration_Literal =>\n+               Error_Msg_N (\"?literal & is not referenced!\", E);\n+\n+            when E_Function         =>\n+               Error_Msg_N (\"?function & is not referenced!\", E);\n+\n+            when E_Procedure         =>\n+               Error_Msg_N (\"?procedure & is not referenced!\", E);\n+\n+            when E_Generic_Procedure =>\n+               Error_Msg_N\n+                 (\"?generic procedure & is never instantiated!\", E);\n+\n+            when E_Generic_Function  =>\n+               Error_Msg_N\n+                 (\"?generic function & is never instantiated!\", E);\n+\n+            when Type_Kind          =>\n+               Error_Msg_N (\"?type & is not referenced!\", E);\n+\n+            when others =>\n+               Error_Msg_N (\"?& is not referenced!\", E);\n+         end case;\n+\n+         --  Kill warnings on the entity on which the message has been posted\n+\n+         Set_Warnings_Off (E);\n+      end if;\n+   end Warn_On_Unreferenced_Entity;\n+\n    --------------------------------\n    -- Warn_On_Useless_Assignment --\n    --------------------------------\n@@ -2833,7 +3423,7 @@ package body Sem_Warn is\n         and then not Is_Return_Object (Ent)\n         and then Present (Last_Assignment (Ent))\n         and then not Warnings_Off (Ent)\n-        and then not Has_Pragma_Unreferenced (Ent)\n+        and then not Has_Pragma_Unreferenced_Check_Spec (Ent)\n         and then not Is_Imported (Ent)\n         and then not Is_Exported (Ent)\n       then\n@@ -2857,12 +3447,12 @@ package body Sem_Warn is\n             then\n                if Loc = No_Location then\n                   Error_Msg_NE\n-                    (\"?useless assignment to&, value never referenced\",\n+                    (\"?useless assignment to&, value never referenced!\",\n                      Last_Assignment (Ent), Ent);\n                else\n                   Error_Msg_Sloc := Loc;\n                   Error_Msg_NE\n-                    (\"?useless assignment to&, value overwritten #\",\n+                    (\"?useless assignment to&, value overwritten #!\",\n                      Last_Assignment (Ent), Ent);\n                end if;\n "}]}