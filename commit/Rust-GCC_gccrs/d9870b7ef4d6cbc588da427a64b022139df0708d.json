{"sha": "d9870b7ef4d6cbc588da427a64b022139df0708d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk4NzBiN2VmNGQ2Y2JjNTg4ZGE0MjdhNjRiMDIyMTM5ZGYwNzA4ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-03-21T21:49:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-03-21T21:49:13Z"}, "message": "predicates.md (const_call_insn_operand): Allow direct calls to locally-defined functions if TARGET_ABSOLUTE_ABICALLS.\n\n\t* config/mips/predicates.md (const_call_insn_operand): Allow direct\n\tcalls to locally-defined functions if TARGET_ABSOLUTE_ABICALLS.\n\t* config/mips/mips.md (jal_macro): Test TARGET_ABSOLUTE_ABICALLS.\n\tUse TARGET_OLDABI instead of !TARGET_NEWABI.\n\t(loadgp): Use mips_current_loadgp_style.\n\t(loadgp_noshared): New pattern.\n\t(sibcall_internal): Use MIPS_CALL.\n\t(sibcall_value_internal): Likewise.\n\t(sibcall_value_multiple_internal): Likewise.\n\t(call_internal): Likewise.\n\t(call_value_internal): Likewise.\n\t(call_value_multiple_internal): Likewise.\n\t(call_split): Use MIPS_CALL and add an 'S' constraint.\n\t(call_value_split): Likewise.\n\t(call_value_multiple_split): Likewise.\n\t* config/mips/mips.opt (-mabicalls): Tweak docstring.\n\t(-mshared): New option.\n\t* config/mips/mips-protos.h (mips_loadgp_style): New enum.\n\t(mips_current_loadgp_style): Declare.\n\t* config/mips/mips.c (mips_classify_symbol): Avoid using\n\tSYMBOL_GOT_LOCAL if TARGET_ABSOLUTE_ABICALLS.  Use SYMBOL_GENERAL\n\trather than SYMBOL_GOT_GLOBAL for locally-binding symbols if\n\tTARGET_ABSOLUTE_ABICALLS.\n\t(override_options): Adjust comments.  Improve the warning that is\n\tissued when -mabicalls and -G are used together.\n\t(mips_file_start): Remove comment.\n\t(mips_current_loadgp_style): New function.\n\t(mips_gnu_local_gp): New variable.\n\t(mips_emit_loadgp): Use mips_current_loadgp_style.  Handle\n\tLOADGP_ABSOLUTE.\n\t(mips_output_function_prologue): Use mips_current_laodgp_style.\n\t(mips_expand_prologue): Call mips_emit_loadgp before emitting\n\tthe cprestore instruction.\n\t(mips_extra_live_on_entry): Fix reversed test.  Don't make $25\n\tlive for TARGET_ABSOLUTE_ABICALLS.\n\t* config/mips/mips.h (TARGET_ABSOLUTE_ABICALLS): New macro.\n\t(ASM_SPEC): Pass down -mshared and -mno-shared.\n\t(MIPS_CALL): New macro.\n\t* config/mips/netbsd.h (TARGET_OS_CPP_BUILTINS): Remove __ABICALLS__\n\tdefinition.\n\t* doc/invoke.texi (-mabicalls): Update documentation.\n\t(-mshared): Document.\n\nFrom-SVN: r112261", "tree": {"sha": "16c45bc0cafdad54bcfc9ce0a93a731a67ef690a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16c45bc0cafdad54bcfc9ce0a93a731a67ef690a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9870b7ef4d6cbc588da427a64b022139df0708d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9870b7ef4d6cbc588da427a64b022139df0708d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9870b7ef4d6cbc588da427a64b022139df0708d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9870b7ef4d6cbc588da427a64b022139df0708d/comments", "author": null, "committer": null, "parents": [{"sha": "487d9a61530a00accfe91cd54598e23608580fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487d9a61530a00accfe91cd54598e23608580fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487d9a61530a00accfe91cd54598e23608580fe7"}], "stats": {"total": 305, "additions": 235, "deletions": 70}, "files": [{"sha": "6b1c06eccd5571e25481682190de01c0534d9916", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -1,3 +1,48 @@\n+2006-03-21  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/predicates.md (const_call_insn_operand): Allow direct\n+\tcalls to locally-defined functions if TARGET_ABSOLUTE_ABICALLS.\n+\t* config/mips/mips.md (jal_macro): Test TARGET_ABSOLUTE_ABICALLS.\n+\tUse TARGET_OLDABI instead of !TARGET_NEWABI.\n+\t(loadgp): Use mips_current_loadgp_style.\n+\t(loadgp_noshared): New pattern.\n+\t(sibcall_internal): Use MIPS_CALL.\n+\t(sibcall_value_internal): Likewise.\n+\t(sibcall_value_multiple_internal): Likewise.\n+\t(call_internal): Likewise.\n+\t(call_value_internal): Likewise.\n+\t(call_value_multiple_internal): Likewise.\n+\t(call_split): Use MIPS_CALL and add an 'S' constraint.\n+\t(call_value_split): Likewise.\n+\t(call_value_multiple_split): Likewise.\n+\t* config/mips/mips.opt (-mabicalls): Tweak docstring.\n+\t(-mshared): New option.\n+\t* config/mips/mips-protos.h (mips_loadgp_style): New enum.\n+\t(mips_current_loadgp_style): Declare.\n+\t* config/mips/mips.c (mips_classify_symbol): Avoid using\n+\tSYMBOL_GOT_LOCAL if TARGET_ABSOLUTE_ABICALLS.  Use SYMBOL_GENERAL\n+\trather than SYMBOL_GOT_GLOBAL for locally-binding symbols if\n+\tTARGET_ABSOLUTE_ABICALLS.\n+\t(override_options): Adjust comments.  Improve the warning that is\n+\tissued when -mabicalls and -G are used together.\n+\t(mips_file_start): Remove comment.\n+\t(mips_current_loadgp_style): New function.\n+\t(mips_gnu_local_gp): New variable.\n+\t(mips_emit_loadgp): Use mips_current_loadgp_style.  Handle\n+\tLOADGP_ABSOLUTE.\n+\t(mips_output_function_prologue): Use mips_current_laodgp_style.\n+\t(mips_expand_prologue): Call mips_emit_loadgp before emitting\n+\tthe cprestore instruction.\n+\t(mips_extra_live_on_entry): Fix reversed test.  Don't make $25\n+\tlive for TARGET_ABSOLUTE_ABICALLS.\n+\t* config/mips/mips.h (TARGET_ABSOLUTE_ABICALLS): New macro.\n+\t(ASM_SPEC): Pass down -mshared and -mno-shared.\n+\t(MIPS_CALL): New macro.\n+\t* config/mips/netbsd.h (TARGET_OS_CPP_BUILTINS): Remove __ABICALLS__\n+\tdefinition.\n+\t* doc/invoke.texi (-mabicalls): Update documentation.\n+\t(-mshared): Document.\n+\n 2006-03-21  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/unwind-hpux.c: New file."}, {"sha": "60f81ada5aa4e0f24f3714d99b59b843065cdb86", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -105,6 +105,28 @@ enum mips_symbol_type {\n };\n #define NUM_SYMBOL_TYPES (SYMBOL_64_LOW + 1)\n \n+/* Identifiers a style of $gp initialization sequence.\n+\n+   LOADGP_NONE\n+\tNo initialization sequence is needed.\n+\n+   LOADGP_OLDABI\n+\tThe o32 and o64 PIC sequence (the kind traditionally generated\n+\tby .cpload).\n+\n+   LOADGP_NEWABI\n+\tThe n32 and n64 PIC sequence (the kind traditionally generated\n+\tby .cpsetup).\n+\n+   LOADGP_ABSOLUTE\n+\tThe GNU absolute sequence, as generated by loadgp_noshared.  */\n+enum mips_loadgp_style {\n+  LOADGP_NONE,\n+  LOADGP_OLDABI,\n+  LOADGP_NEWABI,\n+  LOADGP_ABSOLUTE\n+};\n+\n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_type *);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, int);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n@@ -194,6 +216,7 @@ extern rtx mips_rewrite_small_data (rtx);\n extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT);\n extern HOST_WIDE_INT mips_initial_elimination_offset (int, int);\n extern rtx mips_return_addr (int, rtx);\n+extern enum mips_loadgp_style mips_current_loadgp_style (void);\n extern void mips_expand_prologue (void);\n extern void mips_expand_epilogue (int);\n extern int mips_can_use_return_insn (void);"}, {"sha": "ffe047ea0689ce93aad147d3220a92d1b6f90651", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 86, "deletions": 45, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -1182,7 +1182,7 @@ mips_classify_symbol (rtx x)\n     {\n       if (TARGET_MIPS16)\n \treturn SYMBOL_CONSTANT_POOL;\n-      if (TARGET_ABICALLS)\n+      if (TARGET_ABICALLS && !TARGET_ABSOLUTE_ABICALLS)\n \treturn SYMBOL_GOT_LOCAL;\n       return SYMBOL_GENERAL;\n     }\n@@ -1197,13 +1197,8 @@ mips_classify_symbol (rtx x)\n       if (TARGET_MIPS16)\n \treturn SYMBOL_CONSTANT_POOL;\n \n-      if (TARGET_ABICALLS)\n-\treturn SYMBOL_GOT_LOCAL;\n-\n       if (GET_MODE_SIZE (get_pool_mode (x)) <= mips_section_threshold)\n \treturn SYMBOL_SMALL_DATA;\n-\n-      return SYMBOL_GENERAL;\n     }\n \n   if (SYMBOL_REF_SMALL_P (x))\n@@ -1212,32 +1207,43 @@ mips_classify_symbol (rtx x)\n   if (TARGET_ABICALLS)\n     {\n       if (SYMBOL_REF_DECL (x) == 0)\n-\treturn SYMBOL_REF_LOCAL_P (x) ? SYMBOL_GOT_LOCAL : SYMBOL_GOT_GLOBAL;\n-\n-      /* There are three cases to consider:\n-\n-            - o32 PIC (either with or without explicit relocs)\n-            - n32/n64 PIC without explicit relocs\n-            - n32/n64 PIC with explicit relocs\n-\n-         In the first case, both local and global accesses will use an\n-         R_MIPS_GOT16 relocation.  We must correctly predict which of\n-         the two semantics (local or global) the assembler and linker\n-         will apply.  The choice doesn't depend on the symbol's\n-         visibility, so we deliberately ignore decl_visibility and\n-         binds_local_p here.\n-\n-         In the second case, the assembler will not use R_MIPS_GOT16\n-         relocations, but it chooses between local and global accesses\n-         in the same way as for o32 PIC.\n-\n-         In the third case we have more freedom since both forms of\n-         access will work for any kind of symbol.  However, there seems\n-         little point in doing things differently.  */\n-      if (DECL_P (SYMBOL_REF_DECL (x)) && TREE_PUBLIC (SYMBOL_REF_DECL (x)))\n-\treturn SYMBOL_GOT_GLOBAL;\n+\t{\n+\t  if (!SYMBOL_REF_LOCAL_P (x))\n+\t    return SYMBOL_GOT_GLOBAL;\n+\t}\n+      else\n+\t{\n+\t  /* Don't use GOT accesses for locally-binding symbols if\n+\t     TARGET_ABSOLUTE_ABICALLS.  Otherwise, there are three\n+\t     cases to consider:\n+\n+\t\t- o32 PIC (either with or without explicit relocs)\n+\t\t- n32/n64 PIC without explicit relocs\n+\t\t- n32/n64 PIC with explicit relocs\n+\n+\t     In the first case, both local and global accesses will use an\n+\t     R_MIPS_GOT16 relocation.  We must correctly predict which of\n+\t     the two semantics (local or global) the assembler and linker\n+\t     will apply.  The choice doesn't depend on the symbol's\n+\t     visibility, so we deliberately ignore decl_visibility and\n+\t     binds_local_p here.\n+\n+\t     In the second case, the assembler will not use R_MIPS_GOT16\n+\t     relocations, but it chooses between local and global accesses\n+\t     in the same way as for o32 PIC.\n+\n+\t     In the third case we have more freedom since both forms of\n+\t     access will work for any kind of symbol.  However, there seems\n+\t     little point in doing things differently.  */\n+\t  if (DECL_P (SYMBOL_REF_DECL (x))\n+\t      && TREE_PUBLIC (SYMBOL_REF_DECL (x))\n+\t      && !(TARGET_ABSOLUTE_ABICALLS\n+\t\t   && targetm.binds_local_p (SYMBOL_REF_DECL (x))))\n+\t    return SYMBOL_GOT_GLOBAL;\n+\t}\n \n-      return SYMBOL_GOT_LOCAL;\n+      if (!TARGET_ABSOLUTE_ABICALLS)\n+\treturn SYMBOL_GOT_LOCAL;\n     }\n \n   return SYMBOL_GENERAL;\n@@ -4753,15 +4759,18 @@ override_options (void)\n       target_flags &= ~MASK_ABICALLS;\n     }\n \n-  /* -fpic (-KPIC) is the default when TARGET_ABICALLS is defined.  We need\n-     to set flag_pic so that the LEGITIMATE_PIC_OPERAND_P macro will work.  */\n-  /* ??? -non_shared turns off pic code generation, but this is not\n-     implemented.  */\n   if (TARGET_ABICALLS)\n     {\n+      /* We need to set flag_pic for executables as well as DSOs\n+\t because we may reference symbols that are not defined in\n+\t the final executable.  (MIPS does not use things like\n+\t copy relocs, for example.)\n+\n+\t Also, there is a body of code that uses __PIC__ to distinguish\n+\t between -mabicalls and -mno-abicalls code.  */\n       flag_pic = 1;\n       if (mips_section_threshold > 0)\n-\twarning (0, \"-G is incompatible with PIC code which is the default\");\n+\twarning (0, \"%<-G%> is incompatible with %<-mabicalls%>\");\n     }\n \n   /* mips_split_addresses is a half-way house between explicit\n@@ -5797,7 +5806,6 @@ mips_file_start (void)\n \n   /* Generate the pseudo ops that System V.4 wants.  */\n   if (TARGET_ABICALLS)\n-    /* ??? but do not want this (or want pic0) if -non-shared? */\n     fprintf (asm_out_file, \"\\t.abicalls\\n\");\n \n   if (TARGET_MIPS16)\n@@ -6493,22 +6501,55 @@ mips_output_cplocal (void)\n     output_asm_insn (\".cplocal %+\", 0);\n }\n \n+/* Return the style of GP load sequence that is being used for the\n+   current function.  */\n+\n+enum mips_loadgp_style\n+mips_current_loadgp_style (void)\n+{\n+  if (!TARGET_ABICALLS || cfun->machine->global_pointer == 0)\n+    return LOADGP_NONE;\n+\n+  if (TARGET_ABSOLUTE_ABICALLS)\n+    return LOADGP_ABSOLUTE;\n+\n+  return TARGET_NEWABI ? LOADGP_NEWABI : LOADGP_OLDABI;\n+}\n+\n+/* The __gnu_local_gp symbol.  */\n+\n+static GTY(()) rtx mips_gnu_local_gp;\n+\n /* If we're generating n32 or n64 abicalls, emit instructions\n    to set up the global pointer.  */\n \n static void\n mips_emit_loadgp (void)\n {\n-  if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n+  rtx addr, offset, incoming_address;\n+\n+  switch (mips_current_loadgp_style ())\n     {\n-      rtx addr, offset, incoming_address;\n+    case LOADGP_ABSOLUTE:\n+      if (mips_gnu_local_gp == NULL)\n+\t{\n+\t  mips_gnu_local_gp = gen_rtx_SYMBOL_REF (Pmode, \"__gnu_local_gp\");\n+\t  SYMBOL_REF_FLAGS (mips_gnu_local_gp) |= SYMBOL_FLAG_LOCAL;\n+\t}\n+      emit_insn (gen_loadgp_noshared (mips_gnu_local_gp));\n+      break;\n \n+    case LOADGP_NEWABI:\n       addr = XEXP (DECL_RTL (current_function_decl), 0);\n       offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);\n       incoming_address = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n       emit_insn (gen_loadgp (offset, incoming_address));\n       if (!TARGET_EXPLICIT_RELOCS)\n \temit_insn (gen_loadgp_blockage ());\n+      break;\n+\n+    default:\n+      break;\n     }\n }\n \n@@ -6588,7 +6629,7 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t HIGHEST_GP_SAVED == *FRAMEREG + FRAMESIZE + GPOFFSET => can find saved regs.  */\n     }\n \n-  if (TARGET_ABICALLS && !TARGET_NEWABI && cfun->machine->global_pointer > 0)\n+  if (mips_current_loadgp_style () == LOADGP_OLDABI)\n     {\n       /* Handle the initialization of $gp for SVR4 PIC.  */\n       if (!cfun->machine->all_noreorder_p)\n@@ -6775,12 +6816,12 @@ mips_expand_prologue (void)\n \t\t\t\t\t     stack_pointer_rtx)) = 1;\n     }\n \n+  mips_emit_loadgp ();\n+\n   /* If generating o32/o64 abicalls, save $gp on the stack.  */\n   if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n     emit_insn (gen_cprestore (GEN_INT (current_function_outgoing_args_size)));\n \n-  mips_emit_loadgp ();\n-\n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n \n@@ -10674,13 +10715,13 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n     }\n }\n \n-/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  TARGET_ABICALLS makes\n-   PIC_FUNCTION_ADDR_REGNUM live on entry to a function.  */\n+/* Implement TARGET_EXTRA_LIVE_ON_ENTRY.  PIC_FUNCTION_ADDR_REGNUM is live\n+   on entry to a function when generating -mshared abicalls code.  */\n \n static void\n mips_extra_live_on_entry (bitmap regs)\n {\n-  if (!TARGET_ABICALLS)\n+  if (TARGET_ABICALLS && !TARGET_ABSOLUTE_ABICALLS)\n     bitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n }\n "}, {"sha": "3823963ebacaf940bb11d35d0b2fefcdcfd68c03", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -149,6 +149,19 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define TARGET_SPLIT_CALLS \\\n   (TARGET_EXPLICIT_RELOCS && TARGET_ABICALLS && !TARGET_NEWABI)\n \n+/* True if we're generating a form of -mabicalls in which we can use\n+   operators like %hi and %lo to refer to locally-binding symbols.\n+   We can only do this for -mno-shared, and only then if we can use\n+   relocation operations instead of assembly macros.  It isn't really\n+   worth using absolute sequences for 64-bit symbols because GOT\n+   accesses are so much shorter.  */\n+\n+#define TARGET_ABSOLUTE_ABICALLS\t\\\n+  (TARGET_ABICALLS\t\t\t\\\n+   && !TARGET_SHARED\t\t\t\\\n+   && TARGET_EXPLICIT_RELOCS\t\t\\\n+   && !ABI_HAS_64BIT_SYMBOLS)\n+\n /* True if we can optimize sibling calls.  For simplicity, we only\n    handle cases in which call_insn_operand will reject invalid\n    sibcall addresses.  There are two cases in which this isn't true:\n@@ -820,6 +833,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n %(subtarget_asm_debugging_spec) \\\n %{mabi=*} %{!mabi*: %(asm_abi_default_spec)} \\\n %{mgp32} %{mgp64} %{march=*} %{mxgot:-xgot} \\\n+%{mshared} %{mno-shared} \\\n %{msym32} %{mno-sym32} \\\n %{mtune=*} %{v} \\\n %(subtarget_asm_spec)\"\n@@ -2281,6 +2295,26 @@ typedef struct mips_args {\n    its operands.  */\n #define MIPS_BRANCH(OPCODE, OPERANDS) \\\n   \"%*\" OPCODE \"%?\\t\" OPERANDS \"%/\"\n+\n+/* Return the asm template for a call.  INSN is the instruction's mnemonic\n+   (\"j\" or \"jal\"), OPERANDS are its operands, and OPNO is the operand number\n+   of the target.\n+\n+   When generating -mabicalls without explicit relocation operators,\n+   all calls should use assembly macros.  Otherwise, all indirect\n+   calls should use \"jr\" or \"jalr\"; we will arrange to restore $gp\n+   afterwards if necessary.  Finally, we can only generate direct\n+   calls for -mabicalls by temporarily switching to non-PIC mode.  */\n+#define MIPS_CALL(INSN, OPERANDS, OPNO)\t\t\t\t\\\n+  (TARGET_ABICALLS && !TARGET_EXPLICIT_RELOCS\t\t\t\\\n+   ? \"%*\" INSN \"\\t%\" #OPNO \"%/\"\t\t\t\t\t\\\n+   : REG_P (OPERANDS[OPNO])\t\t\t\t\t\\\n+   ? \"%*\" INSN \"r\\t%\" #OPNO \"%/\"\t\t\t\t\\\n+   : TARGET_ABICALLS\t\t\t\t\t\t\\\n+   ? (\".option\\tpic0\\n\\t\"\t\t\t\t\t\\\n+      \"%*\" INSN \"\\t%\" #OPNO \"%/\\n\\t\"\t\t\t\t\\\n+      \".option\\tpic2\")\t\t\t\t\t\t\\\n+   : \"%*\" INSN \"\\t%\" #OPNO \"%/\")\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "32d0c4186974cc2a7559ada411bc8fbda9566a4d", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -166,14 +166,15 @@\n ;; This attribute is YES if the instruction is a jal macro (not a\n ;; real jal instruction).\n ;;\n-;; jal is always a macro in SVR4 PIC since it includes an instruction to\n-;; restore $gp.  Direct jals are also macros in NewABI PIC since they\n-;; load the target address into $25.\n+;; jal is always a macro for o32 and o64 abicalls because it includes an\n+;; instruction to restore $gp.  Direct jals are also macros for -mshared\n+;; abicalls because they first load the target address into $25.\n (define_attr \"jal_macro\" \"no,yes\"\n   (cond [(eq_attr \"jal\" \"direct\")\n-\t (symbol_ref \"TARGET_ABICALLS != 0\")\n+\t (symbol_ref \"TARGET_ABICALLS\n+\t\t      && (TARGET_OLDABI || !TARGET_ABSOLUTE_ABICALLS)\")\n \t (eq_attr \"jal\" \"indirect\")\n-\t (symbol_ref \"(TARGET_ABICALLS && !TARGET_NEWABI) != 0\")]\n+\t (symbol_ref \"TARGET_ABICALLS && TARGET_OLDABI\")]\n \t(const_string \"no\")))\n \n ;; Classification of each insn.\n@@ -3982,7 +3983,7 @@\n (define_insn_and_split \"loadgp\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")\n \t\t     (match_operand 1 \"register_operand\" \"\")] UNSPEC_LOADGP)]\n-  \"TARGET_ABICALLS && TARGET_NEWABI\"\n+  \"mips_current_loadgp_style () == LOADGP_NEWABI\"\n   \"#\"\n   \"\"\n   [(set (match_dup 2) (match_dup 3))\n@@ -3996,6 +3997,19 @@\n }\n   [(set_attr \"length\" \"12\")])\n \n+;; Likewise, for -mno-shared code.  Operand 0 is the __gnu_local_gp symbol.\n+(define_insn_and_split \"loadgp_noshared\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPEC_LOADGP)]\n+  \"mips_current_loadgp_style () == LOADGP_ABSOLUTE\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  emit_move_insn (pic_offset_table_rtx, operands[0]);\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")])\n+\n ;; The use of gp is hidden when not using explicit relocations.\n ;; This blockage instruction prevents the gp load from being\n ;; scheduled after an implicit use of gp.  It also prevents\n@@ -5060,9 +5074,7 @@\n   [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"j,S\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  \"@\n-    %*jr\\t%0%/\n-    %*j\\t%0%/\"\n+  { return MIPS_CALL (\"j\", operands, 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"sibcall_value\"\n@@ -5082,9 +5094,7 @@\n         (call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,S\"))\n               (match_operand 2 \"\" \"\")))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  \"@\n-    %*jr\\t%1%/\n-    %*j\\t%1%/\"\n+  { return MIPS_CALL (\"j\", operands, 1); }\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"sibcall_value_multiple_internal\"\n@@ -5095,9 +5105,7 @@\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  \"@\n-    %*jr\\t%1%/\n-    %*j\\t%1%/\"\n+  { return MIPS_CALL (\"j\", operands, 1); }\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"call\"\n@@ -5153,7 +5161,7 @@\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))]\n   \"\"\n-  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%0%/\"; }\n+  { return TARGET_SPLIT_CALLS ? \"#\" : MIPS_CALL (\"jal\", operands, 0); }\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[2] = insn)\"\n   [(const_int 0)]\n {\n@@ -5166,12 +5174,12 @@\n    (set_attr \"extended_mips16\" \"no,yes\")])\n \n (define_insn \"call_split\"\n-  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"c\"))\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"cS\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 31))\n    (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\t%0%/\"\n+  { return MIPS_CALL (\"jal\", operands, 0); }\n   [(set_attr \"type\" \"call\")])\n \n (define_expand \"call_value\"\n@@ -5193,7 +5201,7 @@\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))]\n   \"\"\n-  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%1%/\"; }\n+  { return TARGET_SPLIT_CALLS ? \"#\" : MIPS_CALL (\"jal\", operands, 1); }\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[3] = insn)\"\n   [(const_int 0)]\n {\n@@ -5208,12 +5216,12 @@\n \n (define_insn \"call_value_split\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:SI (match_operand 1 \"call_insn_operand\" \"c\"))\n+        (call (mem:SI (match_operand 1 \"call_insn_operand\" \"cS\"))\n               (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI 31))\n    (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\t%1%/\"\n+  { return MIPS_CALL (\"jal\", operands, 1); }\n   [(set_attr \"type\" \"call\")])\n \n ;; See comment for call_internal.\n@@ -5226,7 +5234,7 @@\n \t      (match_dup 2)))\n    (clobber (reg:SI 31))]\n   \"\"\n-  { return TARGET_SPLIT_CALLS ? \"#\" : \"%*jal\\t%1%/\"; }\n+  { return TARGET_SPLIT_CALLS ? \"#\" : MIPS_CALL (\"jal\", operands, 1); }\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[4] = insn)\"\n   [(const_int 0)]\n {\n@@ -5241,15 +5249,15 @@\n \n (define_insn \"call_value_multiple_split\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:SI (match_operand 1 \"call_insn_operand\" \"c\"))\n+        (call (mem:SI (match_operand 1 \"call_insn_operand\" \"cS\"))\n               (match_operand 2 \"\" \"\")))\n    (set (match_operand 3 \"register_operand\" \"=df\")\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))\n    (clobber (reg:SI 31))\n    (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n-  \"%*jalr\\t%1%/\"\n+  { return MIPS_CALL (\"jal\", operands, 1); }\n   [(set_attr \"type\" \"call\")])\n \n ;; Call subroutine returning any type."}, {"sha": "7f8214bb1468845853e50d70561aecb2732a8437", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -25,7 +25,7 @@ Target RejectNegative Joined\n \n mabicalls\n Target Report Mask(ABICALLS)\n-Use SVR4-style PIC\n+Generate code that can be used in SVR4-style dynamic objects\n \n mad\n Target Report Var(TARGET_MAD)\n@@ -185,6 +185,10 @@ mpaired-single\n Target Report Mask(PAIRED_SINGLE_FLOAT)\n Use paired-single floating-point instructions\n \n+mshared\n+Target Report Var(TARGET_SHARED) Init(1)\n+When generating -mabicalls code, make the code suitable for use in shared libraries\n+\n msingle-float\n Target Report RejectNegative Mask(SINGLE_FLOAT)\n Restrict the use of hardware floating-point instructions to 32-bit operations"}, {"sha": "9a6756c20a2f43769144efabbca968c8c8556b1e", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9870b7ef4d6cbc588da427a64b022139df0708d/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=d9870b7ef4d6cbc588da427a64b022139df0708d", "patch": "@@ -103,6 +103,16 @@\n   switch (symbol_type)\n     {\n     case SYMBOL_GENERAL:\n+      /* We can only use direct calls for TARGET_ABSOLUTE_ABICALLS if we\n+\t are sure that the target function does not need $25 to be live\n+\t on entry.  This is true for any locally-defined function because\n+\t any such function will use %hi/%lo accesses to set up $gp.  */\n+      if (TARGET_ABSOLUTE_ABICALLS\n+          && !(GET_CODE (op) == SYMBOL_REF\n+\t       && SYMBOL_REF_DECL (op)\n+\t       && !DECL_EXTERNAL (SYMBOL_REF_DECL (op))))\n+\treturn false;\n+\n       /* If -mlong-calls, force all calls to use register addressing.  Also,\n \t if this function has the long_call attribute, we must use register\n \t addressing.  */"}]}