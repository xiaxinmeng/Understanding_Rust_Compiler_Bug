{"sha": "6cb877be49d68f2d626681f033e9dc7af3628f96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiODc3YmU0OWQ2OGYyZDYyNjY4MWYwMzNlOWRjN2FmMzYyOGY5Ng==", "commit": {"author": {"name": "Paul A. Clarke", "email": "pc@us.ibm.com", "date": "2018-10-09T20:31:52Z"}, "committer": {"name": "Paul Clarke", "email": "pc@gcc.gnu.org", "date": "2018-10-09T20:31:52Z"}, "message": "This is part 2/2 for contributing PPC64LE support for X86 SSE3 instrisics.\n\nThis is part 2/2 for contributing PPC64LE support for X86 SSE3\ninstrisics. This patch includes testsuite/gcc.target tests for the\nintrinsics defined in pmmintrin.h. \n\nTested on POWER8 ppc64le and ppc64 (-m64 and -m32, the latter only reporting\n10 new unsupported tests.)\n\n[gcc/testsuite]\n\n2018-10-09  Paul A. Clarke  <pc@us.ibm.com>\n\n\t* gcc.target/powerpc/sse3-check.h: New file.\n\t* gcc.target/powerpc/sse3-addsubps.c: New file.\n\t* gcc.target/powerpc/sse3-addsubpd.c: New file.\n\t* gcc.target/powerpc/sse3-haddps.c: New file.\n\t* gcc.target/powerpc/sse3-hsubps.c: New file.\n\t* gcc.target/powerpc/sse3-haddpd.c: New file.\n\t* gcc.target/powerpc/sse3-hsubpd.c: New file.\n\t* gcc.target/powerpc/sse3-lddqu.c: New file.\n\t* gcc.target/powerpc/sse3-movsldup.c: New file.\n\t* gcc.target/powerpc/sse3-movshdup.c: New file.\n\t* gcc.target/powerpc/sse3-movddup.c: New file.\n\t* gcc.target/powerpc/pr37191.c: New file.\n\nFrom-SVN: r264992", "tree": {"sha": "39f236d9ceae9bf676a481f9895f821959e6b8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39f236d9ceae9bf676a481f9895f821959e6b8f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb877be49d68f2d626681f033e9dc7af3628f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb877be49d68f2d626681f033e9dc7af3628f96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb877be49d68f2d626681f033e9dc7af3628f96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb877be49d68f2d626681f033e9dc7af3628f96/comments", "author": {"login": "ThinkOpenly", "id": 12301795, "node_id": "MDQ6VXNlcjEyMzAxNzk1", "avatar_url": "https://avatars.githubusercontent.com/u/12301795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThinkOpenly", "html_url": "https://github.com/ThinkOpenly", "followers_url": "https://api.github.com/users/ThinkOpenly/followers", "following_url": "https://api.github.com/users/ThinkOpenly/following{/other_user}", "gists_url": "https://api.github.com/users/ThinkOpenly/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThinkOpenly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThinkOpenly/subscriptions", "organizations_url": "https://api.github.com/users/ThinkOpenly/orgs", "repos_url": "https://api.github.com/users/ThinkOpenly/repos", "events_url": "https://api.github.com/users/ThinkOpenly/events{/privacy}", "received_events_url": "https://api.github.com/users/ThinkOpenly/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fb0f8924f59decc2198de591d7fe80319419814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb0f8924f59decc2198de591d7fe80319419814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb0f8924f59decc2198de591d7fe80319419814"}], "stats": {"total": 2271, "additions": 2271, "deletions": 0}, "files": [{"sha": "1256e0faaa35b1c512c05c4a5e294c59e81f6196", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -1,3 +1,18 @@\n+2018-10-09  Paul A. Clarke  <pc@us.ibm.com>\n+\n+\t* gcc.target/powerpc/sse3-check.h: New file.\n+\t* gcc.target/powerpc/sse3-addsubps.c: New file.\n+\t* gcc.target/powerpc/sse3-addsubpd.c: New file.\n+\t* gcc.target/powerpc/sse3-haddps.c: New file.\n+\t* gcc.target/powerpc/sse3-hsubps.c: New file.\n+\t* gcc.target/powerpc/sse3-haddpd.c: New file.\n+\t* gcc.target/powerpc/sse3-hsubpd.c: New file.\n+\t* gcc.target/powerpc/sse3-lddqu.c: New file.\n+\t* gcc.target/powerpc/sse3-movsldup.c: New file.\n+\t* gcc.target/powerpc/sse3-movshdup.c: New file.\n+\t* gcc.target/powerpc/sse3-movddup.c: New file.\n+\t* gcc.target/powerpc/pr37191.c: New file.\n+\n 2018-10-09  Tobias Burnus <burnus@net-b.de>\n \n \tPR fortran/83522"}, {"sha": "72c26fe359d0a5bf06a6ca20d4d5611d46319345", "filename": "gcc/testsuite/gcc.target/powerpc/pr37191.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr37191.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr37191.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr37191.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O3 -mpower8-vector\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+\n+#include <mmintrin.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#if 0\n+extern const uint64_t ff_bone;\n+#endif\n+\n+static inline void transpose4x4(uint8_t *dst, uint8_t *src, ptrdiff_t dst_stride, ptrdiff_t src_stride) {\n+  __m64 row0 = _mm_cvtsi32_si64(*(unsigned*)(src + (0 * src_stride)));\n+  __m64 row1 = _mm_cvtsi32_si64(*(unsigned*)(src + (1 * src_stride)));\n+  __m64 row2 = _mm_cvtsi32_si64(*(unsigned*)(src + (2 * src_stride)));\n+  __m64 row3 = _mm_cvtsi32_si64(*(unsigned*)(src + (3 * src_stride)));\n+  __m64 tmp0 = _mm_unpacklo_pi8(row0, row1);\n+  __m64 tmp1 = _mm_unpacklo_pi8(row2, row3);\n+  __m64 row01 = _mm_unpacklo_pi16(tmp0, tmp1);\n+  __m64 row23 = _mm_unpackhi_pi16(tmp0, tmp1);\n+  *((unsigned*)(dst + (0 * dst_stride))) = _mm_cvtsi64_si32(row01);\n+  *((unsigned*)(dst + (1 * dst_stride))) = _mm_cvtsi64_si32(_mm_unpackhi_pi32(row01, row01));\n+  *((unsigned*)(dst + (2 * dst_stride))) = _mm_cvtsi64_si32(row23);\n+  *((unsigned*)(dst + (3 * dst_stride))) = _mm_cvtsi64_si32(_mm_unpackhi_pi32(row23, row23));\n+}\n+\n+#if 0\n+static inline void h264_loop_filter_chroma_intra_mmx2(uint8_t *pix, int stride, int alpha1, int beta1)\n+{\n+    asm volatile(\n+        \"\"\n+        :: \"r\"(pix-2*stride), \"r\"(pix), \"r\"((long)stride),\n+           \"m\"(alpha1), \"m\"(beta1), \"m\"(ff_bone)\n+    );\n+}\n+#endif\n+\n+void h264_h_loop_filter_chroma_intra_mmx2(uint8_t *pix, int stride, int alpha, int beta)\n+{\n+  uint8_t trans[8*4] __attribute__ ((aligned (8)));\n+  transpose4x4(trans, pix-2, 8, stride);\n+  transpose4x4(trans+4, pix-2+4*stride, 8, stride);\n+//    h264_loop_filter_chroma_intra_mmx2(trans+2*8, 8, alpha-1, beta-1);\n+  transpose4x4(pix-2, trans, stride, 8);\n+  transpose4x4(pix-2+4*stride, trans+4, stride, 8);\n+}\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O3 -mpower8-vector\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+\n+#include <mmintrin.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#if 0\n+extern const uint64_t ff_bone;\n+#endif\n+\n+static inline void transpose4x4(uint8_t *dst, uint8_t *src, ptrdiff_t dst_stride, ptrdiff_t src_stride) {\n+  __m64 row0 = _mm_cvtsi32_si64(*(unsigned*)(src + (0 * src_stride)));\n+  __m64 row1 = _mm_cvtsi32_si64(*(unsigned*)(src + (1 * src_stride)));\n+  __m64 row2 = _mm_cvtsi32_si64(*(unsigned*)(src + (2 * src_stride)));\n+  __m64 row3 = _mm_cvtsi32_si64(*(unsigned*)(src + (3 * src_stride)));\n+  __m64 tmp0 = _mm_unpacklo_pi8(row0, row1);\n+  __m64 tmp1 = _mm_unpacklo_pi8(row2, row3);\n+  __m64 row01 = _mm_unpacklo_pi16(tmp0, tmp1);\n+  __m64 row23 = _mm_unpackhi_pi16(tmp0, tmp1);\n+  *((unsigned*)(dst + (0 * dst_stride))) = _mm_cvtsi64_si32(row01);\n+  *((unsigned*)(dst + (1 * dst_stride))) = _mm_cvtsi64_si32(_mm_unpackhi_pi32(row01, row01));\n+  *((unsigned*)(dst + (2 * dst_stride))) = _mm_cvtsi64_si32(row23);\n+  *((unsigned*)(dst + (3 * dst_stride))) = _mm_cvtsi64_si32(_mm_unpackhi_pi32(row23, row23));\n+}\n+\n+#if 0\n+static inline void h264_loop_filter_chroma_intra_mmx2(uint8_t *pix, int stride, int alpha1, int beta1)\n+{\n+    asm volatile(\n+        \"\"\n+        :: \"r\"(pix-2*stride), \"r\"(pix), \"r\"((long)stride),\n+           \"m\"(alpha1), \"m\"(beta1), \"m\"(ff_bone)\n+    );\n+}\n+#endif\n+\n+void h264_h_loop_filter_chroma_intra_mmx2(uint8_t *pix, int stride, int alpha, int beta)\n+{\n+  uint8_t trans[8*4] __attribute__ ((aligned (8)));\n+  transpose4x4(trans, pix-2, 8, stride);\n+  transpose4x4(trans+4, pix-2+4*stride, 8, stride);\n+//    h264_loop_filter_chroma_intra_mmx2(trans+2*8, 8, alpha-1, beta-1);\n+  transpose4x4(pix-2, trans, stride, 8);\n+  transpose4x4(pix-2+4*stride, trans+4, stride, 8);\n+}"}, {"sha": "1308d6ad2a79faa1b26c8cbdd6171a9ba94f6243", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-addsubpd.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubpd.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,203 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_addsubpd_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_addsubpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_addsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_addsubpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_addsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+\n+      p2[0] = vals[i+2];\n+      p2[1] = vals[i+3];\n+\n+      ck[0] = p1[0] - p2[0];\n+      ck[1] = p1[1] + p2[1];\n+\n+      sse3_test_addsubpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_addsubpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_addsubpd_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_addsubpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_addsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_addsubpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_addsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+\n+      p2[0] = vals[i+2];\n+      p2[1] = vals[i+3];\n+\n+      ck[0] = p1[0] - p2[0];\n+      ck[1] = p1[1] + p2[1];\n+\n+      sse3_test_addsubpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_addsubpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "546728a6d513f5afb62fb9bd7b75972db4e03e4d", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-addsubps.c", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-addsubps.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,215 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_addsubps_1\n+#endif\n+\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_addsubps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_addsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_addsubps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_addsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] - p2[0];\n+      ck[1] = p1[1] + p2[1];\n+      ck[2] = p1[2] - p2[2];\n+      ck[3] = p1[3] + p2[3];\n+\n+      sse3_test_addsubps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_addsubps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_addsubps_1\n+#endif\n+\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_addsubps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_addsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_addsubps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_addsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] - p2[0];\n+      ck[1] = p1[1] + p2[1];\n+      ck[2] = p1[2] - p2[2];\n+      ck[3] = p1[3] + p2[3];\n+\n+      sse3_test_addsubps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_addsubps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "80c90d706e188e6835a4eaa8f3a2bf14d862edbd", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-check.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-check.h?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,86 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"m128-check.h\"\n+\n+/* define DEBUG replace abort with printf on error.  */\n+//#define DEBUG 1\n+\n+#define TEST sse3_test\n+\n+static void sse3_test (void);\n+\n+static void\n+__attribute__ ((noinline))\n+do_test (void)\n+{\n+  sse3_test ();\n+}\n+\n+int\n+main ()\n+{\n+#ifdef __BUILTIN_CPU_SUPPORTS__\n+  /* Most SSE intrinsic operations can be implemented via VMX\n+     instructions, but some operations may be faster / simpler\n+     using the POWER8 VSX instructions.  This is especially true\n+     when we are transferring / converting to / from __m64 types.\n+     The direct register transfer instructions from POWER8 are\n+     especially important.  So we test for arch_2_07.  */\n+  if (__builtin_cpu_supports (\"arch_2_07\"))\n+    {\n+      do_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+    }\n+#ifdef DEBUG\n+  else\n+    printf (\"SKIPPED\\n\");\n+#endif\n+#endif /* __BUILTIN_CPU_SUPPORTS__ */\n+  return 0;\n+}\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"m128-check.h\"\n+\n+/* define DEBUG replace abort with printf on error.  */\n+//#define DEBUG 1\n+\n+#define TEST sse3_test\n+\n+static void sse3_test (void);\n+\n+static void\n+__attribute__ ((noinline))\n+do_test (void)\n+{\n+  sse3_test ();\n+}\n+\n+int\n+main ()\n+{\n+#ifdef __BUILTIN_CPU_SUPPORTS__\n+  /* Most SSE intrinsic operations can be implemented via VMX\n+     instructions, but some operations may be faster / simpler\n+     using the POWER8 VSX instructions.  This is especially true\n+     when we are transferring / converting to / from __m64 types.\n+     The direct register transfer instructions from POWER8 are\n+     especially important.  So we test for arch_2_07.  */\n+  if (__builtin_cpu_supports (\"arch_2_07\"))\n+    {\n+      do_test ();\n+#ifdef DEBUG\n+      printf (\"PASSED\\n\");\n+#endif\n+    }\n+#ifdef DEBUG\n+  else\n+    printf (\"SKIPPED\\n\");\n+#endif\n+#endif /* __BUILTIN_CPU_SUPPORTS__ */\n+  return 0;\n+}"}, {"sha": "4a1e25f11e40ec0649c2d31d8a0b76b42eb0c3ec", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-haddpd.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddpd.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,200 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_haddpd_1\n+#endif\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_haddpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_hadd_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_haddpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_hadd_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i + 0];\n+      p1[1] = vals[i + 1];\n+\n+      p2[0] = vals[i + 2];\n+      p2[1] = vals[i + 3];\n+\n+      ck[0] = p1[0] + p1[1];\n+      ck[1] = p2[0] + p2[1];\n+\n+      sse3_test_haddpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_haddpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_haddpd_1\n+#endif\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_haddpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_hadd_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_haddpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_hadd_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i + 0];\n+      p1[1] = vals[i + 1];\n+\n+      p2[0] = vals[i + 2];\n+      p2[1] = vals[i + 3];\n+\n+      ck[0] = p1[0] + p1[1];\n+      ck[1] = p2[0] + p2[1];\n+\n+      sse3_test_haddpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_haddpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "b4bfaf1db2fc91d3e44bfc99f7871ebab483fbf4", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-haddps.c", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-haddps.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,215 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_haddps_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_haddps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_hadd_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_haddps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_hadd_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps(float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST ()\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] + p1[1];\n+      ck[1] = p1[2] + p1[3];\n+      ck[2] = p2[0] + p2[1];\n+      ck[3] = p2[2] + p2[3];\n+\n+      sse3_test_haddps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_haddps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_haddps_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_haddps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_hadd_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_haddps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_hadd_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps(float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST ()\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] + p1[1];\n+      ck[1] = p1[2] + p1[3];\n+      ck[2] = p2[0] + p2[1];\n+      ck[3] = p2[2] + p2[3];\n+\n+      sse3_test_haddps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_haddps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "6c71fc79c0b734cf12c38833f4fd3dd2f07e75ac", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-hsubpd.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubpd.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,202 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_hsubpd_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_hsubpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_hsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_hsubpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_hsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i + 0];\n+      p1[1] = vals[i + 1];\n+\n+      p2[0] = vals[i + 2];\n+      p2[1] = vals[i + 3];\n+\n+      ck[0] = p1[0] - p1[1];\n+      ck[1] = p2[0] - p2[1];\n+\n+      sse3_test_hsubpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_hsubpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_hsubpd_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_hsubpd (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (i2);\n+\n+  t1 = _mm_hsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static void\n+sse3_test_hsubpd_subsume (double *i1, double *i2, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_load_pd (i2);\n+\n+  t1 = _mm_hsub_pd (t1, t2);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2] __attribute__ ((aligned(16)));\n+static double p3[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 4)\n+    {\n+      p1[0] = vals[i + 0];\n+      p1[1] = vals[i + 1];\n+\n+      p2[0] = vals[i + 2];\n+      p2[1] = vals[i + 3];\n+\n+      ck[0] = p1[0] - p1[1];\n+      ck[1] = p2[0] - p2[1];\n+\n+      sse3_test_hsubpd (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+\n+      sse3_test_hsubpd_subsume (p1, p2, p3);\n+\n+      fail += chk_pd (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "39d9665f1875a53b94cd0a773d5f212f469a481c", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-hsubps.c", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-hsubps.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,215 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_hsubps_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_hsubps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_hsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_hsubps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_hsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps(float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST ()\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] - p1[1];\n+      ck[1] = p1[2] - p1[3];\n+      ck[2] = p2[0] - p2[1];\n+      ck[3] = p2[2] - p2[3];\n+\n+      sse3_test_hsubps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_hsubps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_hsubps_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_hsubps (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_loadu_ps (i2);\n+\n+  t1 = _mm_hsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static void\n+sse3_test_hsubps_subsume (float *i1, float *i2, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_load_ps (i2);\n+\n+  t1 = _mm_hsub_ps (t1, t2);\n+\n+  _mm_storeu_ps (r, t1);\n+}\n+\n+static int\n+chk_ps(float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4] __attribute__ ((aligned(16)));\n+static float p3[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST ()\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 8)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+      p1[2] = vals[i+2];\n+      p1[3] = vals[i+3];\n+\n+      p2[0] = vals[i+4];\n+      p2[1] = vals[i+5];\n+      p2[2] = vals[i+6];\n+      p2[3] = vals[i+7];\n+\n+      ck[0] = p1[0] - p1[1];\n+      ck[1] = p1[2] - p1[3];\n+      ck[2] = p2[0] - p2[1];\n+      ck[3] = p2[2] - p2[3];\n+\n+      sse3_test_hsubps (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+\n+      sse3_test_hsubps_subsume (p1, p2, p3);\n+\n+      fail += chk_ps (ck, p3);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "dd32f6494a04793b3cd840055b90b105a0048be6", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-lddqu.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-lddqu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-lddqu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-lddqu.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,159 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_lddqu_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_lddqu (double *i1, double *r)\n+{\n+  __m128i t1 = _mm_lddqu_si128 ((__m128i *) i1);\n+\n+  _mm_storeu_si128 ((__m128i *) r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2];\n+static double p2[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+\n+      sse3_test_lddqu (p1, p2);\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[1];\n+\n+      fail += chk_pd (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_lddqu_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_lddqu (double *i1, double *r)\n+{\n+  __m128i t1 = _mm_lddqu_si128 ((__m128i *) i1);\n+\n+  _mm_storeu_si128 ((__m128i *) r, t1);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2];\n+static double p2[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = vals[i+1];\n+\n+      sse3_test_lddqu (p1, p2);\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[1];\n+\n+      fail += chk_pd (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "f463f64220ba5fbd60ea6d4047670352c7f3d7a6", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-movddup.c", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movddup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movddup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movddup.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,269 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movddup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movddup_mem (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loaddup_pd (i1);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static double cnst1 [2] = {1.0, 1.0};\n+\n+static void\n+sse3_test_movddup_reg (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (&cnst1[0]);\n+\n+  t1  = _mm_mul_pd (t1, t2);\n+  t2  = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume_unaligned (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume_ldsd (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_load_sd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 1)\n+    {\n+      p1[0] = vals[i+0];\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[0];\n+\n+      sse3_test_movddup_mem (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume_unaligned (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume_ldsd (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movddup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movddup_mem (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loaddup_pd (i1);\n+\n+  _mm_storeu_pd (r, t1);\n+}\n+\n+static double cnst1 [2] = {1.0, 1.0};\n+\n+static void\n+sse3_test_movddup_reg (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_loadu_pd (&cnst1[0]);\n+\n+  t1  = _mm_mul_pd (t1, t2);\n+  t2  = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume_unaligned (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_loadu_pd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume_ldsd (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_load_sd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static void\n+sse3_test_movddup_reg_subsume (double *i1, double *r)\n+{\n+  __m128d t1 = _mm_load_pd (i1);\n+  __m128d t2 = _mm_movedup_pd (t1);\n+\n+  _mm_storeu_pd (r, t2);\n+}\n+\n+static int\n+chk_pd (double *v1, double *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 2; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static double p1[2] __attribute__ ((aligned(16)));\n+static double p2[2];\n+static double ck[2];\n+\n+static double vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 1)\n+    {\n+      p1[0] = vals[i+0];\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[0];\n+\n+      sse3_test_movddup_mem (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume_unaligned (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+\n+      sse3_test_movddup_reg_subsume_ldsd (p1, p2);\n+\n+      fail += chk_pd (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "a49f89a69b2749b16f4a48c5672c4326e951eacc", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-movshdup.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movshdup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movshdup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movshdup.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,195 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movshdup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movshdup_reg (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_movehdup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static void\n+sse3_test_movshdup_reg_subsume (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_movehdup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = 0.0;\n+      p1[1] = vals[i+0];\n+      p1[2] = 1.0;\n+      p1[3] = vals[i+1];\n+\n+      ck[0] = p1[1];\n+      ck[1] = p1[1];\n+      ck[2] = p1[3];\n+      ck[3] = p1[3];\n+\n+      sse3_test_movshdup_reg (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+\n+      sse3_test_movshdup_reg_subsume (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movshdup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movshdup_reg (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_movehdup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static void\n+sse3_test_movshdup_reg_subsume (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_movehdup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = 0.0;\n+      p1[1] = vals[i+0];\n+      p1[2] = 1.0;\n+      p1[3] = vals[i+1];\n+\n+      ck[0] = p1[1];\n+      ck[1] = p1[1];\n+      ck[2] = p1[3];\n+      ck[3] = p1[3];\n+\n+      sse3_test_movshdup_reg (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+\n+      sse3_test_movshdup_reg_subsume (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}, {"sha": "2933be20e45c7cdca27e32de7882a4e9e77f737f", "filename": "gcc/testsuite/gcc.target/powerpc/sse3-movsldup.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movsldup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb877be49d68f2d626681f033e9dc7af3628f96/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movsldup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fsse3-movsldup.c?ref=6cb877be49d68f2d626681f033e9dc7af3628f96", "patch": "@@ -0,0 +1,195 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movsldup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movsldup_reg (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_moveldup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static void\n+sse3_test_movsldup_reg_subsume (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_moveldup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+//static\n+void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = 0.0;\n+      p1[2] = vals[i+1];\n+      p1[3] = 1.0;\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[0];\n+      ck[2] = p1[2];\n+      ck[3] = p1[2];\n+\n+      sse3_test_movsldup_reg (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+\n+      sse3_test_movsldup_reg_subsume (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -mpower8-vector -Wno-psabi\" } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p8vector_hw } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse3-check.h\"\n+#endif\n+\n+#include CHECK_H\n+\n+#ifndef TEST\n+#define TEST sse3_test_movsldup_1\n+#endif\n+\n+#define NO_WARN_X86_INTRINSICS 1\n+#include <pmmintrin.h>\n+\n+static void\n+sse3_test_movsldup_reg (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_loadu_ps (i1);\n+  __m128 t2 = _mm_moveldup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static void\n+sse3_test_movsldup_reg_subsume (float *i1, float *r)\n+{\n+  __m128 t1 = _mm_load_ps (i1);\n+  __m128 t2 = _mm_moveldup_ps (t1);\n+\n+  _mm_storeu_ps (r, t2);\n+}\n+\n+static int\n+chk_ps (float *v1, float *v2)\n+{\n+  int i;\n+  int n_fails = 0;\n+\n+  for (i = 0; i < 4; i++)\n+    if (v1[i] != v2[i])\n+      n_fails += 1;\n+\n+  return n_fails;\n+}\n+\n+static float p1[4] __attribute__ ((aligned(16)));\n+static float p2[4];\n+static float ck[4];\n+\n+static float vals[] =\n+  {\n+    100.0,  200.0, 300.0, 400.0, 5.0, -1.0, .345, -21.5,\n+    1100.0, 0.235, 321.3, 53.40, 0.3, 10.0, 42.0, 32.52,\n+    32.6,   123.3, 1.234, 2.156, 0.1, 3.25, 4.75, 32.44,\n+    12.16,  52.34, 64.12, 71.13, -.1, 2.30, 5.12, 3.785,\n+    541.3,  321.4, 231.4, 531.4, 71., 321., 231., -531.,\n+    23.45,  23.45, 23.45, 23.45, 23.45, 23.45, 23.45, 23.45,\n+    23.45,  -1.43, -6.74, 6.345, -20.1, -20.1, -40.1, -40.1,\n+    1.234,  2.345, 3.456, 4.567, 5.678, 6.789, 7.891, 8.912,\n+    -9.32,  -8.41, -7.50, -6.59, -5.68, -4.77, -3.86, -2.95,\n+    9.32,  8.41, 7.50, 6.59, -5.68, -4.77, -3.86, -2.95\n+  };\n+\n+static void\n+TEST (void)\n+{\n+  int i;\n+  int fail = 0;\n+\n+  for (i = 0; i < sizeof (vals) / sizeof (vals[0]); i += 2)\n+    {\n+      p1[0] = vals[i+0];\n+      p1[1] = 0.0;\n+      p1[2] = vals[i+1];\n+      p1[3] = 1.0;\n+\n+      ck[0] = p1[0];\n+      ck[1] = p1[0];\n+      ck[2] = p1[2];\n+      ck[3] = p1[2];\n+\n+      sse3_test_movsldup_reg (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+\n+      sse3_test_movsldup_reg_subsume (p1, p2);\n+\n+      fail += chk_ps (ck, p2);\n+    }\n+\n+  if (fail != 0)\n+    abort ();\n+}"}]}