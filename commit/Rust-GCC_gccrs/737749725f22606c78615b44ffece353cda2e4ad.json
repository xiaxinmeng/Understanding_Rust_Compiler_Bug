{"sha": "737749725f22606c78615b44ffece353cda2e4ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3NzQ5NzI1ZjIyNjA2Yzc4NjE1YjQ0ZmZlY2UzNTNjZGEyZTRhZA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2003-10-10T21:28:56Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-10-10T21:28:56Z"}, "message": "lcm.c (optimize_mode_switching): Change NORMAL_MODE to MODE_ENTRY and MODE_EXIT.\n\n2003-10-10  Eric Christopher  <echristo@redhat.com>\n\n        * lcm.c (optimize_mode_switching): Change NORMAL_MODE\n        to MODE_ENTRY and MODE_EXIT. Add MODE_AFTER for insns\n        that set mode.\n        * config/sh/sh.h (MODE_ENTRY): New macro.\n        (MODE_EXIT): Ditto.\n        (MODE_AFTER): Ditto.\n        * config/sh/sh.md: Change for MODE_AFTER. Add\n        fp_set attribute.\n        * doc/tm.texi: Document MODE_AFTER, MODE_ENTRY, and MODE_EXIT.\n\nFrom-SVN: r72315", "tree": {"sha": "aa1df7ffe4c336097455ef2086b46abf1916fc97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa1df7ffe4c336097455ef2086b46abf1916fc97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/737749725f22606c78615b44ffece353cda2e4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737749725f22606c78615b44ffece353cda2e4ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737749725f22606c78615b44ffece353cda2e4ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737749725f22606c78615b44ffece353cda2e4ad/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d61e55ee59689c4b82890bafa1940718db77c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d61e55ee59689c4b82890bafa1940718db77c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d61e55ee59689c4b82890bafa1940718db77c9e"}], "stats": {"total": 218, "additions": 139, "deletions": 79}, "files": [{"sha": "5cf9983411a9aa960cf6ea92ac32ac5fce2e23e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737749725f22606c78615b44ffece353cda2e4ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737749725f22606c78615b44ffece353cda2e4ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=737749725f22606c78615b44ffece353cda2e4ad", "patch": "@@ -1,3 +1,15 @@\n+2003-10-10  Eric Christopher  <echristo@redhat.com>\n+\n+        * lcm.c (optimize_mode_switching): Change NORMAL_MODE\n+        to MODE_ENTRY and MODE_EXIT. Add MODE_AFTER for insns\n+        that set mode.\n+        * config/sh/sh.h (MODE_ENTRY): New macro.\n+        (MODE_EXIT): Ditto.\n+        (MODE_AFTER): Ditto.\n+        * config/sh/sh.md: Change for MODE_AFTER. Add\n+        fp_set attribute.\n+        * doc/tm.texi: Document MODE_AFTER, MODE_ENTRY, and MODE_EXIT.\n+\n 2003-10-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* genmodes.c, mode-classes.def: New files."}, {"sha": "acd9650b254f182337895a2e11d89ccdb550677c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=737749725f22606c78615b44ffece353cda2e4ad", "patch": "@@ -1254,7 +1254,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000ff },\t\\\n /* ALL_REGS:  */\t\t\t\t\t\t\t\\\n   { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x01ffffff },\t\\\n-}\t\t\t\t\t\t\t\t\t \n+}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -1645,7 +1645,7 @@ extern enum reg_class reg_class_from_letter[];\n \t\t || TREE_CODE (VALTYPE) == OFFSET_TYPE))\t\t\\\n \t    ? (TARGET_SHMEDIA ? DImode : SImode) : TYPE_MODE (VALTYPE)), \\\n \t   BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n-     \n+\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE) \\\n@@ -2073,7 +2073,7 @@ struct sh_args {\n \n #define EXIT_IGNORE_STACK 1\n \n-/* \n+/*\n    On the SH, the trampoline looks like\n    2 0002 D202     \t   \tmov.l\tl2,r2\n    1 0000 D301     \t\tmov.l\tl1,r3\n@@ -3189,7 +3189,7 @@ extern int rtx_equal_function_value_matters;\n #define any_register_operand register_operand\n \n /* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n+   in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.\n@@ -3234,6 +3234,11 @@ extern int rtx_equal_function_value_matters;\n    ? (TARGET_FMOVD ? FP_MODE_DOUBLE : FP_MODE_NONE) \\\n    : ACTUAL_NORMAL_MODE (ENTITY))\n \n+#define MODE_ENTRY(ENTITY) NORMAL_MODE (ENTITY)\n+\n+#define MODE_EXIT(ENTITY) \\\n+  (sh_cfun_attr_renesas_p () ? FP_MODE_NONE : NORMAL_MODE (ENTITY))\n+\n #define EPILOGUE_USES(REGNO)       ((TARGET_SH2E || TARGET_SH4)\t\t\\\n \t\t\t\t    && (REGNO) == FPSCR_REG)\n \n@@ -3242,6 +3247,12 @@ extern int rtx_equal_function_value_matters;\n    ? get_attr_fp_mode (INSN)\t\t\t\t\t\t\\\n    : FP_MODE_NONE)\n \n+#define MODE_AFTER(MODE, INSN)                  \\\n+     (recog_memoized (INSN) >= 0                \\\n+      && get_attr_fp_set (INSN) != FP_SET_NONE  \\\n+      ? get_attr_fp_set (INSN)                  \\\n+      : (MODE))\n+\n #define MODE_PRIORITY_TO_MODE(ENTITY, N) \\\n   ((TARGET_FPU_SINGLE != 0) ^ (N) ? FP_MODE_SINGLE : FP_MODE_DOUBLE)\n "}, {"sha": "bad8c66edc9c66e87dd7058bcd154527b19c9561", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=737749725f22606c78615b44ffece353cda2e4ad", "patch": "@@ -152,7 +152,7 @@\n   (UNSPECV_CONST8\t6)\n   (UNSPECV_WINDOW_END\t10)\n   (UNSPECV_CONST_END\t11)\n-])  \n+])\n \n ;; -------------------------------------------------------------------------\n ;; Attributes\n@@ -218,7 +218,7 @@\n ;; ftrc_s\tfix_truncsfsi2_i4\n ;; dfdiv\tdouble precision floating point divide (or square root)\n ;; cwb\t\tic_invalidate_line_i\n-;; tls_load     load TLS related address \n+;; tls_load     load TLS related address\n ;; arith_media\tSHmedia arithmetic, logical, and shift instructions\n ;; cbranch_media SHmedia conditional branch instructions\n ;; cmp_media\tSHmedia compare instructions\n@@ -280,6 +280,14 @@\n \n (define_attr \"fp_mode\" \"single,double,none\" (const_string \"none\"))\n \n+;; Indicate if the fpu mode is set by this instruction\n+;; \"unknown\" must have the value as \"none\" in fp_mode, and means\n+;; that the instruction/abi has left the processor in an unknown\n+;; state.\n+;; \"none\" means that nothing has changed and no mode is set.\n+;; This attribute is only used for the Renesas ABI.\n+(define_attr \"fp_set\" \"single,double,unknown,none\" (const_string \"none\"))\n+\n ; If a conditional branch destination is within -252..258 bytes away\n ; from the instruction it can be 2 bytes long.  Something in the\n ; range -4090..4100 bytes can be 6 bytes long.  All other conditional\n@@ -5065,7 +5073,7 @@\n ;; delay slot scheduling from the target.\n (define_insn \"indirect_jump_scratch\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"const_int_operand\" \"\")] UNSPEC_BBR)) \n+\t(unspec:SI [(match_operand 1 \"const_int_operand\" \"\")] UNSPEC_BBR))\n    (set (pc) (unspec [(const_int 0)] UNSPEC_BBR))]\n   \"TARGET_SH1\"\n   \"\"\n@@ -5562,7 +5570,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n ;; This is a pc-rel call, using bsrf, for use with PIC.\n \n@@ -5579,7 +5588,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n (define_insn_and_split \"call_pcrel\"\n   [(call (mem:SI (match_operand:SI 0 \"symbol_ref_operand\" \"\"))\n@@ -5607,7 +5617,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n (define_insn \"call_compact\"\n   [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n@@ -5662,7 +5673,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n (define_insn \"call_valuei_pcrel\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -5678,7 +5690,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n (define_insn_and_split \"call_value_pcrel\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -5708,7 +5721,8 @@\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n-   (set_attr \"needs_delay_slot\" \"yes\")])\n+   (set_attr \"needs_delay_slot\" \"yes\")\n+   (set_attr \"fp_set\" \"unknown\")])\n \n (define_insn \"call_value_compact\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -8169,7 +8183,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set (reg:PSI FPSCR_REG)\n \t(xor:PSI (reg:PSI FPSCR_REG) (const_int 1048576)))]\n   \"TARGET_SH4\"\n-  \"fschg\")\n+  \"fschg\"\n+  [(set_attr \"fp_set\" \"unknown\")])\n \n (define_expand \"addsf3\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n@@ -10359,7 +10374,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t(const_int 4294967295))\n \t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n                            (const_int 32))))]\n-\t\t\t\t\n+\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -10370,7 +10385,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n                            (const_int 32))\n \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t(const_int 4294967295))))]\n-\t\t\t\t\n+\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N2, %N1, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -10404,7 +10419,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t\t \"rZ\"))\n \t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n                            (const_int 32))))]\n-\t\t\t\t\n+\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -10414,7 +10429,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;;\t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rZ,0,f\")\n \t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rZ,f,f\")\n \t\t\t (match_operand:SF 2 \"register_operand\" \"rZ,f,f\")))]\n-\t\t\t\t\n+\n   \"TARGET_SHMEDIA\"\n   \"@\n \tmshflo.l\t%N1, %N2, %0\n@@ -10436,7 +10451,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n                            (const_int 32))\n \t\t(zero_extend:DI (match_operand:SI 2 \"extend_reg_or_0_operand\" \"rZ\"))))]\n-\t\t\t\t\n+\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N2, %N1, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -10675,16 +10690,16 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set_attr \"type\" \"arith_media\")])\n \n ;; The following description  models the\n-;; SH4 pipeline using the DFA based scheduler. \n-;; The DFA based description is better way to model \n+;; SH4 pipeline using the DFA based scheduler.\n+;; The DFA based description is better way to model\n ;; a superscalar pipeline as compared to function unit\n-;; reservation model.   \n-;; 1. The function unit based model is oriented to describe at most one \n-;;    unit reservation by each insn. It is difficult to model unit reservations in multiple \n+;; reservation model.\n+;; 1. The function unit based model is oriented to describe at most one\n+;;    unit reservation by each insn. It is difficult to model unit reservations in multiple\n ;;    pipeline units by same insn. This can be done using DFA based description.\n ;; 2. The execution performance of DFA based scheduler does not depend on processor complexity.\n-;; 3. Writing all unit reservations for an instruction class is more natural description \n-;;    of the pipeline and makes interface of the hazard recognizer simpler than the \n+;; 3. Writing all unit reservations for an instruction class is more natural description\n+;;    of the pipeline and makes interface of the hazard recognizer simpler than the\n ;;    old function unit based model.\n ;; 4. The DFA model is richer and is a part of greater overall framework of RCSP.\n \n@@ -10695,7 +10710,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n (define_automaton \"inst_pipeline,fpu_pipe\")\n \n ;; This unit is basically the decode unit of the processor.\n-;; Since SH4 is a dual issue machine,it is as if there are two \n+;; Since SH4 is a dual issue machine,it is as if there are two\n ;; units so that any insn can be processed by either one\n ;; of the decoding unit.\n \n@@ -10728,8 +10743,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n ;; The address calculator used for branch instructions.\n ;; This will be reserved after \"issue\" of branch instructions\n-;; and this is to make sure that no two branch instructions \n-;; can be issued in parallel. \n+;; and this is to make sure that no two branch instructions\n+;; can be issued in parallel.\n \n (define_cpu_unit \"pcr_addrcalc\" \"inst_pipeline\")\n \n@@ -10751,14 +10766,14 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n (define_reservation \"fpu\" \"F1+F2\")\n \n-;; This is to highlight the fact that f1 \n+;; This is to highlight the fact that f1\n ;; cannot overlap with F1.\n \n (exclusion_set  \"f1_1,f1_2\" \"F1\")\n \n (define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n \n-;; Although reg moves have a latency of zero \n+;; Although reg moves have a latency of zero\n ;; we need to highlight that they use D stage\n ;; for one cycle.\n \n@@ -10806,7 +10821,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; Latency: \t1\n ;; Issue Rate: \t1\n \n-(define_insn_reservation \"sh4_simple_arith\" 1 \n+(define_insn_reservation \"sh4_simple_arith\" 1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"insn_class\" \"ex_group\"))\n   \"issue,int\")\n@@ -10913,7 +10928,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; Group:\tCO\n ;; Latency: \t5\n ;; Issue Rate: \t5\n-;; this instruction can be executed in any of the pipelines \n+;; this instruction can be executed in any of the pipelines\n ;; and blocks the pipeline for next 4 stages.\n \n (define_insn_reservation \"sh4_return_from_exp\" 5\n@@ -10932,7 +10947,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"cwb\"))\n   \"d_lock*2,(d_lock+memory)*3,issue+load_store+memory,memory*2\")\n-\t\t\n+\n ;; LDS to PR,JSR\n ;; Group:\tCO\n ;; Latency: \t3\n@@ -10944,7 +10959,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; scheduling.  For the function call case, it's really best that we end with\n ;; something that models an rts.\n \n-(define_insn_reservation \"sh4_lds_to_pr\" 3 \n+(define_insn_reservation \"sh4_lds_to_pr\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"prset\") )\n   \"d_lock*2\")\n@@ -10957,17 +10972,17 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; We could, of course, provide exact scheduling information for specific\n ;; sfuncs, if that should prove useful.\n \n-(define_insn_reservation \"sh4_call\" 16 \n+(define_insn_reservation \"sh4_call\" 16\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"call,sfunc\"))\n   \"d_lock*16\")\n \n-;; LDS.L to PR \n+;; LDS.L to PR\n ;; Group:\tCO\n ;; Latency: \t3\n ;; Issue Rate: \t2\n ;; The SX unit is blocked for last 2 cycles.\n- \n+\n (define_insn_reservation \"ldsmem_to_pr\"  3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"pload\"))\n@@ -10989,7 +11004,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; Latency: \t2\n ;; Issue Rate: \t2\n \n-(define_insn_reservation \"sh4_prstore_mem\" 2 \n+(define_insn_reservation \"sh4_prstore_mem\" 2\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"pstore\"))\n   \"d_lock*2,nothing,memory\")\n@@ -10998,7 +11013,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n ;; Group:\tCO\n ;; Latency: \t4\n ;; Issue Rate: \t1\n-;; F1 is blocked for last three cycles. \n+;; F1 is blocked for last three cycles.\n \n (define_insn_reservation \"fpscr_load\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n@@ -11079,7 +11094,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n        (eq_attr \"type\" \"dfp_conv\"))\n   \"issue,F01,F1+F2,F2\")\n \n-;; Double-precision floating-point (FADD,FMUL,FSUB) \n+;; Double-precision floating-point (FADD,FMUL,FSUB)\n ;; Group:\tFE\n ;; Latency: \t(7,8)/9\n ;; Issue Rate: \t1\n@@ -11089,12 +11104,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n        (eq_attr \"type\" \"dfp_arith\"))\n   \"issue,F01,F1+F2,fpu*4,F2\")\n \n-;; Double-precision FCMP (FCMP/EQ,FCMP/GT) \n+;; Double-precision FCMP (FCMP/EQ,FCMP/GT)\n ;; Group:\tCO\n ;; Latency: \t3/5\n ;; Issue Rate: \t2\n \n-(define_insn_reservation \"fp_double_cmp\" 3 \n+(define_insn_reservation \"fp_double_cmp\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"dfp_cmp\"))\n   \"d_lock,(d_lock+F01),F1+F2,F2\")"}, {"sha": "b420bfb419db5ea50c39c1940d630aa86f4d89db", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=737749725f22606c78615b44ffece353cda2e4ad", "patch": "@@ -320,14 +320,14 @@ default value of this macro, will expand to the value of\n @end defmac\n \n @defmac SYSROOT_SUFFIX_SPEC\n-Define this macro to add a suffix to the target sysroot when GCC is \n-configured with a sysroot.  This will cause GCC to search for usr/lib, \n-et al, within sysroot+suffix. \n+Define this macro to add a suffix to the target sysroot when GCC is\n+configured with a sysroot.  This will cause GCC to search for usr/lib,\n+et al, within sysroot+suffix.\n @end defmac\n \n @defmac SYSROOT_HEADERS_SUFFIX_SPEC\n-Define this macro to add a headers_suffix to the target sysroot when \n-GCC is configured with a sysroot.  This will cause GCC to pass the \n+Define this macro to add a headers_suffix to the target sysroot when\n+GCC is configured with a sysroot.  This will cause GCC to pass the\n updated sysroot+headers_suffix to CPP@, causing it to search for\n usr/include, et al, within sysroot+headers_suffix.\n @end defmac\n@@ -2696,11 +2696,11 @@ A C expression that defines the optional machine-dependent constraint\n letters, amongst those accepted by @code{EXTRA_CONSTRAINT}, that should\n be treated like memory constraints by the reload pass.\n \n-It should return 1 if the operand type represented by the constraint \n+It should return 1 if the operand type represented by the constraint\n at the start of @var{str}, the first letter of which is the letter @var{c},\n  comprises a subset of all memory references including\n-all those whose address is simply a base register.  This allows the reload \n-pass to reload an operand, if it does not directly correspond to the operand \n+all those whose address is simply a base register.  This allows the reload\n+pass to reload an operand, if it does not directly correspond to the operand\n type of @var{c}, by copying its address into a base register.\n \n For example, on the S/390, some instructions do not accept arbitrary\n@@ -2720,15 +2720,15 @@ letters, amongst those accepted by @code{EXTRA_CONSTRAINT} /\n @code{EXTRA_CONSTRAINT_STR}, that should\n be treated like address constraints by the reload pass.\n \n-It should return 1 if the operand type represented by the constraint \n+It should return 1 if the operand type represented by the constraint\n at the start of @var{str}, which starts with the letter @var{c}, comprises\n a subset of all memory addresses including\n-all those that consist of just a base register.  This allows the reload \n-pass to reload an operand, if it does not directly correspond to the operand \n+all those that consist of just a base register.  This allows the reload\n+pass to reload an operand, if it does not directly correspond to the operand\n type of @var{str}, by copying it into a base register.\n \n Any constraint marked as @code{EXTRA_ADDRESS_CONSTRAINT} can only\n-be used with the @code{address_operand} predicate.  It is treated \n+be used with the @code{address_operand} predicate.  It is treated\n analogously to the @samp{p} constraint.\n @end defmac\n \n@@ -2905,9 +2905,9 @@ If this RTL is a @code{REG}, you should also define\n @end defmac\n \n @defmac DWARF_ALT_FRAME_RETURN_COLUMN\n-A C expression whose value is an integer giving a DWARF 2 column \n+A C expression whose value is an integer giving a DWARF 2 column\n number that may be used as an alternate return column.  This should\n-be defined only if @code{DWARF_FRAME_RETURN_COLUMN} is set to a \n+be defined only if @code{DWARF_FRAME_RETURN_COLUMN} is set to a\n general register, but an alternate column needs to be used for\n signal frames.\n @end defmac\n@@ -2970,10 +2970,10 @@ Typically this is a call-clobbered hard register that is otherwise\n untouched by the epilogue, but could also be a stack slot.\n \n Do not define this macro if the stack pointer is saved and restored\n-by the regular prolog and epilog code in the call frame itself; in \n-this case, the exception handling library routines will update the \n-stack location to be restored in place.  Otherwise, you must define \n-this macro if you want to support call frame exception handling like \n+by the regular prolog and epilog code in the call frame itself; in\n+this case, the exception handling library routines will update the\n+stack location to be restored in place.  Otherwise, you must define\n+this macro if you want to support call frame exception handling like\n that provided by DWARF 2.\n @end defmac\n \n@@ -2986,8 +2986,8 @@ Typically this is the location in the call frame at which the normal\n return address is stored.  For targets that return by popping an\n address off the stack, this might be a memory address just below\n the @emph{target} call frame rather than inside the current call\n-frame.  If defined, @code{EH_RETURN_STACKADJ_RTX} will have already \n-been assigned, so it may be used to calculate the location of the \n+frame.  If defined, @code{EH_RETURN_STACKADJ_RTX} will have already\n+been assigned, so it may be used to calculate the location of the\n target call frame.\n \n Some targets have more complex requirements than storing to an\n@@ -3265,7 +3265,7 @@ is different than the internal representation for unwind column.\n Given a dwarf register, this macro should return the internal unwind\n column number to use instead.\n \n-See the PowerPC's SPE target for an example.  \n+See the PowerPC's SPE target for an example.\n @end defmac\n \n @node Elimination\n@@ -4666,7 +4666,7 @@ don't need to define this macro.\n @findex gofast_maybe_init_libfuncs\n @defmac US_SOFTWARE_GOFAST\n Define this macro if your system C library uses the US Software GOFAST\n-library to provide floating point emulation.  \n+library to provide floating point emulation.\n \n In addition to defining this macro, your architecture must set\n @code{TARGET_INIT_LIBFUNCS} to @code{gofast_maybe_init_libfuncs}, or\n@@ -6510,7 +6510,7 @@ provided.\n A C statement (sans semicolon) to output to the stdio stream\n @var{stream} a directive telling the assembler to calculate the size of\n the symbol @var{name} by subtracting its address from the current\n-address.  \n+address.\n \n If you define @code{SIZE_ASM_OP}, a default definition of this macro is\n provided.  The default assumes that the assembler recognizes a special\n@@ -8226,7 +8226,8 @@ return nonzero for any @var{entity} that needs mode-switching.\n If you define this macro, you also have to define\n @code{NUM_MODES_FOR_MODE_SWITCHING}, @code{MODE_NEEDED},\n @code{MODE_PRIORITY_TO_MODE} and @code{EMIT_MODE_SET}.\n-@code{NORMAL_MODE} is optional.\n+@code{MODE_AFTER}, @code{MODE_ENTRY}, and @code{MODE_EXIT}\n+are optional.\n @end defmac\n \n @defmac NUM_MODES_FOR_MODE_SWITCHING\n@@ -8250,10 +8251,24 @@ return an integer value not larger than the corresponding element in\n be switched into prior to the execution of @var{insn}.\n @end defmac\n \n-@defmac NORMAL_MODE (@var{entity})\n+@defmac MODE_AFTER (@var{mode}, @var{insn})\n+If this macro is defined, it is evaluated for every @var{insn} during\n+mode switching. It determines the mode that an insn results in (if\n+different from the incoming mode).\n+@end defmac\n+\n+@defmac MODE_ENTRY (@var{entity})\n+If this macro is defined, it is evaluated for every @var{entity} that needs\n+mode switching. It should evaluate to an integer, which is a mode that\n+@var{entity} is assumed to be switched to at function entry. If @code{MODE_ENTRY}\n+is defined then @code{MODE_EXIT} must be defined.\n+@end defmac\n+\n+@defmac MODE_EXIT (@var{entity})\n If this macro is defined, it is evaluated for every @var{entity} that needs\n-mode switching.  It should evaluate to an integer, which is a mode that\n-@var{entity} is assumed to be switched to at function entry and exit.\n+mode switching. It should evaluate to an integer, which is a mode that\n+@var{entity} is assumed to be switched to at function exit. If @code{MODE_EXIT}\n+is defined then @code{MODE_ENTRY} must be defined.\n @end defmac\n \n @defmac MODE_PRIORITY_TO_MODE (@var{entity}, @var{n})\n@@ -9152,12 +9167,11 @@ to reserve space for caller-saved target registers.\n @end deftypefn\n \n @defmac POWI_MAX_MULTS\n-If defined, this macro is interpreted as a signed integer C expression \n+If defined, this macro is interpreted as a signed integer C expression\n that specifies the maximum number of floating point multiplications\n that should be emitted when expanding exponentiation by an integer\n constant inline.  When this value is defined, exponentiation requiring\n more than this number of multiplications is implemented by calling the\n system library's @code{pow}, @code{powf} or @code{powl} routines.\n The default value places no upper bound on the multiplication count.\n @end defmac\n-"}, {"sha": "68b49efb01516aca4aa9cd128a35979634c818e3", "filename": "gcc/lcm.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/737749725f22606c78615b44ffece353cda2e4ad/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=737749725f22606c78615b44ffece353cda2e4ad", "patch": "@@ -958,6 +958,12 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n       SET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno + nregs);\n }\n \n+/* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined\n+   and vice versa.  */\n+#if defined (MODE_ENTRY) != defined (MODE_EXIT)\n+ #error \"Both MODE_ENTRY and MODE_EXIT must be defined\"\n+#endif\n+\n /* Find all insns that need a particular mode setting, and insert the\n    necessary mode switches.  Return true if we did work.  */\n \n@@ -990,7 +996,7 @@ optimize_mode_switching (FILE *file)\n \t/* Create the list of segments within each basic block.\n \t   If NORMAL_MODE is defined, allow for two extra\n \t   blocks split from the entry and exit block.  */\n-#ifdef NORMAL_MODE\n+#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n \tentry_exit_extra = 2;\n #endif\n \tbb_info[n_entities]\n@@ -1003,7 +1009,7 @@ optimize_mode_switching (FILE *file)\n   if (! n_entities)\n     return 0;\n \n-#ifdef NORMAL_MODE\n+#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n   {\n     /* Split the edge from the entry block and the fallthrough edge to the\n        exit block, so that we can note that there NORMAL_MODE is supplied /\n@@ -1068,7 +1074,9 @@ optimize_mode_switching (FILE *file)\n \t\t      add_seginfo (info + bb->index, ptr);\n \t\t      RESET_BIT (transp[bb->index], j);\n \t\t    }\n-\n+#ifdef MODE_AFTER\n+\t\t  last_mode = MODE_AFTER (last_mode, insn);\n+#endif\n \t\t  /* Update LIVE_NOW.  */\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n@@ -1089,9 +1097,9 @@ optimize_mode_switching (FILE *file)\n \t      add_seginfo (info + bb->index, ptr);\n \t    }\n \t}\n-#ifdef NORMAL_MODE\n+#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n       {\n-\tint mode = NORMAL_MODE (e);\n+\tint mode = MODE_ENTRY (e);\n \n \tif (mode != no_mode)\n \t  {\n@@ -1109,7 +1117,7 @@ optimize_mode_switching (FILE *file)\n \t    info[bb->index].computing = mode;\n \n \t    if (pre_exit)\n-\t      info[pre_exit->index].seginfo->mode = mode;\n+\t      info[pre_exit->index].seginfo->mode = MODE_EXIT (e);\n \t  }\n       }\n #endif /* NORMAL_MODE */\n@@ -1285,7 +1293,7 @@ optimize_mode_switching (FILE *file)\n   if (need_commit)\n     commit_edge_insertions ();\n \n-#ifdef NORMAL_MODE\n+#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n   cleanup_cfg (CLEANUP_NO_INSN_DEL);\n #else\n   if (!need_commit && !emited)"}]}