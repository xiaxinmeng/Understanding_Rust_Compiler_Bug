{"sha": "f90800f836965874b1025412cd1690638edfce07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwODAwZjgzNjk2NTg3NGIxMDI1NDEyY2QxNjkwNjM4ZWRmY2UwNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-01-11T18:01:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-11T18:01:35Z"}, "message": "i386.md (movstrsi expander): Rewrite.\n\n\t* i386.md (movstrsi expander): Rewrite.\n\t(movstrsi_1 insn): Deleted.\n\t(strmovhi, strmovqi expander): New expanders.\n\t(movshi_1, movsqi_1, rep_movsi, rep_movqi): New patterns.\n\t* i386.c (x86_single_stringop): New global variable.\n\t* i386.h (x86_single_stringop): Declare.\n\t(TARGET_SINGLE_STRINGOP): New macro.\n\nFrom-SVN: r31329", "tree": {"sha": "c2b4db48b098c107384d99fe3760bbd090cd10b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2b4db48b098c107384d99fe3760bbd090cd10b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90800f836965874b1025412cd1690638edfce07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90800f836965874b1025412cd1690638edfce07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90800f836965874b1025412cd1690638edfce07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90800f836965874b1025412cd1690638edfce07/comments", "author": null, "committer": null, "parents": [{"sha": "1e7a71c15355d9e092bd76ec5eb4317a114587f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7a71c15355d9e092bd76ec5eb4317a114587f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7a71c15355d9e092bd76ec5eb4317a114587f5"}], "stats": {"total": 205, "additions": 153, "deletions": 52}, "files": [{"sha": "0640895f2c34f6696b3e9be895ba9ad200c4d936", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90800f836965874b1025412cd1690638edfce07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90800f836965874b1025412cd1690638edfce07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f90800f836965874b1025412cd1690638edfce07", "patch": "@@ -1,3 +1,13 @@\n+Tue Jan 11 18:59:35 MET 2000  Jan Hubicka <jh@suse.cz>\n+\n+\t* i386.md (movstrsi expander): Rewrite.\n+\t(movstrsi_1 insn): Deleted.\n+\t(strmovhi, strmovqi expander): New expanders.\n+\t(movshi_1, movsqi_1, rep_movsi, rep_movqi): New patterns.\n+\t* i386.c (x86_single_stringop): New global variable.\n+\t* i386.h (x86_single_stringop): Declare.\n+\t(TARGET_SINGLE_STRINGOP): New macro.\n+\n 2000-01-11  Clinton Popetz  <cpopetz@cygnus.com>\n \n         * config/mips/mips.c (mips_va_arg): For EABI, emit the queued"}, {"sha": "f2d98a47a97710d3b7e3bf63b58813c5b7db33df", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f90800f836965874b1025412cd1690638edfce07", "patch": "@@ -206,6 +206,7 @@ const int x86_read_modify_write = ~m_PENT;\n const int x86_read_modify = ~(m_PENT | m_PPRO);\n const int x86_split_long_moves = m_PPRO;\n const int x86_promote_QImode = m_K6 | m_PENT | m_386 | m_486;\n+const int x86_single_stringop = m_386;\n \n #define AT_BP(mode) (gen_rtx_MEM ((mode), frame_pointer_rtx))\n "}, {"sha": "62883d73c9e636f622fd23bb74cac21a39d4abf7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f90800f836965874b1025412cd1690638edfce07", "patch": "@@ -161,7 +161,7 @@ extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;\n extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;\n extern const int x86_use_cltd, x86_read_modify_write;\n extern const int x86_read_modify, x86_split_long_moves;\n-extern const int x86_promote_QImode;\n+extern const int x86_promote_QImode, x86_single_stringop;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -184,6 +184,7 @@ extern const int x86_promote_QImode;\n #define TARGET_READ_MODIFY_WRITE (x86_read_modify_write & CPUMASK)\n #define TARGET_READ_MODIFY (x86_read_modify & CPUMASK)\n #define TARGET_PROMOTE_QImode (x86_promote_QImode & CPUMASK)\n+#define TARGET_SINGLE_STRINGOP (x86_single_stringop & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}, {"sha": "2f7aa6ab140e1d2b5aedb21d72ea347ad7f8f12c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 140, "deletions": 51, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90800f836965874b1025412cd1690638edfce07/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f90800f836965874b1025412cd1690638edfce07", "patch": "@@ -7825,71 +7825,162 @@\n   [(set_attr \"type\" \"cld\")])\n \n (define_expand \"movstrsi\"\n-  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n-\t      (use (reg:SI 19))\n-\t      (clobber (match_scratch:SI 4 \"\"))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 6))])]\n+  [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n+   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  rtx addr0, addr1;\n+  rtx srcreg, destreg, countreg;\n \n   if (GET_CODE (operands[2]) != CONST_INT)\n     FAIL;\n \n-  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+  destreg = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  srcreg = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n \n-  operands[5] = addr0;\n-  operands[6] = addr1;\n-\n-  operands[0] = change_address (operands[0], VOIDmode, addr0);\n-  operands[1] = change_address (operands[1], VOIDmode, addr1);\n-  emit_insn (gen_cld ());\n+  emit_insn (gen_cld());\n+  /* When optimizing for size emit simple rep ; movsb instruction.  */\n+  if (!optimize || optimize_size)\n+    {\n+      countreg = copy_to_mode_reg (SImode, operands[2]);\n+      emit_insn (gen_rep_movqi (destreg, srcreg, countreg,\n+      \t\t\t\tdestreg, srcreg, countreg));\n+    }\n+  else\n+    {\n+      if (INTVAL (operands[2]) & ~0x03)\n+\t{\n+\t  countreg = copy_to_mode_reg (SImode,\n+\t  \t\t\t       GEN_INT ((INTVAL (operands[2]) >> 2)\n+\t\t\t\t\t\t& 0x3fffffff));\n+\t  emit_insn (gen_rep_movsi (destreg, srcreg, countreg,\n+\t\t\t\t    destreg, srcreg, countreg));\n+\t}\n+      if (INTVAL (operands[2]) & 0x02)\n+\temit_insn (gen_strmovhi (destreg, srcreg));\n+      if (INTVAL (operands[2]) & 0x01)\n+\temit_insn (gen_strmovqi (destreg, srcreg));\n+    }\n+  DONE;\n }\")\n \n-;; It might seem that operands 0 & 1 could use predicate register_operand.\n-;; But strength reduction might offset the MEM expression.  So we let\n-;; reload put the address into %edi & %esi.\n+;; Most CPUs don't like single string operations\n+;; Handle this case here to simplify previous expander.\n \n-(define_insn \"*movstrsi_1\"\n-  [(set (mem:BLK (match_operand:SI 0 \"address_operand\" \"D\"))\n-\t(mem:BLK (match_operand:SI 1 \"address_operand\" \"S\")))\n-   (use (match_operand:SI 2 \"const_int_operand\" \"n\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (use (reg:SI 19))\n-   (clobber (match_scratch:SI 4 \"=&c\"))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))]\n+(define_expand \"strmovhi\"\n+  [(set (match_dup 2)\n+  \t(mem:HI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (mem:HI (match_operand:SI 0 \"register_operand\" \"\"))\n+        (match_dup 2))\n+   (parallel [(set (match_dup 0) (plus:SI (match_dup 0) (const_int 2)))\n+\t      (clobber (reg:CC 17))])\n+   (parallel [(set (match_dup 1) (plus:SI (match_dup 1) (const_int 2)))\n+\t      (clobber (reg:CC 17))])]\n   \"\"\n-  \"*\n+  \"\n {\n-  rtx xops[2];\n-\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (TARGET_SINGLE_STRINGOP || optimize_size)\n     {\n-      if (INTVAL (operands[2]) & ~0x03)\n-\t{\n-\t  xops[0] = GEN_INT ((INTVAL (operands[2]) >> 2) & 0x3fffffff);\n-\t  xops[1] = operands[4];\n+      emit_insn (gen_strmovhi_1 (operands[0], operands[1], operands[0],\n+\t\t\t\toperands[1]));\n+      DONE;\n+    }\n+  else \n+    operands[2] = gen_reg_rtx (HImode);\n+}\")\n \n-\t  output_asm_insn (\\\"mov{l}\\\\t{%0, %1|%1,%0}\\\", xops);\n-\t  output_asm_insn (\\\"{rep\\;movsl|rep movsd}\\\", xops);\n-\t}\n-      if (INTVAL (operands[2]) & 0x02)\n-\toutput_asm_insn (\\\"movsw\\\", operands);\n-      if (INTVAL (operands[2]) & 0x01)\n-\toutput_asm_insn (\\\"movsb\\\", operands);\n+(define_expand \"strmovqi\"\n+  [(set (match_dup 2)\n+  \t(mem:QI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set (mem:QI (match_operand:SI 0 \"register_operand\" \"\"))\n+        (match_dup 2))\n+   (parallel [(set (match_dup 0) (plus:SI (match_dup 0) (const_int 1)))\n+\t      (clobber (reg:CC 17))])\n+   (parallel [(set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_SINGLE_STRINGOP || optimize_size)\n+    {\n+      emit_insn (gen_strmovqi_1 (operands[0], operands[1], operands[0],\n+\t\t\t\toperands[1]));\n+      DONE;\n     }\n-  else\n-    abort ();\n-  RET;\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n+  else \n+    operands[2] = gen_reg_rtx (QImode);\n+}\")\n+\n+(define_insn \"strmovhi_1\"\n+  [(set (mem:HI (match_operand:SI 2 \"register_operand\" \"0\"))\n+\t(mem:HI (match_operand:SI 3 \"register_operand\" \"1\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"=D\")\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 2)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=S\")\n+\t(plus:SI (match_dup 1)\n+\t\t (const_int 2)))\n+   (use (reg:SI 19))]\n+  \"TARGET_SINGLE_STRINGOP || optimize_size\"\n+  \"movsw\"\n+  [(set_attr \"type\" \"str\")\n+   (set_attr \"memory\" \"both\")\n+   (set_attr \"length_prefix\" \"1\")])\n+\n+(define_insn \"strmovqi_1\"\n+  [(set (mem:QI (match_operand:SI 2 \"register_operand\" \"0\"))\n+\t(mem:QI (match_operand:SI 3 \"register_operand\" \"1\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"=D\")\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=S\")\n+\t(plus:SI (match_dup 1)\n+\t\t (const_int 1)))\n+   (use (reg:SI 19))]\n+  \"TARGET_SINGLE_STRINGOP || optimize_size\"\n+  \"movsb\"\n+  [(set_attr \"type\" \"str\")\n+   (set_attr \"memory\" \"both\")])\n+\n+;; It might seem that operands 3 & 4 could use predicate register_operand.\n+;; But strength reduction might offset the MEM expression.  So we let\n+;; reload put the address into %edi & %esi.\n+\n+(define_insn \"rep_movsi\"\n+  [(set (match_operand:SI 2 \"register_operand\" \"=c\") (const_int 0))\n+   (use (match_operand:SI 5 \"register_operand\" \"2\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=D\") \n+        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\")\n+\t         (ashift:SI (match_dup 5) (const_int 2))))\n+   (set (match_operand:SI 1 \"register_operand\" \"=S\") \n+        (plus:SI (match_operand:SI 4 \"address_operand\" \"1\")\n+\t         (ashift:SI (match_dup 5) (const_int 2))))\n+   (set (mem:BLK (match_dup 3))\n+\t(mem:BLK (match_dup 4)))\n+   (use (reg:SI 19))]\n+  \"\"\n+  \"rep\\;movsl|rep movsd\"\n+  [(set_attr \"type\" \"str\")\n+   (set_attr \"length_prefix\" \"1\")\n+   (set_attr \"memory\" \"both\")])\n+\n+(define_insn \"rep_movqi\"\n+  [(set (match_operand:SI 2 \"register_operand\" \"=c\") (const_int 0))\n+   (use (match_operand:SI 5 \"register_operand\" \"2\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=D\") \n+        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\") (match_dup 5)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=S\") \n+        (plus:SI (match_operand:SI 4 \"address_operand\" \"1\") (match_dup 5)))\n+   (set (mem:BLK (match_dup 3))\n+\t(mem:BLK (match_dup 4)))\n+   (use (reg:SI 19))]\n+  \"\"\n+  \"rep\\;movsb|rep movsb\"\n+  [(set_attr \"type\" \"str\")\n+   (set_attr \"length_prefix\" \"1\")\n+   (set_attr \"memory\" \"both\")])\n \n (define_expand \"clrstrsi\"\n   [(set (reg:SI 19) (const_int 0))\n@@ -7916,8 +8007,6 @@\n   operands[5] = addr0;\n \n   operands[0] = gen_rtx_MEM (BLKmode, addr0);\n-\n-  emit_insn (gen_cld ());\n }\")\n \n ;; It might seem that operand 0 could use predicate register_operand."}]}