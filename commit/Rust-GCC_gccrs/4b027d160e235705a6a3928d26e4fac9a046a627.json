{"sha": "4b027d160e235705a6a3928d26e4fac9a046a627", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwMjdkMTYwZTIzNTcwNWE2YTM5MjhkMjZlNGZhYzlhMDQ2YTYyNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:29:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:29:58Z"}, "message": "(common_type): Add attribute merging.\n\n(comp_types): Use COMP_TYPE_ATTRIBUTES macro.\n\nFrom-SVN: r7254", "tree": {"sha": "a12f56fce82ad0bb53c1f459bdbc6a46900c493c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a12f56fce82ad0bb53c1f459bdbc6a46900c493c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b027d160e235705a6a3928d26e4fac9a046a627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b027d160e235705a6a3928d26e4fac9a046a627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b027d160e235705a6a3928d26e4fac9a046a627", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b027d160e235705a6a3928d26e4fac9a046a627/comments", "author": null, "committer": null, "parents": [{"sha": "91e97eb8cb646cd6e29794945ee27cd1fd10658b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e97eb8cb646cd6e29794945ee27cd1fd10658b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e97eb8cb646cd6e29794945ee27cd1fd10658b"}], "stats": {"total": 132, "additions": 99, "deletions": 33}, "files": [{"sha": "ba2530679f7470320d7cc917f5a6f6330f2cf604", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 99, "deletions": 33, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b027d160e235705a6a3928d26e4fac9a046a627/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b027d160e235705a6a3928d26e4fac9a046a627/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4b027d160e235705a6a3928d26e4fac9a046a627", "patch": "@@ -178,6 +178,7 @@ common_type (t1, t2)\n {\n   register enum tree_code code1;\n   register enum tree_code code2;\n+  tree attributes;\n \n   /* Save time if the two types are the same.  */\n \n@@ -189,6 +190,40 @@ common_type (t1, t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n+  /* Merge the attributes */\n+\n+  { register tree a1, a2;\n+    a1 = TYPE_ATTRIBUTES (t1);\n+    a2 = TYPE_ATTRIBUTES (t2);\n+\n+    /* Either one unset?  Take the set one.  */\n+\n+    if (!(attributes = a1))\n+       attributes = a2;\n+\n+    /* One that completely contains the other?  Take it.  */\n+\n+    else if (a2 && !attribute_list_contained (a1, a2))\n+       if (attribute_list_contained (a2, a1))\n+\t  attributes = a2;\n+       else\n+\t{\n+\t  /* Pick the longest list, and hang on the other\n+\t     list.  */\n+\t\n+\t  if (list_length (a1) < list_length (a2))\n+\t     attributes = a2, a2 = a1;\n+\n+\t  for (; a2; a2 = TREE_CHAIN (a2))\n+\t     if (!value_member (attributes, a2))\n+\t      {\n+\t\ta1 = copy_node (a2);\n+\t\tTREE_CHAIN (a1) = attributes;\n+\t\tattributes = a1;\n+\t      }\n+\t}\n+  }\n+\n   /* Treat an enum type as the unsigned integer type of the same width.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n@@ -209,11 +244,12 @@ common_type (t1, t2)\n       tree subtype = common_type (subtype1, subtype2);\n \n       if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n-\treturn t1;\n+\treturn build_type_attribute_variant (t1, attributes);\n       else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n-\treturn t2;\n+\treturn build_type_attribute_variant (t2, attributes);\n       else\n-\treturn build_complex_type (subtype);\n+\treturn build_type_attribute_variant (build_complex_type (subtype),\n+\t\t\t\t\t     attributes);\n     }\n \n   switch (code1)\n@@ -223,39 +259,43 @@ common_type (t1, t2)\n       /* If only one is real, use it as the result.  */\n \n       if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n-\treturn t1;\n+\treturn build_type_attribute_variant (t1, attributes);\n \n       if (code2 == REAL_TYPE && code1 != REAL_TYPE)\n-\treturn t2;\n+\treturn build_type_attribute_variant (t2, attributes);\n \n       /* Both real or both integers; use the one with greater precision.  */\n \n       if (TYPE_PRECISION (t1) > TYPE_PRECISION (t2))\n-\treturn t1;\n+\treturn build_type_attribute_variant (t1, attributes);\n       else if (TYPE_PRECISION (t2) > TYPE_PRECISION (t1))\n-\treturn t2;\n+\treturn build_type_attribute_variant (t2, attributes);\n \n       /* Same precision.  Prefer longs to ints even when same size.  */\n \n       if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_unsigned_type_node)\n-\treturn long_unsigned_type_node;\n+\treturn build_type_attribute_variant (long_unsigned_type_node,\n+\t\t\t\t\t     attributes);\n \n       if (TYPE_MAIN_VARIANT (t1) == long_integer_type_node\n \t  || TYPE_MAIN_VARIANT (t2) == long_integer_type_node)\n \t{\n \t  /* But preserve unsignedness from the other type,\n \t     since long cannot hold all the values of an unsigned int.  */\n \t  if (TREE_UNSIGNED (t1) || TREE_UNSIGNED (t2))\n-\t    return long_unsigned_type_node;\n-\t  return long_integer_type_node;\n+\t     t1 = long_unsigned_type_node;\n+\t  else\n+\t     t1 = long_integer_type_node;\n+\t  return build_type_attribute_variant (t1, attributes);\n \t}\n \n       /* Otherwise prefer the unsigned one.  */\n \n       if (TREE_UNSIGNED (t1))\n-\treturn t1;\n-      else return t2;\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else\n+\treturn build_type_attribute_variant (t2, attributes);\n \n     case POINTER_TYPE:\n       /* For two pointers, do this recursively on the target type,\n@@ -270,22 +310,26 @@ common_type (t1, t2)\n \t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n \tint volatilep\n \t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n-\treturn build_pointer_type (c_build_type_variant (target, constp, volatilep));\n+\tt1 = build_pointer_type (c_build_type_variant (target, constp,\n+\t\t\t\t volatilep));\n+\treturn build_type_attribute_variant (t1, attributes);\n       }\n #if 0\n-      return build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      t1 = build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      return build_type_attribute_variant (t1, attributes);\n #endif\n \n     case ARRAY_TYPE:\n       {\n \ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n-\t  return t1;\n+\t  return build_type_attribute_variant (t1, attributes);\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2))\n-\t  return t2;\n+\t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n-\treturn build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\tt1 = build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\treturn build_type_attribute_variant (t1, attributes);\n       }\n \n     case FUNCTION_TYPE:\n@@ -301,15 +345,21 @@ common_type (t1, t2)\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (valtype == TREE_TYPE (t1) && ! TYPE_ARG_TYPES (t2))\n-\t  return t1;\n+\t  return build_type_attribute_variant (t1, attributes);\n \tif (valtype == TREE_TYPE (t2) && ! TYPE_ARG_TYPES (t1))\n-\t  return t2;\n+\t  return build_type_attribute_variant (t2, attributes);\n \n \t/* Simple way if one arg fails to specify argument types.  */\n \tif (TYPE_ARG_TYPES (t1) == 0)\n-\t  return build_function_type (valtype, TYPE_ARG_TYPES (t2));\n+\t {\n+\t   t1 = build_function_type (valtype, TYPE_ARG_TYPES (t2));\n+\t   return build_type_attribute_variant (t1, attributes);\n+\t }\n \tif (TYPE_ARG_TYPES (t2) == 0)\n-\t  return build_function_type (valtype, TYPE_ARG_TYPES (t1));\n+\t {\n+\t   t1 = build_function_type (valtype, TYPE_ARG_TYPES (t1));\n+\t   return build_type_attribute_variant (t1, attributes);\n+\t }\n \n \t/* If both args specify argument types, we must merge the two\n \t   lists, argument by argument.  */\n@@ -373,11 +423,12 @@ common_type (t1, t2)\n \t  parm_done: ;\n \t  }\n \n-\treturn build_function_type (valtype, newargs);\n+\tt1 = build_function_type (valtype, newargs);\n+\t/* ... falls through ... */\n       }\n \n     default:\n-      return t1;\n+      return build_type_attribute_variant (t1, attributes);\n     }\n \n }\n@@ -392,6 +443,7 @@ comptypes (type1, type2)\n {\n   register tree t1 = type1;\n   register tree t2 = type2;\n+  int attrval, val;\n \n   /* Suppress errors caused by previously reported errors.  */\n \n@@ -427,21 +479,33 @@ comptypes (type1, type2)\n   if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n     return 1;\n \n+#ifndef COMP_TYPE_ATTRIBUTES\n+#define COMP_TYPE_ATTRIBUTES(t1,t2)\t1\n+#endif\n+\n+  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n+  if (! (attrval = COMP_TYPE_ATTRIBUTES (t1, t2)))\n+     return 0;\n+\n+  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n+  val = 0;\n+\n   switch (TREE_CODE (t1))\n     {\n     case POINTER_TYPE:\n-      return (TREE_TYPE (t1) == TREE_TYPE (t2)\n+      val = (TREE_TYPE (t1) == TREE_TYPE (t2)\n \t      ? 1 : comptypes (TREE_TYPE (t1), TREE_TYPE (t2)));\n+      break;\n \n     case FUNCTION_TYPE:\n-      return function_types_compatible_p (t1, t2);\n+      val = function_types_compatible_p (t1, t2);\n+      break;\n \n     case ARRAY_TYPE:\n       {\n-\t/* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-\tint val = 1;\n \ttree d1 = TYPE_DOMAIN (t1);\n \ttree d2 = TYPE_DOMAIN (t2);\n+\tval = 1;\n \n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n@@ -454,24 +518,26 @@ comptypes (type1, type2)\n \t    || TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t    || TREE_CODE (TYPE_MAX_VALUE (d1)) != INTEGER_CST\n \t    || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST)\n-\t  return val;\n+\t  break;\n \n-\treturn (((TREE_INT_CST_LOW (TYPE_MIN_VALUE (d1))\n+\tif (! ((TREE_INT_CST_LOW (TYPE_MIN_VALUE (d1))\n \t\t  == TREE_INT_CST_LOW (TYPE_MIN_VALUE (d2)))\n \t\t && (TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d1))\n \t\t     == TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d2)))\n \t\t && (TREE_INT_CST_LOW (TYPE_MAX_VALUE (d1))\n \t\t     == TREE_INT_CST_LOW (TYPE_MAX_VALUE (d2)))\n \t\t && (TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d1))\n-\t\t     == TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d2))))\n-\t\t? val : 0);\n+\t\t     == TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d2)))))\n+\t   val = 0;\n+        break;\n       }\n \n     case RECORD_TYPE:\n       if (maybe_objc_comptypes (t1, t2, 0) == 1)\n-\treturn 1;\n+\tval = 1;\n+      break;\n     }\n-  return 0;\n+  return attrval == 2 && val == 1 ? 2 : val;\n }\n \n /* Return 1 if TTL and TTR are pointers to types that are equivalent,"}]}