{"sha": "c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkM2QxYjY4MWY3ODQ3Mjk5YjJlOGUxNGM2MWNmOTAzZDZlZThmZA==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2018-03-19T18:08:24Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2018-03-19T18:08:24Z"}, "message": "RISC-V: Fix bootstrap failure.\n\n\tgcc/\n\tPR bootstrap/84856\n\t* config/riscv/riscv.c (riscv_function_arg_boundary): Use\n\tPREFERRED_STACK_BOUNDARY instead of STACK_BOUNDARY.\n\t(riscv_first_stack_step): Likewise.\n\t(riscv_option_override): Use STACK_BOUNDARY instead of\n\tMIN_STACK_BOUNDARY.\n\t* config/riscv/riscv.h (STACK_BOUNDARY): Renamed from\n\tMIN_STACK_BOUNDARY.\n\t(BIGGEST_ALIGNMENT): Set to 128.\n\t(PREFERRED_STACK_BOUNDARY): Renamed from STACK_BOUNDARY.\n\t(RISCV_STACK_ALIGN): Use PREFERRED_STACK_BOUNDARY instead of\n\tSTACK_BOUNDARY.\n\nFrom-SVN: r258650", "tree": {"sha": "6c750ebf2a08f4fbadc51e44dfe2f389b7ee21bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c750ebf2a08f4fbadc51e44dfe2f389b7ee21bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/comments", "author": null, "committer": null, "parents": [{"sha": "be742eb4d4a3295d6e07e4c8d66a5ab54a68ef2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be742eb4d4a3295d6e07e4c8d66a5ab54a68ef2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be742eb4d4a3295d6e07e4c8d66a5ab54a68ef2f"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "bed98d6b4ea0e472a8201c02a4715f0a8e835940", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "patch": "@@ -1,3 +1,18 @@\n+2018-03-19  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR bootstrap/84856\n+\t* config/riscv/riscv.c (riscv_function_arg_boundary): Use\n+\tPREFERRED_STACK_BOUNDARY instead of STACK_BOUNDARY.\n+\t(riscv_first_stack_step): Likewise.\n+\t(riscv_option_override): Use STACK_BOUNDARY instead of\n+\tMIN_STACK_BOUNDARY.\n+\t* config/riscv/riscv.h (STACK_BOUNDARY): Renamed from\n+\tMIN_STACK_BOUNDARY.\n+\t(BIGGEST_ALIGNMENT): Set to 128.\n+\t(PREFERRED_STACK_BOUNDARY): Renamed from STACK_BOUNDARY.\n+\t(RISCV_STACK_ALIGN): Use PREFERRED_STACK_BOUNDARY instead of\n+\tSTACK_BOUNDARY.\n+\n 2018-03-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84933"}, {"sha": "9e1005e8f105edec1009026bbc08a509513aa8e6", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "patch": "@@ -2202,7 +2202,7 @@ riscv_expand_conditional_branch (rtx label, rtx_code code, rtx op0, rtx op1)\n \n /* Implement TARGET_FUNCTION_ARG_BOUNDARY.  Every parameter gets at\n    least PARM_BOUNDARY bits of alignment, but will be given anything up\n-   to STACK_BOUNDARY bits if the type requires it.  */\n+   to PREFERRED_STACK_BOUNDARY bits if the type requires it.  */\n \n static unsigned int\n riscv_function_arg_boundary (machine_mode mode, const_tree type)\n@@ -2215,7 +2215,7 @@ riscv_function_arg_boundary (machine_mode mode, const_tree type)\n   else\n     alignment = type ? TYPE_ALIGN (type) : GET_MODE_ALIGNMENT (mode);\n \n-  return MIN (STACK_BOUNDARY, MAX (PARM_BOUNDARY, alignment));\n+  return MIN (PREFERRED_STACK_BOUNDARY, MAX (PARM_BOUNDARY, alignment));\n }\n \n /* If MODE represents an argument that can be passed or returned in\n@@ -3506,7 +3506,7 @@ riscv_first_stack_step (struct riscv_frame_info *frame)\n     return frame->total_size;\n \n   HOST_WIDE_INT min_first_step = frame->total_size - frame->fp_sp_offset;\n-  HOST_WIDE_INT max_first_step = IMM_REACH / 2 - STACK_BOUNDARY / 8;\n+  HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;\n   HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;\n   gcc_assert (min_first_step <= max_first_step);\n \n@@ -4142,7 +4142,7 @@ riscv_option_override (void)\n   riscv_stack_boundary = ABI_STACK_BOUNDARY;\n   if (riscv_preferred_stack_boundary_arg)\n     {\n-      int min = ctz_hwi (MIN_STACK_BOUNDARY / 8);\n+      int min = ctz_hwi (STACK_BOUNDARY / 8);\n       int max = 8;\n \n       if (!IN_RANGE (riscv_preferred_stack_boundary_arg, min, max))"}, {"sha": "ebd80c0a5f2853c29a9232e79559de81aa2db070", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=c0d3d1b681f7847299b2e8e14c61cf903d6ee8fd", "patch": "@@ -124,13 +124,13 @@ along with GCC; see the file COPYING3.  If not see\n #define FUNCTION_BOUNDARY (TARGET_RVC ? 16 : 32)\n \n /* The smallest supported stack boundary the calling convention supports.  */\n-#define MIN_STACK_BOUNDARY (2 * BITS_PER_WORD)\n+#define STACK_BOUNDARY (2 * BITS_PER_WORD)\n \n /* The ABI stack alignment.  */\n #define ABI_STACK_BOUNDARY 128\n \n /* There is no point aligning anything to a rounder boundary than this.  */\n-#define BIGGEST_ALIGNMENT STACK_BOUNDARY\n+#define BIGGEST_ALIGNMENT 128\n \n /* The user-level ISA permits unaligned accesses, but they are not required\n    of the privileged architecture.  */\n@@ -482,7 +482,7 @@ enum reg_class\n    `crtl->outgoing_args_size'.  */\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n \n-#define STACK_BOUNDARY riscv_stack_boundary\n+#define PREFERRED_STACK_BOUNDARY riscv_stack_boundary\n \n /* Symbolic macros for the registers used to return integer and floating\n    point values.  */\n@@ -540,7 +540,7 @@ typedef struct {\n \n /* Align based on stack boundary, which might have been set by the user.  */\n #define RISCV_STACK_ALIGN(LOC) \\\n-  (((LOC) + ((STACK_BOUNDARY/8)-1)) & -(STACK_BOUNDARY/8))\n+  (((LOC) + ((PREFERRED_STACK_BOUNDARY/8)-1)) & -(PREFERRED_STACK_BOUNDARY/8))\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}]}