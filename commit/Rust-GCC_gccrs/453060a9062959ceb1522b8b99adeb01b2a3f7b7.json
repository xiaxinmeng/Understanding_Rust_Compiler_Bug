{"sha": "453060a9062959ceb1522b8b99adeb01b2a3f7b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUzMDYwYTkwNjI5NTljZWIxNTIyYjhiOTlhZGViMDFiMmEzZjdiNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-08T16:37:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-08T16:37:54Z"}, "message": "runtime: copy memory hash code from Go 1.7\n    \n    Rewrite the AES hashing code from gc assembler to C code using\n    intrinsics.  The resulting code generates the same hash code for the\n    same input as the gc code--that doesn't matter as such, but testing it\n    ensures that the C code does something useful.\n    \n    Also change mips64pe32le to mips64p32le in configure script--noticed\n    during CL review.\n    \n    Reviewed-on: https://go-review.googlesource.com/34022\n\nFrom-SVN: r243445", "tree": {"sha": "34a4ee9d0eb2d5e59c8a8ffc86e75b6e7b9a572c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34a4ee9d0eb2d5e59c8a8ffc86e75b6e7b9a572c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/453060a9062959ceb1522b8b99adeb01b2a3f7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/453060a9062959ceb1522b8b99adeb01b2a3f7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/453060a9062959ceb1522b8b99adeb01b2a3f7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/453060a9062959ceb1522b8b99adeb01b2a3f7b7/comments", "author": null, "committer": null, "parents": [{"sha": "b2264b0964560e724010aac2faf4f6a3ec2729f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2264b0964560e724010aac2faf4f6a3ec2729f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2264b0964560e724010aac2faf4f6a3ec2729f7"}], "stats": {"total": 985, "additions": 937, "deletions": 48}, "files": [{"sha": "6bc3797e895b6976b0a66f75412971cfbdc7c94f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -1,4 +1,4 @@\n-2442fca7be8a4f51ddc91070fa69ef66e24593ac\n+78e3527fcaf4ffd33b22e39a56e5d076844302be\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "f3cb32b5142bf12b36a36f88e0b023960c34ad62", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -1648,7 +1648,7 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n   const char* equal_fnname;\n   if (this->compare_is_identity(gogo))\n     {\n-      hash_fnname = \"__go_type_hash_identity\";\n+      hash_fnname = \"runtime.memhash\";\n       equal_fnname = \"__go_type_equal_identity\";\n     }\n   else"}, {"sha": "b9aee9d657dd2509f2916014797d6ef59eb1ac69", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -422,6 +422,7 @@ endif\n endif\n \n runtime_files = \\\n+\truntime/aeshash.c \\\n \truntime/go-assert.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\"}, {"sha": "86d7aa84e7d041b1e8493b0e93fd932f33ef39af", "filename": "libgo/Makefile.in", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -189,7 +189,7 @@ libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_4 =  \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@\tgetncpu-bsd.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_4 = getncpu-linux.lo\n-am__objects_5 = go-assert.lo go-breakpoint.lo go-caller.lo \\\n+am__objects_5 = aeshash.lo go-assert.lo go-breakpoint.lo go-caller.lo \\\n \tgo-callers.lo go-cdiv.lo go-cgo.lo go-construct-map.lo \\\n \tgo-ffi.lo go-fieldtrack.lo go-matherr.lo go-memclr.lo \\\n \tgo-memcmp.lo go-memequal.lo go-memmove.lo go-nanotime.lo \\\n@@ -767,6 +767,7 @@ toolexeclibgounicode_DATA = \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n @LIBGO_IS_LINUX_TRUE@runtime_getncpu_file = runtime/getncpu-linux.c\n runtime_files = \\\n+\truntime/aeshash.c \\\n \truntime/go-assert.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n@@ -1446,6 +1447,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aeshash.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-bsd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-irix.Plo@am__quote@\n@@ -1573,6 +1575,13 @@ libgolibbegin_a-go-libmain.obj: runtime/go-libmain.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -c -o libgolibbegin_a-go-libmain.obj `if test -f 'runtime/go-libmain.c'; then $(CYGPATH_W) 'runtime/go-libmain.c'; else $(CYGPATH_W) '$(srcdir)/runtime/go-libmain.c'; fi`\n \n+aeshash.lo: runtime/aeshash.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT aeshash.lo -MD -MP -MF $(DEPDIR)/aeshash.Tpo -c -o aeshash.lo `test -f 'runtime/aeshash.c' || echo '$(srcdir)/'`runtime/aeshash.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/aeshash.Tpo $(DEPDIR)/aeshash.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/aeshash.c' object='aeshash.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o aeshash.lo `test -f 'runtime/aeshash.c' || echo '$(srcdir)/'`runtime/aeshash.c\n+\n go-assert.lo: runtime/go-assert.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-assert.lo -MD -MP -MF $(DEPDIR)/go-assert.Tpo -c -o go-assert.lo `test -f 'runtime/go-assert.c' || echo '$(srcdir)/'`runtime/go-assert.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-assert.Tpo $(DEPDIR)/go-assert.Plo"}, {"sha": "7789c120a9b92f4b7737e9e5c5ca8799730509cc", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -13624,7 +13624,7 @@ esac\n # supported by the gofrontend and all architectures supported by the\n # gc toolchain.\n # N.B. Keep in sync with gcc/testsuite/go.test/go-test.exp (go-set-goarch).\n-ALLGOARCH=\"386 alpha amd64 amd64p32 arm armbe arm64 arm64be ia64 m68k mipso32 mipsn32 mipso64 mipsn64 mips mipsle mips64 mips64le mips64p32 mips64pe32le ppc ppc64 ppc64le s390 s390x sparc sparc64\"\n+ALLGOARCH=\"386 alpha amd64 amd64p32 arm armbe arm64 arm64be ia64 m68k mipso32 mipsn32 mipso64 mipsn64 mips mipsle mips64 mips64le mips64p32 mips64p32le ppc ppc64 ppc64le s390 s390x sparc sparc64\"\n \n # All known GOARCH_FAMILY values.\n ALLGOARCHFAMILY=\"I386 ALPHA AMD64 ARM ARM64 IA64 M68K MIPS MIPS64 PPC PPC64 S390 S390X SPARC SPARC64\""}, {"sha": "77a744ea4187f8672cf161c776f5b60cbdf7fa78", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -197,7 +197,7 @@ AC_SUBST(USE_DEJAGNU)\n # supported by the gofrontend and all architectures supported by the\n # gc toolchain.\n # N.B. Keep in sync with gcc/testsuite/go.test/go-test.exp (go-set-goarch).\n-ALLGOARCH=\"386 alpha amd64 amd64p32 arm armbe arm64 arm64be ia64 m68k mipso32 mipsn32 mipso64 mipsn64 mips mipsle mips64 mips64le mips64p32 mips64pe32le ppc ppc64 ppc64le s390 s390x sparc sparc64\"\n+ALLGOARCH=\"386 alpha amd64 amd64p32 arm armbe arm64 arm64be ia64 m68k mipso32 mipsn32 mipso64 mipsn64 mips mipsle mips64 mips64le mips64p32 mips64p32le ppc ppc64 ppc64le s390 s390x sparc sparc64\"\n \n # All known GOARCH_FAMILY values.\n ALLGOARCHFAMILY=\"I386 ALPHA AMD64 ARM ARM64 IA64 M68K MIPS MIPS64 PPC PPC64 S390 S390X SPARC SPARC64\""}, {"sha": "5ec19d0a9f9ff33139e2710bca27b625ff17838d", "filename": "libgo/go/runtime/alg.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -23,12 +23,29 @@ import (\n //go:linkname efacevaleq runtime.efacevaleq\n //go:linkname eqstring runtime.eqstring\n //go:linkname cmpstring runtime.cmpstring\n+//\n+// Temporary to be called from C code.\n+//go:linkname alginit runtime.alginit\n \n const (\n \tc0 = uintptr((8-sys.PtrSize)/4*2860486313 + (sys.PtrSize-4)/4*33054211828000289)\n \tc1 = uintptr((8-sys.PtrSize)/4*3267000013 + (sys.PtrSize-4)/4*23344194077549503)\n )\n \n+var useAeshash bool\n+\n+// in C code\n+func aeshashbody(p unsafe.Pointer, h, s uintptr, sched []byte) uintptr\n+\n+func aeshash(p unsafe.Pointer, h, s uintptr) uintptr {\n+\treturn aeshashbody(p, h, s, aeskeysched[:])\n+}\n+\n+func aeshashstr(p unsafe.Pointer, h uintptr) uintptr {\n+\tps := (*stringStruct)(p)\n+\treturn aeshashbody(unsafe.Pointer(ps.str), h, uintptr(ps.len), aeskeysched[:])\n+}\n+\n func interhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n \ta := (*iface)(p)\n \ttab := a.tab\n@@ -198,7 +215,35 @@ func cmpstring(x, y string) int {\n \n // Force the creation of function descriptors for equality and hash\n // functions.  These will be referenced directly by the compiler.\n+var _ = memhash\n var _ = interhash\n var _ = interequal\n var _ = nilinterhash\n var _ = nilinterequal\n+\n+const hashRandomBytes = sys.PtrSize / 4 * 64\n+\n+// used in asm_{386,amd64}.s to seed the hash function\n+var aeskeysched [hashRandomBytes]byte\n+\n+// used in hash{32,64}.go to seed the hash function\n+var hashkey [4]uintptr\n+\n+func alginit() {\n+\t// Install aes hash algorithm if we have the instructions we need\n+\tif (GOARCH == \"386\" || GOARCH == \"amd64\") &&\n+\t\tGOOS != \"nacl\" &&\n+\t\tcpuid_ecx&(1<<25) != 0 && // aes (aesenc)\n+\t\tcpuid_ecx&(1<<9) != 0 && // sse3 (pshufb)\n+\t\tcpuid_ecx&(1<<19) != 0 { // sse4.1 (pinsr{d,q})\n+\t\tuseAeshash = true\n+\t\t// Initialize with random data so hash collisions will be hard to engineer.\n+\t\tgetRandomData(aeskeysched[:])\n+\t\treturn\n+\t}\n+\tgetRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(&hashkey))[:])\n+\thashkey[0] |= 1 // make sure these numbers are odd\n+\thashkey[1] |= 1\n+\thashkey[2] |= 1\n+\thashkey[3] |= 1\n+}"}, {"sha": "cfb3a58c7c875297595516e32ca82fbf254a5c84", "filename": "libgo/go/runtime/hash32.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fhash32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fhash32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhash32.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Hashing algorithm inspired by\n+//   xxhash: https://code.google.com/p/xxhash/\n+// cityhash: https://code.google.com/p/cityhash/\n+\n+// +build 386 arm armbe m68k mipso32 mipsn32 mips mipsle ppc s390 sparc\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname memhash runtime.memhash\n+\n+const (\n+\t// Constants for multiplication: four random odd 32-bit numbers.\n+\tm1 = 3168982561\n+\tm2 = 3339683297\n+\tm3 = 832293441\n+\tm4 = 2336365089\n+)\n+\n+func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {\n+\tif GOARCH == \"386\" && GOOS != \"nacl\" && useAeshash {\n+\t\treturn aeshash(p, seed, s)\n+\t}\n+\th := uint32(seed + s*hashkey[0])\n+tail:\n+\tswitch {\n+\tcase s == 0:\n+\tcase s < 4:\n+\t\th ^= uint32(*(*byte)(p))\n+\t\th ^= uint32(*(*byte)(add(p, s>>1))) << 8\n+\t\th ^= uint32(*(*byte)(add(p, s-1))) << 16\n+\t\th = rotl_15(h*m1) * m2\n+\tcase s == 4:\n+\t\th ^= readUnaligned32(p)\n+\t\th = rotl_15(h*m1) * m2\n+\tcase s <= 8:\n+\t\th ^= readUnaligned32(p)\n+\t\th = rotl_15(h*m1) * m2\n+\t\th ^= readUnaligned32(add(p, s-4))\n+\t\th = rotl_15(h*m1) * m2\n+\tcase s <= 16:\n+\t\th ^= readUnaligned32(p)\n+\t\th = rotl_15(h*m1) * m2\n+\t\th ^= readUnaligned32(add(p, 4))\n+\t\th = rotl_15(h*m1) * m2\n+\t\th ^= readUnaligned32(add(p, s-8))\n+\t\th = rotl_15(h*m1) * m2\n+\t\th ^= readUnaligned32(add(p, s-4))\n+\t\th = rotl_15(h*m1) * m2\n+\tdefault:\n+\t\tv1 := h\n+\t\tv2 := uint32(seed * hashkey[1])\n+\t\tv3 := uint32(seed * hashkey[2])\n+\t\tv4 := uint32(seed * hashkey[3])\n+\t\tfor s >= 16 {\n+\t\t\tv1 ^= readUnaligned32(p)\n+\t\t\tv1 = rotl_15(v1*m1) * m2\n+\t\t\tp = add(p, 4)\n+\t\t\tv2 ^= readUnaligned32(p)\n+\t\t\tv2 = rotl_15(v2*m2) * m3\n+\t\t\tp = add(p, 4)\n+\t\t\tv3 ^= readUnaligned32(p)\n+\t\t\tv3 = rotl_15(v3*m3) * m4\n+\t\t\tp = add(p, 4)\n+\t\t\tv4 ^= readUnaligned32(p)\n+\t\t\tv4 = rotl_15(v4*m4) * m1\n+\t\t\tp = add(p, 4)\n+\t\t\ts -= 16\n+\t\t}\n+\t\th = v1 ^ v2 ^ v3 ^ v4\n+\t\tgoto tail\n+\t}\n+\th ^= h >> 17\n+\th *= m3\n+\th ^= h >> 13\n+\th *= m4\n+\th ^= h >> 16\n+\treturn uintptr(h)\n+}\n+\n+// Note: in order to get the compiler to issue rotl instructions, we\n+// need to constant fold the shift amount by hand.\n+// TODO: convince the compiler to issue rotl instructions after inlining.\n+func rotl_15(x uint32) uint32 {\n+\treturn (x << 15) | (x >> (32 - 15))\n+}"}, {"sha": "551d5b5f8d839a8856fe1d6ed37efe4496b8ea26", "filename": "libgo/go/runtime/hash64.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fhash64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fhash64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhash64.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Hashing algorithm inspired by\n+//   xxhash: https://code.google.com/p/xxhash/\n+// cityhash: https://code.google.com/p/cityhash/\n+\n+// +build amd64 amd64p32 arm64 mips64 mips64le ppc64 ppc64le s390x alpha arm64be ia64 mipso64 mipsn64 mips64p32 mips64p32le sparc64\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname memhash runtime.memhash\n+\n+const (\n+\t// Constants for multiplication: four random odd 64-bit numbers.\n+\tm1 = 16877499708836156737\n+\tm2 = 2820277070424839065\n+\tm3 = 9497967016996688599\n+\tm4 = 15839092249703872147\n+)\n+\n+func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {\n+\tif GOARCH == \"amd64\" && GOOS != \"nacl\" && useAeshash {\n+\t\treturn aeshash(p, seed, s)\n+\t}\n+\th := uint64(seed + s*hashkey[0])\n+tail:\n+\tswitch {\n+\tcase s == 0:\n+\tcase s < 4:\n+\t\th ^= uint64(*(*byte)(p))\n+\t\th ^= uint64(*(*byte)(add(p, s>>1))) << 8\n+\t\th ^= uint64(*(*byte)(add(p, s-1))) << 16\n+\t\th = rotl_31(h*m1) * m2\n+\tcase s <= 8:\n+\t\th ^= uint64(readUnaligned32(p))\n+\t\th ^= uint64(readUnaligned32(add(p, s-4))) << 32\n+\t\th = rotl_31(h*m1) * m2\n+\tcase s <= 16:\n+\t\th ^= readUnaligned64(p)\n+\t\th = rotl_31(h*m1) * m2\n+\t\th ^= readUnaligned64(add(p, s-8))\n+\t\th = rotl_31(h*m1) * m2\n+\tcase s <= 32:\n+\t\th ^= readUnaligned64(p)\n+\t\th = rotl_31(h*m1) * m2\n+\t\th ^= readUnaligned64(add(p, 8))\n+\t\th = rotl_31(h*m1) * m2\n+\t\th ^= readUnaligned64(add(p, s-16))\n+\t\th = rotl_31(h*m1) * m2\n+\t\th ^= readUnaligned64(add(p, s-8))\n+\t\th = rotl_31(h*m1) * m2\n+\tdefault:\n+\t\tv1 := h\n+\t\tv2 := uint64(seed * hashkey[1])\n+\t\tv3 := uint64(seed * hashkey[2])\n+\t\tv4 := uint64(seed * hashkey[3])\n+\t\tfor s >= 32 {\n+\t\t\tv1 ^= readUnaligned64(p)\n+\t\t\tv1 = rotl_31(v1*m1) * m2\n+\t\t\tp = add(p, 8)\n+\t\t\tv2 ^= readUnaligned64(p)\n+\t\t\tv2 = rotl_31(v2*m2) * m3\n+\t\t\tp = add(p, 8)\n+\t\t\tv3 ^= readUnaligned64(p)\n+\t\t\tv3 = rotl_31(v3*m3) * m4\n+\t\t\tp = add(p, 8)\n+\t\t\tv4 ^= readUnaligned64(p)\n+\t\t\tv4 = rotl_31(v4*m4) * m1\n+\t\t\tp = add(p, 8)\n+\t\t\ts -= 32\n+\t\t}\n+\t\th = v1 ^ v2 ^ v3 ^ v4\n+\t\tgoto tail\n+\t}\n+\n+\th ^= h >> 29\n+\th *= m3\n+\th ^= h >> 32\n+\treturn uintptr(h)\n+}\n+\n+// Note: in order to get the compiler to issue rotl instructions, we\n+// need to constant fold the shift amount by hand.\n+// TODO: convince the compiler to issue rotl instructions after inlining.\n+func rotl_31(x uint64) uint64 {\n+\treturn (x << 31) | (x >> (64 - 31))\n+}"}, {"sha": "4609432e08ccf4822255922de5ac8c77286d95c3", "filename": "libgo/go/runtime/os_gccgo.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fos_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_gccgo.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+var urandom_dev = []byte(\"/dev/urandom\\x00\")\n+\n+func getRandomData(r []byte) {\n+\tif startupRandomData != nil {\n+\t\tn := copy(r, startupRandomData)\n+\t\textendRandom(r, n)\n+\t\treturn\n+\t}\n+\tfd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)\n+\tn := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))\n+\tclosefd(fd)\n+\textendRandom(r, int(n))\n+}"}, {"sha": "4712318b76a63f4625d32bb2dec9a6a882cfc32e", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -5,6 +5,7 @@\n package runtime\n \n import (\n+\t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n \n@@ -668,7 +669,6 @@ type forcegcstate struct {\n // the ELF AT_RANDOM auxiliary vector (vdso_linux_amd64.go or os_linux_386.go).\n var startupRandomData []byte\n \n-/*\n // extendRandom extends the random numbers in r[:n] to the whole slice r.\n // Treats n<0 as n==0.\n func extendRandom(r []byte, n int) {\n@@ -689,7 +689,6 @@ func extendRandom(r []byte, n int) {\n \t\t}\n \t}\n }\n-*/\n \n // deferred subroutine calls\n // This is the gccgo version.\n@@ -770,11 +769,12 @@ var (\n \n \tsched schedt\n \n-//\tnewprocs    int32\n+\t//\tnewprocs    int32\n+\n+\t// Information about what cpu features are available.\n+\t// Set on startup.\n+\tcpuid_ecx uint32\n \n-// Information about what cpu features are available.\n-// Set on startup in asm_{x86,amd64}.s.\n-//\tcpuid_ecx         uint32\n //\tcpuid_edx         uint32\n //\tcpuid_ebx7        uint32\n //\tlfenceBeforeRdtsc bool"}, {"sha": "b4fee6b9076b4b1f9b9146ed0870b45c5ecd4ca0", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -248,6 +248,12 @@ func funcPC(f interface{}) uintptr {\n \treturn **(**uintptr)(i.data)\n }\n \n+// For gccgo, to communicate from the C code to the Go code.\n+//go:linkname setCpuidECX runtime.setCpuidECX\n+func setCpuidECX(v uint32) {\n+\tcpuid_ecx = v\n+}\n+\n // typedmemmove copies a typed value.\n // For gccgo for now.\n //go:nosplit"}, {"sha": "c94f19eeb940cc27d8e8cf8a7614bedc2990f304", "filename": "libgo/go/runtime/unaligned1.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Funaligned1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Funaligned1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Funaligned1.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build 386 amd64 amd64p32 arm64 ppc64 ppc64le s390x ppc s390 arm64be\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+func readUnaligned32(p unsafe.Pointer) uint32 {\n+\treturn *(*uint32)(p)\n+}\n+\n+func readUnaligned64(p unsafe.Pointer) uint64 {\n+\treturn *(*uint64)(p)\n+}"}, {"sha": "e52d6ce4c0049ecc3fa14eb75b862f8be73cb2ee", "filename": "libgo/go/runtime/unaligned2.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Funaligned2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fgo%2Fruntime%2Funaligned2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Funaligned2.go?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build arm mips64 mips64le armbe m68k mipso32 mipsn32 mips mipsle sparc alpha ia64 mipso64 mipsn64 mips64p32 mips64p32le sparc64\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// Note: These routines perform the read with an unspecified endianness.\n+func readUnaligned32(p unsafe.Pointer) uint32 {\n+\tq := (*[4]byte)(p)\n+\treturn uint32(q[0]) + uint32(q[1])<<8 + uint32(q[2])<<16 + uint32(q[3])<<24\n+}\n+\n+func readUnaligned64(p unsafe.Pointer) uint64 {\n+\tq := (*[8]byte)(p)\n+\treturn uint64(q[0]) + uint64(q[1])<<8 + uint64(q[2])<<16 + uint64(q[3])<<24 + uint64(q[4])<<32 + uint64(q[5])<<40 + uint64(q[6])<<48 + uint64(q[7])<<56\n+}"}, {"sha": "faa90e073fa7b7fc914d7e61821621f274d16746", "filename": "libgo/runtime/aeshash.c", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Faeshash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Faeshash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Faeshash.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -0,0 +1,583 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Hash code using AES intrinsics.\n+\n+#include \"runtime.h\"\n+\n+uintptr aeshashbody(void*, uintptr, uintptr, Slice)\n+\t__asm__(GOSYM_PREFIX \"runtime.aeshashbody\");\n+\n+uintptr aeshashbody(void*, uintptr, uintptr, Slice)\n+\t__attribute__((no_split_stack));\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+\n+#include <emmintrin.h>\n+#include <tmmintrin.h>\n+#include <wmmintrin.h>\n+\n+// Force appropriate CPU level.  We won't call here unless the CPU\n+// supports it.\n+\n+#pragma GCC target(\"ssse3\", \"aes\")\n+\n+#ifdef __x86_64__\n+\n+// aeshashbody implements a hash function using AES instructions\n+// available in recent x86 processors. Note this is not encryption,\n+// just hashing.\n+//\n+// This is written to produce exactly the same results as the gc\n+// implementation, not because that matters, but just to ensure that\n+// this does something reasonable.\n+uintptr aeshashbody(void* p, uintptr seed, uintptr size, Slice aeskeysched) {\n+\t__m128i mseed, mseed2, mseed3, mseed4, mseed5, mseed6, mseed7, mseed8;\n+\t__m128i mval, mval2, mval3, mval4, mval5, mval6, mval7, mval8;\n+\n+\t// Start with hash seed.\n+\tmseed = _mm_cvtsi64_si128(seed);\n+\t// Get 16 bits of length.\n+\tmseed = _mm_insert_epi16(mseed, size, 4);\n+\t// Repeat length 4 times total.\n+\tmseed = _mm_shufflehi_epi16(mseed, 0);\n+\t// Save unscrambled seed.\n+\tmseed2 = mseed;\n+\t// XOR in per-process seed.\n+\tmseed ^= _mm_loadu_si128(aeskeysched.__values);\n+\t// Scramble seed.\n+\tmseed = _mm_aesenc_si128(mseed, mseed);\n+\n+\tif (size <= 16) {\n+\t\tif (size == 0) {\n+\t\t\t// Return scrambled input seed.\n+\t\t\treturn _mm_cvtsi128_si64(_mm_aesenc_si128(mseed, mseed));\n+\t\t} else if (size < 16) {\n+\t\t\tif ((((uintptr)(p) + 16) & 0xff0) != 0) {\n+\t\t\t\tstatic const uint64 masks[32]\n+\t\t\t\t  __attribute__ ((aligned(16))) =\n+\t\t\t\t  {\n+\t\t\t\t    0x0000000000000000, 0x0000000000000000,\n+\t\t\t\t    0x00000000000000ff, 0x0000000000000000,\n+\t\t\t\t    0x000000000000ffff, 0x0000000000000000,\n+\t\t\t\t    0x0000000000ffffff, 0x0000000000000000,\n+\t\t\t\t    0x00000000ffffffff, 0x0000000000000000,\n+\t\t\t\t    0x000000ffffffffff, 0x0000000000000000,\n+\t\t\t\t    0x0000ffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0x00ffffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffffff, 0x00000000000000ff,\n+\t\t\t\t    0xffffffffffffffff, 0x000000000000ffff,\n+\t\t\t\t    0xffffffffffffffff, 0x0000000000ffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x00000000ffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x000000ffffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x0000ffffffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x00ffffffffffffff\n+\t\t\t\t  };\n+\n+\t\t\t\t// 16 bytes loaded at p won't cross a page\n+\t\t\t\t// boundary, so we can load directly.\n+\t\t\t\tmval = _mm_loadu_si128(p);\n+\t\t\t\tmval &= *(const __m128i*)(&masks[size*2]);\n+\t\t\t} else {\n+\t\t\t\tstatic const uint64 shifts[32]\n+\t\t\t\t  __attribute__ ((aligned(16))) =\n+\t\t\t\t  {\n+\t\t\t\t    0x0000000000000000, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffff0f, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffffffff0f0e, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffffff0f0e0d, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffff0f0e0d0c, 0xffffffffffffffff,\n+\t\t\t\t    0xffffff0f0e0d0c0b, 0xffffffffffffffff,\n+\t\t\t\t    0xffff0f0e0d0c0b0a, 0xffffffffffffffff,\n+\t\t\t\t    0xff0f0e0d0c0b0a09, 0xffffffffffffffff,\n+\t\t\t\t    0x0f0e0d0c0b0a0908, 0xffffffffffffffff,\n+\t\t\t\t    0x0e0d0c0b0a090807, 0xffffffffffffff0f,\n+\t\t\t\t    0x0d0c0b0a09080706, 0xffffffffffff0f0e,\n+\t\t\t\t    0x0c0b0a0908070605, 0xffffffffff0f0e0d,\n+\t\t\t\t    0x0b0a090807060504, 0xffffffff0f0e0d0c,\n+\t\t\t\t    0x0a09080706050403, 0xffffff0f0e0d0c0b,\n+\t\t\t\t    0x0908070605040302, 0xffff0f0e0d0c0b0a,\n+\t\t\t\t    0x0807060504030201, 0xff0f0e0d0c0b0a09,\n+\t\t\t\t  };\n+\n+\t\t\t\t// address ends in 1111xxxx. Might be\n+\t\t\t\t// up against a page boundary, so load\n+\t\t\t\t// ending at last byte.  Then shift\n+\t\t\t\t// bytes down using pshufb.\n+\t\t\t\tmval = _mm_loadu_si128((void*)((char*)p - 16 + size));\n+\t\t\t\tmval = _mm_shuffle_epi8(mval, *(const __m128i*)(&shifts[size*2]));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tmval = _mm_loadu_si128(p);\n+\t\t}\n+\n+\t\t// XOR data with seed.\n+\t\tmval ^= mseed;\n+\t\t// Scramble combo 3 times.\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\treturn _mm_cvtsi128_si64(mval);\n+\t} else if (size <= 32) {\n+\t\t// Make second starting seed.\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\t// Load data to be hashed.\n+\t\tmval = _mm_loadu_si128(p);\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\t\t// XOR with seed.\n+\t\tmval ^= mseed;\n+\t\tmval2 ^= mseed2;\n+\t\t// Scramble 3 times.\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\t// Combine results.\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si64(mval);\n+\t} else if (size <= 64) {\n+\t\t// Make 3 more starting seeds.\n+\t\tmseed3 = mseed2;\n+\t\tmseed4 = mseed2;\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed3 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 32));\n+\t\tmseed4 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 48));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\tmseed3 = _mm_aesenc_si128(mseed3, mseed3);\n+\t\tmseed4 = _mm_aesenc_si128(mseed4, mseed4);\n+\n+\t\tmval = _mm_loadu_si128(p);\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + 16));\n+\t\tmval3 = _mm_loadu_si128((void*)((char*)p + size - 32));\n+\t\tmval4 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\tmval ^= mseed;\n+\t\tmval2 ^= mseed2;\n+\t\tmval3 ^= mseed3;\n+\t\tmval4 ^= mseed4;\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval ^= mval3;\n+\t\tmval2 ^= mval4;\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si64(mval);\n+\t} else if (size <= 128) {\n+\t\t// Make 7 more starting seeds.\n+\t\tmseed3 = mseed2;\n+\t\tmseed4 = mseed2;\n+\t\tmseed5 = mseed2;\n+\t\tmseed6 = mseed2;\n+\t\tmseed7 = mseed2;\n+\t\tmseed8 = mseed2;\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed3 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 32));\n+\t\tmseed4 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 48));\n+\t\tmseed5 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 64));\n+\t\tmseed6 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 80));\n+\t\tmseed7 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 96));\n+\t\tmseed8 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 112));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\tmseed3 = _mm_aesenc_si128(mseed3, mseed3);\n+\t\tmseed4 = _mm_aesenc_si128(mseed4, mseed4);\n+\t\tmseed5 = _mm_aesenc_si128(mseed5, mseed5);\n+\t\tmseed6 = _mm_aesenc_si128(mseed6, mseed6);\n+\t\tmseed7 = _mm_aesenc_si128(mseed7, mseed7);\n+\t\tmseed8 = _mm_aesenc_si128(mseed8, mseed8);\n+\n+\t\t// Load data.\n+\t\tmval = _mm_loadu_si128(p);\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + 16));\n+\t\tmval3 = _mm_loadu_si128((void*)((char*)p + 32));\n+\t\tmval4 = _mm_loadu_si128((void*)((char*)p + 48));\n+\t\tmval5 = _mm_loadu_si128((void*)((char*)p + size - 64));\n+\t\tmval6 = _mm_loadu_si128((void*)((char*)p + size - 48));\n+\t\tmval7 = _mm_loadu_si128((void*)((char*)p + size - 32));\n+\t\tmval8 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\t// XOR with seed.\n+\t\tmval ^= mseed;\n+\t\tmval2 ^= mseed2;\n+\t\tmval3 ^= mseed3;\n+\t\tmval4 ^= mseed4;\n+\t\tmval5 ^= mseed5;\n+\t\tmval6 ^= mseed6;\n+\t\tmval7 ^= mseed7;\n+\t\tmval8 ^= mseed8;\n+\n+\t\t// Scramble 3 times.\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\n+\t\t// Combine results.\n+\t\tmval ^= mval5;\n+\t\tmval2 ^= mval6;\n+\t\tmval3 ^= mval7;\n+\t\tmval4 ^= mval8;\n+\t\tmval ^= mval3;\n+\t\tmval2 ^= mval4;\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si64(mval);\n+\t} else {\n+\t\t// Make 7 more starting seeds.\n+\t\tmseed3 = mseed2;\n+\t\tmseed4 = mseed2;\n+\t\tmseed5 = mseed2;\n+\t\tmseed6 = mseed2;\n+\t\tmseed7 = mseed2;\n+\t\tmseed8 = mseed2;\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed3 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 32));\n+\t\tmseed4 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 48));\n+\t\tmseed5 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 64));\n+\t\tmseed6 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 80));\n+\t\tmseed7 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 96));\n+\t\tmseed8 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 112));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\tmseed3 = _mm_aesenc_si128(mseed3, mseed3);\n+\t\tmseed4 = _mm_aesenc_si128(mseed4, mseed4);\n+\t\tmseed5 = _mm_aesenc_si128(mseed5, mseed5);\n+\t\tmseed6 = _mm_aesenc_si128(mseed6, mseed6);\n+\t\tmseed7 = _mm_aesenc_si128(mseed7, mseed7);\n+\t\tmseed8 = _mm_aesenc_si128(mseed8, mseed8);\n+\n+\t\t// Start with last (possibly overlapping) block.\n+\t\tmval = _mm_loadu_si128((void*)((char*)p + size - 128));\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + size - 112));\n+\t\tmval3 = _mm_loadu_si128((void*)((char*)p + size - 96));\n+\t\tmval4 = _mm_loadu_si128((void*)((char*)p + size - 80));\n+\t\tmval5 = _mm_loadu_si128((void*)((char*)p + size - 64));\n+\t\tmval6 = _mm_loadu_si128((void*)((char*)p + size - 48));\n+\t\tmval7 = _mm_loadu_si128((void*)((char*)p + size - 32));\n+\t\tmval8 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\t// XOR in seed.\n+\t\tmval ^= mseed;\n+\t\tmval2 ^= mseed2;\n+\t\tmval3 ^= mseed3;\n+\t\tmval4 ^= mseed4;\n+\t\tmval5 ^= mseed5;\n+\t\tmval6 ^= mseed6;\n+\t\tmval7 ^= mseed7;\n+\t\tmval8 ^= mseed8;\n+\n+\t\t// Compute number of remaining 128-byte blocks.\n+\t\tsize--;\n+\t\tsize >>= 7;\n+\t\tdo {\n+\t\t\t// Scramble state.\n+\t\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\n+\t\t\t// Scramble state, XOR in a block.\n+\t\t\tmval = _mm_aesenc_si128(mval, _mm_loadu_si128(p));\n+\t\t\tmval2 = _mm_aesenc_si128(mval2, _mm_loadu_si128((void*)((char*)p + 16)));\n+\t\t\tmval3 = _mm_aesenc_si128(mval3, _mm_loadu_si128((void*)((char*)p + 32)));\n+\t\t\tmval4 = _mm_aesenc_si128(mval4, _mm_loadu_si128((void*)((char*)p + 48)));\n+\t\t\tmval5 = _mm_aesenc_si128(mval5, _mm_loadu_si128((void*)((char*)p + 64)));\n+\t\t\tmval6 = _mm_aesenc_si128(mval6, _mm_loadu_si128((void*)((char*)p + 80)));\n+\t\t\tmval7 = _mm_aesenc_si128(mval7, _mm_loadu_si128((void*)((char*)p + 96)));\n+\t\t\tmval8 = _mm_aesenc_si128(mval8, _mm_loadu_si128((void*)((char*)p + 112)));\n+\n+\t\t\tp = (void*)((char*)p + 128);\n+\t\t} while (--size > 0);\n+\n+\t\t// 3 more scrambles to finish.\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\t\tmval5 = _mm_aesenc_si128(mval5, mval5);\n+\t\tmval6 = _mm_aesenc_si128(mval6, mval6);\n+\t\tmval7 = _mm_aesenc_si128(mval7, mval7);\n+\t\tmval8 = _mm_aesenc_si128(mval8, mval8);\n+\n+\t\tmval ^= mval5;\n+\t\tmval2 ^= mval6;\n+\t\tmval3 ^= mval7;\n+\t\tmval4 ^= mval8;\n+\t\tmval ^= mval3;\n+\t\tmval2 ^= mval4;\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si64(mval);\n+\t}\n+}\n+\n+#else // !defined(__x86_64__)\n+\n+// The 32-bit version of aeshashbody.\n+\n+uintptr aeshashbody(void* p, uintptr seed, uintptr size, Slice aeskeysched) {\n+\t__m128i mseed, mseed2, mseed3, mseed4;\n+\t__m128i mval, mval2, mval3, mval4;\n+\n+\t// Start with hash seed.\n+\tmseed = _mm_cvtsi32_si128(seed);\n+\t// Get 16 bits of length.\n+\tmseed = _mm_insert_epi16(mseed, size, 4);\n+\t// Replace size with its low 2 bytes repeated 4 times.\n+\tmseed = _mm_shufflehi_epi16(mseed, 0);\n+\t// Save unscrambled seed.\n+\tmseed2 = mseed;\n+\t// XOR in per-process seed.\n+\tmseed ^= _mm_loadu_si128(aeskeysched.__values);\n+\t// Scramble seed.\n+\tmseed = _mm_aesenc_si128(mseed, mseed);\n+\n+\tif (size <= 16) {\n+\t\tif (size == 0) {\n+\t\t\t// Return scrambled input seed.\n+\t\t\treturn _mm_cvtsi128_si32(_mm_aesenc_si128(mseed, mseed));\n+\t\t} else if (size < 16) {\n+\t\t\tif ((((uintptr)(p) + 16) & 0xff0) != 0) {\n+\t\t\t\tstatic const uint64 masks[32]\n+\t\t\t\t  __attribute__ ((aligned(16))) =\n+\t\t\t\t  {\n+\t\t\t\t    0x0000000000000000, 0x0000000000000000,\n+\t\t\t\t    0x00000000000000ff, 0x0000000000000000,\n+\t\t\t\t    0x000000000000ffff, 0x0000000000000000,\n+\t\t\t\t    0x0000000000ffffff, 0x0000000000000000,\n+\t\t\t\t    0x00000000ffffffff, 0x0000000000000000,\n+\t\t\t\t    0x000000ffffffffff, 0x0000000000000000,\n+\t\t\t\t    0x0000ffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0x00ffffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffffff, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffffff, 0x00000000000000ff,\n+\t\t\t\t    0xffffffffffffffff, 0x000000000000ffff,\n+\t\t\t\t    0xffffffffffffffff, 0x0000000000ffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x00000000ffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x000000ffffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x0000ffffffffffff,\n+\t\t\t\t    0xffffffffffffffff, 0x00ffffffffffffff\n+\t\t\t\t  };\n+\n+\t\t\t\t// 16 bytes loaded at p won't cross a page\n+\t\t\t\t// boundary, so we can load it directly.\n+\t\t\t\tmval = _mm_loadu_si128(p);\n+\t\t\t\tmval &= *(const __m128i*)(&masks[size*2]);\n+\t\t\t} else {\n+\t\t\t\tstatic const uint64 shifts[32]\n+\t\t\t\t  __attribute__ ((aligned(16))) =\n+\t\t\t\t  {\n+\t\t\t\t    0x0000000000000000, 0x0000000000000000,\n+\t\t\t\t    0xffffffffffffff0f, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffffffff0f0e, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffffff0f0e0d, 0xffffffffffffffff,\n+\t\t\t\t    0xffffffff0f0e0d0c, 0xffffffffffffffff,\n+\t\t\t\t    0xffffff0f0e0d0c0b, 0xffffffffffffffff,\n+\t\t\t\t    0xffff0f0e0d0c0b0a, 0xffffffffffffffff,\n+\t\t\t\t    0xff0f0e0d0c0b0a09, 0xffffffffffffffff,\n+\t\t\t\t    0x0f0e0d0c0b0a0908, 0xffffffffffffffff,\n+\t\t\t\t    0x0e0d0c0b0a090807, 0xffffffffffffff0f,\n+\t\t\t\t    0x0d0c0b0a09080706, 0xffffffffffff0f0e,\n+\t\t\t\t    0x0c0b0a0908070605, 0xffffffffff0f0e0d,\n+\t\t\t\t    0x0b0a090807060504, 0xffffffff0f0e0d0c,\n+\t\t\t\t    0x0a09080706050403, 0xffffff0f0e0d0c0b,\n+\t\t\t\t    0x0908070605040302, 0xffff0f0e0d0c0b0a,\n+\t\t\t\t    0x0807060504030201, 0xff0f0e0d0c0b0a09,\n+\t\t\t\t  };\n+\n+\t\t\t\t// address ends in 1111xxxx. Might be\n+\t\t\t\t// up against a page boundary, so load\n+\t\t\t\t// ending at last byte.  Then shift\n+\t\t\t\t// bytes down using pshufb.\n+\t\t\t\tmval = _mm_loadu_si128((void*)((char*)p - 16 + size));\n+\t\t\t\tmval = _mm_shuffle_epi8(mval, *(const __m128i*)(&shifts[size*2]));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tmval = _mm_loadu_si128(p);\n+\t\t}\n+\n+\t\t// Scramble input, XOR in seed.\n+\t\tmval = _mm_aesenc_si128(mval, mseed);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\treturn _mm_cvtsi128_si32(mval);\n+\t} else if (size <= 32) {\n+\t\t// Make second starting seed.\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\t// Load data to be hashed.\n+\t\tmval = _mm_loadu_si128(p);\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\t// Scramble 3 times.\n+\t\tmval = _mm_aesenc_si128(mval, mseed);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mseed2);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\n+\t\t// Combine results.\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si32(mval);\n+\t} else if (size <= 64) {\n+\t\t// Make 3 more starting seeds.\n+\t\tmseed3 = mseed2;\n+\t\tmseed4 = mseed2;\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed3 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 32));\n+\t\tmseed4 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 48));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\tmseed3 = _mm_aesenc_si128(mseed3, mseed3);\n+\t\tmseed4 = _mm_aesenc_si128(mseed4, mseed4);\n+\n+\t\tmval = _mm_loadu_si128(p);\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + 16));\n+\t\tmval3 = _mm_loadu_si128((void*)((char*)p + size - 32));\n+\t\tmval4 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\tmval = _mm_aesenc_si128(mval, mseed);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mseed2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mseed3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mseed4);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval ^= mval3;\n+\t\tmval2 ^= mval4;\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si32(mval);\n+\t} else {\n+\t\t// Make 3 more starting seeds.\n+\t\tmseed3 = mseed2;\n+\t\tmseed4 = mseed2;\n+\t\tmseed2 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 16));\n+\t\tmseed3 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 32));\n+\t\tmseed4 ^= _mm_loadu_si128((void*)((char*)aeskeysched.__values + 48));\n+\t\tmseed2 = _mm_aesenc_si128(mseed2, mseed2);\n+\t\tmseed3 = _mm_aesenc_si128(mseed3, mseed3);\n+\t\tmseed4 = _mm_aesenc_si128(mseed4, mseed4);\n+\n+\t\t// Start with last (possibly overlapping) block.\n+\t\tmval = _mm_loadu_si128((void*)((char*)p + size - 64));\n+\t\tmval2 = _mm_loadu_si128((void*)((char*)p + size - 48));\n+\t\tmval3 = _mm_loadu_si128((void*)((char*)p + size - 32));\n+\t\tmval4 = _mm_loadu_si128((void*)((char*)p + size - 16));\n+\n+\t\t// Scramble state once.\n+\t\tmval = _mm_aesenc_si128(mval, mseed);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mseed2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mseed3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mseed4);\n+\n+\t\t// Compute number of remaining 64-byte blocks.\n+\t\tsize--;\n+\t\tsize >>= 6;\n+\t\tdo {\n+\t\t\t// Scramble state, XOR in a block.\n+\t\t\tmval = _mm_aesenc_si128(mval, _mm_loadu_si128(p));\n+\t\t\tmval2 = _mm_aesenc_si128(mval2, _mm_loadu_si128((void*)((char*)p + 16)));\n+\t\t\tmval3 = _mm_aesenc_si128(mval3, _mm_loadu_si128((void*)((char*)p + 32)));\n+\t\t\tmval4 = _mm_aesenc_si128(mval4, _mm_loadu_si128((void*)((char*)p + 48)));\n+\n+\t\t\t// Scramble state.\n+\t\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\t\tp = (void*)((char*)p + 64);\n+\t\t} while (--size > 0);\n+\n+\t\t// 2 more scrambles to finish.\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval = _mm_aesenc_si128(mval, mval);\n+\t\tmval2 = _mm_aesenc_si128(mval2, mval2);\n+\t\tmval3 = _mm_aesenc_si128(mval3, mval3);\n+\t\tmval4 = _mm_aesenc_si128(mval4, mval4);\n+\n+\t\tmval ^= mval3;\n+\t\tmval2 ^= mval4;\n+\t\tmval ^= mval2;\n+\t\treturn _mm_cvtsi128_si32(mval);\n+\t}\n+}\n+\n+#endif // !defined(__x86_64__)\n+\n+#else // !defined(__i386__) && !defined(__x86_64__)\n+\n+uintptr aeshashbody(void* p, uintptr seed, uintptr size, Slice aeskeysched) {\n+\t// We should never get here on a non-x86 system.\n+\truntime_throw(\"impossible call to aeshashbody\");\n+}\n+\n+#endif // !defined(__i386__) && !defined(__x86_64__)"}, {"sha": "c62ad93c185220e8d5298d4ab3693d83667f541d", "filename": "libgo/runtime/go-libmain.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-libmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-libmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-libmain.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -61,6 +61,7 @@ initfn (int argc, char **argv, char** env __attribute__ ((unused)))\n \n   runtime_isarchive = true;\n \n+  runtime_cpuinit ();\n   runtime_initsig(true);\n \n   a = (struct args *) malloc (sizeof *a);"}, {"sha": "622a77d96af8e80f2531ee41e6ac1c09e5929060", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -47,6 +47,7 @@ main (int argc, char **argv)\n   runtime_isstarted = true;\n \n   __go_end = (uintptr)_end;\n+  runtime_cpuinit ();\n   runtime_check ();\n   runtime_args (argc, (byte **) argv);\n   runtime_osinit ();"}, {"sha": "842fa249bd0c482b47949d31bc4d5045c2c11d26", "filename": "libgo/runtime/go-type-identity.c", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-type-identity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-type-identity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-identity.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -9,44 +9,14 @@\n #include \"runtime.h\"\n #include \"go-type.h\"\n \n-/* An identity hash function for a type.  This is used for types where\n-   we can simply use the type value itself as a hash code.  This is\n-   true of, e.g., integers and pointers.  */\n+/* The hash functions for types that can compare as identity is\n+   written in Go.  */\n \n-uintptr_t\n-__go_type_hash_identity (const void *key, uintptr_t seed, uintptr_t key_size)\n-{\n-  uintptr_t ret;\n-  uintptr_t i;\n-  const unsigned char *p;\n-\n-  if (key_size <= 8)\n-    {\n-      union\n-      {\n-\tuint64 v;\n-\tunsigned char a[8];\n-      } u;\n-      u.v = 0;\n-#ifdef WORDS_BIGENDIAN\n-      __builtin_memcpy (&u.a[8 - key_size], key, key_size);\n-#else\n-      __builtin_memcpy (&u.a[0], key, key_size);\n-#endif\n-      if (sizeof (uintptr_t) >= 8)\n-\treturn (uintptr_t) u.v ^ seed;\n-      else\n-\treturn (uintptr_t) ((u.v >> 32) ^ (u.v & 0xffffffff)) ^ seed;\n-    }\n-\n-  ret = seed;\n-  for (i = 0, p = (const unsigned char *) key; i < key_size; i++, p++)\n-    ret = ret * 33 + *p;\n-  return ret;\n-}\n+extern uintptr runtime_memhash(void *, uintptr, uintptr)\n+  __asm__ (GOSYM_PREFIX \"runtime.memhash\");\n \n const FuncVal __go_type_hash_identity_descriptor =\n-  { (void *) __go_type_hash_identity };\n+  { (void *) runtime_memhash };\n \n /* An identity equality function for a type.  This is used for types\n    where we can check for equality by checking that the values have"}, {"sha": "2d5965c64d3eaf9fe6230ea12c88b8c153ec1c51", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -362,7 +362,6 @@ extern _Bool\n __go_type_descriptors_equal(const struct __go_type_descriptor*,\n \t\t\t    const struct __go_type_descriptor*);\n \n-extern uintptr_t __go_type_hash_identity (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_identity_descriptor;\n extern _Bool __go_type_equal_identity (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_identity_descriptor;"}, {"sha": "be7e083f080be6c4b1c06f3bde8c663a492497dd", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -455,7 +455,8 @@ runtime_schedinit(void)\n \t// runtime_symtabinit();\n \truntime_mallocinit();\n \tmcommoninit(m);\n-\t\n+\truntime_alginit(); // maps must not be used before this call\n+\n \t// Initialize the itable value for newErrorCString,\n \t// so that the next time it gets called, possibly\n \t// in a fault during a garbage collection, it will not"}, {"sha": "424b429b0516ea568344874cea4106c169553e74", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -265,6 +265,8 @@ struct __go_func_type;\n void\truntime_args(int32, byte**)\n   __asm__ (GOSYM_PREFIX \"runtime.args\");\n void\truntime_osinit();\n+void\truntime_alginit(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.alginit\");\n void\truntime_goargs(void)\n   __asm__ (GOSYM_PREFIX \"runtime.goargs\");\n void\truntime_goenvs(void);\n@@ -592,3 +594,7 @@ extern void *getitab(const struct __go_type_descriptor *,\n \t\t     const struct __go_type_descriptor *,\n \t\t     _Bool)\n   __asm__ (GOSYM_PREFIX \"runtime.getitab\");\n+\n+extern void runtime_cpuinit(void);\n+extern void setCpuidECX(uint32)\n+  __asm__ (GOSYM_PREFIX \"runtime.setCpuidECX\");"}, {"sha": "3387401b427c3419a814ce1ddf0d88704677e75f", "filename": "libgo/runtime/runtime_c.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fruntime_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/453060a9062959ceb1522b8b99adeb01b2a3f7b7/libgo%2Fruntime%2Fruntime_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime_c.c?ref=453060a9062959ceb1522b8b99adeb01b2a3f7b7", "patch": "@@ -6,6 +6,10 @@\n #include <signal.h>\n #include <unistd.h>\n \n+#if defined(__i386__) || defined(__x86_64__)\n+#include <cpuid.h>\n+#endif\n+\n #include \"config.h\"\n \n #include \"runtime.h\"\n@@ -204,3 +208,18 @@ go_errno()\n {\n   return (intgo)errno;\n }\n+\n+// CPU-specific initialization.\n+// Fetch CPUID info on x86.\n+\n+void\n+runtime_cpuinit()\n+{\n+#if defined(__i386__) || defined(__x86_64__)\n+\tunsigned int eax, ebx, ecx, edx;\n+\n+\tif (__get_cpuid(1, &eax, &ebx, &ecx, &edx)) {\n+\t\tsetCpuidECX(ecx);\n+\t}\n+#endif\n+}"}]}