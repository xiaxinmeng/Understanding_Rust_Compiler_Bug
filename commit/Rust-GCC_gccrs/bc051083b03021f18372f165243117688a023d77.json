{"sha": "bc051083b03021f18372f165243117688a023d77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwNTEwODNiMDMwMjFmMTgzNzJmMTY1MjQzMTE3Njg4YTAyM2Q3Nw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-06-23T19:02:42Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-06-23T19:02:42Z"}, "message": "i386 (mov<mode>): Macroize expander from mov{sf,df,xf} using X87MODEF mode iterator.\n\n\t* config/i386/i386 (mov<mode>): Macroize expander from mov{sf,df,xf}\n\tusing X87MODEF mode iterator.\n\t(pushsf splitter): Macroize splitter using P mode iterator.\n\t(*swap<mode>): Macroize insn from *swap{sf,df} using MODEF\n\tmode iterator.\n\n\t(*movxf_internal): Rename from *movxf_integer.\n\t(*movxf_internal_nointeger): Rename from *movxf_nointeger.\n\t(*movdf_internal_rex64): Rename from *movdf_integer_rex64.\n\t(*movdf_internal): Rename from *movdf_integer.\n\t(*movdf_internal_nointeger): Rename from *movdf_nointeger.\n\t(*movsf_internal): Rename from *movdf_1.\n\nFrom-SVN: r161287", "tree": {"sha": "81b49809fefb1b97879b14b0ed1561873c130344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b49809fefb1b97879b14b0ed1561873c130344"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc051083b03021f18372f165243117688a023d77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc051083b03021f18372f165243117688a023d77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc051083b03021f18372f165243117688a023d77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc051083b03021f18372f165243117688a023d77/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cde8534c846585f7035055f964243ff397c51355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde8534c846585f7035055f964243ff397c51355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde8534c846585f7035055f964243ff397c51355"}], "stats": {"total": 943, "additions": 461, "deletions": 482}, "files": [{"sha": "59ccdfb4ad0447b136f44cc761a3fdc32c63e521", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc051083b03021f18372f165243117688a023d77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc051083b03021f18372f165243117688a023d77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc051083b03021f18372f165243117688a023d77", "patch": "@@ -1,3 +1,18 @@\n+2010-06-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386 (mov<mode>): Macroize expander from mov{sf,df,xf}\n+\tusing X87MODEF mode iterator.\n+\t(pushsf splitter): Macroize splitter using P mode iterator.\n+\t(*swap<mode>): Macroize insn from *swap{sf,df} using MODEF\n+\tmode iterator.\n+\n+\t(*movxf_internal): Rename from *movxf_integer.\n+\t(*movxf_internal_nointeger): Rename from *movxf_nointeger.\n+\t(*movdf_internal_rex64): Rename from *movdf_integer_rex64.\n+\t(*movdf_internal): Rename from *movdf_integer.\n+\t(*movdf_internal_nointeger): Rename from *movdf_nointeger.\n+\t(*movsf_internal): Rename from *movdf_1.\n+\n 2010-06-23  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* coretypes.h: (gimple_seq_node_d, gimple_seq_node)\n@@ -104,7 +119,7 @@\n \t(SWI48x): Ditto.\n \t(SWI12): Ditto.\n \t(SWI24): Ditto.\n-\t\n+\n \t(mov<mode>): Macroize expander from mov{qi,hi,si,di} using\n \tSWI1248x mode iterator.\n \t(*push<mode>2_rex64): Macroize insn from *push{qi,hi,si}_rex64"}, {"sha": "1f7369b59647882327a897fe488621cf6a1463d0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 445, "deletions": 481, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc051083b03021f18372f165243117688a023d77/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc051083b03021f18372f165243117688a023d77/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bc051083b03021f18372f165243117688a023d77", "patch": "@@ -2604,24 +2604,140 @@\n \f\n ;; Floating point move instructions.\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:TF 1 \"nonimmediate_operand\" \"\"))]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_move (TFmode, operands);\n+  DONE;\n+})\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:X87MODEF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:X87MODEF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"ix86_expand_move (SFmode, operands); DONE;\")\n+  \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n-(define_insn \"*pushsf\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rFm,x\"))]\n-  \"!TARGET_64BIT\"\n+(define_insn \"*pushtf\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:TF 1 \"general_no_elim_operand\" \"x,Fo,*r\"))]\n+  \"TARGET_SSE2\"\n {\n-  /* Anything else should be already split before reg-stack.  */\n-  gcc_assert (which_alternative == 1);\n-  return \"push{l}\\t%1\";\n+  /* This insn should be already split before reg-stack.  */\n+  gcc_unreachable ();\n }\n-  [(set_attr \"type\" \"multi,push,multi\")\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"unit\" \"sse,*,*\")\n+   (set_attr \"mode\" \"TF,SI,SI\")])\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"TARGET_SSE2 && reload_completed\n+   && !SSE_REG_P (operands[1])\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n+\n+(define_split\n+  [(set (match_operand:TF 0 \"push_operand\" \"\")\n+\t(match_operand:TF 1 \"any_fp_register_operand\" \"\"))]\n+  \"TARGET_SSE2\"\n+  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (const_int -16)))\n+   (set (mem:TF (reg:P SP_REG)) (match_dup 1))]\n+  \"\")\n+\n+(define_insn \"*pushxf\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,ro\"))]\n+  \"optimize_function_for_speed_p (cfun)\"\n+{\n+  /* This insn should be already split before reg-stack.  */\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"unit\" \"i387,*\")\n+   (set_attr \"mode\" \"XF,SI\")])\n+\n+;; Size of pushxf is 3 (for sub) + 2 (for fstp) + memory operand size.\n+;; Size of pushxf using integer instructions is 3+3*memory operand size\n+;; Pushing using integer instructions is longer except for constants\n+;; and direct memory references (assuming that any given constant is pushed\n+;; only once, but this ought to be handled elsewhere).\n+\n+(define_insn \"*pushxf_nointeger\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=X,X,X\")\n+\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,Fo,*r\"))]\n+  \"optimize_function_for_size_p (cfun)\"\n+{\n+  /* This insn should be already split before reg-stack.  */\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"unit\" \"i387,*,*\")\n-   (set_attr \"mode\" \"SF,SI,SF\")])\n+   (set_attr \"mode\" \"XF,SI,SI\")])\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"push_operand\" \"\")\n+\t(match_operand:XF 1 \"any_fp_register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (match_dup 2)))\n+   (set (mem:XF (reg:P SP_REG)) (match_dup 1))]\n+  \"operands[2] = GEN_INT (TARGET_128BIT_LONG_DOUBLE ? -16 : -12);\")\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"push_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && !ANY_FP_REG_P (operands[1])\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n+\n+(define_insn \"*pushdf\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,rFo,Y2\"))]\n+  \"TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES\"\n+{\n+  /* This insn should be already split before reg-stack.  */\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"unit\" \"i387,*,*\")\n+   (set_attr \"mode\" \"DF,SI,DF\")])\n+\n+;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n+;; Size of pushdf using integer instructions is 2+2*memory operand size\n+;; On the average, pushdf using integers can be still shorter.  Allow this\n+;; pattern for optimize_size too.\n+\n+(define_insn \"*pushdf_nointeger\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo,*r,Y2\"))]\n+  \"!(TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES)\"\n+{\n+  /* This insn should be already split before reg-stack.  */\n+  gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"unit\" \"i387,*,*,*\")\n+   (set_attr \"mode\" \"DF,SI,SI,DF\")])\n+\n+;; %%% Kill this when call knows how to work this out.\n+(define_split\n+  [(set (match_operand:DF 0 \"push_operand\" \"\")\n+\t(match_operand:DF 1 \"any_fp_register_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (const_int -8)))\n+   (set (mem:DF (reg:P SP_REG)) (match_dup 1))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"push_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && !ANY_FP_REG_P (operands[1])\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*pushsf_rex64\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n@@ -2636,6 +2752,19 @@\n    (set_attr \"unit\" \"i387,*,*\")\n    (set_attr \"mode\" \"SF,DI,SF\")])\n \n+(define_insn \"*pushsf\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rFm,x\"))]\n+  \"!TARGET_64BIT\"\n+{\n+  /* Anything else should be already split before reg-stack.  */\n+  gcc_assert (which_alternative == 1);\n+  return \"push{l}\\t%1\";\n+}\n+  [(set_attr \"type\" \"multi,push,multi\")\n+   (set_attr \"unit\" \"i387,*,*\")\n+   (set_attr \"mode\" \"SF,SI,SF\")])\n+\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"memory_operand\" \"\"))]\n@@ -2649,202 +2778,148 @@\n (define_split\n   [(set (match_operand:SF 0 \"push_operand\" \"\")\n \t(match_operand:SF 1 \"any_fp_register_operand\" \"\"))]\n-  \"!TARGET_64BIT\"\n-  [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -4)))\n-   (set (mem:SF (reg:SI SP_REG)) (match_dup 1))])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"push_operand\" \"\")\n-\t(match_operand:SF 1 \"any_fp_register_operand\" \"\"))]\n-  \"TARGET_64BIT\"\n-  [(set (reg:DI SP_REG) (plus:DI (reg:DI SP_REG) (const_int -8)))\n-   (set (mem:SF (reg:DI SP_REG)) (match_dup 1))])\n+  \"reload_completed\"\n+  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (match_dup 2)))\n+   (set (mem:SF (reg:P SP_REG)) (match_dup 1))]\n+  \"operands[2] = GEN_INT (-GET_MODE_SIZE (<MODE>mode));\")\n \n-(define_insn \"*movsf_1\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t  \"=f,m,f,r  ,m ,x,x,x ,m,!*y,!m,!*y,?Yi,?r,!*Ym,!r\")\n-\t(match_operand:SF 1 \"general_operand\"\n-\t  \"fm,f,G,rmF,Fr,C,x,xm,x,m  ,*y,*y ,r  ,Yi,r   ,*Ym\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (reload_in_progress || reload_completed\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || (!TARGET_SSE_MATH && optimize_function_for_size_p (cfun)\n-\t   && standard_80387_constant_p (operands[1]))\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], SFmode))\"\n+(define_insn \"*movtf_internal\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,m,x,?r,?o\")\n+\t(match_operand:TF 1 \"general_operand\" \"xm,x,C,roF,Fr\"))]\n+  \"TARGET_SSE2\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (which_alternative)\n     {\n     case 0:\n     case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-      return \"mov{l}\\t{%1, %0|%0, %1}\";\n-    case 5:\n-      if (get_attr_mode (insn) == MODE_TI)\n-\treturn \"%vpxor\\t%0, %d0\";\n-      else\n-\treturn \"%vxorps\\t%0, %d0\";\n-    case 6:\n       if (get_attr_mode (insn) == MODE_V4SF)\n \treturn \"%vmovaps\\t{%1, %0|%0, %1}\";\n       else\n-\treturn \"%vmovss\\t{%1, %d0|%d0, %1}\";\n-    case 7:\n-      if (TARGET_AVX)\n-\treturn REG_P (operands[1]) ? \"vmovss\\t{%1, %0, %0|%0, %0, %1}\"\n-\t\t\t\t   : \"vmovss\\t{%1, %0|%0, %1}\";\n+\treturn \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"%vxorps\\t%0, %d0\";\n       else\n-\treturn \"movss\\t{%1, %0|%0, %1}\";\n-    case 8:\n-      return \"%vmovss\\t{%1, %0|%0, %1}\";\n-\n-    case 9: case 10: case 14: case 15:\n-      return \"movd\\t{%1, %0|%0, %1}\";\n-    case 12: case 13:\n-      return \"%vmovd\\t{%1, %0|%0, %1}\";\n-\n-    case 11:\n-      return \"movq\\t{%1, %0|%0, %1}\";\n-\n+\treturn \"%vpxor\\t%0, %d0\";\n+    case 3:\n+    case 4:\n+\treturn \"#\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sselog1,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov,ssemov,ssemov,mmxmov,mmxmov\")\n-   (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"5,6,7,8,12,13\")\n-       (const_string \"maybe_vex\")\n-       (const_string \"orig\")))\n+  [(set_attr \"type\" \"ssemov,ssemov,sselog1,*,*\")\n+   (set_attr \"prefix\" \"maybe_vex,maybe_vex,maybe_vex,*,*\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"3,4,9,10\")\n-\t\t (const_string \"SI\")\n-\t       (eq_attr \"alternative\" \"5\")\n+        (cond [(eq_attr \"alternative\" \"0,2\")\n \t\t (if_then_else\n-\t\t   (and (and (ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n-\t\t\t    \t (const_int 0))\n-\t\t\t     (ne (symbol_ref \"TARGET_SSE2\")\n-\t\t\t\t (const_int 0)))\n-\t\t\t(eq (symbol_ref \"optimize_function_for_size_p (cfun)\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_string \"TI\")\n-\t\t   (const_string \"V4SF\"))\n-\t       /* For architectures resolving dependencies on\n-\t\t  whole SSE registers use APS move to break dependency\n-\t\t  chains, otherwise use short move to avoid extra work.\n-\n-\t\t  Do the same for architectures resolving dependencies on\n-\t\t  the parts.  While in DF mode it is better to always handle\n-\t\t  just register parts, the SF mode is different due to lack\n-\t\t  of instructions to load just part of the register.  It is\n-\t\t  better to maintain the whole registers in single format\n-\t\t  to avoid problems on using packed logical operations.  */\n-\t       (eq_attr \"alternative\" \"6\")\n+\t\t   (ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n+\t\t       (const_int 0))\n+\t\t   (const_string \"V4SF\")\n+\t\t   (const_string \"TI\"))\n+\t       (eq_attr \"alternative\" \"1\")\n \t\t (if_then_else\n-\t\t   (ior (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n+\t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n \t\t\t    (const_int 0))\n-\t\t\t(ne (symbol_ref \"TARGET_SSE_SPLIT_REGS\")\n+\t\t\t(ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n \t\t\t    (const_int 0)))\n \t\t   (const_string \"V4SF\")\n-\t\t   (const_string \"SF\"))\n-\t       (eq_attr \"alternative\" \"11\")\n-\t\t (const_string \"DI\")]\n-\t       (const_string \"SF\")))])\n+\t\t   (const_string \"TI\"))]\n+\t       (const_string \"DI\")))])\n \n-(define_insn \"*swapsf\"\n-  [(set (match_operand:SF 0 \"fp_register_operand\" \"+f\")\n-\t(match_operand:SF 1 \"fp_register_operand\" \"+f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"reload_completed || TARGET_80387\"\n+(define_split\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && !(SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]))\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n+\n+(define_insn \"*movxf_internal\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,r,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,roF,Fr\"))]\n+  \"optimize_function_for_speed_p (cfun)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && (reload_in_progress || reload_completed\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], XFmode))\"\n {\n-  if (STACK_TOP_P (operands[0]))\n-    return \"fxch\\t%1\";\n-  else\n-    return \"fxch\\t%0\";\n-}\n-  [(set_attr \"type\" \"fxch\")\n-   (set_attr \"mode\" \"SF\")])\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return output_387_reg_move (insn, operands);\n \n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"ix86_expand_move (DFmode, operands); DONE;\")\n+    case 2:\n+      return standard_80387_constant_opcode (operands[1]);\n \n-;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer instructions is 2+2*memory operand size\n-;; On the average, pushdf using integers can be still shorter.  Allow this\n-;; pattern for optimize_size too.\n+    case 3: case 4:\n+      return \"#\";\n \n-(define_insn \"*pushdf_nointeger\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Fo,*r,Y2\"))]\n-  \"!TARGET_64BIT && !TARGET_INTEGER_DFMODE_MOVES\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*,*\")\n-   (set_attr \"mode\" \"DF,SI,SI,DF\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n+   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n \n-(define_insn \"*pushdf_integer\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,rFo,Y2\"))]\n-  \"TARGET_64BIT || TARGET_INTEGER_DFMODE_MOVES\"\n+;; Do not use integer registers when optimizing for size\n+(define_insn \"*movxf_internal_nointeger\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n+  \"optimize_function_for_size_p (cfun)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && (reload_in_progress || reload_completed\n+       || standard_80387_constant_p (operands[1])\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], XFmode))\"\n {\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*\")\n-   (set_attr \"mode\" \"DF,SI,DF\")])\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return output_387_reg_move (insn, operands);\n \n-;; %%% Kill this when call knows how to work this out.\n-(define_split\n-  [(set (match_operand:DF 0 \"push_operand\" \"\")\n-\t(match_operand:DF 1 \"any_fp_register_operand\" \"\"))]\n-  \"reload_completed\"\n-  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (const_int -8)))\n-   (set (mem:DF (reg:P SP_REG)) (match_dup 1))]\n-  \"\")\n+    case 2:\n+      return standard_80387_constant_opcode (operands[1]);\n+\n+    case 3: case 4:\n+      return \"#\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n+   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n \n (define_split\n-  [(set (match_operand:DF 0 \"push_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"reload_completed\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:XF 1 \"general_operand\" \"\"))]\n+  \"reload_completed\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ! (ANY_FP_REG_P (operands[0]) ||\n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n+   && ! (ANY_FP_REG_P (operands[1]) ||\n+\t (GET_CODE (operands[1]) == SUBREG\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n-;; Moving is usually shorter when only FP registers are used. This separate\n-;; movdf pattern avoids the use of integer registers for FP operations\n-;; when optimizing for size.\n-\n-(define_insn \"*movdf_nointeger\"\n+(define_insn \"*movdf_internal_rex64\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\t\"=f,m,f,*r  ,o  ,Y2*x,Y2*x,Y2*x ,m  \")\n+\t\t\"=f,m,f,r  ,m ,Y2*x,Y2*x,Y2*x,m   ,Yi,r \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\t\"fm,f,G,*roF,*Fr,C   ,Y2*x,mY2*x,Y2*x\"))]\n-  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && ((optimize_function_for_size_p (cfun)\n-       || !TARGET_INTEGER_DFMODE_MOVES) && !TARGET_64BIT)\n+\t\t\"fm,f,G,rmF,Fr,C   ,Y2*x,m   ,Y2*x,r ,Yi\"))]\n+  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n            && optimize_function_for_size_p (cfun)\n-           && !memory_operand (operands[0], DFmode)\n \t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || ((optimize_function_for_size_p (cfun)\n-            || !TARGET_MEMORY_MISMATCH_STALL\n-\t    || reload_in_progress || reload_completed)\n- \t   && memory_operand (operands[0], DFmode)))\"\n+       || memory_operand (operands[0], DFmode))\"\n {\n   switch (which_alternative)\n     {\n@@ -2858,6 +2933,7 @@\n     case 3:\n     case 4:\n       return \"#\";\n+\n     case 5:\n       switch (get_attr_mode (insn))\n \t{\n@@ -2906,34 +2982,22 @@\n \t  else\n \t    return \"movsd\\t{%1, %0|%0, %1}\";\n \tcase MODE_V1DF:\n-\t  if (TARGET_AVX)\n-\t    {\n-\t      if (REG_P (operands[0]))\n-\t\treturn \"vmovlpd\\t{%1, %0, %0|%0, %0, %1}\";\n-\t      else\n-\t\treturn \"vmovlpd\\t{%1, %0|%0, %1}\";\n-\t    }\n-\t  else\n-\t    return \"movlpd\\t{%1, %0|%0, %1}\";\n+\t  return \"%vmovlpd\\t{%1, %d0|%d0, %1}\";\n \tcase MODE_V2SF:\n-\t  if (TARGET_AVX)\n-\t    {\n-\t      if (REG_P (operands[0]))\n-\t\treturn \"vmovlps\\t{%1, %0, %0|%0, %0, %1}\";\n-\t      else\n-\t\treturn \"vmovlps\\t{%1, %0|%0, %1}\";\n-\t    }\n-\t  else\n-\t    return \"movlps\\t{%1, %0|%0, %1}\";\n+\t  return \"%vmovlps\\t{%1, %d0|%d0, %1}\";\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n+    case 9:\n+    case 10:\n+    return \"%vmovd\\t{%1, %0|%0, %1}\";\n+\n     default:\n-      gcc_unreachable ();\n+      gcc_unreachable();\n     }\n }\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov\")\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov,ssemov,ssemov\")\n    (set (attr \"prefix\")\n      (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4\")\n        (const_string \"orig\")\n@@ -2945,8 +3009,8 @@\n    (set (attr \"mode\")\n         (cond [(eq_attr \"alternative\" \"0,1,2\")\n \t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4\")\n-\t\t (const_string \"SI\")\n+\t       (eq_attr \"alternative\" \"3,4,9,10\")\n+\t\t (const_string \"DI\")\n \n \t       /* For SSE1, we have many fewer alternatives.  */\n \t       (eq (symbol_ref \"TARGET_SSE2\") (const_int 0))\n@@ -2993,12 +3057,14 @@\n \t      ]\n \t      (const_string \"DF\")))])\n \n-(define_insn \"*movdf_integer_rex64\"\n+(define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=f,m,f,r  ,m ,Y2*x,Y2*x,Y2*x,m   ,Yi,r \")\n+\t\t\"=f,m,f,r  ,o ,Y2*x,Y2*x,Y2*x,m   \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"fm,f,G,rmF,Fr,C   ,Y2*x,m   ,Y2*x,r ,Yi\"))]\n-  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+\t\t\"fm,f,G,roF,Fr,C   ,Y2*x,m   ,Y2*x\"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && optimize_function_for_speed_p (cfun)\n+   && TARGET_INTEGER_DFMODE_MOVES\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n@@ -3024,17 +3090,17 @@\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V4SF:\n-\t  return \"%vxorps\\t%0, %d0\";\n+\t  return \"xorps\\t%0, %0\";\n \tcase MODE_V2DF:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n+\t    return \"xorps\\t%0, %0\";\n \t  else\n-\t    return \"%vxorpd\\t%0, %d0\";\n+\t    return \"xorpd\\t%0, %0\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vxorps\\t%0, %d0\";\n+\t    return \"xorps\\t%0, %0\";\n \t  else\n-\t    return \"%vpxor\\t%0, %d0\";\n+\t    return \"pxor\\t%0, %0\";\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -3044,59 +3110,43 @@\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V4SF:\n-\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\t  return \"movaps\\t{%1, %0|%0, %1}\";\n \tcase MODE_V2DF:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\t    return \"movaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"%vmovapd\\t{%1, %0|%0, %1}\";\n+\t    return \"movapd\\t{%1, %0|%0, %1}\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\t    return \"movaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\t    return \"movdqa\\t{%1, %0|%0, %1}\";\n \tcase MODE_DI:\n-\t  return \"%vmovq\\t{%1, %0|%0, %1}\";\n+\t  return \"movq\\t{%1, %0|%0, %1}\";\n \tcase MODE_DF:\n-\t  if (TARGET_AVX)\n-\t    {\n-\t      if (REG_P (operands[0]) && REG_P (operands[1]))\n-\t\treturn \"vmovsd\\t{%1, %0, %0|%0, %0, %1}\";\n-\t      else\n-\t\treturn \"vmovsd\\t{%1, %0|%0, %1}\";\n-\t    }\n-\t  else\n-\t    return \"movsd\\t{%1, %0|%0, %1}\";\n+\t  return \"movsd\\t{%1, %0|%0, %1}\";\n \tcase MODE_V1DF:\n-\t  return \"%vmovlpd\\t{%1, %d0|%d0, %1}\";\n+\t  return \"movlpd\\t{%1, %0|%0, %1}\";\n \tcase MODE_V2SF:\n-\t  return \"%vmovlps\\t{%1, %d0|%d0, %1}\";\n+\t  return \"movlps\\t{%1, %0|%0, %1}\";\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-    case 9:\n-    case 10:\n-    return \"%vmovd\\t{%1, %0|%0, %1}\";\n-\n     default:\n       gcc_unreachable();\n     }\n }\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov,ssemov,ssemov\")\n-   (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4\")\n-       (const_string \"orig\")\n-       (const_string \"maybe_vex\")))\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov\")\n    (set (attr \"prefix_data16\")\n      (if_then_else (eq_attr \"mode\" \"V1DF\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"mode\")\n         (cond [(eq_attr \"alternative\" \"0,1,2\")\n \t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4,9,10\")\n-\t\t (const_string \"DI\")\n+\t       (eq_attr \"alternative\" \"3,4\")\n+\t\t (const_string \"SI\")\n \n \t       /* For SSE1, we have many fewer alternatives.  */\n \t       (eq (symbol_ref \"TARGET_SSE2\") (const_int 0))\n@@ -3143,21 +3193,29 @@\n \t      ]\n \t      (const_string \"DF\")))])\n \n-(define_insn \"*movdf_integer\"\n+;; Moving is usually shorter when only FP registers are used. This separate\n+;; movdf pattern avoids the use of integer registers for FP operations\n+;; when optimizing for size.\n+\n+(define_insn \"*movdf_internal_nointeger\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=f,m,f,r  ,o ,Y2*x,Y2*x,Y2*x,m   \")\n+\t\t\t\"=f,m,f,*r  ,o  ,Y2*x,Y2*x,Y2*x ,m  \")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"fm,f,G,roF,Fr,C   ,Y2*x,m   ,Y2*x\"))]\n+\t\t\t\"fm,f,G,*roF,*Fr,C   ,Y2*x,mY2*x,Y2*x\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && optimize_function_for_speed_p (cfun)\n-   && TARGET_INTEGER_DFMODE_MOVES\n+   && ((optimize_function_for_size_p (cfun)\n+       || !TARGET_INTEGER_DFMODE_MOVES) && !TARGET_64BIT)\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || (!(TARGET_SSE2 && TARGET_SSE_MATH)\n            && optimize_function_for_size_p (cfun)\n+           && !memory_operand (operands[0], DFmode)\n \t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], DFmode))\"\n+       || ((optimize_function_for_size_p (cfun)\n+            || !TARGET_MEMORY_MISMATCH_STALL\n+\t    || reload_in_progress || reload_completed)\n+ \t   && memory_operand (operands[0], DFmode)))\"\n {\n   switch (which_alternative)\n     {\n@@ -3171,22 +3229,21 @@\n     case 3:\n     case 4:\n       return \"#\";\n-\n     case 5:\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V4SF:\n-\t  return \"xorps\\t%0, %0\";\n+\t  return \"%vxorps\\t%0, %d0\";\n \tcase MODE_V2DF:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"xorps\\t%0, %0\";\n+\t    return \"%vxorps\\t%0, %d0\";\n \t  else\n-\t    return \"xorpd\\t%0, %0\";\n+\t    return \"%vxorpd\\t%0, %d0\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"xorps\\t%0, %0\";\n+\t    return \"%vxorps\\t%0, %d0\";\n \t  else\n-\t    return \"pxor\\t%0, %0\";\n+\t    return \"%vpxor\\t%0, %d0\";\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -3196,34 +3253,62 @@\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V4SF:\n-\t  return \"movaps\\t{%1, %0|%0, %1}\";\n+\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \tcase MODE_V2DF:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"movaps\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"movapd\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovapd\\t{%1, %0|%0, %1}\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n-\t    return \"movaps\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \t  else\n-\t    return \"movdqa\\t{%1, %0|%0, %1}\";\n+\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \tcase MODE_DI:\n-\t  return \"movq\\t{%1, %0|%0, %1}\";\n+\t  return \"%vmovq\\t{%1, %0|%0, %1}\";\n \tcase MODE_DF:\n-\t  return \"movsd\\t{%1, %0|%0, %1}\";\n+\t  if (TARGET_AVX)\n+\t    {\n+\t      if (REG_P (operands[0]) && REG_P (operands[1]))\n+\t\treturn \"vmovsd\\t{%1, %0, %0|%0, %0, %1}\";\n+\t      else\n+\t\treturn \"vmovsd\\t{%1, %0|%0, %1}\";\n+\t    }\n+\t  else\n+\t    return \"movsd\\t{%1, %0|%0, %1}\";\n \tcase MODE_V1DF:\n-\t  return \"movlpd\\t{%1, %0|%0, %1}\";\n+\t  if (TARGET_AVX)\n+\t    {\n+\t      if (REG_P (operands[0]))\n+\t\treturn \"vmovlpd\\t{%1, %0, %0|%0, %0, %1}\";\n+\t      else\n+\t\treturn \"vmovlpd\\t{%1, %0|%0, %1}\";\n+\t    }\n+\t  else\n+\t    return \"movlpd\\t{%1, %0|%0, %1}\";\n \tcase MODE_V2SF:\n-\t  return \"movlps\\t{%1, %0|%0, %1}\";\n+\t  if (TARGET_AVX)\n+\t    {\n+\t      if (REG_P (operands[0]))\n+\t\treturn \"vmovlps\\t{%1, %0, %0|%0, %0, %1}\";\n+\t      else\n+\t\treturn \"vmovlps\\t{%1, %0|%0, %1}\";\n+\t    }\n+\t  else\n+\t    return \"movlps\\t{%1, %0|%0, %1}\";\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n     default:\n-      gcc_unreachable();\n+      gcc_unreachable ();\n     }\n }\n   [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi,sselog1,ssemov,ssemov,ssemov\")\n+   (set (attr \"prefix\")\n+     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4\")\n+       (const_string \"orig\")\n+       (const_string \"maybe_vex\")))\n    (set (attr \"prefix_data16\")\n      (if_then_else (eq_attr \"mode\" \"V1DF\")\n        (const_string \"1\")\n@@ -3277,129 +3362,34 @@\n \t\t   (const_string \"V1DF\")\n \t\t   (const_string \"DF\"))\n \t      ]\n-\t      (const_string \"DF\")))])\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"reload_completed\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && ! (ANY_FP_REG_P (operands[0]) ||\n-\t (GET_CODE (operands[0]) == SUBREG\n-\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n-   && ! (ANY_FP_REG_P (operands[1]) ||\n-\t (GET_CODE (operands[1]) == SUBREG\n-\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n-  [(const_int 0)]\n-  \"ix86_split_long_move (operands); DONE;\")\n-\n-(define_insn \"*swapdf\"\n-  [(set (match_operand:DF 0 \"fp_register_operand\" \"+f\")\n-\t(match_operand:DF 1 \"fp_register_operand\" \"+f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"reload_completed || TARGET_80387\"\n-{\n-  if (STACK_TOP_P (operands[0]))\n-    return \"fxch\\t%1\";\n-  else\n-    return \"fxch\\t%0\";\n-}\n-  [(set_attr \"type\" \"fxch\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_expand \"movxf\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:XF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"ix86_expand_move (XFmode, operands); DONE;\")\n-\n-;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer instructions is 3+3*memory operand size\n-;; Pushing using integer instructions is longer except for constants\n-;; and direct memory references.\n-;; (assuming that any given constant is pushed only once, but this ought to be\n-;;  handled elsewhere).\n-\n-(define_insn \"*pushxf_nointeger\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=X,X,X\")\n-\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,Fo,*r\"))]\n-  \"optimize_function_for_size_p (cfun)\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*\")\n-   (set_attr \"mode\" \"XF,SI,SI\")])\n-\n-(define_insn \"*pushxf_integer\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,ro\"))]\n-  \"optimize_function_for_speed_p (cfun)\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*\")\n-   (set_attr \"mode\" \"XF,SI\")])\n+\t      (const_string \"DF\")))])\n \n (define_split\n-  [(set (match_operand 0 \"push_operand\" \"\")\n-\t(match_operand 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"reload_completed\n-   && (GET_MODE (operands[0]) == XFmode\n-       || GET_MODE (operands[0]) == DFmode)\n-   && !ANY_FP_REG_P (operands[1])\"\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+   && ! (ANY_FP_REG_P (operands[0]) ||\n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n+   && ! (ANY_FP_REG_P (operands[1]) ||\n+\t (GET_CODE (operands[1]) == SUBREG\n+\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n-(define_split\n-  [(set (match_operand:XF 0 \"push_operand\" \"\")\n-\t(match_operand:XF 1 \"any_fp_register_operand\" \"\"))]\n-  \"\"\n-  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (match_dup 2)))\n-   (set (mem:XF (reg:P SP_REG)) (match_dup 1))]\n-  \"operands[2] = GEN_INT (TARGET_128BIT_LONG_DOUBLE ? -16 : -12);\")\n-\n-;; Do not use integer registers when optimizing for size\n-(define_insn \"*movxf_nointeger\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n-  \"optimize_function_for_size_p (cfun)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (reload_in_progress || reload_completed\n-       || standard_80387_constant_p (operands[1])\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], XFmode))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3: case 4:\n-      return \"#\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n-\n-(define_insn \"*movxf_integer\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,roF,Fr\"))]\n-  \"optimize_function_for_speed_p (cfun)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+(define_insn \"*movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n+\t  \"=f,m,f,r  ,m ,x,x,x ,m,!*y,!m,!*y,?Yi,?r,!*Ym,!r\")\n+\t(match_operand:SF 1 \"general_operand\"\n+\t  \"fm,f,G,rmF,Fr,C,x,xm,x,m  ,*y,*y ,r  ,Yi,r   ,*Ym\"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n+       || (!TARGET_SSE_MATH && optimize_function_for_size_p (cfun)\n+\t   && standard_80387_constant_p (operands[1]))\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], XFmode))\"\n+       || memory_operand (operands[0], SFmode))\"\n {\n   switch (which_alternative)\n     {\n@@ -3410,112 +3400,79 @@\n     case 2:\n       return standard_80387_constant_opcode (operands[1]);\n \n-    case 3: case 4:\n-      return \"#\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n-\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:TF 1 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_SSE2\"\n-{\n-  ix86_expand_move (TFmode, operands);\n-  DONE;\n-})\n-\n-(define_insn \"*movtf_internal\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,m,x,?r,?o\")\n-\t(match_operand:TF 1 \"general_operand\" \"xm,x,C,roF,Fr\"))]\n-  \"TARGET_SSE2\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n+    case 3:\n+    case 4:\n+      return \"mov{l}\\t{%1, %0|%0, %1}\";\n+    case 5:\n+      if (get_attr_mode (insn) == MODE_TI)\n+\treturn \"%vpxor\\t%0, %d0\";\n+      else\n+\treturn \"%vxorps\\t%0, %d0\";\n+    case 6:\n       if (get_attr_mode (insn) == MODE_V4SF)\n \treturn \"%vmovaps\\t{%1, %0|%0, %1}\";\n       else\n-\treturn \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-    case 2:\n-      if (get_attr_mode (insn) == MODE_V4SF)\n-\treturn \"%vxorps\\t%0, %d0\";\n+\treturn \"%vmovss\\t{%1, %d0|%d0, %1}\";\n+    case 7:\n+      if (TARGET_AVX)\n+\treturn REG_P (operands[1]) ? \"vmovss\\t{%1, %0, %0|%0, %0, %1}\"\n+\t\t\t\t   : \"vmovss\\t{%1, %0|%0, %1}\";\n       else\n-\treturn \"%vpxor\\t%0, %d0\";\n-    case 3:\n-    case 4:\n-\treturn \"#\";\n+\treturn \"movss\\t{%1, %0|%0, %1}\";\n+    case 8:\n+      return \"%vmovss\\t{%1, %0|%0, %1}\";\n+\n+    case 9: case 10: case 14: case 15:\n+      return \"movd\\t{%1, %0|%0, %1}\";\n+    case 12: case 13:\n+      return \"%vmovd\\t{%1, %0|%0, %1}\";\n+\n+    case 11:\n+      return \"movq\\t{%1, %0|%0, %1}\";\n+\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"ssemov,ssemov,sselog1,*,*\")\n-   (set_attr \"prefix\" \"maybe_vex,maybe_vex,maybe_vex,*,*\")\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,sselog1,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov,ssemov,ssemov,mmxmov,mmxmov\")\n+   (set (attr \"prefix\")\n+     (if_then_else (eq_attr \"alternative\" \"5,6,7,8,12,13\")\n+       (const_string \"maybe_vex\")\n+       (const_string \"orig\")))\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0,2\")\n+        (cond [(eq_attr \"alternative\" \"3,4,9,10\")\n+\t\t (const_string \"SI\")\n+\t       (eq_attr \"alternative\" \"5\")\n \t\t (if_then_else\n-\t\t   (ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n-\t\t       (const_int 0))\n-\t\t   (const_string \"V4SF\")\n-\t\t   (const_string \"TI\"))\n-\t       (eq_attr \"alternative\" \"1\")\n+\t\t   (and (and (ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n+\t\t\t    \t (const_int 0))\n+\t\t\t     (ne (symbol_ref \"TARGET_SSE2\")\n+\t\t\t\t (const_int 0)))\n+\t\t\t(eq (symbol_ref \"optimize_function_for_size_p (cfun)\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_string \"TI\")\n+\t\t   (const_string \"V4SF\"))\n+\t       /* For architectures resolving dependencies on\n+\t\t  whole SSE registers use APS move to break dependency\n+\t\t  chains, otherwise use short move to avoid extra work.\n+\n+\t\t  Do the same for architectures resolving dependencies on\n+\t\t  the parts.  While in DF mode it is better to always handle\n+\t\t  just register parts, the SF mode is different due to lack\n+\t\t  of instructions to load just part of the register.  It is\n+\t\t  better to maintain the whole registers in single format\n+\t\t  to avoid problems on using packed logical operations.  */\n+\t       (eq_attr \"alternative\" \"6\")\n \t\t (if_then_else\n-\t\t   (ior (ne (symbol_ref \"TARGET_SSE_TYPELESS_STORES\")\n+\t\t   (ior (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n \t\t\t    (const_int 0))\n-\t\t\t(ne (symbol_ref \"optimize_function_for_size_p (cfun)\")\n+\t\t\t(ne (symbol_ref \"TARGET_SSE_SPLIT_REGS\")\n \t\t\t    (const_int 0)))\n \t\t   (const_string \"V4SF\")\n-\t\t   (const_string \"TI\"))]\n-\t       (const_string \"DI\")))])\n-\n-(define_insn \"*pushtf_sse\"\n-  [(set (match_operand:TF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:TF 1 \"general_no_elim_operand\" \"x,Fo,*r\"))]\n-  \"TARGET_SSE2\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"sse,*,*\")\n-   (set_attr \"mode\" \"TF,SI,SI\")])\n-\n-(define_split\n-  [(set (match_operand:TF 0 \"push_operand\" \"\")\n-\t(match_operand:TF 1 \"general_operand\" \"\"))]\n-  \"TARGET_SSE2 && reload_completed\n-   && !SSE_REG_P (operands[1])\"\n-  [(const_int 0)]\n-  \"ix86_split_long_move (operands); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:TF 0 \"push_operand\" \"\")\n-\t(match_operand:TF 1 \"any_fp_register_operand\" \"\"))]\n-  \"TARGET_SSE2\"\n-  [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (const_int -16)))\n-   (set (mem:TF (reg:P SP_REG)) (match_dup 1))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand 1 \"general_operand\" \"\"))]\n-  \"reload_completed\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && GET_MODE (operands[0]) == XFmode\n-   && ! (ANY_FP_REG_P (operands[0]) ||\n-\t (GET_CODE (operands[0]) == SUBREG\n-\t  && ANY_FP_REG_P (SUBREG_REG (operands[0]))))\n-   && ! (ANY_FP_REG_P (operands[1]) ||\n-\t (GET_CODE (operands[1]) == SUBREG\n-\t  && ANY_FP_REG_P (SUBREG_REG (operands[1]))))\"\n-  [(const_int 0)]\n-  \"ix86_split_long_move (operands); DONE;\")\n+\t\t   (const_string \"SF\"))\n+\t       (eq_attr \"alternative\" \"11\")\n+\t\t (const_string \"DI\")]\n+\t       (const_string \"SF\")))])\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -3524,8 +3481,8 @@\n    && MEM_P (operands[1])\n    && (GET_MODE (operands[0]) == TFmode\n        || GET_MODE (operands[0]) == XFmode\n-       || GET_MODE (operands[0]) == SFmode\n-       || GET_MODE (operands[0]) == DFmode)\n+       || GET_MODE (operands[0]) == DFmode\n+       || GET_MODE (operands[0]) == SFmode)\n    && (operands[2] = find_constant_src (insn))\"\n   [(set (match_dup 0) (match_dup 2))]\n {\n@@ -3556,8 +3513,8 @@\n    && MEM_P (operands[1])\n    && (GET_MODE (operands[0]) == TFmode\n        || GET_MODE (operands[0]) == XFmode\n-       || GET_MODE (operands[0]) == SFmode\n-       || GET_MODE (operands[0]) == DFmode)\n+       || GET_MODE (operands[0]) == DFmode\n+       || GET_MODE (operands[0]) == SFmode)\n    && (operands[2] = find_constant_src (insn))\"\n   [(set (match_dup 0) (match_dup 2))]\n {\n@@ -3581,21 +3538,6 @@\n     FAIL;\n })\n \n-(define_insn \"swapxf\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"+f\")\n-\t(match_operand:XF 1 \"register_operand\" \"+f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"TARGET_80387\"\n-{\n-  if (STACK_TOP_P (operands[0]))\n-    return \"fxch\\t%1\";\n-  else\n-    return \"fxch\\t%0\";\n-}\n-  [(set_attr \"type\" \"fxch\")\n-   (set_attr \"mode\" \"XF\")])\n-\n ;; Split the load of -0.0 or -1.0 into fldz;fchs or fld1;fchs sequence\n (define_split\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"\")\n@@ -3616,13 +3558,35 @@\n     operands[1] = CONST1_RTX (<MODE>mode);\n })\n \n-(define_split\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:TF 1 \"general_operand\" \"\"))]\n-  \"reload_completed\n-   && !(SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]))\"\n-  [(const_int 0)]\n-  \"ix86_split_long_move (operands); DONE;\")\n+(define_insn \"swapxf\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"+f\")\n+\t(match_operand:XF 1 \"register_operand\" \"+f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"TARGET_80387\"\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return \"fxch\\t%1\";\n+  else\n+    return \"fxch\\t%0\";\n+}\n+  [(set_attr \"type\" \"fxch\")\n+   (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"*swap<mode>\"\n+  [(set (match_operand:MODEF 0 \"fp_register_operand\" \"+f\")\n+\t(match_operand:MODEF 1 \"fp_register_operand\" \"+f\"))\n+   (set (match_dup 1)\n+\t(match_dup 0))]\n+  \"TARGET_80387 || reload_completed\"\n+{\n+  if (STACK_TOP_P (operands[0]))\n+    return \"fxch\\t%1\";\n+  else\n+    return \"fxch\\t%0\";\n+}\n+  [(set_attr \"type\" \"fxch\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \f\n ;; Zero extension instructions\n "}]}