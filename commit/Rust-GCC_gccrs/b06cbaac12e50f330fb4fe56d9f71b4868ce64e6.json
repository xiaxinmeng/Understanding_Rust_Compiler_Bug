{"sha": "b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2Y2JhYWMxMmU1MGYzMzBmYjRmZTU2ZDlmNzFiNDg2OGNlNjRlNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-19T03:47:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-19T03:47:40Z"}, "message": "tree-ssa-threadupdate.c: Include ssa-iterators.h\n\n\t* tree-ssa-threadupdate.c: Include ssa-iterators.h\n\t(copy_phi_arg_into_existing_phi): New function.\n\t(any_remaining_duplicated_blocks): Likewise.\n\t(ssa_fix_duplicate_block_edges): Handle multiple duplicated\n\tblocks on a jump threading path.\n\nFrom-SVN: r205004", "tree": {"sha": "e6264bcaef3e53798a1a0bdf0ed88ebeff6cd8a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6264bcaef3e53798a1a0bdf0ed88ebeff6cd8a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6/comments", "author": null, "committer": null, "parents": [{"sha": "01ccc98e191bfa1e2a95338d1536f048f66204ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01ccc98e191bfa1e2a95338d1536f048f66204ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01ccc98e191bfa1e2a95338d1536f048f66204ef"}], "stats": {"total": 148, "additions": 118, "deletions": 30}, "files": [{"sha": "d759d4c5c080a316f3c39fcdbb7cd5f16b1eb238", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "patch": "@@ -1,5 +1,11 @@\n 2013-11-19  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-threadupdate.c: Include ssa-iterators.h\n+\t(copy_phi_arg_into_existing_phi): New function.\n+\t(any_remaining_duplicated_blocks): Likewise.\n+\t(ssa_fix_duplicate_block_edges): Handle multiple duplicated\n+\tblocks on a jump threading path.\n+\t\n \t* tree-ssa-threadupdate.c (thread_through_loop_header):  Do not\n \tthread through a joiner which has the latch edge.\n "}, {"sha": "3fba8486b3a9e6cca0d3da9614e57434cb6dc0a2", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 112, "deletions": 30, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06cbaac12e50f330fb4fe56d9f71b4868ce64e6/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b06cbaac12e50f330fb4fe56d9f71b4868ce64e6", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"tree-ssa.h\"\n #include \"tree-ssa-threadupdate.h\"\n+#include \"ssa-iterators.h\"\n #include \"dumpfile.h\"\n #include \"cfgloop.h\"\n #include \"hash-table.h\"\n@@ -337,6 +338,31 @@ lookup_redirection_data (edge e, enum insert_option insert)\n     }\n }\n \n+/* Similar to copy_phi_args, except that the PHI arg exists, it just\n+   does not have a value associated with it.  */\n+\n+static void\n+copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)\n+{\n+  int src_idx = src_e->dest_idx;\n+  int tgt_idx = tgt_e->dest_idx;\n+\n+  /* Iterate over each PHI in e->dest.  */\n+  for (gimple_stmt_iterator gsi = gsi_start_phis (src_e->dest),\n+\t\t\t    gsi2 = gsi_start_phis (tgt_e->dest);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi), gsi_next (&gsi2))\n+    {\n+      gimple src_phi = gsi_stmt (gsi);\n+      gimple dest_phi = gsi_stmt (gsi2);\n+      tree val = gimple_phi_arg_def (src_phi, src_idx);\n+      source_location locus = gimple_phi_arg_location (src_phi, src_idx);\n+\n+      SET_PHI_ARG_DEF (dest_phi, tgt_idx, val);\n+      gimple_phi_arg_set_location (dest_phi, tgt_idx, locus);\n+    }\n+}\n+\n /* For each PHI in BB, copy the argument associated with SRC_E to TGT_E.  */\n \n static void\n@@ -418,7 +444,23 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n   copy_phi_args (e->dest, rd->path->last ()->e, e);\n }\n \n-/* Wire up the outgoing edges from the duplicate block and\n+/* Look through PATH beginning at START and return TRUE if there are\n+   any additional blocks that need to be duplicated.  Otherwise,\n+   return FALSE.  */\n+static bool\n+any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,\n+\t\t\t\t unsigned int start)\n+{\n+  for (unsigned int i = start + 1; i < path->length (); i++)\n+    {\n+      if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK\n+\t  || (*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Wire up the outgoing edges from the duplicate blocks and\n    update any PHIs as needed.  */\n void\n ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n@@ -427,37 +469,77 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n-  /* If we were threading through an joiner block, then we want\n-     to keep its control statement and redirect an outgoing edge.\n-     Else we want to remove the control statement & edges, then create\n-     a new outgoing edge.  In both cases we may need to update PHIs.  */\n-  if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n-    {\n-      edge victim;\n-      edge e2;\n-\n-      /* This updates the PHIs at the destination of the duplicate\n-\t block.  */\n-      update_destination_phis (local_info->bb, rd->dup_blocks[0]);\n-\n-      /* Find the edge from the duplicate block to the block we're\n-\t threading through.  That's the edge we want to redirect.  */\n-      victim = find_edge (rd->dup_blocks[0], (*path)[1]->e->dest);\n-      e2 = redirect_edge_and_branch (victim, path->last ()->e->dest);\n-      e2->count = path->last ()->e->count;\n-\n-      /* If we redirected the edge, then we need to copy PHI arguments\n-\t at the target.  If the edge already existed (e2 != victim case),\n-\t then the PHIs in the target already have the correct arguments.  */\n-      if (e2 == victim)\n-\tcopy_phi_args (e2->dest, path->last ()->e, e2);\n-    }\n-  else\n-    {\n-      remove_ctrl_stmt_and_useless_edges (rd->dup_blocks[0], NULL);\n-      create_edge_and_update_destination_phis (rd, rd->dup_blocks[0]);\n+  for (unsigned int count = 0, i = 1; i < path->length (); i++)\n+    { \n+      /* If we were threading through an joiner block, then we want\n+\t to keep its control statement and redirect an outgoing edge.\n+\t Else we want to remove the control statement & edges, then create\n+\t a new outgoing edge.  In both cases we may need to update PHIs.  */\n+      if ((*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\t{\n+\t  edge victim;\n+\t  edge e2;\n+\n+\t  /* This updates the PHIs at the destination of the duplicate\n+\t     block.  */\n+\t  update_destination_phis (local_info->bb, rd->dup_blocks[count]);\n+\n+\t  /* Find the edge from the duplicate block to the block we're\n+\t     threading through.  That's the edge we want to redirect.  */\n+\t  victim = find_edge (rd->dup_blocks[count], (*path)[i]->e->dest);\n+\n+\t  /* If there are no remaining blocks on the path to duplicate,\n+\t     then redirect VICTIM to the final destination of the jump\n+\t     threading path.  */\n+\t  if (!any_remaining_duplicated_blocks (path, i))\n+\t    {\n+\t      e2 = redirect_edge_and_branch (victim, path->last ()->e->dest);\n+\t      e2->count = path->last ()->e->count;\n+\t      /* If we redirected the edge, then we need to copy PHI arguments\n+\t         at the target.  If the edge already existed (e2 != victim\n+\t\t case), then the PHIs in the target already have the correct\n+\t\t arguments.  */\n+\t      if (e2 == victim)\n+\t        copy_phi_args (e2->dest, path->last ()->e, e2);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Redirect VICTIM to the next duplicated block in the path.  */\n+\t      e2 = redirect_edge_and_branch (victim, rd->dup_blocks[count + 1]);\n+\n+\t      /* We need to update the PHIs in the next duplicated block.  We\n+\t\t want the new PHI args to have the same value as they had\n+\t\t in the source of the next duplicate block.\n+\n+\t\t Thus, we need to know which edge we traversed into the\n+\t\t source of the duplicate.  Furthermore, we may have\n+\t\t traversed many edges to reach the source of the duplicate.\n+\n+\t\t Walk through the path starting at element I until we\n+\t\t hit an edge marked with EDGE_COPY_SRC_BLOCK.  We want\n+\t\t the edge from the prior element.  */\n+\t      for (unsigned int j = i + 1; j < path->length (); j++)\n+\t\t{\n+\t\t  if ((*path)[j]->type == EDGE_COPY_SRC_BLOCK)\n+\t\t    {\n+\t\t      copy_phi_arg_into_existing_phi ((*path)[j - 1]->e, e2);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  count++;\n+\t}\n+      else if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n+\t{\n+\t  remove_ctrl_stmt_and_useless_edges (rd->dup_blocks[count], NULL);\n+\t  create_edge_and_update_destination_phis (rd, rd->dup_blocks[count]);\n+\t  if (count == 1)\n+\t    single_succ_edge (rd->dup_blocks[1])->aux = NULL;\n+\t  count++;\n+\t}\n     }\n }\n+\n /* Hash table traversal callback routine to create duplicate blocks.  */\n \n int"}]}