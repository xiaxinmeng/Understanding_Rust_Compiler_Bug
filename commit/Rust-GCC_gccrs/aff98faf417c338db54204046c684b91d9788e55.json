{"sha": "aff98faf417c338db54204046c684b91d9788e55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZmOThmYWY0MTdjMzM4ZGI1NDIwNDA0NmM2ODRiOTFkOTc4OGU1NQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-03-14T20:02:05Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-03-14T20:02:05Z"}, "message": "re PR c++/20280 (ICE in create_tmp_var, at gimplify.c:368)\n\ngcc/ChangeLog:\nPR c++/20280\n* gimplify.c (gimplify_cond_expr): Add fallback argument.  Use a\ntemporary variable of pointer type if an lvalues is required.\n(gimplify_modify_expr_rhs): Request an rvalue from it.\n(gimplify_expr): Pass fallback on.\ngcc/testsuite/ChangeLog:\nPR c++/20280\n* g++.dg/tree-ssa/pr20280.C: New.\n\nFrom-SVN: r96444", "tree": {"sha": "e0f63580eedb94d2efdb29726248cb05ff0f224d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0f63580eedb94d2efdb29726248cb05ff0f224d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aff98faf417c338db54204046c684b91d9788e55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff98faf417c338db54204046c684b91d9788e55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff98faf417c338db54204046c684b91d9788e55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff98faf417c338db54204046c684b91d9788e55/comments", "author": null, "committer": null, "parents": [{"sha": "2bb02bf01ba23bbe2ee8d227a6033ce996638241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb02bf01ba23bbe2ee8d227a6033ce996638241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb02bf01ba23bbe2ee8d227a6033ce996638241"}], "stats": {"total": 113, "additions": 107, "deletions": 6}, "files": [{"sha": "910eb398c9f41f231135b212b165e33712d91474", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff98faf417c338db54204046c684b91d9788e55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff98faf417c338db54204046c684b91d9788e55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aff98faf417c338db54204046c684b91d9788e55", "patch": "@@ -1,3 +1,11 @@\n+2005-03-14  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR c++/20280\n+\t* gimplify.c (gimplify_cond_expr): Add fallback argument.  Use a\n+\ttemporary variable of pointer type if an lvalues is required.\n+\t(gimplify_modify_expr_rhs): Request an rvalue from it.\n+\t(gimplify_expr): Pass fallback on.\n+\n 2005-03-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cfgbuild.c: Update comments."}, {"sha": "f16ff201694b2b942ba6d8c06b2bdccb1fd2db4a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff98faf417c338db54204046c684b91d9788e55/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff98faf417c338db54204046c684b91d9788e55/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=aff98faf417c338db54204046c684b91d9788e55", "patch": "@@ -2123,7 +2123,8 @@ gimple_boolify (tree expr)\n      *EXPR_P should be stored.  */\n \n static enum gimplify_status\n-gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target)\n+gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target,\n+\t\t    fallback_t fallback)\n {\n   tree expr = *expr_p;\n   tree tmp, tmp2, type;\n@@ -2137,18 +2138,40 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target)\n      the arms.  */\n   else if (! VOID_TYPE_P (type))\n     {\n+      tree result;\n+\n       if (target)\n \t{\n \t  ret = gimplify_expr (&target, pre_p, post_p,\n \t\t\t       is_gimple_min_lval, fb_lvalue);\n \t  if (ret != GS_ERROR)\n \t    ret = GS_OK;\n-\t  tmp = target;\n+\t  result = tmp = target;\n \t  tmp2 = unshare_expr (target);\n \t}\n+      else if ((fallback & fb_lvalue) == 0)\n+\t{\n+\t  result = tmp2 = tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n+\t  ret = GS_ALL_DONE;\n+\t}\n       else\n \t{\n-\t  tmp2 = tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n+\t  tree type = build_pointer_type (TREE_TYPE (expr));\n+\n+\t  if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n+\t    TREE_OPERAND (expr, 1) =\n+\t      build_fold_addr_expr (TREE_OPERAND (expr, 1));\n+\n+\t  if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n+\t    TREE_OPERAND (expr, 2) =\n+\t      build_fold_addr_expr (TREE_OPERAND (expr, 2));\n+\t  \n+\t  tmp2 = tmp = create_tmp_var (type, \"iftmp\");\n+\n+\t  expr = build (COND_EXPR, void_type_node, TREE_OPERAND (expr, 0),\n+\t\t\tTREE_OPERAND (expr, 1), TREE_OPERAND (expr, 2));\n+\n+\t  result = build_fold_indirect_ref (tmp);\n \t  ret = GS_ALL_DONE;\n \t}\n \n@@ -2169,7 +2192,7 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree *post_p, tree target)\n       /* Move the COND_EXPR to the prequeue.  */\n       gimplify_and_add (expr, pre_p);\n \n-      *expr_p = tmp;\n+      *expr_p = result;\n       return ret;\n     }\n \n@@ -2907,7 +2930,8 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \tif (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n \t  {\n \t    *expr_p = *from_p;\n-\t    return gimplify_cond_expr (expr_p, pre_p, post_p, *to_p);\n+\t    return gimplify_cond_expr (expr_p, pre_p, post_p, *to_p,\n+\t\t\t\t       fb_rvalue);\n \t  }\n \telse\n \t  ret = GS_UNHANDLED;\n@@ -3786,7 +3810,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  break;\n \n \tcase COND_EXPR:\n-\t  ret = gimplify_cond_expr (expr_p, pre_p, post_p, NULL_TREE);\n+\t  ret = gimplify_cond_expr (expr_p, pre_p, post_p, NULL_TREE,\n+\t\t\t\t    fallback);\n \t  break;\n \n \tcase CALL_EXPR:"}, {"sha": "4e18492dbab3af61415066e5dc928187608f2e7c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff98faf417c338db54204046c684b91d9788e55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff98faf417c338db54204046c684b91d9788e55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aff98faf417c338db54204046c684b91d9788e55", "patch": "@@ -1,3 +1,8 @@\n+2005-03-14  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR c++/20280\n+\t* g++.dg/tree-ssa/pr20280.C: New.\n+\n 2005-03-14  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/20467"}, {"sha": "ec4dad70620dcba591e9a960db8d810eba15d1b4", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr20280.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aff98faf417c338db54204046c684b91d9788e55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr20280.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aff98faf417c338db54204046c684b91d9788e55/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr20280.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr20280.C?ref=aff98faf417c338db54204046c684b91d9788e55", "patch": "@@ -0,0 +1,63 @@\n+// PR c++/20280\n+\n+// { dg-do compile }\n+\n+// Gimplification of the COND_EXPR used to fail because it had an\n+// addressable type, and create_tmp_var rejected that.\n+\n+struct A\n+{\n+    ~A();\n+};\n+\n+struct B : A {};\n+\n+A& foo();\n+\n+void bar(bool b)\n+{\n+    (B&) (b ? foo() : foo());\n+}\n+\n+// Make sure bit-fields and addressable types don't cause crashes.\n+// These were not in the original bug report.\n+\n+// Added by Alexandre Oliva <aoliva@redhat.com>\n+\n+// Copyright 2005 Free Software Foundation\n+\n+struct X\n+{\n+  long i : 32, j, k : 32;\n+};\n+\n+void g(long&);\n+void h(const long&);\n+\n+void f(X &x, bool b)\n+{\n+  (b ? x.i : x.j) = 1;\n+  (b ? x.j : x.k) = 2;\n+  (b ? x.i : x.k) = 3;\n+\n+  (void)(b ? x.i : x.j);\n+  (void)(b ? x.i : x.k);\n+  (void)(b ? x.j : x.k);\n+\n+  g (b ? x.i : x.j); // { dg-error \"cannot bind bitfield\" }\n+  g (b ? x.i : x.k); // { dg-error \"cannot bind bitfield\" }\n+  g (b ? x.j : x.k); // { dg-error \"cannot bind bitfield\" }\n+\n+  // It's not entirely clear whether these should be accepted.  The\n+  // conditional expressions are lvalues for sure, and 8.5.3/5 exempts\n+  // lvalues for bit-fields, but it's not clear that conditional\n+  // expressions that are lvalues and that have at least one possible\n+  // result that is a bit-field lvalue meets this condition.\n+  h (b ? x.i : x.j);\n+  h (b ? x.i : x.k);\n+  h (b ? x.j : x.k);\n+\n+  (long &)(b ? x.i : x.j); // { dg-error \"address of bit-field\" }\n+  (long &)(b ? x.i : x.k); // { dg-error \"address of bit-field\" }\n+  (long &)(b ? x.j : x.k); // { dg-error \"address of bit-field\" }\n+}"}]}