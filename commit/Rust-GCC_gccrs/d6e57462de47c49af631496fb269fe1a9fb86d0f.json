{"sha": "d6e57462de47c49af631496fb269fe1a9fb86d0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlNTc0NjJkZTQ3YzQ5YWY2MzE0OTZmYjI2OWZlMWE5ZmI4NmQwZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2004-02-13T16:11:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2004-02-13T16:11:39Z"}, "message": "re PR c++/9851 (confusing error message when using '.', not '->')\n\n\tPR c++/9851\n\t* parser.c (cp_parser_pseudo_destructor_name): Check for errors on\n\tthe type name and look ahead for ::~, and bail out early with a\n\tbetter error message if the parse is going to fail.\n\nFrom-SVN: r77758", "tree": {"sha": "8e212bcdf838506c4ede9c33f222784c6bf36a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e212bcdf838506c4ede9c33f222784c6bf36a76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6e57462de47c49af631496fb269fe1a9fb86d0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e57462de47c49af631496fb269fe1a9fb86d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e57462de47c49af631496fb269fe1a9fb86d0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e57462de47c49af631496fb269fe1a9fb86d0f/comments", "author": null, "committer": null, "parents": [{"sha": "faeb9bb6eed0f0043a8a6bccd42a0faa28767b18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faeb9bb6eed0f0043a8a6bccd42a0faa28767b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faeb9bb6eed0f0043a8a6bccd42a0faa28767b18"}], "stats": {"total": 24, "additions": 23, "deletions": 1}, "files": [{"sha": "4238dea0fc559343a0ba5374fdc6b5c0aa587108", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e57462de47c49af631496fb269fe1a9fb86d0f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e57462de47c49af631496fb269fe1a9fb86d0f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6e57462de47c49af631496fb269fe1a9fb86d0f", "patch": "@@ -1,3 +1,10 @@\n+2004-02-13  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\tPR c++/9851\n+\t* parser.c (cp_parser_pseudo_destructor_name): Check for errors on\n+\tthe type name and look ahead for ::~, and bail out early with a\n+\tbetter error message if the parse is going to fail.\n+\n 2004-02-12  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (conversion_kind): New type."}, {"sha": "7918602dee3de06ae0e0299f107f3849f56d36df", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e57462de47c49af631496fb269fe1a9fb86d0f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e57462de47c49af631496fb269fe1a9fb86d0f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d6e57462de47c49af631496fb269fe1a9fb86d0f", "patch": "@@ -4187,7 +4187,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n    If either of the first two productions is used, sets *SCOPE to the\n    TYPE specified before the final `::'.  Otherwise, *SCOPE is set to\n    NULL_TREE.  *TYPE is set to the TYPE_DECL for the final type-name,\n-   or ERROR_MARK_NODE if no type-name is present.  */\n+   or ERROR_MARK_NODE if the parse fails.  */\n \n static void\n cp_parser_pseudo_destructor_name (cp_parser* parser, \n@@ -4227,6 +4227,21 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n     {\n       /* Look for the type-name.  */\n       *scope = TREE_TYPE (cp_parser_type_name (parser));\n+\n+      /* If we didn't get an aggregate type, or we don't have ::~,\n+\t then something has gone wrong.  Since the only caller of this\n+\t function is looking for something after `.' or `->' after a\n+\t scalar type, most likely the program is trying to get a\n+\t member of a non-aggregate type.  */\n+      if (*scope == error_mark_node\n+\t  || cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE)\n+\t  || cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_COMPL)\n+\t{\n+\t  cp_parser_error (parser, \"request for member of non-aggregate type\");\n+\t  *type = error_mark_node;\n+\t  return;\n+\t}\n+\n       /* Look for the `::' token.  */\n       cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n     }"}]}