{"sha": "7e2df4a192476c23624aa62799844224b6b53938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyZGY0YTE5MjQ3NmMyMzYyNGFhNjI3OTk4NDQyMjRiNmI1MzkzOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-04-14T22:24:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-04-14T22:24:59Z"}, "message": "re PR middle-end/26823 (ICE with OpenMP in add_stmt_to_eh_region_fn, at tree-eh.c:100)\n\n\tPR middle-end/26823\n\t* except.h (eh_region_outermost): New prototype.\n\t* except.c (eh_region_outermost): New function.\n\t* tree-cfg.c (find_outermost_region_in_block): Use it.\n\n\t* g++.dg/gomp/pr26823-1.C: New test.\n\t* g++.dg/gomp/pr26823-2.C: New test.\n\nFrom-SVN: r112959", "tree": {"sha": "1cf0a8f2ef66b04878785ffcb60ed3de58e0a0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf0a8f2ef66b04878785ffcb60ed3de58e0a0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2df4a192476c23624aa62799844224b6b53938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2df4a192476c23624aa62799844224b6b53938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2df4a192476c23624aa62799844224b6b53938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2df4a192476c23624aa62799844224b6b53938/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "008712ae1cf581c664f18f44ccac6d36ccbf3b93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008712ae1cf581c664f18f44ccac6d36ccbf3b93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/008712ae1cf581c664f18f44ccac6d36ccbf3b93"}], "stats": {"total": 213, "additions": 158, "deletions": 55}, "files": [{"sha": "6079a41a5cbc1f79760e0f236bbab4f28e374945", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -1,3 +1,10 @@\n+2006-04-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/26823\n+\t* except.h (eh_region_outermost): New prototype.\n+\t* except.c (eh_region_outermost): New function.\n+\t* tree-cfg.c (find_outermost_region_in_block): Use it.\n+\n 2006-04-14  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* local-alloc.c (rest_of_handle_local_alloc): Use VEC instead"}, {"sha": "57e71bdfb44a5db3aa8c083e799cd0ef6072431c", "filename": "gcc/except.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -1078,6 +1078,48 @@ eh_region_outer_p (struct function *ifun, int region_a, int region_b)\n \n   return false;\n }\n+\n+/* Return region number of region that is outer to both if REGION_A and\n+   REGION_B in IFUN.  */\n+\n+int\n+eh_region_outermost (struct function *ifun, int region_a, int region_b)\n+{\n+  struct eh_region *rp_a, *rp_b;\n+  sbitmap b_outer;\n+\n+  gcc_assert (ifun->eh->last_region_number > 0);\n+  gcc_assert (ifun->eh->region_tree);\n+\n+  rp_a = VEC_index (eh_region, ifun->eh->region_array, region_a);\n+  rp_b = VEC_index (eh_region, ifun->eh->region_array, region_b);\n+  gcc_assert (rp_a != NULL);\n+  gcc_assert (rp_b != NULL);\n+\n+  b_outer = sbitmap_alloc (ifun->eh->last_region_number + 1);\n+  sbitmap_zero (b_outer);\n+\n+  do\n+    {\n+      SET_BIT (b_outer, rp_b->region_number);\n+      rp_b = rp_b->outer;\n+    }\n+  while (rp_b);\n+\n+  do\n+    {\n+      if (TEST_BIT (b_outer, rp_a->region_number))\n+\t{\n+\t  sbitmap_free (b_outer);\n+\t  return rp_a->region_number;\n+\t}\n+      rp_a = rp_a->outer;\n+    }\n+  while (rp_a);\n+\n+  sbitmap_free (b_outer);\n+  return -1;\n+}\n \f\n static int\n t2r_eq (const void *pentry, const void *pdata)"}, {"sha": "1f96477f2e0366d5320a368f73e08b4e0fd1b494", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -108,6 +108,7 @@ extern void expand_resx_expr (tree);\n extern void verify_eh_tree (struct function *);\n extern void dump_eh_tree (FILE *, struct function *);\n extern bool eh_region_outer_p (struct function *, int, int);\n+extern int eh_region_outermost (struct function *, int, int);\n \n /* tree-eh.c */\n extern void add_stmt_to_eh_region_fn (struct function *, tree, int);"}, {"sha": "28eeeb6fe7eb36e0e0c037bc08d8c6874fd72b84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -1,3 +1,9 @@\n+2006-04-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/26823\n+\t* g++.dg/gomp/pr26823-1.C: New test.\n+\t* g++.dg/gomp/pr26823-2.C: New test.\n+\n 2006-04-13  Uros Bizjak  <uros@kss-loka.si>\n \n \tPR middle-end/27134"}, {"sha": "d24eddbdfb265085fc5afb4d9d9b920cde8cfed6", "filename": "gcc/testsuite/g++.dg/gomp/pr26823-1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-1.C?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -0,0 +1,23 @@\n+// PR middle-end/26823\n+// { dg-do compile }\n+\n+struct A\n+{\n+  ~A () {}\n+};\n+\n+struct B\n+{\n+  A a;\n+  B ();\n+};\n+\n+void\n+foo ()\n+{\n+#pragma omp parallel\n+  {\n+    B b[1];\n+    new int;\n+  }\n+}"}, {"sha": "d4747cff5e5af150c9a77c3ecc2cc16a3a62eb8b", "filename": "gcc/testsuite/g++.dg/gomp/pr26823-2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr26823-2.C?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -0,0 +1,29 @@\n+// PR middle-end/26823\n+// { dg-do compile }\n+\n+struct A\n+{\n+  ~A () {}\n+};\n+\n+extern void bar ();\n+\n+void\n+foo ()\n+{\n+#pragma omp parallel\n+  {\n+    {\n+      A a;\n+      bar ();\n+    }\n+    {\n+      A a;\n+      bar ();\n+    }\n+    {\n+      A a;\n+      bar ();\n+    }\n+  }\n+}"}, {"sha": "f6a44ba5a87112c362f16938bf533920d9fe526f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2df4a192476c23624aa62799844224b6b53938/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7e2df4a192476c23624aa62799844224b6b53938", "patch": "@@ -103,6 +103,7 @@ static void make_edges (void);\n static void make_cond_expr_edges (basic_block);\n static void make_switch_expr_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n+static void make_omp_sections_edges (basic_block);\n static edge tree_redirect_edge_and_branch (edge, basic_block);\n static edge tree_try_redirect_by_replacing_jump (edge, basic_block);\n static unsigned int split_critical_edges (void);\n@@ -446,7 +447,6 @@ static void\n make_edges (void)\n {\n   basic_block bb;\n-  struct omp_region *cur_region = NULL;\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n@@ -460,8 +460,7 @@ make_edges (void)\n \n       if (last)\n \t{\n-\t  enum tree_code code = TREE_CODE (last);\n-\t  switch (code)\n+\t  switch (TREE_CODE (last))\n \t    {\n \t    case GOTO_EXPR:\n \t      make_goto_expr_edges (bb);\n@@ -523,53 +522,18 @@ make_edges (void)\n \t    case OMP_ORDERED:\n \t    case OMP_CRITICAL:\n \t    case OMP_SECTION:\n-\t      cur_region = new_omp_region (bb, code, cur_region);\n \t      fallthru = true;\n \t      break;\n \n-\t    case OMP_SECTIONS:\n-\t      cur_region = new_omp_region (bb, code, cur_region);\n-\t      fallthru = false;\n-\t      break;\n-\n-\t    case OMP_RETURN:\n-\t      /* In the case of an OMP_SECTION, the edge will go somewhere\n-\t\t other than the next block.  This will be created later.  */\n-\t      cur_region->exit = bb;\n-\t      fallthru = cur_region->type != OMP_SECTION;\n-\t      cur_region = cur_region->outer;\n+\t    case OMP_RETURN_EXPR:\n+\t      /* In the case of an OMP_SECTION, we may have already made\n+\t\t an edge in make_omp_sections_edges.  */\n+\t      fallthru = EDGE_COUNT (bb->succs) == 0;\n \t      break;\n \n-\t    case OMP_CONTINUE:\n-\t      cur_region->cont = bb;\n-\t      switch (cur_region->type)\n-\t\t{\n-\t\tcase OMP_FOR:\n-\t\t  /* ??? Technically there should be a some sort of loopback\n-\t\t     edge here, but it goes to a block that doesn't exist yet,\n-\t\t     and without it, updating the ssa form would be a real\n-\t\t     bear.  Fortunately, we don't yet do ssa before expanding\n-\t\t     these nodes.  */\n-\t\t  break;\n-\n-\t\tcase OMP_SECTIONS:\n-\t\t  /* Wire up the edges into and out of the nested sections.  */\n-\t\t  /* ??? Similarly wrt loopback.  */\n-\t\t  {\n-\t\t    struct omp_region *i;\n-\t\t    for (i = cur_region->inner; i ; i = i->next)\n-\t\t      {\n-\t\t\tgcc_assert (i->type == OMP_SECTION);\n-\t\t\tmake_edge (cur_region->entry, i->entry, 0);\n-\t\t\tmake_edge (i->exit, bb, EDGE_FALLTHRU);\n-\t\t      }\n-\t\t  }\n-\t\t  break;\n-\t\t     \n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n-\t      fallthru = true;\n+\t    case OMP_SECTIONS:\n+\t      make_omp_sections_edges (bb);\n+\t      fallthru = false;\n \t      break;\n \n \t    default:\n@@ -584,9 +548,6 @@ make_edges (void)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n-  if (root_omp_region)\n-    free_omp_regions ();\n-\n   /* Fold COND_EXPR_COND of each COND_EXPR.  */\n   fold_cond_expr_cond ();\n \n@@ -595,6 +556,35 @@ make_edges (void)\n }\n \n \n+/* Link an OMP_SECTIONS block to all the OMP_SECTION blocks in its body.  */\n+\n+static void\n+make_omp_sections_edges (basic_block bb)\n+{\n+  basic_block exit_bb;\n+  size_t i, n;\n+  tree vec, stmt;\n+\n+  stmt = last_stmt (bb);\n+  vec = OMP_SECTIONS_SECTIONS (stmt);\n+  n = TREE_VEC_LENGTH (vec);\n+  exit_bb = bb_for_stmt (TREE_VEC_ELT (vec, n - 1));\n+\n+  for (i = 0; i < n - 1; i += 2)\n+    {\n+      basic_block start_bb = bb_for_stmt (TREE_VEC_ELT (vec, i));\n+      basic_block end_bb = bb_for_stmt (TREE_VEC_ELT (vec, i + 1));\n+      make_edge (bb, start_bb, 0);\n+      make_edge (end_bb, exit_bb, EDGE_FALLTHRU);\n+    }\n+\n+  /* Once the CFG has been built, the vector of sections is no longer\n+     useful.  The region can be easily obtained with build_omp_regions.\n+     Furthermore, this sharing of tree expressions is not allowed by the\n+     statement verifier.  */\n+  OMP_SECTIONS_SECTIONS (stmt) = NULL_TREE;\n+}\n+\n /* Create the edges for a COND_EXPR starting at block BB.\n    At this point, both clauses must contain only simple gotos.  */\n \n@@ -2508,7 +2498,7 @@ is_ctrl_altering_stmt (tree t)\n     }\n \n   /* OpenMP directives alter control flow.  */\n-  if (OMP_DIRECTIVE_P (t))\n+  if (flag_openmp && OMP_DIRECTIVE_P (t))\n     return true;\n \n   /* If a statement can throw, it alters control flow.  */\n@@ -4559,9 +4549,7 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n   if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n     TREE_BLOCK (t) = p->block;\n \n-  if (OMP_DIRECTIVE_P (t)\n-      && TREE_CODE (t) != OMP_RETURN\n-      && TREE_CODE (t) != OMP_CONTINUE)\n+  if (OMP_DIRECTIVE_P (t) && TREE_CODE (t) != OMP_RETURN_EXPR)\n     {\n       /* Do not remap variables inside OMP directives.  Variables\n \t referenced in clauses and directive header belong to the\n@@ -4745,9 +4733,16 @@ find_outermost_region_in_block (struct function *src_cfun,\n       int stmt_region;\n \n       stmt_region = lookup_stmt_eh_region_fn (src_cfun, stmt);\n-      if (stmt_region > 0\n-\t  && (region < 0 || eh_region_outer_p (src_cfun, stmt_region, region)))\n-\tregion = stmt_region;\n+      if (stmt_region > 0)\n+\t{\n+\t  if (region < 0)\n+\t    region = stmt_region;\n+\t  else if (stmt_region != region)\n+\t    {\n+\t      region = eh_region_outermost (src_cfun, stmt_region, region);\n+\t      gcc_assert (region != -1);\n+\t    }\n+\t}\n     }\n \n   return region;"}]}