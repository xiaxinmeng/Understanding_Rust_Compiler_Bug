{"sha": "a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1ODJmN2M2ZGQxYjNiN2NiYzMwMmNmZjhhOWM4Mzk4NTljOTU2Nw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T20:27:25Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T20:27:25Z"}, "message": "cse.c (have_eh_succ_edges): New function.\n\n\t* cse.c (have_eh_succ_edges): New function.\n\t(cse_insn): Don't remove dead EH edges here\n\t(cse_extended_basic_block): Do it here.\n\t(rest_of_handle_cse, rest_of_handle_cse2): Don't assert\n\tthat we have removed all dead edges.\n\nFrom-SVN: r119993", "tree": {"sha": "ed0d26aaad0d636bc1d11a6a27977280077fed16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed0d26aaad0d636bc1d11a6a27977280077fed16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567/comments", "author": null, "committer": null, "parents": [{"sha": "d3f1be5dcd17b4c11648708a4e2786de03c6f9af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f1be5dcd17b4c11648708a4e2786de03c6f9af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f1be5dcd17b4c11648708a4e2786de03c6f9af"}], "stats": {"total": 49, "additions": 32, "deletions": 17}, "files": [{"sha": "30cd10676da2f15958e64f77b3a2e7c7ed9d1ce0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "patch": "@@ -1,3 +1,11 @@\n+2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cse.c (have_eh_succ_edges): New function.\n+\t(cse_insn): Don't remove dead EH edges here\n+\t(cse_extended_basic_block): Do it here.\n+\t(rest_of_handle_cse, rest_of_handle_cse2): Don't assert\n+\tthat we have removed all dead edges.\n+\n 2006-12-17  Matthias Klose  <doko@debian.org>\n \n \tPR libstdc++/11953"}, {"sha": "fae16dabcc2e667bbbfd0b2cc39f858e92226868", "filename": "gcc/cse.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7582f7c6dd1b3b7cbc302cff8a9c839859c9567/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=a7582f7c6dd1b3b7cbc302cff8a9c839859c9567", "patch": "@@ -4858,13 +4858,6 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t      validate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n \t      apply_change_group ();\n \n-\t      /* With non-call exceptions, if this was an insn that could\n-\t\t trap, we may have made it non-throwing now.  For example\n-\t\t we may have replaced a load with a register.  */\n-\t      if (flag_non_call_exceptions\n-\t\t  && insn == BB_END (BLOCK_FOR_INSN (insn)))\n-\t\tpurge_dead_edges (BLOCK_FOR_INSN (insn));\n-\n \t      break;\n \t    }\n \n@@ -5938,6 +5931,22 @@ cse_dump_path (struct cse_basic_block_data *data, int nsets, FILE *f)\n   fflush (f);\n }\n \n+\f\n+/* Return true if BB has exception handling successor edges.  */\n+\n+static bool\n+have_eh_succ_edges (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_EH)\n+      return true;\n+\n+  return false;\n+}\n+\n \f\n /* Scan to the end of the path described by DATA.  Return an estimate of\n    the total number of SETs, and the lowest and highest insn CUID, of all\n@@ -6109,6 +6118,12 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n       /* Make sure that libcalls don't span multiple basic blocks.  */\n       gcc_assert (libcall_insn == NULL_RTX);\n \n+      /* With non-call exceptions, we are not always able to update\n+\t the CFG properly inside cse_insn.  So clean up possibly\n+\t redundant EH edges here.  */\n+      if (flag_non_call_exceptions && have_eh_succ_edges (bb))\n+\tpurge_dead_edges (bb);\n+\n       /* If we changed a conditional jump, we may have terminated\n \t the path we are following.  Check that by verifying that\n \t the edge we would take still exists.  If the edge does\n@@ -6210,13 +6225,13 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \tINSN_CUID (insn) = ++i;\n     }\n \n-  /* Loop over basic blocks in DFS order,\n+  /* Loop over basic blocks in reverse completion order (RPO),\n      excluding the ENTRY and EXIT blocks.  */\n   n_blocks = pre_and_rev_post_order_compute (NULL, rc_order, false);\n   i = 0;\n   while (i < n_blocks)\n     {\n-      /* Find the first block in the DFS queue that we have not yet\n+      /* Find the first block in the RPO queue that we have not yet\n \t processed before.  */\n       do\n \t{\n@@ -6988,10 +7003,6 @@ rest_of_handle_cse (void)\n      expecting CSE to be run.  But always rerun it in a cheap mode.  */\n   cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n \n-  /* If there are dead edges to purge, we haven't properly updated\n-     the CFG incrementally.  */\n-  gcc_assert (!purge_all_dead_edges ());\n-\n   if (tem)\n     rebuild_jump_labels (get_insns ());\n \n@@ -7044,10 +7055,6 @@ rest_of_handle_cse2 (void)\n      bypassed safely.  */\n   cse_condition_code_reg ();\n \n-  /* If there are dead edges to purge, we haven't properly updated\n-     the CFG incrementally.  */\n-  gcc_assert (!purge_all_dead_edges ());\n-\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n   if (tem)"}]}