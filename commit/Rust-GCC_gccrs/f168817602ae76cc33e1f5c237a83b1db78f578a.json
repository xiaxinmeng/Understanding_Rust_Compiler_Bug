{"sha": "f168817602ae76cc33e1f5c237a83b1db78f578a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2ODgxNzYwMmFlNzZjYzMzZTFmNWMyMzdhODNiMWRiNzhmNTc4YQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2007-10-23T04:33:26Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2007-10-23T04:33:26Z"}, "message": "df-scan.c (df_get_call_refs): Mark global registers as both a DF_REF_REG_USE and a non-clobber DF_REF_REG_DEF.\n\ngcc/:\n\n2007-10-22  Seongbae Park <seongbae.park@gmail.com>\n\tDavid S. Miller  <davem@davemloft.net>\n\n\t* df-scan.c (df_get_call_refs): Mark global registers as both a\n\tDF_REF_REG_USE and a non-clobber DF_REF_REG_DEF.\n\n\ngcc/testsuite/:\n\n2007-10-22  David S. Miller  <davem@davemloft.net>\n\n\t* gcc.dg/globalreg-1.c: New test.\n\nFrom-SVN: r129572", "tree": {"sha": "49d0f59121cd9231ba1263f6dd3fab20f35ca5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49d0f59121cd9231ba1263f6dd3fab20f35ca5e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f168817602ae76cc33e1f5c237a83b1db78f578a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f168817602ae76cc33e1f5c237a83b1db78f578a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f168817602ae76cc33e1f5c237a83b1db78f578a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f168817602ae76cc33e1f5c237a83b1db78f578a/comments", "author": null, "committer": null, "parents": [{"sha": "7de5c6a447ac4c86d737b350b7458c6fe428194c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de5c6a447ac4c86d737b350b7458c6fe428194c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de5c6a447ac4c86d737b350b7458c6fe428194c"}], "stats": {"total": 76, "additions": 72, "deletions": 4}, "files": [{"sha": "f6f8a862a6fd6c55ba8a5e69e57b1d3144565618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f168817602ae76cc33e1f5c237a83b1db78f578a", "patch": "@@ -1,3 +1,9 @@\n+2007-10-22  Seongbae Park <seongbae.park@gmail.com>\n+\tDavid S. Miller  <davem@davemloft.net>\n+\n+\t* df-scan.c (df_get_call_refs): Mark global registers as both a\n+\tDF_REF_REG_USE and a non-clobber DF_REF_REG_DEF.\n+\n 2007-10-22  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR tree-optimization/33834"}, {"sha": "cc6866b6b789cdd3e71783bbcfb1f401c5455d56", "filename": "gcc/df-scan.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=f168817602ae76cc33e1f5c237a83b1db78f578a", "patch": "@@ -3109,18 +3109,22 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n      so they are recorded as used.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n-      df_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t     NULL, bb, insn, DF_REF_REG_USE, flags);\n+      {\n+\tdf_ref_record (collection_rec, regno_reg_rtx[i],\n+\t\t       NULL, bb, insn, DF_REF_REG_USE, flags);\n+\tdf_ref_record (collection_rec, regno_reg_rtx[i],\n+\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags);\n+      }\n \n   is_sibling_call = SIBLING_CALL_P (insn);\n   EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, ui, bi)\n     {\n-      if ((!bitmap_bit_p (defs_generated, ui))\n+      if (!global_regs[ui]\n+\t  && (!bitmap_bit_p (defs_generated, ui))\n \t  && (!is_sibling_call\n \t      || !bitmap_bit_p (df->exit_block_uses, ui)\n \t      || refers_to_regno_p (ui, ui+1, \n \t\t\t\t    current_function_return_rtx, NULL)))\n-\n         df_ref_record (collection_rec, regno_reg_rtx[ui], \n \t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags);\n     }"}, {"sha": "39758307a1be49e15da2149eae12e1046a3bc352", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f168817602ae76cc33e1f5c237a83b1db78f578a", "patch": "@@ -1,3 +1,7 @@\n+2007-10-22  David S. Miller  <davem@davemloft.net>\n+\n+\t* gcc.dg/globalreg-1.c: New test.\n+\n 2007-10-22  Martin Michlmayr <tbm@cyrius.com>\t\n \t    Dorit Nuzman  <dorit@il.ibm.com>\n "}, {"sha": "f54976dce1de49091ad3ee9ebc70235a7bc5d611", "filename": "gcc/testsuite/gcc.dg/globalreg-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Ftestsuite%2Fgcc.dg%2Fglobalreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f168817602ae76cc33e1f5c237a83b1db78f578a/gcc%2Ftestsuite%2Fgcc.dg%2Fglobalreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fglobalreg-1.c?ref=f168817602ae76cc33e1f5c237a83b1db78f578a", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run { target sparc*-*-* } } */\n+/* { dg-options \"-std=gnu99 -Os\" } */\n+\n+/* This is a massively distilled test case based upon\n+   mm/memory.c:unmap_vmas() in the Linux kernel when compiled\n+   on sparc64 for SMP which uses a global register as the\n+   base of the per-cpu variable area.\n+\n+   Because of a bug in global register handling in the dataflow\n+   code, the loop-invariant pass would move 'expression(regval)'\n+   outside of the loop.  */\n+\n+extern void exit(int);\n+extern void abort(void);\n+\n+register unsigned long regval __asm__(\"g6\");\n+\n+extern void cond_resched(void);\n+\n+unsigned int var;\n+\n+static unsigned long expression(unsigned long v)\n+{\n+  unsigned long ret;\n+\n+  __asm__(\"\" : \"=r\" (ret) : \"0\" (0));\n+  return ret + v;\n+}\n+\n+void func(unsigned long *pp)\n+{\n+  int i;\n+\n+  for (i = 0; i < 56; i++) {\n+    cond_resched();\n+    *pp = expression(regval);\n+  }\n+}\n+\n+void __attribute__((noinline)) cond_resched(void)\n+{\n+\tregval++;\n+}\n+\n+int main(void)\n+{\n+  unsigned long val;\n+\n+  regval = 100;\n+  func(&val);\n+  if (val != 156)\n+    abort();\n+  exit(0);\n+}"}]}