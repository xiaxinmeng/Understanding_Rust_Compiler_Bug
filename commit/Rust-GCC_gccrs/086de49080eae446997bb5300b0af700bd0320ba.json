{"sha": "086de49080eae446997bb5300b0af700bd0320ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg2ZGU0OTA4MGVhZTQ0Njk5N2JiNTMwMGIwYWY3MDBiZDAzMjBiYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-02-23T16:26:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-02-23T16:26:32Z"}, "message": "utils2.c (build_simple_component_ref): Fix formatting.\n\n\t* gcc-interface/utils2.c (build_simple_component_ref): Fix formatting.\n\tLook through a conversion between original and packable version to get\n\tthe base object.\n\t(build_component_ref): Rework comment and fix formatting.\n\nFrom-SVN: r208051", "tree": {"sha": "b621368c5b931258f53035b56bbe1fca779ce9f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b621368c5b931258f53035b56bbe1fca779ce9f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/086de49080eae446997bb5300b0af700bd0320ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086de49080eae446997bb5300b0af700bd0320ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/086de49080eae446997bb5300b0af700bd0320ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086de49080eae446997bb5300b0af700bd0320ba/comments", "author": null, "committer": null, "parents": [{"sha": "a6eecdc1728260204bdcdc3ef07ba139cbdd4fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6eecdc1728260204bdcdc3ef07ba139cbdd4fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6eecdc1728260204bdcdc3ef07ba139cbdd4fe2"}], "stats": {"total": 73, "additions": 51, "deletions": 22}, "files": [{"sha": "9ab0bb23b47af16e3107b90ece5eb44c09862478", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/086de49080eae446997bb5300b0af700bd0320ba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/086de49080eae446997bb5300b0af700bd0320ba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=086de49080eae446997bb5300b0af700bd0320ba", "patch": "@@ -1,3 +1,10 @@\n+2014-02-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils2.c (build_simple_component_ref): Fix formatting.\n+\tLook through a conversion between original and packable version to get\n+\tthe base object.\n+\t(build_component_ref): Rework comment and fix formatting.\n+\n 2014-02-20  Sergey Rybin  <rybin@adacore.com frybin>\n \n \t* gnat_ugn.texi, vms_data.ads (gnatelim): Add description of"}, {"sha": "dd4151b5bc599dc58eb21d393fd90423bc2442e2", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/086de49080eae446997bb5300b0af700bd0320ba/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/086de49080eae446997bb5300b0af700bd0320ba/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=086de49080eae446997bb5300b0af700bd0320ba", "patch": "@@ -1897,11 +1897,11 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n    actual record and know how to look for fields in variant parts.  */\n \n static tree\n-build_simple_component_ref (tree record_variable, tree component,\n-                            tree field, bool no_fold_p)\n+build_simple_component_ref (tree record_variable, tree component, tree field,\n+\t\t\t    bool no_fold_p)\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n-  tree ref, inner_variable;\n+  tree base, ref;\n \n   gcc_assert (RECORD_OR_UNION_TYPE_P (record_type)\n \t      && COMPLETE_TYPE_P (record_type)\n@@ -1933,7 +1933,7 @@ build_simple_component_ref (tree record_variable, tree component,\n \t  break;\n \n       /* Next, see if we're looking for an inherited component in an extension.\n-\t If so, look through the extension directly, but not if the type contains\n+\t If so, look through the extension directly, unless the type contains\n \t a placeholder, as it might be needed for a later substitution.  */\n       if (!new_field\n \t  && TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n@@ -1980,17 +1980,40 @@ build_simple_component_ref (tree record_variable, tree component,\n       && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n     return NULL_TREE;\n \n-  /* Look through conversion between type variants.  This is transparent as\n-     far as the field is concerned.  */\n-  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n-\t == record_type)\n-    inner_variable = TREE_OPERAND (record_variable, 0);\n-  else\n-    inner_variable = record_variable;\n+  /* We have found a suitable field.  Before building the COMPONENT_REF, get\n+     the base object of the record variable if possible.  */\n+  base = record_variable;\n+\n+  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR)\n+    {\n+      tree inner_variable = TREE_OPERAND (record_variable, 0);\n+      tree inner_type = TYPE_MAIN_VARIANT (TREE_TYPE (inner_variable));\n \n-  ref = build3 (COMPONENT_REF, TREE_TYPE (field), inner_variable, field,\n-\t\tNULL_TREE);\n+      /* Look through a conversion between type variants.  This is transparent\n+\t as far as the field is concerned.  */\n+      if (inner_type == record_type)\n+\tbase = inner_variable;\n+\n+      /* Look through a conversion between original and packable version, but\n+\t the field needs to be adjusted in this case.  */\n+      else if (TYPE_NAME (inner_type) == TYPE_NAME (record_type))\n+\t{\n+\t  tree new_field;\n+\n+\t  for (new_field = TYPE_FIELDS (inner_type);\n+\t       new_field;\n+\t       new_field = DECL_CHAIN (new_field))\n+\t    if (SAME_FIELD_P (field, new_field))\n+\t      break;\n+\t  if (new_field)\n+\t    {\n+\t      field = new_field;\n+\t      base = inner_variable;\n+\t    }\n+\t}\n+    }\n+\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (field), base, field, NULL_TREE);\n \n   if (TREE_READONLY (record_variable)\n       || TREE_READONLY (field)\n@@ -2007,10 +2030,10 @@ build_simple_component_ref (tree record_variable, tree component,\n \n   /* The generic folder may punt in this case because the inner array type\n      can be self-referential, but folding is in fact not problematic.  */\n-  if (TREE_CODE (record_variable) == CONSTRUCTOR\n-      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n+  if (TREE_CODE (base) == CONSTRUCTOR\n+      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (base)))\n     {\n-      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (record_variable);\n+      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (base);\n       unsigned HOST_WIDE_INT idx;\n       tree index, value;\n       FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n@@ -2022,16 +2045,15 @@ build_simple_component_ref (tree record_variable, tree component,\n   return fold (ref);\n }\n \f\n-/* Like build_simple_component_ref, except that we give an error if the\n-   reference could not be found.  */\n+/* Likewise, but generate a Constraint_Error if the reference could not be\n+   found.  */\n \n tree\n-build_component_ref (tree record_variable, tree component,\n-                     tree field, bool no_fold_p)\n+build_component_ref (tree record_variable, tree component, tree field,\n+\t\t     bool no_fold_p)\n {\n   tree ref = build_simple_component_ref (record_variable, component, field,\n \t\t\t\t\t no_fold_p);\n-\n   if (ref)\n     return ref;\n "}]}