{"sha": "5b0f0db6d9533eed15c6868a5f57d92196e3264f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwZjBkYjZkOTUzM2VlZDE1YzY4NjhhNWY1N2Q5MjE5NmUzMjY0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-05-06T11:23:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-05-06T11:23:42Z"}, "message": "mips-protos.h (mips_subword, [...]): Declare.\n\n\t* config/mips/mips-protos.h (mips_subword, mips_output_move): Declare.\n\t(mips_move_1word, mips_move_2words): Remove declaration.\n\t(mips_split_64bit_move_p, mips_split_64bit_move): Declare.\n\t(mips_restore_gp): Remove insn argument.\n\t* config/mips/mips.h (FP_REG_RTX_P): New macro.\n\t* config/mips/mips.c (volatile_buffer): Remove.\n\t(mips_subword, mips_split_64bit_move_p, mips_split_64bit_move): New.\n\t(mips_move_1word, mips_move_2words): Remove, replacing with...\n\t(mips_output_move): ...this new function.\n\t(mips_restore_gp): Remove insn argument.  Adjust for above changes.\n\t(print_operand): Make '%h' print %hi(op) for HIGH operands.  Remove\n\thandling of floating-point constants.  Handle zero CONST_DOUBLE\n\targuments.\n\t(mips_annotate_frame_insn): Replace with...\n\t(mips_set_frame_expr): ...this, which just takes one argument.\n\t(mips_frame_set): Change the register argument to an rtx.\n\t(mips_emit_frame_related_store): Use mips_split_64bit_move_p to\n\tcheck whether moves should be split.  Use mips_split_64bit_move\n\tto split them.  Use mips_subword to generate the high and low\n\tparts of a paired FPR.  Adjust calls to frame_set and\n\tmips_set_frame_expr.\n\t(mips_expand_prologue): Simplify due to above changes.\n\t* config/mips/mips.md:\tAdd splitters for 64-bit moves on 32-bit\n\ttargets, replacing xisting register-only versions.\n\t(UNSPEC_STORE_DF_HIGH): New unspec.\n\t(UNSPEC_LOAD_DF_LOW, UNSPEC_LOAD_DF_HIGH): New unspecs.\n\t(mulsi3_r4000, muldi3_internal2): Avoid use of mips_move_1word.\n\t(*paradoxical_extendhidi2): Remove.\n\t(movdi_internal, movdi_internal2): Use mips_output_move.\n\t(*movdi_internal2_mips16, movsi_internal, movcc): Likewise.\n\t(movsf_internal1, movsf_internal2): Likewise.\n\t(movdf_internal1a): Likewise.  Fix length and type of f <- G case.\n\t(movdf_internal1b): Use mips_output_move.  Fix type of f <- G case.\n\t(movdf_internal2): Use mips_output_move.  Fix lengths of FPR moves.\n\tAdd m <- G alternative.\n\t(load_df_low, load_df_high, store_df_low): New patterns.\n\t(movhi_internal): Use @ template instead of calling a function.\n\tRemove unnecessary 'z' alternatives.\n\t(movqi_internal): Likewise.\n\t(exception_receiver): Update call to mips_restore_gp.\n\nFrom-SVN: r66521", "tree": {"sha": "1fd7b0cd4ee10455288b825103283f0ec57a0fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd7b0cd4ee10455288b825103283f0ec57a0fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b0f0db6d9533eed15c6868a5f57d92196e3264f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0f0db6d9533eed15c6868a5f57d92196e3264f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0f0db6d9533eed15c6868a5f57d92196e3264f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0f0db6d9533eed15c6868a5f57d92196e3264f/comments", "author": null, "committer": null, "parents": [{"sha": "83f564f76ff896424c3ac8d6cde45867e9c083c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f564f76ff896424c3ac8d6cde45867e9c083c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f564f76ff896424c3ac8d6cde45867e9c083c0"}], "stats": {"total": 1411, "additions": 438, "deletions": 973}, "files": [{"sha": "70bdd48f249b6d3e55dffbbc898ec230f7d2a40b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b0f0db6d9533eed15c6868a5f57d92196e3264f", "patch": "@@ -1,3 +1,46 @@\n+2003-05-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_subword, mips_output_move): Declare.\n+\t(mips_move_1word, mips_move_2words): Remove declaration.\n+\t(mips_split_64bit_move_p, mips_split_64bit_move): Declare.\n+\t(mips_restore_gp): Remove insn argument.\n+\t* config/mips/mips.h (FP_REG_RTX_P): New macro.\n+\t* config/mips/mips.c (volatile_buffer): Remove.\n+\t(mips_subword, mips_split_64bit_move_p, mips_split_64bit_move): New.\n+\t(mips_move_1word, mips_move_2words): Remove, replacing with...\n+\t(mips_output_move): ...this new function.\n+\t(mips_restore_gp): Remove insn argument.  Adjust for above changes.\n+\t(print_operand): Make '%h' print %hi(op) for HIGH operands.  Remove\n+\thandling of floating-point constants.  Handle zero CONST_DOUBLE\n+\targuments.\n+\t(mips_annotate_frame_insn): Replace with...\n+\t(mips_set_frame_expr): ...this, which just takes one argument.\n+\t(mips_frame_set): Change the register argument to an rtx.\n+\t(mips_emit_frame_related_store): Use mips_split_64bit_move_p to\n+\tcheck whether moves should be split.  Use mips_split_64bit_move\n+\tto split them.  Use mips_subword to generate the high and low\n+\tparts of a paired FPR.  Adjust calls to frame_set and\n+\tmips_set_frame_expr.\n+\t(mips_expand_prologue): Simplify due to above changes.\n+\t* config/mips/mips.md:\tAdd splitters for 64-bit moves on 32-bit\n+\ttargets, replacing xisting register-only versions.\n+\t(UNSPEC_STORE_DF_HIGH): New unspec.\n+\t(UNSPEC_LOAD_DF_LOW, UNSPEC_LOAD_DF_HIGH): New unspecs.\n+\t(mulsi3_r4000, muldi3_internal2): Avoid use of mips_move_1word.\n+\t(*paradoxical_extendhidi2): Remove.\n+\t(movdi_internal, movdi_internal2): Use mips_output_move.\n+\t(*movdi_internal2_mips16, movsi_internal, movcc): Likewise.\n+\t(movsf_internal1, movsf_internal2): Likewise.\n+\t(movdf_internal1a): Likewise.  Fix length and type of f <- G case.\n+\t(movdf_internal1b): Use mips_output_move.  Fix type of f <- G case.\n+\t(movdf_internal2): Use mips_output_move.  Fix lengths of FPR moves.\n+\tAdd m <- G alternative.\n+\t(load_df_low, load_df_high, store_df_low): New patterns.\n+\t(movhi_internal): Use @ template instead of calling a function.\n+\tRemove unnecessary 'z' alternatives.\n+\t(movqi_internal): Likewise.\n+\t(exception_receiver): Update call to mips_restore_gp.\n+\n 2003-05-06  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips-protos.h (mips_simplify_dwarf_addr): Remove."}, {"sha": "9e2c156eb05e286e71cd15ce813c9f745bd98190", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=5b0f0db6d9533eed15c6868a5f57d92196e3264f", "patch": "@@ -100,10 +100,12 @@ extern HOST_WIDE_INT\tmips_debugger_offset PARAMS ((rtx, HOST_WIDE_INT));\n extern const char      *mips_fill_delay_slot PARAMS ((const char *,\n \t\t\t\t\t\t      enum delay_type, rtx *,\n \t\t\t\t\t\t      rtx));\n-extern const char      *mips_move_1word PARAMS ((rtx *, rtx, int));\n-extern const char      *mips_move_2words PARAMS ((rtx *, rtx));\n+extern rtx\t\tmips_subword PARAMS ((rtx, int));\n+extern bool\t\tmips_split_64bit_move_p PARAMS ((rtx, rtx));\n+extern void\t\tmips_split_64bit_move PARAMS ((rtx, rtx));\n+extern const char      *mips_output_move PARAMS ((rtx, rtx));\n extern const char      *mips_emit_prefetch PARAMS ((rtx *));\n-extern const char      *mips_restore_gp PARAMS ((rtx *, rtx));\n+extern const char      *mips_restore_gp PARAMS ((rtx *));\n extern const char      *output_block_move PARAMS ((rtx, rtx *, int,\n \t\t\t\t\t\t   enum block_move_type));\n extern void\t\toverride_options PARAMS ((void));"}, {"sha": "caebfbbf6ea5e4b66d6da527c592c2390c502806", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 241, "deletions": 841, "changes": 1082, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5b0f0db6d9533eed15c6868a5f57d92196e3264f", "patch": "@@ -233,9 +233,8 @@ static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n static bool mips_get_unaligned_mem\t\tPARAMS ((rtx *, unsigned int,\n \t\t\t\t\t\t\t int, rtx *, rtx *));\n static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT));\n-static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n-static rtx mips_frame_set\t\t\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t int, int));\n+static void mips_set_frame_expr\t\t\tPARAMS ((rtx));\n+static rtx mips_frame_set\t\t\tPARAMS ((rtx, int));\n static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t HOST_WIDE_INT));\n static void save_restore_insns\t\t\tPARAMS ((int, rtx, long));\n@@ -593,10 +592,6 @@ char mips_print_operand_punct[256];\n /* Map GCC register number to debugger register number.  */\n int mips_dbx_regno[FIRST_PSEUDO_REGISTER];\n \n-/* Buffer to use to enclose a load/store operation with %{ %} to\n-   turn on .set volatile.  */\n-static char volatile_buffer[60];\n-\n /* An alias set for the GOT.  */\n static int mips_got_alias_set;\n \n@@ -1324,7 +1319,7 @@ mips_const_insns (x)\n \n \tcase CONSTANT_RELOC:\n \t  /* When generating mips16 code, we need to set the destination to\n-\t     $0 and then add in the signed offset.  See mips_move_1word.  */\n+\t     $0 and then add in the signed offset.  See mips_output_move.  */\n \t  return (TARGET_MIPS16 ? 3 : 1);\n \n \tcase CONSTANT_SYMBOLIC:\n@@ -2962,403 +2957,264 @@ embedded_pic_offset (x)\n \t\t   gen_rtx_MINUS (Pmode, x,\n \t\t\t\t  XEXP (DECL_RTL (current_function_decl), 0)));\n }\n+\f\n+/* Return one word of double-word value OP, taking into account the fixed\n+   endianness of certain registers.  HIGH_P is true to select the high part,\n+   false to select the low part.  */\n \n-/* Return the appropriate instructions to move one operand to another.  */\n+rtx\n+mips_subword (op, high_p)\n+     rtx op;\n+     int high_p;\n+{\n+  unsigned int byte;\n+  enum machine_mode mode;\n \n-const char *\n-mips_move_1word (operands, insn, unsignedp)\n-     rtx operands[];\n-     rtx insn;\n-     int unsignedp;\n-{\n-  const char *ret = 0;\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  enum rtx_code code0 = GET_CODE (op0);\n-  enum rtx_code code1 = GET_CODE (op1);\n-  enum machine_mode mode = GET_MODE (op0);\n-  int subreg_offset0 = 0;\n-  int subreg_offset1 = 0;\n-  enum delay_type delay = DELAY_NONE;\n-  struct mips_constant_info c;\n+  mode = GET_MODE (op);\n+  if (mode == VOIDmode)\n+    mode = DImode;\n \n-  while (code0 == SUBREG)\n-    {\n-      subreg_offset0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (op0)),\n-\t\t\t\t\t     SUBREG_BYTE (op0),\n-\t\t\t\t\t     GET_MODE (op0));\n-      op0 = SUBREG_REG (op0);\n-      code0 = GET_CODE (op0);\n-    }\n+  if (TARGET_BIG_ENDIAN ? !high_p : high_p)\n+    byte = UNITS_PER_WORD;\n+  else\n+    byte = 0;\n \n-  while (code1 == SUBREG)\n+  if (GET_CODE (op) == REG)\n     {\n-      subreg_offset1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (op1)),\n-\t\t\t\t\t     SUBREG_BYTE (op1),\n-\t\t\t\t\t     GET_MODE (op1));\n-      op1 = SUBREG_REG (op1);\n-      code1 = GET_CODE (op1);\n+      if (FP_REG_P (REGNO (op)))\n+\treturn gen_rtx_REG (word_mode, high_p ? REGNO (op) + 1 : REGNO (op));\n+      if (REGNO (op) == HI_REGNUM)\n+\treturn gen_rtx_REG (word_mode, high_p ? HI_REGNUM : LO_REGNUM);\n     }\n \n-  /* For our purposes, a condition code mode is the same as SImode.  */\n-  if (mode == CCmode)\n-    mode = SImode;\n-\n-  if (code0 == REG)\n-    {\n-      int regno0 = REGNO (op0) + subreg_offset0;\n-\n-      if (code1 == REG)\n-\t{\n-\t  int regno1 = REGNO (op1) + subreg_offset1;\n-\n-\t  /* Just in case, don't do anything for assigning a register\n-\t     to itself, unless we are filling a delay slot.  */\n-\t  if (regno0 == regno1 && set_nomacro == 0)\n-\t    ret = \"\";\n-\n-\t  else if (GP_REG_P (regno0))\n-\t    {\n-\t      if (GP_REG_P (regno1))\n-\t\tret = \"move\\t%0,%1\";\n-\n-\t      else if (MD_REG_P (regno1))\n-\t\t{\n-\t\t  delay = DELAY_HILO;\n-\t\t  if (regno1 != HILO_REGNUM)\n-\t\t    ret = \"mf%1\\t%0\";\n-\t\t  else\n-\t\t    ret = \"mflo\\t%0\";\n-\t\t}\n-\n-\t      else if (ST_REG_P (regno1) && ISA_HAS_8CC)\n-\t\tret = \"li\\t%0,1\\n\\tmovf\\t%0,%.,%1\";\n-\n-\t      else\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  if (FP_REG_P (regno1))\n-\t\t    ret = \"mfc1\\t%0,%1\";\n-\t\t  else if (ALL_COP_REG_P (regno1))\n-\t\t    {\n-\t\t      static char retval[] = \"mfc_\\t%0,%1\";\n+  if (GET_CODE (op) == MEM)\n+    return adjust_address (op, word_mode, byte);\n \n-\t\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n-\t\t      ret = retval;\n-\t\t    }\n-\t\t  else if (regno1 == FPSW_REGNUM && ! ISA_HAS_8CC)\n-\t\t    ret = \"cfc1\\t%0,$31\";\n-\t\t}\n-\t    }\n+  return simplify_gen_subreg (word_mode, op, mode, byte);\n+}\n \n-\t  else if (FP_REG_P (regno0))\n-\t    {\n-\t      if (GP_REG_P (regno1))\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  ret = \"mtc1\\t%1,%0\";\n-\t\t}\n \n-\t      if (FP_REG_P (regno1))\n-\t\tret = \"mov.s\\t%0,%1\";\n-\t    }\n+/* Return true if a 64-bit move from SRC to DEST should be split into two.  */\n \n-\t  else if (MD_REG_P (regno0))\n-\t    {\n-\t      if (GP_REG_P (regno1))\n-\t\t{\n-\t\t  delay = DELAY_HILO;\n-\t\t  if (regno0 != HILO_REGNUM && ! TARGET_MIPS16)\n-\t\t    ret = \"mt%0\\t%1\";\n-\t\t}\n-\t    }\n+bool\n+mips_split_64bit_move_p (dest, src)\n+     rtx dest, src;\n+{\n+  if (TARGET_64BIT)\n+    return false;\n \n-\t  else if (regno0 == FPSW_REGNUM && ! ISA_HAS_8CC)\n-\t    {\n-\t      if (GP_REG_P (regno1))\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  ret = \"ctc1\\t%0,$31\";\n-\t\t}\n-\t    }\n-\t  else if (ALL_COP_REG_P (regno0))\n-\t    {\n-\t      if (GP_REG_P (regno1))\n-\t\t{\n-\t\t  static char retval[] = \"mtc_\\t%1,%0\";\n-\t\t  char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n-\n-\t\t  if (cop == '0')\n-\t\t    abort_with_insn (insn,\n-\t\t\t\t     \"mtc0 not supported; it disturbs virtual address translation\");\n-\t\t  delay = DELAY_LOAD;\n-\t\t  retval[3] = cop;\n-\t\t  ret = retval;\n-\t\t}\n-\t    }\n-\t}\n+  /* FP->FP moves can be done in a single instruction.  */\n+  if (FP_REG_RTX_P (src) && FP_REG_RTX_P (dest))\n+    return false;\n \n-      else if (code1 == MEM)\n-\t{\n-\t  delay = DELAY_LOAD;\n+  /* Check for floating-point loads and stores.  They can be done using\n+     ldc1 and sdc1 on MIPS II and above.  */\n+  if (mips_isa > 1)\n+    {\n+      if (FP_REG_RTX_P (dest) && GET_CODE (src) == MEM)\n+\treturn false;\n+      if (FP_REG_RTX_P (src) && GET_CODE (dest) == MEM)\n+\treturn false;\n+    }\n+  return true;\n+}\n \n-\t  if (TARGET_STATS)\n-\t    mips_count_memory_refs (op1, 1);\n \n-\t  if (GP_REG_P (regno0))\n-\t    {\n-\t      /* For loads, use the mode of the memory item, instead of the\n-\t\t target, so zero/sign extend can use this code as well.  */\n-\t      switch (GET_MODE (op1))\n-\t\t{\n-\t\tdefault:\n-\t\t  break;\n-\t\tcase SFmode:\n-\t\t  ret = \"lw\\t%0,%1\";\n-\t\t  break;\n-\t\tcase SImode:\n-\t\tcase CCmode:\n-\t\t  ret = ((unsignedp && TARGET_64BIT)\n-\t\t\t ? \"lwu\\t%0,%1\"\n-\t\t\t : \"lw\\t%0,%1\");\n-\t\t  break;\n-\t\tcase HImode:\n-\t\t  ret = (unsignedp) ? \"lhu\\t%0,%1\" : \"lh\\t%0,%1\";\n-\t\t  break;\n-\t\tcase QImode:\n-\t\t  ret = (unsignedp) ? \"lbu\\t%0,%1\" : \"lb\\t%0,%1\";\n-\t\t  break;\n-\t\t}\n-\t    }\n+/* Split a 64-bit move from SRC to DEST assuming that\n+   mips_split_64bit_move_p holds.\n \n-\t  else if (FP_REG_P (regno0) && (mode == SImode || mode == SFmode))\n-\t    ret = \"lwc1\\t%0,%1\";\n+   Moves into and out of FPRs cause some difficulty here.  Such moves\n+   will always be DFmode, since paired FPRs are not allowed to store\n+   DImode values.  The most natural representation would be two separate\n+   32-bit moves, such as:\n \n-\t  else if (ALL_COP_REG_P (regno0))\n-\t    {\n-\t      static char retval[] = \"lwc_\\t%0,%1\";\n-\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n-\n-\t      if (cop == '0')\n-\t\tabort_with_insn (insn,\n-\t\t\t\t \"loads from memory to COP0 are illegal\");\n-\t      delay = DELAY_LOAD;\n-\t      retval[3] = cop;\n-\t      ret = retval;\n-\t    }\n+\t(set (reg:SI $f0) (mem:SI ...))\n+\t(set (reg:SI $f1) (mem:SI ...))\n \n-\t  if (ret != (char *)0 && MEM_VOLATILE_P (op1))\n-\t    {\n-\t      size_t i = strlen (ret);\n-\t      if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n-\t\tabort ();\n+   However, the second insn is invalid because odd-numbered FPRs are\n+   not allowed to store independent values.  Use the patterns load_df_low,\n+   load_df_high and store_df_high instead.  */\n \n-\t      sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n-\t      ret = volatile_buffer;\n-\t    }\n-\t}\n+void\n+mips_split_64bit_move (dest, src)\n+     rtx dest, src;\n+{\n+  if (FP_REG_RTX_P (dest))\n+    {\n+      /* Loading an FPR from memory or from GPRs.  */\n+      emit_insn (gen_load_df_low (copy_rtx (dest), mips_subword (src, 0)));\n+      emit_insn (gen_load_df_high (dest, mips_subword (src, 1),\n+\t\t\t\t   copy_rtx (dest)));\n+    }\n+  else if (FP_REG_RTX_P (src))\n+    {\n+      /* Storing an FPR into memory or GPRs.  */\n+      emit_move_insn (mips_subword (dest, 0), mips_subword (src, 0));\n+      emit_insn (gen_store_df_high (mips_subword (dest, 1), src));\n+    }\n+  else\n+    {\n+      /* The operation can be split into two normal moves.  Decide in\n+\t which order to do them.  */\n+      rtx low_dest;\n \n-      else if (code1 == CONST_INT\n-\t       || (code1 == CONST_DOUBLE\n-\t\t   && GET_MODE (op1) == VOIDmode))\n+      low_dest = mips_subword (dest, 0);\n+      if (GET_CODE (low_dest) == REG\n+\t  && reg_overlap_mentioned_p (low_dest, src))\n \t{\n-\t  if (code1 == CONST_DOUBLE)\n-\t    {\n-\t      /* This can happen when storing constants into long long\n-                 bitfields.  Just store the least significant word of\n-                 the value.  */\n-\t      operands[1] = op1 = GEN_INT (CONST_DOUBLE_LOW (op1));\n-\t    }\n-\n-\t  if (INTVAL (op1) == 0 && ! TARGET_MIPS16)\n-\t    {\n-\t      if (GP_REG_P (regno0))\n-\t\tret = \"move\\t%0,%z1\";\n-\n-\t      else if (FP_REG_P (regno0))\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  ret = \"mtc1\\t%z1,%0\";\n-\t\t}\n-\n-\t      else if (MD_REG_P (regno0))\n-\t\t{\n-\t\t  delay = DELAY_HILO;\n-\t\t  ret = \"mt%0\\t%.\";\n-\t\t}\n-\t    }\n-\n-\t  else if (GP_REG_P (regno0))\n-\t    {\n-\t      /* Don't use X format, because that will give out of\n-\t\t range numbers for 64 bit host and 32 bit target.  */\n-\t      if (! TARGET_MIPS16)\n-\t\tret = \"li\\t%0,%1\\t\\t\\t# %X1\";\n-\t      else\n-\t\t{\n-\t\t  if (INTVAL (op1) >= 0 && INTVAL (op1) <= 0xffff)\n-\t\t    ret = \"li\\t%0,%1\";\n-\t\t  else if (INTVAL (op1) < 0 && INTVAL (op1) >= -0xffff)\n-\t\t    ret = \"li\\t%0,%n1\\n\\tneg\\t%0\";\n-\t\t}\n-\t    }\n+\t  emit_move_insn (mips_subword (dest, 1), mips_subword (src, 1));\n+\t  emit_move_insn (low_dest, mips_subword (src, 0));\n \t}\n-\n-      else if (code1 == CONST_DOUBLE && mode == SFmode)\n+      else\n \t{\n-\t  if (op1 == CONST0_RTX (SFmode))\n-\t    {\n-\t      if (GP_REG_P (regno0))\n-\t\tret = \"move\\t%0,%.\";\n-\n-\t      else if (FP_REG_P (regno0))\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  ret = \"mtc1\\t%.,%0\";\n-\t\t}\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      delay = DELAY_LOAD;\n-\t      ret = \"li.s\\t%0,%1\";\n-\t    }\n+\t  emit_move_insn (low_dest, mips_subword (src, 0));\n+\t  emit_move_insn (mips_subword (dest, 1), mips_subword (src, 1));\n \t}\n+    }\n+}\n+\f\n+/* Return the appropriate instructions to move SRC into DEST.  Assume\n+   that SRC is operand 1 and DEST is operand 0.  */\n \n-      else if (code1 == PLUS)\n-\t{\n-\t  rtx add_op0 = XEXP (op1, 0);\n-\t  rtx add_op1 = XEXP (op1, 1);\n+const char *\n+mips_output_move (dest, src)\n+     rtx dest, src;\n+{\n+  enum rtx_code dest_code, src_code;\n+  struct mips_constant_info c;\n+  bool dbl_p;\n \n-\t  if (GET_CODE (XEXP (op1, 1)) == REG\n-\t      && GET_CODE (XEXP (op1, 0)) == CONST_INT)\n-\t    add_op0 = XEXP (op1, 1), add_op1 = XEXP (op1, 0);\n+  dest_code = GET_CODE (dest);\n+  src_code = GET_CODE (src);\n+  dbl_p = (GET_MODE_SIZE (GET_MODE (dest)) == 8);\n \n-\t  operands[2] = add_op0;\n-\t  operands[3] = add_op1;\n-\t  ret = \"add%:\\t%0,%2,%3\";\n-\t}\n+  if (dbl_p && mips_split_64bit_move_p (dest, src))\n+    return \"#\";\n \n-      else if (code1 == HIGH)\n+  if ((src_code == REG && GP_REG_P (REGNO (src)))\n+      || (!TARGET_MIPS16 && src == CONST0_RTX (GET_MODE (dest))))\n+    {\n+      if (dest_code == REG)\n \t{\n-\t  operands[1] = XEXP (op1, 0);\n-\t  ret = \"lui\\t%0,%%hi(%1)\";\n-\t}\n+\t  if (GP_REG_P (REGNO (dest)))\n+\t    return \"move\\t%0,%z1\";\n \n-      else\n-\tswitch (mips_classify_constant (&c, op1))\n-\t  {\n-\t  case CONSTANT_NONE:\n-\t    break;\n+\t  if (MD_REG_P (REGNO (dest)))\n+\t    return \"mt%0\\t%z1\";\n \n-\t  case CONSTANT_GP:\n-\t    ret = \"move\\t%0,%1\";\n-\t    break;\n+\t  if (FP_REG_P (REGNO (dest)))\n+\t    return (dbl_p ? \"dmtc1\\t%z1,%0\" : \"mtc1\\t%z1,%0\");\n \n-\t  case CONSTANT_RELOC:\n-\t    ret = (TARGET_MIPS16 ? \"li\\t%0,0\\n\\taddiu\\t%0,%1\" : \"li\\t%0,%1\");\n-\t    break;\n+\t  if (ALL_COP_REG_P (REGNO (dest)))\n+\t    {\n+\t      static char retval[] = \"dmtc_\\t%z1,%0\";\n \n-\t  case CONSTANT_SYMBOLIC:\n-\t    if (TARGET_STATS)\n-\t      mips_count_memory_refs (op1, 1);\n-\t    ret = \"la\\t%0,%a1\";\n-\t    break;\n-\t  }\n+\t      retval[4] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (dest));\n+\t      return (dbl_p ? retval : retval + 1);\n+\t    }\n+\t}\n+      if (dest_code == MEM)\n+\treturn (dbl_p ? \"sd\\t%z1,%0\" : \"sw\\t%z1,%0\");\n     }\n-\n-  else if (code0 == MEM)\n+  if (dest_code == REG && GP_REG_P (REGNO (dest)))\n     {\n-      if (TARGET_STATS)\n-\tmips_count_memory_refs (op0, 1);\n-\n-      if (code1 == REG)\n+      if (src_code == REG)\n \t{\n-\t  int regno1 = REGNO (op1) + subreg_offset1;\n+\t  if (MD_REG_P (REGNO (src)))\n+\t    return \"mf%1\\t%0\";\n \n-\t  if (GP_REG_P (regno1))\n-\t    {\n-\t      switch (mode)\n-\t\t{\n-\t\tcase SFmode: ret = \"sw\\t%1,%0\"; break;\n-\t\tcase SImode: ret = \"sw\\t%1,%0\"; break;\n-\t\tcase HImode: ret = \"sh\\t%1,%0\"; break;\n-\t\tcase QImode: ret = \"sb\\t%1,%0\"; break;\n-\t\tdefault: break;\n-\t\t}\n-\t    }\n+\t  if (ST_REG_P (REGNO (src)) && ISA_HAS_8CC)\n+\t    return \"lui\\t%0,0x3f80\\n\\tmovf\\t%0,%.,%1\";\n \n-\t  else if (FP_REG_P (regno1) && (mode == SImode || mode == SFmode))\n-\t    ret = \"swc1\\t%1,%0\";\n-\t  else if (ALL_COP_REG_P (regno1))\n+\t  if (FP_REG_P (REGNO (src)))\n+\t    return (dbl_p ? \"dmfc1\\t%0,%1\" : \"mfc1\\t%0,%1\");\n+\n+\t  if (ALL_COP_REG_P (REGNO (src)))\n \t    {\n-\t      static char retval[] = \"swc_\\t%1,%0\";\n+\t      static char retval[] = \"dmfc_\\t%0,%1\";\n \n-\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n-\t      ret = retval;\n+\t      retval[4] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (src));\n+\t      return (dbl_p ? retval : retval + 1);\n \t    }\n \t}\n \n-      else if (code1 == CONST_INT && INTVAL (op1) == 0)\n-\t{\n-\t  switch (mode)\n-\t    {\n-\t    case SFmode: ret = \"sw\\t%z1,%0\"; break;\n-\t    case SImode: ret = \"sw\\t%z1,%0\"; break;\n-\t    case HImode: ret = \"sh\\t%z1,%0\"; break;\n-\t    case QImode: ret = \"sb\\t%z1,%0\"; break;\n-\t    default: break;\n-\t    }\n-\t}\n+      if (src_code == MEM)\n+\treturn (dbl_p ? \"ld\\t%0,%1\" : \"lw\\t%0,%1\");\n \n-      else if (code1 == CONST_DOUBLE && op1 == CONST0_RTX (mode))\n+      if (src_code == CONST_INT)\n \t{\n-\t  switch (mode)\n-\t    {\n-\t    case SFmode: ret = \"sw\\t%.,%0\"; break;\n-\t    case SImode: ret = \"sw\\t%.,%0\"; break;\n-\t    case HImode: ret = \"sh\\t%.,%0\"; break;\n-\t    case QImode: ret = \"sb\\t%.,%0\"; break;\n-\t    default: break;\n-\t    }\n+\t  /* Don't use the X format, because that will give out of\n+\t     range numbers for 64 bit hosts and 32 bit targets.  */\n+\t  if (!TARGET_MIPS16)\n+\t    return \"li\\t%0,%1\\t\\t\\t# %X1\";\n+\n+\t  if (INTVAL (src) >= 0 && INTVAL (src) <= 0xffff)\n+\t    return \"li\\t%0,%1\";\n+\n+\t  if (INTVAL (src) < 0 && INTVAL (src) >= -0xffff)\n+\t    return \"li\\t%0,%n1\\n\\tneg\\t%0\";\n \t}\n \n-      if (ret != 0 && MEM_VOLATILE_P (op0))\n+      if (src_code == HIGH)\n+\treturn \"lui\\t%0,%h1\";\n+\n+      switch (mips_classify_constant (&c, src))\n \t{\n-\t  size_t i = strlen (ret);\n+\tcase CONSTANT_NONE:\n+\t  break;\n \n-\t  if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n-\t    abort ();\n+\tcase CONSTANT_GP:\n+\t  return \"move\\t%0,%1\";\n \n-\t  sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n-\t  ret = volatile_buffer;\n+\tcase CONSTANT_RELOC:\n+\t  return (TARGET_MIPS16 ? \"li\\t%0,0\\n\\taddiu\\t%0,%1\" : \"li\\t%0,%1\");\n+\n+\tcase CONSTANT_SYMBOLIC:\n+\t  return (dbl_p ? \"dla\\t%0,%a1\" : \"la\\t%0,%a1\");\n \t}\n     }\n+  if (src_code == REG && FP_REG_P (REGNO (src)))\n+    {\n+      if (dest_code == REG && FP_REG_P (REGNO (dest)))\n+\treturn (dbl_p ? \"mov.d\\t%0,%1\" : \"mov.s\\t%0,%1\");\n \n-  if (ret == 0)\n+      if (dest_code == MEM)\n+\treturn (dbl_p ? \"sdc1\\t%1,%0\" : \"swc1\\t%1,%0\");\n+    }\n+  if (dest_code == REG && FP_REG_P (REGNO (dest)))\n     {\n-      abort_with_insn (insn, \"bad move\");\n-      return 0;\n+      if (src_code == MEM)\n+\treturn (dbl_p ? \"ldc1\\t%0,%1\" : \"lwc1\\t%0,%1\");\n     }\n+  if (dest_code == REG && ALL_COP_REG_P (REGNO (dest)) && src_code == MEM)\n+    {\n+      static char retval[] = \"l_c_\\t%0,%1\";\n \n-  if (delay != DELAY_NONE)\n-    return mips_fill_delay_slot (ret, delay, operands, insn);\n+      retval[1] = (dbl_p ? 'd' : 'w');\n+      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (dest));\n+      return retval;\n+    }\n+  if (dest_code == MEM && src_code == REG && ALL_COP_REG_P (REGNO (src)))\n+    {\n+      static char retval[] = \"s_c_\\t%1,%0\";\n \n-  return ret;\n+      retval[1] = (dbl_p ? 'd' : 'w');\n+      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (src));\n+      return retval;\n+    }\n+  abort ();\n }\n \f\n /* Return instructions to restore the global pointer from the stack,\n    assuming TARGET_ABICALLS.  Used by exception_receiver to set up\n    the GP for exception handlers.\n \n    OPERANDS is an array of operands whose contents are undefined\n-   on entry.  INSN is the exception_handler instruction.  */\n+   on entry.  */\n \n const char *\n-mips_restore_gp (operands, insn)\n-     rtx *operands, insn;\n+mips_restore_gp (operands)\n+     rtx *operands;\n {\n   rtx loc;\n \n@@ -3370,464 +3226,9 @@ mips_restore_gp (operands, insn)\n   loc = plus_constant (loc, cfun->machine->frame.args_size);\n   operands[1] = gen_rtx_MEM (ptr_mode, loc);\n \n-  return mips_move_1word (operands, insn, 0);\n+  return mips_output_move (operands[0], operands[1]);\n }\n \f\n-/* Return the appropriate instructions to move 2 words */\n-\n-const char *\n-mips_move_2words (operands, insn)\n-     rtx operands[];\n-     rtx insn;\n-{\n-  const char *ret = 0;\n-  rtx op0 = operands[0];\n-  rtx op1 = operands[1];\n-  enum rtx_code code0 = GET_CODE (operands[0]);\n-  enum rtx_code code1 = GET_CODE (operands[1]);\n-  int subreg_offset0 = 0;\n-  int subreg_offset1 = 0;\n-  enum delay_type delay = DELAY_NONE;\n-  struct mips_constant_info c;\n-\n-  while (code0 == SUBREG)\n-    {\n-      subreg_offset0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (op0)),\n-\t\t\t\t\t     SUBREG_BYTE (op0),\n-\t\t\t\t\t     GET_MODE (op0));\n-      op0 = SUBREG_REG (op0);\n-      code0 = GET_CODE (op0);\n-    }\n-\n-  while (code1 == SUBREG)\n-    {\n-      subreg_offset1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (op1)),\n-\t\t\t\t\t     SUBREG_BYTE (op1),\n-\t\t\t\t\t     GET_MODE (op1));\n-      op1 = SUBREG_REG (op1);\n-      code1 = GET_CODE (op1);\n-    }\n-\n-  if (code0 == REG)\n-    {\n-      int regno0 = REGNO (op0) + subreg_offset0;\n-\n-      if (code1 == REG)\n-\t{\n-\t  int regno1 = REGNO (op1) + subreg_offset1;\n-\n-\t  /* Just in case, don't do anything for assigning a register\n-\t     to itself, unless we are filling a delay slot.  */\n-\t  if (regno0 == regno1 && set_nomacro == 0)\n-\t    ret = \"\";\n-\n-\t  else if (FP_REG_P (regno0))\n-\t    {\n-\t      if (FP_REG_P (regno1))\n-\t\tret = \"mov.d\\t%0,%1\";\n-\n-\t      else\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  if (TARGET_FLOAT64)\n-\t\t    {\n-\t\t      if (!TARGET_64BIT)\n-\t\t\tabort_with_insn (insn, \"bad move\");\n-\n-#ifdef TARGET_FP_CALL_32\n-\t\t      if (FP_CALL_GP_REG_P (regno1))\n-\t\t\tret = \"dsll\\t%1,32\\n\\tor\\t%1,%D1\\n\\tdmtc1\\t%1,%0\";\n-\t\t      else\n-#endif\n-\t\t\tret = \"dmtc1\\t%1,%0\";\n-\t\t    }\n-\t\t  else\n-\t\t    ret = \"mtc1\\t%L1,%0\\n\\tmtc1\\t%M1,%D0\";\n-\t\t}\n-\t    }\n-\n-\t  else if (FP_REG_P (regno1))\n-\t    {\n-\t      delay = DELAY_LOAD;\n-\t      if (TARGET_FLOAT64)\n-\t\t{\n-\t\t  if (!TARGET_64BIT)\n-\t\t    abort_with_insn (insn, \"bad move\");\n-\n-#ifdef TARGET_FP_CALL_32\n-\t\t  if (FP_CALL_GP_REG_P (regno0))\n-\t\t    ret = \"dmfc1\\t%0,%1\\n\\tmfc1\\t%D0,%1\\n\\tdsrl\\t%0,32\";\n-\t\t  else\n-#endif\n-\t\t    ret = \"dmfc1\\t%0,%1\";\n-\t\t}\n-\t      else\n-\t\tret = \"mfc1\\t%L0,%1\\n\\tmfc1\\t%M0,%D1\";\n-\t    }\n-\n-\t  else if (MD_REG_P (regno0) && GP_REG_P (regno1) && !TARGET_MIPS16)\n-\t    {\n-\t      delay = DELAY_HILO;\n-\t      if (TARGET_64BIT)\n-\t\t{\n-\t\t  if (regno0 != HILO_REGNUM)\n-\t\t    ret = \"mt%0\\t%1\";\n-\t\t  else if (regno1 == 0)\n-\t\t    ret = \"mtlo\\t%.\\n\\tmthi\\t%.\";\n-\t\t}\n-\t      else\n-\t\tret = \"mthi\\t%M1\\n\\tmtlo\\t%L1\";\n-\t    }\n-\n-\t  else if (GP_REG_P (regno0) && MD_REG_P (regno1))\n-\t    {\n-\t      delay = DELAY_HILO;\n-\t      if (TARGET_64BIT)\n-\t\t{\n-\t\t  if (regno1 != HILO_REGNUM)\n-\t\t    ret = \"mf%1\\t%0\";\n-\t\t}\n-\t      else\n-\t\tret = \"mfhi\\t%M0\\n\\tmflo\\t%L0\";\n-\t    }\n-\t  else if (GP_REG_P (regno0) && ALL_COP_REG_P (regno1)\n-\t\t   && TARGET_64BIT)\n-\t    {\n-\t      static char retval[] = \"dmfc_\\t%0,%1\";\n-\n-\t      delay = DELAY_LOAD;\n-\t      retval[4] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n-\t      ret = retval;\n-\t    }\n-\t  else if (ALL_COP_REG_P (regno0) && GP_REG_P (regno1)\n-\t\t   && TARGET_64BIT)\n-\t    {\n-\t      static char retval[] = \"dmtc_\\t%1,%0\";\n-\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n-\n-\t      if (cop == '0')\n-\t\tabort_with_insn (insn,\n-\t\t\t\t \"dmtc0 not supported; it disturbs virtual address translation\");\n-\t      delay = DELAY_LOAD;\n-\t      retval[4] = cop;\n-\t      ret = retval;\n-\t    }\n-\t  else if (TARGET_64BIT)\n-\t    ret = \"move\\t%0,%1\";\n-\n-\t  else if (regno0 != (regno1+1))\n-\t    ret = \"move\\t%0,%1\\n\\tmove\\t%D0,%D1\";\n-\n-\t  else\n-\t    ret = \"move\\t%D0,%D1\\n\\tmove\\t%0,%1\";\n-\t}\n-\n-      else if (code1 == CONST_DOUBLE)\n-\t{\n-\t  /* Move zero from $0 unless !TARGET_64BIT and recipient\n-\t     is 64-bit fp reg, in which case generate a constant.  */\n-\t  if (op1 != CONST0_RTX (GET_MODE (op1))\n-\t      || (TARGET_FLOAT64 && !TARGET_64BIT && FP_REG_P (regno0)))\n-\t    {\n-\t      if (GET_MODE (op1) == DFmode)\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\n-#ifdef TARGET_FP_CALL_32\n-\t\t  if (FP_CALL_GP_REG_P (regno0))\n-\t\t    {\n-\t\t      if (TARGET_FLOAT64 && !TARGET_64BIT)\n-\t\t\t{\n-\t\t\t  split_double (op1, operands + 2, operands + 3);\n-\t\t\t  ret = \"li\\t%0,%2\\n\\tli\\t%D0,%3\";\n-\t\t\t}\n-\t\t      else\n-\t\t\tret = \"li.d\\t%0,%1\\n\\tdsll\\t%D0,%0,32\\n\\tdsrl\\t%D0,32\\n\\tdsrl\\t%0,32\";\n-\t\t    }\n-\t\t  else\n-#endif\n-\t\t    /* GNU as emits 64-bit code for li.d if the ISA is 3\n-\t\t       or higher.  For !TARGET_64BIT && gp registers we\n-\t\t       need to avoid this by using two li instructions\n-\t\t       instead.  */\n-\t\t    if (ISA_HAS_64BIT_REGS\n-\t\t\t&& ! TARGET_64BIT\n-\t\t\t&& ! FP_REG_P (regno0))\n-\t\t      {\n-\t\t\tsplit_double (op1, operands + 2, operands + 3);\n-\t\t\tret = \"li\\t%0,%2\\n\\tli\\t%D0,%3\";\n-\t\t      }\n-\t\t    else\n-\t\t      ret = \"li.d\\t%0,%1\";\n-\t\t}\n-\n-\t      else if (TARGET_64BIT)\n-\t\t{\n-\t\t  if (! TARGET_MIPS16)\n-\t\t    ret = \"dli\\t%0,%1\";\n-\t\t}\n-\n-\t      else\n-\t\t{\n-\t\t  split_double (op1, operands + 2, operands + 3);\n-\t\t  ret = \"li\\t%0,%2\\n\\tli\\t%D0,%3\";\n-\t\t}\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      if (GP_REG_P (regno0))\n-\t\tret = (TARGET_64BIT\n-#ifdef TARGET_FP_CALL_32\n-\t\t       && ! FP_CALL_GP_REG_P (regno0)\n-#endif\n-\t\t       ? \"move\\t%0,%.\"\n-\t\t       : \"move\\t%0,%.\\n\\tmove\\t%D0,%.\");\n-\n-\t      else if (FP_REG_P (regno0))\n-\t\t{\n-\t\t  delay = DELAY_LOAD;\n-\t\t  ret = (TARGET_64BIT\n-\t\t\t ? \"dmtc1\\t%.,%0\"\n-\t\t\t : \"mtc1\\t%.,%0\\n\\tmtc1\\t%.,%D0\");\n-\t\t}\n-\t    }\n-\t}\n-\n-      else if (code1 == CONST_INT && INTVAL (op1) == 0 && ! TARGET_MIPS16)\n-\t{\n-\t  if (GP_REG_P (regno0))\n-\t    ret = (TARGET_64BIT\n-\t\t   ? \"move\\t%0,%.\"\n-\t\t   : \"move\\t%0,%.\\n\\tmove\\t%D0,%.\");\n-\n-\t  else if (FP_REG_P (regno0))\n-\t    {\n-\t      delay = DELAY_LOAD;\n-\t      ret = (TARGET_64BIT\n-\t\t     ? \"dmtc1\\t%.,%0\"\n-\t\t     : (TARGET_FLOAT64\n-\t\t\t? \"li.d\\t%0,%1\"\n-\t\t\t: \"mtc1\\t%.,%0\\n\\tmtc1\\t%.,%D0\"));\n-\t    }\n-\t  else if (MD_REG_P (regno0))\n-\t    {\n-\t      delay = DELAY_HILO;\n-\t      ret =  (regno0 == HILO_REGNUM\n-\t\t      ? \"mtlo\\t%.\\n\\tmthi\\t%.\"\n-\t\t      : \"mt%0\\t%.\\n\");\n-\t    }\n-\t}\n-\n-      else if (code1 == CONST_INT && GET_MODE (op0) == DImode\n-\t       && GP_REG_P (regno0))\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      if (TARGET_MIPS16)\n-\t\t{\n-\t\t  if (INTVAL (op1) >= 0 && INTVAL (op1) <= 0xffff)\n-\t\t    ret = \"li\\t%0,%1\";\n-\t\t  else if (INTVAL (op1) < 0 && INTVAL (op1) >= -0xffff)\n-\t\t    ret = \"li\\t%0,%n1\\n\\tneg\\t%0\";\n-\t\t}\n-\t      else if (GET_CODE (operands[1]) == SIGN_EXTEND)\n-\t\tret = \"li\\t%0,%1\\t\\t# %X1\";\n-\t      else if (HOST_BITS_PER_WIDE_INT < 64)\n-\t\t/* We can't use 'X' for negative numbers, because then we won't\n-\t\t   get the right value for the upper 32 bits.  */\n-\t\tret = (INTVAL (op1) < 0\n-\t\t       ? \"dli\\t%0,%1\\t\\t\\t# %X1\"\n-\t\t       : \"dli\\t%0,%X1\\t\\t# %1\");\n-\t      else\n-\t\t/* We must use 'X', because otherwise LONG_MIN will print as\n-\t\t   a number that the assembler won't accept.  */\n-\t\tret = \"dli\\t%0,%X1\\t\\t# %1\";\n-\t    }\n-\t  else if (HOST_BITS_PER_WIDE_INT < 64)\n-\t    {\n-\t      operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n-\t      if (TARGET_MIPS16)\n-\t\t{\n-\t\t  if (INTVAL (op1) >= 0 && INTVAL (op1) <= 0xffff)\n-\t\t    ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n-\t\t  else if (INTVAL (op1) < 0 && INTVAL (op1) >= -0xffff)\n-\t\t    {\n-\t\t      operands[2] = GEN_INT (1);\n-\t\t      ret = \"li\\t%M0,%2\\n\\tneg\\t%M0\\n\\tli\\t%L0,%n1\\n\\tneg\\t%L0\";\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We use multiple shifts here, to avoid warnings about out\n-\t\t of range shifts on 32 bit hosts.  */\n-\t      operands[2] = GEN_INT (INTVAL (operands[1]) >> 16 >> 16);\n-\t      operands[1]\n-\t\t= GEN_INT (INTVAL (operands[1]) << 16 << 16 >> 16 >> 16);\n-\t      if (TARGET_MIPS16)\n-\t\t{\n-\t\t  if (INTVAL (op1) >= 0 && INTVAL (op1) <= 0xffff)\n-\t\t    ret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n-\t\t  else if (INTVAL (op1) < 0 && INTVAL (op1) >= -0xffff)\n-\t\t    {\n-\t\t      operands[2] = GEN_INT (1);\n-\t\t      ret = \"li\\t%M0,%2\\n\\tneg\\t%M0\\n\\tli\\t%L0,%n1\\n\\tneg\\t%L0\";\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tret = \"li\\t%M0,%2\\n\\tli\\t%L0,%1\";\n-\t    }\n-\t}\n-\n-      else if (code1 == MEM)\n-\t{\n-\t  delay = DELAY_LOAD;\n-\n-\t  if (TARGET_STATS)\n-\t    mips_count_memory_refs (op1, 2);\n-\n-\t  if (FP_REG_P (regno0))\n-\t    ret = (TARGET_64BIT ? \"ldc1\\t%0,%1\" : \"l.d\\t%0,%1\");\n-\n-\t  else if (ALL_COP_REG_P (regno0) && TARGET_64BIT)\n-\t    {\n-\t      static char retval[] = \"ldc_\\t%0,%1\";\n-\t      char cop = COPNUM_AS_CHAR_FROM_REGNUM (regno0);\n-\n-\t      if (cop == '0')\n-\t\tabort_with_insn (insn,\n-\t\t\t\t \"loads from memory to COP0 are illegal\");\n-\t      delay = DELAY_LOAD;\n-\t      retval[3] = cop;\n-\t      ret = retval;\n-\t    }\n-\n-\t  else if (TARGET_64BIT)\n-\t    {\n-\n-#ifdef TARGET_FP_CALL_32\n-\t      if (FP_CALL_GP_REG_P (regno0))\n-\t\tret = \"lwu\\t%0,%1\\n\\tlwu\\t%D0,4+%1\";\n-\t      else\n-#endif\n-\t\tret = \"ld\\t%0,%1\";\n-\t    }\n-\n-\t  else\n-\t    ret = (reg_mentioned_p (op0, op1)\n-\t\t   ? \"lw\\t%D0,%D1\\n\\tlw\\t%0,%1\"\n-\t\t   : \"lw\\t%0,%1\\n\\tlw\\t%D0,%D1\");\n-\n-\t  if (ret != 0 && MEM_VOLATILE_P (op1))\n-\t    {\n-\t      size_t i = strlen (ret);\n-\n-\t      if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n-\t\tabort ();\n-\n-\t      sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n-\t      ret = volatile_buffer;\n-\t    }\n-\t}\n-      else if (code1 == HIGH)\n-\t{\n-\t  operands[1] = XEXP (op1, 0);\n-\t  ret = \"lui\\t%0,%%hi(%1)\";\n-\t}\n-      else\n-\tswitch (mips_classify_constant (&c, op1))\n-\t  {\n-\t  case CONSTANT_NONE:\n-\t    break;\n-\n-\t  case CONSTANT_GP:\n-\t    ret = \"move\\t%0,%1\";\n-\t    break;\n-\n-\t  case CONSTANT_RELOC:\n-\t    ret = (TARGET_MIPS16 ? \"li\\t%0,0\\n\\taddiu\\t%0,%1\" : \"li\\t%0,%1\");\n-\t    break;\n-\n-\t  case CONSTANT_SYMBOLIC:\n-\t    if (TARGET_STATS)\n-\t      mips_count_memory_refs (op1, 2);\n-\t    ret = \"dla\\t%0,%a1\";\n-\t    break;\n-\t  }\n-    }\n-\n-  else if (code0 == MEM)\n-    {\n-      if (code1 == REG)\n-\t{\n-\t  int regno1 = REGNO (op1) + subreg_offset1;\n-\n-\t  if (FP_REG_P (regno1))\n-\t    ret = (TARGET_64BIT ? \"sdc1\\t%1,%0\" : \"s.d\\t%1,%0\");\n-\n-\t  else if (ALL_COP_REG_P (regno1) && TARGET_64BIT)\n-\t    {\n-\t      static char retval[] = \"sdc_\\t%1,%0\";\n-\n-\t      retval[3] = COPNUM_AS_CHAR_FROM_REGNUM (regno1);\n-\t      ret = retval;\n-\t    }\n-\t  else if (TARGET_64BIT)\n-\t    {\n-\n-#ifdef TARGET_FP_CALL_32\n-\t      if (FP_CALL_GP_REG_P (regno1))\n-\t\tret = \"dsll\\t%1,32\\n\\tor\\t%1,%D1\\n\\tsd\\t%1,%0\";\n-\t      else\n-#endif\n-\t\tret = \"sd\\t%1,%0\";\n-\t    }\n-\n-\t  else\n-\t    ret = \"sw\\t%1,%0\\n\\tsw\\t%D1,%D0\";\n-\t}\n-\n-      else if (((code1 == CONST_INT && INTVAL (op1) == 0)\n-\t\t|| (code1 == CONST_DOUBLE\n-\t\t    && op1 == CONST0_RTX (GET_MODE (op1)))))\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    ret = \"sd\\t%.,%0\";\n-\t  else\n-\t    ret = \"sw\\t%.,%0\\n\\tsw\\t%.,%D0\";\n-\t}\n-\n-      if (TARGET_STATS)\n-\tmips_count_memory_refs (op0, 2);\n-\n-      if (ret != 0 && MEM_VOLATILE_P (op0))\n-\t{\n-\t  size_t i = strlen (ret);\n-\n-\t  if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n-\t    abort ();\n-\n-\t  sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n-\t  ret = volatile_buffer;\n-\t}\n-    }\n-\n-  if (ret == 0)\n-    {\n-      abort_with_insn (insn, \"bad move\");\n-      return 0;\n-    }\n-\n-  if (delay != DELAY_NONE)\n-    return mips_fill_delay_slot (ret, delay, operands, insn);\n-\n-  return ret;\n-}\n \f\n /* Make normal rtx_code into something we can index from an array */\n \n@@ -6622,6 +6023,7 @@ mips_debugger_offset (addr, offset)\n \n    'X'  X is CONST_INT, prints 32 bits in hexadecimal format = \"0x%08x\",\n    'x'  X is CONST_INT, prints 16 bits in hexadecimal format = \"0x%04x\",\n+   'h'  X is HIGH, prints %hi(X),\n    'd'  output integer constant in decimal,\n    'z'\tif the operand is 0, use $0 instead of normal operand.\n    'D'  print second part of double-word register or memory operand.\n@@ -6814,6 +6216,15 @@ print_operand (file, op, letter)\n       fputc (')', file);\n     }\n \n+  else if (letter == 'h')\n+    {\n+      if (GET_CODE (op) != HIGH)\n+\tabort ();\n+      fputs (\"%hi(\", file);\n+      output_addr_const (file, XEXP (op, 0));\n+      fputc (')', file);\n+    }\n+\n   else if (letter == 'C')\n     switch (code)\n       {\n@@ -6914,15 +6325,6 @@ print_operand (file, op, letter)\n \toutput_address (XEXP (op, 0));\n     }\n \n-  else if (code == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT)\n-    {\n-      char s[60];\n-\n-      real_to_decimal (s, CONST_DOUBLE_REAL_VALUE (op), sizeof (s), 0, 1);\n-      fputs (s, file);\n-    }\n-\n   else if (letter == 'x' && GET_CODE (op) == CONST_INT)\n     fprintf (file, HOST_WIDE_INT_PRINT_HEX, 0xffff & INTVAL(op));\n \n@@ -6932,7 +6334,7 @@ print_operand (file, op, letter)\n   else if (letter == 'd' && GET_CODE(op) == CONST_INT)\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC, (INTVAL(op)));\n \n-  else if (letter == 'z' && GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+  else if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))\n     fputs (reg_names[GP_REG_FIRST], file);\n \n   else if (letter == 'd' || letter == 'x' || letter == 'X')\n@@ -7815,32 +7217,32 @@ mips_add_large_offset_to_sp (offset)\n   return reg;\n }\n \n-/* Make INSN frame related and note that it performs the frame-related\n-   operation DWARF_PATTERN.  */\n+/* Make the last instruction frame related and note that it performs\n+   the operation described by FRAME_PATTERN.  */\n \n static void\n-mips_annotate_frame_insn (insn, dwarf_pattern)\n-     rtx insn, dwarf_pattern;\n+mips_set_frame_expr (frame_pattern)\n+     rtx frame_pattern;\n {\n+  rtx insn;\n+\n+  insn = get_last_insn ();\n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t      dwarf_pattern,\n+\t\t\t\t      frame_pattern,\n \t\t\t\t      REG_NOTES (insn));\n }\n \n-/* Return a frame-related rtx that stores register REGNO at (SP + OFFSET).\n-   The expression should only be used to store single registers.  */\n+/* Return a frame-related rtx that stores REG at (SP + OFFSET).\n+   REG must be a single register.  */\n \n static rtx\n-mips_frame_set (mode, regno, offset)\n-     enum machine_mode mode;\n-     int regno;\n+mips_frame_set (reg, offset)\n+     rtx reg;\n      int offset;\n {\n   rtx address = plus_constant (stack_pointer_rtx, offset);\n-  rtx set = gen_rtx_SET (mode,\n-\t\t\t gen_rtx_MEM (mode, address),\n-\t\t\t gen_rtx_REG (mode, regno));\n+  rtx set = gen_rtx_SET (VOIDmode, gen_rtx_MEM (GET_MODE (reg), address), reg);\n   RTX_FRAME_RELATED_P (set) = 1;\n   return set;\n }\n@@ -7856,24 +7258,24 @@ mips_emit_frame_related_store (mem, reg, offset)\n      rtx reg;\n      HOST_WIDE_INT offset;\n {\n-  rtx dwarf_expr;\n+  if (GET_MODE (reg) == DFmode && mips_split_64bit_move_p (mem, reg))\n+    mips_split_64bit_move (mem, reg);\n+  else\n+    emit_move_insn (mem, reg);\n \n-  if (GET_MODE (reg) == DFmode && ! TARGET_FLOAT64)\n+  if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n     {\n+      rtx x1, x2;\n+\n       /* Two registers are being stored, so the frame-related expression\n-\t must be a PARALLEL rtx with one SET for each register.  The\n-\t higher numbered register is stored in the lower address on\n-\t big-endian targets.  */\n-      int regno1 = TARGET_BIG_ENDIAN ? REGNO (reg) + 1 : REGNO (reg);\n-      int regno2 = TARGET_BIG_ENDIAN ? REGNO (reg) : REGNO (reg) + 1;\n-      rtx set1 = mips_frame_set (SFmode, regno1, offset);\n-      rtx set2 = mips_frame_set (SFmode, regno2, offset + UNITS_PER_FPREG);\n-      dwarf_expr = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2));\n+\t must be a PARALLEL rtx with one SET for each register.  */\n+      x1 = mips_frame_set (mips_subword (reg, TARGET_BIG_ENDIAN), offset);\n+      x2 = mips_frame_set (mips_subword (reg, !TARGET_BIG_ENDIAN),\n+\t\t\t   offset + UNITS_PER_FPREG);\n+      mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n     }\n   else\n-    dwarf_expr = mips_frame_set (GET_MODE (reg), REGNO (reg), offset);\n-\n-  mips_annotate_frame_insn (emit_move_insn (mem, reg), dwarf_expr);\n+    mips_set_frame_expr (mips_frame_set (reg, offset));\n }\n \n static void\n@@ -8549,7 +7951,7 @@ mips_expand_prologue ()\n       if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \t  && (!TARGET_MIPS16 || tsize <= 32767))\n \t{\n-\t  rtx adjustment_rtx, insn, dwarf_pattern;\n+\t  rtx adjustment_rtx;\n \n \t  if (tsize > 32767)\n \t    {\n@@ -8560,17 +7962,15 @@ mips_expand_prologue ()\n \t    adjustment_rtx = tsize_rtx;\n \n \t  if (Pmode == DImode)\n-\t    insn = emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t  adjustment_rtx));\n+\t    emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   adjustment_rtx));\n \t  else\n-\t    insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t  adjustment_rtx));\n-\n-\t  dwarf_pattern = gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      -tsize));\n+\t    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   adjustment_rtx));\n \n-\t  mips_annotate_frame_insn (insn, dwarf_pattern);\n+\t  mips_set_frame_expr\n+\t    (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t  plus_constant (stack_pointer_rtx, -tsize)));\n \t}\n \n       if (! mips_entry)"}, {"sha": "bef64a8a3a9d224b00e55482da5f9b7720ba1d37", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=5b0f0db6d9533eed15c6868a5f57d92196e3264f", "patch": "@@ -1935,6 +1935,8 @@ do {\t\t\t\t\t\t\t\\\n #define ALL_COP_REG_P(REGNO) \\\n   ((unsigned int) ((int) (REGNO) - COP0_REG_FIRST) < ALL_COP_REG_NUM)\n \n+#define FP_REG_RTX_P(X) (GET_CODE (X) == REG && FP_REG_P (REGNO (X)))\n+\n /* Return coprocessor number from register number.  */\n \n #define COPNUM_AS_CHAR_FROM_REGNUM(REGNO) \t\t\t\t\\"}, {"sha": "876f0dbd31600c78d12ee72618f341bc59de8a44", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 147, "deletions": 129, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b0f0db6d9533eed15c6868a5f57d92196e3264f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=5b0f0db6d9533eed15c6868a5f57d92196e3264f", "patch": "@@ -27,7 +27,10 @@\n ;; Must include new entries for fmadd in addition to existing entries.\n \n (define_constants\n-  [(UNSPEC_GET_FNADDR\t\t 4)\n+  [(UNSPEC_LOAD_DF_LOW\t\t 0)\n+   (UNSPEC_LOAD_DF_HIGH\t\t 1)\n+   (UNSPEC_STORE_DF_HIGH\t 2)\n+   (UNSPEC_GET_FNADDR\t\t 4)\n    (UNSPEC_HILO_DELAY\t\t 5)\n    (UNSPEC_BLOCKAGE\t\t 6)\n    (UNSPEC_LOADGP\t\t 7)\n@@ -1920,20 +1923,10 @@\n    (clobber (match_scratch:SI 4 \"=l\"))\n    (clobber (match_scratch:SI 5 \"=a\"))]\n   \"TARGET_MIPS4000 && !TARGET_MIPS16\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = gen_rtx_REG (SImode, LO_REGNUM);\n-\n-  output_asm_insn (\\\"mult\\\\t%1,%2\\\", operands);\n-  output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-  return \\\"\\\";\n-}\"\n+  \"mult\\t%1,%2\\;mflo\\t%0\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"   \"12\")])\t\t;; mult + mflo + delay\n+   (set_attr \"length\"   \"8\")])\n \n ;; Multiply-accumulate patterns\n \n@@ -2307,28 +2300,18 @@\n    (clobber (match_scratch:DI 4 \"=l\"))\n    (clobber (match_scratch:DI 5 \"=a\"))]\n   \"TARGET_64BIT && (GENERATE_MULT3_DI || TARGET_MIPS4000 || TARGET_MIPS16)\"\n-  \"*\n-{\n-  if (GENERATE_MULT3_DI)\n-    output_asm_insn (\\\"dmult\\\\t%0,%1,%2\\\", operands);\n-  else\n-    {\n-      rtx xoperands[10];\n-\n-      xoperands[0] = operands[0];\n-      xoperands[1] = gen_rtx_REG (DImode, LO_REGNUM);\n-\n-      output_asm_insn (\\\"dmult\\\\t%1,%2\\\", operands);\n-      output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-    }\n-  return \\\"\\\";\n-}\"\n+  {\n+    if (GENERATE_MULT3_DI)\n+      return \"dmult\\t%0,%1,%2\";\n+    else\n+      return \"dmult\\t%1,%2\\n\\tmflo\\t%0\";\n+  }\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"DI\")\n    (set (attr \"length\")\n \t(if_then_else (ne (symbol_ref \"GENERATE_MULT3_DI\") (const_int 0))\n-\t\t       (const_int 4)\n-\t\t       (const_int 12)))]) \t;; mult + mflo + delay\n+\t\t      (const_int 4)\n+\t\t      (const_int 8)))])\n \n ;; ??? We could define a mulditi3 pattern when TARGET_64BIT.\n \n@@ -4300,23 +4283,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"     \"DI\")\n    (set_attr \"length\"   \"4,*\")])\n \n-;; These can be created when a paradoxical subreg operand with an implicit\n-;; sign_extend operator is reloaded.  Because of the subreg, this is really\n-;; a zero extend.\n-;; ??? It might be possible to eliminate the need for these patterns by adding\n-;; more support to reload for implicit sign_extend operators.\n-(define_insn \"*paradoxical_extendhidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:DI\n-\t (subreg:SI (match_operand:HI 1 \"memory_operand\" \"m\") 0)))]\n-  \"TARGET_64BIT\"\n-  \"*\n-{\n-  return mips_move_1word (operands, insn, TRUE);\n-}\"\n-  [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(zero_extend:DI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n@@ -5114,11 +5080,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n \t(reg:DI 31))]\n   \"TARGET_MIPS16 && TARGET_64BIT\"\n-  \"*\n-{\n-  operands[1] = gen_rtx (REG, DImode, 31);\n-  return mips_move_2words (operands, insn);\n-}\"\n+  \"sd\\t$31,%0\"\n   [(set_attr \"type\"\t\"store\")\n    (set_attr \"mode\"\t\"DI\")])\n \n@@ -5130,7 +5092,7 @@ move\\\\t%0,%z4\\\\n\\\\\n        || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n-  \"* return mips_move_2words (operands, insn); \"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,arith,load,store,hilo,hilo,hilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"   \"8,16,*,*,8,8,8,8,*,8,*\")])\n@@ -5141,23 +5103,11 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_64BIT && TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n-  \"* return mips_move_2words (operands, insn);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,hilo\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operand:DI 1 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n-\n-  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n-   (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n-  \"\")\n-\n (define_insn \"movdi_internal2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*d,*x,*a,*B*C*D,*B*C*D,*d,*m\")\n \t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J,*x,*d,*J,*d,*m,*B*C*D,*B*C*D\"))]\n@@ -5166,31 +5116,18 @@ move\\\\t%0,%z4\\\\n\\\\\n        || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n-  \"* return mips_move_2words (operands, insn); \"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,hilo,hilo,hilo,hilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,8,8,*,8,*\")])\n \n-;; Sign-extended operands are reloaded using this instruction, so the\n-;; constraints must handle every SImode source operand X and destination\n-;; register R for which:\n-;;\n-;;     mips_secondary_reload_class (CLASS_OF (R), DImode, true,\n-;;\t\t\t\t    gen_rtx_SIGN_EXTEND (DImode, X))\n-;;\n-;; returns NO_REGS.  Also handle memory destinations, where allowed.\n-;;\n-;; This pattern is essentially a trimmed-down version of movdi_internal2.\n-;; The main difference is that dJ -> f and f -> d are the only constraints\n-;; involving float registers.  See mips_secondary_reload_class for details.\n-\n (define_insn \"*movdi_internal2_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m,*d\")\n \t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,U,m,d,*x\"))]\n   \"TARGET_64BIT && TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n-  \"* return mips_move_2words (operands, insn);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,move,arith,arith,const,load,store,hilo\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr_alternative \"length\"\n@@ -5478,7 +5415,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,const,const,load,store,move,xfer,load,xfer,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,4,4,*,4,*\")])\n@@ -5489,7 +5426,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,move,arith,arith,const,load,store,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr_alternative \"length\"\n@@ -5575,7 +5512,7 @@ move\\\\t%0,%z4\\\\n\\\\\n }\")\n \n ;; On the mips16, we can split a load of a negative constant into a\n-;; load and a neg.  That's what mips_move_1word will generate anyhow.\n+;; load and a neg.  That's what mips_output_move will generate anyhow.\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -5753,7 +5690,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (match_operand:CC 0 \"nonimmediate_operand\" \"=d,*d,*d,*m,*d,*f,*f,*f,*m\")\n \t(match_operand:CC 1 \"general_operand\" \"z,*d,*m,*d,*f,*d,*f,*m,*f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,load,store,xfer,xfer,move,load,store\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"8,4,*,*,4,4,4,*,*\")])\n@@ -5917,13 +5854,22 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f*z,*f,*x,*d\")\n-\t(match_operand:HI 1 \"general_operand\"       \"d,IK,m,dJ,*f*z,*d,*f,*d,*x\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n+\t(match_operand:HI 1 \"general_operand\"       \"d,IK,m,dJ,*f,*d,*f,*d,*x\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  \"@\n+    move\\t%0,%1\n+    li\\t%0,%1\n+    lhu\\t%0,%1\n+    sh\\t%z1,%0\n+    mfc1\\t%0,%1\n+    mtc1\\t%1,%0\n+    mov.s\\t%0,%1\n+    mt%0\\t%1\n+    mf%1\\t%0\"\n   [(set_attr \"type\"\t\"move,arith,load,store,xfer,xfer,move,hilo,hilo\")\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr \"length\"\t\"4,4,*,*,4,4,4,4,4\")])\n@@ -5934,7 +5880,15 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  \"@\n+    move\\t%0,%1\n+    move\\t%0,%1\n+    move\\t%0,%1\n+    li\\t%0,%1\n+    li\\t%0,%n1\\;neg\\t%0\n+    lhu\\t%0,%1\n+    sh\\t%1,%0\n+    mf%1\\t%0\"\n   [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,hilo\")\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr_alternative \"length\"\n@@ -6025,13 +5979,22 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f*z,*f,*x,*d\")\n-\t(match_operand:QI 1 \"general_operand\"       \"d,IK,m,dJ,*f*z,*d,*f,*d,*x\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n+\t(match_operand:QI 1 \"general_operand\"       \"d,IK,m,dJ,*f,*d,*f,*d,*x\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  \"@\n+    move\\t%0,%1\n+    li\\t%0,%1\n+    lbu\\t%0,%1\n+    sb\\t%z1,%0\n+    mfc1\\t%0,%1\n+    mtc1\\t%1,%0\n+    mov.s\\t%0,%1\n+    mt%0\\t%1\n+    mf%1\\t%0\"\n   [(set_attr \"type\"\t\"move,arith,load,store,xfer,xfer,move,hilo,hilo\")\n    (set_attr \"mode\"\t\"QI\")\n    (set_attr \"length\"\t\"4,4,*,*,4,4,4,4,4\")])\n@@ -6042,23 +6005,18 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n+  \"@\n+    move\\t%0,%1\n+    move\\t%0,%1\n+    move\\t%0,%1\n+    li\\t%0,%1\n+    li\\t%0,%n1\\;neg\\t%0\n+    lbu\\t%0,%1\n+    sb\\t%1,%0\n+    mf%1\\t%0\"\n   [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,hilo\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (const_int 4)\n-\t\t (const_int 4)\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_uimm8_1\" \"\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_nuimm8_1\" \"\")\n-\t\t\t       (const_int 8)\n-\t\t\t       (const_int 12))\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n-\n+   (set_attr \"length\"\t\"4,4,4,4,8,*,*,4\")])\n \n ;; On the mips16, we can split lb $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -6111,7 +6069,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_HARD_FLOAT\n    && (register_operand (operands[0], SFmode)\n        || nonmemory_operand (operands[1], SFmode))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,xfer,load,store,xfer,xfer,move,load,store\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4,4,*,*,4,4,4,*,*\")])\n@@ -6122,7 +6080,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_SOFT_FLOAT && !TARGET_MIPS16\n    && (register_operand (operands[0], SFmode)\n        || nonmemory_operand (operands[1], SFmode))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,load,store\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4,*,*\")])\n@@ -6133,7 +6091,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,move,load,store\")\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4,4,4,*,*\")])\n@@ -6159,54 +6117,114 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_64BIT\n    && (register_operand (operands[0], DFmode)\n        || nonmemory_operand (operands[1], DFmode))\"\n-  \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,move,load,store,xfer,xfer,move,load,store\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,xfer,load,store,xfer,xfer,move,load,store\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,8,*,*,4,4,4,*,*\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4,4,*,*\")])\n \n (define_insn \"movdf_internal1b\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,*f,*d,*d,*d,*m\")\n \t(match_operand:DF 1 \"general_operand\" \"f,G,m,fG,*d,*f,*d*G,*m,*d\"))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\n    && (register_operand (operands[0], DFmode)\n        || nonmemory_operand (operands[1], DFmode))\"\n-  \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,move,load,store,xfer,xfer,move,load,store\")\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\"\t\"move,xfer,load,store,xfer,xfer,move,load,store\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"4,8,*,*,8,8,8,*,*\")])\n \n (define_insn \"movdf_internal2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,m,d,f,f\")\n-\t(match_operand:DF 1 \"general_operand\" \"dG,m,d,f,d,f\"))]\n+\t(match_operand:DF 1 \"general_operand\" \"dG,m,dG,f,d,f\"))]\n   \"(TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT) && !TARGET_MIPS16\n    && (register_operand (operands[0], DFmode)\n        || nonmemory_operand (operands[1], DFmode))\"\n-  \"* return mips_move_2words (operands, insn); \"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,load,store,xfer,xfer,move\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"8,*,*,8,8,4\")])\n+   (set_attr \"length\"\t\"8,*,*,4,4,4\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,y,d,d,m\")\n \t(match_operand:DF 1 \"nonimmediate_operand\" \"d,d,y,m,d\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n-  \"* return mips_move_2words (operands, insn);\"\n+  { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\"\t\"move,move,move,load,store\")\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"8,8,8,*,*\")])\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(match_operand:DF 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"reload_completed && !TARGET_64BIT\n-   && !TARGET_DEBUG_D_MODE && !TARGET_DEBUG_G_MODE\n-   && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n-   && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n-  [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n-   (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n-  \"\")\n+   && mips_split_64bit_move_p (operands[0], operands[1])\"\n+  [(const_int 0)]\n+  {\n+    mips_split_64bit_move (operands[0], operands[1]);\n+    DONE;\n+  })\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"reload_completed && !TARGET_64BIT\n+   && mips_split_64bit_move_p (operands[0], operands[1])\"\n+  [(const_int 0)]\n+  {\n+    mips_split_64bit_move (operands[0], operands[1]);\n+    DONE;\n+  })\n+\n+;; Patterns for loading or storing part of a paired floating point\n+;; register.  We need them because odd-numbered floating-point registers\n+;; are not fully independent: see mips_split_64bit_move.\n+\n+;; Load the low word of operand 0 with operand 1.\n+(define_insn \"load_df_low\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ,m\")]\n+\t\t   UNSPEC_LOAD_DF_LOW))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+  {\n+    operands[0] = mips_subword (operands[0], 0);\n+    return mips_output_move (operands[0], operands[1]);\n+  }\n+  [(set_attr \"type\"\t\"xfer,load\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+;; Load the high word of operand 0 from operand 1, preserving the value\n+;; in the low word.\n+(define_insn \"load_df_high\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ,m\")\n+\t\t    (match_operand:DF 2 \"register_operand\" \"0,0\")]\n+\t\t   UNSPEC_LOAD_DF_HIGH))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+  {\n+    operands[0] = mips_subword (operands[0], 1);\n+    return mips_output_move (operands[0], operands[1]);\n+  }\n+  [(set_attr \"type\"\t\"xfer,load\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+;; Store the high word of operand 1 in operand 0.  The corresponding\n+;; low-word move is done in the normal way.\n+(define_insn \"store_df_high\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(unspec:SI [(match_operand:DF 1 \"register_operand\" \"f,f\")]\n+\t\t   UNSPEC_STORE_DF_HIGH))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+  {\n+    operands[1] = mips_subword (operands[1], 1);\n+    return mips_output_move (operands[0], operands[1]);\n+  }\n+  [(set_attr \"type\"\t\"xfer,store\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"4\")])\n \n ;; Instructions to load the global pointer register.\n ;; This is volatile to make sure that the scheduler won't move any symbol_ref\n@@ -9808,7 +9826,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n (define_insn \"exception_receiver\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_EH_RECEIVER)]\n   \"TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64)\"\n-  \"* return mips_restore_gp (operands, insn);\"\n+  { return mips_restore_gp (operands); }\n   [(set_attr \"type\"   \"load\")\n    (set_attr \"length\" \"8\")])\n \f"}]}