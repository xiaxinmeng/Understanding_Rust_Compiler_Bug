{"sha": "46468cd96fb7916bec2ac3f1189e1805c543bece", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0NjhjZDk2ZmI3OTE2YmVjMmFjM2YxMTg5ZTE4MDVjNTQzYmVjZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-04-19T00:14:49Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-04-19T00:14:49Z"}, "message": "real.h: Define REAL_VALUE_TYPE_SIZE as 96 or 160, as appropriate.\n\n\t* real.h: Define REAL_VALUE_TYPE_SIZE as 96 or 160, as\n\tappropriate.  Document need for extended precision even when\n\tMAX_LONG_DOUBLE_TYPE_SIZE is smaller.  Define REAL_WIDTH here,\n\tbased on REAL_VALUE_TYPE_SIZE.  Use REAL_WIDTH to size\n\tREAL_VALUE_TYPE.  Define CONST_DOUBLE_FORMAT here.  Use #error\n\tinstead of relying on later syntax error when REAL_WIDTH > 5.\n\t* real.c: Define NE based only on whether or not we have a\n\tfull 128-bit extended type (not INTEL_EXTENDED_IEEE_FORMAT).\n\tRequire sizeof(REAL_VALUE_TYPE) == 2*NE.  Unconditionally\n\tdefine GET_REAL and PUT_REAL as simple memcpy operations; no\n\tneed to byteswap or round.\n\tUse #error instead of #ifdef-ing out the entire file, for\n\tprompt error detection.\n\n\t* rtl.c, gengenrtl.c: No need to calculate CONST_DOUBLE_FORMAT here.\n\nFrom-SVN: r52502", "tree": {"sha": "b1368d46e39903775acd3d13ff8c740e88165781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1368d46e39903775acd3d13ff8c740e88165781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46468cd96fb7916bec2ac3f1189e1805c543bece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46468cd96fb7916bec2ac3f1189e1805c543bece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46468cd96fb7916bec2ac3f1189e1805c543bece", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46468cd96fb7916bec2ac3f1189e1805c543bece/comments", "author": null, "committer": null, "parents": [{"sha": "36ce7daa0448f03228d99bc6a081f693cd04ba48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ce7daa0448f03228d99bc6a081f693cd04ba48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ce7daa0448f03228d99bc6a081f693cd04ba48"}], "stats": {"total": 344, "additions": 109, "deletions": 235}, "files": [{"sha": "33c7b5bb47b481b9ed8c2519a4c3c5296fbfebf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46468cd96fb7916bec2ac3f1189e1805c543bece", "patch": "@@ -1,3 +1,21 @@\n+2002-04-18  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* real.h: Define REAL_VALUE_TYPE_SIZE as 96 or 160, as\n+\tappropriate.  Document need for extended precision even when\n+\tMAX_LONG_DOUBLE_TYPE_SIZE is smaller.  Define REAL_WIDTH here,\n+\tbased on REAL_VALUE_TYPE_SIZE.  Use REAL_WIDTH to size\n+\tREAL_VALUE_TYPE.  Define CONST_DOUBLE_FORMAT here.  Use #error\n+\tinstead of relying on later syntax error when REAL_WIDTH > 5.\n+\t* real.c: Define NE based only on whether or not we have a\n+\tfull 128-bit extended type (not INTEL_EXTENDED_IEEE_FORMAT).\n+\tRequire sizeof(REAL_VALUE_TYPE) == 2*NE.  Unconditionally\n+\tdefine GET_REAL and PUT_REAL as simple memcpy operations; no\n+\tneed to byteswap or round.\n+\tUse #error instead of #ifdef-ing out the entire file, for\n+\tprompt error detection.\n+\n+\t* rtl.c, gengenrtl.c: No need to calculate CONST_DOUBLE_FORMAT here.\n+\n 2002-04-18  David S. Miller  <davem@redhat.com>\n \n \t* config/sparc/sparc.h (BRANCH_COST): Define.\n@@ -17,17 +35,17 @@\n \t* config/ia64/ia64.c (ia64_function_arg_pass_by_reference): New.\n \t(ia64_va_arg): Expect variable sized types by reference.\n \t* config/ia64/ia64-protos.h: Update.\n-\t* config/ia64/ia64.h (FUNCTION_ARG_PASS_BY_REFERENCE): Use \n+\t* config/ia64/ia64.h (FUNCTION_ARG_PASS_BY_REFERENCE): Use\n \tia64_function_arg_pass_by_reference.\n \n 2002-04-18  Richard Henderson  <rth@redhat.com>\n \n-        * ifcvt.c: Include except.h.\n-        (block_has_only_trap): Break out from find_cond_trap.\n-        (find_cond_trap): Use it.  Always delete the trap block.\n-        (merge_if_block): Allow then block null.  Be less simplistic about\n-        what insns can end a block.\n-        * Makefile.in (ifcvt.o): Depend on except.h.\n+\t* ifcvt.c: Include except.h.\n+\t(block_has_only_trap): Break out from find_cond_trap.\n+\t(find_cond_trap): Use it.  Always delete the trap block.\n+\t(merge_if_block): Allow then block null.  Be less simplistic about\n+\twhat insns can end a block.\n+\t* Makefile.in (ifcvt.o): Depend on except.h.\n \n \t* config/ia64/ia64.md (trap, conditional_trap): New.\n \n@@ -94,7 +112,7 @@ Thu Apr 18 15:49:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* combine.c (subst): Avoid trying to make a vector mode subreg of\n \tan integer constant.\n \t(gen_lowpart_for_combine): Likewise.\n-\t\t\t\n+\n 2002-04-18  Roger Sayle  <roger@eyesopen.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n \n@@ -163,21 +181,21 @@ Thu Apr 18 15:49:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-04-17  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/altivec.h (vec_ld): Add array variants.\n-        (vec_lde): Same.\n-        (vec_ldl): Same.\n+\t* config/rs6000/altivec.h (vec_ld): Add array variants.\n+\t(vec_lde): Same.\n+\t(vec_ldl): Same.\n \n 2002-04-17  Alan Matsuoka  <alanm@redhat.com>\n-            Aldy Hernandez <aldyh@redhat.com>\n+\t    Aldy Hernandez <aldyh@redhat.com>\n \n-        * config/rs6000/altivec.h: Define __ALTIVEC__.\n-        (bool): New.\n-        (__pixel): New.\n-        (pixel): New.\n-        (vec_cfux): New.\n-        (vec_vmaddfp): New.\n-        (vec_vsldoi): New.\n-        Add parentheses to all macro arguments.\n+\t* config/rs6000/altivec.h: Define __ALTIVEC__.\n+\t(bool): New.\n+\t(__pixel): New.\n+\t(pixel): New.\n+\t(vec_cfux): New.\n+\t(vec_vmaddfp): New.\n+\t(vec_vsldoi): New.\n+\tAdd parentheses to all macro arguments.\n \n 2002-04-16  Richard Henderson  <rth@redhat.com>\n \n@@ -233,7 +251,7 @@ Thu Apr 18 15:49:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \tPR target/6305\n \t* config/s390/s390.md (mulsidi3): Set both subregs of the\n-\tmultiword register. \n+\tmultiword register.\n \n 2002-04-16  Aldy Hernandez  <aldyh@redhat.com>\n \n@@ -272,7 +290,7 @@ Thu Apr 18 15:49:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tthe only supported ways to configure gcc.\n \n 2002-04-15  Roland McGrath  <roland@frob.com>\n- \n+\n \t* config.gcc (alpha*-*-gnu*): New target configuration.\n \t* config/alpha/gnu.h: New file for it.\n \t* config/gnu.h (TARGET_MEM_FUNCTIONS): #undef before #define.\n@@ -285,7 +303,7 @@ Thu Apr 18 15:49:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* stmt.c (expand_start_stmt_expr): Add has_scope parameter.\n \t* tree-inline.c (expand_call_inline): Set STMT_EXPR_NO_SCOPE\n \ton the STMT_EXPR created for the inline function.\n-\t\n+\n 2002-04-15  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/linux.h, config/arm/linux-elf.h, config/i370/linux.h,\n@@ -526,7 +544,7 @@ Fri Apr 12 15:42:59 2002  Jeffrey A Law  (law@redhat.com)\n \t* config/ia64/ia64.h (ASM_SPEC): Moved from here ...\n \t* config/ia64/sysv4.h (ASM_SPEC): ... to here, so that it\n \toverrides the definition in config/svr4.h.\n-\t\n+\n 2002-04-12\tEric Norum <eric.norum@usask.ca>\n \n \t* config/rtems.h, config/a29k/rtems.h, config/arm/rtems-elf.h,\n@@ -574,7 +592,7 @@ Fri Apr 12 10:51:38 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* flow.c (mark_used_reg): Manage reg_cond_dead properly for\n \tmodes spanning multiple hard regs.\n-    \n+\n \t* recog.c (peephole2_optimize): Rebuild jump labels as needed.\n \n 2002-04-11  John David Anglin  <dave@hiauly1.hia.nrc.ca>"}, {"sha": "5795d32edb0938ca3c0009218b06770d9813da9e", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=46468cd96fb7916bec2ac3f1189e1805c543bece", "patch": "@@ -28,69 +28,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"real.h\"\n \n-/* Calculate the format for CONST_DOUBLE.  This depends on the relative\n-   widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n-\n-   We need to go out to e0wwwww, since real.c assumes 16 bits per element\n-   in REAL_VALUE_TYPE.\n-\n-   This is duplicated in rtl.c.\n-\n-   A number of places assume that there are always at least two 'w'\n-   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n-\n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n-# define REAL_WIDTH\t\\\n-     (11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#else\n-# if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n-#  define REAL_WIDTH\t\\\n-     (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-# else\n-#  if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-#   define REAL_WIDTH\t\\\n-      (7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#  endif\n-# endif\n-#endif\n-\n-#ifndef REAL_WIDTH\n-# if HOST_BITS_PER_WIDE_INT*2 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#  define REAL_WIDTH\t2\n-# else\n-#  if HOST_BITS_PER_WIDE_INT*3 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#   define REAL_WIDTH\t3\n-#  else\n-#   if HOST_BITS_PER_WIDE_INT*4 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#    define REAL_WIDTH\t4\n-#   endif\n-#  endif\n-# endif\n-#endif /* REAL_WIDTH */\n-\n-#if REAL_WIDTH == 1\n-# define CONST_DOUBLE_FORMAT\t\"0ww\"\n-#else\n-# if REAL_WIDTH == 2\n-#  define CONST_DOUBLE_FORMAT\t\"0ww\"\n-# else\n-#  if REAL_WIDTH == 3\n-#   define CONST_DOUBLE_FORMAT\t\"0www\"\n-#  else\n-#   if REAL_WIDTH == 4\n-#    define CONST_DOUBLE_FORMAT\t\"0wwww\"\n-#   else\n-#    if REAL_WIDTH == 5\n-#     define CONST_DOUBLE_FORMAT\t\"0wwwww\"\n-#    else\n-#     define CONST_DOUBLE_FORMAT /* nothing - will cause syntax error */\n-#    endif\n-#   endif\n-#  endif\n-# endif\n-#endif\n-\n-\n struct rtx_definition \n {\n   const char *const enumname, *const name, *const format;"}, {"sha": "5d080393867182b60673995ab2d4d8b221a005d8", "filename": "gcc/real.c", "status": "modified", "additions": 27, "deletions": 76, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=46468cd96fb7916bec2ac3f1189e1805c543bece", "patch": "@@ -165,8 +165,7 @@ unknown arithmetic type\n #define EMUSHORT_SIZE HOST_BITS_PER_LONG\n #define EMULONG_SIZE (2 * HOST_BITS_PER_LONG)\n #else\n-/*  You will have to modify this program to have a smaller unit size.  */\n-#define EMU_NON_COMPILE\n+  #error \"You will have to modify this program to have a smaller unit size.\"\n #endif\n #endif\n #endif\n@@ -199,92 +198,45 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n #if HOST_BITS_PER_LONGLONG >= EMULONG_SIZE\n #define EMULONG long long int\n #else\n-/*  You will have to modify this program to have a smaller unit size.  */\n-#define EMU_NON_COMPILE\n+  #error \"You will have to modify this program to have a smaller unit size.\"\n #endif\n #endif\n #endif\n #endif\n \n-\n-/* The host interface doesn't work if no 16-bit size exists.  */\n #if EMUSHORT_SIZE != 16\n-#define EMU_NON_COMPILE\n+  #error \"The host interface doesn't work if no 16-bit size exists.\"\n #endif\n \n-/* OK to continue compilation.  */\n-#ifndef EMU_NON_COMPILE\n+/* Calculate the size of the generic \"e\" type.  This always has\n+   identical in-memory size and representation to REAL_VALUE_TYPE.\n+   There are only two supported sizes: ten and six 16-bit words (160\n+   or 96 bits).  */\n \n-/* Construct macros to translate between REAL_VALUE_TYPE and e type.\n-   In GET_REAL and PUT_REAL, r and e are pointers.\n-   A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations\n-   in memory, with no holes.  */\n-\n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 96 || \\\n-    ((INTEL_EXTENDED_IEEE_FORMAT != 0) && MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n-/* Number of 16 bit words in external e type format */\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !INTEL_EXTENDED_IEEE_FORMAT\n+/* TFmode */\n+# define NE 10\n+# define MAXDECEXP 4932\n+# define MINDECEXP -4977\n+#else\n # define NE 6\n # define MAXDECEXP 4932\n # define MINDECEXP -4956\n-# define GET_REAL(r,e)  memcpy ((e), (r), 2*NE)\n-# define PUT_REAL(e,r)\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n-\t  if (2*NE < sizeof (*r))\t\t\t\t\\\n-\t    memset ((char *) (r) + 2*NE, 0, sizeof (*r) - 2*NE);\t\\\n-\t} while (0)\n-# else /* no XFmode */\n-#  if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n-#   define NE 10\n-#   define MAXDECEXP 4932\n-#   define MINDECEXP -4977\n-#   define GET_REAL(r,e) memcpy ((e), (r), 2*NE)\n-#   define PUT_REAL(e,r)\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n-\t  if (2*NE < sizeof (*r))\t\t\t\t\\\n-\t    memset ((char *) (r) + 2*NE, 0, sizeof (*r) - 2*NE);\t\\\n-\t} while (0)\n-#else\n-#define NE 6\n-#define MAXDECEXP 4932\n-#define MINDECEXP -4956\n-/* Emulator uses target format internally\n-   but host stores it in host endian-ness.  */\n-\n-#define GET_REAL(r,e)\t\t\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-     if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)\t\t\\\n-       e53toe ((const UEMUSHORT *) (r), (e));\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-       {\t\t\t\t\t\t\t\t\\\n-\t UEMUSHORT w[4];\t\t\t\t\t\\\n-         memcpy (&w[3], ((const EMUSHORT *) r), sizeof (EMUSHORT));\t\\\n-         memcpy (&w[2], ((const EMUSHORT *) r) + 1, sizeof (EMUSHORT));\t\\\n-         memcpy (&w[1], ((const EMUSHORT *) r) + 2, sizeof (EMUSHORT));\t\\\n-         memcpy (&w[0], ((const EMUSHORT *) r) + 3, sizeof (EMUSHORT));\t\\\n-\t e53toe (w, (e));\t\t\t\t\t\t\\\n-       }\t\t\t\t\t\t\t\t\\\n-   } while (0)\n-\n-#define PUT_REAL(e,r)\t\t\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-     if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)\t\t\\\n-       etoe53 ((e), (UEMUSHORT *) (r));\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-       {\t\t\t\t\t\t\t\t\\\n-\t UEMUSHORT w[4];\t\t\t\t\t\\\n-\t etoe53 ((e), w);\t\t\t\t\t\t\\\n-         memcpy (((EMUSHORT *) r), &w[3], sizeof (EMUSHORT));\t\t\\\n-         memcpy (((EMUSHORT *) r) + 1, &w[2], sizeof (EMUSHORT));\t\\\n-         memcpy (((EMUSHORT *) r) + 2, &w[1], sizeof (EMUSHORT));\t\\\n-         memcpy (((EMUSHORT *) r) + 3, &w[0], sizeof (EMUSHORT));\t\\\n-       }\t\t\t\t\t\t\t\t\\\n-   } while (0)\n-\n-#endif /* not TFmode */\n-#endif /* not XFmode */\n+#endif\n+\n+/* Fail compilation if 2*NE is not the appropriate size.  */\n+\n+struct compile_test_dummy {\n+  char twice_NE_must_equal_sizeof_REAL_VALUE_TYPE\n+  [(sizeof (REAL_VALUE_TYPE) == 2*NE) ? 1 : -1];\n+};\n \n+/* Construct macros to translate between REAL_VALUE_TYPE and e type.\n+   In GET_REAL and PUT_REAL, r and e are pointers.\n+   A REAL_VALUE_TYPE is guaranteed to occupy contiguous locations\n+   in memory, with no holes.  */\n+#define GET_REAL(r, e)  memcpy ((e), (r), 2*NE)\n+#define PUT_REAL(e, r)  memcpy ((r), (e), 2*NE)\n \n /* Number of 16 bit words in internal format */\n #define NI (NE+3)\n@@ -6918,7 +6870,6 @@ esqrt (x, y)\n   emovo (sq, y);\n }\n #endif\n-#endif /* EMU_NON_COMPILE not defined */\n \f\n /* Return the binary precision of the significand for a given\n    floating point mode.  The mode can hold an integer value"}, {"sha": "b662089d51ecc8e6cd6e44199e68452aba73d9ab", "filename": "gcc/real.h", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=46468cd96fb7916bec2ac3f1189e1805c543bece", "patch": "@@ -76,19 +76,49 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* **** Start of software floating point emulator interface macros **** */\n \n /* REAL_VALUE_TYPE is an array of the minimum number of HOST_WIDE_INTs\n-   required to hold MAX_LONG_DOUBLE_TYPE_SIZE bits.  */\n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n-/* For 128 bit reals, we calculate internally with extra precision.  */\n-#define N (160 / BITS_PER_UNIT)\n+   required to hold either a 96- or 160-bit extended precision floating\n+   point type.  This is true even if the maximum precision floating\n+   point type on the target is smaller.  */\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 128 && !INTEL_EXTENDED_IEEE_FORMAT\n+#define REAL_VALUE_TYPE_SIZE 160\n #else\n-#define N (MAX_LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)\n+#define REAL_VALUE_TYPE_SIZE 96\n #endif\n-#define S sizeof (HOST_WIDE_INT)\n+#define REAL_WIDTH \\\n+  (REAL_VALUE_TYPE_SIZE/HOST_BITS_PER_WIDE_INT \\\n+   + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n typedef struct {\n-  HOST_WIDE_INT r[N/S + (N%S ? 1 : 0)]; /* round up */\n+  HOST_WIDE_INT r[REAL_WIDTH];\n } REAL_VALUE_TYPE;\n-#undef N\n-#undef S\n+\n+/* Calculate the format for CONST_DOUBLE.  We need as many slots as\n+   are necessary to overlay a REAL_VALUE_TYPE on them.  This could be\n+   as many as five (32-bit HOST_WIDE_INT, 160-bit REAL_VALUE_TYPE).\n+\n+   A number of places assume that there are always at least two 'w'\n+   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n+\n+#if REAL_WIDTH == 1\n+# define CONST_DOUBLE_FORMAT\t \"0ww\"\n+#else\n+# if REAL_WIDTH == 2\n+#  define CONST_DOUBLE_FORMAT\t \"0ww\"\n+# else\n+#  if REAL_WIDTH == 3\n+#   define CONST_DOUBLE_FORMAT\t \"0www\"\n+#  else\n+#   if REAL_WIDTH == 4\n+#    define CONST_DOUBLE_FORMAT\t \"0wwww\"\n+#   else\n+#    if REAL_WIDTH == 5\n+#     define CONST_DOUBLE_FORMAT \"0wwwww\"\n+#    else\n+      #error \"REAL_WIDTH > 5 not supported\"\n+#    endif\n+#   endif\n+#  endif\n+# endif\n+#endif\n \n extern unsigned int significand_size\tPARAMS ((enum machine_mode));\n "}, {"sha": "b7ae4452dc46495a58bff8d09433f23545502ada", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46468cd96fb7916bec2ac3f1189e1805c543bece/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=46468cd96fb7916bec2ac3f1189e1805c543bece", "patch": "@@ -27,68 +27,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"errors.h\"\n \n \f\n-/* Calculate the format for CONST_DOUBLE.  This depends on the relative\n-   widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n-\n-   We need to go out to 0wwwww, since real.c assumes 16 bits per element\n-   in REAL_VALUE_TYPE.\n-\n-   This is duplicated in gengenrtl.c.\n-\n-   A number of places assume that there are always at least two 'w'\n-   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n-\n-#if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n-# define REAL_WIDTH\t\\\n-     (11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#else\n-# if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n-#  define REAL_WIDTH\t\\\n-      (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-# else\n-#  if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-#   define REAL_WIDTH\t\\\n-       (7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#  endif\n-# endif\n-#endif\n-\n-#ifndef REAL_WIDTH\n-# if HOST_BITS_PER_WIDE_INT*2 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#  define REAL_WIDTH\t2\n-# else\n-#  if HOST_BITS_PER_WIDE_INT*3 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#   define REAL_WIDTH\t3\n-#  else\n-#   if HOST_BITS_PER_WIDE_INT*4 >= MAX_LONG_DOUBLE_TYPE_SIZE\n-#    define REAL_WIDTH\t4\n-#   endif\n-#  endif\n-# endif\n-#endif /* REAL_WIDTH */\n-\n-#if REAL_WIDTH == 1\n-# define CONST_DOUBLE_FORMAT\t\"0ww\"\n-#else\n-# if REAL_WIDTH == 2\n-#  define CONST_DOUBLE_FORMAT\t\"0ww\"\n-# else\n-#  if REAL_WIDTH == 3\n-#   define CONST_DOUBLE_FORMAT\t\"0www\"\n-#  else\n-#   if REAL_WIDTH == 4\n-#    define CONST_DOUBLE_FORMAT\t\"0wwww\"\n-#   else\n-#    if REAL_WIDTH == 5\n-#     define CONST_DOUBLE_FORMAT\t\"0wwwww\"\n-#    else\n-#     define CONST_DOUBLE_FORMAT\t/* nothing - will cause syntax error */\n-#    endif\n-#   endif\n-#  endif\n-# endif\n-#endif\n-\n /* Indexed by rtx code, gives number of operands for an rtx with that code.\n    Does NOT include rtx header data (code and links).  */\n "}]}