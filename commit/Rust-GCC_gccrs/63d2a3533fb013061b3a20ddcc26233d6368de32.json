{"sha": "63d2a3533fb013061b3a20ddcc26233d6368de32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNkMmEzNTMzZmIwMTMwNjFiM2EyMGRkY2MyNjIzM2Q2MzY4ZGUzMg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-04-15T19:48:25Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-04-15T19:48:25Z"}, "message": "tree.h (ALLOCA_FOR_VAR_P): Rename to CALL_ALLOCA_FOR_VAR_P.\n\n\t* tree.h (ALLOCA_FOR_VAR_P): Rename to CALL_ALLOCA_FOR_VAR_P.\n\t* builtins.c (expand_builtin): Use CALL_ALLOCA_FOR_VAR_P.\n\t* function.c (gimplify_parameters): Ditto.\n\t* gimplify.c (gimplify_vla_decl): Ditto.\n\n\t* gimple.h (enum gf_mask): Add GF_CALL_ALLOCA_FOR_VAR.\n\t(gimple_call_set_alloca_for_var): New inline function.\n\t(gimple_call_alloca_for_var_p): Ditto.\n\t* gimple.c (gimple_build_call_from_tree): Remember CALL_ALLOCA_FOR_VAR_P\n\tstate.\n\t* cfgexpand.c (expand_call_stmt): Restore CALL_ALLOCA_FOR_VAR_P state.\n\n\t* tree-inline.c (inline_forbidden_p_stmt): Don't reject alloca\n\tcalls if they were for VLA objects.\n\nFrom-SVN: r172516", "tree": {"sha": "2ca8a4769f794f0a8bad0116318e591f72ee7e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ca8a4769f794f0a8bad0116318e591f72ee7e8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63d2a3533fb013061b3a20ddcc26233d6368de32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d2a3533fb013061b3a20ddcc26233d6368de32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d2a3533fb013061b3a20ddcc26233d6368de32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d2a3533fb013061b3a20ddcc26233d6368de32/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dee74c343634bec2e6909f197ce0b669820acc56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee74c343634bec2e6909f197ce0b669820acc56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee74c343634bec2e6909f197ce0b669820acc56"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "8fe8856be8d9a2b947bc4d8df3fee86fe9858187", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -1,3 +1,20 @@\n+2011-04-15  Michael Matz  <matz@suse.de>\n+\n+\t* tree.h (ALLOCA_FOR_VAR_P): Rename to CALL_ALLOCA_FOR_VAR_P.\n+\t* builtins.c (expand_builtin): Use CALL_ALLOCA_FOR_VAR_P.\n+\t* function.c (gimplify_parameters): Ditto.\n+\t* gimplify.c (gimplify_vla_decl): Ditto.\n+\n+\t* gimple.h (enum gf_mask): Add GF_CALL_ALLOCA_FOR_VAR.\n+\t(gimple_call_set_alloca_for_var): New inline function.\n+\t(gimple_call_alloca_for_var_p): Ditto.\n+\t* gimple.c (gimple_build_call_from_tree): Remember CALL_ALLOCA_FOR_VAR_P\n+\tstate.\n+\t* cfgexpand.c (expand_call_stmt): Restore CALL_ALLOCA_FOR_VAR_P state.\n+\n+\t* tree-inline.c (inline_forbidden_p_stmt): Don't reject alloca\n+\tcalls if they were for VLA objects.\n+\n 2011-04-15  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (ipa_analyze_virtual_call_uses): Remove handling"}, {"sha": "b2534ce5850d678d81489dd6b1757546d9cf67c6", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -6025,7 +6025,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_ALLOCA:\n       /* If the allocation stems from the declaration of a variable-sized\n \t object, it cannot accumulate.  */\n-      target = expand_builtin_alloca (exp, ALLOCA_FOR_VAR_P (exp));\n+      target = expand_builtin_alloca (exp, CALL_ALLOCA_FOR_VAR_P (exp));\n       if (target)\n \treturn target;\n       break;"}, {"sha": "365f0611f72ce216f6018a4b88798df4d88a5039", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -1879,7 +1879,12 @@ expand_call_stmt (gimple stmt)\n \n   CALL_EXPR_TAILCALL (exp) = gimple_call_tail_p (stmt);\n   CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);\n-  CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n+  if (decl\n+      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (decl) == BUILT_IN_ALLOCA)\n+    CALL_ALLOCA_FOR_VAR_P (exp) = gimple_call_alloca_for_var_p (stmt);\n+  else\n+    CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n   CALL_CANNOT_INLINE_P (exp) = gimple_call_cannot_inline_p (stmt);\n   CALL_EXPR_VA_ARG_PACK (exp) = gimple_call_va_arg_pack_p (stmt);\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));"}, {"sha": "c14a33967456481e201fed1cd397768dc9ce94d0", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -3652,7 +3652,7 @@ gimplify_parameters (void)\n \t\t  t = built_in_decls[BUILT_IN_ALLOCA];\n \t\t  t = build_call_expr (t, 1, DECL_SIZE_UNIT (parm));\n \t\t  /* The call has been built for a variable-sized object.  */\n-\t\t  ALLOCA_FOR_VAR_P (t) = 1;\n+\t\t  CALL_ALLOCA_FOR_VAR_P (t) = 1;\n \t\t  t = fold_convert (ptr_type, t);\n \t\t  t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n \t\t  gimplify_and_add (t, &stmts);"}, {"sha": "f19b219be5fcf5179210c951cecad0121b332966", "filename": "gcc/gimple.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -303,7 +303,12 @@ gimple_build_call_from_tree (tree t)\n   gimple_call_set_tail (call, CALL_EXPR_TAILCALL (t));\n   gimple_call_set_cannot_inline (call, CALL_CANNOT_INLINE_P (t));\n   gimple_call_set_return_slot_opt (call, CALL_EXPR_RETURN_SLOT_OPT (t));\n-  gimple_call_set_from_thunk (call, CALL_FROM_THUNK_P (t));\n+  if (fndecl\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_ALLOCA)\n+    gimple_call_set_alloca_for_var (call, CALL_ALLOCA_FOR_VAR_P (t));\n+  else\n+    gimple_call_set_from_thunk (call, CALL_FROM_THUNK_P (t));\n   gimple_call_set_va_arg_pack (call, CALL_EXPR_VA_ARG_PACK (t));\n   gimple_call_set_nothrow (call, TREE_NOTHROW (t));\n   gimple_set_no_warning (call, TREE_NO_WARNING (t));"}, {"sha": "788ffe6d487726d9ba316fd6621d519b37b8d126", "filename": "gcc/gimple.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -102,6 +102,7 @@ enum gf_mask {\n     GF_CALL_TAILCALL\t\t= 1 << 3,\n     GF_CALL_VA_ARG_PACK\t\t= 1 << 4,\n     GF_CALL_NOTHROW\t\t= 1 << 5,\n+    GF_CALL_ALLOCA_FOR_VAR\t= 1 << 6,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n@@ -2330,6 +2331,29 @@ gimple_call_nothrow_p (gimple s)\n   return (gimple_call_flags (s) & ECF_NOTHROW) != 0;\n }\n \n+/* If FOR_VAR is true, GIMPLE_CALL S is a call to builtin_alloca that\n+   is known to be emitted for VLA objects.  Those are wrapped by\n+   stack_save/stack_restore calls and hence can't lead to unbounded\n+   stack growth even when they occur in loops.  */\n+\n+static inline void\n+gimple_call_set_alloca_for_var (gimple s, bool for_var)\n+{\n+  GIMPLE_CHECK (s, GIMPLE_CALL);\n+  if (for_var)\n+    s->gsbase.subcode |= GF_CALL_ALLOCA_FOR_VAR;\n+  else\n+    s->gsbase.subcode &= ~GF_CALL_ALLOCA_FOR_VAR;\n+}\n+\n+/* Return true of S is a call to builtin_alloca emitted for VLA objects.  */\n+\n+static inline bool\n+gimple_call_alloca_for_var_p (gimple s)\n+{\n+  GIMPLE_CHECK (s, GIMPLE_CALL);\n+  return (s->gsbase.subcode & GF_CALL_ALLOCA_FOR_VAR) != 0;\n+}\n \n /* Copy all the GF_CALL_* flags from ORIG_CALL to DEST_CALL.  */\n "}, {"sha": "f24bea2cb14dd9722beef71da3715aee4721cf7c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -1337,7 +1337,7 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   t = built_in_decls[BUILT_IN_ALLOCA];\n   t = build_call_expr (t, 1, DECL_SIZE_UNIT (decl));\n   /* The call has been built for a variable-sized object.  */\n-  ALLOCA_FOR_VAR_P (t) = 1;\n+  CALL_ALLOCA_FOR_VAR_P (t) = 1;\n   t = fold_convert (ptr_type, t);\n   t = build2 (MODIFY_EXPR, TREE_TYPE (addr), addr, t);\n "}, {"sha": "79c9538dbaf8f0cade9e9ef73a3fe29ee1f844d3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -2997,8 +2997,11 @@ inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t this may change program's memory overhead drastically when the\n \t function using alloca is called in loop.  In GCC present in\n \t SPEC2000 inlining into schedule_block cause it to require 2GB of\n-\t RAM instead of 256MB.  */\n+\t RAM instead of 256MB.  Don't do so for alloca calls emitted for\n+\t VLA objects as those can't cause unbounded growth (they're always\n+\t wrapped inside stack_save/stack_restore regions.  */\n       if (gimple_alloca_call_p (stmt)\n+\t  && !gimple_call_alloca_for_var_p (stmt)\n \t  && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n \t  inline_forbidden_reason"}, {"sha": "0bc98cd01b46691ae9fdab162326e3c65adb74e6", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63d2a3533fb013061b3a20ddcc26233d6368de32/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=63d2a3533fb013061b3a20ddcc26233d6368de32", "patch": "@@ -574,7 +574,7 @@ struct GTY(()) tree_common {\n            all decls\n \n        CALL_FROM_THUNK_P and\n-       ALLOCA_FOR_VAR_P in\n+       CALL_ALLOCA_FOR_VAR_P in\n            CALL_EXPR\n \n    side_effects_flag:\n@@ -1388,7 +1388,8 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n /* In a CALL_EXPR, if the function being called is BUILT_IN_ALLOCA, means that\n    it has been built for the declaration of a variable-sized object.  */\n-#define ALLOCA_FOR_VAR_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n+#define CALL_ALLOCA_FOR_VAR_P(NODE) \\\n+  (CALL_EXPR_CHECK (NODE)->base.protected_flag)\n \n /* In a type, nonzero means that all objects of the type are guaranteed by the\n    language or front-end to be properly aligned, so we can indicate that a MEM"}]}