{"sha": "7b966a95465c9af78959a53c93fff608c9158748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5NjZhOTU0NjVjOWFmNzg5NTlhNTNjOTNmZmY2MDhjOTE1ODc0OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-17T06:52:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-17T06:52:30Z"}, "message": "[multiple changes]\n\n2014-07-17  Vincent Celier  <celier@adacore.com>\n\n\t* gnatbind.adb: Change in message \"try ... for more information\".\n\n2014-07-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sprint.adb: Code clean up.\n\n2014-07-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Find_Last_Init): Relocate local variables to\n\tthe relevant code section. Add new local constant Obj_Id. When\n\ta limited controlled object is initialized by a function call,\n\tthe build-in-place object access function call acts as the last\n\tinitialization statement.\n\t* exp_util.adb (Is_Object_Access_BIP_Func_Call): New routine.\n\t(Is_Secondary_Stack_BIP_Func_Call): Code reformatting.\n\t* exp_util.ads (Is_Object_Access_BIP_Func_Call): New routine.\n\n2014-07-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Generic_Renaming): For generic subprograms,\n\tpropagate intrinsic flag to renamed entity, to allow e.g. renaming\n\tof Unchecked_Conversion.\n\t* sem_ch3.adb (Analyze_Declarations): Do not analyze contracts\n\tif the declaration has errors.\n\n2014-07-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-rbtgbk.adb: a-rbtgbk.adb (Generic_Insert_Post): Check whether\n\tcontainer is busy before checking whether capacity allows for\n\ta further insertion. Insertion in a busy container that is full\n\traises Program_Error rather than Capacity_Error. Previous to that\n\tpatch which exception was raised varied among container types.\n\nFrom-SVN: r212730", "tree": {"sha": "932722f0610e4afe2d75cad3ac2d6ee7f8b0fee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/932722f0610e4afe2d75cad3ac2d6ee7f8b0fee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b966a95465c9af78959a53c93fff608c9158748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b966a95465c9af78959a53c93fff608c9158748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b966a95465c9af78959a53c93fff608c9158748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b966a95465c9af78959a53c93fff608c9158748/comments", "author": null, "committer": null, "parents": [{"sha": "44ccf4b4581279ffadfe20bc20f34f6a8dd05a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44ccf4b4581279ffadfe20bc20f34f6a8dd05a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44ccf4b4581279ffadfe20bc20f34f6a8dd05a53"}], "stats": {"total": 377, "additions": 281, "deletions": 96}, "files": [{"sha": "c2351f9bf2ffed4ef5fe30d51b758af3299bfd9e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -1,3 +1,38 @@\n+2014-07-17  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatbind.adb: Change in message \"try ... for more information\".\n+\n+2014-07-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sprint.adb: Code clean up.\n+\n+2014-07-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Find_Last_Init): Relocate local variables to\n+\tthe relevant code section. Add new local constant Obj_Id. When\n+\ta limited controlled object is initialized by a function call,\n+\tthe build-in-place object access function call acts as the last\n+\tinitialization statement.\n+\t* exp_util.adb (Is_Object_Access_BIP_Func_Call): New routine.\n+\t(Is_Secondary_Stack_BIP_Func_Call): Code reformatting.\n+\t* exp_util.ads (Is_Object_Access_BIP_Func_Call): New routine.\n+\n+2014-07-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Generic_Renaming): For generic subprograms,\n+\tpropagate intrinsic flag to renamed entity, to allow e.g. renaming\n+\tof Unchecked_Conversion.\n+\t* sem_ch3.adb (Analyze_Declarations): Do not analyze contracts\n+\tif the declaration has errors.\n+\n+2014-07-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-rbtgbk.adb: a-rbtgbk.adb (Generic_Insert_Post): Check whether\n+\tcontainer is busy before checking whether capacity allows for\n+\ta further insertion. Insertion in a busy container that is full\n+\traises Program_Error rather than Capacity_Error. Previous to that\n+\tpatch which exception was raised varied among container types.\n+\n 2014-07-17  Robert Dewar  <dewar@adacore.com>\n \n \t* g-comlin.ads, g-comlin.adb: Minor clean up."}, {"sha": "dba3e0bd095c6c90f3444da5f93f517151662886", "filename": "gcc/ada/a-rbtgbk.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fa-rbtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fa-rbtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rbtgbk.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -349,15 +349,15 @@ package body Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys is\n       N : Nodes_Type renames Tree.Nodes;\n \n    begin\n-      if Tree.Length >= Tree.Capacity then\n-         raise Capacity_Error with \"not enough capacity to insert new item\";\n-      end if;\n-\n       if Tree.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (container is busy)\";\n       end if;\n \n+      if Tree.Length >= Tree.Capacity then\n+         raise Capacity_Error with \"not enough capacity to insert new item\";\n+      end if;\n+\n       Z := New_Node;\n       pragma Assert (Z /= 0);\n "}, {"sha": "2f6ae985249d507556a0eff6f94b6fc65e6b0913", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 83, "deletions": 41, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -2256,10 +2256,6 @@ package body Exp_Ch7 is\n             Last_Init   : out Node_Id;\n             Body_Insert : out Node_Id)\n          is\n-            Nod_1 : Node_Id := Empty;\n-            Nod_2 : Node_Id := Empty;\n-            Utyp  : Entity_Id;\n-\n             function Is_Init_Call\n               (N   : Node_Id;\n                Typ : Entity_Id) return Boolean;\n@@ -2332,6 +2328,14 @@ package body Exp_Ch7 is\n                return Result;\n             end Next_Suitable_Statement;\n \n+            --  Local variables\n+\n+            Obj_Id : constant Entity_Id := Defining_Entity (Decl);\n+            Nod_1  : Node_Id := Empty;\n+            Nod_2  : Node_Id := Empty;\n+            Stmt   : Node_Id;\n+            Utyp   : Entity_Id;\n+\n          --  Start of processing for Find_Last_Init\n \n          begin\n@@ -2357,6 +2361,42 @@ package body Exp_Ch7 is\n                Utyp := Full_View (Utyp);\n             end if;\n \n+            --  A limited controlled object initialized by a function call uses\n+            --  the build-in-place machinery to obtain its value.\n+\n+            --    Obj : Lim_Controlled_Type := Func_Call;\n+\n+            --  is expanded into\n+\n+            --    Obj  : Lim_Controlled_Type;\n+            --    type Ptr_Typ is access Lim_Controlled_Type;\n+            --    Temp : constant Ptr_Typ :=\n+            --             Func_Call\n+            --               (BIPalloc  => 1,\n+            --                BIPaccess => Obj'Unrestricted_Access)'reference;\n+\n+            --  In this scenario the declaration of the temporary acts as the\n+            --  last initialization statement.\n+\n+            if Is_Limited_Type (Utyp)\n+              and then Has_Init_Expression (Decl)\n+              and then No (Expression (Decl))\n+            then\n+               Stmt := Next (Decl);\n+               while Present (Stmt) loop\n+                  if Nkind (Stmt) = N_Object_Declaration\n+                    and then Present (Expression (Stmt))\n+                    and then Is_Object_Access_BIP_Func_Call\n+                               (Expr   => Expression (Stmt),\n+                                Obj_Id => Obj_Id)\n+                  then\n+                     Last_Init := Stmt;\n+                     exit;\n+                  end if;\n+\n+                  Next (Stmt);\n+               end loop;\n+\n             --  The init procedures are arranged as follows:\n \n             --    Object : Controlled_Type;\n@@ -2366,53 +2406,55 @@ package body Exp_Ch7 is\n             --  where the user-defined initialize may be optional or may appear\n             --  inside a block when abort deferral is needed.\n \n-            Nod_1 := Next_Suitable_Statement (Decl);\n-            if Present (Nod_1) then\n-               Nod_2 := Next_Suitable_Statement (Nod_1);\n+            else\n+               Nod_1 := Next_Suitable_Statement (Decl);\n \n-               --  The statement following an object declaration is always a\n-               --  call to the type init proc.\n+               if Present (Nod_1) then\n+                  Nod_2 := Next_Suitable_Statement (Nod_1);\n \n-               Last_Init := Nod_1;\n-            end if;\n+                  --  The statement following an object declaration is always a\n+                  --  call to the type init proc.\n \n-            --  Optional user-defined init or deep init processing\n+                  Last_Init := Nod_1;\n+               end if;\n \n-            if Present (Nod_2) then\n+               --  Optional user-defined init or deep init processing\n \n-               --  The statement following the type init proc may be a block\n-               --  statement in cases where abort deferral is required.\n+               if Present (Nod_2) then\n \n-               if Nkind (Nod_2) = N_Block_Statement then\n-                  declare\n-                     HSS  : constant Node_Id :=\n-                              Handled_Statement_Sequence (Nod_2);\n-                     Stmt : Node_Id;\n+                  --  The statement following the type init proc may be a block\n+                  --  statement in cases where abort deferral is required.\n \n-                  begin\n-                     if Present (HSS)\n-                       and then Present (Statements (HSS))\n-                     then\n-                        Stmt := First (Statements (HSS));\n+                  if Nkind (Nod_2) = N_Block_Statement then\n+                     declare\n+                        HSS  : constant Node_Id :=\n+                                 Handled_Statement_Sequence (Nod_2);\n+                        Stmt : Node_Id;\n \n-                        --  Examine individual block statements and locate the\n-                        --  call to [Deep_]Initialze.\n+                     begin\n+                        if Present (HSS)\n+                          and then Present (Statements (HSS))\n+                        then\n+                           --  Examine individual block statements and locate\n+                           --  the call to [Deep_]Initialze.\n \n-                        while Present (Stmt) loop\n-                           if Is_Init_Call (Stmt, Utyp) then\n-                              Last_Init   := Stmt;\n-                              Body_Insert := Nod_2;\n+                           Stmt := First (Statements (HSS));\n+                           while Present (Stmt) loop\n+                              if Is_Init_Call (Stmt, Utyp) then\n+                                 Last_Init   := Stmt;\n+                                 Body_Insert := Nod_2;\n \n-                              exit;\n-                           end if;\n+                                 exit;\n+                              end if;\n \n-                           Next (Stmt);\n-                        end loop;\n-                     end if;\n-                  end;\n+                              Next (Stmt);\n+                           end loop;\n+                        end if;\n+                     end;\n \n-               elsif Is_Init_Call (Nod_2, Utyp) then\n-                  Last_Init := Nod_2;\n+                  elsif Is_Init_Call (Nod_2, Utyp) then\n+                     Last_Init := Nod_2;\n+                  end if;\n                end if;\n             end if;\n          end Find_Last_Init;\n@@ -2434,7 +2476,7 @@ package body Exp_Ch7 is\n \n          --  Set a new value for the state counter and insert the statement\n          --  after the object declaration. Generate:\n-         --\n+\n          --    Counter := <value>;\n \n          Inc_Decl :=\n@@ -2496,7 +2538,7 @@ package body Exp_Ch7 is\n              Label_Construct     => Label));\n \n          --  Create the associated jump with this object, generate:\n-         --\n+\n          --    when <counter> =>\n          --       goto L<counter>;\n "}, {"sha": "800c276d5366d8ca05853d9aeb983240a143fdc8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 110, "deletions": 42, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -4794,6 +4794,79 @@ package body Exp_Util is\n           and then not Is_Build_In_Place_Function_Call (Prefix (Expr));\n    end Is_Non_BIP_Func_Call;\n \n+   ------------------------------------\n+   -- Is_Object_Access_BIP_Func_Call --\n+   ------------------------------------\n+\n+   function Is_Object_Access_BIP_Func_Call\n+      (Expr   : Node_Id;\n+       Obj_Id : Entity_Id) return Boolean\n+   is\n+      Access_Nam : Name_Id := No_Name;\n+      Actual     : Node_Id;\n+      Call       : Node_Id;\n+      Formal     : Node_Id;\n+      Param      : Node_Id;\n+\n+   begin\n+      --  Build-in-place calls usually appear in 'reference format. Note that\n+      --  the accessibility check machinery may add an extra 'reference due to\n+      --  side effect removal.\n+\n+      Call := Expr;\n+      while Nkind (Call) = N_Reference loop\n+         Call := Prefix (Call);\n+      end loop;\n+\n+      if Nkind_In (Call, N_Qualified_Expression,\n+                         N_Unchecked_Type_Conversion)\n+      then\n+         Call := Expression (Call);\n+      end if;\n+\n+      if Is_Build_In_Place_Function_Call (Call) then\n+\n+         --  Examine all parameter associations of the function call\n+\n+         Param := First (Parameter_Associations (Call));\n+         while Present (Param) loop\n+            if Nkind (Param) = N_Parameter_Association\n+              and then Nkind (Selector_Name (Param)) = N_Identifier\n+            then\n+               Formal := Selector_Name (Param);\n+               Actual := Explicit_Actual_Parameter (Param);\n+\n+               --  Construct the name of formal BIPaccess. It is much easier to\n+               --  extract the name of the function using an arbitrary formal's\n+               --  scope rather than the Name field of Call.\n+\n+               if Access_Nam = No_Name and then Present (Entity (Formal)) then\n+                  Access_Nam :=\n+                    New_External_Name\n+                      (Chars (Scope (Entity (Formal))),\n+                       BIP_Formal_Suffix (BIP_Object_Access));\n+               end if;\n+\n+               --  A match for BIPaccess => Obj_Id'Unrestricted_Access has been\n+               --  found.\n+\n+               if Chars (Formal) = Access_Nam\n+                 and then Nkind (Actual) = N_Attribute_Reference\n+                 and then Attribute_Name (Actual) = Name_Unrestricted_Access\n+                 and then Nkind (Prefix (Actual)) = N_Identifier\n+                 and then Entity (Prefix (Actual)) = Obj_Id\n+               then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next (Param);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Is_Object_Access_BIP_Func_Call;\n+\n    ----------------------------------\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------\n@@ -5183,7 +5256,11 @@ package body Exp_Util is\n    --------------------------------------\n \n    function Is_Secondary_Stack_BIP_Func_Call (Expr : Node_Id) return Boolean is\n-      Call : Node_Id := Expr;\n+      Alloc_Nam : Name_Id := No_Name;\n+      Actual    : Node_Id;\n+      Call      : Node_Id := Expr;\n+      Formal    : Node_Id;\n+      Param     : Node_Id;\n \n    begin\n       --  Build-in-place calls usually appear in 'reference format. Note that\n@@ -5201,49 +5278,40 @@ package body Exp_Util is\n       end if;\n \n       if Is_Build_In_Place_Function_Call (Call) then\n-         declare\n-            Access_Nam : Name_Id := No_Name;\n-            Actual     : Node_Id;\n-            Param      : Node_Id;\n-            Formal     : Node_Id;\n-\n-         begin\n-            --  Examine all parameter associations of the function call\n-\n-            Param := First (Parameter_Associations (Call));\n-            while Present (Param) loop\n-               if Nkind (Param) = N_Parameter_Association\n-                 and then Nkind (Selector_Name (Param)) = N_Identifier\n-               then\n-                  Formal := Selector_Name (Param);\n-                  Actual := Explicit_Actual_Parameter (Param);\n \n-                  --  Construct the name of formal BIPalloc. It is much easier\n-                  --  to extract the name of the function using an arbitrary\n-                  --  formal's scope rather than the Name field of Call.\n+         --  Examine all parameter associations of the function call\n \n-                  if Access_Nam = No_Name\n-                    and then Present (Entity (Formal))\n-                  then\n-                     Access_Nam :=\n-                       New_External_Name\n-                         (Chars (Scope (Entity (Formal))),\n-                          BIP_Formal_Suffix (BIP_Alloc_Form));\n-                  end if;\n+         Param := First (Parameter_Associations (Call));\n+         while Present (Param) loop\n+            if Nkind (Param) = N_Parameter_Association\n+              and then Nkind (Selector_Name (Param)) = N_Identifier\n+            then\n+               Formal := Selector_Name (Param);\n+               Actual := Explicit_Actual_Parameter (Param);\n+\n+               --  Construct the name of formal BIPalloc. It is much easier to\n+               --  extract the name of the function using an arbitrary formal's\n+               --  scope rather than the Name field of Call.\n+\n+               if Alloc_Nam = No_Name and then Present (Entity (Formal)) then\n+                  Alloc_Nam :=\n+                    New_External_Name\n+                      (Chars (Scope (Entity (Formal))),\n+                       BIP_Formal_Suffix (BIP_Alloc_Form));\n+               end if;\n \n-                  --  A match for BIPalloc => 2 has been found\n+               --  A match for BIPalloc => 2 has been found\n \n-                  if Chars (Formal) = Access_Nam\n-                    and then Nkind (Actual) = N_Integer_Literal\n-                    and then Intval (Actual) = Uint_2\n-                  then\n-                     return True;\n-                  end if;\n+               if Chars (Formal) = Alloc_Nam\n+                 and then Nkind (Actual) = N_Integer_Literal\n+                 and then Intval (Actual) = Uint_2\n+               then\n+                  return True;\n                end if;\n+            end if;\n \n-               Next (Param);\n-            end loop;\n-         end;\n+            Next (Param);\n+         end loop;\n       end if;\n \n       return False;\n@@ -5274,10 +5342,10 @@ package body Exp_Util is\n    begin\n       return (not Is_Tagged_Type (T) and then Is_Derived_Type (T))\n                or else\n-             (Is_Private_Type (T) and then Present (Full_View (T))\n-               and then not Is_Tagged_Type (Full_View (T))\n-               and then Is_Derived_Type (Full_View (T))\n-               and then Etype (Full_View (T)) /= T);\n+                 (Is_Private_Type (T) and then Present (Full_View (T))\n+                   and then not Is_Tagged_Type (Full_View (T))\n+                   and then Is_Derived_Type (Full_View (T))\n+                   and then Etype (Full_View (T)) /= T);\n    end Is_Untagged_Derivation;\n \n    ---------------------------"}, {"sha": "2f316ddb8d15c22d1e88acf03125aabec2c24dc0", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -127,6 +127,12 @@ package Exp_Util is\n    --  Assoc_Node must be a node in a list. Same as Insert_Action but the\n    --  action will be inserted after N in a manner that is compatible with\n    --  the transient scope mechanism.\n+   --\n+   --  Note: If several successive calls to Insert_Action_After are made for\n+   --  the same node, they will each in turn be inserted just after the node.\n+   --  This means they will end up being executed in reverse order. Use the\n+   --  call to Insert_Actions_After to insert a list of actions to be executed\n+   --  in the sequence in which they are given in the list.\n \n    procedure Insert_Actions_After\n      (Assoc_Node  : Node_Id;\n@@ -575,6 +581,12 @@ package Exp_Util is\n    function Is_Non_BIP_Func_Call (Expr : Node_Id) return Boolean;\n    --  Determine whether node Expr denotes a non build-in-place function call\n \n+   function Is_Object_Access_BIP_Func_Call\n+      (Expr   : Node_Id;\n+       Obj_Id : Entity_Id) return Boolean;\n+   --  Determine if Expr denotes a build-in-place function which stores its\n+   --  result in the BIPaccess actual parameter whose prefix must match Obj_Id.\n+\n    function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n    --  Node N is an object reference. This function returns True if it is\n    --  possible that the object may not be aligned according to the normal"}, {"sha": "6383e818b14ea574c4ebc6a98ca7a70d8850e252", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -672,7 +672,7 @@ begin\n       if Argument_Count = 0 then\n          Bindusg.Display;\n       else\n-         Write_Line (\"try `gnatbind --help` for more information.\");\n+         Write_Line (\"try \"\"gnatbind --help\"\" for more information.\");\n       end if;\n \n       Exit_Program (E_Fatal);"}, {"sha": "b6023637575deae8c2663c712dec2a9e33c5bb66", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -2366,11 +2366,14 @@ package body Sem_Ch3 is\n \n       --  Analyze the contracts of subprogram declarations, subprogram bodies\n       --  and variables now due to the delayed visibility requirements of their\n-      --  aspects.\n+      --  aspects. Skip analysis if the declaration already has an error.\n \n       Decl := First (L);\n       while Present (Decl) loop\n-         if Nkind (Decl) = N_Object_Declaration then\n+         if Error_Posted (Decl) then\n+            null;\n+\n+         elsif Nkind (Decl) = N_Object_Declaration then\n             Analyze_Object_Contract (Defining_Entity (Decl));\n \n          elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,"}, {"sha": "2bc1ea03e07ef7879f4abc8dfbdb3b4a57a0d37e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -706,6 +706,14 @@ package body Sem_Ch8 is\n             Error_Msg_N (\"within its scope, generic denotes its instance\", N);\n          end if;\n \n+         --  For subprograms, propagate the Intrinsic flag, to allow, e.g.\n+         --  renamings and subsequent instantiations of Unchecked_Conversion.\n+\n+         if Ekind_In (Old_P, E_Generic_Function, E_Generic_Procedure) then\n+            Set_Is_Intrinsic_Subprogram\n+              (New_P, Is_Intrinsic_Subprogram (Old_P));\n+         end if;\n+\n          Check_Library_Unit_Renaming (N, Old_P);\n       end if;\n "}, {"sha": "9a55e8cc65a4f39fab7d132bd1e5d1c5914ae286", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b966a95465c9af78959a53c93fff608c9158748/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=7b966a95465c9af78959a53c93fff608c9158748", "patch": "@@ -2249,13 +2249,30 @@ package body Sprint is\n \n                   --  Print type, we used to print the Object_Definition from\n                   --  the node, but it is much more useful to print the Etype\n-                  --  of the defining identifier. For example, this will be a\n-                  --  clear reference to the Itype with the bounds in the case\n-                  --  of an unconstrained array type like String. The object\n-                  --  after all is constrained, even if its nominal subtype is\n+                  --  of the defining identifier for the case where the nominal\n+                  --  type is an unconstrained array type. For example, this\n+                  --  will be a clear reference to the Itype with the bounds\n+                  --  in the case of a type like String. The object after\n+                  --  all is constrained, even if its nominal subtype is\n                   --  unconstrained.\n \n-                  Sprint_Node (Etype (Def_Id));\n+                  declare\n+                     Odef : constant Node_Id := Object_Definition (Node);\n+\n+                  begin\n+                     if Nkind (Odef) = N_Identifier\n+                       and then Is_Array_Type (Etype (Odef))\n+                       and then not Is_Constrained (Etype (Odef))\n+                       and then Present (Etype (Def_Id))\n+                     then\n+                        Sprint_Node (Etype (Def_Id));\n+\n+                        --  In other cases, the nominal type is fine to print\n+\n+                     else\n+                        Sprint_Node (Odef);\n+                     end if;\n+                  end;\n \n                   if Present (Expression (Node)) then\n                      Write_Str (\" := \");"}]}