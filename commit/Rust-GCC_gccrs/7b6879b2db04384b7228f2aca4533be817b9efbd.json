{"sha": "7b6879b2db04384b7228f2aca4533be817b9efbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2ODc5YjJkYjA0Mzg0YjcyMjhmMmFjYTQ1MzNiZTgxN2I5ZWZiZA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-06-13T17:45:52Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2019-06-13T17:45:52Z"}, "message": "re PR fortran/88810 (gcc/fortran/dependency.c:2200: possible cut'n'paste error ?)\n\n2019-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/88810\n\t* dependency.c (gfc_dep_resolver): Re-arrange code to make the logic\n\ta bit more transparent.  Fix 2 nearby formatting issues.\n\nFrom-SVN: r272254", "tree": {"sha": "5a27e2e554315d1165ede1f75f09d176b8ea3afb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a27e2e554315d1165ede1f75f09d176b8ea3afb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b6879b2db04384b7228f2aca4533be817b9efbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6879b2db04384b7228f2aca4533be817b9efbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6879b2db04384b7228f2aca4533be817b9efbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6879b2db04384b7228f2aca4533be817b9efbd/comments", "author": null, "committer": null, "parents": [{"sha": "342f89653affafb42ba578c876635a9ae4d06810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/342f89653affafb42ba578c876635a9ae4d06810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/342f89653affafb42ba578c876635a9ae4d06810"}], "stats": {"total": 62, "additions": 36, "deletions": 26}, "files": [{"sha": "ebff4278f5abd5dc69088d5cde86cde75596af09", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6879b2db04384b7228f2aca4533be817b9efbd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6879b2db04384b7228f2aca4533be817b9efbd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7b6879b2db04384b7228f2aca4533be817b9efbd", "patch": "@@ -1,3 +1,9 @@\n+2019-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/88810\n+\t* dependency.c (gfc_dep_resolver): Re-arrange code to make the logic\n+\ta bit more transparent.  Fix 2 nearby formatting issues.\n+\n 2019-06-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* io.c (check_format): Use G_(...) instead of _(...) for error values,"}, {"sha": "8eae644962313c6406a67b23826316ff2bb6077a", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b6879b2db04384b7228f2aca4533be817b9efbd/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b6879b2db04384b7228f2aca4533be817b9efbd/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=7b6879b2db04384b7228f2aca4533be817b9efbd", "patch": "@@ -2141,7 +2141,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t  /* Index for the reverse array.  */\n \t  m = -1;\n-\t  for (n=0; n < lref->u.ar.dimen; n++)\n+\t  for (n = 0; n < lref->u.ar.dimen; n++)\n \t    {\n \t      /* Handle dependency when either of array reference is vector\n \t\t subscript. There is no dependency if the vector indices\n@@ -2163,7 +2163,8 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \n \t      if (lref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t  && rref->u.ar.dimen_type[n] == DIMEN_RANGE)\n-\t\tthis_dep = check_section_vs_section (&lref->u.ar, &rref->u.ar, n);\n+\t\tthis_dep = check_section_vs_section (&lref->u.ar,\n+\t\t\t\t\t\t     &rref->u.ar, n);\n \t      else if (lref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t       && rref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\tthis_dep = gfc_check_element_vs_section (lref, rref, n);\n@@ -2196,35 +2197,38 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\t{\n-\t\t  /* Set reverse if backward dependence and not inhibited.  */\n-\t\t  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)\n-\t\t    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?\n-\t\t\t         GFC_REVERSE_SET : reverse[m];\n-\n-\t\t  /* Set forward if forward dependence and not inhibited.  */\n-\t\t  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)\n-\t\t    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?\n-\t\t\t         GFC_FORWARD_SET : reverse[m];\n-\n-\t\t  /* Flag up overlap if dependence not compatible with\n-\t\t     the overall state of the expression.  */\n-\t\t  if (reverse && reverse[m] == GFC_REVERSE_SET\n-\t\t        && this_dep == GFC_DEP_FORWARD)\n+\t\t  if (reverse)\n \t\t    {\n-\t              reverse[m] = GFC_INHIBIT_REVERSE;\n-\t\t      this_dep = GFC_DEP_OVERLAP;\n-\t\t    }\n-\t\t  else if (reverse && reverse[m] == GFC_FORWARD_SET\n-\t\t        && this_dep == GFC_DEP_BACKWARD)\n-\t\t    {\n-\t              reverse[m] = GFC_INHIBIT_REVERSE;\n-\t\t      this_dep = GFC_DEP_OVERLAP;\n+\t\t      /* Reverse if backward dependence and not inhibited.  */\n+\t\t      if (reverse[m] == GFC_ENABLE_REVERSE\n+\t\t\t  && this_dep == GFC_DEP_BACKWARD)\n+\t\t\treverse[m] = GFC_REVERSE_SET;\n+\n+\t\t      /* Forward if forward dependence and not inhibited.  */\n+\t\t      if (reverse[m] == GFC_ENABLE_REVERSE\n+\t\t\t  && this_dep == GFC_DEP_FORWARD)\n+\t\t\treverse[m] = GFC_FORWARD_SET;\n+\n+\t\t      /* Flag up overlap if dependence not compatible with\n+\t\t\t the overall state of the expression.  */\n+\t\t      if (reverse[m] == GFC_REVERSE_SET\n+\t\t\t  && this_dep == GFC_DEP_FORWARD)\n+\t\t\t{\n+\t\t\t  reverse[m] = GFC_INHIBIT_REVERSE;\n+\t\t\t  this_dep = GFC_DEP_OVERLAP;\n+\t\t\t}\n+\t\t      else if (reverse[m] == GFC_FORWARD_SET\n+\t\t\t       && this_dep == GFC_DEP_BACKWARD)\n+\t\t\t{\n+\t\t\t  reverse[m] = GFC_INHIBIT_REVERSE;\n+\t\t\t  this_dep = GFC_DEP_OVERLAP;\n+\t\t\t}\n \t\t    }\n \n \t\t  /* If no intention of reversing or reversing is explicitly\n \t\t     inhibited, convert backward dependence to overlap.  */\n-\t\t  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)\n-\t\t      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))\n+\t\t  if ((!reverse && this_dep == GFC_DEP_BACKWARD)\n+\t\t      || (reverse && reverse[m] == GFC_INHIBIT_REVERSE))\n \t\t    this_dep = GFC_DEP_OVERLAP;\n \t\t}\n "}]}