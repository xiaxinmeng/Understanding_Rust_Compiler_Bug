{"sha": "e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZhOGViYjRlMGQzMjJlNTJmNzY3MzY0NzYxYWU4ZWQyMGM4YTMxNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-03-17T14:49:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-03-17T14:49:22Z"}, "message": "alpha.h (HARD_REGNO_MODE_OK): Allow only 4 and 8 byte unit modes in FP regs.\n\n        * alpha.h (HARD_REGNO_MODE_OK): Allow only 4 and 8 byte unit modes\n        in FP regs.\n        (MODES_TIEABLE_P): Define asymmetricly wrt modes illegal in FP regs.\n\nFrom-SVN: r25825", "tree": {"sha": "a9c3933c0256a0e7d3852288be8cfeb80d5ca2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c3933c0256a0e7d3852288be8cfeb80d5ca2c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a8ebb4e0d322e52f767364761ae8ed20c8a317/comments", "author": null, "committer": null, "parents": [{"sha": "aec3cfba19c324590612c95a33b14d4142a19823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec3cfba19c324590612c95a33b14d4142a19823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aec3cfba19c324590612c95a33b14d4142a19823"}], "stats": {"total": 25, "additions": 17, "deletions": 8}, "files": [{"sha": "3d8f5fe8c4459d58736baa2d1e147231360544e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a8ebb4e0d322e52f767364761ae8ed20c8a317/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a8ebb4e0d322e52f767364761ae8ed20c8a317/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "patch": "@@ -1,3 +1,9 @@\n+Wed Mar 17 14:51:19 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.h (HARD_REGNO_MODE_OK): Allow only 4 and 8 byte unit modes\n+\tin FP regs.\n+\t(MODES_TIEABLE_P): Define asymmetricly wrt modes illegal in FP regs.\n+\n Wed Mar 17 14:41:41 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/arm/aout.h (ASM_GENERATE_INTERNAL_LABEL): Fix compile"}, {"sha": "4587bbf96f0d708dbeb868f2fb27921a0cebd067", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6a8ebb4e0d322e52f767364761ae8ed20c8a317/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6a8ebb4e0d322e52f767364761ae8ed20c8a317/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e6a8ebb4e0d322e52f767364761ae8ed20c8a317", "patch": "@@ -622,17 +622,20 @@ extern void override_options ();\n    registers can hold 32-bit and 64-bit integers as well, but not 16-bit\n    or 8-bit values.  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n-  ((REGNO) < 32 || ((MODE) != QImode && (MODE) != HImode))\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\t\\\n+  ((REGNO) >= 32 && (REGNO) <= 62 \t\t\t\t\t\\\n+   ? GET_MODE_UNIT_SIZE (MODE) == 8 || GET_MODE_UNIT_SIZE (MODE) == 4\t\\\n+   : 1)\n+\n+/* A C expression that is nonzero if a value of mode\n+   MODE1 is accessible in mode MODE2 without copying.\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   This asymmetric test is true when MODE1 could be put\n+   in an FP register but MODE2 could not.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2) \t\t\t\t\\\n-  ((MODE1) == QImode || (MODE1) == HImode\t\t\t\\\n-   ? (MODE2) == QImode || (MODE2) == HImode\t\t\t\\\n+  (HARD_REGNO_MODE_OK (32, (MODE1))\t\t\t\t\\\n+   ? HARD_REGNO_MODE_OK (32, (MODE2))\t\t\t\t\\\n    : 1)\n \n /* Specify the registers used for certain standard purposes."}]}