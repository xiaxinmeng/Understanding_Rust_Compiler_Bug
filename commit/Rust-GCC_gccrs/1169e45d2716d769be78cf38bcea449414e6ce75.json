{"sha": "1169e45d2716d769be78cf38bcea449414e6ce75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE2OWU0NWQyNzE2ZDc2OWJlNzhjZjM4YmNlYTQ0OTQxNGU2Y2U3NQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2011-07-27T13:22:09Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2011-07-27T13:22:09Z"}, "message": "params.h (ALLOW_STORE_DATA_RACES): New.\n\n\t* params.h (ALLOW_STORE_DATA_RACES): New.\n\t* params.def (PARAM_ALLOW_STORE_DATA_RACES): New.\n\t* Makefile.in (expr.o): Depend on PARAMS_H.\n\t* machmode.h (get_best_mode): Add argument.\n\t* fold-const.c (optimize_bit_field_compare): Add argument to\n\tget_best_mode.\n\t(fold_truthop): Same.\n\t* ifcvt.c (noce_emit_move_insn): Add argument to store_bit_field.\n\t* expr.c (emit_group_store): Same.\n\t(copy_blkmode_from_reg): Same.\n\t(write_complex_part): Same.\n\t(optimize_bitfield_assignment_op): Add argument.\n\tAdd argument to get_best_mode.\n\t(get_bit_range): New.\n\t(expand_assignment): Calculate maxbits and pass it down\n\taccordingly.\n\t(store_field): New argument.\n\t(expand_expr_real_2): New argument to store_field.\n\tInclude params.h.\n\t* expr.h (store_bit_field): New argument.\n\t* stor-layout.c (get_best_mode): Restrict mode expansion by taking\n\tinto account maxbits.\n\t* calls.c (store_unaligned_arguments_into_pseudos): New argument\n\tto store_bit_field.\n\t* expmed.c (store_bit_field_1): New argument.  Use it.\n\t(store_bit_field): Same.\n\t(store_fixed_bit_field): Same.\n\t(store_split_bit_field): Same.\n\t(extract_bit_field_1): Pass new argument to get_best_mode.\n\t(extract_bit_field): Same.\n\t* stmt.c (store_bit_field): Pass new argument to store_bit_field.\n\t* doc/invoke.texi: Document parameter allow-store-data-races.\n\nFrom-SVN: r176824", "tree": {"sha": "efd1ef13f8faacffa0a54f18314494501d46696b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efd1ef13f8faacffa0a54f18314494501d46696b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1169e45d2716d769be78cf38bcea449414e6ce75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1169e45d2716d769be78cf38bcea449414e6ce75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1169e45d2716d769be78cf38bcea449414e6ce75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1169e45d2716d769be78cf38bcea449414e6ce75/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f13e17fff3c787928f674a9ba26fd5517fc387d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f13e17fff3c787928f674a9ba26fd5517fc387d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f13e17fff3c787928f674a9ba26fd5517fc387d"}], "stats": {"total": 474, "additions": 433, "deletions": 41}, "files": [{"sha": "bdb1b612ccb8f4caa30ad4e74cd178181569885a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -1,3 +1,38 @@\n+2011-07-27  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* params.h (ALLOW_STORE_DATA_RACES): New.\n+\t* params.def (PARAM_ALLOW_STORE_DATA_RACES): New.\n+\t* Makefile.in (expr.o): Depend on PARAMS_H.\n+\t* machmode.h (get_best_mode): Add argument.\n+\t* fold-const.c (optimize_bit_field_compare): Add argument to\n+\tget_best_mode.\n+\t(fold_truthop): Same.\n+\t* ifcvt.c (noce_emit_move_insn): Add argument to store_bit_field.\n+\t* expr.c (emit_group_store): Same.\n+\t(copy_blkmode_from_reg): Same.\n+\t(write_complex_part): Same.\n+\t(optimize_bitfield_assignment_op): Add argument.\n+\tAdd argument to get_best_mode.\n+\t(get_bit_range): New.\n+\t(expand_assignment): Calculate maxbits and pass it down\n+\taccordingly.\n+\t(store_field): New argument.\n+\t(expand_expr_real_2): New argument to store_field.\n+\tInclude params.h.\n+\t* expr.h (store_bit_field): New argument.\n+\t* stor-layout.c (get_best_mode): Restrict mode expansion by taking\n+\tinto account maxbits.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): New argument\n+\tto store_bit_field.\n+\t* expmed.c (store_bit_field_1): New argument.  Use it.\n+\t(store_bit_field): Same.\n+\t(store_fixed_bit_field): Same.\n+\t(store_split_bit_field): Same.\n+\t(extract_bit_field_1): Pass new argument to get_best_mode.\n+\t(extract_bit_field): Same.\n+\t* stmt.c (store_bit_field): Pass new argument to store_bit_field.\n+\t* doc/invoke.texi: Document parameter allow-store-data-races.\n+\n 2011-07-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (gen_producer_string): Ignore also -fverbose-asm"}, {"sha": "593c951b497e67fb6e1497f82ac106a8896882f7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -2909,7 +2909,7 @@ expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    reload.h langhooks.h intl.h $(TM_P_H) $(TARGET_H) \\\n    tree-iterator.h gt-expr.h $(MACHMODE_H) $(TIMEVAR_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(DF_H) $(DIAGNOSTIC_H) vecprim.h $(SSAEXPAND_H) \\\n-   $(COMMON_TARGET_H)\n+   $(PARAMS_H) $(COMMON_TARGET_H)\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h $(GGC_H) gt-dojump.h vecprim.h $(BASIC_BLOCK_H) output.h"}, {"sha": "dfa9ceb556332eadc4b2a8ccd8c1ac1cf2898a42", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -924,8 +924,8 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    emit_move_insn (reg, const0_rtx);\n \n \t    bytes -= bitsize / BITS_PER_UNIT;\n-\t    store_bit_field (reg, bitsize, endian_correction, word_mode,\n-\t\t\t     word);\n+\t    store_bit_field (reg, bitsize, endian_correction, 0, 0,\n+\t\t\t     word_mode, word);\n \t  }\n       }\n }"}, {"sha": "db9a5da50510eb43befb7ac2863e316e327b0a84", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -9058,6 +9058,11 @@ The maximum number of conditional stores paires that can be sunk.  Set to 0\n if either vectorization (@option{-ftree-vectorize}) or if-conversion\n (@option{-ftree-loop-if-convert}) is disabled.  The default is 2.\n \n+@item allow-store-data-races\n+Allow optimizers to introduce new data races on stores.\n+Set to 1 to allow, otherwise to 0.  This option is enabled by default\n+unless implicitly set by the @option{-fmemory-model=} option.\n+\n @item case-values-threshold\n The smallest number of different values for which it is best to use a\n jump-table instead of a tree of conditional branches.  If the value is"}, {"sha": "92167f148ab3fbc2e2a80a9adb8fb06a16549f14", "filename": "gcc/expmed.c", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -47,9 +47,15 @@ struct target_expmed *this_target_expmed = &default_target_expmed;\n \n static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT, rtx);\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   rtx);\n static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT, rtx);\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   rtx);\n static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n@@ -333,7 +339,10 @@ mode_for_extraction (enum extraction_pattern pattern, int opno)\n \n static bool\n store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n+\t\t   unsigned HOST_WIDE_INT bitnum,\n+\t\t   unsigned HOST_WIDE_INT bitregion_start,\n+\t\t   unsigned HOST_WIDE_INT bitregion_end,\n+\t\t   enum machine_mode fieldmode,\n \t\t   rtx value, bool fallback_p)\n {\n   unsigned int unit\n@@ -455,6 +464,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   /* We may be accessing data outside the field, which means\n      we can alias adjacent data.  */\n+  /* ?? not always for C++0x memory model ?? */\n   if (MEM_P (op0))\n     {\n       op0 = shallow_copy_rtx (op0);\n@@ -547,7 +557,9 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n \t  if (!store_bit_field_1 (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t    bitsize - i * BITS_PER_WORD),\n-\t\t\t\t  bitnum + bit_offset, word_mode,\n+\t\t\t\t  bitnum + bit_offset,\n+\t\t\t\t  bitregion_start, bitregion_end,\n+\t\t\t\t  word_mode,\n \t\t\t\t  value_word, fallback_p))\n \t    {\n \t      delete_insns_since (last);\n@@ -710,16 +722,23 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (HAVE_insv && MEM_P (op0))\n     {\n       enum machine_mode bestmode;\n+      unsigned HOST_WIDE_INT maxbits = MAX_FIXED_MODE_SIZE;\n+\n+      if (bitregion_end)\n+\tmaxbits = bitregion_end - bitregion_start + 1;\n \n       /* Get the mode to use for inserting into this field.  If OP0 is\n \t BLKmode, get the smallest mode consistent with the alignment. If\n \t OP0 is a non-BLKmode object that is no wider than OP_MODE, use its\n \t mode. Otherwise, use the smallest mode containing the field.  */\n \n       if (GET_MODE (op0) == BLKmode\n+\t  || GET_MODE_BITSIZE (GET_MODE (op0)) > maxbits\n \t  || (op_mode != MAX_MACHINE_MODE\n \t      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (op_mode)))\n-\tbestmode = get_best_mode (bitsize, bitnum, MEM_ALIGN (op0),\n+\tbestmode = get_best_mode  (bitsize, bitnum,\n+\t\t\t\t  bitregion_start, bitregion_end,\n+\t\t\t\t  MEM_ALIGN (op0),\n \t\t\t\t  (op_mode == MAX_MACHINE_MODE\n \t\t\t\t   ? VOIDmode : op_mode),\n \t\t\t\t  MEM_VOLATILE_P (op0));\n@@ -748,6 +767,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t     the unit.  */\n \t  tempreg = copy_to_reg (xop0);\n \t  if (store_bit_field_1 (tempreg, bitsize, xbitpos,\n+\t\t\t\t bitregion_start, bitregion_end,\n \t\t\t\t fieldmode, orig_value, false))\n \t    {\n \t      emit_move_insn (xop0, tempreg);\n@@ -760,21 +780,59 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (!fallback_p)\n     return false;\n \n-  store_fixed_bit_field (op0, offset, bitsize, bitpos, value);\n+  store_fixed_bit_field (op0, offset, bitsize, bitpos,\n+\t\t\t bitregion_start, bitregion_end, value);\n   return true;\n }\n \n /* Generate code to store value from rtx VALUE\n    into a bit-field within structure STR_RTX\n    containing BITSIZE bits starting at bit BITNUM.\n+\n+   BITREGION_START is bitpos of the first bitfield in this region.\n+   BITREGION_END is the bitpos of the ending bitfield in this region.\n+   These two fields are 0, if the C++ memory model does not apply,\n+   or we are not interested in keeping track of bitfield regions.\n+\n    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.  */\n \n void\n store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n+\t\t unsigned HOST_WIDE_INT bitnum,\n+\t\t unsigned HOST_WIDE_INT bitregion_start,\n+\t\t unsigned HOST_WIDE_INT bitregion_end,\n+\t\t enum machine_mode fieldmode,\n \t\t rtx value)\n {\n-  if (!store_bit_field_1 (str_rtx, bitsize, bitnum, fieldmode, value, true))\n+  /* Under the C++0x memory model, we must not touch bits outside the\n+     bit region.  Adjust the address to start at the beginning of the\n+     bit region.  */\n+  if (MEM_P (str_rtx)\n+      && bitregion_start > 0)\n+    {\n+      enum machine_mode bestmode;\n+      enum machine_mode op_mode;\n+      unsigned HOST_WIDE_INT offset;\n+\n+      op_mode = mode_for_extraction (EP_insv, 3);\n+      if (op_mode == MAX_MACHINE_MODE)\n+\top_mode = VOIDmode;\n+\n+      offset = bitregion_start / BITS_PER_UNIT;\n+      bitnum -= bitregion_start;\n+      bitregion_end -= bitregion_start;\n+      bitregion_start = 0;\n+      bestmode = get_best_mode (bitsize, bitnum,\n+\t\t\t\tbitregion_start, bitregion_end,\n+\t\t\t\tMEM_ALIGN (str_rtx),\n+\t\t\t\top_mode,\n+\t\t\t\tMEM_VOLATILE_P (str_rtx));\n+      str_rtx = adjust_address (str_rtx, bestmode, offset);\n+    }\n+\n+  if (!store_bit_field_1 (str_rtx, bitsize, bitnum,\n+\t\t\t  bitregion_start, bitregion_end,\n+\t\t\t  fieldmode, value, true))\n     gcc_unreachable ();\n }\n \f\n@@ -790,7 +848,10 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n static void\n store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t\t       unsigned HOST_WIDE_INT bitsize,\n-\t\t       unsigned HOST_WIDE_INT bitpos, rtx value)\n+\t\t       unsigned HOST_WIDE_INT bitpos,\n+\t\t       unsigned HOST_WIDE_INT bitregion_start,\n+\t\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t\t       rtx value)\n {\n   enum machine_mode mode;\n   unsigned int total_bits = BITS_PER_WORD;\n@@ -811,12 +872,19 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n       /* Special treatment for a bit field split across two registers.  */\n       if (bitsize + bitpos > BITS_PER_WORD)\n \t{\n-\t  store_split_bit_field (op0, bitsize, bitpos, value);\n+\t  store_split_bit_field (op0, bitsize, bitpos,\n+\t\t\t\t bitregion_start, bitregion_end,\n+\t\t\t\t value);\n \t  return;\n \t}\n     }\n   else\n     {\n+      unsigned HOST_WIDE_INT maxbits = MAX_FIXED_MODE_SIZE;\n+\n+      if (bitregion_end)\n+\tmaxbits = bitregion_end - bitregion_start + 1;\n+\n       /* Get the proper mode to use for this field.  We want a mode that\n \t includes the entire field.  If such a mode would be larger than\n \t a word, we won't be doing the extraction the normal way.\n@@ -829,18 +897,20 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \n       if (MEM_VOLATILE_P (op0)\n           && GET_MODE_BITSIZE (GET_MODE (op0)) > 0\n+\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= maxbits\n \t  && flag_strict_volatile_bitfields > 0)\n \tmode = GET_MODE (op0);\n       else\n \tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n+\t\t\t      bitregion_start, bitregion_end,\n \t\t\t      MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t{\n \t  /* The only way this should occur is if the field spans word\n \t     boundaries.  */\n \t  store_split_bit_field (op0, bitsize, bitpos + offset * BITS_PER_UNIT,\n-\t\t\t\t value);\n+\t\t\t\t bitregion_start, bitregion_end, value);\n \t  return;\n \t}\n \n@@ -960,7 +1030,10 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \n static void\n store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t       unsigned HOST_WIDE_INT bitpos, rtx value)\n+\t\t       unsigned HOST_WIDE_INT bitpos,\n+\t\t       unsigned HOST_WIDE_INT bitregion_start,\n+\t\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t\t       rtx value)\n {\n   unsigned int unit;\n   unsigned int bitsdone = 0;\n@@ -1075,7 +1148,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t it is just an out-of-bounds access.  Ignore it.  */\n       if (word != const0_rtx)\n \tstore_fixed_bit_field (word, offset * unit / BITS_PER_UNIT, thissize,\n-\t\t\t       thispos, part);\n+\t\t\t       thispos, bitregion_start, bitregion_end, part);\n       bitsdone += thissize;\n     }\n }\n@@ -1515,7 +1588,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (GET_MODE (op0) == BLKmode\n \t  || (ext_mode != MAX_MACHINE_MODE\n \t      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (ext_mode)))\n-\tbestmode = get_best_mode (bitsize, bitnum, MEM_ALIGN (op0),\n+\tbestmode = get_best_mode (bitsize, bitnum, 0, 0, MEM_ALIGN (op0),\n \t\t\t\t  (ext_mode == MAX_MACHINE_MODE\n \t\t\t\t   ? VOIDmode : ext_mode),\n \t\t\t\t  MEM_VOLATILE_P (op0));\n@@ -1641,7 +1714,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t    mode = tmode;\n \t}\n       else\n-\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n+\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT, 0, 0,\n \t\t\t      MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)"}, {"sha": "0988c51e545e9b2bda66908ab0446b4387d5e1f7", "filename": "gcc/expr.c", "status": "modified", "additions": 154, "deletions": 14, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"ssaexpand.h\"\n #include \"target-globals.h\"\n+#include \"params.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n@@ -143,7 +144,9 @@ static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t     tree, tree, int, alias_set_type);\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n-static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n+static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\tenum machine_mode,\n \t\t\ttree, tree, alias_set_type, bool);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (const_tree, const_tree);\n@@ -2074,7 +2077,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \temit_move_insn (adjust_address (dest, mode, bytepos), tmps[i]);\n       else\n \tstore_bit_field (dest, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n-\t\t\t mode, tmps[i]);\n+\t\t\t 0, 0, mode, tmps[i]);\n     }\n \n   /* Copy from the pseudo into the (probable) hard reg.  */\n@@ -2168,7 +2171,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n \n       /* Use xbitpos for the source extraction (right justified) and\n \t bitpos for the destination store (left justified).  */\n-      store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, copy_mode,\n+      store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, 0, 0, copy_mode,\n \t\t       extract_bit_field (src, bitsize,\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1, false,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode));\n@@ -2805,7 +2808,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n \tgcc_assert (MEM_P (cplx) && ibitsize < BITS_PER_WORD);\n     }\n \n-  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, imode, val);\n+  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, 0, 0, imode, val);\n }\n \n /* Extract one of the components of the complex value CPLX.  Extract the\n@@ -3940,6 +3943,8 @@ get_subtarget (rtx x)\n static bool\n optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t unsigned HOST_WIDE_INT bitpos,\n+\t\t\t\t unsigned HOST_WIDE_INT bitregion_start,\n+\t\t\t\t unsigned HOST_WIDE_INT bitregion_end,\n \t\t\t\t enum machine_mode mode1, rtx str_rtx,\n \t\t\t\t tree to, tree src)\n {\n@@ -4001,6 +4006,7 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n       if (str_bitsize == 0 || str_bitsize > BITS_PER_WORD)\n \tstr_mode = word_mode;\n       str_mode = get_best_mode (bitsize, bitpos,\n+\t\t\t\tbitregion_start, bitregion_end,\n \t\t\t\tMEM_ALIGN (str_rtx), str_mode, 0);\n       if (str_mode == VOIDmode)\n \treturn false;\n@@ -4109,6 +4115,113 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n   return false;\n }\n \n+/* In the C++ memory model, consecutive bit fields in a structure are\n+   considered one memory location.\n+\n+   Given a COMPONENT_REF, this function returns the bit range of\n+   consecutive bits in which this COMPONENT_REF belongs in.  The\n+   values are returned in *BITSTART and *BITEND.  If either the C++\n+   memory model is not activated, or this memory access is not thread\n+   visible, 0 is returned in *BITSTART and *BITEND.\n+\n+   EXP is the COMPONENT_REF.\n+   INNERDECL is the actual object being referenced.\n+   BITPOS is the position in bits where the bit starts within the structure.\n+   BITSIZE is size in bits of the field being referenced in EXP.\n+\n+   For example, while storing into FOO.A here...\n+\n+      struct {\n+        BIT 0:\n+          unsigned int a : 4;\n+\t  unsigned int b : 1;\n+\tBIT 8:\n+\t  unsigned char c;\n+\t  unsigned int d : 6;\n+      } foo;\n+\n+   ...we are not allowed to store past <b>, so for the layout above, a\n+   range of 0..7 (because no one cares if we store into the\n+   padding).  */\n+\n+static void\n+get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n+\t       unsigned HOST_WIDE_INT *bitend,\n+\t       tree exp, tree innerdecl,\n+\t       HOST_WIDE_INT bitpos, HOST_WIDE_INT bitsize)\n+{\n+  tree field, record_type, fld;\n+  bool found_field = false;\n+  bool prev_field_is_bitfield;\n+\n+  gcc_assert (TREE_CODE (exp) == COMPONENT_REF);\n+\n+  /* If other threads can't see this value, no need to restrict stores.  */\n+  if (ALLOW_STORE_DATA_RACES\n+      || (!ptr_deref_may_alias_global_p (innerdecl)\n+\t  && (DECL_THREAD_LOCAL_P (innerdecl)\n+\t      || !TREE_STATIC (innerdecl))))\n+    {\n+      *bitstart = *bitend = 0;\n+      return;\n+    }\n+\n+  /* Bit field we're storing into.  */\n+  field = TREE_OPERAND (exp, 1);\n+  record_type = DECL_FIELD_CONTEXT (field);\n+\n+  /* Count the contiguous bitfields for the memory location that\n+     contains FIELD.  */\n+  *bitstart = 0;\n+  prev_field_is_bitfield = true;\n+  for (fld = TYPE_FIELDS (record_type); fld; fld = DECL_CHAIN (fld))\n+    {\n+      tree t, offset;\n+      enum machine_mode mode;\n+      int unsignedp, volatilep;\n+\n+      if (TREE_CODE (fld) != FIELD_DECL)\n+\tcontinue;\n+\n+      t = build3 (COMPONENT_REF, TREE_TYPE (exp),\n+\t\t  unshare_expr (TREE_OPERAND (exp, 0)),\n+\t\t  fld, NULL_TREE);\n+      get_inner_reference (t, &bitsize, &bitpos, &offset,\n+\t\t\t   &mode, &unsignedp, &volatilep, true);\n+\n+      if (field == fld)\n+\tfound_field = true;\n+\n+      if (DECL_BIT_FIELD_TYPE (fld) && bitsize > 0)\n+\t{\n+\t  if (prev_field_is_bitfield == false)\n+\t    {\n+\t      *bitstart = bitpos;\n+\t      prev_field_is_bitfield = true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  prev_field_is_bitfield = false;\n+\t  if (found_field)\n+\t    break;\n+\t}\n+    }\n+  gcc_assert (found_field);\n+\n+  if (fld)\n+    {\n+      /* We found the end of the bit field sequence.  Include the\n+\t padding up to the next field and be done.  */\n+      *bitend = bitpos - 1;\n+    }\n+  else\n+    {\n+      /* If this is the last element in the structure, include the padding\n+\t at the end of structure.  */\n+      *bitend = TREE_INT_CST_LOW (TYPE_SIZE (record_type)) - 1;\n+    }\n+}\n \n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n    is true, try generating a nontemporal store.  */\n@@ -4208,6 +4321,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n     {\n       enum machine_mode mode1;\n       HOST_WIDE_INT bitsize, bitpos;\n+      unsigned HOST_WIDE_INT bitregion_start = 0;\n+      unsigned HOST_WIDE_INT bitregion_end = 0;\n       tree offset;\n       int unsignedp;\n       int volatilep = 0;\n@@ -4217,6 +4332,11 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n \t\t\t\t &unsignedp, &volatilep, true);\n \n+      if (TREE_CODE (to) == COMPONENT_REF\n+\t  && DECL_BIT_FIELD_TYPE (TREE_OPERAND (to, 1)))\n+\tget_bit_range (&bitregion_start, &bitregion_end,\n+\t\t       to, tem, bitpos, bitsize);\n+\n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */\n \n@@ -4298,11 +4418,14 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t\t nontemporal);\n \t  else if (bitpos + bitsize <= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 0), bitsize, bitpos,\n+\t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  mode1, from, TREE_TYPE (tem),\n \t\t\t\t  get_alias_set (to), nontemporal);\n \t  else if (bitpos >= mode_bitsize / 2)\n \t    result = store_field (XEXP (to_rtx, 1), bitsize,\n-\t\t\t\t  bitpos - mode_bitsize / 2, mode1, from,\n+\t\t\t\t  bitpos - mode_bitsize / 2,\n+\t\t\t\t  bitregion_start, bitregion_end,\n+\t\t\t\t  mode1, from,\n \t\t\t\t  TREE_TYPE (tem), get_alias_set (to),\n \t\t\t\t  nontemporal);\n \t  else if (bitpos == 0 && bitsize == mode_bitsize)\n@@ -4323,7 +4446,9 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\t\t\t\t    0);\n \t      write_complex_part (temp, XEXP (to_rtx, 0), false);\n \t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n-\t      result = store_field (temp, bitsize, bitpos, mode1, from,\n+\t      result = store_field (temp, bitsize, bitpos,\n+\t\t\t\t    bitregion_start, bitregion_end,\n+\t\t\t\t    mode1, from,\n \t\t\t\t    TREE_TYPE (tem), get_alias_set (to),\n \t\t\t\t    nontemporal);\n \t      emit_move_insn (XEXP (to_rtx, 0), read_complex_part (temp, false));\n@@ -4348,11 +4473,15 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t\tMEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t    }\n \n-\t  if (optimize_bitfield_assignment_op (bitsize, bitpos, mode1,\n+\t  if (optimize_bitfield_assignment_op (bitsize, bitpos,\n+\t\t\t\t\t       bitregion_start, bitregion_end,\n+\t\t\t\t\t       mode1,\n \t\t\t\t\t       to_rtx, to, from))\n \t    result = NULL;\n \t  else\n-\t    result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n+\t    result = store_field (to_rtx, bitsize, bitpos,\n+\t\t\t\t  bitregion_start, bitregion_end,\n+\t\t\t\t  mode1, from,\n \t\t\t\t  TREE_TYPE (tem), get_alias_set (to),\n \t\t\t\t  nontemporal);\n \t}\n@@ -4745,7 +4874,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t      : BLOCK_OP_NORMAL));\n \t  else if (GET_MODE (target) == BLKmode)\n \t    store_bit_field (target, INTVAL (expr_size (exp)) * BITS_PER_UNIT,\n-\t\t\t     0, GET_MODE (temp), temp);\n+\t\t\t     0, 0, 0, GET_MODE (temp), temp);\n \t  else\n \t    convert_move (target, temp, unsignedp);\n \t}\n@@ -5210,7 +5339,8 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n-    store_field (target, bitsize, bitpos, mode, exp, type, alias_set, false);\n+    store_field (target, bitsize, bitpos, 0, 0, mode, exp, type, alias_set,\n+\t\t false);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -5784,6 +5914,11 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n    BITSIZE bits, starting BITPOS bits from the start of TARGET.\n    If MODE is VOIDmode, it means that we are storing into a bit-field.\n \n+   BITREGION_START is bitpos of the first bitfield in this region.\n+   BITREGION_END is the bitpos of the ending bitfield in this region.\n+   These two fields are 0, if the C++ memory model does not apply,\n+   or we are not interested in keeping track of bitfield regions.\n+\n    Always return const0_rtx unless we have something particular to\n    return.\n \n@@ -5797,6 +5932,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n+\t     unsigned HOST_WIDE_INT bitregion_start,\n+\t     unsigned HOST_WIDE_INT bitregion_end,\n \t     enum machine_mode mode, tree exp, tree type,\n \t     alias_set_type alias_set, bool nontemporal)\n {\n@@ -5829,8 +5966,9 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n \temit_move_insn (object, target);\n \n-      store_field (blk_object, bitsize, bitpos, mode, exp, type, alias_set,\n-\t\t   nontemporal);\n+      store_field (blk_object, bitsize, bitpos,\n+\t\t   bitregion_start, bitregion_end,\n+\t\t   mode, exp, type, alias_set, nontemporal);\n \n       emit_move_insn (target, object);\n \n@@ -5944,7 +6082,9 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t}\n \n       /* Store the value in the bitfield.  */\n-      store_bit_field (target, bitsize, bitpos, mode, temp);\n+      store_bit_field (target, bitsize, bitpos,\n+\t\t       bitregion_start, bitregion_end,\n+\t\t       mode, temp);\n \n       return const0_rtx;\n     }\n@@ -7354,7 +7494,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t\t\t\t\t    (treeop0))\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n-\t\t\t   0, TYPE_MODE (valtype), treeop0,\n+\t\t\t   0, 0, 0, TYPE_MODE (valtype), treeop0,\n \t\t\t   type, 0, false);\n \t    }\n "}, {"sha": "74c608ad1ae0f9d6d8947bebf8a3dcfb87beca49", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -665,7 +665,10 @@ extern enum machine_mode\n mode_for_extraction (enum extraction_pattern, int);\n \n extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t     unsigned HOST_WIDE_INT, enum machine_mode, rtx);\n+\t\t\t     unsigned HOST_WIDE_INT,\n+\t\t\t     unsigned HOST_WIDE_INT,\n+\t\t\t     unsigned HOST_WIDE_INT,\n+\t\t\t     enum machine_mode, rtx);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, bool, rtx,\n \t\t\t      enum machine_mode, enum machine_mode);"}, {"sha": "736b5cafa50a20462540f45b17677fd0fb0b84ee", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -3394,7 +3394,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n       && flag_strict_volatile_bitfields > 0)\n     nmode = lmode;\n   else\n-    nmode = get_best_mode (lbitsize, lbitpos,\n+    nmode = get_best_mode (lbitsize, lbitpos, 0, 0,\n \t\t\t   const_p ? TYPE_ALIGN (TREE_TYPE (linner))\n \t\t\t   : MIN (TYPE_ALIGN (TREE_TYPE (linner)),\n \t\t\t\t  TYPE_ALIGN (TREE_TYPE (rinner))),\n@@ -5221,7 +5221,7 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n      to be relative to a field of that size.  */\n   first_bit = MIN (ll_bitpos, rl_bitpos);\n   end_bit = MAX (ll_bitpos + ll_bitsize, rl_bitpos + rl_bitsize);\n-  lnmode = get_best_mode (end_bit - first_bit, first_bit,\n+  lnmode = get_best_mode (end_bit - first_bit, first_bit, 0, 0,\n \t\t\t  TYPE_ALIGN (TREE_TYPE (ll_inner)), word_mode,\n \t\t\t  volatilep);\n   if (lnmode == VOIDmode)\n@@ -5286,7 +5286,7 @@ fold_truthop (location_t loc, enum tree_code code, tree truth_type,\n \n       first_bit = MIN (lr_bitpos, rr_bitpos);\n       end_bit = MAX (lr_bitpos + lr_bitsize, rr_bitpos + rr_bitsize);\n-      rnmode = get_best_mode (end_bit - first_bit, first_bit,\n+      rnmode = get_best_mode (end_bit - first_bit, first_bit, 0, 0,\n \t\t\t      TYPE_ALIGN (TREE_TYPE (lr_inner)), word_mode,\n \t\t\t      volatilep);\n       if (rnmode == VOIDmode)"}, {"sha": "a26df192a923d62b315841dd6724ea9b587f19ce", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -885,7 +885,7 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t}\n \n \t      gcc_assert (start < (MEM_P (op) ? BITS_PER_UNIT : BITS_PER_WORD));\n-\t      store_bit_field (op, size, start, GET_MODE (x), y);\n+\t      store_bit_field (op, size, start, 0, 0, GET_MODE (x), y);\n \t      return;\n \t    }\n \n@@ -939,7 +939,8 @@ noce_emit_move_insn (rtx x, rtx y)\n   inner = XEXP (outer, 0);\n   outmode = GET_MODE (outer);\n   bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;\n-  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos, outmode, y);\n+  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos,\n+\t\t   0, 0, outmode, y);\n }\n \n /* Return sequence of instructions generated by if conversion.  This"}, {"sha": "b965d0f874a16541d3f2d15f5bc7d77ca536c0fe", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -248,7 +248,10 @@ extern enum machine_mode mode_for_vector (enum machine_mode, unsigned);\n \n /* Find the best mode to use to access a bit field.  */\n \n-extern enum machine_mode get_best_mode (int, int, unsigned int,\n+extern enum machine_mode get_best_mode (int, int,\n+\t\t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\t\tunsigned int,\n \t\t\t\t\tenum machine_mode, int);\n \n /* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */"}, {"sha": "e8372ed7eb5f3ad2b4b0aca97c3a15ccd63eb67d", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -908,6 +908,12 @@ DEFPARAM (PARAM_CASE_VALUES_THRESHOLD,\n \t  \"if 0, use the default for the machine\",\n           0, 0, 0)\n \n+/* Data race flags for C++0x memory model compliance.  */\n+DEFPARAM (PARAM_ALLOW_STORE_DATA_RACES,\n+\t  \"allow-store-data-races\",\n+\t  \"Allow new data races on stores to be introduced\",\n+\t  1, 0, 1)\n+\n \n /*\n Local variables:"}, {"sha": "783f3b3d51d30ecd5cac19523473f04a730e5b4a", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -211,4 +211,6 @@ extern void init_param_values (int *params);\n   PARAM_VALUE (PARAM_MIN_NONDEBUG_INSN_UID)\n #define MAX_STORES_TO_SINK \\\n   PARAM_VALUE (PARAM_MAX_STORES_TO_SINK)\n+#define ALLOW_STORE_DATA_RACES \\\n+  PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "2fb4b18dd55b733262e3c7a83514f2ee1cd7e61d", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -1759,7 +1759,8 @@ expand_return (tree retval)\n \n \t  /* Use bitpos for the source extraction (left justified) and\n \t     xbitpos for the destination store (right justified).  */\n-\t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, word_mode,\n+\t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD,\n+\t\t\t   0, 0, word_mode,\n \t\t\t   extract_bit_field (src, bitsize,\n \t\t\t\t\t      bitpos % BITS_PER_WORD, 1, false,\n \t\t\t\t\t      NULL_RTX, word_mode, word_mode));"}, {"sha": "fee26e6ce9c30d3d87f779cb4090b08a74baa108", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -2361,6 +2361,13 @@ fixup_unsigned_type (tree type)\n /* Find the best machine mode to use when referencing a bit field of length\n    BITSIZE bits starting at BITPOS.\n \n+   BITREGION_START is the bit position of the first bit in this\n+   sequence of bit fields.  BITREGION_END is the last bit in this\n+   sequence.  If these two fields are non-zero, we should restrict the\n+   memory access to a maximum sized chunk of\n+   BITREGION_END - BITREGION_START + 1.  Otherwise, we are allowed to touch\n+   any adjacent non bit-fields.\n+\n    The underlying object is known to be aligned to a boundary of ALIGN bits.\n    If LARGEST_MODE is not VOIDmode, it means that we should not use a mode\n    larger than LARGEST_MODE (usually SImode).\n@@ -2378,11 +2385,21 @@ fixup_unsigned_type (tree type)\n    decide which of the above modes should be used.  */\n \n enum machine_mode\n-get_best_mode (int bitsize, int bitpos, unsigned int align,\n+get_best_mode (int bitsize, int bitpos,\n+\t       unsigned HOST_WIDE_INT bitregion_start,\n+\t       unsigned HOST_WIDE_INT bitregion_end,\n+\t       unsigned int align,\n \t       enum machine_mode largest_mode, int volatilep)\n {\n   enum machine_mode mode;\n   unsigned int unit = 0;\n+  unsigned HOST_WIDE_INT maxbits;\n+\n+  /* If unset, no restriction.  */\n+  if (!bitregion_end)\n+    maxbits = MAX_FIXED_MODE_SIZE;\n+  else\n+    maxbits = (bitregion_end - bitregion_start) % align + 1;\n \n   /* Find the narrowest integer mode that contains the bit field.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n@@ -2419,6 +2436,7 @@ get_best_mode (int bitsize, int bitpos, unsigned int align,\n \t      && bitpos / unit == (bitpos + bitsize - 1) / unit\n \t      && unit <= BITS_PER_WORD\n \t      && unit <= MIN (align, BIGGEST_ALIGNMENT)\n+\t      && unit <= maxbits\n \t      && (largest_mode == VOIDmode\n \t\t  || unit <= GET_MODE_BITSIZE (largest_mode)))\n \t    wide_mode = tmode;"}, {"sha": "b98b56daa91a79b6ae3591a360b519de2a3f06b1", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-2.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n+\n+/* Test that we don't store past VAR.K.  */\n+\n+struct S\n+{\n+  volatile int i;\n+  volatile int j: 32;\n+  volatile int k: 15;\n+  volatile char c[2];\n+} var;\n+\n+void setit()\n+{\n+  var.k = 13;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl.*, var\" } } */"}, {"sha": "6fc4876f0ea6c35a608e3fc1736bdb51967d8e64", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-3.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n+\n+/* Make sure we don't narrow down to a QI or HI to store into VAR.J,\n+   but instead use an SI.  */\n+\n+struct S\n+{ \n+  volatile int i: 4;\n+  volatile int j: 4;\n+  volatile int k: 8;\n+  volatile int l: 8;\n+  volatile int m: 8;\n+} var;\n+\n+void setit()\n+{ \n+  var.j = 5;\n+}\n+\n+/* { dg-final { scan-assembler \"movl.*, var\" } } */"}, {"sha": "a2d55f4a8c4fbb688d9e58d24833a6d650ad732d", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-4.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n+\n+struct bits\n+{\n+  char a;\n+  int b:7;\n+  int c:9;\n+  unsigned char d;\n+} x;\n+\n+/* Store into <c> should not clobber <d>.  */\n+void update_c(struct bits *p, int val) \n+{\n+    p -> c = val;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\" } } */"}, {"sha": "69e4e1067bf627d2b214448c163acb263547f251", "filename": "gcc/testsuite/c-c++-common/cxxbitfields-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields-5.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n+\n+#include <stdlib.h>\n+\n+struct bits\n+{\n+  char a;\n+  int b:7;\n+  int c:9;\n+  unsigned char d;\n+} x;\n+\n+struct bits *p;\n+\n+static void allocit()\n+{\n+  p = (struct bits *) malloc (sizeof (struct bits));\n+}\n+\n+/* Store into <c> should not clobber <d>.  */\n+/* We should not use a 32-bit move to store into p->, but a smaller move.  */\n+void foo()\n+{\n+  allocit();\n+  p -> c = 55;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\\t\\\\(\" } } */"}, {"sha": "43c840b15ebcfa9c35fd5b4dba3088131ee791b7", "filename": "gcc/testsuite/c-c++-common/cxxbitfields.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1169e45d2716d769be78cf38bcea449414e6ce75/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcxxbitfields.c?ref=1169e45d2716d769be78cf38bcea449414e6ce75", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 --param allow-store-data-races=0\" } */\n+\n+/* Test that we don't store past VAR.A.  */\n+\n+struct S\n+{\n+  volatile unsigned int a : 4;\n+  unsigned char b;\n+  unsigned int c : 6;\n+} var;\n+\n+void set_a()\n+{\n+  var.a = 12;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl.*, var\" } } */"}]}