{"sha": "4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4ZGNhMWMzYWIwNjBiZDdiYzFiNzBkNGM2MmQ2OTMzZTdiYzQ3OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-01-03T20:04:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-01-03T20:04:38Z"}, "message": "fold-const.c (fold): Avoid NOP_EXPRs better.\n\n        * fold-const.c (fold) [COND_EXPR]: Avoid NOP_EXPRs better.\n\n        * integrate.c (copy_decl_for_inlining): Don't clear the rtl for\n        static/external decls.\ncp/\n        * call.c (build_conditional_expr): Stabilize lvalues properly.\n        * cvt.c (ocp_convert): Don't build NOP_EXPRs of class type.\n        * tree.c (lvalue_p_1): Don't allow sloppy NOP_EXPRs as lvalues.\n        Don't allow CALL_EXPR or VA_ARG_EXPR, either.\n\n        * call.c (convert_like_real): Call decl_constant_value for an\n        IDENTITY_CONV even if there are no more conversions.\n\n        * cvt.c (build_up_reference): Don't push unnamed temps.\n\n        * decl2.c (do_namespace_alias): Namespace aliases are DECL_EXTERNAL.\n\n        * dump.c (cp_dump_tree): Don't try to dump class-specific fields\n        for a backend struct.\n\n        * except.c (wrap_cleanups_r, build_throw): Make\n        MUST_NOT_THROW_EXPRs void.\n        * init.c (expand_default_init): Update to handle MUST_NOT_THROW_EXPR.\n\n        * init.c (build_vec_delete_1): Pre-evaluate the base address.\n\n        * init.c (get_temp_regvar): Simplify logic.\n\n        * tree.c (cp_copy_res_decl_for_inlining): Only do debug tweaks if\n        our replacement is a decl.\n\nFrom-SVN: r60851", "tree": {"sha": "3080ff7fbc3a73e39df1773fb9eda1ec24ad5334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3080ff7fbc3a73e39df1773fb9eda1ec24ad5334"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9aad8f83a8c33f5af53fa712234677766716659d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aad8f83a8c33f5af53fa712234677766716659d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aad8f83a8c33f5af53fa712234677766716659d"}], "stats": {"total": 145, "additions": 103, "deletions": 42}, "files": [{"sha": "b3fbf3b37b11ee1315a49a54c3fd9868c00ca6fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -1,5 +1,10 @@\n 2003-01-02  Jason Merrill  <jason@redhat.com>\n \n+\t* fold-const.c (fold) [COND_EXPR]: Avoid NOP_EXPRs better.\n+\n+\t* integrate.c (copy_decl_for_inlining): Don't clear the rtl for\n+\tstatic/external decls.\n+        \n \t* c-common.c (finish_fname_decls): Put the DECL_STMTs inside the\n \toutermost scope.\n \t* c-decl.c (c_make_fname_decl): Push the decls there, too."}, {"sha": "cdc4127ccf02070faf4712b343c956c21aa81723", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -16,6 +16,32 @@\n \t\n 2003-01-02  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (build_conditional_expr): Stabilize lvalues properly.\n+\t* cvt.c (ocp_convert): Don't build NOP_EXPRs of class type.\n+\t* tree.c (lvalue_p_1): Don't allow sloppy NOP_EXPRs as lvalues.\n+\tDon't allow CALL_EXPR or VA_ARG_EXPR, either.\n+\n+\t* call.c (convert_like_real): Call decl_constant_value for an\n+\tIDENTITY_CONV even if there are no more conversions.\n+\n+\t* cvt.c (build_up_reference): Don't push unnamed temps.\n+\n+\t* decl2.c (do_namespace_alias): Namespace aliases are DECL_EXTERNAL.\n+\n+\t* dump.c (cp_dump_tree): Don't try to dump class-specific fields\n+\tfor a backend struct.\n+\n+\t* except.c (wrap_cleanups_r, build_throw): Make\n+\tMUST_NOT_THROW_EXPRs void.\n+\t* init.c (expand_default_init): Update to handle MUST_NOT_THROW_EXPR.\n+\n+\t* init.c (build_vec_delete_1): Pre-evaluate the base address.\n+\n+\t* init.c (get_temp_regvar): Simplify logic.\n+\n+\t* tree.c (cp_copy_res_decl_for_inlining): Only do debug tweaks if\n+\tour replacement is a decl.\n+\n \t* decl.c (cp_make_fname_decl): Push the decls inside the\n \toutermost scope.\n "}, {"sha": "00458c0624813633edb9c34080445f838cdb8f94", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -2977,7 +2977,12 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     {\n       if (pedantic)\n \tpedwarn (\"ISO C++ forbids omitting the middle term of a ?: expression\");\n-      arg1 = arg2 = save_expr (arg1);\n+\n+      /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n+      if (real_lvalue_p (arg1))\n+\targ2 = arg1 = stabilize_reference (arg1);\n+      else\n+\targ2 = arg1 = save_expr (arg1);\n     }\n \n   /* [expr.cond]\n@@ -3964,6 +3969,12 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n     case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (totype, expr, tf_error | tf_warning);\n+      /* Convert a non-array constant variable to its underlying value, unless we\n+\t are about to bind it to a reference, in which case we need to\n+\t leave it as an lvalue.  */\n+      if (inner >= 0\n+\t  && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n+\texpr = decl_constant_value (expr);\n       return expr;\n     case AMBIG_CONV:\n       /* Call build_user_type_conversion again for the error.  */\n@@ -3979,13 +3990,6 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n-  /* Convert a non-array constant variable to its underlying value, unless we\n-     are about to bind it to a reference, in which case we need to\n-     leave it as an lvalue.  */\n-  if (TREE_CODE (convs) != REF_BIND\n-      && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n-    expr = decl_constant_value (expr);\n-\n   switch (TREE_CODE (convs))\n     {\n     case RVALUE_CONV:"}, {"sha": "48477735ac1be9128f9759fe7406ada42ad31519", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -381,7 +381,8 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \t{\n \t  /* Automatic; make sure we handle the cleanup properly.  */\n \t  maybe_push_cleanup_level (argtype);\n-\t  arg = pushdecl (arg);\n+\t  /* Don't push unnamed temps.  Do set DECL_CONTEXT, though.  */\n+\t  DECL_CONTEXT (arg) = current_function_decl;\n \t}\n \n       /* Process the initializer for the declaration.  */\n@@ -654,6 +655,19 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n          conversion.  */\n       else if (TREE_CODE (type) == COMPLEX_TYPE)\n         return fold (convert_to_complex (type, e));\n+      else if (TREE_CODE (e) == TARGET_EXPR)\n+\t{\n+\t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n+\t     type of the temporary.  Only allow this for cv-qual changes,\n+\t     though.  */\n+\t  if (!same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (e)),\n+\t\t\t    TYPE_MAIN_VARIANT (type)))\n+\t    abort ();\n+\t  TREE_TYPE (e) = TREE_TYPE (TARGET_EXPR_SLOT (e)) = type;\n+\t  return e;\n+\t}\n+      else if (CLASS_TYPE_P (type))\n+\tabort ();\n       else\n \treturn fold (build1 (NOP_EXPR, type, e));\n     }"}, {"sha": "4e0b7fed1b72e9d37aed80fdc804f7d288e4f9bc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -4258,6 +4258,7 @@ do_namespace_alias (tree alias, tree namespace)\n   /* Build the alias.  */\n   alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n   DECL_NAMESPACE_ALIAS (alias) = namespace;\n+  DECL_EXTERNAL (alias) = 1;\n   pushdecl (alias);\n }\n "}, {"sha": "b03dc82f1341ebc41c18972af8d73b3b8917f1ce", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -273,6 +273,9 @@ cp_dump_tree (dump_info, t)\n \t  return 1;\n \t}\n       \n+      if (! IS_AGGR_TYPE (t))\n+\tbreak;\n+\n       dump_child (\"vfld\", TYPE_VFIELD (t));\n       if (CLASSTYPE_TEMPLATE_SPECIALIZATION(t))\n         dump_string(di, \"spec\");"}, {"sha": "44309e3ddfbfac9d136f0e23540aa68fac6eab0e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -561,7 +561,7 @@ wrap_cleanups_r (tp, walk_subtrees, data)\n   cleanup = TARGET_EXPR_CLEANUP (exp);\n   if (cleanup)\n     {\n-      cleanup = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (cleanup), cleanup);\n+      cleanup = build1 (MUST_NOT_THROW_EXPR, void_type_node, cleanup);\n       TARGET_EXPR_CLEANUP (exp) = cleanup;\n     }\n \n@@ -733,7 +733,7 @@ build_throw (exp)\n \t  return error_mark_node;\n \t}\n \n-      exp = build1 (MUST_NOT_THROW_EXPR, TREE_TYPE (exp), exp);\n+      exp = build1 (MUST_NOT_THROW_EXPR, void_type_node, exp);\n       /* Prepend the allocation.  */\n       exp = build (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n       if (temp_expr != void_zero_node)"}, {"sha": "2fd0c50779b7a4d9b6a80b9f5672fad142e418f3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -1206,13 +1206,16 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n       else\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n-      if (TREE_CODE (init) == TRY_CATCH_EXPR)\n-\t/* We need to protect the initialization of a catch parm\n-\t   with a call to terminate(), which shows up as a TRY_CATCH_EXPR\n+      if (TREE_CODE (init) == MUST_NOT_THROW_EXPR)\n+\t/* We need to protect the initialization of a catch parm with a\n+\t   call to terminate(), which shows up as a MUST_NOT_THROW_EXPR\n \t   around the TARGET_EXPR for the copy constructor.  See\n-\t   expand_start_catch_block.  */\n-\tTREE_OPERAND (init, 0) = build (INIT_EXPR, TREE_TYPE (exp), exp,\n-\t\t\t\t\tTREE_OPERAND (init, 0));\n+\t   initialize_handler_parm.  */\n+\t{\n+\t  TREE_OPERAND (init, 0) = build (INIT_EXPR, TREE_TYPE (exp), exp,\n+\t\t\t\t\t  TREE_OPERAND (init, 0));\n+\t  TREE_TYPE (init) = void_type_node;\n+\t}\n       else\n \tinit = build (INIT_EXPR, TREE_TYPE (exp), exp, init);\n       TREE_SIDE_EFFECTS (init) = 1;\n@@ -2652,10 +2655,14 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n   if (controller)\n     {\n       TREE_OPERAND (controller, 1) = body;\n-      return controller;\n+      body = controller;\n     }\n-  else\n-    return cp_convert (void_type_node, body);\n+\n+  if (TREE_CODE (base) == SAVE_EXPR)\n+    /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n+    body = build (COMPOUND_EXPR, void_type_node, base, body);\n+\n+  return cp_convert (void_type_node, body);\n }\n \n /* Create an unnamed variable of the indicated TYPE.  */ \n@@ -2693,7 +2700,7 @@ get_temp_regvar (type, init)\n   decl = create_temporary_var (type);\n   if (building_stmt_tree ())\n     add_decl_stmt (decl);\n-  if (!building_stmt_tree ())\n+  else\n     SET_DECL_RTL (decl, assign_temp (type, 2, 0, 1));\n   finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n "}, {"sha": "ad062b7202a533e5efa0f681834847f9008a33f9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -93,13 +93,7 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n \t\t\t allow_cast_as_lvalue);\n \n     case NOP_EXPR:\n-      /* If expression doesn't change the type, we consider it as an\n-\t lvalue even when cast_as_lvalue extension isn't selected.\n-\t That's because parts of the compiler are alleged to be sloppy\n-\t about sticking in NOP_EXPR node for no good reason.  */\n-      if (allow_cast_as_lvalue ||\n-\t  same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ref)),\n-\t\t       TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ref, 0)))))\n+      if (allow_cast_as_lvalue)\n \treturn lvalue_p_1 (TREE_OPERAND (ref, 0),\n \t\t\t   treat_class_rvalues_as_lvalues,\n \t\t\t   allow_cast_as_lvalue);\n@@ -179,9 +173,8 @@ lvalue_p_1 (ref, treat_class_rvalues_as_lvalues, allow_cast_as_lvalue)\n \n     case CALL_EXPR:\n     case VA_ARG_EXPR:\n-      return ((treat_class_rvalues_as_lvalues\n-\t       && IS_AGGR_TYPE (TREE_TYPE (ref)))\n-\t      ? clk_class : clk_none);\n+      /* Any class-valued call would be wrapped in a TARGET_EXPR.  */\n+      return clk_none;\n \n     case FUNCTION_DECL:\n       /* All functions (except non-static-member functions) are\n@@ -2353,13 +2346,16 @@ cp_copy_res_decl_for_inlining (result, fn, caller, decl_map_,\n \t  /* We have a named return value; copy the name and source\n \t     position so we can get reasonable debugging information, and\n \t     register the return variable as its equivalent.  */\n-\t  DECL_NAME (var) = DECL_NAME (nrv);\n-\t  DECL_SOURCE_LOCATION (var) = DECL_SOURCE_LOCATION (nrv);\n-\t  DECL_ABSTRACT_ORIGIN (var) = DECL_ORIGIN (nrv);\n-\t  /* Don't lose initialization info.  */\n-\t  DECL_INITIAL (var) = DECL_INITIAL (nrv);\n-\t  /* Don't forget that it needs to go in the stack.  */\n-\t  TREE_ADDRESSABLE (var) = TREE_ADDRESSABLE (nrv);\n+\t  if (TREE_CODE (var) == VAR_DECL)\n+\t    {\n+\t      DECL_NAME (var) = DECL_NAME (nrv);\n+\t      DECL_SOURCE_LOCATION (var) = DECL_SOURCE_LOCATION (nrv);\n+\t      DECL_ABSTRACT_ORIGIN (var) = DECL_ORIGIN (nrv);\n+\t      /* Don't lose initialization info.  */\n+\t      DECL_INITIAL (var) = DECL_INITIAL (nrv);\n+\t      /* Don't forget that it needs to go in the stack.  */\n+\t      TREE_ADDRESSABLE (var) = TREE_ADDRESSABLE (nrv);\n+\t    }\n \n \t  splay_tree_insert (decl_map,\n \t\t\t     (splay_tree_key) nrv,"}, {"sha": "0c53604e7d521e4a51dfd1a3eb534516607c4496", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -7002,7 +7002,11 @@ fold (expr)\n \n \t      /* Avoid adding NOP_EXPRs in case this is an lvalue.  */\n \t      if (TYPE_MAIN_VARIANT (comp_type) == TYPE_MAIN_VARIANT (type))\n-\t\tcomp_type = type;\n+\t\t{\n+\t\t  comp_type = type;\n+\t\t  comp_op0 = arg1;\n+\t\t  comp_op1 = arg2;\n+\t\t}\n \n \t      switch (comp_code)\n \t\t{"}, {"sha": "8feb845b9e428bd96e19c3dd916e7b20cb6c9244", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=4e8dca1c3ab060bd7bc1b70d4c62d6933e7bc479", "patch": "@@ -394,7 +394,8 @@ copy_decl_for_inlining (decl, from_fn, to_fn)\n   DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n \n   /* The new variable/label has no RTL, yet.  */\n-  SET_DECL_RTL (copy, NULL_RTX);\n+  if (!TREE_STATIC (copy) && !DECL_EXTERNAL (copy))\n+    SET_DECL_RTL (copy, NULL_RTX);\n \n   /* These args would always appear unused, if not for this.  */\n   TREE_USED (copy) = 1;\n@@ -405,10 +406,10 @@ copy_decl_for_inlining (decl, from_fn, to_fn)\n     ;\n   else if (DECL_CONTEXT (decl) != from_fn)\n     /* Things that weren't in the scope of the function we're inlining\n-       from aren't in the scope we're inlining too, either.  */\n+       from aren't in the scope we're inlining to, either.  */\n     ;\n   else if (TREE_STATIC (decl))\n-    /* Function-scoped static variables should say in the original\n+    /* Function-scoped static variables should stay in the original\n        function.  */\n     ;\n   else"}]}