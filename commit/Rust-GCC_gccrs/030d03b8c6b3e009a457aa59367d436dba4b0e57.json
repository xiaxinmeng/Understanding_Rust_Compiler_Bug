{"sha": "030d03b8c6b3e009a457aa59367d436dba4b0e57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMwZDAzYjhjNmIzZTAwOWE0NTdhYTU5MzY3ZDQzNmRiYTRiMGU1Nw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2014-01-16T17:35:50Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2014-01-16T17:35:50Z"}, "message": "re PR target/59780 (ICE in aarch64_split_128bit_move)\n\n\tPR target/59780\n\t* aarch64.c (aarch64_split_128bit_move): Don't lookup REGNO on\n\tnon-register objects.  Use gen_(high/low)part more consistently.\n\tFix assertions.\n\nFrom-SVN: r206671", "tree": {"sha": "d09bf18dcf3f5b5eba3f728612dad79308011f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d09bf18dcf3f5b5eba3f728612dad79308011f3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/030d03b8c6b3e009a457aa59367d436dba4b0e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030d03b8c6b3e009a457aa59367d436dba4b0e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/030d03b8c6b3e009a457aa59367d436dba4b0e57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030d03b8c6b3e009a457aa59367d436dba4b0e57/comments", "author": null, "committer": null, "parents": [{"sha": "e78f06a8c35fcdab58cef654a3a2bc37a5d3c790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78f06a8c35fcdab58cef654a3a2bc37a5d3c790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78f06a8c35fcdab58cef654a3a2bc37a5d3c790"}], "stats": {"total": 133, "additions": 66, "deletions": 67}, "files": [{"sha": "7f6eb7d8b03747153711b81c25755aa2b252715b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030d03b8c6b3e009a457aa59367d436dba4b0e57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030d03b8c6b3e009a457aa59367d436dba4b0e57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=030d03b8c6b3e009a457aa59367d436dba4b0e57", "patch": "@@ -1,3 +1,10 @@\n+2014-01-16  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/59780\n+\t* aarch64.c (aarch64_split_128bit_move): Don't lookup REGNO on\n+\tnon-register objects.  Use gen_(high/low)part more consistently.\n+\tFix assertions.\n+\n 2014-01-16  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/59844"}, {"sha": "96a6d23598116808dd6969d709d0d255a267ff8d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030d03b8c6b3e009a457aa59367d436dba4b0e57/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030d03b8c6b3e009a457aa59367d436dba4b0e57/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=030d03b8c6b3e009a457aa59367d436dba4b0e57", "patch": "@@ -680,90 +680,82 @@ aarch64_emit_move (rtx dest, rtx src)\n \t  : emit_move_insn_1 (dest, src));\n }\n \n+/* Split a 128-bit move operation into two 64-bit move operations,\n+   taking care to handle partial overlap of register to register\n+   copies.  Special cases are needed when moving between GP regs and\n+   FP regs.  SRC can be a register, constant or memory; DST a register\n+   or memory.  If either operand is memory it must not have any side\n+   effects.  */\n void\n aarch64_split_128bit_move (rtx dst, rtx src)\n {\n-  rtx low_dst;\n+  rtx dst_lo, dst_hi;\n+  rtx src_lo, src_hi;\n \n-  enum machine_mode src_mode = GET_MODE (src);\n-  enum machine_mode dst_mode = GET_MODE (dst);\n-  int src_regno = REGNO (src);\n-  int dst_regno = REGNO (dst);\n+  enum machine_mode mode = GET_MODE (dst);\n \n-  gcc_assert (dst_mode == TImode || dst_mode == TFmode);\n+  gcc_assert (mode == TImode || mode == TFmode);\n+  gcc_assert (!(side_effects_p (src) || side_effects_p (dst)));\n+  gcc_assert (mode == GET_MODE (src) || GET_MODE (src) == VOIDmode);\n \n   if (REG_P (dst) && REG_P (src))\n     {\n-      gcc_assert (src_mode == TImode || src_mode == TFmode);\n+      int src_regno = REGNO (src);\n+      int dst_regno = REGNO (dst);\n \n-      /* Handle r -> w, w -> r.  */\n+      /* Handle FP <-> GP regs.  */\n       if (FP_REGNUM_P (dst_regno) && GP_REGNUM_P (src_regno))\n \t{\n-\t  switch (src_mode) {\n-\t  case TImode:\n-\t    emit_insn\n-\t      (gen_aarch64_movtilow_di (dst, gen_lowpart (word_mode, src)));\n-\t    emit_insn\n-\t      (gen_aarch64_movtihigh_di (dst, gen_highpart (word_mode, src)));\n-\t    return;\n-\t  case TFmode:\n-\t    emit_insn\n-\t      (gen_aarch64_movtflow_di (dst, gen_lowpart (word_mode, src)));\n-\t    emit_insn\n-\t      (gen_aarch64_movtfhigh_di (dst, gen_highpart (word_mode, src)));\n-\t    return;\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n+\t  src_lo = gen_lowpart (word_mode, src);\n+\t  src_hi = gen_highpart (word_mode, src);\n+\n+\t  if (mode == TImode)\n+\t    {\n+\t      emit_insn (gen_aarch64_movtilow_di (dst, src_lo));\n+\t      emit_insn (gen_aarch64_movtihigh_di (dst, src_hi));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_aarch64_movtflow_di (dst, src_lo));\n+\t      emit_insn (gen_aarch64_movtfhigh_di (dst, src_hi));\n+\t    }\n+\t  return;\n \t}\n       else if (GP_REGNUM_P (dst_regno) && FP_REGNUM_P (src_regno))\n \t{\n-\t  switch (src_mode) {\n-\t  case TImode:\n-\t    emit_insn\n-\t      (gen_aarch64_movdi_tilow (gen_lowpart (word_mode, dst), src));\n-\t    emit_insn\n-\t      (gen_aarch64_movdi_tihigh (gen_highpart (word_mode, dst), src));\n-\t    return;\n-\t  case TFmode:\n-\t    emit_insn\n-\t      (gen_aarch64_movdi_tflow (gen_lowpart (word_mode, dst), src));\n-\t    emit_insn\n-\t      (gen_aarch64_movdi_tfhigh (gen_highpart (word_mode, dst), src));\n-\t    return;\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n+\t  dst_lo = gen_lowpart (word_mode, dst);\n+\t  dst_hi = gen_highpart (word_mode, dst);\n+\n+\t  if (mode == TImode)\n+\t    {\n+\t      emit_insn (gen_aarch64_movdi_tilow (dst_lo, src));\n+\t      emit_insn (gen_aarch64_movdi_tihigh (dst_hi, src));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_aarch64_movdi_tflow (dst_lo, src));\n+\t      emit_insn (gen_aarch64_movdi_tfhigh (dst_hi, src));\n+\t    }\n+\t  return;\n \t}\n-      /* Fall through to r -> r cases.  */\n     }\n \n-  switch (dst_mode) {\n-  case TImode:\n-    low_dst = gen_lowpart (word_mode, dst);\n-    if (REG_P (low_dst)\n-\t&& reg_overlap_mentioned_p (low_dst, src))\n-      {\n-\taarch64_emit_move (gen_highpart (word_mode, dst),\n-\t\t\t   gen_highpart_mode (word_mode, TImode, src));\n-\taarch64_emit_move (low_dst, gen_lowpart (word_mode, src));\n-      }\n-    else\n-      {\n-\taarch64_emit_move (low_dst, gen_lowpart (word_mode, src));\n-\taarch64_emit_move (gen_highpart (word_mode, dst),\n-\t\t\t   gen_highpart_mode (word_mode, TImode, src));\n-      }\n-    return;\n-  case TFmode:\n-    emit_move_insn (gen_rtx_REG (DFmode, dst_regno),\n-\t\t    gen_rtx_REG (DFmode, src_regno));\n-    emit_move_insn (gen_rtx_REG (DFmode, dst_regno + 1),\n-\t\t    gen_rtx_REG (DFmode, src_regno + 1));\n-    return;\n-  default:\n-    gcc_unreachable ();\n-  }\n+  dst_lo = gen_lowpart (word_mode, dst);\n+  dst_hi = gen_highpart (word_mode, dst);\n+  src_lo = gen_lowpart (word_mode, src);\n+  src_hi = gen_highpart_mode (word_mode, mode, src);\n+\n+  /* At most one pairing may overlap.  */\n+  if (reg_overlap_mentioned_p (dst_lo, src_hi))\n+    {\n+      aarch64_emit_move (dst_hi, src_hi);\n+      aarch64_emit_move (dst_lo, src_lo);\n+    }\n+  else\n+    {\n+      aarch64_emit_move (dst_lo, src_lo);\n+      aarch64_emit_move (dst_hi, src_hi);\n+    }\n }\n \n bool"}]}