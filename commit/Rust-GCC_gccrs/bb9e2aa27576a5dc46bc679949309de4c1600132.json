{"sha": "bb9e2aa27576a5dc46bc679949309de4c1600132", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5ZTJhYTI3NTc2YTVkYzQ2YmM2Nzk5NDkzMDlkZTRjMTYwMDEzMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:52:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:52:18Z"}, "message": "[multiple changes]\n\n2017-04-27  Yannick Moy  <moy@adacore.com>\n\n\t* exp_unst.ads: Fix typos in comments.\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_eval.adb (Choice_Matches): Handle properly a real literal\n\twhose type has a defined static predicate.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Insert_Dereference_Action):\n\tDo not adjust the address of a controlled object when the\n\tassociated access type is subject to pragma No_Heap_Finalization.\n\tCode reformatting.\n\nFrom-SVN: r247304", "tree": {"sha": "bec9fcf07c0e3b8c57ef421a1cffb95c0a5e8663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bec9fcf07c0e3b8c57ef421a1cffb95c0a5e8663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb9e2aa27576a5dc46bc679949309de4c1600132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9e2aa27576a5dc46bc679949309de4c1600132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9e2aa27576a5dc46bc679949309de4c1600132", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9e2aa27576a5dc46bc679949309de4c1600132/comments", "author": null, "committer": null, "parents": [{"sha": "ed8cbbaf7d254e592bd9e57931cf2d57b6f62e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed8cbbaf7d254e592bd9e57931cf2d57b6f62e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed8cbbaf7d254e592bd9e57931cf2d57b6f62e9c"}], "stats": {"total": 86, "additions": 60, "deletions": 26}, "files": [{"sha": "d6f3ec9017d569367fd5fed4163f042e05d33682", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bb9e2aa27576a5dc46bc679949309de4c1600132", "patch": "@@ -1,3 +1,19 @@\n+2017-04-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_unst.ads: Fix typos in comments.\n+\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_eval.adb (Choice_Matches): Handle properly a real literal\n+\twhose type has a defined static predicate.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Insert_Dereference_Action):\n+\tDo not adjust the address of a controlled object when the\n+\tassociated access type is subject to pragma No_Heap_Finalization.\n+\tCode reformatting.\n+\n 2017-04-27  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_type_for_size): Set"}, {"sha": "e247c8b6f8a8ecda641e362f23db37309e53873b", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=bb9e2aa27576a5dc46bc679949309de4c1600132", "patch": "@@ -12032,7 +12032,6 @@ package body Exp_Ch4 is\n    -------------------------------\n \n    procedure Insert_Dereference_Action (N : Node_Id) is\n-\n       function Is_Checked_Storage_Pool (P : Entity_Id) return Boolean;\n       --  Return true if type of P is derived from Checked_Pool;\n \n@@ -12062,11 +12061,12 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n-      Typ   : constant Entity_Id  := Etype (N);\n-      Desig : constant Entity_Id  := Available_View (Designated_Type (Typ));\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Pool  : constant Entity_Id  := Associated_Storage_Pool (Typ);\n-      Pnod  : constant Node_Id    := Parent (N);\n+      Context   : constant Node_Id    := Parent (N);\n+      Ptr_Typ   : constant Entity_Id  := Etype (N);\n+      Desig_Typ : constant Entity_Id  :=\n+                    Available_View (Designated_Type (Ptr_Typ));\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Pool      : constant Entity_Id  := Associated_Storage_Pool (Ptr_Typ);\n \n       Addr      : Entity_Id;\n       Alig      : Entity_Id;\n@@ -12078,18 +12078,18 @@ package body Exp_Ch4 is\n    --  Start of processing for Insert_Dereference_Action\n \n    begin\n-      pragma Assert (Nkind (Pnod) = N_Explicit_Dereference);\n+      pragma Assert (Nkind (Context) = N_Explicit_Dereference);\n \n       --  Do not re-expand a dereference which has already been processed by\n       --  this routine.\n \n-      if Has_Dereference_Action (Pnod) then\n+      if Has_Dereference_Action (Context) then\n          return;\n \n       --  Do not perform this type of expansion for internally-generated\n       --  dereferences.\n \n-      elsif not Comes_From_Source (Original_Node (Pnod)) then\n+      elsif not Comes_From_Source (Original_Node (Context)) then\n          return;\n \n       --  A dereference action is only applicable to objects which have been\n@@ -12131,15 +12131,15 @@ package body Exp_Ch4 is\n \n       --  Special case of an unconstrained array: need to add descriptor size\n \n-      if Is_Array_Type (Desig)\n-        and then not Is_Constrained (First_Subtype (Desig))\n+      if Is_Array_Type (Desig_Typ)\n+        and then not Is_Constrained (First_Subtype (Desig_Typ))\n       then\n          Size_Bits :=\n            Make_Op_Add (Loc,\n              Left_Opnd  =>\n                Make_Attribute_Reference (Loc,\n                  Prefix         =>\n-                   New_Occurrence_Of (First_Subtype (Desig), Loc),\n+                   New_Occurrence_Of (First_Subtype (Desig_Typ), Loc),\n                  Attribute_Name => Name_Descriptor_Size),\n              Right_Opnd => Size_Bits);\n       end if;\n@@ -12181,7 +12181,14 @@ package body Exp_Ch4 is\n       --  knowledge of hidden pointers, we have to bring the two pointers back\n       --  in view in order to restore the original state of the object.\n \n-      if Needs_Finalization (Desig) then\n+      --  The address manipulation is not performed for access types that are\n+      --  subject to pragma No_Heap_Finalization because the two pointers do\n+      --  not exist in the first place.\n+\n+      if No_Heap_Finalization (Ptr_Typ) then\n+         null;\n+\n+      elsif Needs_Finalization (Desig_Typ) then\n \n          --  Adjust the address and size of the dereferenced object. Generate:\n          --    Adjust_Controlled_Dereference (Addr, Size, Alig);\n@@ -12203,7 +12210,7 @@ package body Exp_Ch4 is\n          --       <Stmt>;\n          --    end if;\n \n-         if Is_Class_Wide_Type (Desig) then\n+         if Is_Class_Wide_Type (Desig_Typ) then\n             Deref :=\n               Make_Explicit_Dereference (Loc,\n                 Prefix => Duplicate_Subexpr_Move_Checks (N));\n@@ -12242,7 +12249,7 @@ package body Exp_Ch4 is\n       --  Mark the explicit dereference as processed to avoid potential\n       --  infinite expansion.\n \n-      Set_Has_Dereference_Action (Pnod);\n+      Set_Has_Dereference_Action (Context);\n \n    exception\n       when RE_Not_Available =>"}, {"sha": "1b7de11ed6aa0e89c4c3e6c036a80821b3082046", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=bb9e2aa27576a5dc46bc679949309de4c1600132", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2014-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2014-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -294,13 +294,13 @@ package Exp_Unst is\n \n    --    What we do is to always generate a local constant for any dynamic\n    --    bound in a dynamic subtype xx with name xx_FIRST or xx_LAST. The one\n-   --    case where we can skip this is where the bound is e.g. in the third\n-   --    example above, subtype dynam is expanded as\n+   --    case where we can skip this is where the bound is already a constant.\n+   --    E.g. in the third example above, subtype dynam is expanded as\n \n-   --      dynam_LAST  : constant Integer := y + 3;\n+   --      dynam_LAST : constant Integer := y + 3;\n    --      subtype dynam is integer range x .. dynam_LAST;\n \n-   --    Now if type dynam is uplevel referenced (as it is this case), then\n+   --    Now if type dynam is uplevel referenced (as it is in this case), then\n    --    the bounds x and dynam_LAST are marked as uplevel references\n    --    so that appropriate entries are made in the activation record. Any\n    --    explicit reference to such a bound in the front end generated code\n@@ -310,7 +310,7 @@ package Exp_Unst is\n    --    these bounds can be replaced by an appropriate reference to the entry\n    --    in the activation record for xx_FIRST or xx_LAST. Thus the back end\n    --    can eliminate the problematical uplevel reference without the need to\n-   --    do the heavy tree modification to do that at the code expansion level\n+   --    do the heavy tree modification to do that at the code expansion level.\n \n    --  Looking at case 3 again, here is the normal -gnatG expanded code\n \n@@ -347,7 +347,7 @@ package Exp_Unst is\n    --  we ignore that detail to clarify the examples.\n \n    --  Here we see that some of the bounds references are expanded by the\n-   --  front end, so that we get explicit references to y or dynamLast. These\n+   --  front end, so that we get explicit references to y or dynam_Last. These\n    --  cases are handled by the normal uplevel reference mechanism described\n    --  above for case 2. This is the case for the constraint check for the\n    --  initialization of xx, and the range check in function inner."}, {"sha": "e024c6d306802f82ad3c9d675ee0c8a531e779ed", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9e2aa27576a5dc46bc679949309de4c1600132/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=bb9e2aa27576a5dc46bc679949309de4c1600132", "patch": "@@ -626,18 +626,29 @@ package body Sem_Eval is\n          return Non_Static;\n \n       --  When the choice denotes a subtype with a static predictate, check the\n-      --  expression against the predicate values.\n+      --  expression against the predicate values. Different procedures apply\n+      --  to discrete and non-discrete types.\n \n       elsif (Nkind (Choice) = N_Subtype_Indication\n                or else (Is_Entity_Name (Choice)\n                          and then Is_Type (Entity (Choice))))\n         and then Has_Predicates (Etype (Choice))\n         and then Has_Static_Predicate (Etype (Choice))\n       then\n-         return\n-           Choices_Match (Expr, Static_Discrete_Predicate (Etype (Choice)));\n+         if Is_Discrete_Type (Etype (Choice)) then\n+            return Choices_Match\n+              (Expr, Static_Discrete_Predicate (Etype (Choice)));\n+\n+         elsif\n+            Real_Or_String_Static_Predicate_Matches (Expr, Etype (Choice))\n+         then\n+            return Match;\n+\n+         else\n+            return No_Match;\n+         end if;\n \n-      --  Discrete type case\n+      --  Discrete type case only\n \n       elsif Is_Discrete_Type (Etyp) then\n          Val := Expr_Value (Expr);"}]}