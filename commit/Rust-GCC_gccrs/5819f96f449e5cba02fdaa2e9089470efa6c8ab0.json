{"sha": "5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxOWY5NmY0NDllNWNiYTAyZmRhYTJlOTA4OTQ3MGVmYTZjOGFiMA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2013-04-25T10:54:39Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2013-04-25T10:54:39Z"}, "message": "arm.c (neon_builtin_type_mode): Add T_V4HF.\n\n2013-04-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n            Julian Brown  <julian@codesourcery.com>\n\n\t* config/arm/arm.c (neon_builtin_type_mode): Add T_V4HF.\n\t(TB_DREG): Add T_V4HF.\n\t(v4hf_UP): New macro.\n\t(neon_itype): Add NEON_FLOAT_WIDEN, NEON_FLOAT_NARROW.\n\t(arm_init_neon_builtins): Handle NEON_FLOAT_WIDEN,\n\tNEON_FLOAT_NARROW.\n\tHandle initialisation of V4HF. Adjust initialisation of reinterpret\n\tbuilt-ins.\n\t(arm_expand_neon_builtin): Handle NEON_FLOAT_WIDEN,\n\tNEON_FLOAT_NARROW.\n\t(arm_vector_mode_supported_p): Handle V4HF.\n\t(arm_mangle_map): Handle V4HFmode.\n\t* config/arm/arm.h (VALID_NEON_DREG_MODE): Add V4HF.\n\t* config/arm/arm_neon_builtins.def: Add entries for\n\tvcvtv4hfv4sf, vcvtv4sfv4hf.\n\t* config/arm/neon.md (neon_vcvtv4sfv4hf): New pattern.\n\t(neon_vcvtv4hfv4sf): Likewise.\n\t* config/arm/neon-gen.ml: Handle half-precision floating point\n\tfeatures.\n\t* config/arm/neon-testgen.ml: Handle Requires_FP_bit feature.\n\t* config/arm/arm_neon.h: Regenerate.\n\t* config/arm/neon.ml (type elts): Add F16.\n\t(type vectype): Add T_float16x4, T_floatHF.\n\t(type vecmode): Add V4HF.\n\t(type features): Add Requires_FP_bit feature.\n\t(elt_width): Handle F16.\n\t(elt_class): Likewise.\n\t(elt_of_class_width): Likewise.\n\t(mode_of_elt): Refactor.\n\t(type_for_elt): Handle F16, fix error messages.\n\t(vectype_size): Handle T_float16x4.\n\t(vcvt_sh): New function.\n\t(ops): Add entries for vcvt_f16_f32, vcvt_f32_f16.\n\t(string_of_vectype): Handle T_floatHF, T_float16, T_float16x4.\n\t(string_of_mode): Handle V4HF.\n\t* doc/arm-neon-intrinsics.texi: Regenerate.\n\n2013-04-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_neon_fp16_ok_nocache): New procedure.\n\t(check_effective_target_arm_neon_fp16_ok): Likewise.\n\t(add_options_for_arm_neon_fp16): Likewise.\n\t* gcc.target/arm/neon/vcvtf16_f32.c: New test. Generated.\n\t* gcc.target/arm/neon/vcvtf32_f16.c: Likewise.\n\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\n\nFrom-SVN: r198298", "tree": {"sha": "27825bda688a67445e26f1c90cffc22c096d39c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27825bda688a67445e26f1c90cffc22c096d39c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8b8c01c3d00065dc5cd4c000db79e5b47463d4"}], "stats": {"total": 326, "additions": 295, "deletions": 31}, "files": [{"sha": "e4d576778c64dbc8e4e7be9cbf61e0f1fd5f04b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -1,3 +1,43 @@\n+2013-04-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+            Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/arm/arm.c (neon_builtin_type_mode): Add T_V4HF.\n+\t(TB_DREG): Add T_V4HF.\n+\t(v4hf_UP): New macro.\n+\t(neon_itype): Add NEON_FLOAT_WIDEN, NEON_FLOAT_NARROW.\n+\t(arm_init_neon_builtins): Handle NEON_FLOAT_WIDEN,\n+\tNEON_FLOAT_NARROW.\n+\tHandle initialisation of V4HF. Adjust initialisation of reinterpret\n+\tbuilt-ins.\n+\t(arm_expand_neon_builtin): Handle NEON_FLOAT_WIDEN,\n+\tNEON_FLOAT_NARROW.\n+\t(arm_vector_mode_supported_p): Handle V4HF.\n+\t(arm_mangle_map): Handle V4HFmode.\n+\t* config/arm/arm.h (VALID_NEON_DREG_MODE): Add V4HF.\n+\t* config/arm/arm_neon_builtins.def: Add entries for\n+\tvcvtv4hfv4sf, vcvtv4sfv4hf.\n+\t* config/arm/neon.md (neon_vcvtv4sfv4hf): New pattern.\n+\t(neon_vcvtv4hfv4sf): Likewise.\n+\t* config/arm/neon-gen.ml: Handle half-precision floating point\n+\tfeatures.\n+\t* config/arm/neon-testgen.ml: Handle Requires_FP_bit feature.\n+\t* config/arm/arm_neon.h: Regenerate.\n+\t* config/arm/neon.ml (type elts): Add F16.\n+\t(type vectype): Add T_float16x4, T_floatHF.\n+\t(type vecmode): Add V4HF.\n+\t(type features): Add Requires_FP_bit feature.\n+\t(elt_width): Handle F16.\n+\t(elt_class): Likewise.\n+\t(elt_of_class_width): Likewise.\n+\t(mode_of_elt): Refactor.\n+\t(type_for_elt): Handle F16, fix error messages.\n+\t(vectype_size): Handle T_float16x4.\n+\t(vcvt_sh): New function.\n+\t(ops): Add entries for vcvt_f16_f32, vcvt_f32_f16.\n+\t(string_of_vectype): Handle T_floatHF, T_float16, T_float16x4.\n+\t(string_of_mode): Handle V4HF.\n+\t* doc/arm-neon-intrinsics.texi: Regenerate.\n+\n 2013-04-25  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_print_operand): Fix asm_fprintf"}, {"sha": "bc4247358ebad52e4db2c77364fc4f5b4355875e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -19940,6 +19940,7 @@ arm_debugger_arg_offset (int value, rtx addr)\n typedef enum {\n   T_V8QI,\n   T_V4HI,\n+  T_V4HF,\n   T_V2SI,\n   T_V2SF,\n   T_DI,\n@@ -19957,14 +19958,15 @@ typedef enum {\n #define TYPE_MODE_BIT(X) (1 << (X))\n \n #define TB_DREG (TYPE_MODE_BIT (T_V8QI) | TYPE_MODE_BIT (T_V4HI)\t\\\n-\t\t | TYPE_MODE_BIT (T_V2SI) | TYPE_MODE_BIT (T_V2SF)\t\\\n-\t\t | TYPE_MODE_BIT (T_DI))\n+\t\t | TYPE_MODE_BIT (T_V4HF) | TYPE_MODE_BIT (T_V2SI)\t\\\n+\t\t | TYPE_MODE_BIT (T_V2SF) | TYPE_MODE_BIT (T_DI))\n #define TB_QREG (TYPE_MODE_BIT (T_V16QI) | TYPE_MODE_BIT (T_V8HI)\t\\\n \t\t | TYPE_MODE_BIT (T_V4SI) | TYPE_MODE_BIT (T_V4SF)\t\\\n \t\t | TYPE_MODE_BIT (T_V2DI) | TYPE_MODE_BIT (T_TI))\n \n #define v8qi_UP  T_V8QI\n #define v4hi_UP  T_V4HI\n+#define v4hf_UP  T_V4HF\n #define v2si_UP  T_V2SI\n #define v2sf_UP  T_V2SF\n #define di_UP    T_DI\n@@ -20000,6 +20002,8 @@ typedef enum {\n   NEON_SCALARMULH,\n   NEON_SCALARMAC,\n   NEON_CONVERT,\n+  NEON_FLOAT_WIDEN,\n+  NEON_FLOAT_NARROW,\n   NEON_FIXCONV,\n   NEON_SELECT,\n   NEON_RESULTPAIR,\n@@ -20393,6 +20397,7 @@ arm_init_neon_builtins (void)\n \n   tree neon_intQI_type_node;\n   tree neon_intHI_type_node;\n+  tree neon_floatHF_type_node;\n   tree neon_polyQI_type_node;\n   tree neon_polyHI_type_node;\n   tree neon_intSI_type_node;\n@@ -20419,6 +20424,7 @@ arm_init_neon_builtins (void)\n \n   tree V8QI_type_node;\n   tree V4HI_type_node;\n+  tree V4HF_type_node;\n   tree V2SI_type_node;\n   tree V2SF_type_node;\n   tree V16QI_type_node;\n@@ -20473,6 +20479,9 @@ arm_init_neon_builtins (void)\n   neon_float_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (neon_float_type_node) = FLOAT_TYPE_SIZE;\n   layout_type (neon_float_type_node);\n+  neon_floatHF_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (neon_floatHF_type_node) = GET_MODE_PRECISION (HFmode);\n+  layout_type (neon_floatHF_type_node);\n \n   /* Define typedefs which exactly correspond to the modes we are basing vector\n      types on.  If you change these names you'll need to change\n@@ -20481,6 +20490,8 @@ arm_init_neon_builtins (void)\n \t\t\t\t\t     \"__builtin_neon_qi\");\n   (*lang_hooks.types.register_builtin_type) (neon_intHI_type_node,\n \t\t\t\t\t     \"__builtin_neon_hi\");\n+  (*lang_hooks.types.register_builtin_type) (neon_floatHF_type_node,\n+\t\t\t\t\t     \"__builtin_neon_hf\");\n   (*lang_hooks.types.register_builtin_type) (neon_intSI_type_node,\n \t\t\t\t\t     \"__builtin_neon_si\");\n   (*lang_hooks.types.register_builtin_type) (neon_float_type_node,\n@@ -20522,6 +20533,8 @@ arm_init_neon_builtins (void)\n     build_vector_type_for_mode (neon_intQI_type_node, V8QImode);\n   V4HI_type_node =\n     build_vector_type_for_mode (neon_intHI_type_node, V4HImode);\n+  V4HF_type_node =\n+    build_vector_type_for_mode (neon_floatHF_type_node, V4HFmode);\n   V2SI_type_node =\n     build_vector_type_for_mode (neon_intSI_type_node, V2SImode);\n   V2SF_type_node =\n@@ -20644,7 +20657,7 @@ arm_init_neon_builtins (void)\n       neon_builtin_datum *d = &neon_builtin_data[i];\n \n       const char* const modenames[] = {\n-\t\"v8qi\", \"v4hi\", \"v2si\", \"v2sf\", \"di\",\n+\t\"v8qi\", \"v4hi\", \"v4hf\", \"v2si\", \"v2sf\", \"di\",\n \t\"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\",\n \t\"ti\", \"ei\", \"oi\"\n       };\n@@ -20847,8 +20860,9 @@ arm_init_neon_builtins (void)\n \tcase NEON_REINTERP:\n \t  {\n \t    /* We iterate over 5 doubleword types, then 5 quadword\n-\t       types.  */\n-\t    int rhs = d->mode % 5;\n+\t       types. V4HF is not a type used in reinterpret, so we translate\n+\t       d->mode to the correct index in reinterp_ftype_dreg.  */\n+\t    int rhs = (d->mode - ((d->mode > T_V4HF) ? 1 : 0)) % 5;\n \t    switch (insn_data[d->code].operand[0].mode)\n \t      {\n \t      case V8QImode: ftype = reinterp_ftype_dreg[0][rhs]; break;\n@@ -20865,7 +20879,38 @@ arm_init_neon_builtins (void)\n \t      }\n \t  }\n \t  break;\n+\tcase NEON_FLOAT_WIDEN:\n+\t  {\n+\t    tree eltype = NULL_TREE;\n+\t    tree return_type = NULL_TREE;\n \n+\t    switch (insn_data[d->code].operand[1].mode)\n+\t    {\n+\t      case V4HFmode:\n+\t        eltype = V4HF_type_node;\n+\t        return_type = V4SF_type_node;\n+\t        break;\n+\t      default: gcc_unreachable ();\n+\t    }\n+\t    ftype = build_function_type_list (return_type, eltype, NULL);\n+\t    break;\n+\t  }\n+\tcase NEON_FLOAT_NARROW:\n+\t  {\n+\t    tree eltype = NULL_TREE;\n+\t    tree return_type = NULL_TREE;\n+\n+\t    switch (insn_data[d->code].operand[1].mode)\n+\t    {\n+\t      case V4SFmode:\n+\t        eltype = V4SF_type_node;\n+\t        return_type = V4HF_type_node;\n+\t        break;\n+\t      default: gcc_unreachable ();\n+\t    }\n+\t    ftype = build_function_type_list (return_type, eltype, NULL);\n+\t    break;\n+\t  }\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -21862,6 +21907,8 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n     case NEON_DUP:\n     case NEON_RINT:\n     case NEON_SPLIT:\n+    case NEON_FLOAT_WIDEN:\n+    case NEON_FLOAT_NARROW:\n     case NEON_REINTERP:\n       return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n@@ -25517,7 +25564,7 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n {\n   /* Neon also supports V2SImode, etc. listed in the clause below.  */\n   if (TARGET_NEON && (mode == V2SFmode || mode == V4SImode || mode == V8HImode\n-      || mode == V16QImode || mode == V4SFmode || mode == V2DImode))\n+      || mode == V4HFmode || mode == V16QImode || mode == V4SFmode || mode == V2DImode))\n     return true;\n \n   if ((TARGET_NEON || TARGET_IWMMXT)\n@@ -26361,6 +26408,7 @@ static arm_mangle_map_entry arm_mangle_map[] = {\n   { V8QImode,  \"__builtin_neon_uqi\",    \"16__simd64_uint8_t\" },\n   { V4HImode,  \"__builtin_neon_hi\",     \"16__simd64_int16_t\" },\n   { V4HImode,  \"__builtin_neon_uhi\",    \"17__simd64_uint16_t\" },\n+  { V4HFmode,  \"__builtin_neon_hf\",     \"18__simd64_float16_t\" },\n   { V2SImode,  \"__builtin_neon_si\",     \"16__simd64_int32_t\" },\n   { V2SImode,  \"__builtin_neon_usi\",    \"17__simd64_uint32_t\" },\n   { V2SFmode,  \"__builtin_neon_sf\",     \"18__simd64_float32_t\" },"}, {"sha": "c47fdf68098536ef317c04809d5d23efacda4712", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -1052,7 +1052,7 @@ extern int prefer_neon_for_64bits;\n /* Modes valid for Neon D registers.  */\n #define VALID_NEON_DREG_MODE(MODE) \\\n   ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode \\\n-   || (MODE) == V2SFmode || (MODE) == DImode)\n+   || (MODE) == V4HFmode || (MODE) == V2SFmode || (MODE) == DImode)\n \n /* Modes valid for Neon Q registers.  */\n #define VALID_NEON_QREG_MODE(MODE) \\"}, {"sha": "e23d03b9d10d8b4008133374bb7d5b70f84f171d", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -43,6 +43,7 @@ typedef __builtin_neon_hi int16x4_t\t__attribute__ ((__vector_size__ (8)));\n typedef __builtin_neon_si int32x2_t\t__attribute__ ((__vector_size__ (8)));\n typedef __builtin_neon_di int64x1_t;\n typedef __builtin_neon_sf float32x2_t\t__attribute__ ((__vector_size__ (8)));\n+typedef __builtin_neon_hf float16x4_t\t__attribute__ ((__vector_size__ (8)));\n typedef __builtin_neon_poly8 poly8x8_t\t__attribute__ ((__vector_size__ (8)));\n typedef __builtin_neon_poly16 poly16x4_t\t__attribute__ ((__vector_size__ (8)));\n typedef __builtin_neon_uqi uint8x8_t\t__attribute__ ((__vector_size__ (8)));\n@@ -6016,6 +6017,22 @@ vcvtq_u32_f32 (float32x4_t __a)\n   return (uint32x4_t)__builtin_neon_vcvtv4sf (__a, 0);\n }\n \n+#if ((__ARM_FP & 0x2) != 0)\n+__extension__ static __inline float16x4_t __attribute__ ((__always_inline__))\n+vcvt_f16_f32 (float32x4_t __a)\n+{\n+  return (float16x4_t)__builtin_neon_vcvtv4hfv4sf (__a);\n+}\n+\n+#endif\n+#if ((__ARM_FP & 0x2) != 0)\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vcvt_f32_f16 (float16x4_t __a)\n+{\n+  return (float32x4_t)__builtin_neon_vcvtv4sfv4hf (__a);\n+}\n+\n+#endif\n __extension__ static __inline int32x2_t __attribute__ ((__always_inline__))\n vcvt_n_s32_f32 (float32x2_t __a, const int __b)\n {"}, {"sha": "92f1d7ad1c437b7c043c6f93c4f3bade8609f8a9", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -132,6 +132,8 @@ VAR4 (UNOP, vrev32, v8qi, v4hi, v16qi, v8hi),\n VAR2 (UNOP, vrev16, v8qi, v16qi),\n VAR4 (CONVERT, vcvt, v2si, v2sf, v4si, v4sf),\n VAR4 (FIXCONV, vcvt_n, v2si, v2sf, v4si, v4sf),\n+VAR1 (FLOAT_WIDEN, vcvtv4sf, v4hf),\n+VAR1 (FLOAT_NARROW, vcvtv4hf, v4sf),\n VAR10 (SELECT, vbsl,\n \t v8qi, v4hi, v2si, v2sf, di, v16qi, v8hi, v4si, v4sf, v2di),\n VAR2 (RINT, vrintn, v2sf, v4sf),"}, {"sha": "948b162ccfa7f09574ae2f41a88a5378b323383f", "filename": "gcc/config/arm/neon-gen.ml", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon-gen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-gen.ml?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -121,6 +121,7 @@ let rec signed_ctype = function\n   | T_uint16 | T_int16 -> T_intHI\n   | T_uint32 | T_int32 -> T_intSI\n   | T_uint64 | T_int64 -> T_intDI\n+  | T_float16 -> T_floatHF\n   | T_float32 -> T_floatSF\n   | T_poly8 -> T_intQI\n   | T_poly16 -> T_intHI\n@@ -275,8 +276,8 @@ let rec mode_suffix elttype shape =\n     let mode = mode_of_elt elttype shape in\n     string_of_mode mode\n   with MixedMode (dst, src) ->\n-    let dstmode = mode_of_elt dst shape\n-    and srcmode = mode_of_elt src shape in\n+    let dstmode = mode_of_elt ~argpos:0 dst shape\n+    and srcmode = mode_of_elt ~argpos:1 src shape in\n     string_of_mode dstmode ^ string_of_mode srcmode\n \n let get_shuffle features =\n@@ -291,19 +292,24 @@ let print_feature_test_start features =\n     match List.find (fun feature ->\n                        match feature with Requires_feature _ -> true\n                                         | Requires_arch _ -> true\n+                                        | Requires_FP_bit _ -> true\n                                         | _ -> false)\n                      features with\n-      Requires_feature feature -> \n+      Requires_feature feature ->\n         Format.printf \"#ifdef __ARM_FEATURE_%s@\\n\" feature\n     | Requires_arch arch ->\n         Format.printf \"#if __ARM_ARCH >= %d@\\n\" arch\n+    | Requires_FP_bit bit ->\n+        Format.printf \"#if ((__ARM_FP & 0x%X) != 0)@\\n\"\n+                      (1 lsl bit)\n     | _ -> assert false\n   with Not_found -> assert true\n \n let print_feature_test_end features =\n   let feature =\n-    List.exists (function Requires_feature x -> true\n-                          | Requires_arch x -> true\n+    List.exists (function Requires_feature _ -> true\n+                          | Requires_arch _ -> true\n+                          | Requires_FP_bit _ -> true\n                           |  _ -> false) features in\n   if feature then Format.printf \"#endif@\\n\"\n \n@@ -365,6 +371,7 @@ let deftypes () =\n     \"__builtin_neon_hi\", \"int\", 16, 4;\n     \"__builtin_neon_si\", \"int\", 32, 2;\n     \"__builtin_neon_di\", \"int\", 64, 1;\n+    \"__builtin_neon_hf\", \"float\", 16, 4;\n     \"__builtin_neon_sf\", \"float\", 32, 2;\n     \"__builtin_neon_poly8\", \"poly\", 8, 8;\n     \"__builtin_neon_poly16\", \"poly\", 16, 4;"}, {"sha": "543318bfcc6161b814000be507f9a79a7cd9cdbd", "filename": "gcc/config/arm/neon-testgen.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon-testgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon-testgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-testgen.ml?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -163,10 +163,12 @@ let effective_target features =\n     match List.find (fun feature ->\n                        match feature with Requires_feature _ -> true\n                                         | Requires_arch _ -> true\n+                                        | Requires_FP_bit 1 -> true\n                                         | _ -> false)\n                      features with\n       Requires_feature \"FMA\" -> \"arm_neonv2\"\n     | Requires_arch 8 -> \"arm_v8_neon\"\n+    | Requires_FP_bit 1 -> \"arm_neon_fp16\"\n     | _ -> assert false\n   with Not_found -> \"arm_neon\"\n "}, {"sha": "f91a6f7d08bfd2499512a08baa23cf8e949aaffb", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -3258,6 +3258,24 @@\n                    (const_string \"neon_fp_vadd_qqq_vabs_qq\")))]\n )\n \n+(define_insn \"neon_vcvtv4sfv4hf\"\n+  [(set (match_operand:V4SF 0 \"s_register_operand\" \"=w\")\n+\t(unspec:V4SF [(match_operand:V4HF 1 \"s_register_operand\" \"w\")]\n+\t\t\t  UNSPEC_VCVT))]\n+  \"TARGET_NEON && TARGET_FP16\"\n+  \"vcvt.f32.f16\\t%q0, %P1\"\n+  [(set_attr \"neon_type\" \"neon_fp_vadd_ddd_vabs_dd\")]\n+)\n+\n+(define_insn \"neon_vcvtv4hfv4sf\"\n+  [(set (match_operand:V4HF 0 \"s_register_operand\" \"=w\")\n+\t(unspec:V4HF [(match_operand:V4SF 1 \"s_register_operand\" \"w\")]\n+\t\t\t  UNSPEC_VCVT))]\n+  \"TARGET_NEON && TARGET_FP16\"\n+  \"vcvt.f16.f32\\t%P0, %q1\"\n+  [(set_attr \"neon_type\" \"neon_fp_vadd_ddd_vabs_dd\")]\n+)\n+\n (define_insn \"neon_vcvt_n<mode>\"\n   [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_CVTTO> [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")"}, {"sha": "ca9a4c06aa645591445c84446ea7f688234ddf13", "filename": "gcc/config/arm/neon.ml", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fconfig%2Farm%2Fneon.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.ml?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -21,7 +21,7 @@\n    <http://www.gnu.org/licenses/>.  *)\n \n (* Shorthand types for vector elements.  *)\n-type elts = S8 | S16 | S32 | S64 | F32 | U8 | U16 | U32 | U64 | P8 | P16\n+type elts = S8 | S16 | S32 | S64 | F16 | F32 | U8 | U16 | U32 | U64 | P8 | P16\n           | I8 | I16 | I32 | I64 | B8 | B16 | B32 | B64 | Conv of elts * elts\n           | Cast of elts * elts | NoElts\n \n@@ -37,6 +37,7 @@ type vectype = T_int8x8    | T_int8x16\n \t     | T_uint16x4  | T_uint16x8\n \t     | T_uint32x2  | T_uint32x4\n \t     | T_uint64x1  | T_uint64x2\n+\t     | T_float16x4\n \t     | T_float32x2 | T_float32x4\n \t     | T_poly8x8   | T_poly8x16\n \t     | T_poly16x4  | T_poly16x8\n@@ -46,11 +47,13 @@ type vectype = T_int8x8    | T_int8x16\n              | T_uint8     | T_uint16\n              | T_uint32    | T_uint64\n              | T_poly8     | T_poly16\n-             | T_float32   | T_arrayof of int * vectype\n+             | T_float16   | T_float32\n+             | T_arrayof of int * vectype\n              | T_ptrto of vectype | T_const of vectype\n              | T_void      | T_intQI\n              | T_intHI     | T_intSI\n-             | T_intDI     | T_floatSF\n+             | T_intDI     | T_floatHF\n+             | T_floatSF\n \n (* The meanings of the following are:\n      TImode : \"Tetra\", two registers (four words).\n@@ -92,7 +95,7 @@ type arity = Arity0 of vectype\n \t   | Arity3 of vectype * vectype * vectype * vectype\n            | Arity4 of vectype * vectype * vectype * vectype * vectype\n \n-type vecmode = V8QI | V4HI | V2SI | V2SF | DI\n+type vecmode = V8QI | V4HI | V4HF |V2SI | V2SF | DI\n              | V16QI | V8HI | V4SI | V4SF | V2DI\n              | QI | HI | SI | SF\n \n@@ -284,26 +287,30 @@ type features =\n   | Fixed_core_reg\n     (* Mark that the intrinsic requires __ARM_FEATURE_string to be defined.  *)\n   | Requires_feature of string\n+    (* Mark that the intrinsic requires a particular architecture version.  *)\n   | Requires_arch of int\n+    (* Mark that the intrinsic requires a particular bit in __ARM_FP to\n+    be set.   *)\n+  | Requires_FP_bit of int\n \n exception MixedMode of elts * elts\n \n let rec elt_width = function\n     S8 | U8 | P8 | I8 | B8 -> 8\n-  | S16 | U16 | P16 | I16 | B16 -> 16\n+  | S16 | U16 | P16 | I16 | B16 | F16 -> 16\n   | S32 | F32 | U32 | I32 | B32 -> 32\n   | S64 | U64 | I64 | B64 -> 64\n   | Conv (a, b) ->\n       let wa = elt_width a and wb = elt_width b in\n-      if wa = wb then wa else failwith \"element width?\"\n+      if wa = wb then wa else raise (MixedMode (a, b))\n   | Cast (a, b) -> raise (MixedMode (a, b))\n   | NoElts -> failwith \"No elts\"\n \n let rec elt_class = function\n     S8 | S16 | S32 | S64 -> Signed\n   | U8 | U16 | U32 | U64 -> Unsigned\n   | P8 | P16 -> Poly\n-  | F32 -> Float\n+  | F16 | F32 -> Float\n   | I8 | I16 | I32 | I64 -> Int\n   | B8 | B16 | B32 | B64 -> Bits\n   | Conv (a, b) | Cast (a, b) -> ConvClass (elt_class a, elt_class b)\n@@ -315,6 +322,7 @@ let elt_of_class_width c w =\n   | Signed, 16 -> S16\n   | Signed, 32 -> S32\n   | Signed, 64 -> S64\n+  | Float, 16 -> F16\n   | Float, 32 -> F32\n   | Unsigned, 8 -> U8\n   | Unsigned, 16 -> U16\n@@ -384,7 +392,12 @@ let find_key_operand operands =\n   in\n     scan ((Array.length operands) - 1)\n \n-let rec mode_of_elt elt shape =\n+(* Find a vecmode from a shape_elt ELT for an instruction with shape_form\n+   SHAPE.  For a Use_operands shape, if ARGPOS is passed then return the mode\n+   for the given argument position, else determine which argument to return a\n+   mode for automatically.  *)\n+\n+let rec mode_of_elt ?argpos elt shape =\n   let flt = match elt_class elt with\n     Float | ConvClass(_, Float) -> true | _ -> false in\n   let idx =\n@@ -394,7 +407,10 @@ let rec mode_of_elt elt shape =\n   in match shape with\n     All (_, Dreg) | By_scalar Dreg | Pair_result Dreg | Unary_scalar Dreg\n   | Binary_imm Dreg | Long_noreg Dreg | Wide_noreg Dreg ->\n-      [| V8QI; V4HI; if flt then V2SF else V2SI; DI |].(idx)\n+      if flt then\n+        [| V8QI; V4HF; V2SF; DI |].(idx)\n+      else\n+        [| V8QI; V4HI; V2SI; DI |].(idx)\n   | All (_, Qreg) | By_scalar Qreg | Pair_result Qreg | Unary_scalar Qreg\n   | Binary_imm Qreg | Long_noreg Qreg | Wide_noreg Qreg ->\n       [| V16QI; V8HI; if flt then V4SF else V4SI; V2DI |].(idx)\n@@ -404,7 +420,11 @@ let rec mode_of_elt elt shape =\n   | Long_imm ->\n       [| V8QI; V4HI; V2SI; DI |].(idx)\n   | Narrow | Narrow_imm -> [| V16QI; V8HI; V4SI; V2DI |].(idx)\n-  | Use_operands ops -> mode_of_elt elt (All (0, (find_key_operand ops)))\n+  | Use_operands ops ->\n+      begin match argpos with\n+        None -> mode_of_elt ?argpos elt (All (0, (find_key_operand ops)))\n+      | Some pos -> mode_of_elt ?argpos elt (All (0, ops.(pos)))\n+      end\n   | _ -> failwith \"invalid shape\"\n \n (* Modify an element type dependent on the shape of the instruction and the\n@@ -454,10 +474,11 @@ let type_for_elt shape elt no =\n         | U16 -> T_uint16x4\n         | U32 -> T_uint32x2\n         | U64 -> T_uint64x1\n+        | F16 -> T_float16x4\n         | F32 -> T_float32x2\n         | P8 -> T_poly8x8\n         | P16 -> T_poly16x4\n-        | _ -> failwith \"Bad elt type\"\n+        | _ -> failwith \"Bad elt type for Dreg\"\n         end\n     | Qreg ->\n         begin match elt with\n@@ -472,7 +493,7 @@ let type_for_elt shape elt no =\n         | F32 -> T_float32x4\n         | P8 -> T_poly8x16\n         | P16 -> T_poly16x8\n-        | _ -> failwith \"Bad elt type\"\n+        | _ -> failwith \"Bad elt type for Qreg\"\n         end\n     | Corereg ->\n         begin match elt with\n@@ -487,7 +508,7 @@ let type_for_elt shape elt no =\n         | P8 -> T_poly8\n         | P16 -> T_poly16\n         | F32 -> T_float32\n-        | _ -> failwith \"Bad elt type\"\n+        | _ -> failwith \"Bad elt type for Corereg\"\n         end\n     | Immed ->\n         T_immediate (0, 0)\n@@ -506,7 +527,7 @@ let type_for_elt shape elt no =\n let vectype_size = function\n     T_int8x8 | T_int16x4 | T_int32x2 | T_int64x1\n   | T_uint8x8 | T_uint16x4 | T_uint32x2 | T_uint64x1\n-  | T_float32x2 | T_poly8x8 | T_poly16x4 -> 64\n+  | T_float32x2 | T_poly8x8 | T_poly16x4 | T_float16x4 -> 64\n   | T_int8x16 | T_int16x8 | T_int32x4 | T_int64x2\n   | T_uint8x16 | T_uint16x8  | T_uint32x4  | T_uint64x2\n   | T_float32x4 | T_poly8x16 | T_poly16x8 -> 128\n@@ -1217,6 +1238,10 @@ let ops =\n       [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n     Vcvt, [InfoWord], All (2, Qreg), \"vcvtQ\", conv_1,\n       [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n+    Vcvt, [Builtin_name \"vcvt\" ; Requires_FP_bit 1],\n+          Use_operands [| Dreg; Qreg; |], \"vcvt\", conv_1, [Conv (F16, F32)];\n+    Vcvt, [Builtin_name \"vcvt\" ; Requires_FP_bit 1],\n+          Use_operands [| Qreg; Dreg; |], \"vcvt\", conv_1, [Conv (F32, F16)];\n     Vcvt_n, [InfoWord], Use_operands [| Dreg; Dreg; Immed |], \"vcvt_n\", conv_2,\n       [Conv (S32, F32); Conv (U32, F32); Conv (F32, S32); Conv (F32, U32)];\n     Vcvt_n, [InfoWord], Use_operands [| Qreg; Qreg; Immed |], \"vcvtQ_n\", conv_2,\n@@ -1782,7 +1807,7 @@ let rec string_of_elt = function\n   | U8 -> \"u8\" | U16 -> \"u16\" | U32 -> \"u32\" | U64 -> \"u64\"\n   | I8 -> \"i8\" | I16 -> \"i16\" | I32 -> \"i32\" | I64 -> \"i64\"\n   | B8 -> \"8\" | B16 -> \"16\" | B32 -> \"32\" | B64 -> \"64\"\n-  | F32 -> \"f32\" | P8 -> \"p8\" | P16 -> \"p16\"\n+  | F16 -> \"f16\" | F32 -> \"f32\" | P8 -> \"p8\" | P16 -> \"p16\"\n   | Conv (a, b) | Cast (a, b) -> string_of_elt a ^ \"_\" ^ string_of_elt b\n   | NoElts -> failwith \"No elts\"\n \n@@ -1809,6 +1834,7 @@ let string_of_vectype vt =\n   | T_uint32x4 -> affix \"uint32x4\"\n   | T_uint64x1 -> affix \"uint64x1\"\n   | T_uint64x2 -> affix \"uint64x2\"\n+  | T_float16x4 -> affix \"float16x4\"\n   | T_float32x2 -> affix \"float32x2\"\n   | T_float32x4 -> affix \"float32x4\"\n   | T_poly8x8 -> affix \"poly8x8\"\n@@ -1825,13 +1851,15 @@ let string_of_vectype vt =\n   | T_uint64 -> affix \"uint64\"\n   | T_poly8 -> affix \"poly8\"\n   | T_poly16 -> affix \"poly16\"\n+  | T_float16 -> affix \"float16\"\n   | T_float32 -> affix \"float32\"\n   | T_immediate _ -> \"const int\"\n   | T_void -> \"void\"\n   | T_intQI -> \"__builtin_neon_qi\"\n   | T_intHI -> \"__builtin_neon_hi\"\n   | T_intSI -> \"__builtin_neon_si\"\n   | T_intDI -> \"__builtin_neon_di\"\n+  | T_floatHF -> \"__builtin_neon_hf\"\n   | T_floatSF -> \"__builtin_neon_sf\"\n   | T_arrayof (num, base) ->\n       let basename = name (fun x -> x) base in\n@@ -1853,10 +1881,10 @@ let string_of_inttype = function\n   | B_XImode -> \"__builtin_neon_xi\"\n \n let string_of_mode = function\n-    V8QI -> \"v8qi\" | V4HI  -> \"v4hi\"  | V2SI -> \"v2si\" | V2SF -> \"v2sf\"\n-  | DI   -> \"di\"   | V16QI -> \"v16qi\" | V8HI -> \"v8hi\" | V4SI -> \"v4si\"\n-  | V4SF -> \"v4sf\" | V2DI  -> \"v2di\"  | QI -> \"qi\" | HI -> \"hi\" | SI -> \"si\"\n-  | SF -> \"sf\"\n+    V8QI -> \"v8qi\" | V4HI -> \"v4hi\" | V4HF  -> \"v4hf\"  | V2SI -> \"v2si\"\n+  | V2SF -> \"v2sf\" | DI   -> \"di\"   | V16QI -> \"v16qi\" | V8HI -> \"v8hi\"\n+  | V4SI -> \"v4si\" | V4SF -> \"v4sf\" | V2DI  -> \"v2di\"  | QI   -> \"qi\"\n+  | HI -> \"hi\" | SI -> \"si\" | SF -> \"sf\"\n \n (* Use uppercase chars for letters which form part of the intrinsic name, but\n    should be omitted from the builtin name (the info is passed in an extra"}, {"sha": "fcd6c0f5305c027b5921f8a7bfa72e36a31032e3", "filename": "gcc/doc/arm-neon-intrinsics.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Fdoc%2Farm-neon-intrinsics.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Farm-neon-intrinsics.texi?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -5747,6 +5747,18 @@\n @end itemize\n \n \n+@itemize @bullet\n+@item float16x4_t vcvt_f16_f32 (float32x4_t)\n+@*@emph{Form of expected instruction(s):} @code{vcvt.f16.f32 @var{d0}, @var{q0}}\n+@end itemize\n+\n+\n+@itemize @bullet\n+@item float32x4_t vcvt_f32_f16 (float16x4_t)\n+@*@emph{Form of expected instruction(s):} @code{vcvt.f32.f16 @var{q0}, @var{d0}}\n+@end itemize\n+\n+\n @itemize @bullet\n @item float32x2_t vcvt_n_f32_u32 (uint32x2_t, const int)\n @*@emph{Form of expected instruction(s):} @code{vcvt.f32.u32 @var{d0}, @var{d0}, #@var{0}}"}, {"sha": "0bc2c8350f28e8bd00661d59a6347656c9ccd048", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -1,3 +1,12 @@\n+2013-04-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_neon_fp16_ok_nocache): New procedure.\n+\t(check_effective_target_arm_neon_fp16_ok): Likewise.\n+\t(add_options_for_arm_neon_fp16): Likewise.\n+\t* gcc.target/arm/neon/vcvtf16_f32.c: New test. Generated.\n+\t* gcc.target/arm/neon/vcvtf32_f16.c: Likewise.\n+\n 2013-04-24  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimizations/57046"}, {"sha": "6675596d7418d8daff8637e6b80dcdb9b0b9a6e0", "filename": "gcc/testsuite/gcc.target/arm/neon/vcvtf16_f32.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf16_f32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf16_f32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf16_f32.c?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcvtf16_f32' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_fp16_ok } */\n+/* { dg-options \"-save-temps -O0\" } */\n+/* { dg-add-options arm_neon_fp16 } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcvtf16_f32 (void)\n+{\n+  float16x4_t out_float16x4_t;\n+  float32x4_t arg0_float32x4_t;\n+\n+  out_float16x4_t = vcvt_f16_f32 (arg0_float32x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcvt\\.f16.f32\\[ \t\\]+\\[dD\\]\\[0-9\\]+, \\[qQ\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "dd0ce1702ea704379a93f239606a7dcf8d4f52e2", "filename": "gcc/testsuite/gcc.target/arm/neon/vcvtf32_f16.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf32_f16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf32_f16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvcvtf32_f16.c?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -0,0 +1,20 @@\n+/* Test the `vcvtf32_f16' ARM Neon intrinsic.  */\n+/* This file was autogenerated by neon-testgen.  */\n+\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_neon_fp16_ok } */\n+/* { dg-options \"-save-temps -O0\" } */\n+/* { dg-add-options arm_neon_fp16 } */\n+\n+#include \"arm_neon.h\"\n+\n+void test_vcvtf32_f16 (void)\n+{\n+  float32x4_t out_float32x4_t;\n+  float16x4_t arg0_float16x4_t;\n+\n+  out_float32x4_t = vcvt_f32_f16 (arg0_float16x4_t);\n+}\n+\n+/* { dg-final { scan-assembler \"vcvt\\.f32.f16\\[ \t\\]+\\[qQ\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { cleanup-saved-temps } } */"}, {"sha": "593ed06ad361e11900740a314c54af64f001d11b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5819f96f449e5cba02fdaa2e9089470efa6c8ab0/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5819f96f449e5cba02fdaa2e9089470efa6c8ab0", "patch": "@@ -2255,6 +2255,47 @@ proc check_effective_target_arm_neon_ok { } {\n \t\tcheck_effective_target_arm_neon_ok_nocache]\n }\n \n+# Return 1 if this is an ARM target supporting -mfpu=neon-fp16\n+# -mfloat-abi=softfp or equivalent options.  Some multilibs may be\n+# incompatible with these options.  Also set et_arm_neon_flags to the\n+# best options to add.\n+\n+proc check_effective_target_arm_neon_fp16_ok_nocache { } {\n+    global et_arm_neon_fp16_flags\n+    set et_arm_neon_fp16_flags \"\"\n+    if { [check_effective_target_arm32] } {\n+\tforeach flags {\"\" \"-mfloat-abi=softfp\" \"-mfpu=neon-fp16\"\n+\t               \"-mfpu=neon-fp16 -mfloat-abi=softfp\"} {\n+\t    if { [check_no_compiler_messages_nocache arm_neon_fp_16_ok object {\n+\t\t#include \"arm_neon.h\"\n+\t\tfloat16x4_t\n+\t\tfoo (float32x4_t arg)\n+\t\t{\n+                  return vcvt_f16_f32 (arg);\n+\t\t}\n+\t    } \"$flags\"] } {\n+\t\tset et_arm_neon_fp16_flags $flags\n+\t\treturn 1\n+\t    }\n+\t}\n+    }\n+\n+    return 0\n+}\n+\n+proc check_effective_target_arm_neon_fp16_ok { } {\n+    return [check_cached_effective_target arm_neon_fp16_ok \\\n+\t\tcheck_effective_target_arm_neon_fp16_ok_nocache]\n+}\n+\n+proc add_options_for_arm_neon_fp16 { flags } {\n+    if { ! [check_effective_target_arm_neon_fp16_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_neon_fp16_flags\n+    return \"$flags $et_arm_neon_fp16_flags\"\n+}\n+\n # Return 1 if this is an ARM target supporting -mfpu=neon-fp-armv8\n # -mfloat-abi=softfp or equivalent options.  Some multilibs may be\n # incompatible with these options.  Also set et_arm_v8_neon_flags to the"}]}