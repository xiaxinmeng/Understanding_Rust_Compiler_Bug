{"sha": "6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "node_id": "C_kwDOANBUbNoAKDYxODBmNWM4ZDZkMWRjN2I2NjM0YzQxYTQ2ZjBmOGY1Y2EyZTViOWQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-24T08:08:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-24T11:40:36Z"}, "message": "tree-optimization/103168 - Improve VN of pure function calls\n\nThis improves value-numbering of calls that read memory, calls\nto const functions with aggregate arguments and calls to\npure functions where the latter include const functions we\ndemoted to pure for the fear of interposing with a less\noptimized version.  Note that for pure functions we do not\nhandle functions that access global memory.\n\n2021-11-24  Richard Biener  <rguenther@suse.de>\n\t    Jan Hubicka  <jh@suse.cz>\n\n\tPR tree-optimization/103168\n\t* ipa-modref.h (struct modref_summary): Add load_accesses.\n\t* ipa-modref.c (modref_summary::finalize): Initialize load_accesses.\n\t* tree-ssa-sccvn.c (visit_reference_op_call): Use modref\n\tinfo to walk the virtual use->def chain to CSE const/pure\n\tfunction calls possibly reading from memory.\n\n\t* g++.dg/tree-ssa/pr103168.C: New testcase.", "tree": {"sha": "81b714a9f498a39897ac2e4119f1d4b281116fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b714a9f498a39897ac2e4119f1d4b281116fc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd34569e7a9fc2b6c638a7ef62b965ed7e832ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdd34569e7a9fc2b6c638a7ef62b965ed7e832ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdd34569e7a9fc2b6c638a7ef62b965ed7e832ce"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "923ae6c1dd32c7cef3f49d7fd20a0a184da1ebb9", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "patch": "@@ -721,6 +721,23 @@ modref_summary::finalize (tree fun)\n \t    break;\n \t}\n     }\n+  if (loads->every_base)\n+    load_accesses = 1;\n+  else\n+    {\n+      load_accesses = 0;\n+      for (auto base_node : loads->bases)\n+\t{\n+\t  if (base_node->every_ref)\n+\t    load_accesses++;\n+\t  else\n+\t    for (auto ref_node : base_node->refs)\n+\t      if (ref_node->every_access)\n+\t\tload_accesses++;\n+\t      else\n+\t\tload_accesses += ref_node->accesses->length ();\n+\t}\n+    }\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */"}, {"sha": "a0247f5449f4ffd88dcfeb6791f05f9ab808afa3", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "patch": "@@ -53,6 +53,8 @@ struct GTY(()) modref_summary\n \n   /* Flags coputed by finalize method.  */\n \n+  /* Total number of accesses in loads tree.  */\n+  unsigned int load_accesses;\n   /* global_memory_read is not set for functions calling functions\n      with !binds_to_current_def which, after interposition, may read global\n      memory but do nothing useful with it (except for crashing if some"}, {"sha": "82924a3e3cec5f46428d6b046531b294c5df1fb5", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr103168.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr103168.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr103168.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr103168.C?ref=6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-fre1-details\" }\n+\n+struct a\n+{\n+  int a;\n+  static __attribute__ ((noinline))\n+      int ret (int v) {return v;}\n+\n+  __attribute__ ((noinline))\n+      int inca () {return a++;}\n+};\n+\n+int\n+test()\n+{\n+  struct a av;\n+  av.a=1;\n+  int val = av.ret (0) + av.inca();\n+  av.a=2;\n+  return val + av.ret(0) + av.inca();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replaced a::ret\" 1 \"fre1\" } } */"}, {"sha": "d31bf329d2e0e2de84c78d308061aa385115b34f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6180f5c8d6d1dc7b6634c41a46f0f8f5ca2e5b9d", "patch": "@@ -71,6 +71,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop-niter.h\"\n #include \"builtins.h\"\n #include \"fold-const-call.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n #include \"tree-ssa-sccvn.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n@@ -5084,12 +5086,136 @@ visit_reference_op_call (tree lhs, gcall *stmt)\n   struct vn_reference_s vr1;\n   vn_reference_t vnresult = NULL;\n   tree vdef = gimple_vdef (stmt);\n+  modref_summary *summary;\n \n   /* Non-ssa lhs is handled in copy_reference_ops_from_call.  */\n   if (lhs && TREE_CODE (lhs) != SSA_NAME)\n     lhs = NULL_TREE;\n \n   vn_reference_lookup_call (stmt, &vnresult, &vr1);\n+\n+  /* If the lookup did not succeed for pure functions try to use\n+     modref info to find a candidate to CSE to.  */\n+  const unsigned accesses_limit = 8;\n+  if (!vnresult\n+      && !vdef\n+      && lhs\n+      && gimple_vuse (stmt)\n+      && (((summary = get_modref_function_summary (stmt, NULL))\n+\t   && !summary->global_memory_read\n+\t   && summary->load_accesses < accesses_limit)\n+\t  || gimple_call_flags (stmt) & ECF_CONST))\n+    {\n+      /* First search if we can do someting useful and build a\n+\t vector of all loads we have to check.  */\n+      bool unknown_memory_access = false;\n+      auto_vec<ao_ref, accesses_limit> accesses;\n+      unsigned load_accesses = summary ? summary->load_accesses : 0;\n+      if (!unknown_memory_access)\n+\t/* Add loads done as part of setting up the call arguments.\n+\t   That's also necessary for CONST functions which will\n+\t   not have a modref summary.  */\n+\tfor (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t  {\n+\t    tree arg = gimple_call_arg (stmt, i);\n+\t    if (TREE_CODE (arg) != SSA_NAME\n+\t\t&& !is_gimple_min_invariant (arg))\n+\t      {\n+\t\tif (accesses.length () >= accesses_limit - load_accesses)\n+\t\t  {\n+\t\t    unknown_memory_access = true;\n+\t\t    break;\n+\t\t  }\n+\t\taccesses.quick_grow (accesses.length () + 1);\n+\t\tao_ref_init (&accesses.last (), arg);\n+\t      }\n+\t  }\n+      if (summary && !unknown_memory_access)\n+\t{\n+\t  /* Add loads as analyzed by IPA modref.  */\n+\t  for (auto base_node : summary->loads->bases)\n+\t    if (unknown_memory_access)\n+\t      break;\n+\t    else for (auto ref_node : base_node->refs)\n+\t      if (unknown_memory_access)\n+\t\tbreak;\n+\t      else for (auto access_node : ref_node->accesses)\n+\t\t{\n+\t\t  accesses.quick_grow (accesses.length () + 1);\n+\t\t  ao_ref *r = &accesses.last ();\n+\t\t  if (!access_node.get_ao_ref (stmt, r))\n+\t\t    {\n+\t\t      /* Initialize a ref based on the argument and\n+\t\t\t unknown offset if possible.  */\n+\t\t      tree arg = access_node.get_call_arg (stmt);\n+\t\t      if (arg && TREE_CODE (arg) == SSA_NAME)\n+\t\t\targ = SSA_VAL (arg);\n+\t\t      if (arg\n+\t\t\t  && TREE_CODE (arg) == ADDR_EXPR\n+\t\t\t  && (arg = get_base_address (arg))\n+\t\t\t  && DECL_P (arg))\n+\t\t\t{\n+\t\t\t  ao_ref_init (r, arg);\n+\t\t\t  r->ref = NULL_TREE;\n+\t\t\t  r->base = arg;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  unknown_memory_access = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  r->base_alias_set = base_node->base;\n+\t\t  r->ref_alias_set = ref_node->ref;\n+\t\t}\n+\t}\n+\n+      /* Walk the VUSE->VDEF chain optimistically trying to find an entry\n+\t for the call in the hashtable.  */\n+      unsigned limit = (unknown_memory_access\n+\t\t\t? 0\n+\t\t\t: (param_sccvn_max_alias_queries_per_access\n+\t\t\t   / (accesses.length () + 1)));\n+      tree saved_vuse = vr1.vuse;\n+      hashval_t saved_hashcode = vr1.hashcode;\n+      while (limit > 0 && !vnresult && !SSA_NAME_IS_DEFAULT_DEF (vr1.vuse))\n+\t{\n+\t  vr1.hashcode = vr1.hashcode - SSA_NAME_VERSION (vr1.vuse);\n+\t  gimple *def = SSA_NAME_DEF_STMT (vr1.vuse);\n+\t  /* ???  We could use fancy stuff like in walk_non_aliased_vuses, but\n+\t     do not bother for now.  */\n+\t  if (is_a <gphi *> (def))\n+\t    break;\n+\t  vr1.vuse = vuse_ssa_val (gimple_vuse (def));\n+\t  vr1.hashcode = vr1.hashcode + SSA_NAME_VERSION (vr1.vuse);\n+\t  vn_reference_lookup_1 (&vr1, &vnresult);\n+\t  limit--;\n+\t}\n+\n+      /* If we found a candidate to CSE to verify it is valid.  */\n+      if (vnresult && !accesses.is_empty ())\n+\t{\n+\t  tree vuse = vuse_ssa_val (gimple_vuse (stmt));\n+\t  while (vnresult && vuse != vr1.vuse)\n+\t    {\n+\t      gimple *def = SSA_NAME_DEF_STMT (vuse);\n+\t      for (auto &ref : accesses)\n+\t\t{\n+\t\t  /* ???  stmt_may_clobber_ref_p_1 does per stmt constant\n+\t\t     analysis overhead that we might be able to cache.  */\n+\t\t  if (stmt_may_clobber_ref_p_1 (def, &ref, true))\n+\t\t    {\n+\t\t      vnresult = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      vuse = vuse_ssa_val (gimple_vuse (def));\n+\t    }\n+\t}\n+      vr1.vuse = saved_vuse;\n+      vr1.hashcode = saved_hashcode;\n+    }\n+\n   if (vnresult)\n     {\n       if (vnresult->result_vdef && vdef)"}]}