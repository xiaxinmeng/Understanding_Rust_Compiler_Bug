{"sha": "31933f4f788b6cd64cbb7ee42076997f6d0fe212", "node_id": "C_kwDOANBUbNoAKDMxOTMzZjRmNzg4YjZjZDY0Y2JiN2VlNDIwNzY5OTdmNmQwZmUyMTI", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-04-01T16:09:43Z"}, "committer": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-04-01T16:09:43Z"}, "message": "Add an assertion: the zeroed_hardregs set is a subset of all call used regs.\n\nWe should make sure that the hard register set that is actually cleared by\nthe target hook zero_call_used_regs should be a subset of all call used\nregisters.\n\nAt the same time, update documentation for the target hook\nTARGET_ZERO_CALL_USED_REGS.\n\nThis new assertion identified a bug in the i386 implemenation, which\nincorrectly set the zeroed_hardregs for stack registers. Fixed this bug\nin i386 implementation.\n\ngcc/ChangeLog:\n\n2022-04-01  Qing Zhao  <qing.zhao@oracle.com>\n\n\t* config/i386/i386.cc (zero_all_st_registers): Return the value of\n\tnum_of_st.\n\t(ix86_zero_call_used_regs): Update zeroed_hardregs set according to\n\tthe return value of zero_all_st_registers.\n\t* doc/tm.texi: Update the documentation of TARGET_ZERO_CALL_USED_REGS.\n\t* function.cc (gen_call_used_regs_seq): Add an assertion.\n\t* target.def: Update the documentation of TARGET_ZERO_CALL_USED_REGS.", "tree": {"sha": "5daa89e8f0c580f945687dc4a47f4eb9d1e7032e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5daa89e8f0c580f945687dc4a47f4eb9d1e7032e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31933f4f788b6cd64cbb7ee42076997f6d0fe212", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31933f4f788b6cd64cbb7ee42076997f6d0fe212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31933f4f788b6cd64cbb7ee42076997f6d0fe212", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31933f4f788b6cd64cbb7ee42076997f6d0fe212/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413187b0b3c873333253838e4afbf8463b288b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/413187b0b3c873333253838e4afbf8463b288b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/413187b0b3c873333253838e4afbf8463b288b59"}], "stats": {"total": 63, "additions": 50, "deletions": 13}, "files": [{"sha": "d84047a4bc1b5b1e09336975a98aebcf4945f867", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=31933f4f788b6cd64cbb7ee42076997f6d0fe212", "patch": "@@ -3753,16 +3753,17 @@ zero_all_vector_registers (HARD_REG_SET need_zeroed_hardregs)\n    needs to be cleared, the whole stack should be cleared.  However,\n    x87 stack registers that hold the return value should be excluded.\n    x87 returns in the top (two for complex values) register, so\n-   num_of_st should be 7/6 when x87 returns, otherwise it will be 8.  */\n+   num_of_st should be 7/6 when x87 returns, otherwise it will be 8.\n+   return the value of num_of_st.  */\n \n \n-static bool\n+static int\n zero_all_st_registers (HARD_REG_SET need_zeroed_hardregs)\n {\n \n   /* If the FPU is disabled, no need to zero all st registers.  */\n   if (! (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387))\n-    return false;\n+    return 0;\n \n   unsigned int num_of_st = 0;\n   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -3774,7 +3775,7 @@ zero_all_st_registers (HARD_REG_SET need_zeroed_hardregs)\n       }\n \n   if (num_of_st == 0)\n-    return false;\n+    return 0;\n \n   bool return_with_x87 = false;\n   return_with_x87 = (crtl->return_rtx\n@@ -3802,7 +3803,7 @@ zero_all_st_registers (HARD_REG_SET need_zeroed_hardregs)\n       insn = emit_insn (gen_rtx_SET (st_reg, st_reg));\n       add_reg_note (insn, REG_DEAD, st_reg);\n     }\n-  return true;\n+  return num_of_st;\n }\n \n \n@@ -3851,7 +3852,7 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n {\n   HARD_REG_SET zeroed_hardregs;\n   bool all_sse_zeroed = false;\n-  bool all_st_zeroed = false;\n+  int all_st_zeroed_num = 0;\n   bool all_mm_zeroed = false;\n \n   CLEAR_HARD_REG_SET (zeroed_hardregs);\n@@ -3881,9 +3882,17 @@ ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n   if (!exit_with_mmx_mode)\n     /* x87 exit mode, we should zero all st registers together.  */\n     {\n-      all_st_zeroed = zero_all_st_registers (need_zeroed_hardregs);\n-      if (all_st_zeroed)\n-\tSET_HARD_REG_BIT (zeroed_hardregs, FIRST_STACK_REG);\n+      all_st_zeroed_num = zero_all_st_registers (need_zeroed_hardregs);\n+\n+      if (all_st_zeroed_num > 0)\n+\tfor (unsigned int regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n+\t  /* x87 stack registers that hold the return value should be excluded.\n+\t     x87 returns in the top (two for complex values) register.  */\n+\t  if (all_st_zeroed_num == 8\n+\t      || !((all_st_zeroed_num >= 6 && regno == REGNO (crtl->return_rtx))\n+\t\t   || (all_st_zeroed_num == 6\n+\t\t       && (regno == (REGNO (crtl->return_rtx) + 1)))))\n+\t    SET_HARD_REG_BIT (zeroed_hardregs, regno);\n     }\n   else\n     /* MMX exit mode, check whether we can zero all mm registers.  */"}, {"sha": "c5006afc00d2ae82a81c48b4c6be89275f7ecf35", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=31933f4f788b6cd64cbb7ee42076997f6d0fe212", "patch": "@@ -12330,6 +12330,13 @@ This target hook emits instructions to zero the subset of @var{selected_regs}\n that could conceivably contain values that are useful to an attacker.\n Return the set of registers that were actually cleared.\n \n+For most targets, the returned set of registers is a subset of\n+@var{selected_regs}, however, for some of the targets (for example MIPS),\n+clearing some registers that are in the @var{selected_regs} requires\n+clearing other call used registers that are not in the @var{selected_regs},\n+under such situation, the returned set of registers must be a subset of all\n+call used registers.\n+\n The default implementation uses normal move instructions to zero\n all the registers in @var{selected_regs}.  Define this hook if the\n target has more efficient ways of zeroing certain registers,"}, {"sha": "ad0096a43eff655a6734f4888998e5e7c0125400", "filename": "gcc/function.cc", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Ffunction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Ffunction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.cc?ref=31933f4f788b6cd64cbb7ee42076997f6d0fe212", "patch": "@@ -5892,7 +5892,9 @@ gen_call_used_regs_seq (rtx_insn *ret, unsigned int zero_regs_type)\n   df_simulate_one_insn_backwards (bb, ret, live_out);\n \n   HARD_REG_SET selected_hardregs;\n+  HARD_REG_SET all_call_used_regs;\n   CLEAR_HARD_REG_SET (selected_hardregs);\n+  CLEAR_HARD_REG_SET (all_call_used_regs);\n   for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     {\n       if (!crtl->abi->clobbers_full_reg_p (regno))\n@@ -5901,17 +5903,20 @@ gen_call_used_regs_seq (rtx_insn *ret, unsigned int zero_regs_type)\n \tcontinue;\n       if (REGNO_REG_SET_P (live_out, regno))\n \tcontinue;\n+#ifdef LEAF_REG_REMAP\n+      if (crtl->uses_only_leaf_regs && LEAF_REG_REMAP (regno) < 0)\n+\tcontinue;\n+#endif\n+      /* This is a call used register that is dead at return.  */\n+      SET_HARD_REG_BIT (all_call_used_regs, regno);\n+\n       if (only_gpr\n \t  && !TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], regno))\n \tcontinue;\n       if (only_used && !df_regs_ever_live_p (regno))\n \tcontinue;\n       if (only_arg && !FUNCTION_ARG_REGNO_P (regno))\n \tcontinue;\n-#ifdef LEAF_REG_REMAP\n-      if (crtl->uses_only_leaf_regs && LEAF_REG_REMAP (regno) < 0)\n-\tcontinue;\n-#endif\n \n       /* Now this is a register that we might want to zero.  */\n       SET_HARD_REG_BIT (selected_hardregs, regno);\n@@ -5925,6 +5930,15 @@ gen_call_used_regs_seq (rtx_insn *ret, unsigned int zero_regs_type)\n   HARD_REG_SET zeroed_hardregs;\n   start_sequence ();\n   zeroed_hardregs = targetm.calls.zero_call_used_regs (selected_hardregs);\n+\n+  /* For most targets, the returned set of registers is a subset of\n+     selected_hardregs, however, for some of the targets (for example MIPS),\n+     clearing some registers that are in selected_hardregs requires clearing\n+     other call used registers that are not in the selected_hardregs, under\n+     such situation, the returned set of registers must be a subset of\n+     all call used registers.  */\n+  gcc_assert (hard_reg_set_subset_p (zeroed_hardregs, all_call_used_regs));\n+\n   rtx_insn *seq = get_insns ();\n   end_sequence ();\n   if (seq)"}, {"sha": "d85adf36a3918ec4ce3409ef05a8d0bdcec9478c", "filename": "gcc/target.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31933f4f788b6cd64cbb7ee42076997f6d0fe212/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=31933f4f788b6cd64cbb7ee42076997f6d0fe212", "patch": "@@ -5122,6 +5122,13 @@ DEFHOOK\n that could conceivably contain values that are useful to an attacker.\\n\\\n Return the set of registers that were actually cleared.\\n\\\n \\n\\\n+For most targets, the returned set of registers is a subset of\\n\\\n+@var{selected_regs}, however, for some of the targets (for example MIPS),\\n\\\n+clearing some registers that are in the @var{selected_regs} requires\\n\\\n+clearing other call used registers that are not in the @var{selected_regs},\\n\\\n+under such situation, the returned set of registers must be a subset of all\\n\\\n+call used registers.\\n\\\n+\\n\\\n The default implementation uses normal move instructions to zero\\n\\\n all the registers in @var{selected_regs}.  Define this hook if the\\n\\\n target has more efficient ways of zeroing certain registers,\\n\\"}]}