{"sha": "4ce3d5373035e991585e11d68a07c6e6e101eb92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlM2Q1MzczMDM1ZTk5MTU4NWUxMWQ2OGEwN2M2ZTZlMTAxZWI5Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-18T20:44:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-18T20:44:14Z"}, "message": "cp-tree.h (build_lang_field_decl): Remove.\n\n        * cp-tree.h (build_lang_field_decl): Remove.\n\t* class.c (build_vtable): Replace calls to build_lang_field_decl\n\twith build_lang_decl.\n\t(prepare_fresh_vtable): Likewise.\n\t(finish_struct_1): Likewise.\n\t(init_class_processing): Likewise.\n\t* decl.c (push_using_decl): Likewise.\n\t(init_decl_processsing): Likewise.\n\t(grokvardecl): Likewise.\n\t(build_ptrmemfunc_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t(build_enumerator): Likewise.\n\t* decl2.c (grok_x_components): Likewise.\n\t(do_class_using_decl): Likewise.\n\t* except.c (call_eh_info): Likewise.\n\t* init.c (init_init_processing): Likewise.\n\t* rtti.c (expand_class_decl): Likewise.\n\t* tree.c (build_base_fields): Likewise.\n\t(build_vbase_pointer_fields): Likewise.\n\t* lex.c (build_lang_decl): Build declarations on the permanent\n\tobstack if we're building statmeent trees.\n\t(retrofit_lang_decl): Handle both the full lang_decl and also the\n\tsmaller lang_decl_flags here.\n\t(build_lang_field_decl): Remove.\n\t* pt.c (push_template_decl_real): Issue errors for variable\n\tdeclarations that are not static members.\n\nFrom-SVN: r28755", "tree": {"sha": "aec1b78caa248bc5c7196080755c9db3d1f8c70a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aec1b78caa248bc5c7196080755c9db3d1f8c70a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce3d5373035e991585e11d68a07c6e6e101eb92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce3d5373035e991585e11d68a07c6e6e101eb92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce3d5373035e991585e11d68a07c6e6e101eb92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce3d5373035e991585e11d68a07c6e6e101eb92/comments", "author": null, "committer": null, "parents": [{"sha": "88049523aee2c2f48a78bd6f7cf36958a864f302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88049523aee2c2f48a78bd6f7cf36958a864f302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88049523aee2c2f48a78bd6f7cf36958a864f302"}], "stats": {"total": 231, "additions": 134, "deletions": 97}, "files": [{"sha": "0e1012f817176dac36f04e8452155ea04bf3b20b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -1,3 +1,32 @@\n+1999-08-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+        * cp-tree.h (build_lang_field_decl): Remove.\n+\t* class.c (build_vtable): Replace calls to build_lang_field_decl\n+\twith build_lang_decl.\n+\t(prepare_fresh_vtable): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(init_class_processing): Likewise.\n+\t* decl.c (push_using_decl): Likewise.\n+\t(init_decl_processsing): Likewise.\n+\t(grokvardecl): Likewise.\n+\t(build_ptrmemfunc_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(build_enumerator): Likewise.\n+\t* decl2.c (grok_x_components): Likewise.\n+\t(do_class_using_decl): Likewise.\n+\t* except.c (call_eh_info): Likewise.\n+\t* init.c (init_init_processing): Likewise.\n+\t* rtti.c (expand_class_decl): Likewise.\n+\t* tree.c (build_base_fields): Likewise.\n+\t(build_vbase_pointer_fields): Likewise.\n+\t* lex.c (build_lang_decl): Build declarations on the permanent\n+\tobstack if we're building statmeent trees.\n+\t(retrofit_lang_decl): Handle both the full lang_decl and also the\n+\tsmaller lang_decl_flags here.\n+\t(build_lang_field_decl): Remove.\n+\t* pt.c (push_template_decl_real): Issue errors for variable\n+\tdeclarations that are not static members.\n+\n 1999-08-18  Richard Henderson  <rth@cygnus.com>\n \n \t* tree.c (search_tree): Handle TRUTH_{AND,OR,XOR}_EXPR too."}, {"sha": "a6499551f852fab5fffe3a6f87c84b68e9e4b74a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -737,8 +737,8 @@ build_vtable (binfo, type)\n       tree offset;\n \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n-      decl = build_lang_field_decl (VAR_DECL, name, \n-\t\t\t\t    TREE_TYPE (BINFO_VTABLE (binfo)));\n+      decl = build_lang_decl (VAR_DECL, name, \n+\t\t\t      TREE_TYPE (BINFO_VTABLE (binfo)));\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n@@ -748,7 +748,7 @@ build_vtable (binfo, type)\n   else\n     {\n       virtuals = NULL_TREE;\n-      decl = build_lang_field_decl (VAR_DECL, name, void_type_node);\n+      decl = build_lang_decl (VAR_DECL, name, void_type_node);\n     }\n \n #ifdef GATHER_STATISTICS\n@@ -898,7 +898,7 @@ prepare_fresh_vtable (binfo, for_type)\n       buf2 = new_buf2;\n     }\n \n-  new_decl = build_lang_field_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n+  new_decl = build_lang_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n   /* Remember which class this vtable is really for.  */\n   DECL_CONTEXT (new_decl) = for_type;\n \n@@ -3841,7 +3841,7 @@ finish_struct_1 (t)\n \t bounds.  That's better than using `void*' or some such; it's\n \t cleaner, and it let's the alias analysis code know that these\n \t stores cannot alias stores to void*!  */\n-      vfield = build_lang_field_decl (FIELD_DECL, get_vfield_name (t),\n+      vfield = build_lang_decl (FIELD_DECL, get_vfield_name (t),\n \t\t\t\t      vtbl_ptr_type_node);\n       /* If you change any of the below, take a look at all the\n \t other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n@@ -3908,7 +3908,7 @@ finish_struct_1 (t)\n   if (empty)\n     {\n       /* C++: do not let empty structures exist.  */\n-      tree decl = build_lang_field_decl\n+      tree decl = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, char_type_node);\n       TREE_CHAIN (decl) = fields;\n       TYPE_FIELDS (t) = decl;\n@@ -4507,7 +4507,7 @@ init_class_processing ()\n   access_private_virtual_node = build_int_2 (7, 0);\n \n   /* Keep these values lying around.  */\n-  base_layout_decl = build_lang_field_decl (FIELD_DECL, NULL_TREE, error_mark_node);\n+  base_layout_decl = build_lang_decl (FIELD_DECL, NULL_TREE, error_mark_node);\n   TREE_TYPE (base_layout_decl) = make_node (RECORD_TYPE);\n \n   gcc_obstack_init (&class_obstack);"}, {"sha": "905a6595e4561b2322ab240bd20cca7b6b55d5b6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -3159,7 +3159,6 @@ extern int real_yylex\t\t\t\tPROTO((void));\n extern int is_rid\t\t\t\tPROTO((tree));\n extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n extern void retrofit_lang_decl\t\t\tPROTO((tree));\n-extern tree build_lang_field_decl\t\tPROTO((enum tree_code, tree, tree));\n extern void copy_lang_decl\t\t\tPROTO((tree));\n extern tree make_lang_type\t\t\tPROTO((enum tree_code));\n extern void dump_time_statistics\t\tPROTO((void));"}, {"sha": "1b1ad983b452a44dd351ef96b08094a49f66e529", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -4492,7 +4492,7 @@ push_using_decl (scope, name)\n       break;\n   if (decl)\n     return NULL_TREE;\n-  decl = build_lang_field_decl (USING_DECL, name, void_type_node);\n+  decl = build_lang_decl (USING_DECL, name, void_type_node);\n   DECL_INITIAL (decl) = scope;\n   TREE_CHAIN (decl) = current_binding_level->usings;\n   current_binding_level->usings = decl;\n@@ -6511,12 +6511,12 @@ init_decl_processing ()\n   else\n     {\n       vtable_entry_type = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, pfn_identifier,\n-\t\t\t\t\t ptr_type_node);\n+      fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n+\t\t\t\t   delta_type_node);\n+      fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n+\t\t\t\t   delta_type_node);\n+      fields[2] = build_lang_decl (FIELD_DECL, pfn_identifier,\n+\t\t\t\t   ptr_type_node);\n       finish_builtin_type (vtable_entry_type, VTBL_PTR_TYPE, fields, 2,\n \t\t\t   double_type_node);\n \n@@ -8624,7 +8624,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \t can be initialized, the code will reach here.  */\n       tree basetype = TYPE_OFFSET_BASETYPE (type);\n       type = TREE_TYPE (type);\n-      decl = build_lang_field_decl (VAR_DECL, declarator, type);\n+      decl = build_lang_decl (VAR_DECL, declarator, type);\n       DECL_CONTEXT (decl) = basetype;\n       DECL_CLASS_CONTEXT (decl) = basetype;\n       DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n@@ -8645,7 +8645,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \t  /* If we're in a template, we need DECL_LANG_SPECIFIC so that\n \t     we can call push_template_decl.  */\n \t  push_permanent_obstack ();\n-\t  decl = build_lang_field_decl (VAR_DECL, declarator,\n+\t  decl = build_lang_decl (VAR_DECL, declarator,\n \t\t\t\t\tcomplete_type (type));\n \t  pop_obstacks ();\n \t}\n@@ -8742,9 +8742,9 @@ build_ptrmemfunc_type (type)\n \n   u = make_lang_type (UNION_TYPE);\n   SET_IS_AGGR_TYPE (u, 0);\n-  fields[0] = build_lang_field_decl (FIELD_DECL, pfn_identifier, type);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, delta2_identifier,\n-\t\t\t\t     delta_type_node);\n+  fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n+  fields[1] = build_lang_decl (FIELD_DECL, delta2_identifier,\n+\t\t\t       delta_type_node);\n   finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n   TYPE_NAME (u) = NULL_TREE;\n \n@@ -8755,11 +8755,11 @@ build_ptrmemfunc_type (type)\n   /* ... and not really an aggregate.  */\n   SET_IS_AGGR_TYPE (t, 0);\n \n-  fields[0] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t     delta_type_node);\n-  fields[1] = build_lang_field_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t     delta_type_node);\n-  fields[2] = build_lang_field_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n+  fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n+\t\t\t       delta_type_node);\n+  fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n+\t\t\t       delta_type_node);\n+  fields[2] = build_lang_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n   finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n \n   pop_obstacks ();\n@@ -11044,16 +11044,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      {\n \t\t/* C++ allows static class members.\n \t\t   All other work for this is done by grokfield.\n-\t\t   This VAR_DECL is built by build_lang_field_decl.\n+\t\t   This VAR_DECL is built by build_lang_decl.\n \t\t   All other VAR_DECLs are built by build_decl.  */\n-\t\tdecl = build_lang_field_decl (VAR_DECL, declarator, type);\n+\t\tdecl = build_lang_decl (VAR_DECL, declarator, type);\n \t\tTREE_STATIC (decl) = 1;\n \t\t/* In class context, 'static' means public access.  */\n \t\tTREE_PUBLIC (decl) = DECL_EXTERNAL (decl) = 1;\n \t      }\n \t    else\n \t      {\n-\t\tdecl = build_lang_field_decl (FIELD_DECL, declarator, type);\n+\t\tdecl = build_lang_decl (FIELD_DECL, declarator, type);\n \t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;\n@@ -12701,7 +12701,7 @@ build_enumerator (name, value, type)\n  context = current_scope ();\n  if (context && context == current_class_type)\n    /* This enum declaration is local to the class.  */\n-   decl = build_lang_field_decl (CONST_DECL, name, type);\n+   decl = build_lang_decl (CONST_DECL, name, type);\n  else\n    /* It's a global enum, or it's local to a function.  (Note local to\n       a function could mean local to a class method.  */"}, {"sha": "a0a7e6c367fada6f5d7a8310f5d0bca3e44b6c20", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -901,9 +901,7 @@ grok_x_components (specs)\n     return;\n \n   fixup_anonymous_aggr (t);\n-  finish_member_declaration (build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t\t    NULL_TREE,\n-\t\t\t\t\t\t    t)); \n+  finish_member_declaration (build_lang_decl (FIELD_DECL, NULL_TREE, t)); \n \n   /* Ignore any inline function definitions in the anonymous union\n      since an anonymous union may not have function members.  */\n@@ -5130,7 +5128,7 @@ do_class_using_decl (decl)\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n \n-  value = build_lang_field_decl (USING_DECL, name, void_type_node);\n+  value = build_lang_decl (USING_DECL, name, void_type_node);\n   DECL_INITIAL (value) = TREE_OPERAND (decl, 0);\n   return value;\n }"}, {"sha": "0a9bcf54f0fec253d33c1dd0c91003bae03b1715", "filename": "gcc/cp/except.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -245,46 +245,46 @@ call_eh_info ()\n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n       t1= make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, \n+      fields[0] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"handler_label\"), ptr_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, \n+      fields[1] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"dynamic_handler_chain\"), ptr_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, \n+      fields[2] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"info\"), ptr_type_node);\n-      fields[3] = build_lang_field_decl (FIELD_DECL, \n+      fields[3] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"table_index\"), ptr_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n       finish_builtin_type (t1, \"eh_context\", fields, 3, ptr_type_node);\n       t1 = build_pointer_type (t1);\n \n       t1= make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, \n+      fields[0] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"match_function\"), ptr_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, \n+      fields[1] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"language\"), short_integer_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, \n+      fields[2] = build_lang_decl (FIELD_DECL, \n                     get_identifier (\"version\"), short_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n       finish_builtin_type (t1, \"__eh_info\", fields, 2, ptr_type_node);\n       t = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, \n-                                              get_identifier (\"eh_info\"), t1);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n-\t\t\t\t\t ptr_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n-\t\t\t\t\t ptr_type_node);\n-      fields[3] = build_lang_field_decl\n+      fields[0] = build_lang_decl (FIELD_DECL, \n+\t\t\t\t   get_identifier (\"eh_info\"), t1);\n+      fields[1] = build_lang_decl (FIELD_DECL, get_identifier (\"value\"),\n+\t\t\t\t   ptr_type_node);\n+      fields[2] = build_lang_decl (FIELD_DECL, get_identifier (\"type\"),\n+\t\t\t\t   ptr_type_node);\n+      fields[3] = build_lang_decl\n \t(FIELD_DECL, get_identifier (\"cleanup\"),\n \t build_pointer_type (build_function_type\n \t\t\t     (ptr_type_node, tree_cons\n \t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n-      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n-\t\t\t\t\t boolean_type_node);\n-      fields[5] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n-\t\t\t\t\t build_pointer_type (t));\n-      fields[6] = build_lang_field_decl\n+      fields[4] = build_lang_decl (FIELD_DECL, get_identifier (\"caught\"),\n+\t\t\t\t   boolean_type_node);\n+      fields[5] = build_lang_decl (FIELD_DECL, get_identifier (\"next\"),\n+\t\t\t\t   build_pointer_type (t));\n+      fields[6] = build_lang_decl\n \t(FIELD_DECL, get_identifier (\"handlers\"), long_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */"}, {"sha": "f8c1980d214a612f77d78d3c2e74507345b7923c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -82,7 +82,7 @@ void init_init_processing ()\n      arrays allocated via operator new.  */\n   BI_header_type = make_lang_type (RECORD_TYPE);\n   nc_nelts_field_id = get_identifier (\"nelts\");\n-  fields[0] = build_lang_field_decl (FIELD_DECL, nc_nelts_field_id, sizetype);\n+  fields[0] = build_lang_decl (FIELD_DECL, nc_nelts_field_id, sizetype);\n   finish_builtin_type (BI_header_type, \"__new_cookie\", fields,\n \t\t       0, double_type_node);\n   BI_header_size = size_in_bytes (BI_header_type);"}, {"sha": "a67b37d97cc1ceed73761ae89f121cfcd587f83f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -4734,8 +4734,19 @@ build_lang_decl (code, name, type)\n      tree name;\n      tree type;\n {\n-  register tree t = build_decl (code, name, type);\n+  tree t;\n+\n+  /* When we're building statement trees, declarations need to live\n+     forever.  */\n+  if (building_stmt_tree ())\n+    push_permanent_obstack ();\n+\n+  t = build_decl (code, name, type);\n   retrofit_lang_decl (t);\n+\n+  if (building_stmt_tree ())\n+    pop_obstacks ();\n+\n   return t;\n }\n \n@@ -4748,30 +4759,33 @@ retrofit_lang_decl (t)\n {\n   struct obstack *obstack = current_obstack;\n   struct lang_decl *ld;\n+  size_t size;\n \n-  my_friendly_assert (CAN_HAVE_FULL_LANG_DECL_P (t), 19990816);\n+  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n+    size = sizeof (struct lang_decl);\n+  else\n+    size = sizeof (struct lang_decl_flags);\n \n   if (! TREE_PERMANENT (t))\n     obstack = saveable_obstack;\n   else\n     /* Could be that saveable is permanent and current is not.  */\n     obstack = &permanent_obstack;\n \n-  if (free_lang_decl_chain && obstack == &permanent_obstack)\n+  if (CAN_HAVE_FULL_LANG_DECL_P (t) && free_lang_decl_chain \n+      && obstack == &permanent_obstack)\n     {\n       ld = free_lang_decl_chain;\n       free_lang_decl_chain = free_lang_decl_chain->u.next;\n     }\n   else\n-    ld = ((struct lang_decl *) \n-\t  obstack_alloc (obstack, sizeof (struct lang_decl)));\n+    ld = (struct lang_decl *) obstack_alloc (obstack, size);\n \n-  bzero (ld, sizeof (struct lang_decl));\n+  bzero (ld, size);\n \n   DECL_LANG_SPECIFIC (t) = ld;\n   LANG_DECL_PERMANENT (ld) = obstack == &permanent_obstack;\n   my_friendly_assert (LANG_DECL_PERMANENT (ld) == TREE_PERMANENT  (t), 234);\n-  DECL_MAIN_VARIANT (t) = t;\n   if (current_lang_name == lang_name_cplusplus)\n     DECL_LANGUAGE (t) = lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n@@ -4780,39 +4794,15 @@ retrofit_lang_decl (t)\n     DECL_LANGUAGE (t) = lang_java;\n   else my_friendly_abort (64);\n \n+  if (CAN_HAVE_FULL_LANG_DECL_P (t))\n+    DECL_MAIN_VARIANT (t) = t;\n+\n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += sizeof (struct lang_decl);\n+  tree_node_sizes[(int)lang_decl] += size;\n #endif\n }\n \n-/* Like build_decl, except that a new lang_decl_flags structure is\n-   placed in DECL_LANG_SPECIFIC.  */\n-\n-tree\n-build_lang_field_decl (code, name, type)\n-     enum tree_code code;\n-     tree name;\n-     tree type;\n-{\n-  extern struct obstack *current_obstack, *saveable_obstack;\n-  register tree t = build_decl (code, name, type);\n-  struct obstack *obstack = current_obstack;\n-\n-  if (! TREE_PERMANENT (t))\n-    obstack = saveable_obstack;\n-  else\n-    my_friendly_assert (obstack == &permanent_obstack, 235);\n-\n-  my_friendly_assert (!CAN_HAVE_FULL_LANG_DECL_P (t), 19990816);\n-\n-  DECL_LANG_SPECIFIC (t) \n-    = ((struct lang_decl *) \n-       obstack_alloc (obstack, sizeof (struct lang_decl_flags)));\n-  bzero (DECL_LANG_SPECIFIC (t), sizeof (struct lang_decl_flags));\n-  return t;\n-}\n-\n void\n copy_lang_decl (node)\n      tree node;"}, {"sha": "9a31d60699ddb701475e0f8b4208927b47bb959a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -2421,11 +2421,15 @@ push_template_decl_real (decl, is_friend)\n     {\n       if (current_lang_name == lang_name_c)\n \tcp_error (\"template with C linkage\");\n-      if (TREE_CODE (decl) == TYPE_DECL && ANON_AGGRNAME_P (DECL_NAME (decl)))\n+      else if (TREE_CODE (decl) == TYPE_DECL \n+\t       && ANON_AGGRNAME_P (DECL_NAME (decl))) \n \tcp_error (\"template class without a name\");\n-      if (TREE_CODE (decl) == TYPE_DECL \n+      else if (TREE_CODE (decl) == TYPE_DECL \n \t  && TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n \tcp_error (\"template declaration of `%#T'\", TREE_TYPE (decl));\n+      else if (TREE_CODE (decl) == VAR_DECL\n+\t       && !CLASS_TYPE_P (CP_DECL_CONTEXT (decl)))\n+\tcp_error (\"template declaration of `%#D'\", decl);\n     }\n \n   /* Check to see that the rules regarding the use of default"}, {"sha": "93947d288c1d84dd71066eff9952c5c3518c0abc", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -802,23 +802,23 @@ expand_class_desc (tdecl, type)\n       base_info_type_node = make_lang_type (RECORD_TYPE);\n \n       /* Actually const __user_type_info * */\n-      fields [0] = build_lang_field_decl\n+      fields [0] = build_lang_decl\n \t(FIELD_DECL, NULL_TREE,\n \t build_pointer_type (build_qualified_type\n \t\t\t     (type_info_type_node,\n \t\t\t      TYPE_QUAL_CONST)));\n-      fields [1] = build_lang_field_decl\n+      fields [1] = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n       DECL_BIT_FIELD (fields[1]) = 1;\n       DECL_FIELD_SIZE (fields[1]) = 29;\n \n-      fields [2] = build_lang_field_decl\n+      fields [2] = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, boolean_type_node);\n       DECL_BIT_FIELD (fields[2]) = 1;\n       DECL_FIELD_SIZE (fields[2]) = 1;\n \n       /* Actually enum access */\n-      fields [3] = build_lang_field_decl\n+      fields [3] = build_lang_decl\n \t(FIELD_DECL, NULL_TREE, integer_type_node);\n       DECL_BIT_FIELD (fields[3]) = 1;\n       DECL_FIELD_SIZE (fields[3]) = 2;"}, {"sha": "d159ac143b37a894b2c6d59db40850ffdde56bea", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -888,7 +888,7 @@ build_base_fields (rec)\n       if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n-      decl = build_lang_field_decl (FIELD_DECL, NULL_TREE, basetype);\n+      decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = rec;\n       DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n@@ -1000,8 +1000,8 @@ build_vbase_pointer_fields (rec)\n \t\tgoto got_it;\n \t    }\n \t  FORMAT_VBASE_NAME (name, basetype);\n-\t  decl = build_lang_field_decl (FIELD_DECL, get_identifier (name),\n-\t\t\t\t\tbuild_pointer_type (basetype));\n+\t  decl = build_lang_decl (FIELD_DECL, get_identifier (name),\n+\t\t\t\t  build_pointer_type (basetype));\n \t  /* If you change any of the below, take a look at all the\n \t     other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n \t     them too.  */"}, {"sha": "6201a5cc57769ac4c62e5850f89da2ede5e9e6da", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash45.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash45.C?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+template <class T> void f()\n+{\n+  extern void g ();\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}\n+"}, {"sha": "06cbfa9db862cd3f6a3e2e73bc7af947972e9105", "filename": "gcc/testsuite/g++.old-deja/g++.pt/var1.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvar1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce3d5373035e991585e11d68a07c6e6e101eb92/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvar1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvar1.C?ref=4ce3d5373035e991585e11d68a07c6e6e101eb92", "patch": "@@ -0,0 +1,4 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+template <class T> T t; // ERROR - template declaration of t"}]}