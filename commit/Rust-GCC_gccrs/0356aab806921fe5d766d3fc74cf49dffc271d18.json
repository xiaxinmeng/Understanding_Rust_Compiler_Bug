{"sha": "0356aab806921fe5d766d3fc74cf49dffc271d18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1NmFhYjgwNjkyMWZlNWQ3NjZkM2ZjNzRjZjQ5ZGZmYzI3MWQxOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-17T21:20:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-17T21:20:00Z"}, "message": "omp-low.c (struct omp_context): Add scan_inclusive field.\n\n\t* omp-low.c (struct omp_context): Add scan_inclusive field.\n\t(scan_omp_1_stmt) <case GIMPLE_OMP_SCAN>: Set ctx->scan_inclusive\n\tif inclusive scan.\n\t(struct omplow_simd_context): Add lastlane member.\n\t(lower_rec_simd_input_clauses): Add rvar argument, handle inscan\n\treductions.  Build 2 or 3 argument .GOMP_SIMD_LANE calls rather than\n\t1 or 2 argument.\n\t(lower_rec_input_clauses): Handle inscan reductions in simd contexts.\n\t(lower_lastprivate_clauses): Set TREE_THIS_NOTRAP on the ARRAY_REF.\n\t(lower_omp_scan): New function.\n\t(lower_omp_1) <case GIMPLE_OMP_SCAN>: Use lower_omp_scan.\n\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): For IFN_GOMP_SIMD_LANE\n\tcheck 3rd argument if present rather than 2nd.\n\t* tree-vectorizer.h (struct _loop_vec_info): Add scan_map member.\n\t(struct _stmt_vec_info): Change simd_lane_access_p from bool into\n\t2-bit bitfield.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tscan_map.  For IFN_GOMP_SIMD_LANE check 3rd argument if present rather\n\tthan 2nd.\n\t(_loop_vec_info::~_loop_vec_info): Delete scan_map.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_accesses): Allow two\n\tdifferent STMT_VINFO_SIMD_LANE_ACCESS_P refs if they have the same\n\tinit.\n\t(vect_find_stmt_data_reference): Encode in ->aux the 2nd\n\tIFN_GOMP_SIMD_LANE argument.\n\t(vect_analyze_data_refs): Set STMT_VINFO_SIMD_LANE_ACCESS_P from the\n\tencoded ->aux value.\n\t* tree-vect-stmts.c: Include attribs.h.\n\t(vectorizable_call): Adjust comment about IFN_GOMP_SIMD_LANE.\n\t(scan_operand_equal_p, check_scan_store, vectorizable_scan_store): New\n\tfunctions.\n\t(vectorizable_load): For STMT_VINFO_SIMD_LANE_ACCESS_P tests use != 0.\n\t(vectorizable_store): Handle STMT_VINFO_SIMD_LANE_ACCESS_P > 1.\ncp/\n\t* semantics.c (finish_omp_clauses): For OMP_CLAUSE_REDUCTION_INSCAN\n\tset need_copy_assignment.\ntestsuite/\n\t* gcc.dg/vect/vect-simd-8.c: New test.\n\t* gcc.dg/vect/vect-simd-9.c: New test.\n\t* g++.dg/vect/simd-2.cc: New test.\n\t* g++.dg/gomp/scan-1.C: New test.\n\nFrom-SVN: r272399", "tree": {"sha": "4dbb450a132e4d4c5cadbc107b5997460457aecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dbb450a132e4d4c5cadbc107b5997460457aecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0356aab806921fe5d766d3fc74cf49dffc271d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0356aab806921fe5d766d3fc74cf49dffc271d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0356aab806921fe5d766d3fc74cf49dffc271d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0356aab806921fe5d766d3fc74cf49dffc271d18/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a064fd4c7385442dd4f9f3a1b538aef2fdac5209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a064fd4c7385442dd4f9f3a1b538aef2fdac5209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a064fd4c7385442dd4f9f3a1b538aef2fdac5209"}], "stats": {"total": 1382, "additions": 1348, "deletions": 34}, "files": [{"sha": "c75b08e487b0151b45350d459c3774399262b067", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -1,3 +1,39 @@\n+2019-06-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-low.c (struct omp_context): Add scan_inclusive field.\n+\t(scan_omp_1_stmt) <case GIMPLE_OMP_SCAN>: Set ctx->scan_inclusive\n+\tif inclusive scan.\n+\t(struct omplow_simd_context): Add lastlane member.\n+\t(lower_rec_simd_input_clauses): Add rvar argument, handle inscan\n+\treductions.  Build 2 or 3 argument .GOMP_SIMD_LANE calls rather than\n+\t1 or 2 argument.\n+\t(lower_rec_input_clauses): Handle inscan reductions in simd contexts.\n+\t(lower_lastprivate_clauses): Set TREE_THIS_NOTRAP on the ARRAY_REF.\n+\t(lower_omp_scan): New function.\n+\t(lower_omp_1) <case GIMPLE_OMP_SCAN>: Use lower_omp_scan.\n+\t* tree-ssa-dce.c (eliminate_unnecessary_stmts): For IFN_GOMP_SIMD_LANE\n+\tcheck 3rd argument if present rather than 2nd.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add scan_map member.\n+\t(struct _stmt_vec_info): Change simd_lane_access_p from bool into\n+\t2-bit bitfield.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tscan_map.  For IFN_GOMP_SIMD_LANE check 3rd argument if present rather\n+\tthan 2nd.\n+\t(_loop_vec_info::~_loop_vec_info): Delete scan_map.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_accesses): Allow two\n+\tdifferent STMT_VINFO_SIMD_LANE_ACCESS_P refs if they have the same\n+\tinit.\n+\t(vect_find_stmt_data_reference): Encode in ->aux the 2nd\n+\tIFN_GOMP_SIMD_LANE argument.\n+\t(vect_analyze_data_refs): Set STMT_VINFO_SIMD_LANE_ACCESS_P from the\n+\tencoded ->aux value.\n+\t* tree-vect-stmts.c: Include attribs.h.\n+\t(vectorizable_call): Adjust comment about IFN_GOMP_SIMD_LANE.\n+\t(scan_operand_equal_p, check_scan_store, vectorizable_scan_store): New\n+\tfunctions.\n+\t(vectorizable_load): For STMT_VINFO_SIMD_LANE_ACCESS_P tests use != 0.\n+\t(vectorizable_store): Handle STMT_VINFO_SIMD_LANE_ACCESS_P > 1.\n+\n 2019-06-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/62055"}, {"sha": "bab08df1ce5a086d8fe07e45d83db13b599afe4a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -1,3 +1,8 @@\n+2019-06-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* semantics.c (finish_omp_clauses): For OMP_CLAUSE_REDUCTION_INSCAN\n+\tset need_copy_assignment.\n+\n 2019-06-17  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/83820 - excessive attribute arguments not detected."}, {"sha": "6cf3af71c21b90e6e5ca217adf01d920abcd3766", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -7688,6 +7688,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_REDUCTION:\n \t  if (reduction_seen == -2)\n \t    OMP_CLAUSE_REDUCTION_INSCAN (c) = 0;\n+\t  if (OMP_CLAUSE_REDUCTION_INSCAN (c))\n+\t    need_copy_assignment = true;\n \t  need_implicitly_determined = true;\n \t  break;\n \tcase OMP_CLAUSE_IN_REDUCTION:"}, {"sha": "9df21a4d0466f27771f8222293ff5f665cd88312", "filename": "gcc/omp-low.c", "status": "modified", "additions": 357, "deletions": 20, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -141,6 +141,9 @@ struct omp_context\n   /* True if lower_omp_1 should look up lastprivate conditional in parent\n      context.  */\n   bool combined_into_simd_safelen0;\n+\n+  /* True if there is nested scan context with inclusive clause.  */\n+  bool scan_inclusive;\n };\n \n static splay_tree all_contexts;\n@@ -3329,11 +3332,15 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       scan_omp_single (as_a <gomp_single *> (stmt), ctx);\n       break;\n \n+    case GIMPLE_OMP_SCAN:\n+      if (tree clauses = gimple_omp_scan_clauses (as_a <gomp_scan *> (stmt)))\n+\tif (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_INCLUSIVE)\n+\t  ctx->scan_inclusive = true;\n+      /* FALLTHRU */\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_CRITICAL:\n-    case GIMPLE_OMP_SCAN:\n     case GIMPLE_OMP_GRID_BODY:\n       ctx = new_omp_context (stmt, ctx);\n       scan_omp (gimple_omp_body_ptr (stmt), ctx);\n@@ -3671,6 +3678,7 @@ struct omplow_simd_context {\n   omplow_simd_context () { memset (this, 0, sizeof (*this)); }\n   tree idx;\n   tree lane;\n+  tree lastlane;\n   vec<tree, va_heap> simt_eargs;\n   gimple_seq simt_dlist;\n   poly_uint64_pod max_vf;\n@@ -3682,7 +3690,8 @@ struct omplow_simd_context {\n \n static bool\n lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n-\t\t\t      omplow_simd_context *sctx, tree &ivar, tree &lvar)\n+\t\t\t      omplow_simd_context *sctx, tree &ivar,\n+\t\t\t      tree &lvar, tree *rvar = NULL)\n {\n   if (known_eq (sctx->max_vf, 0U))\n     {\n@@ -3738,7 +3747,27 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t= tree_cons (get_identifier (\"omp simd array\"), NULL,\n \t\t     DECL_ATTRIBUTES (avar));\n       gimple_add_tmp_var (avar);\n-      ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->idx,\n+      tree iavar = avar;\n+      if (rvar)\n+\t{\n+\t  /* For inscan reductions, create another array temporary,\n+\t     which will hold the reduced value.  */\n+\t  iavar = create_tmp_var_raw (atype);\n+\t  if (TREE_ADDRESSABLE (new_var))\n+\t    TREE_ADDRESSABLE (iavar) = 1;\n+\t  DECL_ATTRIBUTES (iavar)\n+\t    = tree_cons (get_identifier (\"omp simd array\"), NULL,\n+\t\t\t tree_cons (get_identifier (\"omp simd inscan\"), NULL,\n+\t\t\t\t    DECL_ATTRIBUTES (iavar)));\n+\t  gimple_add_tmp_var (iavar);\n+\t  ctx->cb.decl_map->put (avar, iavar);\n+\t  if (sctx->lastlane == NULL_TREE)\n+\t    sctx->lastlane = create_tmp_var (unsigned_type_node);\n+\t  *rvar = build4 (ARRAY_REF, TREE_TYPE (new_var), iavar,\n+\t\t\t  sctx->lastlane, NULL_TREE, NULL_TREE);\n+\t  TREE_THIS_NOTRAP (*rvar) = 1;\n+\t}\n+      ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), iavar, sctx->idx,\n \t\t     NULL_TREE, NULL_TREE);\n       lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, sctx->lane,\n \t\t     NULL_TREE, NULL_TREE);\n@@ -3814,7 +3843,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   omplow_simd_context sctx = omplow_simd_context ();\n   tree simt_lane = NULL_TREE, simtrec = NULL_TREE;\n   tree ivar = NULL_TREE, lvar = NULL_TREE, uid = NULL_TREE;\n-  gimple_seq llist[3] = { };\n+  gimple_seq llist[4] = { };\n   tree nonconst_simd_if = NULL_TREE;\n \n   copyin_seq = NULL;\n@@ -5155,9 +5184,14 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      new_vard = TREE_OPERAND (new_var, 0);\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n+\t\t  tree rvar = NULL_TREE, *rvarp = NULL;\n+\t\t  if (is_simd\n+\t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n+\t\t    rvarp = &rvar;\n \t\t  if (is_simd\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n-\t\t\t\t\t\t       ivar, lvar))\n+\t\t\t\t\t\t       ivar, lvar, rvarp))\n \t\t    {\n \t\t      if (new_vard == new_var)\n \t\t\t{\n@@ -5173,6 +5207,93 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t(c, unshare_expr (ivar),\n \t\t\t\t build_outer_var_ref (var, ctx));\n+\t\t      if (rvarp)\n+\t\t\t{\n+\t\t\t  if (x)\n+\t\t\t    {\n+\t\t\t      gimplify_and_add (x, &llist[0]);\n+\n+\t\t\t      tree ivar2 = unshare_expr (lvar);\n+\t\t\t      TREE_OPERAND (ivar2, 1) = sctx.idx;\n+\t\t\t      x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t    (c, ivar2, build_outer_var_ref (var, ctx));\n+\t\t\t      gimplify_and_add (x, &llist[0]);\n+\n+\t\t\t      /* For types that need construction, add another\n+\t\t\t\t private var which will be default constructed\n+\t\t\t\t and optionally initialized with\n+\t\t\t\t OMP_CLAUSE_REDUCTION_GIMPLE_INIT, as in the\n+\t\t\t\t loop we want to assign this value instead of\n+\t\t\t\t constructing and destructing it in each\n+\t\t\t\t iteration.  */\n+\t\t\t      tree nv = create_tmp_var_raw (TREE_TYPE (ivar));\n+\t\t\t      gimple_add_tmp_var (nv);\n+\t\t\t      ctx->cb.decl_map->put (TREE_OPERAND (ivar, 0),\n+\t\t\t\t\t\t     nv);\n+\t\t\t      x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t    (c, nv, build_outer_var_ref (var, ctx));\n+\t\t\t      gimplify_and_add (x, ilist);\n+\n+\t\t\t      if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n+\t\t\t\t{\n+\t\t\t\t  tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\t\t\t  x = DECL_VALUE_EXPR (new_var);\n+\t\t\t\t  SET_DECL_VALUE_EXPR (new_var, nv);\n+\t\t\t\t  lower_omp (&tseq, ctx);\n+\t\t\t\t  SET_DECL_VALUE_EXPR (new_var, x);\n+\t\t\t\t  gimple_seq_add_seq (ilist, tseq);\n+\t\t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\t\t\t}\n+\n+\t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, nv);\n+\t\t\t      if (x)\n+\t\t\t\t{\n+\t\t\t\t  tseq = NULL;\n+\t\t\t\t  dtor = x;\n+\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n+\t\t\t\t  gimple_seq_add_seq (dlist, tseq);\n+\t\t\t\t}\n+\t\t\t    }\n+\n+\t\t\t  tree ref = build_outer_var_ref (var, ctx);\n+\t\t\t  x = unshare_expr (ivar);\n+\t\t\t  x = lang_hooks.decls.omp_clause_assign_op (c, x,\n+\t\t\t\t\t\t\t\t     ref);\n+\t\t\t  gimplify_and_add (x, &llist[0]);\n+\n+\t\t\t  ref = build_outer_var_ref (var, ctx);\n+\t\t\t  x = lang_hooks.decls.omp_clause_assign_op (c, ref,\n+\t\t\t\t\t\t\t\t     rvar);\n+\t\t\t  gimplify_and_add (x, &llist[3]);\n+\n+\t\t\t  DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\t\t  if (new_vard == new_var)\n+\t\t\t    SET_DECL_VALUE_EXPR (new_var, lvar);\n+\t\t\t  else\n+\t\t\t    SET_DECL_VALUE_EXPR (new_vard,\n+\t\t\t\t\t\t build_fold_addr_expr (lvar));\n+\n+\t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n+\t\t\t  if (x)\n+\t\t\t    {\n+\t\t\t      tseq = NULL;\n+\t\t\t      dtor = x;\n+\t\t\t      gimplify_stmt (&dtor, &tseq);\n+\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t    }\n+\n+\t\t\t  tree ivar2 = unshare_expr (lvar);\n+\t\t\t  TREE_OPERAND (ivar2, 1) = sctx.idx;\n+\t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, ivar2);\n+\t\t\t  if (x)\n+\t\t\t    {\n+\t\t\t      tseq = NULL;\n+\t\t\t      dtor = x;\n+\t\t\t      gimplify_stmt (&dtor, &tseq);\n+\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t    }\n+\t\t\t  break;\n+\t\t\t}\n \t\t      if (x)\n \t\t\tgimplify_and_add (x, &llist[0]);\n \t\t      if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n@@ -5240,6 +5361,41 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t : build_outer_var_ref (var, ctx));\n \t\t  if (x)\n \t\t    gimplify_and_add (x, ilist);\n+\n+\t\t  if (rvarp)\n+\t\t    {\n+\t\t      if (x)\n+\t\t\t{\n+\t\t\t  tree nv = create_tmp_var_raw (TREE_TYPE (new_vard));\n+\t\t\t  gimple_add_tmp_var (nv);\n+\t\t\t  ctx->cb.decl_map->put (new_var, nv);\n+\t\t\t  x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t(c, nv, build_outer_var_ref (var, ctx));\n+\t\t\t  gimplify_and_add (x, ilist);\n+\t\t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n+\t\t\t    {\n+\t\t\t      tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\t\t      SET_DECL_VALUE_EXPR (new_var, nv);\n+\t\t\t      DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n+\t\t\t      lower_omp (&tseq, ctx);\n+\t\t\t      SET_DECL_VALUE_EXPR (new_var, NULL_TREE);\n+\t\t\t      DECL_HAS_VALUE_EXPR_P (new_var) = 0;\n+\t\t\t      gimple_seq_add_seq (ilist, tseq);\n+\t\t\t    }\n+\t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, nv);\n+\t\t\t  if (x)\n+\t\t\t    {\n+\t\t\t      tseq = NULL;\n+\t\t\t      dtor = x;\n+\t\t\t      gimplify_stmt (&dtor, &tseq);\n+\t\t\t      gimple_seq_add_seq (dlist, tseq);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\t      goto do_dtor;\n+\t\t    }\n+\n \t\t  if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n \t\t    {\n \t\t      tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n@@ -5324,12 +5480,32 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      new_vard = TREE_OPERAND (new_var, 0);\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n+\t\t  tree rvar = NULL_TREE, *rvarp = NULL;\n+\t\t  if (is_simd\n+\t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n+\t\t    rvarp = &rvar;\n \t\t  if (is_simd\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n-\t\t\t\t\t\t       ivar, lvar))\n+\t\t\t\t\t\t       ivar, lvar, rvarp))\n \t\t    {\n+\t\t      if (new_vard != new_var)\n+\t\t\t{\n+\t\t\t  SET_DECL_VALUE_EXPR (new_vard,\n+\t\t\t\t\t       build_fold_addr_expr (lvar));\n+\t\t\t  DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n+\t\t\t}\n+\n \t\t      tree ref = build_outer_var_ref (var, ctx);\n \n+\t\t      if (rvarp)\n+\t\t\t{\n+\t\t\t  gimplify_assign (ivar, ref, &llist[0]);\n+\t\t\t  ref = build_outer_var_ref (var, ctx);\n+\t\t\t  gimplify_assign (ref, rvar, &llist[3]);\n+\t\t\t  break;\n+\t\t\t}\n+\n \t\t      gimplify_assign (unshare_expr (ivar), x, &llist[0]);\n \n \t\t      if (sctx.is_simt)\n@@ -5346,14 +5522,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      ref = build_outer_var_ref (var, ctx);\n \t\t      gimplify_assign (ref, x, &llist[1]);\n \n-\t\t      if (new_vard != new_var)\n-\t\t\t{\n-\t\t\t  SET_DECL_VALUE_EXPR (new_vard,\n-\t\t\t\t\t       build_fold_addr_expr (lvar));\n-\t\t\t  DECL_HAS_VALUE_EXPR_P (new_vard) = 1;\n-\t\t\t}\n \t\t    }\n-\t\t  else\n+\t\t  else if (rvarp == NULL)\n \t\t    {\n \t\t      if (omp_is_reference (var) && is_simd)\n \t\t\thandle_simd_reference (clause_loc, new_vard, ilist);\n@@ -5456,14 +5626,23 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   if (sctx.lane)\n     {\n       gimple *g = gimple_build_call_internal (IFN_GOMP_SIMD_LANE,\n-\t\t\t\t\t      1 + (nonconst_simd_if != NULL),\n-\t\t\t\t\t      uid, nonconst_simd_if);\n+\t\t\t\t\t      2 + (nonconst_simd_if != NULL),\n+\t\t\t\t\t      uid, integer_zero_node,\n+\t\t\t\t\t      nonconst_simd_if);\n       gimple_call_set_lhs (g, sctx.lane);\n       gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n       gsi_insert_before_without_update (&gsi, g, GSI_SAME_STMT);\n       g = gimple_build_assign (sctx.lane, INTEGER_CST,\n \t\t\t       build_int_cst (unsigned_type_node, 0));\n       gimple_seq_add_stmt (ilist, g);\n+      if (sctx.lastlane)\n+\t{\n+\t  g = gimple_build_call_internal (IFN_GOMP_SIMD_LAST_LANE,\n+\t\t\t\t\t  2, uid, sctx.lane);\n+\t  gimple_call_set_lhs (g, sctx.lastlane);\n+\t  gimple_seq_add_stmt (dlist, g);\n+\t  gimple_seq_add_seq (dlist, llist[3]);\n+\t}\n       /* Emit reductions across SIMT lanes in log_2(simt_vf) steps.  */\n       if (llist[2])\n \t{\n@@ -5865,6 +6044,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \t\t  new_var = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t    TREE_OPERAND (val, 0), lastlane,\n \t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\t  TREE_THIS_NOTRAP (new_var) = 1;\n \t\t}\n \t    }\n \t  else if (maybe_simt)\n@@ -8371,6 +8551,167 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n }\n \n \n+/* Expand code for an OpenMP scan directive and the structured block\n+   before the scan directive.  */\n+\n+static void\n+lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  bool has_clauses\n+    = gimple_omp_scan_clauses (as_a <gomp_scan *> (stmt)) != NULL;\n+  tree lane = NULL_TREE;\n+  gimple_seq before = NULL;\n+  omp_context *octx = ctx->outer;\n+  gcc_assert (octx);\n+  bool input_phase = has_clauses ^ octx->scan_inclusive;\n+  if (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n+      && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD)\n+      && !gimple_omp_for_combined_into_p (octx->stmt)\n+      && octx->scan_inclusive)\n+    {\n+      if (tree c = omp_find_clause (gimple_omp_for_clauses (octx->stmt),\n+\t\t\t\t    OMP_CLAUSE__SIMDUID_))\n+\t{\n+\t  tree uid = OMP_CLAUSE__SIMDUID__DECL (c);\n+\t  lane = create_tmp_var (unsigned_type_node);\n+\t  tree t = build_int_cst (integer_type_node, 1 + !input_phase);\n+\t  gimple *g\n+\t    = gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 2, uid, t);\n+\t  gimple_call_set_lhs (g, lane);\n+\t  gimple_seq_add_stmt (&before, g);\n+\t}\n+      for (tree c = gimple_omp_for_clauses (octx->stmt);\n+\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t    && OMP_CLAUSE_REDUCTION_INSCAN (c))\n+\t  {\n+\t    tree var = OMP_CLAUSE_DECL (c);\n+\t    tree new_var = lookup_decl (var, octx);\n+\t    tree val = new_var;\n+\t    tree var2 = NULL_TREE;\n+\t    tree var3 = NULL_TREE;\n+\t    if (DECL_HAS_VALUE_EXPR_P (new_var))\n+\t      {\n+\t\tval = DECL_VALUE_EXPR (new_var);\n+\t\tif (TREE_CODE (val) == ARRAY_REF\n+\t\t    && VAR_P (TREE_OPERAND (val, 0)))\n+\t\t  {\n+\t\t    tree v = TREE_OPERAND (val, 0);\n+\t\t    if (lookup_attribute (\"omp simd array\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (v)))\n+\t\t      {\n+\t\t\tval = unshare_expr (val);\n+\t\t\tTREE_OPERAND (val, 1) = lane;\n+\t\t\tvar2 = lookup_decl (v, octx);\n+\t\t\tif (input_phase\n+\t\t\t    && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t\t\t  var3 = maybe_lookup_decl (var2, octx);\n+\t\t\tif (!input_phase)\n+\t\t\t  {\n+\t\t\t    var2 = build4 (ARRAY_REF, TREE_TYPE (val),\n+\t\t\t\t\t   var2, lane, NULL_TREE, NULL_TREE);\n+\t\t\t    TREE_THIS_NOTRAP (var2) = 1;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  var2 = val;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tvar2 = build_outer_var_ref (var, octx);\n+\t\tif (input_phase && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t\t  {\n+\t\t    var3 = maybe_lookup_decl (new_var, octx);\n+\t\t    if (var3 == new_var)\n+\t\t      var3 = NULL_TREE;\n+\t\t  }\n+\t      }\n+\t    if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t      {\n+\t\ttree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n+\t\tif (input_phase)\n+\t\t  {\n+\t\t    if (var3)\n+\t\t      {\n+\t\t\t/* If we've added a separate identity element\n+\t\t\t   variable, copy it over into val.  */\n+\t\t\ttree x = lang_hooks.decls.omp_clause_assign_op (c, val,\n+\t\t\t\t\t\t\t\t\tvar3);\n+\t\t\tgimplify_and_add (x, &before);\n+\t\t      }\n+\t\t    else if (OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c))\n+\t\t      {\n+\t\t\t/* Otherwise, assign to it the identity element.  */\n+\t\t\tgimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c);\n+\t\t\ttree x = (DECL_HAS_VALUE_EXPR_P (new_var)\n+\t\t\t\t  ? DECL_VALUE_EXPR (new_var) : NULL_TREE);\n+\t\t\ttree ref = build_outer_var_ref (var, octx);\n+\t\t\tSET_DECL_VALUE_EXPR (new_var, val);\n+\t\t\tSET_DECL_VALUE_EXPR (placeholder, ref);\n+\t\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\t\tlower_omp (&tseq, octx);\n+\t\t\tSET_DECL_VALUE_EXPR (new_var, x);\n+\t\t\tSET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n+\t\t\tDECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\t\tif (x == NULL_TREE)\n+\t\t\t  DECL_HAS_VALUE_EXPR_P (new_var) = 0;\n+\t\t\tgimple_seq_add_seq (&before, tseq);\n+\t\t\tOMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n+\t\t    tree x = (DECL_HAS_VALUE_EXPR_P (new_var)\n+\t\t\t      ? DECL_VALUE_EXPR (new_var) : NULL_TREE);\n+\t\t    SET_DECL_VALUE_EXPR (new_var, val);\n+\t\t    SET_DECL_VALUE_EXPR (placeholder, var2);\n+\t\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 1;\n+\t\t    lower_omp (&tseq, octx);\n+\t\t    gimple_seq_add_seq (&before, tseq);\n+\t\t    OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c) = NULL;\n+\t\t    SET_DECL_VALUE_EXPR (new_var, x);\n+\t\t    SET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n+\t\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n+\t\t    x = lang_hooks.decls.omp_clause_assign_op (c, val, var2);\n+\t\t    gimplify_and_add (x, &before);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (input_phase)\n+\t\t  {\n+\t\t    /* input phase.  Set val to initializer before\n+\t\t       the body.  */\n+\t\t    tree x = omp_reduction_init (c, TREE_TYPE (new_var));\n+\t\t    gimplify_assign (val, x, &before);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* scan phase.  */\n+\t\t    enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t\t    if (code == MINUS_EXPR)\n+\t\t      code = PLUS_EXPR;\n+\n+\t\t    tree x = build2 (code, TREE_TYPE (var2),\n+\t\t\t\t     unshare_expr (var2), unshare_expr (val));\n+\t\t    gimplify_assign (unshare_expr (var2), x, &before);\n+\t\t    gimplify_assign (val, var2, &before);\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+  else if (has_clauses)\n+    sorry_at (gimple_location (stmt),\n+\t      \"%<#pragma omp scan%> not supported yet\");\n+  gsi_insert_seq_after (gsi_p, gimple_omp_body (stmt), GSI_SAME_STMT);\n+  gsi_insert_seq_after (gsi_p, before, GSI_SAME_STMT);\n+  gsi_replace (gsi_p, gimple_build_nop (), true);\n+}\n+\n+\n /* Gimplify a GIMPLE_OMP_CRITICAL statement.  This is a relatively simple\n    substitution of a couple of function calls.  But in the NAMED case,\n    requires that languages coordinate a symbol name.  It is therefore\n@@ -10843,11 +11184,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     case GIMPLE_OMP_SCAN:\n       ctx = maybe_lookup_ctx (stmt);\n       gcc_assert (ctx);\n-      gsi_insert_seq_after (gsi_p, gimple_omp_body (stmt), GSI_SAME_STMT);\n-      if (gimple_omp_scan_clauses (as_a <gomp_scan *> (stmt)))\n-\tsorry_at (gimple_location (stmt),\n-\t\t  \"%<#pragma omp scan%> not supported yet\");\n-      gsi_replace (gsi_p, gimple_build_nop (), true);\n+      lower_omp_scan (gsi_p, ctx);\n       break;\n     case GIMPLE_OMP_CRITICAL:\n       ctx = maybe_lookup_ctx (stmt);"}, {"sha": "27a522e0140a478cb2d025270b2a4ce9c1940551", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -1,3 +1,10 @@\n+2019-06-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/vect/vect-simd-8.c: New test.\n+\t* gcc.dg/vect/vect-simd-9.c: New test.\n+\t* g++.dg/vect/simd-2.cc: New test.\n+\t* g++.dg/gomp/scan-1.C: New test.\n+\n 2019-06-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/62055"}, {"sha": "6fd3320d6560b64cad43467135d21a7e344fec19", "filename": "gcc/testsuite/g++.dg/gomp/scan-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fscan-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fscan-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fscan-1.C?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct S { S (); ~S (); S &operator = (const S &) = delete; int s; };\t// { dg-message \"declared here\" }\n+#pragma omp declare reduction (+ : S : omp_out.s += omp_in.s)\n+\n+S s;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp simd reduction (+: s)\n+  for (int i = 0; i < 64; ++i)\n+    s.s += i;\n+}\n+\n+void\n+bar (int *x)\n+{\n+  #pragma omp simd reduction (inscan, +: s)\t// { dg-error \"use of deleted function\" }\n+  for (int i = 0; i < 64; ++i)\n+    {\n+      s.s += i;\n+      #pragma omp scan inclusive (s)\t\t// { dg-error \"\" }\n+      x[i] = s.s;\n+    }\n+}"}, {"sha": "3160495761ce37dd6ac2f03c2f57ecef18fc915f", "filename": "gcc/testsuite/g++.dg/vect/simd-2.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-2.cc?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -0,0 +1,153 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r.s += a[i].s;\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp simd if (0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s.s += 2 * a[i].s;\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return S (s);\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s.s += 2 * i;\n+      if (b[i].s != s.s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "123a201ce7f90ec3fbc08a620050b7a2ce3d2f79", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-8.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-8.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, +:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "ce5ae57710054302020cc240b19f87a1791bc167", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-9.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-9.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, foo:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      r += a[i];\n+      #pragma omp scan inclusive(r)\n+      b[i] = r;\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, foo:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      s += 2 * a[i];\n+      #pragma omp scan inclusive(s)\n+      b[i] = s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += i;\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      s += 2 * i;\n+      if (b[i] != s)\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "c73fbabfe29107703f8cb1fcd8b49f242db9c474", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -1339,14 +1339,14 @@ eliminate_unnecessary_stmts (void)\n \t\t  update_stmt (stmt);\n \t\t  release_ssa_name (name);\n \n-\t\t  /* GOMP_SIMD_LANE (unless two argument) or ASAN_POISON\n+\t\t  /* GOMP_SIMD_LANE (unless three argument) or ASAN_POISON\n \t\t     without lhs is not needed.  */\n \t\t  if (gimple_call_internal_p (stmt))\n \t\t    switch (gimple_call_internal_fn (stmt))\n \t\t      {\n \t\t      case IFN_GOMP_SIMD_LANE:\n-\t\t\tif (gimple_call_num_args (stmt) >= 2\n-\t\t\t    && !integer_nonzerop (gimple_call_arg (stmt, 1)))\n+\t\t\tif (gimple_call_num_args (stmt) >= 3\n+\t\t\t    && !integer_nonzerop (gimple_call_arg (stmt, 2)))\n \t\t\t  break;\n \t\t\t/* FALLTHRU */\n \t\t      case IFN_ASAN_POISON:"}, {"sha": "f2f0d2317119dc1ba0ad51220e69dca14ffebb2d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -3003,6 +3003,13 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t      || TREE_CODE (DR_INIT (drb)) != INTEGER_CST)\n \t    break;\n \n+\t  /* Different .GOMP_SIMD_LANE calls still give the same lane,\n+\t     just hold extra information.  */\n+\t  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmtinfo_a)\n+\t      && STMT_VINFO_SIMD_LANE_ACCESS_P (stmtinfo_b)\n+\t      && data_ref_compare_tree (DR_INIT (dra), DR_INIT (drb)) == 0)\n+\t    break;\n+\n \t  /* Sorting has ensured that DR_INIT (dra) <= DR_INIT (drb).  */\n \t  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n \t  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n@@ -4101,7 +4108,8 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t\t\t  DR_STEP_ALIGNMENT (newdr)\n \t\t\t    = highest_pow2_factor (step);\n \t\t\t  /* Mark as simd-lane access.  */\n-\t\t\t  newdr->aux = (void *)-1;\n+\t\t\t  tree arg2 = gimple_call_arg (def, 1);\n+\t\t\t  newdr->aux = (void *) (-1 - tree_to_uhwi (arg2));\n \t\t\t  free_data_ref (dr);\n \t\t\t  datarefs->safe_push (newdr);\n \t\t\t  return opt_result::success ();\n@@ -4210,14 +4218,17 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n         }\n \n       /* See if this was detected as SIMD lane access.  */\n-      if (dr->aux == (void *)-1)\n+      if (dr->aux == (void *)-1\n+\t  || dr->aux == (void *)-2\n+\t  || dr->aux == (void *)-3)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n \t    return opt_result::failure_at (stmt_info->stmt,\n \t\t\t\t\t   \"not vectorized:\"\n \t\t\t\t\t   \" data ref analysis failed: %G\",\n \t\t\t\t\t   stmt_info->stmt);\n-\t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n+\t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info)\n+\t    = -(uintptr_t) dr->aux;\n \t}\n \n       tree base = get_base_address (DR_REF (dr));"}, {"sha": "92a7c29d077c078ea0b6f61f7cd1108f897598d8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -824,6 +824,7 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n     peeling_for_alignment (0),\n     ptr_mask (0),\n     ivexpr_map (NULL),\n+    scan_map (NULL),\n     slp_unrolling_factor (1),\n     single_scalar_iteration_cost (0),\n     vectorizable (false),\n@@ -863,21 +864,21 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n \t  gimple *stmt = gsi_stmt (si);\n \t  gimple_set_uid (stmt, 0);\n \t  add_stmt (stmt);\n-\t  /* If .GOMP_SIMD_LANE call for the current loop has 2 arguments, the\n-\t     second argument is the #pragma omp simd if (x) condition, when 0,\n+\t  /* If .GOMP_SIMD_LANE call for the current loop has 3 arguments, the\n+\t     third argument is the #pragma omp simd if (x) condition, when 0,\n \t     loop shouldn't be vectorized, when non-zero constant, it should\n \t     be vectorized normally, otherwise versioned with vectorized loop\n \t     done if the condition is non-zero at runtime.  */\n \t  if (loop_in->simduid\n \t      && is_gimple_call (stmt)\n \t      && gimple_call_internal_p (stmt)\n \t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n-\t      && gimple_call_num_args (stmt) >= 2\n+\t      && gimple_call_num_args (stmt) >= 3\n \t      && TREE_CODE (gimple_call_arg (stmt, 0)) == SSA_NAME\n \t      && (loop_in->simduid\n \t\t  == SSA_NAME_VAR (gimple_call_arg (stmt, 0))))\n \t    {\n-\t      tree arg = gimple_call_arg (stmt, 1);\n+\t      tree arg = gimple_call_arg (stmt, 2);\n \t      if (integer_zerop (arg) || TREE_CODE (arg) == SSA_NAME)\n \t\tsimd_if_cond = arg;\n \t      else\n@@ -959,6 +960,7 @@ _loop_vec_info::~_loop_vec_info ()\n \n   release_vec_loop_masks (&masks);\n   delete ivexpr_map;\n+  delete scan_map;\n \n   loop->aux = NULL;\n }"}, {"sha": "790b49bcb4be1ea324415d27a12e323466653775", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 496, "deletions": 3, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop-niter.h\"\n #include \"gimple-fold.h\"\n #include \"regs.h\"\n+#include \"attribs.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -3257,7 +3258,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   if (nargs == 0 || nargs > 4)\n     return false;\n \n-  /* Ignore the argument of IFN_GOMP_SIMD_LANE, it is magic.  */\n+  /* Ignore the arguments of IFN_GOMP_SIMD_LANE, they are magic.  */\n   combined_fn cfn = gimple_call_combined_fn (stmt);\n   if (cfn == CFN_GOMP_SIMD_LANE)\n     {\n@@ -6320,6 +6321,489 @@ get_group_alias_ptr_type (stmt_vec_info first_stmt_info)\n }\n \n \n+/* Function scan_operand_equal_p.\n+\n+   Helper function for check_scan_store.  Compare two references\n+   with .GOMP_SIMD_LANE bases.  */\n+\n+static bool\n+scan_operand_equal_p (tree ref1, tree ref2)\n+{\n+  machine_mode mode1, mode2;\n+  poly_int64 bitsize1, bitsize2, bitpos1, bitpos2;\n+  tree offset1, offset2;\n+  int unsignedp1, unsignedp2, reversep1, reversep2;\n+  int volatilep1 = 0, volatilep2 = 0;\n+  tree base1 = get_inner_reference (ref1, &bitsize1, &bitpos1, &offset1,\n+\t\t\t\t    &mode1, &unsignedp1, &reversep1,\n+\t\t\t\t    &volatilep1);\n+  tree base2 = get_inner_reference (ref2, &bitsize2, &bitpos2, &offset2,\n+\t\t\t\t    &mode2, &unsignedp2, &reversep2,\n+\t\t\t\t    &volatilep2);\n+  if (reversep1 || reversep2 || volatilep1 || volatilep2)\n+    return false;\n+  if (!operand_equal_p (base1, base2, 0))\n+    return false;\n+  if (maybe_ne (bitpos1, 0) || maybe_ne (bitpos2, 0))\n+    return false;\n+  if (maybe_ne (bitsize1, bitsize2))\n+    return false;\n+  if (!operand_equal_p (offset1, offset2, 0))\n+    return false;\n+  return true;\n+}\n+\n+\n+/* Function check_scan_store.\n+\n+   Check magic stores for #pragma omp scan {in,ex}clusive reductions.  */\n+\n+static bool\n+check_scan_store (stmt_vec_info stmt_info, tree vectype,\n+\t\t  enum vect_def_type rhs_dt, bool slp, tree mask,\n+\t\t  vect_memory_access_type memory_access_type)\n+{\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n+  tree ref_type;\n+\n+  gcc_assert (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) > 1);\n+  if (slp\n+      || mask\n+      || memory_access_type != VMAT_CONTIGUOUS\n+      || TREE_CODE (DR_BASE_ADDRESS (dr_info->dr)) != ADDR_EXPR\n+      || !VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0))\n+      || loop_vinfo == NULL\n+      || LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+      || STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      || !integer_zerop (DR_OFFSET (dr_info->dr))\n+      || !integer_zerop (DR_INIT (dr_info->dr))\n+      || !(ref_type = reference_alias_ptr_type (DR_REF (dr_info->dr)))\n+      || !alias_sets_conflict_p (get_alias_set (vectype),\n+\t\t\t\t get_alias_set (TREE_TYPE (ref_type))))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"unsupported OpenMP scan store.\\n\");\n+      return false;\n+    }\n+\n+  /* We need to pattern match code built by OpenMP lowering and simplified\n+     by following optimizations into something we can handle.\n+     #pragma omp simd reduction(inscan,+:r)\n+     for (...)\n+       {\n+\t r += something ();\n+\t #pragma omp scan inclusive (r)\n+\t use (r);\n+       }\n+     shall have body with:\n+       // Initialization for input phase, store the reduction initializer:\n+       _20 = .GOMP_SIMD_LANE (simduid.3_14(D), 0);\n+       _21 = .GOMP_SIMD_LANE (simduid.3_14(D), 1);\n+       D.2042[_21] = 0;\n+       // Actual input phase:\n+       ...\n+       r.0_5 = D.2042[_20];\n+       _6 = _4 + r.0_5;\n+       D.2042[_20] = _6;\n+       // Initialization for scan phase:\n+       _25 = .GOMP_SIMD_LANE (simduid.3_14(D), 2);\n+       _26 = D.2043[_25];\n+       _27 = D.2042[_25];\n+       _28 = _26 + _27;\n+       D.2043[_25] = _28;\n+       D.2042[_25] = _28;\n+       // Actual scan phase:\n+       ...\n+       r.1_8 = D.2042[_20];\n+       ...\n+     The \"omp simd array\" variable D.2042 holds the privatized copy used\n+     inside of the loop and D.2043 is another one that holds copies of\n+     the current original list item.  The separate GOMP_SIMD_LANE ifn\n+     kinds are there in order to allow optimizing the initializer store\n+     and combiner sequence, e.g. if it is originally some C++ish user\n+     defined reduction, but allow the vectorizer to pattern recognize it\n+     and turn into the appropriate vectorized scan.  */\n+\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 2)\n+    {\n+      /* Match the D.2042[_21] = 0; store above.  Just require that\n+\t it is a constant or external definition store.  */\n+      if (rhs_dt != vect_constant_def && rhs_dt != vect_external_def)\n+\t{\n+\t fail_init:\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"unsupported OpenMP scan initializer store.\\n\");\n+\t  return false;\n+\t}\n+\n+      if (! loop_vinfo->scan_map)\n+\tloop_vinfo->scan_map = new hash_map<tree, tree>;\n+      tree var = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n+      tree &cached = loop_vinfo->scan_map->get_or_insert (var);\n+      if (cached)\n+\tgoto fail_init;\n+      cached = gimple_assign_rhs1 (STMT_VINFO_STMT (stmt_info));\n+\n+      /* These stores can be vectorized normally.  */\n+      return true;\n+    }\n+\n+  if (rhs_dt != vect_internal_def)\n+    {\n+     fail:\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"unsupported OpenMP scan combiner pattern.\\n\");\n+      return false;\n+    }\n+\n+  gimple *stmt = STMT_VINFO_STMT (stmt_info);\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (rhs) != SSA_NAME)\n+    goto fail;\n+\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+  gimple *other_store_stmt = NULL;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, rhs)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p);\n+      if (use_stmt == stmt || is_gimple_debug (use_stmt))\n+\tcontinue;\n+      if (gimple_bb (use_stmt) != gimple_bb (stmt)\n+\t  || !gimple_store_p (use_stmt)\n+\t  || other_store_stmt)\n+\tgoto fail;\n+      other_store_stmt = use_stmt;\n+    }\n+  if (other_store_stmt == NULL)\n+    goto fail;\n+  stmt_vec_info other_store_stmt_info\n+    = loop_vinfo->lookup_stmt (other_store_stmt);\n+  if (other_store_stmt_info == NULL\n+      || STMT_VINFO_SIMD_LANE_ACCESS_P (other_store_stmt_info) != 3)\n+    goto fail;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n+  if (gimple_bb (def_stmt) != gimple_bb (stmt)\n+      || !is_gimple_assign (def_stmt)\n+      || gimple_assign_rhs_class (def_stmt) != GIMPLE_BINARY_RHS)\n+    goto fail;\n+\n+  enum tree_code code = gimple_assign_rhs_code (def_stmt);\n+  /* For pointer addition, we should use the normal plus for the vector\n+     operation.  */\n+  switch (code)\n+    {\n+    case POINTER_PLUS_EXPR:\n+      code = PLUS_EXPR;\n+      break;\n+    case MULT_HIGHPART_EXPR:\n+      goto fail;\n+    default:\n+      break;\n+    }\n+  if (TREE_CODE_LENGTH (code) != binary_op || !commutative_tree_code (code))\n+    goto fail;\n+\n+  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+  tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+  if (TREE_CODE (rhs1) != SSA_NAME\n+      || TREE_CODE (rhs2) != SSA_NAME)\n+    goto fail;\n+\n+  gimple *load1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+  gimple *load2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+  if (gimple_bb (load1_stmt) != gimple_bb (stmt)\n+      || !gimple_assign_load_p (load1_stmt)\n+      || gimple_bb (load2_stmt) != gimple_bb (stmt)\n+      || !gimple_assign_load_p (load2_stmt))\n+    goto fail;\n+\n+  stmt_vec_info load1_stmt_info = loop_vinfo->lookup_stmt (load1_stmt);\n+  stmt_vec_info load2_stmt_info = loop_vinfo->lookup_stmt (load2_stmt);\n+  if (load1_stmt_info == NULL\n+      || load2_stmt_info == NULL\n+      || STMT_VINFO_SIMD_LANE_ACCESS_P (load1_stmt_info) != 3\n+      || STMT_VINFO_SIMD_LANE_ACCESS_P (load2_stmt_info) != 3)\n+    goto fail;\n+\n+  if (scan_operand_equal_p (gimple_assign_lhs (stmt),\n+\t\t\t    gimple_assign_rhs1 (load2_stmt)))\n+    {\n+      std::swap (rhs1, rhs2);\n+      std::swap (load1_stmt, load2_stmt);\n+      std::swap (load1_stmt_info, load2_stmt_info);\n+    }\n+  if (!scan_operand_equal_p (gimple_assign_lhs (stmt),\n+\t\t\t     gimple_assign_rhs1 (load1_stmt))\n+      || !scan_operand_equal_p (gimple_assign_lhs (other_store_stmt),\n+\t\t\t\tgimple_assign_rhs1 (load2_stmt)))\n+    goto fail;\n+\n+  dr_vec_info *other_dr_info = STMT_VINFO_DR_INFO (other_store_stmt_info);\n+  if (TREE_CODE (DR_BASE_ADDRESS (other_dr_info->dr)) != ADDR_EXPR\n+      || !VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (other_dr_info->dr), 0)))\n+    goto fail;\n+\n+  tree var1 = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n+  tree var2 = TREE_OPERAND (DR_BASE_ADDRESS (other_dr_info->dr), 0);\n+  if (!lookup_attribute (\"omp simd array\", DECL_ATTRIBUTES (var1))\n+      || !lookup_attribute (\"omp simd array\", DECL_ATTRIBUTES (var2))\n+      || (!lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var1)))\n+\t == (!lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var2))))\n+    goto fail;\n+\n+  if (lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var1)))\n+    std::swap (var1, var2);\n+\n+  if (loop_vinfo->scan_map == NULL)\n+    goto fail;\n+  tree *init = loop_vinfo->scan_map->get (var1);\n+  if (init == NULL)\n+    goto fail;\n+\n+  /* The IL is as expected, now check if we can actually vectorize it.\n+       _26 = D.2043[_25];\n+       _27 = D.2042[_25];\n+       _28 = _26 + _27;\n+       D.2043[_25] = _28;\n+       D.2042[_25] = _28;\n+     should be vectorized as (where _40 is the vectorized rhs\n+     from the D.2042[_21] = 0; store):\n+       _30 = MEM <vector(8) int> [(int *)&D.2043];\n+       _31 = MEM <vector(8) int> [(int *)&D.2042];\n+       _32 = VEC_PERM_EXPR <_31, _40, { 8, 0, 1, 2, 3, 4, 5, 6 }>;\n+       _33 = _31 + _32;\n+       // _33 = { _31[0], _31[0]+_31[1], _31[1]+_31[2], ..., _31[6]+_31[7] };\n+       _34 = VEC_PERM_EXPR <_33, _40, { 8, 9, 0, 1, 2, 3, 4, 5 }>;\n+       _35 = _33 + _34;\n+       // _35 = { _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n+       //         _31[1]+.._31[4], ... _31[4]+.._31[7] };\n+       _36 = VEC_PERM_EXPR <_35, _40, { 8, 9, 10, 11, 0, 1, 2, 3 }>;\n+       _37 = _35 + _36;\n+       // _37 = { _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n+       //         _31[0]+.._31[4], ... _31[0]+.._31[7] };\n+       _38 = _30 + _37;\n+       _39 = VEC_PERM_EXPR <_38, _38, { 7, 7, 7, 7, 7, 7, 7, 7 }>;\n+       MEM <vector(8) int> [(int *)&D.2043] = _39;\n+       MEM <vector(8) int> [(int *)&D.2042] = _38;  */\n+  enum machine_mode vec_mode = TYPE_MODE (vectype);\n+  optab optab = optab_for_tree_code (code, vectype, optab_default);\n+  if (!optab || optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n+    goto fail;\n+\n+  unsigned HOST_WIDE_INT nunits;\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n+    goto fail;\n+  int units_log2 = exact_log2 (nunits);\n+  if (units_log2 <= 0)\n+    goto fail;\n+\n+  for (int i = 0; i <= units_log2; ++i)\n+    {\n+      unsigned HOST_WIDE_INT j, k;\n+      vec_perm_builder sel (nunits, nunits, 1);\n+      sel.quick_grow (nunits);\n+      if (i == units_log2)\n+\t{\n+\t  for (j = 0; j < nunits; ++j)\n+\t    sel[j] = nunits - 1;\n+\t}\n+      else\n+\t{\n+\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n+\t    sel[j] = nunits + j;\n+\t  for (k = 0; j < nunits; ++j, ++k)\n+\t    sel[j] = k;\n+\t}\n+      vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n+      if (!can_vec_perm_const_p (vec_mode, indices))\n+\tgoto fail;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Function vectorizable_scan_store.\n+\n+   Helper of vectorizable_score, arguments like on vectorizable_store.\n+   Handle only the transformation, checking is done in check_scan_store.  */\n+\n+static bool\n+vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n+\t\t\t stmt_vec_info *vec_stmt, int ncopies)\n+{\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n+  tree ref_type = reference_alias_ptr_type (DR_REF (dr_info->dr));\n+  vec_info *vinfo = stmt_info->vinfo;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"transform scan store. ncopies = %d\\n\", ncopies);\n+\n+  gimple *stmt = STMT_VINFO_STMT (stmt_info);\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  gcc_assert (TREE_CODE (rhs) == SSA_NAME);\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n+  enum tree_code code = gimple_assign_rhs_code (def_stmt);\n+  if (code == POINTER_PLUS_EXPR)\n+    code = PLUS_EXPR;\n+  gcc_assert (TREE_CODE_LENGTH (code) == binary_op\n+\t      && commutative_tree_code (code));\n+  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+  tree rhs2 = gimple_assign_rhs2 (def_stmt);\n+  gcc_assert (TREE_CODE (rhs1) == SSA_NAME && TREE_CODE (rhs2) == SSA_NAME);\n+  gimple *load1_stmt = SSA_NAME_DEF_STMT (rhs1);\n+  gimple *load2_stmt = SSA_NAME_DEF_STMT (rhs2);\n+  stmt_vec_info load1_stmt_info = loop_vinfo->lookup_stmt (load1_stmt);\n+  stmt_vec_info load2_stmt_info = loop_vinfo->lookup_stmt (load2_stmt);\n+  dr_vec_info *load1_dr_info = STMT_VINFO_DR_INFO (load1_stmt_info);\n+  dr_vec_info *load2_dr_info = STMT_VINFO_DR_INFO (load2_stmt_info);\n+  tree var1 = TREE_OPERAND (DR_BASE_ADDRESS (load1_dr_info->dr), 0);\n+  tree var2 = TREE_OPERAND (DR_BASE_ADDRESS (load2_dr_info->dr), 0);\n+\n+  if (lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var1)))\n+    {\n+      std::swap (rhs1, rhs2);\n+      std::swap (var1, var2);\n+    }\n+\n+  tree *init = loop_vinfo->scan_map->get (var1);\n+  gcc_assert (init);\n+\n+  tree var = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n+  bool inscan_var_store\n+    = lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var)) != NULL;\n+\n+  unsigned HOST_WIDE_INT nunits;\n+  if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n+    gcc_unreachable ();\n+  int units_log2 = exact_log2 (nunits);\n+  gcc_assert (units_log2 > 0);\n+  auto_vec<tree, 16> perms;\n+  perms.quick_grow (units_log2 + 1);\n+  for (int i = 0; i <= units_log2; ++i)\n+    {\n+      unsigned HOST_WIDE_INT j, k;\n+      vec_perm_builder sel (nunits, nunits, 1);\n+      sel.quick_grow (nunits);\n+      if (i == units_log2)\n+\t{\n+\t  for (j = 0; j < nunits; ++j)\n+\t    sel[j] = nunits - 1;\n+\t}\n+      else\n+\t{\n+\t  for (j = 0; j < (HOST_WIDE_INT_1U << i); ++j)\n+\t    sel[j] = nunits + j;\n+\t  for (k = 0; j < nunits; ++j, ++k)\n+\t    sel[j] = k;\n+\t}\n+      vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n+      perms[i] = vect_gen_perm_mask_checked (vectype, indices);\n+    }\n+\n+  stmt_vec_info prev_stmt_info = NULL;\n+  tree vec_oprnd1 = NULL_TREE;\n+  tree vec_oprnd2 = NULL_TREE;\n+  tree vec_oprnd3 = NULL_TREE;\n+  tree dataref_ptr = unshare_expr (DR_BASE_ADDRESS (dr_info->dr));\n+  tree dataref_offset = build_int_cst (ref_type, 0);\n+  tree bump = vect_get_data_ptr_increment (dr_info, vectype, VMAT_CONTIGUOUS);\n+  tree orig = NULL_TREE;\n+  for (int j = 0; j < ncopies; j++)\n+    {\n+      stmt_vec_info new_stmt_info;\n+      if (j == 0)\n+\t{\n+\t  vec_oprnd1 = vect_get_vec_def_for_operand (*init, stmt_info);\n+\t  vec_oprnd2 = vect_get_vec_def_for_operand (rhs1, stmt_info);\n+\t  vec_oprnd3 = vect_get_vec_def_for_operand (rhs2, stmt_info);\n+\t  orig = vec_oprnd3;\n+\t}\n+      else\n+\t{\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n+\t  vec_oprnd2 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd2);\n+\t  vec_oprnd3 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd3);\n+\t  if (!inscan_var_store)\n+\t    dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n+\t}\n+\n+      tree v = vec_oprnd2;\n+      for (int i = 0; i < units_log2; ++i)\n+\t{\n+\t  tree new_temp = make_ssa_name (vectype);\n+\t  gimple *g = gimple_build_assign (new_temp, VEC_PERM_EXPR, v,\n+\t\t\t\t\t   vec_oprnd1, perms[i]);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t  if (prev_stmt_info == NULL)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\n+\t  tree new_temp2 = make_ssa_name (vectype);\n+\t  g = gimple_build_assign (new_temp2, code, v, new_temp);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\n+\t  v = new_temp2;\n+\t}\n+\n+      tree new_temp = make_ssa_name (vectype);\n+      gimple *g = gimple_build_assign (new_temp, code, orig, v);\n+      new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+      prev_stmt_info = new_stmt_info;\n+\n+      orig = make_ssa_name (vectype);\n+      g = gimple_build_assign (orig, VEC_PERM_EXPR, new_temp, new_temp,\n+\t\t\t       perms[units_log2]);\n+      new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+      prev_stmt_info = new_stmt_info;\n+\n+      if (!inscan_var_store)\n+\t{\n+\t  tree data_ref = fold_build2 (MEM_REF, vectype, dataref_ptr,\n+\t\t\t\t       dataref_offset);\n+\t  vect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n+\t  g = gimple_build_assign (data_ref, new_temp);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\t}\n+    }\n+\n+  if (inscan_var_store)\n+    for (int j = 0; j < ncopies; j++)\n+      {\n+\tif (j != 0)\n+\t  dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n+\n+\ttree data_ref = fold_build2 (MEM_REF, vectype, dataref_ptr,\n+\t\t\t\t     dataref_offset);\n+\tvect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n+\tgimple *g = gimple_build_assign (data_ref, orig);\n+\tstmt_vec_info new_stmt_info\n+\t  = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\tprev_stmt_info = new_stmt_info;\n+      }\n+  return true;\n+}\n+\n+\n /* Function vectorizable_store.\n \n    Check if STMT_INFO defines a non scalar data-ref (array/pointer/structure)\n@@ -6514,6 +6998,13 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       group_size = vec_num = 1;\n     }\n \n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) > 1 && !vec_stmt)\n+    {\n+      if (!check_scan_store (stmt_info, vectype, rhs_dt, slp, mask,\n+\t\t\t     memory_access_type))\n+\treturn false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n@@ -6737,6 +7228,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t}\n       return true;\n     }\n+  else if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 3)\n+    return vectorizable_scan_store (stmt_info, gsi, vec_stmt, ncopies);\n \n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     DR_GROUP_STORE_COUNT (DR_GROUP_FIRST_ELEMENT (stmt_info))++;\n@@ -7162,7 +7655,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  gcc_assert (useless_type_conversion_p (vectype,\n \t\t\t\t\t\t TREE_TYPE (vec_oprnd)));\n \t  bool simd_lane_access_p\n-\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info);\n+\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) != 0;\n \t  if (simd_lane_access_p\n \t      && !loop_masks\n \t      && TREE_CODE (DR_BASE_ADDRESS (first_dr_info->dr)) == ADDR_EXPR\n@@ -8347,7 +8840,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (j == 0)\n \t{\n \t  bool simd_lane_access_p\n-\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info);\n+\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) != 0;\n \t  if (simd_lane_access_p\n \t      && TREE_CODE (DR_BASE_ADDRESS (first_dr_info->dr)) == ADDR_EXPR\n \t      && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (first_dr_info->dr), 0))"}, {"sha": "df828ff0a40fbf7db2fbb4f02fd984f1a1ea4183", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0356aab806921fe5d766d3fc74cf49dffc271d18/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0356aab806921fe5d766d3fc74cf49dffc271d18", "patch": "@@ -491,6 +491,10 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Map of IV base/step expressions to inserted name in the preheader.  */\n   hash_map<tree_operand_hash, tree> *ivexpr_map;\n \n+  /* Map of OpenMP \"omp simd array\" scan variables to corresponding\n+     rhs of the store of the initializer.  */\n+  hash_map<tree, tree> *scan_map;\n+\n   /* The unrolling factor needed to SLP the loop. In case of that pure SLP is\n      applied to the loop, i.e., no unrolling is needed, this is 1.  */\n   poly_uint64 slp_unrolling_factor;\n@@ -913,7 +917,7 @@ struct _stmt_vec_info {\n   bool strided_p;\n \n   /* For both loads and stores.  */\n-  bool simd_lane_access_p;\n+  unsigned simd_lane_access_p : 2;\n \n   /* Classifies how the load or store is going to be implemented\n      for loop vectorization.  */"}]}