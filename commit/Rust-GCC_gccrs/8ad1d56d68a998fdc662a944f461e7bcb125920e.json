{"sha": "8ad1d56d68a998fdc662a944f461e7bcb125920e", "node_id": "C_kwDOANBUbNoAKDhhZDFkNTZkNjhhOTk4ZmRjNjYyYTk0NGY0NjFlN2JjYjEyNTkyMGU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T11:44:20Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add declarations for Rust HIR\n\nThis patch contains the declarations needed for our second intermediate\nrepresentation, which we will refer to as an HIR.\n\nThis gives the front-end a chance to desugar much of the AST, such as:\n- Removing distinction between functions and methods\n- Removing Macros\n- Removing IdentifierExprs\n- Removing duplicate attribute structures\n\n\tgcc/rust/\n\t* hir/tree/rust-hir-expr.h: New.\n\t* hir/tree/rust-hir-item.h: New.\n\t* hir/tree/rust-hir-path.h: New.\n\t* hir/tree/rust-hir-pattern.h: New.\n\t* hir/tree/rust-hir-stmt.h: New.\n\t* hir/tree/rust-hir-type.h: New.", "tree": {"sha": "1b63caef7fb0d557c9aa64c9783202f26646e5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b63caef7fb0d557c9aa64c9783202f26646e5c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad1d56d68a998fdc662a944f461e7bcb125920e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad1d56d68a998fdc662a944f461e7bcb125920e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad1d56d68a998fdc662a944f461e7bcb125920e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad1d56d68a998fdc662a944f461e7bcb125920e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85a8fe00f805e7889b4e67a98ae1d435c042166b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a8fe00f805e7889b4e67a98ae1d435c042166b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a8fe00f805e7889b4e67a98ae1d435c042166b"}], "stats": {"total": 10903, "additions": 10903, "deletions": 0}, "files": [{"sha": "832785296460661714d4d1d3565a433440bd4682", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "added", "additions": 4194, "deletions": 0, "changes": 4194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e"}, {"sha": "394b04f6c7fa53ddfcf22ac11e20000892857c5e", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "added", "additions": 3207, "deletions": 0, "changes": 3207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e"}, {"sha": "03cf5f5d2e89c2c9d9880ae32b507cf06aff93b2", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e", "patch": "@@ -0,0 +1,1013 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_H\n+#define RUST_HIR_PATH_H\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// The \"identifier\" (not generic args) aspect of each path expression segment\n+class PathIdentSegment\n+{\n+  std::string segment_name;\n+\n+  // TODO: should this have location info stored?\n+\n+  // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n+public:\n+  PathIdentSegment (std::string segment_name)\n+    : segment_name (std::move (segment_name))\n+  {}\n+\n+  /* TODO: insert check in constructor for this? Or is this a semantic error\n+   * best handled then? */\n+\n+  /* TODO: does this require visitor? pretty sure this isn't polymorphic, but\n+   * not entirely sure */\n+\n+  // Creates an error PathIdentSegment.\n+  static PathIdentSegment create_error () { return PathIdentSegment (\"\"); }\n+\n+  // Returns whether PathIdentSegment is in an error state.\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  std::string as_string () const { return segment_name; }\n+};\n+\n+// A binding of an identifier to a type used in generic arguments in paths\n+struct GenericArgsBinding\n+{\n+private:\n+  Identifier identifier;\n+  std::unique_ptr<Type> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether binding is in an error state.\n+  bool is_error () const\n+  {\n+    return type == nullptr;\n+    // and also identifier is empty, but cheaper computation\n+  }\n+\n+  // Creates an error state generic args binding.\n+  static GenericArgsBinding create_error ()\n+  {\n+    return GenericArgsBinding (\"\", nullptr);\n+  }\n+\n+  // Pointer type for type in constructor to enable polymorphism\n+  GenericArgsBinding (Identifier ident, std::unique_ptr<Type> type_ptr,\n+\t\t      Location locus = Location ())\n+    : identifier (std::move (ident)), type (std::move (type_ptr)), locus (locus)\n+  {}\n+\n+  // Copy constructor has to deep copy the type as it is a unique pointer\n+  GenericArgsBinding (GenericArgsBinding const &other)\n+    : identifier (other.identifier), type (other.type->clone_type ()),\n+      locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~GenericArgsBinding () = default;\n+\n+  // Overload assignment operator to deep copy the pointed-to type\n+  GenericArgsBinding &operator= (GenericArgsBinding const &other)\n+  {\n+    identifier = other.identifier;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgsBinding (GenericArgsBinding &&other) = default;\n+  GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  Identifier get_identifier () const { return identifier; }\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+class ConstGenericArg\n+{\n+  // FIXME: Do we need to disambiguate or no? We should be able to disambiguate\n+  // at name-resolution, hence no need for ambiguities here\n+\n+public:\n+  ConstGenericArg (std::unique_ptr<Expr> expression, Location locus)\n+    : expression (std::move (expression)), locus (locus)\n+  {}\n+\n+  ConstGenericArg (const ConstGenericArg &other) : locus (other.locus)\n+  {\n+    expression = other.expression->clone_expr ();\n+  }\n+\n+  ConstGenericArg operator= (const ConstGenericArg &other)\n+  {\n+    expression = other.expression->clone_expr ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+private:\n+  std::unique_ptr<Expr> expression;\n+  Location locus;\n+};\n+\n+// Generic arguments allowed in each path expression segment - inline?\n+struct GenericArgs\n+{\n+  std::vector<Lifetime> lifetime_args;\n+  std::vector<std::unique_ptr<Type> > type_args;\n+  std::vector<GenericArgsBinding> binding_args;\n+  std::vector<ConstGenericArg> const_args;\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const\n+  {\n+    return !(lifetime_args.empty () && type_args.empty ()\n+\t     && binding_args.empty ());\n+  }\n+\n+  GenericArgs (std::vector<Lifetime> lifetime_args,\n+\t       std::vector<std::unique_ptr<Type> > type_args,\n+\t       std::vector<GenericArgsBinding> binding_args,\n+\t       std::vector<ConstGenericArg> const_args, Location locus)\n+    : lifetime_args (std::move (lifetime_args)),\n+      type_args (std::move (type_args)),\n+      binding_args (std::move (binding_args)),\n+      const_args (std::move (const_args)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  GenericArgs (GenericArgs const &other)\n+    : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n+      const_args (other.const_args), locus (other.locus)\n+  {\n+    type_args.reserve (other.type_args.size ());\n+\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+  }\n+\n+  ~GenericArgs () = default;\n+\n+  // overloaded assignment operator to vector clone\n+  GenericArgs &operator= (GenericArgs const &other)\n+  {\n+    lifetime_args = other.lifetime_args;\n+    binding_args = other.binding_args;\n+    const_args = other.const_args;\n+    locus = other.locus;\n+\n+    type_args.reserve (other.type_args.size ());\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgs (GenericArgs &&other) = default;\n+  GenericArgs &operator= (GenericArgs &&other) = default;\n+\n+  // Creates an empty GenericArgs (no arguments)\n+  static GenericArgs create_empty (Location locus = Location ())\n+  {\n+    return GenericArgs ({}, {}, {}, {}, locus);\n+  }\n+\n+  bool is_empty () const\n+  {\n+    return lifetime_args.size () == 0 && type_args.size () == 0\n+\t   && binding_args.size () == 0;\n+  }\n+\n+  std::string as_string () const;\n+\n+  std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; }\n+\n+  std::vector<std::unique_ptr<Type> > &get_type_args () { return type_args; }\n+\n+  std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n+\n+  std::vector<ConstGenericArg> &get_const_args () { return const_args; }\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* A segment of a path in expression, including an identifier aspect and maybe\n+ * generic args */\n+class PathExprSegment\n+{\n+private:\n+  Analysis::NodeMapping mappings;\n+  PathIdentSegment segment_name;\n+  GenericArgs generic_args;\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  // Constructor for segment (from IdentSegment and GenericArgs)\n+  PathExprSegment (Analysis::NodeMapping mappings,\n+\t\t   PathIdentSegment segment_name, Location locus = Location (),\n+\t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n+    : mappings (std::move (mappings)), segment_name (std::move (segment_name)),\n+      generic_args (std::move (generic_args)), locus (locus)\n+  {}\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  PathIdentSegment get_segment () const { return segment_name; }\n+\n+  GenericArgs &get_generic_args () { return generic_args; }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+};\n+\n+// HIR node representing a pattern that involves a \"path\" - abstract base class\n+class PathPattern : public Pattern\n+{\n+  std::vector<PathExprSegment> segments;\n+\n+protected:\n+  PathPattern (std::vector<PathExprSegment> segments)\n+    : segments (std::move (segments))\n+  {}\n+\n+  // Returns whether path has segments.\n+  bool has_segments () const { return !segments.empty (); }\n+\n+  /* Converts path segments to their equivalent SimplePath segments if possible,\n+   * and creates a SimplePath from them. */\n+  AST::SimplePath\n+  convert_to_simple_path (bool with_opening_scope_resolution) const;\n+\n+public:\n+  /* Returns whether the path is a single segment (excluding qualified path\n+   * initial as segment). */\n+  bool is_single_segment () const { return segments.size () == 1; }\n+\n+  std::string as_string () const override;\n+\n+  void iterate_path_segments (std::function<bool (PathExprSegment &)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  std::vector<PathExprSegment> &get_segments () { return segments; }\n+\n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+\n+  PathExprSegment &get_root_seg () { return segments.at (0); }\n+\n+  PathExprSegment get_final_segment () const { return segments.back (); }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::PATH;\n+  }\n+};\n+\n+/* HIR node representing a path-in-expression pattern (path that allows generic\n+ * arguments) */\n+class PathInExpression : public PathPattern, public PathExpr\n+{\n+  bool has_opening_scope_resolution;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  PathInExpression (Analysis::NodeMapping mappings,\n+\t\t    std::vector<PathExprSegment> path_segments,\n+\t\t    Location locus = Location (),\n+\t\t    bool has_opening_scope_resolution = false,\n+\t\t    std::vector<AST::Attribute> outer_attrs\n+\t\t    = std::vector<AST::Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+  {}\n+\n+  // Creates an error state path in expression.\n+  static PathInExpression create_error ()\n+  {\n+    return PathInExpression (Analysis::NodeMapping::get_error (),\n+\t\t\t     std::vector<PathExprSegment> ());\n+  }\n+\n+  // Returns whether path in expression is in an error state.\n+  bool is_error () const { return !has_segments (); }\n+\n+  /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  AST::SimplePath as_simple_path () const\n+  {\n+    /* delegate to parent class as can't access segments. however,\n+     * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n+     * so the method in the parent class should be protected, not public. Have\n+     * to pass in opening scope resolution as parent class has no access to it.\n+     */\n+    return convert_to_simple_path (has_opening_scope_resolution);\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRExpressionVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+  bool is_self () const\n+  {\n+    if (!is_single_segment ())\n+      return false;\n+\n+    return get_final_segment ().get_segment ().as_string ().compare (\"self\")\n+\t   == 0;\n+  }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return get_mappings ();\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_pattern_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+};\n+\n+/* Base class for segments used in type paths - not abstract (represents an\n+ * ident-only segment) */\n+class TypePathSegment\n+{\n+public:\n+  enum SegmentType\n+  {\n+    REG,\n+    GENERIC,\n+    FUNCTION\n+  };\n+\n+private:\n+  Analysis::NodeMapping mappings;\n+  PathIdentSegment ident_segment;\n+  Location locus;\n+\n+protected:\n+  bool has_separating_scope_resolution;\n+  SegmentType type;\n+\n+  // Clone function implementation - not pure virtual as overrided by subclasses\n+  virtual TypePathSegment *clone_type_path_segment_impl () const\n+  {\n+    return new TypePathSegment (*this);\n+  }\n+\n+public:\n+  virtual ~TypePathSegment () {}\n+\n+  virtual SegmentType get_type () const { return SegmentType::REG; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  {\n+    return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+  }\n+\n+  TypePathSegment (Analysis::NodeMapping mappings,\n+\t\t   PathIdentSegment ident_segment,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : mappings (std::move (mappings)),\n+      ident_segment (std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      type (SegmentType::REG)\n+  {}\n+\n+  TypePathSegment (Analysis::NodeMapping mappings, std::string segment_name,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : mappings (std::move (mappings)),\n+      ident_segment (PathIdentSegment (std::move (segment_name))),\n+      locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      type (SegmentType::REG)\n+  {}\n+\n+  virtual std::string as_string () const { return ident_segment.as_string (); }\n+\n+  /* Returns whether the type path segment is in an error state. May be virtual\n+   * in future. */\n+  bool is_error () const { return ident_segment.is_error (); }\n+\n+  /* Returns whether segment is identifier only (as opposed to generic args or\n+   * function). Overriden in derived classes with other segments. */\n+  virtual bool is_ident_only () const { return true; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // not pure virtual as class not abstract\n+  virtual void accept_vis (HIRFullVisitor &vis);\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+  const PathIdentSegment &get_ident_segment () const { return ident_segment; }\n+\n+  bool is_generic_segment () const\n+  {\n+    return get_type () == SegmentType::GENERIC;\n+  }\n+};\n+\n+// Segment used in type path with generic args\n+class TypePathSegmentGeneric : public TypePathSegment\n+{\n+  GenericArgs generic_args;\n+\n+public:\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  // Constructor with PathIdentSegment and GenericArgs\n+  TypePathSegmentGeneric (Analysis::NodeMapping mappings,\n+\t\t\t  PathIdentSegment ident_segment,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  GenericArgs generic_args, Location locus)\n+    : TypePathSegment (std::move (mappings), std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (std::move (generic_args))\n+  {}\n+\n+  // Constructor from segment name and all args\n+  TypePathSegmentGeneric (Analysis::NodeMapping mappings,\n+\t\t\t  std::string segment_name,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  std::vector<Lifetime> lifetime_args,\n+\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n+\t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  std::vector<ConstGenericArg> const_args,\n+\t\t\t  Location locus)\n+    : TypePathSegment (std::move (mappings), std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (\n+\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t     std::move (binding_args), std::move (const_args), locus))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  GenericArgs &get_generic_args () { return generic_args; }\n+\n+  virtual SegmentType get_type () const override final\n+  {\n+    return SegmentType::GENERIC;\n+  }\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentGeneric (*this);\n+  }\n+};\n+\n+// A function as represented in a type path\n+struct TypePathFunction\n+{\n+private:\n+  // TODO: remove\n+  /*bool has_inputs;\n+  TypePathFnInputs inputs;*/\n+  // inlined from TypePathFnInputs\n+  std::vector<std::unique_ptr<Type> > inputs;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> return_type;\n+\n+  // FIXME: think of better way to mark as invalid than taking up storage\n+  bool is_invalid;\n+\n+  // TODO: should this have location info?\n+\n+protected:\n+  // Constructor only used to create invalid type path functions.\n+  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n+\n+public:\n+  // Returns whether the return type of the function has been specified.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Returns whether the function has inputs.\n+  bool has_inputs () const { return !inputs.empty (); }\n+\n+  // Returns whether function is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  // Creates an error state function.\n+  static TypePathFunction create_error () { return TypePathFunction (true); }\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    Type *type = nullptr)\n+    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n+  {}\n+  // FIXME: deprecated\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    std::unique_ptr<Type> type = nullptr)\n+    : inputs (std::move (inputs)), return_type (std::move (type)),\n+      is_invalid (false)\n+  {}\n+\n+  // Copy constructor with clone\n+  TypePathFunction (TypePathFunction const &other)\n+    : return_type (other.return_type->clone_type ()),\n+      is_invalid (other.is_invalid)\n+  {\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+  }\n+\n+  ~TypePathFunction () = default;\n+\n+  // Overloaded assignment operator to clone type\n+  TypePathFunction &operator= (TypePathFunction const &other)\n+  {\n+    return_type = other.return_type->clone_type ();\n+    is_invalid = other.is_invalid;\n+\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePathFunction (TypePathFunction &&other) = default;\n+  TypePathFunction &operator= (TypePathFunction &&other) = default;\n+\n+  std::string as_string () const;\n+};\n+\n+// Segment used in type path with a function argument\n+class TypePathSegmentFunction : public TypePathSegment\n+{\n+  TypePathFunction function_path;\n+\n+public:\n+  // Constructor with PathIdentSegment and TypePathFn\n+  TypePathSegmentFunction (Analysis::NodeMapping mappings,\n+\t\t\t   PathIdentSegment ident_segment,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (mappings), std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  // Constructor with segment name and TypePathFn\n+  TypePathSegmentFunction (Analysis::NodeMapping mappings,\n+\t\t\t   std::string segment_name,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (mappings), std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  virtual SegmentType get_type () const override final\n+  {\n+    return SegmentType::FUNCTION;\n+  }\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentFunction *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentFunction (*this);\n+  }\n+};\n+\n+// Path used inside types\n+class TypePath : public TypeNoBounds\n+{\n+public:\n+  bool has_opening_scope_resolution;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_no_bounds_impl () const override\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+public:\n+  /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n+   * is global path or crate-relative path, not module-relative) */\n+  bool has_opening_scope_resolution_op () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  // Returns whether the TypePath is in an invalid state.\n+  bool is_error () const { return segments.empty (); }\n+\n+  // Creates an error state TypePath.\n+  static TypePath create_error ()\n+  {\n+    return TypePath (Analysis::NodeMapping::get_error (),\n+\t\t     std::vector<std::unique_ptr<TypePathSegment> > (),\n+\t\t     Location ());\n+  }\n+\n+  // Constructor\n+  TypePath (Analysis::NodeMapping mappings,\n+\t    std::vector<std::unique_ptr<TypePathSegment> > segments,\n+\t    Location locus, bool has_opening_scope_resolution = false)\n+    : TypeNoBounds (mappings, locus),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (segments))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TypePath (TypePath const &other)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      has_opening_scope_resolution (other.has_opening_scope_resolution)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with clone\n+  TypePath &operator= (TypePath const &other)\n+  {\n+    has_opening_scope_resolution = other.has_opening_scope_resolution;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePath (TypePath &&other) = default;\n+  TypePath &operator= (TypePath &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  AST::SimplePath as_simple_path () const;\n+\n+  // Creates a trait bound with a clone of this type path as its only element.\n+  TraitBound *to_trait_bound (bool in_parens) const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+\n+  std::unique_ptr<TypePathSegment> &get_final_segment ()\n+  {\n+    return segments.back ();\n+  }\n+};\n+\n+struct QualifiedPathType\n+{\n+private:\n+  std::unique_ptr<Type> type;\n+  std::unique_ptr<TypePath> trait;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Constructor\n+  QualifiedPathType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t\t     std::unique_ptr<TypePath> trait, Location locus)\n+    : type (std::move (type)), trait (std::move (trait)), locus (locus),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor uses custom deep copy for Type to preserve polymorphism\n+  QualifiedPathType (QualifiedPathType const &other)\n+    : type (other.type->clone_type ()),\n+      trait (other.has_as_clause () ? std::unique_ptr<HIR::TypePath> (\n+\t       new HIR::TypePath (*other.trait))\n+\t\t\t\t    : nullptr),\n+      locus (other.locus), mappings (other.mappings)\n+  {}\n+\n+  // default destructor\n+  ~QualifiedPathType () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  QualifiedPathType &operator= (QualifiedPathType const &other)\n+  {\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    mappings = other.mappings;\n+    trait\n+      = other.has_as_clause ()\n+\t  ? std::unique_ptr<HIR::TypePath> (new HIR::TypePath (*other.trait))\n+\t  : nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructor\n+  QualifiedPathType (QualifiedPathType &&other) = default;\n+  QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n+\n+  // Returns whether the qualified path type has a rebind as clause.\n+  bool has_as_clause () const { return trait != nullptr; }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+\n+  std::unique_ptr<TypePath> &get_trait ()\n+  {\n+    rust_assert (has_as_clause ());\n+    return trait;\n+  }\n+\n+  bool trait_has_generic_args () const\n+  {\n+    rust_assert (has_as_clause ());\n+    bool is_generic_seg = trait->get_final_segment ()->get_type ()\n+\t\t\t  == TypePathSegment::SegmentType::GENERIC;\n+    if (!is_generic_seg)\n+      return false;\n+\n+    TypePathSegmentGeneric *seg = static_cast<TypePathSegmentGeneric *> (\n+      trait->get_final_segment ().get ());\n+    return seg->has_generic_args ();\n+  }\n+\n+  GenericArgs &get_trait_generic_args ()\n+  {\n+    rust_assert (trait_has_generic_args ());\n+    TypePathSegmentGeneric *seg = static_cast<TypePathSegmentGeneric *> (\n+      trait->get_final_segment ().get ());\n+    return seg->get_generic_args ();\n+  }\n+};\n+\n+/* HIR node representing a qualified path-in-expression pattern (path that\n+ * allows specifying trait functions) */\n+class QualifiedPathInExpression : public PathPattern, public PathExpr\n+{\n+  QualifiedPathType path_type;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  QualifiedPathInExpression (Analysis::NodeMapping mappings,\n+\t\t\t     QualifiedPathType qual_path_type,\n+\t\t\t     std::vector<PathExprSegment> path_segments,\n+\t\t\t     Location locus = Location (),\n+\t\t\t     std::vector<AST::Attribute> outer_attrs\n+\t\t\t     = std::vector<AST::Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      path_type (std::move (qual_path_type)), locus (locus)\n+  {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRExpressionVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  QualifiedPathType &get_path_type () { return path_type; }\n+\n+  Location get_locus () { return locus; }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return get_mappings ();\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_pattern_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+};\n+\n+/* Represents a qualified path in a type; used for disambiguating trait function\n+ * calls */\n+class QualifiedPathInType : public TypeNoBounds\n+{\n+  QualifiedPathType path_type;\n+  std::unique_ptr<TypePathSegment> associated_segment;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_no_bounds_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+public:\n+  QualifiedPathInType (\n+    Analysis::NodeMapping mappings, QualifiedPathType qual_path_type,\n+    std::unique_ptr<TypePathSegment> associated_segment,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n+    Location locus = Location ())\n+    : TypeNoBounds (mappings, locus), path_type (std::move (qual_path_type)),\n+      associated_segment (std::move (associated_segment)),\n+      segments (std::move (path_segments))\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n+\n+  // Copy constructor with vector clone\n+  QualifiedPathInType (QualifiedPathInType const &other)\n+    : TypeNoBounds (other.mappings, other.locus), path_type (other.path_type)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    // Untested.\n+    gcc_unreachable ();\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  QualifiedPathInType &operator= (QualifiedPathInType const &other)\n+  {\n+    path_type = other.path_type;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  QualifiedPathInType (QualifiedPathInType &&other) = default;\n+  QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  QualifiedPathType &get_path_type () { return path_type; }\n+\n+  std::unique_ptr<TypePathSegment> &get_associated_segment ()\n+  {\n+    return associated_segment;\n+  }\n+\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+};\n+\n+class SimplePathSegment\n+{\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  SimplePathSegment (Analysis::NodeMapping mappings) : mappings (mappings) {}\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+};\n+\n+class SimplePath\n+{\n+  std::vector<SimplePathSegment> segments;\n+  Analysis::NodeMapping mappings;\n+  Location locus;\n+\n+public:\n+  SimplePath (std::vector<SimplePathSegment> segments,\n+\t      Analysis::NodeMapping mappings, Location locus)\n+    : segments (std::move (segments)), mappings (mappings), locus (locus)\n+  {}\n+\n+  static HIR::SimplePath create_empty ()\n+  {\n+    return HIR::SimplePath ({}, Analysis::NodeMapping::get_error (),\n+\t\t\t    Location ());\n+  }\n+\n+  bool is_error () const { return segments.empty (); }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+  const Location &get_locus () const { return locus; }\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "7129b5a36849961fa68989e741aa898fd1612093", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "added", "additions": 1356, "deletions": 0, "changes": 1356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e", "patch": "@@ -0,0 +1,1356 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATTERN_H\n+#define RUST_HIR_PATTERN_H\n+\n+#include \"rust-common.h\"\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// Literal pattern HIR node (comparing to a literal)\n+class LiteralPattern : public Pattern\n+{\n+  Literal lit;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor for a literal pattern\n+  LiteralPattern (Analysis::NodeMapping mappings, Literal lit, Location locus)\n+    : lit (std::move (lit)), locus (locus), mappings (mappings)\n+  {}\n+\n+  LiteralPattern (Analysis::NodeMapping mappings, std::string val,\n+\t\t  Literal::LitType type, Location locus)\n+    : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n+      locus (locus), mappings (mappings)\n+  {}\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::LITERAL;\n+  }\n+\n+  Literal &get_literal () { return lit; }\n+  const Literal &get_literal () const { return lit; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  virtual LiteralPattern *clone_pattern_impl () const override\n+  {\n+    return new LiteralPattern (*this);\n+  }\n+};\n+\n+// Identifier pattern HIR node (bind value matched to a variable)\n+class IdentifierPattern : public Pattern\n+{\n+  Identifier variable_ident;\n+  bool is_ref;\n+  Mutability mut;\n+  std::unique_ptr<Pattern> to_bind;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns whether the IdentifierPattern has a pattern to bind.\n+  bool has_pattern_to_bind () const { return to_bind != nullptr; }\n+\n+  // Constructor\n+  IdentifierPattern (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t     Location locus, bool is_ref = false,\n+\t\t     Mutability mut = Mutability::Imm,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : variable_ident (std::move (ident)), is_ref (is_ref), mut (mut),\n+      to_bind (std::move (to_bind)), locus (locus), mappings (mappings)\n+  {}\n+\n+  // Copy constructor with clone\n+  IdentifierPattern (IdentifierPattern const &other)\n+    : variable_ident (other.variable_ident), is_ref (other.is_ref),\n+      mut (other.mut), locus (other.locus), mappings (other.mappings)\n+  {\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to use clone\n+  IdentifierPattern &operator= (IdentifierPattern const &other)\n+  {\n+    variable_ident = other.variable_ident;\n+    is_ref = other.is_ref;\n+    mut = other.mut;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  IdentifierPattern (IdentifierPattern &&other) = default;\n+  IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n+\n+  Location get_locus () const override { return locus; }\n+\n+  bool is_mut () const { return mut == Mutability::Mut; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  Identifier get_identifier () const { return variable_ident; }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::IDENTIFIER;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  IdentifierPattern *clone_pattern_impl () const override\n+  {\n+    return new IdentifierPattern (*this);\n+  }\n+};\n+\n+// HIR node for using the '_' wildcard \"match any value\" pattern\n+class WildcardPattern : public Pattern\n+{\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, '_'); }\n+\n+  WildcardPattern (Analysis::NodeMapping mappings, Location locus)\n+    : locus (locus), mappings (mappings)\n+  {}\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::WILDCARD;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  WildcardPattern *clone_pattern_impl () const override\n+  {\n+    return new WildcardPattern (*this);\n+  }\n+};\n+\n+// Base range pattern bound (lower or upper limit) - abstract\n+class RangePatternBound\n+{\n+public:\n+  enum RangePatternBoundType\n+  {\n+    LITERAL,\n+    PATH,\n+    QUALPATH\n+  };\n+\n+  virtual ~RangePatternBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  {\n+    return std::unique_ptr<RangePatternBound> (\n+      clone_range_pattern_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual RangePatternBoundType get_bound_type () const = 0;\n+\n+protected:\n+  // pure virtual as RangePatternBound is abstract\n+  virtual RangePatternBound *clone_range_pattern_bound_impl () const = 0;\n+};\n+\n+// Literal-based pattern bound\n+class RangePatternBoundLiteral : public RangePatternBound\n+{\n+  Literal literal;\n+  /* Can only be a char, byte, int, or float literal - same impl here as\n+   * previously */\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  RangePatternBoundLiteral (Literal literal, Location locus,\n+\t\t\t    bool has_minus = false)\n+    : literal (literal), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  Literal get_literal () const { return literal; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::LITERAL;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundLiteral *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundLiteral (*this);\n+  }\n+};\n+\n+// Path-based pattern bound\n+class RangePatternBoundPath : public RangePatternBound\n+{\n+  PathInExpression path;\n+\n+  /* TODO: should this be refactored so that PathInExpression is a subclass of\n+   * RangePatternBound? */\n+\n+public:\n+  RangePatternBoundPath (PathInExpression path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::PATH;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundPath (*this);\n+  }\n+};\n+\n+// Qualified path-based pattern bound\n+class RangePatternBoundQualPath : public RangePatternBound\n+{\n+  QualifiedPathInExpression path;\n+\n+  /* TODO: should this be refactored so that QualifiedPathInExpression is a\n+   * subclass of RangePatternBound? */\n+\n+public:\n+  RangePatternBoundQualPath (QualifiedPathInExpression path)\n+    : path (std::move (path))\n+  {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  QualifiedPathInExpression &get_qualified_path () { return path; }\n+  const QualifiedPathInExpression &get_qualified_path () const { return path; }\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::QUALPATH;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundQualPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundQualPath (*this);\n+  }\n+};\n+\n+// HIR node for matching within a certain range (range pattern)\n+class RangePattern : public Pattern\n+{\n+  std::unique_ptr<RangePatternBound> lower;\n+  std::unique_ptr<RangePatternBound> upper;\n+\n+  bool has_ellipsis_syntax;\n+\n+  /* location only stored to avoid a dereference - lower pattern should give\n+   * correct location so maybe change in future */\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  RangePattern (Analysis::NodeMapping mappings,\n+\t\tstd::unique_ptr<RangePatternBound> lower,\n+\t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n+\t\tbool has_ellipsis_syntax = false)\n+    : lower (std::move (lower)), upper (std::move (upper)),\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor with clone\n+  RangePattern (RangePattern const &other)\n+    : lower (other.lower->clone_range_pattern_bound ()),\n+      upper (other.upper->clone_range_pattern_bound ()),\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus),\n+      mappings (other.mappings)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  RangePattern &operator= (RangePattern const &other)\n+  {\n+    lower = other.lower->clone_range_pattern_bound ();\n+    upper = other.upper->clone_range_pattern_bound ();\n+    has_ellipsis_syntax = other.has_ellipsis_syntax;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RangePattern (RangePattern &&other) = default;\n+  RangePattern &operator= (RangePattern &&other) = default;\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::RANGE;\n+  }\n+\n+  std::unique_ptr<RangePatternBound> &get_lower_bound ()\n+  {\n+    rust_assert (lower != nullptr);\n+    return lower;\n+  }\n+\n+  std::unique_ptr<RangePatternBound> &get_upper_bound ()\n+  {\n+    rust_assert (upper != nullptr);\n+    return upper;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePattern *clone_pattern_impl () const override\n+  {\n+    return new RangePattern (*this);\n+  }\n+};\n+\n+// HIR node for pattern based on dereferencing the pointers given\n+class ReferencePattern : public Pattern\n+{\n+  bool has_two_amps;\n+  Mutability mut;\n+  std::unique_ptr<Pattern> pattern;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ReferencePattern (Analysis::NodeMapping mappings,\n+\t\t    std::unique_ptr<Pattern> pattern, Mutability reference_mut,\n+\t\t    bool ref_has_two_amps, Location locus)\n+    : has_two_amps (ref_has_two_amps), mut (reference_mut),\n+      pattern (std::move (pattern)), locus (locus), mappings (mappings)\n+  {}\n+\n+  // Copy constructor requires clone\n+  ReferencePattern (ReferencePattern const &other)\n+    : has_two_amps (other.has_two_amps), mut (other.mut),\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus),\n+      mappings (other.mappings)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  ReferencePattern &operator= (ReferencePattern const &other)\n+  {\n+    pattern = other.pattern->clone_pattern ();\n+    mut = other.mut;\n+    has_two_amps = other.has_two_amps;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ReferencePattern (ReferencePattern &&other) = default;\n+  ReferencePattern &operator= (ReferencePattern &&other) = default;\n+\n+  bool is_mut () const { return mut == Mutability::Mut; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::REFERENCE;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferencePattern *clone_pattern_impl () const override\n+  {\n+    return new ReferencePattern (*this);\n+  }\n+};\n+\n+// Base class for a single field in a struct pattern - abstract\n+class StructPatternField\n+{\n+  AST::AttrVec outer_attrs;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  enum ItemType\n+  {\n+    TUPLE_PAT,\n+    IDENT_PAT,\n+    IDENT\n+  };\n+\n+  virtual ~StructPatternField () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  {\n+    return std::unique_ptr<StructPatternField> (\n+      clone_struct_pattern_field_impl ());\n+  }\n+\n+  virtual std::string as_string () const;\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+  virtual ItemType get_item_type () const = 0;\n+\n+  Location get_locus () const { return locus; }\n+  Analysis::NodeMapping get_mappings () const { return mappings; };\n+\n+protected:\n+  StructPatternField (Analysis::NodeMapping mappings,\n+\t\t      AST::AttrVec outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus),\n+      mappings (mappings)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual StructPatternField *clone_struct_pattern_field_impl () const = 0;\n+};\n+\n+// Tuple pattern single field in a struct pattern\n+class StructPatternFieldTuplePat : public StructPatternField\n+{\n+  TupleIndex index;\n+  std::unique_ptr<Pattern> tuple_pattern;\n+\n+public:\n+  StructPatternFieldTuplePat (Analysis::NodeMapping mappings, TupleIndex index,\n+\t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      AST::AttrVec outer_attribs, Location locus)\n+    : StructPatternField (mappings, std::move (outer_attribs), locus),\n+      index (index), tuple_pattern (std::move (tuple_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n+    : StructPatternField (other), index (other.index),\n+      tuple_pattern (other.tuple_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to perform clone\n+  StructPatternFieldTuplePat &\n+  operator= (StructPatternFieldTuplePat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    index = other.index;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat &&other) = default;\n+  StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  ItemType get_item_type () const override final { return ItemType::TUPLE_PAT; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldTuplePat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldTuplePat (*this);\n+  }\n+};\n+\n+// Identifier pattern single field in a struct pattern\n+class StructPatternFieldIdentPat : public StructPatternField\n+{\n+  Identifier ident;\n+  std::unique_ptr<Pattern> ident_pattern;\n+\n+public:\n+  StructPatternFieldIdentPat (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t\t      std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      AST::AttrVec outer_attrs, Location locus)\n+    : StructPatternField (mappings, std::move (outer_attrs), locus),\n+      ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n+    : StructPatternField (other), ident (other.ident),\n+      ident_pattern (other.ident_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to clone\n+  StructPatternFieldIdentPat &\n+  operator= (StructPatternFieldIdentPat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    ident = other.ident;\n+    ident_pattern = other.ident_pattern->clone_pattern ();\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat &&other) = default;\n+  StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT_PAT; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdentPat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdentPat (*this);\n+  }\n+};\n+\n+// Identifier only (with no pattern) single field in a struct pattern\n+class StructPatternFieldIdent : public StructPatternField\n+{\n+  bool has_ref;\n+  Mutability mut;\n+  Identifier ident;\n+\n+public:\n+  StructPatternFieldIdent (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t\t   bool is_ref, Mutability mut,\n+\t\t\t   AST::AttrVec outer_attrs, Location locus)\n+    : StructPatternField (mappings, std::move (outer_attrs), locus),\n+      has_ref (is_ref), mut (mut), ident (std::move (ident))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  bool is_mut () const { return mut == Mutability::Mut; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT; }\n+\n+  Identifier get_identifier () const { return ident; };\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdent *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdent (*this);\n+  }\n+};\n+\n+// Elements of a struct pattern\n+struct StructPatternElements\n+{\n+private:\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n+\n+public:\n+  // Returns whether there are any struct pattern fields\n+  bool has_struct_pattern_fields () const { return !fields.empty (); }\n+\n+  /* Returns whether the struct pattern elements is entirely empty (no fields,\n+   * no etc). */\n+  bool is_empty () const { return !has_struct_pattern_fields (); }\n+\n+  // Constructor for StructPatternElements with both (potentially)\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n+    : fields (std::move (fields))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  StructPatternElements (StructPatternElements const &other)\n+  {\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  StructPatternElements &operator= (StructPatternElements const &other)\n+  {\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  StructPatternElements (StructPatternElements &&other) = default;\n+  StructPatternElements &operator= (StructPatternElements &&other) = default;\n+\n+  // Creates an empty StructPatternElements\n+  static StructPatternElements create_empty ()\n+  {\n+    return StructPatternElements (\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields ()\n+  {\n+    return fields;\n+  }\n+};\n+\n+// Struct pattern HIR node representation\n+class StructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  StructPatternElements elems;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  StructPattern (Analysis::NodeMapping mappings, PathInExpression struct_path,\n+\t\t StructPatternElements elems)\n+    : path (std::move (struct_path)), elems (std::move (elems)),\n+      mappings (mappings)\n+  {}\n+\n+  bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+\n+  Location get_locus () const override { return path.get_locus (); }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  PathInExpression &get_path () { return path; }\n+  StructPatternElements &get_struct_pattern_elems () { return elems; }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::STRUCT;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPattern *clone_pattern_impl () const override\n+  {\n+    return new StructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class for patterns used in TupleStructPattern\n+class TupleStructItems\n+{\n+public:\n+  enum ItemType\n+  {\n+    RANGE,\n+    NO_RANGE\n+  };\n+\n+  virtual ~TupleStructItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  {\n+    return std::unique_ptr<TupleStructItems> (clone_tuple_struct_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual ItemType get_item_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n+};\n+\n+// Class for non-ranged tuple struct pattern patterns\n+class TupleStructItemsNoRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsNoRange (TupleStructItemsNoRange &&other) = default;\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::NO_RANGE; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsNoRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsNoRange (*this);\n+  }\n+};\n+\n+// Class for ranged tuple struct pattern patterns\n+class TupleStructItemsRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsRange (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n+  TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::RANGE; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsRange (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple struct pattern\n+class TupleStructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  std::unique_ptr<TupleStructItems> items;\n+  Analysis::NodeMapping mappings;\n+\n+  /* TOOD: should this store location data? current accessor uses path location\n+   * data */\n+\n+public:\n+  std::string as_string () const override;\n+\n+  TupleStructPattern (Analysis::NodeMapping mappings,\n+\t\t      PathInExpression tuple_struct_path,\n+\t\t      std::unique_ptr<TupleStructItems> items)\n+    : path (std::move (tuple_struct_path)), items (std::move (items)),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor required to clone\n+  TupleStructPattern (TupleStructPattern const &other)\n+    : path (other.path), items (other.items->clone_tuple_struct_items ()),\n+      mappings (other.mappings)\n+  {}\n+\n+  // Operator overload assignment operator to clone\n+  TupleStructPattern &operator= (TupleStructPattern const &other)\n+  {\n+    path = other.path;\n+    items = other.items->clone_tuple_struct_items ();\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructPattern (TupleStructPattern &&other) = default;\n+  TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n+\n+  Location get_locus () const override { return path.get_locus (); }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  PathInExpression &get_path () { return path; }\n+\n+  std::unique_ptr<TupleStructItems> &get_items () { return items; }\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::TUPLE_STRUCT;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructPattern *clone_pattern_impl () const override\n+  {\n+    return new TupleStructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class representing TuplePattern patterns\n+class TuplePatternItems\n+{\n+public:\n+  enum TuplePatternItemType\n+  {\n+    MULTIPLE,\n+    RANGED,\n+  };\n+\n+  virtual ~TuplePatternItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  {\n+    return std::unique_ptr<TuplePatternItems> (\n+      clone_tuple_pattern_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRFullVisitor &vis) = 0;\n+\n+  virtual TuplePatternItemType get_pattern_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n+};\n+\n+// Class representing TuplePattern patterns where there are multiple patterns\n+class TuplePatternItemsMultiple : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple &&other) = default;\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::MULTIPLE;\n+  }\n+\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsMultiple *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsMultiple (*this);\n+  }\n+};\n+\n+// Class representing TuplePattern patterns where there are a range of patterns\n+class TuplePatternItemsRanged : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TuplePatternItemsRanged (\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsRanged (TuplePatternItemsRanged &&other) = default;\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::RANGED;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsRanged *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsRanged (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple pattern\n+class TuplePattern : public Pattern\n+{\n+  std::unique_ptr<TuplePatternItems> items;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns true if the tuple pattern has items\n+  bool has_tuple_pattern_items () const { return items != nullptr; }\n+\n+  TuplePattern (Analysis::NodeMapping mappings,\n+\t\tstd::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus), mappings (mappings)\n+  {}\n+\n+  // Copy constructor requires clone\n+  TuplePattern (TuplePattern const &other)\n+    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus),\n+      mappings (other.mappings)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  TuplePattern &operator= (TuplePattern const &other)\n+  {\n+    items = other.items->clone_tuple_pattern_items ();\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::TUPLE;\n+  }\n+\n+  std::unique_ptr<TuplePatternItems> &get_items () { return items; }\n+  const std::unique_ptr<TuplePatternItems> &get_items () const { return items; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePattern *clone_pattern_impl () const override\n+  {\n+    return new TuplePattern (*this);\n+  }\n+};\n+\n+// HIR node representing a pattern in parentheses, used to control precedence\n+class GroupedPattern : public Pattern\n+{\n+  std::unique_ptr<Pattern> pattern_in_parens;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override\n+  {\n+    return \"(\" + pattern_in_parens->as_string () + \")\";\n+  }\n+\n+  GroupedPattern (Analysis::NodeMapping mappings,\n+\t\t  std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor uses clone\n+  GroupedPattern (GroupedPattern const &other)\n+    : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n+      locus (other.locus), mappings (other.mappings)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  GroupedPattern &operator= (GroupedPattern const &other)\n+  {\n+    pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  GroupedPattern (GroupedPattern &&other) = default;\n+  GroupedPattern &operator= (GroupedPattern &&other) = default;\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::GROUPED;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  GroupedPattern *clone_pattern_impl () const override\n+  {\n+    return new GroupedPattern (*this);\n+  }\n+};\n+\n+// HIR node representing patterns that can match slices and arrays\n+class SlicePattern : public Pattern\n+{\n+  std::vector<std::unique_ptr<Pattern> > items;\n+  Location locus;\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  SlicePattern (Analysis::NodeMapping mappings,\n+\t\tstd::vector<std::unique_ptr<Pattern> > items, Location locus)\n+    : items (std::move (items)), locus (locus), mappings (mappings)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  SlicePattern (SlicePattern const &other)\n+    : locus (other.locus), mappings (other.mappings)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  SlicePattern &operator= (SlicePattern const &other)\n+  {\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SlicePattern (SlicePattern &&other) = default;\n+  SlicePattern &operator= (SlicePattern &&other) = default;\n+\n+  Location get_locus () const override { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRPatternVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_pattern_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  PatternType get_pattern_type () const override final\n+  {\n+    return PatternType::SLICE;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SlicePattern *clone_pattern_impl () const override\n+  {\n+    return new SlicePattern (*this);\n+  }\n+};\n+\n+// Moved definition to rust-path.h\n+class PathPattern;\n+\n+// Forward decls for paths (defined in rust-path.h)\n+class PathInExpression;\n+class QualifiedPathInExpression;\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "5247b0aa0f0b78a195d69abdd85d30d192fb1465", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e", "patch": "@@ -0,0 +1,273 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_STATEMENT_H\n+#define RUST_HIR_STATEMENT_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Just a semi-colon, which apparently is a statement.\n+class EmptyStmt : public Stmt\n+{\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, ';'); }\n+\n+  EmptyStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRStmtVisitor &vis) override;\n+\n+  bool is_item () const override final { return false; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  EmptyStmt *clone_stmt_impl () const override { return new EmptyStmt (*this); }\n+};\n+\n+/* Variable assignment let statement - type of \"declaration statement\" as it\n+ * introduces new name into scope */\n+class LetStmt : public Stmt\n+{\n+  // bool has_outer_attrs;\n+  AST::AttrVec outer_attrs;\n+\n+  std::unique_ptr<Pattern> variables_pattern;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> type;\n+\n+  // bool has_init_expr;\n+  std::unique_ptr<Expr> init_expr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether let statement has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether let statement has a given return type.\n+  bool has_type () const { return type != nullptr; }\n+\n+  // Returns whether let statement has an initialisation expression.\n+  bool has_init_expr () const { return init_expr != nullptr; }\n+\n+  std::string as_string () const override;\n+\n+  LetStmt (Analysis::NodeMapping mappings,\n+\t   std::unique_ptr<Pattern> variables_pattern,\n+\t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n+\t   AST::AttrVec outer_attrs, Location locus)\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attrs)),\n+      variables_pattern (std::move (variables_pattern)),\n+      type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  LetStmt (LetStmt const &other)\n+    : Stmt (other.mappings), outer_attrs (other.outer_attrs),\n+      locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  LetStmt &operator= (LetStmt const &other)\n+  {\n+    outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+    else\n+      variables_pattern = nullptr;\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    else\n+      init_expr = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LetStmt (LetStmt &&other) = default;\n+  LetStmt &operator= (LetStmt &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRStmtVisitor &vis) override;\n+\n+  HIR::Type *get_type () { return type.get (); }\n+\n+  HIR::Expr *get_init_expr () { return init_expr.get (); }\n+\n+  HIR::Pattern *get_pattern () { return variables_pattern.get (); }\n+\n+  bool is_item () const override final { return false; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LetStmt *clone_stmt_impl () const override { return new LetStmt (*this); }\n+};\n+\n+/* Abstract base class for expression statements (statements containing an\n+ * expression) */\n+class ExprStmt : public Stmt\n+{\n+  // TODO: add any useful virtual functions\n+\n+  Location locus;\n+\n+public:\n+  Location get_locus () const override final { return locus; }\n+\n+  bool is_item () const override final { return false; }\n+\n+protected:\n+  ExprStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+};\n+\n+/* Statement containing an expression without a block (or, due to technical\n+ * difficulties, can only be guaranteed to hold an expression). */\n+class ExprStmtWithoutBlock : public ExprStmt\n+{\n+  std::unique_ptr<Expr> expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprStmtWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t\tstd::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRStmtVisitor &vis) override;\n+\n+  Expr *get_expr () { return expr.get (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithoutBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithoutBlock (*this);\n+  }\n+};\n+\n+// Statement containing an expression with a block\n+class ExprStmtWithBlock : public ExprStmt\n+{\n+  std::unique_ptr<ExprWithBlock> expr;\n+  bool must_be_unit;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprStmtWithBlock (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<ExprWithBlock> expr, Location locus,\n+\t\t     bool must_be_unit)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr)),\n+      must_be_unit (must_be_unit)\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr_with_block ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRStmtVisitor &vis) override;\n+\n+  ExprWithBlock *get_expr () { return expr.get (); }\n+\n+  bool is_unit_check_needed () const override { return must_be_unit; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithBlock (*this);\n+  }\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "0d2e7436acc3a5b9140da750afccbdf7ec44aead", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad1d56d68a998fdc662a944f461e7bcb125920e/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=8ad1d56d68a998fdc662a944f461e7bcb125920e", "patch": "@@ -0,0 +1,860 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_H\n+#define RUST_HIR_TYPE_H\n+\n+#include \"rust-common.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// definitions moved to rust-ast.h\n+class TypeParamBound;\n+class Lifetime;\n+\n+// A trait bound\n+class TraitBound : public TypeParamBound\n+{\n+  bool in_parens;\n+  bool opening_question_mark;\n+  std::vector<LifetimeParam> for_lifetimes;\n+  TypePath type_path;\n+  Location locus;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Returns whether trait bound has \"for\" lifetimes\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  TraitBound (Analysis::NodeMapping mapping, TypePath type_path, Location locus,\n+\t      bool in_parens = false, bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus), mappings (mapping)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+\n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  }\n+\n+  BoundType get_bound_type () const final override { return TRAITBOUND; }\n+\n+  TypePath &get_path () { return type_path; }\n+\n+  const TypePath &get_path () const { return type_path; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitBound *clone_type_param_bound_impl () const override\n+  {\n+    return new TraitBound (*this);\n+  }\n+};\n+\n+// definition moved to rust-ast.h\n+class TypeNoBounds;\n+\n+// An impl trait? Poor reference material here.\n+class ImplTraitType : public Type\n+{\n+  // TypeParamBounds type_param_bounds;\n+  // inlined form\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitType *clone_type_impl () const override\n+  {\n+    return new ImplTraitType (*this);\n+  }\n+\n+public:\n+  ImplTraitType (Analysis::NodeMapping mappings,\n+\t\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t\t Location locus)\n+    : Type (mappings, locus), type_param_bounds (std::move (type_param_bounds))\n+  {}\n+\n+  // copy constructor with vector clone\n+  ImplTraitType (ImplTraitType const &other)\n+    : Type (other.mappings, other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  ImplTraitType &operator= (ImplTraitType const &other)\n+  {\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ImplTraitType (ImplTraitType &&other) = default;\n+  ImplTraitType &operator= (ImplTraitType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+};\n+\n+// An opaque value of another type that implements a set of traits\n+class TraitObjectType : public Type\n+{\n+  bool has_dyn;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectType *clone_type_impl () const override\n+  {\n+    return new TraitObjectType (*this);\n+  }\n+\n+public:\n+  TraitObjectType (\n+    Analysis::NodeMapping mappings,\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    Location locus, bool is_dyn_dispatch)\n+    : Type (mappings, locus), has_dyn (is_dyn_dispatch),\n+      type_param_bounds (std::move (type_param_bounds))\n+  {}\n+\n+  // copy constructor with vector clone\n+  TraitObjectType (TraitObjectType const &other)\n+    : Type (other.mappings, other.locus), has_dyn (other.has_dyn)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TraitObjectType &operator= (TraitObjectType const &other)\n+  {\n+    mappings = other.mappings;\n+    has_dyn = other.has_dyn;\n+    locus = other.locus;\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TraitObjectType (TraitObjectType &&other) = default;\n+  TraitObjectType &operator= (TraitObjectType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+};\n+\n+// A type with parentheses around it, used to avoid ambiguity.\n+class ParenthesisedType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> type_in_parens;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+public:\n+  // Constructor uses Type pointer for polymorphism\n+  ParenthesisedType (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : TypeNoBounds (mappings, locus),\n+      type_in_parens (std::move (type_inside_parens))\n+  {}\n+\n+  /* Copy constructor uses custom deep copy method for type to preserve\n+   * polymorphism */\n+  ParenthesisedType (ParenthesisedType const &other)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      type_in_parens (other.type_in_parens->clone_type ())\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  ParenthesisedType &operator= (ParenthesisedType const &other)\n+  {\n+    mappings = other.mappings;\n+    type_in_parens = other.type_in_parens->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ParenthesisedType (ParenthesisedType &&other) = default;\n+  ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n+\n+  std::string as_string () const override\n+  {\n+    return \"(\" + type_in_parens->as_string () + \")\";\n+  }\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  {\n+    /* NOTE: obviously it is unknown whether the internal type is a trait bound\n+     * due to polymorphism, so just let the internal type handle it. As\n+     * parenthesised type, it must be in parentheses. */\n+    return type_in_parens->to_trait_bound (true);\n+  }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+};\n+\n+// Impl trait with a single bound? Poor reference material here.\n+class ImplTraitTypeOneBound : public TypeNoBounds\n+{\n+  TraitBound trait_bound;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+public:\n+  ImplTraitTypeOneBound (Analysis::NodeMapping mappings, TraitBound trait_bound,\n+\t\t\t Location locus)\n+    : TypeNoBounds (mappings, locus), trait_bound (std::move (trait_bound))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+};\n+\n+class TypePath; // definition moved to \"rust-path.h\"\n+\n+/* A type consisting of the \"product\" of others (the tuple's elements) in a\n+ * specific order */\n+class TupleType : public TypeNoBounds\n+{\n+  std::vector<std::unique_ptr<Type>> elems;\n+\n+public:\n+  // Returns whether the tuple type is the unit type, i.e. has no elements.\n+  bool is_unit_type () const { return elems.empty (); }\n+\n+  TupleType (Analysis::NodeMapping mappings,\n+\t     std::vector<std::unique_ptr<Type>> elems, Location locus)\n+    : TypeNoBounds (mappings, locus), elems (std::move (elems))\n+  {}\n+\n+  // copy constructor with vector clone\n+  TupleType (TupleType const &other)\n+    : TypeNoBounds (other.mappings, other.locus)\n+  {\n+    mappings = other.mappings;\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TupleType &operator= (TupleType const &other)\n+  {\n+    locus = other.locus;\n+\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleType (TupleType &&other) = default;\n+  TupleType &operator= (TupleType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  std::vector<std::unique_ptr<Type>> &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type>> &get_elems () const { return elems; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_no_bounds_impl () const override\n+  {\n+    return new TupleType (*this);\n+  }\n+};\n+\n+/* A type with no values, representing the result of computations that never\n+ * complete. Expressions of NeverType can be coerced into any other types.\n+ * Represented as \"!\". */\n+class NeverType : public TypeNoBounds\n+{\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_no_bounds_impl () const override\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+public:\n+  NeverType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings, locus)\n+  {}\n+\n+  std::string as_string () const override { return \"! (never type)\"; }\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+};\n+\n+// A type consisting of a pointer without safety or liveness guarantees\n+class RawPointerType : public TypeNoBounds\n+{\n+private:\n+  Mutability mut;\n+  std::unique_ptr<Type> type;\n+\n+public:\n+  // Constructor requires pointer for polymorphism reasons\n+  RawPointerType (Analysis::NodeMapping mappings, Mutability mut,\n+\t\t  std::unique_ptr<Type> type, Location locus)\n+    : TypeNoBounds (mappings, locus), mut (mut), type (std::move (type))\n+  {}\n+\n+  // Copy constructor calls custom polymorphic clone function\n+  RawPointerType (RawPointerType const &other)\n+    : TypeNoBounds (other.mappings, other.locus), mut (other.mut),\n+      type (other.type->clone_type ())\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  RawPointerType &operator= (RawPointerType const &other)\n+  {\n+    mappings = other.mappings;\n+    mut = other.mut;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RawPointerType (RawPointerType &&other) = default;\n+  RawPointerType &operator= (RawPointerType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+\n+  Mutability get_mut () const { return mut; }\n+\n+  bool is_mut () const { return mut == Mutability::Mut; }\n+\n+  bool is_const () const { return mut == Mutability::Imm; }\n+\n+  std::unique_ptr<Type> &get_base_type () { return type; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_no_bounds_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+};\n+\n+// A type pointing to memory owned by another value\n+class ReferenceType : public TypeNoBounds\n+{\n+  // bool has_lifetime; // TODO: handle in lifetime or something?\n+  Lifetime lifetime;\n+\n+  Mutability mut;\n+  std::unique_ptr<Type> type;\n+\n+public:\n+  // Returns whether the reference is mutable or immutable.\n+  bool is_mut () const { return mut == Mutability::Mut; }\n+\n+  // Returns whether the reference has a lifetime.\n+  bool has_lifetime () const { return !lifetime.is_error (); }\n+\n+  // Constructor\n+  ReferenceType (Analysis::NodeMapping mappings, Mutability mut,\n+\t\t std::unique_ptr<Type> type_no_bounds, Location locus,\n+\t\t Lifetime lifetime)\n+    : TypeNoBounds (mappings, locus), lifetime (std::move (lifetime)),\n+      mut (mut), type (std::move (type_no_bounds))\n+  {}\n+\n+  // Copy constructor with custom clone method\n+  ReferenceType (ReferenceType const &other)\n+    : TypeNoBounds (other.mappings, other.locus), lifetime (other.lifetime),\n+      mut (other.mut), type (other.type->clone_type ())\n+  {}\n+\n+  // Operator overload assignment operator to custom clone the unique pointer\n+  ReferenceType &operator= (ReferenceType const &other)\n+  {\n+    mappings = other.mappings;\n+    lifetime = other.lifetime;\n+    mut = other.mut;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ReferenceType (ReferenceType &&other) = default;\n+  ReferenceType &operator= (ReferenceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  Lifetime &get_lifetime () { return lifetime; }\n+\n+  Mutability get_mut () const { return mut; }\n+\n+  std::unique_ptr<Type> &get_base_type () { return type; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+};\n+\n+// A fixed-size sequence of elements of a specified type\n+class ArrayType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  std::unique_ptr<Expr> size;\n+\n+public:\n+  // Constructor requires pointers for polymorphism\n+  ArrayType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     std::unique_ptr<Expr> array_size, Location locus)\n+    : TypeNoBounds (mappings, locus), elem_type (std::move (type)),\n+      size (std::move (array_size))\n+  {}\n+\n+  // Copy constructor requires deep copies of both unique pointers\n+  ArrayType (ArrayType const &other)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ())\n+  {}\n+\n+  // Overload assignment operator to deep copy pointers\n+  ArrayType &operator= (ArrayType const &other)\n+  {\n+    mappings = other.mappings;\n+    elem_type = other.elem_type->clone_type ();\n+    size = other.size->clone_expr ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ArrayType (ArrayType &&other) = default;\n+  ArrayType &operator= (ArrayType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  Type *get_element_type () { return elem_type.get (); }\n+\n+  Expr *get_size_expr () { return size.get (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ArrayType (*this);\n+  }\n+};\n+\n+/* A dynamically-sized type representing a \"view\" into a sequence of elements of\n+ * a type */\n+class SliceType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+\n+public:\n+  // Constructor requires pointer for polymorphism\n+  SliceType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     Location locus)\n+    : TypeNoBounds (mappings, locus), elem_type (std::move (type))\n+  {}\n+\n+  // Copy constructor requires deep copy of Type smart pointer\n+  SliceType (SliceType const &other)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      elem_type (other.elem_type->clone_type ())\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  SliceType &operator= (SliceType const &other)\n+  {\n+    mappings = other.mappings;\n+    elem_type = other.elem_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SliceType (SliceType &&other) = default;\n+  SliceType &operator= (SliceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  std::unique_ptr<Type> &get_element_type () { return elem_type; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new SliceType (*this);\n+  }\n+};\n+\n+/* Type used in generic arguments to explicitly request type inference (wildcard\n+ * pattern) */\n+class InferredType : public TypeNoBounds\n+{\n+  // e.g. Vec<_> = whatever\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_no_bounds_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+public:\n+  InferredType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings, locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+};\n+\n+class QualifiedPathInType; // definition moved to \"rust-path.h\"\n+\n+// A possibly named param used in a BaseFunctionType\n+struct MaybeNamedParam\n+{\n+public:\n+  enum ParamKind\n+  {\n+    UNNAMED,\n+    IDENTIFIER,\n+    WILDCARD\n+  };\n+\n+private:\n+  std::unique_ptr<Type> param_type;\n+\n+  ParamKind param_kind;\n+  Identifier name; // technically, can be an identifier or '_'\n+\n+  Location locus;\n+\n+public:\n+  MaybeNamedParam (Identifier name, ParamKind param_kind,\n+\t\t   std::unique_ptr<Type> param_type, Location locus)\n+    : param_type (std::move (param_type)), param_kind (param_kind),\n+      name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MaybeNamedParam (MaybeNamedParam const &other)\n+    : param_type (other.param_type->clone_type ()),\n+      param_kind (other.param_kind), name (other.name), locus (other.locus)\n+  {}\n+\n+  ~MaybeNamedParam () = default;\n+\n+  // Overloaded assignment operator with clone\n+  MaybeNamedParam &operator= (MaybeNamedParam const &other)\n+  {\n+    name = other.name;\n+    param_kind = other.param_kind;\n+    param_type = other.param_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MaybeNamedParam (MaybeNamedParam &&other) = default;\n+  MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the param is in an error state.\n+  bool is_error () const { return param_type == nullptr; }\n+\n+  // Creates an error state param.\n+  static MaybeNamedParam create_error ()\n+  {\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n+};\n+\n+/* A function pointer type - can be created via coercion from function items and\n+ * non- capturing closures. */\n+class BareFunctionType : public TypeNoBounds\n+{\n+  // bool has_for_lifetimes;\n+  // ForLifetimes for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined version\n+\n+  FunctionQualifiers function_qualifiers;\n+  std::vector<MaybeNamedParam> params;\n+  bool is_variadic;\n+\n+  std::unique_ptr<Type> return_type; // inlined version\n+\n+public:\n+  // Whether a return type is defined with the function.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Whether the function has ForLifetimes.\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  BareFunctionType (Analysis::NodeMapping mappings,\n+\t\t    std::vector<LifetimeParam> lifetime_params,\n+\t\t    FunctionQualifiers qualifiers,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::unique_ptr<Type> type, Location locus)\n+    : TypeNoBounds (mappings, locus),\n+      for_lifetimes (std::move (lifetime_params)),\n+      function_qualifiers (std::move (qualifiers)),\n+      params (std::move (named_params)), is_variadic (is_variadic),\n+      return_type (std::move (type))\n+  {}\n+\n+  // Copy constructor with clone\n+  BareFunctionType (BareFunctionType const &other)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      for_lifetimes (other.for_lifetimes),\n+      function_qualifiers (other.function_qualifiers), params (other.params),\n+      is_variadic (other.is_variadic),\n+      return_type (other.return_type->clone_type ())\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  BareFunctionType &operator= (BareFunctionType const &other)\n+  {\n+    mappings = other.mappings;\n+    for_lifetimes = other.for_lifetimes;\n+    function_qualifiers = other.function_qualifiers;\n+    params = other.params;\n+    is_variadic = other.is_variadic;\n+    return_type = other.return_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  BareFunctionType (BareFunctionType &&other) = default;\n+  BareFunctionType &operator= (BareFunctionType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRFullVisitor &vis) override;\n+  void accept_vis (HIRTypeVisitor &vis) override;\n+\n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n+  {\n+    return params;\n+  }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_no_bounds_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+};\n+\n+/* TODO: possible types\n+ * struct type?\n+ * \"enum\" (tagged union) type?\n+ * C-like union type?\n+ * function item type?\n+ * closure expression types?\n+ * primitive types (bool, int, float, char, str (the slice))\n+ * Although supposedly TypePaths are used to reference these types (including\n+ * primitives) */\n+\n+/* FIXME: Incomplete spec references:\n+ *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then\n+ * trait bounds abstract return types, aka \"impl Trait in return position\" -\n+ * impl then trait bounds */\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}]}