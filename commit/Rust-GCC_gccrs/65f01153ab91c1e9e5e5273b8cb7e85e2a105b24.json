{"sha": "65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVmMDExNTNhYjkxYzFlOWU1ZTUyNzNiOGNiN2U4NWUyYTEwNWIyNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-11-15T13:56:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:56:51Z"}, "message": "sem_attr.adb: Implement Machine_Rounding attribute\n\n2005-11-14  Robert Dewar  <dewar@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb: Implement Machine_Rounding attribute\n\t(Analyze_Access_Attribute): The access attribute may appear within an\n\taggregate that has been expanded into a loop.\n\t(Check_Task_Prefix): Add semantic check for attribute 'Callable and\n\t'Terminated whenever the prefix is of a task interface class-wide type.\n\t(Analyze_Attribute): Add semantic check for attribute 'Identity whenever\n\tthe prefix is of a task interface class-wide type.\n\n\t* s-vaflop-vms-alpha.adb: Valid_D, Valid_F, Valid_G: Make Val constant\n\tto avoid warnings.\n\n\t* s-fatgen.ads, s-fatgen.adb (Machine_Rounding): New function\n\tRemove pragma Inline for [Unaligned_]Valid.\n\tAdd comments that Valid routines do not work for Vax_Float\n\n\t* exp_attr.adb: Implement Machine_Rounding attribute\n\n\t* snames.h: Add entry for Machine_Rounding attribute\n\nFrom-SVN: r106970", "tree": {"sha": "12763bf49f192f9375a0f912c3516ed9c9911fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12763bf49f192f9375a0f912c3516ed9c9911fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/comments", "author": null, "committer": null, "parents": [{"sha": "7b9d0d6990c025f037fef869732a960e9fe39e94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9d0d6990c025f037fef869732a960e9fe39e94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b9d0d6990c025f037fef869732a960e9fe39e94"}], "stats": {"total": 742, "additions": 513, "deletions": 229}, "files": [{"sha": "11bc258d86ed9117da0e91d1b7d5e4d9b50ca138", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 263, "deletions": 75, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -85,16 +85,17 @@ package body Exp_Attr is\n \n    procedure Expand_Fpt_Attribute\n      (N    : Node_Id;\n-      Rtp  : Entity_Id;\n+      Pkg  : RE_Id;\n       Nam  : Name_Id;\n       Args : List_Id);\n    --  This procedure expands a call to a floating-point attribute function.\n    --  N is the attribute reference node, and Args is a list of arguments to\n-   --  be passed to the function call. Rtp is the root type of the floating\n-   --  point type involved (used to select the proper generic instantiation\n-   --  of the package containing the attribute routines). The Nam argument\n-   --  is the attribute processing routine to be called. This is normally\n-   --  the same as the attribute name, except in the Unaligned_Valid case.\n+   --  be passed to the function call. Pkg identifies the package containing\n+   --  the appropriate instantiation of System.Fat_Gen. Float arguments in Args\n+   --  have already been converted to the floating-point type for which Pkg was\n+   --  instantiated. The Nam argument is the relevant attribute processing\n+   --  routine to be called. This is the same as the attribute name, except in\n+   --  the Unaligned_Valid case.\n \n    procedure Expand_Fpt_Attribute_R (N : Node_Id);\n    --  This procedure expands a call to a floating-point attribute function\n@@ -123,6 +124,15 @@ package body Exp_Attr is\n    --  A reference to a type within its own scope is resolved to a reference\n    --  to the current instance of the type in its initialization procedure.\n \n+   procedure Find_Fat_Info\n+     (T        : Entity_Id;\n+      Fat_Type : out Entity_Id;\n+      Fat_Pkg  : out RE_Id);\n+   --  Given a floating-point type T, identifies the package containing the\n+   --  attributes for this type (returned in Fat_Pkg), and the corresponding\n+   --  type for which this package was instantiated from Fat_Gen. Error if T\n+   --  is not a floating-point type.\n+\n    function Find_Stream_Subprogram\n      (Typ : Entity_Id;\n       Nam : TSS_Name_Type) return Entity_Id;\n@@ -176,7 +186,7 @@ package body Exp_Attr is\n       if Check then\n          Insert_Action (N, Decl);\n       else\n-         Insert_Action (N, Decl, All_Checks);\n+         Insert_Action (N, Decl, Suppress => All_Checks);\n       end if;\n \n       if Installed then\n@@ -260,35 +270,24 @@ package body Exp_Attr is\n \n    procedure Expand_Fpt_Attribute\n      (N    : Node_Id;\n-      Rtp  : Entity_Id;\n+      Pkg  : RE_Id;\n       Nam  : Name_Id;\n       Args : List_Id)\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n-      Pkg : RE_Id;\n       Fnm : Node_Id;\n \n    begin\n-      --  The function name is the selected component Fat_xxx.yyy where xxx\n-      --  is the floating-point root type, and yyy is the argument Nam.\n+      --  The function name is the selected component Attr_xxx.yyy where\n+      --  Attr_xxx is the package name, and yyy is the argument Nam.\n \n       --  Note: it would be more usual to have separate RE entries for each\n       --  of the entities in the Fat packages, but first they have identical\n       --  names (so we would have to have lots of renaming declarations to\n       --  meet the normal RE rule of separate names for all runtime entities),\n       --  and second there would be an awful lot of them!\n \n-      if Rtp = Standard_Short_Float then\n-         Pkg := RE_Fat_Short_Float;\n-      elsif Rtp = Standard_Float then\n-         Pkg := RE_Fat_Float;\n-      elsif Rtp = Standard_Long_Float then\n-         Pkg := RE_Fat_Long_Float;\n-      else\n-         Pkg := RE_Fat_Long_Long_Float;\n-      end if;\n-\n       Fnm :=\n         Make_Selected_Component (Loc,\n           Prefix        => New_Reference_To (RTE (Pkg), Loc),\n@@ -302,7 +301,7 @@ package body Exp_Attr is\n       Rewrite (N,\n         Unchecked_Convert_To (Base_Type (Etype (N)),\n           Make_Function_Call (Loc,\n-            Name => Fnm,\n+            Name                   => Fnm,\n             Parameter_Associations => Args)));\n \n       Analyze_And_Resolve (N, Typ);\n@@ -318,12 +317,13 @@ package body Exp_Attr is\n \n    procedure Expand_Fpt_Attribute_R (N : Node_Id) is\n       E1  : constant Node_Id    := First (Expressions (N));\n-      Rtp : constant Entity_Id  := Root_Type (Etype (E1));\n-\n+      Ftp : Entity_Id;\n+      Pkg : RE_Id;\n    begin\n+      Find_Fat_Info (Etype (E1), Ftp, Pkg);\n       Expand_Fpt_Attribute\n-        (N, Rtp, Attribute_Name (N),\n-         New_List (Unchecked_Convert_To (Rtp, Relocate_Node (E1))));\n+        (N, Pkg, Attribute_Name (N),\n+         New_List (Unchecked_Convert_To (Ftp, Relocate_Node (E1))));\n    end Expand_Fpt_Attribute_R;\n \n    -----------------------------\n@@ -337,14 +337,15 @@ package body Exp_Attr is\n \n    procedure Expand_Fpt_Attribute_RI (N : Node_Id) is\n       E1  : constant Node_Id   := First (Expressions (N));\n-      Rtp : constant Entity_Id := Root_Type (Etype (E1));\n+      Ftp : Entity_Id;\n+      Pkg : RE_Id;\n       E2  : constant Node_Id   := Next (E1);\n-\n    begin\n+      Find_Fat_Info (Etype (E1), Ftp, Pkg);\n       Expand_Fpt_Attribute\n-        (N, Rtp, Attribute_Name (N),\n+        (N, Pkg, Attribute_Name (N),\n          New_List (\n-           Unchecked_Convert_To (Rtp, Relocate_Node (E1)),\n+           Unchecked_Convert_To (Ftp, Relocate_Node (E1)),\n            Unchecked_Convert_To (Standard_Integer, Relocate_Node (E2))));\n    end Expand_Fpt_Attribute_RI;\n \n@@ -358,15 +359,16 @@ package body Exp_Attr is\n \n    procedure Expand_Fpt_Attribute_RR (N : Node_Id) is\n       E1  : constant Node_Id   := First (Expressions (N));\n-      Rtp : constant Entity_Id := Root_Type (Etype (E1));\n+      Ftp : Entity_Id;\n+      Pkg : RE_Id;\n       E2  : constant Node_Id   := Next (E1);\n-\n    begin\n+      Find_Fat_Info (Etype (E1), Ftp, Pkg);\n       Expand_Fpt_Attribute\n-        (N, Rtp, Attribute_Name (N),\n+        (N, Pkg, Attribute_Name (N),\n          New_List (\n-           Unchecked_Convert_To (Rtp, Relocate_Node (E1)),\n-           Unchecked_Convert_To (Rtp, Relocate_Node (E2))));\n+           Unchecked_Convert_To (Ftp, Relocate_Node (E1)),\n+           Unchecked_Convert_To (Ftp, Relocate_Node (E2))));\n    end Expand_Fpt_Attribute_RR;\n \n    ----------------------------------\n@@ -1011,8 +1013,31 @@ package body Exp_Attr is\n \n       when Attribute_Callable => Callable :\n       begin\n-         Rewrite (N,\n-           Build_Call_With_Task (Pref, RTE (RE_Callable)));\n+         --  We have an object of a task interface class-wide type as a prefix\n+         --  to Callable. Generate:\n+\n+         --    callable (Pref._disp_get_task_id);\n+\n+         if Ada_Version >= Ada_05\n+           and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n+           and then Is_Interface      (Etype (Pref))\n+           and then Is_Task_Interface (Etype (Pref))\n+         then\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Callable), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      New_Copy_Tree (Pref),\n+                    Selector_Name =>\n+                      Make_Identifier (Loc, Name_uDisp_Get_Task_Id)))));\n+         else\n+            Rewrite (N,\n+              Build_Call_With_Task (Pref, RTE (RE_Callable)));\n+         end if;\n+\n          Analyze_And_Resolve (N, Standard_Boolean);\n       end Callable;\n \n@@ -1630,8 +1655,8 @@ package body Exp_Attr is\n \n       --  expands into\n \n-      --    Result_Type (System.Fore (Long_Long_Float (Type'First)),\n-      --                              Long_Long_Float (Type'Last))\n+      --    Result_Type (System.Fore (Universal_Real (Type'First)),\n+      --                              Universal_Real (Type'Last))\n \n       --  Note that we know that the type is a non-static subtype, or Fore\n       --  would have itself been computed dynamically in Eval_Attribute.\n@@ -1647,12 +1672,12 @@ package body Exp_Attr is\n                Name => New_Reference_To (RTE (RE_Fore), Loc),\n \n                Parameter_Associations => New_List (\n-                 Convert_To (Standard_Long_Long_Float,\n+                 Convert_To (Universal_Real,\n                    Make_Attribute_Reference (Loc,\n                      Prefix => New_Reference_To (Ptyp, Loc),\n                      Attribute_Name => Name_First)),\n \n-                 Convert_To (Standard_Long_Long_Float,\n+                 Convert_To (Universal_Real,\n                    Make_Attribute_Reference (Loc,\n                      Prefix => New_Reference_To (Ptyp, Loc),\n                      Attribute_Name => Name_Last))))));\n@@ -2283,6 +2308,17 @@ package body Exp_Attr is\n       when Attribute_Machine =>\n          Expand_Fpt_Attribute_R (N);\n \n+      ----------------------\n+      -- Machine_Rounding --\n+      ----------------------\n+\n+      --  Transforms 'Machine_Rounding into a call to the floating-point\n+      --  attribute function Machine_Rounding in Fat_xxx (where xxx is the root\n+      --  type).\n+\n+      when Attribute_Machine_Rounding =>\n+         Expand_Fpt_Attribute_R (N);\n+\n       ------------------\n       -- Machine_Size --\n       ------------------\n@@ -2425,7 +2461,7 @@ package body Exp_Attr is\n \n          end if;\n \n-         Analyze_And_Resolve (N, Btyp, All_Checks);\n+         Analyze_And_Resolve (N, Btyp, Suppress => All_Checks);\n       end Mod_Case;\n \n       -----------\n@@ -3211,7 +3247,7 @@ package body Exp_Attr is\n             Rewrite (Prefix (N), New_Occurrence_Of (Entity (Pref), Loc));\n             return;\n \n-         --  For x'Size applied to an object of a class-wide type, transform\n+         --  For X'Size applied to an object of a class-wide type, transform\n          --  X'Size into a call to the primitive operation _Size applied to X.\n \n          elsif Is_Class_Wide_Type (Ptyp) then\n@@ -3268,8 +3304,8 @@ package body Exp_Attr is\n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n \n-            --  If we have Size applied to a formal parameter, that is a\n-            --  packed array subtype, then apply size to the actual subtype.\n+            --  If Size is applied to a formal parameter that is of a packed\n+            --  array subtype, then apply Size to the actual subtype.\n \n             if Is_Entity_Name (Pref)\n               and then Is_Formal (Entity (Pref))\n@@ -3284,6 +3320,20 @@ package body Exp_Attr is\n                Analyze_And_Resolve (N, Typ);\n             end if;\n \n+            --  If Size is applied to a dereference of an access to\n+            --  unconstrained packed array, GIGI needs to see its\n+            --  unconstrained nominal type, but also a hint to the actual\n+            --  constrained type.\n+\n+            if Nkind (Pref) = N_Explicit_Dereference\n+              and then Is_Array_Type (Etype (Pref))\n+              and then not Is_Constrained (Etype (Pref))\n+              and then Is_Packed (Etype (Pref))\n+            then\n+               Set_Actual_Designated_Subtype (Pref,\n+                 Get_Actual_Subtype (Pref));\n+            end if;\n+\n             return;\n          end if;\n \n@@ -3590,7 +3640,28 @@ package body Exp_Attr is\n \n       when Attribute_Terminated => Terminated :\n       begin\n-         if Restricted_Profile then\n+         --  The prefix of Terminated is of a task interface class-wide type.\n+         --  Generate:\n+\n+         --    terminated (Pref._disp_get_task_id);\n+\n+         if Ada_Version >= Ada_05\n+           and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n+           and then Is_Interface      (Etype (Pref))\n+           and then Is_Task_Interface (Etype (Pref))\n+         then\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name =>\n+                  New_Reference_To (RTE (RE_Terminated), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      New_Copy_Tree (Pref),\n+                    Selector_Name =>\n+                      Make_Identifier (Loc, Name_uDisp_Get_Task_Id)))));\n+\n+         elsif Restricted_Profile then\n             Rewrite (N,\n               Build_Call_With_Task (Pref, RTE (RE_Restricted_Terminated)));\n \n@@ -3641,7 +3712,26 @@ package body Exp_Attr is\n       ----------------------\n \n       when Attribute_Unchecked_Access =>\n-         Expand_Access_To_Type (N);\n+\n+         --  Ada 2005 (AI-251): If the designated type is an interface, then\n+         --  rewrite the referenced object as a conversion to force the\n+         --  displacement of the pointer to the secondary dispatch table.\n+\n+         if Is_Interface (Directly_Designated_Type (Btyp)) then\n+            declare\n+               Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n+               Conversion : Node_Id;\n+            begin\n+               Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+               Rewrite (N, Conversion);\n+               Analyze_And_Resolve (N, Typ);\n+            end;\n+\n+         --  Otherwise this is like normal Access without a check\n+\n+         else\n+            Expand_Access_To_Type (N);\n+         end if;\n \n       -----------------\n       -- UET_Address --\n@@ -3687,7 +3777,26 @@ package body Exp_Attr is\n       -------------------------\n \n       when Attribute_Unrestricted_Access =>\n-         Expand_Access_To_Type (N);\n+\n+         --  Ada 2005 (AI-251): If the designated type is an interface, then\n+         --  rewrite the referenced object as a conversion to force the\n+         --  displacement of the pointer to the secondary dispatch table.\n+\n+         if Is_Interface (Directly_Designated_Type (Btyp)) then\n+            declare\n+               Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n+               Conversion : Node_Id;\n+            begin\n+               Conversion := Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+               Rewrite (N, Conversion);\n+               Analyze_And_Resolve (N, Typ);\n+            end;\n+\n+         --  Otherwise this is like Access without a check\n+\n+         else\n+            Expand_Access_To_Type (N);\n+         end if;\n \n       ---------------\n       -- VADS_Size --\n@@ -3824,43 +3933,50 @@ package body Exp_Attr is\n \n          if Is_Floating_Point_Type (Ptyp) then\n             declare\n-               Rtp : constant Entity_Id := Root_Type (Etype (Pref));\n+               Pkg : RE_Id;\n+               Ftp : Entity_Id;\n \n             begin\n                --  For vax fpt types, call appropriate routine in special vax\n                --  floating point unit. We do not have to worry about loads in\n                --  this case, since these types have no signalling NaN's.\n \n-               if Vax_Float (Rtp) then\n+               if Vax_Float (Btyp) then\n                   Expand_Vax_Valid (N);\n \n-               --  If the floating-point object might be unaligned, we need\n-               --  to call the special routine Unaligned_Valid, which makes\n-               --  the needed copy, being careful not to load the value into\n-               --  any floating-point register. The argument in this case is\n-               --  obj'Address (see Unchecked_Valid routine in s-fatgen.ads).\n+               --  Non VAX float case\n \n-               elsif Is_Possibly_Unaligned_Object (Pref) then\n-                  Set_Attribute_Name (N, Name_Unaligned_Valid);\n-                  Expand_Fpt_Attribute\n-                    (N, Rtp, Name_Unaligned_Valid,\n-                     New_List (\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix         => Relocate_Node (Pref),\n-                         Attribute_Name => Name_Address)));\n+               else\n+                  Find_Fat_Info (Etype (Pref), Ftp, Pkg);\n+\n+                  --  If the floating-point object might be unaligned, we need\n+                  --  to call the special routine Unaligned_Valid, which makes\n+                  --  the needed copy, being careful not to load the value into\n+                  --  any floating-point register. The argument in this case is\n+                  --  obj'Address (see Unchecked_Valid routine in Fat_Gen).\n+\n+                  if Is_Possibly_Unaligned_Object (Pref) then\n+                     Set_Attribute_Name (N, Name_Unaligned_Valid);\n+                     Expand_Fpt_Attribute\n+                       (N, Pkg, Name_Unaligned_Valid,\n+                        New_List (\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Relocate_Node (Pref),\n+                            Attribute_Name => Name_Address)));\n \n-               --  In the normal case where we are sure the object is aligned,\n-               --  we generate a call to Valid, and the argument in this case\n-               --  is obj'Unrestricted_Access (after converting obj to the\n-               --  right floating-point type).\n+                  --  In the normal case where we are sure the object is\n+                  --  aligned, we generate a call to Valid, and the argument in\n+                  --  this case is obj'Unrestricted_Access (after converting\n+                  --  obj to the right floating-point type).\n \n-               else\n-                  Expand_Fpt_Attribute\n-                    (N, Rtp, Name_Valid,\n-                     New_List (\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix         => Unchecked_Convert_To (Rtp, Pref),\n-                         Attribute_Name => Name_Unrestricted_Access)));\n+                  else\n+                     Expand_Fpt_Attribute\n+                       (N, Pkg, Name_Valid,\n+                        New_List (\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Unchecked_Convert_To (Ftp, Pref),\n+                            Attribute_Name => Name_Unrestricted_Access)));\n+                  end if;\n                end if;\n \n                --  One more task, we still need a range check. Required\n@@ -4488,6 +4604,78 @@ package body Exp_Attr is\n           Reason => CE_Overflow_Check_Failed));\n    end Expand_Pred_Succ;\n \n+   -------------------\n+   -- Find_Fat_Info --\n+   -------------------\n+\n+   procedure Find_Fat_Info\n+     (T        : Entity_Id;\n+      Fat_Type : out Entity_Id;\n+      Fat_Pkg  : out RE_Id)\n+   is\n+      Btyp : constant Entity_Id := Base_Type (T);\n+      Rtyp : constant Entity_Id := Root_Type (T);\n+      Digs : constant Nat       := UI_To_Int (Digits_Value (Btyp));\n+\n+   begin\n+      --  If the base type is VAX float, then get appropriate VAX float type\n+\n+      if Vax_Float (Btyp) then\n+         case Digs is\n+            when 6 =>\n+               Fat_Type := RTE (RE_Fat_VAX_F);\n+               Fat_Pkg  := RE_Attr_VAX_F_Float;\n+\n+            when 9 =>\n+               Fat_Type := RTE (RE_Fat_VAX_D);\n+               Fat_Pkg  := RE_Attr_VAX_D_Float;\n+\n+            when 15 =>\n+               Fat_Type := RTE (RE_Fat_VAX_G);\n+               Fat_Pkg  := RE_Attr_VAX_G_Float;\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+      --  If root type is VAX float, this is the case where the library has\n+      --  been recompiled in VAX float mode, and we have an IEEE float type.\n+      --  This is when we use the special IEEE Fat packages.\n+\n+      elsif Vax_Float (Rtyp) then\n+         case Digs is\n+            when 6 =>\n+               Fat_Type := RTE (RE_Fat_IEEE_Short);\n+               Fat_Pkg  := RE_Attr_IEEE_Short;\n+\n+            when 15 =>\n+               Fat_Type := RTE (RE_Fat_IEEE_Long);\n+               Fat_Pkg  := RE_Attr_IEEE_Long;\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+\n+      --  If neither the base type nor the root type is VAX_Float then VAX\n+      --  float is out of the picture, and we can just use the root type.\n+\n+      else\n+         Fat_Type := Rtyp;\n+\n+         if Fat_Type = Standard_Short_Float then\n+            Fat_Pkg := RE_Attr_Short_Float;\n+         elsif Fat_Type = Standard_Float then\n+            Fat_Pkg := RE_Attr_Float;\n+         elsif Fat_Type = Standard_Long_Float then\n+            Fat_Pkg := RE_Attr_Long_Float;\n+         elsif Fat_Type = Standard_Long_Long_Float then\n+            Fat_Pkg := RE_Attr_Long_Long_Float;\n+         else\n+            raise Program_Error;\n+         end if;\n+      end if;\n+   end Find_Fat_Info;\n+\n    ----------------------------\n    -- Find_Stream_Subprogram --\n    ----------------------------"}, {"sha": "9d4b5042d69c86c7a9a35843baa07bc58f1f8b72", "filename": "gcc/ada/s-fatgen.adb", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.adb?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -99,10 +99,8 @@ package body System.Fat_Gen is\n    begin\n       if Towards = X then\n          return X;\n-\n       elsif Towards > X then\n          return Succ (X);\n-\n       else\n          return Pred (X);\n       end if;\n@@ -114,14 +112,11 @@ package body System.Fat_Gen is\n \n    function Ceiling (X : T) return T is\n       XT : constant T := Truncation (X);\n-\n    begin\n       if X <= 0.0 then\n          return XT;\n-\n       elsif X = XT then\n          return X;\n-\n       else\n          return XT + 1.0;\n       end if;\n@@ -175,7 +170,7 @@ package body System.Fat_Gen is\n          --  T'Machine_Emin - T'Machine_Mantissa, which would preserve\n          --  monotonicity of the exponent function ???\n \n-      --  Check for infinities, transfinites, whatnot.\n+      --  Check for infinities, transfinites, whatnot\n \n       elsif X > T'Safe_Last then\n          Frac := Invrad;\n@@ -193,7 +188,7 @@ package body System.Fat_Gen is\n             Ax : T  := abs X;\n             Ex : UI := 0;\n \n-         --  Ax * Rad ** Ex is invariant.\n+         --  Ax * Rad ** Ex is invariant\n \n          begin\n             if Ax >= 1.0 then\n@@ -256,7 +251,6 @@ package body System.Fat_Gen is\n    function Exponent (X : T) return UI is\n       X_Frac : T;\n       X_Exp  : UI;\n-\n    begin\n       Decompose (X, X_Frac, X_Exp);\n       return X_Exp;\n@@ -268,14 +262,11 @@ package body System.Fat_Gen is\n \n    function Floor (X : T) return T is\n       XT : constant T := Truncation (X);\n-\n    begin\n       if X >= 0.0 then\n          return XT;\n-\n       elsif XT = X then\n          return X;\n-\n       else\n          return XT - 1.0;\n       end if;\n@@ -288,7 +279,6 @@ package body System.Fat_Gen is\n    function Fraction (X : T) return T is\n       X_Frac : T;\n       X_Exp  : UI;\n-\n    begin\n       Decompose (X, X_Frac, X_Exp);\n       return X_Frac;\n@@ -366,6 +356,38 @@ package body System.Fat_Gen is\n       return Temp;\n    end Machine;\n \n+   ----------------------\n+   -- Machine_Rounding --\n+   ----------------------\n+\n+   --  For now, the implementation is identical to that of Rounding, which is\n+   --  a permissible behavior, but is not the most efficient possible approach.\n+\n+   function Machine_Rounding (X : T) return T is\n+      Result : T;\n+      Tail   : T;\n+\n+   begin\n+      Result := Truncation (abs X);\n+      Tail   := abs X - Result;\n+\n+      if Tail >= 0.5  then\n+         Result := Result + 1.0;\n+      end if;\n+\n+      if X > 0.0 then\n+         return Result;\n+\n+      elsif X < 0.0 then\n+         return -Result;\n+\n+      --  For zero case, make sure sign of zero is preserved\n+\n+      else\n+         return X;\n+      end if;\n+   end Machine_Rounding;\n+\n    -----------\n    -- Model --\n    -----------\n@@ -542,7 +564,7 @@ package body System.Fat_Gen is\n          return X;\n       end if;\n \n-      --  Nonzero x. essentially, just multiply repeatedly by Rad ** (+-2**n).\n+      --  Nonzero x. essentially, just multiply repeatedly by Rad ** (+-2**n)\n \n       declare\n          Y  : T  := X;\n@@ -587,6 +609,7 @@ package body System.Fat_Gen is\n                end if;\n \n                --  0 <= Ex < Log_Power (N)\n+\n             end loop;\n \n             --  Ex = 0\n@@ -652,7 +675,7 @@ package body System.Fat_Gen is\n \n    --  The basic approach is to compute\n \n-   --    T'Machine (RM1 + N) - RM1.\n+   --    T'Machine (RM1 + N) - RM1\n \n    --  where N >= 0.0 and RM1 = radix ** (mantissa - 1)\n \n@@ -693,7 +716,6 @@ package body System.Fat_Gen is\n             return X;\n          end if;\n       end if;\n-\n    end Truncation;\n \n    -----------------------\n@@ -727,13 +749,16 @@ package body System.Fat_Gen is\n       else\n          return X;\n       end if;\n-\n    end Unbiased_Rounding;\n \n    -----------\n    -- Valid --\n    -----------\n \n+   --  Note: this routine does not work for VAX float. We compensate for this\n+   --  in Exp_Attr by using the Valid functions in Vax_Float_Operations rather\n+   --  than the corresponding instantiation of this function.\n+\n    function Valid (X : access T) return Boolean is\n \n       IEEE_Emin : constant Integer := T'Machine_Emin - 1;\n@@ -744,17 +769,17 @@ package body System.Fat_Gen is\n       subtype IEEE_Exponent_Range is\n         Integer range IEEE_Emin - 1 .. IEEE_Emax + 1;\n \n-      --  The implementation of this floating point attribute uses\n-      --  a representation type Float_Rep that allows direct access to\n-      --  the exponent and mantissa parts of a floating point number.\n+      --  The implementation of this floating point attribute uses a\n+      --  representation type Float_Rep that allows direct access to the\n+      --  exponent and mantissa parts of a floating point number.\n \n       --  The Float_Rep type is an array of Float_Word elements. This\n-      --  representation is chosen to make it possible to size the\n-      --  type based on a generic parameter. Since the array size is\n-      --  known at compile-time, efficient code can still be generated.\n-      --  The size of Float_Word elements should be large enough to allow\n-      --  accessing the exponent in one read, but small enough so that all\n-      --  floating point object sizes are a multiple of the Float_Word'Size.\n+      --  representation is chosen to make it possible to size the type based\n+      --  on a generic parameter. Since the array size is known at compile\n+      --  time, efficient code can still be generated. The size of Float_Word\n+      --  elements should be large enough to allow accessing the exponent in\n+      --  one read, but small enough so that all floating point object sizes\n+      --  are a multiple of the Float_Word'Size.\n \n       --  The following conditions must be met for all possible\n       --  instantiations of the attributes package:\n@@ -764,9 +789,9 @@ package body System.Fat_Gen is\n       --    - The exponent and sign are completely contained in a single\n       --      component of Float_Rep, named Most_Significant_Word (MSW).\n \n-      --    - The sign occupies the most significant bit of the MSW\n-      --      and the exponent is in the following bits.\n-      --      Unused bits (if any) are in the least significant part.\n+      --    - The sign occupies the most significant bit of the MSW and the\n+      --      exponent is in the following bits. Unused bits (if any) are in\n+      --      the least significant part.\n \n       type Float_Word is mod 2**Positive'Min (System.Word_Size, 32);\n       type Rep_Index is range 0 .. 7;\n@@ -775,12 +800,12 @@ package body System.Fat_Gen is\n          (T'Size + Float_Word'Size - 1) / Float_Word'Size;\n       Rep_Last  : constant Rep_Index := Rep_Index'Min\n         (Rep_Index (Rep_Words - 1), (T'Mantissa + 16) / Float_Word'Size);\n-      --  Determine the number of Float_Words needed for representing\n-      --  the entire floating-poinit value. Do not take into account\n-      --  excessive padding, as occurs on IA-64 where 80 bits floats get\n-      --  padded to 128 bits. In general, the exponent field cannot\n-      --  be larger than 15 bits, even for 128-bit floating-poin t types,\n-      --  so the final format size won't be larger than T'Mantissa + 16.\n+      --  Determine the number of Float_Words needed for representing the\n+      --  entire floating-point value. Do not take into account excessive\n+      --  padding, as occurs on IA-64 where 80 bits floats get padded to 128\n+      --  bits. In general, the exponent field cannot be larger than 15 bits,\n+      --  even for 128-bit floating-poin t types, so the final format size\n+      --  won't be larger than T'Mantissa + 16.\n \n       type Float_Rep is\n          array (Rep_Index range 0 .. Rep_Index (Rep_Words - 1)) of Float_Word;\n@@ -794,26 +819,26 @@ package body System.Fat_Gen is\n \n       Most_Significant_Word : constant Rep_Index :=\n                                 Rep_Last * Standard'Default_Bit_Order;\n-      --  Finding the location of the Exponent_Word is a bit tricky.\n-      --  In general we assume Word_Order = Bit_Order.\n-      --  This expression needs to be refined for VMS.\n+      --  Finding the location of the Exponent_Word is a bit tricky. In general\n+      --  we assume Word_Order = Bit_Order. This expression needs to be refined\n+      --  for VMS.\n \n       Exponent_Factor : constant Float_Word :=\n                           2**(Float_Word'Size - 1) /\n                             Float_Word (IEEE_Emax - IEEE_Emin + 3) *\n                               Boolean'Pos (Most_Significant_Word /= 2) +\n                                 Boolean'Pos (Most_Significant_Word = 2);\n-      --  Factor that the extracted exponent needs to be divided by\n-      --  to be in range 0 .. IEEE_Emax - IEEE_Emin + 2.\n-      --  Special kludge: Exponent_Factor is 1 for x86/IA64 double extended\n-      --  as GCC adds unused bits to the type.\n+      --  Factor that the extracted exponent needs to be divided by to be in\n+      --  range 0 .. IEEE_Emax - IEEE_Emin + 2. Special kludge: Exponent_Factor\n+      --  is 1 for x86/IA64 double extended as GCC adds unused bits to the\n+      --  type.\n \n       Exponent_Mask : constant Float_Word :=\n                         Float_Word (IEEE_Emax - IEEE_Emin + 2) *\n                           Exponent_Factor;\n-      --  Value needed to mask out the exponent field.\n-      --  This assumes that the range IEEE_Emin - 1 .. IEEE_Emax + 1\n-      --  contains 2**N values, for some N in Natural.\n+      --  Value needed to mask out the exponent field. This assumes that the\n+      --  range IEEE_Emin - 1 .. IEEE_Emax + contains 2**N values, for some N\n+      --  in Natural.\n \n       function To_Float is new Ada.Unchecked_Conversion (Float_Rep, T);\n \n@@ -834,17 +859,17 @@ package body System.Fat_Gen is\n              Integer ((R (Most_Significant_Word) and Exponent_Mask) /\n                                                         Exponent_Factor)\n                - IEEE_Bias;\n-      --  Mask/Shift T to only get bits from the exponent\n-      --  Then convert biased value to integer value.\n+      --  Mask/Shift T to only get bits from the exponent. Then convert biased\n+      --  value to integer value.\n \n       SR : Float_Rep;\n       --  Float_Rep representation of significant of X.all\n \n    begin\n       if T'Denorm then\n \n-         --  All denormalized numbers are valid, so only invalid numbers\n-         --  are overflows and NaN's, both with exponent = Emax + 1.\n+         --  All denormalized numbers are valid, so only invalid numbers are\n+         --  overflows and NaN's, both with exponent = Emax + 1.\n \n          return E /= IEEE_Emax + 1;\n "}, {"sha": "83b6f06446136adf99d6a79fd447f83260712f35", "filename": "gcc/ada/s-fatgen.ads", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-fatgen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-fatgen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fatgen.ads?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -71,6 +71,8 @@ package System.Fat_Gen is\n \n    function Machine           (X : T)                       return T;\n \n+   function Machine_Rounding  (X : T)                       return T;\n+\n    function Model             (X : T)                       return T;\n \n    function Pred              (X : T)                       return T;\n@@ -95,6 +97,8 @@ package System.Fat_Gen is\n    --  register, and the whole point of 'Valid is to prevent exceptions.\n    --  Note that the object of type T must have the natural alignment\n    --  for type T. See Unaligned_Valid for further discussion.\n+   --\n+   --  Note: this routine does not work for Vax_Float ???\n \n    function Unaligned_Valid (A : System.Address) return Boolean;\n    --  This version of Valid is used if the floating-point value to\n@@ -112,11 +116,16 @@ package System.Fat_Gen is\n    --  not require strict alignment (e.g. the ia32/x86), since on a\n    --  target not requiring strict alignment, it is fine to pass a\n    --  non-aligned value to the standard Valid routine.\n+   --\n+   --  Note: this routine does not work for Vax_Float ???\n \n private\n    pragma Inline (Machine);\n    pragma Inline (Model);\n-   pragma Inline_Always (Valid);\n-   pragma Inline_Always (Unaligned_Valid);\n+\n+   --  Note: previously the validity checking subprograms (Unaligned_Valid and\n+   --  Valid) were also inlined, but this was changed since there were some\n+   --  problems with this inlining in optimized mode, and in any case it seems\n+   --  better to avoid this inlining (space and robustness considerations).\n \n end System.Fat_Gen;"}, {"sha": "5ab772d447721a3fba60399ce231a4254ce47072", "filename": "gcc/ada/s-vaflop-vms-alpha.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop-vms-alpha.adb?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -626,7 +626,7 @@ package body System.Vax_Float_Operations is\n    --  accurate, but is good enough in practice.\n \n    function Valid_D (Arg : D) return Boolean is\n-      Val : T := G_To_T (D_To_G (Arg));\n+      Val : constant T := G_To_T (D_To_G (Arg));\n    begin\n       return Val'Valid;\n    end Valid_D;\n@@ -639,7 +639,7 @@ package body System.Vax_Float_Operations is\n    --  accurate, but is good enough in practice.\n \n    function Valid_F (Arg : F) return Boolean is\n-      Val : S := F_To_S (Arg);\n+      Val : constant S := F_To_S (Arg);\n    begin\n       return Val'Valid;\n    end Valid_F;\n@@ -652,7 +652,7 @@ package body System.Vax_Float_Operations is\n    --  accurate, but is good enough in practice.\n \n    function Valid_G (Arg : G) return Boolean is\n-      Val : T := G_To_T (Arg);\n+      Val : constant T := G_To_T (Arg);\n    begin\n       return Val'Valid;\n    end Valid_G;"}, {"sha": "e0c05fd62ae3bbc13fd0285c8539709d1ddd7a56", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -492,9 +492,16 @@ package body Sem_Attr is\n          --  accesses are allowed (references to the current type instance).\n \n          if Is_Entity_Name (P) then\n-            Scop := Current_Scope;\n             Typ := Entity (P);\n \n+            --  The reference may appear in an aggregate that has been expanded\n+            --  into a loop. Locate scope of type definition, if any.\n+\n+            Scop := Current_Scope;\n+            while Ekind (Scop) = E_Loop loop\n+               Scop := Scope (Scop);\n+            end loop;\n+\n             if Is_Type (Typ) then\n \n                --  OK if we are within the scope of a limited type\n@@ -516,6 +523,7 @@ package body Sem_Attr is\n                      loop\n                         Q := Parent (Q);\n                      end loop;\n+\n                      if Present (Q) then\n                         Set_Has_Per_Object_Constraint (\n                           Defining_Identifier (Q), True);\n@@ -585,11 +593,9 @@ package body Sem_Attr is\n             declare\n                Index : Interp_Index;\n                It    : Interp;\n-\n             begin\n                Set_Etype (N, Any_Type);\n                Get_First_Interp (P, Index, It);\n-\n                while Present (It.Typ) loop\n                   Acc_Type := Build_Access_Object_Type (It.Typ);\n                   Add_One_Interp (N, Acc_Type, Acc_Type);\n@@ -1373,13 +1379,27 @@ package body Sem_Attr is\n       begin\n          Analyze (P);\n \n+         --  Ada 2005 (AI-345): Attribute 'Terminated can be applied to\n+         --  task interface class-wide types.\n+\n          if Is_Task_Type (Etype (P))\n            or else (Is_Access_Type (Etype (P))\n-              and then Is_Task_Type (Designated_Type (Etype (P))))\n+                      and then Is_Task_Type (Designated_Type (Etype (P))))\n+           or else (Ada_Version >= Ada_05\n+                      and then Ekind (Etype (P)) = E_Class_Wide_Type\n+                      and then Is_Interface (Etype (P))\n+                      and then Is_Task_Interface (Etype (P)))\n          then\n             Resolve (P);\n+\n          else\n-            Error_Attr (\"prefix of % attribute must be a task\", P);\n+            if Ada_Version >= Ada_05 then\n+               Error_Attr (\"prefix of % attribute must be a task or a task \"\n+                           & \"interface class-wide object\", P);\n+\n+            else\n+               Error_Attr (\"prefix of % attribute must be a task\", P);\n+            end if;\n          end if;\n       end Check_Task_Prefix;\n \n@@ -2793,16 +2813,28 @@ package body Sem_Attr is\n          if Etype (P) =  Standard_Exception_Type then\n             Set_Etype (N, RTE (RE_Exception_Id));\n \n+         --  Ada 2005 (AI-345): Attribute 'Identity may be applied to\n+         --  task interface class-wide types.\n+\n          elsif Is_Task_Type (Etype (P))\n            or else (Is_Access_Type (Etype (P))\n-              and then Is_Task_Type (Designated_Type (Etype (P))))\n+                      and then Is_Task_Type (Designated_Type (Etype (P))))\n+           or else (Ada_Version >= Ada_05\n+                      and then Ekind (Etype (P)) = E_Class_Wide_Type\n+                      and then Is_Interface (Etype (P))\n+                      and then Is_Task_Interface (Etype (P)))\n          then\n             Resolve (P);\n             Set_Etype (N, RTE (RO_AT_Task_Id));\n \n          else\n-            Error_Attr (\"prefix of % attribute must be a task or an \"\n-              & \"exception\", P);\n+            if Ada_Version >= Ada_05 then\n+               Error_Attr (\"prefix of % attribute must be an exception, a \"\n+                         & \"task or a task interface class-wide object\", P);\n+            else\n+               Error_Attr (\"prefix of % attribute must be a task or an \"\n+                         & \"exception\", P);\n+            end if;\n          end if;\n \n       -----------\n@@ -2962,6 +2994,15 @@ package body Sem_Attr is\n          Check_E0;\n          Set_Etype (N, Universal_Integer);\n \n+      ----------------------\n+      -- Machine_Rounding --\n+      ----------------------\n+\n+      when Attribute_Machine_Rounding =>\n+         Check_Floating_Point_Type_1;\n+         Set_Etype (N, P_Base_Type);\n+         Resolve (E1, P_Base_Type);\n+\n       --------------------\n       -- Machine_Rounds --\n       --------------------\n@@ -5481,6 +5522,20 @@ package body Sem_Attr is\n             Fold_Uint (N, Uint_2, True);\n          end if;\n \n+      ----------------------\n+      -- Machine_Rounding --\n+      ----------------------\n+\n+      --  Note: for the folding case, it is fine to treat Machine_Rounding\n+      --  exactly the same way as Rounding, since this is one of the allowed\n+      --  behaviors, and performance is not an issue here. It might be a bit\n+      --  better to give the same result as it would give at run-time, even\n+      --  though the non-determinism is certainly permitted.\n+\n+      when Attribute_Machine_Rounding =>\n+         Fold_Ureal (N,\n+           Eval_Fat.Rounding (P_Root_Type, Expr_Value_R (E1)), Static);\n+\n       --------------------\n       -- Machine_Rounds --\n       --------------------\n@@ -6243,7 +6298,6 @@ package body Sem_Attr is\n          end if;\n \n          Rewrite (N, New_Occurrence_Of (RTE (Id), Loc));\n-\n       end Type_Class;\n \n       -----------------------\n@@ -7685,12 +7739,19 @@ package body Sem_Attr is\n          return True;\n       end if;\n \n-      if Nam = TSS_Stream_Input then\n-         return Ada_Version >= Ada_05\n-           and then Stream_Attribute_Available (Etyp, TSS_Stream_Read);\n-      elsif Nam = TSS_Stream_Output then\n-         return Ada_Version >= Ada_05\n-           and then Stream_Attribute_Available (Etyp, TSS_Stream_Write);\n+      --  In Ada 2005, Input can invoke Read, and Output can invoke Write\n+\n+      if Nam = TSS_Stream_Input\n+        and then Ada_Version >= Ada_05\n+        and then Stream_Attribute_Available (Etyp, TSS_Stream_Read)\n+      then\n+         return True;\n+\n+      elsif Nam = TSS_Stream_Output\n+        and then Ada_Version >= Ada_05\n+        and then Stream_Attribute_Available (Etyp, TSS_Stream_Write)\n+      then\n+         return True;\n       end if;\n \n       --  Case of Read and Write: check for attribute definition clause that"}, {"sha": "7b0c2ee5d0aaea464901cee7e3b76c149e8048ef", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f01153ab91c1e9e5e5273b8cb7e85e2a105b24/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=65f01153ab91c1e9e5e5273b8cb7e85e2a105b24", "patch": "@@ -95,91 +95,92 @@ extern unsigned char Get_Attribute_Id (int);\n #define  Attr_Machine_Mantissa              47\n #define  Attr_Machine_Overflows             48\n #define  Attr_Machine_Radix                 49\n-#define  Attr_Machine_Rounds                50\n-#define  Attr_Machine_Size                  51\n-#define  Attr_Mantissa                      52\n-#define  Attr_Max_Size_In_Storage_Elements  53\n-#define  Attr_Maximum_Alignment             54\n-#define  Attr_Mechanism_Code                55\n-#define  Attr_Mod                           56\n-#define  Attr_Model_Emin                    57\n-#define  Attr_Model_Epsilon                 58\n-#define  Attr_Model_Mantissa                59\n-#define  Attr_Model_Small                   60\n-#define  Attr_Modulus                       61\n-#define  Attr_Null_Parameter                62\n-#define  Attr_Object_Size                   63\n-#define  Attr_Partition_ID                  64\n-#define  Attr_Passed_By_Reference           65\n-#define  Attr_Pool_Address                  66\n-#define  Attr_Pos                           67\n-#define  Attr_Position                      68\n-#define  Attr_Range                         69\n-#define  Attr_Range_Length                  70\n-#define  Attr_Round                         71\n-#define  Attr_Safe_Emax                     72\n-#define  Attr_Safe_First                    73\n-#define  Attr_Safe_Large                    74\n-#define  Attr_Safe_Last                     75\n-#define  Attr_Safe_Small                    76\n-#define  Attr_Scale                         77\n-#define  Attr_Scaling                       78\n-#define  Attr_Signed_Zeros                  79\n-#define  Attr_Size                          80\n-#define  Attr_Small                         81\n-#define  Attr_Storage_Size                  82\n-#define  Attr_Storage_Unit                  83\n-#define  Attr_Stream_Size                   84\n-#define  Attr_Tag                           85\n-#define  Attr_Target_Name                   86\n-#define  Attr_Terminated                    87\n-#define  Attr_To_Address                    88\n-#define  Attr_Type_Class                    89\n-#define  Attr_UET_Address                   90\n-#define  Attr_Unbiased_Rounding             91\n-#define  Attr_Unchecked_Access              92\n-#define  Attr_Unconstrained_Array           93\n-#define  Attr_Universal_Literal_String      94\n-#define  Attr_Unrestricted_Access           95\n-#define  Attr_VADS_Size                     96\n-#define  Attr_Val                           97\n-#define  Attr_Valid                         98\n-#define  Attr_Value_Size                    99\n-#define  Attr_Version                       100\n-#define  Attr_Wchar_T_Size                  101\n-#define  Attr_Wide_Wide_Width               102\n-#define  Attr_Wide_Width                    103\n-#define  Attr_Width                         104\n-#define  Attr_Word_Size                     105\n-#define  Attr_Adjacent                      106\n-#define  Attr_Ceiling                       107\n-#define  Attr_Copy_Sign                     108\n-#define  Attr_Floor                         109\n-#define  Attr_Fraction                      110\n-#define  Attr_Image                         111\n-#define  Attr_Input                         112\n-#define  Attr_Machine                       113\n-#define  Attr_Max                           114\n-#define  Attr_Min                           115\n-#define  Attr_Model                         116\n-#define  Attr_Pred                          117\n-#define  Attr_Remainder                     118\n-#define  Attr_Rounding                      119\n-#define  Attr_Succ                          120\n-#define  Attr_Truncation                    121\n-#define  Attr_Value                         122\n-#define  Attr_Wide_Image                    123\n-#define  Attr_Wide_Wide_Image               124\n-#define  Attr_Wide_Value                    125\n-#define  Attr_Wide_Wide_Value               126\n-#define  Attr_Output                        127\n-#define  Attr_Read                          128\n-#define  Attr_Write                         129\n-#define  Attr_Elab_Body                     130\n-#define  Attr_Elab_Spec                     131\n-#define  Attr_Storage_Pool                  132\n-#define  Attr_Base                          133\n-#define  Attr_Class                         134\n+#define  Attr_Machine_Rounding              50\n+#define  Attr_Machine_Rounds                51\n+#define  Attr_Machine_Size                  52\n+#define  Attr_Mantissa                      53\n+#define  Attr_Max_Size_In_Storage_Elements  54\n+#define  Attr_Maximum_Alignment             55\n+#define  Attr_Mechanism_Code                56\n+#define  Attr_Mod                           57\n+#define  Attr_Model_Emin                    58\n+#define  Attr_Model_Epsilon                 59\n+#define  Attr_Model_Mantissa                60\n+#define  Attr_Model_Small                   61\n+#define  Attr_Modulus                       62\n+#define  Attr_Null_Parameter                63\n+#define  Attr_Object_Size                   64\n+#define  Attr_Partition_ID                  65\n+#define  Attr_Passed_By_Reference           66\n+#define  Attr_Pool_Address                  67\n+#define  Attr_Pos                           68\n+#define  Attr_Position                      69\n+#define  Attr_Range                         70\n+#define  Attr_Range_Length                  71\n+#define  Attr_Round                         72\n+#define  Attr_Safe_Emax                     73\n+#define  Attr_Safe_First                    74\n+#define  Attr_Safe_Large                    75\n+#define  Attr_Safe_Last                     76\n+#define  Attr_Safe_Small                    77\n+#define  Attr_Scale                         78\n+#define  Attr_Scaling                       79\n+#define  Attr_Signed_Zeros                  80\n+#define  Attr_Size                          81\n+#define  Attr_Small                         82\n+#define  Attr_Storage_Size                  83\n+#define  Attr_Storage_Unit                  84\n+#define  Attr_Stream_Size                   85\n+#define  Attr_Tag                           86\n+#define  Attr_Target_Name                   87\n+#define  Attr_Terminated                    88\n+#define  Attr_To_Address                    89\n+#define  Attr_Type_Class                    90\n+#define  Attr_UET_Address                   91\n+#define  Attr_Unbiased_Rounding             92\n+#define  Attr_Unchecked_Access              93\n+#define  Attr_Unconstrained_Array           94\n+#define  Attr_Universal_Literal_String      95\n+#define  Attr_Unrestricted_Access           96\n+#define  Attr_VADS_Size                     97\n+#define  Attr_Val                           98\n+#define  Attr_Valid                         99\n+#define  Attr_Value_Size                    100\n+#define  Attr_Version                       101\n+#define  Attr_Wchar_T_Size                  102\n+#define  Attr_Wide_Wide_Width               103\n+#define  Attr_Wide_Width                    104\n+#define  Attr_Width                         105\n+#define  Attr_Word_Size                     106\n+#define  Attr_Adjacent                      107\n+#define  Attr_Ceiling                       108\n+#define  Attr_Copy_Sign                     109\n+#define  Attr_Floor                         110\n+#define  Attr_Fraction                      111\n+#define  Attr_Image                         112\n+#define  Attr_Input                         113\n+#define  Attr_Machine                       114\n+#define  Attr_Max                           115\n+#define  Attr_Min                           116\n+#define  Attr_Model                         117\n+#define  Attr_Pred                          118\n+#define  Attr_Remainder                     119\n+#define  Attr_Rounding                      120\n+#define  Attr_Succ                          121\n+#define  Attr_Truncation                    122\n+#define  Attr_Value                         123\n+#define  Attr_Wide_Image                    124\n+#define  Attr_Wide_Wide_Image               125\n+#define  Attr_Wide_Value                    126\n+#define  Attr_Wide_Wide_Value               127\n+#define  Attr_Output                        128\n+#define  Attr_Read                          129\n+#define  Attr_Write                         130\n+#define  Attr_Elab_Body                     131\n+#define  Attr_Elab_Spec                     132\n+#define  Attr_Storage_Pool                  133\n+#define  Attr_Base                          134\n+#define  Attr_Class                         135\n \n /* Define the numeric values for the conventions.  */\n "}]}