{"sha": "145870b56f7710f2f39156ddfdc7b62b0ed079b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ1ODcwYjU2Zjc3MTBmMmYzOTE1NmRkZmRjN2I2MmIwZWQwNzliNA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1997-09-16T06:13:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T06:13:27Z"}, "message": "v850.c (register_is_ok_for_epilogue, [...]): New functions.\n\n        * config/v850/v850.c (register_is_ok_for_epilogue,\n        pattern_is_ok_for_epilogue, construct_restore_jr,\n        pattern_is_ok_for_prologue, construct_save_jarl): New functions.\n\n        * config/v850/v850.h (pattern_is_ok_for_prologue,\n        pattern_is_ok_for_epilogue, register_is_ok_for_epilogue): New\n        predicates.\n\n        * config/v850/v850.md: Replace prologue and epilogue patterns with a\n        match_parallel pattern.\n\n        * config/v850/v850.c (output_move_single_unsigned): Cope with zero\n        extending and moving between registers at the same time.\n\nBrought over from devo.\n\nFrom-SVN: r15477", "tree": {"sha": "6bcaebccfd79b6dc8d68e3bdc71ff5e99c7fc5e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bcaebccfd79b6dc8d68e3bdc71ff5e99c7fc5e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/145870b56f7710f2f39156ddfdc7b62b0ed079b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145870b56f7710f2f39156ddfdc7b62b0ed079b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/145870b56f7710f2f39156ddfdc7b62b0ed079b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145870b56f7710f2f39156ddfdc7b62b0ed079b4/comments", "author": null, "committer": null, "parents": [{"sha": "9302e6e54c6bdbe354924f249ce1edac6847b467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9302e6e54c6bdbe354924f249ce1edac6847b467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9302e6e54c6bdbe354924f249ce1edac6847b467"}], "stats": {"total": 480, "additions": 454, "deletions": 26}, "files": [{"sha": "266f78fbbb147b972dc7afd6659986cf05c2acfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=145870b56f7710f2f39156ddfdc7b62b0ed079b4", "patch": "@@ -1,3 +1,19 @@\n+Tue Sep 16 00:13:20 1997  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/v850/v850.c (register_is_ok_for_epilogue,\n+\tpattern_is_ok_for_epilogue, construct_restore_jr,\n+\tpattern_is_ok_for_prologue, construct_save_jarl): New functions.\n+\n+\t* config/v850/v850.h (pattern_is_ok_for_prologue,\n+\tpattern_is_ok_for_epilogue, register_is_ok_for_epilogue): New\n+\tpredicates.\n+\n+\t* config/v850/v850.md: Replace prologue and epilogue patterns with a\n+\tmatch_parallel pattern.\n+\n+\t* config/v850/v850.c (output_move_single_unsigned): Cope with zero\n+\textending and moving between registers at the same time.\n+\n Mon Sep 15 22:53:01 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* aclocal.m4: Add replacement for AC_PROG_INSTALL."}, {"sha": "2247dae01516f44156a8318312633ad6be4f56a7", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 392, "deletions": 15, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=145870b56f7710f2f39156ddfdc7b62b0ed079b4", "patch": "@@ -476,7 +476,15 @@ print_operand (file, x, code)\n     case 'S':\n       {\n         /* if it's a referance to a TDA variable, use sst/sld vs. st/ld */\n-        if (GET_CODE (x) == MEM && ep_memory_operand (x, GET_MODE (x)))\n+        if (GET_CODE (x) == MEM && ep_memory_operand (x, GET_MODE (x), FALSE))\n+          fputs (\"s\", file);\n+\n+        break;\n+      }\n+    case 'T':\n+      {\n+\t/* Like an 'S' operand above, but for unsigned loads only.  */\n+        if (GET_CODE (x) == MEM && ep_memory_operand (x, GET_MODE (x), TRUE))\n           fputs (\"s\", file);\n \n         break;\n@@ -702,7 +710,9 @@ output_move_single (operands)\n       else if (GET_CODE (src) == LABEL_REF\n \t       || GET_CODE (src) == SYMBOL_REF\n \t       || GET_CODE (src) == CONST)\n-\treturn \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n+\t{\n+\t  return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n+\t}\n \n       else if (GET_CODE (src) == HIGH)\n \treturn \"movhi hi(%1),%.,%0\";\n@@ -814,9 +824,10 @@ output_move_double (operands)\n /* Return true if OP is a valid short EP memory reference */\n \n int\n-ep_memory_operand (op, mode)\n+ep_memory_operand (op, mode, unsigned_load)\n      rtx op;\n      enum machine_mode mode;\n+     int unsigned_load;\n {\n   rtx addr, op0, op1;\n   int max_offset;\n@@ -831,18 +842,18 @@ ep_memory_operand (op, mode)\n       return FALSE;\n \n     case QImode:\n-      max_offset = 128;\n+\t  max_offset = (1 << 7);\n       mask = 0;\n       break;\n \n     case HImode:\n-      max_offset = 256;\n+\t  max_offset = (1 << 8);\n       mask = 1;\n       break;\n \n     case SImode:\n     case SFmode:\n-      max_offset = 256;\n+      max_offset = (1 << 8);\n       mask = 3;\n       break;\n     }\n@@ -1218,7 +1229,7 @@ void v850_reorg (start_insn)\n \t      else\n \t\tmem = NULL_RTX;\n \n-\t      if (mem && ep_memory_operand (mem, GET_MODE (mem)))\n+\t      if (mem && ep_memory_operand (mem, GET_MODE (mem), FALSE))\n \t\tuse_ep = TRUE;\n \n \t      else if (!use_ep && mem\n@@ -1499,15 +1510,18 @@ expand_prologue ()\n \t stack space is allocated.  */\n       if (save_func_len < save_normal_len)\n \t{\n-\t  save_all = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num_save + 2));\n+\t  save_all = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num_save + (TARGET_V850 ? 2 : 1)));\n \t  XVECEXP (save_all, 0, 0) = gen_rtx (SET, VOIDmode,\n \t\t\t\t\t      stack_pointer_rtx,\n \t\t\t\t\t      gen_rtx (PLUS, Pmode,\n \t\t\t\t\t\t       stack_pointer_rtx,\n \t\t\t\t\t\t       GEN_INT (-alloc_stack)));\n \n-\t  XVECEXP (save_all, 0, num_save+1)\n-\t    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 10));\n+\t  if (TARGET_V850)\n+\t    {\n+\t      XVECEXP (save_all, 0, num_save+1)\n+\t\t= gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 10));\n+\t    }\n \n \t  offset = - default_stack;\n \t  for (i = 0; i < num_save; i++)\n@@ -1555,15 +1569,15 @@ expand_prologue ()\n \t    init_stack_alloc = compute_register_save_size (NULL);\n \t  else\n \t    init_stack_alloc = actual_fsize;\n-\n+\t      \n \t  /* Save registers at the beginning of the stack frame */\n \t  offset = init_stack_alloc - 4;\n-\n+\t  \n \t  if (init_stack_alloc)\n \t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t\t   stack_pointer_rtx,\n \t\t\t\t   GEN_INT (-init_stack_alloc)));\n-\n+\t  \n \t  /* Save the return pointer first.  */\n \t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == 31)\n \t    {\n@@ -1573,12 +1587,12 @@ expand_prologue ()\n \t\t\t      save_regs[--num_save]);\n \t      offset -= 4;\n \t    }\n-\n+\t  \n \t  for (i = 0; i < num_save; i++)\n \t    {\n \t      emit_move_insn (gen_rtx (MEM, SImode,\n \t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t       offset)),\n+\t\t\t\t\t\t      offset)),\n \t\t\t      save_regs[i]);\n \t      offset -= 4;\n \t    }\n@@ -1940,3 +1954,366 @@ v850_encode_data_area (decl)\n      here to make merges easier.  */\n   return;\n }\n+\n+/* Return true if the given RTX is a register which can be restored\n+   by a function epilogue.  */\n+int\n+register_is_ok_for_epilogue (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* The save/restore routines can only cope with registers 2, and 20 - 31 */\n+  return (GET_CODE (op) == REG)\n+\t  && (((REGNO (op) >= 20) && REGNO (op) <= 31)\n+\t      || REGNO (op) == 2);\n+}\n+\n+/* Return non-zero if the given RTX is suitable for collapsing into\n+   jump to a function epilogue.  */\n+int\n+pattern_is_ok_for_epilogue (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+  \n+  /* If there are no registers to restore then the function epilogue\n+     is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are performing a\n+     function epilogue and that we are popping at least one register.  We must\n+     now check the remaining entries in the vector to make sure that they are\n+     also register pops.  There is no good reason why there should ever be\n+     anything else in this vector, but being paranoid always helps...\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+        (set (match_operand:SI n \"register_is_ok_for_epilogue\" \"r\")\n+\t  (mem:SI (plus:SI (reg:SI 3) (match_operand:SI n \"immediate_operand\" \"i\"))))\n+     */\n+\n+  for (i = 3; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+      \n+      dest = SET_DEST (vector_element);\n+      src = SET_SRC (vector_element);\n+\n+      if (GET_CODE (dest) != REG\n+\t  || GET_MODE (dest) != SImode\n+\t  || ! register_is_ok_for_epilogue (dest, SImode)\n+\t  || GET_CODE (src) != MEM\n+\t  || GET_MODE (src) != SImode)\n+\treturn 0;\n+\n+      plus = XEXP (src, 0);\n+\n+      if (GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Construct a JR instruction to a routine that will perform the equivalent of\n+   the RTL passed in as an argument.  This RTL is a function epilogue that\n+   pops registers off the stack and possibly releases some extra stack space\n+   as well.  The code has already verified that the RTL matches these\n+   requirements.  */\n+char *\n+construct_restore_jr (op)\n+     rtx op;\n+{\n+  int count = XVECLEN (op, 0);\n+  int stack_bytes;\n+  unsigned long int mask;\n+  unsigned long int first;\n+  unsigned long int last;\n+  int i;\n+  static char buff [100]; /* XXX */\n+  \n+  if (count <= 2)\n+    {\n+      error (\"Bogus JR construction: %d\\n\", count);\n+      return NULL;\n+    }\n+\n+  /* Work out how many bytes to pop off the stack before retrieving\n+     registers.  */\n+  if (GET_CODE (XVECEXP (op, 0, 1)) != SET)\n+    abort ();\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) != PLUS)\n+    abort ();\n+  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1)) != CONST_INT)\n+    abort ();\n+    \n+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1));\n+\n+  /* Each pop will remove 4 bytes from the stack... */\n+  stack_bytes -= (count - 2) * 4;\n+\n+  /* Make sure that the amount we are popping either 0 or 16 bytes.  */\n+  if (stack_bytes != 0 && stack_bytes != 16)\n+    {\n+      error (\"Bad amount of stack space removal: %d\", stack_bytes);\n+      return NULL;\n+    }\n+\n+  /* Now compute the bit mask of registers to push.  */\n+  mask = 0;\n+  for (i = 2; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\tabort ();\n+      if (GET_CODE (SET_DEST (vector_element)) != REG)\n+\tabort ();\n+      if (! register_is_ok_for_epilogue (SET_DEST (vector_element), SImode))\n+\tabort ();\n+      \n+      mask |= 1 << REGNO (SET_DEST (vector_element));\n+    }\n+\n+  /* Scan for the first register to pop.  */\n+  for (first = 0; first < 32; first++)\n+    {\n+      if (mask & (1 << first))\n+\tbreak;\n+    }\n+\n+  if (first >= 32)\n+    abort ();\n+\n+  /* Discover the last register to pop.  */\n+  if (mask & (1 << 31))\n+    {\n+      if (stack_bytes != 16)\n+\tabort ();\n+      \n+      last = 31;\n+    }\n+  else\n+    {\n+      if (stack_bytes != 0)\n+\tabort ();\n+      if ((mask & (1 << 29)) == 0)\n+\tabort ();\n+      \n+      last = 29;\n+    }\n+\n+  /* Paranoia */\n+  for (i = (first == 2 ? 20 : first + 1); i < 29; i++)\n+    if ((mask & (1 << i)) == 0)\n+      abort ();\n+\n+  if (first == last)\n+    sprintf (buff, \"jr __return_%s\", reg_names [first]);\n+  else\n+    sprintf (buff, \"jr __return_%s_%s\", reg_names [first], reg_names [last]);\n+\n+  return buff;\n+}\n+\n+\n+/* Return non-zero if the given RTX is suitable for collapsing into\n+   a jump to a function prologue.  */\n+int\n+pattern_is_ok_for_prologue (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int count = XVECLEN (op, 0);\n+  int i; \n+  rtx vector_element;\n+ \n+  /* If there are no registers to save then the function prologue\n+     is not suitable.  */\n+  if (count <= 2)\n+    return 0;\n+\n+  /* The pattern matching has already established that we are adjusting the\n+     stack and pushing at least one register.  We must now check that the\n+     remaining entries in the vector to make sure that they are also register\n+     pushes, except for the last entry which should be a CLOBBER of r10.\n+\n+     The test below performs the C equivalent of this machine description\n+     pattern match:\n+\n+     (set (mem:SI (plus:SI (reg:SI 3)\n+      (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+      (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))\n+\n+     */\n+\n+  for (i = 2; i < count - 1; i++)\n+    {\n+      rtx dest;\n+      rtx src;\n+      rtx plus;\n+      \n+      vector_element = XVECEXP (op, 0, i);\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\treturn 0;\n+      \n+      dest = SET_DEST (vector_element);\n+      src = SET_SRC (vector_element);\n+\n+      if (GET_CODE (dest) != MEM\n+\t  || GET_MODE (dest) != SImode\n+\t  || GET_CODE (src) != REG\n+\t  || GET_MODE (src) != SImode\n+\t  || ! register_is_ok_for_epilogue (src, SImode))\n+\treturn 0;\n+\n+      plus = XEXP (dest, 0);\n+\n+      if ( GET_CODE (plus) != PLUS\n+\t  || GET_CODE (XEXP (plus, 0)) != REG\n+\t  || GET_MODE (XEXP (plus, 0)) != SImode\n+\t  || REGNO (XEXP (plus, 0)) != STACK_POINTER_REGNUM\n+\t  || GET_CODE (XEXP (plus, 1)) != CONST_INT)\n+\treturn 0;\n+\n+      /* If the register is being pushed somewhere other than the stack\n+\t space just aquired by the first operand then abandon this quest.\n+\t Note: the test is <= becuase both values are negative.\t */\n+      if (INTVAL (XEXP (plus, 1))\n+\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n+\t{\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Make sure that the last entry in the vector is a clobber.  */\n+  vector_element = XVECEXP (op, 0, i);\n+  \n+  if (GET_CODE (vector_element) != CLOBBER\n+      || GET_CODE (XEXP (vector_element, 0)) != REG\n+      || REGNO (XEXP (vector_element, 0)) != 10)\n+    return 0;\n+  \n+  return 1;\n+}\n+\n+/* Construct a JARL instruction to a routine that will perform the equivalent\n+   of the RTL passed as a parameter.  This RTL is a function prologue that\n+   saves some of the registers r20 - r31 onto the stack, and possibly acquires\n+   some stack space as well.  The code has already verified that the RTL\n+   matches these requirements.  */\n+char *\n+construct_save_jarl (op)\n+     rtx op;\n+{\n+  int count = XVECLEN (op, 0);\n+  int stack_bytes;\n+  unsigned long int mask;\n+  unsigned long int first;\n+  unsigned long int last;\n+  int i;\n+  static char buff [100]; /* XXX */\n+  \n+  if (count <= 2)\n+    {\n+      error (\"Bogus JARL construction: %d\\n\", count);\n+      return NULL;\n+    }\n+\n+  /* Paranoia.  */\n+  if (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    abort ();\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != PLUS)\n+    abort ();\n+  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 0)) != REG)\n+    abort ();\n+  if (GET_CODE (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)) != CONST_INT)\n+    abort ();\n+    \n+  /* Work out how many bytes to push onto the stack after storing the\n+     registers.  */\n+  stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));\n+\n+  /* Each push will put 4 bytes from the stack... */\n+  stack_bytes += (count - 2) * 4;\n+\n+  /* Make sure that the amount we are popping either 0 or 16 bytes.  */\n+  if (stack_bytes != 0 && stack_bytes != -16)\n+    {\n+      error (\"Bad amount of stack space removal: %d\", stack_bytes);\n+      return NULL;\n+    }\n+\n+  /* Now compute the bit mask of registers to push.  */\n+  mask = 0;\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx vector_element = XVECEXP (op, 0, i);\n+      \n+      if (GET_CODE (vector_element) != SET)\n+\tabort ();\n+      if (GET_CODE (SET_SRC (vector_element)) != REG)\n+\tabort ();\n+      if (! register_is_ok_for_epilogue (SET_SRC (vector_element), SImode))\n+\tabort ();\n+      \n+      mask |= 1 << REGNO (SET_SRC (vector_element));\n+    }\n+\n+  /* Scan for the first register to push.  */  \n+  for (first = 0; first < 32; first++)\n+    {\n+      if (mask & (1 << first))\n+\tbreak;\n+    }\n+\n+  if (first >= 32)\n+    abort ();\n+\n+  /* Discover the last register to push.  */\n+  if (mask & (1 << 31))\n+    {\n+      if (stack_bytes != -16)\n+\tabort();\n+      \n+      last = 31;\n+    }\n+  else\n+    {\n+      if (stack_bytes != 0)\n+\tabort ();\n+      if ((mask & (1 << 29)) == 0)\n+\tabort ();\n+      \n+      last = 29;\n+    }\n+\n+  /* Paranoia */\n+  for (i = (first == 2 ? 20 : first + 1); i < 29; i++)\n+    if ((mask & (1 << i)) == 0)\n+      abort ();\n+\n+  if (first == last)\n+    sprintf (buff, \"jarl __save_%s, r10\", reg_names [first]);\n+  else\n+    sprintf (buff, \"jarl __save_%s_%s, r10\", reg_names [first],\n+\t     reg_names [last]);\n+\n+  return buff;\n+}\n+"}, {"sha": "8e7f9fe6a9e6040cb68e0e33bc73e76228ebf841", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=145870b56f7710f2f39156ddfdc7b62b0ed079b4", "patch": "@@ -55,6 +55,16 @@ extern int target_flags;\n #define MASK_PROLOG_FUNCTION\t0x00000008\n #define MASK_DEBUG\t\t0x40000000\n \n+#define MASK_CPU                0x00000030\n+#define MASK_V850               0x00000010\n+\n+#ifndef MASK_DEFAULT\n+#define MASK_DEFAULT            MASK_V850\n+#endif\n+\n+#define TARGET_V850    \t\t((target_flags & MASK_CPU) == MASK_V850)\n+\n+\n /* Macros used in the machine description to test the flags.  */\n \n /* The GHS calling convention support doesn't really work,\n@@ -117,7 +127,7 @@ extern int target_flags;\n #endif\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT MASK_DEFAULT\n+#define TARGET_DEFAULT \t\tMASK_DEFAULT\n #endif\n \n /* Information about the various small memory areas.  */\n@@ -458,18 +468,23 @@ enum reg_class {\n \n #define INT_7_BITS(VALUE) ((unsigned) (VALUE) + 0x40 < 0x80)\n #define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n+/* 0 bits */\n #define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n+/* 4 bits */\n #define CONST_OK_FOR_J(VALUE) ((unsigned) (VALUE) + 0x10 < 0x20)\n+/* 15 bits */\n #define CONST_OK_FOR_K(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n #define CONST_OK_FOR_L(VALUE) \\\n   (((unsigned) ((int) (VALUE) >> 16) + 0x8000 < 0x10000) \\\n    && CONST_OK_FOR_I ((VALUE & 0xffff)))\n-#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000)\n+/* 16 bits */\n+#define CONST_OK_FOR_M(VALUE) ((unsigned)(VALUE) < 0x10000\n \n #define CONST_OK_FOR_N(VALUE) ((unsigned) VALUE >= 0 && (unsigned) VALUE <= 31) /* 5 bit signed immediate in shift instructions */\n #define CONST_OK_FOR_O(VALUE) 0\n #define CONST_OK_FOR_P(VALUE) 0\n \n+\n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n   ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n    (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n@@ -1390,6 +1405,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t  REG, SUBREG }},\t\t\t\\\n { \"special_symbolref_operand\",\t{ SYMBOL_REF }},\t\t\t\\\n { \"power_of_two_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+{ \"pattern_is_ok_for_prologue\",\t{ PARALLEL }},\t\t\t\t\\\n+{ \"pattern_is_ok_for_epilogue\",\t{ PARALLEL }},\t\t\t\t\\\n+{ \"register_is_ok_for_epilogue\",{ REG }},\t\t\t\t\\\n { \"not_power_of_two_operand\",\t{ CONST_INT }},\n \n extern void override_options ();\n@@ -1415,3 +1433,11 @@ extern void expand_epilogue ();\n extern void notice_update_cc ();\n extern int v850_valid_machine_decl_attribute ();\n extern int v850_interrupt_function_p ();\n+\n+extern int pattern_is_ok_for_prologue();\n+extern int pattern_is_ok_for_epilogue();\n+extern int register_is_ok_for_epilogue ();\n+extern char *construct_save_jarl ();\n+extern char *construct_restore_jr ();\n+\n+"}, {"sha": "5db807b03c4db222a11b312678f6b6a0bfa761bc", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/145870b56f7710f2f39156ddfdc7b62b0ed079b4/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=145870b56f7710f2f39156ddfdc7b62b0ed079b4", "patch": "@@ -181,6 +181,8 @@\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n    (set_attr \"type\" \"other,other,other,load,other,load,other,other,other\")])\n \n+\n+\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n@@ -963,6 +965,7 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_znv\")])\n \n+\n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI\n@@ -974,12 +977,16 @@\n \n ;;- sign extension instructions\n \n+\n+;; ??? This is missing a sign extend from memory pattern to match the ld.h\n+;; instruction.\n+\n (define_expand \"extendhisi2\"\n   [(set (match_dup 2)\n         (ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n                    (const_int 16)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ashiftrt:SI (match_dup 2)\n+       (ashiftrt:SI (match_dup 2)\n                      (const_int 16)))]\n   \"\"\n   \"\n@@ -988,6 +995,10 @@\n   operands[2] = gen_reg_rtx (SImode);\n }\")\n \n+\n+;; ??? This is missing a sign extend from memory pattern to match the ld.b\n+;; instruction.\n+\n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n         (ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n@@ -1089,20 +1100,19 @@\n ;; RTXs.  These RTXs will then be turned into a suitable call to a worker\n ;; function.\n \n+\n (define_insn \"\"\n  [(match_parallel 0 \"pattern_is_ok_for_prologue\"\n    [(set (reg:SI 3)\n \t (plus:SI (reg:SI 3) (match_operand:SI 1 \"immediate_operand\" \"i\")))\n-    (set (mem:SI\n-\t   (plus:SI (reg:SI 3) (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+    (set (mem:SI (plus:SI (reg:SI 3)\n+\t\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))\n \t (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))])]\n  \"TARGET_PROLOG_FUNCTION\"\n  \"* return construct_save_jarl (operands[0]);\n  \"\n  [(set_attr \"length\" \"4\")\n-  (set_attr \"cc\"     \"clobber\")\n- ]\n-)\n+  (set_attr \"cc\"     \"clobber\")])\n \n \n ;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n@@ -1139,6 +1149,7 @@\n ;; and possible a stack adjustment as well.  These RTXs will be turned into\n ;; a suitable call to a worker function.\n \n+\n (define_insn \"\"\n [(match_parallel 0 \"pattern_is_ok_for_epilogue\"\n    [(return)\n@@ -1151,9 +1162,7 @@\n  \"* return construct_restore_jr (operands[0]);\n  \"\n  [(set_attr \"length\" \"4\")\n-  (set_attr \"cc\"     \"clobber\")\n- ]\n-)\n+  (set_attr \"cc\"     \"clobber\")])\n \n ;; Restore r1, r5, r10, and return from the interrupt\n (define_insn \"restore_interrupt\""}]}