{"sha": "7209f1f9e430458aeb12bad7a980687a38b4a38d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIwOWYxZjllNDMwNDU4YWViMTJiYWQ3YTk4MDY4N2EzOGI0YTM4ZA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-25T04:17:33Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1995-01-25T04:17:33Z"}, "message": "(jump_optimize):  Try to emit a conditional move insn before\ntrying a store-flag insn.\n\nFrom-SVN: r8801", "tree": {"sha": "15d94170ad8af6fda6d0885657f85bda80fc0b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15d94170ad8af6fda6d0885657f85bda80fc0b19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7209f1f9e430458aeb12bad7a980687a38b4a38d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7209f1f9e430458aeb12bad7a980687a38b4a38d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7209f1f9e430458aeb12bad7a980687a38b4a38d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7209f1f9e430458aeb12bad7a980687a38b4a38d/comments", "author": null, "committer": null, "parents": [{"sha": "3c9958cd4adf0f2beb3e2ba2dc7d2b7a662c609a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9958cd4adf0f2beb3e2ba2dc7d2b7a662c609a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9958cd4adf0f2beb3e2ba2dc7d2b7a662c609a"}], "stats": {"total": 394, "additions": 239, "deletions": 155}, "files": [{"sha": "6172969c4af0cb45f431785c0a65c9bbf4bc3082", "filename": "gcc/jump.c", "status": "modified", "additions": 239, "deletions": 155, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7209f1f9e430458aeb12bad7a980687a38b4a38d/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7209f1f9e430458aeb12bad7a980687a38b4a38d/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=7209f1f9e430458aeb12bad7a980687a38b4a38d", "patch": "@@ -987,26 +987,23 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t    }\n #endif /* HAVE_cc0 */\n \n-\t  /* We deal with four cases:\n-\n-\t     1) x = a; if (...) x = b; and either A or B is zero,\n-\t     2) if (...) x = 0; and jumps are expensive,\n-\t     3) x = a; if (...) x = b; and A and B are constants where all the\n-\t        set bits in A are also set in B and jumps are expensive, and\n-\t     4) x = a; if (...) x = b; and A and B non-zero, and jumps are\n-\t        more expensive.\n-\t     5) if (...) x = b; if jumps are even more expensive.\n-\n-\t     In each of these try to use a store-flag insn to avoid the jump.\n-\t     (If the jump would be faster, the machine should not have\n-\t     defined the scc insns!).  These cases are often made by the\n+\t  /* Try to use a conditional move (if the target has them), or a\n+\t     store-flag insn.  The general case is:\n+\n+\t     1) x = a; if (...) x = b; and\n+\t     2) if (...) x = b;\n+\n+\t     If the jump would be faster, the machine should not have defined\n+\t     the movcc or scc insns!.  These cases are often made by the\n \t     previous optimization.\n \n+\t     The second case is treated as  x = x; if (...) x = b;.\n+\n \t     INSN here is the jump around the store.  We set:\n \n \t     TEMP to the \"x = b;\" insn.\n \t     TEMP1 to X.\n-\t     TEMP2 to B (const0_rtx in the second case).\n+\t     TEMP2 to B.\n \t     TEMP3 to A (X in the second case).\n \t     TEMP4 to the condition being tested.\n \t     TEMP5 to the earliest insn used to find the condition.  */\n@@ -1022,25 +1019,18 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n #ifdef SMALL_REGISTER_CLASSES\n \t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n #endif\n-\t      && GET_MODE_CLASS (GET_MODE (temp1)) == MODE_INT\n \t      && (GET_CODE (temp2 = SET_SRC (PATTERN (temp))) == REG\n \t\t  || GET_CODE (temp2) == SUBREG\n+\t\t  /* ??? How about floating point constants?  */\n \t\t  || GET_CODE (temp2) == CONST_INT)\n \t      /* Allow either form, but prefer the former if both apply. \n \t\t There is no point in using the old value of TEMP1 if\n \t\t it is a register, since cse will alias them.  It can\n \t\t lose if the old value were a hard register since CSE\n \t\t won't replace hard registers.  */\n-\t      && (((temp3 = reg_set_last (temp1, insn)) != 0\n-\t\t   && GET_CODE (temp3) == CONST_INT)\n-\t\t  /* Make the latter case look like  x = x; if (...) x = 0;  */\n-\t\t  || (temp3 = temp1,\n-\t\t      ((BRANCH_COST >= 2\n-\t\t\t&& temp2 == const0_rtx)\n-#ifdef HAVE_conditional_move\n-\t\t       || HAVE_conditional_move\n-#endif\n-\t\t       || BRANCH_COST >= 3)))\n+\t      && (((temp3 = reg_set_last (temp1, insn)) != 0)\n+\t\t  /* Make the latter case look like  x = x; if (...) x = b;  */\n+\t\t  || (temp3 = temp1, 1))\n \t      /* INSN must either branch to the insn after TEMP or the insn\n \t\t after TEMP must branch to the same place as INSN.  */\n \t      && (reallabelprev == temp\n@@ -1052,25 +1042,13 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t We could handle BLKmode if (1) emit_store_flag could\n \t\t and (2) we could find the size reliably.  */\n \t      && GET_MODE (XEXP (temp4, 0)) != BLKmode\n-\n-\t      /* If B is zero, OK; if A is zero, can only do (1) if we\n-\t\t can reverse the condition.  See if (3) applies possibly\n-\t\t by reversing the condition.  Prefer reversing to (4) when\n-\t\t branches are very expensive.  */\n-\t      && ((reversep = 0, temp2 == const0_rtx)\n-\t\t  || (temp3 == const0_rtx\n-\t\t      && (reversep = can_reverse_comparison_p (temp4, insn)))\n-\t\t  || (BRANCH_COST >= 2\n-\t\t      && GET_CODE (temp2) == CONST_INT\n-\t\t      && GET_CODE (temp3) == CONST_INT\n-\t\t      && ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp2)\n-\t\t\t  || ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp3)\n-\t\t\t      && (reversep = can_reverse_comparison_p (temp4,\n-\t\t\t\t\t\t\t\t       insn)))))\n+\t      /* No point in doing any of this if branches are cheap or we\n+\t\t don't have conditional moves.  */\n+\t      && (BRANCH_COST >= 2\n #ifdef HAVE_conditional_move\n-\t\t  || HAVE_conditional_move\n+\t\t  || 1\n #endif\n-\t\t  || BRANCH_COST >= 3)\n+\t\t  )\n #ifdef HAVE_cc0\n \t      /* If the previous insn sets CC0 and something else, we can't\n \t\t do this since we are going to delete that insn.  */\n@@ -1083,139 +1061,245 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n #endif\n \t      )\n \t    {\n-\t      enum rtx_code code = GET_CODE (temp4);\n-\t      rtx uval, cval, var = temp1;\n-\t      int normalizep;\n-\t      rtx target;\n-\n-\t      /* If necessary, reverse the condition.  */\n-\t      if (reversep)\n-\t\tcode = reverse_condition (code), uval = temp2, cval = temp3;\n-\t      else\n-\t\tuval = temp3, cval = temp2;\n-\n-\t      /* See if we can do this with a store-flag insn. */\n-\t      start_sequence ();\n+#ifdef HAVE_conditional_move\n+\t      /* First try a conditional move.  */\n+\t      {\n+\t\tenum rtx_code code = GET_CODE (temp4);\n+\t\trtx var = temp1;\n+\t\trtx cond0, cond1, aval, bval;\n+\t\trtx target;\n+\n+\t\t/* Copy the compared variables into cond0 and cond1, so that\n+\t\t   any side effects performed in or after the old comparison,\n+\t\t   will not affect our compare which will come later.  */\n+\t\t/* ??? Is it possible to just use the comparison in the jump\n+\t\t   insn?  After all, we're going to delete it.  We'd have\n+\t\t   to modify emit_conditional_move to take a comparison rtx\n+\t\t   instead or write a new function.  */\n+\t\tcond0 = gen_reg_rtx (GET_MODE (XEXP (temp4, 0)));\n+\t\t/* We want the target to be able to simplify comparisons with\n+\t\t   zero (and maybe other constants as well), so don't create\n+\t\t   pseudos for them.  There's no need to either.  */\n+\t\tif (GET_CODE (XEXP (temp4, 1)) == CONST_INT\n+\t\t    || GET_CODE (XEXP (temp4, 1)) == CONST_DOUBLE)\n+\t\t  cond1 = XEXP (temp4, 1);\n+\t\telse\n+\t\t  cond1 = gen_reg_rtx (GET_MODE (XEXP (temp4, 1)));\n \n-\t      /* If CVAL is non-zero, normalize to -1.  Otherwise,\n-\t\t if UVAL is the constant 1, it is best to just compute\n-\t\t the result directly.  If UVAL is constant and STORE_FLAG_VALUE\n-\t\t includes all of its bits, it is best to compute the flag\n-\t\t value unnormalized and `and' it with UVAL.  Otherwise,\n-\t\t normalize to -1 and `and' with UVAL.  */\n-\t      normalizep = (cval != const0_rtx ? -1\n-\t\t\t    : (uval == const1_rtx ? 1\n-\t\t\t       : (GET_CODE (uval) == CONST_INT\n-\t\t\t\t  && (INTVAL (uval) & ~STORE_FLAG_VALUE) == 0)\n-\t\t\t       ? 0 : -1));\n-\n-\t      /* We will be putting the store-flag insn immediately in\n-\t\t front of the comparison that was originally being done,\n-\t\t so we know all the variables in TEMP4 will be valid.\n-\t\t However, this might be in front of the assignment of\n-\t\t A to VAR.  If it is, it would clobber the store-flag\n-\t\t we will be emitting.\n-\n-\t\t Therefore, emit into a temporary which will be copied to\n-\t\t VAR immediately after TEMP.  */\n-\n-\t      target = emit_store_flag (gen_reg_rtx (GET_MODE (var)), code,\n-\t\t\t\t\tXEXP (temp4, 0), XEXP (temp4, 1),\n-\t\t\t\t\tVOIDmode,\n-\t\t\t\t\t(code == LTU || code == LEU \n-\t\t\t\t\t || code == GEU || code == GTU),\n-\t\t\t\t\tnormalizep);\n-\t      if (target)\n-\t\t{\n-\t\t  rtx before = insn;\n-\t\t  rtx seq;\n+\t\taval = temp3;\n+\t\tbval = temp2;\n \n-\t\t  /* Put the store-flag insns in front of the first insn\n-\t\t     used to compute the condition to ensure that we\n-\t\t     use the same values of them as the current \n-\t\t     comparison.  However, the remainder of the insns we\n-\t\t     generate will be placed directly in front of the\n-\t\t     jump insn, in case any of the pseudos we use\n-\t\t     are modified earlier.  */\n+\t\tstart_sequence ();\n+\t\ttarget = emit_conditional_move (var, code,\n+\t\t\t\t\t\tcond0, cond1, VOIDmode,\n+\t\t\t\t\t\taval, bval, GET_MODE (var),\n+\t\t\t\t\t\t(code == LTU || code == GEU\n+\t\t\t\t\t\t || code == LEU || code == GTU));\n \n-\t\t  seq = get_insns ();\n+\t\tif (target)\n+\t\t  {\n+\t\t    rtx seq1,seq2;\n+\n+\t\t    /* Save the conditional move sequence but don't emit it\n+\t\t       yet.  On some machines, like the alpha, it is possible\n+\t\t       that temp5 == insn, so next generate the sequence that\n+\t\t       saves the compared values and then emit both\n+\t\t       sequences ensuring seq1 occurs before seq2.  */\n+\t\t    seq2 = get_insns ();\n+\t\t    end_sequence ();\n+\n+\t\t    /* Now that we can't fail, generate the copy insns that\n+\t\t       preserve the compared values.  */\n+\t\t    start_sequence ();\n+\t\t    emit_move_insn (cond0, XEXP (temp4, 0));\n+\t\t    if (cond1 != XEXP (temp4, 1))\n+\t\t      emit_move_insn (cond1, XEXP (temp4, 1));\n+\t\t    seq1 = get_insns ();\n+\t\t    end_sequence ();\n+\n+\t\t    emit_insns_before (seq1, temp5);\n+\t\t    emit_insns_before (seq2, insn);\n+\n+\t\t    /* ??? We can also delete the insn that sets X to A.\n+\t\t       Flow will do it too though.  */\n+\t\t    delete_insn (temp);\n+\t\t    next = NEXT_INSN (insn);\n+\t\t    delete_jump (insn);\n+\t\t    changed = 1;\n+\t\t    continue;\n+\t\t  }\n+\t\telse\n \t\t  end_sequence ();\n+\t      }\n+#endif\n+\n+\t      /* That didn't work, try a store-flag insn.\n+\n+\t\t We further divide the cases into:\n+\n+\t\t 1) x = a; if (...) x = b; and either A or B is zero,\n+\t\t 2) if (...) x = 0; and jumps are expensive,\n+\t\t 3) x = a; if (...) x = b; and A and B are constants where all\n+\t\t the set bits in A are also set in B and jumps are expensive,\n+\t\t 4) x = a; if (...) x = b; and A and B non-zero, and jumps are\n+\t\t more expensive, and\n+\t\t 5) if (...) x = b; if jumps are even more expensive.  */\n+\n+\t      if (GET_MODE_CLASS (GET_MODE (temp1)) == MODE_INT\n+\t\t  && ((GET_CODE (temp3) == CONST_INT)\n+\t\t      /* Make the latter case look like\n+\t\t\t x = x; if (...) x = 0;  */\n+\t\t      || (temp3 = temp1,\n+\t\t\t  ((BRANCH_COST >= 2\n+\t\t\t    && temp2 == const0_rtx)\n+\t\t\t   || BRANCH_COST >= 3)))\n+\t\t  /* If B is zero, OK; if A is zero, can only do (1) if we\n+\t\t     can reverse the condition.  See if (3) applies possibly\n+\t\t     by reversing the condition.  Prefer reversing to (4) when\n+\t\t     branches are very expensive.  */\n+\t\t  && ((reversep = 0, temp2 == const0_rtx)\n+\t\t      || (temp3 == const0_rtx\n+\t\t\t  && (reversep = can_reverse_comparison_p (temp4, insn)))\n+\t\t      || (BRANCH_COST >= 2\n+\t\t\t  && GET_CODE (temp2) == CONST_INT\n+\t\t\t  && GET_CODE (temp3) == CONST_INT\n+\t\t\t  && ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp2)\n+\t\t\t      || ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp3)\n+\t\t\t\t  && (reversep = can_reverse_comparison_p (temp4,\n+\t\t\t\t\t\t\t\t\t   insn)))))\n+\t\t      || BRANCH_COST >= 3)\n+\t\t  )\n+\t\t{\n+\t\t  enum rtx_code code = GET_CODE (temp4);\n+\t\t  rtx uval, cval, var = temp1;\n+\t\t  int normalizep;\n+\t\t  rtx target;\n \n-\t\t  emit_insns_before (seq, temp5);\n+\t\t  /* If necessary, reverse the condition.  */\n+\t\t  if (reversep)\n+\t\t    code = reverse_condition (code), uval = temp2, cval = temp3;\n+\t\t  else\n+\t\t    uval = temp3, cval = temp2;\n+\n+\t\t  /* If CVAL is non-zero, normalize to -1.  Otherwise, if UVAL\n+\t\t     is the constant 1, it is best to just compute the result\n+\t\t     directly.  If UVAL is constant and STORE_FLAG_VALUE\n+\t\t     includes all of its bits, it is best to compute the flag\n+\t\t     value unnormalized and `and' it with UVAL.  Otherwise,\n+\t\t     normalize to -1 and `and' with UVAL.  */\n+\t\t  normalizep = (cval != const0_rtx ? -1\n+\t\t\t\t: (uval == const1_rtx ? 1\n+\t\t\t\t   : (GET_CODE (uval) == CONST_INT\n+\t\t\t\t      && (INTVAL (uval) & ~STORE_FLAG_VALUE) == 0)\n+\t\t\t\t   ? 0 : -1));\n+\n+\t\t  /* We will be putting the store-flag insn immediately in\n+\t\t     front of the comparison that was originally being done,\n+\t\t     so we know all the variables in TEMP4 will be valid.\n+\t\t     However, this might be in front of the assignment of\n+\t\t     A to VAR.  If it is, it would clobber the store-flag\n+\t\t     we will be emitting.\n+\n+\t\t     Therefore, emit into a temporary which will be copied to\n+\t\t     VAR immediately after TEMP.  */\n \n \t\t  start_sequence ();\n-\n-\t\t  /* Both CVAL and UVAL are non-zero.  */\n-\t\t  if (cval != const0_rtx && uval != const0_rtx)\n+\t\t  target = emit_store_flag (gen_reg_rtx (GET_MODE (var)), code,\n+\t\t\t\t\t    XEXP (temp4, 0), XEXP (temp4, 1),\n+\t\t\t\t\t    VOIDmode,\n+\t\t\t\t\t    (code == LTU || code == LEU \n+\t\t\t\t\t     || code == GEU || code == GTU),\n+\t\t\t\t\t    normalizep);\n+\t\t  if (target)\n \t\t    {\n-\t\t      rtx tem1, tem2;\n+\t\t      rtx seq;\n+\t\t      rtx before = insn;\n \n-\t\t      tem1 = expand_and (uval, target, NULL_RTX);\n-\t\t      if (GET_CODE (cval) == CONST_INT\n-\t\t\t  && GET_CODE (uval) == CONST_INT\n-\t\t\t  && (INTVAL (cval) & INTVAL (uval)) == INTVAL (cval))\n-\t\t\ttem2 = cval;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  tem2 = expand_unop (GET_MODE (var), one_cmpl_optab,\n-\t\t\t\t\t      target, NULL_RTX, 0);\n-\t\t\t  tem2 = expand_and (cval, tem2,\n-\t\t\t\t\t     (GET_CODE (tem2) == REG\n-\t\t\t\t\t      ? tem2 : 0));\n-\t\t\t}\n+\t\t      seq = get_insns ();\n+\t\t      end_sequence ();\n \n-\t\t      /* If we usually make new pseudos, do so here.  This\n-\t\t\t turns out to help machines that have conditional\n-\t\t\t move insns.  */\n+\t\t      /* Put the store-flag insns in front of the first insn\n+\t\t\t used to compute the condition to ensure that we\n+\t\t\t use the same values of them as the current \n+\t\t\t comparison.  However, the remainder of the insns we\n+\t\t\t generate will be placed directly in front of the\n+\t\t\t jump insn, in case any of the pseudos we use\n+\t\t\t are modified earlier.  */\n \n-\t\t      if (flag_expensive_optimizations)\n-\t\t\ttarget = 0;\n+\t\t      emit_insns_before (seq, temp5);\n \n-\t\t      target = expand_binop (GET_MODE (var), ior_optab,\n-\t\t\t\t\t     tem1, tem2, target,\n-\t\t\t\t\t     1, OPTAB_WIDEN);\n-\t\t    }\n-\t\t  else if (normalizep != 1)\n-\t\t    {\n-\t\t      /* We know that either CVAL or UVAL is zero.  If\n-\t\t\t UVAL is zero, negate TARGET and `and' with CVAL.\n-\t\t\t Otherwise, `and' with UVAL.  */\n-\t\t      if (uval == const0_rtx)\n+\t\t      start_sequence ();\n+\n+\t\t      /* Both CVAL and UVAL are non-zero.  */\n+\t\t      if (cval != const0_rtx && uval != const0_rtx)\n \t\t\t{\n-\t\t\t  target = expand_unop (GET_MODE (var), one_cmpl_optab,\n-\t\t\t\t\t\ttarget, NULL_RTX, 0);\n-\t\t\t  uval = cval;\n+\t\t\t  rtx tem1, tem2;\n+\n+\t\t\t  tem1 = expand_and (uval, target, NULL_RTX);\n+\t\t\t  if (GET_CODE (cval) == CONST_INT\n+\t\t\t      && GET_CODE (uval) == CONST_INT\n+\t\t\t      && (INTVAL (cval) & INTVAL (uval)) == INTVAL (cval))\n+\t\t\t    tem2 = cval;\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      tem2 = expand_unop (GET_MODE (var), one_cmpl_optab,\n+\t\t\t\t\t\t  target, NULL_RTX, 0);\n+\t\t\t      tem2 = expand_and (cval, tem2,\n+\t\t\t\t\t\t (GET_CODE (tem2) == REG\n+\t\t\t\t\t\t  ? tem2 : 0));\n+\t\t\t    }\n+\n+\t\t\t  /* If we usually make new pseudos, do so here.  This\n+\t\t\t     turns out to help machines that have conditional\n+\t\t\t     move insns.  */\n+\t\t\t  /* ??? Conditional moves have already been handled.\n+\t\t\t     This may be obsolete.  */\n+\n+\t\t\t  if (flag_expensive_optimizations)\n+\t\t\t    target = 0;\n+\n+\t\t\t  target = expand_binop (GET_MODE (var), ior_optab,\n+\t\t\t\t\t\t tem1, tem2, target,\n+\t\t\t\t\t\t 1, OPTAB_WIDEN);\n \t\t\t}\n+\t\t      else if (normalizep != 1)\n+\t\t\t{\n+\t\t\t  /* We know that either CVAL or UVAL is zero.  If\n+\t\t\t     UVAL is zero, negate TARGET and `and' with CVAL.\n+\t\t\t     Otherwise, `and' with UVAL.  */\n+\t\t\t  if (uval == const0_rtx)\n+\t\t\t    {\n+\t\t\t      target = expand_unop (GET_MODE (var), one_cmpl_optab,\n+\t\t\t\t\t\t    target, NULL_RTX, 0);\n+\t\t\t      uval = cval;\n+\t\t\t    }\n \n-\t\t      target = expand_and (uval, target,\n-\t\t\t\t\t   (GET_CODE (target) == REG\n-\t\t\t\t\t    && ! preserve_subexpressions_p ()\n-\t\t\t\t\t    ? target : NULL_RTX));\n-\t\t    }\n+\t\t\t  target = expand_and (uval, target,\n+\t\t\t\t\t       (GET_CODE (target) == REG\n+\t\t\t\t\t\t&& ! preserve_subexpressions_p ()\n+\t\t\t\t\t\t? target : NULL_RTX));\n+\t\t\t}\n \t\t  \n-\t\t  emit_move_insn (var, target);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\n+\t\t      emit_move_insn (var, target);\n+\t\t      seq = get_insns ();\n+\t\t      end_sequence ();\n #ifdef HAVE_cc0\n-\t\t  /* If INSN uses CC0, we must not separate it from the\n-\t\t     insn that sets cc0.  */\n-\n-\t\t  if (reg_mentioned_p (cc0_rtx, PATTERN (before)))\n-\t\t    before = prev_nonnote_insn (before);\n+\t\t      /* If INSN uses CC0, we must not separate it from the\n+\t\t\t insn that sets cc0.  */\n+\t\t      if (reg_mentioned_p (cc0_rtx, PATTERN (before)))\n+\t\t\tbefore = prev_nonnote_insn (before);\n #endif\n+\t\t      emit_insns_before (seq, before);\n \n-\t\t  emit_insns_before (seq, before);\n-\n-\t\t  delete_insn (temp);\n-\t\t  next = NEXT_INSN (insn);\n-\n-\t\t  delete_jump (insn);\n-\t\t  changed = 1;\n-\t\t  continue;\n+\t\t      delete_insn (temp);\n+\t\t      next = NEXT_INSN (insn);\n+\t\t      delete_jump (insn);\n+\t\t      changed = 1;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else\n+\t\t    end_sequence ();\n \t\t}\n-\t      else\n-\t\tend_sequence ();\n \t    }\n \n \t  /* If branches are expensive, convert"}]}