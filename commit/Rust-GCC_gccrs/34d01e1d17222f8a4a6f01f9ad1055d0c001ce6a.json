{"sha": "34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkMDFlMWQxNzIyMmY4YTRhNmYwMWY5YWQxMDU1ZDBjMDAxY2U2YQ==", "commit": {"author": {"name": "Vasilis Liaskovitis", "email": "vliaskov@gmail.com", "date": "2009-04-20T10:59:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-04-20T10:59:59Z"}, "message": "re PR fortran/35423 (Implement OpenMP workshare)\n\n\tPR fortran/35423\n\t* trans.h (OMPWS_WORKSHARE_FLAG, OMPWS_CURR_SINGLEUNIT,\n\tOMPWS_SCALARIZER_WS, OMPWS_NOWAIT): Define.\n\t(ompws_flags): New extern decl.\n\t* trans-array.c (gfc_trans_scalarized_loop_end): Build OMP_FOR\n\tfor the outer dimension if ompws_flags allow it.\n\t* trans.c (gfc_generate_code): Clear ompws_flags.\n\t* trans-expr.c (gfc_trans_assignment_1): Allow worksharing\n\tarray assignments inside of !$omp workshare.\n\t* trans-stmt.c (gfc_trans_where_3): Similarly for where statements\n\tand constructs.\n\t* trans-openmp.c (ompws_flags): New variable.\n\t(gfc_trans_omp_workshare): Rewritten.\n\n\t* testsuite/libgomp.fortran/workshare2.f90: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r146397", "tree": {"sha": "e982e6dcc0e7f77f8e2d84a9b5d59acecea11936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e982e6dcc0e7f77f8e2d84a9b5d59acecea11936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/comments", "author": {"login": "vliaskov", "id": 330408, "node_id": "MDQ6VXNlcjMzMDQwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vliaskov", "html_url": "https://github.com/vliaskov", "followers_url": "https://api.github.com/users/vliaskov/followers", "following_url": "https://api.github.com/users/vliaskov/following{/other_user}", "gists_url": "https://api.github.com/users/vliaskov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vliaskov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vliaskov/subscriptions", "organizations_url": "https://api.github.com/users/vliaskov/orgs", "repos_url": "https://api.github.com/users/vliaskov/repos", "events_url": "https://api.github.com/users/vliaskov/events{/privacy}", "received_events_url": "https://api.github.com/users/vliaskov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2907036db71b583f6a7c627e1e1753e85c779312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2907036db71b583f6a7c627e1e1753e85c779312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2907036db71b583f6a7c627e1e1753e85c779312"}], "stats": {"total": 348, "additions": 317, "deletions": 31}, "files": [{"sha": "3384aad93a22114ccdb81167f4e1d379ae67f8b5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -1,3 +1,20 @@\n+2009-04-20  Vasilis Liaskovitis  <vliaskov@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/35423\n+\t* trans.h (OMPWS_WORKSHARE_FLAG, OMPWS_CURR_SINGLEUNIT,\n+\tOMPWS_SCALARIZER_WS, OMPWS_NOWAIT): Define.\n+\t(ompws_flags): New extern decl.\n+\t* trans-array.c (gfc_trans_scalarized_loop_end): Build OMP_FOR\n+\tfor the outer dimension if ompws_flags allow it.\n+\t* trans.c (gfc_generate_code): Clear ompws_flags.\n+\t* trans-expr.c (gfc_trans_assignment_1): Allow worksharing\n+\tarray assignments inside of !$omp workshare.\n+\t* trans-stmt.c (gfc_trans_where_3): Similarly for where statements\n+\tand constructs.\n+\t* trans-openmp.c (ompws_flags): New variable.\n+\t(gfc_trans_omp_workshare): Rewritten.\n+\n 2009-04-11  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37746"}, {"sha": "47f4e0ce5b2fbe5bbe5996cd971e974a956f60bc", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 81, "deletions": 26, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -2697,41 +2697,96 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   tree tmp;\n   tree loopbody;\n   tree exit_label;\n+  tree stmt;\n+  tree init;\n+  tree incr;\n \n-  loopbody = gfc_finish_block (pbody);\n+  if ((ompws_flags & (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS))\n+      == (OMPWS_WORKSHARE_FLAG | OMPWS_SCALARIZER_WS)\n+      && n == loop->dimen - 1)\n+    {\n+      /* We create an OMP_FOR construct for the outermost scalarized loop.  */\n+      init = make_tree_vec (1);\n+      cond = make_tree_vec (1);\n+      incr = make_tree_vec (1);\n+\n+      /* Cycle statement is implemented with a goto.  Exit statement must not\n+\t be present for this loop.  */\n+      exit_label = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (exit_label) = 1;\n+\n+      /* Label for cycle statements (if needed).  */\n+      tmp = build1_v (LABEL_EXPR, exit_label);\n+      gfc_add_expr_to_block (pbody, tmp);\n+\n+      stmt = make_node (OMP_FOR);\n+\n+      TREE_TYPE (stmt) = void_type_node;\n+      OMP_FOR_BODY (stmt) = loopbody = gfc_finish_block (pbody);\n+\n+      OMP_FOR_CLAUSES (stmt) = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+      OMP_CLAUSE_SCHEDULE_KIND (OMP_FOR_CLAUSES (stmt))\n+\t= OMP_CLAUSE_SCHEDULE_STATIC;\n+      if (ompws_flags & OMPWS_NOWAIT)\n+\tOMP_CLAUSE_CHAIN (OMP_FOR_CLAUSES (stmt))\n+\t  = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+\n+      /* Initialize the loopvar.  */\n+      TREE_VEC_ELT (init, 0) = build2_v (MODIFY_EXPR, loop->loopvar[n],\n+\t\t\t\t\t loop->from[n]);\n+      OMP_FOR_INIT (stmt) = init;\n+      /* The exit condition.  */\n+      TREE_VEC_ELT (cond, 0) = build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t       loop->loopvar[n], loop->to[n]);\n+      OMP_FOR_COND (stmt) = cond;\n+      /* Increment the loopvar.  */\n+      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t  loop->loopvar[n], gfc_index_one_node);\n+      TREE_VEC_ELT (incr, 0) = fold_build2 (MODIFY_EXPR,\n+\t  void_type_node, loop->loopvar[n], tmp);\n+      OMP_FOR_INCR (stmt) = incr;\n+\n+      ompws_flags &= ~OMPWS_CURR_SINGLEUNIT;\n+      gfc_add_expr_to_block (&loop->code[n], stmt);\n+    }\n+  else\n+    {\n+      loopbody = gfc_finish_block (pbody);\n \n-  /* Initialize the loopvar.  */\n-  gfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n+      /* Initialize the loopvar.  */\n+      gfc_add_modify (&loop->code[n], loop->loopvar[n], loop->from[n]);\n \n-  exit_label = gfc_build_label_decl (NULL_TREE);\n+      exit_label = gfc_build_label_decl (NULL_TREE);\n \n-  /* Generate the loop body.  */\n-  gfc_init_block (&block);\n+      /* Generate the loop body.  */\n+      gfc_init_block (&block);\n \n-  /* The exit condition.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      loop->loopvar[n], loop->to[n]);\n-  tmp = build1_v (GOTO_EXPR, exit_label);\n-  TREE_USED (exit_label) = 1;\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n-  gfc_add_expr_to_block (&block, tmp);\n+      /* The exit condition.  */\n+      cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t loop->loopvar[n], loop->to[n]);\n+      tmp = build1_v (GOTO_EXPR, exit_label);\n+      TREE_USED (exit_label) = 1;\n+      tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+      gfc_add_expr_to_block (&block, tmp);\n \n-  /* The main body.  */\n-  gfc_add_expr_to_block (&block, loopbody);\n+      /* The main body.  */\n+      gfc_add_expr_to_block (&block, loopbody);\n \n-  /* Increment the loopvar.  */\n-  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t     loop->loopvar[n], gfc_index_one_node);\n-  gfc_add_modify (&block, loop->loopvar[n], tmp);\n+      /* Increment the loopvar.  */\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t loop->loopvar[n], gfc_index_one_node);\n+      gfc_add_modify (&block, loop->loopvar[n], tmp);\n \n-  /* Build the loop.  */\n-  tmp = gfc_finish_block (&block);\n-  tmp = build1_v (LOOP_EXPR, tmp);\n-  gfc_add_expr_to_block (&loop->code[n], tmp);\n+      /* Build the loop.  */\n+      tmp = gfc_finish_block (&block);\n+      tmp = build1_v (LOOP_EXPR, tmp);\n+      gfc_add_expr_to_block (&loop->code[n], tmp);\n+\n+      /* Add the exit label.  */\n+      tmp = build1_v (LABEL_EXPR, exit_label);\n+      gfc_add_expr_to_block (&loop->code[n], tmp);\n+    }\n \n-  /* Add the exit label.  */\n-  tmp = build1_v (LABEL_EXPR, exit_label);\n-  gfc_add_expr_to_block (&loop->code[n], tmp);\n }\n \n "}, {"sha": "2b67c6ddcd3c34cd49c24d09b005d18cd40f160a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -4598,6 +4598,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag)\n   rss = NULL;\n   if (lss != gfc_ss_terminator)\n     {\n+      /* Allow the scalarizer to workshare array assignments.  */\n+      if (ompws_flags & OMPWS_WORKSHARE_FLAG)\n+\tompws_flags |= OMPWS_SCALARIZER_WS;\n+\n       /* The assignment needs scalarization.  */\n       lss_section = lss;\n "}, {"sha": "5ad2f9cc6697a7ddc66cfd66624dcec571d2925f", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 158, "deletions": 3, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -1,5 +1,5 @@\n /* OpenMP directive translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>\n \n This file is part of GCC.\n@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"arith.h\"\n \n+int ompws_flags;\n \n /* True if OpenMP should privatize what this DECL points to rather\n    than the DECL itself.  */\n@@ -1544,8 +1545,162 @@ gfc_trans_omp_taskwait (void)\n static tree\n gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n {\n-  /* XXX */\n-  return gfc_trans_omp_single (code, clauses);\n+  tree res, tmp, stmt;\n+  stmtblock_t block, *pblock = NULL;\n+  stmtblock_t singleblock;\n+  int saved_ompws_flags;\n+  bool singleblock_in_progress = false;\n+  /* True if previous gfc_code in workshare construct is not workshared.  */\n+  bool prev_singleunit;\n+\n+  code = code->block->next;\n+\n+  pushlevel (0);\n+\n+  if (!code)\n+    return build_empty_stmt ();\n+\n+  gfc_start_block (&block);\n+  pblock = &block;\n+\n+  ompws_flags = OMPWS_WORKSHARE_FLAG;\n+  prev_singleunit = false;\n+\n+  /* Translate statements one by one to trees until we reach\n+     the end of the workshare construct.  Adjacent gfc_codes that\n+     are a single unit of work are clustered and encapsulated in a\n+     single OMP_SINGLE construct.  */\n+  for (; code; code = code->next)\n+    {\n+      if (code->here != 0)\n+\t{\n+\t  res = gfc_trans_label_here (code);\n+\t  gfc_add_expr_to_block (pblock, res);\n+\t}\n+\n+      /* No dependence analysis, use for clauses with wait.\n+\t If this is the last gfc_code, use default omp_clauses.  */\n+      if (code->next == NULL && clauses->nowait)\n+\tompws_flags |= OMPWS_NOWAIT;\n+\n+      /* By default, every gfc_code is a single unit of work.  */\n+      ompws_flags |= OMPWS_CURR_SINGLEUNIT;\n+      ompws_flags &= ~OMPWS_SCALARIZER_WS;\n+\n+      switch (code->op)\n+\t{\n+\tcase EXEC_NOP:\n+\t  res = NULL_TREE;\n+\t  break;\n+\n+\tcase EXEC_ASSIGN:\n+\t  res = gfc_trans_assign (code);\n+\t  break;\n+\n+\tcase EXEC_POINTER_ASSIGN:\n+\t  res = gfc_trans_pointer_assign (code);\n+\t  break;\n+\n+\tcase EXEC_INIT_ASSIGN:\n+\t  res = gfc_trans_init_assign (code);\n+\t  break;\n+\n+\tcase EXEC_FORALL:\n+\t  res = gfc_trans_forall (code);\n+\t  break;\n+\n+\tcase EXEC_WHERE:\n+\t  res = gfc_trans_where (code);\n+\t  break;\n+\n+\tcase EXEC_OMP_ATOMIC:\n+\t  res = gfc_trans_omp_directive (code);\n+\t  break;\n+\n+\tcase EXEC_OMP_PARALLEL:\n+\tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_SECTIONS:\n+\tcase EXEC_OMP_PARALLEL_WORKSHARE:\n+\tcase EXEC_OMP_CRITICAL:\n+\t  saved_ompws_flags = ompws_flags;\n+\t  ompws_flags = 0;\n+\t  res = gfc_trans_omp_directive (code);\n+\t  ompws_flags = saved_ompws_flags;\n+\t  break;\n+\t\n+\tdefault:\n+\t  internal_error (\"gfc_trans_omp_workshare(): Bad statement code\");\n+\t}\n+\n+      gfc_set_backend_locus (&code->loc);\n+\n+      if (res != NULL_TREE && ! IS_EMPTY_STMT (res))\n+\t{\n+\t  if (TREE_CODE (res) == STATEMENT_LIST)\n+\t    tree_annotate_all_with_location (&res, input_location);\n+\t  else\n+\t    SET_EXPR_LOCATION (res, input_location);\n+\n+\t  if (prev_singleunit)\n+\t    {\n+\t      if (ompws_flags & OMPWS_CURR_SINGLEUNIT)\n+\t\t/* Add current gfc_code to single block.  */\n+\t\tgfc_add_expr_to_block (&singleblock, res);\n+\t      else\n+\t\t{\n+\t\t  /* Finish single block and add it to pblock.  */\n+\t\t  tmp = gfc_finish_block (&singleblock);\n+\t\t  tmp = build2 (OMP_SINGLE, void_type_node, tmp, NULL_TREE);\n+\t\t  gfc_add_expr_to_block (pblock, tmp);\n+\t\t  /* Add current gfc_code to pblock.  */\n+\t\t  gfc_add_expr_to_block (pblock, res);\n+\t\t  singleblock_in_progress = false;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (ompws_flags & OMPWS_CURR_SINGLEUNIT)\n+\t\t{\n+\t\t  /* Start single block.  */\n+\t\t  gfc_init_block (&singleblock);\n+\t\t  gfc_add_expr_to_block (&singleblock, res);\n+\t\t  singleblock_in_progress = true;\n+\t\t}\n+\t      else\n+\t\t/* Add the new statement to the block.  */\n+\t\tgfc_add_expr_to_block (pblock, res);\n+\t    }\n+\t  prev_singleunit = (ompws_flags & OMPWS_CURR_SINGLEUNIT) != 0;\n+\t}\n+    }\n+\n+  /* Finish remaining SINGLE block, if we were in the middle of one.  */\n+  if (singleblock_in_progress)\n+    {\n+      /* Finish single block and add it to pblock.  */\n+      tmp = gfc_finish_block (&singleblock);\n+      tmp = build2 (OMP_SINGLE, void_type_node, tmp,\n+\t\t    clauses->nowait\n+\t\t    ? build_omp_clause (OMP_CLAUSE_NOWAIT) : NULL_TREE);\n+      gfc_add_expr_to_block (pblock, tmp);\n+    }\n+\n+  stmt = gfc_finish_block (pblock);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    {\n+      if (!IS_EMPTY_STMT (stmt))\n+\t{\n+\t  tree bindblock = poplevel (1, 0, 0);\n+\t  stmt = build3_v (BIND_EXPR, NULL, stmt, bindblock);\n+\t}\n+      else\n+\tpoplevel (0, 0, 0);\n+    }\n+  else\n+    poplevel (0, 0, 0);\n+\n+  ompws_flags = 0;\n+  return stmt;\n }\n \n tree"}, {"sha": "e96c0afc4c7f1ee2dc68d620f561fedc92ebfa8f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -3696,6 +3696,10 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n   gfc_ss *edss = 0;\n   gfc_ss *esss = 0;\n \n+  /* Allow the scalarizer to workshare simple where loops.  */\n+  if (ompws_flags & OMPWS_WORKSHARE_FLAG)\n+    ompws_flags |= OMPWS_SCALARIZER_WS;\n+\n   cond = cblock->expr;\n   tdst = cblock->next->expr;\n   tsrc = cblock->next->expr2;"}, {"sha": "e926a950fcf415a93100958cf33979dd9f09ca19", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -1259,6 +1259,7 @@ gfc_trans_code (gfc_code * code)\n void\n gfc_generate_code (gfc_namespace * ns)\n {\n+  ompws_flags = 0;\n   if (ns->is_block_data)\n     {\n       gfc_generate_block_data (ns);"}, {"sha": "2c531ec263672df84cb0571d38fc81b3662a4386", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -1,6 +1,6 @@\n /* Header for code translation functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of GCC.\n@@ -766,5 +766,12 @@ extern const char gfc_msg_bounds[];\n extern const char gfc_msg_fault[];\n extern const char gfc_msg_wrong_return[];\n \n+#define OMPWS_WORKSHARE_FLAG\t1\t/* Set if in a workshare construct.  */\n+#define OMPWS_CURR_SINGLEUNIT\t2\t/* Set if current gfc_code in workshare\n+\t\t\t\t\t   construct is not workshared.  */\n+#define OMPWS_SCALARIZER_WS\t4\t/* Set if scalarizer should attempt\n+\t\t\t\t\t   to create parallel loops.  */\n+#define OMPWS_NOWAIT\t\t8\t/* Use NOWAIT on OMP_FOR.  */\n+extern int ompws_flags;\n \n #endif /* GFC_TRANS_H */"}, {"sha": "e7183d589b67eb400d05d56206b254c6c96ca6d7", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -1,3 +1,9 @@\n+2009-04-20  Vasilis Liaskovitis  <vliaskov@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR fortran/35423\n+\t* testsuite/libgomp.fortran/workshare2.f90: New test.\n+\n 2009-04-09  Nick Clifton  <nickc@redhat.com>\n \n \t* iter.c: Change copyright header to refer to version 3 of the"}, {"sha": "1b749a6cf0571caa1e3edfdd29328f6895fdf8c2", "filename": "libgomp/testsuite/libgomp.fortran/workshare2.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare2.f90?ref=34d01e1d17222f8a4a6f01f9ad1055d0c001ce6a", "patch": "@@ -0,0 +1,37 @@\n+subroutine f1\n+  integer a(20:50,70:90)\n+!$omp parallel workshare\n+  a(:,:) = 17\n+!$omp end parallel workshare\n+  if (any (a.ne.17)) call abort\n+end subroutine f1\n+subroutine f2\n+  integer a(20:50,70:90),d(15),e(15),f(15)\n+  integer b, c, i\n+!$omp parallel workshare\n+  c = 5\n+  a(:,:) = 17\n+  b = 4\n+  d = (/ 0, 1, 2, 3, 4, 0, 6, 7, 8, 9, 10, 0, 0, 13, 14 /)\n+  forall (i=1:15, d(i) /= 0)\n+     d(i) = 0\n+  end forall\n+  e = (/ 4, 5, 2, 6, 4, 5, 2, 6, 4, 5, 2, 6, 4, 5, 2 /)\n+  f = 7\n+  where (e.ge.5) f = f + 1\n+!$omp end parallel workshare\n+  if (any (a.ne.17)) call abort\n+  if (c.ne.5.or.b.ne.4) call abort\n+  if (any(d.ne.0)) call abort\n+  do i = 1, 15\n+    if (e(i).ge.5) then\n+      if (f(i).ne.8) call abort\n+    else\n+      if (f(i).ne.7) call abort\n+    end if\n+  end do\n+end subroutine f2\n+\n+  call f1\n+  call f2\n+end"}]}