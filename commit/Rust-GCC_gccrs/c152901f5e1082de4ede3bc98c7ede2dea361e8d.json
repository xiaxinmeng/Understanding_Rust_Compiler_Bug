{"sha": "c152901f5e1082de4ede3bc98c7ede2dea361e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE1MjkwMWY1ZTEwODJkZTRlZGUzYmM5OGM3ZWRlMmRlYTM2MWU4ZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-09-17T17:22:05Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-09-17T17:22:05Z"}, "message": "tree-flow.h (ssa_undefined_value_p): Remove prototype.\n\n2013-09-17  Andrew MacLeod <amacleod@redhat.com>\n\n\t* tree-flow.h (ssa_undefined_value_p): Remove prototype.\n\t* tree-ssa.c (ssa_undefined_value_p): Move pass independent parts here.\n\t(warn_uninit, warn_uninitialized_vars, execute_early_warn_uninitialized,\n\tmake_pass_early_warn_uninitialized): Move to tree-ssa-uninit.c.\n\t* tree-ssa-uninit.c (ssa_undefined_value_p): Move to tree-ssa.c\n\t(has_undefined_value_p): New.  Pass dependant parts of \n\tssa_undefined_value_p.\n\t(uninit_undefined_value_p): Use has_undefined_value_p.\n\t(warn_uninit, warn_uninitialized_vars, execute_early_warn_uninitialized,\n\tmake_pass_early_warn_uninitialized): Move from tree-ssa.c\n\t* tree-ssa.h: Adjust prototypes\n\nFrom-SVN: r202659", "tree": {"sha": "ba3badb1ebc6b822039de7c1796a0f9d5805f0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba3badb1ebc6b822039de7c1796a0f9d5805f0c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c152901f5e1082de4ede3bc98c7ede2dea361e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c152901f5e1082de4ede3bc98c7ede2dea361e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c152901f5e1082de4ede3bc98c7ede2dea361e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c152901f5e1082de4ede3bc98c7ede2dea361e8d/comments", "author": null, "committer": null, "parents": [{"sha": "cdb87c08f66da0d5b6ae8ee9b3d2f917813a3cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb87c08f66da0d5b6ae8ee9b3d2f917813a3cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb87c08f66da0d5b6ae8ee9b3d2f917813a3cf1"}], "stats": {"total": 493, "additions": 254, "deletions": 239}, "files": [{"sha": "eb162f4a2b2125e86da17e9c04a232681fea1306", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c152901f5e1082de4ede3bc98c7ede2dea361e8d", "patch": "@@ -1,3 +1,17 @@\n+2013-09-17  Andrew MacLeod <amacleod@redhat.com>\n+\n+\t* tree-flow.h (ssa_undefined_value_p): Remove prototype.\n+\t* tree-ssa.c (ssa_undefined_value_p): Move pass independent parts here.\n+\t(warn_uninit, warn_uninitialized_vars, execute_early_warn_uninitialized,\n+\tmake_pass_early_warn_uninitialized): Move to tree-ssa-uninit.c.\n+\t* tree-ssa-uninit.c (ssa_undefined_value_p): Move to tree-ssa.c\n+\t(has_undefined_value_p): New.  Pass dependant parts of \n+\tssa_undefined_value_p.\n+\t(uninit_undefined_value_p): Use has_undefined_value_p.\n+\t(warn_uninit, warn_uninitialized_vars, execute_early_warn_uninitialized,\n+\tmake_pass_early_warn_uninitialized): Move from tree-ssa.c\n+\t* tree-ssa.h: Adjust prototypes\n+\n 2013-09-17  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/58329"}, {"sha": "2f64abc2bbde7a52e984fb2a4b782d0defed0f88", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c152901f5e1082de4ede3bc98c7ede2dea361e8d", "patch": "@@ -421,9 +421,6 @@ extern bool gimple_seq_may_fallthru (gimple_seq);\n extern bool gimple_stmt_may_fallthru (gimple);\n extern bool gimple_check_call_matching_types (gimple, tree, bool);\n \n-/* In tree-ssa-uninit.c  */\n-extern bool ssa_undefined_value_p (tree);\n-\n /* In tree-into-ssa.c  */\n void update_ssa (unsigned);\n void delete_update_ssa (void);"}, {"sha": "bd46ddfb18ee08df6cef31f485854fb1e4f53344", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 214, "deletions": 25, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=c152901f5e1082de4ede3bc98c7ede2dea361e8d", "patch": "@@ -74,46 +74,173 @@ get_mask_first_set_bit (unsigned mask)\n }\n #define MASK_FIRST_SET_BIT(mask) get_mask_first_set_bit (mask)\n \n-\n /* Return true if T, an SSA_NAME, has an undefined value.  */\n-\n-bool\n-ssa_undefined_value_p (tree t)\n+static bool\n+has_undefined_value_p (tree t)\n {\n-  tree var = SSA_NAME_VAR (t);\n-\n-  if (!var)\n-    ;\n-  /* Parameters get their initial value from the function entry.  */\n-  else if (TREE_CODE (var) == PARM_DECL)\n-    return false;\n-  /* When returning by reference the return address is actually a hidden\n-     parameter.  */\n-  else if (TREE_CODE (var) == RESULT_DECL && DECL_BY_REFERENCE (var))\n-    return false;\n-  /* Hard register variables get their initial value from the ether.  */\n-  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n-    return false;\n-\n-  /* The value is undefined iff its definition statement is empty.  */\n-  return (gimple_nop_p (SSA_NAME_DEF_STMT (t))\n+  return (ssa_undefined_value_p (t)\n           || (possibly_undefined_names\n               && pointer_set_contains (possibly_undefined_names, t)));\n }\n \n-/* Like ssa_undefined_value_p, but don't return true if TREE_NO_WARNING\n+\n+\n+/* Like has_undefined_value_p, but don't return true if TREE_NO_WARNING\n    is set on SSA_NAME_VAR.  */\n \n static inline bool\n-uninit_undefined_value_p (tree t)\n-{\n-  if (!ssa_undefined_value_p (t))\n+uninit_undefined_value_p (tree t) {\n+  if (!has_undefined_value_p (t))\n     return false;\n   if (SSA_NAME_VAR (t) && TREE_NO_WARNING (SSA_NAME_VAR (t)))\n     return false;\n   return true;\n }\n \n+/* Emit warnings for uninitialized variables.  This is done in two passes.\n+\n+   The first pass notices real uses of SSA names with undefined values.\n+   Such uses are unconditionally uninitialized, and we can be certain that\n+   such a use is a mistake.  This pass is run before most optimizations,\n+   so that we catch as many as we can.\n+\n+   The second pass follows PHI nodes to find uses that are potentially\n+   uninitialized.  In this case we can't necessarily prove that the use\n+   is really uninitialized.  This pass is run after most optimizations,\n+   so that we thread as many jumps and possible, and delete as much dead\n+   code as possible, in order to reduce false positives.  We also look\n+   again for plain uninitialized variables, since optimization may have\n+   changed conditionally uninitialized to unconditionally uninitialized.  */\n+\n+/* Emit a warning for EXPR based on variable VAR at the point in the\n+   program T, an SSA_NAME, is used being uninitialized.  The exact\n+   warning text is in MSGID and LOCUS may contain a location or be null.\n+   WC is the warning code.  */\n+\n+static void\n+warn_uninit (enum opt_code wc, tree t,\n+\t     tree expr, tree var, const char *gmsgid, void *data)\n+{\n+  gimple context = (gimple) data;\n+  location_t location, cfun_loc;\n+  expanded_location xloc, floc;\n+\n+  if (!has_undefined_value_p (t))\n+    return;\n+\n+  /* TREE_NO_WARNING either means we already warned, or the front end\n+     wishes to suppress the warning.  */\n+  if ((context\n+       && (gimple_no_warning_p (context)\n+\t   || (gimple_assign_single_p (context)\n+\t       && TREE_NO_WARNING (gimple_assign_rhs1 (context)))))\n+      || TREE_NO_WARNING (expr))\n+    return;\n+\n+  location = (context != NULL && gimple_has_location (context))\n+\t     ? gimple_location (context)\n+\t     : DECL_SOURCE_LOCATION (var);\n+  location = linemap_resolve_location (line_table, location,\n+\t\t\t\t       LRK_SPELLING_LOCATION,\n+\t\t\t\t       NULL);\n+  cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n+  xloc = expand_location (location);\n+  floc = expand_location (cfun_loc);\n+  if (warning_at (location, wc, gmsgid, expr))\n+    {\n+      TREE_NO_WARNING (expr) = 1;\n+\n+      if (location == DECL_SOURCE_LOCATION (var))\n+\treturn;\n+      if (xloc.file != floc.file\n+\t  || linemap_location_before_p (line_table,\n+\t\t\t\t\tlocation, cfun_loc)\n+\t  || linemap_location_before_p (line_table,\n+\t\t\t\t\tcfun->function_end_locus,\n+\t\t\t\t\tlocation))\n+\tinform (DECL_SOURCE_LOCATION (var), \"%qD was declared here\", var);\n+    }\n+}\n+\n+static unsigned int\n+warn_uninitialized_vars (bool warn_possibly_uninitialized)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n+\t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR), bb);\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  use_operand_p use_p;\n+\t  ssa_op_iter op_iter;\n+\t  tree use;\n+\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n+\t  /* We only do data flow with SSA_NAMEs, so that's all we\n+\t     can warn about.  */\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, op_iter, SSA_OP_USE)\n+\t    {\n+\t      use = USE_FROM_PTR (use_p);\n+\t      if (always_executed)\n+\t\twarn_uninit (OPT_Wuninitialized, use,\n+\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n+\t\t\t     \"%qD is used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t      else if (warn_possibly_uninitialized)\n+\t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n+\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n+\t\t\t     \"%qD may be used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t    }\n+\n+\t  /* For memory the only cheap thing we can do is see if we\n+\t     have a use of the default def of the virtual operand.\n+\t     ???  Note that at -O0 we do not have virtual operands.\n+\t     ???  Not so cheap would be to use the alias oracle via\n+\t     walk_aliased_vdefs, if we don't find any aliasing vdef\n+\t     warn as is-used-uninitialized, if we don't find an aliasing\n+\t     vdef that kills our use (stmt_kills_ref_p), warn as\n+\t     may-be-used-uninitialized.  But this walk is quadratic and\n+\t     so must be limited which means we would miss warning\n+\t     opportunities.  */\n+\t  use = gimple_vuse (stmt);\n+\t  if (use\n+\t      && gimple_assign_single_p (stmt)\n+\t      && !gimple_vdef (stmt)\n+\t      && SSA_NAME_IS_DEFAULT_DEF (use))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      tree base = get_base_address (rhs);\n+\n+\t      /* Do not warn if it can be initialized outside this function.  */\n+\t      if (TREE_CODE (base) != VAR_DECL\n+\t\t  || DECL_HARD_REGISTER (base)\n+\t\t  || is_global_var (base))\n+\t\tcontinue;\n+\n+\t      if (always_executed)\n+\t\twarn_uninit (OPT_Wuninitialized, use, \n+\t\t\t     gimple_assign_rhs1 (stmt), base,\n+\t\t\t     \"%qE is used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t      else if (warn_possibly_uninitialized)\n+\t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n+\t\t\t     gimple_assign_rhs1 (stmt), base,\n+\t\t\t     \"%qE may be used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t    }\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Checks if the operand OPND of PHI is defined by \n    another phi with one operand defined by this PHI, \n    but the rest operands are all defined. If yes, \n@@ -2084,3 +2211,65 @@ make_pass_late_warn_uninitialized (gcc::context *ctxt)\n {\n   return new pass_late_warn_uninitialized (ctxt);\n }\n+\n+\n+static unsigned int\n+execute_early_warn_uninitialized (void)\n+{\n+  /* Currently, this pass runs always but\n+     execute_late_warn_uninitialized only runs with optimization. With\n+     optimization we want to warn about possible uninitialized as late\n+     as possible, thus don't do it here.  However, without\n+     optimization we need to warn here about \"may be uninitialized\".\n+  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n+  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n+\n+  /* Post-dominator information can not be reliably updated. Free it\n+     after the use.  */\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  return 0;\n+}\n+\n+\n+namespace {\n+\n+const pass_data pass_data_early_warn_uninitialized =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*early_warn_uninitialized\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_TREE_UNINIT, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_early_warn_uninitialized : public gimple_opt_pass\n+{\n+public:\n+  pass_early_warn_uninitialized(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_early_warn_uninitialized, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_warn_uninitialized (); }\n+  unsigned int execute () { return execute_early_warn_uninitialized (); }\n+\n+}; // class pass_early_warn_uninitialized\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_early_warn_uninitialized (gcc::context *ctxt)\n+{\n+  return new pass_early_warn_uninitialized (ctxt);\n+}\n+\n+"}, {"sha": "8146e1fed1d46ed1ba1bb01c612ecb86c3de597c", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 25, "deletions": 209, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c152901f5e1082de4ede3bc98c7ede2dea361e8d", "patch": "@@ -1193,6 +1193,31 @@ tree_ssa_strip_useless_type_conversions (tree exp)\n }\n \n \n+/* Return true if T, an SSA_NAME, has an undefined value.  */\n+\n+bool\n+ssa_undefined_value_p (tree t)\n+{\n+  tree var = SSA_NAME_VAR (t);\n+\n+  if (!var)\n+    ;\n+  /* Parameters get their initial value from the function entry.  */\n+  else if (TREE_CODE (var) == PARM_DECL)\n+    return false;\n+  /* When returning by reference the return address is actually a hidden\n+     parameter.  */\n+  else if (TREE_CODE (var) == RESULT_DECL && DECL_BY_REFERENCE (var))\n+    return false;\n+  /* Hard register variables get their initial value from the ether.  */\n+  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n+    return false;\n+\n+  /* The value is undefined iff its definition statement is empty.  */\n+  return gimple_nop_p (SSA_NAME_DEF_STMT (t));\n+}\n+\n+\n /* Internal helper for walk_use_def_chains.  VAR, FN and DATA are as\n    described in walk_use_def_chains.\n \n@@ -1301,215 +1326,6 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n     }\n }\n \n-\f\n-/* Emit warnings for uninitialized variables.  This is done in two passes.\n-\n-   The first pass notices real uses of SSA names with undefined values.\n-   Such uses are unconditionally uninitialized, and we can be certain that\n-   such a use is a mistake.  This pass is run before most optimizations,\n-   so that we catch as many as we can.\n-\n-   The second pass follows PHI nodes to find uses that are potentially\n-   uninitialized.  In this case we can't necessarily prove that the use\n-   is really uninitialized.  This pass is run after most optimizations,\n-   so that we thread as many jumps and possible, and delete as much dead\n-   code as possible, in order to reduce false positives.  We also look\n-   again for plain uninitialized variables, since optimization may have\n-   changed conditionally uninitialized to unconditionally uninitialized.  */\n-\n-/* Emit a warning for EXPR based on variable VAR at the point in the\n-   program T, an SSA_NAME, is used being uninitialized.  The exact\n-   warning text is in MSGID and LOCUS may contain a location or be null.\n-   WC is the warning code.  */\n-\n-void\n-warn_uninit (enum opt_code wc, tree t,\n-\t     tree expr, tree var, const char *gmsgid, void *data)\n-{\n-  gimple context = (gimple) data;\n-  location_t location, cfun_loc;\n-  expanded_location xloc, floc;\n-\n-  if (!ssa_undefined_value_p (t))\n-    return;\n-\n-  /* TREE_NO_WARNING either means we already warned, or the front end\n-     wishes to suppress the warning.  */\n-  if ((context\n-       && (gimple_no_warning_p (context)\n-\t   || (gimple_assign_single_p (context)\n-\t       && TREE_NO_WARNING (gimple_assign_rhs1 (context)))))\n-      || TREE_NO_WARNING (expr))\n-    return;\n-\n-  location = (context != NULL && gimple_has_location (context))\n-\t     ? gimple_location (context)\n-\t     : DECL_SOURCE_LOCATION (var);\n-  location = linemap_resolve_location (line_table, location,\n-\t\t\t\t       LRK_SPELLING_LOCATION,\n-\t\t\t\t       NULL);\n-  cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n-  xloc = expand_location (location);\n-  floc = expand_location (cfun_loc);\n-  if (warning_at (location, wc, gmsgid, expr))\n-    {\n-      TREE_NO_WARNING (expr) = 1;\n-\n-      if (location == DECL_SOURCE_LOCATION (var))\n-\treturn;\n-      if (xloc.file != floc.file\n-\t  || linemap_location_before_p (line_table,\n-\t\t\t\t\tlocation, cfun_loc)\n-\t  || linemap_location_before_p (line_table,\n-\t\t\t\t\tcfun->function_end_locus,\n-\t\t\t\t\tlocation))\n-\tinform (DECL_SOURCE_LOCATION (var), \"%qD was declared here\", var);\n-    }\n-}\n-\n-unsigned int\n-warn_uninitialized_vars (bool warn_possibly_uninitialized)\n-{\n-  gimple_stmt_iterator gsi;\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR), bb);\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  use_operand_p use_p;\n-\t  ssa_op_iter op_iter;\n-\t  tree use;\n-\n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n-\n-\t  /* We only do data flow with SSA_NAMEs, so that's all we\n-\t     can warn about.  */\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, op_iter, SSA_OP_USE)\n-\t    {\n-\t      use = USE_FROM_PTR (use_p);\n-\t      if (always_executed)\n-\t\twarn_uninit (OPT_Wuninitialized, use,\n-\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n-\t\t\t     \"%qD is used uninitialized in this function\",\n-\t\t\t     stmt);\n-\t      else if (warn_possibly_uninitialized)\n-\t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n-\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n-\t\t\t     \"%qD may be used uninitialized in this function\",\n-\t\t\t     stmt);\n-\t    }\n-\n-\t  /* For memory the only cheap thing we can do is see if we\n-\t     have a use of the default def of the virtual operand.\n-\t     ???  Note that at -O0 we do not have virtual operands.\n-\t     ???  Not so cheap would be to use the alias oracle via\n-\t     walk_aliased_vdefs, if we don't find any aliasing vdef\n-\t     warn as is-used-uninitialized, if we don't find an aliasing\n-\t     vdef that kills our use (stmt_kills_ref_p), warn as\n-\t     may-be-used-uninitialized.  But this walk is quadratic and\n-\t     so must be limited which means we would miss warning\n-\t     opportunities.  */\n-\t  use = gimple_vuse (stmt);\n-\t  if (use\n-\t      && gimple_assign_single_p (stmt)\n-\t      && !gimple_vdef (stmt)\n-\t      && SSA_NAME_IS_DEFAULT_DEF (use))\n-\t    {\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      tree base = get_base_address (rhs);\n-\n-\t      /* Do not warn if it can be initialized outside this function.  */\n-\t      if (TREE_CODE (base) != VAR_DECL\n-\t\t  || DECL_HARD_REGISTER (base)\n-\t\t  || is_global_var (base))\n-\t\tcontinue;\n-\n-\t      if (always_executed)\n-\t\twarn_uninit (OPT_Wuninitialized, use, \n-\t\t\t     gimple_assign_rhs1 (stmt), base,\n-\t\t\t     \"%qE is used uninitialized in this function\",\n-\t\t\t     stmt);\n-\t      else if (warn_possibly_uninitialized)\n-\t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n-\t\t\t     gimple_assign_rhs1 (stmt), base,\n-\t\t\t     \"%qE may be used uninitialized in this function\",\n-\t\t\t     stmt);\n-\t    }\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-static unsigned int\n-execute_early_warn_uninitialized (void)\n-{\n-  /* Currently, this pass runs always but\n-     execute_late_warn_uninitialized only runs with optimization. With\n-     optimization we want to warn about possible uninitialized as late\n-     as possible, thus don't do it here.  However, without\n-     optimization we need to warn here about \"may be uninitialized\".\n-  */\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n-\n-  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n-\n-  /* Post-dominator information can not be reliably updated. Free it\n-     after the use.  */\n-\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-  return 0;\n-}\n-\n-static bool\n-gate_warn_uninitialized (void)\n-{\n-  return warn_uninitialized != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_early_warn_uninitialized =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"*early_warn_uninitialized\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_TREE_UNINIT, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_early_warn_uninitialized : public gimple_opt_pass\n-{\n-public:\n-  pass_early_warn_uninitialized(gcc::context *ctxt)\n-    : gimple_opt_pass(pass_data_early_warn_uninitialized, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_warn_uninitialized (); }\n-  unsigned int execute () { return execute_early_warn_uninitialized (); }\n-\n-}; // class pass_early_warn_uninitialized\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_early_warn_uninitialized (gcc::context *ctxt)\n-{\n-  return new pass_early_warn_uninitialized (ctxt);\n-}\n-\n \n /* If necessary, rewrite the base of the reference tree *TP from\n    a MEM_REF to a plain or converted symbol.  */"}, {"sha": "1808b1c447a5affbebd4d7bc6a7b9f00a4935312", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152901f5e1082de4ede3bc98c7ede2dea361e8d/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=c152901f5e1082de4ede3bc98c7ede2dea361e8d", "patch": "@@ -58,8 +58,7 @@ extern tree tree_ssa_strip_useless_type_conversions (tree);\n typedef bool (*walk_use_def_chains_fn) (tree, gimple, void *);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n \n-extern void warn_uninit (enum opt_code, tree, tree, tree, const char *, void *);\n-extern unsigned int warn_uninitialized_vars (bool);\n+extern bool ssa_undefined_value_p (tree);\n extern void execute_update_addresses_taken (void);\n \n /* Given an edge_var_map V, return the PHI arg definition.  */"}]}