{"sha": "ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiN2IxMGI2ZDQ0ZWQ4ZmNiYzgzMTg1MzRiYWM5OGJjMjk2NDNlZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-03-05T02:15:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-03-05T02:15:23Z"}, "message": "haifa-sched.c (free_list): Rename from free_pnd_lst.\n\n* haifa-sched.c (free_list): Rename from free_pnd_lst.\n(free_pending_lists): Rename free_pnd_lst uses.\n(remove_dependence): Place expunged element on unused_insn_list.\n(alloc_INSN_LIST, alloc_EXPR_LIST): New.  Change all callers of\ngen_rtx_*_LIST and alloc_rtx to use them.\n(compute_block_backward_dependences): Free the reg_last_* lists.\n\nFrom-SVN: r18415", "tree": {"sha": "970e60ce8a22cbecfaa5baa3350e81bd5ec81202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/970e60ce8a22cbecfaa5baa3350e81bd5ec81202"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef/comments", "author": null, "committer": null, "parents": [{"sha": "c940e6278c9fd4961a7d4299e36dba342de98764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c940e6278c9fd4961a7d4299e36dba342de98764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c940e6278c9fd4961a7d4299e36dba342de98764"}], "stats": {"total": 307, "additions": 168, "deletions": 139}, "files": [{"sha": "c99b2d2a00cec79b4cd1ca2ac027f7d37b1a3d6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "patch": "@@ -1,3 +1,12 @@\n+Thu Mar  5 02:14:44 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (free_list): Rename from free_pnd_lst.\n+\t(free_pending_lists): Rename free_pnd_lst uses.\n+\t(remove_dependence): Place expunged element on unused_insn_list.\n+\t(alloc_INSN_LIST, alloc_EXPR_LIST): New.  Change all callers of\n+\tgen_rtx_*_LIST and alloc_rtx to use them.\n+\t(compute_block_backward_dependences): Free the reg_last_* lists.\n+\n Thu Mar  5 00:05:40 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* cccp.c (main): Avoid undefined behavior when setting pend_includes"}, {"sha": "99f01f6fc16f96ec5145954490941b47d70003ec", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 159, "deletions": 139, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "patch": "@@ -791,6 +791,80 @@ static void split_block_insns PROTO ((int));\n \n /* Helper functions for instruction scheduling.  */\n \n+/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */\n+static rtx unused_insn_list;\n+\n+/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n+static rtx unused_expr_list;\n+\n+static void free_list PROTO ((rtx *, rtx *));\n+static rtx alloc_INSN_LIST PROTO ((rtx, rtx));\n+static rtx alloc_EXPR_LIST PROTO ((int, rtx, rtx));\n+\n+static void\n+free_list (listp, unused_listp)\n+     rtx *listp, *unused_listp;\n+{\n+  register rtx link, prev_link;\n+\n+  if (*listp == 0)\n+    return;\n+\n+  prev_link = *listp;\n+  link = XEXP (prev_link, 1);\n+\n+  while (link)\n+    {\n+      prev_link = link;\n+      link = XEXP (link, 1);\n+    }\n+\n+  XEXP (prev_link, 1) = *unused_listp;\n+  *unused_listp = *listp;\n+  *listp = 0;\n+}\n+\n+rtx\n+alloc_INSN_LIST (val, next)\n+     rtx val, next;\n+{\n+  rtx r;\n+\n+  if (unused_insn_list)\n+    {\n+      r = unused_insn_list;\n+      unused_insn_list = XEXP (r, 1);\n+      XEXP (r, 0) = val;\n+      XEXP (r, 1) = next;\n+      PUT_REG_NOTE_KIND (r, VOIDmode);\n+    }\n+  else\n+    r = gen_rtx_INSN_LIST (VOIDmode, val, next);\n+\n+  return r;\n+}\n+\n+rtx\n+alloc_EXPR_LIST (kind, val, next)\n+     int kind;\n+     rtx val, next;\n+{\n+  rtx r;\n+\n+  if (unused_insn_list)\n+    {\n+      r = unused_insn_list;\n+      unused_insn_list = XEXP (r, 1);\n+      XEXP (r, 0) = val;\n+      XEXP (r, 1) = next;\n+      PUT_REG_NOTE_KIND (r, kind);\n+    }\n+  else\n+    r = gen_rtx_EXPR_LIST (kind, val, next);\n+\n+  return r;\n+}\n+\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n    of dependence that this link represents.  */\n@@ -865,12 +939,11 @@ add_dependence (insn, elem, dep_type)\n       }\n   /* Might want to check one level of transitivity to save conses.  */\n \n-  link = rtx_alloc (INSN_LIST);\n+  link = alloc_INSN_LIST (elem, LOG_LINKS (insn));\n+  LOG_LINKS (insn) = link;\n+\n   /* Insn dependency, not data dependency.  */\n   PUT_REG_NOTE_KIND (link, dep_type);\n-  XEXP (link, 0) = elem;\n-  XEXP (link, 1) = LOG_LINKS (insn);\n-  LOG_LINKS (insn) = link;\n }\n \n /* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n@@ -881,18 +954,22 @@ remove_dependence (insn, elem)\n      rtx insn;\n      rtx elem;\n {\n-  rtx prev, link;\n+  rtx prev, link, next;\n   int found = 0;\n \n-  for (prev = 0, link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+  for (prev = 0, link = LOG_LINKS (insn); link; link = next)\n     {\n+      next = XEXP (link, 1);\n       if (XEXP (link, 0) == elem)\n \t{\n-\t  RTX_INTEGRATED_P (link) = 1;\n \t  if (prev)\n-\t    XEXP (prev, 1) = XEXP (link, 1);\n+\t    XEXP (prev, 1) = next;\n \t  else\n-\t    LOG_LINKS (insn) = XEXP (link, 1);\n+\t    LOG_LINKS (insn) = next;\n+\n+\t  XEXP (link, 1) = unused_insn_list;\n+\t  unused_insn_list = link;\n+\n \t  found = 1;\n \t}\n       else\n@@ -945,14 +1022,6 @@ static rtx pending_write_mems;\n \n static int pending_lists_length;\n \n-/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */\n-\n-static rtx unused_insn_list;\n-\n-/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n-\n-static rtx unused_expr_list;\n-\n /* The last insn upon which all memory references must depend.\n    This is an insn which flushed the pending lists, creating a dependency\n    between it and all previously pending memory references.  This creates\n@@ -3232,40 +3301,15 @@ priority (insn)\n /* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add\n    them to the unused_*_list variables, so that they can be reused.  */\n \n-__inline static void\n-free_pnd_lst (listp, unused_listp)\n-     rtx *listp, *unused_listp;\n-{\n-  register rtx link, prev_link;\n-\n-  if (*listp == 0)\n-    return;\n-\n-  prev_link = *listp;\n-  link = XEXP (prev_link, 1);\n-\n-  while (link)\n-    {\n-      prev_link = link;\n-      link = XEXP (link, 1);\n-    }\n-\n-  XEXP (prev_link, 1) = *unused_listp;\n-  *unused_listp = *listp;\n-  *listp = 0;\n-}\n-\n static void\n free_pending_lists ()\n {\n-\n-\n   if (current_nr_blocks <= 1)\n     {\n-      free_pnd_lst (&pending_read_insns, &unused_insn_list);\n-      free_pnd_lst (&pending_write_insns, &unused_insn_list);\n-      free_pnd_lst (&pending_read_mems, &unused_expr_list);\n-      free_pnd_lst (&pending_write_mems, &unused_expr_list);\n+      free_list (&pending_read_insns, &unused_insn_list);\n+      free_list (&pending_write_insns, &unused_insn_list);\n+      free_list (&pending_read_mems, &unused_expr_list);\n+      free_list (&pending_write_mems, &unused_expr_list);\n     }\n   else\n     {\n@@ -3274,10 +3318,10 @@ free_pending_lists ()\n \n       for (bb = 0; bb < current_nr_blocks; bb++)\n \t{\n-\t  free_pnd_lst (&bb_pending_read_insns[bb], &unused_insn_list);\n-\t  free_pnd_lst (&bb_pending_write_insns[bb], &unused_insn_list);\n-\t  free_pnd_lst (&bb_pending_read_mems[bb], &unused_expr_list);\n-\t  free_pnd_lst (&bb_pending_write_mems[bb], &unused_expr_list);\n+\t  free_list (&bb_pending_read_insns[bb], &unused_insn_list);\n+\t  free_list (&bb_pending_write_insns[bb], &unused_insn_list);\n+\t  free_list (&bb_pending_read_mems[bb], &unused_expr_list);\n+\t  free_list (&bb_pending_write_mems[bb], &unused_expr_list);\n \t}\n     }\n }\n@@ -3292,26 +3336,10 @@ add_insn_mem_dependence (insn_list, mem_list, insn, mem)\n {\n   register rtx link;\n \n-  if (unused_insn_list)\n-    {\n-      link = unused_insn_list;\n-      unused_insn_list = XEXP (link, 1);\n-    }\n-  else\n-    link = rtx_alloc (INSN_LIST);\n-  XEXP (link, 0) = insn;\n-  XEXP (link, 1) = *insn_list;\n+  link = alloc_INSN_LIST (insn, *insn_list);\n   *insn_list = link;\n \n-  if (unused_expr_list)\n-    {\n-      link = unused_expr_list;\n-      unused_expr_list = XEXP (link, 1);\n-    }\n-  else\n-    link = rtx_alloc (EXPR_LIST);\n-  XEXP (link, 0) = mem;\n-  XEXP (link, 1) = *mem_list;\n+  link = alloc_EXPR_LIST (VOIDmode, mem, *mem_list);\n   *mem_list = link;\n \n   pending_lists_length++;\n@@ -3364,8 +3392,8 @@ flush_pending_lists (insn, only_write)\n   for (u = last_pending_memory_flush; u; u = XEXP (u, 1))\n     add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n-  last_pending_memory_flush =\n-    gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+  free_list (&last_pending_memory_flush, &unused_insn_list);\n+  last_pending_memory_flush = alloc_INSN_LIST (insn, NULL_RTX);\n }\n \n /* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated\n@@ -3581,8 +3609,7 @@ sched_analyze_2 (x, insn)\n \t    while (--i >= 0)\n \t      {\n \t\treg_last_uses[regno + i]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode,\n-\t\t\t\t       insn, reg_last_uses[regno + i]);\n+\t\t  = alloc_INSN_LIST (insn, reg_last_uses[regno + i]);\n \n \t\tfor (u = reg_last_sets[regno + i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n@@ -3595,8 +3622,7 @@ sched_analyze_2 (x, insn)\n \t  }\n \telse\n \t  {\n-\t    reg_last_uses[regno]\n-\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_last_uses[regno]);\n+\t    reg_last_uses[regno] = alloc_INSN_LIST (insn, reg_last_uses[regno]);\n \n \t    for (u = reg_last_sets[regno]; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n@@ -3835,18 +3861,20 @@ sched_analyze_insn (x, insn, loop_notes)\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n \t\t\t       /* reg_last_sets[r] is now a list of insns */\n+\t\t\t       free_list (&reg_last_sets[i], &unused_insn_list);\n \t\t\t       reg_last_sets[i]\n-\t\t\t\t = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t\t\t\t = alloc_INSN_LIST (insn, NULL_RTX);\n \t\t\t     });\n   CLEAR_REG_SET (reg_pending_sets);\n \n   if (reg_pending_sets_all)\n     {\n       for (i = 0; i < maxreg; i++)\n-\n-\t/* reg_last_sets[r] is now a list of insns */\n-\treg_last_sets[i]\n-\t  = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t{\n+\t  /* reg_last_sets[r] is now a list of insns */\n+\t  free_list (&reg_last_sets[i], &unused_insn_list);\n+\t  reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n+\t}\n \n       reg_pending_sets_all = 0;\n     }\n@@ -3946,12 +3974,12 @@ sched_analyze (head, tail)\n \t      /* Add a pair of fake REG_NOTE which we will later\n \t\t convert back into a NOTE_INSN_SETJMP note.  See\n \t\t reemit_notes for why we use a pair of NOTEs.  */\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t    GEN_INT (0),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t    GEN_INT (NOTE_INSN_SETJMP),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n+\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t  GEN_INT (0),\n+\t\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n+\t\t\t\t\t\t  REG_NOTES (insn));\n \t    }\n \t  else\n \t    {\n@@ -3993,8 +4021,8 @@ sched_analyze (head, tail)\n \t     function call) on all hard register clobberage.  */\n \n \t  /* last_function_call is now a list of insns */\n-\t  last_function_call\n-\t    = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n+\t  free_list(&last_function_call, &unused_insn_list);\n+\t  last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n \n       /* See comments on reemit_notes as to why we do this.  */\n@@ -4006,12 +4034,12 @@ sched_analyze (head, tail)\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n-\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t  GEN_INT (NOTE_BLOCK_NUMBER (insn)),\n-\t\t\t\t\t  loop_notes);\n-\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t  GEN_INT (NOTE_LINE_NUMBER (insn)),\n-\t\t\t\t\t  loop_notes);\n+\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\tGEN_INT (NOTE_BLOCK_NUMBER (insn)),\n+\t\t\t\t\tloop_notes);\n+\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n+\t\t\t\t\tloop_notes);\n \t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n \t}\n \n@@ -4226,9 +4254,7 @@ queue_insn (insn, n_cycles)\n      int n_cycles;\n {\n   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);\n-  rtx link = rtx_alloc (INSN_LIST);\n-  XEXP (link, 0) = insn;\n-  XEXP (link, 1) = insn_queue[next_q];\n+  rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n   insn_queue[next_q] = link;\n   q_size += 1;\n \n@@ -4443,10 +4469,7 @@ create_reg_dead_note (reg, insn)\n       if (current_nr_blocks <= 1)\n \tabort ();\n       else\n-\t{\n-\t  link = rtx_alloc (EXPR_LIST);\n-\t  PUT_REG_NOTE_KIND (link, REG_DEAD);\n-\t}\n+\tlink = alloc_EXPR_LIST (REG_DEAD, NULL_RTX, NULL_RTX);\n     }\n   else\n     {\n@@ -4473,12 +4496,8 @@ create_reg_dead_note (reg, insn)\n \t  if (link == NULL_RTX && current_nr_blocks <= 1)\n \t    abort ();\n \t  else if (link == NULL_RTX)\n-\t    {\n-\t      link = rtx_alloc (EXPR_LIST);\n-\t      PUT_REG_NOTE_KIND (link, REG_DEAD);\n-\t      XEXP (link, 0) = gen_rtx_REG (word_mode, 0);\n-\t      XEXP (link, 1) = NULL_RTX;\n-\t    }\n+\t    link = alloc_EXPR_LIST (REG_DEAD, gen_rtx_REG (word_mode, 0),\n+\t\t\t\t    NULL_RTX);\n \t     \n \t  reg_note_regs += (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t    : HARD_REGNO_NREGS (REGNO (XEXP (link, 0)),\n@@ -4492,10 +4511,7 @@ create_reg_dead_note (reg, insn)\n \t  rtx temp_reg, temp_link;\n \n \t  temp_reg = gen_rtx_REG (word_mode, 0);\n-\t  temp_link = rtx_alloc (EXPR_LIST);\n-\t  PUT_REG_NOTE_KIND (temp_link, REG_DEAD);\n-\t  XEXP (temp_link, 0) = temp_reg;\n-\t  XEXP (temp_link, 1) = dead_notes;\n+\t  temp_link = alloc_EXPR_LIST (REG_DEAD, temp_reg, dead_notes);\n \t  dead_notes = temp_link;\n \t  reg_note_regs--;\n \t}\n@@ -7054,14 +7070,11 @@ compute_block_forward_dependences (bb)\n \t  if (find_insn_list (insn, INSN_DEPEND (x)))\n \t    continue;\n \n-\t  new_link = rtx_alloc (INSN_LIST);\n+\t  new_link = alloc_INSN_LIST (insn, INSN_DEPEND (x));\n \n \t  dep_type = REG_NOTE_KIND (link);\n \t  PUT_REG_NOTE_KIND (new_link, dep_type);\n \n-\t  XEXP (new_link, 0) = insn;\n-\t  XEXP (new_link, 1) = INSN_DEPEND (x);\n-\n \t  INSN_DEPEND (x) = new_link;\n \t  INSN_DEP_COUNT (insn) += 1;\n \t}\n@@ -7287,8 +7300,8 @@ compute_block_backward_dependences (bb)\n \t\t      continue;\n \n \t\t    (bb_reg_last_uses[bb_succ])[reg]\n-\t\t      = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n-\t\t\t\t\t   (bb_reg_last_uses[bb_succ])[reg]);\n+\t\t      = alloc_INSN_LIST (XEXP (u, 0),\n+\t\t\t\t\t (bb_reg_last_uses[bb_succ])[reg]);\n \t\t  }\n \n \t\t/* reg-last-defs lists are inherited by bb_succ */\n@@ -7298,8 +7311,8 @@ compute_block_backward_dependences (bb)\n \t\t      continue;\n \n \t\t    (bb_reg_last_sets[bb_succ])[reg]\n-\t\t      = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n-\t\t\t\t\t   (bb_reg_last_sets[bb_succ])[reg]);\n+\t\t      = alloc_INSN_LIST (XEXP (u, 0),\n+\t\t\t\t\t (bb_reg_last_sets[bb_succ])[reg]);\n \t\t  }\n \t      }\n \n@@ -7340,8 +7353,8 @@ compute_block_backward_dependences (bb)\n \t\t  continue;\n \n \t\tbb_last_function_call[bb_succ]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n-\t\t\t\t       bb_last_function_call[bb_succ]);\n+\t\t  = alloc_INSN_LIST (XEXP (u, 0),\n+\t\t\t\t     bb_last_function_call[bb_succ]);\n \t      }\n \n \t    /* last_pending_memory_flush is inherited by bb_succ */\n@@ -7351,8 +7364,8 @@ compute_block_backward_dependences (bb)\n \t\t  continue;\n \n \t\tbb_last_pending_memory_flush[bb_succ]\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n-\t\t\t\t       bb_last_pending_memory_flush[bb_succ]);\n+\t\t  = alloc_INSN_LIST (XEXP (u, 0),\n+\t\t\t\t     bb_last_pending_memory_flush[bb_succ]);\n \t      }\n \n \t    /* sched_before_next_call is inherited by bb_succ */\n@@ -7365,6 +7378,20 @@ compute_block_backward_dependences (bb)\n \t  }\n \twhile (e != first_edge);\n     }\n+\n+  /* Free up the INSN_LISTs */\n+  for (b = 0; b < max_reg; ++b)\n+    {\n+      free_list (&reg_last_sets[b], &unused_insn_list);\n+      free_list (&reg_last_uses[b], &unused_insn_list);\n+    }\n+\n+  /* Assert that we won't need bb_reg_last_* for this block anymore.  */\n+  if (current_nr_blocks > 1)\n+    {\n+      bb_reg_last_uses[bb] = (rtx *) NULL_RTX;\n+      bb_reg_last_sets[bb] = (rtx *) NULL_RTX;\n+    }\n }\n \n /* Print dependences for debugging, callable from debugger */\n@@ -7729,10 +7756,7 @@ split_hard_reg_notes (note, first, last)\n \t      && (temp = regno_use_in (new_reg, PATTERN (insn))))\n \t    {\n \t      /* Create a new reg dead note ere.  */\n-\t      link = rtx_alloc (EXPR_LIST);\n-\t      PUT_REG_NOTE_KIND (link, REG_DEAD);\n-\t      XEXP (link, 0) = temp;\n-\t      XEXP (link, 1) = REG_NOTES (insn);\n+\t      link = alloc_EXPR_LIST (REG_DEAD, temp, REG_NOTES (insn));\n \t      REG_NOTES (insn) = link;\n \n \t      /* If killed multiple registers here, then add in the excess.  */\n@@ -7788,10 +7812,8 @@ new_insn_dead_notes (pat, insn, last, orig_insn)\n \t\t  if (!find_regno_note (tem, REG_UNUSED, REGNO (dest))\n \t\t      && !find_regno_note (tem, REG_DEAD, REGNO (dest)))\n \t\t    {\n-\t\t      rtx note = rtx_alloc (EXPR_LIST);\n-\t\t      PUT_REG_NOTE_KIND (note, REG_DEAD);\n-\t\t      XEXP (note, 0) = dest;\n-\t\t      XEXP (note, 1) = REG_NOTES (tem);\n+\t\t      rtx note = alloc_EXPR_LIST (REG_DEAD, dest,\n+\t\t\t\t\t\t  REG_NOTES (tem));\n \t\t      REG_NOTES (tem) = note;\n \t\t    }\n \t\t  /* The reg only dies in one insn, the last one that uses\n@@ -7817,10 +7839,7 @@ new_insn_dead_notes (pat, insn, last, orig_insn)\n \n \t  if (GET_CODE (pat) == CLOBBER)\n \t    {\n-\t      rtx note = rtx_alloc (EXPR_LIST);\n-\t      PUT_REG_NOTE_KIND (note, REG_UNUSED);\n-\t      XEXP (note, 0) = dest;\n-\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t      rtx note = alloc_EXPR_LIST (REG_UNUSED, dest, REG_NOTES (insn));\n \t      REG_NOTES (insn) = note;\n \t      return;\n \t    }\n@@ -8124,9 +8143,11 @@ update_flow_info (notes, first, last, orig_insn)\n \t  for (insn = first; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n \t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t\t&& reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t      {\n+\t        REG_NOTES (insn) = alloc_EXPR_LIST (REG_LABEL,\n \t\t\t\t\t\t    XEXP (note, 0),\n \t\t\t\t\t\t    REG_NOTES (insn));\n+\t      }\n \t  break;\n \n \tcase REG_CC_SETTER:\n@@ -8222,10 +8243,7 @@ update_flow_info (notes, first, last, orig_insn)\n \n \t\t  if (insn_dest != dest)\n \t\t    {\n-\t\t      note = rtx_alloc (EXPR_LIST);\n-\t\t      PUT_REG_NOTE_KIND (note, REG_DEAD);\n-\t\t      XEXP (note, 0) = dest;\n-\t\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t\t      note = alloc_EXPR_LIST (REG_DEAD, dest, REG_NOTES (insn));\n \t\t      REG_NOTES (insn) = note;\n \t\t      /* The reg only dies in one insn, the last one\n \t\t\t that uses it.  */\n@@ -8700,6 +8718,8 @@ schedule_insns (dump_file)\n     emit_note_after (NOTE_INSN_DELETED, basic_block_end[n_basic_blocks - 1]);\n \n   /* Schedule every region in the subroutine */\n+  fprintf(stderr, \"HELLO: nr_regions=%d max_reg_num=%d\\n\",\n+        (int)nr_regions, (int)max_reg_num());   \n   for (rgn = 0; rgn < nr_regions; rgn++)\n     {\n       schedule_region (rgn);"}]}