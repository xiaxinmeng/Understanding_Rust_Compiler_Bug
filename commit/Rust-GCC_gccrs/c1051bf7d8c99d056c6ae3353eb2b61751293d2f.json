{"sha": "c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEwNTFiZjdkOGM5OWQwNTZjNmFlMzM1M2ViMmI2MTc1MTI5M2QyZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-11-13T22:34:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-11-13T22:34:38Z"}, "message": "Capture adjustments for P0588R1.\n\n\t* semantics.c (process_outer_var_ref): Capture variables when\n\tthey are named; complain about non-capture uses when odr-used.\n\t* expr.c (mark_use): Rvalue use looks through capture proxy.\n\t* constexpr.c (potential_constant_expression_1): Improve error about\n\tuse of captured variable.\n\t* lambda.c (need_generic_capture, dependent_capture_r)\n\t(do_dependent_capture, processing_nonlambda_template): Remove.\n\t* call.c (build_this): Remove uses of the above.\n\t* decl.c (cp_finish_decl): Likewise.\n\t* semantics.c (maybe_cleanup_point_expr)\n\t(maybe_cleanup_point_expr_void, finish_goto_stmt)\n\t(maybe_convert_cond): Likewise.\n\t* typeck.c (check_return_expr): Likewise.\n\nFrom-SVN: r254713", "tree": {"sha": "fd734eba6bb7c4373c5a32b46fdb8e5256e42335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd734eba6bb7c4373c5a32b46fdb8e5256e42335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04757a2a49bd21c71af386a64591f77c165a0d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04757a2a49bd21c71af386a64591f77c165a0d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04757a2a49bd21c71af386a64591f77c165a0d93"}], "stats": {"total": 218, "additions": 68, "deletions": 150}, "files": [{"sha": "ce0c874a5b0c7795aea15943022d9a7f081543f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -1,5 +1,20 @@\n 2017-11-13  Jason Merrill  <jason@redhat.com>\n \n+\tCapture adjustments for P0588R1.\n+\t* semantics.c (process_outer_var_ref): Capture variables when\n+\tthey are named; complain about non-capture uses when odr-used.\n+\t* expr.c (mark_use): Rvalue use looks through capture proxy.\n+\t* constexpr.c (potential_constant_expression_1): Improve error about\n+\tuse of captured variable.\n+\t* lambda.c (need_generic_capture, dependent_capture_r)\n+\t(do_dependent_capture, processing_nonlambda_template): Remove.\n+\t* call.c (build_this): Remove uses of the above.\n+\t* decl.c (cp_finish_decl): Likewise.\n+\t* semantics.c (maybe_cleanup_point_expr)\n+\t(maybe_cleanup_point_expr_void, finish_goto_stmt)\n+\t(maybe_convert_cond): Likewise.\n+\t* typeck.c (check_return_expr): Likewise.\n+\n \tDefer folding of *&.\n \t* typeck.c (cp_build_fold_indirect_ref): New.\n \t(cp_build_indirect_ref_1): Split out from cp_build_indirect_ref."}, {"sha": "e09cf97920b553e32ee7b45aa02c226e2a0484a9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -3365,7 +3365,7 @@ build_this (tree obj)\n {\n   /* In a template, we are only concerned about the type of the\n      expression, so we can take a shortcut.  */\n-  if (processing_nonlambda_template ())\n+  if (processing_template_decl)\n     return build_address (obj);\n \n   return cp_build_addr_expr (obj, tf_warning_or_error);"}, {"sha": "d6b6843e8048dca0a6ad35f8f76fa45e5280efc9", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -1286,8 +1286,6 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  && is_dummy_object (x))\n \t{\n \t  x = ctx->object;\n-\t  /* We don't use cp_build_addr_expr here because we don't want to\n-\t     capture the object argument during constexpr evaluation.  */\n \t  x = build_address (x);\n \t}\n       bool lval = false;\n@@ -5289,7 +5287,25 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \n     case VAR_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (t))\n-\treturn RECUR (DECL_VALUE_EXPR (t), rval);\n+\t{\n+\t  if (now && is_normal_capture_proxy (t))\n+\t    {\n+\t      /* -- in a lambda-expression, a reference to this or to a\n+\t\t variable with automatic storage duration defined outside that\n+\t\t lambda-expression, where the reference would be an\n+\t\t odr-use.  */\n+\t      if (flags & tf_error)\n+\t\t{\n+\t\t  tree cap = DECL_CAPTURED_VARIABLE (t);\n+\t\t  error (\"lambda capture of %qE is not a constant expression\",\n+\t\t\t cap);\n+\t\t  if (!want_rval && decl_constant_var_p (cap))\n+\t\t    inform (input_location, \"because it is used as a glvalue\");\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  return RECUR (DECL_VALUE_EXPR (t), rval);\n+\t}\n       if (want_rval\n \t  && !var_in_maybe_constexpr_fn (t)\n \t  && !type_dependent_expression_p (t)"}, {"sha": "b9942066a07ce0cb81bbbda4eefe82b6db1809c6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -6462,7 +6462,6 @@ extern int uses_template_parms\t\t\t(tree);\n extern bool uses_template_parms_level\t\t(tree, int);\n extern bool in_template_function\t\t(void);\n extern bool need_generic_capture\t\t(void);\n-extern bool processing_nonlambda_template\t(void);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern tree fn_type_unification\t\t\t(tree, tree, tree,"}, {"sha": "2e356a0f09a96c9c9e68363adadf2331f368f2c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -6844,8 +6844,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  DECL_INITIAL (decl) = NULL_TREE;\n \t}\n \n-      init = do_dependent_capture (init);\n-\n       /* Generally, initializers in templates are expanded when the\n \t template is instantiated.  But, if DECL is a variable constant\n \t then it can be used in future constant expressions, so its value"}, {"sha": "81b9a5b1dc9c1795de5f64b84aca8b457b3b039c", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -111,6 +111,14 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n     {\n     case VAR_DECL:\n     case PARM_DECL:\n+      if (rvalue_p && is_normal_capture_proxy (expr))\n+\t{\n+\t  /* Look through capture by copy.  */\n+\t  tree cap = DECL_CAPTURED_VARIABLE (expr);\n+\t  if (TREE_CODE (TREE_TYPE (cap)) == TREE_CODE (TREE_TYPE (expr))\n+\t      && decl_constant_var_p (cap))\n+\t    return RECUR (cap);\n+\t}\n       if (outer_automatic_var_p (expr)\n \t  && decl_constant_var_p (expr))\n \t{\n@@ -146,6 +154,14 @@ mark_use (tree expr, bool rvalue_p, bool read_p,\n \t{\n \t  /* Try to look through the reference.  */\n \t  tree ref = TREE_OPERAND (expr, 0);\n+\t  if (rvalue_p && is_normal_capture_proxy (ref))\n+\t    {\n+\t      /* Look through capture by reference.  */\n+\t      tree cap = DECL_CAPTURED_VARIABLE (ref);\n+\t      if (TREE_CODE (TREE_TYPE (cap)) != REFERENCE_TYPE\n+\t\t  && decl_constant_var_p (cap))\n+\t\treturn RECUR (cap);\n+\t    }\n \t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n \t  if (r != ref)\n \t    expr = convert_from_reference (r);"}, {"sha": "2cbad878ff651877bbd76a292b7402b5a5df2d0c", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -985,121 +985,6 @@ generic_lambda_fn_p (tree callop)\n \t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (callop)));\n }\n \n-/* Returns true iff we need to consider default capture for an enclosing\n-   generic lambda.  */\n-\n-bool\n-need_generic_capture (void)\n-{\n-  if (!processing_template_decl)\n-    return false;\n-\n-  tree outer_closure = NULL_TREE;\n-  for (tree t = current_class_type; t;\n-       t = decl_type_context (TYPE_MAIN_DECL (t)))\n-    {\n-      tree lam = CLASSTYPE_LAMBDA_EXPR (t);\n-      if (!lam || LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lam) == CPLD_NONE)\n-\t/* No default capture.  */\n-\tbreak;\n-      outer_closure = t;\n-    }\n-\n-  if (!outer_closure)\n-    /* No lambda.  */\n-    return false;\n-  else if (dependent_type_p (outer_closure))\n-    /* The enclosing context isn't instantiated.  */\n-    return false;\n-  else\n-    return true;\n-}\n-\n-/* A lambda-expression...is said to implicitly capture the entity...if the\n-   compound-statement...names the entity in a potentially-evaluated\n-   expression where the enclosing full-expression depends on a generic lambda\n-   parameter declared within the reaching scope of the lambda-expression.  */\n-\n-static tree\n-dependent_capture_r (tree *tp, int *walk_subtrees, void *data)\n-{\n-  hash_set<tree> *pset = (hash_set<tree> *)data;\n-\n-  if (TYPE_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  if (outer_automatic_var_p (*tp))\n-    {\n-      tree t = process_outer_var_ref (*tp, tf_warning_or_error, /*force*/true);\n-      if (t != *tp\n-\t  && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE\n-\t  && TREE_CODE (TREE_TYPE (*tp)) != REFERENCE_TYPE)\n-\tt = convert_from_reference (t);\n-      *tp = t;\n-    }\n-\n-  if (pset->add (*tp))\n-    *walk_subtrees = 0;\n-\n-  switch (TREE_CODE (*tp))\n-    {\n-      /* Don't walk into unevaluated context or another lambda.  */\n-    case SIZEOF_EXPR:\n-    case ALIGNOF_EXPR:\n-    case TYPEID_EXPR:\n-    case NOEXCEPT_EXPR:\n-    case LAMBDA_EXPR:\n-      *walk_subtrees = 0;\n-      break;\n-\n-      /* Don't walk into statements whose subexpressions we already\n-\t handled.  */\n-    case TRY_BLOCK:\n-    case EH_SPEC_BLOCK:\n-    case HANDLER:\n-    case IF_STMT:\n-    case FOR_STMT:\n-    case RANGE_FOR_STMT:\n-    case WHILE_STMT:\n-    case DO_STMT:\n-    case SWITCH_STMT:\n-    case STATEMENT_LIST:\n-    case RETURN_EXPR:\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case DECL_EXPR:\n-      {\n-\ttree decl = DECL_EXPR_DECL (*tp);\n-\tif (VAR_P (decl))\n-\t  {\n-\t    /* walk_tree_1 won't step in here.  */\n-\t    cp_walk_tree (&DECL_INITIAL (decl),\n-\t\t\t  dependent_capture_r, &pset, NULL);\n-\t    *walk_subtrees = 0;\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-tree\n-do_dependent_capture (tree expr, bool force)\n-{\n-  if (!need_generic_capture ()\n-      || (!force && !instantiation_dependent_expression_p (expr)))\n-    return expr;\n-\n-  hash_set<tree> pset;\n-  cp_walk_tree (&expr, dependent_capture_r, &pset, NULL);\n-  return expr;\n-}\n-\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n "}, {"sha": "4ca5974b1967d3cd07b310d7374e1da7879eade5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -9500,16 +9500,6 @@ in_template_function (void)\n   return ret;\n }\n \n-/* Returns true iff we are currently within a template other than a\n-   default-capturing generic lambda, so we don't need to worry about semantic\n-   processing.  */\n-\n-bool\n-processing_nonlambda_template (void)\n-{\n-  return processing_template_decl && !need_generic_capture ();\n-}\n-\n /* Returns true if T depends on any template parameter with level LEVEL.  */\n \n bool"}, {"sha": "51489d17ad58f56da3f8fb8837e0e8962f4a2c3b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -410,8 +410,6 @@ maybe_cleanup_point_expr (tree expr)\n {\n   if (!processing_template_decl && stmts_are_full_exprs_p ())\n     expr = fold_build_cleanup_point_expr (TREE_TYPE (expr), expr);\n-  else\n-    expr = do_dependent_capture (expr);\n   return expr;\n }\n \n@@ -425,8 +423,6 @@ maybe_cleanup_point_expr_void (tree expr)\n {\n   if (!processing_template_decl && stmts_are_full_exprs_p ())\n     expr = fold_build_cleanup_point_expr (void_type_node, expr);\n-  else\n-    expr = do_dependent_capture (expr);\n   return expr;\n }\n \n@@ -633,8 +629,6 @@ finish_goto_stmt (tree destination)\n \t    = fold_build_cleanup_point_expr (TREE_TYPE (destination),\n \t\t\t\t\t     destination);\n \t}\n-      else\n-\tdestination = do_dependent_capture (destination);\n     }\n \n   check_goto (destination);\n@@ -656,7 +650,7 @@ maybe_convert_cond (tree cond)\n \n   /* Wait until we instantiate templates before doing conversion.  */\n   if (processing_template_decl)\n-    return do_dependent_capture (cond);\n+    return cond;\n \n   if (warn_sequence_point)\n     verify_sequence_points (cond);\n@@ -3291,10 +3285,14 @@ outer_automatic_var_p (tree decl)\n }\n \n /* DECL satisfies outer_automatic_var_p.  Possibly complain about it or\n-   rewrite it for lambda capture.  */\n+   rewrite it for lambda capture.\n+\n+   If ODR_USE is true, we're being called from mark_use, and we complain about\n+   use of constant variables.  If ODR_USE is false, we're being called for the\n+   id-expression, and we do lambda capture.  */\n \n tree\n-process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n+process_outer_var_ref (tree decl, tsubst_flags_t complain, bool odr_use)\n {\n   if (cp_unevaluated_operand)\n     /* It's not a use (3.2) if we're in an unevaluated context.  */\n@@ -3315,12 +3313,6 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n   if (parsing_nsdmi ())\n     containing_function = NULL_TREE;\n \n-  /* Core issue 696: Only an odr-use of an outer automatic variable causes a\n-     capture (or error), and a constant variable can decay to a prvalue\n-     constant without odr-use.  So don't capture yet.  */\n-  if (decl_constant_var_p (decl) && !force_use)\n-    return decl;\n-\n   if (containing_function && LAMBDA_FUNCTION_P (containing_function))\n     {\n       /* Check whether we've already built a proxy.  */\n@@ -3336,7 +3328,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n \t    return d;\n \t  else\n \t    /* We need to capture an outer proxy.  */\n-\t    return process_outer_var_ref (d, complain, force_use);\n+\t    return process_outer_var_ref (d, complain, odr_use);\n \t}\n     }\n \n@@ -3382,12 +3374,19 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain, bool force_use)\n \terror (\"cannot capture member %qD of anonymous union\", decl);\n       return error_mark_node;\n     }\n-  if (context == containing_function)\n+  /* Do lambda capture when processing the id-expression, not when\n+     odr-using a variable.  */\n+  if (!odr_use && context == containing_function)\n     {\n       decl = add_default_capture (lambda_stack,\n \t\t\t\t  /*id=*/DECL_NAME (decl),\n \t\t\t\t  initializer);\n     }\n+  /* Only an odr-use of an outer automatic variable causes an\n+     error, and a constant variable can decay to a prvalue\n+     constant without odr-use.  So don't complain yet.  */\n+  else if (!odr_use && decl_constant_var_p (decl))\n+    return decl;\n   else if (lambda_expr)\n     {\n       if (complain & tf_error)"}, {"sha": "cb93cc335615e0f539bb158d82dcd9f8adfc0b64", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1051bf7d8c99d056c6ae3353eb2b61751293d2f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c1051bf7d8c99d056c6ae3353eb2b61751293d2f", "patch": "@@ -9158,7 +9158,7 @@ check_return_expr (tree retval, bool *no_warning)\n     dependent:\n       /* We should not have changed the return value.  */\n       gcc_assert (retval == saved_retval);\n-      return do_dependent_capture (retval, /*force*/true);\n+      return retval;\n     }\n \n   /* The fabled Named Return Value optimization, as per [class.copy]/15:"}]}