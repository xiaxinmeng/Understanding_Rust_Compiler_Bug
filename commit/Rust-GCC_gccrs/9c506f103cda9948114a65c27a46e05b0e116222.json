{"sha": "9c506f103cda9948114a65c27a46e05b0e116222", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM1MDZmMTAzY2RhOTk0ODExNGE2NWMyN2E0NmUwNWIwZTExNjIyMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-06T14:25:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-06T14:25:04Z"}, "message": "re PR rtl-optimization/45394 (gnat fails to build on s390, trunk 20100918)\n\n\tPR rtl-optimization/45394\n\t* combine.c (cleanup_auto_inc_dec): Remove AFTER parameter and adjust.\n\t(struct rtx_subst_pair): Remove AFTER field.\n\t(propagate_for_debug_subst): Adjust call to cleanup_auto_inc_dec.\n\t(propagate_for_debug): Remove MOVE parameter and adjust.\n\t(try_combine): In the special case where I2 is a PARALLEL, combine only\n\tdestinations of SETs and set I2SRC to the I2 source.\n\tAdjust calls to propagate_for_debug throughout.\n\t* reload1.c (eliminate_regs_1) <ASM_OPERANDS>: Do not abort for debug\n\tinsns.\n\nFrom-SVN: r165030", "tree": {"sha": "999567e1c0b21278b6e7d9d57f50517dd0b0fd1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/999567e1c0b21278b6e7d9d57f50517dd0b0fd1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c506f103cda9948114a65c27a46e05b0e116222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c506f103cda9948114a65c27a46e05b0e116222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c506f103cda9948114a65c27a46e05b0e116222", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c506f103cda9948114a65c27a46e05b0e116222/comments", "author": null, "committer": null, "parents": [{"sha": "5919751c15c869e1ba4df2b6b870f3ccda4cb80a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5919751c15c869e1ba4df2b6b870f3ccda4cb80a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5919751c15c869e1ba4df2b6b870f3ccda4cb80a"}], "stats": {"total": 166, "additions": 102, "deletions": 64}, "files": [{"sha": "bcd9f897a78175f25e5da94a51e25a725b4c25f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -1,13 +1,27 @@\n+2010-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/45394\n+\t* combine.c (cleanup_auto_inc_dec): Remove AFTER parameter and adjust.\n+\t(struct rtx_subst_pair): Remove AFTER field.\n+\t(propagate_for_debug_subst): Adjust call to cleanup_auto_inc_dec.\n+\t(propagate_for_debug): Remove MOVE parameter and adjust.\n+\t(try_combine): In the special case where I2 is a PARALLEL, combine only\n+\tdestinations of SETs and set I2SRC to the I2 source.\n+\tAdjust calls to propagate_for_debug throughout.\n+\t* reload1.c (eliminate_regs_1) <ASM_OPERANDS>: Do not abort for debug\n+\tinsns.\n+\n 2010-10-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/rs6000/rs6000.c (rs6000_expand_ternop_builtin): Rewrite\n \tswitch on insn codes as sequence of ifs.\n \n-2010-10-06  Hariharan Sandanagobalane <hariharan@picochip.com>\n+2010-10-06  Hariharan Sandanagobalane  <hariharan@picochip.com>\n+\n \t* config/picochip/picochip.c (TARGET_EXCEPT_UNWIND_INFO): Define it to\n \tbe UI_NONE for picochip.\n \t(picochip_option_override): Do not disable exception flags.\n-\t* config/picochip/picochip-protos.h (picochip_except_unwind_info)\n+\t* config/picochip/picochip-protos.h (picochip_except_unwind_info):\n \tDeclare.\n \n 2010-10-06  Richard Guenther  <rguenther@suse.de>\n@@ -107,7 +121,7 @@\n \t* cgraphunit.c (assemble_function): Output thunks and aliases before\n \tthe function itself.\n \n-2010-09-29  Hariharan Sandanagobalane <hariharan@picochip.com>\n+2010-09-29  Hariharan Sandanagobalane  <hariharan@picochip.com>\n \n \t* config/picochip/picochip.c (picochip_option_override): Disable\n \texception flags for picochip.\n@@ -1209,7 +1223,7 @@\n \t* sel-sched.c: Use HARD_FRAME_POINTER_IS_FRAME_POINTER\n \t* stmt.c: Use HARD_FRAME_POINTER_IS_ARG_POINTER.\n \n-2010-09-29  Hariharan Sandanagobalane <hariharan@picochip.com>\n+2010-09-29  Hariharan Sandanagobalane  <hariharan@picochip.com>\n \n \t* config/picochip/picochip.c (picochip_output_internal_label):\n \tThis function can now be called for debug CFI labels, which can come"}, {"sha": "a5088b0f72bcf974c3c8f84ffe84be3742f77ef8", "filename": "gcc/combine.c", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -2292,13 +2292,11 @@ reg_subword_p (rtx x, rtx reg)\n }\n \n #ifdef AUTO_INC_DEC\n-/* Replace auto-increment addressing modes with explicit operations to\n-   access the same addresses without modifying the corresponding\n-   registers.  If AFTER holds, SRC is meant to be reused after the\n-   side effect, otherwise it is to be reused before that.  */\n+/* Replace auto-increment addressing modes with explicit operations to access\n+   the same addresses without modifying the corresponding registers.  */\n \n static rtx\n-cleanup_auto_inc_dec (rtx src, bool after, enum machine_mode mem_mode)\n+cleanup_auto_inc_dec (rtx src, enum machine_mode mem_mode)\n {\n   rtx x = src;\n   const RTX_CODE code = GET_CODE (x);\n@@ -2335,26 +2333,20 @@ cleanup_auto_inc_dec (rtx src, bool after, enum machine_mode mem_mode)\n \n     case PRE_INC:\n     case PRE_DEC:\n-    case POST_INC:\n-    case POST_DEC:\n       gcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n-      if (after == (code == PRE_INC || code == PRE_DEC))\n-\tx = cleanup_auto_inc_dec (XEXP (x, 0), after, mem_mode);\n-      else\n-\tx = gen_rtx_PLUS (GET_MODE (x),\n-\t\t\t  cleanup_auto_inc_dec (XEXP (x, 0), after, mem_mode),\n-\t\t\t  GEN_INT ((code == PRE_INC || code == POST_INC)\n-\t\t\t\t   ? GET_MODE_SIZE (mem_mode)\n-\t\t\t\t   : -GET_MODE_SIZE (mem_mode)));\n-      return x;\n+      return gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t   cleanup_auto_inc_dec (XEXP (x, 0), mem_mode),\n+\t\t\t   GEN_INT (code == PRE_INC\n+\t\t\t\t    ? GET_MODE_SIZE (mem_mode)\n+\t\t\t\t    : -GET_MODE_SIZE (mem_mode)));\n \n+    case POST_INC:\n+    case POST_DEC:\n     case PRE_MODIFY:\n     case POST_MODIFY:\n-      if (after == (code == PRE_MODIFY))\n-\tx = XEXP (x, 0);\n-      else\n-\tx = XEXP (x, 1);\n-      return cleanup_auto_inc_dec (x, after, mem_mode);\n+      return cleanup_auto_inc_dec (code == PRE_MODIFY\n+\t\t\t\t   ? XEXP (x, 1) : XEXP (x, 0),\n+\t\t\t\t   mem_mode);\n \n     default:\n       break;\n@@ -2377,14 +2369,14 @@ cleanup_auto_inc_dec (rtx src, bool after, enum machine_mode mem_mode)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     if (fmt[i] == 'e')\n-      XEXP (x, i) = cleanup_auto_inc_dec (XEXP (x, i), after, mem_mode);\n+      XEXP (x, i) = cleanup_auto_inc_dec (XEXP (x, i), mem_mode);\n     else if (fmt[i] == 'E' || fmt[i] == 'V')\n       {\n \tint j;\n \tXVEC (x, i) = rtvec_alloc (XVECLEN (x, i));\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n \t  XVECEXP (x, i, j)\n-\t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), after, mem_mode);\n+\t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), mem_mode);\n       }\n \n   return x;\n@@ -2397,7 +2389,6 @@ struct rtx_subst_pair\n {\n   rtx to;\n   bool adjusted;\n-  bool after;\n };\n \n /* DATA points to an rtx_subst_pair.  Return the value that should be\n@@ -2414,7 +2405,7 @@ propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n     {\n       pair->adjusted = true;\n #ifdef AUTO_INC_DEC\n-      pair->to = cleanup_auto_inc_dec (pair->to, pair->after, VOIDmode);\n+      pair->to = cleanup_auto_inc_dec (pair->to, VOIDmode);\n #else\n       pair->to = copy_rtx (pair->to);\n #endif\n@@ -2424,19 +2415,17 @@ propagate_for_debug_subst (rtx from, const_rtx old_rtx, void *data)\n   return copy_rtx (pair->to);\n }\n \n-/* Replace occurrences of DEST with SRC in DEBUG_INSNs between INSN\n-   and LAST.  If MOVE holds, debug insns must also be moved past\n-   LAST.  */\n+/* Replace all the occurrences of DEST with SRC in DEBUG_INSNs between INSN\n+   and LAST.  */\n \n static void\n-propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src, bool move)\n+propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src)\n {\n-  rtx next, move_pos = move ? last : NULL_RTX, loc;\n+  rtx next, loc;\n \n   struct rtx_subst_pair p;\n   p.to = src;\n   p.adjusted = false;\n-  p.after = move;\n \n   next = NEXT_INSN (insn);\n   while (next != last)\n@@ -2450,14 +2439,7 @@ propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src, bool move)\n \t  if (loc == INSN_VAR_LOCATION_LOC (insn))\n \t    continue;\n \t  INSN_VAR_LOCATION_LOC (insn) = loc;\n-\t  if (move_pos)\n-\t    {\n-\t      remove_insn (insn);\n-\t      PREV_INSN (insn) = NEXT_INSN (insn) = NULL_RTX;\n-\t      move_pos = emit_debug_insn_after (insn, move_pos);\n-\t    }\n-\t  else\n-\t    df_insn_rescan (insn);\n+\t  df_insn_rescan (insn);\n \t}\n     }\n }\n@@ -2619,16 +2601,16 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n   added_links_insn = 0;\n \n-  /* First check for one important special-case that the code below will\n+  /* First check for one important special case that the code below will\n      not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL\n      and I3 is a SET whose SET_SRC is a SET_DEST in I2.  In that case,\n      we may be able to replace that destination with the destination of I3.\n      This occurs in the common code where we compute both a quotient and\n      remainder into a structure, in which case we want to do the computation\n      directly into the structure to avoid register-register copies.\n \n-     Note that this case handles both multiple sets in I2 and also\n-     cases where I2 has a number of CLOBBER or PARALLELs.\n+     Note that this case handles both multiple sets in I2 and also cases\n+     where I2 has a number of CLOBBERs inside the PARALLEL.\n \n      We make very conservative checks below and only try to handle the\n      most common cases of this.  For example, we only handle the case\n@@ -2672,8 +2654,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n       if (i == XVECLEN (p2, 0))\n \tfor (i = 0; i < XVECLEN (p2, 0); i++)\n-\t  if ((GET_CODE (XVECEXP (p2, 0, i)) == SET\n-\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER)\n+\t  if (GET_CODE (XVECEXP (p2, 0, i)) == SET\n \t      && SET_DEST (XVECEXP (p2, 0, i)) == SET_SRC (PATTERN (i3)))\n \t    {\n \t      combine_merges++;\n@@ -2682,16 +2663,14 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t      subst_low_luid = DF_INSN_LUID (i2);\n \n \t      added_sets_2 = added_sets_1 = added_sets_0 = 0;\n-\t      i2src = SET_DEST (PATTERN (i3));\n-\t      i2dest = SET_SRC (PATTERN (i3));\n+\t      i2src = SET_SRC (XVECEXP (p2, 0, i));\n+\t      i2dest = SET_DEST (XVECEXP (p2, 0, i));\n \t      i2dest_killed = dead_or_set_p (i2, i2dest);\n \n \t      /* Replace the dest in I2 with our dest and make the resulting\n-\t\t insn the new pattern for I3.  Then skip to where we\n-\t\t validate the pattern.  Everything was set up above.  */\n-\t      SUBST (SET_DEST (XVECEXP (p2, 0, i)),\n-\t\t     SET_DEST (PATTERN (i3)));\n-\n+\t\t insn the new pattern for I3.  Then skip to where we validate\n+\t\t the pattern.  Everything was set up above.  */\n+\t      SUBST (SET_DEST (XVECEXP (p2, 0, i)), SET_DEST (PATTERN (i3)));\n \t      newpat = p2;\n \t      i3_subst_into_i2 = 1;\n \t      goto validate_replacement;\n@@ -3820,7 +3799,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t\t   i2src while its original mode is temporarily\n \t\t   restored, and then clear i2scratch so that we don't\n \t\t   do it again later.  */\n-\t\tpropagate_for_debug (i2, i3, reg, i2src, false);\n+\t\tpropagate_for_debug (i2, i3, reg, i2src);\n \t\ti2scratch = false;\n \t\t/* Put back the new mode.  */\n \t\tadjust_reg_mode (reg, new_mode);\n@@ -3851,11 +3830,10 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t\t   with this copy we have created; then, replace the\n \t\t   copy with the SUBREG of the original shared reg,\n \t\t   once again changed to the new mode.  */\n-\t\tpropagate_for_debug (first, last, reg, tempreg, false);\n+\t\tpropagate_for_debug (first, last, reg, tempreg);\n \t\tadjust_reg_mode (reg, new_mode);\n \t\tpropagate_for_debug (first, last, tempreg,\n-\t\t\t\t     lowpart_subreg (old_mode, reg, new_mode),\n-\t\t\t\t     false);\n+\t\t\t\t     lowpart_subreg (old_mode, reg, new_mode));\n \t      }\n \t  }\n     }\n@@ -4069,14 +4047,14 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n     if (newi2pat)\n       {\n \tif (MAY_HAVE_DEBUG_INSNS && i2scratch)\n-\t  propagate_for_debug (i2, i3, i2dest, i2src, false);\n+\t  propagate_for_debug (i2, i3, i2dest, i2src);\n \tINSN_CODE (i2) = i2_code_number;\n \tPATTERN (i2) = newi2pat;\n       }\n     else\n       {\n \tif (MAY_HAVE_DEBUG_INSNS && i2src)\n-\t  propagate_for_debug (i2, i3, i2dest, i2src, i3_subst_into_i2);\n+\t  propagate_for_debug (i2, i3, i2dest, i2src);\n \tSET_INSN_DELETED (i2);\n       }\n \n@@ -4085,7 +4063,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \tLOG_LINKS (i1) = 0;\n \tREG_NOTES (i1) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n-\t  propagate_for_debug (i1, i3, i1dest, i1src, false);\n+\t  propagate_for_debug (i1, i3, i1dest, i1src);\n \tSET_INSN_DELETED (i1);\n       }\n \n@@ -4094,7 +4072,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \tLOG_LINKS (i0) = 0;\n \tREG_NOTES (i0) = 0;\n \tif (MAY_HAVE_DEBUG_INSNS)\n-\t  propagate_for_debug (i0, i3, i0dest, i0src, false);\n+\t  propagate_for_debug (i0, i3, i0dest, i0src);\n \tSET_INSN_DELETED (i0);\n       }\n "}, {"sha": "40098b3f7e2604d2f5e93aa21aaac05c22026f02", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -2882,10 +2882,10 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       return x;\n \n     case CLOBBER:\n+    case ASM_OPERANDS:\n       gcc_assert (insn && DEBUG_INSN_P (insn));\n       break;\n \n-    case ASM_OPERANDS:\n     case SET:\n       gcc_unreachable ();\n "}, {"sha": "8cab44c376f1b0ee065547428dde29b0dc27733c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -1,3 +1,7 @@\n+2010-10-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt6.ad[sb]: New test.\n+\n 2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented fast enumeration for Objective-C."}, {"sha": "44dc047b538f2d15c6e64b4a16bb515433930139", "filename": "gcc/testsuite/gnat.dg/opt6.adb", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.adb?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -0,0 +1,28 @@\n+-- PR rtl-optimization/45394\n+\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -g\" }\n+\n+package body Opt6 is\n+\n+   function Current_Parameter (Iter : Command_Line_Iterator) return String is\n+   begin\n+      if Iter.Params = null\n+        or else Iter.Current > Iter.Params'Last\n+        or else Iter.Params (Iter.Current) = null\n+      then\n+         return \"\";\n+\n+      else\n+         declare\n+            P : constant String := Iter.Params (Iter.Current).all;\n+\n+         begin\n+            --  Skip separator\n+\n+            return P (P'First + 1 .. P'Last);\n+         end;\n+      end if;\n+   end Current_Parameter;\n+\n+end Opt6;"}, {"sha": "f04985316425cdcf40ddb8bcc4af00a6a5a1b6a0", "filename": "gcc/testsuite/gnat.dg/opt6.ads", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c506f103cda9948114a65c27a46e05b0e116222/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt6.ads?ref=9c506f103cda9948114a65c27a46e05b0e116222", "patch": "@@ -0,0 +1,14 @@\n+package Opt6 is\n+\n+   type String_Access is access all String;\n+   type String_List is array (Positive range <>) of String_Access;\n+   type String_List_Access is access all String_List;\n+\n+   type Command_Line_Iterator is record\n+      Params   : String_List_Access;\n+      Current  : Natural;\n+   end record;\n+\n+   function Current_Parameter (Iter : Command_Line_Iterator) return String;\n+\n+end Opt6;"}]}