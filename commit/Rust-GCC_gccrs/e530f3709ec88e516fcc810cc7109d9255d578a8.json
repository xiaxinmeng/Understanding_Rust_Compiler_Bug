{"sha": "e530f3709ec88e516fcc810cc7109d9255d578a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUzMGYzNzA5ZWM4OGU1MTZmY2M4MTBjYzcxMDlkOTI1NWQ1NzhhOA==", "commit": {"author": {"name": "Olga Rodimina", "email": "rodimina@redhat.com", "date": "2004-02-04T18:43:54Z"}, "committer": {"name": "Olga Rodimina", "email": "rodimina@gcc.gnu.org", "date": "2004-02-04T18:43:54Z"}, "message": "AffineTransform.java: Corrected comments on the field definitions for m11 and m10.\n\n\n\t* java/awt/geom/AffineTransform.java:\n\tCorrected comments on the field definitions for\n\tm11 and m10.\n\t(shear): Fixed few errors that caused shear\n\ttransformation to be performed incorrectly.\n\t(createInverse): Fixed to return correct\n\tinverse of the given matrix.\n\nFrom-SVN: r77261", "tree": {"sha": "775a19e62616e1935eff711bf6eb537f6114a488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/775a19e62616e1935eff711bf6eb537f6114a488"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e530f3709ec88e516fcc810cc7109d9255d578a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e530f3709ec88e516fcc810cc7109d9255d578a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e530f3709ec88e516fcc810cc7109d9255d578a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e530f3709ec88e516fcc810cc7109d9255d578a8/comments", "author": null, "committer": null, "parents": [{"sha": "9baa27a975e184773ffb8ec4297db8ce34291246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baa27a975e184773ffb8ec4297db8ce34291246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9baa27a975e184773ffb8ec4297db8ce34291246"}], "stats": {"total": 65, "additions": 57, "deletions": 8}, "files": [{"sha": "88a58154ca531a4ca83ca7849aab7180eeab08b8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e530f3709ec88e516fcc810cc7109d9255d578a8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e530f3709ec88e516fcc810cc7109d9255d578a8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e530f3709ec88e516fcc810cc7109d9255d578a8", "patch": "@@ -1,3 +1,13 @@\n+2004-02-04  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* java/awt/geom/AffineTransform.java: \n+\tCorrected comments on the field definitions for\n+\tm11 and m10.\n+\t(shear): Fixed few errors that caused shear\n+\ttransformation to be performed incorrectly.\n+\t(createInverse): Fixed to return correct\n+\tinverse of the given matrix.\n+\n 2004-02-03  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natPosixProcess.cc (startProcess): Handle case where"}, {"sha": "1410d90cb373c358f357ee09450ef7e5c7b8b820", "filename": "libjava/java/awt/geom/AffineTransform.java", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e530f3709ec88e516fcc810cc7109d9255d578a8/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e530f3709ec88e516fcc810cc7109d9255d578a8/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FAffineTransform.java?ref=e530f3709ec88e516fcc810cc7109d9255d578a8", "patch": "@@ -226,7 +226,7 @@ public class AffineTransform implements Cloneable, Serializable\n   private double m00;\n \n   /**\n-   * The Y coordinate scaling element of the transform matrix.\n+   * The Y coordinate shearing element of the transform matrix.\n    *\n    * @serial matrix[1,0]\n    */\n@@ -240,7 +240,7 @@ public class AffineTransform implements Cloneable, Serializable\n   private double m01;\n \n   /**\n-   * The Y coordinate shearing element of the transform matrix.\n+   * The Y coordinate scaling element of the transform matrix.\n    *\n    * @serial matrix[1,1]\n    */\n@@ -738,10 +738,10 @@ public void scale(double sx, double sy)\n    */\n   public void shear(double shx, double shy)\n   {\n-    double n00 = m00 + shx * m01;\n-    double n01 = shx * m00 + m01;\n-    double n10 = m10 * shy + m11;\n-    double n11 = shx * m10 + m11;\n+    double n00 = m00 + (shy * m01);\n+    double n01 = m01 + (shx * m00);\n+    double n10 = m10 + (shy * m11);\n+    double n11 = m11 + (shx * m10);\n     m00 = n00;\n     m01 = n01;\n     m10 = n10;\n@@ -996,6 +996,38 @@ public void preConcatenate(AffineTransform tx)\n    * map multiple points to the same line or point). A transform exists only\n    * if getDeterminant() has a non-zero value.\n    *\n+   * The inverse is calculated as:\n+   * \n+   * <pre>\n+   *\n+   * Let A be the matrix for which we want to find the inverse:\n+   *\n+   * A = [ m00 m01 m02 ]\n+   *     [ m10 m11 m12 ]\n+   *     [ 0   0   1   ] \n+   *\n+   *\n+   *                 1    \n+   * inverse (A) =  ---   x  adjoint(A) \n+   *                det \n+   *\n+   *\n+   *\n+   *             =   1       [  m11  -m01   m01*m12-m02*m11  ]\n+   *                ---   x  [ -m10   m00  -m00*m12+m10*m02  ]\n+   *                det      [  0     0     m00*m11-m10*m01  ]\n+   *\n+   *\n+   *\n+   *             = [  m11/det  -m01/det   m01*m12-m02*m11/det ]\n+   *               [ -m10/det   m00/det  -m00*m12+m10*m02/det ]\n+   *               [   0           0          1               ]\n+   *\n+   *\n+   * </pre>\n+   *\n+   *\n+   *\n    * @return a new inverse transform\n    * @throws NoninvertibleTransformException if inversion is not possible\n    * @see #getDeterminant()\n@@ -1006,8 +1038,15 @@ public AffineTransform createInverse()\n     double det = getDeterminant();\n     if (det == 0)\n       throw new NoninvertibleTransformException(\"can't invert transform\");\n-    return new AffineTransform(m11 / det, -m10 / det, m01 / det, -m00 / det,\n-                               -m02, -m12);\n+    \n+    double im00 = m11 / det;\n+    double im10 = -m10 / det;\n+    double im01 = -m01 / det;\n+    double im11 = m00 / det;\n+    double im02 = (m01 * m12 - m02 * m11) / det;\n+    double im12 = (-m00 * m12 + m10 * m02) / det;\n+    \n+    return new AffineTransform (im00, im10, im01, im11, im02, im12);\n   }\n \n   /**"}]}