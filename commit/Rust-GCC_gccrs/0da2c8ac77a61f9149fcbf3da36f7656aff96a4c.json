{"sha": "0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhMmM4YWM3N2E2MWY5MTQ5ZmNiZjNkYTM2Zjc2NTZhZmY5NmE0Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-06-25T16:39:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-06-25T16:39:33Z"}, "message": "revert: [multiple changes]\n\n2004-06-25  Pascal Obry  <obry@gnat.com>\n\n\t* makegpr.adb (Build_Library): Remove parameter Lib_Address and\n\tRelocatable from Build_Dynamic_Library call.\n\n\t* gnat_ugn.texi: Change documentation about Library_Kind. Dynamic and\n\tRelocatable are now synonym.\n\n\t* Makefile.in: Use s-parame-mingw.adb on MingW platform.\n\n\t* mlib-prj.adb (Build_Library): Remove DLL_Address constant definition.\n\tRemove parameter Lib_Address and Relocatable from Build_Dynamic_Library\n\tcall.\n\n\t* mlib-tgt.ads, mlib-tgt.adb (Build_Dynamic_Library): Remove parameter\n\tLib_Address and Relocatable.\n\t(Default_DLL_Address): Removed.\n\n\t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb,\n\tmlib-tgt-hpux.adb, mlib-tgt-linux.adb, mlib-tgt-solaris.adb,\n\tmlib-tgt-vms-alpha.adb, mlib-tgt-vms-ia64.adb, mlib-tgt-vxworks.adb:\n\t(Build_Dynamic_Library): Remove parameter Lib_Address and Relocatable.\n\t(Default_DLL_Address): Removed.\n\n\t* mlib-tgt-mingw.adb: Ditto.\n\t(Build_Dynamic_Library): Do not add \"lib\" prefix to the DLL name.\n\n\t* s-taprop-mingw.adb (Create_Task): Use Adjust_Storage_Size to compute\n\tthe initial thread stack size.\n\n\t* a-strmap.ads: Move package L to private part as it is not used in\n\tthe spec. Found while reading code.\n\n2004-06-25  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* tracebak.c: Introduce support for a GCC infrastructure based\n\timplementation of __gnat_backtrace.\n\n\t* raise.c: Don't rely on a C mapping of the GNAT_GCC_Exception record\n\tany more. Use accessors instead. This eases maintenance and relaxes\n\tsome alignment constraints.\n\t(_GNAT_Exception structure): Remove the Ada specific fields\n\t(EID_For, Adjust_N_Cleanups_For): New accessors, exported by\n\ta-exexpr.adb.\n\t(is_handled_by, __gnat_eh_personality): Replace component references to\n\texception structure by use of the new accessors.\n\n\t* init.c (__gnat_initialize): Adjust comments to match the just\n\treverted meaning of the -static link-time option.\n\n\t* adaint.c (convert_addresses): Arrange not to define a stub for\n\tmips-irix any more, as we now want to rely on a real version from a\n\trecent libaddr2line.\n\n\t* a-exexpr.adb: Provide new accessors to a GNAT_GCC occurrence, so that\n\tthe personality routine can use them and not have to rely on a C\n\tcounterpart of the record anymore. This simplifies maintenance and\n\trelaxes the constraint of having Standard'Maximum_Alignment match\n\tBIGGEST_ALIGNMENT.\n\tUpdate comments, and add a section on the common header alignment issue.\n\n2004-06-25  Geert Bosch  <bosch@gnat.com>\n\n\t* a-ngelfu.adb (Tanh): Use full 20 digit precision for constants in\n\tpolynomial approximation. Fixes inconsistency with Cody/Waite algorithm.\n\n2004-06-25  Robert Dewar  <dewar@gnat.com>\n\n\t* gnat_rm.texi: Fix section on component clauses to indicate that the\n\trestriction on byte boundary placement still applies for bit packed\n\tarrays.\n\tAdd comment on stack usage from Initialize_Scalars\n\n\t* gnat_ugn.texi: Add documentation for -gnatyLnnn\n\n\t* stylesw.ads, stylesw.adb: Implement new -gnatyLnnn option for\n\tlimiting nesting level.\n\n\t* usage.adb: Add line for -gnatyLnnn switch\n\n\t* g-debpoo.ads, xtreeprs.adb, sinput.ads, sem_ch13.ads,\n\tsem_ch13.adb, exp_aggr.adb: Minor reformatting\n\n\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Set Is_Atomic on base\n\ttype as well as on the subtype. This corrects a problem in freeze in\n\tsetting alignments of atomic types.\n\n\t* sem_eval.ads: Minor comment typo fixed\n\n\t* par-util.adb (Push_Scope_Stack): Check for violation of max nesting\n\tlevel.  Minor reformatting.\n\n\t* fname.adb (Is_Predefined_File_Name): Require a letter after the\n\tminus sign. This means that file names like a--b.adb will not be\n\tconsidered predefined.\n\n\t* freeze.adb: Propagate new flag Must_Be_On_Byte_Boundary to containing\n\trecord Test new flag and give diagnostic for bad component clause.\n\t(Freeze_Entity): Set alignment of array from component alignment in\n\tcases where this is safe to do.\n\n\t* exp_pakd.adb: Set new flag Must_Be_On_Byte_Boundary for large packed\n\tarrays.\n\n\t* cstand.adb: (Create_Standard): Set alignment of String to 1\n\n\t* einfo.ads, einfo.adb: Introduce new flag Must_Be_On_Byte_Boundary\n\n\t* exp_ch4.adb (Expand_Array_Equality): Improve efficiency of generated\n\tcode in the common constrained array cases.\n\n\t* a-storio.adb: Change implementation to avoid possible alignment\n\tproblems on machines requiring strict alignment (data should be moved\n\tas type Buffer, not type Elmt).\n\n\t* checks.adb (Apply_Array_Size_Check): Improve these checks by\n\tkilling the overflow checks which we really do not need (64-bits is\n\tenough).\n\n2004-06-25  Vincent Celier  <celier@gnat.com>\n\n\t* makegpr.adb (Is_Included_In_Global_Archive): New Boolean function\n\t(Add_Archives.Recursive_Add_Archives): Call Add_Archive_Path\n\tinconditionally for the main project.\n\t(Recursive_Add_Archives.Add_Archive_Path): New procedure\n\t(Link_Executables.Check_Time_Stamps): New procedure\n\t(Link_Executables.Link_Foreign): New procedure\n\tChanges made to reduce nesting level of this package\n\t(Check): New procedure\n\t(Add_Switches): When not in quiet output, check that a switch is not\n\tthe concatenation of several valid switches. If it is, issue a warning.\n\t(Build_Global_Archive): If the global archive is rebuilt, linking need\n\tto be done.\n\t(Compile_Sources): Rebuilding a library archive does not imply\n\trebuilding the global archive.\n\t(Build_Global_Archive): New procedure\n\t(Build_Library): New name for Build_Archive, now only for library\n\tproject\n\t(Check_Archive_Builder): New procedure\n\t(Create_Global_Archive_Dependency_File): New procedure\n\t(Gprmake): Call Build_Global_Archive before linking\n\t* makegpr.adb: Use Other_Sources_Present instead of Sources_Present\n\tthroughout.\n\t(Scan_Arg): Display the Copyright notice when -v is used\n\n\t* gnat_ugn.texi: Document new switch -files= (VMS qualifier /FILES=)\n\tfor gnatls.\n\n\t* vms_data.ads: Add qualifier /MAX_NESTING=nnn (-gnatyLnnn) for GNAT\n\tCOMPILE.\n\tAdd new GNAT LIST qualifier /FILES=\n\tAdded qualifier /DIRECTORY= to GNAT METRIC\n\tAdded qualifier /FILES= to GNAT METRIC\n\tAdded qualifier /FILES to GNAT PRETTY\n\n\t* switch.adb (Is_Front_End_Switch): Refine the test for --RTS or -fRTS,\n\tto take into account both versions of the switch.\n\n\t* switch-c.adb (Scan_Front_End_Switches): New switch -gnatez. Should\n\talways be the last switch to the gcc driver. Disable switch storing so\n\tthat switches automatically added by the gcc driver are not put in the\n\tALI file.\n\n\t* prj.adb (Project_Empty): Take into account changes in components of\n\tProject_Data.\n\n\t* prj.ads (Languages_Processed): New enumaration value All_Languages.\n\n\t* prj.ads (Project_Data): Remove component Lib_Elaboration: never\n\tused. Split Boolean component Ada_Sources_Present in two Boolean\n\tcomponents Ada_Sources_Present and Other_Sources_Present.\n\tMinor reformatting\n\n\t* prj-env.adb (For_All_Source_Dirs.Add): Use Ada_Sources_Present\n\tinstead of Sources_Present.\n\t(Set_Ada_Paths.Add.Recursive_Add): Ditto\n\n\t* prj-nmsc.adb: Minor reformatting\n\t(Check_Ada_Naming_Scheme): New name of procedure Check_Naming_Scheme\n\t(Check_Ada_Naming_Scheme_Validity): New name of previous procedure\n\tCheck_Ada_Naming_Scheme.\n\tChange Sources_Present to Ada_Sources_Present or Other_Sources_Present\n\tthroughout.\n\n\t* prj-part.adb (Post_Parse_Context_Clause): New Boolean parameter\n\tIn_Limited.\n\tMake sure that all cycles where there is at least one \"limited with\"\n\tare detected.\n\t(Parse_Single_Project): New Boolean parameter In_Limited\n\n\t* prj-proc.adb (Recursive_Check): When Process_Languages is\n\tAll_Languages, call first Prj.Nmsc.Ada_Check, then\n\tPrj.Nmsc.Other_Languages_Check.\n\n\t* prj-proc.adb (Process): Use Ada_Sources_Present or\n\tOther_Sources_Present (instead of Sources_Present) depending on\n\tProcess_Languages.\n\n\t* lang-specs.h: Keep -g and -m switches in the same order, and as the\n\tlast switches.\n\n\t* lib.adb (Switch_Storing_Enabled): New global Boolean flag\n\t(Disable_Switch_Storing): New procedure. Set Switch_Storing_Enabled to\n\tFalse.\n\t(Store_Compilation_Switch): Do nothing if Switch_Storing_Enabled is\n\tFalse.\n\n\t* lib.ads (Disable_Switch_Storing): New procedure.\n\n\t* make.adb: Modifications to reduce nesting level of this package.\n\t(Check_Standard_Library): New procedure\n\t(Gnatmake.Check_Mains): New procedure\n\t(Gnatmake.Create_Binder_Mapping_File): New procedure\n\t(Compile_Sources.Compile): Add switch -gnatez as the last option\n\t(Display): Never display -gnatez\n\n\t* Makefile.generic:\n\tWhen using $(MAIN_OBJECT), always use $(OBJ_DIR)/$(MAIN_OBJECT)\n\n\t* gnatcmd.adb (Check_Project): New function\n\t(Process_Link): New procedure to reduce nesting depth\n\t(Check_Files): New procedure to reduce the nesting depth.\n\tFor GNAT METRIC, include the inherited sources in extending projects.\n\t(GNATCmd): When GNAT LS is invoked with a project file and no files,\n\tadd the list of files from the sources of the project file. If this list\n\tis too long, put it in a temp text files and use switch -files=\n\t(Delete_Temp_Config_Files): Delete the temp text file that contains\n\ta list of source for gnatpp or gnatmetric, if one has been created.\n\t(GNATCmd): For GNAT METRIC and GNAT PRETTY, if the number of sources\n\tin the project file is too large, create a temporary text file that\n\tlist them and pass it to the tool with \"-files=<temp text file>\".\n\t(GNATCmd): For GNAT METRIC add \"-d=<abject dir>\" as the first switch\n\n\t* gnatlink.adb (Gnatlink): Do not compile with --RTS= when the\n\tgenerated file is in not in Ada.\n\n\t* gnatls.adb: Remove all parameters And_Save that are no longer used.\n\t(Scan_Ls_Arg): Add processing for -files=\n\t(Usage): Add line for -files=\n\n\t* g-os_lib.adb (On_Windows): New global constant Boolean flag\n\t(Normalize_Pathname): When on Windows and the path starts with a\n\tdirectory separator, make sure that the resulting path will start with\n\ta drive letter.\n\n\t* clean.adb (Clean_Archive): New procedure\n\t(Clean_Project): When there is non-Ada code, delete the global archive,\n\tthe archive dependency files, the object files and their dependency\n\tfiles, if they exist.\n\t(Gnatclean): Call Prj.Pars.Parse for All_Languages, not for Ada only.\n\n2004-06-25  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sinfo.ads: Fix typo in comment.\n\n\t* sem_dist.adb (Process_Remote_AST_Attribute): Simplify code that uses\n\tthe TSS for remote access-to-subprogram types, since these TSS are\n\talways present once the type has been analyzed.\n\t(RAS_E_Dereference): Same.\n\n\t* sem_attr.adb (Analyze_Attribute): When analysis of an attribute\n\treference raises Bad_Attribute, mark the reference as analyzed so the\n\tnode (and any children resulting from rewrites that could have occurred\n\tduring the analysis that ultimately failed) is not analyzed again.\n\n\t* exp_ch7.ads (Find_Final_List): Fix misaligned comment.\n\n\t* exp_dist.adb: Minor comment fix.\n\n\t* exp_ch4.adb (Expand_N_Allocator): For an allocator whose expected\n\ttype is an anonymous access type, no unchecked deallocation of the\n\tallocated object can occur. If the object is controlled, attach it with\n\ta count of 1. This allows attachment to the Global_Final_List, if\n\tno other relevant list is available.\n\t(Get_Allocator_Final_List): For an anonymous access type that is\n\tthe type of a discriminant or record component, the corresponding\n\tfinalisation list is the one of the scope of the type.\n\n2004-06-25  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb (Replace_Type): When computing the signature of an\n\tinherited subprogram, use the first subtype if the derived type\n\tdeclaration has no constraint.\n\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): Check that formal is an array\n\tbefore applying previous optimization. Minor code cleanup.\n\n\t* exp_util.adb (Is_Possibly_Unaligned_Slice): If the component is\n\tplaced at the beginning of an unpacked record without explicit\n\talignment, a slice of it will be aligned and does not need a copy when\n\tused as an actual.\n\n2004-06-25  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15591\n\tPR ada/15592\n\t* sem_ch8.adb (Attribute_Renaming): Reject renaming if the attribute\n\treference is written with expressions mimicking parameters.\n\n2004-06-25  Hristian Kirtchev  <kirtchev@gnat.com>\n\n\tPR ada/15589\n\t* sem_ch3.adb (Build_Derived_Record_Type): Add additional check to\n\tSTEP 2a. The constraints of a full type declaration of a derived record\n\ttype are checked for conformance with those declared in the\n\tcorresponding private extension declaration. The message\n\t\"not conformant with previous declaration\" is emitted if an error is\n\tdetected.\n\n2004-06-25  Vasiliy Fofanov  <fofanov@act-europe.fr>\n\n\t* g-traceb.ads: Document the need for -E binder switch in the spec.\n\n\t* g-trasym.ads: Document the need for -E binder switch in the spec.\n\n2004-06-25  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* sem_prag.adb: Add handling of pragma Detect_Blocking.\n\n\t* snames.h, snames.ads, snames.adb: Add entry for pragma\n\tDetect_Blocking.\n\n\t* s-rident.ads: Change reference to pragma Detect_Blocking.\n\n\t* targparm.ads, targparm.adb: Allow pragma Detect_Blocking in\n\tsystem.ads.\n\n\t* opt.ads (Detect_Blocking): New Boolean variable (defaulted to False)\n\tto indicate whether pragma Detect_Blocking is active.\n\n\t* par-prag.adb: Add entry for pragma Detect_Blocking.\n\n\t* rtsfind.adb (RTU_Loaded): Fix the temporary kludge to get past bug\n\tof not handling WITH.\n\tNote that this replaces the previous update which was incorrect.\n\n2004-06-25  Javier Miranda  <miranda@gnat.com>\n\n\t* sem_ch10.adb (Re_Install_Use_Clauses): Force the installation of the\n\tuse-clauses to have a clean environment.\n\n\t* sem_ch8.adb (Install_Use_Clauses): Addition of a new formal to force\n\tthe installation of the use-clauses to stablish a clean environment in\n\tcase of compilation of a separate unit; otherwise the call to\n\tuse_one_package is protected by the barrier Applicable_Use.\n\n\t* sem_ch8.ads (Install_Use_Clauses): Addition of a new formal to force\n\tthe installation of the use-clauses to stablish a clean environment in\n\tcase of compilation of a separate unit.\n\t(End_Use_Clauses): Minor comment cleanup.\n\n2004-06-25  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* gnat_ugn.texi: Add description of the gnatpp 'files' switch\n\nFrom-SVN: r83658", "tree": {"sha": "7773949d835bb70e525203ff86961e0f04f2c02c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7773949d835bb70e525203ff86961e0f04f2c02c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/comments", "author": null, "committer": null, "parents": [{"sha": "29357d8b9417cf74ce10fc868e4774d4c77d6889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29357d8b9417cf74ce10fc868e4774d4c77d6889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29357d8b9417cf74ce10fc868e4774d4c77d6889"}], "stats": {"total": 8123, "additions": 4923, "deletions": 3200}, "files": [{"sha": "38108d94cf412f08a0a84d51ac8d75251b3229a1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1,3 +1,358 @@\n+2004-06-25  Pascal Obry  <obry@gnat.com>\n+\n+\t* makegpr.adb (Build_Library): Remove parameter Lib_Address and\n+\tRelocatable from Build_Dynamic_Library call.\n+\n+\t* gnat_ugn.texi: Change documentation about Library_Kind. Dynamic and\n+\tRelocatable are now synonym.\n+\n+\t* Makefile.in: Use s-parame-mingw.adb on MingW platform.\n+\n+\t* mlib-prj.adb (Build_Library): Remove DLL_Address constant definition.\n+\tRemove parameter Lib_Address and Relocatable from Build_Dynamic_Library\n+\tcall.\n+\n+\t* mlib-tgt.ads, mlib-tgt.adb (Build_Dynamic_Library): Remove parameter\n+\tLib_Address and Relocatable.\n+\t(Default_DLL_Address): Removed.\n+\n+\t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb, \n+\tmlib-tgt-hpux.adb, mlib-tgt-linux.adb, mlib-tgt-solaris.adb, \n+\tmlib-tgt-vms-alpha.adb, mlib-tgt-vms-ia64.adb, mlib-tgt-vxworks.adb:\n+\t(Build_Dynamic_Library): Remove parameter Lib_Address and Relocatable.\n+\t(Default_DLL_Address): Removed.\n+\n+\t* mlib-tgt-mingw.adb: Ditto.\n+\t(Build_Dynamic_Library): Do not add \"lib\" prefix to the DLL name.\n+\n+\t* s-taprop-mingw.adb (Create_Task): Use Adjust_Storage_Size to compute\n+\tthe initial thread stack size.\n+\n+\t* a-strmap.ads: Move package L to private part as it is not used in\n+\tthe spec. Found while reading code.\n+\n+2004-06-25  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* tracebak.c: Introduce support for a GCC infrastructure based\n+\timplementation of __gnat_backtrace.\n+\n+\t* raise.c: Don't rely on a C mapping of the GNAT_GCC_Exception record\n+\tany more. Use accessors instead. This eases maintenance and relaxes\n+\tsome alignment constraints.\n+\t(_GNAT_Exception structure): Remove the Ada specific fields\n+\t(EID_For, Adjust_N_Cleanups_For): New accessors, exported by\n+\ta-exexpr.adb.\n+\t(is_handled_by, __gnat_eh_personality): Replace component references to\n+\texception structure by use of the new accessors.\n+\n+\t* init.c (__gnat_initialize): Adjust comments to match the just\n+\treverted meaning of the -static link-time option.\n+\n+\t* adaint.c (convert_addresses): Arrange not to define a stub for\n+\tmips-irix any more, as we now want to rely on a real version from a\n+\trecent libaddr2line.\n+\n+\t* a-exexpr.adb: Provide new accessors to a GNAT_GCC occurrence, so that\n+\tthe personality routine can use them and not have to rely on a C\n+\tcounterpart of the record anymore. This simplifies maintenance and\n+\trelaxes the constraint of having Standard'Maximum_Alignment match\n+\tBIGGEST_ALIGNMENT.\n+\tUpdate comments, and add a section on the common header alignment issue.\n+\n+2004-06-25  Geert Bosch  <bosch@gnat.com>\n+\n+\t* a-ngelfu.adb (Tanh): Use full 20 digit precision for constants in\n+\tpolynomial approximation. Fixes inconsistency with Cody/Waite algorithm.\n+\n+2004-06-25  Robert Dewar  <dewar@gnat.com>\n+\n+\t* gnat_rm.texi: Fix section on component clauses to indicate that the\n+\trestriction on byte boundary placement still applies for bit packed\n+\tarrays.\n+\tAdd comment on stack usage from Initialize_Scalars\n+\n+\t* gnat_ugn.texi: Add documentation for -gnatyLnnn\n+\n+\t* stylesw.ads, stylesw.adb: Implement new -gnatyLnnn option for\n+\tlimiting nesting level.\n+\n+\t* usage.adb: Add line for -gnatyLnnn switch\n+\n+\t* g-debpoo.ads, xtreeprs.adb, sinput.ads, sem_ch13.ads,\n+\tsem_ch13.adb, exp_aggr.adb: Minor reformatting\n+\n+\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Set Is_Atomic on base\n+\ttype as well as on the subtype. This corrects a problem in freeze in\n+\tsetting alignments of atomic types.\n+\n+\t* sem_eval.ads: Minor comment typo fixed\n+\n+\t* par-util.adb (Push_Scope_Stack): Check for violation of max nesting\n+\tlevel.  Minor reformatting.\n+\n+\t* fname.adb (Is_Predefined_File_Name): Require a letter after the\n+\tminus sign. This means that file names like a--b.adb will not be\n+\tconsidered predefined.\n+\n+\t* freeze.adb: Propagate new flag Must_Be_On_Byte_Boundary to containing\n+\trecord Test new flag and give diagnostic for bad component clause.\n+\t(Freeze_Entity): Set alignment of array from component alignment in\n+\tcases where this is safe to do.\n+\n+\t* exp_pakd.adb: Set new flag Must_Be_On_Byte_Boundary for large packed\n+\tarrays.\n+\n+\t* cstand.adb: (Create_Standard): Set alignment of String to 1\n+\n+\t* einfo.ads, einfo.adb: Introduce new flag Must_Be_On_Byte_Boundary\n+\n+\t* exp_ch4.adb (Expand_Array_Equality): Improve efficiency of generated\n+\tcode in the common constrained array cases.\n+\n+\t* a-storio.adb: Change implementation to avoid possible alignment\n+\tproblems on machines requiring strict alignment (data should be moved\n+\tas type Buffer, not type Elmt).\n+\n+\t* checks.adb (Apply_Array_Size_Check): Improve these checks by\n+\tkilling the overflow checks which we really do not need (64-bits is\n+\tenough).\n+\n+2004-06-25  Vincent Celier  <celier@gnat.com>\n+\n+\t* makegpr.adb (Is_Included_In_Global_Archive): New Boolean function\n+\t(Add_Archives.Recursive_Add_Archives): Call Add_Archive_Path\n+\tinconditionally for the main project.\n+\t(Recursive_Add_Archives.Add_Archive_Path): New procedure\n+\t(Link_Executables.Check_Time_Stamps): New procedure\n+\t(Link_Executables.Link_Foreign): New procedure\n+\tChanges made to reduce nesting level of this package\n+\t(Check): New procedure\n+\t(Add_Switches): When not in quiet output, check that a switch is not\n+\tthe concatenation of several valid switches. If it is, issue a warning.\n+\t(Build_Global_Archive): If the global archive is rebuilt, linking need\n+\tto be done.\n+\t(Compile_Sources): Rebuilding a library archive does not imply\n+\trebuilding the global archive.\n+\t(Build_Global_Archive): New procedure\n+\t(Build_Library): New name for Build_Archive, now only for library\n+\tproject\n+\t(Check_Archive_Builder): New procedure\n+\t(Create_Global_Archive_Dependency_File): New procedure\n+\t(Gprmake): Call Build_Global_Archive before linking\n+\t* makegpr.adb: Use Other_Sources_Present instead of Sources_Present\n+\tthroughout.\n+\t(Scan_Arg): Display the Copyright notice when -v is used\n+\n+\t* gnat_ugn.texi: Document new switch -files= (VMS qualifier /FILES=)\n+\tfor gnatls.\n+\n+\t* vms_data.ads: Add qualifier /MAX_NESTING=nnn (-gnatyLnnn) for GNAT\n+\tCOMPILE.\n+\tAdd new GNAT LIST qualifier /FILES=\n+\tAdded qualifier /DIRECTORY= to GNAT METRIC\n+\tAdded qualifier /FILES= to GNAT METRIC\n+\tAdded qualifier /FILES to GNAT PRETTY\n+\n+\t* switch.adb (Is_Front_End_Switch): Refine the test for --RTS or -fRTS,\n+\tto take into account both versions of the switch.\n+\n+\t* switch-c.adb (Scan_Front_End_Switches): New switch -gnatez. Should\n+\talways be the last switch to the gcc driver. Disable switch storing so\n+\tthat switches automatically added by the gcc driver are not put in the\n+\tALI file.\n+\n+\t* prj.adb (Project_Empty): Take into account changes in components of\n+\tProject_Data.\n+\n+\t* prj.ads (Languages_Processed): New enumaration value All_Languages.\n+\n+\t* prj.ads (Project_Data): Remove component Lib_Elaboration: never\n+\tused. Split Boolean component Ada_Sources_Present in two Boolean\n+\tcomponents Ada_Sources_Present and Other_Sources_Present.\n+\tMinor reformatting\n+\n+\t* prj-env.adb (For_All_Source_Dirs.Add): Use Ada_Sources_Present\n+\tinstead of Sources_Present.\n+\t(Set_Ada_Paths.Add.Recursive_Add): Ditto\n+\n+\t* prj-nmsc.adb: Minor reformatting\n+\t(Check_Ada_Naming_Scheme): New name of procedure Check_Naming_Scheme\n+\t(Check_Ada_Naming_Scheme_Validity): New name of previous procedure\n+\tCheck_Ada_Naming_Scheme.\n+\tChange Sources_Present to Ada_Sources_Present or Other_Sources_Present\n+\tthroughout.\n+\n+\t* prj-part.adb (Post_Parse_Context_Clause): New Boolean parameter\n+\tIn_Limited.\n+\tMake sure that all cycles where there is at least one \"limited with\"\n+\tare detected.\n+\t(Parse_Single_Project): New Boolean parameter In_Limited\n+\n+\t* prj-proc.adb (Recursive_Check): When Process_Languages is\n+\tAll_Languages, call first Prj.Nmsc.Ada_Check, then\n+\tPrj.Nmsc.Other_Languages_Check.\n+\n+\t* prj-proc.adb (Process): Use Ada_Sources_Present or\n+\tOther_Sources_Present (instead of Sources_Present) depending on\n+\tProcess_Languages.\n+\n+\t* lang-specs.h: Keep -g and -m switches in the same order, and as the\n+\tlast switches.\n+\n+\t* lib.adb (Switch_Storing_Enabled): New global Boolean flag\n+\t(Disable_Switch_Storing): New procedure. Set Switch_Storing_Enabled to\n+\tFalse.\n+\t(Store_Compilation_Switch): Do nothing if Switch_Storing_Enabled is\n+\tFalse.\n+\n+\t* lib.ads (Disable_Switch_Storing): New procedure.\n+\n+\t* make.adb: Modifications to reduce nesting level of this package.\n+\t(Check_Standard_Library): New procedure\n+\t(Gnatmake.Check_Mains): New procedure\n+\t(Gnatmake.Create_Binder_Mapping_File): New procedure\n+\t(Compile_Sources.Compile): Add switch -gnatez as the last option\n+\t(Display): Never display -gnatez\n+\n+\t* Makefile.generic: \n+\tWhen using $(MAIN_OBJECT), always use $(OBJ_DIR)/$(MAIN_OBJECT)\n+\n+\t* gnatcmd.adb (Check_Project): New function\n+\t(Process_Link): New procedure to reduce nesting depth\n+\t(Check_Files): New procedure to reduce the nesting depth.\n+\tFor GNAT METRIC, include the inherited sources in extending projects.\n+\t(GNATCmd): When GNAT LS is invoked with a project file and no files,\n+\tadd the list of files from the sources of the project file. If this list\n+\tis too long, put it in a temp text files and use switch -files=\n+\t(Delete_Temp_Config_Files): Delete the temp text file that contains\n+\ta list of source for gnatpp or gnatmetric, if one has been created.\n+\t(GNATCmd): For GNAT METRIC and GNAT PRETTY, if the number of sources\n+\tin the project file is too large, create a temporary text file that\n+\tlist them and pass it to the tool with \"-files=<temp text file>\".\n+\t(GNATCmd): For GNAT METRIC add \"-d=<abject dir>\" as the first switch\n+\n+\t* gnatlink.adb (Gnatlink): Do not compile with --RTS= when the\n+\tgenerated file is in not in Ada.\n+\n+\t* gnatls.adb: Remove all parameters And_Save that are no longer used.\n+\t(Scan_Ls_Arg): Add processing for -files=\n+\t(Usage): Add line for -files=\n+\n+\t* g-os_lib.adb (On_Windows): New global constant Boolean flag\n+\t(Normalize_Pathname): When on Windows and the path starts with a\n+\tdirectory separator, make sure that the resulting path will start with\n+\ta drive letter.\n+\n+\t* clean.adb (Clean_Archive): New procedure\n+\t(Clean_Project): When there is non-Ada code, delete the global archive,\n+\tthe archive dependency files, the object files and their dependency\n+\tfiles, if they exist.\n+\t(Gnatclean): Call Prj.Pars.Parse for All_Languages, not for Ada only.\n+\n+2004-06-25  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sinfo.ads: Fix typo in comment.\n+\n+\t* sem_dist.adb (Process_Remote_AST_Attribute): Simplify code that uses\n+\tthe TSS for remote access-to-subprogram types, since these TSS are\n+\talways present once the type has been analyzed.\n+\t(RAS_E_Dereference): Same.\n+\n+\t* sem_attr.adb (Analyze_Attribute): When analysis of an attribute\n+\treference raises Bad_Attribute, mark the reference as analyzed so the\n+\tnode (and any children resulting from rewrites that could have occurred\n+\tduring the analysis that ultimately failed) is not analyzed again.\n+\n+\t* exp_ch7.ads (Find_Final_List): Fix misaligned comment.\n+\n+\t* exp_dist.adb: Minor comment fix.\n+\n+\t* exp_ch4.adb (Expand_N_Allocator): For an allocator whose expected\n+\ttype is an anonymous access type, no unchecked deallocation of the\n+\tallocated object can occur. If the object is controlled, attach it with\n+\ta count of 1. This allows attachment to the Global_Final_List, if\n+\tno other relevant list is available.\n+\t(Get_Allocator_Final_List): For an anonymous access type that is\n+\tthe type of a discriminant or record component, the corresponding\n+\tfinalisation list is the one of the scope of the type.\n+\n+2004-06-25  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb (Replace_Type): When computing the signature of an\n+\tinherited subprogram, use the first subtype if the derived type\n+\tdeclaration has no constraint.\n+\n+\t* exp_ch6.adb (Add_Call_By_Copy_Code): Check that formal is an array\n+\tbefore applying previous optimization. Minor code cleanup.\n+\n+\t* exp_util.adb (Is_Possibly_Unaligned_Slice): If the component is\n+\tplaced at the beginning of an unpacked record without explicit\n+\talignment, a slice of it will be aligned and does not need a copy when\n+\tused as an actual.\n+\n+2004-06-25  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15591\n+\tPR ada/15592\n+\t* sem_ch8.adb (Attribute_Renaming): Reject renaming if the attribute\n+\treference is written with expressions mimicking parameters.\n+\n+2004-06-25  Hristian Kirtchev  <kirtchev@gnat.com>\n+\n+\tPR ada/15589\n+\t* sem_ch3.adb (Build_Derived_Record_Type): Add additional check to\n+\tSTEP 2a. The constraints of a full type declaration of a derived record\n+\ttype are checked for conformance with those declared in the\n+\tcorresponding private extension declaration. The message\n+\t\"not conformant with previous declaration\" is emitted if an error is\n+\tdetected.\n+\n+2004-06-25  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* g-traceb.ads: Document the need for -E binder switch in the spec.\n+\n+\t* g-trasym.ads: Document the need for -E binder switch in the spec.\n+\n+2004-06-25  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* sem_prag.adb: Add handling of pragma Detect_Blocking.\n+\n+\t* snames.h, snames.ads, snames.adb: Add entry for pragma\n+\tDetect_Blocking.\n+\n+\t* s-rident.ads: Change reference to pragma Detect_Blocking.\n+\n+\t* targparm.ads, targparm.adb: Allow pragma Detect_Blocking in\n+\tsystem.ads.\n+\n+\t* opt.ads (Detect_Blocking): New Boolean variable (defaulted to False)\n+\tto indicate whether pragma Detect_Blocking is active.\n+\n+\t* par-prag.adb: Add entry for pragma Detect_Blocking.\n+\n+\t* rtsfind.adb (RTU_Loaded): Fix the temporary kludge to get past bug\n+\tof not handling WITH.\n+\tNote that this replaces the previous update which was incorrect.\n+\n+2004-06-25  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sem_ch10.adb (Re_Install_Use_Clauses): Force the installation of the\n+\tuse-clauses to have a clean environment.\n+\n+\t* sem_ch8.adb (Install_Use_Clauses): Addition of a new formal to force\n+\tthe installation of the use-clauses to stablish a clean environment in\n+\tcase of compilation of a separate unit; otherwise the call to\n+\tuse_one_package is protected by the barrier Applicable_Use.\n+\n+\t* sem_ch8.ads (Install_Use_Clauses): Addition of a new formal to force\n+\tthe installation of the use-clauses to stablish a clean environment in\n+\tcase of compilation of a separate unit.\n+\t(End_Use_Clauses): Minor comment cleanup.\n+\n+2004-06-25  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Add description of the gnatpp 'files' switch\n+\n 2004-06-23  Richard Henderson  <rth@redhat.com>\n \n \t* trans.c (gnat_gimplify_stmt): Update gimplify_type_sizes call."}, {"sha": "a758e523c7ced4e902ca09b3bc0afc04584a3f98", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -374,13 +374,13 @@ else\n link: $(LINKER) archive-objects force\n \t@$(display) $(GNATMAKE) $(EXEC_RULE) -B -P$(PROJECT_FILE) $(ADA_SOURCES)\n \t@$(GNATMAKE) $(EXEC_RULE) -B -P$(PROJECT_FILE) $(ADA_SOURCES) \\\n-\t\t -largs $(MAIN_OBJECT) $(LARGS) $(LDFLAGS) $(FLDFLAGS)\n+\t\t -largs $(OBJ_DIR)/$(MAIN_OBJECT) $(LARGS) $(LDFLAGS) $(FLDFLAGS)\n \n internal-build: $(LINKER) archive-objects force\n-\t@$(display) $(GNATMAKE) -B -P$(PROJECT_FILE) $(ADA_SOURCES) $(EXEC_RULE) $(ADAFLAGS)\n+\t@$(display) $(GNATMAKE) $(EXEC_RULE) -B -P$(PROJECT_FILE) $(ADA_SOURCES) $(ADAFLAGS)\n \t@$(GNATMAKE) $(EXEC_RULE) \\\n \t\t -B -P$(PROJECT_FILE) $(ADA_SOURCES) $(ADAFLAGS) \\\n-\t\t -largs $(MAIN_OBJECT) $(LARGS) $(LDFLAGS) $(FLDFLAGS)\n+\t\t -largs $(OBJ_DIR)/$(MAIN_OBJECT) $(LARGS) $(LDFLAGS) $(FLDFLAGS)\n endif\n \n else"}, {"sha": "84d12a62ba9afd094327353a5b27e4b0d361f871", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1204,8 +1204,8 @@ endif\n   $(LIBGNAT_TARGET_PAIRS_AUX2)\n \n ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n-  TOOLS_TARGET_PAIRS= \\ \n-  mlib-tgt.adb<mlib-tgt-vms-ia64.adb \\ \n+  TOOLS_TARGET_PAIRS= \\\n+  mlib-tgt.adb<mlib-tgt-vms-ia64.adb \\\n   symbols.adb<symbols-vms-ia64.adb\n else\n   TOOLS_TARGET_PAIRS= \\\n@@ -1246,6 +1246,7 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   s-osprim.adb<s-osprim-mingw.adb \\\n   s-taprop.adb<s-taprop-mingw.adb \\\n   s-taspri.ads<s-taspri-mingw.ads \\\n+  s-parame.adb<s-parame-mingw.adb \\\n   g-socthi.ads<g-socthi-mingw.ads \\\n   g-socthi.adb<g-socthi-mingw.adb \\\n   g-soccon.ads<g-soccon-mingw.ads \\"}, {"sha": "41fb21d7f3c84fcf39af19591b310e6799ae7dcc", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -106,61 +106,68 @@ package body Exception_Propagation is\n \n    type Unwind_Word is mod 2 ** System.Word_Size;\n    for Unwind_Word'Size use System.Word_Size;\n-   --  Map the corresponding C type used in Unwind_Exception below.\n+   --  Map the corresponding C type used in Unwind_Exception below\n \n    type Unwind_Exception is record\n       Class    : Exception_Class := GNAT_Exception_Class;\n       Cleanup  : System.Address  := System.Null_Address;\n       Private1 : Unwind_Word;\n       Private2 : Unwind_Word;\n    end record;\n-   --  Map the GCC struct used for exception handling.\n+   --  Map the GCC struct used for exception handling\n \n    for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n    --  The C++ ABI mandates the common exception header to be at least\n    --  doubleword aligned, and the libGCC implementation actually makes it\n-   --  maximally aligned (see unwind.h). We need to match this because:\n-\n-   --  1/ We pass pointers to such headers down to the underlying\n-   --     libGCC unwinder,\n-\n-   --    and\n-\n-   --  2/ The GNAT_GCC_Exception record below starts with this common\n-   --     common header and has a C counterpart which needs to be laid\n-   --     out identically in raise.c. If the alignment of the C and Ada\n-   --     common headers mismatch, their size may also differ, and the\n-   --     layouts may not match anymore.\n+   --  maximally aligned (see unwind.h). See additional comments on the\n+   --  alignment below.\n \n    ---------------------------------------------------------------\n    --  GNAT specific entities to deal with the GCC eh circuitry --\n    ---------------------------------------------------------------\n \n    --  A GNAT exception object to be dealt with by the personality routine\n-   --  called by the GCC unwinding runtime. This structure shall match the\n-   --  one in raise.c and is currently experimental as it might be merged\n-   --  with the GNAT runtime definition some day.\n+   --  called by the GCC unwinding runtime.\n \n    type GNAT_GCC_Exception is record\n       Header : Unwind_Exception;\n       --  ABI Exception header first.\n \n       Id : Exception_Id;\n-      --  GNAT Exception identifier. This is used by the personality\n-      --  routine to determine if the context it examines contains a\n-      --  handler for the exception beeing propagated.\n+      --  GNAT Exception identifier.  This is filled by Propagate_Exception\n+      --  and then used by the personality routine to determine if the context\n+      --  it examines contains a handler for the exception beeing propagated.\n \n       N_Cleanups_To_Trigger : Integer;\n-      --  Number of cleanup only frames encountered in SEARCH phase.\n-      --  This is used to control the forced unwinding triggered when\n-      --  no handler has been found.\n+      --  Number of cleanup only frames encountered in SEARCH phase.  This is\n+      --  initialized to 0 by Propagate_Exception and maintained by the\n+      --  personality routine to control a forced unwinding phase triggering\n+      --  all the cleanups before calling Unhandled_Exception_Terminate when\n+      --  an exception is not handled.\n \n       Next_Exception : EOA;\n       --  Used to create a linked list of exception occurrences.\n    end record;\n \n    pragma Convention (C, GNAT_GCC_Exception);\n \n+   --  There is a subtle issue with the common header alignment, since the C\n+   --  version is aligned on BIGGEST_ALIGNMENT, the Ada version is aligned on\n+   --  Standard'Maximum_Alignment, and those two values don't quite represent\n+   --  the same concepts and so may be decoupled someday. One typical reason\n+   --  is that BIGGEST_ALIGNMENT may be larger than what the underlying system\n+   --  allocator guarantees, and there are extra costs involved in allocating\n+   --  objects aligned to such factors.\n+\n+   --  To deal with the potential alignment differences between the C and Ada\n+   --  representations, the Ada part of the whole structure is only accessed\n+   --  by the personality routine through the accessors declared below.  Ada\n+   --  specific fields are thus always accessed through consistent layout, and\n+   --  we expect the actual alignment to always be large enough to avoid traps\n+   --  from the C accesses to the common header. Besides, accessors aleviate\n+   --  the need for a C struct whole conterpart, both painful and errorprone\n+   --  to maintain anyway.\n+\n    type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n \n    function To_GNAT_GCC_Exception is new\n@@ -251,6 +258,15 @@ package body Exception_Propagation is\n    function Import_Code_For (E : Exception_Data_Ptr) return Exception_Code;\n    pragma Export (C, Import_Code_For, \"__gnat_import_code_for\");\n \n+   function EID_For (GNAT_Exception : GNAT_GCC_Exception_Access)\n+     return Exception_Id;\n+   pragma Export (C, EID_For, \"__gnat_eid_for\");\n+\n+   procedure Adjust_N_Cleanups_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access;\n+      Adjustment     : Integer);\n+   pragma Export (C, Adjust_N_Cleanups_For, \"__gnat_adjust_n_cleanups_for\");\n+\n    ------------\n    -- Remove --\n    ------------\n@@ -457,6 +473,7 @@ package body Exception_Propagation is\n       --  already been performed by Propagate_Exception. This hook remains for\n       --  potential future necessity in optimizing the overall scheme, as well\n       --  a useful debugging tool.\n+\n       null;\n    end Begin_Handler;\n \n@@ -466,7 +483,6 @@ package body Exception_Propagation is\n \n    procedure End_Handler (GCC_Exception : GNAT_GCC_Exception_Access) is\n       Removed : Boolean;\n-\n    begin\n       Removed := Remove (Get_Current_Excep.all, GCC_Exception);\n       pragma Assert (Removed);\n@@ -553,6 +569,30 @@ package body Exception_Propagation is\n       Unhandled_Exception_Terminate;\n    end Propagate_Exception;\n \n+   ---------------------------\n+   -- Adjust_N_Cleanups_For --\n+   ---------------------------\n+\n+   procedure Adjust_N_Cleanups_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access;\n+      Adjustment     : Integer)\n+   is\n+   begin\n+      GNAT_Exception.N_Cleanups_To_Trigger :=\n+        GNAT_Exception.N_Cleanups_To_Trigger + Adjustment;\n+   end Adjust_N_Cleanups_For;\n+\n+   -------------\n+   -- EID_For --\n+   -------------\n+\n+   function EID_For\n+     (GNAT_Exception : GNAT_GCC_Exception_Access) return Exception_Id\n+   is\n+   begin\n+      return GNAT_Exception.Id;\n+   end EID_For;\n+\n    ---------------------\n    -- Import_Code_For --\n    ---------------------\n@@ -612,29 +652,29 @@ package body Exception_Propagation is\n    --  An attempt was made to use the Private_Data pointer for this purpose.\n    --  It did not work because:\n \n-   --  1/ The Private_Data has to be saved by Save_Occurrence to be usable\n+   --  1) The Private_Data has to be saved by Save_Occurrence to be usable\n    --     as a key in case of a later reraise,\n \n-   --  2/ There is no easy way to synchronize End_Handler for an occurrence\n+   --  2) There is no easy way to synchronize End_Handler for an occurrence\n    --     and the data attached to potential copies, so these copies may end\n    --     up pointing to stale data. Moreover ...\n \n-   --  3/ The same address may be reused for different occurrences, which\n+   --  3) The same address may be reused for different occurrences, which\n    --     defeats the idea of using it as a key.\n \n    --  The example below illustrates:\n \n    --  Saved_CE : Exception_Occurrence;\n-   --\n+\n    --  begin\n    --    raise Constraint_Error;\n    --  exception\n    --    when CE: others =>\n    --      Save_Occurrence (Saved_CE, CE);      <= Saved_CE.PDA = CE.PDA\n    --  end;\n-   --\n+\n    --                                           <= Saved_CE.PDA is stale (!)\n-   --\n+\n    --  begin\n    --    raise Program_Error;                   <= Saved_CE.PDA = PE.PDA (!!)\n    --  exception"}, {"sha": "cddf9a8217c8fdf86aa84cf321b2c43d1e6fe3a8", "filename": "gcc/ada/a-ngelfu.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-ngelfu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-ngelfu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngelfu.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -992,16 +992,16 @@ package body Ada.Numerics.Generic_Elementary_Functions is\n    ----------\n \n    function Tanh (X : Float_Type'Base) return Float_Type'Base is\n-      P0 : constant Float_Type'Base := -0.16134_11902E4;\n-      P1 : constant Float_Type'Base := -0.99225_92967E2;\n-      P2 : constant Float_Type'Base := -0.96437_49299E0;\n+      P0 : constant Float_Type'Base := -0.16134_11902_39962_28053E+4;\n+      P1 : constant Float_Type'Base := -0.99225_92967_22360_83313E+2;\n+      P2 : constant Float_Type'Base := -0.96437_49277_72254_69787E+0;\n \n-      Q0 : constant Float_Type'Base :=  0.48402_35707E4;\n-      Q1 : constant Float_Type'Base :=  0.22337_72071E4;\n-      Q2 : constant Float_Type'Base :=  0.11274_47438E3;\n-      Q3 : constant Float_Type'Base :=  0.10000000000E1;\n+      Q0 : constant Float_Type'Base :=  0.48402_35707_19886_88686E+4;\n+      Q1 : constant Float_Type'Base :=  0.22337_72071_89623_12926E+4;\n+      Q2 : constant Float_Type'Base :=  0.11274_47438_05349_49335E+3;\n+      Q3 : constant Float_Type'Base :=  0.10000_00000_00000_00000E+1;\n \n-      Half_Ln3 : constant Float_Type'Base := 0.54930_61443;\n+      Half_Ln3 : constant Float_Type'Base := 0.54930_61443_34054_84570;\n \n       P, Q, R : Float_Type'Base;\n       Y : constant Float_Type'Base := abs X;"}, {"sha": "3a08392256f571f74d620caa99312c434828d1f1", "filename": "gcc/ada/a-storio.adb", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-storio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-storio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-storio.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---        Copyright (C) 1992,1993,1994 Free Software Foundation, Inc.       --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,32 +31,31 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Address_To_Access_Conversions;\n+with Unchecked_Conversion;\n \n package body Ada.Storage_IO is\n \n-   package Element_Ops is new\n-     System.Address_To_Access_Conversions (Element_Type);\n+   type Buffer_Ptr is access all Buffer_Type;\n+   type Elmt_Ptr   is access all Element_Type;\n+\n+   function To_Buffer_Ptr is new Unchecked_Conversion (Elmt_Ptr, Buffer_Ptr);\n \n    ----------\n    -- Read --\n    ----------\n \n-   procedure Read (Buffer : in  Buffer_Type; Item : out Element_Type) is\n+   procedure Read (Buffer : Buffer_Type; Item : out Element_Type) is\n    begin\n-      Element_Ops.To_Pointer (Item'Address).all :=\n-        Element_Ops.To_Pointer (Buffer'Address).all;\n+      To_Buffer_Ptr (Item'Unrestricted_Access).all := Buffer;\n    end Read;\n \n-\n    -----------\n    -- Write --\n    -----------\n \n-   procedure Write (Buffer : out Buffer_Type; Item : in  Element_Type) is\n+   procedure Write (Buffer : out Buffer_Type; Item : Element_Type) is\n    begin\n-      Element_Ops.To_Pointer (Buffer'Address).all :=\n-        Element_Ops.To_Pointer (Item'Address).all;\n+      Buffer := To_Buffer_Ptr (Item'Unrestricted_Access).all;\n    end Write;\n \n end Ada.Storage_IO;"}, {"sha": "41cedea3b34721dd4d3a68425c1971f5f888f568", "filename": "gcc/ada/a-strmap.ads", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-strmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fa-strmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strmap.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -40,8 +40,6 @@ with Ada.Characters.Latin_1;\n package Ada.Strings.Maps is\n pragma Preelaborate (Maps);\n \n-   package L renames Ada.Characters.Latin_1;\n-\n    --------------------------------\n    -- Character Set Declarations --\n    --------------------------------\n@@ -139,10 +137,6 @@ pragma Preelaborate (Maps);\n    type Character_Mapping_Function is\n       access function (From : in Character) return Character;\n \n-   ------------------\n-   -- Private Part --\n-   ------------------\n-\n private\n    pragma Inline (Is_In);\n    pragma Inline (Value);\n@@ -161,6 +155,8 @@ private\n \n    type Character_Mapping is array (Character) of Character;\n \n+   package L renames Ada.Characters.Latin_1;\n+\n    Identity : constant Character_Mapping :=\n      (L.NUL                         &  -- NUL                             0\n       L.SOH                         &  -- SOH                             1"}, {"sha": "bf6454ea8b376ce75ee70b70a6f20d2d5f02ff55", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -2444,7 +2444,8 @@ _flush_cache()\n       && ! defined (hpux) \\\n       && ! defined (_AIX) \\\n       && ! (defined (__alpha__)  && defined (__osf__)) \\\n-      && ! defined (__MINGW32__))\n+      && ! defined (__MINGW32__) \\\n+      && ! (defined (__mips) && defined (__sgi)))\n \n /* Dummy function to satisfy g-trasym.o.  Currently Solaris sparc, HP/UX,\n    GNU/Linux x86, Tru64 & Windows provide a non-dummy version of this"}, {"sha": "b9c4004df6bb641f90870123b9c0045e470af4f1", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 145, "deletions": 88, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -695,6 +695,17 @@ package body Checks is\n    --  and perhaps this is not quite the right value, but it is good\n    --  enough to catch the normal cases (and the relevant ACVC tests!)\n \n+   --  The situation is as follows. In GNAT 3 (GCC 2.x), the size in bits\n+   --  is computed in 32 bits without an overflow check. That's a real\n+   --  problem for Ada. So what we do in GNAT 3 is to approximate the\n+   --  size of an array by manually multiplying the element size by the\n+   --  number of elements, and comparing that against the allowed limits.\n+\n+   --  In GNAT 5, the size in byte is still computed in 32 bits without\n+   --  an overflow check in the dynamic case, but the size in bits is\n+   --  computed in 64 bits. We assume that's good enough, so we use the\n+   --  size in bits for the test.\n+\n    procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Ctyp : constant Entity_Id  := Component_Type (Typ);\n@@ -774,13 +785,19 @@ package body Checks is\n    --  Start of processing for Apply_Array_Size_Check\n \n    begin\n-      if not Expander_Active\n-        or else Storage_Checks_Suppressed (Typ)\n-      then\n+      --  No need for a check if not expanding\n+\n+      if not Expander_Active then\n          return;\n       end if;\n \n-      --  It is pointless to insert this check inside an  init proc, because\n+      --  No need for a check if checks are suppressed\n+\n+      if Storage_Checks_Suppressed (Typ) then\n+         return;\n+      end if;\n+\n+      --  It is pointless to insert this check inside an init proc, because\n       --  that's too late, we have already built the object to be the right\n       --  size, and if it's too large, too bad!\n \n@@ -803,124 +820,164 @@ package body Checks is\n          end if;\n       end loop;\n \n-      --  First step is to calculate the maximum number of elements. For this\n-      --  calculation, we use the actual size of the subtype if it is static,\n-      --  and if a bound of a subtype is non-static, we go to the bound of the\n-      --  base type.\n+      --  GCC 3 case\n \n-      Siz := Uint_1;\n-      Indx := First_Index (Typ);\n-      while Present (Indx) loop\n-         Xtyp := Etype (Indx);\n-         Lo := Type_Low_Bound (Xtyp);\n-         Hi := Type_High_Bound (Xtyp);\n+      if Opt.GCC_Version = 3 then\n \n-         --  If any bound raises constraint error, we will never get this\n-         --  far, so there is no need to generate any kind of check.\n+         --  No problem if size is known at compile time (even if the front\n+         --  end does not know it) because the back end does do overflow\n+         --  checking on the size in bytes if it is compile time known.\n \n-         if Raises_Constraint_Error (Lo)\n-              or else\n-            Raises_Constraint_Error (Hi)\n-         then\n-            Uintp.Release (Umark);\n+         if Size_Known_At_Compile_Time (Typ) then\n             return;\n          end if;\n \n-         --  Otherwise get bounds values\n+         --  No problem on 64-bit machines, we just don't bother with\n+         --  the case where the size in bytes overflows 64-bits.\n \n-         if Is_Static_Expression (Lo) then\n-            Lob := Expr_Value (Lo);\n-         else\n-            Lob := Expr_Value (Type_Low_Bound (Base_Type (Xtyp)));\n-            Static := False;\n+         if System_Address_Size = 64 then\n+            return;\n          end if;\n+      end if;\n \n-         if Is_Static_Expression (Hi) then\n-            Hib := Expr_Value (Hi);\n-         else\n-            Hib := Expr_Value (Type_High_Bound (Base_Type (Xtyp)));\n-            Static := False;\n-         end if;\n+      --  Following code is temporarily deleted, since GCC 3 is returning\n+      --  zero for size in bits of large dynamic arrays. ???\n \n-         Siz := Siz *  UI_Max (Hib - Lob + 1, Uint_0);\n-         Next_Index (Indx);\n-      end loop;\n+--           --  Otherwise we check for the size in bits exceeding 2**31-1 * 8.\n+--           --  This is the case in which we could end up with problems from\n+--           --  an unnoticed overflow in computing the size in bytes\n+--\n+--           Check_Siz := (Uint_2 ** 31 - Uint_1) * Uint_8;\n+--\n+--           Sizx :=\n+--             Make_Attribute_Reference (Loc,\n+--               Prefix => New_Occurrence_Of (Typ, Loc),\n+--               Attribute_Name => Name_Size);\n \n-      --  Compute the limit against which we want to check. For subprograms,\n-      --  where the array will go on the stack, we use 8*2**24, which (in\n-      --  bits) is the size of a 16 megabyte array.\n+      --  GCC 2 case (for now this is for GCC 3 dynamic case as well)\n \n-      if Is_Subprogram (Scope (Ent)) then\n-         Check_Siz := Uint_2 ** 27;\n-      else\n-         Check_Siz := Uint_2 ** 31;\n-      end if;\n+      begin\n+         --  First step is to calculate the maximum number of elements. For\n+         --  this calculation, we use the actual size of the subtype if it is\n+         --  static, and if a bound of a subtype is non-static, we go to the\n+         --  bound of the base type.\n+\n+         Siz := Uint_1;\n+         Indx := First_Index (Typ);\n+         while Present (Indx) loop\n+            Xtyp := Etype (Indx);\n+            Lo := Type_Low_Bound (Xtyp);\n+            Hi := Type_High_Bound (Xtyp);\n+\n+            --  If any bound raises constraint error, we will never get this\n+            --  far, so there is no need to generate any kind of check.\n+\n+            if Raises_Constraint_Error (Lo)\n+              or else\n+                Raises_Constraint_Error (Hi)\n+            then\n+               Uintp.Release (Umark);\n+               return;\n+            end if;\n \n-      --  If we have all static bounds and Siz is too large, then we know we\n-      --  know we have a storage error right now, so generate message\n+            --  Otherwise get bounds values\n \n-      if Static and then Siz >= Check_Siz then\n-         Insert_Action (N,\n-           Make_Raise_Storage_Error (Loc,\n-             Reason => SE_Object_Too_Large));\n-         Error_Msg_N (\"?Storage_Error will be raised at run-time\", N);\n-         Uintp.Release (Umark);\n-         return;\n-      end if;\n+            if Is_Static_Expression (Lo) then\n+               Lob := Expr_Value (Lo);\n+            else\n+               Lob := Expr_Value (Type_Low_Bound (Base_Type (Xtyp)));\n+               Static := False;\n+            end if;\n \n-      --  Case of component size known at compile time. If the array\n-      --  size is definitely in range, then we do not need a check.\n+            if Is_Static_Expression (Hi) then\n+               Hib := Expr_Value (Hi);\n+            else\n+               Hib := Expr_Value (Type_High_Bound (Base_Type (Xtyp)));\n+               Static := False;\n+            end if;\n \n-      if Known_Esize (Ctyp)\n-        and then Siz * Esize (Ctyp) < Check_Siz\n-      then\n-         Uintp.Release (Umark);\n-         return;\n-      end if;\n+            Siz := Siz *  UI_Max (Hib - Lob + 1, Uint_0);\n+            Next_Index (Indx);\n+         end loop;\n \n-      --  Here if a dynamic check is required\n+         --  Compute the limit against which we want to check. For subprograms,\n+         --  where the array will go on the stack, we use 8*2**24, which (in\n+         --  bits) is the size of a 16 megabyte array.\n \n-      --  What we do is to build an expression for the size of the array,\n-      --  which is computed as the 'Size of the array component, times\n-      --  the size of each dimension.\n+         if Is_Subprogram (Scope (Ent)) then\n+            Check_Siz := Uint_2 ** 27;\n+         else\n+            Check_Siz := Uint_2 ** 31;\n+         end if;\n \n-      Uintp.Release (Umark);\n+         --  If we have all static bounds and Siz is too large, then we know\n+         --  we know we have a storage error right now, so generate message\n \n-      Sizx :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Ctyp, Loc),\n-          Attribute_Name => Name_Size);\n+         if Static and then Siz >= Check_Siz then\n+            Insert_Action (N,\n+              Make_Raise_Storage_Error (Loc,\n+                 Reason => SE_Object_Too_Large));\n+            Error_Msg_N (\"?Storage_Error will be raised at run-time\", N);\n+            Uintp.Release (Umark);\n+            return;\n+         end if;\n \n-      Indx := First_Index (Typ);\n+         --  Case of component size known at compile time. If the array\n+         --  size is definitely in range, then we do not need a check.\n \n-      for J in 1 .. Number_Dimensions (Typ) loop\n-         if Sloc (Etype (Indx)) = Sloc (N) then\n-            Ensure_Defined (Etype (Indx), N);\n+         if Known_Esize (Ctyp)\n+           and then Siz * Esize (Ctyp) < Check_Siz\n+         then\n+            Uintp.Release (Umark);\n+            return;\n          end if;\n \n+         --  Here if a dynamic check is required\n+\n+         --  What we do is to build an expression for the size of the array,\n+         --  which is computed as the 'Size of the array component, times\n+         --  the size of each dimension.\n+\n+         Uintp.Release (Umark);\n+\n          Sizx :=\n-           Make_Op_Multiply (Loc,\n-             Left_Opnd  => Sizx,\n-             Right_Opnd =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix => New_Occurrence_Of (Typ, Loc),\n-                 Attribute_Name => Name_Length,\n-                 Expressions => New_List (\n-                   Make_Integer_Literal (Loc, J))));\n-         Next_Index (Indx);\n-      end loop;\n+           Make_Attribute_Reference (Loc,\n+             Prefix =>         New_Occurrence_Of (Ctyp, Loc),\n+             Attribute_Name => Name_Size);\n+\n+         Indx := First_Index (Typ);\n+         for J in 1 .. Number_Dimensions (Typ) loop\n+            if Sloc (Etype (Indx)) = Sloc (N) then\n+               Ensure_Defined (Etype (Indx), N);\n+            end if;\n+\n+            Sizx :=\n+              Make_Op_Multiply (Loc,\n+                Left_Opnd  => Sizx,\n+                Right_Opnd =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Occurrence_Of (Typ, Loc),\n+                    Attribute_Name => Name_Length,\n+                    Expressions    => New_List (\n+                                        Make_Integer_Literal (Loc, J))));\n+            Next_Index (Indx);\n+         end loop;\n+      end;\n+\n+      --  Common code to actually emit the check\n \n       Code :=\n         Make_Raise_Storage_Error (Loc,\n           Condition =>\n             Make_Op_Ge (Loc,\n               Left_Opnd  => Sizx,\n               Right_Opnd =>\n-                Make_Integer_Literal (Loc, Check_Siz)),\n-            Reason => SE_Object_Too_Large);\n+                Make_Integer_Literal (Loc,\n+                  Intval    => Check_Siz)),\n+                  Reason    => SE_Object_Too_Large);\n \n       Set_Size_Check_Code (Defining_Identifier (N), Code);\n-      Insert_Action (N, Code);\n+      Insert_Action (N, Code, Suppress => All_Checks);\n    end Apply_Array_Size_Check;\n \n    ----------------------------"}, {"sha": "4a3895044a3d0567c85bef6eeca9474d49136d4b", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 226, "deletions": 126, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -31,6 +31,7 @@ with Csets;\n with Gnatvsn;\n with Hostparm;\n with Makeutl;  use Makeutl;\n+with MLib.Tgt; use MLib.Tgt;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -182,6 +183,10 @@ package body Clean is\n    function Assembly_File_Name (Source : Name_Id) return String;\n    --  Returns the assembly file name corresponding to Source\n \n+   procedure Clean_Archive (Project : Project_Id);\n+   --  Delete a global archive or a fake library project archive and the\n+   --  dependency file, if they exist.\n+\n    procedure Clean_Directory (Dir : Name_Id);\n    --  Delete all regular files in a library directory or in a library\n    --  interface dir.\n@@ -314,6 +319,39 @@ package body Clean is\n       return Src & Assembly_Suffix;\n    end Assembly_File_Name;\n \n+   -------------------\n+   -- Clean_Archive --\n+   -------------------\n+\n+   procedure Clean_Archive (Project : Project_Id) is\n+      Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n+\n+      Data        : constant Project_Data := Projects.Table (Project);\n+\n+      Archive_Name : constant String :=\n+        \"lib\" & Get_Name_String (Data.Name) & '.' & Archive_Ext;\n+      --  The name of the archive file for this project\n+\n+      Archive_Dep_Name : constant String :=\n+        \"lib\" & Get_Name_String (Data.Name) & \".deps\";\n+      --  The name of the archive dependency file for this project\n+\n+      Obj_Dir : constant String := Get_Name_String (Data.Object_Directory);\n+\n+   begin\n+      Change_Dir (Obj_Dir);\n+\n+      if Is_Regular_File (Archive_Name) then\n+         Delete (Obj_Dir, Archive_Name);\n+      end if;\n+\n+      if Is_Regular_File (Archive_Dep_Name) then\n+         Delete (Obj_Dir, Archive_Dep_Name);\n+      end if;\n+\n+      Change_Dir (Current_Dir);\n+   end Clean_Archive;\n+\n    ---------------------\n    -- Clean_Directory --\n    ---------------------\n@@ -534,6 +572,11 @@ package body Clean is\n       Index2      : Int;\n       Lib_File    : File_Name_Type;\n \n+      Source_Id   : Other_Source_Id;\n+      Source      : Other_Source;\n+\n+      Global_Archive : Boolean := False;\n+\n       use Prj.Com;\n \n    begin\n@@ -567,141 +610,221 @@ package body Clean is\n          begin\n             Change_Dir (Obj_Dir);\n \n+            --  First, deal with Ada.\n             --  Look through the units to find those that are either immediate\n             --  sources or inherited sources of the project.\n \n-            for Unit in 1 .. Prj.Com.Units.Last loop\n-               U_Data := Prj.Com.Units.Table (Unit);\n-               File_Name1 := No_Name;\n-               File_Name2 := No_Name;\n-\n-               --  If either the spec or the body is a source of the project,\n-               --  check for the corresponding ALI file in the object\n-               --  directory.\n-\n-               if In_Extension_Chain\n-                 (U_Data.File_Names (Body_Part).Project, Project)\n-                 or else\n-                   In_Extension_Chain\n-                     (U_Data.File_Names (Specification).Project, Project)\n-               then\n-                  File_Name1 := U_Data.File_Names (Body_Part).Name;\n-                  Index1     := U_Data.File_Names (Body_Part).Index;\n-                  File_Name2 := U_Data.File_Names (Specification).Name;\n-                  Index2     := U_Data.File_Names (Specification).Index;\n-\n-                  --  If there is no body file name, then there may be only a\n-                  --  spec.\n-\n-                  if File_Name1 = No_Name then\n-                     File_Name1 := File_Name2;\n-                     Index1     := Index2;\n-                     File_Name2 := No_Name;\n-                     Index2     := 0;\n+            if Data.Languages (Lang_Ada) then\n+               for Unit in 1 .. Prj.Com.Units.Last loop\n+                  U_Data := Prj.Com.Units.Table (Unit);\n+                  File_Name1 := No_Name;\n+                  File_Name2 := No_Name;\n+\n+                  --  If either the spec or the body is a source of the\n+                  --  project, check for the corresponding ALI file in the\n+                  --  object directory.\n+\n+                  if In_Extension_Chain\n+                    (U_Data.File_Names (Body_Part).Project, Project)\n+                    or else\n+                      In_Extension_Chain\n+                        (U_Data.File_Names (Specification).Project, Project)\n+                  then\n+                     File_Name1 := U_Data.File_Names (Body_Part).Name;\n+                     Index1     := U_Data.File_Names (Body_Part).Index;\n+                     File_Name2 := U_Data.File_Names (Specification).Name;\n+                     Index2     := U_Data.File_Names (Specification).Index;\n+\n+                     --  If there is no body file name, then there may be only\n+                     --  a spec.\n+\n+                     if File_Name1 = No_Name then\n+                        File_Name1 := File_Name2;\n+                        Index1     := Index2;\n+                        File_Name2 := No_Name;\n+                        Index2     := 0;\n+                     end if;\n                   end if;\n-               end if;\n \n-               --  If there is either a spec or a body, look for files in the\n-               --  object directory.\n+                  --  If there is either a spec or a body, look for files\n+                  --  in the object directory.\n+\n+                  if File_Name1 /= No_Name then\n+                     Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n \n-               if File_Name1 /= No_Name then\n-                  Lib_File := Osint.Lib_File_Name (File_Name1, Index1);\n+                     declare\n+                        Asm : constant String := Assembly_File_Name (Lib_File);\n+                        ALI : constant String := ALI_File_Name      (Lib_File);\n+                        Obj : constant String := Object_File_Name   (Lib_File);\n+                        Adt : constant String := Tree_File_Name     (Lib_File);\n+                        Deb : constant String :=\n+                                Debug_File_Name (File_Name1);\n+                        Rep : constant String :=\n+                                Repinfo_File_Name (File_Name1);\n+                        Del : Boolean := True;\n \n-                  declare\n-                     Asm : constant String := Assembly_File_Name (Lib_File);\n-                     ALI : constant String := ALI_File_Name      (Lib_File);\n-                     Obj : constant String := Object_File_Name   (Lib_File);\n-                     Adt : constant String := Tree_File_Name     (Lib_File);\n-                     Deb : constant String := Debug_File_Name    (File_Name1);\n-                     Rep : constant String := Repinfo_File_Name  (File_Name1);\n-                     Del : Boolean := True;\n+                     begin\n+                        --  If the ALI file exists and is read-only, no file\n+                        --  is deleted.\n \n-                  begin\n-                     --  If the ALI file exists and is read-only, no file is\n-                     --  deleted.\n+                        if Is_Regular_File (ALI) then\n+                           if Is_Writable_File (ALI) then\n+                              Delete (Obj_Dir, ALI);\n \n-                     if Is_Regular_File (ALI) then\n-                        if Is_Writable_File (ALI) then\n-                           Delete (Obj_Dir, ALI);\n+                           else\n+                              Del := False;\n \n-                        else\n-                           Del := False;\n+                              if Verbose_Mode then\n+                                 Put ('\"');\n+                                 Put (Obj_Dir);\n \n-                           if Verbose_Mode then\n-                              Put ('\"');\n-                              Put (Obj_Dir);\n+                                 if Obj_Dir (Obj_Dir'Last) /=\n+                                      Dir_Separator\n+                                 then\n+                                    Put (Dir_Separator);\n+                                 end if;\n \n-                              if Obj_Dir (Obj_Dir'Last) /= Dir_Separator then\n-                                 Put (Dir_Separator);\n+                                 Put (ALI);\n+                                 Put_Line (\"\"\" is read-only\");\n                               end if;\n-\n-                              Put (ALI);\n-                              Put_Line (\"\"\" is read-only\");\n                            end if;\n                         end if;\n-                     end if;\n \n-                     if Del then\n+                        if Del then\n \n-                        --  Object file\n+                           --  Object file\n \n-                        if Is_Regular_File (Obj) then\n-                           Delete (Obj_Dir, Obj);\n-                        end if;\n+                           if Is_Regular_File (Obj) then\n+                              Delete (Obj_Dir, Obj);\n+                           end if;\n \n-                        --  Assembly file\n+                           --  Assembly file\n \n-                        if Is_Regular_File (Asm) then\n-                           Delete (Obj_Dir, Asm);\n-                        end if;\n+                           if Is_Regular_File (Asm) then\n+                              Delete (Obj_Dir, Asm);\n+                           end if;\n \n-                        --  Tree file\n+                           --  Tree file\n \n-                        if Is_Regular_File (Adt) then\n-                           Delete (Obj_Dir, Adt);\n-                        end if;\n+                           if Is_Regular_File (Adt) then\n+                              Delete (Obj_Dir, Adt);\n+                           end if;\n \n-                        --  First expanded source file\n+                           --  First expanded source file\n \n-                        if Is_Regular_File (Deb) then\n-                           Delete (Obj_Dir, Deb);\n-                        end if;\n+                           if Is_Regular_File (Deb) then\n+                              Delete (Obj_Dir, Deb);\n+                           end if;\n \n-                        --  Repinfo file\n+                           --  Repinfo file\n \n-                        if Is_Regular_File (Rep) then\n-                           Delete (Obj_Dir, Rep);\n+                           if Is_Regular_File (Rep) then\n+                              Delete (Obj_Dir, Rep);\n+                           end if;\n+\n+                           --  Second expanded source file\n+\n+                           if File_Name2 /= No_Name then\n+                              declare\n+                                 Deb : constant String :=\n+                                         Debug_File_Name   (File_Name2);\n+                                 Rep : constant String :=\n+                                         Repinfo_File_Name (File_Name2);\n+                              begin\n+                                 if Is_Regular_File (Deb) then\n+                                    Delete (Obj_Dir, Deb);\n+                                 end if;\n+\n+                                 if Is_Regular_File (Rep) then\n+                                    Delete (Obj_Dir, Rep);\n+                                 end if;\n+                              end;\n+                           end if;\n                         end if;\n+                     end;\n+                  end if;\n+               end loop;\n+            end if;\n \n-                        --  Second expanded source file\n+            --  Check if a global archive and it dependency file could have\n+            --  been created and, if they exist, delete them.\n \n-                        if File_Name2 /= No_Name then\n-                           declare\n-                              Deb : constant String :=\n-                                      Debug_File_Name   (File_Name2);\n-                              Rep : constant String :=\n-                                      Repinfo_File_Name (File_Name2);\n-                           begin\n-                              if Is_Regular_File (Deb) then\n-                                 Delete (Obj_Dir, Deb);\n-                              end if;\n+            if Project = Main_Project and then not Data.Library then\n+               Global_Archive := False;\n \n-                              if Is_Regular_File (Rep) then\n-                                 Delete (Obj_Dir, Rep);\n-                              end if;\n-                           end;\n-                        end if;\n-                     end if;\n-                  end;\n+               for Proj in 1 .. Projects.Last loop\n+                  if Projects.Table (Proj).Other_Sources_Present then\n+                     Global_Archive := True;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               if Global_Archive then\n+                  Clean_Archive (Project);\n                end if;\n-            end loop;\n+            end if;\n+\n+            if Data.Other_Sources_Present then\n+               --  There is non-Ada code: delete the object files and\n+               --  the dependency files, if they exist.\n \n-            if Verbose_Mode then\n-               New_Line;\n+               Source_Id := Data.First_Other_Source;\n+\n+               while Source_Id /= No_Other_Source loop\n+                  Source := Other_Sources.Table (Source_Id);\n+\n+                  if Is_Regular_File\n+                       (Get_Name_String (Source.Object_Name))\n+                  then\n+                     Delete (Obj_Dir, Get_Name_String (Source.Object_Name));\n+                  end if;\n+\n+                  if Is_Regular_File (Get_Name_String (Source.Dep_Name)) then\n+                     Delete (Obj_Dir, Get_Name_String (Source.Dep_Name));\n+                  end if;\n+\n+                  Source_Id := Source.Next;\n+               end loop;\n+\n+               --  If it is a library with only non Ada sources, delete\n+               --  the fake archive and the dependency file, if they exist.\n+\n+               if Data.Library and then not Data.Languages (Lang_Ada) then\n+                  Clean_Archive (Project);\n+               end if;\n             end if;\n          end;\n       end if;\n \n+      --  If this is a library project, clean the library directory, the\n+      --  interface copy dir and, for a Stand-Alone Library, the binder\n+      --  generated files of the library.\n+\n+      --  The directories are cleaned only if switch -c is not specified.\n+\n+      if Data.Library then\n+         if not Compile_Only then\n+            Clean_Directory (Data.Library_Dir);\n+\n+            if Data.Library_Src_Dir /= No_Name\n+              and then Data.Library_Src_Dir /= Data.Library_Dir\n+            then\n+               Clean_Directory (Data.Library_Src_Dir);\n+            end if;\n+         end if;\n+\n+         if Data.Standalone_Library and then\n+            Data.Object_Directory /= No_Name\n+         then\n+            Delete_Binder_Generated_Files\n+              (Get_Name_String (Data.Object_Directory), Data.Library_Name);\n+         end if;\n+      end if;\n+\n+      if Verbose_Mode then\n+         New_Line;\n+      end if;\n+\n       --  If switch -r is specified, call Clean_Project recursively for the\n       --  imported projects and the project being extended.\n \n@@ -745,36 +868,12 @@ package body Clean is\n          end;\n       end if;\n \n-      --  If this is a library project, clean the library directory, the\n-      --  interface copy dir and, for a Stand-Alone Library, the binder\n-      --  generated files of the library.\n-\n-      --  The directories are cleaned only if switch -c is not specified.\n-\n-      if Data.Library then\n-         if not Compile_Only then\n-            Clean_Directory (Data.Library_Dir);\n-\n-            if Data.Library_Src_Dir /= No_Name\n-              and then Data.Library_Src_Dir /= Data.Library_Dir\n-            then\n-               Clean_Directory (Data.Library_Src_Dir);\n-            end if;\n-         end if;\n-\n-         if Data.Standalone_Library and then\n-            Data.Object_Directory /= No_Name\n-         then\n-            Delete_Binder_Generated_Files\n-              (Get_Name_String (Data.Object_Directory), Data.Library_Name);\n-         end if;\n-\n-         --  Otherwise, for the main project, delete the executables and the\n+         --  For the main project, delete the executables and the\n          --  binder generated files.\n \n          --  The executables are deleted only if switch -c is not specified.\n \n-      elsif Project = Main_Project and then Data.Exec_Directory /= No_Name then\n+      if Project = Main_Project and then Data.Exec_Directory /= No_Name then\n          declare\n             Exec_Dir : constant String :=\n               Get_Name_String (Data.Exec_Directory);\n@@ -1000,7 +1099,8 @@ package body Clean is\n          Prj.Pars.Parse\n            (Project           => Main_Project,\n             Project_File_Name => Project_File_Name.all,\n-            Packages_To_Check => Packages_To_Check_By_Gnatmake);\n+            Packages_To_Check => Packages_To_Check_By_Gnatmake,\n+            Process_Languages => All_Languages);\n \n          if Main_Project = No_Project then\n             Fail (\"\"\"\" & Project_File_Name.all &"}, {"sha": "3782c75bccafd69330d6d8b8f0cbf948bb232221", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -243,7 +243,6 @@ package body CStand is\n \n       Set_Etype (First_Entity (Standard_Op_Concatw), Standard_Wide_String);\n       Set_Etype (Last_Entity  (Standard_Op_Concatw), Standard_Wide_String);\n-\n    end Create_Operators;\n \n    ---------------------\n@@ -584,6 +583,7 @@ package body CStand is\n       Set_Component_Type (Standard_String, Standard_Character);\n       Set_Component_Size (Standard_String, Uint_8);\n       Init_Size_Align    (Standard_String);\n+      Set_Alignment      (Standard_String, Uint_1);\n \n       --  Set index type of String\n "}, {"sha": "b45279f9ccebc4e4cfd72bf452824c7835b1801d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -419,10 +419,9 @@ package body Einfo is\n \n    --    Has_Contiguous_Rep             Flag181\n    --    Has_Xref_Entry                 Flag182\n+   --    Must_Be_On_Byte_Boundary       Flag183\n \n-   --  Remaining flags are currently unused and available\n-\n-   --    (unused)                       Flag183\n+   --   Note: there are no unused flags currently!\n \n    --------------------------------\n    -- Attribute Access Functions --\n@@ -1754,6 +1753,12 @@ package body Einfo is\n       return Uint17 (Base_Type (Id));\n    end Modulus;\n \n+   function Must_Be_On_Byte_Boundary (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag183 (Id);\n+   end Must_Be_On_Byte_Boundary;\n+\n    function Needs_Debug_Info (Id : E) return B is\n    begin\n       return Flag147 (Id);\n@@ -3712,6 +3717,12 @@ package body Einfo is\n       Set_Uint17 (Id, V);\n    end Set_Modulus;\n \n+   procedure Set_Must_Be_On_Byte_Boundary (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag183 (Id, V);\n+   end Set_Must_Be_On_Byte_Boundary;\n+\n    procedure Set_Needs_Debug_Info (Id : E; V : B := True) is\n    begin\n       Set_Flag147 (Id, V);\n@@ -6249,6 +6260,7 @@ package body Einfo is\n       W (\"Kill_Tag_Checks\",               Flag34  (Id));\n       W (\"Machine_Radix_10\",              Flag84  (Id));\n       W (\"Materialize_Entity\",            Flag168 (Id));\n+      W (\"Must_Be_On_Byte_Boundary\",      Flag183 (Id));\n       W (\"Needs_Debug_Info\",              Flag147 (Id));\n       W (\"Needs_No_Actuals\",              Flag22  (Id));\n       W (\"Never_Set_In_Source\",           Flag115 (Id));"}, {"sha": "ca5d69d7d40262045bbb724be21565f34adadc71", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -2443,6 +2443,14 @@ package Einfo is\n --       case, this will be a power of 2, but if Non_Binary_Modulus is\n --       set, then it will not be a power of 2.\n \n+--    Must_Be_On_Byte_Boundary (Flag183)\n+--       Present in entities for types and subtypes. Set if objects of\n+--       the type must always be allocated on a byte boundary (more\n+--       accurately a storage unit boundary). The front end checks that\n+--       component clauses respect this rule, and the back end ensures\n+--       that record packing does not violate this rule. Currently the\n+--       flag is set only for packed arrays longer than 64 bits.\n+\n --    Needs_Debug_Info (Flag147)\n --       Present in all entities. Set if the entity requires debugging\n --       information to be generated. This is true of all entities that\n@@ -3995,6 +4003,7 @@ package Einfo is\n    --    Is_Tagged_Type                (Flag55)\n    --    Is_Unsigned_Type              (Flag144)\n    --    Is_Volatile                   (Flag16)\n+   --    Must_Be_On_Byte_Boundary      (Flag183)\n    --    Size_Depends_On_Discriminant  (Flag177)\n    --    Size_Known_At_Compile_Time    (Flag92)\n    --    Strict_Alignment              (Flag145)  (base type only)\n@@ -5197,6 +5206,7 @@ package Einfo is\n    function Materialize_Entity                 (Id : E) return B;\n    function Mechanism                          (Id : E) return M;\n    function Modulus                            (Id : E) return U;\n+   function Must_Be_On_Byte_Boundary           (Id : E) return B;\n    function Needs_Debug_Info                   (Id : E) return B;\n    function Needs_No_Actuals                   (Id : E) return B;\n    function Never_Set_In_Source                (Id : E) return B;\n@@ -5671,6 +5681,7 @@ package Einfo is\n    procedure Set_Materialize_Entity            (Id : E; V : B := True);\n    procedure Set_Mechanism                     (Id : E; V : M);\n    procedure Set_Modulus                       (Id : E; V : U);\n+   procedure Set_Must_Be_On_Byte_Boundary      (Id : E; V : B := True);\n    procedure Set_Needs_Debug_Info              (Id : E; V : B := True);\n    procedure Set_Needs_No_Actuals              (Id : E; V : B := True);\n    procedure Set_Never_Set_In_Source           (Id : E; V : B := True);\n@@ -6197,6 +6208,7 @@ package Einfo is\n    pragma Inline (Materialize_Entity);\n    pragma Inline (Mechanism);\n    pragma Inline (Modulus);\n+   pragma Inline (Must_Be_On_Byte_Boundary);\n    pragma Inline (Needs_Debug_Info);\n    pragma Inline (Needs_No_Actuals);\n    pragma Inline (Never_Set_In_Source);\n@@ -6506,6 +6518,7 @@ package Einfo is\n    pragma Inline (Set_Materialize_Entity);\n    pragma Inline (Set_Mechanism);\n    pragma Inline (Set_Modulus);\n+   pragma Inline (Set_Must_Be_On_Byte_Boundary);\n    pragma Inline (Set_Needs_Debug_Info);\n    pragma Inline (Set_Needs_No_Actuals);\n    pragma Inline (Set_Never_Set_In_Source);"}, {"sha": "1eab6ef7c9e37b3a87ab533d4fa9cbec027883a4", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -4125,7 +4125,7 @@ package body Exp_Aggr is\n                raise Program_Error;\n             end if;\n \n-            --  Name in assignment is explicit dereference.\n+            --  Name in assignment is explicit dereference\n \n             Target := New_Copy (Tmp);\n          end if;"}, {"sha": "e0d5f7cb5857ebe04771698d3de37d81a4de70d6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 269, "deletions": 154, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -94,20 +94,21 @@ package body Exp_Ch4 is\n \n    function Expand_Array_Equality\n      (Nod    : Node_Id;\n-      Typ    : Entity_Id;\n-      A_Typ  : Entity_Id;\n       Lhs    : Node_Id;\n       Rhs    : Node_Id;\n-      Bodies : List_Id) return Node_Id;\n+      Bodies : List_Id;\n+      Typ    : Entity_Id) return Node_Id;\n    --  Expand an array equality into a call to a function implementing this\n    --  equality, and a call to it. Loc is the location for the generated\n-   --  nodes. Typ is the type of the array, and Lhs, Rhs are the array\n-   --  expressions to be compared. A_Typ is the type of the arguments,\n-   --  which may be a private type, in which case Typ is its full view.\n+   --  nodes. Lhs and Rhs are the array expressions to be compared.\n    --  Bodies is a list on which to attach bodies of local functions that\n-   --  are created in the process. This is the responsibility of the\n+   --  are created in the process. It is the responsibility of the\n    --  caller to insert those bodies at the right place. Nod provides\n-   --  the Sloc value for the generated code.\n+   --  the Sloc value for the generated code. Normally the types used\n+   --  for the generated equality routine are taken from Lhs and Rhs.\n+   --  However, in some situations of generated code, the Etype fields\n+   --  of Lhs and Rhs are not set yet. In such cases, Typ supplies the\n+   --  type to be used for the formal parameters.\n \n    procedure Expand_Boolean_Operator (N : Node_Id);\n    --  Common expansion processing for Boolean operators (And, Or, Xor)\n@@ -124,7 +125,8 @@ package body Exp_Ch4 is\n    --  is a list on which to attach bodies of local functions that are\n    --  created in the process. This is the responsability of the caller\n    --  to insert those bodies at the right place. Nod provides the Sloc\n-   --  value for generated code.\n+   --  value for generated code. Lhs and Rhs are the left and right sides\n+   --  for the comparison, and Typ is the type of the arrays to compare.\n \n    procedure Expand_Concatenate_Other (Cnode : Node_Id; Opnds : List_Id);\n    --  This routine handles expansion of concatenation operations, where\n@@ -570,7 +572,7 @@ package body Exp_Ch4 is\n         and then Nkind (Exp) = N_Allocator\n         and then Nkind (Expression (Exp)) /= N_Qualified_Expression\n       then\n-         --  Apply constraint to designated subtype indication.\n+         --  Apply constraint to designated subtype indication\n \n          Apply_Constraint_Check (Expression (Exp),\n            Designated_Type (Designated_Type (PtrT)),\n@@ -858,58 +860,57 @@ package body Exp_Ch4 is\n    --  Expand an equality function for multi-dimensional arrays. Here is\n    --  an example of such a function for Nb_Dimension = 2\n \n-   --  function Enn (A : arr; B : arr) return boolean is\n+   --  function Enn (A : atyp; B : btyp) return boolean is\n    --  begin\n    --     if (A'length (1) = 0 or else A'length (2) = 0)\n    --          and then\n    --        (B'length (1) = 0 or else B'length (2) = 0)\n    --     then\n    --        return True;    -- RM 4.5.2(22)\n    --     end if;\n-   --\n+\n    --     if A'length (1) /= B'length (1)\n    --               or else\n    --           A'length (2) /= B'length (2)\n    --     then\n    --        return False;   -- RM 4.5.2(23)\n    --     end if;\n-   --\n+\n    --     declare\n-   --        A1 : Index_type_1 := A'first (1)\n-   --        B1 : Index_Type_1 := B'first (1)\n+   --        B1 : Index_T1 := B'first (1)\n    --     begin\n-   --        loop\n+   --        for A1 in A'range (1) loop\n    --           declare\n-   --              A2 : Index_type_2 := A'first (2);\n-   --              B2 : Index_type_2 := B'first (2)\n+   --              B2 : Index_T2 := B'first (2)\n    --           begin\n-   --              loop\n+   --              for A2 in A'range (2) loop\n    --                 if A (A1, A2) /= B (B1, B2) then\n    --                    return False;\n    --                 end if;\n-   --\n-   --                 exit when A2 = A'last (2);\n-   --                 A2 := Index_type2'succ (A2);\n-   --                 B2 := Index_type2'succ (B2);\n+\n+   --                 B2 := Index_T2'succ (B2);\n    --              end loop;\n    --           end;\n-   --\n-   --           exit when A1 = A'last (1);\n-   --           A1 := Index_type1'succ (A1);\n-   --           B1 := Index_type1'succ (B1);\n+\n+   --           B1 := Index_T1'succ (B1);\n    --        end loop;\n    --     end;\n-   --\n+\n    --     return true;\n    --  end Enn;\n \n+   --  Note on the formal types used (atyp and btyp). If either of the\n+   --  arrays is of a private type, we use the underlying type, and\n+   --  do an unchecked conversion of the actual. If either of the arrays\n+   --  has a bound depending on a discriminant, then we use the base type\n+   --  since otherwise we have an escaped discriminant in the function.\n+\n    function Expand_Array_Equality\n      (Nod    : Node_Id;\n-      Typ    : Entity_Id;\n-      A_Typ  : Entity_Id;\n       Lhs    : Node_Id;\n       Rhs    : Node_Id;\n-      Bodies : List_Id) return Node_Id\n+      Bodies : List_Id;\n+      Typ    : Entity_Id) return Node_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (Nod);\n       Decls       : constant List_Id    := New_List;\n@@ -924,6 +925,10 @@ package body Exp_Ch4 is\n       A : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uA);\n       B : constant Entity_Id := Make_Defining_Identifier (Loc, Name_uB);\n \n+      Ltyp : Entity_Id;\n+      Rtyp : Entity_Id;\n+      --  The parameter types to be used for the formals\n+\n       function Arr_Attr\n         (Arr : Entity_Id;\n          Nam : Name_Id;\n@@ -934,29 +939,37 @@ package body Exp_Ch4 is\n       --  Create one statement to compare corresponding components,\n       --  designated by a full set of indices.\n \n+      function Get_Arg_Type (N : Node_Id) return Entity_Id;\n+      --  Given one of the arguments, computes the appropriate type to\n+      --  be used for that argument in the corresponding function formal\n+\n       function Handle_One_Dimension\n         (N     : Int;\n          Index : Node_Id) return Node_Id;\n-      --  This procedure returns a declare block:\n+      --  This procedure returns the following code\n       --\n       --    declare\n-      --       An : Index_Type_n := A'First (n);\n-      --       Bn : Index_Type_n := B'First (n);\n+      --       Bn : Index_T := B'First (n);\n       --    begin\n-      --       loop\n+      --       for An in A'range (n) loop\n       --          xxx\n-      --          exit when An = A'Last (n);\n-      --          An := Index_Type_n'Succ (An)\n-      --          Bn := Index_Type_n'Succ (Bn)\n+      --          Bn := Index_T'Succ (Bn)\n       --       end loop;\n       --    end;\n       --\n+      --  Note: we don't need Bn or the declare block when the index types\n+      --  of the two arrays are constrained and identical.\n+      --\n       --  where N is the value of \"n\" in the above code. Index is the\n       --  N'th index node, whose Etype is Index_Type_n in the above code.\n-      --  The xxx statement is either the declare block for the next\n+      --  The xxx statement is either the loop or declare for the next\n       --  dimension or if this is the last dimension the comparison\n       --  of corresponding components of the arrays.\n       --\n+      --  Note: if the index types are identical and constrained, we\n+      --  need only one index, so we generate only An and we do not\n+      --  need the declare block.\n+      --\n       --  The actual way the code works is to return the comparison\n       --  of corresponding components for the N+1 call. That's neater!\n \n@@ -1025,6 +1038,40 @@ package body Exp_Ch4 is\n                  Expression => New_Occurrence_Of (Standard_False, Loc))));\n       end Component_Equality;\n \n+      ------------------\n+      -- Get_Arg_Type --\n+      ------------------\n+\n+      function Get_Arg_Type (N : Node_Id) return Entity_Id is\n+         T : Entity_Id;\n+         X : Node_Id;\n+\n+      begin\n+         T := Etype (N);\n+\n+         if No (T) then\n+            return Typ;\n+\n+         else\n+            T := Underlying_Type (T);\n+\n+            X := First_Index (T);\n+            while Present (X) loop\n+               if Denotes_Discriminant (Type_Low_Bound (Etype (X)))\n+                 or else\n+                   Denotes_Discriminant (Type_High_Bound (Etype (X)))\n+               then\n+                  T := Base_Type (T);\n+                  exit;\n+               end if;\n+\n+               Next_Index (X);\n+            end loop;\n+\n+            return T;\n+         end if;\n+      end Get_Arg_Type;\n+\n       --------------------------\n       -- Handle_One_Dimension --\n       ---------------------------\n@@ -1033,70 +1080,85 @@ package body Exp_Ch4 is\n         (N     : Int;\n          Index : Node_Id) return Node_Id\n       is\n+         Need_Separate_Indexes : constant Boolean :=\n+                                   Ltyp /= Rtyp\n+                                     or else not Is_Constrained (Ltyp);\n+         --  If the index types are identical, and we are working with\n+         --  constrained types, then we can use the same index for both of\n+         --  the arrays.\n+\n          An : constant Entity_Id := Make_Defining_Identifier (Loc,\n                                       Chars => New_Internal_Name ('A'));\n-         Bn : constant Entity_Id := Make_Defining_Identifier (Loc,\n-                                      Chars => New_Internal_Name ('B'));\n-         Index_Type_n  : Entity_Id;\n+\n+         Bn       : Entity_Id;\n+         Index_T  : Entity_Id;\n+         Stm_List : List_Id;\n+         Loop_Stm : Node_Id;\n \n       begin\n-         if N > Number_Dimensions (Typ) then\n-            return Component_Equality (Typ);\n+         if N > Number_Dimensions (Ltyp) then\n+            return Component_Equality (Ltyp);\n          end if;\n \n-         --  Case where we generate a declare block\n+         --  Case where we generate a loop\n+\n+         Index_T := Base_Type (Etype (Index));\n+\n+         if Need_Separate_Indexes then\n+            Bn :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('B'));\n+         else\n+            Bn := An;\n+         end if;\n \n-         Index_Type_n := Base_Type (Etype (Index));\n          Append (New_Reference_To (An, Loc), Index_List1);\n          Append (New_Reference_To (Bn, Loc), Index_List2);\n \n-         return\n-            Make_Block_Statement (Loc,\n-              Declarations => New_List (\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => An,\n-                   Object_Definition   =>\n-                     New_Reference_To (Index_Type_n, Loc),\n-                   Expression => Arr_Attr (A, Name_First, N)),\n+         Stm_List := New_List (\n+           Handle_One_Dimension (N + 1, Next_Index (Index)));\n \n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Bn,\n-                   Object_Definition   =>\n-                     New_Reference_To (Index_Type_n, Loc),\n-                   Expression => Arr_Attr (B, Name_First, N))),\n-\n-              Handled_Statement_Sequence =>\n-                Make_Handled_Sequence_Of_Statements (Loc,\n-                  Statements => New_List (\n-                    Make_Implicit_Loop_Statement (Nod,\n-                      Statements => New_List (\n-                        Handle_One_Dimension (N + 1, Next_Index (Index)),\n-\n-                        Make_Exit_Statement (Loc,\n-                          Condition =>\n-                            Make_Op_Eq (Loc,\n-                              Left_Opnd  => New_Reference_To (An, Loc),\n-                              Right_Opnd => Arr_Attr (A, Name_Last, N))),\n-\n-                        Make_Assignment_Statement (Loc,\n-                          Name => New_Reference_To (An, Loc),\n-                          Expression =>\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix =>\n-                                New_Reference_To (Index_Type_n, Loc),\n-                              Attribute_Name => Name_Succ,\n-                              Expressions => New_List (\n-                                New_Reference_To (An, Loc)))),\n-\n-                       Make_Assignment_Statement (Loc,\n-                          Name => New_Reference_To (Bn, Loc),\n-                          Expression =>\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix =>\n-                                New_Reference_To (Index_Type_n, Loc),\n-                              Attribute_Name => Name_Succ,\n-                              Expressions => New_List (\n-                                New_Reference_To (Bn, Loc)))))))));\n+         if Need_Separate_Indexes then\n+            Append_To (Stm_List,\n+              Make_Assignment_Statement (Loc,\n+                Name       => New_Reference_To (Bn, Loc),\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Reference_To (Index_T, Loc),\n+                    Attribute_Name => Name_Succ,\n+                    Expressions    => New_List (New_Reference_To (Bn, Loc)))));\n+         end if;\n+\n+         Loop_Stm :=\n+           Make_Implicit_Loop_Statement (Nod,\n+             Statements       => Stm_List,\n+             Iteration_Scheme =>\n+               Make_Iteration_Scheme (Loc,\n+                 Loop_Parameter_Specification =>\n+                   Make_Loop_Parameter_Specification (Loc,\n+                     Defining_Identifier         => An,\n+                     Discrete_Subtype_Definition =>\n+                       Arr_Attr (A, Name_Range, N))));\n+\n+         --  If separate indexes, need a declare block to declare Bn\n+\n+         if Need_Separate_Indexes then\n+            return\n+              Make_Block_Statement (Loc,\n+                Declarations => New_List (\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Bn,\n+                    Object_Definition   => New_Reference_To (Index_T, Loc),\n+                    Expression          => Arr_Attr (B, Name_First, N))),\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Loop_Stm)));\n+\n+         --  If no separate indexes, return loop statement on its own\n+\n+         else\n+            return Loop_Stm;\n+         end if;\n       end Handle_One_Dimension;\n \n       -----------------------\n@@ -1113,7 +1175,7 @@ package body Exp_Ch4 is\n       begin\n          Alist := Empty;\n          Blist := Empty;\n-         for J in 1 .. Number_Dimensions (Typ) loop\n+         for J in 1 .. Number_Dimensions (Ltyp) loop\n             Atest :=\n               Make_Op_Eq (Loc,\n                 Left_Opnd  => Arr_Attr (A, Name_Length, J),\n@@ -1157,7 +1219,7 @@ package body Exp_Ch4 is\n \n       begin\n          Result := Empty;\n-         for J in 1 .. Number_Dimensions (Typ) loop\n+         for J in 1 .. Number_Dimensions (Ltyp) loop\n             Rtest :=\n               Make_Op_Ne (Loc,\n                 Left_Opnd  => Arr_Attr (A, Name_Length, J),\n@@ -1179,14 +1241,29 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_Array_Equality\n \n    begin\n+      Ltyp := Get_Arg_Type (Lhs);\n+      Rtyp := Get_Arg_Type (Rhs);\n+\n+      --  For now, if the argument types are not the same, go to the\n+      --  base type, since the code assumes that the formals have the\n+      --  same type. This is fixable in future ???\n+\n+      if Ltyp /= Rtyp then\n+         Ltyp := Base_Type (Ltyp);\n+         Rtyp := Base_Type (Rtyp);\n+         pragma Assert (Ltyp = Rtyp);\n+      end if;\n+\n+      --  Build list of formals for function\n+\n       Formals := New_List (\n         Make_Parameter_Specification (Loc,\n           Defining_Identifier => A,\n-          Parameter_Type      => New_Reference_To (Typ, Loc)),\n+          Parameter_Type      => New_Reference_To (Ltyp, Loc)),\n \n         Make_Parameter_Specification (Loc,\n           Defining_Identifier => B,\n-          Parameter_Type      => New_Reference_To (Typ, Loc)));\n+          Parameter_Type      => New_Reference_To (Rtyp, Loc)));\n \n       Func_Name := Make_Defining_Identifier (Loc,  New_Internal_Name ('E'));\n \n@@ -1220,30 +1297,45 @@ package body Exp_Ch4 is\n                       Expression =>\n                         New_Occurrence_Of (Standard_False, Loc)))),\n \n-                Handle_One_Dimension (1, First_Index (Typ)),\n+                Handle_One_Dimension (1, First_Index (Ltyp)),\n \n                 Make_Return_Statement (Loc,\n                   Expression => New_Occurrence_Of (Standard_True, Loc)))));\n \n          Set_Has_Completion (Func_Name, True);\n+         Set_Is_Inlined (Func_Name);\n \n          --  If the array type is distinct from the type of the arguments,\n          --  it is the full view of a private type. Apply an unchecked\n          --  conversion to insure that analysis of the call succeeds.\n \n-         if Base_Type (A_Typ) /= Base_Type (Typ) then\n-            Actuals := New_List (\n-              OK_Convert_To (Typ, Lhs),\n-              OK_Convert_To (Typ, Rhs));\n-         else\n-            Actuals := New_List (Lhs, Rhs);\n-         end if;\n+         declare\n+            L, R : Node_Id;\n+\n+         begin\n+            L := Lhs;\n+            R := Rhs;\n+\n+            if No (Etype (Lhs))\n+              or else Base_Type (Etype (Lhs)) /= Base_Type (Ltyp)\n+            then\n+               L := OK_Convert_To (Ltyp, Lhs);\n+            end if;\n+\n+            if No (Etype (Rhs))\n+              or else Base_Type (Etype (Rhs)) /= Base_Type (Rtyp)\n+            then\n+               R := OK_Convert_To (Rtyp, Rhs);\n+            end if;\n+\n+            Actuals := New_List (L, R);\n+         end;\n \n          Append_To (Bodies, Func_Body);\n \n          return\n            Make_Function_Call (Loc,\n-             Name => New_Reference_To (Func_Name, Loc),\n+             Name                   => New_Reference_To (Func_Name, Loc),\n              Parameter_Associations => Actuals);\n    end Expand_Array_Equality;\n \n@@ -1370,8 +1462,7 @@ package body Exp_Ch4 is\n          --  case of any composite type recursively containing such fields.\n \n          else\n-            return Expand_Array_Equality\n-                     (Nod, Full_Type, Typ, Lhs, Rhs, Bodies);\n+            return Expand_Array_Equality (Nod, Lhs, Rhs, Bodies, Full_Type);\n          end if;\n \n       elsif Is_Tagged_Type (Full_Type) then\n@@ -2101,6 +2192,7 @@ package body Exp_Ch4 is\n \n    procedure Expand_N_Allocator (N : Node_Id) is\n       PtrT  : constant Entity_Id  := Etype (N);\n+      Dtyp  : constant Entity_Id  := Designated_Type (PtrT);\n       Desig : Entity_Id;\n       Loc   : constant Source_Ptr := Sloc (N);\n       Temp  : Entity_Id;\n@@ -2172,8 +2264,8 @@ package body Exp_Ch4 is\n          --  so that the constant is not labelled as having a nomimally\n          --  unconstrained subtype.\n \n-         if Entity (Desig) = Base_Type (Designated_Type (PtrT)) then\n-            Desig := New_Occurrence_Of (Designated_Type (PtrT), Loc);\n+         if Entity (Desig) = Base_Type (Dtyp) then\n+            Desig := New_Occurrence_Of (Dtyp, Loc);\n          end if;\n \n          Insert_Action (N,\n@@ -2198,6 +2290,8 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Handle case of qualified expression (other than optimization above)\n+\n       if Nkind (Expression (N)) = N_Qualified_Expression then\n          Expand_Allocator_Expression (N);\n \n@@ -2219,19 +2313,19 @@ package body Exp_Ch4 is\n \n       else\n          declare\n-            T         : constant Entity_Id  := Entity (Expression (N));\n-            Init      : Entity_Id;\n-            Arg1      : Node_Id;\n-            Args      : List_Id;\n-            Decls     : List_Id;\n-            Decl      : Node_Id;\n-            Discr     : Elmt_Id;\n-            Flist     : Node_Id;\n-            Temp_Decl : Node_Id;\n-            Temp_Type : Entity_Id;\n+            T            : constant Entity_Id  := Entity (Expression (N));\n+            Init         : Entity_Id;\n+            Arg1         : Node_Id;\n+            Args         : List_Id;\n+            Decls        : List_Id;\n+            Decl         : Node_Id;\n+            Discr        : Elmt_Id;\n+            Flist        : Node_Id;\n+            Temp_Decl    : Node_Id;\n+            Temp_Type    : Entity_Id;\n+            Attach_Level : Uint;\n \n          begin\n-\n             if No_Initialization (N) then\n                null;\n \n@@ -2284,7 +2378,7 @@ package body Exp_Ch4 is\n                   --  if the context is access to class wide, indicate that\n                   --  the object being allocated has the right specific type.\n \n-                  if Is_Class_Wide_Type (Designated_Type (PtrT)) then\n+                  if Is_Class_Wide_Type (Dtyp) then\n                      Arg1 := Unchecked_Convert_To (T, Arg1);\n                   end if;\n                end if;\n@@ -2327,7 +2421,6 @@ package body Exp_Ch4 is\n                --  part of the generated code for the allocator).\n \n                if Has_Task (T) then\n-\n                   if No (Master_Id (Base_Type (PtrT))) then\n \n                      --  The designated type was an incomplete type, and\n@@ -2475,13 +2568,18 @@ package body Exp_Ch4 is\n \n                if Controlled_Type (T) then\n                   Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n-\n+                  if Ekind (PtrT) = E_Anonymous_Access_Type then\n+                     Attach_Level := Uint_1;\n+                  else\n+                     Attach_Level := Uint_2;\n+                  end if;\n                   Insert_Actions (N,\n                     Make_Init_Call (\n                       Ref          => New_Copy_Tree (Arg1),\n                       Typ          => T,\n                       Flist_Ref    => Flist,\n-                      With_Attach  => Make_Integer_Literal (Loc, 2)));\n+                      With_Attach  => Make_Integer_Literal (Loc,\n+                        Attach_Level)));\n                end if;\n \n                if Is_CPP_Class (T) then\n@@ -3283,7 +3381,6 @@ package body Exp_Ch4 is\n    --  all three are available, False if any one of these is unavailable.\n \n    procedure Expand_N_Op_Concat (N : Node_Id) is\n-\n       Opnds : List_Id;\n       --  List of operands to be concatenated\n \n@@ -3643,10 +3740,13 @@ package body Exp_Ch4 is\n             begin\n                Force_Validity_Checks := True;\n                Rewrite (N,\n-                 Expand_Array_Equality (N, Typl, A_Typ,\n-                   Relocate_Node (Lhs), Relocate_Node (Rhs), Bodies));\n-\n-               Insert_Actions      (N, Bodies);\n+                 Expand_Array_Equality\n+                  (N,\n+                   Relocate_Node (Lhs),\n+                   Relocate_Node (Rhs),\n+                   Bodies,\n+                   Typl));\n+               Insert_Actions (N, Bodies);\n                Analyze_And_Resolve (N, Standard_Boolean);\n                Force_Validity_Checks := Save_Force_Validity_Checks;\n             end;\n@@ -3672,9 +3772,12 @@ package body Exp_Ch4 is\n \n          else\n             Rewrite (N,\n-              Expand_Array_Equality (N, Typl, A_Typ,\n-                Relocate_Node (Lhs), Relocate_Node (Rhs), Bodies));\n-\n+              Expand_Array_Equality\n+                (N,\n+                 Relocate_Node (Lhs),\n+                 Relocate_Node (Rhs),\n+                 Bodies,\n+                 Typl));\n             Insert_Actions      (N, Bodies,           Suppress => All_Checks);\n             Analyze_And_Resolve (N, Standard_Boolean, Suppress => All_Checks);\n          end if;\n@@ -6510,34 +6613,46 @@ package body Exp_Ch4 is\n       PtrT : Entity_Id) return Entity_Id\n    is\n       Loc : constant Source_Ptr := Sloc (N);\n-      Acc : Entity_Id;\n \n-   begin\n-      --  If the context is an access parameter, we need to create\n-      --  a non-anonymous access type in order to have a usable\n-      --  final list, because there is otherwise no pool to which\n-      --  the allocated object can belong. We create both the type\n-      --  and the finalization chain here, because freezing an\n-      --  internal type does not create such a chain. The Final_Chain\n-      --  that is thus created is shared by the access parameter.\n+      Owner : Entity_Id := PtrT;\n+      --  The entity whose finalisation list must be used to attach the\n+      --  allocated object.\n \n+   begin\n       if Ekind (PtrT) = E_Anonymous_Access_Type then\n-         Acc := Make_Defining_Identifier (Loc, New_Internal_Name ('J'));\n-         Insert_Action (N,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Acc,\n-             Type_Definition =>\n-                Make_Access_To_Object_Definition (Loc,\n-                  Subtype_Indication =>\n-                    New_Occurrence_Of (T, Loc))));\n+         if Nkind (Associated_Node_For_Itype (PtrT))\n+              in N_Subprogram_Specification\n+         then\n+            --  If the context is an access parameter, we need to create\n+            --  a non-anonymous access type in order to have a usable\n+            --  final list, because there is otherwise no pool to which\n+            --  the allocated object can belong. We create both the type\n+            --  and the finalization chain here, because freezing an\n+            --  internal type does not create such a chain. The Final_Chain\n+            --  that is thus created is shared by the access parameter.\n+\n+            Owner := Make_Defining_Identifier (Loc, New_Internal_Name ('J'));\n+            Insert_Action (N,\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Owner,\n+                Type_Definition =>\n+                   Make_Access_To_Object_Definition (Loc,\n+                     Subtype_Indication =>\n+                       New_Occurrence_Of (T, Loc))));\n \n-         Build_Final_List (N, Acc);\n-         Set_Associated_Final_Chain (PtrT, Associated_Final_Chain (Acc));\n-         return Find_Final_List (Acc);\n+            Build_Final_List (N, Owner);\n+            Set_Associated_Final_Chain (PtrT, Associated_Final_Chain (Owner));\n \n-      else\n-         return Find_Final_List (PtrT);\n+         else\n+            --  Case of an access discriminant, or (Ada 2005) of\n+            --  an anonymous access component: find the final list\n+            --  associated with the scope of the type.\n+\n+            Owner := Scope (PtrT);\n+         end if;\n       end if;\n+\n+      return Find_Final_List (Owner);\n    end Get_Allocator_Final_List;\n \n    -------------------------------"}, {"sha": "1842996362e95b6ef185d8f658f914a78a1b1da5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -534,6 +534,7 @@ package body Exp_Ch6 is\n          Temp  : Entity_Id;\n          Indic : Node_Id := New_Occurrence_Of (Etype (Formal), Loc);\n          Var   : Entity_Id;\n+         F_Typ : constant Entity_Id := Etype (Formal);\n          V_Typ : Entity_Id;\n          Crep  : Boolean;\n \n@@ -549,7 +550,7 @@ package body Exp_Ch6 is\n             Var := Make_Var (Expression (Actual));\n \n             Crep := not Same_Representation\n-                          (Etype (Formal), Etype (Expression (Actual)));\n+                          (F_Typ, Etype (Expression (Actual)));\n \n          else\n             V_Typ := Etype (Actual);\n@@ -567,21 +568,19 @@ package body Exp_Ch6 is\n          --  right size.\n \n          if Ekind (Formal) = E_In_Out_Parameter\n-           or else (Is_Array_Type (Etype (Formal))\n-                     and then not Is_Constrained (Etype (Formal)))\n+           or else (Is_Array_Type (F_Typ) and then not Is_Constrained (F_Typ))\n          then\n             if Nkind (Actual) = N_Type_Conversion then\n                if Conversion_OK (Actual) then\n-                  Init := OK_Convert_To\n-                            (Etype (Formal), New_Occurrence_Of (Var, Loc));\n+                  Init := OK_Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n                else\n-                  Init := Convert_To\n-                            (Etype (Formal), New_Occurrence_Of (Var, Loc));\n+                  Init := Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n                end if;\n \n             elsif Ekind (Formal) = E_Out_Parameter\n-              and then Number_Dimensions (Etype (Formal)) = 1\n-              and then not Has_Non_Null_Base_Init_Proc (Etype (Formal))\n+              and then Is_Array_Type (F_Typ)\n+              and then Number_Dimensions (F_Typ) = 1\n+              and then not Has_Non_Null_Base_Init_Proc (F_Typ)\n             then\n                --  Actual is a one-dimensional array or slice, and the type\n                --  requires no initialization. Create a temporary of the\n@@ -591,7 +590,7 @@ package body Exp_Ch6 is\n                Indic :=\n                  Make_Subtype_Indication (Loc,\n                    Subtype_Mark =>\n-                     New_Occurrence_Of (Etype (Formal), Loc),\n+                     New_Occurrence_Of (F_Typ, Loc),\n                    Constraint   =>\n                      Make_Index_Or_Discriminant_Constraint (Loc,\n                        Constraints => New_List (\n@@ -617,16 +616,16 @@ package body Exp_Ch6 is\n \n          elsif Ekind (Formal) = E_Out_Parameter\n            and then Nkind (Actual) = N_Type_Conversion\n-           and then (Is_Bit_Packed_Array (Etype (Formal))\n+           and then (Is_Bit_Packed_Array (F_Typ)\n                        or else\n                      Is_Bit_Packed_Array (Etype (Expression (Actual))))\n          then\n             if Conversion_OK (Actual) then\n                Init :=\n-                 OK_Convert_To (Etype (Formal), New_Occurrence_Of (Var, Loc));\n+                 OK_Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n             else\n                Init :=\n-                 Convert_To (Etype (Formal), New_Occurrence_Of (Var, Loc));\n+                 Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n             end if;\n \n          elsif Ekind (Formal) = E_In_Parameter then"}, {"sha": "e541758e05a54fb7c1733bf392cdafdaca71dd6e", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,9 @@ package Exp_Ch7 is\n    procedure Expand_N_Package_Body        (N : Node_Id);\n    procedure Expand_N_Package_Declaration (N : Node_Id);\n \n-   ------------------------------\n-   --  Finalization Management --\n-   ------------------------------\n+   -----------------------------\n+   -- Finalization Management --\n+   -----------------------------\n \n    function In_Finalization_Root (E : Entity_Id) return Boolean;\n    --  True if current scope is in package System.Finalization_Root. Used\n@@ -61,38 +61,35 @@ package Exp_Ch7 is\n    --  True if T potentially needs finalization actions\n \n    function Find_Final_List\n-     (E    : Entity_Id;\n-      Ref  : Node_Id := Empty)\n-      return Node_Id;\n-      --  E is an entity representing a controlled object, a controlled type\n-      --  or a scope. If Ref is not empty, it is a reference to a controlled\n-      --  record, the closest Final list is in the controller component of\n-      --  the record containing Ref otherwise this function returns a\n-      --  reference to the final list attached to the closest dynamic scope\n-      --  (that can be E itself) creating this final list if necessary.\n+     (E   : Entity_Id;\n+      Ref : Node_Id := Empty) return Node_Id;\n+   --  E is an entity representing a controlled object, a controlled type\n+   --  or a scope. If Ref is not empty, it is a reference to a controlled\n+   --  record, the closest Final list is in the controller component of\n+   --  the record containing Ref otherwise this function returns a\n+   --  reference to the final list attached to the closest dynamic scope\n+   --  (that can be E itself) creating this final list if necessary.\n \n    function Has_New_Controlled_Component (E : Entity_Id) return Boolean;\n    --  E is a type entity. Give the same resul as Has_Controlled_Component\n    --  except for tagged extensions where the result is True only if the\n    --  latest extension contains a controlled component.\n \n    function Make_Attach_Call\n-     (Obj_Ref      : Node_Id;\n-      Flist_Ref    : Node_Id;\n-      With_Attach  : Node_Id)\n-      return         Node_Id;\n+     (Obj_Ref     : Node_Id;\n+      Flist_Ref   : Node_Id;\n+      With_Attach : Node_Id) return Node_Id;\n    --  Attach the referenced object to the referenced Final Chain\n    --  'Flist_Ref' With_Attach is an expression of type Short_Short_Integer\n    --  which can be either '0' to signify no attachment, '1' for\n    --  attachement to a simply linked list or '2' for attachement to a\n    --  doubly linked list.\n \n    function Make_Init_Call\n-     (Ref          : Node_Id;\n-      Typ          : Entity_Id;\n-      Flist_Ref    : Node_Id;\n-      With_Attach  : Node_Id)\n-      return         List_Id;\n+     (Ref         : Node_Id;\n+      Typ         : Entity_Id;\n+      Flist_Ref   : Node_Id;\n+      With_Attach : Node_Id) return List_Id;\n    --  Ref is an expression (with no-side effect and is not required to\n    --  have been previously analyzed) that references the object to be\n    --  initialized. Typ is the expected type of Ref, which is a controlled\n@@ -108,11 +105,10 @@ package Exp_Ch7 is\n    --  caller, the details are in the body.\n \n    function Make_Adjust_Call\n-     (Ref          : Node_Id;\n-      Typ          : Entity_Id;\n-      Flist_Ref    : Node_Id;\n-      With_Attach  : Node_Id)\n-      return         List_Id;\n+     (Ref         : Node_Id;\n+      Typ         : Entity_Id;\n+      Flist_Ref   : Node_Id;\n+      With_Attach : Node_Id) return List_Id;\n    --  Ref is an expression (with no-side effect and is not required to\n    --  have been previously analyzed) that references the object to be\n    --  adjusted. Typ is the expected type of Ref, which is a controlled\n@@ -132,8 +128,7 @@ package Exp_Ch7 is\n    function Make_Final_Call\n      (Ref         : Node_Id;\n       Typ         : Entity_Id;\n-      With_Detach : Node_Id)\n-      return        List_Id;\n+      With_Detach : Node_Id) return List_Id;\n    --  Ref is an expression (with no-side effect and is not required\n    --  to have been previously analyzed) that references the object to\n    --  be Finalized. Typ is the expected type of Ref, which is a\n@@ -161,31 +156,27 @@ package Exp_Ch7 is\n    --------------------------------------------\n \n    function Cleanup_Array\n-     (N    : Node_Id;\n-      Obj  : Node_Id;\n-      Typ  : Entity_Id)\n-      return List_Id;\n+     (N   : Node_Id;\n+      Obj : Node_Id;\n+      Typ : Entity_Id) return List_Id;\n    --  Generate loops to finalize any tasks or simple protected objects\n    --  that are subcomponents of an array.\n \n    function Cleanup_Protected_Object\n-     (N    : Node_Id;\n-      Ref  : Node_Id)\n-      return Node_Id;\n+     (N   : Node_Id;\n+      Ref : Node_Id) return Node_Id;\n    --  Generate code to finalize a protected object without entries.\n \n    function Cleanup_Record\n-     (N    : Node_Id;\n-      Obj  : Node_Id;\n-      Typ  : Entity_Id)\n-      return List_Id;\n+     (N   : Node_Id;\n+      Obj : Node_Id;\n+      Typ : Entity_Id) return List_Id;\n    --  For each subcomponent of a record that contains tasks or simple\n    --  protected objects, generate the appropriate finalization call.\n \n    function Cleanup_Task\n-     (N    : Node_Id;\n-      Ref  : Node_Id)\n-      return Node_Id;\n+     (N   : Node_Id;\n+      Ref : Node_Id) return Node_Id;\n    --  Generate code to finalize a task.\n \n    function Has_Simple_Protected_Object (T : Entity_Id) return Boolean;"}, {"sha": "dd8b095822a61623be024439433c5d0ea9289016", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -66,7 +66,7 @@ package body Exp_Dist is\n    --       converted to and from this type to make it suitable for\n    --       System.Partition_Interface.Get_Unique_Remote_Pointer in order\n    --       to avoid memory leaks when the same remote object arrive on the\n-   --       same partition by following different pathes\n+   --       same partition through several paths;\n \n    --    2) It also has the same dispatching table as the designated type D,\n    --       and thus can be used as an object designated by a value of type"}, {"sha": "364b4d7664c4d64609429675300b355aad37dd21", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1156,7 +1156,7 @@ package body Exp_Pakd is\n          --    subtype tttPn is\n          --      System.Packed_Bytes{1,2,4} (0 .. (Bits + 7) / 8 - 1);\n \n-         --  Bits is the length of the array in bits.\n+         --  Bits is the length of the array in bits\n \n          Set_PB_Type;\n \n@@ -1197,6 +1197,12 @@ package body Exp_Pakd is\n                            High_Bound => PAT_High)))));\n \n          Install_PAT;\n+\n+         --  Currently the code in this unit requires that packed arrays\n+         --  represented by non-modular arrays of bytes be on a byte\n+         --  boundary.\n+\n+         Set_Must_Be_On_Byte_Boundary (Typ);\n       end if;\n    end Create_Packed_Array_Type;\n "}, {"sha": "e90c491b5544c4cd75bb52dad6ef44464eb2906e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -2384,6 +2384,34 @@ package body Exp_Util is\n    ---------------------------------\n \n    function Is_Possibly_Unaligned_Slice (P : Node_Id) return Boolean is\n+\n+      function Has_Non_Trivial_Component_Clause (E : Entity_Id) return Boolean;\n+      --  Check whether the component clause might place the component at an\n+      --  alignment that will require the use of a copy when a slice is passed\n+      --  as a parameter.  The code is conservative because at this point the\n+      --  expander does not know the alignment choice that the back-end will\n+      --  make. For now we return true if the component is not the first one\n+      --  in the enclosing record. This routine is a place holder for further\n+      --  analysis of this kind.\n+\n+      --------------------------------------\n+      -- Has_Non_Trivial_Component_Clause --\n+      --------------------------------------\n+\n+      function Has_Non_Trivial_Component_Clause (E : Entity_Id) return Boolean\n+      is\n+         Rep_Clause : constant Node_Id := Component_Clause (E);\n+      begin\n+         if No (Rep_Clause) then\n+            return False;\n+         else\n+            return Intval (Position (Rep_Clause)) /= Uint_0\n+              or else Intval (First_Bit (Rep_Clause)) /= Uint_0;\n+         end if;\n+      end Has_Non_Trivial_Component_Clause;\n+\n+   --  Start of processing for Is_Possibly_Unaligned_Slice\n+\n    begin\n       --  ??? GCC3 will eventually handle strings with arbitrary alignments,\n       --  but for now the following check must be disabled.\n@@ -2448,7 +2476,8 @@ package body Exp_Util is\n                     or else\n                   Known_Alignment (Etype (Prefix (Pref)))\n                     or else\n-                  Present (Component_Clause (Entity (Selector_Name (Pref)))));\n+                      Has_Non_Trivial_Component_Clause\n+                        (Entity (Selector_Name (Pref))));\n       end;\n    end Is_Possibly_Unaligned_Slice;\n "}, {"sha": "a688564ad11caa148681d8a26ec60442a86abe40", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -149,13 +149,18 @@ package body Fname is\n       if Name_Len > 8 then\n          return False;\n \n-      --  Definitely predefined if prefix is a- i- or s-\n+      --  Definitely predefined if prefix is a- i- or s- followed by letter\n \n-      elsif Name_Len > 2\n+      elsif Name_Len >=  3\n         and then Name_Buffer (2) = '-'\n-        and then (Name_Buffer (1) = 'a' or else\n-                  Name_Buffer (1) = 'i' or else\n+        and then (Name_Buffer (1) = 'a'\n+                    or else\n+                  Name_Buffer (1) = 'i'\n+                    or else\n                   Name_Buffer (1) = 's')\n+        and then (Name_Buffer (3) in 'a' .. 'z'\n+                    or else\n+                  Name_Buffer (3) in 'A' .. 'Z')\n       then\n          return True;\n       end if;"}, {"sha": "6e2d126763703885e2df8d6bf89060535e032c47", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 154, "deletions": 113, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -601,7 +601,6 @@ package body Freeze is\n \n             begin\n                Index := First_Index (T);\n-\n                while Present (Index) loop\n                   if Nkind (Index) = N_Range then\n                      Get_Index_Bounds (Index, Low, High);\n@@ -881,8 +880,7 @@ package body Freeze is\n       -------------------------------------\n \n       function Static_Discriminated_Components\n-        (T    : Entity_Id)\n-         return Boolean\n+        (T : Entity_Id) return Boolean\n       is\n          Constraint : Elmt_Id;\n \n@@ -1340,7 +1338,6 @@ package body Freeze is\n       Result : in out List_Id)\n    is\n       L : constant List_Id := Freeze_Entity (Ent, Loc);\n-\n    begin\n       if Is_Non_Empty_List (L) then\n          if Result = No_List then\n@@ -1357,7 +1354,6 @@ package body Freeze is\n \n    procedure Freeze_Before (N : Node_Id; T : Entity_Id) is\n       Freeze_Nodes : constant List_Id := Freeze_Entity (T, Sloc (N));\n-\n    begin\n       if Is_Non_Empty_List (Freeze_Nodes) then\n          Insert_Actions (N, Freeze_Nodes);\n@@ -1619,16 +1615,16 @@ package body Freeze is\n             if Ekind (Comp) = E_Component\n               or else Ekind (Comp) = E_Discriminant\n             then\n-               --  Check for error of component clause given for variable\n-               --  sized type. We have to delay this test till this point,\n-               --  since the component type has to be frozen for us to know\n-               --  if it is variable length. We omit this test in a generic\n-               --  context, it will be applied at instantiation time.\n-\n                declare\n                   CC : constant Node_Id := Component_Clause (Comp);\n \n                begin\n+                  --  Check for error of component clause given for variable\n+                  --  sized type. We have to delay this test till this point,\n+                  --  since the component type has to be frozen for us to know\n+                  --  if it is variable length. We omit this test in a generic\n+                  --  context, it will be applied at instantiation time.\n+\n                   if Present (CC) then\n                      Placed_Component := True;\n \n@@ -1646,116 +1642,141 @@ package body Freeze is\n                   else\n                      Unplaced_Component := True;\n                   end if;\n-               end;\n \n-               --  If component clause is present, then deal with the\n-               --  non-default bit order case. We cannot do this before\n-               --  the freeze point, because there is no required order\n-               --  for the component clause and the bit_order clause.\n+                  --  Case of component requires byte alignment\n \n-               --  We only do this processing for the base type, and in\n-               --  fact that's important, since otherwise if there are\n-               --  record subtypes, we could reverse the bits once for\n-               --  each subtype, which would be incorrect.\n+                  if Must_Be_On_Byte_Boundary (Etype (Comp)) then\n \n-               if Present (Component_Clause (Comp))\n-                 and then Reverse_Bit_Order (Rec)\n-                 and then Ekind (E) = E_Record_Type\n-               then\n-                  declare\n-                     CFB : constant Uint    := Component_Bit_Offset (Comp);\n-                     CSZ : constant Uint    := Esize (Comp);\n-                     CLC : constant Node_Id := Component_Clause (Comp);\n-                     Pos : constant Node_Id := Position (CLC);\n-                     FB  : constant Node_Id := First_Bit (CLC);\n+                     --  Set the enclosing record to also require byte align\n \n-                     Storage_Unit_Offset : constant Uint :=\n-                                             CFB / System_Storage_Unit;\n+                     Set_Must_Be_On_Byte_Boundary (Rec);\n \n-                     Start_Bit : constant Uint :=\n-                                   CFB mod System_Storage_Unit;\n+                     --  Check for component clause that is inconsistent\n+                     --  with the required byte boundary alignment.\n \n-                  begin\n-                     --  Cases where field goes over storage unit boundary\n+                     if Present (CC)\n+                       and then Normalized_First_Bit (Comp) mod\n+                                  System_Storage_Unit /= 0\n+                     then\n+                        Error_Msg_N\n+                          (\"component & must be byte aligned\",\n+                           Component_Name (Component_Clause (Comp)));\n+                     end if;\n+                  end if;\n \n-                     if Start_Bit + CSZ > System_Storage_Unit then\n+                  --  If component clause is present, then deal with the\n+                  --  non-default bit order case. We cannot do this before\n+                  --  the freeze point, because there is no required order\n+                  --  for the component clause and the bit_order clause.\n \n-                        --  Allow multi-byte field but generate warning\n+                  --  We only do this processing for the base type, and in\n+                  --  fact that's important, since otherwise if there are\n+                  --  record subtypes, we could reverse the bits once for\n+                  --  each subtype, which would be incorrect.\n \n-                        if Start_Bit mod System_Storage_Unit = 0\n-                          and then CSZ mod System_Storage_Unit = 0\n-                        then\n-                           Error_Msg_N\n-                             (\"multi-byte field specified with non-standard\"\n-                                & \" Bit_Order?\", CLC);\n+                  if Present (CC)\n+                    and then Reverse_Bit_Order (Rec)\n+                    and then Ekind (E) = E_Record_Type\n+                  then\n+                     declare\n+                        CFB : constant Uint    := Component_Bit_Offset (Comp);\n+                        CSZ : constant Uint    := Esize (Comp);\n+                        CLC : constant Node_Id := Component_Clause (Comp);\n+                        Pos : constant Node_Id := Position (CLC);\n+                        FB  : constant Node_Id := First_Bit (CLC);\n+\n+                        Storage_Unit_Offset : constant Uint :=\n+                                                CFB / System_Storage_Unit;\n+\n+                        Start_Bit : constant Uint :=\n+                                      CFB mod System_Storage_Unit;\n+\n+                     begin\n+                        --  Cases where field goes over storage unit boundary\n+\n+                        if Start_Bit + CSZ > System_Storage_Unit then\n \n-                           if Bytes_Big_Endian then\n+                           --  Allow multi-byte field but generate warning\n+\n+                           if Start_Bit mod System_Storage_Unit = 0\n+                             and then CSZ mod System_Storage_Unit = 0\n+                           then\n                               Error_Msg_N\n-                                (\"bytes are not reversed \"\n-                                   & \"(component is big-endian)?\", CLC);\n+                                (\"multi-byte field specified with non-standard\"\n+                                 & \" Bit_Order?\", CLC);\n+\n+                              if Bytes_Big_Endian then\n+                                 Error_Msg_N\n+                                   (\"bytes are not reversed \"\n+                                    & \"(component is big-endian)?\", CLC);\n+                              else\n+                                 Error_Msg_N\n+                                   (\"bytes are not reversed \"\n+                                    & \"(component is little-endian)?\", CLC);\n+                              end if;\n+\n+                              --  Do not allow non-contiguous field\n+\n                            else\n                               Error_Msg_N\n-                                (\"bytes are not reversed \"\n-                                   & \"(component is little-endian)?\", CLC);\n+                                (\"attempt to specify non-contiguous field\"\n+                                 & \" not permitted\", CLC);\n+                              Error_Msg_N\n+                                (\"\\(caused by non-standard Bit_Order \"\n+                                 & \"specified)\", CLC);\n                            end if;\n \n-                        --  Do not allow non-contiguous field\n+                           --  Case where field fits in one storage unit\n \n                         else\n-                           Error_Msg_N\n-                             (\"attempt to specify non-contiguous field\"\n-                                & \" not permitted\", CLC);\n-                           Error_Msg_N\n-                             (\"\\(caused by non-standard Bit_Order \"\n-                                & \"specified)\", CLC);\n-                        end if;\n-\n-                     --  Case where field fits in one storage unit\n+                           --  Give warning if suspicious component clause\n \n-                     else\n-                        --  Give warning if suspicious component clause\n-\n-                        if Intval (FB) >= System_Storage_Unit then\n-                           Error_Msg_N\n-                             (\"?Bit_Order clause does not affect \" &\n-                              \"byte ordering\", Pos);\n-                           Error_Msg_Uint_1 :=\n-                             Intval (Pos) + Intval (FB) / System_Storage_Unit;\n-                           Error_Msg_N\n-                             (\"?position normalized to ^ before bit \" &\n-                              \"order interpreted\", Pos);\n-                        end if;\n+                           if Intval (FB) >= System_Storage_Unit then\n+                              Error_Msg_N\n+                                (\"?Bit_Order clause does not affect \" &\n+                                 \"byte ordering\", Pos);\n+                              Error_Msg_Uint_1 :=\n+                                Intval (Pos) + Intval (FB) /\n+                                  System_Storage_Unit;\n+                              Error_Msg_N\n+                                (\"?position normalized to ^ before bit \" &\n+                                 \"order interpreted\", Pos);\n+                           end if;\n \n-                        --  Here is where we fix up the Component_Bit_Offset\n-                        --  value to account for the reverse bit order.\n-                        --  Some examples of what needs to be done are:\n+                           --  Here is where we fix up the Component_Bit_Offset\n+                           --  value to account for the reverse bit order.\n+                           --  Some examples of what needs to be done are:\n \n-                        --    First_Bit .. Last_Bit     Component_Bit_Offset\n-                        --      old          new          old       new\n+                           --    First_Bit .. Last_Bit     Component_Bit_Offset\n+                           --      old          new          old       new\n \n-                        --     0 .. 0       7 .. 7         0         7\n-                        --     0 .. 1       6 .. 7         0         6\n-                        --     0 .. 2       5 .. 7         0         5\n-                        --     0 .. 7       0 .. 7         0         4\n+                           --     0 .. 0       7 .. 7         0         7\n+                           --     0 .. 1       6 .. 7         0         6\n+                           --     0 .. 2       5 .. 7         0         5\n+                           --     0 .. 7       0 .. 7         0         4\n \n-                        --     1 .. 1       6 .. 6         1         6\n-                        --     1 .. 4       3 .. 6         1         3\n-                        --     4 .. 7       0 .. 3         4         0\n+                           --     1 .. 1       6 .. 6         1         6\n+                           --     1 .. 4       3 .. 6         1         3\n+                           --     4 .. 7       0 .. 3         4         0\n \n-                        --  The general rule is that the first bit is\n-                        --  is obtained by subtracting the old ending bit\n-                        --  from storage_unit - 1.\n+                           --  The general rule is that the first bit is\n+                           --  is obtained by subtracting the old ending bit\n+                           --  from storage_unit - 1.\n \n-                        Set_Component_Bit_Offset (Comp,\n-                          (Storage_Unit_Offset * System_Storage_Unit)\n-                          + (System_Storage_Unit - 1)\n-                          - (Start_Bit + CSZ - 1));\n+                           Set_Component_Bit_Offset\n+                             (Comp,\n+                              (Storage_Unit_Offset * System_Storage_Unit) +\n+                                (System_Storage_Unit - 1) -\n+                                  (Start_Bit + CSZ - 1));\n \n-                        Set_Normalized_First_Bit (Comp,\n-                          Component_Bit_Offset (Comp) mod System_Storage_Unit);\n-                     end if;\n-                  end;\n-               end if;\n+                           Set_Normalized_First_Bit\n+                             (Comp,\n+                                Component_Bit_Offset (Comp) mod\n+                                  System_Storage_Unit);\n+                        end if;\n+                     end;\n+                  end if;\n+               end;\n             end if;\n \n             Next_Entity (Comp);\n@@ -2543,27 +2564,43 @@ package body Freeze is\n                   Set_Has_Non_Standard_Rep (Base_Type (E));\n                   Set_Is_Packed            (Base_Type (E));\n                end if;\n-            end;\n \n-            Set_Component_Alignment_If_Not_Set (E);\n+               Set_Component_Alignment_If_Not_Set (E);\n \n-            --  If the array is packed, we must create the packed array\n-            --  type to be used to actually implement the type. This is\n-            --  only needed for real array types (not for string literal\n-            --  types, since they are present only for the front end).\n+               --  If the array is packed, we must create the packed array\n+               --  type to be used to actually implement the type. This is\n+               --  only needed for real array types (not for string literal\n+               --  types, since they are present only for the front end).\n \n-            if Is_Packed (E)\n-              and then Ekind (E) /= E_String_Literal_Subtype\n-            then\n-               Create_Packed_Array_Type (E);\n-               Freeze_And_Append (Packed_Array_Type (E), Loc, Result);\n+               if Is_Packed (E)\n+                 and then Ekind (E) /= E_String_Literal_Subtype\n+               then\n+                  Create_Packed_Array_Type (E);\n+                  Freeze_And_Append (Packed_Array_Type (E), Loc, Result);\n \n-               --  Size information of packed array type is copied to the\n-               --  array type, since this is really the representation.\n+                  --  Size information of packed array type is copied to the\n+                  --  array type, since this is really the representation.\n \n-               Set_Size_Info (E, Packed_Array_Type (E));\n-               Set_RM_Size   (E, RM_Size (Packed_Array_Type (E)));\n-            end if;\n+                  Set_Size_Info (E, Packed_Array_Type (E));\n+                  Set_RM_Size   (E, RM_Size (Packed_Array_Type (E)));\n+               end if;\n+\n+               --  For non-packed arrays set the alignment of the array\n+               --  to the alignment of the component type if it is unknown.\n+               --  Skip this in the atomic case, since atomic arrays may\n+               --  need larger alignments.\n+\n+               if not Is_Packed (E)\n+                 and then Unknown_Alignment (E)\n+                 and then Known_Alignment (Ctyp)\n+                 and then Known_Static_Component_Size (E)\n+                 and then Known_Static_Esize (Ctyp)\n+                 and then Esize (Ctyp) = Component_Size (E)\n+                 and then not Is_Atomic (E)\n+               then\n+                  Set_Alignment (E, Alignment (Component_Type (E)));\n+               end if;\n+            end;\n \n          --  For a class-wide type, the corresponding specific type is\n          --  frozen as well (RM 13.14(15))\n@@ -3628,14 +3665,18 @@ package body Freeze is\n       --  Returns size of type with given bounds. Also leaves these\n       --  bounds set as the current bounds of the Typ.\n \n+      -----------\n+      -- Fsize --\n+      -----------\n+\n       function Fsize (Lov, Hiv : Ureal) return Nat is\n       begin\n          Set_Realval (Lo, Lov);\n          Set_Realval (Hi, Hiv);\n          return Minimum_Size (Typ);\n       end Fsize;\n \n-   --  Start of processing for Freeze_Fixed_Point_Type;\n+   --  Start of processing for Freeze_Fixed_Point_Type\n \n    begin\n       --  If Esize of a subtype has not previously been set, set it now"}, {"sha": "1ac0e56050ab45c22277c237cd5c81c0b6a509e0", "filename": "gcc/ada/g-debpoo.ads", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-debpoo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-debpoo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -32,59 +32,59 @@\n ------------------------------------------------------------------------------\n \n --  This packages provides a special implementation of the Ada95 storage pools.\n---\n+\n --  The goal of this debug pool is to detect incorrect uses of memory\n --  (multiple deallocations, access to invalid memory,...). Errors are reported\n --  in one of two ways: either by immediately raising an exception, or by\n --  printing a message on standard output.\n---\n+\n --  You need to instrument your code to use this package: for each access type\n --  you want to monitor, you need to add a clause similar to:\n---\n+\n --      type Integer_Access is access Integer;\n --      for Integer_Access'Storage_Pool use Pool;\n \n --  where Pool is a tagged object declared with\n --\n --      Pool : GNAT.Debug_Pools.Debug_Pool;\n---\n+\n --  This package was designed to be as efficient as possible, but still has an\n --  impact on the performance of your code, which depends on the number of\n --  allocations, deallocations and, somewhat less, dereferences that your\n --  application performs.\n---\n+\n --  For each faulty memory use, this debug pool will print several lines\n --  of information, including things like the location where the memory\n --  was initially allocated, the location where it was freed etc.\n---\n+\n --  Physical allocations and deallocations are done through the usual system\n --  calls. However, in order to provide proper checks, the debug pool will not\n --  release the memory immediately. It keeps released memory around (the amount\n --  kept around is configurable) so that it can distinguish between memory that\n --  has not been allocated and memory that has been allocated but freed. This\n --  also means that this memory cannot be reallocated, preventing what would\n --  otherwise be a false indication that freed memory is now allocated.\n---\n+\n --  In addition, this package presents several subprograms that help analyze\n --  the behavior of your program, by reporting memory leaks, the total amount\n --  of memory that was allocated. The pool is also designed to work correctly\n --  in conjunction with gnatmem.\n---\n+\n --  Finally, a subprogram Print_Pool is provided for use from the debugger.\n---\n+\n --  Limitations\n --  ===========\n---\n+\n --  Current limitation of this debug pool: if you use this debug pool for a\n --  general access type (\"access all\"), the pool might report invalid\n --  dereferences if the access object is pointing to another object on the\n --  stack which was not allocated through a call to \"new\".\n---\n+\n --  This debug pool will respect all alignments specified in your code, but\n --  it does that by aligning all objects using Standard'Maximum_Alignment.\n --  This allows faster checks, and limits the performance impact of using\n --  this pool.\n---\n+\n \n with System;                  use System;\n with System.Storage_Elements; use System.Storage_Elements;"}, {"sha": "a3d63d90ae8e38a70860b6feac91738f811b7b88", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -43,6 +43,8 @@ package body GNAT.OS_Lib is\n    --  Note: OpenVMS should be a constant, but it cannot be, because it\n    --        prevents bootstrapping on some platforms.\n \n+   On_Windows : constant Boolean := Directory_Separator = '\\';\n+\n    pragma Import (Ada, OpenVMS, \"system__openvms\");\n    --  Needed to avoid doing useless checks when non on a VMS platform (see\n    --  Normalize_Pathname).\n@@ -1584,8 +1586,9 @@ package body GNAT.OS_Lib is\n \n                --  Remove trailing directory separator, if any\n \n-               if Result (Last) = '/' or else\n-                  Result (Last) = Directory_Separator\n+               if Last > 1 and then\n+                 (Result (Last) = '/' or else\n+                  Result (Last) = Directory_Separator)\n                then\n                   Last := Last - 1;\n                end if;\n@@ -1602,13 +1605,26 @@ package body GNAT.OS_Lib is\n \n             Last := S1'Last;\n \n-            if S1 (Last) = '/' or else S1 (Last) = Directory_Separator then\n-               Last := Last - 1;\n+            if Last > 1\n+              and then (S1 (Last) = '/'\n+                          or else\n+                        S1 (Last) = Directory_Separator)\n+            then\n+               --  Special case for Windows: C:\\\n+\n+               if Last = 3\n+                 and then S1 (1) /= Directory_Separator\n+                 and then S1 (2) = ':'\n+               then\n+                  null;\n+\n+               else\n+                  Last := Last - 1;\n+               end if;\n             end if;\n \n             return S1 (1 .. Last);\n          end if;\n-\n       end Final_Value;\n \n    --  Start of processing for Normalize_Pathname\n@@ -1666,13 +1682,23 @@ package body GNAT.OS_Lib is\n          end loop;\n       end if;\n \n-      --  Resolving logical names from VMS.\n-      --  If we have a Unix path on VMS such as /temp/..., and TEMP is a\n+      --  Resolve directory names for VMS and Windows\n+\n+      --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a\n       --  logical name, we need to resolve this logical name.\n-      --  We find the directory, change to it, get the current directory,\n-      --  and change the directory to this value.\n \n-      if OpenVMS and then Path_Buffer (1) = '/' then\n+      --  On Windows, if we have an absolute path starting with a directory\n+      --  separator, we need to have the drive letter appended in front.\n+\n+      --  For both platforms, Get_Current_Dir will return a suitable\n+      --  directory name (logical names resolved on VMS, path starting with\n+      --  a drive letter on Windows). So we find the directory, change to it,\n+      --  call Get_Current_Dir and change the directory to the returned value.\n+      --  Then, of course, we return to the previous directory.\n+\n+      if (OpenVMS or On_Windows)\n+        and then Path_Buffer (1) = Directory_Separator\n+      then\n          declare\n             Cur_Dir : String := Get_Directory (\"\");\n             --  Save the current directory, so that we can change dir back to\n@@ -1685,21 +1711,21 @@ package body GNAT.OS_Lib is\n             --  set to ASCII.NUL to call chdir.\n \n             Pos : Positive := End_Path;\n-            --  Position of the last directory separator ('/')\n+            --  Position of the last directory separator\n \n             Status : Integer;\n             --  Value returned by chdir\n \n          begin\n-            --  Look for the last '/'\n+            --  Look for the last directory separator\n \n-            while Path (Pos) /= '/' loop\n+            while Path (Pos) /= Directory_Separator loop\n                Pos := Pos - 1;\n             end loop;\n \n-            --  Get the previous character that is not a '/'\n+            --  Get the previous character that is not a directory separator\n \n-            while Pos > 1 and then Path (Pos) = '/' loop\n+            while Pos > 1 and then Path (Pos) = Directory_Separator loop\n                Pos := Pos - 1;\n             end loop;\n \n@@ -1934,7 +1960,6 @@ package body GNAT.OS_Lib is\n         (Name  : C_File_Name;\n          Fmode : Mode) return File_Descriptor;\n       pragma Import (C, C_Open_Read, \"__gnat_open_read\");\n-\n    begin\n       return C_Open_Read (Name, Fmode);\n    end Open_Read;\n@@ -1944,7 +1969,6 @@ package body GNAT.OS_Lib is\n       Fmode : Mode) return File_Descriptor\n    is\n       C_Name : String (1 .. Name'Length + 1);\n-\n    begin\n       C_Name (1 .. Name'Length) := Name;\n       C_Name (C_Name'Last)      := ASCII.NUL;\n@@ -1963,7 +1987,6 @@ package body GNAT.OS_Lib is\n         (Name  : C_File_Name;\n          Fmode : Mode) return File_Descriptor;\n       pragma Import (C, C_Open_Read_Write, \"__gnat_open_rw\");\n-\n    begin\n       return C_Open_Read_Write (Name, Fmode);\n    end Open_Read_Write;\n@@ -1973,7 +1996,6 @@ package body GNAT.OS_Lib is\n       Fmode : Mode) return File_Descriptor\n    is\n       C_Name : String (1 .. Name'Length + 1);\n-\n    begin\n       C_Name (1 .. Name'Length) := Name;\n       C_Name (C_Name'Last)      := ASCII.NUL;\n@@ -2005,9 +2027,7 @@ package body GNAT.OS_Lib is\n    is\n       function rename (From, To : Address) return Integer;\n       pragma Import (C, rename, \"rename\");\n-\n       R : Integer;\n-\n    begin\n       R := rename (Old_Name, New_Name);\n       Success := (R = 0);\n@@ -2020,14 +2040,11 @@ package body GNAT.OS_Lib is\n    is\n       C_Old_Name : String (1 .. Old_Name'Length + 1);\n       C_New_Name : String (1 .. New_Name'Length + 1);\n-\n    begin\n       C_Old_Name (1 .. Old_Name'Length) := Old_Name;\n       C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;\n-\n       C_New_Name (1 .. New_Name'Length) := New_Name;\n       C_New_Name (C_New_Name'Last)      := ASCII.NUL;\n-\n       Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);\n    end Rename_File;\n \n@@ -2062,7 +2079,6 @@ package body GNAT.OS_Lib is\n    is\n       Junk   : Process_Id;\n       Result : Integer;\n-\n    begin\n       Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);\n       return Result;"}, {"sha": "c7ad39481f557192c4683ca483a3f9de00c86ea2", "filename": "gcc/ada/g-traceb.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-traceb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-traceb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-traceb.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1999-2002 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,6 +42,10 @@\n --  These code locations may be converted to corresponding source locations\n --  using the external addr2line utility, or from within GDB.\n \n+--  In order to use this facility, in some cases the binder must be invoked\n+--  with -E switch (store the backtrace with exception occurence). Please\n+--  refer to gnatbind documentation for more information.\n+\n --  To analyze the code locations later using addr2line or gdb, the necessary\n --  units must be compiled with the debugging switch -g in the usual manner.\n --  Note that it is not necessary to compile with -g to use Call_Chain. In"}, {"sha": "aa899d93179c799c46616eb7e6830780df0514c0", "filename": "gcc/ada/g-trasym.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-trasym.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fg-trasym.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -40,6 +40,10 @@\n --  been compiled with debugging information turned on, since this information\n --  is used to build a symbolic traceback.\n \n+--  It is also in some cases necessary to invoke the binder\n+--  with -E switch (store the backtrace with exception occurence). Please\n+--  refer to gnatbind documentation for more information.\n+\n --  In order to retrieve symbolic information, functions in this package will\n --  read on disk all the debug information of the executable file (found via\n --  Argument (0), so any path information needed to read the executable file"}, {"sha": "c3753d19cd7640b41585c51244c860fa4566441b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -2224,6 +2224,13 @@ users guide) in conjunction with pragma @code{Initialize_Scalars}\n provides a powerful new tool to assist in the detection of problems\n caused by uninitialized variables.\n \n+Note: the use of @code{Initialize_Scalars} has a fairly extensive\n+effect on the generated code. This may cause your code to be\n+substantially larger. It may also cause an increase in the amount\n+of stack required, so it is probably a good idea to turn on stack\n+checking (see description of stack checking in the GNAT users guide)\n+when using this pragma.\n+\n @node Pragma Inline_Always\n @unnumberedsec Pragma Inline_Always\n @findex Inline_Always\n@@ -9442,15 +9449,19 @@ thus the same lack of restriction applies.  For example, if you declare:\n then a component clause for a component of type R may start on any\n specified bit boundary, and may specify a value of 49 bits or greater.\n \n+Packed bit arrays that are longer than 64 bits must always be placed\n+on a storage unit (byte) boundary. Any component clause that does not\n+meet this requirement will be rejected.\n+\n The rules for other types are different for GNAT 3 and GNAT 5 versions\n (based on GCC 2 and GCC 3 respectively). In GNAT 5, larger components\n+(other than packed arrays)\n may also be placed on arbitrary boundaries, so for example, the following\n is permitted:\n \n @smallexample @c ada\n-   type R is array (1 .. 79) of Boolean;\n-   pragma Pack (R);\n-   for R'Size use 79;\n+   type R is array (1 .. 10) of Boolean;\n+   for R'Size use 80;\n \n    type Q is record\n       G, H : Boolean;\n@@ -9460,8 +9471,8 @@ is permitted:\n    for Q use record\n       G at 0 range  0 ..   0;\n       H at 0 range  1 ..   1;\n-      L at 0 range  2 ..  80;\n-      R at 0 range 81 .. 159;\n+      L at 0 range  2 ..  81;\n+      R at 0 range 82 .. 161;\n    end record;\n @end smallexample\n "}, {"sha": "ff9358d2d7978c08aa4160760f4045ad83c74d91", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -5429,6 +5429,14 @@ Clear :\n @end cartouche\n @end smallexample\n \n+@item ^Lnnn^MAX_NESTING=nnn^\n+@emph{Set maximum nesting level}\n+If the sequence ^Lnnn^MAX_NESTING=nnn^, where nnn is a decimal number in\n+the range 0-999, appears in the string after @option{-gnaty} then the\n+maximum level of nesting of constructs (including subprograms, loops,\n+blocks, packages, and conditionals) may not exceed the given value. A\n+value of zero disconnects this style check.\n+\n @item ^m^LINE_LENGTH^\n @emph{Check maximum line length.}\n If the ^letter m^word LINE_LENGTH^ appears in the string after @option{-gnaty}\n@@ -12447,19 +12455,11 @@ library-related attributes are checked only for such project files.\n \n The @code{Library_Kind} attribute has a string value that must be one of the\n following (case insensitive): @code{\"static\"}, @code{\"dynamic\"} or\n-@code{\"relocatable\"}. If this attribute is not specified, the library is a\n-static library, that is an archive of object files that can be potentially\n-linked into an static executable. Otherwise, the library may be dynamic or\n+@code{\"relocatable\"} (which is a synonym for @code{\"dynamic\"}). If this\n+attribute is not specified, the library is a static library, that is\n+an archive of object files that can be potentially linked into an\n+static executable. Otherwise, the library may be dynamic or\n relocatable, that is a library that is loaded only at the start of execution.\n-Depending on the operating system, there may or may not be a distinction\n-between dynamic and relocatable libraries. For Unix and VMS Unix there is no\n-such distinction.\n-\n-@ifset unw\n-On Windows @code{\"relocatable\"} will build a relocatable @code{DLL}\n-and @code{\"dynamic\"} will build a non-relocatable @code{DLL}.\n-@pxref{Introduction to Dynamic Link Libraries (DLLs)}.\n-@end ifset\n \n If you need to build both a static and a dynamic library, you should use two\n different object directories, since in some cases some extra code needs to\n@@ -14870,6 +14870,14 @@ contains only one file to reformat\n The additional @command{gnatpp} switches are defined in this subsection.\n \n @table @option\n+@item ^-files @var{filename}^/FILES=@var{output_file}^\n+@cindex @option{^-files^/FILES^} (@code{gnatpp})\n+Take the argument source files from the specified file. This file should be an\n+ordinary textual file containing file names separated by spaces or\n+line breaks. You can use this switch more then once in the same call to\n+@command{gnatpp}. You also can combine this switch with explicit list of\n+files.\n+\n @item ^-v^/VERBOSE^\n @cindex @option{^-v^/VERBOSE^} (@code{gnatpp})\n Verbose mode;\n@@ -16034,6 +16042,13 @@ Only output information about source files.\n @cindex @option{^-u^/OUTPUT=UNITS^} (@code{gnatls})\n Only output information about compilation units.\n \n+@item ^-files^/FILES^=@var{file}\n+@cindex @option{^-files^/FILES^} (@code{gnatls})\n+Take as arguments the files listed in text file @var{file}.\n+Text file @var{file} may contain empty lines that are ignored.\n+Each non empty line should contain the name of an existing file.\n+Several such switches may be specified simultaneously.\n+\n @item ^-aO^/OBJECT_SEARCH=^@var{dir}\n @itemx ^-aI^/SOURCE_SEARCH=^@var{dir}\n @itemx ^-I^/SEARCH=^@var{dir}"}, {"sha": "3a0e5e4a7f18d86e47b5d70ca9499746e4bba9cd", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 551, "deletions": 341, "changes": 892, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -39,6 +39,7 @@ with Prj.Env;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Pars;\n with Prj.Util; use Prj.Util;\n+with Sinput.P;\n with Snames;   use Snames;\n with Table;\n with Types;    use Types;\n@@ -61,11 +62,17 @@ procedure GNATCmd is\n    Current_Verbosity : Prj.Verbosity := Prj.Default;\n    Tool_Package_Name : Name_Id       := No_Name;\n \n+   Old_Project_File_Used : Boolean := False;\n    --  This flag indicates a switch -p (for gnatxref and gnatfind) for\n    --  an old fashioned project file. -p cannot be used in conjonction\n    --  with -P.\n \n-   Old_Project_File_Used : Boolean := False;\n+   Max_Files_On_The_Command_Line : constant := 30; --  Arbitrary\n+\n+   Temp_File_Name : String_Access := null;\n+   --  The name of the temporary text file to put a list of source/object\n+   --  files to pass to a tool, when there are more than\n+   --  Max_Files_On_The_Command_Line files.\n \n    --  A table to keep the switches from the project file\n \n@@ -145,6 +152,19 @@ procedure GNATCmd is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Check_Files;\n+   --  For GNAT LIST, GNAT PRETTY and GNAT METRIC, check if a project\n+   --  file is specified, without any file arguments. If it is the case,\n+   --  invoke the GNAT tool with the proper list of files, derived from\n+   --  the sources of the project.\n+\n+   function Check_Project\n+     (Project      : Project_Id;\n+      Root_Project : Project_Id) return Boolean;\n+   --  Returns True if Project = Root_Project.\n+   --  For GNAT METRIC, also returns True if Project is extended by\n+   --  Root_Project.\n+\n    procedure Check_Relative_Executable (Name : in out String_Access);\n    --  Check if an executable is specified as a relative path.\n    --  If it is, and the path contains directory information, fail.\n@@ -168,6 +188,9 @@ procedure GNATCmd is\n    procedure Non_VMS_Usage;\n    --  Display usage for platforms other than VMS\n \n+   procedure Process_Link;\n+   --  Process GNAT LINK, when there is a project file specified.\n+\n    procedure Set_Library_For\n      (Project             : Project_Id;\n       There_Are_Libraries : in out Boolean);\n@@ -186,6 +209,214 @@ procedure GNATCmd is\n    --  If it is and it includes directory information, prepend the path with\n    --  Parent.This subprogram is only called when using project files.\n \n+   -----------------\n+   -- Check_Files --\n+   -----------------\n+\n+   procedure Check_Files is\n+      Add_Sources : Boolean := True;\n+      Unit_Data   : Prj.Com.Unit_Data;\n+      Subunit     : Boolean := False;\n+\n+   begin\n+      --  Check if there is at least one argument that is not a switch\n+\n+      for Index in 1 .. Last_Switches.Last loop\n+         if Last_Switches.Table (Index) (1) /= '-' then\n+            Add_Sources := False;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  If all arguments were switches, add the path names of\n+      --  all the sources of the main project.\n+\n+      if Add_Sources then\n+         declare\n+            Current_Last : constant Integer := Last_Switches.Last;\n+            use Prj.Com;\n+\n+         begin\n+            for Unit in 1 .. Prj.Com.Units.Last loop\n+               Unit_Data := Prj.Com.Units.Table (Unit);\n+\n+               --  For gnatls, we only need to put the library units,\n+               --  body or spec, but not the subunits.\n+\n+               if The_Command = List then\n+                  if\n+                    Unit_Data.File_Names (Body_Part).Name /= No_Name\n+                  then\n+                     --  There is a body; check if it is for this\n+                     --  project.\n+\n+                     if Unit_Data.File_Names (Body_Part).Project =\n+                       Project\n+                     then\n+                        Subunit := False;\n+\n+                        if Unit_Data.File_Names (Specification).Name =\n+                          No_Name\n+                        then\n+                           --  We have a body with no spec: we need\n+                           --  to check if this is a subunit, because\n+                           --  gnatls will complain about subunits.\n+\n+                           declare\n+                              Src_Ind : Source_File_Index;\n+\n+                           begin\n+                              Src_Ind := Sinput.P.Load_Project_File\n+                                (Get_Name_String\n+                                   (Unit_Data.File_Names\n+                                      (Body_Part).Path));\n+\n+                              Subunit :=\n+                                Sinput.P.Source_File_Is_Subunit\n+                                  (Src_Ind);\n+                           end;\n+                        end if;\n+\n+                        if not Subunit then\n+                           Last_Switches.Increment_Last;\n+                           Last_Switches.Table (Last_Switches.Last) :=\n+                             new String'\n+                               (Get_Name_String\n+                                    (Unit_Data.File_Names\n+                                         (Body_Part).Display_Name));\n+                        end if;\n+                     end if;\n+\n+                  elsif Unit_Data.File_Names (Specification).Name /=\n+                    No_Name\n+                  then\n+                     --  We have a spec with no body; check if it is\n+                     --  for this project.\n+\n+                     if Unit_Data.File_Names (Specification).Project =\n+                       Project\n+                     then\n+                        Last_Switches.Increment_Last;\n+                        Last_Switches.Table (Last_Switches.Last) :=\n+                          new String'\n+                            (Get_Name_String\n+                                 (Unit_Data.File_Names\n+                                      (Specification).Display_Name));\n+                     end if;\n+                  end if;\n+\n+               else\n+                  --  For gnatpp and gnatmetric, put all sources\n+                  --  of the project.\n+\n+                  for Kind in Prj.Com.Spec_Or_Body loop\n+\n+                     --  Put only sources that belong to the main\n+                     --  project.\n+\n+                     if Check_Project\n+                          (Unit_Data.File_Names (Kind).Project, Project)\n+                     then\n+                        Last_Switches.Increment_Last;\n+                        Last_Switches.Table (Last_Switches.Last) :=\n+                          new String'\n+                            (Get_Name_String\n+                                 (Unit_Data.File_Names\n+                                      (Kind).Display_Path));\n+                     end if;\n+                  end loop;\n+               end if;\n+            end loop;\n+\n+            --  If the list of files is too long, create a temporary\n+            --  text file that lists these files, and pass this temp\n+            --  file to gnatpp or gnatmetric using switch -files=.\n+\n+            if Last_Switches.Last - Current_Last >\n+              Max_Files_On_The_Command_Line\n+            then\n+               declare\n+                  Temp_File_FD : File_Descriptor;\n+                  Buffer       : String (1 .. 1_000);\n+                  Len          : Natural;\n+                  OK           : Boolean := True;\n+\n+               begin\n+                  Create_Temp_File (Temp_File_FD, Temp_File_Name);\n+\n+                  if Temp_File_Name /= null then\n+                     for Index in Current_Last + 1 ..\n+                       Last_Switches.Last\n+                     loop\n+                        Len := Last_Switches.Table (Index)'Length;\n+                        Buffer (1 .. Len) :=\n+                          Last_Switches.Table (Index).all;\n+                        Len := Len + 1;\n+                        Buffer (Len) := ASCII.LF;\n+                        Buffer (Len + 1) := ASCII.NUL;\n+                        OK :=\n+                          Write (Temp_File_FD,\n+                                 Buffer (1)'Address,\n+                                 Len) = Len;\n+                        exit when not OK;\n+                     end loop;\n+\n+                     if OK then\n+                        Close (Temp_File_FD, OK);\n+                     else\n+                        Close (Temp_File_FD, OK);\n+                        OK := False;\n+                     end if;\n+\n+                     --  If there were any problem creating the temp\n+                     --  file, then pass the list of files.\n+\n+                     if OK then\n+\n+                        --  Replace the list of files with\n+                        --  \"-files=<temp file name>\".\n+\n+                        Last_Switches.Set_Last (Current_Last + 1);\n+                        Last_Switches.Table (Last_Switches.Last) :=\n+                          new String'(\"-files=\" & Temp_File_Name.all);\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n+      end if;\n+   end Check_Files;\n+\n+   -------------------\n+   -- Check_Project --\n+   -------------------\n+\n+   function Check_Project\n+     (Project      : Project_Id;\n+      Root_Project : Project_Id) return Boolean\n+   is\n+   begin\n+      if Project = Root_Project then\n+         return True;\n+\n+      elsif The_Command = Metric then\n+         declare\n+            Data : Project_Data := Projects.Table (Root_Project);\n+\n+         begin\n+            while Data.Extends /= No_Project loop\n+               if Project = Data.Extends then\n+                  return True;\n+               end if;\n+\n+               Data := Projects.Table (Data.Extends);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Check_Project;\n+\n    -------------------------------\n    -- Check_Relative_Executable --\n    -------------------------------\n@@ -256,6 +487,13 @@ procedure GNATCmd is\n             end if;\n          end loop;\n       end if;\n+\n+      --  If a temporary text file that contains a list of files for a tool\n+      --  has been created, delete this temporary file.\n+\n+      if Temp_File_Name /= null then\n+         Delete_File (Temp_File_Name.all, Success);\n+      end if;\n    end Delete_Temp_Config_Files;\n \n    -----------\n@@ -273,6 +511,288 @@ procedure GNATCmd is\n       return 0;\n    end Index;\n \n+   ------------------\n+   -- Process_Link --\n+   ------------------\n+\n+   procedure Process_Link is\n+      Look_For_Executable  : Boolean := True;\n+      There_Are_Libraries  : Boolean := False;\n+      Path_Option          : constant String_Access :=\n+                               MLib.Linker_Library_Path_Option;\n+      Prj                  : Project_Id := Project;\n+      Arg                  : String_Access;\n+      Last                 : Natural := 0;\n+      Skip_Executable      : Boolean := False;\n+\n+   begin\n+      --  Add the default search directories, to be able to find\n+      --  libgnat in call to MLib.Utl.Lib_Directory.\n+\n+      Add_Default_Search_Dirs;\n+\n+      Library_Paths.Set_Last (0);\n+\n+      --  Check if there are library project files\n+\n+      if MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None then\n+         Set_Libraries (Project, There_Are_Libraries);\n+      end if;\n+\n+      --  If there are, add the necessary additional switches\n+\n+      if There_Are_Libraries then\n+\n+         --  Add -L<lib_dir> -lgnarl -lgnat -Wl,-rpath,<lib_dir>\n+\n+         Last_Switches.Increment_Last;\n+         Last_Switches.Table (Last_Switches.Last) :=\n+           new String'(\"-L\" & MLib.Utl.Lib_Directory);\n+         Last_Switches.Increment_Last;\n+         Last_Switches.Table (Last_Switches.Last) :=\n+           new String'(\"-lgnarl\");\n+         Last_Switches.Increment_Last;\n+         Last_Switches.Table (Last_Switches.Last) :=\n+           new String'(\"-lgnat\");\n+\n+         --  If Path_Option is not null, create the switch\n+         --  (\"-Wl,-rpath,\" or equivalent) with all the library dirs\n+         --  plus the standard GNAT library dir.\n+\n+         if Path_Option /= null then\n+            declare\n+               Option  : String_Access;\n+               Length  : Natural := Path_Option'Length;\n+               Current : Natural;\n+\n+            begin\n+               --  First, compute the exact length for the switch\n+\n+               for Index in\n+                 Library_Paths.First .. Library_Paths.Last\n+               loop\n+                  --  Add the length of the library dir plus one\n+                  --  for the directory separator.\n+\n+                  Length :=\n+                    Length +\n+                      Library_Paths.Table (Index)'Length + 1;\n+               end loop;\n+\n+               --  Finally, add the length of the standard GNAT\n+               --  library dir.\n+\n+               Length := Length + MLib.Utl.Lib_Directory'Length;\n+               Option := new String (1 .. Length);\n+               Option (1 .. Path_Option'Length) := Path_Option.all;\n+               Current := Path_Option'Length;\n+\n+               --  Put each library dir followed by a dir separator\n+\n+               for Index in\n+                 Library_Paths.First .. Library_Paths.Last\n+               loop\n+                  Option\n+                    (Current + 1 ..\n+                       Current +\n+                         Library_Paths.Table (Index)'Length) :=\n+                      Library_Paths.Table (Index).all;\n+                  Current :=\n+                    Current +\n+                      Library_Paths.Table (Index)'Length + 1;\n+                  Option (Current) := Path_Separator;\n+               end loop;\n+\n+               --  Finally put the standard GNAT library dir\n+\n+               Option\n+                 (Current + 1 ..\n+                    Current + MLib.Utl.Lib_Directory'Length) :=\n+                   MLib.Utl.Lib_Directory;\n+\n+               --  And add the switch to the last switches\n+\n+               Last_Switches.Increment_Last;\n+               Last_Switches.Table (Last_Switches.Last) :=\n+                 Option;\n+            end;\n+         end if;\n+      end if;\n+\n+      --  Check if the first ALI file specified can be found, either\n+      --  in the object directory of the main project or in an object\n+      --  directory of a project file extended by the main project.\n+      --  If the ALI file can be found, replace its name with its\n+      --  absolute path.\n+\n+      Skip_Executable := False;\n+\n+      Switch_Loop : for J in 1 .. Last_Switches.Last loop\n+\n+         --  If we have an executable just reset the flag\n+\n+         if Skip_Executable then\n+            Skip_Executable := False;\n+\n+         --  If -o, set flag so that next switch is not processed\n+\n+         elsif Last_Switches.Table (J).all = \"-o\" then\n+            Skip_Executable := True;\n+\n+         --  Normal case\n+\n+         else\n+            declare\n+               Switch         : constant String :=\n+                                  Last_Switches.Table (J).all;\n+\n+               ALI_File       : constant String (1 .. Switch'Length + 4) :=\n+                                  Switch & \".ali\";\n+\n+               Test_Existence : Boolean := False;\n+\n+            begin\n+               Last := Switch'Length;\n+\n+               --  Skip real switches\n+\n+               if Switch'Length /= 0\n+                 and then Switch (Switch'First) /= '-'\n+               then\n+                  --  Append \".ali\" if file name does not end with it\n+\n+                  if Switch'Length <= 4\n+                    or else Switch (Switch'Last - 3 .. Switch'Last)\n+                    /= \".ali\"\n+                  then\n+                     Last := ALI_File'Last;\n+                  end if;\n+\n+                  --  If file name includes directory information,\n+                  --  stop if ALI file exists.\n+\n+                  if Is_Absolute_Path (ALI_File (1 .. Last)) then\n+                     Test_Existence := True;\n+\n+                  else\n+                     for K in Switch'Range loop\n+                        if Switch (K) = '/' or else\n+                          Switch (K) = Directory_Separator\n+                        then\n+                           Test_Existence := True;\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n+\n+                  if Test_Existence then\n+                     if Is_Regular_File (ALI_File (1 .. Last)) then\n+                        exit Switch_Loop;\n+                     end if;\n+\n+                  --  Look in object directories if ALI file exists\n+\n+                  else\n+                     Project_Loop : loop\n+                        declare\n+                           Dir : constant String :=\n+                                   Get_Name_String\n+                                     (Projects.Table (Prj).\n+                                              Object_Directory);\n+                        begin\n+                           if Is_Regular_File\n+                                (Dir &\n+                                 Directory_Separator &\n+                                 ALI_File (1 .. Last))\n+                           then\n+                              --  We have found the correct project, so we\n+                              --  replace the file with the absolute path.\n+\n+                              Last_Switches.Table (J) :=\n+                                new String'\n+                                  (Dir & Directory_Separator &\n+                                   ALI_File (1 .. Last));\n+\n+                              --  And we are done\n+\n+                              exit Switch_Loop;\n+                           end if;\n+                        end;\n+\n+                        --  Go to the project being extended,\n+                        --  if any.\n+\n+                        Prj := Projects.Table (Prj).Extends;\n+                        exit Project_Loop when Prj = No_Project;\n+                     end loop Project_Loop;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end loop Switch_Loop;\n+\n+      --  If a relative path output file has been specified, we add\n+      --  the exec directory.\n+\n+      for J in reverse 1 .. Last_Switches.Last - 1 loop\n+         if Last_Switches.Table (J).all = \"-o\" then\n+            Check_Relative_Executable\n+              (Name => Last_Switches.Table (J + 1));\n+            Look_For_Executable := False;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      if Look_For_Executable then\n+         for J in reverse 1 .. First_Switches.Last - 1 loop\n+            if First_Switches.Table (J).all = \"-o\" then\n+               Look_For_Executable := False;\n+               Check_Relative_Executable\n+                 (Name => First_Switches.Table (J + 1));\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If no executable is specified, then find the name\n+      --  of the first ALI file on the command line and issue\n+      --  a -o switch with the absolute path of the executable\n+      --  in the exec directory.\n+\n+      if Look_For_Executable then\n+         for J in 1 .. Last_Switches.Last loop\n+            Arg  := Last_Switches.Table (J);\n+            Last := 0;\n+\n+            if Arg'Length /= 0 and then Arg (Arg'First) /= '-' then\n+               if Arg'Length > 4\n+                 and then Arg (Arg'Last - 3 .. Arg'Last) = \".ali\"\n+               then\n+                  Last := Arg'Last - 4;\n+\n+               elsif Is_Regular_File (Arg.all & \".ali\") then\n+                  Last := Arg'Last;\n+               end if;\n+\n+               if Last /= 0 then\n+                  Last_Switches.Increment_Last;\n+                  Last_Switches.Table (Last_Switches.Last) :=\n+                    new String'(\"-o\");\n+                  Get_Name_String\n+                    (Projects.Table (Project).Exec_Directory);\n+                  Last_Switches.Increment_Last;\n+                  Last_Switches.Table (Last_Switches.Last) :=\n+                    new String'(Name_Buffer (1 .. Name_Len) &\n+                                Directory_Separator &\n+                                Base_Name (Arg (Arg'First .. Last)) &\n+                                Get_Executable_Suffix.all);\n+                  exit;\n+               end if;\n+            end if;\n+         end loop;\n+      end if;\n+   end Process_Link;\n+\n    ---------------------\n    -- Set_Library_For --\n    ---------------------\n@@ -317,7 +837,6 @@ procedure GNATCmd is\n               new String'(Get_Name_String\n                             (Projects.Table (Project).Library_Dir));\n          end if;\n-\n       end if;\n    end Set_Library_For;\n \n@@ -341,9 +860,9 @@ procedure GNATCmd is\n \n             if Sw (1) = '-' then\n                if Sw'Length >= 3\n-                 and then (Sw (2) = 'A'\n-                           or else Sw (2) = 'I'\n-                           or else Sw (2) = 'L')\n+                 and then (Sw (2) = 'A' or else\n+                           Sw (2) = 'I' or else\n+                           Sw (2) = 'L')\n                then\n                   Start := 3;\n \n@@ -352,9 +871,9 @@ procedure GNATCmd is\n                   end if;\n \n                elsif Sw'Length >= 4\n-                 and then (Sw (2 .. 3) = \"aL\"\n-                           or else Sw (2 .. 3) = \"aO\"\n-                           or else Sw (2 .. 3) = \"aI\")\n+                 and then (Sw (2 .. 3) = \"aL\" or else\n+                           Sw (2 .. 3) = \"aO\" or else\n+                           Sw (2 .. 3) = \"aI\")\n                then\n                   Start := 4;\n \n@@ -937,301 +1456,7 @@ begin\n          end if;\n \n          if The_Command = Link then\n-\n-            --  Add the default search directories, to be able to find\n-            --  libgnat in call to MLib.Utl.Lib_Directory.\n-\n-            Add_Default_Search_Dirs;\n-\n-            declare\n-               There_Are_Libraries  : Boolean := False;\n-               Path_Option : constant String_Access :=\n-                               MLib.Linker_Library_Path_Option;\n-\n-            begin\n-               Library_Paths.Set_Last (0);\n-\n-               --  Check if there are library project files\n-\n-               if MLib.Tgt.Support_For_Libraries /= MLib.Tgt.None then\n-                  Set_Libraries (Project, There_Are_Libraries);\n-               end if;\n-\n-               --  If there are, add the necessary additional switches\n-\n-               if There_Are_Libraries then\n-\n-                  --  Add -L<lib_dir> -lgnarl -lgnat -Wl,-rpath,<lib_dir>\n-\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(\"-L\" & MLib.Utl.Lib_Directory);\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(\"-lgnarl\");\n-                  Last_Switches.Increment_Last;\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(\"-lgnat\");\n-\n-                  --  If Path_Option is not null, create the switch\n-                  --  (\"-Wl,-rpath,\" or equivalent) with all the library dirs\n-                  --  plus the standard GNAT library dir.\n-\n-                  if Path_Option /= null then\n-                     declare\n-                        Option : String_Access;\n-                        Length : Natural := Path_Option'Length;\n-                        Current : Natural;\n-\n-                     begin\n-                        --  First, compute the exact length for the switch\n-\n-                        for Index in\n-                          Library_Paths.First .. Library_Paths.Last\n-                        loop\n-                           --  Add the length of the library dir plus one\n-                           --  for the directory separator.\n-\n-                           Length :=\n-                             Length +\n-                             Library_Paths.Table (Index)'Length + 1;\n-                        end loop;\n-\n-                        --  Finally, add the length of the standard GNAT\n-                        --  library dir.\n-\n-                        Length := Length + MLib.Utl.Lib_Directory'Length;\n-                        Option := new String (1 .. Length);\n-                        Option (1 .. Path_Option'Length) := Path_Option.all;\n-                        Current := Path_Option'Length;\n-\n-                        --  Put each library dir followed by a dir separator\n-\n-                        for Index in\n-                          Library_Paths.First .. Library_Paths.Last\n-                        loop\n-                           Option\n-                             (Current + 1 ..\n-                                Current +\n-                                Library_Paths.Table (Index)'Length) :=\n-                             Library_Paths.Table (Index).all;\n-                           Current :=\n-                             Current +\n-                             Library_Paths.Table (Index)'Length + 1;\n-                           Option (Current) := Path_Separator;\n-                        end loop;\n-\n-                        --  Finally put the standard GNAT library dir\n-\n-                        Option\n-                          (Current + 1 ..\n-                             Current + MLib.Utl.Lib_Directory'Length) :=\n-                          MLib.Utl.Lib_Directory;\n-\n-                        --  And add the switch to the last switches\n-\n-                        Last_Switches.Increment_Last;\n-                        Last_Switches.Table (Last_Switches.Last) :=\n-                          Option;\n-                     end;\n-                  end if;\n-               end if;\n-            end;\n-\n-            --  Check if the first ALI file specified can be found, either\n-            --  in the object directory of the main project or in an object\n-            --  directory of a project file extended by the main project.\n-            --  If the ALI file can be found, replace its name with its\n-            --  absolute path.\n-\n-            declare\n-               Skip_Executable : Boolean := False;\n-\n-            begin\n-               Switch_Loop : for J in 1 .. Last_Switches.Last loop\n-\n-                  --  If we have an executable just reset the flag\n-\n-                  if Skip_Executable then\n-                     Skip_Executable := False;\n-\n-                  --  If -o, set flag so that next switch is not processed\n-\n-                  elsif Last_Switches.Table (J).all = \"-o\" then\n-                     Skip_Executable := True;\n-\n-                  --  Normal case\n-\n-                  else\n-                     declare\n-                        Switch : constant String :=\n-                                   Last_Switches.Table (J).all;\n-\n-                        ALI_File : constant String (1 .. Switch'Length + 4) :=\n-                                     Switch & \".ali\";\n-\n-                        Last           : Natural := Switch'Length;\n-                        Test_Existence : Boolean := False;\n-\n-                     begin\n-                        --  Skip real switches\n-\n-                        if Switch'Length /= 0 and then\n-                          Switch (Switch'First) /= '-'\n-                        then\n-                           --  Append \".ali\" if file name does not end with it\n-\n-                           if Switch'Length <= 4 or else\n-                             Switch (Switch'Last - 3 .. Switch'Last) /= \".ali\"\n-                           then\n-                              Last := ALI_File'Last;\n-                           end if;\n-\n-                           --  If file name includes directory information,\n-                           --  stop if ALI file exists.\n-\n-                           if Is_Absolute_Path (ALI_File (1 .. Last)) then\n-                              Test_Existence := True;\n-\n-                           else\n-                              for K in Switch'Range loop\n-                                 if Switch (K) = '/' or else\n-                                   Switch (K) = Directory_Separator\n-                                 then\n-                                    Test_Existence := True;\n-                                    exit;\n-                                 end if;\n-                              end loop;\n-                           end if;\n-\n-                           if Test_Existence then\n-                              if Is_Regular_File (ALI_File (1 .. Last)) then\n-                                 exit Switch_Loop;\n-                              end if;\n-\n-                           else\n-                              --  Look in the object directories if the ALI\n-                              --  file exists.\n-\n-                              declare\n-                                 Prj : Project_Id := Project;\n-                              begin\n-                                 Project_Loop :\n-                                 loop\n-                                    declare\n-                                       Dir : constant String :=\n-                                         Get_Name_String\n-                                           (Projects.Table (Prj).\n-                                              Object_Directory);\n-                                    begin\n-                                       if Is_Regular_File\n-                                         (Dir & Directory_Separator &\n-                                          ALI_File (1 .. Last))\n-                                       then\n-                                          --  We have found the correct\n-                                          --  project, so we replace the file\n-                                          --  with the absolute path.\n-\n-                                          Last_Switches.Table (J) :=\n-                                            new String'\n-                                              (Dir & Directory_Separator &\n-                                               ALI_File (1 .. Last));\n-\n-                                          --  And we are done\n-\n-                                          exit Switch_Loop;\n-                                       end if;\n-                                    end;\n-\n-                                    --  Go to the project being extended,\n-                                    --  if any.\n-\n-                                    Prj := Projects.Table (Prj).Extends;\n-                                    exit Project_Loop when Prj = No_Project;\n-                                 end loop Project_Loop;\n-                              end;\n-                           end if;\n-                        end if;\n-                     end;\n-                  end if;\n-               end loop Switch_Loop;\n-            end;\n-\n-            --  If a relative path output file has been specified, we add\n-            --  the exec directory.\n-\n-            declare\n-               Look_For_Executable : Boolean := True;\n-\n-            begin\n-\n-               for J in reverse 1 .. Last_Switches.Last - 1 loop\n-                  if Last_Switches.Table (J).all = \"-o\" then\n-                     Check_Relative_Executable\n-                       (Name => Last_Switches.Table (J + 1));\n-                     Look_For_Executable := False;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               if Look_For_Executable then\n-                  for J in reverse 1 .. First_Switches.Last - 1 loop\n-                     if First_Switches.Table (J).all = \"-o\" then\n-                        Look_For_Executable := False;\n-                        Check_Relative_Executable\n-                          (Name => First_Switches.Table (J + 1));\n-                        exit;\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-               --  If no executable is specified, then find the name\n-               --  of the first ALI file on the command line and issue\n-               --  a -o switch with the absolute path of the executable\n-               --  in the exec directory.\n-\n-               if Look_For_Executable then\n-                  for J in 1 .. Last_Switches.Last loop\n-                     declare\n-                        Arg  : constant String_Access :=\n-                                 Last_Switches.Table (J);\n-                        Last : Natural := 0;\n-\n-                     begin\n-                        if Arg'Length /= 0 and then Arg (Arg'First) /= '-' then\n-                           if Arg'Length > 4\n-                             and then Arg (Arg'Last - 3 .. Arg'Last) = \".ali\"\n-                           then\n-                              Last := Arg'Last - 4;\n-\n-                           elsif Is_Regular_File (Arg.all & \".ali\") then\n-                              Last := Arg'Last;\n-                           end if;\n-\n-                           if Last /= 0 then\n-                              declare\n-                                 Executable_Name : constant String :=\n-                                   Base_Name (Arg (Arg'First .. Last));\n-                              begin\n-                                 Last_Switches.Increment_Last;\n-                                 Last_Switches.Table (Last_Switches.Last) :=\n-                                   new String'(\"-o\");\n-                                 Get_Name_String\n-                                   (Projects.Table (Project).Exec_Directory);\n-                                 Last_Switches.Increment_Last;\n-                                 Last_Switches.Table (Last_Switches.Last) :=\n-                                    new String'(Name_Buffer (1 .. Name_Len) &\n-                                                  Directory_Separator &\n-                                                  Executable_Name &\n-                                                  Get_Executable_Suffix.all);\n-                                 exit;\n-                              end;\n-                           end if;\n-                        end if;\n-                     end;\n-                  end loop;\n-               end if;\n-            end;\n+            Process_Link;\n          end if;\n \n          if The_Command = Link or The_Command = Bind then\n@@ -1337,55 +1562,40 @@ begin\n             end;\n          end if;\n \n+         --  For gnatmetric, the generated files should be put in the\n+         --  object directory. This must be the first dwitch, because it may\n+         --  be overriden by a switch in package Metrics in the project file\n+         --  or by a command line option.\n+\n+         if The_Command = Metric then\n+            First_Switches.Increment_Last;\n+            First_Switches.Table (2 .. First_Switches.Last) :=\n+              First_Switches.Table (1 .. First_Switches.Last - 1);\n+            First_Switches.Table (1) :=\n+              new String'(\"-d=\" &\n+                          Get_Name_String\n+                            (Projects.Table (Project).Object_Directory));\n+         end if;\n+\n          --  For gnat pretty and gnat metric, if no file has been put on the\n          --  command line, call the tool with all the sources of the main\n          --  project.\n \n-         if The_Command = Pretty or else The_Command = Metric then\n-            declare\n-               Add_Sources : Boolean := True;\n-               Unit_Data   : Prj.Com.Unit_Data;\n-            begin\n-               --  Check if there is at least one argument that is not a switch\n-\n-               for Index in 1 .. Last_Switches.Last loop\n-                  if Last_Switches.Table (Index)(1) /= '-' then\n-                     Add_Sources := False;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               --  If all arguments were switches, add the path names of\n-               --  all the sources of the main project.\n-\n-               if Add_Sources then\n-                  for Unit in 1 .. Prj.Com.Units.Last loop\n-                     Unit_Data := Prj.Com.Units.Table (Unit);\n-\n-                     for Kind in Prj.Com.Spec_Or_Body loop\n-\n-                        --  Put only sources that belong to the main project\n-\n-                        if Unit_Data.File_Names (Kind).Project = Project then\n-                           Last_Switches.Increment_Last;\n-                           Last_Switches.Table (Last_Switches.Last) :=\n-                             new String'\n-                               (Get_Name_String\n-                                  (Unit_Data.File_Names (Kind).Display_Path));\n-                        end if;\n-                     end loop;\n-                  end loop;\n-               end if;\n-            end;\n+         if The_Command = Pretty or else\n+            The_Command = Metric or else\n+            The_Command = List\n+         then\n+            Check_Files;\n          end if;\n       end if;\n \n       --  Gather all the arguments and invoke the executable\n \n       declare\n          The_Args : Argument_List\n-           (1 .. First_Switches.Last + Last_Switches.Last);\n-         Arg_Num : Natural := 0;\n+                      (1 .. First_Switches.Last + Last_Switches.Last);\n+         Arg_Num  : Natural := 0;\n+\n       begin\n          for J in 1 .. First_Switches.Last loop\n             Arg_Num := Arg_Num + 1;"}, {"sha": "ef35b931f131e18523301dc2b705c3b0e1bce9d2", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1406,12 +1406,16 @@ begin\n                        Units.Table (ALIs.Table (A).First_Unit).Last_Arg\n             loop\n                --  Do not compile with the front end switches except for --RTS\n+               --  if the binder generated file is in Ada.\n \n                declare\n                   Arg : String_Ptr renames Args.Table (Index);\n                begin\n                   if not Is_Front_End_Switch (Arg.all)\n-                    or else Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n+                    or else\n+                      (Ada_Bind_File\n+                        and then Arg'Length > 5\n+                        and then Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\")\n                   then\n                      Binder_Options_From_ALI.Increment_Last;\n                      Binder_Options_From_ALI.Table"}, {"sha": "303560571514d821feca79b94af164cd93a39dc1", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 114, "deletions": 63, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -115,15 +115,11 @@ procedure Gnatls is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Add_Lib_Dir (Dir : String; And_Save : Boolean);\n-   --  Add an object directory, using Osint.Add_Lib_Search_Dir\n-   --  if And_Save is False or keeping in the list First_Lib_Dir,\n-   --  Last_Lib_Dir if And_Save is True.\n+   procedure Add_Lib_Dir (Dir : String);\n+   --  Add an object directory in the list First_Lib_Dir-Last_Lib_Dir\n \n-   procedure Add_Source_Dir (Dir : String; And_Save : Boolean);\n-   --  Add a source directory, using Osint.Add_Src_Search_Dir\n-   --  if And_Save is False or keeping in the list First_Source_Dir,\n-   --  Last_Source_Dir if And_Save is True.\n+   procedure Add_Source_Dir (Dir : String);\n+   --  Add a source directory in the list First_Source_Dir-Last_Source_Dir\n \n    procedure Find_General_Layout;\n    --  Determine the structure of the output (multi columns or not, etc)\n@@ -157,7 +153,7 @@ procedure Gnatls is\n    procedure Reset_Print;\n    --  Reset Print flags properly when selective output is chosen\n \n-   procedure Scan_Ls_Arg (Argv : String; And_Save : Boolean);\n+   procedure Scan_Ls_Arg (Argv : String);\n    --  Scan and process lser specific arguments. Argv is a single argument\n \n    procedure Usage;\n@@ -170,53 +166,43 @@ procedure Gnatls is\n    -- Add_Lib_Dir --\n    -----------------\n \n-   procedure Add_Lib_Dir (Dir : String; And_Save : Boolean) is\n+   procedure Add_Lib_Dir (Dir : String) is\n    begin\n-      if And_Save then\n-         if First_Lib_Dir = null then\n-            First_Lib_Dir :=\n-              new Dir_Data'\n-                (Value => new String'(Dir),\n-                 Next => null);\n-            Last_Lib_Dir := First_Lib_Dir;\n-\n-         else\n-            Last_Lib_Dir.Next :=\n-              new Dir_Data'\n-                (Value => new String'(Dir),\n-                 Next => null);\n-            Last_Lib_Dir := Last_Lib_Dir.Next;\n-         end if;\n+      if First_Lib_Dir = null then\n+         First_Lib_Dir :=\n+           new Dir_Data'\n+             (Value => new String'(Dir),\n+              Next  => null);\n+         Last_Lib_Dir := First_Lib_Dir;\n \n       else\n-         Add_Lib_Search_Dir (Dir);\n+         Last_Lib_Dir.Next :=\n+           new Dir_Data'\n+             (Value => new String'(Dir),\n+              Next  => null);\n+         Last_Lib_Dir := Last_Lib_Dir.Next;\n       end if;\n    end Add_Lib_Dir;\n \n    -- -----------------\n    -- Add_Source_Dir --\n    --------------------\n \n-   procedure Add_Source_Dir (Dir : String; And_Save : Boolean) is\n+   procedure Add_Source_Dir (Dir : String) is\n    begin\n-      if And_Save then\n-         if First_Source_Dir = null then\n-            First_Source_Dir :=\n-              new Dir_Data'\n-                (Value => new String'(Dir),\n-                 Next => null);\n-            Last_Source_Dir := First_Source_Dir;\n-\n-         else\n-            Last_Source_Dir.Next :=\n-              new Dir_Data'\n-                (Value => new String'(Dir),\n-                 Next => null);\n-            Last_Source_Dir := Last_Source_Dir.Next;\n-         end if;\n+      if First_Source_Dir = null then\n+         First_Source_Dir :=\n+           new Dir_Data'\n+             (Value => new String'(Dir),\n+              Next  => null);\n+         Last_Source_Dir := First_Source_Dir;\n \n       else\n-         Add_Src_Search_Dir (Dir);\n+         Last_Source_Dir.Next :=\n+           new Dir_Data'\n+             (Value => new String'(Dir),\n+              Next  => null);\n+         Last_Source_Dir := Last_Source_Dir.Next;\n       end if;\n    end Add_Source_Dir;\n \n@@ -695,7 +681,9 @@ procedure Gnatls is\n    -- Scan_Ls_Arg --\n    -------------------\n \n-   procedure Scan_Ls_Arg (Argv : String; And_Save : Boolean) is\n+   procedure Scan_Ls_Arg (Argv : String) is\n+      FD  : File_Descriptor;\n+      Len : Integer;\n    begin\n       pragma Assert (Argv'First = 1);\n \n@@ -723,23 +711,23 @@ procedure Gnatls is\n          --  Processing for -Idir\n \n          elsif Argv (2) = 'I' then\n-            Add_Source_Dir (Argv (3 .. Argv'Last), And_Save);\n-            Add_Lib_Dir (Argv (3 .. Argv'Last), And_Save);\n+            Add_Source_Dir (Argv (3 .. Argv'Last));\n+            Add_Lib_Dir (Argv (3 .. Argv'Last));\n \n          --  Processing for -aIdir (to gcc this is like a -I switch)\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aI\" then\n-            Add_Source_Dir (Argv (4 .. Argv'Last), And_Save);\n+            Add_Source_Dir (Argv (4 .. Argv'Last));\n \n          --  Processing for -aOdir\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aO\" then\n-            Add_Lib_Dir (Argv (4 .. Argv'Last), And_Save);\n+            Add_Lib_Dir (Argv (4 .. Argv'Last));\n \n          --  Processing for -aLdir (to gnatbind this is like a -aO switch)\n \n          elsif Argv'Length >= 3 and then Argv (2 .. 3) = \"aL\" then\n-            Add_Lib_Dir (Argv (4 .. Argv'Last), And_Save);\n+            Add_Lib_Dir (Argv (4 .. Argv'Last));\n \n          --  Processing for -nostdinc\n \n@@ -761,6 +749,62 @@ procedure Gnatls is\n                when others => null;\n             end case;\n \n+         --  Processing for -files=file\n+\n+         elsif Argv'Length > 7 and then Argv (1 .. 7) = \"-files=\" then\n+            FD := Open_Read (Argv (8 .. Argv'Last), GNAT.OS_Lib.Text);\n+\n+            if FD = Invalid_FD then\n+               Osint.Fail (\"could not find text file \"\"\" &\n+                           Argv (8 .. Argv'Last) & '\"');\n+            end if;\n+\n+            Len := Integer (File_Length (FD));\n+\n+            declare\n+               Buffer : String (1 .. Len + 1);\n+               Index  : Positive := 1;\n+               Last   : Positive;\n+\n+            begin\n+               --  Read the file\n+\n+               Len := Read (FD, Buffer (1)'Address, Len);\n+               Buffer (Buffer'Last) := ASCII.NUL;\n+               Close (FD);\n+\n+               --  Scan the file line by line\n+\n+               while Index < Buffer'Last loop\n+                  --  Find the end of line\n+\n+                  Last := Index;\n+\n+                  while Last <= Buffer'Last\n+                    and then Buffer (Last) /= ASCII.LF\n+                    and then Buffer (Last) /= ASCII.CR\n+                  loop\n+                     Last := Last + 1;\n+                  end loop;\n+\n+                  --  Ignore empty lines\n+\n+                  if Last > Index then\n+                     Add_File (Buffer (Index .. Last - 1));\n+                  end if;\n+\n+                  Index := Last;\n+\n+                  --  Find the beginning of the next line\n+\n+                  while Buffer (Index) = ASCII.CR or else\n+                        Buffer (Index) = ASCII.LF\n+                  loop\n+                     Index := Index + 1;\n+                  end loop;\n+               end loop;\n+            end;\n+\n          --  Processing for --RTS=path\n \n          elsif Argv'Length >= 5 and then Argv (1 .. 5) = \"--RTS\" then\n@@ -849,70 +893,77 @@ procedure Gnatls is\n \n       --  Line for -a\n \n-      Write_Str (\"  -a        also output relevant predefined units\");\n+      Write_Str (\"  -a         also output relevant predefined units\");\n       Write_Eol;\n \n       --  Line for -u\n \n-      Write_Str (\"  -u        output only relevant unit names\");\n+      Write_Str (\"  -u         output only relevant unit names\");\n       Write_Eol;\n \n       --  Line for -h\n \n-      Write_Str (\"  -h        output this help message\");\n+      Write_Str (\"  -h         output this help message\");\n       Write_Eol;\n \n       --  Line for -s\n \n-      Write_Str (\"  -s        output only relevant source names\");\n+      Write_Str (\"  -s         output only relevant source names\");\n       Write_Eol;\n \n       --  Line for -o\n \n-      Write_Str (\"  -o        output only relevant object names\");\n+      Write_Str (\"  -o         output only relevant object names\");\n       Write_Eol;\n \n       --  Line for -d\n \n-      Write_Str (\"  -d        output sources on which specified units depend\");\n+      Write_Str (\"  -d         output sources on which specified units \" &\n+                               \"depend\");\n       Write_Eol;\n \n       --  Line for -v\n \n-      Write_Str (\"  -v        verbose output, full path and unit information\");\n+      Write_Str (\"  -v         verbose output, full path and unit \" &\n+                               \"information\");\n+      Write_Eol;\n       Write_Eol;\n+\n+      --  Line for -files=\n+\n+      Write_Str (\"  -files=fil files are listed in text file 'fil'\");\n       Write_Eol;\n \n       --  Line for -aI switch\n \n-      Write_Str (\"  -aIdir    specify source files search path\");\n+      Write_Str (\"  -aIdir     specify source files search path\");\n       Write_Eol;\n \n       --  Line for -aO switch\n \n-      Write_Str (\"  -aOdir    specify object files search path\");\n+      Write_Str (\"  -aOdir     specify object files search path\");\n       Write_Eol;\n \n       --  Line for -I switch\n \n-      Write_Str (\"  -Idir     like -aIdir -aOdir\");\n+      Write_Str (\"  -Idir      like -aIdir -aOdir\");\n       Write_Eol;\n \n       --  Line for -I- switch\n \n-      Write_Str (\"  -I-       do not look for sources & object files\");\n+      Write_Str (\"  -I-        do not look for sources & object files\");\n       Write_Str (\" in the default directory\");\n       Write_Eol;\n \n       --  Line for -nostdinc\n \n-      Write_Str (\"  -nostdinc do not look for source files\");\n+      Write_Str (\"  -nostdinc  do not look for source files\");\n       Write_Str (\" in the system default directory\");\n       Write_Eol;\n \n       --  Line for --RTS\n \n-      Write_Str (\"  --RTS=dir specify the default source and object search\"\n+      Write_Str (\"  --RTS=dir  specify the default source and object search\"\n                  & \" path\");\n       Write_Eol;\n \n@@ -949,7 +1000,7 @@ begin\n          Next_Argv : String (1 .. Len_Arg (Next_Arg));\n       begin\n          Fill_Arg (Next_Argv'Address, Next_Arg);\n-         Scan_Ls_Arg (Next_Argv, And_Save => True);\n+         Scan_Ls_Arg (Next_Argv);\n       end;\n \n       Next_Arg := Next_Arg + 1;"}, {"sha": "9fe4aa13239b88ce3a7e0cfaab72dd1615bc4293", "filename": "gcc/ada/init.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1812,27 +1812,34 @@ __gnat_initialize (void)\n   /* On targets where we might be using the ZCX scheme, we need to register\n      the frame tables.\n \n-     For application \"modules\", the crtstuff objects linked in (crtbegin/endS)\n-     are tailored to provide this service a-la C++ constructor fashion,\n-     typically triggered by the dynamic loader. This is achieved by way of a\n-     special variable declaration in the crt object, the name of which has\n-     been deduced by analyzing the output of the \"munching\" step documented\n-     for C++.  The de-registration call is handled symetrically, a-la C++\n-     destructor fashion and typically triggered by the dynamic unloader. With\n-     this scheme, a mixed Ada/C++ application has to be linked and loaded as\n-     separate modules for each language, which is not unreasonable anyway.\n-\n-     For applications statically linked with the kernel, the module scheme\n-     above would lead to duplicated symbols because the VxWorks kernel build\n-     \"munches\" by default. To prevent those conflicts, we link against\n-     crtbegin/end objects that don't include the special variable and directly\n-     call the appropriate function here. We'll never unload that, so there is\n-     no de-registration to worry about.\n+     For applications loaded as a set of \"modules\", the crtstuff objects\n+     linked in (crtbegin/endS) are tailored to provide this service a-la C++\n+     static constructor fashion, typically triggered by the VxWorks loader.\n+     This is achieved by way of a special variable declaration in the crt\n+     object, the name of which has been deduced by analyzing the output of the\n+     \"munching\" step documented for C++.  The de-registration call is handled\n+     symetrically, a-la C++ destructor fashion and typically triggered by the\n+     dynamic unloader. Note that since the tables shall be registered against\n+     a common datastructure, libgcc should be one of the modules (vs beeing\n+     partially linked against all the others at build time) and shall be\n+     loaded first.\n+\n+     For applications linked with the kernel, the scheme above would lead to\n+     duplicated symbols because the VxWorks kernel build \"munches\" by default.\n+     To prevent those conflicts, we link against crtbegin/end objects that\n+     don't include the special variable and directly call the appropriate\n+     function here. We'll never unload that, so there is no de-registration to\n+     worry about.\n+\n+     For whole applications loaded as a single module, we may use one scheme\n+     or the other, except for the mixed Ada/C++ case in which the first scheme\n+     would fail for the same reason as in the linked-with-kernel situation.\n \n      We can differentiate by looking at the __module_has_ctors value provided\n-     by each class of crt objects. As of today, selecting the crt set intended\n-     for applications to be statically linked with the kernel is triggered by\n-     adding \"-static\" to the gcc *link* command line options.\n+     by each class of crt objects. As of today, selecting the crt set with the\n+     static ctors/dtors capabilities (first scheme above) is triggered by\n+     adding \"-static\" to the gcc *link* command line options. Without this,\n+     the other set of crt objects is fetched.\n \n      This is a first approach, tightly synchronized with a number of GCC\n      configuration and crtstuff changes. We need to ensure that those changes"}, {"sha": "7b6aa524a70d9f4391db31b958d785920e1d1322", "filename": "gcc/ada/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -36,7 +36,7 @@\n  gnat1 %{I*} %{k8:-gnatk8} %{w:-gnatws} %1 %{!Q:-quiet} %{nostdinc*}\\\n     %{nostdlib*}\\\n     -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n-    %{g*} %{O*} %{W*} %{w} %{p} %{pg:-p} %{m*} %{a} %{f*} %{d*}\\\n+    %{O*} %{W*} %{w} %{p} %{pg:-p} %{a} %{f*} %{d*} %{g*&m*} \\\n     %{!S:%{o*:%w%*-gnatO}} \\\n     %i %{S:%W{o*}%{!o*:-o %b.s}} \\\n     %{gnatc*|gnats*: -o %j} \\"}, {"sha": "e64db771b5bfed90b61be46cf68ee7c9b1e69a26", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -50,6 +50,9 @@ with Uname;   use Uname;\n \n package body Lib is\n \n+   Switch_Storing_Enabled : Boolean := True;\n+   --  Set to False by Disable_Switch_Storing\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -403,6 +406,11 @@ package body Lib is\n       return Compilation_Switches.Last;\n    end Compilation_Switches_Last;\n \n+   procedure Disable_Switch_Storing is\n+   begin\n+      Switch_Storing_Enabled := False;\n+   end Disable_Switch_Storing;\n+\n    ------------------------------\n    -- Earlier_In_Extended_Unit --\n    ------------------------------\n@@ -921,18 +929,20 @@ package body Lib is\n \n    procedure Store_Compilation_Switch (Switch : String) is\n    begin\n-      Compilation_Switches.Increment_Last;\n-      Compilation_Switches.Table (Compilation_Switches.Last) :=\n-        new String'(Switch);\n+      if Switch_Storing_Enabled then\n+         Compilation_Switches.Increment_Last;\n+         Compilation_Switches.Table (Compilation_Switches.Last) :=\n+           new String'(Switch);\n \n-      --  Fix up --RTS flag which has been transformed by the gcc driver\n-      --  into -fRTS\n+         --  Fix up --RTS flag which has been transformed by the gcc driver\n+         --  into -fRTS\n \n-      if Switch'Last >= Switch'First + 4\n-        and then Switch (Switch'First .. Switch'First + 4) = \"-fRTS\"\n-      then\n-         Compilation_Switches.Table\n-           (Compilation_Switches.Last) (Switch'First + 1) := '-';\n+         if Switch'Last >= Switch'First + 4\n+           and then Switch (Switch'First .. Switch'First + 4) = \"-fRTS\"\n+         then\n+            Compilation_Switches.Table\n+              (Compilation_Switches.Last) (Switch'First + 1) := '-';\n+         end if;\n       end if;\n    end Store_Compilation_Switch;\n "}, {"sha": "9ec0278680f4a75afc795a9982ad1a408f18b645", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -537,14 +537,20 @@ package Lib is\n    --  be kept consistent).\n \n    procedure Replace_Linker_Option_String\n-     (S : String_Id; Match_String : String);\n+     (S            : String_Id;\n+      Match_String : String);\n    --  Replace an existing Linker_Option if the prefix Match_String\n    --  matches, otherwise call Store_Linker_Option_String.\n \n    procedure Store_Compilation_Switch (Switch : String);\n    --  Called to register a compilation switch, either front-end or\n    --  back-end, which may influence the generated output file(s).\n \n+   procedure Disable_Switch_Storing;\n+   --  Disable the registration of compilation switches with\n+   --  Store_Compilation_Switch. This is used to not register switches added\n+   --  automatically by the gcc driver.\n+\n    procedure Store_Linker_Option_String (S : String_Id);\n    --  This procedure is called to register the string from a pragma\n    --  Linker_Option. The argument is the Id of the string to register."}, {"sha": "0f3fc50d83dc68cf8b7e019afc2d0c14fa59818a", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 434, "deletions": 389, "changes": 823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1986,6 +1986,9 @@ package body Make is\n       function Bad_Compilation_Count return Natural;\n       --  Returns the number of compilation failures.\n \n+      procedure Check_Standard_Library;\n+      --  Check if s-stalib.adb needs to be compiled\n+\n       procedure Collect_Arguments_And_Compile\n         (Source_File : File_Name_Type; Source_Index : Int);\n       --  Collect arguments from project file (if any) and compile\n@@ -2146,6 +2149,48 @@ package body Make is\n          return Bad_Compilation.Last - Bad_Compilation.First + 1;\n       end Bad_Compilation_Count;\n \n+      ----------------------------\n+      -- Check_Standard_Library --\n+      ----------------------------\n+\n+      procedure Check_Standard_Library is\n+      begin\n+         Need_To_Check_Standard_Library := False;\n+\n+         if not Targparm.Suppress_Standard_Library_On_Target then\n+            declare\n+               Sfile  : Name_Id;\n+               Add_It : Boolean := True;\n+\n+            begin\n+               Name_Len := Standard_Library_Package_Body_Name'Length;\n+               Name_Buffer (1 .. Name_Len) :=\n+                 Standard_Library_Package_Body_Name;\n+               Sfile := Name_Enter;\n+\n+               --  If we have a special runtime, we add the standard\n+               --  library only if we can find it.\n+\n+               if RTS_Switch then\n+                  Add_It :=\n+                    Find_File (Sfile, Osint.Source) /= No_File;\n+               end if;\n+\n+               if Add_It then\n+                  if Is_Marked (Sfile) then\n+                     if Is_In_Obsoleted (Sfile) then\n+                        Executable_Obsolete := True;\n+                     end if;\n+\n+                  else\n+                     Insert_Q (Sfile, Index => 0);\n+                     Mark (Sfile, Index => 0);\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end Check_Standard_Library;\n+\n       -----------------------------------\n       -- Collect_Arguments_And_Compile --\n       -----------------------------------\n@@ -2234,7 +2279,7 @@ package body Make is\n          Source_Index : Int;\n          Args         : Argument_List) return Process_Id\n       is\n-         Comp_Args : Argument_List (Args'First .. Args'Last + 8);\n+         Comp_Args : Argument_List (Args'First .. Args'Last + 9);\n          Comp_Next : Integer := Args'First;\n          Comp_Last : Integer;\n \n@@ -2401,6 +2446,9 @@ package body Make is\n \n          GNAT.OS_Lib.Normalize_Arguments (Comp_Args (Args'First .. Comp_Last));\n \n+         Comp_Last := Comp_Last + 1;\n+         Comp_Args (Comp_Last) := new String'(\"-gnatez\");\n+\n          Display (Gcc.all, Comp_Args (Args'First .. Comp_Last));\n \n          if Gcc_Path = null then\n@@ -2828,40 +2876,7 @@ package body Make is\n                --  only when \"-a\" is used.\n \n                if Need_To_Check_Standard_Library then\n-                  Need_To_Check_Standard_Library := False;\n-\n-                  if not Targparm.Suppress_Standard_Library_On_Target then\n-                     declare\n-                        Sfile  : Name_Id;\n-                        Add_It : Boolean := True;\n-\n-                     begin\n-                        Name_Len := Standard_Library_Package_Body_Name'Length;\n-                        Name_Buffer (1 .. Name_Len) :=\n-                          Standard_Library_Package_Body_Name;\n-                        Sfile := Name_Enter;\n-\n-                        --  If we have a special runtime, we add the standard\n-                        --  library only if we can find it.\n-\n-                        if RTS_Switch then\n-                           Add_It :=\n-                             Find_File (Sfile, Osint.Source) /= No_File;\n-                        end if;\n-\n-                        if Add_It then\n-                           if Is_Marked (Sfile) then\n-                              if Is_In_Obsoleted (Sfile) then\n-                                 Executable_Obsolete := True;\n-                              end if;\n-\n-                           else\n-                              Insert_Q (Sfile, Index => 0);\n-                              Mark (Sfile, Index => 0);\n-                           end if;\n-                        end if;\n-                     end;\n-                  end if;\n+                  Check_Standard_Library;\n                end if;\n \n                --  Now insert in the Q the unmarked source files (i.e. those\n@@ -3179,39 +3194,44 @@ package body Make is\n \n          for J in Args'Range loop\n \n-            --  Do not display the mapping file argument automatically\n-            --  created when using a project file.\n+            --  Never display -gnatez\n \n-            if Main_Project = No_Project\n-              or else Debug.Debug_Flag_N\n-              or else Args (J)'Length < 8\n-              or else\n-                Args (J)(Args (J)'First .. Args (J)'First + 6) /= \"-gnatem\"\n-            then\n-               --  When -dn is not specified, do not display the config\n-               --  pragmas switch (-gnatec) for the temporary file created\n-               --  by the project manager (always the first -gnatec switch).\n-               --  Reset Temporary_Config_File to False so that the eventual\n-               --  other -gnatec switches will be displayed.\n-\n-               if (not Debug.Debug_Flag_N)\n-                 and then Temporary_Config_File\n-                 and then Args (J)'Length > 7\n-                 and then Args (J)(Args (J)'First .. Args (J)'First + 6)\n-                            = \"-gnatec\"\n-               then\n-                  Temporary_Config_File := False;\n+            if Args (J).all /= \"-gnatez\" then\n \n-               --  Do not display the -F=mapping_file switch for gnatbind,\n-               --  if -dn is not specified.\n+               --  Do not display the mapping file argument automatically\n+               --  created when using a project file.\n \n-               elsif Debug.Debug_Flag_N\n-                 or else Args (J)'Length < 4\n-                 or else Args (J)(Args (J)'First .. Args (J)'First + 2) /=\n-                           \"-F=\"\n+               if Main_Project = No_Project\n+                 or else Debug.Debug_Flag_N\n+                 or else Args (J)'Length < 8\n+                 or else\n+                   Args (J) (Args (J)'First .. Args (J)'First + 6) /= \"-gnatem\"\n                then\n-                  Write_Str (\" \");\n-                  Write_Str (Args (J).all);\n+                  --  When -dn is not specified, do not display the config\n+                  --  pragmas switch (-gnatec) for the temporary file created\n+                  --  by the project manager (always the first -gnatec switch).\n+                  --  Reset Temporary_Config_File to False so that the eventual\n+                  --  other -gnatec switches will be displayed.\n+\n+                  if (not Debug.Debug_Flag_N)\n+                    and then Temporary_Config_File\n+                    and then Args (J)'Length > 7\n+                    and then Args (J) (Args (J)'First .. Args (J)'First + 6)\n+                    = \"-gnatec\"\n+                  then\n+                     Temporary_Config_File := False;\n+\n+                     --  Do not display the -F=mapping_file switch for\n+                     --  gnatbind, if -dn is not specified.\n+\n+                  elsif Debug.Debug_Flag_N\n+                    or else Args (J)'Length < 4\n+                    or else\n+                      Args (J) (Args (J)'First .. Args (J)'First + 2) /= \"-F=\"\n+                  then\n+                     Write_Str (\" \");\n+                     Write_Str (Args (J).all);\n+                  end if;\n                end if;\n             end if;\n          end loop;\n@@ -3366,6 +3386,352 @@ package body Make is\n       --  Set to True when there are Stand-Alone Libraries, so that gnatbind\n       --  is invoked with the -F switch to force checking of elaboration flags.\n \n+      Mapping_Path : Name_Id := No_Name;\n+      --  The path name of the mapping file\n+\n+      Discard : Boolean;\n+\n+      procedure Check_Mains;\n+      --  Check that the main subprograms do exist and that they all\n+      --  belong to the same project file.\n+\n+      procedure Create_Binder_Mapping_File\n+        (Args : in out Argument_List; Last_Arg : in out Natural);\n+      --  Create a binder mapping file and add the necessary switch\n+\n+      -----------------\n+      -- Check_Mains --\n+      -----------------\n+\n+      procedure Check_Mains is\n+         Real_Main_Project : Project_Id := No_Project;\n+         --  The project of the first main\n+\n+         Proj              : Project_Id := No_Project;\n+         --  The project of the current main\n+\n+         Data              : Project_Data;\n+\n+         Real_Path         : String_Access;\n+\n+      begin\n+         Mains.Reset;\n+\n+         --  Check each main\n+\n+         loop\n+            declare\n+               Main      : constant String := Mains.Next_Main;\n+               --  The name specified on the command line may include\n+               --  directory information.\n+\n+               File_Name : constant String := Base_Name (Main);\n+               --  The simple file name of the current main main\n+\n+            begin\n+               exit when Main = \"\";\n+\n+               --  Get the project of the current main\n+\n+               Proj := Prj.Env.Project_Of (File_Name, Main_Project);\n+\n+               --  Fail if the current main is not a source of a\n+               --  project.\n+\n+               if Proj = No_Project then\n+                  Make_Failed\n+                    (\"\"\"\" & Main &\n+                     \"\"\" is not a source of any project\");\n+\n+               else\n+                  --  If there is directory information, check that\n+                  --  the source exists and, if it does, that the path\n+                  --  is the actual path of a source of a project.\n+\n+                  if Main /= File_Name then\n+                     Data := Projects.Table (Main_Project);\n+\n+                     Real_Path :=\n+                       Locate_Regular_File\n+                         (Main &\n+                          Get_Name_String\n+                            (Data.Naming.Current_Body_Suffix),\n+                          \"\");\n+                     if Real_Path = null then\n+                        Real_Path :=\n+                          Locate_Regular_File\n+                            (Main &\n+                             Get_Name_String\n+                               (Data.Naming.Current_Spec_Suffix),\n+                             \"\");\n+                     end if;\n+\n+                     if Real_Path = null then\n+                        Real_Path :=\n+                          Locate_Regular_File (Main, \"\");\n+                     end if;\n+\n+                     --  Fail if the file cannot be found\n+\n+                     if Real_Path = null then\n+                        Make_Failed\n+                          (\"file \"\"\" & Main & \"\"\" does not exist\");\n+                     end if;\n+\n+                     declare\n+                        Project_Path : constant String :=\n+                                         Prj.Env.File_Name_Of_Library_Unit_Body\n+                                           (Name              => File_Name,\n+                                            Project           => Main_Project,\n+                                            Main_Project_Only => False,\n+                                            Full_Path         => True);\n+                        Normed_Path  : constant String :=\n+                                         Normalize_Pathname\n+                                           (Real_Path.all,\n+                                            Case_Sensitive => False);\n+                        Proj_Path    : constant String :=\n+                                         Normalize_Pathname\n+                                           (Project_Path,\n+                                            Case_Sensitive => False);\n+\n+                     begin\n+                        Free (Real_Path);\n+\n+                        --  Fail if it is not the correct path\n+\n+                        if Normed_Path /= Proj_Path then\n+                           if Verbose_Mode then\n+                              Write_Str (Normed_Path);\n+                              Write_Str (\" /= \");\n+                              Write_Line (Proj_Path);\n+                           end if;\n+\n+                           Make_Failed\n+                             (\"\"\"\" & Main &\n+                              \"\"\" is not a source of any project\");\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  if not Unique_Compile then\n+\n+                     --  Record the project, if it is the first main\n+\n+                     if Real_Main_Project = No_Project then\n+                        Real_Main_Project := Proj;\n+\n+                     elsif Proj /= Real_Main_Project then\n+\n+                        --  Fail, as the current main is not a source\n+                        --  of the same project as the first main.\n+\n+                        Make_Failed\n+                          (\"\"\"\" & Main &\n+                           \"\"\" is not a source of project \" &\n+                           Get_Name_String\n+                             (Projects.Table\n+                                (Real_Main_Project).Name));\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               --  If -u and -U are not used, we may have mains that\n+               --  are sources of a project that is not the one\n+               --  specified with switch -P.\n+\n+               if not Unique_Compile then\n+                  Main_Project := Real_Main_Project;\n+               end if;\n+            end;\n+         end loop;\n+      end Check_Mains;\n+\n+      --------------------------------\n+      -- Create_Binder_Mapping_File --\n+      --------------------------------\n+\n+      procedure Create_Binder_Mapping_File\n+        (Args : in out Argument_List; Last_Arg : in out Natural)\n+      is\n+         Mapping_FD : File_Descriptor := Invalid_FD;\n+         --  A File Descriptor for an eventual mapping file\n+\n+         ALI_Unit     : Name_Id := No_Name;\n+         --  The unit name of an ALI file\n+\n+         ALI_Name     : Name_Id := No_Name;\n+         --  The file name of the ALI file\n+\n+         ALI_Project  : Project_Id := No_Project;\n+         --  The project of the ALI file\n+\n+         Bytes        : Integer;\n+         OK           : Boolean := True;\n+\n+         Status       : Boolean;\n+         --  For call to Close\n+\n+      begin\n+         Tempdir.Create_Temp_File (Mapping_FD, Mapping_Path);\n+\n+         if Mapping_FD /= Invalid_FD then\n+\n+            --  Traverse all units\n+\n+            for J in Prj.Com.Units.First .. Prj.Com.Units.Last loop\n+               declare\n+                  Unit : constant Prj.Com.Unit_Data :=\n+                           Prj.Com.Units.Table (J);\n+                  use Prj.Com;\n+\n+               begin\n+                  if Unit.Name /= No_Name then\n+\n+                     --  If there is a body, put it in the mapping\n+\n+                     if Unit.File_Names (Body_Part).Name /= No_Name\n+                       and then Unit.File_Names (Body_Part).Project\n+                       /= No_Project\n+                     then\n+                        Get_Name_String (Unit.Name);\n+                        Name_Buffer\n+                          (Name_Len + 1 .. Name_Len + 2) := \"%b\";\n+                        Name_Len := Name_Len + 2;\n+                        ALI_Unit := Name_Find;\n+                        ALI_Name :=\n+                          Lib_File_Name\n+                            (Unit.File_Names (Body_Part).Name);\n+                        ALI_Project :=\n+                          Unit.File_Names (Body_Part).Project;\n+\n+                        --  Otherwise, if there is a spec, put it\n+                        --  in the mapping.\n+\n+                     elsif Unit.File_Names (Specification).Name\n+                       /= No_Name\n+                       and then Unit.File_Names\n+                         (Specification).Project\n+                         /= No_Project\n+                     then\n+                        Get_Name_String (Unit.Name);\n+                        Name_Buffer\n+                          (Name_Len + 1 .. Name_Len + 2) := \"%s\";\n+                        Name_Len := Name_Len + 2;\n+                        ALI_Unit := Name_Find;\n+                        ALI_Name := Lib_File_Name\n+                          (Unit.File_Names (Specification).Name);\n+                        ALI_Project :=\n+                          Unit.File_Names (Specification).Project;\n+\n+                     else\n+                        ALI_Name := No_Name;\n+                     end if;\n+\n+                     --  If we have something to put in the mapping\n+                     --  then we do it now. However, if the project\n+                     --  is extended, we don't put anything in the\n+                     --  mapping file, because we do not know where\n+                     --  the ALI file is: it might be in the ext-\n+                     --  ended project obj dir as well as in the\n+                     --  extending project obj dir.\n+\n+                     if ALI_Name /= No_Name\n+                       and then\n+                         Projects.Table (ALI_Project).Extended_By = No_Project\n+                       and then\n+                         Projects.Table (ALI_Project).Extends = No_Project\n+                     then\n+                        --  First line is the unit name\n+\n+                        Get_Name_String (ALI_Unit);\n+                        Name_Len := Name_Len + 1;\n+                        Name_Buffer (Name_Len) := ASCII.LF;\n+                        Bytes :=\n+                          Write\n+                            (Mapping_FD,\n+                             Name_Buffer (1)'Address,\n+                             Name_Len);\n+                        OK := Bytes = Name_Len;\n+\n+                        exit when not OK;\n+\n+                        --  Second line it the ALI file name\n+\n+                        Get_Name_String (ALI_Name);\n+                        Name_Len := Name_Len + 1;\n+                        Name_Buffer (Name_Len) := ASCII.LF;\n+                        Bytes :=\n+                          Write\n+                            (Mapping_FD,\n+                             Name_Buffer (1)'Address,\n+                             Name_Len);\n+                        OK := Bytes = Name_Len;\n+\n+                        exit when not OK;\n+\n+                        --  Third line it the ALI path name,\n+                        --  concatenation of the project\n+                        --  directory with the ALI file name.\n+\n+                        declare\n+                           ALI : constant String :=\n+                                   Get_Name_String (ALI_Name);\n+                        begin\n+                           Get_Name_String\n+                             (Projects.Table (ALI_Project).\n+                                Object_Directory);\n+\n+                           if Name_Buffer (Name_Len) /=\n+                             Directory_Separator\n+                           then\n+                              Name_Len := Name_Len + 1;\n+                              Name_Buffer (Name_Len) :=\n+                                Directory_Separator;\n+                           end if;\n+\n+                           Name_Buffer\n+                             (Name_Len + 1 ..\n+                                Name_Len + ALI'Length) := ALI;\n+                           Name_Len :=\n+                             Name_Len + ALI'Length + 1;\n+                           Name_Buffer (Name_Len) := ASCII.LF;\n+                           Bytes :=\n+                             Write\n+                               (Mapping_FD,\n+                                Name_Buffer (1)'Address,\n+                                Name_Len);\n+                           OK := Bytes = Name_Len;\n+                        end;\n+\n+                        --  If OK is False, it means we were unable\n+                        --  to write a line. No point in continuing\n+                        --  with the other units.\n+\n+                        exit when not OK;\n+                     end if;\n+                  end if;\n+               end;\n+            end loop;\n+\n+            Close (Mapping_FD, Status);\n+\n+            OK := OK and Status;\n+\n+            --  If the creation of the mapping file was successful,\n+            --  we add the switch to the arguments of gnatbind.\n+\n+            if OK then\n+               Last_Arg := Last_Arg + 1;\n+               Args (Last_Arg) :=\n+                 new String'(\"-F=\" & Get_Name_String (Mapping_Path));\n+            end if;\n+         end if;\n+      end Create_Binder_Mapping_File;\n+\n+   --  Start of processing for Gnatmake\n+\n+   --  This body is very long, should be broken down ???\n+\n    begin\n       Gnatmake_Called := True;\n \n@@ -3466,148 +3832,7 @@ package body Make is\n                --  project file and, if there are several mains, each of them\n                --  is a source of the same project file.\n \n-               Mains.Reset;\n-\n-               declare\n-                  Real_Main_Project : Project_Id := No_Project;\n-                  --  The project of the first main\n-\n-                  Proj : Project_Id := No_Project;\n-                  --  The project of the current main\n-\n-               begin\n-                  --  Check each main\n-\n-                  loop\n-                     declare\n-                        Main : constant String := Mains.Next_Main;\n-                        --  The name specified on the command line may include\n-                        --  directory information.\n-\n-                        File_Name : constant String := Base_Name (Main);\n-                        --  The simple file name of the current main main\n-\n-                     begin\n-                        exit when Main = \"\";\n-\n-                        --  Get the project of the current main\n-\n-                        Proj := Prj.Env.Project_Of (File_Name, Main_Project);\n-\n-                        --  Fail if the current main is not a source of a\n-                        --  project.\n-\n-                        if Proj = No_Project then\n-                           Make_Failed\n-                             (\"\"\"\" & Main &\n-                              \"\"\" is not a source of any project\");\n-\n-                        else\n-                           --  If there is directory information, check that\n-                           --  the source exists and, if it does, that the path\n-                           --  is the actual path of a source of a project.\n-\n-                           if Main /= File_Name then\n-                              declare\n-                                 Data : constant Project_Data :=\n-                                          Projects.Table (Main_Project);\n-\n-                                 Project_Path : constant String :=\n-                                   Prj.Env.File_Name_Of_Library_Unit_Body\n-                                     (Name              => File_Name,\n-                                      Project           => Main_Project,\n-                                      Main_Project_Only => False,\n-                                      Full_Path         => True);\n-                                 Real_Path : String_Access :=\n-                                   Locate_Regular_File\n-                                     (Main &\n-                                      Get_Name_String\n-                                        (Data.Naming.Current_Body_Suffix),\n-                                      \"\");\n-                              begin\n-                                 if Real_Path = null then\n-                                    Real_Path :=\n-                                      Locate_Regular_File\n-                                        (Main &\n-                                         Get_Name_String\n-                                           (Data.Naming.Current_Spec_Suffix),\n-                                         \"\");\n-                                 end if;\n-\n-                                 if Real_Path = null then\n-                                    Real_Path :=\n-                                      Locate_Regular_File (Main, \"\");\n-                                 end if;\n-\n-                                 --  Fail if the file cannot be found\n-\n-                                 if Real_Path = null then\n-                                    Make_Failed\n-                                      (\"file \"\"\" & Main & \"\"\" does not exist\");\n-                                 end if;\n-\n-                                 declare\n-                                    Normed_Path : constant String :=\n-                                      Normalize_Pathname\n-                                        (Real_Path.all,\n-                                         Case_Sensitive => False);\n-                                    Proj_Path : constant String :=\n-                                      Normalize_Pathname\n-                                        (Project_Path,\n-                                         Case_Sensitive => False);\n-\n-                                 begin\n-                                    Free (Real_Path);\n-\n-                                    --  Fail if it is not the correct path\n-\n-                                    if Normed_Path /= Proj_Path then\n-                                       if Verbose_Mode then\n-                                          Write_Str (Normed_Path);\n-                                          Write_Str (\" /= \");\n-                                          Write_Line (Proj_Path);\n-                                       end if;\n-\n-                                       Make_Failed\n-                                         (\"\"\"\" & Main &\n-                                          \"\"\" is not a source of any project\");\n-                                    end if;\n-                                 end;\n-                              end;\n-                           end if;\n-\n-                           if not Unique_Compile then\n-\n-                              --  Record the project, if it is the first main\n-\n-                              if Real_Main_Project = No_Project then\n-                                 Real_Main_Project := Proj;\n-\n-                              elsif Proj /= Real_Main_Project then\n-\n-                                 --  Fail, as the current main is not a source\n-                                 --  of the same project as the first main.\n-\n-                                 Make_Failed\n-                                   (\"\"\"\" & Main &\n-                                    \"\"\" is not a source of project \" &\n-                                    Get_Name_String\n-                                      (Projects.Table\n-                                         (Real_Main_Project).Name));\n-                              end if;\n-                           end if;\n-                        end if;\n-\n-                        --  If -u and -U are not used, we may have mains that\n-                        --  are sources of a project that is not the one\n-                        --  specified with switch -P.\n-\n-                        if not Unique_Compile then\n-                           Main_Project := Real_Main_Project;\n-                        end if;\n-                     end;\n-                  end loop;\n-               end;\n+               Check_Mains;\n             end if;\n \n          --  If no mains have been specified on the command line,\n@@ -4717,27 +4942,6 @@ package body Make is\n                Last_Arg : Natural := Binder_Switches.Last;\n                --  Index of the last argument in Args\n \n-               Mapping_FD : File_Descriptor := Invalid_FD;\n-               --  A File Descriptor for an eventual mapping file\n-\n-               Mapping_Path : Name_Id := No_Name;\n-               --  The path name of the mapping file\n-\n-               ALI_Unit : Name_Id := No_Name;\n-               --  The unit name of an ALI file\n-\n-               ALI_Name : Name_Id := No_Name;\n-               --  The file name of the ALI file\n-\n-               ALI_Project  : Project_Id := No_Project;\n-               --  The project of the ALI file\n-\n-               Bytes : Integer;\n-               OK    : Boolean := True;\n-\n-               Status : Boolean;\n-               --  For call to Close\n-\n             begin\n                --  If it is the first time the bind step is performed,\n                --  check if there are shared libraries, so that gnatbind is\n@@ -4787,164 +4991,7 @@ package body Make is\n                   --  If switch -C was specified, create a binder mapping file\n \n                   if Create_Mapping_File then\n-                     Tempdir.Create_Temp_File (Mapping_FD, Mapping_Path);\n-\n-                     if Mapping_FD /= Invalid_FD then\n-\n-                        --  Traverse all units\n-\n-                        for J in Prj.Com.Units.First .. Prj.Com.Units.Last loop\n-                           declare\n-                              Unit : constant Prj.Com.Unit_Data :=\n-                                       Prj.Com.Units.Table (J);\n-                              use Prj.Com;\n-\n-                           begin\n-                              if Unit.Name /= No_Name then\n-\n-                                 --  If there is a body, put it in the mapping\n-\n-                                 if Unit.File_Names (Body_Part).Name /= No_Name\n-                                   and then Unit.File_Names (Body_Part).Project\n-                                                  /= No_Project\n-                                 then\n-                                    Get_Name_String (Unit.Name);\n-                                    Name_Buffer\n-                                      (Name_Len + 1 .. Name_Len + 2) := \"%b\";\n-                                    Name_Len := Name_Len + 2;\n-                                    ALI_Unit := Name_Find;\n-                                    ALI_Name :=\n-                                      Lib_File_Name\n-                                        (Unit.File_Names (Body_Part).Name);\n-                                    ALI_Project :=\n-                                      Unit.File_Names (Body_Part).Project;\n-\n-                                 --  Otherwise, if there is a spec, put it\n-                                 --  in the mapping.\n-\n-                                 elsif Unit.File_Names (Specification).Name\n-                                                 /= No_Name\n-                                   and then Unit.File_Names\n-                                             (Specification).Project\n-                                                /= No_Project\n-                                 then\n-                                    Get_Name_String (Unit.Name);\n-                                    Name_Buffer\n-                                      (Name_Len + 1 .. Name_Len + 2) := \"%s\";\n-                                    Name_Len := Name_Len + 2;\n-                                    ALI_Unit := Name_Find;\n-                                    ALI_Name := Lib_File_Name\n-                                        (Unit.File_Names (Specification).Name);\n-                                    ALI_Project :=\n-                                      Unit.File_Names (Specification).Project;\n-\n-                                 else\n-                                    ALI_Name := No_Name;\n-                                 end if;\n-\n-                                 --  If we have something to put in the mapping\n-                                 --  then we do it now. However, if the project\n-                                 --  is extended, we don't put anything in the\n-                                 --  mapping file, because we do not know where\n-                                 --  the ALI file is: it might be in the ext-\n-                                 --  ended project obj dir as well as in the\n-                                 --  extending project obj dir.\n-\n-                                 if ALI_Name /= No_Name\n-                                    and then Projects.Table\n-                                               (ALI_Project).Extended_By\n-                                                        = No_Project\n-                                    and then Projects.Table\n-                                               (ALI_Project).Extends\n-                                                        = No_Project\n-                                 then\n-                                    --  First line is the unit name\n-\n-                                    Get_Name_String (ALI_Unit);\n-                                    Name_Len := Name_Len + 1;\n-                                    Name_Buffer (Name_Len) := ASCII.LF;\n-                                    Bytes :=\n-                                      Write\n-                                        (Mapping_FD,\n-                                         Name_Buffer (1)'Address,\n-                                         Name_Len);\n-                                    OK := Bytes = Name_Len;\n-\n-                                    if OK then\n-\n-                                       --  Second line it the ALI file name\n-\n-                                       Get_Name_String (ALI_Name);\n-                                       Name_Len := Name_Len + 1;\n-                                       Name_Buffer (Name_Len) := ASCII.LF;\n-                                       Bytes :=\n-                                         Write\n-                                           (Mapping_FD,\n-                                            Name_Buffer (1)'Address,\n-                                            Name_Len);\n-                                       OK := Bytes = Name_Len;\n-                                    end if;\n-\n-                                    if OK then\n-\n-                                       --  Third line it the ALI path name,\n-                                       --  concatenation of the project\n-                                       --  directory with the ALI file name.\n-\n-                                       declare\n-                                          ALI : constant String :=\n-                                                  Get_Name_String (ALI_Name);\n-                                       begin\n-                                          Get_Name_String\n-                                            (Projects.Table (ALI_Project).\n-                                               Object_Directory);\n-\n-                                          if Name_Buffer (Name_Len) /=\n-                                            Directory_Separator\n-                                          then\n-                                             Name_Len := Name_Len + 1;\n-                                             Name_Buffer (Name_Len) :=\n-                                               Directory_Separator;\n-                                          end if;\n-\n-                                          Name_Buffer\n-                                            (Name_Len + 1 ..\n-                                               Name_Len + ALI'Length) := ALI;\n-                                          Name_Len :=\n-                                            Name_Len + ALI'Length + 1;\n-                                          Name_Buffer (Name_Len) := ASCII.LF;\n-                                          Bytes :=\n-                                            Write\n-                                              (Mapping_FD,\n-                                               Name_Buffer (1)'Address,\n-                                               Name_Len);\n-                                          OK := Bytes = Name_Len;\n-                                       end;\n-                                    end if;\n-\n-                                    --  If OK is False, it means we were unable\n-                                    --  to write a line. No point in continuing\n-                                    --  with the other units.\n-\n-                                    exit when not OK;\n-                                 end if;\n-                              end if;\n-                           end;\n-                        end loop;\n-\n-                        Close (Mapping_FD, Status);\n-\n-                        OK := OK and Status;\n-\n-                        --  If the creation of the mapping file was successful,\n-                        --  we add the switch to the arguments of gnatbind.\n-\n-                        if OK then\n-                           Last_Arg := Last_Arg + 1;\n-                           Args (Last_Arg) := new String'\n-                                      (\"-F=\" & Get_Name_String (Mapping_Path));\n-                        end if;\n-                     end if;\n+                     Create_Binder_Mapping_File (Args, Last_Arg);\n                   end if;\n \n                end if;\n@@ -4962,7 +5009,7 @@ package body Make is\n                      if not Debug.Debug_Flag_N\n                        and then Mapping_Path /= No_Name\n                      then\n-                        Delete_File (Get_Name_String (Mapping_Path), OK);\n+                        Delete_File (Get_Name_String (Mapping_Path), Discard);\n                      end if;\n \n                      --  And reraise the exception\n@@ -4974,7 +5021,7 @@ package body Make is\n                --  if one was created.\n \n                if not Debug.Debug_Flag_N and then Mapping_Path /= No_Name then\n-                  Delete_File (Get_Name_String (Mapping_Path), OK);\n+                  Delete_File (Get_Name_String (Mapping_Path), Discard);\n                end if;\n             end Bind_Step;\n          end if;\n@@ -5439,7 +5486,6 @@ package body Make is\n       when X : others =>\n          Write_Line (Exception_Information (X));\n          Make_Failed (\"INTERNAL ERROR. Please report.\");\n-\n    end Gnatmake;\n \n    ----------\n@@ -5458,7 +5504,6 @@ package body Make is\n    function In_Ada_Lib_Dir (File : File_Name_Type) return Boolean is\n       D : constant Name_Id := Get_Directory (File);\n       B : constant Byte    := Get_Name_Table_Byte (D);\n-\n    begin\n       return (B and Ada_Lib_Dir) /= 0;\n    end In_Ada_Lib_Dir;"}, {"sha": "d818ff2542301f028c639206a6772bf09ec9c947", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 939, "deletions": 502, "changes": 1441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -66,15 +66,14 @@ package body Makegpr is\n    --  sources and the C++ compiler is not g++.\n \n    No_Argument : constant Argument_List := (1 .. 0 => null);\n+   --  Null argument list representing case of no arguments\n \n    FD : Process_Descriptor;\n    --  The process descriptor used when invoking a non GNU compiler with -M\n    --  and getting the output with GNAT.Expect.\n \n-   Line_Matcher : constant Pattern_Matcher :=\n-                    Compile (\"^.*?\\n\", Single_Line);\n-   --  The pattern when using GNAT.Expect for the invocation of a non GNU\n-   --  compiler with -M.\n+   Line_Matcher : constant Pattern_Matcher := Compile (\"^.*?\\n\", Single_Line);\n+   --  Pattern for GNAT.Expect for the invocation of a non GNU compiler with -M\n \n    Name_Ide              : Name_Id;\n    Name_Compiler_Command : Name_Id;\n@@ -85,11 +84,11 @@ package body Makegpr is\n    --  True when switch -u is used on the command line\n \n    type Source_Index_Rec is record\n-      Id : Other_Source_Id;\n-      Found : Boolean := False;\n+      Project : Project_Id;\n+      Id      : Other_Source_Id;\n+      Found   : Boolean := False;\n    end record;\n-   --  Used as component of Source_Indexes, to check if an archive need to\n-   --  be rebuilt.\n+   --  Used as Source_Indexes component to check if archive needs to be rebuilt\n \n    type Source_Index_Array is array (Positive range <>) of Source_Index_Rec;\n    type Source_Indexes_Ref is access Source_Index_Array;\n@@ -127,8 +126,7 @@ package body Makegpr is\n \n    Copyright_Output : Boolean := False;\n    Usage_Output     : Boolean := False;\n-   --  Flags to avoid multiple displays of the Copyright notice and of the\n-   --  Usage.\n+   --  Flags to avoid multiple displays of Copyright notice and of Usage\n \n    Output_File_Name           : String_Access := null;\n    --  The name given after a switch -o\n@@ -156,8 +154,7 @@ package body Makegpr is\n       Binder_String   'Access,\n       Linker_String   'Access);\n    Packages_To_Check : constant String_List_Access := List_Of_Packages'Access;\n-   --  List of the packages to be checked when parsing/processing project\n-   --  files.\n+   --  List of the packages to be checked when parsing/processing project files\n \n    Main_Project : Project_Id;\n    --  The project id of the main project\n@@ -300,6 +297,8 @@ package body Makegpr is\n    --  Used when Keep_Going is True (switch -k) to keep the total number\n    --  of compilation/linking errors, to report at the end of execution.\n \n+   Need_To_Rebuild_Global_Archive : Boolean := False;\n+\n    Error_Header : constant String := \"*** ERROR: \";\n    --  The beginning of error message, when Keep_Going is True\n \n@@ -335,12 +334,13 @@ package body Makegpr is\n    --  Current_Processor and Current_Language.\n \n    procedure Add_Search_Directories\n-     (Data : Project_Data; Language : Programming_Language);\n+     (Data     : Project_Data;\n+      Language : Programming_Language);\n    --  Either add to the Arguments the necessary -I switches needed to\n    --  compile, or, when compiler is gcc/g++, set up the C*INCLUDE_PATH\n    --  environment variable, if necessary.\n \n-   procedure Add_Source_Id (Id : Other_Source_Id);\n+   procedure Add_Source_Id (Project : Project_Id; Id : Other_Source_Id);\n    --  Add a source id to Source_Indexes, with Found set to False\n \n    procedure Add_Switches\n@@ -352,11 +352,21 @@ package body Makegpr is\n    --  or language (attribute Default_Switches), coming from package Compiler\n    --  or Linker (depending on Proc) of a specified project file.\n \n-   procedure Build_Archive (Project : Project_Id; Unconditionally : Boolean);\n-   --  Build the archive for a specified project. If Unconditionally is\n-   --  False, first check if the archive is up to date, and build it only\n+   procedure Build_Global_Archive;\n+   --  Build the archive for the main project\n+\n+   procedure Build_Library (Project : Project_Id; Unconditionally : Boolean);\n+   --  Build the library for a library project. If Unconditionally is\n+   --  False, first check if the library is up to date, and build it only\n    --  if it is not.\n \n+   procedure Check (Option : String);\n+   --  Check that a switch coming from a project file is not the concatenation\n+   --  of several valid switch, for example \"-g -v\". If it is, issue a warning.\n+\n+   procedure Check_Archive_Builder;\n+   --  Check if the archive builder (ar) is there\n+\n    procedure Check_Compilation_Needed\n      (Source          : Other_Source;\n       Need_To_Compile : out Boolean);\n@@ -370,6 +380,7 @@ package body Makegpr is\n      (Source_Id    : Other_Source_Id;\n       Data         : Project_Data;\n       Local_Errors : in out Boolean);\n+   --  Compile one non-Ada source\n \n    procedure Compile_Individual_Sources;\n    --  Compile the sources specified on the command line, when in\n@@ -390,7 +401,10 @@ package body Makegpr is\n    procedure Create_Archive_Dependency_File\n      (Name         : String;\n       First_Source : Other_Source_Id);\n-   --  ??? needs comment\n+   --  Create the archive dependency file for a library project\n+\n+   procedure Create_Global_Archive_Dependency_File (Name : String);\n+   --  Create the archive depenency file for the main project\n \n    procedure Display_Command\n      (Name  : String;\n@@ -419,6 +433,12 @@ package body Makegpr is\n    --  Do the necessary package initialization and process the command line\n    --  arguments.\n \n+   function Is_Included_In_Global_Archive\n+     (Object_Name : Name_Id;\n+      Project     : Project_Id) return Boolean;\n+   --  Return True if the object Object_Name is not overridden by a source\n+   --  in a project extending project Project.\n+\n    procedure Link_Executables;\n    --  Link executables\n \n@@ -434,7 +454,7 @@ package body Makegpr is\n    --  Process one command line argument\n \n    function Strip_CR_LF (Text : String) return String;\n-   --  Needs comment ???\n+   --  Remove characters ASCII.CR and ASCII.LF from a String\n \n    procedure Usage;\n    --  Display the usage\n@@ -462,6 +482,103 @@ package body Makegpr is\n          Imported : Project_List;\n          Prj      : Project_Id;\n \n+         procedure Add_Archive_Path;\n+         --  For a library project or the main project, add the archive\n+         --  path to the arguments.\n+\n+         ----------------------\n+         -- Add_Archive_Path --\n+         ----------------------\n+\n+         procedure Add_Archive_Path is\n+            Increment : Positive;\n+            Prev_Last : Positive;\n+\n+         begin\n+            if Data.Library then\n+\n+               --  If it is a library project file, nothing to do if\n+               --  gnatmake will be invoked, because gnatmake will take\n+               --  care of it, even if the library is not an Ada library.\n+\n+               if not For_Gnatmake then\n+                  if Data.Library_Kind = Static then\n+                     Add_Argument\n+                       (Get_Name_String (Data.Library_Dir) &\n+                        Directory_Separator &\n+                        \"lib\" & Get_Name_String (Data.Library_Name) &\n+                        '.' & Archive_Ext,\n+                        Verbose_Mode);\n+\n+                  else\n+                     --  As we first insert in the reverse order,\n+                     --  -L<dir> is put after -l<lib>\n+\n+                     Add_Argument\n+                       (\"-l\" & Get_Name_String (Data.Library_Name),\n+                        Verbose_Mode);\n+\n+                     Get_Name_String (Data.Library_Dir);\n+\n+                     Add_Argument\n+                       (\"-L\" & Name_Buffer (1 .. Name_Len),\n+                        Verbose_Mode);\n+\n+                     --  If there is a run path option, prepend this\n+                     --  directory to the library path. It is probable\n+                     --  that the order of the directories in the path\n+                     --  option is not important, but just in case\n+                     --  put the directories in the same order as the\n+                     --  libraries.\n+\n+                     if Path_Option /= null then\n+\n+                        --  If it is not the first directory, make room\n+                        --  at the beginning of the table, including\n+                        --  for a path separator.\n+\n+                        if Lib_Path.Last > 0 then\n+                           Increment := Name_Len + 1;\n+                           Prev_Last := Lib_Path.Last;\n+                           Lib_Path.Set_Last (Prev_Last + Increment);\n+\n+                           for Index in reverse 1 .. Prev_Last loop\n+                              Lib_Path.Table (Index + Increment) :=\n+                                Lib_Path.Table (Index);\n+                           end loop;\n+\n+                           Lib_Path.Table (Increment) := Path_Separator;\n+\n+                        else\n+                           --  If it is the first directory, just set\n+                           --  Last to the length of the directory.\n+\n+                           Lib_Path.Set_Last (Name_Len);\n+                        end if;\n+\n+                        --  Put the directory at the beginning of the\n+                        --  table.\n+\n+                        for Index in 1 .. Name_Len loop\n+                           Lib_Path.Table (Index) := Name_Buffer (Index);\n+                        end loop;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+            --  For a non-library project, the only archive needed\n+            --  is the one for the main project.\n+\n+            elsif Project = Main_Project then\n+               Add_Argument\n+                 (Get_Name_String (Data.Object_Directory) &\n+                  Directory_Separator &\n+                  \"lib\" & Get_Name_String (Data.Name) &\n+                  '.' & Archive_Ext,\n+                  Verbose_Mode);\n+            end if;\n+         end Add_Archive_Path;\n+\n       begin\n          --  Nothing to do when there is no project specified\n \n@@ -499,100 +616,17 @@ package body Makegpr is\n                --  If there is sources of language other than Ada in this\n                --  project, add the path of the archive to Arguments.\n \n-               if Data.Sources_Present then\n-                  if Data.Library then\n-\n-                     --  If it is a library project file, nothing to do if\n-                     --  gnatmake will be invoked, because gnatmake will take\n-                     --  care of it, even if the library is not an Ada library.\n-\n-                     if not For_Gnatmake then\n-                        if Data.Library_Kind = Static then\n-                           Add_Argument\n-                             (Get_Name_String (Data.Library_Dir) &\n-                              Directory_Separator &\n-                              \"lib\" & Get_Name_String (Data.Library_Name) &\n-                              '.' & Archive_Ext,\n-                              Verbose_Mode);\n-\n-                        else\n-                           --  As we first insert in the reverse order,\n-                           --  -L<dir> is put after -l<lib>\n-\n-                           Add_Argument\n-                             (\"-l\" & Get_Name_String (Data.Library_Name),\n-                              Verbose_Mode);\n-\n-                           Get_Name_String (Data.Library_Dir);\n-\n-                           Add_Argument\n-                             (\"-L\" & Name_Buffer (1 .. Name_Len),\n-                              Verbose_Mode);\n-\n-                           --  If there is a run path option, prepend this\n-                           --  directory to the library path. It is probable\n-                           --  that the order of the directories in the path\n-                           --  option is not important, but just in case\n-                           --  put the directories in the same order as the\n-                           --  libraries.\n-\n-                           if Path_Option /= null then\n-                              --  If it is not the first directory, make room\n-                              --  at the beginning of the table, including\n-                              --  for a path separator.\n-\n-                              if Lib_Path.Last > 0 then\n-                                 declare\n-                                    Increment : constant Positive :=\n-                                                  Name_Len + 1;\n-                                    Prev_Last : constant Positive :=\n-                                                  Lib_Path.Last;\n-\n-                                 begin\n-                                    Lib_Path.Set_Last (Prev_Last + Increment);\n-\n-                                    for Index in reverse 1 .. Prev_Last loop\n-                                       Lib_Path.Table (Index + Increment) :=\n-                                         Lib_Path.Table (Index);\n-                                    end loop;\n-\n-                                    Lib_Path.Table (Increment) :=\n-                                      Path_Separator;\n-                                 end;\n-\n-                              else\n-                                 --  If it is the first directory, just set\n-                                 --  Last to the length of the directory.\n-\n-                                 Lib_Path.Set_Last (Name_Len);\n-                              end if;\n-\n-                              --  Put the directory at the beginning of the\n-                              --  table.\n-\n-                              for Index in 1 .. Name_Len loop\n-                                 Lib_Path.Table (Index) := Name_Buffer (Index);\n-                              end loop;\n-                           end if;\n-                        end if;\n-                     end if;\n-\n-                  else\n-                     --  For a non library project, just add the path name of\n-                     --  the archive.\n-\n-                     Add_Argument\n-                       (Get_Name_String (Data.Object_Directory) &\n-                        Directory_Separator &\n-                        \"lib\" & Get_Name_String (Data.Name) &\n-                        '.' & Archive_Ext,\n-                        Verbose_Mode);\n-                  end if;\n+               if Project = Main_Project\n+                 or else Data.Other_Sources_Present\n+               then\n+                  Add_Archive_Path;\n                end if;\n             end if;\n          end if;\n       end Recursive_Add_Archives;\n \n+   --  Start of processing for Add_Archives\n+\n    begin\n       --  First, mark all projects as not processed\n \n@@ -723,11 +757,15 @@ package body Makegpr is\n       if Last_Argument + Args'Length > Arguments'Last then\n          declare\n             New_Arguments : constant Argument_List_Access :=\n-              new Argument_List\n-                (1 .. Last_Argument + Args'Length + Initial_Argument_Count);\n+                              new Argument_List\n+                                    (1 .. Last_Argument + Args'Length +\n+                                          Initial_Argument_Count);\n+\n             New_Arguments_Displayed : constant Booleans :=\n-              new Boolean_Array\n-                (1 .. Last_Argument + Args'Length + Initial_Argument_Count);\n+                                        new Boolean_Array\n+                                              (1 .. Last_Argument +\n+                                                    Args'Length +\n+                                                    Initial_Argument_Count);\n \n          begin\n             New_Arguments (1 .. Last_Argument) :=\n@@ -790,7 +828,7 @@ package body Makegpr is\n    -- Add_Source_Id --\n    -------------------\n \n-   procedure Add_Source_Id (Id : Other_Source_Id) is\n+   procedure Add_Source_Id (Project : Project_Id; Id : Other_Source_Id) is\n    begin\n       --  Reallocate the array, if necessary\n \n@@ -808,7 +846,7 @@ package body Makegpr is\n       end if;\n \n       Last_Source := Last_Source + 1;\n-      Source_Indexes (Last_Source) := (Id, False);\n+      Source_Indexes (Last_Source) := (Project, Id, False);\n    end Add_Source_Id;\n \n    ----------------------------\n@@ -902,25 +940,35 @@ package body Makegpr is\n \n       if Switches /= Nil_Variable_Value then\n          Element_Id := Switches.Values;\n-\n          while Element_Id /= Nil_String loop\n             Element := String_Elements.Table (Element_Id);\n \n             if Element.Value /= No_Name then\n-               Add_Argument (Get_Name_String (Element.Value), True);\n+               Get_Name_String (Element.Value);\n+\n+               if not Quiet_Output then\n+\n+                  --  When not in quiet output (no -q), check that the switch\n+                  --  is not the concatenation of several valid switches,\n+                  --  such as \"-g -v\". If it is, issue a warning.\n+\n+                  Check (Option => Name_Buffer (1 .. Name_Len));\n+               end if;\n+\n+               Add_Argument (Name_Buffer (1 .. Name_Len), True);\n             end if;\n \n             Element_Id := Element.Next;\n          end loop;\n       end if;\n    end Add_Switches;\n \n-   -------------------\n-   -- Build_Archive --\n-   -------------------\n+   --------------------------\n+   -- Build_Global_Archive --\n+   --------------------------\n \n-   procedure Build_Archive (Project : Project_Id; Unconditionally : Boolean) is\n-      Data      : constant Project_Data := Projects.Table (Project);\n+   procedure Build_Global_Archive is\n+      Data      : Project_Data := Projects.Table (Main_Project);\n       Source_Id : Other_Source_Id;\n       Source    : Other_Source;\n       Success   : Boolean;\n@@ -933,37 +981,345 @@ package body Makegpr is\n         \"lib\" & Get_Name_String (Data.Name) & \".deps\";\n       --  The name of the archive dependency file for this project\n \n-      Need_To_Rebuild : Boolean := Unconditionally;\n+      Need_To_Rebuild : Boolean := Need_To_Rebuild_Global_Archive;\n       --  When True, archive will be rebuilt\n \n       File : Prj.Util.Text_File;\n \n-      Object_Name : Name_Id;\n-      Time_Stamp  : Time_Stamp_Type;\n+      Object_Path  : Name_Id;\n+      Time_Stamp   : Time_Stamp_Type;\n \n       Saved_Last_Argument : Natural;\n+      First_Object        : Natural;\n+\n+      Discard : Boolean;\n \n    begin\n-      --  First, make sure that the archive builder (ar) is on the path\n+      Check_Archive_Builder;\n \n-      if Archive_Builder_Path = null then\n-         Archive_Builder_Path := Locate_Exec_On_Path (Archive_Builder);\n+      Change_Dir (Get_Name_String (Data.Object_Directory));\n \n-         if Archive_Builder_Path = null then\n-            Osint.Fail\n-              (\"unable to locate archive builder \"\"\",\n-               Archive_Builder,\n-               \"\"\"\");\n+      if not Need_To_Rebuild then\n+         if Verbose_Mode then\n+            Write_Str  (\"   Checking \");\n+            Write_Line (Archive_Name);\n          end if;\n \n-         --  If there is an archive indexer (ranlib), try to locate it on the\n-         --  path. Don't fail if it is not found.\n+         --  If the archive does not exist, of course it needs to be built\n \n-         if Archive_Indexer /= \"\" then\n-            Archive_Indexer_Path := Locate_Exec_On_Path (Archive_Indexer);\n+         if not Is_Regular_File (Archive_Name) then\n+            Need_To_Rebuild := True;\n+\n+            if Verbose_Mode then\n+               Write_Line (\"      -> archive does not exist\");\n+            end if;\n+\n+         --  Archive does exist\n+\n+         else\n+            --  Check the archive dependency file\n+\n+            Open (File, Archive_Dep_Name);\n+\n+            --  If the archive dependency file does not exist, we need to\n+            --  to rebuild the archive and to create its dependency file.\n+\n+            if not Is_Valid (File) then\n+               Need_To_Rebuild := True;\n+\n+               if Verbose_Mode then\n+                  Write_Str  (\"      -> archive dependency file \");\n+                  Write_Str  (Archive_Dep_Name);\n+                  Write_Line (\" does not exist\");\n+               end if;\n+\n+            else\n+               --  Put all sources of language other than Ada in\n+               --  Source_Indexes.\n+\n+               for Proj in 1 .. Projects.Last loop\n+                  Data := Projects.Table (Proj);\n+\n+                  if not Data.Library then\n+                     Last_Source := 0;\n+                     Source_Id := Data.First_Other_Source;\n+\n+                     while Source_Id /= No_Other_Source loop\n+                        Add_Source_Id (Proj, Source_Id);\n+                        Source_Id := Other_Sources.Table (Source_Id).Next;\n+                     end loop;\n+                  end if;\n+               end loop;\n+\n+               --  Read the dependency file, line by line\n+\n+               while not End_Of_File (File) loop\n+                  Get_Line (File, Name_Buffer, Name_Len);\n+\n+                  --  First line is the path of the object file\n+\n+                  Object_Path := Name_Find;\n+                  Source_Id := No_Other_Source;\n+\n+                  --  Check if this object file is for a source of this project\n+\n+                  for S in 1 .. Last_Source loop\n+                     Source_Id := Source_Indexes (S).Id;\n+                     Source := Other_Sources.Table (Source_Id);\n+\n+                     if (not Source_Indexes (S).Found)\n+                       and then Source.Object_Path = Object_Path\n+                     then\n+                        --  We have found the object file: get the source\n+                        --  data, and mark it as found.\n+\n+                        Source_Indexes (S).Found := True;\n+                        exit;\n+                     end if;\n+                  end loop;\n+\n+                  --  If it is not for a source of this project, then the\n+                  --  archive needs to be rebuilt.\n+\n+                  if Source_Id = No_Other_Source then\n+                     Need_To_Rebuild := True;\n+                     if Verbose_Mode then\n+                        Write_Str  (\"      -> \");\n+                        Write_Str  (Get_Name_String (Object_Path));\n+                        Write_Line (\" is not an object of any project\");\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+\n+                  --  The second line is the time stamp of the object file.\n+                  --  If there is no next line, then the dependency file is\n+                  --  truncated, and the archive need to be rebuilt.\n+\n+                  if End_Of_File (File) then\n+                     Need_To_Rebuild := True;\n+\n+                     if Verbose_Mode then\n+                        Write_Str  (\"      -> archive dependency file \");\n+                        Write_Line (\" is truncated\");\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+\n+                  Get_Line (File, Name_Buffer, Name_Len);\n+\n+                  --  If the line has the wrong number of characters, then\n+                  --  the dependency file is incorrectly formatted, and the\n+                  --  archive needs to be rebuilt.\n+\n+                  if Name_Len /= Time_Stamp_Length then\n+                     Need_To_Rebuild := True;\n+\n+                     if Verbose_Mode then\n+                        Write_Str  (\"      -> archive dependency file \");\n+                        Write_Line (\" is incorrectly formatted (time stamp)\");\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+\n+                  Time_Stamp := Time_Stamp_Type (Name_Buffer (1 .. Name_Len));\n+\n+                  --  If the time stamp in the dependency file is different\n+                  --  from the time stamp of the object file, then the archive\n+                  --  needs to be rebuilt.\n+\n+                  if Time_Stamp /= Source.Object_TS then\n+                     Need_To_Rebuild := True;\n+\n+                     if Verbose_Mode then\n+                        Write_Str  (\"      -> time stamp of \");\n+                        Write_Str  (Get_Name_String (Object_Path));\n+                        Write_Str  (\" is incorrect in the archive\");\n+                        Write_Line (\" dependency file\");\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               Close (File);\n+            end if;\n          end if;\n       end if;\n \n+      if not Need_To_Rebuild then\n+         if Verbose_Mode then\n+            Write_Line  (\"      -> up to date\");\n+         end if;\n+\n+      --  Archive needs to be rebuilt\n+\n+      else\n+         --  If the archive is built, then linking will need to occur\n+         --  unconditionally.\n+\n+         Need_To_Relink := True;\n+\n+         --  If archive already exists, first delete it\n+\n+         --  Comment needed on why we discard result???\n+\n+         if Is_Regular_File (Archive_Name) then\n+            Delete_File (Archive_Name, Discard);\n+         end if;\n+\n+         Last_Argument := 0;\n+\n+         --  Start with the options found in MLib.Tgt (usually just \"rc\")\n+\n+         Add_Arguments (Archive_Builder_Options.all, True);\n+\n+         --  Followed by the archive name\n+\n+         Add_Argument (Archive_Name, True);\n+\n+         First_Object := Last_Argument;\n+\n+         --  Followed by all the object files of the non library projects\n+\n+         for Proj in 1 .. Projects.Last loop\n+            Data := Projects.Table (Proj);\n+\n+            if not Data.Library then\n+               Source_Id := Data.First_Other_Source;\n+\n+               while Source_Id /= No_Other_Source loop\n+                  Source := Other_Sources.Table (Source_Id);\n+\n+                  --  Only include object file name that have not been\n+                  --  overriden in extending projects.\n+\n+                  if Is_Included_In_Global_Archive\n+                       (Source.Object_Name, Proj)\n+                  then\n+                     Add_Argument\n+                       (Get_Name_String (Source.Object_Path), Verbose_Mode);\n+                  end if;\n+\n+                  Source_Id := Source.Next;\n+               end loop;\n+            end if;\n+         end loop;\n+\n+         --  Spawn the archive builder (ar)\n+\n+         Saved_Last_Argument := Last_Argument;\n+\n+         Last_Argument := First_Object + Max_In_Archives;\n+\n+         loop\n+            if Last_Argument > Saved_Last_Argument then\n+               Last_Argument := Saved_Last_Argument;\n+            end if;\n+\n+            Display_Command (Archive_Builder, Archive_Builder_Path);\n+\n+            Spawn\n+              (Archive_Builder_Path.all,\n+               Arguments (1 .. Last_Argument),\n+               Success);\n+\n+            exit when not Success;\n+\n+            exit when Last_Argument = Saved_Last_Argument;\n+\n+            Arguments (1) := r;\n+            Arguments (3 .. Saved_Last_Argument - Last_Argument + 2) :=\n+              Arguments (Last_Argument + 1 .. Saved_Last_Argument);\n+            Saved_Last_Argument := Saved_Last_Argument - Last_Argument + 2;\n+         end loop;\n+\n+         --  If the archive was built, run the archive indexer (ranlib)\n+         --  if there is one.\n+\n+         if Success then\n+\n+            --  If the archive was built, run the archive indexer (ranlib),\n+            --  if there is one.\n+\n+            if Archive_Indexer_Path /= null then\n+               Last_Argument := 0;\n+               Add_Argument (Archive_Name, True);\n+\n+               Display_Command (Archive_Indexer, Archive_Indexer_Path);\n+\n+               Spawn (Archive_Indexer_Path.all, Arguments (1 .. 1), Success);\n+\n+               if not Success then\n+\n+                  --  Running ranlib failed, delete the dependency file,\n+                  --  if it exists.\n+\n+                  if Is_Regular_File (Archive_Dep_Name) then\n+                     Delete_File (Archive_Dep_Name, Success);\n+                  end if;\n+\n+                  --  And report the error\n+\n+                  Report_Error\n+                    (\"running\" & Archive_Indexer & \" for project \"\"\",\n+                     Get_Name_String (Data.Name),\n+                     \"\"\" failed\");\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  The archive was correctly built, create its dependency file\n+\n+            Create_Global_Archive_Dependency_File (Archive_Dep_Name);\n+\n+         --  Building the archive failed, delete dependency file if one exists\n+\n+         else\n+            if Is_Regular_File (Archive_Dep_Name) then\n+               Delete_File (Archive_Dep_Name, Success);\n+            end if;\n+\n+            --  And report the error\n+\n+            Report_Error\n+              (\"building archive for project \"\"\",\n+               Get_Name_String (Data.Name),\n+               \"\"\" failed\");\n+         end if;\n+      end if;\n+   end Build_Global_Archive;\n+\n+   -------------------\n+   -- Build_Library --\n+   -------------------\n+\n+   procedure Build_Library (Project : Project_Id; Unconditionally : Boolean) is\n+      Data      : constant Project_Data := Projects.Table (Project);\n+      Source_Id : Other_Source_Id;\n+      Source    : Other_Source;\n+\n+      Archive_Name : constant String :=\n+                       \"lib\" & Get_Name_String (Data.Name) & '.' & Archive_Ext;\n+      --  The name of the archive file for this project\n+\n+      Archive_Dep_Name : constant String :=\n+                           \"lib\" & Get_Name_String (Data.Name) & \".deps\";\n+      --  The name of the archive dependency file for this project\n+\n+      Need_To_Rebuild : Boolean := Unconditionally;\n+      --  When True, archive will be rebuilt\n+\n+      File : Prj.Util.Text_File;\n+\n+      Object_Name : Name_Id;\n+      Time_Stamp  : Time_Stamp_Type;\n+\n+   begin\n+      Check_Archive_Builder;\n+\n       --  If Unconditionally is False, check if the archive need to be built\n \n       if not Need_To_Rebuild then\n@@ -1001,14 +1357,13 @@ package body Makegpr is\n                end if;\n \n             else\n-               --  Put all sources of language other than Ada in\n-               --  Source_Indexes.\n+               --  Put all sources of language other than Ada in Source_Indexes\n \n                Last_Source := 0;\n                Source_Id := Data.First_Other_Source;\n \n                while Source_Id /= No_Other_Source loop\n-                  Add_Source_Id (Source_Id);\n+                  Add_Source_Id (Project, Source_Id);\n                   Source_Id := Other_Sources.Table (Source_Id).Next;\n                end loop;\n \n@@ -1045,6 +1400,7 @@ package body Makegpr is\n \n                   if Source_Id = No_Other_Source then\n                      Need_To_Rebuild := True;\n+\n                      if Verbose_Mode then\n                         Write_Str  (\"      -> \");\n                         Write_Str  (Get_Name_String (Object_Name));\n@@ -1139,22 +1495,17 @@ package body Makegpr is\n          end if;\n       end if;\n \n-      --  Build the archive if necessary\n+      --  Build the library if necessary\n \n       if Need_To_Rebuild then\n \n-         --  If an archive is built, then linking will need to occur\n+         --  If a library is built, then linking will need to occur\n          --  unconditionally.\n \n          Need_To_Relink := True;\n \n          Last_Argument := 0;\n \n-         --  If it is a library project file, we need to build the library\n-         --  in the library directory.\n-\n-         if Data.Library then\n-\n             --  If there are sources in Ada, then gnatmake will build the\n             --  library, so nothing to do.\n \n@@ -1192,129 +1543,106 @@ package body Makegpr is\n                      Lib_Dir      => Get_Name_String (Data.Library_Dir),\n                      Symbol_Data  => No_Symbols,\n                      Driver_Name  => No_Name,\n-                     Lib_Address  => \"\",\n                      Lib_Version  => \"\",\n-                     Relocatable  => Data.Library_Kind = Relocatable,\n                      Auto_Init    => False);\n-               end if;\n-            end if;\n-\n-            --  Create fake empty archive, so we can check its time stamp later\n-\n-            declare\n-               Archive : Ada.Text_IO.File_Type;\n-               use Ada.Text_IO;\n-            begin\n-               Create (Archive, Out_File, Archive_Name);\n-               Close (Archive);\n-            end;\n-\n-            Create_Archive_Dependency_File\n-              (Archive_Dep_Name, Data.First_Other_Source);\n-\n-            return;\n-         end if;\n-\n-         --  Start with the options found in MLib.Tgt (usually just \"rc\")\n-\n-         Add_Arguments (Archive_Builder_Options.all, True);\n-\n-         --  Followed by the archive name\n-\n-         Add_Argument (Archive_Name, True);\n-\n-         --  Followed by all the object files of the project\n-\n-         Source_Id := Data.First_Other_Source;\n-\n-         while Source_Id /= No_Other_Source loop\n-            Source := Other_Sources.Table (Source_Id);\n-            Add_Argument (Get_Name_String (Source.Object_Name), Verbose_Mode);\n-            Source_Id := Source.Next;\n-         end loop;\n-\n-         --  Spawn the archive builder (ar)\n-\n-         Saved_Last_Argument := Last_Argument;\n-\n-         Last_Argument := Max_In_Archives;\n-\n-         loop\n-            if Last_Argument > Saved_Last_Argument then\n-               Last_Argument := Saved_Last_Argument;\n-            end if;\n-\n-            Display_Command (Archive_Builder, Archive_Builder_Path);\n-\n-            Spawn\n-              (Archive_Builder_Path.all,\n-               Arguments (1 .. Last_Argument),\n-               Success);\n+               end if;\n+            end if;\n \n-            exit when not Success;\n+            --  Create fake empty archive, so we can check its time stamp later\n \n-            exit when Last_Argument = Saved_Last_Argument;\n+            declare\n+               Archive : Ada.Text_IO.File_Type;\n+               use Ada.Text_IO;\n+            begin\n+               Create (Archive, Out_File, Archive_Name);\n+               Close (Archive);\n+            end;\n \n-            Arguments (1) := r;\n-            Arguments (3 .. Saved_Last_Argument - Last_Argument + 2) :=\n-              Arguments (Last_Argument + 1 .. Saved_Last_Argument);\n-            Saved_Last_Argument := Saved_Last_Argument - Last_Argument + 2;\n-         end loop;\n+            Create_Archive_Dependency_File\n+              (Archive_Dep_Name, Data.First_Other_Source);\n \n-         if Success then\n+      end if;\n+   end Build_Library;\n \n-            --  If the archive was built, run the archive indexer (ranlib),\n-            --  if there is one.\n+   -----------\n+   -- Check --\n+   -----------\n \n-            if Archive_Indexer_Path /= null then\n-               Last_Argument := 0;\n-               Add_Argument (Archive_Name, True);\n+   procedure Check (Option : String) is\n+      First : Positive := Option'First;\n+      Last  : Natural;\n \n-               Display_Command (Archive_Indexer, Archive_Indexer_Path);\n+   begin\n+      for Index in Option'First + 1 .. Option'Last - 1 loop\n+         if Option (Index) = ' ' and then Option (Index + 1) = '-' then\n+            Write_Str (\"warning: switch \"\"\");\n+            Write_Str (Option);\n+            Write_Str (\"\"\" is suspicious; consider using \");\n+\n+            Last := First;\n+            while Last <= Option'Last loop\n+               if Option (Last) = ' ' then\n+                  if First /= Option'First then\n+                     Write_Str (\", \");\n+                  end if;\n \n-               Spawn (Archive_Indexer_Path.all, Arguments (1 .. 1), Success);\n+                  Write_Char ('\"');\n+                  Write_Str (Option (First .. Last - 1));\n+                  Write_Char ('\"');\n \n-               if not Success then\n+                  while Last <= Option'Last and then Option (Last) = ' ' loop\n+                     Last := Last + 1;\n+                  end loop;\n \n-                  --  Running ranlib failed, delete the dependency file,\n-                  --  if it exists.\n+                  First := Last;\n \n-                  if Is_Regular_File (Archive_Dep_Name) then\n-                     Delete_File (Archive_Dep_Name, Success);\n-                  end if;\n+               else\n+                  if Last = Option'Last then\n+                     if First /= Option'First then\n+                        Write_Str (\", \");\n+                     end if;\n \n-                  --  And report the error\n+                     Write_Char ('\"');\n+                     Write_Str (Option (First .. Last));\n+                     Write_Char ('\"');\n+                  end if;\n \n-                  Report_Error\n-                    (\"running\" & Archive_Indexer & \" for project \"\"\",\n-                     Get_Name_String (Data.Name),\n-                     \"\"\" failed\");\n-                  return;\n+                  Last := Last + 1;\n                end if;\n-            end if;\n+            end loop;\n \n-            --  The archive was correctly built, create its dependency file\n+            Write_Line (\" instead\");\n+            exit;\n+         end if;\n+      end loop;\n+   end Check;\n \n-            Create_Archive_Dependency_File\n-              (Archive_Dep_Name, Data.First_Other_Source);\n+   ---------------------------\n+   -- Check_Archive_Builder --\n+   ---------------------------\n \n-         else\n-            --  Building the archive failed, delete the dependency file, if\n-            --  one exists.\n+   procedure Check_Archive_Builder is\n+   begin\n+      --  First, make sure that the archive builder (ar) is on the path\n \n-            if Is_Regular_File (Archive_Dep_Name) then\n-               Delete_File (Archive_Dep_Name, Success);\n-            end if;\n+      if Archive_Builder_Path = null then\n+         Archive_Builder_Path := Locate_Exec_On_Path (Archive_Builder);\n \n-            --  And report the error\n+         if Archive_Builder_Path = null then\n+            Osint.Fail\n+              (\"unable to locate archive builder \"\"\",\n+               Archive_Builder,\n+               \"\"\"\");\n+         end if;\n \n-            Report_Error\n-              (\"building archive for project \"\"\",\n-               Get_Name_String (Data.Name),\n-               \"\"\" failed\");\n+         --  If there is an archive indexer (ranlib), try to locate it on the\n+         --  path. Don't fail if it is not found.\n+\n+         if Archive_Indexer /= \"\" then\n+            Archive_Indexer_Path := Locate_Exec_On_Path (Archive_Indexer);\n          end if;\n       end if;\n-   end Build_Archive;\n+   end Check_Archive_Builder;\n \n    ------------------------------\n    -- Check_Compilation_Needed --\n@@ -1330,8 +1658,7 @@ package body Makegpr is\n       Dep_Name    : constant String := Get_Name_String (Source.Dep_Name);\n \n       Source_In_Dependencies : Boolean := False;\n-      --  Set to True if the source was find in the dependency file of its\n-      --  object file.\n+      --  Set True if source was found in dependency file of its object file\n \n       Dep_File : Prj.Util.Text_File;\n       Start    : Natural;\n@@ -1349,8 +1676,7 @@ package body Makegpr is\n          Write_Line (\" ... \");\n       end if;\n \n-      --  If the object file does not exist, of course the source need to be\n-      --  compiled.\n+      --  If object file does not exist, of course source need to be compiled\n \n       if Source.Object_TS = Empty_Time_Stamp then\n          if Verbose_Mode then\n@@ -1432,8 +1758,7 @@ package body Makegpr is\n          end loop;\n \n          --  If dependency file contains only empty lines or comments, then\n-         --  the dependencies are unknown, and the source needs to be\n-         --  recompiled.\n+         --  dependencies are unknown, and the source needs to be recompiled.\n \n          if End_Of_File_Reached then\n             if Verbose_Mode then\n@@ -1450,8 +1775,7 @@ package body Makegpr is\n       Start  := 1;\n       Finish := Index (Name_Buffer (1 .. Name_Len), \": \");\n \n-      --  The first line must start with the name of the object file, followed\n-      --  by a colon (:).\n+      --  First line must start with name of object file, followed by colon\n \n       if Finish = 0 or else Name_Buffer (1 .. Finish - 1) /= Object_Name then\n          if Verbose_Mode then\n@@ -1470,7 +1794,7 @@ package body Makegpr is\n \n          Line_Loop : loop\n             declare\n-               Line : constant String := Name_Buffer (1 .. Name_Len);\n+               Line : constant String  := Name_Buffer (1 .. Name_Len);\n                Last : constant Natural := Name_Len;\n \n             begin\n@@ -1631,13 +1955,13 @@ package body Makegpr is\n       CPATH   : String_Access := null;\n \n    begin\n-      --  If the compiler is not know yet, get its path name\n+      --  If the compiler is not known yet, get its path name\n \n       if Compiler_Names (Source.Language) = null then\n          Get_Compiler (Source.Language);\n       end if;\n \n-      --  For non GCC compilers, get the dependency file, calling first the\n+      --  For non GCC compilers, get the dependency file, first calling the\n       --  compiler with the switch -M.\n \n       if not Compiler_Is_Gcc (Source.Language) then\n@@ -1663,8 +1987,7 @@ package body Makegpr is\n             Add_Argument (Options (Source.Language).Table (J), True);\n          end loop;\n \n-         --  Finally, add the imported directory switches for this\n-         --  project file.\n+         --  Finally, add imported directory switches for this project file\n \n          Add_Search_Directories (Data, Source.Language);\n \n@@ -1800,9 +2123,7 @@ package body Makegpr is\n       --  Add the compiling switches for the language specified\n       --  on the command line, if any.\n \n-      for\n-        J in 1 .. Comp_Opts.Last (Options (Source.Language))\n-      loop\n+      for J in 1 .. Comp_Opts.Last (Options (Source.Language)) loop\n          Add_Argument (Options (Source.Language).Table (J), True);\n       end loop;\n \n@@ -1830,10 +2151,11 @@ package body Makegpr is\n          Arguments (1 .. Last_Argument),\n          Success);\n \n+      --  Case of successful compilation\n+\n       if Success then\n \n-         --  Compilation was successful, update the time stamp\n-         --  of the object file.\n+         --  Update the time stamp of the object file\n \n          Source.Object_TS := File_Stamp (Source.Object_Name);\n \n@@ -1859,6 +2181,8 @@ package body Makegpr is\n             Other_Sources.Table (Source_Id) := Source;\n          end if;\n \n+      --  Compilation failed\n+\n       else\n          Local_Errors := True;\n          Report_Error\n@@ -1884,9 +2208,7 @@ package body Makegpr is\n \n    begin\n       Ada_Mains.Init;\n-\n       To_Mixed (Project_Name);\n-\n       Compile_Only := True;\n \n       Get_Imported_Directories (Main_Project, Data);\n@@ -1896,7 +2218,7 @@ package body Makegpr is\n \n       Change_Dir (Get_Name_String (Data.Object_Directory));\n \n-      if not Data.Sources_Present then\n+      if not Data.Other_Sources_Present then\n          if Ada_Is_A_Language then\n             Mains.Reset;\n \n@@ -1930,7 +2252,6 @@ package body Makegpr is\n \n                if not Sources_Compiled.Get (Source_Name) then\n                   Sources_Compiled.Set (Source_Name, True);\n-\n                   Source_Id := Data.First_Other_Source;\n \n                   while Source_Id /= No_Other_Source loop\n@@ -1942,8 +2263,7 @@ package body Makegpr is\n                   if Source_Id = No_Other_Source then\n                      if Ada_Is_A_Language then\n                         Ada_Mains.Increment_Last;\n-                        Ada_Mains.Table (Ada_Mains.Last) :=\n-                          new String'(Main);\n+                        Ada_Mains.Table (Ada_Mains.Last) := new String'(Main);\n \n                      else\n                         Report_Error\n@@ -1962,10 +2282,9 @@ package body Makegpr is\n \n       if Ada_Mains.Last > 0 then\n \n-         --  Invoke gnatmake for all sources that are not of a non Ada language\n+         --  Invoke gnatmake for all Ada sources\n \n          Last_Argument := 0;\n-\n          Add_Argument (Dash_u, True);\n \n          for Index in 1 .. Ada_Mains.Last loop\n@@ -2019,7 +2338,7 @@ package body Makegpr is\n          Add_Argument (Output_File_Name, True);\n       end if;\n \n-      --  Transmit to gnatmake some switches\n+      --  Transmit some switches to gnatmake\n \n       --  -c\n \n@@ -2075,8 +2394,9 @@ package body Makegpr is\n       end if;\n \n       if not Compile_Only then\n-         --  If there are linking options from the command line, transmit them\n-         --  to gnatmake.\n+\n+         --  If there are linking options from the command line,\n+         --  transmit them to gnatmake.\n \n          if Linker_Options.Last /= 0 then\n             Add_Argument (Dash_largs, True);\n@@ -2133,15 +2453,15 @@ package body Makegpr is\n       --  True when the archive needs to be built/rebuilt unconditionally\n \n    begin\n-      --  For each project file\n+      --  Loop through project files\n \n       for Project in 1 .. Projects.Last loop\n          Local_Errors := False;\n          Data := Projects.Table (Project);\n \n          --  Nothing to do when no sources of language other than Ada\n \n-         if (not Data.Virtual) and then Data.Sources_Present then\n+         if (not Data.Virtual) and then Data.Other_Sources_Present then\n \n             --  If the imported directory switches are unknown, compute them\n \n@@ -2187,11 +2507,18 @@ package body Makegpr is\n                Source_Id := Source.Next;\n             end loop;\n \n+            if Need_To_Rebuild_Archive and then (not Data.Library) then\n+               Need_To_Rebuild_Global_Archive := True;\n+            end if;\n+\n             --  If there was no compilation error, build/rebuild the archive\n             --  if necessary.\n \n-            if not Local_Errors then\n-               Build_Archive (Project, Need_To_Rebuild_Archive);\n+            if not Local_Errors\n+              and then Data.Library\n+              and then not Data.Languages (Lang_Ada)\n+            then\n+               Build_Library (Project, Need_To_Rebuild_Archive);\n             end if;\n          end if;\n       end loop;\n@@ -2229,7 +2556,10 @@ package body Makegpr is\n       use Ada.Text_IO;\n \n    begin\n-      Create (Dep_File, Out_File, Name);\n+      --  Create the file in Append mode, to avoid automatic insertion of\n+      --  an end of line if file is empty.\n+\n+      Create (Dep_File, Append_File, Name);\n \n       while Source_Id /= No_Other_Source loop\n          Source := Other_Sources.Table (Source_Id);\n@@ -2247,6 +2577,55 @@ package body Makegpr is\n          end if;\n    end Create_Archive_Dependency_File;\n \n+   -------------------------------------------\n+   -- Create_Global_Archive_Dependency_File --\n+   -------------------------------------------\n+\n+   procedure Create_Global_Archive_Dependency_File (Name : String) is\n+      Source_Id : Other_Source_Id;\n+      Source    : Other_Source;\n+      Dep_File  : Ada.Text_IO.File_Type;\n+\n+      use Ada.Text_IO;\n+\n+   begin\n+      --  Create the file in Append mode, to avoid automatic insertion of\n+      --  an end of line if file is empty.\n+\n+      Create (Dep_File, Append_File, Name);\n+\n+      --  Get all the object files of non-Ada sources in non-library projects\n+\n+      for Project in 1 .. Projects.Last loop\n+         if not Projects.Table (Project).Library then\n+            Source_Id := Projects.Table (Project).First_Other_Source;\n+\n+            while Source_Id /= No_Other_Source loop\n+               Source := Other_Sources.Table (Source_Id);\n+\n+               --  Put only those object files that are in the global archive\n+\n+               if Is_Included_In_Global_Archive\n+                    (Source.Object_Name, Project)\n+               then\n+                  Put_Line (Dep_File, Get_Name_String (Source.Object_Path));\n+                  Put_Line (Dep_File, String (Source.Object_TS));\n+               end if;\n+\n+               Source_Id := Source.Next;\n+            end loop;\n+         end if;\n+      end loop;\n+\n+      Close (Dep_File);\n+\n+   exception\n+      when others =>\n+         if Is_Open (Dep_File) then\n+            Close (Dep_File);\n+         end if;\n+   end Create_Global_Archive_Dependency_File;\n+\n    ---------------------\n    -- Display_Command --\n    ---------------------\n@@ -2261,6 +2640,7 @@ package body Makegpr is\n       --  not in Quiet Output (no -q).\n \n       if Verbose_Mode or (not Quiet_Output) then\n+\n          --  In Verbose Mode output the full path of the spawned process\n \n          if Verbose_Mode then\n@@ -2391,9 +2771,9 @@ package body Makegpr is\n          Element_Id : String_List_Id := Source_Dirs;\n          Element    : String_Element;\n          Add_Arg    : Boolean := True;\n+\n       begin\n-         --  Add each source directory path name, preceded by \"-I\" to\n-         --  Arguments.\n+         --  Add each source directory path name, preceded by \"-I\" to Arguments\n \n          while Element_Id /= Nil_String loop\n             Element := String_Elements.Table (Element_Id);\n@@ -2476,6 +2856,8 @@ package body Makegpr is\n          end if;\n       end Recursive_Get_Dirs;\n \n+   --  Start of processing for Get_Imported_Directories\n+\n    begin\n       --  First, mark all project as not processed\n \n@@ -2538,8 +2920,7 @@ package body Makegpr is\n          Write_Eol;\n       end if;\n \n-      --  Parse and process the project files for other languages\n-      --  (not for Ada).\n+      --  Parse and process project files for other languages (not for Ada)\n \n       Prj.Pars.Parse\n         (Project           => Main_Project,\n@@ -2570,14 +2951,14 @@ package body Makegpr is\n          if Mains.Number_Of_Mains = 0 then\n             Osint.Fail\n               (\"No source specified to compile in 'unique compile' mode\");\n-\n          else\n             Compile_Individual_Sources;\n             Report_Total_Errors (\"compilation\");\n          end if;\n \n       else\n-         --  First compile sources and build archives, if necessary\n+         --  First compile sources and build archives for library project,\n+         --  if necessary.\n \n          Compile_Sources;\n \n@@ -2590,6 +2971,7 @@ package body Makegpr is\n          --  If -c was not specified, link the executables, if there are any.\n \n          if not Compile_Only then\n+            Build_Global_Archive;\n             Check_For_C_Plus_Plus;\n             Link_Executables;\n          end if;\n@@ -2655,6 +3037,34 @@ package body Makegpr is\n       Osint.Add_Default_Search_Dirs;\n    end Initialize;\n \n+   -----------------------------------\n+   -- Is_Included_In_Global_Archive --\n+   -----------------------------------\n+\n+   function Is_Included_In_Global_Archive\n+     (Object_Name : Name_Id;\n+      Project     : Project_Id) return Boolean\n+   is\n+      Data   : Project_Data := Projects.Table (Project);\n+      Source : Other_Source_Id;\n+\n+   begin\n+      while Data.Extended_By /= No_Project loop\n+         Data := Projects.Table (Data.Extended_By);\n+         Source := Data.First_Other_Source;\n+\n+         while Source /= No_Other_Source loop\n+            if Other_Sources.Table (Source).Object_Name = Object_Name then\n+               return False;\n+            else\n+               Source := Other_Sources.Table (Source).Next;\n+            end if;\n+         end loop;\n+      end loop;\n+\n+      return True;\n+   end Is_Included_In_Global_Archive;\n+\n    ----------------------\n    -- Link_Executables --\n    ----------------------\n@@ -2684,9 +3094,19 @@ package body Makegpr is\n       procedure Add_C_Plus_Plus_Link_For_Gnatmake;\n       --  Add the --LINK= switch for gnatlink, depending on the C++ compiler\n \n+      procedure Check_Time_Stamps (Exec_Time_Stamp : Time_Stamp_Type);\n+      --  Check if there is an archive that is more recent than the executable\n+      --  to decide if we need to relink.\n+\n       procedure Choose_C_Plus_Plus_Link_Process;\n       --  If the C++ compiler is not g++, create the correct script to link\n \n+      procedure Link_Foreign\n+        (Main    : String;\n+         Main_Id : Name_Id;\n+         Source  : Other_Source);\n+      --  Link a non-Ada main, when there is no Ada code\n+\n       ---------------------------------------\n       -- Add_C_Plus_Plus_Link_For_Gnatmake --\n       ---------------------------------------\n@@ -2707,6 +3127,61 @@ package body Makegpr is\n          end if;\n       end Add_C_Plus_Plus_Link_For_Gnatmake;\n \n+      -----------------------\n+      -- Check_Time_Stamps --\n+      -----------------------\n+\n+      procedure Check_Time_Stamps (Exec_Time_Stamp : Time_Stamp_Type) is\n+         Prj_Data : Project_Data;\n+\n+      begin\n+         for Prj in 1 .. Projects.Last loop\n+            Prj_Data := Projects.Table (Prj);\n+\n+            --  There is an archive only in project\n+            --  files with sources other than Ada\n+            --  sources.\n+\n+            if Data.Other_Sources_Present then\n+               declare\n+                  Archive_Path : constant String :=\n+                                   Get_Name_String\n+                                     (Prj_Data.Object_Directory) &\n+                  Directory_Separator &\n+                  \"lib\" &\n+                  Get_Name_String (Prj_Data.Name) &\n+                    '.' & Archive_Ext;\n+                  Archive_TS   : Time_Stamp_Type;\n+               begin\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer\n+                    (Archive_Path);\n+                  Archive_TS := File_Stamp (Name_Find);\n+\n+                  --  If the archive is later than the\n+                  --  executable, we need to relink.\n+\n+                  if Archive_TS /=  Empty_Time_Stamp\n+                    and then\n+                      Exec_Time_Stamp < Archive_TS\n+                  then\n+                     Need_To_Relink := True;\n+\n+                     if Verbose_Mode then\n+                        Write_Str (\"      -> \");\n+                        Write_Str (Archive_Path);\n+                        Write_Str (\" has time stamp \");\n+                        Write_Str (\"later than \");\n+                        Write_Line (\"executable\");\n+                     end if;\n+\n+                     exit;\n+                  end if;\n+               end;\n+            end if;\n+         end loop;\n+      end Check_Time_Stamps;\n+\n       -------------------------------------\n       -- Choose_C_Plus_Plus_Link_Process --\n       -------------------------------------\n@@ -2747,6 +3222,159 @@ package body Makegpr is\n          end if;\n       end Choose_C_Plus_Plus_Link_Process;\n \n+      ------------------\n+      -- Link_Foreign --\n+      ------------------\n+\n+      procedure Link_Foreign\n+        (Main    : String;\n+         Main_Id : Name_Id;\n+         Source  : Other_Source)\n+      is\n+         Executable_Name : constant String :=\n+                             Get_Name_String\n+                               (Executable_Of\n+                                  (Project  => Main_Project,\n+                                   Main     => Main_Id,\n+                                   Index    => 0,\n+                                   Ada_Main => False));\n+         --  File name of the executable\n+\n+         Executable_Path : constant String :=\n+                             Get_Name_String\n+                               (Data.Exec_Directory) &\n+                                Directory_Separator &\n+                                Executable_Name;\n+         --  Path name of the executable\n+\n+         Exec_Time_Stamp : Time_Stamp_Type;\n+\n+      begin\n+         --  Now, check if the executable is up to date. It is considered\n+         --  up to date if its time stamp is not earlier that the time stamp\n+         --  of any archive. Only do that if we don't know if we need to link.\n+\n+         if not Need_To_Relink then\n+\n+            --  Get the time stamp of the executable\n+\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (Executable_Path);\n+            Exec_Time_Stamp := File_Stamp (Name_Find);\n+\n+            if Verbose_Mode then\n+               Write_Str  (\"   Checking executable \");\n+               Write_Line (Executable_Name);\n+            end if;\n+\n+            --  If executable does not exist, we need to link\n+\n+            if Exec_Time_Stamp = Empty_Time_Stamp then\n+               Need_To_Relink := True;\n+\n+               if Verbose_Mode then\n+                  Write_Line (\"      -> not found\");\n+               end if;\n+\n+            --  Otherwise, get the time stamps of each archive. If one of\n+            --  them is found later than the executable, we need to relink.\n+\n+            else\n+               Check_Time_Stamps (Exec_Time_Stamp);\n+            end if;\n+\n+            --  If Need_To_Relink is False, we are done\n+\n+            if Verbose_Mode and (not Need_To_Relink) then\n+               Write_Line (\"      -> up to date\");\n+            end if;\n+         end if;\n+\n+         --  Prepare to link\n+\n+         if Need_To_Relink then\n+            Link_Done := True;\n+\n+            Last_Argument := 0;\n+\n+            --  Specify the executable path name\n+\n+            Add_Argument (Dash_o, True);\n+            Add_Argument\n+              (Get_Name_String (Data.Exec_Directory) &\n+               Directory_Separator &\n+               Get_Name_String\n+                 (Executable_Of\n+                    (Project  => Main_Project,\n+                     Main     => Main_Id,\n+                     Index    => 0,\n+                     Ada_Main => False)),\n+               True);\n+\n+            --  Specify the object file of the main source\n+\n+            Add_Argument\n+              (Object_Dir & Directory_Separator &\n+               Get_Name_String (Source.Object_Name),\n+               True);\n+\n+            --  Add the switches specified in package Linker of\n+            --  the main project.\n+\n+            Add_Switches\n+              (Data      => Data,\n+               Proc      => Linker,\n+               Language  => Source.Language,\n+               File_Name => Main_Id);\n+\n+            --  Add the switches specified in attribute\n+            --  Linker_Options of packages Linker.\n+\n+            if Link_Options_Switches = null then\n+               Link_Options_Switches :=\n+                 new Argument_List'\n+                   (Linker_Options_Switches (Main_Project));\n+            end if;\n+\n+            Add_Arguments (Link_Options_Switches.all, True);\n+\n+            --  Add the linking options specified on the\n+            --  command line.\n+\n+            for Arg in 1 ..  Linker_Options.Last loop\n+               Add_Argument (Linker_Options.Table (Arg), True);\n+            end loop;\n+\n+            --  Add all the archives, in a correct order\n+\n+            Add_Archives (For_Gnatmake => False);\n+\n+            --  If there are shared libraries and the run path\n+            --  option is supported, add the run path switch.\n+\n+            if Lib_Path.Last > 0 then\n+               Add_Argument\n+                 (Path_Option.all &\n+                  String (Lib_Path.Table (1 .. Lib_Path.Last)),\n+                  Verbose_Mode);\n+            end if;\n+\n+            --  And invoke the linker\n+\n+            Display_Command (Linker_Name.all, Linker_Path);\n+            Spawn\n+              (Linker_Path.all,\n+               Arguments (1 .. Last_Argument),\n+               Success);\n+\n+            if not Success then\n+               Report_Error (\"could not link \", Main);\n+            end if;\n+         end if;\n+      end Link_Foreign;\n+\n+   --  Start of processing of Link_Executables\n+\n    begin\n       --  If no mains specified, get mains from attribute Main, if it exists\n \n@@ -2769,6 +3397,7 @@ package body Makegpr is\n       end if;\n \n       if Mains.Number_Of_Mains = 0 then\n+\n          --  If the attribute Main is an empty list or not specified,\n          --  there is nothing to do.\n \n@@ -2786,10 +3415,12 @@ package body Makegpr is\n \n       --  Check how we are going to do the link\n \n-      if not Data.Sources_Present then\n+      if not Data.Other_Sources_Present then\n+\n          --  Only Ada sources in the main project, and even maybe not\n \n          if not Data.Languages (Lang_Ada) then\n+\n             --  Fail if the main project has no source of any language\n \n             Osint.Fail\n@@ -2802,8 +3433,7 @@ package body Makegpr is\n \n             Last_Argument := 0;\n \n-            --  Choose the correct linker if there is C++ code in other\n-            --  projects.\n+            --  Choose correct linker if there is C++ code in other projects\n \n             if C_Plus_Plus_Is_Used then\n                Choose_C_Plus_Plus_Link_Process;\n@@ -2820,10 +3450,11 @@ package body Makegpr is\n          --  sources in Ada.\n \n          if Data.Languages (Lang_Ada) then\n+\n             --  There is a mix of Ada and other language sources in the main\n             --  project. Any main that is not a source of the other languages\n             --  will be deemed to be an Ada main.\n-            --\n+\n             --  Find the mains of the other languages and the Ada mains.\n \n             Mains.Reset;\n@@ -2834,8 +3465,9 @@ package body Makegpr is\n \n             loop\n                declare\n-                  Main : constant String := Mains.Next_Main;\n+                  Main    : constant String := Mains.Next_Main;\n                   Main_Id : Name_Id;\n+\n                begin\n                   exit when Main'Length = 0;\n \n@@ -2883,6 +3515,7 @@ package body Makegpr is\n             for Main in 1 .. Other_Mains.Last loop\n                declare\n                   Source : constant Other_Source := Other_Mains.Table (Main);\n+\n                begin\n                   Last_Argument := 0;\n \n@@ -3007,200 +3640,7 @@ package body Makegpr is\n                         Get_Name_String (Data.Name));\n \n                   else\n-                     declare\n-                        Executable_Name : constant String :=\n-                          Get_Name_String\n-                            (Executable_Of\n-                                 (Project  => Main_Project,\n-                                  Main     => Main_Id,\n-                                  Index    => 0,\n-                                  Ada_Main => False));\n-                        --  File name of the executable\n-\n-                        Executable_Path : constant String :=\n-                                            Get_Name_String\n-                                              (Data.Exec_Directory) &\n-                                            Directory_Separator &\n-                                            Executable_Name;\n-                        --  Path name of the executable\n-\n-                        Exec_Time_Stamp : Time_Stamp_Type;\n-\n-                     begin\n-                        --  Now, check if the executable is up to date.\n-                        --  It is considered up to date if its time stamp is\n-                        --  not earlier that the time stamp of any archive.\n-                        --  Only do that if we don't know if we need to link.\n-\n-                        if not Need_To_Relink then\n-\n-                           --  Get the time stamp of the executable\n-\n-                           Name_Len := 0;\n-                           Add_Str_To_Name_Buffer (Executable_Path);\n-                           Exec_Time_Stamp := File_Stamp (Name_Find);\n-\n-                           if Verbose_Mode then\n-                              Write_Str  (\"   Checking executable \");\n-                              Write_Line (Executable_Name);\n-                           end if;\n-\n-                           --  If executable does not exist, we need to link\n-\n-                           if Exec_Time_Stamp = Empty_Time_Stamp then\n-                              Need_To_Relink := True;\n-\n-                              if Verbose_Mode then\n-                                 Write_Line (\"      -> not found\");\n-                              end if;\n-\n-                           else\n-                              --  Otherwise, get the time stamps of each\n-                              --  archive. If one of them is found later than\n-                              --  the executable, we need to relink.\n-\n-                              declare\n-                                 Prj_Data : Project_Data;\n-\n-                              begin\n-                                 for Prj in 1 .. Projects.Last loop\n-                                    Prj_Data := Projects.Table (Prj);\n-\n-                                    --  There is an archive only in project\n-                                    --  files with sources other than Ada\n-                                    --  sources.\n-\n-                                    if Data.Sources_Present then\n-                                       declare\n-                                          Archive_Path : constant String :=\n-                                            Get_Name_String\n-                                              (Prj_Data.Object_Directory) &\n-                                          Directory_Separator &\n-                                          \"lib\" &\n-                                          Get_Name_String (Prj_Data.Name) &\n-                                          '.' & Archive_Ext;\n-                                          Archive_TS : Time_Stamp_Type;\n-                                       begin\n-                                          Name_Len := 0;\n-                                          Add_Str_To_Name_Buffer\n-                                            (Archive_Path);\n-                                          Archive_TS := File_Stamp (Name_Find);\n-\n-                                          --  If the archive is later than the\n-                                          --  executable, we need to relink.\n-\n-                                          if Archive_TS /=  Empty_Time_Stamp\n-                                            and then\n-                                              Exec_Time_Stamp < Archive_TS\n-                                          then\n-                                             Need_To_Relink := True;\n-\n-                                             if Verbose_Mode then\n-                                                Write_Str (\"      -> \");\n-                                                Write_Str (Archive_Path);\n-                                                Write_Str (\" has time stamp \");\n-                                                Write_Str (\"later than \");\n-                                                Write_Line (\"executable\");\n-                                             end if;\n-\n-                                             exit;\n-                                          end if;\n-                                       end;\n-                                    end if;\n-                                 end loop;\n-                              end;\n-                           end if;\n-\n-                           --  If Need_To_Relink is False, we are done\n-\n-                           if Verbose_Mode and (not Need_To_Relink) then\n-                              Write_Line (\"      -> up to date\");\n-                           end if;\n-\n-                        end if;\n-\n-                        --  Prepare to link\n-\n-                        if Need_To_Relink then\n-                           Link_Done := True;\n-\n-                           Last_Argument := 0;\n-\n-                           --  Specify the executable path name\n-\n-                           Add_Argument (Dash_o, True);\n-                           Add_Argument\n-                             (Get_Name_String (Data.Exec_Directory) &\n-                              Directory_Separator &\n-                              Get_Name_String\n-                                (Executable_Of\n-                                   (Project  => Main_Project,\n-                                    Main     => Main_Id,\n-                                    Index    => 0,\n-                                    Ada_Main => False)),\n-                              True);\n-\n-                           --  Specify the object file of the main source\n-\n-                           Add_Argument\n-                             (Object_Dir & Directory_Separator &\n-                              Get_Name_String (Source.Object_Name),\n-                              True);\n-\n-                           --  Add the switches specified in package Linker of\n-                           --  the main project.\n-\n-                           Add_Switches\n-                             (Data      => Data,\n-                              Proc      => Linker,\n-                              Language  => Source.Language,\n-                              File_Name => Main_Id);\n-\n-                           --  Add the switches specified in attribute\n-                           --  Linker_Options of packages Linker.\n-\n-                           if Link_Options_Switches = null then\n-                              Link_Options_Switches :=\n-                                new Argument_List'\n-                                  (Linker_Options_Switches (Main_Project));\n-                           end if;\n-\n-                           Add_Arguments (Link_Options_Switches.all, True);\n-\n-                           --  Add the linking options specified on the\n-                           --  command line.\n-\n-                           for Arg in 1 ..  Linker_Options.Last loop\n-                              Add_Argument (Linker_Options.Table (Arg), True);\n-                           end loop;\n-\n-                           --  Add all the archives, in a correct order\n-\n-                           Add_Archives (For_Gnatmake => False);\n-\n-                           --  If there are shared libraries and the run path\n-                           --  option is supported, add the run path switch.\n-\n-                           if Lib_Path.Last > 0 then\n-                              Add_Argument\n-                                (Path_Option.all &\n-                                 String (Lib_Path.Table (1 .. Lib_Path.Last)),\n-                                Verbose_Mode);\n-                           end if;\n-\n-                           --  And invoke the linker\n-\n-                           Display_Command (Linker_Name.all, Linker_Path);\n-                           Spawn\n-                             (Linker_Path.all,\n-                              Arguments (1 .. Last_Argument),\n-                              Success);\n-\n-                           if not Success then\n-                              Report_Error (\"could not link \", Main);\n-                           end if;\n-                        end if;\n-                     end;\n+                     Link_Foreign (Main, Main_Id, Source);\n                   end if;\n                end;\n             end loop;\n@@ -3211,13 +3651,14 @@ package body Makegpr is\n                Osint.Write_Program_Name;\n \n                if Mains.Number_Of_Mains = 1 then\n+\n                   --  If there is only one executable, report its name too\n \n                   Write_Str (\": \"\"\");\n                   Mains.Reset;\n \n                   declare\n-                     Main : constant String := Mains.Next_Main;\n+                     Main    : constant String := Mains.Next_Main;\n                      Main_Id : Name_Id;\n                   begin\n                      Name_Len := 0;\n@@ -3251,8 +3692,7 @@ package body Makegpr is\n       S3 : String := \"\")\n    is\n    begin\n-      --  If Keep_Going is True, output the error message, preceded by the\n-      --  error header.\n+      --  If Keep_Going is True, output error message preceded by error header\n \n       if Keep_Going then\n          Total_Number_Of_Errors := Total_Number_Of_Errors + 1;\n@@ -3262,9 +3702,9 @@ package body Makegpr is\n          Write_Str (S3);\n          Write_Eol;\n \n-      else\n-         --  Otherwise, just fail\n+      --  Otherwise just fail\n \n+      else\n          Osint.Fail (S1, S2, S3);\n       end if;\n    end Report_Error;\n@@ -3300,8 +3740,8 @@ package body Makegpr is\n          return;\n       end if;\n \n-      --  If preceding switch was -P, a project file name need to be specified,\n-      --  not a switch.\n+      --  If preceding switch was -P, a project file name need to be\n+      --  specified, not a switch.\n \n       if Project_File_Name_Expected then\n          if Arg (1) = '-' then\n@@ -3311,8 +3751,8 @@ package body Makegpr is\n             Project_File_Name := new String'(Arg);\n          end if;\n \n-      --  If preceding switch was -o, an executable name need to be specidied,\n-      --  not a switch.\n+      --  If preceding switch was -o, an executable name need to be\n+      --  specified, not a switch.\n \n       elsif Output_File_Name_Expected then\n          if Arg (1) = '-' then\n@@ -3326,10 +3766,9 @@ package body Makegpr is\n \n       --  -c???args: Compiler arguments\n \n-      elsif Arg'Length >= 6 and then\n-         Arg (Arg'First .. Arg'First + 1) = \"-c\" and then\n-      Arg (Arg'Last - 3 .. Arg'Last) = \"args\"\n-\n+      elsif Arg'Length >= 6\n+        and then Arg (Arg'First .. Arg'First + 1) = \"-c\"\n+        and then Arg (Arg'Last - 3 .. Arg'Last) = \"args\"\n       then\n          declare\n             OK          : Boolean := False;\n@@ -3347,7 +3786,6 @@ package body Makegpr is\n \n             if OK then\n                Current_Processor := Compiler;\n-\n             else\n                Osint.Fail (\"illegal option \"\"\", Arg, \"\"\"\");\n             end if;\n@@ -3417,6 +3855,7 @@ package body Makegpr is\n \n          elsif Arg = \"-v\" then\n             Verbose_Mode := True;\n+            Copyright;\n \n          elsif Arg'Length = 4 and then Arg (1 .. 3) = \"-vP\"\n            and then Arg (4) in '0' .. '2'\n@@ -3435,8 +3874,7 @@ package body Makegpr is\n          elsif Arg'Length >= 3 and then Arg (2) = 'X'\n            and then Is_External_Assignment (Arg)\n          then\n-            --  Is_External_Assignment has side effects\n-            --  when it returns True;\n+            --  Is_External_Assignment has side effects when it returns True\n \n             null;\n \n@@ -3456,8 +3894,7 @@ package body Makegpr is\n    -----------------\n \n    function Strip_CR_LF (Text : String) return String is\n-\n-      To  : String (1 .. Text'Length);\n+      To       : String (1 .. Text'Length);\n       Index_To : Natural := 0;\n \n    begin"}, {"sha": "8cce3e8d8ce7f575ee03cefc9e9d259b7bead51d", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -324,9 +324,6 @@ package body MLib.Prj is\n \n       Project_Name : constant String := Get_Name_String (Data.Name);\n \n-      DLL_Address  : constant String_Access :=\n-                       new String'(Default_DLL_Address);\n-\n       Current_Dir  : constant String := Get_Current_Dir;\n \n       Lib_Filename : String_Access;\n@@ -1473,9 +1470,7 @@ package body MLib.Prj is\n                   Lib_Dir       => Lib_Dirpath.all,\n                   Symbol_Data   => Data.Symbol_Data,\n                   Driver_Name   => Driver_Name,\n-                  Lib_Address   => DLL_Address.all,\n                   Lib_Version   => Lib_Version.all,\n-                  Relocatable   => The_Build_Mode = Relocatable,\n                   Auto_Init     => Data.Lib_Auto_Init);\n \n             when Static =>"}, {"sha": "033ca6a90ff7d9b860ecc973d429b2c1f1e77a8d", "filename": "gcc/ada/mlib-tgt-aix.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-aix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-aix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-aix.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -124,18 +124,14 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n       pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -222,15 +218,6 @@ package body MLib.Tgt is\n             Options_2   => Options_2.all);\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "f295b3810b9b8f047a7c3f0e398ad4245892d257", "filename": "gcc/ada/mlib-tgt-hpux.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-hpux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-hpux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-hpux.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -104,17 +104,13 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -201,15 +197,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "2f09a14d38baf3ac656f3704ac81309efed8aafe", "filename": "gcc/ada/mlib-tgt-irix.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-irix.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -105,17 +105,13 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -196,15 +192,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "7901f637c3e38d8433217819ce9257d533d7ff4a", "filename": "gcc/ada/mlib-tgt-linux.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-linux.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -108,17 +108,13 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -198,15 +194,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "79aeab59066637ec6b71d068207cb3a78db5a370", "filename": "gcc/ada/mlib-tgt-mingw.adb", "status": "modified", "additions": 3, "deletions": 106, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-mingw.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -96,9 +96,7 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n@@ -108,126 +106,25 @@ package body MLib.Tgt is\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Lib_Version);\n \n-      Strip_Name  : constant String := \"strip\";\n-      Strip_Exec  : String_Access;\n-\n-      procedure Strip_Reloc (Lib_File : String);\n-      --  Strip .reloc section to build a non relocatable DLL\n-\n-      -----------------\n-      -- Strip_Reloc --\n-      -----------------\n-\n-      procedure Strip_Reloc (Lib_File : String) is\n-         Arguments   : Argument_List (1 .. 3);\n-         Success     : Boolean;\n-         Line_Length : Natural;\n-\n-      begin\n-         --  Look for strip executable\n-\n-         Strip_Exec := Locate_Exec_On_Path (Strip_Name);\n-\n-         if Strip_Exec = null then\n-            Fail (Strip_Name, \" not found in path\");\n-\n-         elsif Opt.Verbose_Mode then\n-            Write_Str  (\"found \");\n-            Write_Line (Strip_Exec.all);\n-         end if;\n-\n-         --  Call it: strip -R .reloc <dll>\n-\n-         Arguments (1) := new String'(\"-R\");\n-         Arguments (2) := new String'(\".reloc\");\n-         Arguments (3) := new String'(Lib_File);\n-\n-         if not Opt.Quiet_Output then\n-            Write_Str (Strip_Exec.all);\n-            Line_Length := Strip_Exec'Length;\n-\n-            for K in Arguments'Range loop\n-\n-               --  Make sure the Output buffer does not overflow\n-\n-               if Line_Length + 1 + Arguments (K)'Length >\n-                 Integer (Opt.Max_Line_Length)\n-               then\n-                  Write_Eol;\n-                  Line_Length := 0;\n-               end if;\n-\n-               Write_Char (' ');\n-               Write_Str  (Arguments (K).all);\n-               Line_Length := Line_Length + 1 + Arguments (K)'Length;\n-            end loop;\n-\n-            Write_Eol;\n-         end if;\n-\n-         Spawn (Strip_Exec.all, Arguments, Success);\n-\n-         if not Success then\n-            Fail (Strip_Name, \" execution error.\");\n-         end if;\n-\n-         for K in Arguments'Range loop\n-            Free (Arguments (K));\n-         end loop;\n-      end Strip_Reloc;\n-\n       Lib_File : constant String :=\n-        Lib_Dir & Directory_Separator & \"lib\" &\n+        Lib_Dir & Directory_Separator &\n         Files.Ext_To (Lib_Filename, DLL_Ext);\n \n-      I_Base    : aliased String := \"-Wl,--image-base,\" & Lib_Address;\n-\n-      Options_2 : Argument_List (1 .. 1);\n-      O_Index   : Natural := 0;\n-\n    --  Start of processing for Build_Dynamic_Library\n \n    begin\n       if Opt.Verbose_Mode then\n-         Write_Str (\"building \");\n-\n-         if not Relocatable then\n-            Write_Str (\"non-\");\n-         end if;\n-\n-         Write_Str (\"relocatable shared library \");\n+         Write_Str (\"building relocatable shared library \");\n          Write_Line (Lib_File);\n       end if;\n \n-      if not Relocatable then\n-         O_Index := O_Index + 1;\n-         Options_2 (O_Index) := I_Base'Unchecked_Access;\n-      end if;\n-\n       Tools.Gcc\n         (Output_File => Lib_File,\n          Objects     => Ofiles,\n          Options     => Options,\n-         Driver_Name => Driver_Name,\n-         Options_2   => Options_2 (1 .. O_Index));\n-\n-      if not Relocatable then\n-\n-         --  Strip reloc symbols from the DLL\n-\n-         Strip_Reloc (Lib_File);\n-      end if;\n+         Driver_Name => Driver_Name);\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"0x11000000\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "d40928500c8757fdb2b7a464b68cfe3c26271f0d", "filename": "gcc/ada/mlib-tgt-solaris.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-solaris.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -102,17 +102,13 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -195,15 +191,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "13417e8d2d4c5d1ac32e8f0d589e095e5318758f", "filename": "gcc/ada/mlib-tgt-tru64.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-tru64.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -110,17 +110,13 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n       pragma Unreferenced (Interfaces);\n       pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n         Lib_Dir & Directory_Separator & \"lib\" &\n@@ -213,15 +209,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "285f2bd2f550f7e5e784f235c5178954703c18fd", "filename": "gcc/ada/mlib-tgt-vms-alpha.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms-alpha.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -132,15 +132,11 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n                    Lib_Dir & Directory_Separator & \"lib\" &\n@@ -529,15 +525,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "e279a51fb17e501bbb9052d117b1344a42c0205d", "filename": "gcc/ada/mlib-tgt-vms-ia64.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms-ia64.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -132,15 +132,11 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Foreign);\n       pragma Unreferenced (Afiles);\n-      pragma Unreferenced (Lib_Address);\n-      pragma Unreferenced (Relocatable);\n \n       Lib_File : constant String :=\n                    Lib_Dir & Directory_Separator & \"lib\" &\n@@ -562,15 +558,6 @@ package body MLib.Tgt is\n       end if;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "6eaa882b924a96f8201167d3a8671a8b436a4767", "filename": "gcc/ada/mlib-tgt-vxworks.adb", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vxworks.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -95,9 +95,7 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Ofiles);\n@@ -109,24 +107,13 @@ package body MLib.Tgt is\n       pragma Unreferenced (Lib_Dir);\n       pragma Unreferenced (Symbol_Data);\n       pragma Unreferenced (Driver_Name);\n-      pragma Unreferenced (Lib_Address);\n       pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Relocatable);\n       pragma Unreferenced (Auto_Init);\n \n    begin\n       null;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "c18dec8caf1779e995cbce2638d75a18e2586761", "filename": "gcc/ada/mlib-tgt.adb", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2003, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,9 +81,7 @@ package body MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False)\n    is\n       pragma Unreferenced (Ofiles);\n@@ -95,24 +93,13 @@ package body MLib.Tgt is\n       pragma Unreferenced (Lib_Dir);\n       pragma Unreferenced (Symbol_Data);\n       pragma Unreferenced (Driver_Name);\n-      pragma Unreferenced (Lib_Address);\n       pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Relocatable);\n       pragma Unreferenced (Auto_Init);\n \n    begin\n       null;\n    end Build_Dynamic_Library;\n \n-   -------------------------\n-   -- Default_DLL_Address --\n-   -------------------------\n-\n-   function Default_DLL_Address return String is\n-   begin\n-      return \"\";\n-   end Default_DLL_Address;\n-\n    -------------\n    -- DLL_Ext --\n    -------------"}, {"sha": "971325ff54421baf9595db76a989bb928d10a0bf", "filename": "gcc/ada/mlib-tgt.ads", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -64,11 +64,6 @@ package MLib.Tgt is\n    --  Returns the name of the program, if any, that generates an index\n    --  to the contents of an archive, usually \"ranlib\".\n \n-   function Default_DLL_Address return String;\n-   --  Default address for non relocatable DLL.\n-   --  For OSes where a dynamic library is always relocatable,\n-   --  this function returns an empty string.\n-\n    function Dynamic_Option return String;\n    --  gcc option to create a dynamic library.\n    --  For Unix, returns \"-shared\", for Windows returns \"-mdll\".\n@@ -96,7 +91,7 @@ package MLib.Tgt is\n    --  Returns True iff Ext is an object file extension\n \n    function Is_C_Ext (Ext : String) return Boolean;\n-   --  Returns True iff Ext is a C file extension.\n+   --  Returns True iff Ext is a C file extension\n \n    function Is_Archive_Ext (Ext : String) return Boolean;\n    --  Returns True iff Ext is an extension for a library\n@@ -111,9 +106,7 @@ package MLib.Tgt is\n       Lib_Dir      : String;\n       Symbol_Data  : Symbol_Record;\n       Driver_Name  : Name_Id := No_Name;\n-      Lib_Address  : String  := \"\";\n       Lib_Version  : String  := \"\";\n-      Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False);\n    --  Build a dynamic/relocatable library\n    --\n@@ -135,20 +128,12 @@ package MLib.Tgt is\n    --\n    --  Lib_Dir is the directory path where the library will be located\n    --\n-   --  Lib_Address is the base address of the library for a non relocatable\n-   --  library, given as an hexadecimal string.\n-   --\n    --  For OSes that support symbolic links, Lib_Version, if non null,\n    --  is the actual file name of the library. For example on Unix, if\n    --  Lib_Filename is \"toto\" and Lib_Version is \"libtoto.so.2.1\",\n    --  \"libtoto.so\" will be a symbolic link to \"libtoto.so.2.1\" which\n    --  will be the actual library file.\n    --\n-   --  Relocatable indicates if the library should be relocatable or not,\n-   --  for those OSes that actually support non relocatable dynamic libraries.\n-   --  Relocatable indicates that automatic elaboration/finalization must be\n-   --  indicated to the linker, if possible.\n-   --\n    --  Symbol_Data is used for some patforms, including VMS, to generate\n    --  the symbols to be exported by the library.\n    --"}, {"sha": "0e9f7c4778f2b742368315195693291aeb52db17", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -249,17 +249,17 @@ package Opt is\n \n    Create_Mapping_File : Boolean := False;\n    --  GNATMAKE\n-   --  Set to True (-C switch) to indicate that gnatmake\n-   --  invokes the compiler with a mapping file (-gnatem compiler switch).\n+   --  Set to True (-C switch) to indicate that gnatmake will invoke\n+   --  the compiler with a mapping file (-gnatem compiler switch).\n \n    subtype Debug_Level_Value is Nat range 0 .. 3;\n    Debugger_Level : Debug_Level_Value := 0;\n    --  GNATBIND\n-   --  The value given to the -g parameter.\n-   --  The default value for -g with no value is 2\n-   --  This is usually ignored by GNATBIND, except in the VMS version\n-   --  where it is passed as an argument to __gnat_initialize to trigger\n-   --  the activation of the remote debugging interface (is this true???).\n+   --  The value given to the -g parameter. The default value for -g with\n+   --  no value is 2. This is usually ignored by GNATBIND, except in the\n+   --  VMS version where it is passed as an argument to __gnat_initialize\n+   --  to trigger the activation of the remote debugging interface.\n+   --  Is this still true ???\n \n    Debug_Generated_Code : Boolean := False;\n    --  GNAT\n@@ -274,11 +274,15 @@ package Opt is\n    --  default was set by the binder, and that the default should be the\n    --  initial value of System.Secondary_Stack.Default_Secondary_Stack_Size.\n \n+   Detect_Blocking : Boolean := False;\n+   --  GNAT\n+   --  Set True to force the run time to raise Program_Error if calls to\n+   --  potentially blocking operations are detected from protected actions.\n+\n    Display_Compilation_Progress : Boolean := False;\n    --  GNATMAKE\n    --  Set True (-d switch) to display information on progress while compiling\n-   --  files. Internal flag to be used in conjunction with an IDE such as\n-   --  Glide.\n+   --  files. Internal flag to be used in conjunction with an IDE (e.g GPS).\n \n    type Distribution_Stub_Mode_Type is\n    --  GNAT\n@@ -457,8 +461,6 @@ package Opt is\n    GCC_Version : constant Nat := get_gcc_version;\n    --  GNATMAKE\n    --  Indicates which version of gcc is in use (2 = 2.8.1, 3 = 3.x).\n-   --  Used in particular to decide if gcc switch -shared-libgcc should be\n-   --  used (it cannot be used for 2.8.1).\n \n    Global_Discard_Names : Boolean := False;\n    --  GNAT, GNATBIND"}, {"sha": "c07c39b78821332a1b527fe1d597eb01d2c64fba", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -928,6 +928,7 @@ begin\n            Pragma_Component_Alignment          |\n            Pragma_Controlled                   |\n            Pragma_Convention                   |\n+           Pragma_Detect_Blocking              |\n            Pragma_Discard_Names                |\n            Pragma_Eliminate                    |\n            Pragma_Elaborate                    |"}, {"sha": "19d9130dd9ae3f3bf054f09da428750fcdee5616", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -24,8 +24,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Csets; use Csets;\n-with Uintp; use Uintp;\n+with Csets;   use Csets;\n+with Stylesw; use Stylesw;\n+with Uintp;   use Uintp;\n \n with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n \n@@ -114,7 +115,6 @@ package body Util is\n       end if;\n \n       if Is_Bad_Spelling_Of (Name_Buffer (1 .. Name_Len), S) then\n-\n          for J in 1 .. S'Last loop\n             M1 (P1 + J - 1) := Fold_Upper (S (J));\n          end loop;\n@@ -126,7 +126,6 @@ package body Util is\n       else\n          return False;\n       end if;\n-\n    end Bad_Spelling_Of;\n \n    ----------------------\n@@ -360,7 +359,6 @@ package body Util is\n \n    procedure Discard_Junk_List (L : List_Id) is\n       pragma Warnings (Off, L);\n-\n    begin\n       null;\n    end Discard_Junk_List;\n@@ -371,7 +369,6 @@ package body Util is\n \n    procedure Discard_Junk_Node (N : Node_Id) is\n       pragma Warnings (Off, N);\n-\n    begin\n       null;\n    end Discard_Junk_Node;\n@@ -627,6 +624,15 @@ package body Util is\n    procedure Push_Scope_Stack is\n    begin\n       Scope.Increment_Last;\n+\n+      if Style_Check_Max_Nesting_Level\n+        and then Scope.Last = Style_Max_Nesting_Level + 1\n+      then\n+         Error_Msg\n+           (\"(style) maximum nesting level exceeded\",\n+            First_Non_Blank_Location);\n+      end if;\n+\n       Scope.Table (Scope.Last).Junk := False;\n       Scope.Table (Scope.Last).Node := Empty;\n "}, {"sha": "a736641a65cfdd410f277a7764f9cadc593684b3", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1484,7 +1484,7 @@ package body Prj.Env is\n             --  If there are Ada sources, call action with the name of every\n             --  source directory.\n \n-            if Projects.Table (Project).Sources_Present then\n+            if Projects.Table (Project).Ada_Sources_Present then\n                while Current /= Nil_String loop\n                   The_String := String_Elements.Table (Current);\n                   Action (Get_Name_String (The_String.Value));\n@@ -1948,7 +1948,7 @@ package body Prj.Env is\n                      --  Add to path all source directories of this project\n                      --  if there are Ada sources.\n \n-                     if Projects.Table (Project).Sources_Present then\n+                     if Projects.Table (Project).Ada_Sources_Present then\n                         Add_To_Source_Path (Data.Source_Dirs);\n                      end if;\n                   end if;"}, {"sha": "6ae47557e22cb5158ba6254995208d5514eb9914", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -149,16 +149,21 @@ package body Prj.Nmsc is\n    function ALI_File_Name (Source : String) return String;\n    --  Return the ALI file name corresponding to a source.\n \n-   procedure Check_Ada_Naming_Scheme\n-     (Project : Project_Id;\n-      Naming  : Naming_Data);\n-   --  Check that the package Naming is correct.\n-\n    procedure Check_Ada_Name\n      (Name : String;\n       Unit : out Name_Id);\n    --  Check that a name is a valid Ada unit name.\n \n+   procedure Check_Ada_Naming_Scheme\n+     (Data    : in out Project_Data;\n+      Project : Project_Id);\n+   --  Check the naming scheme part of Data\n+\n+   procedure Check_Ada_Naming_Scheme_Validity\n+     (Project : Project_Id;\n+      Naming  : Naming_Data);\n+   --  Check that the package Naming is correct.\n+\n    procedure Check_For_Source\n      (File_Name        : Name_Id;\n       Path_Name        : Name_Id;\n@@ -171,11 +176,6 @@ package body Prj.Nmsc is\n    --  Check if a file in a source directory is a source for a specific\n    --  language other than Ada.\n \n-   procedure Check_Naming_Scheme\n-     (Data    : in out Project_Data;\n-      Project : Project_Id);\n-   --  Check the naming scheme part of Data\n-\n    function Check_Project\n      (P            : Project_Id;\n       Root_Project : Project_Id;\n@@ -540,7 +540,7 @@ package body Prj.Nmsc is\n       Languages := Prj.Util.Value_Of (Name_Languages, Data.Decl.Attributes);\n \n       Data.Naming.Current_Language := Name_Ada;\n-      Data.Sources_Present         := Data.Source_Dirs /= Nil_String;\n+      Data.Ada_Sources_Present     := Data.Source_Dirs /= Nil_String;\n \n       if not Languages.Default then\n          declare\n@@ -566,21 +566,21 @@ package body Prj.Nmsc is\n \n                --  Mark the project file as having no sources for Ada\n \n-               Data.Sources_Present := False;\n+               Data.Ada_Sources_Present := False;\n             end if;\n          end;\n       end if;\n \n-      Check_Naming_Scheme (Data, Project);\n+      Check_Ada_Naming_Scheme (Data, Project);\n \n       Prepare_Ada_Naming_Exceptions (Data.Naming.Bodies, Body_Part);\n       Prepare_Ada_Naming_Exceptions (Data.Naming.Specs,  Specification);\n \n       --  If we have source directories, then find the sources\n \n-      if Data.Sources_Present then\n+      if Data.Ada_Sources_Present then\n          if Data.Source_Dirs = Nil_String then\n-            Data.Sources_Present := False;\n+            Data.Ada_Sources_Present := False;\n \n          else\n             declare\n@@ -628,7 +628,7 @@ package body Prj.Nmsc is\n                   begin\n                      Source_Names.Reset;\n \n-                     Data.Sources_Present := Current /= Nil_String;\n+                     Data.Ada_Sources_Present := Current /= Nil_String;\n \n                      while Current /= Nil_String loop\n                         Element := String_Elements.Table (Current);\n@@ -835,7 +835,7 @@ package body Prj.Nmsc is\n          end if;\n       end if;\n \n-      if Data.Sources_Present then\n+      if Data.Ada_Sources_Present then\n \n          --  Check that all individual naming conventions apply to\n          --  sources of this project file.\n@@ -1754,7 +1754,8 @@ package body Prj.Nmsc is\n             Other_Sources.Table (Other_Sources.Last) := Source;\n \n             --  There are sources of languages other than Ada in this project\n-            Data.Sources_Present := True;\n+\n+            Data.Other_Sources_Present := True;\n \n             --  And there are sources of this language in this project\n \n@@ -1776,11 +1777,11 @@ package body Prj.Nmsc is\n       end if;\n    end Check_For_Source;\n \n-   -----------------------------\n-   -- Check_Ada_Naming_Scheme --\n-   -----------------------------\n+   --------------------------------------\n+   -- Check_Ada_Naming_Scheme_Validity --\n+   --------------------------------------\n \n-   procedure Check_Ada_Naming_Scheme\n+   procedure Check_Ada_Naming_Scheme_Validity\n      (Project : Project_Id;\n       Naming  : Naming_Data)\n    is\n@@ -1909,13 +1910,13 @@ package body Prj.Nmsc is\n             end if;\n          end;\n       end if;\n-   end Check_Ada_Naming_Scheme;\n+   end Check_Ada_Naming_Scheme_Validity;\n \n-   -------------------------\n-   -- Check_Naming_Scheme --\n-   -------------------------\n+   -----------------------------\n+   -- Check_Ada_Naming_Scheme --\n+   -----------------------------\n \n-   procedure Check_Naming_Scheme\n+   procedure Check_Ada_Naming_Scheme\n      (Data    : in out Project_Data;\n       Project : Project_Id)\n    is\n@@ -1975,7 +1976,7 @@ package body Prj.Nmsc is\n          end loop;\n       end Check_Unit_Names;\n \n-   --  Start of processing for Check_Naming_Scheme\n+   --  Start of processing for Check_Ada_Naming_Scheme\n \n    begin\n       --  If there is a package Naming, we will put in Data.Naming what is in\n@@ -2232,14 +2233,14 @@ package body Prj.Nmsc is\n \n          --  Check if Data.Naming is valid\n \n-         Check_Ada_Naming_Scheme (Project, Data.Naming);\n+         Check_Ada_Naming_Scheme_Validity (Project, Data.Naming);\n \n       else\n          Data.Naming.Current_Spec_Suffix := Default_Ada_Spec_Suffix;\n          Data.Naming.Current_Body_Suffix := Default_Ada_Body_Suffix;\n          Data.Naming.Separate_Suffix     := Default_Ada_Body_Suffix;\n       end if;\n-   end Check_Naming_Scheme;\n+   end Check_Ada_Naming_Scheme;\n \n    -------------------\n    -- Check_Project --\n@@ -2515,7 +2516,7 @@ package body Prj.Nmsc is\n          --  any source, then we never call Find_Sources.\n \n          if Current_Source /= Nil_String then\n-            Data.Sources_Present := True;\n+            Data.Ada_Sources_Present := True;\n \n          elsif Data.Extends = No_Project then\n             Error_Msg\n@@ -3431,8 +3432,9 @@ package body Prj.Nmsc is\n                Data.Object_Directory := No_Name;\n             end if;\n \n-            Data.Source_Dirs     := Nil_String;\n-            Data.Sources_Present := False;\n+            Data.Source_Dirs           := Nil_String;\n+            Data.Ada_Sources_Present   := False;\n+            Data.Other_Sources_Present := False;\n \n          else\n             declare\n@@ -4016,9 +4018,9 @@ package body Prj.Nmsc is\n       Data      := Projects.Table (Project);\n       Languages := Prj.Util.Value_Of (Name_Languages, Data.Decl.Attributes);\n \n-      Data.Sources_Present := Data.Source_Dirs /= Nil_String;\n+      Data.Other_Sources_Present := Data.Source_Dirs /= Nil_String;\n \n-      if Data.Sources_Present then\n+      if Data.Other_Sources_Present then\n          --  Check if languages other than Ada are specified in this project\n \n          if Languages.Default then\n@@ -4029,7 +4031,7 @@ package body Prj.Nmsc is\n \n             --  No sources of languages other than Ada\n \n-            Data.Sources_Present := False;\n+            Data.Other_Sources_Present := False;\n \n          else\n             declare\n@@ -4039,9 +4041,9 @@ package body Prj.Nmsc is\n             begin\n                --  Assumethat there is no language other than Ada specified.\n                --  If in fact there is at least one, we will set back\n-               --  Sources_Present to True.\n+               --  Other_Sources_Present to True.\n \n-               Data.Sources_Present := False;\n+               Data.Other_Sources_Present := False;\n \n                --  Look through all the languages specified in attribute\n                --  Languages, if any\n@@ -4070,7 +4072,7 @@ package body Prj.Nmsc is\n                         --  than Ada.\n \n                         if Lang /= Lang_Ada then\n-                           Data.Sources_Present := True;\n+                           Data.Other_Sources_Present := True;\n                         end if;\n \n                         exit Lang_Loop;\n@@ -4095,11 +4097,11 @@ package body Prj.Nmsc is\n \n       --  If there may be some sources, look for them\n \n-      if Data.Sources_Present then\n+      if Data.Other_Sources_Present then\n          --  Set Source_Present to False. It will be set back to True whenever\n          --  a source is found.\n \n-         Data.Sources_Present := False;\n+         Data.Other_Sources_Present := False;\n \n          for Lang in Other_Programming_Language loop\n             --  For each language (other than Ada) in the project file"}, {"sha": "aaf45ac7fabff0c1af4ba69ef51ac06fbbd58888", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -161,22 +161,26 @@ package body Prj.Part is\n      (Context_Clause    : With_Id;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n-      From_Extended     : Extension_Origin);\n+      From_Extended     : Extension_Origin;\n+      In_Limited        : Boolean);\n    --  Parse the imported projects that have been stored in table Withs,\n    --  if any. From_Extended is used for the call to Parse_Single_Project\n-   --  below.\n+   --  below. When In_Limited is True, the importing path includes at least\n+   --  one \"limited with\".\n \n    procedure Parse_Single_Project\n      (Project       : out Project_Node_Id;\n       Extends_All   : out Boolean;\n       Path_Name     : String;\n       Extended      : Boolean;\n-      From_Extended : Extension_Origin);\n+      From_Extended : Extension_Origin;\n+      In_Limited    : Boolean);\n    --  Parse a project file.\n    --  Recursive procedure: it calls itself for imported and extended\n    --  projects. When From_Extended is not None, if the project has already\n    --  been parsed and is an extended project A, return the ultimate\n-   --  (not extended) project that extends A.\n+   --  (not extended) project that extends A. When In_Limited is True,\n+   --  the importing path includes at least one \"limited with\".\n \n    function Project_Path_Name_Of\n      (Project_File_Name : String;\n@@ -472,7 +476,8 @@ package body Prj.Part is\n             Extends_All   => Dummy,\n             Path_Name     => Path_Name,\n             Extended      => False,\n-            From_Extended => None);\n+            From_Extended => None,\n+            In_Limited    => False);\n \n          --  If Project is an extending-all project, create the eventual\n          --  virtual extending projects and check that there are no illegally\n@@ -668,7 +673,8 @@ package body Prj.Part is\n      (Context_Clause    : With_Id;\n       Imported_Projects : out Project_Node_Id;\n       Project_Directory : Name_Id;\n-      From_Extended     : Extension_Origin)\n+      From_Extended     : Extension_Origin;\n+      In_Limited        : Boolean)\n    is\n       Current_With_Clause : With_Id := Context_Clause;\n \n@@ -690,7 +696,7 @@ package body Prj.Part is\n          Current_With := Withs.Table (Current_With_Clause);\n          Current_With_Clause := Current_With.Next;\n \n-         Limited_With := Current_With.Limited_With;\n+         Limited_With := In_Limited or Current_With.Limited_With;\n \n          declare\n             Original_Path : constant String :=\n@@ -783,7 +789,8 @@ package body Prj.Part is\n                      Extends_All   => Extends_All,\n                      Path_Name     => Imported_Path_Name,\n                      Extended      => False,\n-                     From_Extended => From_Extended);\n+                     From_Extended => From_Extended,\n+                     In_Limited    => Limited_With);\n \n                else\n                   Extends_All := Is_Extending_All (Withed_Project);\n@@ -833,7 +840,8 @@ package body Prj.Part is\n       Extends_All   : out Boolean;\n       Path_Name     : String;\n       Extended      : Boolean;\n-      From_Extended : Extension_Origin)\n+      From_Extended : Extension_Origin;\n+      In_Limited    : Boolean)\n    is\n       Normed_Path_Name    : Name_Id;\n       Canonical_Path_Name : Name_Id;\n@@ -1159,7 +1167,8 @@ package body Prj.Part is\n               (Context_Clause    => First_With,\n                Imported_Projects => Imported_Projects,\n                Project_Directory => Project_Directory,\n-               From_Extended     => From_Ext);\n+               From_Extended     => From_Ext,\n+               In_Limited        => In_Limited);\n             Set_First_With_Clause_Of (Project, Imported_Projects);\n          end;\n \n@@ -1255,7 +1264,8 @@ package body Prj.Part is\n                         Extends_All   => Extends_All,\n                         Path_Name     => Extended_Project_Path_Name,\n                         Extended      => True,\n-                        From_Extended => From_Ext);\n+                        From_Extended => From_Ext,\n+                        In_Limited    => In_Limited);\n                   end;\n \n                   --  A project that extends an extending-all project is also"}, {"sha": "7cc17fddf81dad922cf6734be005b8d47c6db599", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -63,6 +63,14 @@ package body Prj.Proc is\n    --  Add all attributes, starting with First, with their default\n    --  values to the package or project with declarations Decl.\n \n+   procedure Check\n+     (Project           : in out Project_Id;\n+      Process_Languages : Languages_Processed;\n+      Follow_Links      : Boolean);\n+   --  Set all projects to not checked, then call Recursive_Check for the\n+   --  main project Project. Project is set to No_Project if errors occurred.\n+   --  See Prj.Nmsc.Ada_Check for information on Follow_Links.\n+\n    function Expression\n      (Project           : Project_Id;\n       From_Project_Node : Project_Node_Id;\n@@ -102,14 +110,6 @@ package body Prj.Proc is\n    --  recursively for all imported projects and a extended project, if any.\n    --  Then process the declarative items of the project.\n \n-   procedure Check\n-     (Project           : in out Project_Id;\n-      Process_Languages : Languages_Processed;\n-      Follow_Links      : Boolean);\n-   --  Set all projects to not checked, then call Recursive_Check for the\n-   --  main project Project. Project is set to No_Project if errors occurred.\n-   --  See Prj.Nmsc.Ada_Check for information on Follow_Links.\n-\n    procedure Recursive_Check\n      (Project           : Project_Id;\n       Process_Languages : Languages_Processed;\n@@ -903,7 +903,13 @@ package body Prj.Proc is\n                Extending2 := Extending;\n \n                while Extending2 /= No_Project loop\n-                  if Projects.Table (Extending2).Sources_Present\n+                  if ((Process_Languages = Ada_Language\n+                       and then\n+                       Projects.Table (Extending2).Ada_Sources_Present)\n+                      or else\n+                       (Process_Languages = Other_Languages\n+                        and then\n+                        Projects.Table (Extending2).Other_Sources_Present))\n                     and then\n                       Projects.Table (Extending2).Object_Directory = Obj_Dir\n                   then\n@@ -1827,6 +1833,11 @@ package body Prj.Proc is\n \n             when Other_Languages =>\n                Prj.Nmsc.Other_Languages_Check (Project, Error_Report);\n+\n+            when All_Languages =>\n+               Prj.Nmsc.Ada_Check (Project, Error_Report, Follow_Links);\n+               Prj.Nmsc.Other_Languages_Check (Project, Error_Report);\n+\n          end case;\n       end if;\n    end Recursive_Check;"}, {"sha": "747e7f8248a914ff505bc1a01157668f6fe13c45", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -93,12 +93,12 @@ package body Prj is\n       Library_Name                   => No_Name,\n       Library_Kind                   => Static,\n       Lib_Internal_Name              => No_Name,\n-      Lib_Elaboration                => False,\n       Standalone_Library             => False,\n       Lib_Interface_ALIs             => Nil_String,\n       Lib_Auto_Init                  => False,\n       Symbol_Data                    => No_Symbols,\n-      Sources_Present                => True,\n+      Ada_Sources_Present            => True,\n+      Other_Sources_Present          => True,\n       Sources                        => Nil_String,\n       First_Other_Source             => No_Other_Source,\n       Last_Other_Source              => No_Other_Source,"}, {"sha": "d742bbf28fcb8262bc09af75bb80bdf1eda93703", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -67,7 +67,7 @@ package Prj is\n    Slash : Name_Id;\n    --  \"/\", used as the path of locally removed files\n \n-   type Languages_Processed is (Ada_Language, Other_Languages);\n+   type Languages_Processed is (Ada_Language, Other_Languages, All_Languages);\n    --  To specify how to process project files\n \n    type Programming_Language is\n@@ -521,11 +521,6 @@ package Prj is\n       --  If a library project, internal name store inside the library\n       --  Set by Prj.Nmsc.Language_Independent_Check.\n \n-      Lib_Elaboration : Boolean := False;\n-      --  If a library project, indicate if <lib>init and <lib>final\n-      --  procedures need to be defined.\n-      --  Set by Prj.Nmsc.Language_Independent_Check.\n-\n       Standalone_Library : Boolean := False;\n       --  Indicate that this is a Standalone Library Project File.\n       --  Set by Prj.Nmsc.Ada_Check.\n@@ -542,16 +537,18 @@ package Prj is\n       Symbol_Data : Symbol_Record := No_Symbols;\n       --  Symbol file name, reference symbol file name, symbol policy\n \n-      Sources_Present : Boolean := True;\n-      --  A flag that indicates if there are sources in this project file.\n+      Ada_Sources_Present : Boolean := True;\n+      --  A flag that indicates if there are Ada sources in this project file.\n       --  There are no sources if 1) Source_Dirs is specified as an\n       --  empty list, 2) Source_Files is specified as an empty list, or\n-      --  3) the current language is not in the list of the specified\n-      --  Languages.\n+      --  3) Ada is not in the list of the specified Languages.\n+\n+      Other_Sources_Present   : Boolean := True;\n+      --  A flag that indicates that there are non-Ada sources in this project\n \n       Sources : String_List_Id := Nil_String;\n       --  The list of all the source file names.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n \n       First_Other_Source : Other_Source_Id := No_Other_Source;\n       Last_Other_Source  : Other_Source_Id := No_Other_Source;\n@@ -571,7 +568,7 @@ package Prj is\n \n       Source_Dirs : String_List_Id := Nil_String;\n       --  The list of all the source directories.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  Set by Prj.Nmsc.Language_Independent_Check.\n \n       Known_Order_Of_Source_Dirs : Boolean := True;\n       --  False, if there is any /** in the Source_Dirs, because in this case\n@@ -580,14 +577,14 @@ package Prj is\n \n       Object_Directory : Name_Id := No_Name;\n       --  The object directory of this project file.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  Set by Prj.Nmsc.Language_Independent_Check.\n \n       Display_Object_Dir : Name_Id := No_Name;\n \n       Exec_Directory   : Name_Id := No_Name;\n       --  The exec directory of this project file.\n       --  Default is equal to Object_Directory.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  Set by Prj.Nmsc.Language_Independent_Check.\n \n       Display_Exec_Dir : Name_Id := No_Name;\n \n@@ -661,7 +658,7 @@ package Prj is\n       Checked : Boolean := False;\n       --  A flag to avoid checking repetitively the naming scheme of\n       --  this project file.\n-      --  Set by Prj.Nmsc.Check_Naming_Scheme.\n+      --  Set by Prj.Nmsc.Check_Ada_Naming_Scheme.\n \n       Seen  : Boolean := False;\n       Flag1 : Boolean := False;"}, {"sha": "77f39370d550cca75bd19629e161b4435fe069bc", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -467,33 +467,16 @@ db_phases (int phases)\n */\n \n \n-/* This is the structure of exception objects as built by the GNAT runtime\n-   library (a-exexpr.adb). The layouts should exactly match, and the \"common\"\n-   header is mandated by the exception handling ABI.  */\n+/* This is an incomplete \"proxy\" of the structure of exception objects as\n+   built by the GNAT runtime library. Accesses to other fields than the common\n+   header are performed through subprogram calls to aleviate the need of an\n+   exact counterpart here and potential alignment/size issues for the common\n+   header. See a-exexpr.adb.  */\n \n typedef struct\n {\n   _Unwind_Exception common;\n   /* ABI header, maximally aligned. */\n-\n-  _Unwind_Ptr id;\n-  /* Id of the exception beeing propagated, filled by Propagate_Exception.\n-\n-     This is compared against the ttype entries associated with actions in the\n-     examined context to see if one of these actions matches.  */\n-\n-  int  n_cleanups_to_trigger;\n-  /* Number of cleanups on the propagation way for the occurrence. This is\n-     initialized to 0 by Propagate_Exception and computed by the personality\n-     routine during the first phase of the propagation (incremented for each\n-     context in which only cleanup actions match).\n-\n-     This is used by Propagate_Exception when the occurrence is not handled,\n-     to control a forced unwinding phase aimed at triggering all the cleanups\n-     before calling Unhandled_Exception_Terminate.\n-\n-     This is also used by __gnat_eh_personality to identify the point at which\n-     the notification routine shall be called for a handled occurrence.  */\n } _GNAT_Exception;\n \n /* The two constants below are specific ttype identifiers for special\n@@ -846,21 +829,26 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n    PROPAGATED_EXCEPTION is caught by the handling code controlled by CHOICE.\n    This takes care of the special Non_Ada_Error case on VMS.  */\n \n-#define Is_Handled_By_Others __gnat_is_handled_by_others\n-#define Language_For __gnat_language_for\n-#define Import_Code_For __gnat_import_code_for\n+#define Is_Handled_By_Others  __gnat_is_handled_by_others\n+#define Language_For          __gnat_language_for\n+#define Import_Code_For       __gnat_import_code_for\n+#define EID_For               __gnat_eid_for\n+#define Adjust_N_Cleanups_For __gnat_adjust_n_cleanups_for\n+\n+extern bool Is_Handled_By_Others (_Unwind_Ptr eid);\n+extern char Language_For (_Unwind_Ptr eid);\n \n-extern bool Is_Handled_By_Others (_Unwind_Ptr e);\n-extern char Language_For (_Unwind_Ptr e);\n+extern Exception_Code Import_Code_For (_Unwind_Ptr eid);\n \n-extern Exception_Code Import_Code_For (_Unwind_Ptr e);\n+extern Exception_Id EID_For (_GNAT_Exception * e);\n+extern void Adjust_N_Cleanups_For (_GNAT_Exception * e, int n);\n \n static int\n is_handled_by (_Unwind_Ptr choice, _GNAT_Exception * propagated_exception)\n {\n   /* Pointer to the GNAT exception data corresponding to the propagated\n      occurrence.  */\n-  _Unwind_Ptr E = propagated_exception->id;\n+  _Unwind_Ptr E = (_Unwind_Ptr) EID_For (propagated_exception);\n \n   /* Base matching rules: An exception data (id) matches itself, \"when\n      all_others\" matches anything and \"when others\" matches anything unless\n@@ -1066,7 +1054,7 @@ __gnat_eh_personality (int uw_version,\n     {\n       if (action.kind == cleanup)\n \t{\n-\t  gnat_exception->n_cleanups_to_trigger ++;\n+\t  Adjust_N_Cleanups_For (gnat_exception, 1);\n \t  return _URC_CONTINUE_UNWIND;\n \t}\n       else\n@@ -1090,7 +1078,7 @@ __gnat_eh_personality (int uw_version,\n      Ada.Exceptions.Exception_Propagation to decide wether unwinding should\n      proceed further or Unhandled_Exception_Terminate should be called.  */\n   if (action.kind == cleanup)\n-    gnat_exception->n_cleanups_to_trigger --;\n+    Adjust_N_Cleanups_For (gnat_exception, -1);\n \n   setup_to_install\n     (uw_context, uw_exception, action.landing_pad, action.ttype_filter);"}, {"sha": "b36ee59bed41aad4b22c183b4f834159135db759", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1052,9 +1052,9 @@ package body Rtsfind is\n \n    function RTU_Loaded (U : RTU_Id) return Boolean is\n    begin\n-      return True and Present (RT_Unit_Table (U).Entity);\n-      --  Temp kludge, return True, deals with bug of loading unit with\n-      --  WITH not being registered as a proper rtsfind load ???\n+      return True or else Present (RT_Unit_Table (U).Entity);\n+      --  Temporary kludge until we get proper interaction to ensure that\n+      --  an explicit WITH of a unit is properly registered in rtsfind ???\n    end RTU_Loaded;\n \n    --------------------"}, {"sha": "d77ebdbcca14e4abf99031acec929861fc8d15c5", "filename": "gcc/ada/s-parame-mingw.adb", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-parame-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-parame-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-mingw.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -0,0 +1,73 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . P A R A M E T E R S                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Windows (native) specific version\n+\n+package body System.Parameters is\n+\n+   -------------------------\n+   -- Adjust_Storage_Size --\n+   -------------------------\n+\n+   function Adjust_Storage_Size (Size : Size_Type) return Size_Type is\n+   begin\n+      if Size = Unspecified_Size then\n+         return Default_Stack_Size;\n+\n+      elsif Size < Minimum_Stack_Size then\n+         return Minimum_Stack_Size;\n+\n+      else\n+         return Size;\n+      end if;\n+   end Adjust_Storage_Size;\n+\n+   ------------------------\n+   -- Default_Stack_Size --\n+   ------------------------\n+\n+   function Default_Stack_Size return Size_Type is\n+   begin\n+      return 20 * 1024;\n+   end Default_Stack_Size;\n+\n+   ------------------------\n+   -- Minimum_Stack_Size --\n+   ------------------------\n+\n+   function Minimum_Stack_Size return Size_Type is\n+   begin\n+      return 1024;\n+   end Minimum_Stack_Size;\n+\n+end System.Parameters;"}, {"sha": "409adc66c0ffc9a135682704a7f1389314a3fa1c", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -348,7 +348,7 @@ package System.Rident is\n \n                      --    pragma Dispatching_Policy (FIFO_Within_Priorities);\n                      --    pragma Locking_Policy (Ceiling_Locking);\n-                     --    pragma Detect_Blocking_Mode ???\n+                     --    pragma Detect_Blocking\n \n                      Ravenscar  =>\n "}, {"sha": "049a63d42a595da2891619b182425bb10eeb298f", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -846,28 +846,17 @@ package body System.Task_Primitives.Operations is\n       hTask          : HANDLE;\n       TaskId         : aliased DWORD;\n       pTaskParameter : System.OS_Interface.PVOID;\n-      dwStackSize    : DWORD;\n       Result         : DWORD;\n       Entry_Point    : PTHREAD_START_ROUTINE;\n \n    begin\n       pTaskParameter := To_Address (T);\n \n-      if Stack_Size = Unspecified_Size then\n-         dwStackSize := DWORD (Default_Stack_Size);\n-\n-      elsif Stack_Size < Minimum_Stack_Size then\n-         dwStackSize := DWORD (Minimum_Stack_Size);\n-\n-      else\n-         dwStackSize := DWORD (Stack_Size);\n-      end if;\n-\n       Entry_Point := To_PTHREAD_START_ROUTINE (Wrapper);\n \n       hTask := CreateThread\n          (null,\n-          dwStackSize,\n+          DWORD (Adjust_Storage_Size (Stack_Size)),\n           Entry_Point,\n           pTaskParameter,\n           DWORD (Create_Suspended),"}, {"sha": "4e04afc32778b715b579f3d12d9bfe550a03e0d1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -3803,11 +3803,14 @@ package body Sem_Attr is\n    --  one attribute expression, and the check succeeds, we want to be able\n    --  to proceed securely assuming that an expression is in fact present.\n \n+   --  Note: we set the attribute analyzed in this case to prevent any\n+   --  attempt at reanalysis which could generate spurious error msgs.\n+\n    exception\n       when Bad_Attribute =>\n+         Set_Analyzed (N);\n          Set_Etype (N, Any_Type);\n          return;\n-\n    end Analyze_Attribute;\n \n    --------------------"}, {"sha": "b8f30017ce4e9e07f2404056d57d194781ecadce", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1432,7 +1432,7 @@ package body Sem_Ch10 is\n          for J in reverse 1 .. Num_Scopes loop\n             U := Use_Clauses (J);\n             Scope_Stack.Table (Scope_Stack.Last - J + 1).First_Use_Clause := U;\n-            Install_Use_Clauses (U);\n+            Install_Use_Clauses (U, Force_Installation => True);\n          end loop;\n       end Re_Install_Use_Clauses;\n "}, {"sha": "2030b3020a35d085b1f2211ea85f19727ad0ec4e", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -2092,7 +2092,6 @@ package body Sem_Ch13 is\n                --  tag to get an explicit position.\n \n                elsif Nkind (Component_Name (CC)) = N_Attribute_Reference then\n-\n                   if Attribute_Name (Component_Name (CC)) = Name_Tag then\n                      Error_Msg_N (\"position of tag cannot be specified\", CC);\n                   else\n@@ -3422,10 +3421,7 @@ package body Sem_Ch13 is\n    -- Rep_Item_Too_Early --\n    ------------------------\n \n-   function Rep_Item_Too_Early\n-     (T : Entity_Id;\n-      N : Node_Id) return Boolean\n-   is\n+   function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean is\n    begin\n       --  Cannot apply rep items that are not operational items\n       --  to generic types\n@@ -3646,6 +3642,10 @@ package body Sem_Ch13 is\n                --  CD1 and CD2 are either components or discriminants. This\n                --  function tests whether the two have the same representation\n \n+               --------------\n+               -- Same_Rep --\n+               --------------\n+\n                function Same_Rep return Boolean is\n                begin\n                   if No (Component_Clause (CD1)) then"}, {"sha": "cc573ef154a5a3888c1242c9928cfb944f8d9508", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,8 +46,7 @@ package Sem_Ch13 is\n \n    function Minimum_Size\n      (T      : Entity_Id;\n-      Biased : Boolean := False)\n-      return   Nat;\n+      Biased : Boolean := False) return Nat;\n    --  Given a primitive type, determines the minimum number of bits required\n    --  to represent all values of the type. This function may not be called\n    --  with any other types. If the flag Biased is set True, then the minimum\n@@ -96,10 +95,7 @@ package Sem_Ch13 is\n    --  definition clause that applies to type T. This procedure links\n    --  the node N onto the Rep_Item chain for the type T.\n \n-   function Rep_Item_Too_Early\n-     (T     : Entity_Id;\n-      N     : Node_Id)\n-      return  Boolean;\n+   function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean;\n    --  Called at the start of processing a representation clause or a\n    --  representation pragma. Used to check that the representation item\n    --  is not being applied to an incompleted type or to a generic formal\n@@ -110,8 +106,7 @@ package Sem_Ch13 is\n    function Rep_Item_Too_Late\n      (T     : Entity_Id;\n       N     : Node_Id;\n-      FOnly : Boolean := False)\n-      return  Boolean;\n+      FOnly : Boolean := False) return Boolean;\n    --  Called at the start of processing a representation clause or a\n    --  representation pragma. Used to check that a representation item\n    --  for entity T does not appear too late (according to the rules in"}, {"sha": "a85d8c5ddca1e8e44eafd6e161fe47ff55183be9", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -762,7 +762,7 @@ package body Sem_Ch3 is\n       Formal  : Entity_Id;\n \n       Desig_Type : constant Entity_Id :=\n-                   Create_Itype (E_Subprogram_Type, Parent (T_Def));\n+                     Create_Itype (E_Subprogram_Type, Parent (T_Def));\n \n    begin\n       if Nkind (T_Def) = N_Access_Function_Definition then\n@@ -5273,15 +5273,41 @@ package body Sem_Ch3 is\n \n                Next_Discriminant (Discrim);\n             end loop;\n+\n+            --  Check whether the constraints of the full view statically\n+            --  match those imposed by the parent subtype [7.3(13)].\n+\n+            if Present (Stored_Constraint (Derived_Type)) then\n+               declare\n+                  C1, C2 : Elmt_Id;\n+\n+               begin\n+                  C1 := First_Elmt (Discs);\n+                  C2 := First_Elmt (Stored_Constraint (Derived_Type));\n+                  while Present (C1) and then Present (C2) loop\n+                     if not\n+                       Fully_Conformant_Expressions (Node (C1), Node (C2))\n+                     then\n+                        Error_Msg_N (\n+                          \"not conformant with previous declaration\",\n+                             Node (C1));\n+                     end if;\n+\n+                     Next_Elmt (C1);\n+                     Next_Elmt (C2);\n+                  end loop;\n+               end;\n+            end if;\n          end if;\n \n       --  STEP 2b: No new discriminants, inherit discriminants if any\n \n       else\n          if Private_Extension then\n             Set_Has_Unknown_Discriminants\n-              (Derived_Type, Has_Unknown_Discriminants (Parent_Type)\n-                             or else Unknown_Discriminants_Present (N));\n+              (Derived_Type,\n+               Has_Unknown_Discriminants (Parent_Type)\n+                 or else Unknown_Discriminants_Present (N));\n \n          --  The partial view of the parent may have unknown discriminants,\n          --  but if the full view has discriminants and the parent type is\n@@ -8480,8 +8506,7 @@ package body Sem_Ch3 is\n       Is_Static   : Boolean := True;\n \n       procedure Collect_Fixed_Components (Typ : Entity_Id);\n-      --  Collect components of parent type that do not appear in a variant\n-      --  part.\n+      --  Collect parent type components that do not appear in a variant part\n \n       procedure Create_All_Components;\n       --  Iterate over Comp_List to create the components of the subtype.\n@@ -8679,8 +8704,8 @@ package body Sem_Ch3 is\n          --  If the tagged derivation has a type extension, collect all the\n          --  new components therein.\n \n-         if Present (\n-           Record_Extension_Part (Type_Definition (Parent (Typ))))\n+         if Present\n+              (Record_Extension_Part (Type_Definition (Parent (Typ))))\n          then\n             Old_C := First_Component (Typ);\n \n@@ -8894,9 +8919,6 @@ package body Sem_Ch3 is\n    is\n       Formal     : Entity_Id;\n       New_Formal : Entity_Id;\n-      Same_Subt  : constant Boolean :=\n-        Is_Scalar_Type (Parent_Type)\n-          and then Subtypes_Statically_Compatible (Parent_Type, Derived_Type);\n       Visible_Subp : Entity_Id := Parent_Subp;\n \n       function Is_Private_Overriding return Boolean;\n@@ -8959,6 +8981,7 @@ package body Sem_Ch3 is\n       procedure Replace_Type (Id, New_Id : Entity_Id) is\n          Acc_Type : Entity_Id;\n          IR       : Node_Id;\n+         Par      : constant Node_Id := Parent (Derived_Type);\n \n       begin\n          --  When the type is an anonymous access type, create a new access\n@@ -9001,7 +9024,7 @@ package body Sem_Ch3 is\n                   Set_Etype (New_Id, Acc_Type);\n                   Set_Scope (New_Id, New_Subp);\n \n-                  --  Create a reference to it.\n+                  --  Create a reference to it\n \n                   IR := Make_Itype_Reference (Sloc (Parent (Derived_Type)));\n                   Set_Itype (IR, Acc_Type);\n@@ -9011,14 +9034,14 @@ package body Sem_Ch3 is\n                   Set_Etype (New_Id, Etype (Id));\n                end if;\n             end;\n+\n          elsif Base_Type (Etype (Id)) = Base_Type (Parent_Type)\n            or else\n              (Ekind (Etype (Id)) = E_Record_Type_With_Private\n                and then Present (Full_View (Etype (Id)))\n-               and then Base_Type (Full_View (Etype (Id))) =\n-                 Base_Type (Parent_Type))\n+               and then\n+                 Base_Type (Full_View (Etype (Id))) = Base_Type (Parent_Type))\n          then\n-\n             --  Constraint checks on formals are generated during expansion,\n             --  based on the signature of the original subprogram. The bounds\n             --  of the derived type are not relevant, and thus we can use\n@@ -9027,10 +9050,31 @@ package body Sem_Ch3 is\n             --  be used (a case statement, for example)  and for those cases\n             --  we must use the derived type (first subtype), not its base.\n \n-            if Etype (Id) = Parent_Type\n-              and then Same_Subt\n-            then\n-               Set_Etype (New_Id, Derived_Type);\n+            --  If the derived_type_definition has no constraints, we know that\n+            --  the derived type has the same constraints as the first subtype\n+            --  of the parent, and we can also use it rather than its base,\n+            --  which can lead to more efficient code.\n+\n+            if Etype (Id) = Parent_Type then\n+               if Is_Scalar_Type (Parent_Type)\n+                 and then\n+                   Subtypes_Statically_Compatible (Parent_Type, Derived_Type)\n+               then\n+                  Set_Etype (New_Id, Derived_Type);\n+\n+               elsif Nkind (Par) = N_Full_Type_Declaration\n+                 and then\n+                   Nkind (Type_Definition (Par)) = N_Derived_Type_Definition\n+                 and then\n+                   Is_Entity_Name\n+                     (Subtype_Indication (Type_Definition (Par)))\n+               then\n+                  Set_Etype (New_Id, Derived_Type);\n+\n+               else\n+                  Set_Etype (New_Id, Base_Type (Derived_Type));\n+               end if;\n+\n             else\n                Set_Etype (New_Id, Base_Type (Derived_Type));\n             end if;"}, {"sha": "ea64e37a5927cfadbd6ed0caccb9c0a490b2bf95", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1800,6 +1800,12 @@ package body Sem_Ch8 is\n       if Form_Num > 2 then\n          Error_Msg_N (\"too many formals for attribute\", N);\n \n+      --  Error if the attribute reference has expressions that look\n+      --  like formal parameters.\n+\n+      elsif Present (Expressions (Nam)) then\n+         Error_Msg_N (\"illegal expressions in attribute reference\", Nam);\n+\n       elsif\n         Aname = Name_Compose      or else\n         Aname = Name_Exponent     or else\n@@ -4794,7 +4800,10 @@ package body Sem_Ch8 is\n    -- Install_Use_Clauses --\n    -------------------------\n \n-   procedure Install_Use_Clauses (Clause : Node_Id) is\n+   procedure Install_Use_Clauses\n+     (Clause             : Node_Id;\n+      Force_Installation : Boolean := False)\n+   is\n       U  : Node_Id := Clause;\n       P  : Node_Id;\n       Id : Entity_Id;\n@@ -4820,8 +4829,9 @@ package body Sem_Ch8 is\n                   then\n                      Set_Redundant_Use (P, True);\n \n-                  else\n+                  elsif Force_Installation or else Applicable_Use (P) then\n                      Use_One_Package (Id, U);\n+\n                   end if;\n                end if;\n "}, {"sha": "3c6eacfa84be89a813c1227033108d1ef4814e68", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,8 +65,8 @@ package Sem_Ch8 is\n    --  specifications, more specialized procedures are invoked.\n \n    procedure End_Use_Clauses (Clause : Node_Id);\n-   --  Invoked on scope exit, to undo the effect of local use clauses. U is\n-   --  the first Use clause of a scope being exited. This can be the current\n+   --  Invoked on scope exit, to undo the effect of local use clauses. Clause\n+   --  is the first use-clause of a scope being exited. This can be the current\n    --  scope, or some enclosing scopes when building a clean environment to\n    --  compile an instance body for inlining.\n \n@@ -108,11 +108,15 @@ package Sem_Ch8 is\n    --  Initializes data structures used for visibility analysis. Must be\n    --  called before analyzing each new main source program.\n \n-   procedure Install_Use_Clauses (Clause : Node_Id);\n-   --  applies the use clauses appearing in a given declarative part,\n+   procedure Install_Use_Clauses\n+     (Clause             : Node_Id;\n+      Force_Installation : Boolean := False);\n+   --  Applies the use clauses appearing in a given declarative part,\n    --  when the corresponding scope has been placed back on the scope\n    --  stack after unstacking to compile a different context (subunit or\n-   --  parent of generic body).\n+   --  parent of generic body). Force_Installation is used when called from\n+   --  Analyze_Subunit.Re_Install_Use_Clauses to insure that, after the\n+   --  analysis of the subunit, the parent's environment is again identical.\n \n    function In_Open_Scopes (S : Entity_Id) return Boolean;\n    --  S is the entity of a scope. This function determines if this scope"}, {"sha": "aee306dd1d64bc67753907ebce67d24c5f2202c7", "filename": "gcc/ada/sem_dist.adb", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -291,7 +291,7 @@ package body Sem_Dist is\n       Remote_Subp_Decl      : Node_Id;\n       RS_Pkg_Specif         : Node_Id;\n       RS_Pkg_E              : Entity_Id;\n-      RAS_Type              : Entity_Id;\n+      RAS_Type              : Entity_Id := New_Type;\n       Async_E               : Entity_Id;\n       All_Calls_Remote_E    : Entity_Id;\n       Attribute_Subp        : Entity_Id;\n@@ -304,24 +304,14 @@ package body Sem_Dist is\n \n       if not Expander_Active then\n          return;\n+      end if;\n \n-      elsif Ekind (New_Type) = E_Record_Type then\n-         RAS_Type := New_Type;\n-\n-      else\n-         --  If the remote type has not been constructed yet, create\n-         --  it and its attributes now.\n-\n-         Attribute_Subp := TSS (New_Type, TSS_RAS_Access);\n-\n-         if No (Attribute_Subp) then\n-            Add_RAST_Features (Parent (New_Type));\n-         end if;\n-\n-         RAS_Type := Equivalent_Type (New_Type);\n+      if Ekind (RAS_Type) /= E_Record_Type then\n+         RAS_Type := Equivalent_Type (RAS_Type);\n       end if;\n \n       Attribute_Subp := TSS (RAS_Type, TSS_RAS_Access);\n+      pragma Assert (Present (Attribute_Subp));\n       Remote_Subp_Decl := Unit_Declaration_Node (Remote_Subp);\n \n       if Nkind (Remote_Subp_Decl) = N_Subprogram_Body then\n@@ -457,9 +447,6 @@ package body Sem_Dist is\n       Loc             : constant Source_Ptr := Sloc (Pref);\n       Call_Node       : Node_Id;\n       New_Type        : constant Entity_Id := Etype (Pref);\n-      RAS             : constant Entity_Id :=\n-                          Corresponding_Remote_Type (New_Type);\n-      RAS_Decl        : constant Node_Id   := Parent (RAS);\n       Explicit_Deref  : constant Node_Id   := Parent (Pref);\n       Deref_Subp_Call : constant Node_Id   := Parent (Explicit_Deref);\n       Deref_Proc      : Entity_Id;\n@@ -491,16 +478,13 @@ package body Sem_Dist is\n          return;\n       end if;\n \n-      Deref_Proc := TSS (New_Type, TSS_RAS_Dereference);\n-\n       if not Expander_Active then\n          return;\n-\n-      elsif No (Deref_Proc) then\n-         Add_RAST_Features (RAS_Decl);\n-         Deref_Proc := TSS (New_Type, TSS_RAS_Dereference);\n       end if;\n \n+      Deref_Proc := TSS (New_Type, TSS_RAS_Dereference);\n+      pragma Assert (Present (Deref_Proc));\n+\n       if Ekind (Deref_Proc) = E_Function then\n          Call_Node :=\n            Make_Function_Call (Loc,"}, {"sha": "0945a4dbc7d705e751bf26647bf4bc48c4c0f40f", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -100,7 +100,7 @@ package Sem_Eval is\n    --  When we are trying to perform compile time constant folding (for\n    --  instance for expressions such as 'C + 1', Is_Static_Expression or\n    --  Is_OK_Static_Expression are not the right functions to test to see\n-   --  if folding is possible. Instead, we use Compile_Time_Know_Value.\n+   --  if folding is possible. Instead, we use Compile_Time_Known_Value.\n    --  All static expressions that do not raise constraint error (i.e.\n    --  those for which Is_OK_Static_Expression is true) are known at\n    --  compile time, but as shown by the above example, there are cases"}, {"sha": "e4689a67e35aa426caa5179a4675abf976100aca", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1652,6 +1652,27 @@ package body Sem_Prag is\n          K    : Node_Kind;\n          Utyp : Entity_Id;\n \n+         procedure Set_Atomic (E : Entity_Id);\n+         --  Set given type as atomic, and if no explicit alignment was\n+         --  given, set alignment to unknown, since back end knows what\n+         --  the alignment requirements are for atomic arrays. Note that\n+         --  this step is necessary for derived types.\n+\n+         ----------------\n+         -- Set_Atomic --\n+         ----------------\n+\n+         procedure Set_Atomic (E : Entity_Id) is\n+         begin\n+            Set_Is_Atomic (E);\n+\n+            if not Has_Alignment_Clause (E) then\n+               Set_Alignment (E, Uint_0);\n+            end if;\n+         end Set_Atomic;\n+\n+      --  Start of processing for Process_Atomic_Shared_Volatile\n+\n       begin\n          Check_Ada_83_Warning;\n          Check_No_Identifiers;\n@@ -1678,8 +1699,9 @@ package body Sem_Prag is\n             end if;\n \n             if Prag_Id /= Pragma_Volatile then\n-               Set_Is_Atomic (E);\n-               Set_Is_Atomic (Underlying_Type (E));\n+               Set_Atomic (E);\n+               Set_Atomic (Underlying_Type (E));\n+               Set_Atomic (Base_Type (E));\n             end if;\n \n             --  Attribute belongs on the base type. If the\n@@ -3902,7 +3924,7 @@ package body Sem_Prag is\n       --      pragma Task_Dispatching_Policy (FIFO_Within_Priorities)\n       --      pragma Locking_Policy (Ceiling_Locking)\n \n-      --    Set Detect_Blocking mode ???\n+      --    Set Detect_Blocking mode\n \n       --    Set required restrictions (see System.Rident for detailed list)\n \n@@ -3948,7 +3970,9 @@ package body Sem_Prag is\n             end if;\n          end if;\n \n-         --  ??? Detect_Blocking\n+         --  pragma Detect_Blocking\n+\n+         Detect_Blocking := True;\n \n          --  Set the corresponding restrictions\n \n@@ -5239,6 +5263,18 @@ package body Sem_Prag is\n             end if;\n          end Debug;\n \n+         ---------------------\n+         -- Detect_Blocking --\n+         ---------------------\n+\n+         --  pragma Detect_Blocking;\n+\n+         when Pragma_Detect_Blocking =>\n+            GNAT_Pragma;\n+            Check_Arg_Count (0);\n+            Check_Valid_Configuration_Pragma;\n+            Detect_Blocking := True;\n+\n          -------------------\n          -- Discard_Names --\n          -------------------\n@@ -10188,6 +10224,7 @@ package body Sem_Prag is\n       Pragma_Convention                   =>  0,\n       Pragma_Convention_Identifier        =>  0,\n       Pragma_Debug                        => -1,\n+      Pragma_Detect_Blocking              => -1,\n       Pragma_Discard_Names                =>  0,\n       Pragma_Elaborate                    => -1,\n       Pragma_Elaborate_All                => -1,"}, {"sha": "84f22c550aa3aa87e97efb9f5c27dba2f8c00f18", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1383,7 +1383,7 @@ package Sinfo is\n    --    This is used to clarify output from the packed array cases.\n \n    --  Procedure_To_Call (Node4-Sem)\n-   --    Present in N_Allocator. N_Free_Statement, and N_Return_Statement\n+   --    Present in N_Allocator, N_Free_Statement, and N_Return_Statement\n    --    nodes. References the entity for the declaration of the procedure\n    --    to be called to accomplish the required operation (i.e. for the\n    --    Allocate procedure in the case of N_Allocator and N_Return_Statement"}, {"sha": "90f388dc7450fae5a970e550416af63ee6a875c9", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -445,8 +445,7 @@ package Sinput is\n    --  represent the standard 1,9,17.. spacing pattern.\n \n    function Get_Logical_Line_Number\n-     (P    : Source_Ptr)\n-      return Logical_Line_Number;\n+     (P : Source_Ptr) return Logical_Line_Number;\n    --  The line number of the specified source position is obtained by\n    --  doing a binary search on the source positions in the lines table\n    --  for the unit containing the given source position. The returned\n@@ -457,8 +456,7 @@ package Sinput is\n    --  the same as the physical line number.\n \n    function Get_Physical_Line_Number\n-     (P    : Source_Ptr)\n-      return Physical_Line_Number;\n+     (P : Source_Ptr) return Physical_Line_Number;\n    --  The line number of the specified source position is obtained by\n    --  doing a binary search on the source positions in the lines table\n    --  for the unit containing the given source position. The returned\n@@ -478,9 +476,8 @@ package Sinput is\n    --  given source location.\n \n    function Line_Start\n-     (L    : Physical_Line_Number;\n-      S    : Source_File_Index)\n-      return Source_Ptr;\n+     (L : Physical_Line_Number;\n+      S : Source_File_Index) return Source_Ptr;\n    --  Finds the source position of the start of the given line in the\n    --  given source file, using a physical line number to identify the line.\n \n@@ -525,8 +522,7 @@ package Sinput is\n \n    function Physical_To_Logical\n      (Line : Physical_Line_Number;\n-      S    : Source_File_Index)\n-      return Logical_Line_Number;\n+      S    : Source_File_Index) return Logical_Line_Number;\n    --  Given a physical line number in source file whose source index is S,\n    --  return the corresponding logical line number. If the physical line\n    --  number is one containing a Source_Reference pragma, the result will"}, {"sha": "2e2aeb58a44d603d048f6dfec83ae688477ec6cc", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -171,6 +171,7 @@ package body Snames is\n      \"compile_time_warning#\" &\n      \"component_alignment#\" &\n      \"convention_identifier#\" &\n+     \"detect_blocking#\" &\n      \"discard_names#\" &\n      \"elaboration_checks#\" &\n      \"eliminate#\" &"}, {"sha": "bcd57939ea57a0dcfdd5e2b3b7a92607cebdb39e", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 528, "deletions": 526, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -323,131 +323,132 @@ package Snames is\n    Name_Compile_Time_Warning           : constant Name_Id := N + 111; -- GNAT\n    Name_Component_Alignment            : constant Name_Id := N + 112; -- GNAT\n    Name_Convention_Identifier          : constant Name_Id := N + 113; -- GNAT\n-   Name_Discard_Names                  : constant Name_Id := N + 114;\n-   Name_Elaboration_Checks             : constant Name_Id := N + 115; -- GNAT\n-   Name_Eliminate                      : constant Name_Id := N + 116; -- GNAT\n-   Name_Explicit_Overriding            : constant Name_Id := N + 117;\n-   Name_Extend_System                  : constant Name_Id := N + 118; -- GNAT\n-   Name_Extensions_Allowed             : constant Name_Id := N + 119; -- GNAT\n-   Name_External_Name_Casing           : constant Name_Id := N + 120; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + 121; -- GNAT\n-   Name_Initialize_Scalars             : constant Name_Id := N + 122; -- GNAT\n-   Name_Interrupt_State                : constant Name_Id := N + 123; -- GNAT\n-   Name_License                        : constant Name_Id := N + 124; -- GNAT\n-   Name_Locking_Policy                 : constant Name_Id := N + 125;\n-   Name_Long_Float                     : constant Name_Id := N + 126; -- VMS\n-   Name_No_Run_Time                    : constant Name_Id := N + 127; -- GNAT\n-   Name_No_Strict_Aliasing             : constant Name_Id := N + 128; -- GNAT\n-   Name_Normalize_Scalars              : constant Name_Id := N + 129;\n-   Name_Polling                        : constant Name_Id := N + 130; -- GNAT\n-   Name_Persistent_Data                : constant Name_Id := N + 131; -- GNAT\n-   Name_Persistent_Object              : constant Name_Id := N + 132; -- GNAT\n-   Name_Profile                        : constant Name_Id := N + 133; -- Ada05\n-   Name_Profile_Warnings               : constant Name_Id := N + 134; -- GNAT\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 135; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 136;\n-   Name_Ravenscar                      : constant Name_Id := N + 137;\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 138;\n-   Name_Restrictions                   : constant Name_Id := N + 139;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 140; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 141;\n-   Name_Source_File_Name               : constant Name_Id := N + 142; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 143; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 144; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 145;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 146; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 147;\n-   Name_Universal_Data                 : constant Name_Id := N + 148; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 149; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 150; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 151; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 152; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 152;\n+   Name_Detect_Blocking                : constant Name_Id := N + 114; -- Ada05\n+   Name_Discard_Names                  : constant Name_Id := N + 115;\n+   Name_Elaboration_Checks             : constant Name_Id := N + 116; -- GNAT\n+   Name_Eliminate                      : constant Name_Id := N + 117; -- GNAT\n+   Name_Explicit_Overriding            : constant Name_Id := N + 118;\n+   Name_Extend_System                  : constant Name_Id := N + 119; -- GNAT\n+   Name_Extensions_Allowed             : constant Name_Id := N + 120; -- GNAT\n+   Name_External_Name_Casing           : constant Name_Id := N + 121; -- GNAT\n+   Name_Float_Representation           : constant Name_Id := N + 122; -- GNAT\n+   Name_Initialize_Scalars             : constant Name_Id := N + 123; -- GNAT\n+   Name_Interrupt_State                : constant Name_Id := N + 124; -- GNAT\n+   Name_License                        : constant Name_Id := N + 125; -- GNAT\n+   Name_Locking_Policy                 : constant Name_Id := N + 126;\n+   Name_Long_Float                     : constant Name_Id := N + 127; -- VMS\n+   Name_No_Run_Time                    : constant Name_Id := N + 128; -- GNAT\n+   Name_No_Strict_Aliasing             : constant Name_Id := N + 129; -- GNAT\n+   Name_Normalize_Scalars              : constant Name_Id := N + 130;\n+   Name_Polling                        : constant Name_Id := N + 131; -- GNAT\n+   Name_Persistent_Data                : constant Name_Id := N + 132; -- GNAT\n+   Name_Persistent_Object              : constant Name_Id := N + 133; -- GNAT\n+   Name_Profile                        : constant Name_Id := N + 134; -- Ada05\n+   Name_Profile_Warnings               : constant Name_Id := N + 135; -- GNAT\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 136; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 137;\n+   Name_Ravenscar                      : constant Name_Id := N + 138;\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 139;\n+   Name_Restrictions                   : constant Name_Id := N + 140;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 141; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 142;\n+   Name_Source_File_Name               : constant Name_Id := N + 143; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 144; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 145; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 146;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 147; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 148;\n+   Name_Universal_Data                 : constant Name_Id := N + 149; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 150; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 151; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 152; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 153; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 153;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 153; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 154;\n-   Name_Annotate                       : constant Name_Id := N + 155; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 154; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 155;\n+   Name_Annotate                       : constant Name_Id := N + 156; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Attribute_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 156; -- GNAT\n-   Name_Asynchronous                   : constant Name_Id := N + 157;\n-   Name_Atomic                         : constant Name_Id := N + 158;\n-   Name_Atomic_Components              : constant Name_Id := N + 159;\n-   Name_Attach_Handler                 : constant Name_Id := N + 160;\n-   Name_Comment                        : constant Name_Id := N + 161; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 162; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 163; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 164;\n-   Name_Convention                     : constant Name_Id := N + 165;\n-   Name_CPP_Class                      : constant Name_Id := N + 166; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 167; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 168; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 169; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 170; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 171; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 172;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 173;\n-   Name_Export                         : constant Name_Id := N + 174;\n-   Name_Export_Exception               : constant Name_Id := N + 175; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 176; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 177; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 178; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 179; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 180; -- GNAT\n-   Name_External                       : constant Name_Id := N + 181; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 182; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 183; -- VMS\n-   Name_Import                         : constant Name_Id := N + 184;\n-   Name_Import_Exception               : constant Name_Id := N + 185; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 186; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 187; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 188; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 189; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 190;\n-   Name_Inline_Always                  : constant Name_Id := N + 191; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 192; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 193;\n-   Name_Interface                      : constant Name_Id := N + 194; -- Ada 83\n-   Name_Interface_Name                 : constant Name_Id := N + 195; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 196;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 197;\n-   Name_Java_Constructor               : constant Name_Id := N + 198; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 199; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 200; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 201; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 202; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 203;\n-   Name_Linker_Section                 : constant Name_Id := N + 204; -- GNAT\n-   Name_List                           : constant Name_Id := N + 205;\n-   Name_Machine_Attribute              : constant Name_Id := N + 206; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 207; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 208; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 209; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 210; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 211; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 212;\n-   Name_Optional_Overriding            : constant Name_Id := N + 213;\n-   Name_Overriding                     : constant Name_Id := N + 214;\n-   Name_Pack                           : constant Name_Id := N + 215;\n-   Name_Page                           : constant Name_Id := N + 216;\n-   Name_Passive                        : constant Name_Id := N + 217; -- GNAT\n-   Name_Preelaborate                   : constant Name_Id := N + 218;\n-   Name_Priority                       : constant Name_Id := N + 219;\n-   Name_Psect_Object                   : constant Name_Id := N + 220; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 221;\n-   Name_Pure_Function                  : constant Name_Id := N + 222; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 223;\n-   Name_Remote_Types                   : constant Name_Id := N + 224;\n-   Name_Share_Generic                  : constant Name_Id := N + 225; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 226; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 227;\n+   Name_Assert                         : constant Name_Id := N + 157; -- GNAT\n+   Name_Asynchronous                   : constant Name_Id := N + 158;\n+   Name_Atomic                         : constant Name_Id := N + 159;\n+   Name_Atomic_Components              : constant Name_Id := N + 160;\n+   Name_Attach_Handler                 : constant Name_Id := N + 161;\n+   Name_Comment                        : constant Name_Id := N + 162; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 163; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 164; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 165;\n+   Name_Convention                     : constant Name_Id := N + 166;\n+   Name_CPP_Class                      : constant Name_Id := N + 167; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 168; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 169; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 170; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 171; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 172; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 173;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 174;\n+   Name_Export                         : constant Name_Id := N + 175;\n+   Name_Export_Exception               : constant Name_Id := N + 176; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 177; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 178; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 179; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 180; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 181; -- GNAT\n+   Name_External                       : constant Name_Id := N + 182; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 183; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 184; -- VMS\n+   Name_Import                         : constant Name_Id := N + 185;\n+   Name_Import_Exception               : constant Name_Id := N + 186; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 187; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 188; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 189; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 190; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 191;\n+   Name_Inline_Always                  : constant Name_Id := N + 192; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 193; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 194;\n+   Name_Interface                      : constant Name_Id := N + 195; -- Ada 83\n+   Name_Interface_Name                 : constant Name_Id := N + 196; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 197;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 198;\n+   Name_Java_Constructor               : constant Name_Id := N + 199; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 200; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 201; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 202; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 203; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 204;\n+   Name_Linker_Section                 : constant Name_Id := N + 205; -- GNAT\n+   Name_List                           : constant Name_Id := N + 206;\n+   Name_Machine_Attribute              : constant Name_Id := N + 207; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 208; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 209; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 210; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 211; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 212; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 213;\n+   Name_Optional_Overriding            : constant Name_Id := N + 214;\n+   Name_Overriding                     : constant Name_Id := N + 215;\n+   Name_Pack                           : constant Name_Id := N + 216;\n+   Name_Page                           : constant Name_Id := N + 217;\n+   Name_Passive                        : constant Name_Id := N + 218; -- GNAT\n+   Name_Preelaborate                   : constant Name_Id := N + 219;\n+   Name_Priority                       : constant Name_Id := N + 220;\n+   Name_Psect_Object                   : constant Name_Id := N + 221; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 222;\n+   Name_Pure_Function                  : constant Name_Id := N + 223; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 224;\n+   Name_Remote_Types                   : constant Name_Id := N + 225;\n+   Name_Share_Generic                  : constant Name_Id := N + 226; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 227; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 228;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -457,27 +458,27 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 228; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 229; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 230; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 231; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 232; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 233; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 234; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 235; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 236; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 237; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 238; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 239; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 240; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 241; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 242; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 243; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 244; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 245;\n-   Name_Volatile_Components            : constant Name_Id := N + 246;\n-   Name_Weak_External                  : constant Name_Id := N + 247; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 247;\n+   Name_Source_Reference               : constant Name_Id := N + 229; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 230; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 231; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 232; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 233; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 234; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 235; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 236; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 237; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 238; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 239; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 240; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 241; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 242; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 243; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 244; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 245; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 246;\n+   Name_Volatile_Components            : constant Name_Id := N + 247;\n+   Name_Weak_External                  : constant Name_Id := N + 248; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 248;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -488,105 +489,105 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 248;\n-   Name_Ada                            : constant Name_Id := N + 248;\n-   Name_Assembler                      : constant Name_Id := N + 249;\n-   Name_COBOL                          : constant Name_Id := N + 250;\n-   Name_CPP                            : constant Name_Id := N + 251;\n-   Name_Fortran                        : constant Name_Id := N + 252;\n-   Name_Intrinsic                      : constant Name_Id := N + 253;\n-   Name_Java                           : constant Name_Id := N + 254;\n-   Name_Stdcall                        : constant Name_Id := N + 255;\n-   Name_Stubbed                        : constant Name_Id := N + 256;\n-   Last_Convention_Name                : constant Name_Id := N + 256;\n+   First_Convention_Name               : constant Name_Id := N + 249;\n+   Name_Ada                            : constant Name_Id := N + 249;\n+   Name_Assembler                      : constant Name_Id := N + 250;\n+   Name_COBOL                          : constant Name_Id := N + 251;\n+   Name_CPP                            : constant Name_Id := N + 252;\n+   Name_Fortran                        : constant Name_Id := N + 253;\n+   Name_Intrinsic                      : constant Name_Id := N + 254;\n+   Name_Java                           : constant Name_Id := N + 255;\n+   Name_Stdcall                        : constant Name_Id := N + 256;\n+   Name_Stubbed                        : constant Name_Id := N + 257;\n+   Last_Convention_Name                : constant Name_Id := N + 257;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 257;\n-   Name_Assembly                       : constant Name_Id := N + 258;\n+   Name_Asm                            : constant Name_Id := N + 258;\n+   Name_Assembly                       : constant Name_Id := N + 259;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 259;\n+   Name_Default                        : constant Name_Id := N + 260;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 260;\n-   Name_Win32                          : constant Name_Id := N + 261;\n+   Name_DLL                            : constant Name_Id := N + 261;\n+   Name_Win32                          : constant Name_Id := N + 262;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 262;\n-   Name_Body_File_Name                 : constant Name_Id := N + 263;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 264;\n-   Name_Casing                         : constant Name_Id := N + 265;\n-   Name_Code                           : constant Name_Id := N + 266;\n-   Name_Component                      : constant Name_Id := N + 267;\n-   Name_Component_Size_4               : constant Name_Id := N + 268;\n-   Name_Copy                           : constant Name_Id := N + 269;\n-   Name_D_Float                        : constant Name_Id := N + 270;\n-   Name_Descriptor                     : constant Name_Id := N + 271;\n-   Name_Dot_Replacement                : constant Name_Id := N + 272;\n-   Name_Dynamic                        : constant Name_Id := N + 273;\n-   Name_Entity                         : constant Name_Id := N + 274;\n-   Name_External_Name                  : constant Name_Id := N + 275;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 276;\n-   Name_Form                           : constant Name_Id := N + 277;\n-   Name_G_Float                        : constant Name_Id := N + 278;\n-   Name_Gcc                            : constant Name_Id := N + 279;\n-   Name_Gnat                           : constant Name_Id := N + 280;\n-   Name_GPL                            : constant Name_Id := N + 281;\n-   Name_IEEE_Float                     : constant Name_Id := N + 282;\n-   Name_Internal                       : constant Name_Id := N + 283;\n-   Name_Link_Name                      : constant Name_Id := N + 284;\n-   Name_Lowercase                      : constant Name_Id := N + 285;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 286;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 287;\n-   Name_Max_Size                       : constant Name_Id := N + 288;\n-   Name_Mechanism                      : constant Name_Id := N + 289;\n-   Name_Mixedcase                      : constant Name_Id := N + 290;\n-   Name_Modified_GPL                   : constant Name_Id := N + 291;\n-   Name_Name                           : constant Name_Id := N + 292;\n-   Name_NCA                            : constant Name_Id := N + 293;\n-   Name_No                             : constant Name_Id := N + 294;\n-   Name_On                             : constant Name_Id := N + 295;\n-   Name_Parameter_Types                : constant Name_Id := N + 296;\n-   Name_Reference                      : constant Name_Id := N + 297;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 298;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 299;\n-   Name_No_Requeue                     : constant Name_Id := N + 300;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 301;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 302;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 303;\n-   Name_Restricted                     : constant Name_Id := N + 304;\n-   Name_Result_Mechanism               : constant Name_Id := N + 305;\n-   Name_Result_Type                    : constant Name_Id := N + 306;\n-   Name_Runtime                        : constant Name_Id := N + 307;\n-   Name_SB                             : constant Name_Id := N + 308;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 309;\n-   Name_Section                        : constant Name_Id := N + 310;\n-   Name_Semaphore                      : constant Name_Id := N + 311;\n-   Name_Simple_Barriers                : constant Name_Id := N + 312;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 313;\n-   Name_Static                         : constant Name_Id := N + 314;\n-   Name_Stack_Size                     : constant Name_Id := N + 315;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 316;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 317;\n-   Name_Task_Type                      : constant Name_Id := N + 318;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 319;\n-   Name_Top_Guard                      : constant Name_Id := N + 320;\n-   Name_UBA                            : constant Name_Id := N + 321;\n-   Name_UBS                            : constant Name_Id := N + 322;\n-   Name_UBSB                           : constant Name_Id := N + 323;\n-   Name_Unit_Name                      : constant Name_Id := N + 324;\n-   Name_Unknown                        : constant Name_Id := N + 325;\n-   Name_Unrestricted                   : constant Name_Id := N + 326;\n-   Name_Uppercase                      : constant Name_Id := N + 327;\n-   Name_User                           : constant Name_Id := N + 328;\n-   Name_VAX_Float                      : constant Name_Id := N + 329;\n-   Name_VMS                            : constant Name_Id := N + 330;\n-   Name_Working_Storage                : constant Name_Id := N + 331;\n+   Name_As_Is                          : constant Name_Id := N + 263;\n+   Name_Body_File_Name                 : constant Name_Id := N + 264;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 265;\n+   Name_Casing                         : constant Name_Id := N + 266;\n+   Name_Code                           : constant Name_Id := N + 267;\n+   Name_Component                      : constant Name_Id := N + 268;\n+   Name_Component_Size_4               : constant Name_Id := N + 269;\n+   Name_Copy                           : constant Name_Id := N + 270;\n+   Name_D_Float                        : constant Name_Id := N + 271;\n+   Name_Descriptor                     : constant Name_Id := N + 272;\n+   Name_Dot_Replacement                : constant Name_Id := N + 273;\n+   Name_Dynamic                        : constant Name_Id := N + 274;\n+   Name_Entity                         : constant Name_Id := N + 275;\n+   Name_External_Name                  : constant Name_Id := N + 276;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 277;\n+   Name_Form                           : constant Name_Id := N + 278;\n+   Name_G_Float                        : constant Name_Id := N + 279;\n+   Name_Gcc                            : constant Name_Id := N + 280;\n+   Name_Gnat                           : constant Name_Id := N + 281;\n+   Name_GPL                            : constant Name_Id := N + 282;\n+   Name_IEEE_Float                     : constant Name_Id := N + 283;\n+   Name_Internal                       : constant Name_Id := N + 284;\n+   Name_Link_Name                      : constant Name_Id := N + 285;\n+   Name_Lowercase                      : constant Name_Id := N + 286;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 287;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 288;\n+   Name_Max_Size                       : constant Name_Id := N + 289;\n+   Name_Mechanism                      : constant Name_Id := N + 290;\n+   Name_Mixedcase                      : constant Name_Id := N + 291;\n+   Name_Modified_GPL                   : constant Name_Id := N + 292;\n+   Name_Name                           : constant Name_Id := N + 293;\n+   Name_NCA                            : constant Name_Id := N + 294;\n+   Name_No                             : constant Name_Id := N + 295;\n+   Name_On                             : constant Name_Id := N + 296;\n+   Name_Parameter_Types                : constant Name_Id := N + 297;\n+   Name_Reference                      : constant Name_Id := N + 298;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 299;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 300;\n+   Name_No_Requeue                     : constant Name_Id := N + 301;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 302;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 303;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 304;\n+   Name_Restricted                     : constant Name_Id := N + 305;\n+   Name_Result_Mechanism               : constant Name_Id := N + 306;\n+   Name_Result_Type                    : constant Name_Id := N + 307;\n+   Name_Runtime                        : constant Name_Id := N + 308;\n+   Name_SB                             : constant Name_Id := N + 309;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 310;\n+   Name_Section                        : constant Name_Id := N + 311;\n+   Name_Semaphore                      : constant Name_Id := N + 312;\n+   Name_Simple_Barriers                : constant Name_Id := N + 313;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 314;\n+   Name_Static                         : constant Name_Id := N + 315;\n+   Name_Stack_Size                     : constant Name_Id := N + 316;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 317;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 318;\n+   Name_Task_Type                      : constant Name_Id := N + 319;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 320;\n+   Name_Top_Guard                      : constant Name_Id := N + 321;\n+   Name_UBA                            : constant Name_Id := N + 322;\n+   Name_UBS                            : constant Name_Id := N + 323;\n+   Name_UBSB                           : constant Name_Id := N + 324;\n+   Name_Unit_Name                      : constant Name_Id := N + 325;\n+   Name_Unknown                        : constant Name_Id := N + 326;\n+   Name_Unrestricted                   : constant Name_Id := N + 327;\n+   Name_Uppercase                      : constant Name_Id := N + 328;\n+   Name_User                           : constant Name_Id := N + 329;\n+   Name_VAX_Float                      : constant Name_Id := N + 330;\n+   Name_VMS                            : constant Name_Id := N + 331;\n+   Name_Working_Storage                : constant Name_Id := N + 332;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -600,375 +601,375 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 332;\n-   Name_Abort_Signal                   : constant Name_Id := N + 332;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 333;\n-   Name_Address                        : constant Name_Id := N + 334;\n-   Name_Address_Size                   : constant Name_Id := N + 335;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 336;\n-   Name_Alignment                      : constant Name_Id := N + 337;\n-   Name_Asm_Input                      : constant Name_Id := N + 338;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 339;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 340;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 341;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 342;\n-   Name_Bit_Position                   : constant Name_Id := N + 343;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 344;\n-   Name_Callable                       : constant Name_Id := N + 345;\n-   Name_Caller                         : constant Name_Id := N + 346;\n-   Name_Code_Address                   : constant Name_Id := N + 347;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 348;\n-   Name_Compose                        : constant Name_Id := N + 349;\n-   Name_Constrained                    : constant Name_Id := N + 350;\n-   Name_Count                          : constant Name_Id := N + 351;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 352; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 353;\n-   Name_Delta                          : constant Name_Id := N + 354;\n-   Name_Denorm                         : constant Name_Id := N + 355;\n-   Name_Digits                         : constant Name_Id := N + 356;\n-   Name_Elaborated                     : constant Name_Id := N + 357; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 358; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 359; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 360; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 361;\n-   Name_External_Tag                   : constant Name_Id := N + 362;\n-   Name_First                          : constant Name_Id := N + 363;\n-   Name_First_Bit                      : constant Name_Id := N + 364;\n-   Name_Fixed_Value                    : constant Name_Id := N + 365; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 366;\n-   Name_Has_Discriminants              : constant Name_Id := N + 367; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 368;\n-   Name_Img                            : constant Name_Id := N + 369; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 370; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 371; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 372;\n-   Name_Last_Bit                       : constant Name_Id := N + 373;\n-   Name_Leading_Part                   : constant Name_Id := N + 374;\n-   Name_Length                         : constant Name_Id := N + 375;\n-   Name_Machine_Emax                   : constant Name_Id := N + 376;\n-   Name_Machine_Emin                   : constant Name_Id := N + 377;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 378;\n-   Name_Machine_Overflows              : constant Name_Id := N + 379;\n-   Name_Machine_Radix                  : constant Name_Id := N + 380;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 381;\n-   Name_Machine_Size                   : constant Name_Id := N + 382; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 383; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 384;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 385; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 386; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 387;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 388;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 389;\n-   Name_Model_Small                    : constant Name_Id := N + 390;\n-   Name_Modulus                        : constant Name_Id := N + 391;\n-   Name_Null_Parameter                 : constant Name_Id := N + 392; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 393; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 394;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 395; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 396;\n-   Name_Pos                            : constant Name_Id := N + 397;\n-   Name_Position                       : constant Name_Id := N + 398;\n-   Name_Range                          : constant Name_Id := N + 399;\n-   Name_Range_Length                   : constant Name_Id := N + 400; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 401;\n-   Name_Safe_Emax                      : constant Name_Id := N + 402; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 403;\n-   Name_Safe_Large                     : constant Name_Id := N + 404; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 405;\n-   Name_Safe_Small                     : constant Name_Id := N + 406; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 407;\n-   Name_Scaling                        : constant Name_Id := N + 408;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 409;\n-   Name_Size                           : constant Name_Id := N + 410;\n-   Name_Small                          : constant Name_Id := N + 411;\n-   Name_Storage_Size                   : constant Name_Id := N + 412;\n-   Name_Storage_Unit                   : constant Name_Id := N + 413; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 414;\n-   Name_Target_Name                    : constant Name_Id := N + 415; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 416;\n-   Name_To_Address                     : constant Name_Id := N + 417; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 418; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 419; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 420;\n-   Name_Unchecked_Access               : constant Name_Id := N + 421;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 422;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 423; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 424; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 425; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 426;\n-   Name_Valid                          : constant Name_Id := N + 427;\n-   Name_Value_Size                     : constant Name_Id := N + 428; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 429;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 430; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 431;\n-   Name_Width                          : constant Name_Id := N + 432;\n-   Name_Word_Size                      : constant Name_Id := N + 433; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 333;\n+   Name_Abort_Signal                   : constant Name_Id := N + 333;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 334;\n+   Name_Address                        : constant Name_Id := N + 335;\n+   Name_Address_Size                   : constant Name_Id := N + 336;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 337;\n+   Name_Alignment                      : constant Name_Id := N + 338;\n+   Name_Asm_Input                      : constant Name_Id := N + 339;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 340;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 341;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 342;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 343;\n+   Name_Bit_Position                   : constant Name_Id := N + 344;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 345;\n+   Name_Callable                       : constant Name_Id := N + 346;\n+   Name_Caller                         : constant Name_Id := N + 347;\n+   Name_Code_Address                   : constant Name_Id := N + 348;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 349;\n+   Name_Compose                        : constant Name_Id := N + 350;\n+   Name_Constrained                    : constant Name_Id := N + 351;\n+   Name_Count                          : constant Name_Id := N + 352;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 353; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 354;\n+   Name_Delta                          : constant Name_Id := N + 355;\n+   Name_Denorm                         : constant Name_Id := N + 356;\n+   Name_Digits                         : constant Name_Id := N + 357;\n+   Name_Elaborated                     : constant Name_Id := N + 358; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 359; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 360; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 361; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 362;\n+   Name_External_Tag                   : constant Name_Id := N + 363;\n+   Name_First                          : constant Name_Id := N + 364;\n+   Name_First_Bit                      : constant Name_Id := N + 365;\n+   Name_Fixed_Value                    : constant Name_Id := N + 366; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 367;\n+   Name_Has_Discriminants              : constant Name_Id := N + 368; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 369;\n+   Name_Img                            : constant Name_Id := N + 370; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 371; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 372; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 373;\n+   Name_Last_Bit                       : constant Name_Id := N + 374;\n+   Name_Leading_Part                   : constant Name_Id := N + 375;\n+   Name_Length                         : constant Name_Id := N + 376;\n+   Name_Machine_Emax                   : constant Name_Id := N + 377;\n+   Name_Machine_Emin                   : constant Name_Id := N + 378;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 379;\n+   Name_Machine_Overflows              : constant Name_Id := N + 380;\n+   Name_Machine_Radix                  : constant Name_Id := N + 381;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 382;\n+   Name_Machine_Size                   : constant Name_Id := N + 383; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 384; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 385;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 386; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 387; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 388;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 389;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 390;\n+   Name_Model_Small                    : constant Name_Id := N + 391;\n+   Name_Modulus                        : constant Name_Id := N + 392;\n+   Name_Null_Parameter                 : constant Name_Id := N + 393; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 394; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 395;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 396; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 397;\n+   Name_Pos                            : constant Name_Id := N + 398;\n+   Name_Position                       : constant Name_Id := N + 399;\n+   Name_Range                          : constant Name_Id := N + 400;\n+   Name_Range_Length                   : constant Name_Id := N + 401; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 402;\n+   Name_Safe_Emax                      : constant Name_Id := N + 403; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 404;\n+   Name_Safe_Large                     : constant Name_Id := N + 405; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 406;\n+   Name_Safe_Small                     : constant Name_Id := N + 407; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 408;\n+   Name_Scaling                        : constant Name_Id := N + 409;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 410;\n+   Name_Size                           : constant Name_Id := N + 411;\n+   Name_Small                          : constant Name_Id := N + 412;\n+   Name_Storage_Size                   : constant Name_Id := N + 413;\n+   Name_Storage_Unit                   : constant Name_Id := N + 414; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 415;\n+   Name_Target_Name                    : constant Name_Id := N + 416; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 417;\n+   Name_To_Address                     : constant Name_Id := N + 418; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 419; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 420; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 421;\n+   Name_Unchecked_Access               : constant Name_Id := N + 422;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 423;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 424; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 425; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 426; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 427;\n+   Name_Valid                          : constant Name_Id := N + 428;\n+   Name_Value_Size                     : constant Name_Id := N + 429; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 430;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 431; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 432;\n+   Name_Width                          : constant Name_Id := N + 433;\n+   Name_Word_Size                      : constant Name_Id := N + 434; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 434;\n-   Name_Adjacent                       : constant Name_Id := N + 434;\n-   Name_Ceiling                        : constant Name_Id := N + 435;\n-   Name_Copy_Sign                      : constant Name_Id := N + 436;\n-   Name_Floor                          : constant Name_Id := N + 437;\n-   Name_Fraction                       : constant Name_Id := N + 438;\n-   Name_Image                          : constant Name_Id := N + 439;\n-   Name_Input                          : constant Name_Id := N + 440;\n-   Name_Machine                        : constant Name_Id := N + 441;\n-   Name_Max                            : constant Name_Id := N + 442;\n-   Name_Min                            : constant Name_Id := N + 443;\n-   Name_Model                          : constant Name_Id := N + 444;\n-   Name_Pred                           : constant Name_Id := N + 445;\n-   Name_Remainder                      : constant Name_Id := N + 446;\n-   Name_Rounding                       : constant Name_Id := N + 447;\n-   Name_Succ                           : constant Name_Id := N + 448;\n-   Name_Truncation                     : constant Name_Id := N + 449;\n-   Name_Value                          : constant Name_Id := N + 450;\n-   Name_Wide_Image                     : constant Name_Id := N + 451;\n-   Name_Wide_Value                     : constant Name_Id := N + 452;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 452;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 435;\n+   Name_Adjacent                       : constant Name_Id := N + 435;\n+   Name_Ceiling                        : constant Name_Id := N + 436;\n+   Name_Copy_Sign                      : constant Name_Id := N + 437;\n+   Name_Floor                          : constant Name_Id := N + 438;\n+   Name_Fraction                       : constant Name_Id := N + 439;\n+   Name_Image                          : constant Name_Id := N + 440;\n+   Name_Input                          : constant Name_Id := N + 441;\n+   Name_Machine                        : constant Name_Id := N + 442;\n+   Name_Max                            : constant Name_Id := N + 443;\n+   Name_Min                            : constant Name_Id := N + 444;\n+   Name_Model                          : constant Name_Id := N + 445;\n+   Name_Pred                           : constant Name_Id := N + 446;\n+   Name_Remainder                      : constant Name_Id := N + 447;\n+   Name_Rounding                       : constant Name_Id := N + 448;\n+   Name_Succ                           : constant Name_Id := N + 449;\n+   Name_Truncation                     : constant Name_Id := N + 450;\n+   Name_Value                          : constant Name_Id := N + 451;\n+   Name_Wide_Image                     : constant Name_Id := N + 452;\n+   Name_Wide_Value                     : constant Name_Id := N + 453;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 453;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 453;\n-   Name_Output                         : constant Name_Id := N + 453;\n-   Name_Read                           : constant Name_Id := N + 454;\n-   Name_Write                          : constant Name_Id := N + 455;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 455;\n+   First_Procedure_Attribute           : constant Name_Id := N + 454;\n+   Name_Output                         : constant Name_Id := N + 454;\n+   Name_Read                           : constant Name_Id := N + 455;\n+   Name_Write                          : constant Name_Id := N + 456;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 456;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 456;\n-   Name_Elab_Body                      : constant Name_Id := N + 456; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 457; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 458;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 457;\n+   Name_Elab_Body                      : constant Name_Id := N + 457; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 458; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 459;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 459;\n-   Name_Base                           : constant Name_Id := N + 459;\n-   Name_Class                          : constant Name_Id := N + 460;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 460;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 460;\n-   Last_Attribute_Name                 : constant Name_Id := N + 460;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 460;\n+   Name_Base                           : constant Name_Id := N + 460;\n+   Name_Class                          : constant Name_Id := N + 461;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 461;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 461;\n+   Last_Attribute_Name                 : constant Name_Id := N + 461;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 461;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 461;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 462;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 462;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 462;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 462;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 463;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 463;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 463;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 463;\n-   Name_Priority_Queuing               : constant Name_Id := N + 464;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 464;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 464;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 464;\n+   Name_Priority_Queuing               : constant Name_Id := N + 465;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 465;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 465;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 465;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 465;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 466;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 466;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 466;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 466;\n-   Name_Access_Check                   : constant Name_Id := N + 466;\n-   Name_Accessibility_Check            : constant Name_Id := N + 467;\n-   Name_Discriminant_Check             : constant Name_Id := N + 468;\n-   Name_Division_Check                 : constant Name_Id := N + 469;\n-   Name_Elaboration_Check              : constant Name_Id := N + 470;\n-   Name_Index_Check                    : constant Name_Id := N + 471;\n-   Name_Length_Check                   : constant Name_Id := N + 472;\n-   Name_Overflow_Check                 : constant Name_Id := N + 473;\n-   Name_Range_Check                    : constant Name_Id := N + 474;\n-   Name_Storage_Check                  : constant Name_Id := N + 475;\n-   Name_Tag_Check                      : constant Name_Id := N + 476;\n-   Name_All_Checks                     : constant Name_Id := N + 477;\n-   Last_Check_Name                     : constant Name_Id := N + 477;\n+   First_Check_Name                    : constant Name_Id := N + 467;\n+   Name_Access_Check                   : constant Name_Id := N + 467;\n+   Name_Accessibility_Check            : constant Name_Id := N + 468;\n+   Name_Discriminant_Check             : constant Name_Id := N + 469;\n+   Name_Division_Check                 : constant Name_Id := N + 470;\n+   Name_Elaboration_Check              : constant Name_Id := N + 471;\n+   Name_Index_Check                    : constant Name_Id := N + 472;\n+   Name_Length_Check                   : constant Name_Id := N + 473;\n+   Name_Overflow_Check                 : constant Name_Id := N + 474;\n+   Name_Range_Check                    : constant Name_Id := N + 475;\n+   Name_Storage_Check                  : constant Name_Id := N + 476;\n+   Name_Tag_Check                      : constant Name_Id := N + 477;\n+   Name_All_Checks                     : constant Name_Id := N + 478;\n+   Last_Check_Name                     : constant Name_Id := N + 478;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 478;\n-   Name_Abs                            : constant Name_Id := N + 479;\n-   Name_Accept                         : constant Name_Id := N + 480;\n-   Name_And                            : constant Name_Id := N + 481;\n-   Name_All                            : constant Name_Id := N + 482;\n-   Name_Array                          : constant Name_Id := N + 483;\n-   Name_At                             : constant Name_Id := N + 484;\n-   Name_Begin                          : constant Name_Id := N + 485;\n-   Name_Body                           : constant Name_Id := N + 486;\n-   Name_Case                           : constant Name_Id := N + 487;\n-   Name_Constant                       : constant Name_Id := N + 488;\n-   Name_Declare                        : constant Name_Id := N + 489;\n-   Name_Delay                          : constant Name_Id := N + 490;\n-   Name_Do                             : constant Name_Id := N + 491;\n-   Name_Else                           : constant Name_Id := N + 492;\n-   Name_Elsif                          : constant Name_Id := N + 493;\n-   Name_End                            : constant Name_Id := N + 494;\n-   Name_Entry                          : constant Name_Id := N + 495;\n-   Name_Exception                      : constant Name_Id := N + 496;\n-   Name_Exit                           : constant Name_Id := N + 497;\n-   Name_For                            : constant Name_Id := N + 498;\n-   Name_Function                       : constant Name_Id := N + 499;\n-   Name_Generic                        : constant Name_Id := N + 500;\n-   Name_Goto                           : constant Name_Id := N + 501;\n-   Name_If                             : constant Name_Id := N + 502;\n-   Name_In                             : constant Name_Id := N + 503;\n-   Name_Is                             : constant Name_Id := N + 504;\n-   Name_Limited                        : constant Name_Id := N + 505;\n-   Name_Loop                           : constant Name_Id := N + 506;\n-   Name_Mod                            : constant Name_Id := N + 507;\n-   Name_New                            : constant Name_Id := N + 508;\n-   Name_Not                            : constant Name_Id := N + 509;\n-   Name_Null                           : constant Name_Id := N + 510;\n-   Name_Of                             : constant Name_Id := N + 511;\n-   Name_Or                             : constant Name_Id := N + 512;\n-   Name_Others                         : constant Name_Id := N + 513;\n-   Name_Out                            : constant Name_Id := N + 514;\n-   Name_Package                        : constant Name_Id := N + 515;\n-   Name_Pragma                         : constant Name_Id := N + 516;\n-   Name_Private                        : constant Name_Id := N + 517;\n-   Name_Procedure                      : constant Name_Id := N + 518;\n-   Name_Raise                          : constant Name_Id := N + 519;\n-   Name_Record                         : constant Name_Id := N + 520;\n-   Name_Rem                            : constant Name_Id := N + 521;\n-   Name_Renames                        : constant Name_Id := N + 522;\n-   Name_Return                         : constant Name_Id := N + 523;\n-   Name_Reverse                        : constant Name_Id := N + 524;\n-   Name_Select                         : constant Name_Id := N + 525;\n-   Name_Separate                       : constant Name_Id := N + 526;\n-   Name_Subtype                        : constant Name_Id := N + 527;\n-   Name_Task                           : constant Name_Id := N + 528;\n-   Name_Terminate                      : constant Name_Id := N + 529;\n-   Name_Then                           : constant Name_Id := N + 530;\n-   Name_Type                           : constant Name_Id := N + 531;\n-   Name_Use                            : constant Name_Id := N + 532;\n-   Name_When                           : constant Name_Id := N + 533;\n-   Name_While                          : constant Name_Id := N + 534;\n-   Name_With                           : constant Name_Id := N + 535;\n-   Name_Xor                            : constant Name_Id := N + 536;\n+   Name_Abort                          : constant Name_Id := N + 479;\n+   Name_Abs                            : constant Name_Id := N + 480;\n+   Name_Accept                         : constant Name_Id := N + 481;\n+   Name_And                            : constant Name_Id := N + 482;\n+   Name_All                            : constant Name_Id := N + 483;\n+   Name_Array                          : constant Name_Id := N + 484;\n+   Name_At                             : constant Name_Id := N + 485;\n+   Name_Begin                          : constant Name_Id := N + 486;\n+   Name_Body                           : constant Name_Id := N + 487;\n+   Name_Case                           : constant Name_Id := N + 488;\n+   Name_Constant                       : constant Name_Id := N + 489;\n+   Name_Declare                        : constant Name_Id := N + 490;\n+   Name_Delay                          : constant Name_Id := N + 491;\n+   Name_Do                             : constant Name_Id := N + 492;\n+   Name_Else                           : constant Name_Id := N + 493;\n+   Name_Elsif                          : constant Name_Id := N + 494;\n+   Name_End                            : constant Name_Id := N + 495;\n+   Name_Entry                          : constant Name_Id := N + 496;\n+   Name_Exception                      : constant Name_Id := N + 497;\n+   Name_Exit                           : constant Name_Id := N + 498;\n+   Name_For                            : constant Name_Id := N + 499;\n+   Name_Function                       : constant Name_Id := N + 500;\n+   Name_Generic                        : constant Name_Id := N + 501;\n+   Name_Goto                           : constant Name_Id := N + 502;\n+   Name_If                             : constant Name_Id := N + 503;\n+   Name_In                             : constant Name_Id := N + 504;\n+   Name_Is                             : constant Name_Id := N + 505;\n+   Name_Limited                        : constant Name_Id := N + 506;\n+   Name_Loop                           : constant Name_Id := N + 507;\n+   Name_Mod                            : constant Name_Id := N + 508;\n+   Name_New                            : constant Name_Id := N + 509;\n+   Name_Not                            : constant Name_Id := N + 510;\n+   Name_Null                           : constant Name_Id := N + 511;\n+   Name_Of                             : constant Name_Id := N + 512;\n+   Name_Or                             : constant Name_Id := N + 513;\n+   Name_Others                         : constant Name_Id := N + 514;\n+   Name_Out                            : constant Name_Id := N + 515;\n+   Name_Package                        : constant Name_Id := N + 516;\n+   Name_Pragma                         : constant Name_Id := N + 517;\n+   Name_Private                        : constant Name_Id := N + 518;\n+   Name_Procedure                      : constant Name_Id := N + 519;\n+   Name_Raise                          : constant Name_Id := N + 520;\n+   Name_Record                         : constant Name_Id := N + 521;\n+   Name_Rem                            : constant Name_Id := N + 522;\n+   Name_Renames                        : constant Name_Id := N + 523;\n+   Name_Return                         : constant Name_Id := N + 524;\n+   Name_Reverse                        : constant Name_Id := N + 525;\n+   Name_Select                         : constant Name_Id := N + 526;\n+   Name_Separate                       : constant Name_Id := N + 527;\n+   Name_Subtype                        : constant Name_Id := N + 528;\n+   Name_Task                           : constant Name_Id := N + 529;\n+   Name_Terminate                      : constant Name_Id := N + 530;\n+   Name_Then                           : constant Name_Id := N + 531;\n+   Name_Type                           : constant Name_Id := N + 532;\n+   Name_Use                            : constant Name_Id := N + 533;\n+   Name_When                           : constant Name_Id := N + 534;\n+   Name_While                          : constant Name_Id := N + 535;\n+   Name_With                           : constant Name_Id := N + 536;\n+   Name_Xor                            : constant Name_Id := N + 537;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 537;\n-   Name_Divide                         : constant Name_Id := N + 537;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 538;\n-   Name_Exception_Information          : constant Name_Id := N + 539;\n-   Name_Exception_Message              : constant Name_Id := N + 540;\n-   Name_Exception_Name                 : constant Name_Id := N + 541;\n-   Name_File                           : constant Name_Id := N + 542;\n-   Name_Import_Address                 : constant Name_Id := N + 543;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 544;\n-   Name_Import_Value                   : constant Name_Id := N + 545;\n-   Name_Is_Negative                    : constant Name_Id := N + 546;\n-   Name_Line                           : constant Name_Id := N + 547;\n-   Name_Rotate_Left                    : constant Name_Id := N + 548;\n-   Name_Rotate_Right                   : constant Name_Id := N + 549;\n-   Name_Shift_Left                     : constant Name_Id := N + 550;\n-   Name_Shift_Right                    : constant Name_Id := N + 551;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 552;\n-   Name_Source_Location                : constant Name_Id := N + 553;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 554;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 555;\n-   Name_To_Pointer                     : constant Name_Id := N + 556;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 556;\n+   First_Intrinsic_Name                : constant Name_Id := N + 538;\n+   Name_Divide                         : constant Name_Id := N + 538;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 539;\n+   Name_Exception_Information          : constant Name_Id := N + 540;\n+   Name_Exception_Message              : constant Name_Id := N + 541;\n+   Name_Exception_Name                 : constant Name_Id := N + 542;\n+   Name_File                           : constant Name_Id := N + 543;\n+   Name_Import_Address                 : constant Name_Id := N + 544;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 545;\n+   Name_Import_Value                   : constant Name_Id := N + 546;\n+   Name_Is_Negative                    : constant Name_Id := N + 547;\n+   Name_Line                           : constant Name_Id := N + 548;\n+   Name_Rotate_Left                    : constant Name_Id := N + 549;\n+   Name_Rotate_Right                   : constant Name_Id := N + 550;\n+   Name_Shift_Left                     : constant Name_Id := N + 551;\n+   Name_Shift_Right                    : constant Name_Id := N + 552;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 553;\n+   Name_Source_Location                : constant Name_Id := N + 554;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 555;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 556;\n+   Name_To_Pointer                     : constant Name_Id := N + 557;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 557;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 557;\n-   Name_Abstract                       : constant Name_Id := N + 557;\n-   Name_Aliased                        : constant Name_Id := N + 558;\n-   Name_Protected                      : constant Name_Id := N + 559;\n-   Name_Until                          : constant Name_Id := N + 560;\n-   Name_Requeue                        : constant Name_Id := N + 561;\n-   Name_Tagged                         : constant Name_Id := N + 562;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 562;\n+   First_95_Reserved_Word              : constant Name_Id := N + 558;\n+   Name_Abstract                       : constant Name_Id := N + 558;\n+   Name_Aliased                        : constant Name_Id := N + 559;\n+   Name_Protected                      : constant Name_Id := N + 560;\n+   Name_Until                          : constant Name_Id := N + 561;\n+   Name_Requeue                        : constant Name_Id := N + 562;\n+   Name_Tagged                         : constant Name_Id := N + 563;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 563;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 563;\n+   Name_Raise_Exception                : constant Name_Id := N + 564;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 564;\n-   Name_Body_Suffix                    : constant Name_Id := N + 565;\n-   Name_Builder                        : constant Name_Id := N + 566;\n-   Name_Compiler                       : constant Name_Id := N + 567;\n-   Name_Cross_Reference                : constant Name_Id := N + 568;\n-   Name_Default_Switches               : constant Name_Id := N + 569;\n-   Name_Exec_Dir                       : constant Name_Id := N + 570;\n-   Name_Executable                     : constant Name_Id := N + 571;\n-   Name_Executable_Suffix              : constant Name_Id := N + 572;\n-   Name_Extends                        : constant Name_Id := N + 573;\n-   Name_Finder                         : constant Name_Id := N + 574;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 575;\n-   Name_Gnatls                         : constant Name_Id := N + 576;\n-   Name_Gnatstub                       : constant Name_Id := N + 577;\n-   Name_Implementation                 : constant Name_Id := N + 578;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 579;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 580;\n-   Name_Languages                      : constant Name_Id := N + 581;\n-   Name_Library_Dir                    : constant Name_Id := N + 582;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 583;\n-   Name_Library_GCC                    : constant Name_Id := N + 584;\n-   Name_Library_Interface              : constant Name_Id := N + 585;\n-   Name_Library_Kind                   : constant Name_Id := N + 586;\n-   Name_Library_Name                   : constant Name_Id := N + 587;\n-   Name_Library_Options                : constant Name_Id := N + 588;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 589;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 590;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 591;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 592;\n-   Name_Library_Version                : constant Name_Id := N + 593;\n-   Name_Linker                         : constant Name_Id := N + 594;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 595;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 596;\n-   Name_Metrics                        : constant Name_Id := N + 597;\n-   Name_Naming                         : constant Name_Id := N + 598;\n-   Name_Object_Dir                     : constant Name_Id := N + 599;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 600;\n-   Name_Project                        : constant Name_Id := N + 601;\n-   Name_Separate_Suffix                : constant Name_Id := N + 602;\n-   Name_Source_Dirs                    : constant Name_Id := N + 603;\n-   Name_Source_Files                   : constant Name_Id := N + 604;\n-   Name_Source_List_File               : constant Name_Id := N + 605;\n-   Name_Spec                           : constant Name_Id := N + 606;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 607;\n-   Name_Specification                  : constant Name_Id := N + 608;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 609;\n-   Name_Specification_Suffix           : constant Name_Id := N + 610;\n-   Name_Switches                       : constant Name_Id := N + 611;\n+   Name_Binder                         : constant Name_Id := N + 565;\n+   Name_Body_Suffix                    : constant Name_Id := N + 566;\n+   Name_Builder                        : constant Name_Id := N + 567;\n+   Name_Compiler                       : constant Name_Id := N + 568;\n+   Name_Cross_Reference                : constant Name_Id := N + 569;\n+   Name_Default_Switches               : constant Name_Id := N + 570;\n+   Name_Exec_Dir                       : constant Name_Id := N + 571;\n+   Name_Executable                     : constant Name_Id := N + 572;\n+   Name_Executable_Suffix              : constant Name_Id := N + 573;\n+   Name_Extends                        : constant Name_Id := N + 574;\n+   Name_Finder                         : constant Name_Id := N + 575;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 576;\n+   Name_Gnatls                         : constant Name_Id := N + 577;\n+   Name_Gnatstub                       : constant Name_Id := N + 578;\n+   Name_Implementation                 : constant Name_Id := N + 579;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 580;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 581;\n+   Name_Languages                      : constant Name_Id := N + 582;\n+   Name_Library_Dir                    : constant Name_Id := N + 583;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 584;\n+   Name_Library_GCC                    : constant Name_Id := N + 585;\n+   Name_Library_Interface              : constant Name_Id := N + 586;\n+   Name_Library_Kind                   : constant Name_Id := N + 587;\n+   Name_Library_Name                   : constant Name_Id := N + 588;\n+   Name_Library_Options                : constant Name_Id := N + 589;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 590;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 591;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 592;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 593;\n+   Name_Library_Version                : constant Name_Id := N + 594;\n+   Name_Linker                         : constant Name_Id := N + 595;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 596;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 597;\n+   Name_Metrics                        : constant Name_Id := N + 598;\n+   Name_Naming                         : constant Name_Id := N + 599;\n+   Name_Object_Dir                     : constant Name_Id := N + 600;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 601;\n+   Name_Project                        : constant Name_Id := N + 602;\n+   Name_Separate_Suffix                : constant Name_Id := N + 603;\n+   Name_Source_Dirs                    : constant Name_Id := N + 604;\n+   Name_Source_Files                   : constant Name_Id := N + 605;\n+   Name_Source_List_File               : constant Name_Id := N + 606;\n+   Name_Spec                           : constant Name_Id := N + 607;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 608;\n+   Name_Specification                  : constant Name_Id := N + 609;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 610;\n+   Name_Specification_Suffix           : constant Name_Id := N + 611;\n+   Name_Switches                       : constant Name_Id := N + 612;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 612;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 613;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 612;\n+   Last_Predefined_Name                : constant Name_Id := N + 613;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;\n@@ -1178,6 +1179,7 @@ package Snames is\n       Pragma_Compile_Time_Warning,\n       Pragma_Component_Alignment,\n       Pragma_Convention_Identifier,\n+      Pragma_Detect_Blocking,\n       Pragma_Discard_Names,\n       Pragma_Elaboration_Checks,\n       Pragma_Eliminate,"}, {"sha": "d14d9279ed32dcae9ceef1ca36f6a5c0940eaf80", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 138, "deletions": 137, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -203,149 +203,150 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Compile_Time_Warning          4\n #define  Pragma_Component_Alignment           5\n #define  Pragma_Convention_Identifier         6\n-#define  Pragma_Discard_Names                 7\n-#define  Pragma_Elaboration_Checking          8\n-#define  Pragma_Eliminate                     9\n-#define  Pragma_Explicit_Overriding          10\n-#define  Pragma_Extend_System                11\n-#define  Pragma_Extensions_Allowed           12\n-#define  Pragma_External_Name_Casing         13\n-#define  Pragma_Float_Representation         14\n-#define  Pragma_Initialize_Scalars           15\n-#define  Pragma_Interrupt_State              16\n-#define  Pragma_License                      17\n-#define  Pragma_Locking_Policy               18\n-#define  Pragma_Long_Float                   19\n-#define  Pragma_No_Run_Time                  20\n-#define  Pragma_No_Strict_Aliasing           21\n-#define  Pragma_Normalize_Scalars            22\n-#define  Pragma_Polling                      23\n-#define  Pragma_Persistent_Data              24\n-#define  Pragma_Persistent_Object            25\n-#define  Pragma_Profile                      26\n-#define  Pragma_Profile_Warnings             27\n-#define  Pragma_Propagate_Exceptions         28\n-#define  Pragma_Queuing_Policy               29\n-#define  Pragma_Ravenscar                    30\n-#define  Pragma_Restricted_Run_Time          31\n-#define  Pragma_Restrictions                 32\n-#define  Pragma_Restriction_Warnings         33\n-#define  Pragma_Reviewable                   34\n-#define  Pragma_Source_File_Name             35\n-#define  Pragma_Source_File_Name_Project     36\n-#define  Pragma_Style_Checks                 37\n-#define  Pragma_Suppress                     38\n-#define  Pragma_Suppress_Exception_Locations 39\n-#define  Pragma_Task_Dispatching_Policy      40\n-#define  Pragma_Universal_Data               41\n-#define  Pragma_Unsuppress                   42\n-#define  Pragma_Use_VADS_Size                43\n-#define  Pragma_Validity_Checks              44\n-#define  Pragma_Warnings                     45\n+#define  Pragma_Detect_Blocking               7\n+#define  Pragma_Discard_Names                 8\n+#define  Pragma_Elaboration_Checking          9\n+#define  Pragma_Eliminate                    10\n+#define  Pragma_Explicit_Overriding          11\n+#define  Pragma_Extend_System                12\n+#define  Pragma_Extensions_Allowed           13\n+#define  Pragma_External_Name_Casing         14\n+#define  Pragma_Float_Representation         15\n+#define  Pragma_Initialize_Scalars           16\n+#define  Pragma_Interrupt_State              17\n+#define  Pragma_License                      18\n+#define  Pragma_Locking_Policy               19\n+#define  Pragma_Long_Float                   20\n+#define  Pragma_No_Run_Time                  21\n+#define  Pragma_No_Strict_Aliasing           22\n+#define  Pragma_Normalize_Scalars            23\n+#define  Pragma_Polling                      24\n+#define  Pragma_Persistent_Data              25\n+#define  Pragma_Persistent_Object            26\n+#define  Pragma_Profile                      27\n+#define  Pragma_Profile_Warnings             28\n+#define  Pragma_Propagate_Exceptions         29\n+#define  Pragma_Queuing_Policy               30\n+#define  Pragma_Ravenscar                    31\n+#define  Pragma_Restricted_Run_Time          32\n+#define  Pragma_Restrictions                 33\n+#define  Pragma_Restriction_Warnings         34\n+#define  Pragma_Reviewable                   35\n+#define  Pragma_Source_File_Name             36\n+#define  Pragma_Source_File_Name_Project     37\n+#define  Pragma_Style_Checks                 38\n+#define  Pragma_Suppress                     39\n+#define  Pragma_Suppress_Exception_Locations 40\n+#define  Pragma_Task_Dispatching_Policy      41\n+#define  Pragma_Universal_Data               42\n+#define  Pragma_Unsuppress                   43\n+#define  Pragma_Use_VADS_Size                44\n+#define  Pragma_Validity_Checks              45\n+#define  Pragma_Warnings                     46\n \n /* Remaining pragmas */\n \n-#define  Pragma_Abort_Defer                  46\n-#define  Pragma_All_Calls_Remote             47\n-#define  Pragma_Annotate                     48\n-#define  Pragma_Assert                       49\n-#define  Pragma_Asynchronous                 50\n-#define  Pragma_Atomic                       51\n-#define  Pragma_Atomic_Components            52\n-#define  Pragma_Attach_Handler               53\n-#define  Pragma_Comment                      54\n-#define  Pragma_Common_Object                55\n-#define  Pragma_Complex_Representation       56\n-#define  Pragma_Controlled                   57\n-#define  Pragma_Convention                   58\n-#define  Pragma_CPP_Class                    59\n-#define  Pragma_CPP_Constructor              60\n-#define  Pragma_CPP_Virtual                  61\n-#define  Pragma_CPP_Vtable                   62\n-#define  Pragma_Debug                        63\n-#define  Pragma_Elaborate                    64\n-#define  Pragma_Elaborate_All                65\n-#define  Pragma_Elaborate_Body               66\n-#define  Pragma_Export                       67\n-#define  Pragma_Export_Exception             68\n-#define  Pragma_Export_Function              69\n-#define  Pragma_Export_Object                70\n-#define  Pragma_Export_Procedure             71\n-#define  Pragma_Export_Value                 72\n-#define  Pragma_Export_Valued_Procedure      73\n-#define  Pragma_External                     74\n-#define  Pragma_Finalize_Storage_Only        75\n-#define  Pragma_Ident                        76\n-#define  Pragma_Import                       77\n-#define  Pragma_Import_Exception             78\n-#define  Pragma_Import_Function              79\n-#define  Pragma_Import_Object                80\n-#define  Pragma_Import_Procedure             81\n-#define  Pragma_Import_Valued_Procedure      82\n-#define  Pragma_Inline                       83\n-#define  Pragma_Inline_Always                84\n-#define  Pragma_Inline_Generic               85\n-#define  Pragma_Inspection_Point             86\n-#define  Pragma_Interface                    87\n-#define  Pragma_Interface_Name               88\n-#define  Pragma_Interrupt_Handler            89\n-#define  Pragma_Interrupt_Priority           90\n-#define  Pragma_Java_Constructor             91\n-#define  Pragma_Java_Interface               92\n-#define  Pragma_Keep_Names                   93\n-#define  Pragma_Link_With                    94\n-#define  Pragma_Linker_Alias                 95\n-#define  Pragma_Linker_Options               96\n-#define  Pragma_Linker_Section               97\n-#define  Pragma_List                         98\n-#define  Pragma_Machine_Attribute            99\n-#define  Pragma_Main                        100\n-#define  Pragma_Main_Storage                101\n-#define  Pragma_Memory_Size                 102\n-#define  Pragma_No_Return                   103\n-#define  Pragma_Obsolescent                 104\n-#define  Pragma_Optimize                    105\n-#define  Pragma_Optional_Overriding         106\n-#define  Pragma_Overriding                  107\n-#define  Pragma_Pack                        108\n-#define  Pragma_Page                        109\n-#define  Pragma_Passive                     110\n-#define  Pragma_Preelaborate                111\n-#define  Pragma_Priority                    112\n-#define  Pragma_Psect_Object                113\n-#define  Pragma_Pure                        114\n-#define  Pragma_Pure_Function               115\n-#define  Pragma_Remote_Call_Interface       116\n-#define  Pragma_Remote_Types                117\n-#define  Pragma_Share_Generic               118\n-#define  Pragma_Shared                      119\n-#define  Pragma_Shared_Passive              120\n-#define  Pragma_Source_Reference            121\n-#define  Pragma_Stream_Convert              122\n-#define  Pragma_Subtitle                    123\n-#define  Pragma_Suppress_All                124\n-#define  Pragma_Suppress_Debug_Info         125\n-#define  Pragma_Suppress_Initialization     126\n-#define  Pragma_System_Name                 127\n-#define  Pragma_Task_Info                   128\n-#define  Pragma_Task_Name                   129\n-#define  Pragma_Task_Storage                130\n-#define  Pragma_Thread_Body                 131\n-#define  Pragma_Time_Slice                  132\n-#define  Pragma_Title                       133\n-#define  Pragma_Unchecked_Union             134\n-#define  Pragma_Unimplemented_Unit          135\n-#define  Pragma_Unreferenced                136\n-#define  Pragma_Unreserve_All_Interrupts    137\n-#define  Pragma_Volatile                    138\n-#define  Pragma_Volatile_Components         139\n-#define  Pragma_Weak_External               140\n+#define  Pragma_Abort_Defer                  47\n+#define  Pragma_All_Calls_Remote             48\n+#define  Pragma_Annotate                     49\n+#define  Pragma_Assert                       50\n+#define  Pragma_Asynchronous                 51\n+#define  Pragma_Atomic                       52\n+#define  Pragma_Atomic_Components            53\n+#define  Pragma_Attach_Handler               54\n+#define  Pragma_Comment                      55\n+#define  Pragma_Common_Object                56\n+#define  Pragma_Complex_Representation       57\n+#define  Pragma_Controlled                   58\n+#define  Pragma_Convention                   59\n+#define  Pragma_CPP_Class                    60\n+#define  Pragma_CPP_Constructor              61\n+#define  Pragma_CPP_Virtual                  62\n+#define  Pragma_CPP_Vtable                   63\n+#define  Pragma_Debug                        64\n+#define  Pragma_Elaborate                    65\n+#define  Pragma_Elaborate_All                66\n+#define  Pragma_Elaborate_Body               67\n+#define  Pragma_Export                       68\n+#define  Pragma_Export_Exception             69\n+#define  Pragma_Export_Function              70\n+#define  Pragma_Export_Object                71\n+#define  Pragma_Export_Procedure             72\n+#define  Pragma_Export_Value                 73\n+#define  Pragma_Export_Valued_Procedure      74\n+#define  Pragma_External                     75\n+#define  Pragma_Finalize_Storage_Only        76\n+#define  Pragma_Ident                        77\n+#define  Pragma_Import                       78\n+#define  Pragma_Import_Exception             79\n+#define  Pragma_Import_Function              80\n+#define  Pragma_Import_Object                81\n+#define  Pragma_Import_Procedure             82\n+#define  Pragma_Import_Valued_Procedure      83\n+#define  Pragma_Inline                       84\n+#define  Pragma_Inline_Always                85\n+#define  Pragma_Inline_Generic               86\n+#define  Pragma_Inspection_Point             87\n+#define  Pragma_Interface                    88\n+#define  Pragma_Interface_Name               89\n+#define  Pragma_Interrupt_Handler            90\n+#define  Pragma_Interrupt_Priority           91\n+#define  Pragma_Java_Constructor             92\n+#define  Pragma_Java_Interface               93\n+#define  Pragma_Keep_Names                   94\n+#define  Pragma_Link_With                    95\n+#define  Pragma_Linker_Alias                 96\n+#define  Pragma_Linker_Options               97\n+#define  Pragma_Linker_Section               98\n+#define  Pragma_List                         99\n+#define  Pragma_Machine_Attribute           100\n+#define  Pragma_Main                        101\n+#define  Pragma_Main_Storage                102\n+#define  Pragma_Memory_Size                 103\n+#define  Pragma_No_Return                   104\n+#define  Pragma_Obsolescent                 105\n+#define  Pragma_Optimize                    106\n+#define  Pragma_Optional_Overriding         107\n+#define  Pragma_Overriding                  108\n+#define  Pragma_Pack                        109\n+#define  Pragma_Page                        110\n+#define  Pragma_Passive                     111\n+#define  Pragma_Preelaborate                112\n+#define  Pragma_Priority                    113\n+#define  Pragma_Psect_Object                114\n+#define  Pragma_Pure                        115\n+#define  Pragma_Pure_Function               116\n+#define  Pragma_Remote_Call_Interface       117\n+#define  Pragma_Remote_Types                118\n+#define  Pragma_Share_Generic               119\n+#define  Pragma_Shared                      120\n+#define  Pragma_Shared_Passive              121\n+#define  Pragma_Source_Reference            122\n+#define  Pragma_Stream_Convert              123\n+#define  Pragma_Subtitle                    124\n+#define  Pragma_Suppress_All                125\n+#define  Pragma_Suppress_Debug_Info         126\n+#define  Pragma_Suppress_Initialization     127\n+#define  Pragma_System_Name                 128\n+#define  Pragma_Task_Info                   129\n+#define  Pragma_Task_Name                   130\n+#define  Pragma_Task_Storage                131\n+#define  Pragma_Thread_Body                 132\n+#define  Pragma_Time_Slice                  133\n+#define  Pragma_Title                       134\n+#define  Pragma_Unchecked_Union             135\n+#define  Pragma_Unimplemented_Unit          136\n+#define  Pragma_Unreferenced                137\n+#define  Pragma_Unreserve_All_Interrupts    138\n+#define  Pragma_Volatile                    139\n+#define  Pragma_Volatile_Components         140\n+#define  Pragma_Weak_External               141\n \n /* The following are deliberately out of alphabetical order, see Snames */\n \n-#define  Pragma_AST_Entry                   141\n-#define  Pragma_Storage_Size                142\n-#define  Pragma_Storage_Unit                143\n+#define  Pragma_AST_Entry                   142\n+#define  Pragma_Storage_Size                143\n+#define  Pragma_Storage_Unit                144\n \n /* Define the numeric values for the conventions.  */\n "}, {"sha": "8c2aa58d08ebd15629420314ffeaa6cf86cb83eb", "filename": "gcc/ada/stylesw.adb", "status": "modified", "additions": 82, "deletions": 29, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fstylesw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fstylesw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -34,23 +34,24 @@ package body Stylesw is\n \n    procedure Reset_Style_Check_Options is\n    begin\n-      Style_Check_Indentation      := 0;\n-      Style_Check_Attribute_Casing := False;\n-      Style_Check_Blanks_At_End    := False;\n-      Style_Check_Comments         := False;\n-      Style_Check_End_Labels       := False;\n-      Style_Check_Form_Feeds       := False;\n-      Style_Check_Horizontal_Tabs  := False;\n-      Style_Check_If_Then_Layout   := False;\n-      Style_Check_Keyword_Casing   := False;\n-      Style_Check_Layout           := False;\n-      Style_Check_Max_Line_Length  := False;\n-      Style_Check_Pragma_Casing    := False;\n-      Style_Check_References       := False;\n-      Style_Check_Specs            := False;\n-      Style_Check_Standard         := False;\n-      Style_Check_Subprogram_Order := False;\n-      Style_Check_Tokens           := False;\n+      Style_Check_Indentation       := 0;\n+      Style_Check_Attribute_Casing  := False;\n+      Style_Check_Blanks_At_End     := False;\n+      Style_Check_Comments          := False;\n+      Style_Check_End_Labels        := False;\n+      Style_Check_Form_Feeds        := False;\n+      Style_Check_Horizontal_Tabs   := False;\n+      Style_Check_If_Then_Layout    := False;\n+      Style_Check_Keyword_Casing    := False;\n+      Style_Check_Layout            := False;\n+      Style_Check_Max_Line_Length   := False;\n+      Style_Check_Max_Nesting_Level := False;\n+      Style_Check_Pragma_Casing     := False;\n+      Style_Check_References        := False;\n+      Style_Check_Specs             := False;\n+      Style_Check_Standard          := False;\n+      Style_Check_Subprogram_Order  := False;\n+      Style_Check_Tokens            := False;\n    end Reset_Style_Check_Options;\n \n    ------------------------------\n@@ -59,11 +60,17 @@ package body Stylesw is\n \n    procedure Save_Style_Check_Options (Options : out Style_Check_Options) is\n       P : Natural := 0;\n-      J : Natural;\n \n       procedure Add (C : Character; S : Boolean);\n       --  Add given character C to string if switch S is true\n \n+      procedure Add_Nat (N : Nat);\n+      --  Add given natural number to string\n+\n+      ---------\n+      -- Add --\n+      ---------\n+\n       procedure Add (C : Character; S : Boolean) is\n       begin\n          if S then\n@@ -72,6 +79,20 @@ package body Stylesw is\n          end if;\n       end Add;\n \n+      -------------\n+      -- Add_Nat --\n+      -------------\n+\n+      procedure Add_Nat (N : Nat) is\n+      begin\n+         if N > 9 then\n+            Add_Nat (N / 10);\n+         end if;\n+\n+         P := P + 1;\n+         Options (P) := Character'Val (Character'Pos ('0') + N mod 10);\n+      end Add_Nat;\n+\n    --  Start of processing for Save_Style_Check_Options\n \n    begin\n@@ -91,7 +112,6 @@ package body Stylesw is\n       Add ('i', Style_Check_If_Then_Layout);\n       Add ('k', Style_Check_Keyword_Casing);\n       Add ('l', Style_Check_Layout);\n-      Add ('m', Style_Check_Max_Line_Length);\n       Add ('n', Style_Check_Standard);\n       Add ('o', Style_Check_Subprogram_Order);\n       Add ('p', Style_Check_Pragma_Casing);\n@@ -100,19 +120,23 @@ package body Stylesw is\n       Add ('t', Style_Check_Tokens);\n \n       if Style_Check_Max_Line_Length then\n-         P := Options'Last;\n-         J := Natural (Style_Max_Line_Length);\n-\n-         loop\n-            Options (P) := Character'Val (J mod 10 + Character'Pos ('0'));\n-            P := P - 1;\n-            J := J / 10;\n-            exit when J = 0;\n-         end loop;\n-\n+         P := P + 1;\n          Options (P) := 'M';\n+         Add_Nat (Style_Max_Line_Length);\n       end if;\n \n+      if Style_Check_Max_Nesting_Level then\n+         P := P + 1;\n+         Options (P) := 'L';\n+         Add_Nat (Style_Max_Nesting_Level);\n+      end if;\n+\n+      pragma Assert (P <= Options'Last);\n+\n+      while P < Options'Last loop\n+         P := P + 1;\n+         Options (P) := ' ';\n+      end loop;\n    end Save_Style_Check_Options;\n \n    -------------------------------------\n@@ -186,6 +210,35 @@ package body Stylesw is\n             when 'l' =>\n                Style_Check_Layout           := True;\n \n+            when 'L' =>\n+               Style_Max_Nesting_Level := 0;\n+\n+               if J > Options'Last\n+                 or else Options (J) not in '0' .. '9'\n+               then\n+                  OK := False;\n+                  Err_Col := J;\n+                  return;\n+               end if;\n+\n+               loop\n+                  Style_Max_Nesting_Level :=\n+                    Style_Max_Nesting_Level * 10 +\n+                      Character'Pos (Options (J)) - Character'Pos ('0');\n+\n+                  if Style_Max_Nesting_Level > 999 then\n+                     OK := False;\n+                     Err_Col := J;\n+                     return;\n+                  end if;\n+\n+                  J := J + 1;\n+                  exit when J > Options'Last\n+                    or else Options (J) not in '0' .. '9';\n+               end loop;\n+\n+               Style_Check_Max_Nesting_Level := Style_Max_Nesting_Level /= 0;\n+\n             when 'm' =>\n                Style_Check_Max_Line_Length  := True;\n                Style_Max_Line_Length        := 79;"}, {"sha": "435b31b038a9d6bcf3ca801f1f40e02fe47e1af2", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -140,6 +140,11 @@ package Stylesw is\n    --  If it is True, it activates checking for a maximum line length of\n    --  Style_Max_Line_Length characters.\n \n+   Style_Check_Max_Nesting_Level : Boolean := False;\n+   --  This can be set True by using -gnatyLnnn with a value other than\n+   --  zero (a value of zero resets it to False). If True, it activates\n+   --  checking the maximum nesting level against Style_Max_Nesting_Level.\n+\n    Style_Check_Pragma_Casing : Boolean := False;\n    --  This can be set True by using the -gnatg or -gnatyp switches. If\n    --  it is True, then pragma names must use mixed case.\n@@ -218,7 +223,13 @@ package Stylesw is\n \n    Style_Max_Line_Length : Int := 0;\n    --  Value used to check maximum line length. Gets reset as a result of\n-   --  use of -gnatym or -gnatyM switches (or by use of -gnatg).\n+   --  use of -gnatym or -gnatyMnnn switches (or by use of -gnatg). This\n+   --  value is only read if Style_Check_Max_Line_Length is True.\n+\n+   Style_Max_Nesting_Level : Int := 0;\n+   --  Value used to check maximum nesting level. Gets reset as a result\n+   --  of use of the -gnatyLnnn switch. This value is only read if\n+   --  Style_Check_Max_Nesting_Level is True.\n \n    -----------------\n    -- Subprograms --\n@@ -250,7 +261,7 @@ package Stylesw is\n    procedure Reset_Style_Check_Options;\n    --  Sets all style check options to off\n \n-   subtype Style_Check_Options is String (1 .. 32);\n+   subtype Style_Check_Options is String (1 .. 64);\n    --  Long enough string to hold all options from Save call below\n \n    procedure Save_Style_Check_Options (Options : out Style_Check_Options);"}, {"sha": "391347a0c227d2f618379b8de6622c21e97fd1ec", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -446,6 +446,11 @@ package body Switch.C is\n \n                   return;\n \n+                  when 'z' =>\n+                     Store_Switch := False;\n+                     Disable_Switch_Storing;\n+                     Ptr := Ptr + 1;\n+\n                   --  All other -gnate? switches are unassigned\n \n                   when others =>"}, {"sha": "c1c5c51a0f2904b2cb2fb623cd7dfb1d737af4b8", "filename": "gcc/ada/switch.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fswitch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fswitch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,15 +32,14 @@ package body Switch is\n \n    function Is_Front_End_Switch (Switch_Chars : String) return Boolean is\n       Ptr : constant Positive := Switch_Chars'First;\n-\n    begin\n       return Is_Switch (Switch_Chars)\n         and then\n-        (Switch_Chars (Ptr + 1) = 'I'\n-         or else (Switch_Chars'Length >= 5\n-                  and then Switch_Chars (Ptr + 1 .. Ptr + 4) = \"gnat\")\n-         or else (Switch_Chars'Length >= 5\n-                  and then Switch_Chars (Ptr + 1 .. Ptr + 4) = \"fRTS\"));\n+          (Switch_Chars (Ptr + 1) = 'I'\n+            or else (Switch_Chars'Length >= 5\n+                      and then Switch_Chars (Ptr + 1 .. Ptr + 4) = \"gnat\")\n+            or else (Switch_Chars'Length >= 5\n+                      and then Switch_Chars (Ptr + 2 .. Ptr + 4) = \"RTS\"));\n    end Is_Front_End_Switch;\n \n    ---------------\n@@ -90,8 +89,8 @@ package body Switch is\n      (Switch_Chars : String;\n       Max          : Integer;\n       Ptr          : in out Integer;\n-      Result       : out Pos) is\n-\n+      Result       : out Pos)\n+   is\n       Temp : Nat;\n \n    begin"}, {"sha": "7be260b9738f986fb4ed0403ca445b67bb2539d0", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -374,6 +374,13 @@ package body Targparm is\n             Fatal := True;\n             Set_Standard_Output;\n \n+         --  Test for pragma Detect_Blocking;\n+\n+         elsif System_Text (P .. P + 22) = \"pragma Detect_Blocking;\" then\n+            P := P + 23;\n+            Opt.Detect_Blocking := True;\n+            goto Line_Loop_Continue;\n+\n          --  Discard_Names\n \n          elsif System_Text (P .. P + 20) = \"pragma Discard_Names;\" then"}, {"sha": "d7a25148e398d8feda3f0b595df566950fbf68b5", "filename": "gcc/ada/targparm.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftargparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftargparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -101,6 +101,9 @@ package Targparm is\n    --  If a pragma Polling (On) appears, then the flag Opt.Polling_Required\n    --  is set to True.\n \n+   --  If a pragma Detect_Blocking appears, then the flag Opt.Detect_Blocking\n+   --  is set to True.\n+\n    --  if a pragma Suppress_Exception_Locations appears, then the flag\n    --  Opt.Exception_Locations_Suppressed is set to True.\n "}, {"sha": "9c621929d1a37ef681ceb0e935ff9ac99054f410", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -60,17 +60,19 @@\n \n extern int __gnat_backtrace (void **, int, void *, void *, int);\n \n-/* The point is to provide an implementation of the __gnat_bactrace function\n-   above, called by the default implementation of the System.Traceback\n-   package.\n+/* The point is to provide an implementation of the __gnat_backtrace function\n+   above, called by the default implementation of the System.Traceback package.\n \n    We first have a series of target specific implementations, each included\n    from a separate C file for readability purposes.\n \n-   Then comes a somewhat generic implementation based on a set of macro and\n-   structure definitions which may be tailored on a per target basis. The\n-   presence of a definition for one of these macros (PC_ADJUST) controls\n-   wether or not the generic implementation is included.\n+   Then come two flavors of a generic implementation: one relying on static\n+   assumptions about the frame layout, and the other one using the GCC EH\n+   infrastructure.  The former uses a whole set of macros and structures which\n+   may be tailored on a per target basis, and is activated as soon as\n+   USE_GENERIC_UNWINDER is defined.  The latter uses a small subset of the\n+   macro definitions and is activated when USE_GCC_UNWINDER is defined. It is\n+   only available post GCC 3.3.\n \n    Finally, there is a default dummy implementation, necessary to make the\n    linker happy on platforms where the feature is not supported, but where the\n@@ -192,6 +194,9 @@ extern void (*Unlock_Task) (void);\n /*------------------------------ PPC AIX -------------------------------*/\n \n #if defined (_AIX)\n+\n+#define USE_GENERIC_UNWINDER\n+\n struct layout\n {\n   struct layout *next;\n@@ -218,6 +223,9 @@ struct layout\n /*---------------------------- PPC VxWorks------------------------------*/\n \n #elif defined (_ARCH_PPC) && defined (__vxworks)\n+\n+#define USE_GENERIC_UNWINDER\n+\n struct layout\n {\n   struct layout *next;\n@@ -238,6 +246,8 @@ struct layout\n \n #elif defined (sun) && defined (sparc)\n \n+#define USE_GENERIC_UNWINDER\n+\n /* These definitions are inspired from the Appendix D (Software\n    Considerations) of the SPARC V8 architecture manual.  */\n \n@@ -267,6 +277,9 @@ struct layout\n /*------------------------------- x86 ----------------------------------*/\n \n #elif defined (i386)\n+\n+#define USE_GENERIC_UNWINDER\n+\n struct layout\n {\n   struct layout *next;\n@@ -310,13 +323,39 @@ extern unsigned int _image_base__;\n     || ((*((ptr) - 1) & 0xff) == 0xff) \\\n     || (((*(ptr) & 0xd0ff) == 0xd0ff)))\n \n+/*------------------------------- mips-irix -------------------------------*/\n+\n+#elif defined (__mips) && defined (__sgi)\n+\n+#define USE_GCC_UNWINDER\n+#define PC_ADJUST -8\n+\n #endif\n \n-/*---------------------------------------*\n- *-- The generic implementation per se --*\n- *---------------------------------------*/\n \n-#if defined (PC_ADJUST)\n+/*---------------------------------------------------------------------*\n+ *--      The post GCC 3.3 infrastructure based implementation       --*\n+ *---------------------------------------------------------------------*/\n+\n+#if defined (USE_GCC_UNWINDER) && (__GNUC__ * 10 + __GNUC_MINOR__ > 33)\n+\n+/* Conditioning the inclusion on the GCC version is useful to avoid bootstrap\n+   path problems, since the included file refers to post 3.3 functions in\n+   libgcc, and the stage1 compiler is unlikely to be linked against a post 3.3\n+   library.  It actually disables the support for backtraces in this compiler\n+   for targets defining USE_GCC_UNWINDER, which is OK since we don't use the\n+   traceback capablity in the compiler anyway.\n+\n+   The condition is expressed the way above because we cannot reliably rely on\n+   any other macro from the base compiler when compiling stage1.  */\n+\n+#include \"tb-gcc.c\"\n+\n+/*------------------------------------------------------------------*\n+ *-- The generic implementation based on frame layout assumptions --*\n+ *------------------------------------------------------------------*/\n+\n+#elif defined (USE_GENERIC_UNWINDER)\n \n #ifndef CURRENT_STACK_FRAME\n # define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })\n@@ -398,7 +437,9 @@ __gnat_backtrace (void **array,\n }\n \n #else\n-/* No target specific implementation and PC_ADJUST not defined.  */\n+\n+/* No target specific implementation and neither USE_GCC_UNWINDER not\n+   USE_GCC_UNWINDER defined.  */\n \n /*------------------------------*\n  *-- The dummy implementation --*"}, {"sha": "deda649effb3c4ef43a578213eb55b1ef9559da6", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -436,6 +436,7 @@ begin\n    Write_Line (\"        i    check if-then layout\");\n    Write_Line (\"        k    check casing rules for keywords\");\n    Write_Line (\"        l    check reference manual layout\");\n+   Write_Line (\"        Lnnn check max nest level < nnn\");\n    Write_Line (\"        m    check line length <= 79 characters\");\n    Write_Line (\"        n    check casing of package Standard identifiers\");\n    Write_Line (\"        Mnnn check line length <= nnn characters\");"}, {"sha": "bf236aebca765bb710abc8df162495d68c406127", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 124, "deletions": 4, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -1505,6 +1505,15 @@ package VMS_Data is\n    --      HIGH        A great number of messages are output, most of them not\n    --                  being useful for the user.\n \n+   S_GCC_Nesting  : aliased constant S := \"/MAX_NESTING=#\"                &\n+                                             \"-gnatyL#\";\n+   --        /MAX_NESTING=nnn\n+   --\n+   --   Set maximum level of nesting of constructs (including subprograms,\n+   --   loops, blocks, packages, and conditionals).\n+   --   The level of nesting must not exceed the given value nnn.\n+   --   A value of zero disable this style check (not enabled by default).\n+\n    S_GCC_Noadc   : aliased constant S := \"/NO_GNAT_ADC \"                   &\n                                              \"-gnatA\";\n    --        /NO_GNAT_ADC\n@@ -2830,6 +2839,7 @@ package VMS_Data is\n       S_GCC_List    'Access,\n       S_GCC_Mapping 'Access,\n       S_GCC_Mess    'Access,\n+      S_GCC_Nesting 'Access,\n       S_GCC_Noadc   'Access,\n       S_GCC_Noload  'Access,\n       S_GCC_Nostinc 'Access,\n@@ -3432,6 +3442,13 @@ package VMS_Data is\n    --   Example:\n    --      /EXTERNAL_REFERENCE=\"DEBUG=TRUE\"\n \n+   S_List_Files   : aliased constant S := \"/FILES=@\"                       &\n+                                            \"-files=@\";\n+   --        /FILES=filename\n+   --\n+   --   Take as arguments the files that are listed in the specified\n+   --   text file.\n+\n    S_List_Mess    : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"        &\n                                             \"DEFAULT \"                     &\n                                                \"-vP0 \"                     &\n@@ -3522,6 +3539,7 @@ package VMS_Data is\n       S_List_Current 'Access,\n       S_List_Depend  'Access,\n       S_List_Ext     'Access,\n+      S_List_Files   'Access,\n       S_List_Mess    'Access,\n       S_List_Nostinc 'Access,\n       S_List_Object  'Access,\n@@ -4042,6 +4060,15 @@ package VMS_Data is\n    S_Metric_Debug    : aliased constant S := \"/DEBUG_OUTPUT \"               &\n                                              \"-dv\";\n    --      /DEBUG_OUTPUT\n+   --\n+   --   Generate the debug information\n+\n+   S_Metric_Direct   : aliased constant S := \"/DIRECTORY=@\"                 &\n+                                             \"-d=@\";\n+   --      /DIRECTORY=pathname\n+   --\n+   --   Put the files with detailed metric information into the specified\n+   --   directory\n \n    S_Metric_Element : aliased constant S := \"/ELEMENT_METRICS=\"             &\n                                              \"ALL \"                         &\n@@ -4064,6 +4091,24 @@ package VMS_Data is\n                                              \"PROGRAM_NESTING_MAX \"         &\n                                               \"-enu\";\n    --       /ELEMENT_METRICS=(option, option ...)\n+   --\n+   --   Specifies the element metrics to be computed (if not set, all the\n+   --   element metrics are set on, otherwise only specified metrics are\n+   --   computed and reported)\n+   --\n+   --   option may be one of the following:\n+   --\n+   --     ALL (D)               All the element metrics are computed\n+   --     DECLARATION_TOTAL     Compute the total number of declarations\n+   --     STATEMENT_TOTAL       Compute the total number of statements\n+   --     LOOP_NESTING_MAX      Compute the maximal loop nesting level\n+   --     INT_SUBPROGRAMS       Compute the number of interface subprograms\n+   --     SUBPROGRAMS_ALL       Compute the number of all the subprograms\n+   --     INT_TYPES             Compute the number of interface types\n+   --     TYPES_ALL             Compute the number of all the types\n+   --     PROGRAM_NESTING_MAX   Compute the maximal program unit nesting level\n+   --\n+   --   All combinations of element metrics options are allowed.\n \n    S_Metric_Ext     : aliased constant S := \"/EXTERNAL_REFERENCE=\" & '\"'    &\n                                              \"-X\" & '\"';\n@@ -4075,6 +4120,13 @@ package VMS_Data is\n    --   Example:\n    --      /EXTERNAL_REFERENCE=\"DEBUG=TRUE\"\n \n+   S_Metric_Files   : aliased constant S := \"/FILES=@\"                 &\n+                                             \"-files=@\";\n+   --      /FILES=filename\n+   --\n+   --   Take as arguments the files that are listed in the specified\n+   --   text file.\n+\n    S_Metric_Format  : aliased constant S := \"/FORMAT_OUTPUT=\"               &\n                                              \"DEFAULT \"                     &\n                                               \"!-x,!-nt,!-sfn \"             &\n@@ -4085,10 +4137,22 @@ package VMS_Data is\n                                              \"SHORT_SOURCE_FILE_NAME \"      &\n                                               \"-sfn\";\n    --       /FORMAT_OUTPUT=(option, option ...)\n+   --\n+   --   Specifies the details of the tool output\n+   --\n+   --   option may be one of the following:\n+   --\n+   --     DEFAULT (D)             Generate the text output only, use full\n+   --                             argument source names in global information\n+   --     XML                     Generate the output in XML format\n+   --     NO_TEXT                 Do not generate the text output (implies XML)\n+   --     SHORT_SOURCE_FILE_NAME  Use short argument source names in output\n \n    S_Metric_Globout : aliased constant S := \"/GLOBAL_OUTPUT=@\"              &\n                                              \"-og@\";\n    --        /GLOBAL_OUTPUT=filename\n+   --\n+   --   Put the textual global metric information into the specified file\n \n    S_Metric_Line     : aliased constant S := \"/LINE_METRICS=\"               &\n                                                 \"ALL \"                      &\n@@ -4106,6 +4170,22 @@ package VMS_Data is\n                                                  \"-lb \";\n    --      /LINE_METRICS=(option, option ...)\n \n+   --   Specifies the line metrics to be computed (if not set, all the line\n+   --   metrics are set on, otherwise only specified metrics are computed and\n+   --   reported)\n+   --\n+   --   option may be one of the following:\n+   --\n+   --     ALL (D)              All the line metrics are computed\n+   --     LINES_ALL            All lines are computed\n+   --     CODE_LINES           Lines with Ada code are computed\n+   --     COMENT_LINES         All comment lines are computed\n+   --     MIXED_CODE_COMMENTS  All lines containing both code and comment are\n+   --                          computed\n+   --     BLANK_LINES          Blank lines are computed\n+   --\n+   --   All combinations of line metrics options are allowed.\n+\n    S_Metric_Mess    : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"       &\n                                              \"DEFAULT \"                     &\n                                                 \"-vP0 \"                     &\n@@ -4135,15 +4215,25 @@ package VMS_Data is\n \n    S_Metric_Quiet    : aliased constant S := \"/QUIET \"                      &\n                                              \"-q\";\n-   --      /QUIET\n+   --        /NOQUIET (D)\n+   --        /QUIET\n+   --\n+   --   Quiet mode: by default GNAT METRIC outputs to the standard error stream\n+   --   the number of program units left to be processed. This option turns\n+   --   this trace off.\n \n    S_Metric_Search  : aliased constant S := \"/SEARCH=*\"                     &\n                                              \"-I*\";\n-   --        /SEARCH=(directory[,...])\n+   --        /SEARCH=(directory, ...)\n+   --\n+   --   When looking for source files also look in the specified directories.\n \n    S_Metric_Suffix  : aliased constant S := \"/SUFFIX_DETAILS=\" & '\"'        &\n                                              \"-o\" & '\"';\n    --        /SUFFIX_DETAILS=suffix\n+   --\n+   --   Use the given suffix as the suffix for the name of the file to place\n+   --   the detailed metrics into.\n \n    S_Metric_Suppress : aliased constant S :=  \"/SUPPRESS=\"                  &\n                                                \"NOTHING \"                   &\n@@ -4160,21 +4250,43 @@ package VMS_Data is\n                                                \"LOCAL_DETAILS \"             &\n                                                 \"-nolocal \";\n    --      /SUPPRESS=(option, option ...)\n+   --\n+   --   Specifies the metric that should not be computed\n+   --\n+   --   option may be one of the following:\n+   --\n+   --     NOTHING (D)             Do not suppress computation of any metric\n+   --     CYCLOMATIC_COMPLEXITY   Do not compute the Cyclomatic Complexity\n+   --     ESSENTIAL_COMPLEXITY    Do not compute the Essential Complexity\n+   --     MAXIMAL_LOOP_NESTING    Do not compute the maximal loop nesting\n+   --     EXITS_AS_GOTOS          Do not count EXIT statements as GOTOs when\n+   --                             computing the  Essential Complexity\n+   --     LOCAL_DETAILS           Do not compute the detailed metrics for local\n+   --                             program units\n+   --\n+   --   All combinations of options are allowed.\n \n    S_Metric_Verbose  : aliased constant S := \"/VERBOSE \"                    &\n                                              \"-v\";\n-   --      /VERBOSE\n+   --        /NOVERBOSE (D)\n+   --        /VERBOSE\n+   --\n+   --   Verbose mode.\n \n    S_Metric_XMLout  : aliased constant S := \"/XML_OUTPUT=@\"                 &\n                                              \"-ox@\";\n    --        /XML_OUTPUT=filename\n+   --\n+   --   Place the XML output into the specified file\n \n    Metric_Switches : aliased constant Switches :=\n      (S_Metric_Config   'Access,\n       S_Metric_Current  'Access,\n       S_Metric_Debug    'Access,\n+      S_Metric_Direct   'Access,\n       S_Metric_Element  'Access,\n       S_Metric_Ext      'Access,\n+      S_Metric_Files    'Access,\n       S_Metric_Format   'Access,\n       S_Metric_Globout  'Access,\n       S_Metric_Line     'Access,\n@@ -4434,7 +4546,7 @@ package VMS_Data is\n    --   Set the comment layout. By default, comments use the GNAT style\n    --   comment line indentation.\n    --\n-   --   layout-option is be one of the following:\n+   --   layout-option may be one of the following:\n    --\n    --     UNTOUCHED\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd All the comments remain unchanged\n    --     DEFAULT (D)         GNAT style comment line indentation\n@@ -4577,6 +4689,13 @@ package VMS_Data is\n    --   used in the default dictionary file, are defined in the GNAT User's\n    --   Guide.\n \n+   S_Pretty_Files     : aliased constant S := \"/FILES=@\"                   &\n+                                                 \"-files=@\";\n+   --      /FILES=filename\n+   --\n+   --   Take as arguments the files that are listed in the specified\n+   --   text file.\n+\n    S_Pretty_Forced    : aliased constant S := \"/FORCED_OUTPUT=@\"           &\n                                                  \"-of@\";\n    --        /FORCED_OUTPUT=file\n@@ -4799,6 +4918,7 @@ package VMS_Data is\n       S_Pretty_Ext       'Access,\n       S_Pretty_Current   'Access,\n       S_Pretty_Dico      'Access,\n+      S_Pretty_Files     'Access,\n       S_Pretty_Forced    'Access,\n       S_Pretty_Formfeed  'Access,\n       S_Pretty_Indent    'Access,"}, {"sha": "2e026d101630de040b9b976d68bab9c0d9c0038d", "filename": "gcc/ada/xtreeprs.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fxtreeprs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da2c8ac77a61f9149fcbf3da36f7656aff96a4c/gcc%2Fada%2Fxtreeprs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxtreeprs.adb?ref=0da2c8ac77a61f9149fcbf3da36f7656aff96a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -303,7 +303,7 @@ begin\n \n       loop\n          Sp := 79 - 4 - Length (Prefix);\n-         exit when (Size (S) <= Sp);\n+         exit when Size (S) <= Sp;\n          Match (S, Chop_SP, \"\");\n          Put_Line (OutS, Prefix & '\"' & S1 & \"\"\" &\");\n          Prefix := V (\"         \");"}]}