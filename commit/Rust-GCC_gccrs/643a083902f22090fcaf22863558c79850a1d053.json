{"sha": "643a083902f22090fcaf22863558c79850a1d053", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQzYTA4MzkwMmYyMjA5MGZjYWYyMjg2MzU1OGM3OTg1MGExZDA1Mw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-06-16T08:36:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:36:48Z"}, "message": "exp_aggr.adb (Aggr_Size_OK): An array with no components can always be expanded in place.\n\n2005-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Aggr_Size_OK): An array with no components can always\n\tbe expanded in place. The size computation does not require a\n\tsubtraction, which would raise an exception on a compiler built with\n\tassertions when the upper bound is Integer'first.\n\t(Flatten): For an array of composite components, take into account the\n\tsize of the components to determine whether it is safe to expand the\n\tarray into a purely positional representation.\n\nFrom-SVN: r101031", "tree": {"sha": "0418da4d08536fc0e807240bc6e514c2d4e5d889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0418da4d08536fc0e807240bc6e514c2d4e5d889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/643a083902f22090fcaf22863558c79850a1d053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643a083902f22090fcaf22863558c79850a1d053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643a083902f22090fcaf22863558c79850a1d053", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643a083902f22090fcaf22863558c79850a1d053/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2aab5fd53b1e58ff46df944161645943fb1bbe5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aab5fd53b1e58ff46df944161645943fb1bbe5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aab5fd53b1e58ff46df944161645943fb1bbe5c"}], "stats": {"total": 201, "additions": 161, "deletions": 40}, "files": [{"sha": "c5286b023ab9d165d65ccba8a7b226b7032bf1b5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 161, "deletions": 40, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643a083902f22090fcaf22863558c79850a1d053/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643a083902f22090fcaf22863558c79850a1d053/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=643a083902f22090fcaf22863558c79850a1d053", "patch": "@@ -158,6 +158,13 @@ package body Exp_Aggr is\n    -- Local Subprograms for Array Aggregate Expansion --\n    -----------------------------------------------------\n \n+   function Aggr_Size_OK (Typ : Entity_Id) return Boolean;\n+   --  Very large static aggregates present problems to the back-end, and\n+   --  are transformed into assignments and loops. This function verifies\n+   --  that the total number of components of an aggregate is acceptable\n+   --  for transformation into a purely positional static form. It is called\n+   --  prior to calling Flatten.\n+\n    procedure Convert_Array_Aggr_In_Allocator\n      (Decl   : Node_Id;\n       Aggr   : Node_Id;\n@@ -269,6 +276,152 @@ package body Exp_Aggr is\n    --  the assignment can be done in place even if bounds are not static,\n    --  by converting it into a loop over the discrete range of the slice.\n \n+   ------------------\n+   -- Aggr_Size_OK --\n+   ------------------\n+\n+   function Aggr_Size_OK (Typ : Entity_Id) return Boolean is\n+      Lo   : Node_Id;\n+      Hi   : Node_Id;\n+      Indx : Node_Id;\n+      Siz  : Int;\n+      Lov  : Uint;\n+      Hiv  : Uint;\n+\n+      --  The following constant determines the maximum size of an\n+      --  aggregate produced by converting named to positional\n+      --  notation (e.g. from others clauses). This avoids running\n+      --  away with attempts to convert huge aggregates, which hit\n+      --  memory limits in the backend.\n+\n+      --  The normal limit is 5000, but we increase this limit to\n+      --  2**24 (about 16 million) if Restrictions (No_Elaboration_Code)\n+      --  or Restrictions (No_Implicit_Loops) is specified, since in\n+      --  either case, we are at risk of declaring the program illegal\n+      --  because of this limit.\n+\n+      Max_Aggr_Size : constant Nat :=\n+                        5000 + (2 ** 24 - 5000) *\n+                          Boolean'Pos\n+                            (Restriction_Active (No_Elaboration_Code)\n+                               or else\n+                             Restriction_Active (No_Implicit_Loops));\n+\n+      function Component_Count (T : Entity_Id) return Int;\n+      --  The limit is applied to the total number of components that the\n+      --  aggregate will have, which is the number of static expressions\n+      --  that will appear in the flattened array. This requires a recursive\n+      --  computation of the the number of scalar components of the structure.\n+\n+      ---------------------\n+      -- Component_Count --\n+      ---------------------\n+\n+      function Component_Count (T : Entity_Id) return Int is\n+         Res  : Int := 0;\n+         Comp : Entity_Id;\n+\n+      begin\n+         if Is_Scalar_Type (T) then\n+            return 1;\n+\n+         elsif Is_Record_Type (T) then\n+            Comp := First_Component (T);\n+            while Present (Comp) loop\n+               Res := Res + Component_Count (Etype (Comp));\n+               Next_Component (Comp);\n+            end loop;\n+\n+            return Res;\n+\n+         elsif Is_Array_Type (T) then\n+            declare\n+               Lo : constant Node_Id :=\n+                      Type_Low_Bound (Etype (First_Index (T)));\n+               Hi : constant Node_Id :=\n+                      Type_High_Bound (Etype (First_Index (T)));\n+\n+               Siz  : constant Int := Component_Count (Component_Type (T));\n+\n+            begin\n+               if not Compile_Time_Known_Value (Lo)\n+                 or else not Compile_Time_Known_Value (Hi)\n+               then\n+                  return 0;\n+               else\n+                  return\n+                    Siz * UI_To_Int (Expr_Value (Hi) - Expr_Value (Lo) + 1);\n+               end if;\n+            end;\n+\n+         else\n+            --  Can only be a null for an access type\n+\n+            return 1;\n+         end if;\n+      end Component_Count;\n+\n+   --  Start of processing for Aggr_Size_OK\n+\n+   begin\n+      Siz  := Component_Count (Component_Type (Typ));\n+      Indx := First_Index (Typ);\n+\n+      while Present (Indx) loop\n+         Lo  := Type_Low_Bound (Etype (Indx));\n+         Hi  := Type_High_Bound (Etype (Indx));\n+\n+         --  Bounds need to be known at compile time\n+\n+         if not Compile_Time_Known_Value (Lo)\n+           or else not Compile_Time_Known_Value (Hi)\n+         then\n+            return False;\n+         end if;\n+\n+         Lov := Expr_Value (Lo);\n+         Hiv := Expr_Value (Hi);\n+\n+         --  A flat array is always safe\n+\n+         if Hiv < Lov then\n+            return True;\n+         end if;\n+\n+         declare\n+            Rng : constant Uint := Hiv - Lov + 1;\n+\n+         begin\n+            --  Check if size is too large\n+\n+            if not UI_Is_In_Int_Range (Rng) then\n+               return False;\n+            end if;\n+\n+            Siz := Siz * UI_To_Int (Rng);\n+         end;\n+\n+         if Siz <= 0\n+           or else Siz > Max_Aggr_Size\n+         then\n+            return False;\n+         end if;\n+\n+         --  Bounds must be in integer range, for later array construction\n+\n+         if not UI_Is_In_Int_Range (Lov)\n+             or else\n+            not UI_Is_In_Int_Range (Hiv)\n+         then\n+            return False;\n+         end if;\n+\n+         Next_Index (Indx);\n+      end loop;\n+\n+      return True;\n+   end Aggr_Size_OK;\n+\n    ---------------------------------\n    -- Backend_Processing_Possible --\n    ---------------------------------\n@@ -2680,7 +2833,9 @@ package body Exp_Aggr is\n         (N   : Node_Id;\n          Ix  : Node_Id;\n          Ixb : Node_Id) return Boolean;\n-      --  Convert the aggregate into a purely positional form if possible\n+      --  Convert the aggregate into a purely positional form if possible.\n+      --  On entry the bounds of all dimensions are known to be static,\n+      --  and the total number of components is safe enough to expand.\n \n       function Is_Flat (N : Node_Id; Dims : Int) return Boolean;\n       --  Return True iff the array N is flat (which is not rivial\n@@ -2702,39 +2857,12 @@ package body Exp_Aggr is\n          Lov : Uint;\n          Hiv : Uint;\n \n-         --  The following constant determines the maximum size of an\n-         --  aggregate produced by converting named to positional\n-         --  notation (e.g. from others clauses). This avoids running\n-         --  away with attempts to convert huge aggregates.\n-\n-         --  The normal limit is 5000, but we increase this limit to\n-         --  2**24 (about 16 million) if Restrictions (No_Elaboration_Code)\n-         --  or Restrictions (No_Implicit_Loops) is specified, since in\n-         --  either case, we are at risk of declaring the program illegal\n-         --  because of this limit.\n-\n-         Max_Aggr_Size : constant Nat :=\n-                           5000 + (2 ** 24 - 5000) *\n-                             Boolean'Pos\n-                               (Restriction_Active (No_Elaboration_Code)\n-                                  or else\n-                                Restriction_Active (No_Implicit_Loops));\n-\n       begin\n          if Nkind (Original_Node (N)) = N_String_Literal then\n             return True;\n          end if;\n \n-         --  Bounds need to be known at compile time\n-\n-         if not Compile_Time_Known_Value (Lo)\n-           or else not Compile_Time_Known_Value (Hi)\n-         then\n-            return False;\n-         end if;\n-\n-         --  Get bounds and check reasonable size (positive, not too large)\n-         --  Also only handle bounds starting at the base type low bound\n+         --  Only handle bounds starting at the base type low bound\n          --  for now since the compiler isn't able to handle different low\n          --  bounds yet. Case such as new String'(3..5 => ' ') will get\n          --  the wrong bounds, though it seems that the aggregate should\n@@ -2744,22 +2872,12 @@ package body Exp_Aggr is\n          Hiv := Expr_Value (Hi);\n \n          if Hiv < Lov\n-           or else (Hiv - Lov > Max_Aggr_Size)\n            or else not Compile_Time_Known_Value (Blo)\n            or else (Lov /= Expr_Value (Blo))\n          then\n             return False;\n          end if;\n \n-         --  Bounds must be in integer range (for array Vals below)\n-\n-         if not UI_Is_In_Int_Range (Lov)\n-             or else\n-            not UI_Is_In_Int_Range (Hiv)\n-         then\n-            return False;\n-         end if;\n-\n          --  Determine if set of alternatives is suitable for conversion\n          --  and build an array containing the values in sequence.\n \n@@ -2987,7 +3105,10 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      if Flatten (N, First_Index (Typ), First_Index (Base_Type (Typ))) then\n+      if Aggr_Size_OK (Typ)\n+        and then\n+          Flatten (N, First_Index (Typ), First_Index (Base_Type (Typ)))\n+      then\n          Analyze_And_Resolve (N, Typ);\n       end if;\n    end Convert_To_Positional;"}]}