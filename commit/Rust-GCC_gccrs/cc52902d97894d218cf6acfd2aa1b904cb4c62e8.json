{"sha": "cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M1MjkwMmQ5Nzg5NGQyMThjZjZhY2ZkMmFhMWI5MDRjYjRjNjJlOA==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-05-19T03:35:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-19T03:35:19Z"}, "message": "tree-ssa-phiopt.c (abs_replacement): New function.\n\n        * tree-ssa-phiopt.c (abs_replacement): New function.\n        (empty_block_p): New function extracted from...\n        (candidate_bb_for_phi_optimization): Break out empty block test.\n        (conditional_replacement): Use empty_block_p.\n        (value_replacement): Similarly.\n\n        * gcc.dg/tree-ssa/20040514-2.c: Update expected output.\n        * gcc.dg/tree-ssa/20040518-2.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r82017", "tree": {"sha": "62473a83bfb15d0913a0cac54dedc5a8f8620515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62473a83bfb15d0913a0cac54dedc5a8f8620515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/comments", "author": null, "committer": null, "parents": [{"sha": "eeab4d81a61970e9079dbd9a8033d13e0cc27980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeab4d81a61970e9079dbd9a8033d13e0cc27980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeab4d81a61970e9079dbd9a8033d13e0cc27980"}], "stats": {"total": 259, "additions": 237, "deletions": 22}, "files": [{"sha": "cff555cea4aa712fc9b8022fa60f2532f6c52355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "patch": "@@ -40,6 +40,12 @@\n 2004-05-18  Andrew Pinski  <pinskia@physics.uc.edu>\n \t    Jeff Law <law@redhat.com>\n \n+\t* tree-ssa-phiopt.c (abs_replacement): New function.\n+\t(empty_block_p): New function extracted from...\n+\t(candidate_bb_for_phi_optimization): Break out empty block test.\n+\t(conditional_replacement): Use empty_block_p.\n+\t(value_replacement): Similarly.\n+\n \t* Makefile.in (tree-ssa-phiopt.o): Depends on flags.h.\n \t* tree-ssa-phiopt.c: Include flags.h.\n \t(conditional_replacement): Remove argument names from prototype."}, {"sha": "001a935fd80d1f270067092aa2c3cd03d3b096b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "patch": "@@ -3,6 +3,10 @@\n \t* gfortran.fortran-torture/execute/power.f90: Test constant integers.\n \n 2004-05-18  Andrew Pinski  <pinskia@physics.uc.edu>\n+            Jeff Law  <law@redhat.com>\n+\n+        * gcc.dg/tree-ssa/20040514-2.c: Update expected output.\n+        * gcc.dg/tree-ssa/20040518-2.c: New test.\n \n \t* gcc.dg/tree-ssa/20040518-1.c: New test.\n "}, {"sha": "fb01bb8d858b2dc5ac2ad4fe5ee0b5760afdcd82", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040514-2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040514-2.c?ref=cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "patch": "@@ -11,5 +11,7 @@ foo2 (distance, i, j)\n  return t;\n }\n \n-/* There should be no ABS_EXPR.  */\n-/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 0 \"dom3\"} } */\n+/* There should be one ABS_EXPR and no conditionals.  */\n+/* { dg-final { scan-tree-dump-times \"ABS_EXPR \" 1 \"dom3\"} } */\n+/* { dg-final { scan-tree-dump-times \"if \" 0 \"dom3\"} } */\n+"}, {"sha": "009dce45efabfbf77caa7a586e9d6b1b69507276", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040518-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040518-2.c?ref=cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-phiopt1-details\" } */\n+\n+int t( int i)\n+{\n+   int j;\n+   if(i>=0)\n+    j = i;\n+   else\n+    j = -i;\n+   return j;\n+}\n+\n+/* We should convert one COND_EXPRs into straightline code with ABS.  */\n+/* { dg-final { scan-tree-dump-times \"straightline\" 1 \"phiopt1\"} } */\n+/* { dg-final { scan-tree-dump-times \"ABS_EXPR\" 1 \"phiopt1\"} } */"}, {"sha": "7648bc090d60bce63f0c74af6c6579d6e3170161", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 207, "deletions": 20, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc52902d97894d218cf6acfd2aa1b904cb4c62e8/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "patch": "@@ -39,11 +39,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static void tree_ssa_phiopt (void);\n static bool conditional_replacement (basic_block, tree, tree, tree);\n static bool value_replacement (basic_block, tree, tree, tree);\n+static bool abs_replacement (basic_block, tree, tree, tree);\n static void replace_phi_with_stmt (block_stmt_iterator, basic_block,\n \t\t\t\t   basic_block, tree, tree);\n static bool candidate_bb_for_phi_optimization (basic_block,\n \t\t\t\t\t       basic_block *,\n \t\t\t\t\t       basic_block *);\n+static bool empty_block_p (basic_block);\n \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  ie if we have something\n@@ -82,8 +84,29 @@ static bool candidate_bb_for_phi_optimization (basic_block,\n       x = b;\n \n    This can sometimes occur as a result of other optimizations.  A\n-   similar transformation is done by the ifcvt RTL optimizer.  */\n-   \n+   similar transformation is done by the ifcvt RTL optimizer. \n+\n+   This pass also eliminates PHI nodes which are really absolute \n+   values.  i.e. if we have something like:\n+\n+     bb0:\n+      if (a >= 0) goto bb2; else goto bb1;\n+     bb1:\n+      x = -a;\n+     bb2:\n+      x = PHI (x (bb1), a (bb0));\n+\n+   We can rewrite that as:\n+\n+     bb0:\n+     bb1:\n+     bb2:\n+      x = ABS_EXPR< a >;\n+\n+   bb1 will become unreachable and bb0 and bb2 will almost always be merged\n+   into a single block.  Similar transformations are done by the ifcvt\n+   RTL optimizer.  */ \n+\n static void\n tree_ssa_phiopt (void)\n {\n@@ -106,7 +129,8 @@ tree_ssa_phiopt (void)\n \t    \n \t  /* Do the replacement of conditional if it can be done.  */\n \t    if (conditional_replacement (bb, phi, arg0, arg1)\n-\t\t|| value_replacement (bb, phi, arg0, arg1))\n+\t\t|| value_replacement (bb, phi, arg0, arg1)\n+\t\t|| abs_replacement (bb, phi, arg0, arg1))\n \t      {\n \t\t/* We have done the replacement so we need to rebuild the\n \t\t   cfg when this pass is complete.  */\n@@ -121,12 +145,32 @@ tree_ssa_phiopt (void)\n     cleanup_tree_cfg ();\n }\n \n+/* Return TRUE if block BB has no executable statements, otherwise return\n+   FALSE.  */\n+static bool\n+empty_block_p (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+\n+  /* BB must have no executable statements.  */\n+  bsi = bsi_start (bb);\n+  while (!bsi_end_p (bsi)\n+\t  && (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR\n+\t      || IS_EMPTY_STMT (bsi_stmt (bsi))))\n+    bsi_next (&bsi);\n+  \n+  if (!bsi_end_p (bsi))\n+    return false;\n+\n+  return true;\n+}\n+\n /* BB is a basic block which has only one PHI node with precisely two\n    arguments.\n \n    Examine both of BB's predecessors to see if one ends with a \n-   COND_EXPR and the other is an empty block.  If so, then we may\n-   be able to optimize PHI nodes at the start of BB. \n+   COND_EXPR and the other is a successor of the COND_EXPR.  If so, then\n+   we may be able to optimize PHI nodes at the start of BB. \n \n    If so, mark store the block with the COND_EXPR into COND_BLOCK_P\n    and the other block into OTHER_BLOCK_P and return true, otherwise\n@@ -138,12 +182,10 @@ candidate_bb_for_phi_optimization (basic_block bb,\n \t\t\t\t   basic_block *other_block_p)\n {\n   tree last0, last1;\n-  block_stmt_iterator bsi;\n   basic_block cond_block, other_block;\n \n   /* One of the alternatives must come from a block ending with\n-     a COND_EXPR.  The other block must be entirely empty, except\n-     for labels.  */\n+     a COND_EXPR.  */\n   last0 = last_stmt (bb->pred->src);\n   last1 = last_stmt (bb->pred->pred_next->src);\n   if (last0 && TREE_CODE (last0) == COND_EXPR)\n@@ -180,16 +222,6 @@ candidate_bb_for_phi_optimization (basic_block bb,\n       || phi_nodes (other_block))\n     return false;\n   \n-  /* OTHER_BLOCK must have no executable statements.  */\n-  bsi = bsi_start (other_block);\n-  while (!bsi_end_p (bsi)\n-\t  && (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR\n-\t      || IS_EMPTY_STMT (bsi_stmt (bsi))))\n-    bsi_next (&bsi);\n-  \n-  if (!bsi_end_p (bsi))\n-    return false;\n-\n   *cond_block_p = cond_block;\n   *other_block_p = other_block;\n   /* Everything looks OK.  */\n@@ -271,7 +303,8 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   else\n     return false;\n   \n-  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n+  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block)\n+      || !empty_block_p (other_block))\n     return false;\n \t\t\t\t\t\t\t\t\t\t\n   /* If the condition is not a naked SSA_NAME and its type does not\n@@ -397,7 +430,8 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n     return false;\n \n-  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n+  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block)\n+      || !empty_block_p (other_block))\n     return false;\n \n   cond = COND_EXPR_COND (last_stmt (cond_block));\n@@ -447,6 +481,159 @@ value_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   return false;\n }\n \n+/*  The function absolute_replacement does the main work of doing the absolute\n+    replacement.  Return true if the replacement is done.  Otherwise return\n+    false.\n+    bb is the basic block where the replacement is going to be done on.  arg0\n+    is argument 0 from the phi.  Likewise for arg1.   */\n+static bool\n+abs_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n+{\n+  tree result;\n+  basic_block other_block = NULL;\n+  basic_block cond_block = NULL;\n+  tree new, cond;\n+  block_stmt_iterator bsi;\n+  edge true_edge, false_edge;\n+  tree assign = NULL;\n+  edge e;\n+  tree rhs = NULL, lhs = NULL;\n+  bool negate;\n+  enum tree_code cond_code;\n+\n+  /* If the type says honor signed zeros we cannot do this\n+     optimization.   */\n+  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+    return false;\n+\n+  if (!candidate_bb_for_phi_optimization (bb, &cond_block, &other_block))\n+    return false;\n+\n+  /* OTHER_BLOCK must have only one executable statement which must have the\n+     form arg0 = -arg1 or arg1 = -arg0.  */\n+  bsi = bsi_start (other_block);\n+  while (!bsi_end_p (bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      /* Empty statements and labels are uninteresting.  */\n+      if (TREE_CODE (stmt) == LABEL_EXPR\n+          || IS_EMPTY_STMT (stmt))\n+        {\n+          bsi_next (&bsi);\n+          continue;\n+        }\n+\n+      /* If we found the assignment, but it was not the only executable\n+\t statement in OTHER_BLOCK, then we can not optimize.  */\n+      if (assign)\n+\treturn false;\n+\n+      /* If we got here, then we have found the first executable statement\n+\t in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n+\t arg1 = -arg0, then we can not optimize.  */\n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+        {\n+          lhs = TREE_OPERAND (stmt, 0);\n+          rhs = TREE_OPERAND (stmt, 1);\n+\n+          if (TREE_CODE (rhs) == NEGATE_EXPR)\n+            {\n+              rhs = TREE_OPERAND (rhs, 0);\n+\n+              /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n+              if ((lhs == arg0 && rhs == arg1)\n+\t\t  || (lhs == arg1 && rhs == arg0))\n+\t\t{\n+\t\t  assign = stmt;\n+\t\t  bsi_next (&bsi);\n+\t\t}\n+\t      else\n+\t\treturn false;\n+            }\n+\t  else\n+\t    return false;\n+        }\n+      else\n+\treturn false;\n+    }\n+\n+  /* If we did not find the proper negation assignment, then we can not\n+     optimize.  */\n+  if (assign == NULL)\n+    return false;\n+\n+  cond = COND_EXPR_COND (last_stmt (cond_block));\n+  result = PHI_RESULT (phi);\n+\n+  /* Only relationals comparing arg[01] against zero are interesting.  */\n+  cond_code = TREE_CODE (cond);\n+  if (cond_code != GT_EXPR && cond_code != GE_EXPR\n+      && cond_code != LT_EXPR && cond_code != LE_EXPR)\n+    return false;\n+\n+  /* Make sure the conditional is arg[01] OP y.   */\n+  if (TREE_OPERAND (cond, 0) != rhs)\n+    return false;\n+\n+  if (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))\n+\t       ? real_zerop (TREE_OPERAND (cond, 1))\n+\t       : integer_zerop (TREE_OPERAND (cond, 1)))\n+    ;\n+  else\n+    return false;\n+\n+  /* We need to know which is the true edge and which is the false\n+     edge so that we know if have abs or negative abs.  */\n+  extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n+\n+  /* For GT_EXPR/GE_EXPR, if the true edge goes to OTHER_BLOCK, then we\n+     will need to negate the result.  Similarly for LT_EXPR/LE_EXPR if\n+     the false edge goes to OTHER_BLOCK.  */\n+  if (cond_code == GT_EXPR || cond_code == GE_EXPR)\n+    e = true_edge;\n+  else\n+    e = false_edge;\n+  \n+  if (e->dest == other_block)\n+    negate = true;\n+  else\n+    negate = false;\n+  \n+  if (negate)\n+    lhs = make_rename_temp (TREE_TYPE (result), NULL);\n+  else\n+    lhs = result;\n+\n+  /*  Build the modify expression with abs expression.   */\n+  new = build (MODIFY_EXPR, TREE_TYPE (lhs),\n+               lhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n+\n+  replace_phi_with_stmt (bsi_start (bb), bb, cond_block, phi, new);\n+\n+  if (negate)\n+    {\n+\n+      /* Get the right BSI.  We want to insert after the recently \n+\t added ABS_EXPR statement (which we know is the first statement\n+\t in the block.  */\n+      bsi = bsi_start (bb);\n+      bsi_next (&bsi);\n+      new = build (MODIFY_EXPR, TREE_TYPE (result),\n+                   result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n+\n+      bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\n+      /* Register the new statement as defining the temporary -- this is\n+\t normally done by replace_phi_with_stmt, but the link will be wrong\n+\t if we had to negate the resulting value.  */\n+      SSA_NAME_DEF_STMT (result) = new;\n+    }\n+\n+  /* Note that we optimized this PHI.  */\n+  return true;\n+}\n+\n \n /* Always do these optimizations if we have SSA\n    trees to work on.  */\t\t\t\t\t\t"}]}