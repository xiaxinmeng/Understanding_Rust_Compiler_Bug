{"sha": "40e01041b3593c72f3d52013953fbfbe0011abb8", "node_id": "C_kwDOANBUbNoAKDQwZTAxMDQxYjM1OTNjNzJmM2Q1MjAxMzk1M2ZiZmJlMDAxMWFiYjg", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-04-19T15:46:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-30T08:29:02Z"}, "message": "[Ada] Update proofs of double arithmetic unit after prover changes\n\nChanges in GNATprove (translation to Why3 and provers) result in proofs\nbeing much less automatic, and requiring ghost code to detail\nintermediate steps. In some cases, it is better to use the new By\nmechanism to prove assertions in steps, as this avoids polluting the\nproof context for other proofs. For that reason, add units s-spark.ads\nand s-spcuop.ads/b to the runtime sources.\n\ngcc/ada/\n\n\t* Makefile.rtl: Add new units.\n\t* libgnat/s-aridou.adb (Scaled_Divide): Add ghost code for provers.\n\t* libgnat/s-spcuop.adb: New unit for ghost cut operations.\n\t* libgnat/s-spcuop.ads: New unit for ghost cut operations.\n\t* libgnat/s-spark.ads: New unit.", "tree": {"sha": "783be6a33b2d7a363219000b4a326e179021faf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/783be6a33b2d7a363219000b4a326e179021faf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40e01041b3593c72f3d52013953fbfbe0011abb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e01041b3593c72f3d52013953fbfbe0011abb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40e01041b3593c72f3d52013953fbfbe0011abb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e01041b3593c72f3d52013953fbfbe0011abb8/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33dec214f0270ac86c445e08c32843b73e44fb23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33dec214f0270ac86c445e08c32843b73e44fb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33dec214f0270ac86c445e08c32843b73e44fb23"}], "stats": {"total": 669, "additions": 578, "deletions": 91}, "files": [{"sha": "8812d15a21824b29f547bfdd4ba5c9f572460b1b", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=40e01041b3593c72f3d52013953fbfbe0011abb8", "patch": "@@ -749,6 +749,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-shasto$(objext) \\\n   s-soflin$(objext) \\\n   s-soliin$(objext) \\\n+  s-spark$(objext) \\\n+  s-spcuop$(objext) \\\n   s-spsufi$(objext) \\\n   s-stache$(objext) \\\n   s-stalib$(objext) \\"}, {"sha": "259c0ac0da208b0f6583455e0e696b9dc439bc6c", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 439, "deletions": 91, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=40e01041b3593c72f3d52013953fbfbe0011abb8", "patch": "@@ -30,6 +30,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Conversion;\n+with System.SPARK.Cut_Operations; use System.SPARK.Cut_Operations;\n \n package body System.Arith_Double\n   with SPARK_Mode\n@@ -1822,31 +1823,51 @@ is\n       Big_Q : Big_Integer with Ghost;\n       Inter : Natural with Ghost;\n \n+      --  Local ghost functions\n+\n+      function Is_Mult_Decomposition\n+        (D1, D2, D3, D4 : Big_Integer)\n+         return Boolean\n+      is\n+        (Mult = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle * D1\n+                              + Big_2xxSingle * Big_2xxSingle * D2\n+                                              + Big_2xxSingle * D3\n+                                                              + D4)\n+      with Ghost;\n+\n+      function Is_Scaled_Mult_Decomposition\n+        (D1, D2, D3, D4 : Big_Integer)\n+         return Boolean\n+      is\n+        (Mult * Big_2xx (Scale)\n+           = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle * D1\n+                           + Big_2xxSingle * Big_2xxSingle * D2\n+                                           + Big_2xxSingle * D3\n+                                                           + D4)\n+      with\n+        Ghost,\n+        Pre  => Scale < Double_Size;\n+\n       --  Local lemmas\n \n       procedure Prove_Dividend_Scaling\n       with\n         Ghost,\n         Pre  => D'Initialized\n           and then Scale <= Single_Size\n-          and then Mult =\n-            Big_2xxSingle\n-              * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-              + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                              + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                              + Big (Double_Uns (D (4)))\n+          and then Is_Mult_Decomposition (Big (Double_Uns (D (1))),\n+                                          Big (Double_Uns (D (2))),\n+                                          Big (Double_Uns (D (3))),\n+                                          Big (Double_Uns (D (4))))\n           and then Big (D (1) & D (2)) * Big_2xx (Scale) < Big_2xxDouble\n           and then T1 = Shift_Left (D (1) & D (2), Scale)\n           and then T2 = Shift_Left (Double_Uns (D (3)), Scale)\n           and then T3 = Shift_Left (Double_Uns (D (4)), Scale),\n-        Post => Mult * Big_2xx (Scale) =\n-          Big_2xxSingle\n-            * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n-            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1) or\n-                                                                      Hi (T2)))\n-                            + Big_2xxSingle * Big (Double_Uns (Lo (T2) or\n-                                                                      Hi (T3)))\n-                                            + Big (Double_Uns (Lo (T3)));\n+        Post => Is_Scaled_Mult_Decomposition\n+          (Big (Double_Uns (Hi (T1))),\n+           Big (Double_Uns (Lo (T1) or Hi (T2))),\n+           Big (Double_Uns (Lo (T2) or Hi (T3))),\n+           Big (Double_Uns (Lo (T3))));\n       --  Proves the scaling of the 4-digit dividend actually multiplies it by\n       --  2**Scale.\n \n@@ -2030,21 +2051,32 @@ is\n       ----------------------------\n \n       procedure Prove_Dividend_Scaling is\n+         Big_D12 : constant Big_Integer :=\n+           Big_2xx (Scale) * Big (D (1) & D (2));\n+         Big_T1  : constant Big_Integer := Big (T1);\n+         Big_D3  : constant Big_Integer :=\n+           Big_2xx (Scale) * Big (Double_Uns (D (3)));\n+         Big_T2  : constant Big_Integer := Big (T2);\n+         Big_D4  : constant Big_Integer :=\n+           Big_2xx (Scale) * Big (Double_Uns (D (4)));\n+         Big_T3  : constant Big_Integer := Big (T3);\n+\n       begin\n          Lemma_Shift_Left (D (1) & D (2), Scale);\n+         pragma Assert (By (Big_2xxSingle * Big_2xx (Scale) <= Big_2xxDouble,\n+                            Big_2xx (Scale) <= Big_2xxSingle));\n+         Lemma_Lt_Mult (Big (Double_Uns (D (3))), Big_2xxSingle,\n+                        Big_2xx (Scale), Big_2xxDouble);\n          Lemma_Shift_Left (Double_Uns (D (3)), Scale);\n+         Lemma_Lt_Mult (Big (Double_Uns (D (4))), Big_2xxSingle,\n+                        Big_2xx (Scale), Big_2xxDouble);\n          Lemma_Shift_Left (Double_Uns (D (4)), Scale);\n          Lemma_Hi_Lo (D (1) & D (2), D (1), D (2));\n          pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xxSingle\n-             * Big_2xxSingle * Big_2xx (Scale) * Big (D (1) & D (2))\n-             + Big_2xxSingle * Big_2xx (Scale) * Big (Double_Uns (D (3)))\n-                             + Big_2xx (Scale) * Big (Double_Uns (D (4))));\n+           Big_2xxSingle * Big_2xxSingle * Big_D12\n+                         + Big_2xxSingle * Big_D3\n+                                         + Big_D4);\n          pragma Assert (Big_2xx (Scale) > 0);\n-         Lemma_Lt_Mult (Big (Double_Uns (D (3))), Big_2xxSingle,\n-                        Big_2xx (Scale), Big_2xxDouble);\n-         Lemma_Lt_Mult (Big (Double_Uns (D (4))), Big_2xxSingle,\n-                        Big_2xx (Scale), Big_2xxDouble);\n          declare\n             Two_xx_Scale : constant Double_Uns := Double_Uns'(2 ** Scale);\n             D12          : constant Double_Uns := D (1) & D (2);\n@@ -2053,43 +2085,120 @@ is\n             pragma Assert (Big (Two_xx_Scale) * Big (D12) < Big_2xxDouble);\n             Lemma_Mult_Commutation (Two_xx_Scale, D12, T1);\n          end;\n-         declare\n-            Big_D12 : constant Big_Integer :=\n-              Big_2xx (Scale) * Big (D (1) & D (2));\n-            Big_T1  : constant Big_Integer := Big (T1);\n-         begin\n-            pragma Assert (Big_D12 = Big_T1);\n-            pragma Assert (Big_2xxSingle * Big_2xxSingle * Big_D12\n-                           = Big_2xxSingle * Big_2xxSingle * Big_T1);\n-         end;\n+         pragma Assert (Big_D12 = Big_T1);\n+         pragma Assert (Big_2xxSingle * Big_2xxSingle * Big_D12\n+                        = Big_2xxSingle * Big_2xxSingle * Big_T1);\n          Lemma_Mult_Commutation (2 ** Scale, Double_Uns (D (3)), T2);\n-         declare\n-            Big_D3 : constant Big_Integer :=\n-              Big_2xx (Scale) * Big (Double_Uns (D (3)));\n-            Big_T2 : constant Big_Integer := Big (T2);\n-         begin\n-            pragma Assert (Big_D3 = Big_T2);\n-            pragma Assert (Big_2xxSingle * Big_D3 = Big_2xxSingle * Big_T2);\n-         end;\n+         pragma Assert (Big_D3 = Big_T2);\n+         pragma Assert (Big_2xxSingle * Big_D3 = Big_2xxSingle * Big_T2);\n          Lemma_Mult_Commutation (2 ** Scale, Double_Uns (D (4)), T3);\n-         declare\n-            Big_D4 : constant Big_Integer :=\n-              Big_2xx (Scale) * Big (Double_Uns (D (4)));\n-            Big_T3 : constant Big_Integer := Big (T3);\n-         begin\n-            pragma Assert (Big_D4 = Big_T3);\n-         end;\n-         pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xxSingle * Big_2xxSingle * Big (T1)\n-                         + Big_2xxSingle * Big (T2)\n-                                         + Big (T3));\n+         pragma Assert (Big_D4 = Big_T3);\n+         pragma Assert\n+           (By (Is_Scaled_Mult_Decomposition (0, Big_T1, Big_T2, Big_T3),\n+            By (Big_2xxSingle * Big_2xxSingle * Big_D12 =\n+                Big_2xxSingle * Big_2xxSingle * Big_T1,\n+                Big_D12 = Big_T1)\n+              and then\n+            By (Big_2xxSingle * Big_D3  = Big_2xxSingle * Big_T2,\n+                Big_D3 = Big_T2)\n+              and then\n+            Big_D4 = Big_T3));\n          Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n          Lemma_Hi_Lo (T3, Hi (T3), Lo (T3));\n+         Lemma_Mult_Distribution (Big_2xxSingle * Big_2xxSingle,\n+                                  Big_2xxSingle * Big (Double_Uns (Hi (T1))),\n+                                  Big (Double_Uns (Lo (T1))));\n+         Lemma_Mult_Distribution (Big_2xxSingle,\n+                                  Big_2xxSingle * Big (Double_Uns (Hi (T2))),\n+                                  Big (Double_Uns (Lo (T2))));\n+         Lemma_Mult_Distribution (Big_2xxSingle * Big_2xxSingle,\n+                                  Big (Double_Uns (Lo (T1))),\n+                                  Big (Double_Uns (Hi (T2))));\n+         Lemma_Mult_Distribution (Big_2xxSingle,\n+                                  Big (Double_Uns (Lo (T2))),\n+                                  Big (Double_Uns (Hi (T3))));\n+         pragma Assert\n+           (By (Is_Scaled_Mult_Decomposition\n+              (Big (Double_Uns (Hi (T1))),\n+               Big (Double_Uns (Lo (T1))) + Big (Double_Uns (Hi (T2))),\n+               Big (Double_Uns (Lo (T2))) + Big (Double_Uns (Hi (T3))),\n+               Big (Double_Uns (Lo (T3)))),\n+            --  Start from stating equality between the expanded values of\n+            --  the right-hand side in the known and desired assertions over\n+            --  Is_Scaled_Mult_Decomposition.\n+            By (Big_2xxSingle * Big_2xxSingle * Big_2xxSingle *\n+              Big (Double_Uns (Hi (T1)))\n+            + Big_2xxSingle * Big_2xxSingle *\n+              (Big (Double_Uns (Lo (T1))) + Big (Double_Uns (Hi (T2))))\n+            + Big_2xxSingle *\n+              (Big (Double_Uns (Lo (T2))) + Big (Double_Uns (Hi (T3))))\n+            + Big (Double_Uns (Lo (T3))) =\n+              Big_2xxSingle * Big_2xxSingle * Big_2xxSingle * 0\n+            + Big_2xxSingle * Big_2xxSingle * Big_T1\n+            + Big_2xxSingle * Big_T2\n+            + Big_T3,\n+              --  Now list all known equalities that contribute\n+              Big_2xxSingle * Big_2xxSingle * Big_2xxSingle *\n+              Big (Double_Uns (Hi (T1)))\n+            + Big_2xxSingle * Big_2xxSingle *\n+              (Big (Double_Uns (Lo (T1))) + Big (Double_Uns (Hi (T2))))\n+            + Big_2xxSingle *\n+              (Big (Double_Uns (Lo (T2))) + Big (Double_Uns (Hi (T3))))\n+            + Big (Double_Uns (Lo (T3))) =\n+              Big_2xxSingle * Big_2xxSingle * Big_2xxSingle *\n+                Big (Double_Uns (Hi (T1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+            + Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+            + Big_2xxSingle * Big (Double_Uns (Hi (T3)))\n+            + Big (Double_Uns (Lo (T3)))\n+              and then\n+            By (Big_2xxSingle * Big_2xxSingle * Big (T1)\n+            = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+            * Big (Double_Uns (Hi (T1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1))),\n+            Big_2xxSingle * Big_2xxSingle * Big (T1)\n+            = Big_2xxSingle * Big_2xxSingle\n+            * (Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+               + Big (Double_Uns (Lo (T1)))))\n+              and then\n+            By (Big_2xxSingle * Big (T2)\n+            = Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+            + Big_2xxSingle * Big (Double_Uns (Lo (T2))),\n+            Big_2xxSingle * Big (T2)\n+            = Big_2xxSingle * (Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+              + Big (Double_Uns (Lo (T2)))))\n+              and then\n+            Big (T3) = Big_2xxSingle * Big (Double_Uns (Hi (T3)))\n+            + Big (Double_Uns (Lo (T3))))));\n+         Lemma_Mult_Distribution (Big_2xxSingle * Big_2xxSingle,\n+                                  Big (Double_Uns (Lo (T1))),\n+                                  Big (Double_Uns (Hi (T2))));\n          pragma Assert (Double_Uns (Lo (T1) or Hi (T2)) =\n                           Double_Uns (Lo (T1)) + Double_Uns (Hi (T2)));\n          pragma Assert (Double_Uns (Lo (T2) or Hi (T3)) =\n                           Double_Uns (Lo (T2)) + Double_Uns (Hi (T3)));\n+         Lemma_Add_Commutation (Double_Uns (Lo (T1)), Hi (T2));\n+         Lemma_Add_Commutation (Double_Uns (Lo (T2)), Hi (T3));\n+         pragma Assert\n+           (By (Is_Scaled_Mult_Decomposition\n+              (Big (Double_Uns (Hi (T1))),\n+               Big (Double_Uns (Lo (T1) or Hi (T2))),\n+               Big (Double_Uns (Lo (T2) or Hi (T3))),\n+               Big (Double_Uns (Lo (T3)))),\n+            By (Big_2xxSingle * Big_2xxSingle\n+              * Big (Double_Uns (Lo (T1) or Hi (T2))) =\n+                Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1)))\n+              + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2))),\n+              Big_2xxSingle * Big_2xxSingle\n+              * Big (Double_Uns (Lo (T1)) + Double_Uns (Hi (T2))) =\n+                Big_2xxSingle * Big_2xxSingle\n+              * (Big (Double_Uns (Lo (T1))) + Big (Double_Uns (Hi (T2)))))\n+              and then\n+            Big_2xxSingle * Big (Double_Uns (Lo (T2) or Hi (T3))) =\n+            Big_2xxSingle * Big (Double_Uns (Lo (T2)))\n+            + Big_2xxSingle * Big (Double_Uns (Hi (T3)))));\n       end Prove_Dividend_Scaling;\n \n       --------------------------\n@@ -2299,24 +2408,58 @@ is\n       Lemma_Abs_Commutation (X);\n       Lemma_Abs_Commutation (Y);\n       Lemma_Mult_Decomposition (Mult, Xu, Yu, Xhi, Xlo, Yhi, Ylo);\n+      pragma Assert\n+        (Is_Mult_Decomposition\n+           (D1 => 0,\n+            D2 => Big (Double_Uns'(Xhi * Yhi)),\n+            D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns'(Xlo * Yhi)),\n+            D4 => Big (Double_Uns'(Xlo * Ylo))));\n \n       T1 := Xlo * Ylo;\n       D (4) := Lo (T1);\n       D (3) := Hi (T1);\n \n       Lemma_Hi_Lo (T1, D (3), D (4));\n+      pragma Assert\n+        (Is_Mult_Decomposition\n+           (D1 => 0,\n+            D2 => Big (Double_Uns'(Xhi * Yhi)),\n+            D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns'(Xlo * Yhi))\n+              + Big (Double_Uns (D (3))),\n+            D4 => Big (Double_Uns (D (4)))));\n \n       if Yhi /= 0 then\n          T1 := Xlo * Yhi;\n \n          Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n+         pragma Assert\n+           (Is_Mult_Decomposition\n+              (D1 => 0,\n+               D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (Hi (T1))),\n+               D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns (Lo (T1)))\n+                 + Big (Double_Uns (D (3))),\n+               D4 => Big (Double_Uns (D (4)))));\n \n          T2 := D (3) + Lo (T1);\n \n+         Lemma_Add_Commutation (Double_Uns (Lo (T1)), D (3));\n+         pragma Assert\n+           (Is_Mult_Decomposition\n+              (D1 => 0,\n+               D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (Hi (T1))),\n+               D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (T2),\n+               D4 => Big (Double_Uns (D (4)))));\n          Lemma_Mult_Distribution (Big_2xxSingle,\n                                   Big (Double_Uns (D (3))),\n                                   Big (Double_Uns (Lo (T1))));\n          Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n+         pragma Assert\n+           (Is_Mult_Decomposition\n+              (D1 => 0,\n+               D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (Hi (T1)))\n+                 + Big (Double_Uns (Hi (T2))),\n+               D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns (Lo (T2))),\n+               D4 => Big (Double_Uns (D (4)))));\n \n          D (3) := Lo (T2);\n          D (2) := Hi (T1) + Hi (T2);\n@@ -2326,31 +2469,131 @@ is\n          pragma Assert\n            (Big (Double_Uns (Hi (T1))) + Big (Double_Uns (Hi (T2))) =\n               Big (Double_Uns (D (2))));\n+         pragma Assert\n+           (Is_Mult_Decomposition\n+              (D1 => 0,\n+               D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2))),\n+               D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns (D (3))),\n+               D4 => Big (Double_Uns (D (4)))));\n \n          if Xhi /= 0 then\n             T1 := Xhi * Ylo;\n \n             Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n+                    + Big (Double_Uns (Hi (T1))),\n+                  D3 => Big (Double_Uns (Lo (T1))) + Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               (By (Big_2xxSingle * Big (T1) =\n+                    Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+                    + Big_2xxSingle * Big (Double_Uns (Lo (T1))),\n+                    Big_2xxSingle * Big (T1) =\n+                    Big_2xxSingle * (Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+                    + Big (Double_Uns (Lo (T1))))))));\n \n             T2 := D (3) + Lo (T1);\n \n+            Lemma_Add_Commutation (Double_Uns (D (3)), Lo (T1));\n+            pragma Assert\n+              (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n+                    + Big (Double_Uns (Hi (T1))),\n+                  D3 => Big (T2),\n+                  D4 => Big (Double_Uns (D (4)))));\n             Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (Double_Uns (D (2)))\n+                    + Big (Double_Uns (Hi (T1))) + Big (Double_Uns (Hi (T2))),\n+                  D3 => Big (Double_Uns (Lo (T2))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               By (Big_2xxSingle * Big (T2) =\n+                 Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+                 + Big_2xxSingle * Big (Double_Uns (Lo (T2))),\n+               Big_2xxSingle *\n+                 (Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+                                + Big (Double_Uns (Lo (T2))))\n+              = Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+                  + Big_2xxSingle * Big (Double_Uns (Lo (T2))))));\n \n             D (3) := Lo (T2);\n             T3 := D (2) + Hi (T1);\n \n+            Lemma_Add_Commutation (Double_Uns (D (2)), Hi (T1));\n+            pragma Assert\n+              (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns'(Xhi * Yhi)) + Big (T3)\n+                    + Big (Double_Uns (Hi (T2))),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))));\n             Lemma_Add_Commutation (T3, Hi (T2));\n \n             T3 := T3 + Hi (T2);\n             T2 := Double_Uns'(Xhi * Yhi);\n \n+            pragma Assert\n+              (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (T2) + Big (T3),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))));\n             Lemma_Hi_Lo (T2, Hi (T2), Lo (T2));\n-            Lemma_Add_Commutation (T3, Lo (T2));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => Big (Double_Uns (Hi (T2))),\n+                  D2 => Big (Double_Uns (Lo (T2))) + Big (T3),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               By (Big_2xxSingle * Big_2xxSingle * Big (T2) =\n+                   Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+                 * Big (Double_Uns (Hi (T2)))\n+                 + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T2))),\n+               Big_2xxSingle * Big_2xxSingle *\n+                 (Big_2xxSingle * Big (Double_Uns (Hi (T2)))\n+                                + Big (Double_Uns (Lo (T2))))\n+                 = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+                     * Big (Double_Uns (Hi (T2)))\n+                   + Big_2xxSingle * Big_2xxSingle\n+                     * Big (Double_Uns (Lo (T2))))));\n \n             T1 := T3 + Lo (T2);\n             D (2) := Lo (T1);\n \n-            Lemma_Hi_Lo (T1, Hi (T1), D (2));\n+            Lemma_Add_Commutation (T3, Lo (T2));\n+            pragma Assert\n+              (Is_Mult_Decomposition\n+                 (D1 => Big (Double_Uns (Hi (T2))),\n+                  D2 => Big (T1),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))));\n+            Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                (D1 => Big (Double_Uns (Hi (T2))) + Big (Double_Uns (Hi (T1))),\n+                 D2 => Big (Double_Uns (D (2))),\n+                 D3 => Big (Double_Uns (D (3))),\n+                 D4 => Big (Double_Uns (D (4)))),\n+               By (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1))) =\n+                   Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2))),\n+                   D (2) = Lo (T1))\n+                 and then\n+               By (Big_2xxSingle * Big_2xxSingle * Big (T1) =\n+                   Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+                 * Big (Double_Uns (Hi (T1)))\n+                 + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Lo (T1))),\n+               Big_2xxSingle * Big_2xxSingle *\n+                 (Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+                                + Big (Double_Uns (Lo (T1))))\n+                 = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+                     * Big (Double_Uns (Hi (T1)))\n+                   + Big_2xxSingle * Big_2xxSingle\n+                     * Big (Double_Uns (Lo (T1))))));\n \n             D (1) := Hi (T2) + Hi (T1);\n \n@@ -2361,32 +2604,71 @@ is\n               (Big (Double_Uns (Hi (T2))) + Big (Double_Uns (Hi (T1))) =\n                    Big (Double_Uns (D (1))));\n \n-            pragma Assert (Mult =\n-              Big_2xxSingle\n-                * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-                + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                                + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                                + Big (Double_Uns (D (4))));\n-\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => Big (Double_Uns (D (1))),\n+                  D2 => Big (Double_Uns (D (2))),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               Big_2xxSingle * Big_2xxSingle * Big_2xxSingle *\n+                 Big (Double_Uns (D (1)))\n+               = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle *\n+                 (Big (Double_Uns (Hi (T2)) + Double_Uns (Hi (T1))))));\n          else\n             D (1) := 0;\n-         end if;\n \n-         pragma Assert (Mult =\n-           Big_2xxSingle\n-             * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-             + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                             + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                             + Big (Double_Uns (D (4))));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => Big (Double_Uns (D (1))),\n+                  D2 => Big (Double_Uns (D (2))),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               Big (Double_Uns'(Xhi * Yhi)) = 0\n+                 and then Big (Double_Uns'(Xhi * Ylo)) = 0\n+                 and then Big (Double_Uns (D (1))) = 0));\n+         end if;\n \n+         pragma Assert\n+           (Is_Mult_Decomposition (D1 => Big (Double_Uns (D (1))),\n+                                   D2 => Big (Double_Uns (D (2))),\n+                                   D3 => Big (Double_Uns (D (3))),\n+                                   D4 => Big (Double_Uns (D (4)))));\n       else\n+         pragma Assert\n+           (By (Is_Mult_Decomposition\n+              (D1 => 0,\n+               D2 => 0,\n+               D3 => Big (Double_Uns'(Xhi * Ylo)) + Big (Double_Uns (D (3))),\n+               D4 => Big (Double_Uns (D (4)))),\n+            Big (Double_Uns'(Xhi * Yhi)) = 0\n+              and then Big (Double_Uns'(Xlo * Yhi)) = 0));\n+\n          if Xhi /= 0 then\n             T1 := Xhi * Ylo;\n \n             Lemma_Hi_Lo (T1, Hi (T1), Lo (T1));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns (Hi (T1))),\n+                  D3 => Big (Double_Uns (Lo (T1))) + Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               Big_2xxSingle * Big (Double_Uns'(Xhi * Ylo)) =\n+                 Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (Hi (T1)))\n+                   + Big_2xxSingle * Big (Double_Uns (Lo (T1)))));\n \n             T2 := D (3) + Lo (T1);\n \n+            Lemma_Add_Commutation (Double_Uns (Lo (T1)), D (3));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns (Hi (T1))),\n+                  D3 => Big (T2),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               Big_2xxSingle * Big (T2) =\n+                 Big_2xxSingle *\n+                   (Big (Double_Uns (Lo (T1))) + Big (Double_Uns (D (3))))));\n             Lemma_Mult_Distribution (Big_2xxSingle,\n                                      Big (Double_Uns (D (3))),\n                                      Big (Double_Uns (Lo (T1))));\n@@ -2401,28 +2683,32 @@ is\n             pragma Assert\n               (Big (Double_Uns (Hi (T1))) + Big (Double_Uns (Hi (T2))) =\n                  Big (Double_Uns (D (2))));\n-            pragma Assert (Mult =\n-              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                            + Big (Double_Uns (D (4))));\n+            pragma Assert\n+              (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns (D (2))),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))));\n          else\n             D (2) := 0;\n \n-            pragma Assert (Mult =\n-              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                            + Big (Double_Uns (D (4))));\n+            pragma Assert\n+              (By (Is_Mult_Decomposition\n+                 (D1 => 0,\n+                  D2 => Big (Double_Uns (D (2))),\n+                  D3 => Big (Double_Uns (D (3))),\n+                  D4 => Big (Double_Uns (D (4)))),\n+               Big (Double_Uns'(Xhi * Ylo)) = 0\n+                 and then Big (Double_Uns (D (2))) = 0));\n          end if;\n \n          D (1) := 0;\n       end if;\n \n-      pragma Assert (Mult =\n-        Big_2xxSingle\n-          * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-          + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                          + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                          + Big (Double_Uns (D (4))));\n+      pragma Assert (Is_Mult_Decomposition (D1 => Big (Double_Uns (D (1))),\n+                                            D2 => Big (Double_Uns (D (2))),\n+                                            D3 => Big (Double_Uns (D (3))),\n+                                            D4 => Big (Double_Uns (D (4)))));\n \n       --  Now it is time for the dreaded multiple precision division. First an\n       --  easy case, check for the simple case of a one digit divisor.\n@@ -2627,26 +2913,88 @@ is\n          D (3) := Lo (T2) or Hi (T3);\n          D (4) := Lo (T3);\n \n-         pragma Assert (Mult * Big_2xx (Scale) =\n-           Big_2xxSingle\n-             * Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n-             + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n-                             + Big_2xxSingle * Big (Double_Uns (D (3)))\n-                                             + Big (Double_Uns (D (4))));\n-         Lemma_Substitution (Big_2xxDouble * Big (Zu), Big_2xxDouble, Big (Zu),\n-                             Big (Double_Uns'(abs Z)) * Big_2xx (Scale), 0);\n-         Lemma_Lt_Mult (Mult, Big_2xxDouble * Big (Double_Uns'(abs Z)),\n-                        Big_2xx (Scale), Big_2xxDouble * Big (Zu));\n-         Lemma_Div_Lt (Mult * Big_2xx (Scale), Big (Zu), Big_2xxDouble);\n+         pragma Assert (Big (Double_Uns (Hi (T1))) = Big (Double_Uns (D (1))));\n+         pragma Assert\n+           (Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+            * Big (Double_Uns (Hi (T1)))\n+            = Big_2xxSingle * Big_2xxSingle * Big_2xxSingle\n+            * Big (Double_Uns (D (1))));\n+\n+         pragma Assert\n+           (Is_Scaled_Mult_Decomposition\n+              (Big (Double_Uns (D (1))),\n+               Big (Double_Uns (D (2))),\n+               Big (Double_Uns (D (3))),\n+               Big (Double_Uns (D (4)))));\n+         pragma Assert\n+           (By (Is_Scaled_Mult_Decomposition\n+              (0,\n+               0,\n+               Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                             + Big (Double_Uns (D (3))),\n+               Big (Double_Uns (D (4)))),\n+            Big_2xxSingle *\n+              (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                             + Big (Double_Uns (D (3))))\n+            + Big (Double_Uns (D (4))) =\n+              Big_2xxSingle *\n+              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                            + Big (Double_Uns (D (4)))\n+              and then\n+            (By (Mult * Big_2xx (Scale) =\n+              Big_2xxSingle *\n+              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))\n+                            + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                                            + Big (Double_Uns (D (4))),\n+             Is_Scaled_Mult_Decomposition\n+              (Big (Double_Uns (D (1))),\n+               Big (Double_Uns (D (2))),\n+               Big (Double_Uns (D (3))),\n+               Big (Double_Uns (D (4))))))));\n          Lemma_Substitution\n            (Mult * Big_2xx (Scale), Big_2xxSingle,\n             Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n                           + Big_2xxSingle * Big (Double_Uns (D (2)))\n                                           + Big (Double_Uns (D (3))),\n             Big3 (D (1), D (2), D (3)),\n             Big (Double_Uns (D (4))));\n+         Lemma_Substitution (Big_2xxDouble * Big (Zu), Big_2xxDouble, Big (Zu),\n+                             Big (Double_Uns'(abs Z)) * Big_2xx (Scale), 0);\n+         Lemma_Lt_Mult (Mult, Big_2xxDouble * Big (Double_Uns'(abs Z)),\n+                        Big_2xx (Scale), Big_2xxDouble * Big (Zu));\n+         Lemma_Div_Lt (Mult * Big_2xx (Scale), Big (Zu), Big_2xxDouble);\n          Lemma_Concat_Definition (D (1), D (2));\n          Lemma_Double_Big_2xxSingle;\n+         pragma Assert\n+           (Big_2xxSingle *\n+              (Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big_2xxSingle * Big (Double_Uns (D (2)))\n+                                             + Big (Double_Uns (D (3))))\n+            + Big (Double_Uns (D (4)))\n+            = Big_2xxSingle * Big_2xxSingle *\n+              (Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big (Double_Uns (D (2))))\n+            + Big_2xxSingle * Big (Double_Uns (D (3)))\n+                            + Big (Double_Uns (D (4))));\n+         pragma Assert\n+           (By (Is_Scaled_Mult_Decomposition\n+              (0,\n+               Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big (Double_Uns (D (2))),\n+               0,\n+               Big_2xxSingle * Big (Double_Uns (D (3)))\n+                             + Big (Double_Uns (D (4)))),\n+            Big_2xxSingle * Big_2xxSingle *\n+              (Big_2xxSingle * Big (Double_Uns (D (1)))\n+                             + Big (Double_Uns (D (2)))) =\n+            Big_2xxSingle *\n+              Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (1)))\n+            + Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (2)))));\n          Lemma_Substitution\n            (Mult * Big_2xx (Scale), Big_2xxSingle * Big_2xxSingle,\n               Big_2xxSingle * Big (Double_Uns (D (1)))"}, {"sha": "25a18a417ed1ab2489140d872a06134cc5a686fb", "filename": "gcc/ada/libgnat/s-spark.ads", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spark.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spark.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-spark.ads?ref=40e01041b3593c72f3d52013953fbfbe0011abb8", "patch": "@@ -0,0 +1,36 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         S Y S T E M . S P A R K                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2022, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System.SPARK with\n+  SPARK_Mode,\n+  Pure\n+is\n+end System.SPARK;"}, {"sha": "d91f89750cd77b4dd3355b91dbc04c7148d357e7", "filename": "gcc/ada/libgnat/s-spcuop.adb", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spcuop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spcuop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-spcuop.adb?ref=40e01041b3593c72f3d52013953fbfbe0011abb8", "patch": "@@ -0,0 +1,42 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . S P A R K . C U T _ O P E R A T I O N S          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2022, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.SPARK.Cut_Operations with\n+  SPARK_Mode => Off\n+is\n+\n+   function By (Consequence, Premise : Boolean) return Boolean is\n+     (Premise and then Consequence);\n+\n+   function So (Premise, Consequence : Boolean) return Boolean is\n+     (Premise and then Consequence);\n+\n+end System.SPARK.Cut_Operations;"}, {"sha": "39a61c96af136368602d7489a245e98ed9c3fded", "filename": "gcc/ada/libgnat/s-spcuop.ads", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spcuop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e01041b3593c72f3d52013953fbfbe0011abb8/gcc%2Fada%2Flibgnat%2Fs-spcuop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-spcuop.ads?ref=40e01041b3593c72f3d52013953fbfbe0011abb8", "patch": "@@ -0,0 +1,59 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--           S Y S T E M . S P A R K . C U T _ O P E R A T I O N S          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2022, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  By and So are connectors used to manually help the proof of assertions by\n+--  introducing intermediate steps. They can only be used inside pragmas\n+--  Assert or Assert_And_Cut. They are handled in the following way:\n+--\n+--  *  If A and B are two boolean expressions, proving By (A, B) requires\n+--     proving B, the premise, and then A assuming B, the side-condition. When\n+--     By (A, B) is assumed on the other hand, we only assume A. B is used\n+--     for the proof, but is not visible afterward.\n+--\n+--  *  If A and B are two boolean expressions, proving So (A, B) requires\n+--     proving A, the premise, and then B assuming A, the side-condition. When\n+--     So (A, B) is assumed both A and B are assumed to be true.\n+\n+package System.SPARK.Cut_Operations with\n+  SPARK_Mode,\n+  Pure,\n+  Annotate => (GNATprove, Terminating)\n+is\n+\n+   function By (Consequence, Premise : Boolean) return Boolean with\n+     Ghost,\n+     Global => null;\n+\n+   function So (Premise, Consequence : Boolean) return Boolean with\n+     Ghost,\n+     Global => null;\n+\n+end System.SPARK.Cut_Operations;"}]}