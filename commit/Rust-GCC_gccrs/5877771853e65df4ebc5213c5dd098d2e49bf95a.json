{"sha": "5877771853e65df4ebc5213c5dd098d2e49bf95a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3Nzc3MTg1M2U2NWRmNGViYzUyMTNjNWRkMDk4ZDJlNDliZjk1YQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-08T04:30:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-08T04:30:48Z"}, "message": "expmed.c (add_cost, [...]): Make arrays indexed by machine mode.\n\n\n\t* expmed.c (add_cost, neg_cost, sdiv_pow2_cheap, smod_pow2_cheap):\n\tMake arrays indexed by machine mode.  Rename negate_cost to neg_cost.\n\t(init_expmed): Initialize these cost arrays as appropriate.\n\t(store_bit_field, extract_bit_field): Correct whitespace.\n\t(synth_mult, choose_mult_variant, expand_mult, expand_mult_highpart,\n\texpand_mult_highpart_optab, expand_divmod): Update uses of add_cost,\n\tneg_cost, sdiv_pow2_cheap, smod_pow2_cheap to index with mode,\n\tword_mode or compute_mode as appropriate.\n\nFrom-SVN: r82743", "tree": {"sha": "fa8c7b542da2f90c4e78015c04f02d97eafef476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa8c7b542da2f90c4e78015c04f02d97eafef476"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5877771853e65df4ebc5213c5dd098d2e49bf95a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877771853e65df4ebc5213c5dd098d2e49bf95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5877771853e65df4ebc5213c5dd098d2e49bf95a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877771853e65df4ebc5213c5dd098d2e49bf95a/comments", "author": null, "committer": null, "parents": [{"sha": "9221325f10a58e13a35dfac007c6b5c906760679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9221325f10a58e13a35dfac007c6b5c906760679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9221325f10a58e13a35dfac007c6b5c906760679"}], "stats": {"total": 185, "additions": 106, "deletions": 79}, "files": [{"sha": "355a54b2f2efe06cb5b32043f5fe7e63e37a1813", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5877771853e65df4ebc5213c5dd098d2e49bf95a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5877771853e65df4ebc5213c5dd098d2e49bf95a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5877771853e65df4ebc5213c5dd098d2e49bf95a", "patch": "@@ -1,3 +1,14 @@\n+2004-06-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (add_cost, neg_cost, sdiv_pow2_cheap, smod_pow2_cheap):\n+\tMake arrays indexed by machine mode.  Rename negate_cost to neg_cost.\n+\t(init_expmed): Initialize these cost arrays as appropriate.\n+\t(store_bit_field, extract_bit_field): Correct whitespace.\n+\t(synth_mult, choose_mult_variant, expand_mult, expand_mult_highpart,\n+\texpand_mult_highpart_optab, expand_divmod): Update uses of add_cost,\n+\tneg_cost, sdiv_pow2_cheap, smod_pow2_cheap to index with mode,\n+\tword_mode or compute_mode as appropriate.\n+\n 2004-06-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/15783"}, {"sha": "b6012721479d2ae0111aa74a005d72ae12b31603", "filename": "gcc/expmed.c", "status": "modified", "additions": 95, "deletions": 79, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5877771853e65df4ebc5213c5dd098d2e49bf95a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5877771853e65df4ebc5213c5dd098d2e49bf95a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5877771853e65df4ebc5213c5dd098d2e49bf95a", "patch": "@@ -57,7 +57,8 @@ static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx);\n    Usually, this will mean that the MD file will emit non-branch\n    sequences.  */\n \n-static int sdiv_pow2_cheap, smod_pow2_cheap;\n+static int sdiv_pow2_cheap[NUM_MACHINE_MODES];\n+static int smod_pow2_cheap[NUM_MACHINE_MODES];\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n@@ -90,7 +91,9 @@ static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n /* Cost of various pieces of RTL.  Note that some of these are indexed by\n    shift count and some by mode.  */\n-static int add_cost, negate_cost, zero_cost;\n+static int zero_cost;\n+static int add_cost[NUM_MACHINE_MODES];\n+static int neg_cost[NUM_MACHINE_MODES];\n static int shift_cost[MAX_BITS_PER_WORD];\n static int shiftadd_cost[MAX_BITS_PER_WORD];\n static int shiftsub_cost[MAX_BITS_PER_WORD];\n@@ -114,7 +117,6 @@ init_expmed (void)\n   reg = gen_rtx_REG (word_mode, 10000);\n \n   zero_cost = rtx_cost (const0_rtx, 0);\n-  add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n \n   shift_insn = emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t       gen_rtx_ASHIFT (word_mode, reg,\n@@ -136,52 +138,33 @@ init_expmed (void)\n \n   init_recog ();\n \n-  shift_cost[0] = 0;\n-  shiftadd_cost[0] = shiftsub_cost[0] = add_cost;\n-\n-  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n-    {\n-      rtx c_int = GEN_INT ((HOST_WIDE_INT) 1 << m);\n-      shift_cost[m] = shiftadd_cost[m] = shiftsub_cost[m] = 32000;\n-\n-      XEXP (SET_SRC (PATTERN (shift_insn)), 1) = GEN_INT (m);\n-      if (recog (PATTERN (shift_insn), shift_insn, &dummy) >= 0)\n-\tshift_cost[m] = rtx_cost (SET_SRC (PATTERN (shift_insn)), SET);\n-\n-      XEXP (XEXP (SET_SRC (PATTERN (shiftadd_insn)), 0), 1) = c_int;\n-      if (recog (PATTERN (shiftadd_insn), shiftadd_insn, &dummy) >= 0)\n-\tshiftadd_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftadd_insn)), SET);\n-\n-      XEXP (XEXP (SET_SRC (PATTERN (shiftsub_insn)), 0), 1) = c_int;\n-      if (recog (PATTERN (shiftsub_insn), shiftsub_insn, &dummy) >= 0)\n-\tshiftsub_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftsub_insn)), SET);\n-    }\n-\n-  negate_cost = rtx_cost (gen_rtx_NEG (word_mode, reg), SET);\n-\n-  sdiv_pow2_cheap\n-    = (rtx_cost (gen_rtx_DIV (word_mode, reg, GEN_INT (32)), SET)\n-       <= 2 * add_cost);\n-  smod_pow2_cheap\n-    = (rtx_cost (gen_rtx_MOD (word_mode, reg, GEN_INT (32)), SET)\n-       <= 2 * add_cost);\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n       reg = gen_rtx_REG (mode, 10000);\n-      div_cost[(int) mode] = rtx_cost (gen_rtx_UDIV (mode, reg, reg), SET);\n-      mul_cost[(int) mode] = rtx_cost (gen_rtx_MULT (mode, reg, reg), SET);\n+      add_cost[mode] = rtx_cost (gen_rtx_PLUS (mode, reg, reg), SET);\n+      neg_cost[mode] = rtx_cost (gen_rtx_NEG (mode, reg), SET);\n+      div_cost[mode] = rtx_cost (gen_rtx_UDIV (mode, reg, reg), SET);\n+      mul_cost[mode] = rtx_cost (gen_rtx_MULT (mode, reg, reg), SET);\n+\n+      sdiv_pow2_cheap[mode]\n+\t= (rtx_cost (gen_rtx_DIV (mode, reg, GEN_INT (32)), SET)\n+\t   <= 2 * add_cost[mode]);\n+      smod_pow2_cheap[mode]\n+\t= (rtx_cost (gen_rtx_MOD (mode, reg, GEN_INT (32)), SET)\n+\t   <= 2 * add_cost[mode]);\n+\n       wider_mode = GET_MODE_WIDER_MODE (mode);\n       if (wider_mode != VOIDmode)\n \t{\n-\t  mul_widen_cost[(int) wider_mode]\n+\t  mul_widen_cost[wider_mode]\n \t    = rtx_cost (gen_rtx_MULT (wider_mode,\n \t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg),\n \t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg)),\n \t\t\tSET);\n-\t  mul_highpart_cost[(int) mode]\n+\t  mul_highpart_cost[mode]\n \t    = rtx_cost (gen_rtx_TRUNCATE\n \t\t\t(mode,\n \t\t\t gen_rtx_LSHIFTRT (wider_mode,\n@@ -195,6 +178,27 @@ init_expmed (void)\n \t}\n     }\n \n+  shift_cost[0] = 0;\n+  shiftadd_cost[0] = shiftsub_cost[0] = add_cost[word_mode];\n+\n+  for (m = 1; m < MAX_BITS_PER_WORD; m++)\n+    {\n+      rtx c_int = GEN_INT ((HOST_WIDE_INT) 1 << m);\n+      shift_cost[m] = shiftadd_cost[m] = shiftsub_cost[m] = 32000;\n+\n+      XEXP (SET_SRC (PATTERN (shift_insn)), 1) = GEN_INT (m);\n+      if (recog (PATTERN (shift_insn), shift_insn, &dummy) >= 0)\n+\tshift_cost[m] = rtx_cost (SET_SRC (PATTERN (shift_insn)), SET);\n+\n+      XEXP (XEXP (SET_SRC (PATTERN (shiftadd_insn)), 0), 1) = c_int;\n+      if (recog (PATTERN (shiftadd_insn), shiftadd_insn, &dummy) >= 0)\n+\tshiftadd_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftadd_insn)), SET);\n+\n+      XEXP (XEXP (SET_SRC (PATTERN (shiftsub_insn)), 0), 1) = c_int;\n+      if (recog (PATTERN (shiftsub_insn), shiftsub_insn, &dummy) >= 0)\n+\tshiftsub_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftsub_insn)), SET);\n+    }\n+\n   end_sequence ();\n }\n \n@@ -317,15 +321,15 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && GET_CODE (op0) != MEM\n-      && (vec_set_optab->handlers[(int)GET_MODE (op0)].insn_code\n+      && (vec_set_optab->handlers[GET_MODE (op0)].insn_code\n \t  != CODE_FOR_nothing)\n       && fieldmode == GET_MODE_INNER (GET_MODE (op0))\n       && bitsize == GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n       && !(bitnum % GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) vec_set_optab->handlers[(int) outermode].insn_code;\n+      int icode = (int) vec_set_optab->handlers[outermode].insn_code;\n       int pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = value;\n@@ -451,10 +455,10 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (GET_CODE (op0) != MEM\n       && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (movstrict_optab->handlers[(int) fieldmode].insn_code\n+      && (movstrict_optab->handlers[fieldmode].insn_code\n \t  != CODE_FOR_nothing))\n     {\n-      int icode = movstrict_optab->handlers[(int) fieldmode].insn_code;\n+      int icode = movstrict_optab->handlers[fieldmode].insn_code;\n \n       /* Get appropriate low part of the value being stored.  */\n       if (GET_CODE (value) == CONST_INT || GET_CODE (value) == REG)\n@@ -1086,14 +1090,14 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && GET_CODE (op0) != MEM\n-      && (vec_extract_optab->handlers[(int)GET_MODE (op0)].insn_code\n+      && (vec_extract_optab->handlers[GET_MODE (op0)].insn_code\n \t  != CODE_FOR_nothing)\n       && ((bitsize + bitnum) / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n \t  == bitsize / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n     {\n       enum machine_mode outermode = GET_MODE (op0);\n       enum machine_mode innermode = GET_MODE_INNER (outermode);\n-      int icode = (int) vec_extract_optab->handlers[(int) outermode].insn_code;\n+      int icode = (int) vec_extract_optab->handlers[outermode].insn_code;\n       int pos = bitnum / GET_MODE_BITSIZE (innermode);\n       rtx rtxpos = GEN_INT (pos);\n       rtx src = op0;\n@@ -2255,7 +2259,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n \n-\t  cost = add_cost;\n+\t  cost = add_cost[word_mode];\n \t  synth_mult (alg_in, t + 1, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n@@ -2272,7 +2276,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t{\n \t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-\t  cost = add_cost;\n+\t  cost = add_cost[word_mode];\n \t  synth_mult (alg_in, t - 1, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n@@ -2304,7 +2308,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n+\t  cost = add_cost[word_mode] + shift_cost[m];\n+\t  if (shiftadd_cost[m] < cost)\n+\t    cost = shiftadd_cost[m];\n \t  synth_mult (alg_in, t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n@@ -2323,7 +2329,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d && m < BITS_PER_WORD)\n \t{\n-\t  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);\n+\t  cost = add_cost[word_mode] + shift_cost[m];\n+\t  if (shiftsub_cost[m] < cost)\n+\t    cost = shiftsub_cost[m];\n \t  synth_mult (alg_in, t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n@@ -2427,15 +2435,17 @@ choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n      `unsigned int' */\n   if (HOST_BITS_PER_INT >= GET_MODE_BITSIZE (mode))\n     {\n-      synth_mult (&alg2, -val, MIN (alg->cost, mult_cost) - negate_cost);\n-      alg2.cost += negate_cost;\n+      synth_mult (&alg2, -val, MIN (alg->cost, mult_cost)\n+\t\t\t       - neg_cost[mode]);\n+      alg2.cost += neg_cost[mode];\n       if (alg2.cost < alg->cost)\n \t*alg = alg2, *variant = negate_variant;\n     }\n \n   /* This proves very useful for division-by-constant.  */\n-  synth_mult (&alg2, val - 1, MIN (alg->cost, mult_cost) - add_cost);\n-  alg2.cost += add_cost;\n+  synth_mult (&alg2, val - 1, MIN (alg->cost, mult_cost)\n+\t\t\t      - add_cost[mode]);\n+  alg2.cost += add_cost[mode];\n   if (alg2.cost < alg->cost)\n     *alg = alg2, *variant = add_variant;\n \n@@ -2633,7 +2643,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n       && (unsignedp || !flag_trapv))\n     {\n       int mult_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET);\n-      mult_cost = MIN (12 * add_cost, mult_cost);\n+      mult_cost = MIN (12 * add_cost[mode], mult_cost);\n \n       if (choose_mult_variant (mode, INTVAL (const_op1), &algorithm, &variant,\n \t\t\t       mult_cost))\n@@ -2887,7 +2897,7 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n      high part of the product, and in the sign flavor of unsignedp.  */\n-  if (mul_highpart_cost[(int) mode] < max_cost)\n+  if (mul_highpart_cost[mode] < max_cost)\n     {\n       moptab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -2899,8 +2909,8 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n   if (size - 1 < BITS_PER_WORD\n-      && (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost\n-\t  < max_cost))\n+      && (mul_highpart_cost[mode] + 2 * shift_cost[size-1]\n+\t  + 4 * add_cost[mode] < max_cost))\n     {\n       moptab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n       tem = expand_binop (mode, moptab, op0, narrow_op1, target,\n@@ -2913,8 +2923,8 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n-  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n-      && mul_widen_cost[(int) wider_mode] < max_cost)\n+  if (moptab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n+      && mul_widen_cost[wider_mode] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1, 0,\n \t\t\t  unsignedp, OPTAB_WIDEN);\n@@ -2924,9 +2934,9 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening the mode and perform a non-widening multiplication.  */\n   moptab = smul_optab;\n-  if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+  if (smul_optab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)\n+      && mul_cost[wider_mode] + shift_cost[size-1] < max_cost)\n     {\n       tem = expand_binop (wider_mode, moptab, op0, op1, 0,\n \t\t\t  unsignedp, OPTAB_WIDEN);\n@@ -2936,10 +2946,10 @@ expand_mult_highpart_optab (enum machine_mode mode, rtx op0, rtx op1,\n \n   /* Try widening multiplication of opposite signedness, and adjust.  */\n   moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n-  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+  if (moptab->handlers[wider_mode].insn_code != CODE_FOR_nothing\n       && size - 1 < BITS_PER_WORD\n-      && (mul_widen_cost[(int) wider_mode]\n-\t  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))\n+      && (mul_widen_cost[wider_mode] + 2 * shift_cost[size-1]\n+\t  + 4 * add_cost[mode] < max_cost))\n     {\n       tem = expand_binop (wider_mode, moptab, op0, narrow_op1,\n \t\t\t  NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n@@ -2998,7 +3008,7 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n   if (!unsignedp && ((cnst1 >> (GET_MODE_BITSIZE (mode) - 1)) & 1))\n     {\n       sign_adjust = true;\n-      extra_cost += add_cost;\n+      extra_cost += add_cost[mode];\n     }\n \n   /* See whether shift/add multiplication is cheap enough.  */\n@@ -3179,15 +3189,15 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n        compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-    if (optab1->handlers[(int) compute_mode].insn_code != CODE_FOR_nothing\n-\t|| optab2->handlers[(int) compute_mode].insn_code != CODE_FOR_nothing)\n+    if (optab1->handlers[compute_mode].insn_code != CODE_FOR_nothing\n+\t|| optab2->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n       break;\n \n   if (compute_mode == VOIDmode)\n     for (compute_mode = mode; compute_mode != VOIDmode;\n \t compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n-      if (optab1->handlers[(int) compute_mode].libfunc\n-\t  || optab2->handlers[(int) compute_mode].libfunc)\n+      if (optab1->handlers[compute_mode].libfunc\n+\t  || optab2->handlers[compute_mode].libfunc)\n \tbreak;\n \n   /* If we still couldn't find a mode, use MODE, but we'll probably abort\n@@ -3211,10 +3221,11 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n   /* Only deduct something for a REM if the last divide done was\n      for a different constant.   Then set the constant of the last\n      divide.  */\n-  max_cost = div_cost[(int) compute_mode]\n+  max_cost = div_cost[compute_mode]\n     - (rem_flag && ! (last_div_const != 0 && op1_is_constant\n \t\t      && INTVAL (op1) == last_div_const)\n-       ? mul_cost[(int) compute_mode] + add_cost : 0);\n+       ? mul_cost[compute_mode] + add_cost[compute_mode]\n+       : 0);\n \n   last_div_const = ! rem_flag && op1_is_constant ? INTVAL (op1) : 0;\n \n@@ -3332,7 +3343,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t      goto fail1;\n \n \t\t\t    extra_cost = (shift_cost[post_shift - 1]\n-\t\t\t\t\t  + shift_cost[1] + 2 * add_cost);\n+\t\t\t\t\t  + shift_cost[1]\n+\t\t\t\t\t  + 2 * add_cost[compute_mode]);\n \t\t\t    t1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t       NULL_RTX, 1,\n \t\t\t\t\t\t       max_cost - extra_cost);\n@@ -3415,15 +3427,16 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t      goto fail1;\n \t\t  }\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n-\t\t\t && (rem_flag ? smod_pow2_cheap : sdiv_pow2_cheap)\n+\t\t\t && (rem_flag ? smod_pow2_cheap[compute_mode]\n+\t\t\t\t      : sdiv_pow2_cheap[compute_mode])\n \t\t\t /* ??? The cheap metric is computed only for\n \t\t\t    word_mode.  If this operation is wider, this may\n \t\t\t    not be so.  Assume true if the optab has an\n \t\t\t    expander for this mode.  */\n \t\t\t && (((rem_flag ? smod_optab : sdiv_optab)\n-\t\t\t      ->handlers[(int) compute_mode].insn_code\n+\t\t\t      ->handlers[compute_mode].insn_code\n \t\t\t      != CODE_FOR_nothing)\n-\t\t\t     || (sdivmod_optab->handlers[(int) compute_mode]\n+\t\t\t     || (sdivmod_optab->handlers[compute_mode]\n \t\t\t\t .insn_code != CODE_FOR_nothing)))\n \t\t  ;\n \t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n@@ -3497,7 +3510,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  goto fail1;\n \n \t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1] + add_cost);\n+\t\t\t\t      + shift_cost[size - 1]\n+\t\t\t\t      + add_cost[compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -3528,7 +3542,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n \t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1] + 2 * add_cost);\n+\t\t\t\t      + shift_cost[size - 1]\n+\t\t\t\t      + 2 * add_cost[compute_mode]);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n \t\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -3618,7 +3633,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \t\t\textra_cost = (shift_cost[post_shift]\n-\t\t\t\t      + shift_cost[size - 1] + 2 * add_cost);\n+\t\t\t\t      + shift_cost[size - 1]\n+\t\t\t\t      + 2 * add_cost[compute_mode]);\n \t\t\tt3 = expand_mult_highpart (compute_mode, t2, ml,\n \t\t\t\t\t\t   NULL_RTX, 1,\n \t\t\t\t\t\t   max_cost - extra_cost);\n@@ -4079,7 +4095,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n \t\t\t\t op0, op1, target,\n \t\t\t\t unsignedp,\n-\t\t\t\t ((optab2->handlers[(int) compute_mode].insn_code\n+\t\t\t\t ((optab2->handlers[compute_mode].insn_code\n \t\t\t\t   != CODE_FOR_nothing)\n \t\t\t\t  ? OPTAB_DIRECT : OPTAB_WIDEN));\n \t  if (remainder == 0)\n@@ -4107,7 +4123,7 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t= sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n \t\t\t     op0, op1, rem_flag ? NULL_RTX : target,\n \t\t\t     unsignedp,\n-\t\t\t     ((optab2->handlers[(int) compute_mode].insn_code\n+\t\t\t     ((optab2->handlers[compute_mode].insn_code\n \t\t\t       != CODE_FOR_nothing)\n \t\t\t      ? OPTAB_DIRECT : OPTAB_WIDEN));\n \n@@ -4751,9 +4767,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t that is compensated by the subsequent overflow when subtracting\n \t one / negating.  */\n \n-      if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+      if (abs_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, abs_optab, op0, subtarget, 1);\n-      else if (ffs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+      else if (ffs_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, ffs_optab, op0, subtarget, 1);\n       else if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{"}]}