{"sha": "9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwZDFlMWIxMWZjOGE3ZmQ0MWYwMzhkN2IyNDNiNmQyNTczZWQ2NA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-05-14T13:39:15Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-05-14T13:39:15Z"}, "message": "First cut of changes to utilize the new exception handling model\n\nFrom-SVN: r19746", "tree": {"sha": "210e41e74a68a515399d6c03258a484e02563706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/210e41e74a68a515399d6c03258a484e02563706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/comments", "author": null, "committer": null, "parents": [{"sha": "2129b0816f369ee6bf172e7065b0de137ac9c7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2129b0816f369ee6bf172e7065b0de137ac9c7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2129b0816f369ee6bf172e7065b0de137ac9c7f7"}], "stats": {"total": 1173, "additions": 960, "deletions": 213}, "files": [{"sha": "1f14869dce3eea6ddc5f19044ac8712fa2cfc448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -1,3 +1,65 @@\n+Thu May 14 16:30:47 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* eh-common.h: New file for basic EH data structures.\n+\t* except.h: Various prototypes and structures for NEW_EH_MODEL\n+\t* function.h (struct function): Add a struct eh_stack for the catch\n+\tclause stack.\n+\t* except.c (gen_exception_label): New function to generate an \n+\texception label.\n+\t(push_eh_entry): Use gen_exception_label() and init 'label_used' field.\n+\t(push_entry): New function to push an existing entry onto a stack.\n+\t(receive_exception_label): New function to emit the code required \n+\tat the start of all catch blocks.\n+\t(struct func_eh_entry): New structure for maintaining handlers\n+\tassociated with EH regions.\n+\t(new_eh_region_entry): New function to register an EH region.\n+\t(add_new_handler): New function to register a handler with a region.\n+\t(get_new_handler): Creates  anew handler entry for registering.\n+\t(find_func_region): New function to convert a NOTE eh region number\n+\tto an Eh region index.\n+\t(get_first_handler): New function to get the first handler in a region.\n+\t(clear_function_eh_region): New function to release memory.\n+\t(duplicate_handlers): New function to duplicate a list of handlers.\n+\t(expand_eh_region_end): Create a new region entry node as well.\n+\t(expand_leftover_cleanups): Call receive_exception_label() and\n+\tregister the cleanup as a handler to the current region.\n+\t(expand_start_catch): New function to start a catch clause.\n+\t(expand_end_catch): New function to end a catch clause.\n+\t(expand_start_all_catch): restructure to not do the equivilent of\n+\twhat expand_start_catch() does now. Push the exception region being\n+\thandled onto the catch stack.\n+\t(output_exception_table_entry): Issue an entry for each handler\n+\tassociated with a region.\n+\t(set_exception_lang_code): New function for setting the language code.\n+\t(set_exception_version_code): New function to set the version number.\n+\t(output_exception_table): Output version and language codes.\n+\t(find_exception_handler_labels): Find handler labels using new scheme.\n+\t(is_exception_handler_label): New function, returns 1 if label is\n+\tpresent as a handler in some exception region.\n+\t(check_exception_handler_labels): Use the new scheme.\n+\t(init_eh_for_function): Initialize the catch stack.\n+\t(save_eh_status): Save the catch stack.\n+\t(restore_eh_status): Restore the catch stack.\n+\t(scan_region): Don't remove unreferenced handler label. Flow does it.\n+\t(get_reg_for_handler): New function to get the eh_context pointer\n+\tpassed by __throw.\n+\t(expand_builtin_eh_stub): Changes required for NEW_EH_MODEL only.\n+\t* final.c (final_scan_insn): With NEW_EH_MODEL, add EH table\n+\tentry when processing END region rather that START region.\n+\t* flow.c (find_basic_blocks_1): Find all potential handler regions\n+\tnow that we don't automatically know what the labels might be.\n+\tLet scan_region() remove unreferenced EH BEGIN/END labels.\n+\t* integrate.c (get_label_from_map): Put inlined labels onto the\n+\tpermanent obstack since we dont know which ones might be exception\n+\tlabels.\n+\t(save_for_inline_copying): Make new copies of all the handlers.\n+\t(expand_inline_function): Make new copies of all the handlers.\n+\t* libgcc2.c: Remove local struct decls, and include eh-common.h.\n+\t(find_exception_handler): With NEW_EH_MODEL the first matching \n+\tregion we find is the right one. Add eh_info as a new parameter.\n+\t(__throw): Pass eh_info to find_exception_handler. Set handler\n+\tand pass use different regs  under NEW_EH_MODEL.\n+\n Thu May 14 12:58:21 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* i960.h (hard_regno_mode_ok): Changed to function from array of"}, {"sha": "ae3695b0b6f61eb729a9d8d4e06777c00aee7a03", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -1,3 +1,19 @@\n+Thu May 14 16:30:47 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* exception.cc: Include eh-common.h.\n+\t(struct cp_eh_info): add eh_info struct with NEW_EH_MODEL.\n+\t(__cplus_type_matcher): First stab at new C++ runtime type matcher.\n+\t(__cp_push_exception): Initialize eh_info struct as well.\n+\t* except.c: Remove local structs and include eh-common.h.\n+\t(init_exception_processing): Set language and version codes.\n+\t(call_eh_info): add presence of eh_info to runtime description of \n+\tstruct cp_eh_info.\n+\t(expand_end_eh_spec): call start_catch_block() and end_catch_block().\n+\t* semantics.c (finish_try_block): call start_catch_block() and \n+\tend_catch_block().\n+\t* parse.y (function_try_block): call start_catch_block() and \n+\tend_catch_block().\n+\n Thu May 14 12:27:34 1998  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* typeck.c (original_type): New function."}, {"sha": "5b6831471a54006f2f339e3f362a5a05250ecd26", "filename": "gcc/cp/except.c", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"defaults.h\"\n #include \"toplev.h\"\n+#include \"eh-common.h\"\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \n@@ -65,14 +66,6 @@ static tree do_pop_exception PROTO((void));\n #define EXCEPT_SECTION_ASM_OP\t\"section\\t.gcc_except_table,\\\"a\\\",@progbits\"\n #endif\n \n-#ifdef EXCEPT_SECTION_ASM_OP\n-typedef struct {\n-    void *start_region;\n-    void *end_region;\n-    void *exception_handler;\n- } exception_table;\n-#endif /* EXCEPT_SECTION_ASM_OP */\n-\n #ifdef EXCEPT_SECTION_ASM_OP\n \n  /* on machines which support it, the exception table lives in another section,\n@@ -227,6 +220,11 @@ init_exception_processing ()\n \n   push_lang_context (lang_name_c);\n \n+#ifdef NEW_EH_MODEL\n+  set_exception_lang_code (EH_LANG_C_plus_plus);\n+  set_exception_version_code (1);\n+#endif\n+\n   CatchMatch\n     = builtin_function (flag_rtti\n \t\t\t? \"__throw_type_match_rtti\"\n@@ -269,7 +267,8 @@ call_eh_info ()\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      tree t, fields[6];\n+      tree t1,t, fields[7];\n+      int fo = 0;\n \n       /* Declare cp_eh_info * __cp_exception_info (void),\n \t as defined in exception.cc. */\n@@ -278,25 +277,56 @@ call_eh_info ()\n \n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n+#ifdef NEW_EH_MODEL\n+      t1= make_lang_type (RECORD_TYPE);\n+      fields[0] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"handler_label\"), ptr_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"dynamic_handler_chain\"), ptr_type_node);\n+      fields[2] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"info\"), ptr_type_node);\n+      /* N.B.: The fourth field LEN is expected to be\n+\t the number of fields - 1, not the total number of fields.  */\n+      finish_builtin_type (t1, \"eh_context\", fields, 2, ptr_type_node);\n+      t1 = build_pointer_type (t1);\n+\n+      t1= make_lang_type (RECORD_TYPE);\n+      fields[0] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"match_function\"), ptr_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"coerced_value\"), ptr_type_node);\n+      fields[2] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"language\"), short_integer_type_node);\n+      fields[3] = build_lang_field_decl (FIELD_DECL, \n+                    get_identifier (\"version\"), short_integer_type_node);\n+      /* N.B.: The fourth field LEN is expected to be\n+\t the number of fields - 1, not the total number of fields.  */\n+      finish_builtin_type (t1, \"__eh_info\", fields, 3, ptr_type_node);\n+      fo = 1;\n+#endif\n       t = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n+#ifdef NEW_EH_MODEL\n+      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"eh_info\"),\n+\t\t\t\t\t t1);\n+#endif\n+      fields[0+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n \t\t\t\t\t ptr_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n+      fields[1+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n \t\t\t\t\t ptr_type_node);\n-      fields[2] = build_lang_field_decl\n+      fields[2+fo] = build_lang_field_decl\n \t(FIELD_DECL, get_identifier (\"cleanup\"),\n \t build_pointer_type (build_function_type\n \t\t\t     (ptr_type_node, tree_cons\n \t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n-      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n+      fields[3+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n \t\t\t\t\t boolean_type_node);\n-      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n+      fields[4+fo] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n \t\t\t\t\t build_pointer_type (t));\n-      fields[5] = build_lang_field_decl\n+      fields[5+fo] = build_lang_field_decl\n \t(FIELD_DECL, get_identifier (\"handlers\"), long_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n-      finish_builtin_type (t, \"cp_eh_info\", fields, 5, ptr_type_node);\n+      finish_builtin_type (t, \"cp_eh_info\", fields, 5+fo, ptr_type_node);\n       t = build_pointer_type (t);\n \n       /* And now the function.  */\n@@ -681,6 +711,7 @@ expand_end_eh_spec (raises)\n   int count = 0;\n \n   expand_start_all_catch ();\n+  expand_start_catch (NULL);\n   expand_start_catch_block (NULL_TREE, NULL_TREE);\n \n   /* Build up an array of type_infos.  */\n@@ -733,6 +764,7 @@ expand_end_eh_spec (raises)\n   expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   expand_end_catch_block ();\n+  expand_end_catch ();\n   expand_end_all_catch ();\n }\n "}, {"sha": "461dba40c34d708cad983462f426be73fdcfdc55", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -30,6 +30,7 @@\n #include \"typeinfo\"\n #include \"exception\"\n #include <stddef.h>\n+#include \"eh-common.h\"\n \n /* Define terminate, unexpected, set_terminate, set_unexpected as\n    well as the default terminate func and default unexpected func.  */\n@@ -85,6 +86,9 @@ std::unexpected ()\n \n struct cp_eh_info\n {\n+#ifdef NEW_EH_MODEL\n+  __eh_info eh_info;\n+#endif\n   void *value;\n   void *type;\n   void (*cleanup)(void *, int);\n@@ -133,6 +137,29 @@ __eh_free (void *p)\n   free (p);\n }\n \n+\n+#ifdef NEW_EH_MODEL\n+\n+typedef void * (* rtimetype) (void);\n+\n+extern \"C\" void *\n+__cplus_type_matcher (cp_eh_info *info, exception_table *matching_info, \n+                                 exception_descriptor *exception_table)\n+{\n+  void *ret;\n+\n+  if (exception_table->lang.language != EH_LANG_C_plus_plus)\n+    return NULL;\n+\n+  /* we don't worry about version info yet, there is only one version! */\n+  \n+  void *match_type = ((rtimetype) (matching_info->match_info)) ();\n+  ret = __throw_type_match_rtti (match_type, info->type, info->value);\n+  return ret;\n+}\n+#endif\n+\n+\n /* Compiler hook to push a new exception onto the stack.\n    Used by expand_throw().  */\n \n@@ -147,6 +174,13 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n   p->handlers = 0;\n   p->caught = false;\n \n+#ifdef NEW_EH_MODEL\n+  p->eh_info.match_function = __cplus_type_matcher;\n+  p->eh_info.language = EH_LANG_C_plus_plus;\n+  p->eh_info.version = 1;\n+  p->eh_info.coerced_value = NULL;\n+#endif\n+\n   cp_eh_info **q = __get_eh_info ();\n \n   p->next = *q;"}, {"sha": "9bdc979df7f0bdbac42302957934fe9788111d0d", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -3222,12 +3222,16 @@ function_try_block:\n \t\t  expand_start_early_try_stmts ();\n \t\t}\n \t  ctor_initializer_opt compstmt\n-\t\t{ expand_start_all_catch (); }\n+\t\t{ \n+                  expand_start_all_catch (); \n+                  expand_start_catch (NULL);\n+                }\n \t  handler_seq\n \t\t{\n \t\t  int nested = (hack_decl_function_context\n \t\t\t\t(current_function_decl) != NULL_TREE);\n \t\t  expand_end_all_catch ();\n+                  expand_end_catch ();\n \t\t  finish_function (lineno, (int)$3, nested);\n \t\t}\n \t;"}, {"sha": "25016423365ca2464dbe947a27c3736a203cf7db", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -587,7 +587,10 @@ finish_try_block (try_block)\n   if (processing_template_decl)\n     RECHAIN_STMTS_FROM_LAST (try_block, TRY_STMTS (try_block));\n   else\n-    expand_start_all_catch ();  \n+    {\n+      expand_start_all_catch ();  \n+      expand_start_catch (NULL);\n+    }\n }\n \n /* Finish a handler-sequence for a try-block, which may be given by\n@@ -600,7 +603,10 @@ finish_handler_sequence (try_block)\n   if (processing_template_decl)\n     RECHAIN_STMTS_FROM_CHAIN (try_block, TRY_HANDLERS (try_block));\n   else\n-    expand_end_all_catch ();\n+    {\n+      expand_end_catch ();\n+      expand_end_all_catch ();\n+    }\n }\n \n /* Begin a handler.  Returns a HANDLER if appropriate.  */"}, {"sha": "708946b412a41b73b319cb4039ec40e9b459ccab", "filename": "gcc/eh-common.h", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -0,0 +1,133 @@\n+/* Copyright (C) 1997 Free Software Foundation, Inc.\n+   This file is part of GNU CC.  */\n+\n+/* This file contains the structures required for the language\n+   independant exception handling model. Both the static compiler and\n+   the runtime library share this file. */\n+\n+/* The compiler flag NEW_EH_MODEL is used to determine whether the \n+   compiler supports the new runtime typechecking mechanism or not. Under\n+   the new model, runtime info is contained in the exception table, and\n+   the __throw() library routine determines which handler to call based\n+   on the results of a call to a matching function provided by the expcetion\n+   thrower.  Otherwise the old scheme of calling any handler which matches\n+   an exception range is used, and the handler is responsible for all\n+   checking of runtime conditions. If the handler wasn't suppose to\n+   get the exception, it performs a re-throw. */\n+\n+#include \"gansidecl.h\"\n+\n+\n+#ifndef NEW_EH_MODEL\n+\n+struct eh_context\n+{\n+  void **dynamic_handler_chain;\n+  /* This is language dependent part of the eh context. */\n+  void *info;\n+};\n+\n+#else\n+\n+/* The handler_label field MUST be the first field in this structure. The \n+   __throw()  library routine expects uses __eh_stub() from except.c, which\n+   simply dereferences the context pointer to get the handler */\n+\n+struct eh_context\n+{\n+  void *handler_label;\n+  void **dynamic_handler_chain;\n+  /* This is language dependent part of the eh context. */\n+  void *info;\n+};\n+\n+#endif\n+\n+\n+#ifndef EH_TABLE_LOOKUP\n+\n+#ifndef NEW_EH_MODEL\n+\n+typedef struct exception_table \n+{\n+  void *start_region;\n+  void *end_region;\n+  void *exception_handler;\n+} exception_table;\n+\n+typedef exception_table exception_descriptor;\n+\n+#else\n+\n+typedef struct exception_table \n+{\n+  void *start_region;\n+  void *end_region;\n+  void *exception_handler;\n+  void *match_info;              /* runtime type info */\n+} exception_table;\n+\n+\n+/* The language identifying portion of an exception table */\n+\n+typedef struct exception_lang_info \n+{\n+  short language;\n+  short version;  \n+} exception_lang_info;\n+\n+/* Each function has an exception_descriptor which contains the\n+   language info, and a table of exception ranges and handlers */\n+\n+typedef struct exception_descriptor \n+{\n+  exception_lang_info lang;\n+  exception_table table[1];\n+} exception_descriptor;\n+\n+\n+/* A pointer to a matching function is initialized at runtime by the \n+   specific language if run-time exceptions are supported. \n+   The function takes 3 parameters\n+    1 - runtime exception that has been thrown info. (__eh_info *)\n+    2 - Match info pointer from the region being considered (void *)\n+    3 - exception table region is in (exception descriptor *)\n+*/\n+\n+typedef void * (*__eh_matcher)          PROTO ((void *, void *, void *));\n+\n+/* This is the runtime exception information. This forms the minimum required\n+   information for an exception info pointer in an eh_context structure. */\n+\n+typedef struct __eh_info \n+{\n+  __eh_matcher match_function;\n+  void *coerced_value;\n+  short language;\n+  short version;\n+} __eh_info;\n+\n+/* Convienient language codes for ID the originating language. Similar\n+   to the codes in dwarf2.h. */\n+\n+enum exception_source_language\n+  {\n+    EH_LANG_C89 = 0x0001,\n+    EH_LANG_C = 0x0002,\n+    EH_LANG_Ada83 = 0x0003,\n+    EH_LANG_C_plus_plus = 0x0004,\n+    EH_LANG_Cobol74 = 0x0005,\n+    EH_LANG_Cobol85 = 0x0006,\n+    EH_LANG_Fortran77 = 0x0007,\n+    EH_LANG_Fortran90 = 0x0008,\n+    EH_LANG_Pascal83 = 0x0009,\n+    EH_LANG_Modula2 = 0x000a,\n+    EH_LANG_Java = 0x000b,\n+    EH_LANG_Mips_Assembler = 0x8001\n+  };\n+\n+#endif\n+\n+#endif  /* EH_TABLE_LOOKUP */\n+\n+"}, {"sha": "a2213a8e60209bffd7cecce51393eeca11df3791", "filename": "gcc/except.c", "status": "modified", "additions": 422, "deletions": 140, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -390,6 +390,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"defaults.h\"\n+#include \"eh-common.h\"\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n@@ -442,6 +443,12 @@ rtx current_function_ehc;\n \n static struct eh_stack ehstack;\n \n+\n+/* This stack is used to represent what the current eh region is\n+   for the catch blocks beings processed */\n+\n+static struct eh_stack catchstack;\n+\n /* A queue used for tracking which exception regions have closed but\n    whose handlers have not yet been expanded. Regions are emitted in\n    groups in an attempt to improve paging performance.\n@@ -553,6 +560,20 @@ top_label_entry (stack)\n   return (*stack)->u.tlabel;\n }\n \n+/* get an exception label. These must be on the permanent obstack */\n+\n+rtx\n+gen_exception_label ()\n+{\n+  rtx lab;\n+\n+  push_obstacks_nochange ();\n+  end_temporary_allocation ();\n+  lab = gen_label_rtx ();\n+  pop_obstacks ();\n+  return lab;\n+}\n+\n /* Push a new eh_node entry onto STACK.  */\n \n static void\n@@ -563,9 +584,22 @@ push_eh_entry (stack)\n   struct eh_entry *entry = (struct eh_entry *) xmalloc (sizeof (struct eh_entry));\n \n   entry->outer_context = gen_label_rtx ();\n-  entry->exception_handler_label = gen_label_rtx ();\n   entry->finalization = NULL_TREE;\n+  entry->label_used = 0;\n+  entry->exception_handler_label = gen_exception_label ();\n+\n+  node->entry = entry;\n+  node->chain = stack->top;\n+  stack->top = node;\n+}\n \n+/* push an existing entry onto a stack. */\n+static void\n+push_entry (stack, entry)\n+     struct eh_stack *stack;\n+     struct eh_entry *entry;\n+{\n+  struct eh_node *node = (struct eh_node *) xmalloc (sizeof (struct eh_node));\n   node->entry = entry;\n   node->chain = stack->top;\n   stack->top = node;\n@@ -631,6 +665,185 @@ dequeue_eh_entry (queue)\n \n   return tempentry;\n }\n+\n+static void\n+receive_exception_label (handler_label)\n+     rtx handler_label;\n+{\n+  emit_label (handler_label);\n+  \n+#ifdef HAVE_exception_receiver\n+  if (! exceptions_via_longjmp)\n+    if (HAVE_exception_receiver)\n+      emit_insn (gen_exception_receiver ());\n+#endif\n+\n+#ifdef HAVE_nonlocal_goto_receiver\n+  if (! exceptions_via_longjmp)\n+    if (HAVE_nonlocal_goto_receiver)\n+      emit_insn (gen_nonlocal_goto_receiver ());\n+#endif\n+}\n+\n+\n+struct func_eh_entry \n+{\n+  int range_number;   /* EH region number from EH NOTE insn's */\n+  struct handler_info *handlers;\n+};\n+\n+\n+/* table of function eh regions */\n+static struct func_eh_entry *function_eh_regions = NULL;\n+static int num_func_eh_entries = 0;\n+static int current_func_eh_entry = 0;\n+\n+#define SIZE_FUNC_EH(X)   (sizeof (struct func_eh_entry) * X)\n+\n+/* Add a new eh_entry for this function, and base it off of the information\n+   in the EH_ENTRY parameter. A NULL parameter is invalid. The number\n+   returned is an number which uniquely identifies this exception range. */\n+\n+int \n+new_eh_region_entry (note_eh_region) \n+     int note_eh_region;\n+{\n+  if (current_func_eh_entry == num_func_eh_entries) \n+    {\n+      if (num_func_eh_entries == 0)\n+        {\n+          function_eh_regions = \n+                        (struct func_eh_entry *) malloc (SIZE_FUNC_EH (50));\n+          num_func_eh_entries = 50;\n+        }\n+      else\n+        {\n+          num_func_eh_entries  = num_func_eh_entries * 3 / 2;\n+          function_eh_regions = (struct func_eh_entry *) \n+            realloc (function_eh_regions, SIZE_FUNC_EH (num_func_eh_entries));\n+        }\n+    }\n+  function_eh_regions[current_func_eh_entry].range_number = note_eh_region;\n+  function_eh_regions[current_func_eh_entry].handlers = NULL;\n+\n+  return current_func_eh_entry++;\n+}\n+\n+/* Add new handler information to an exception range. The  first parameter\n+   specifies the range number (returned from new_eh_entry()). The second\n+   parameter specifies the handler.  By default the handler is inserted at\n+   the end of the list. A handler list may contain only ONE NULL_TREE\n+   typeinfo entry. Regardless where it is positioned, a NULL_TREE entry\n+   is always output as the LAST handler in the exception table for a region. */\n+\n+void \n+add_new_handler (region, newhandler)\n+     int region;\n+     struct handler_info *newhandler;\n+{\n+  struct handler_info *last;\n+\n+  newhandler->next = NULL;\n+  last = function_eh_regions[region].handlers;\n+  if (last == NULL)\n+    function_eh_regions[region].handlers = newhandler;\n+  else \n+    {\n+      for ( ; last->next != NULL; last = last->next)\n+        last->next = newhandler;\n+    }\n+}\n+\n+/* Create a new handler structure initialized with the handler label and\n+   typeinfo fields passed in. */\n+\n+struct handler_info *\n+get_new_handler (handler, typeinfo)\n+     rtx handler;\n+     void *typeinfo;\n+{\n+  struct handler_info* ptr;\n+  ptr = (struct handler_info *) malloc (sizeof (struct handler_info));\n+  ptr->handler_label = handler;\n+  ptr->type_info = typeinfo;\n+  ptr->next = NULL;\n+\n+  return ptr;\n+}\n+\n+\n+\n+/* Find the index in function_eh_regions associated with a NOTE region. If\n+   the region cannot be found, a -1 is returned. This should never happen! */\n+\n+int \n+find_func_region (insn_region)\n+     int insn_region;\n+{\n+  int x;\n+  for (x = 0; x < current_func_eh_entry; x++)\n+    if (function_eh_regions[x].range_number == insn_region)\n+      return x;\n+\n+  return -1;\n+}\n+\n+/* Get a pointer to the first handler in an exception region's list. */\n+\n+struct handler_info *\n+get_first_handler (region)\n+     int region;\n+{\n+  return function_eh_regions[find_func_region (region)].handlers;\n+}\n+\n+/* Clean out the function_eh_region table and free all memory */\n+\n+static void\n+clear_function_eh_region ()\n+{\n+  int x;\n+  struct handler_info *ptr, *next;\n+  for (x = 0; x < current_func_eh_entry; x++)\n+    for (ptr = function_eh_regions[x].handlers; ptr != NULL; ptr = next)\n+      {\n+        next = ptr->next;\n+        free (ptr);\n+      }\n+  free (function_eh_regions);\n+  num_func_eh_entries  = 0;\n+  current_func_eh_entry = 0;\n+}\n+\n+/* Make a duplicate of an exception region by copying all the handlers\n+   for an exception region. Return the new handler index. */\n+\n+int \n+duplicate_handlers (old_note_eh_region, new_note_eh_region)\n+     int old_note_eh_region, new_note_eh_region;\n+{\n+  struct handler_info *ptr, *new_ptr;\n+  int new_region, region;\n+\n+  region = find_func_region (old_note_eh_region);\n+  if (region == -1)\n+    error (\"Cannot duplicate non-existant exception region.\");\n+\n+  if (find_func_region (new_note_eh_region) != -1)\n+    error (\"Cannot duplicate EH region because new note region already exists\");\n+\n+  new_region = new_eh_region_entry (new_note_eh_region);\n+  ptr = function_eh_regions[region].handlers;\n+\n+  for ( ; ptr; ptr = ptr->next) \n+    {\n+      new_ptr = get_new_handler (ptr->handler_label, ptr->type_info);\n+      add_new_handler (new_region, new_ptr);\n+    }\n+\n+  return new_region;\n+}\n+\n \f\n /* Routine to see if exception handling is turned on.\n    DO_WARN is non-zero if we want to inform the user that exception\n@@ -1118,6 +1331,9 @@ expand_eh_region_end (handler)\n \n   entry->finalization = handler;\n \n+  /* create region entry in final exception table */\n+  new_eh_region_entry (NOTE_BLOCK_NUMBER (note));\n+\n   enqueue_eh_entry (&ehqueue, entry);\n \n   /* If we have already started ending the bindings, don't recurse.\n@@ -1232,19 +1448,13 @@ expand_leftover_cleanups ()\n \tabort ();\n \n       /* Output the label for the start of the exception handler.  */\n-      emit_label (entry->exception_handler_label);\n \n-#ifdef HAVE_exception_receiver\n-      if (! exceptions_via_longjmp)\n-\tif (HAVE_exception_receiver)\n-\t  emit_insn (gen_exception_receiver ());\n-#endif\n+      receive_exception_label (entry->exception_handler_label);\n \n-#ifdef HAVE_nonlocal_goto_receiver\n-      if (! exceptions_via_longjmp)\n-\tif (HAVE_nonlocal_goto_receiver)\n-\t  emit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n+      /* register a handler for this cleanup region */\n+      add_new_handler (\n+        find_func_region (CODE_LABEL_NUMBER (entry->exception_handler_label)), \n+        get_new_handler (entry->exception_handler_label, NULL));\n \n       /* And now generate the insns for the handler.  */\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n@@ -1270,6 +1480,37 @@ expand_start_try_stmts ()\n   expand_eh_region_start ();\n }\n \n+/* Called to begin a catch clause. The parameter is the object which\n+   will be passed to the runtime type check routine. */\n+void \n+expand_start_catch (rtime)\n+     tree rtime;\n+{\n+  rtx handler_label = catchstack.top->entry->exception_handler_label;\n+  int insn_region_num = CODE_LABEL_NUMBER (handler_label);\n+  int eh_region_entry = find_func_region (insn_region_num);\n+\n+  /* If we've already issued this label, pick a new one */\n+  if (catchstack.top->entry->label_used == 0)\n+    handler_label = gen_exception_label ();\n+  else\n+    catchstack.top->entry->label_used = 1;\n+\n+  receive_exception_label (handler_label);\n+\n+  add_new_handler (eh_region_entry, get_new_handler (handler_label, rtime));\n+}\n+\n+/* End a catch clause by dequeuing the current region */\n+\n+void \n+expand_end_catch ()\n+{\n+  struct eh_entry *entry;\n+  entry = pop_eh_entry (&catchstack);\n+  free (entry);\n+}\n+\n /* Generate RTL for the start of a group of catch clauses. \n \n    It is responsible for starting a new instruction sequence for the\n@@ -1308,12 +1549,13 @@ expand_start_all_catch ()\n      the handlers in this handler-seq.  */\n   start_sequence ();\n \n-  while (1)\n+  entry = dequeue_eh_entry (&ehqueue);\n+  for ( ; entry->finalization != integer_zero_node;\n+                                 entry = dequeue_eh_entry (&ehqueue))\n     {\n       rtx prev;\n \n-      entry = dequeue_eh_entry (&ehqueue);\n-      /* Emit the label for the exception handler for this region, and\n+      /* Emit the label for the cleanup handler for this region, and\n \t expand the code for the handler. \n \n \t Note that a catch region is handled as a side-effect here;\n@@ -1322,29 +1564,15 @@ expand_start_all_catch ()\n \t expand_expr call below. But, the label for the handler will\n \t still be emitted, so any code emitted after this point will\n \t end up being the handler.  */\n-      emit_label (entry->exception_handler_label);\n-\n-#ifdef HAVE_exception_receiver\n-      if (! exceptions_via_longjmp)\n-\tif (HAVE_exception_receiver)\n-\t  emit_insn (gen_exception_receiver ());\n-#endif\n-\n-#ifdef HAVE_nonlocal_goto_receiver\n-      if (! exceptions_via_longjmp)\n-\tif (HAVE_nonlocal_goto_receiver)\n-\t  emit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n+      \n+      receive_exception_label (entry->exception_handler_label);\n \n-      /* When we get down to the matching entry for this try block, stop.  */\n-      if (entry->finalization == integer_zero_node)\n-\t{\n-\t  /* Don't forget to free this entry.  */\n-\t  free (entry);\n-\t  break;\n-\t}\n+      /* register a handler for this cleanup region */\n+      add_new_handler (\n+        find_func_region (CODE_LABEL_NUMBER (entry->exception_handler_label)), \n+        get_new_handler (entry->exception_handler_label, NULL));\n \n-      /* And now generate the insns for the handler.  */\n+      /* And now generate the insns for the cleanup handler.  */\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       prev = get_last_insn ();\n@@ -1358,6 +1586,12 @@ expand_start_all_catch ()\n       free (entry);\n     }\n \n+  /* At this point, all the cleanups are done, and the ehqueue now has\n+     the current exception region at its head. We dequeue it, and put it\n+     on the catch stack. */\n+\n+    push_entry (&catchstack, entry);\n+\n   /* If we are not doing setjmp/longjmp EH, because we are reordered\n      out of line, we arrange to rethrow in the outer context.  We need to\n      do this because we are not physically within the region, if any, that\n@@ -1496,15 +1730,16 @@ protect_with_terminate (e)\n    handler for the region. This is added by add_eh_table_entry and\n    used by output_exception_table_entry.  */\n \n-static int *eh_table;\n-static int eh_table_size;\n-static int eh_table_max_size;\n+static int *eh_table = NULL;\n+static int eh_table_size = 0;\n+static int eh_table_max_size = 0;\n \n /* Note the need for an exception table entry for region N.  If we\n    don't need to output an explicit exception table, avoid all of the\n    extra work.\n \n    Called from final_scan_insn when a NOTE_INSN_EH_REGION_BEG is seen.\n+   (Or NOTE_INSN_EH_REGION_END sometimes)\n    N is the NOTE_BLOCK_NUMBER of the note, which comes from the code\n    label number of the exception handler for the region.  */\n \n@@ -1562,24 +1797,60 @@ output_exception_table_entry (file, n)\n {\n   char buf[256];\n   rtx sym;\n+  int eh_entry;\n+  struct handler_info *handler;\n+\n+  handler = get_first_handler (n);\n \n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n-  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+  for ( ; handler != NULL; handler = handler->next)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n+      sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n+      assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHE\", n);\n-  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHE\", n);\n+      sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n+      assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      \n+      assemble_integer (handler->handler_label, \n+                                         POINTER_SIZE / BITS_PER_UNIT, 1);\n \n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", n);\n-  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n-  assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n+#ifdef NEW_EH_MODEL\n+    /* for now make sure the sizes match */\n+      if (handler->type_info == NULL)\n+        assemble_integer (const0_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+      else\n+        output_constant ((tree)(handler->type_info), \n+                                                POINTER_SIZE / BITS_PER_UNIT);\n+#endif\n \n-  putc ('\\n', file);\t\t/* blank line */\n+      putc ('\\n', file);\t\t/* blank line */\n+    }\n }\n \n /* Output the exception table if we have and need one.  */\n \n+#ifdef NEW_EH_MODEL\n+\n+static short language_code = 0;\n+static short version_code = 0; \n+\n+/* This routine will set the language code for exceptions. */\n+void set_exception_lang_code (code)\n+     short code;\n+{\n+  language_code = code;\n+}\n+\n+/* This routine will set the language version code for exceptions. */\n+void set_exception_version_code (code)\n+     short code;\n+{\n+  version_code = code;\n+}\n+\n+#endif\n+\n void\n output_exception_table ()\n {\n@@ -1595,15 +1866,31 @@ output_exception_table ()\n   assemble_align (GET_MODE_ALIGNMENT (ptr_mode));\n   assemble_label (\"__EXCEPTION_TABLE__\");\n \n+#ifdef NEW_EH_MODEL\n+  assemble_integer (GEN_INT (language_code), 2 , 1); \n+  assemble_integer (GEN_INT (version_code), 2 , 1);\n+\n+  /* Add enough padding to make sure table aligns on a pointer boundry. */\n+  i = GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT - 4;\n+  for ( ; i < 0; i = i + GET_MODE_ALIGNMENT (ptr_mode) / BITS_PER_UNIT)\n+    ;\n+  if (i != 0)\n+    assemble_integer (const0_rtx, i , 1);\n+#endif\n+\n   for (i = 0; i < eh_table_size; ++i)\n     output_exception_table_entry (asm_out_file, eh_table[i]);\n \n   free (eh_table);\n+  clear_function_eh_region ();\n \n   /* Ending marker for table.  */\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+#ifndef NEW_EH_MODEL\n+  /* for binary compatability, the old __throw checked the second\n+     position for a -1, so we should output at least 2 -1's */\n   assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n-  assemble_integer (constm1_rtx, POINTER_SIZE / BITS_PER_UNIT, 1);\n+#endif\n   putc ('\\n', asm_out_file);\t\t/* blank line */\n }\n \f\n@@ -1662,63 +1949,49 @@ void\n find_exception_handler_labels ()\n {\n   rtx insn;\n-  int max_labelno = max_label_num ();\n-  int min_labelno = get_first_label_num ();\n-  rtx *labels;\n \n   exception_handler_labels = NULL_RTX;\n \n   /* If we aren't doing exception handling, there isn't much to check.  */\n   if (! doing_eh (0))\n     return;\n \n-  /* Generate a handy reference to each label.  */\n-\n-  /* We call xmalloc here instead of alloca; we did the latter in the past,\n-     but found that it can sometimes end up being asked to allocate space\n-     for more than 1 million labels.  */\n-  labels = (rtx *) xmalloc ((max_labelno - min_labelno) * sizeof (rtx));\n-  bzero ((char *) labels, (max_labelno - min_labelno) * sizeof (rtx));\n-\n-  /* Arrange for labels to be indexed directly by CODE_LABEL_NUMBER.  */\n-  labels -= min_labelno;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tif (CODE_LABEL_NUMBER (insn) >= min_labelno\n-\t    && CODE_LABEL_NUMBER (insn) < max_labelno)\n-\t  labels[CODE_LABEL_NUMBER (insn)] = insn;\n-    }\n-\n   /* For each start of a region, add its label to the list.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n+      struct handler_info* ptr;\n       if (GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n \t{\n-\t  rtx label = NULL_RTX;\n-\n-\t  if (NOTE_BLOCK_NUMBER (insn) >= min_labelno\n-\t      && NOTE_BLOCK_NUMBER (insn) < max_labelno)\n-\t    {\n-\t      label = labels[NOTE_BLOCK_NUMBER (insn)];\n-\n-\t      if (label)\n-\t\texception_handler_labels\n-\t\t  = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t       label, exception_handler_labels);\n-\t      else\n-\t\twarning (\"didn't find handler for EH region %d\",\n-\t\t\t NOTE_BLOCK_NUMBER (insn));\n-\t    }\n-\t  else\n-\t    warning (\"mismatched EH region %d\", NOTE_BLOCK_NUMBER (insn));\n+          ptr = get_first_handler (NOTE_BLOCK_NUMBER (insn));\n+          for ( ; ptr; ptr = ptr->next) \n+            {\n+              /* make sure label isn't in the list already */\n+              rtx x;\n+              for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+                if (XEXP (x, 0) == ptr->handler_label)\n+                  break;\n+              if (! x)\n+                exception_handler_labels = gen_rtx_EXPR_LIST (VOIDmode,\n+                               ptr->handler_label, exception_handler_labels);\n+            }\n \t}\n     }\n+}\n+\n+/* Return a value of 1 if the parameter label number is an exception handler\n+   label. Return 0 otherwise. */\n \n-  free (labels + min_labelno);\n+int\n+is_exception_handler_label (lab)\n+     int lab;\n+{\n+  rtx x;\n+  for (x = exception_handler_labels ; x ; x = XEXP (x, 1))\n+    if (lab == CODE_LABEL_NUMBER (XEXP (x, 0)))\n+      return 1;\n+  return 0;\n }\n \n /* Perform sanity checking on the exception_handler_labels list.\n@@ -1730,60 +2003,24 @@ find_exception_handler_labels ()\n void\n check_exception_handler_labels ()\n {\n-  rtx insn, handler;\n+  rtx insn, insn2;\n \n   /* If we aren't doing exception handling, there isn't much to check.  */\n   if (! doing_eh (0))\n     return;\n \n-  /* Ensure that the CODE_LABEL_NUMBER for the CODE_LABEL entry point\n-     in each handler corresponds to the CODE_LABEL_NUMBER of the\n-     handler.  */\n-\n-  for (handler = exception_handler_labels;\n-       handler;\n-       handler = XEXP (handler, 1))\n+  /* Make sure there is no more than 1 copy of a label */\n+  for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))\n     {\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n-\t    {\n-\t      if (CODE_LABEL_NUMBER (insn)\n-\t\t  == CODE_LABEL_NUMBER (XEXP (handler, 0)))\n-\t\t{\n-\t\t  if (insn != XEXP (handler, 0))\n-\t\t    warning (\"mismatched handler %d\",\n-\t\t\t     CODE_LABEL_NUMBER (insn));\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-      if (insn == NULL_RTX)\n-\twarning (\"handler not found %d\",\n-\t\t CODE_LABEL_NUMBER (XEXP (handler, 0)));\n+      int count = 0;\n+      for (insn2 = exception_handler_labels; insn2; insn2 = XEXP (insn2, 1))\n+        if (XEXP (insn, 0) == XEXP (insn2, 0))\n+          count++;\n+      if (count != 1)\n+       warning (\"Counted %d copies of EH region %d in list.\\n\", count, \n+                                        CODE_LABEL_NUMBER (insn));\n     }\n \n-  /* Now go through and make sure that for each region there is a\n-     corresponding label.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE\n-\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n-\t{\n-\t  for (handler = exception_handler_labels;\n-\t       handler;\n-\t       handler = XEXP (handler, 1))\n-\t    {\n-\t      if (CODE_LABEL_NUMBER (XEXP (handler, 0))\n-\t\t  == NOTE_BLOCK_NUMBER (insn))\n-\t\tbreak;\n-\t    }\n-\t  if (handler == NULL_RTX && !flag_syntax_only)\n-\t    warning (\"region exists, no handler %d\",\n-\t\t     NOTE_BLOCK_NUMBER (insn));\n-\t}\n-    }\n }\n \f\n /* This group of functions initializes the exception handling data\n@@ -1805,6 +2042,7 @@ void\n init_eh_for_function ()\n {\n   ehstack.top = 0;\n+  catchstack.top = 0;\n   ehqueue.head = ehqueue.tail = 0;\n   catch_clauses = NULL_RTX;\n   false_label_stack = 0;\n@@ -1826,6 +2064,7 @@ save_eh_status (p)\n     abort ();\n \n   p->ehstack = ehstack;\n+  p->catchstack = catchstack;\n   p->ehqueue = ehqueue;\n   p->catch_clauses = catch_clauses;\n   p->false_label_stack = false_label_stack;\n@@ -1853,6 +2092,7 @@ restore_eh_status (p)\n   catch_clauses\t= p->catch_clauses;\n   ehqueue = p->ehqueue;\n   ehstack = p->ehstack;\n+  catchstack = p->catchstack;\n   current_function_ehc = p->ehc;\n }\n \f\n@@ -1951,6 +2191,10 @@ scan_region (insn, n, delete_outer)\n       delete_insn (start);\n       delete_insn (insn);\n \n+/* We no longer removed labels here, since flow will now remove any\n+   handler which cannot be called any more. */\n+   \n+#if 0\n       /* Only do this part if we have built the exception handler\n          labels.  */\n       if (exception_handler_labels)\n@@ -1984,6 +2228,7 @@ scan_region (insn, n, delete_outer)\n \t      prev = &XEXP (x, 1);\n \t    }\n \t}\n+#endif\n     }\n   return insn;\n }\n@@ -2133,6 +2378,20 @@ eh_regs (r1, r2, outgoing)\n   *r2 = reg2;\n }\n \n+\n+/* Retrieve the register which contains the pointer to the eh_context\n+   structure set the __throw. */\n+\n+rtx \n+get_reg_for_handler ()\n+{\n+  rtx reg1;\n+  reg1 = FUNCTION_VALUE (build_pointer_type (void_type_node),\n+\t\t\t   current_function_decl);\n+  return reg1;\n+}\n+\n+\n /* Emit inside of __throw a stub which adjusts the stack pointer and jumps\n    to the exception handler.  __throw will set up the necessary values\n    and then return to the stub.  */\n@@ -2150,8 +2409,28 @@ expand_builtin_eh_stub ()\n   eh_regs (&handler, &offset, 0);\n \n   adjust_stack (offset);\n+#ifdef NEW_EH_MODEL\n+\n+  /* Handler is in fact a pointer to the _eh_context structure, we need \n+     to pick out the handler field (first element), and jump to there, \n+     leaving the pointer to _eh_conext in the same hardware register. */\n+  {\n+    rtx jump_to, temp;\n+\n+    temp = gen_rtx_MEM (Pmode, handler);  \n+    MEM_IN_STRUCT_P (temp) = 1;\n+    RTX_UNCHANGING_P (temp) = 1;\n+    emit_insn (gen_rtx_SET (Pmode, offset, temp));\n+    emit_insn (gen_rtx_USE (Pmode, handler));\n+\n+    emit_indirect_jump (offset);\n+   \n+  }\n+\n+#else\n   emit_indirect_jump (handler);\n \n+#endif\n   emit_label (after_stub);\n   return gen_rtx_LABEL_REF (Pmode, stub_start);\n }\n@@ -2213,7 +2492,8 @@ set_insn_eh_region (first, region_num)\n \n /* Free the insn table, an make sure it cannot be used again. */\n \n-void free_insn_eh_region () \n+void \n+free_insn_eh_region () \n {\n   if (!doing_eh (0))\n     return;\n@@ -2229,7 +2509,8 @@ void free_insn_eh_region ()\n    this routine. If it is unavailable, passing a value of 0 will \n    cause this routine to calculate it as well. */\n \n-void init_insn_eh_region (first, max_uid)\n+void \n+init_insn_eh_region (first, max_uid)\n      rtx first;\n      int max_uid;\n {\n@@ -2255,8 +2536,9 @@ void init_insn_eh_region (first, max_uid)\n \n /* Check whether 2 instructions are within the same region. */\n \n-int in_same_eh_region(insn1, insn2) \n-     rtx insn1,insn2;\n+int \n+in_same_eh_region (insn1, insn2) \n+     rtx insn1, insn2;\n {\n   int ret, uid1, uid2;\n "}, {"sha": "6cb6dc8878f45959b858aebdf7769047298d6eec", "filename": "gcc/except.h", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -43,15 +43,19 @@ struct label_node {\n    EXCEPTION_HANDLER_LABEL is the label corresponding to the handler\n    for this region.\n \n+   LABEL_USED indicates whether a CATCH block has already used this\n+   label or not. New ones are needed for additional catch blocks if\n+   it has.\n+\n    FINALIZATION is the tree codes for the handler, or is NULL_TREE if\n    one hasn't been generated yet, or is integer_zero_node to mark the\n    end of a group of try blocks.  */\n \n struct eh_entry {\n   rtx outer_context;\n   rtx exception_handler_label;\n-\n   tree finalization;\n+  int label_used;\n };\n \n /* A list of EH_ENTRYs. ENTRY is the entry; CHAIN points to the next\n@@ -145,17 +149,89 @@ extern int doing_eh\t\t\t\t       PROTO ((int));\n \n /* Toplevel initialization for EH.  */\n \n+#ifdef NEW_EH_MODEL\n+\n+void set_exception_lang_code                    PROTO((short));\n+void set_exception_version_code                 PROTO((short));\n+\n+#endif\n+\n+/* A list of handlers asocciated with an exception region. HANDLER_LABEL\n+   is the the label that control should be transfered to if the data\n+   in TYPE_INFO matches an exception. a value of NULL_TREE for TYPE_INFO\n+   means This is a cleanup, and must always be called. A value of\n+   CATCH_ALL_TYPE works like a cleanup, but a call to the runtime matcher\n+   is still performed to avoid being caught by a different language\n+   exception. NEXT is a pointer to the next handler for this region. \n+   NULL means there are no more. */\n+\n+#define CATCH_ALL_TYPE   (tree *) -1\n+\n+typedef struct handler_info \n+{\n+  rtx  handler_label;\n+  void *type_info;\n+  struct handler_info *next;\n+} handler_info;\n+\n+\n+/* Add a new eh_entry for this function, The parameter specifies what\n+   exception region number NOTE insns use to delimit this range. \n+   The integer returned is uniquely identifies this exception range\n+   within an internal table. */\n+\n+int new_eh_region_entry                         PROTO((int));\n+\n+/* Add new handler information to an exception range. The  first parameter\n+   specifies the range number (returned from new_eh_entry()). The second\n+   parameter specifies the handler.  By default the handler is inserted at\n+   the end of the list. A handler list may contain only ONE NULL_TREE\n+   typeinfo entry. Regardless where it is positioned, a NULL_TREE entry\n+   is always output as the LAST handler in the exception table for a region. */\n+\n+void add_new_handler                       PROTO((int, struct handler_info *));\n+\n+/* Create a new handler structure initialized with the handler label and\n+   typeinfo fields passed in. */\n+\n+struct handler_info *get_new_handler            PROTO((rtx, void *));\n+\n+/* Make a duplicate of an exception region by copying all the handlers\n+   for an exception region. Return the new handler index. */\n+\n+int duplicate_handlers                          PROTO((int, int));\n+\n+\n+/* Get a pointer to the first handler in an exception region's list. */\n+\n+struct handler_info *get_first_handler          PROTO((int));\n+\n+\n extern void init_eh\t\t\t\tPROTO((void));\n \n /* Initialization for the per-function EH data.  */\n \n extern void init_eh_for_function\t\tPROTO((void));\n \n+/* Generate an exception label. Use instead of gen_label_rtx */\n+\n+extern rtx gen_exception_label                  PROTO((void));\n+\n /* Adds an EH table entry for EH entry number N. Called from\n    final_scan_insn for NOTE_INSN_EH_REGION_BEG.  */\n \n extern void add_eh_table_entry\t\t\tPROTO((int n));\n \n+/* Start a catch clause, triggered by runtime value paramter. */\n+\n+#ifdef TREE_CODE\n+extern void expand_start_catch                  PROTO((tree));\n+#endif\n+\n+/* End a catch clause. */\n+\n+extern void expand_end_catch                    PROTO((void));\n+\n /* Returns a non-zero value if we need to output an exception table.  */\n \n extern int exception_table_p\t\t\tPROTO((void));\n@@ -225,6 +301,10 @@ extern void end_eh_unwinder\t\t\tPROTO((void));\n \n extern void find_exception_handler_labels\tPROTO((void));\n \n+/* Determine if an arbitrary label is an exception label */\n+\n+extern int is_exception_handler_label           PROTO((int));\n+\n /* Performs sanity checking on the check_exception_handler_labels\n    list.  */\n "}, {"sha": "89436e4fb5881fb4ae9741274a1291fc304e830a", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -1988,7 +1988,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  && ! exceptions_via_longjmp)\n \t{\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHB\", NOTE_BLOCK_NUMBER (insn));\n+#ifndef NEW_EH_MODEL\n \t  add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n+#endif\n #ifdef ASM_OUTPUT_EH_REGION_BEG\n \t  ASM_OUTPUT_EH_REGION_BEG (file, NOTE_BLOCK_NUMBER (insn));\n #endif\n@@ -1999,6 +2001,9 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  && ! exceptions_via_longjmp)\n \t{\n \t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHE\", NOTE_BLOCK_NUMBER (insn));\n+#ifdef NEW_EH_MODEL\n+\t  add_eh_table_entry (NOTE_BLOCK_NUMBER (insn));\n+#endif\n #ifdef ASM_OUTPUT_EH_REGION_END\n \t  ASM_OUTPUT_EH_REGION_END (file, NOTE_BLOCK_NUMBER (insn));\n #endif"}, {"sha": "95beb78d1cae5d060a938b69e454cbc072a18776", "filename": "gcc/flow.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -396,7 +396,8 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n   register char *block_marked = (char *) alloca (n_basic_blocks);\n   /* An array of CODE_LABELs, indexed by UID for the start of the active\n      EH handler for each insn in F.  */\n-  rtx *active_eh_handler;\n+  int *active_eh_region;\n+  int *nested_eh_region;\n   /* List of label_refs to all labels whose addresses are taken\n      and used as data.  */\n   rtx label_value_list;\n@@ -406,15 +407,17 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n   int in_libcall_block = 0;\n \n   pass = 1;\n-  active_eh_handler = (rtx *) alloca ((max_uid_for_flow + 1) * sizeof (rtx));\n+  active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n+  nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n  restart:\n \n   label_value_list = 0;\n   block_live_static = block_live;\n   bzero (block_live, n_basic_blocks);\n   bzero (block_marked, n_basic_blocks);\n   bzero (basic_block_computed_jump_target, n_basic_blocks);\n-  bzero ((char *) active_eh_handler, (max_uid_for_flow + 1) * sizeof (rtx));\n+  bzero ((char *) active_eh_region, (max_uid_for_flow + 1) * sizeof (int));\n+  bzero ((char *) nested_eh_region, (max_label_num () + 1) * sizeof (int));\n   current_function_has_computed_jump = 0;\n \n   /* Initialize with just block 0 reachable and no blocks marked.  */\n@@ -482,20 +485,18 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t\t\t\t    label_value_list);\n \t}\n \n-      /* Keep a lifo list of the currently active exception handlers.  */\n+      /* Keep a lifo list of the currently active exception notes.  */\n       if (GET_CODE (insn) == NOTE)\n \t{\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n \t    {\n-\t      for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-\t\tif (CODE_LABEL_NUMBER (XEXP (x, 0)) == NOTE_BLOCK_NUMBER (insn))\n-\t\t  {\n-\t\t    eh_note = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t XEXP (x, 0), eh_note);\n-\t\t    break;\n-\t\t  }\n-\t      if (x == NULL_RTX)\n-\t\tabort ();\n+              if (eh_note)\n+                nested_eh_region [NOTE_BLOCK_NUMBER (insn)] = \n+                                     NOTE_BLOCK_NUMBER (XEXP (eh_note, 0));\n+              else\n+                nested_eh_region [NOTE_BLOCK_NUMBER (insn)] = 0;\n+\t      eh_note = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t insn, eh_note);\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t    eh_note = XEXP (eh_note, 1);\n@@ -509,8 +510,8 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t       && (asynchronous_exceptions\n \t\t   || (GET_CODE (insn) == CALL_INSN\n \t\t       && ! in_libcall_block)))\n-\tactive_eh_handler[INSN_UID (insn)] = XEXP (eh_note, 0);\n-\n+\tactive_eh_region[INSN_UID (insn)] = \n+                                        NOTE_BLOCK_NUMBER (XEXP (eh_note, 0));\n       BLOCK_NUM (insn) = i;\n \n       if (code != NOTE)\n@@ -655,11 +656,20 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t\t     && ! find_reg_note (insn, REG_RETVAL,\n \t\t\t\t\t\t\t NULL_RTX)))\n \t\t\t  {\n-\t\t\t    if (active_eh_handler[INSN_UID (insn)])\n-\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t active_eh_handler[INSN_UID (insn)]),\n-\t\t\t\t\t      insn, 0);\n-\n+\t\t\t    if (active_eh_region[INSN_UID (insn)]) \n+                              {\n+                                int region;\n+                                handler_info *ptr;\n+                                region = active_eh_region[INSN_UID (insn)];\n+                                for ( ; region; \n+                                             region = nested_eh_region[region]) \n+                                  {\n+                                    ptr = get_first_handler (region);\n+                                    for ( ; ptr ; ptr = ptr->next)\n+                                      mark_label_ref (gen_rtx_LABEL_REF \n+                                       (VOIDmode, ptr->handler_label), insn, 0);\n+                                  }\n+                              }\n \t\t\t    if (!asynchronous_exceptions)\n \t\t\t      {\n \t\t\t\tfor (x = nonlocal_label_list;\n@@ -764,6 +774,10 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t    /* Now we have to find the EH_BEG and EH_END notes\n \t\t\t       associated with this label and remove them.  */\n \n+#if 0\n+/* Handlers and labels no longer needs to have the same values.\n+   If there are no references, scan_region will remove any region\n+   labels which are of no use. */\n \t\t\t    for (x = get_insns (); x; x = NEXT_INSN (x))\n \t\t\t      {\n \t\t\t\tif (GET_CODE (x) == NOTE\n@@ -778,6 +792,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t\t    NOTE_SOURCE_FILE (x) = 0;\n \t\t\t\t  }\n \t\t\t      }\n+#endif\n \t\t\t    break;\n \t\t\t  }\n \t\t\tprev = &XEXP (x, 1);"}, {"sha": "e31f48416745ee36af8e80fb8e7c0f62c549c9d7", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -133,6 +133,7 @@ struct function\n \n   /* For exception handling information.  */\n   struct eh_stack ehstack;\n+  struct eh_stack catchstack;\n   struct eh_queue ehqueue;\n   rtx catch_clauses;\n   struct label_node *false_label_stack;"}, {"sha": "7a588884e86b2b1d6f3a112ded59b8a3e4f71381", "filename": "gcc/integrate.c", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -95,7 +95,12 @@ get_label_from_map (map, i)\n   rtx x = map->label_map[i];\n \n   if (x == NULL_RTX)\n-    x = map->label_map[i] = gen_label_rtx();\n+    {                     \n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      x = map->label_map[i] = gen_label_rtx();\n+      pop_obstacks ();\n+    }\n \n   return x;\n }\n@@ -658,10 +663,28 @@ save_for_inline_copying (fndecl)\n \t  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG\n \t      || NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_END)\n \t    {\n+              int new_region = CODE_LABEL_NUMBER \n+                                        (label_map[NOTE_BLOCK_NUMBER (copy)]);\n+\n+              /* we have to duplicate the handlers for the original */\n+              if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG) \n+                {\n+                  handler_info *ptr, *temp;\n+                  int nr;\n+                  nr = new_eh_region_entry (new_region);\n+                  ptr = get_first_handler (NOTE_BLOCK_NUMBER (copy));\n+                  for ( ; ptr; ptr = ptr->next)\n+                    {\n+                      temp = get_new_handler (\n+                           label_map[CODE_LABEL_NUMBER (ptr->handler_label)],\n+                                                               ptr->type_info);\n+                      add_new_handler (nr, temp);\n+                    }\n+                }\n+                \n \t      /* We have to forward these both to match the new exception\n \t\t region.  */\n-\t      NOTE_BLOCK_NUMBER (copy)\n-\t\t= CODE_LABEL_NUMBER (label_map[NOTE_BLOCK_NUMBER (copy)]);\n+\t      NOTE_BLOCK_NUMBER (copy) = new_region;\n \t      \n \t    }\n \t  RTX_INTEGRATED_P (copy) = RTX_INTEGRATED_P (insn);\n@@ -2038,6 +2061,22 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\t  rtx label\n \t\t    = get_label_from_map (map, NOTE_BLOCK_NUMBER (copy));\n \n+                  /* we have to duplicate the handlers for the original */\n+                  if (NOTE_LINE_NUMBER (copy) == NOTE_INSN_EH_REGION_BEG)\n+                    {\n+                      handler_info *ptr, *temp;\n+                      int nr;\n+                      nr = new_eh_region_entry (CODE_LABEL_NUMBER (label));\n+                      ptr = get_first_handler (NOTE_BLOCK_NUMBER (copy));\n+                      for ( ; ptr; ptr = ptr->next)\n+                        {\n+                          temp = get_new_handler ( get_label_from_map (map, \n+                                      CODE_LABEL_NUMBER (ptr->handler_label)),\n+                                                               ptr->type_info);\n+                          add_new_handler (nr, temp);\n+                        }\n+                    }\n+\n \t\t  /* We have to forward these both to match the new exception\n \t\t     region.  */\n \t\t  NOTE_BLOCK_NUMBER (copy) = CODE_LABEL_NUMBER (label);"}, {"sha": "c8604124a19e0df819eb71f428eeeccbf79408d0", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=9a0d1e1b11fc8a7fd41f038d7b243b6d2573ed64", "patch": "@@ -3046,14 +3046,10 @@ __empty ()\n {\n }\n \f\n-/* EH context structure. */\n \n-struct eh_context\n-{\n-  void **dynamic_handler_chain;\n-  /* This is language dependent part of the eh context. */\n-  void *info;\n-};\n+/* Include definitions of EH context and table layout */\n+\n+#include \"eh-common.h\"\n \n /* This is a safeguard for dynamic handler chain. */\n \n@@ -3361,11 +3357,6 @@ EH_TABLE_LOOKUP\n #else\n \n #ifdef DWARF2_UNWIND_INFO\n-typedef struct exception_table {\n-  void *start;\n-  void *end;\n-  void *exception_handler;\n-} exception_table;\n \n /* This routine takes a PC and a pointer to the exception region TABLE for\n    its translation unit, and returns the address of the exception handler\n@@ -3376,31 +3367,68 @@ typedef struct exception_table {\n    an inner block.  */\n \n static void *\n-find_exception_handler (void *pc, exception_table *table)\n+find_exception_handler (void *pc, exception_descriptor *table, void *eh_info)\n {\n   if (table)\n     {\n+#ifdef NEW_EH_MODEL\n+      /* The new model assumed the table is sorted inner-most out so the\n+         first region we find which matches is the correct one */\n+\n+      int pos;\n+      void *ret;\n+      exception_table *tab = &(table->table[0]);\n+\n+      /* Subtract 1 from the PC to avoid hitting the next region */\n+      pc--;\n+      \n+      /* We can't do a binary search because the table is in inner-most\n+         to outermost address ranges within functions */\n+      for (pos = 0; tab[pos].start_region != (void *) -1; pos++)\n+        { \n+          if (tab[pos].start_region <= pc && tab[pos].end_region > pc)\n+            {\n+              if (tab[pos].match_info)\n+                {\n+                  __eh_matcher matcher = ((__eh_info *)eh_info)->match_function;\n+                  /* match info but no matcher is NOT a match */\n+                  if (matcher) \n+                    {\n+                      ret = (*matcher)(eh_info, tab[pos].match_info, table);\n+                      if (ret)\n+                        {\n+                          ((__eh_info *)eh_info)->coerced_value = ret;\n+                          return tab[pos].exception_handler;\n+                        }\n+                    }\n+                }\n+              else\n+                return tab[pos].exception_handler;\n+            }\n+        }\n+#else\n       int pos;\n       int best = -1;\n \n       /* We can't do a binary search because the table isn't guaranteed\n-\t to be sorted from function to function.  */\n-      for (pos = 0; table[pos].exception_handler != (void *) -1; ++pos)\n-\t{\n-\t  if (table[pos].start <= pc && table[pos].end > pc)\n-\t    {\n-\t      /* This can apply.  Make sure it is at least as small as\n-\t\t the previous best.  */\n-\t      if (best == -1 || (table[pos].end <= table[best].end\n-\t\t\t\t && table[pos].start >= table[best].start))\n-\t\tbest = pos;\n-\t    }\n-\t  /* But it is sorted by starting PC within a function.  */\n-\t  else if (best >= 0 && table[pos].start > pc)\n-\t    break;\n-\t}\n+         to be sorted from function to function.  */\n+      for (pos = 0; table[pos].start_region != (void *) -1; ++pos)\n+        {\n+          if (table[pos].start_region <= pc && table[pos].end_region > pc)\n+            {\n+              /* This can apply.  Make sure it is at least as small as\n+                 the previous best.  */\n+              if (best == -1 || (table[pos].end_region <= table[best].end_region\n+                        && table[pos].start_region >= table[best].start_region))\n+                best = pos;\n+            }\n+          /* But it is sorted by starting PC within a function.  */\n+          else if (best >= 0 && table[pos].start_region > pc)\n+            break;\n+        }\n       if (best != -1)\n-\treturn table[best].exception_handler;\n+        return table[best].exception_handler;\n+#endif\n     }\n \n   return (void *) 0;\n@@ -3583,7 +3611,7 @@ __throw ()\n       if (! udata)\n \tbreak;\n \n-      handler = find_exception_handler (pc, udata->eh_ptr);\n+      handler = find_exception_handler (pc, udata->eh_ptr, eh->info);\n \n       /* If we found one, we can stop searching.  */\n       if (handler)\n@@ -3602,6 +3630,10 @@ __throw ()\n   if (! handler)\n     __terminate ();\n \n+#ifdef NEW_EH_MODEL\n+  eh->handler_label = handler;\n+#endif\n+\n   if (pc == saved_pc)\n     /* We found a handler in the throw context, no need to unwind.  */\n     udata = my_udata;\n@@ -3669,7 +3701,13 @@ __throw ()\n \n   /* Set up the registers we use to communicate with the stub.\n      We check STACK_GROWS_DOWNWARD so the stub can use adjust_stack.  */\n+\n+#ifdef NEW_EH_MODEL\n+  __builtin_set_eh_regs ((void *)eh,\n+#else\n   __builtin_set_eh_regs (handler,\n+#endif\n+\n #ifdef STACK_GROWS_DOWNWARD\n \t\t\t udata->cfa - my_udata->cfa\n #else"}]}