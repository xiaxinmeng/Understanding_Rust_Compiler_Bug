{"sha": "bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlZDhkYWM5N2Q4ZDBlNTNjMjU1NmQ3OTFiNzgwNmNiMWU3ODJiNA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-06-10T09:15:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-10T09:15:39Z"}, "message": "mips.c (gpr_mode): New variable.\n\n        * mips.c (gpr_mode): New variable.\n        (override_options): Initialize gpr_mode.\n        (compute_frame_size): Use \"gpr_mode\" instead of \"word_mode\" to\n        determine size and offset of general purpose registers save slots.\n        (save_restore_insns, mips_expand_prologue): Similarly.\n\nFrom-SVN: r20403", "tree": {"sha": "055f62afeed11b9a735bb585cf53f1b6869f1a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/055f62afeed11b9a735bb585cf53f1b6869f1a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfed8dac97d8d0e53c2556d791b7806cb1e782b4/comments", "author": null, "committer": null, "parents": [{"sha": "0254c56158b0533600ba9036258c11d377d46adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0254c56158b0533600ba9036258c11d377d46adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0254c56158b0533600ba9036258c11d377d46adf"}], "stats": {"total": 51, "additions": 33, "deletions": 18}, "files": [{"sha": "24fa34aafafe95d8ed2efa19eeefc203ddb07134", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfed8dac97d8d0e53c2556d791b7806cb1e782b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfed8dac97d8d0e53c2556d791b7806cb1e782b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "patch": "@@ -6,6 +6,12 @@ Wed Jun 10 08:56:27 1998  John Carr  <jfc@mit.edu>\n \n Wed Jun 10 02:11:55 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* mips.c (gpr_mode): New variable.\n+\t(override_options): Initialize gpr_mode.\n+\t(compute_frame_size): Use \"gpr_mode\" instead of \"word_mode\" to\n+\tdetermine size and offset of general purpose registers save slots.\n+\t(save_restore_insns, mips_expand_prologue): Similarly.\n+\n \t* reload.c (find_reloads_toplev): Use gen_lowpart common to convert\n \tbetween constant representations when we have (SUBREG (REG)) with\n \tREG equivalent to a constant."}, {"sha": "9bda30fe40efd227794a5082403d977e8c5d70ce", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfed8dac97d8d0e53c2556d791b7806cb1e782b4/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfed8dac97d8d0e53c2556d791b7806cb1e782b4/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bfed8dac97d8d0e53c2556d791b7806cb1e782b4", "patch": "@@ -244,6 +244,9 @@ enum mips_abicalls_type mips_abicalls;\n    initialized in override_options.  */\n REAL_VALUE_TYPE dfhigh, dflow, sfhigh, sflow;\n \n+/* Mode used for saving/restoring general purpose registers.  */\n+static static enum machine_mode gpr_mode;\n+\n /* Array giving truth value on whether or not a given hard register\n    can support a given mode.  */\n char mips_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n@@ -4449,6 +4452,9 @@ override_options ()\n \t  mips_hard_regno_mode_ok[(int)mode][regno] = temp;\n \t}\n     }\n+\n+  /* Save GPR registers in word_mode sized hunks.  */\n+  gpr_mode = word_mode;\n }\n \n /* On the mips16, we want to allocate $24 (T_REG) before other\n@@ -5495,7 +5501,7 @@ compute_frame_size (size)\n \t\t  || (GET_MODE_SIZE (DECL_MODE (DECL_RESULT (current_function_decl)))\n \t\t      <= 4))))\n \t{\n-\t  gp_reg_size += UNITS_PER_WORD;\n+\t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n \t  mask |= 1L << (regno - GP_REG_FIRST);\n \n \t  /* The entry and exit pseudo instructions can not save $17\n@@ -5582,9 +5588,10 @@ compute_frame_size (size)\n          top of the stack.  */\n       if (! mips_entry)\n \toffset = (args_size + extra_size + var_size\n-\t\t  + gp_reg_size - UNITS_PER_WORD);\n+\t\t  + gp_reg_size - GET_MODE_SIZE (gpr_mode));\n       else\n-\toffset = total_size - UNITS_PER_WORD;\n+\toffset = total_size - GET_MODE_SIZE (gpr_mode);\n+\n       current_frame_info.gp_sp_offset = offset;\n       current_frame_info.gp_save_offset = offset - total_size;\n     }\n@@ -5660,7 +5667,8 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n       gp_offset = current_frame_info.gp_sp_offset;\n       end_offset\n-\t= gp_offset - (current_frame_info.gp_reg_size - UNITS_PER_WORD);\n+\t= gp_offset - (current_frame_info.gp_reg_size\n+\t\t       - GET_MODE_SIZE (gpr_mode));\n \n       if (gp_offset < 0 || end_offset < 0)\n \tfatal (\"gp_offset (%ld) or end_offset (%ld) is less than zero.\",\n@@ -5771,7 +5779,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t      {\n \t\trtx reg_rtx;\n \t\trtx mem_rtx\n-\t\t  = gen_rtx (MEM, word_mode,\n+\t\t  = gen_rtx (MEM, gpr_mode,\n \t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n \t\t\t\t      GEN_INT (gp_offset - base_offset)));\n \n@@ -5781,23 +5789,23 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n                    $31, so we load $7 instead, and work things out\n                    in the caller.  */\n \t\tif (TARGET_MIPS16 && ! store_p && regno == GP_REG_FIRST + 31)\n-\t\t  reg_rtx = gen_rtx (REG, word_mode, GP_REG_FIRST + 7);\n+\t\t  reg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 7);\n \t\t/* The mips16 sometimes needs to save $18.  */\n \t\telse if (TARGET_MIPS16\n \t\t\t && regno != GP_REG_FIRST + 31\n \t\t\t && ! M16_REG_P (regno))\n \t\t  {\n \t\t    if (! store_p)\n-\t\t      reg_rtx = gen_rtx (REG, word_mode, 6);\n+\t\t      reg_rtx = gen_rtx (REG, gpr_mode, 6);\n \t\t    else\n \t\t      {\n-\t\t\treg_rtx = gen_rtx (REG, word_mode, 3);\n+\t\t\treg_rtx = gen_rtx (REG, gpr_mode, 3);\n \t\t\temit_move_insn (reg_rtx,\n-\t\t\t\t\tgen_rtx (REG, word_mode, regno));\n+\t\t\t\t\tgen_rtx (REG, gpr_mode, regno));\n \t\t      }\n \t\t  }\n \t\telse\n-\t\t  reg_rtx = gen_rtx (REG, word_mode, regno);\n+\t\t  reg_rtx = gen_rtx (REG, gpr_mode, regno);\n \n \t\tif (store_p)\n \t\t  {\n@@ -5811,7 +5819,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t    if (TARGET_MIPS16\n \t\t\t&& regno != GP_REG_FIRST + 31\n \t\t\t&& ! M16_REG_P (regno))\n-\t\t      emit_move_insn (gen_rtx (REG, word_mode, regno),\n+\t\t      emit_move_insn (gen_rtx (REG, gpr_mode, regno),\n \t\t\t\t      reg_rtx);\n \t\t  }\n \t      }\n@@ -5857,7 +5865,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  }\n \n \t      }\n-\t    gp_offset -= UNITS_PER_WORD;\n+\t    gp_offset -= GET_MODE_SIZE (gpr_mode);\n \t  }\n     }\n   else\n@@ -6331,9 +6339,10 @@ mips_expand_prologue ()\n \t{\n \t  if (offset != 0)\n \t    ptr = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (offset));\n-\t  emit_move_insn (gen_rtx (MEM, word_mode, ptr),\n-\t\t\t  gen_rtx (REG, word_mode, regno));\n-\t  offset += UNITS_PER_WORD;\n+\t  emit_move_insn (gen_rtx (MEM, gpr_mode, ptr),\n+\t\t\t  gen_rtx (REG, gpr_mode, regno));\n+\n+\t  offset += GET_MODE_SIZE (gpr_mode);\n \t}\n     }\n \n@@ -6378,7 +6387,7 @@ mips_expand_prologue ()\n \t moment.  */\n       if (TARGET_MIPS16 && BITSET_P (current_frame_info.mask, 18))\n \t{\n-\t  rtx reg_rtx = gen_rtx (REG, word_mode, GP_REG_FIRST + 3);\n+\t  rtx reg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 3);\n \t  long gp_offset, base_offset;\n \n \t  gp_offset = current_frame_info.gp_sp_offset;\n@@ -6394,8 +6403,8 @@ mips_expand_prologue ()\n \t    base_offset = 0;\n \t  start_sequence ();\n \t  emit_move_insn (reg_rtx,\n-\t\t\t  gen_rtx (REG, word_mode, GP_REG_FIRST + 18));\n-\t  emit_move_insn (gen_rtx (MEM, word_mode,\n+\t\t\t  gen_rtx (REG, gpr_mode, GP_REG_FIRST + 18));\n+\t  emit_move_insn (gen_rtx (MEM, gpr_mode,\n \t\t\t\t   gen_rtx (PLUS, Pmode, stack_pointer_rtx,\n \t\t\t\t\t    GEN_INT (gp_offset\n \t\t\t\t\t\t     - base_offset))),"}]}