{"sha": "c4ba884897fc5aa644f3d43990431e023ed618f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiYTg4NDg5N2ZjNWFhNjQ0ZjNkNDM5OTA0MzFlMDIzZWQ2MThmNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-21T13:16:06Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-21T13:16:06Z"}, "message": "re PR fortran/31867 ([4.2 only] function result with character LEN computed at run time)\n\n2007-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31867\n\tPR fortran/31994\n\t* trans-array.c (gfc_conv_expr_descriptor): Obtain the stored\n\toffset for non-descriptor, source arrays and correct for stride\n\tnot equal to one before writing to field of output descriptor.\n\n2007-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31867\n\t* gfortran.dg/char_length_5.f90: New test.\n\n\tPR fortran/31994\n\t* gfortran.dg/array_reference_1.f90: New test.\n\nFrom-SVN: r124903", "tree": {"sha": "c5e95ad910c1fbf82bdcaff914302cf400079f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5e95ad910c1fbf82bdcaff914302cf400079f67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ba884897fc5aa644f3d43990431e023ed618f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ba884897fc5aa644f3d43990431e023ed618f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ba884897fc5aa644f3d43990431e023ed618f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ba884897fc5aa644f3d43990431e023ed618f4/comments", "author": null, "committer": null, "parents": [{"sha": "4d8a8a0a223f8e65a810bdb4ec3fe7496a964699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d8a8a0a223f8e65a810bdb4ec3fe7496a964699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d8a8a0a223f8e65a810bdb4ec3fe7496a964699"}], "stats": {"total": 133, "additions": 130, "deletions": 3}, "files": [{"sha": "10886d736dfaaa27113aa3d1c73498357f04821a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c4ba884897fc5aa644f3d43990431e023ed618f4", "patch": "@@ -1,3 +1,11 @@\n+2007-05-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31867\n+\tPR fortran/31994\n+\t* trans-array.c (gfc_conv_expr_descriptor): Obtain the stored\n+\toffset for non-descriptor, source arrays and correct for stride\n+\tnot equal to one before writing to field of output descriptor.\n+\n 2007-05-20  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/32001"}, {"sha": "e7e091f9065241742e75023c2b0e6c251de7ae83", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c4ba884897fc5aa644f3d43990431e023ed618f4", "patch": "@@ -4595,6 +4595,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       if (se->direct_byref)\n \tbase = gfc_index_zero_node;\n+      else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\tbase = gfc_evaluate_now (gfc_conv_array_offset (desc), &loop.pre);\n       else\n \tbase = NULL_TREE;\n \n@@ -4668,8 +4670,20 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t\t\t\tstride, info->stride[dim]);\n \n \t  if (se->direct_byref)\n-\t    base = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n-\t\t\t\tbase, stride);\n+\t    {\n+\t      base = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n+\t\t\t\t  base, stride);\n+\t    }\n+\t  else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\t    {\n+\t      tmp = gfc_conv_array_lbound (desc, n);\n+\t      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n+\t\t\t\t tmp, loop.from[dim]);\n+\t      tmp = fold_build2 (MULT_EXPR, TREE_TYPE (base),\n+\t\t\t\t tmp, gfc_conv_array_stride (desc, n));\n+\t      base = fold_build2 (PLUS_EXPR, TREE_TYPE (base),\n+\t\t\t\t  tmp, base);\n+\t    }\n \n \t  /* Store the new stride.  */\n \t  tmp = gfc_conv_descriptor_stride (parm, gfc_rank_cst[dim]);\n@@ -4690,7 +4704,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  gfc_conv_descriptor_data_set (&loop.pre, parm, offset);\n \t}\n \n-      if (se->direct_byref && !se->data_not_needed)\n+      if ((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\t     && !se->data_not_needed)\n \t{\n \t  /* Set the offset.  */\n \t  tmp = gfc_conv_descriptor_offset (parm);"}, {"sha": "031c15d27c99f86b3151994f85ad8be45dabadae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4ba884897fc5aa644f3d43990431e023ed618f4", "patch": "@@ -1,3 +1,11 @@\n+2007-05-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31867\n+\t* gfortran.dg/char_length_5.f90: New test.\n+\n+\tPR fortran/31994\n+\t* gfortran.dg/array_reference_1.f90: New test.\n+\n 2007-05-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR middle-end/7651"}, {"sha": "6de09919f17c41e59be442e47f36c08fc0723d6d", "filename": "gcc/testsuite/gfortran.dg/array_reference_1.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_reference_1.f90?ref=c4ba884897fc5aa644f3d43990431e023ed618f4", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! Tests the fix for PR31994, aka 31867, in which the offset\n+! of 'a' in both subroutines was being evaluated incorrectly.\n+! The testcase for PR31867 is char_length_5.f90\n+!\n+! Contributed by Elizabeth Yip <elizabeth.l.yip@boeing.com>\n+!            and Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+!\n+program main\n+  call PR31994\n+  call PR31994_comment6\n+contains\n+  subroutine PR31994\r\n+    implicit none\r\n+    complex (kind=4), dimension(2,2) :: a, b, c\r\n+    a(1,1) = (1.,1.)\r\n+    a(2,1) = (2.,2.)\r\n+    a(1,2) = (3.,3.)\r\n+    a(2,2) = (4.,4.)\r\n+    b=conjg (transpose (a))\r\n+    c=transpose (a)\r\n+    c=conjg (c)\r\n+    if (any (b .ne. c)) call abort ()\n+  end subroutine PR31994\n+  subroutine PR31994_comment6\n+    implicit none\r\n+    real ,dimension(2,2)::a\n+    integer ,dimension(2,2) :: b, c\n+    a = reshape ((/1.,2.,3.,4./), (/2,2/))\n+    b=int (transpose(a))\n+    c = int (a)\n+    c = transpose (c)\n+    if (any (b .ne. c)) call abort ()\n+  end subroutine PR31994_comment6\r\n+END program main\r"}, {"sha": "03a4d85602971cf4cbb34e6ac0a21337b2093718", "filename": "gcc/testsuite/gfortran.dg/char_length_5.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ba884897fc5aa644f3d43990431e023ed618f4/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_5.f90?ref=c4ba884897fc5aa644f3d43990431e023ed618f4", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+! Tests the fix for PR31867, in which the interface evaluation\n+! of the character length of 'join' (ie. the length available in\n+! the caller) was wrong.\n+!\n+! Contributed by <beliavsky@aol.com> \n+!\n+module util_mod\n+  implicit none\n+contains\n+  function join (words, sep) result(str)\n+    character (len=*), intent(in)        :: words(:),sep\n+    character (len = (size (words) - 1) * len_trim (sep) + & \n+               sum (len_trim (words)))   :: str\n+    integer                              :: i,nw\n+    nw  = size (words)\n+    str = \"\"\n+    if (nw < 1) then\n+      return\n+    else\n+      str = words(1)\n+    end if\n+    do i=2,nw\n+      str = trim (str) // trim (sep) // words(i)\n+    end do\n+  end function join\n+end module util_mod\n+!\n+program xjoin\n+  use util_mod, only: join\n+  implicit none\n+  integer yy\n+  character (len=5) :: words(5:8) = (/\"two  \",\"three\",\"four \",\"five \"/), sep = \"^#^\"\n+  character (len=5) :: words2(4) = (/\"bat  \",\"ball \",\"goal \",\"stump\"/), sep2 = \"&\"\n+\n+  if (join (words, sep) .ne. \"two^#^three^#^four^#^five\") call abort ()\n+  if (len (join (words, sep)) .ne. 25) call abort ()\n+\n+  if (join (words(5:6), sep) .ne. \"two^#^three\") call abort ()\n+  if (len (join (words(5:6), sep)) .ne. 11) call abort ()\n+\n+  if (join (words(7:8), sep) .ne. \"four^#^five\") call abort ()\n+  if (len (join (words(7:8), sep)) .ne. 11) call abort ()\n+\n+  if (join (words(5:7:2), sep) .ne. \"two^#^four\") call abort ()\n+  if (len (join (words(5:7:2), sep)) .ne. 10) call abort ()\n+\n+  if (join (words(6:8:2), sep) .ne. \"three^#^five\") call abort ()\n+  if (len (join (words(6:8:2), sep)) .ne. 12) call abort ()\n+\n+  if (join (words2, sep2) .ne. \"bat&ball&goal&stump\") call abort ()\n+  if (len (join (words2, sep2)) .ne. 19) call abort ()\n+\n+  if (join (words2(1:2), sep2) .ne. \"bat&ball\") call abort ()\n+  if (len (join (words2(1:2), sep2)) .ne. 8) call abort ()\n+\n+  if (join (words2(2:4:2), sep2) .ne. \"ball&stump\") call abort ()\n+  if (len (join (words2(2:4:2), sep2)) .ne. 10) call abort ()\n+\n+end program xjoin\n+! { dg-final { cleanup-modules \"util_mod\" } }"}]}