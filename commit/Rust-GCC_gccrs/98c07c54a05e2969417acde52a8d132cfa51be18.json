{"sha": "98c07c54a05e2969417acde52a8d132cfa51be18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMDdjNTRhMDVlMjk2OTQxN2FjZGU1MmE4ZDEzMmNmYTUxYmUxOA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-04-08T17:32:23Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-04-08T17:32:23Z"}, "message": "Fix comments, simplify logic.\n\n2010-04-08  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-if-conv.c: Fix comments and simplify logic.\n\nFrom-SVN: r158136", "tree": {"sha": "242abb8ef949aedf33f279f0ae57a6c77d879bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/242abb8ef949aedf33f279f0ae57a6c77d879bae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c07c54a05e2969417acde52a8d132cfa51be18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c07c54a05e2969417acde52a8d132cfa51be18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c07c54a05e2969417acde52a8d132cfa51be18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c07c54a05e2969417acde52a8d132cfa51be18/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cbcfa9d67d03fb039c5f887b0f6ff76d5c2c169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbcfa9d67d03fb039c5f887b0f6ff76d5c2c169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbcfa9d67d03fb039c5f887b0f6ff76d5c2c169"}], "stats": {"total": 231, "additions": 108, "deletions": 123}, "files": [{"sha": "d7f6c36755c4321aaf6808869ab3303e76bfda18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c07c54a05e2969417acde52a8d132cfa51be18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c07c54a05e2969417acde52a8d132cfa51be18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98c07c54a05e2969417acde52a8d132cfa51be18", "patch": "@@ -1,3 +1,7 @@\n+2010-04-08  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-if-conv.c: Fix comments and simplify logic.\n+\n 2010-04-08  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c (if_convertible_loop_p): Remove unused parameter."}, {"sha": "43b04c1900ef5c8feff607e31ff65c49db11cf10", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 104, "deletions": 123, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c07c54a05e2969417acde52a8d132cfa51be18/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c07c54a05e2969417acde52a8d132cfa51be18/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=98c07c54a05e2969417acde52a8d132cfa51be18", "patch": "@@ -19,8 +19,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This pass implements tree level if-conversion transformation of loops.\n-   Initial goal is to help vectorizer vectorize loops with conditions.\n+/* This pass implements a tree level if-conversion of loops.  Its\n+   initial goal is to help the vectorizer to vectorize loops with\n+   conditions.\n \n    A short description of if-conversion:\n \n@@ -103,7 +104,7 @@ along with GCC; see the file COPYING3.  If not see\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n-/* Make a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n+/* Create a new temp variable of type TYPE.  Add GIMPLE_ASSIGN to assign EXP\n    to the new variable.  */\n \n static gimple\n@@ -130,7 +131,7 @@ ifc_temp_var (tree type, tree exp)\n   return stmt;\n }\n \n-/* Add condition NEW_COND into predicate list of basic block BB.  */\n+/* Add condition NEW_COND to the predicate list of basic block BB.  */\n \n static void\n add_to_predicate_list (basic_block bb, tree new_cond)\n@@ -147,7 +148,7 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n   bb->aux = cond;\n }\n \n-/* And condition COND to the previous condition PREV_COND and add this\n+/* Add the condition COND to the previous condition PREV_COND, and add this\n    to the predicate list of the destination of edge E.  GSI is the\n    place where the gimplification of the resulting condition should\n    output code.  LOOP is the loop to be if-converted.  */\n@@ -175,9 +176,9 @@ add_to_dst_predicate_list (struct loop *loop, edge e,\n       cond = force_gimple_operand_gsi (gsi, unshare_expr (cond),\n \t\t\t\t       true, NULL, true, GSI_SAME_STMT);\n \n-      /* Add the condition to aux field of the edge.  In case edge\n-\t destination is a PHI node, this condition will be ANDed with\n-\t block predicate to construct complete condition.  */\n+      /* Add the condition COND to the e->aux field.  In case the edge\n+\t destination is a PHI node, this condition will be added to\n+\t the block predicate to construct a complete condition.  */\n       e->aux = cond;\n \n       tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n@@ -191,29 +192,25 @@ add_to_dst_predicate_list (struct loop *loop, edge e,\n   return new_cond;\n }\n \n-/* Return true if one of the basic block BB edge is exit of LOOP.  */\n+/* Return true if one of the successor edges of BB exits LOOP.  */\n \n static bool\n bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  bool exit_edge_found = false;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     if (loop_exit_edge_p (loop, e))\n-      {\n-\texit_edge_found = true;\n-\tbreak;\n-      }\n+      return true;\n \n-  return exit_edge_found;\n+  return false;\n }\n \n /* STMT is a GIMPLE_COND.  Update two destination's predicate list.\n-   Remove COND_EXPR, if it is not the loop exit condition.  Otherwise\n-   update loop exit condition appropriately.  GSI is the iterator\n-   used to traverse statement list.  STMT is part of loop LOOP.  */\n+   Remove COND_EXPR, if it is not the exit condition of LOOP.\n+   Otherwise update the exit condition of LOOP appropriately.  GSI\n+   points to the statement STMT.  */\n \n static void\n tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n@@ -237,23 +234,23 @@ tree_if_convert_cond_stmt (struct loop *loop, gimple stmt, tree cond,\n   c2 = invert_truthvalue_loc (loc, unshare_expr (c));\n   add_to_dst_predicate_list (loop, false_edge, cond, c2, gsi);\n \n-  /* Now this conditional statement is redundant.  Remove it.\n-     But, do not remove exit condition!  Update exit condition\n-     using new condition.  */\n+  /* Now this conditional statement is redundant.  Remove it.  But, do\n+     not remove the exit condition!  Update the exit condition using\n+     the new condition.  */\n   if (!bb_with_exit_edge_p (loop, gimple_bb (stmt)))\n     {\n       gsi_remove (gsi, true);\n       cond = NULL_TREE;\n     }\n-  return;\n }\n \n /* If-convert stmt T which is part of LOOP.\n-   If T is a GIMPLE_ASSIGN then it is converted into conditional modify\n-   expression using COND.  For conditional expressions, add condition in the\n-   destination basic block's predicate list and remove conditional\n-   expression itself.  BSI is the iterator used to traverse statements of\n-   loop.  It is used here when it is required to delete current statement.  */\n+\n+   If T is a GIMPLE_ASSIGN then it is converted into a conditional\n+   modify expression using COND.  For conditional expressions, add\n+   a condition in the destination basic block's predicate list and\n+   remove the conditional expression itself.  GSI points to the\n+   statement T.  */\n \n static tree\n tree_if_convert_stmt (struct loop *loop, gimple t, tree cond,\n@@ -299,13 +296,15 @@ tree_if_convert_stmt (struct loop *loop, gimple t, tree cond,\n     default:\n       gcc_unreachable ();\n     }\n+\n   return cond;\n }\n \n-/* Return true, iff PHI is if-convertible.  PHI is part of loop LOOP\n+/* Return true when PHI is if-convertible.  PHI is part of loop LOOP\n    and it belongs to basic block BB.\n-   PHI is not if-convertible\n-   - if it has more than 2 arguments,\n+\n+   PHI is not if-convertible if:\n+   - it has more than 2 arguments,\n    - virtual PHI is immediately used in another PHI node,\n    - virtual PHI on BB other than header.  */\n \n@@ -350,30 +349,27 @@ if_convertible_phi_p (struct loop *loop, basic_block bb, gimple phi)\n   return true;\n }\n \n-/* Return true, if STMT is if-convertible.\n+/* Return true when STMT is if-convertible.\n+\n    GIMPLE_ASSIGN statement is not if-convertible if,\n    - it is not movable,\n    - it could trap,\n    - LHS is not var decl.\n+\n    GIMPLE_ASSIGN is part of block BB, which is inside loop LOOP.  */\n \n static bool\n if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n     \t\t\t\t     gimple stmt)\n {\n-  tree lhs;\n-\n-  if (!is_gimple_assign (stmt))\n-    return false;\n+  tree lhs = gimple_assign_lhs (stmt);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"-------------------------\\n\");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n     }\n \n-  lhs = gimple_assign_lhs (stmt);\n-\n   /* Some of these constrains might be too conservative.  */\n   if (stmt_ends_bb_p (stmt)\n       || gimple_has_volatile_ops (stmt)\n@@ -410,30 +406,26 @@ if_convertible_gimple_assign_stmt_p (struct loop *loop, basic_block bb,\n   return true;\n }\n \n-/* Return true, iff STMT is if-convertible.\n-   Statement is if-convertible if,\n-   - it is if-convertible GIMPLE_ASSGIN,\n-   - it is GIMPLE_LABEL or GIMPLE_COND.\n-   STMT is inside block BB, which is inside loop LOOP.  */\n+/* Return true when STMT is if-convertible.\n+\n+   A statement is if-convertible if:\n+   - it is an if-convertible GIMPLE_ASSGIN,\n+   - it is a GIMPLE_LABEL or a GIMPLE_COND.\n+\n+   STMT is inside BB, which is inside loop LOOP.  */\n \n static bool\n if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n {\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_LABEL:\n-      break;\n-\n     case GIMPLE_DEBUG:\n-      break;\n+    case GIMPLE_COND:\n+      return true;\n \n     case GIMPLE_ASSIGN:\n-      if (!if_convertible_gimple_assign_stmt_p (loop, bb, stmt))\n-\treturn false;\n-      break;\n-\n-    case GIMPLE_COND:\n-      break;\n+      return if_convertible_gimple_assign_stmt_p (loop, bb, stmt);\n \n     default:\n       /* Don't know what to do with 'em so don't do anything.  */\n@@ -449,14 +441,16 @@ if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n   return true;\n }\n \n-/* Return true, iff BB is if-convertible.\n-   Note: This routine does _not_ check basic block statements and phis.\n-   Basic block is not if-convertible if:\n-   - basic block is non-empty and it is after exit block (in BFS order),\n-   - basic block is after exit block but before latch,\n-   - basic block edge(s) is not normal.\n-   EXIT_BB_SEEN is true if basic block with exit edge is already seen.\n-   BB is inside loop LOOP.  */\n+/* Return true when BB is if-convertible.  This routine does not check\n+   basic block's statements and phis.\n+\n+   A basic block is not if-convertible if:\n+   - it is non-empty and it is after the exit block (in BFS order),\n+   - it is after the exit block but before the latch,\n+   - its edges are not normal.\n+\n+   EXIT_BB is the basic block containing the exit of the LOOP.  BB is\n+   inside LOOP.  */\n \n static bool\n if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n@@ -497,15 +491,15 @@ if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n \t(EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_ABNORMAL | EDGE_IRREDUCIBLE_LOOP))\n       {\n \tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  fprintf (dump_file,\"Difficult to handle edges\\n\");\n+\t  fprintf (dump_file, \"Difficult to handle edges\\n\");\n \treturn false;\n       }\n \n   return true;\n }\n \n-/* Return TRUE iff, all pred blocks of BB are visited.\n-   Bitmap VISITED keeps history of visited blocks.  */\n+/* Return true when all predecessor blocks of BB are visited.  The\n+   VISITED bitmap keeps track of the visited blocks.  */\n \n static bool\n pred_blocks_visited_p (basic_block bb, bitmap *visited)\n@@ -578,7 +572,7 @@ get_loop_body_in_if_conv_order (const struct loop *loop)\n   return blocks;\n }\n \n-/* Return true, iff LOOP is if-convertible.\n+/* Return true when LOOP is if-convertible.\n    LOOP is if-convertible if:\n    - it is innermost,\n    - it has two or more basic blocks,\n@@ -675,10 +669,11 @@ if_convertible_loop_p (struct loop *loop)\n   return true;\n }\n \n-/* During if-conversion aux field from basic block structure is used to hold\n-   predicate list.  Clean each basic block's predicate list for the given LOOP.\n-   Also clean aux field of successor edges, used to hold true and false\n-   condition from conditional expression.  */\n+/* During if-conversion, the bb->aux field is used to hold a predicate\n+   list.  This function cleans for all the basic blocks in the given\n+   LOOP their predicate list.  It also cleans up the e->aux field of\n+   all the successor edges: e->aux is used to hold the true and false\n+   conditions for conditional expressions.  */\n \n static void\n clean_predicate_lists (struct loop *loop)\n@@ -698,9 +693,11 @@ clean_predicate_lists (struct loop *loop)\n   free (bb);\n }\n \n-/* Basic block BB has two predecessors. Using predecessor's aux field, set\n-   appropriate condition COND for the PHI node replacement.  Return true block\n-   whose phi arguments are selected when cond is true.  */\n+/* Basic block BB has two predecessors.  Using predecessor's bb->aux\n+   field, set appropriate condition COND for the PHI node replacement.\n+   Return true block whose phi arguments are selected when cond is\n+   true.  LOOP is the loop containing the if-converted region, GSI is\n+   the place to insert the code for the if-conversion.  */\n \n static basic_block\n find_phi_replacement_condition (struct loop *loop,\n@@ -759,37 +756,34 @@ find_phi_replacement_condition (struct loop *loop,\n     {\n       *cond = (tree) (second_edge->src)->aux;\n \n-      /* If there is a condition on an incoming edge,\n-\t AND it with the incoming bb predicate.  */\n+      /* If there is a condition on an incoming edge, add it to the\n+\t incoming bb predicate.  */\n       if (second_edge->aux)\n \t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t*cond, (tree) second_edge->aux);\n \n       if (TREE_CODE (*cond) == TRUTH_NOT_EXPR)\n-\t/* We can be smart here and choose inverted\n-\t   condition without switching bbs.  */\n \t*cond = invert_truthvalue (*cond);\n       else\n \t/* Select non loop header bb.  */\n \tfirst_edge = second_edge;\n     }\n   else\n     {\n-      /* FIRST_BB is not loop header */\n       *cond = (tree) (first_edge->src)->aux;\n \n-      /* If there is a condition on an incoming edge,\n-\t AND it with the incoming bb predicate.  */\n+      /* If there is a condition on an incoming edge, add it to the\n+\t incoming bb predicate.  */\n       if (first_edge->aux)\n \t*cond = build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t*cond, (tree) first_edge->aux);\n     }\n \n-  /* Create temp. for the condition. Vectorizer prefers to have gimple\n-     value as condition. Various targets use different means to communicate\n-     condition in vector compare operation. Using gimple value allows\n-     compiler to emit vector compare and select RTL without exposing\n-     compare's result.  */\n+  /* Gimplify the condition: the vectorizer prefers to have gimple\n+     values as conditions.  Various targets use different means to\n+     communicate conditions in vector compare operations.  Using a\n+     gimple value allows the compiler to emit vector compare and\n+     select RTL without exposing compare's result.  */\n   *cond = force_gimple_operand_gsi (gsi, unshare_expr (*cond),\n \t\t\t\t    false, NULL_TREE,\n \t\t\t\t    true, GSI_SAME_STMT);\n@@ -807,16 +801,17 @@ find_phi_replacement_condition (struct loop *loop,\n   return first_edge->src;\n }\n \n+/* Replace PHI node with conditional modify expr using COND.  This\n+   routine does not handle PHI nodes with more than two arguments.\n \n-/* Replace PHI node with conditional modify expr using COND.\n-   This routine does not handle PHI nodes with more than two arguments.\n    For example,\n      S1: A = PHI <x1(1), x2(5)\n    is converted into,\n      S2: A = cond ? x1 : x2;\n-   S2 is inserted at the top of basic block's statement list.\n-   When COND is true, phi arg from TRUE_BB is selected.\n-*/\n+\n+   The generated code is inserted at GSI that points to the top of\n+   basic block's statement list.  When COND is true, phi arg from\n+   TRUE_BB is selected.  */\n \n static void\n replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n@@ -828,12 +823,9 @@ replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n   tree rhs;\n   tree arg_0, arg_1;\n \n-  gcc_assert (gimple_code (phi) == GIMPLE_PHI);\n+  gcc_assert (gimple_code (phi) == GIMPLE_PHI\n+\t      && gimple_phi_num_args (phi) == 2);\n \n-  /* If this is not filtered earlier, then now it is too late.  */\n-  gcc_assert (gimple_phi_num_args (phi) == 2);\n-\n-  /* Find basic block and initialize iterator.  */\n   bb = gimple_bb (phi);\n \n   /* Use condition that is not TRUTH_NOT_EXPR in conditional modify expr.  */\n@@ -853,13 +845,8 @@ replace_phi_with_cond_gimple_assign_stmt (gimple phi, tree cond,\n \t        unshare_expr (cond), unshare_expr (arg_0),\n \t        unshare_expr (arg_1));\n \n-  /* Create new GIMPLE_ASSIGN statement using RHS.  */\n   new_stmt = gimple_build_assign (unshare_expr (PHI_RESULT (phi)), rhs);\n-\n-  /* Make new statement definition of the original phi result.  */\n   SSA_NAME_DEF_STMT (gimple_phi_result (phi)) = new_stmt;\n-\n-  /* Insert using iterator.  */\n   gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n   update_stmt (new_stmt);\n \n@@ -908,7 +895,6 @@ process_phi_nodes (struct loop *loop)\n \t}\n       set_phi_nodes (bb, NULL);\n     }\n-  return;\n }\n \n /* Combine all the basic blocks from LOOP into one or two super basic\n@@ -926,8 +912,8 @@ combine_blocks (struct loop *loop)\n   /* Process phi nodes to prepare blocks for merge.  */\n   process_phi_nodes (loop);\n \n-  /* Merge basic blocks.  First remove all the edges in the loop, except\n-     for those from the exit block.  */\n+  /* Merge basic blocks: first remove all the edges in the loop,\n+     except for those from the exit block.  */\n   exit_bb = NULL;\n   for (i = 0; i < orig_loop_num_nodes; i++)\n     {\n@@ -957,7 +943,7 @@ combine_blocks (struct loop *loop)\n     {\n       if (exit_bb != loop->header)\n \t{\n-\t  /* Connect this node with loop header.  */\n+\t  /* Connect this node to loop header.  */\n \t  make_edge (loop->header, exit_bb, EDGE_FALLTHRU);\n \t  set_immediate_dominator (CDI_DOMINATORS, exit_bb, loop->header);\n \t}\n@@ -972,7 +958,7 @@ combine_blocks (struct loop *loop)\n     }\n   else\n     {\n-      /* If the loop does not have exit then reconnect header and latch.  */\n+      /* If the loop does not have an exit, reconnect header and latch.  */\n       make_edge (loop->header, loop->latch, EDGE_FALLTHRU);\n       set_immediate_dominator (CDI_DOMINATORS, loop->latch, loop->header);\n     }\n@@ -1008,30 +994,30 @@ combine_blocks (struct loop *loop)\n       delete_basic_block (bb);\n     }\n \n-  /* Now if possible, merge loop header and block with exit edge.\n-     This reduces number of basic blocks to 2.  Auto vectorizer addresses\n-     loops with two nodes only.  FIXME: Use cleanup_tree_cfg().  */\n+  /* If possible, merge loop header to the block with the exit edge.\n+     This reduces the number of basic blocks to two, to please the\n+     vectorizer that handles only loops with two nodes.\n+\n+     FIXME: Call cleanup_tree_cfg.  */\n   if (exit_bb\n       && exit_bb != loop->header\n       && can_merge_blocks_p (loop->header, exit_bb))\n     merge_blocks (loop->header, exit_bb);\n }\n \n-/* Main entry point.  Apply if-conversion to the LOOP.  Return true if\n-   successful otherwise return false.  If false is returned then loop\n-   remains unchanged.  */\n+/* Main entry point: return true when LOOP is if-converted, otherwise\n+   the loop remains unchanged.  */\n \n static bool\n tree_if_conversion (struct loop *loop)\n {\n-  basic_block bb;\n   gimple_stmt_iterator itr;\n   unsigned int i;\n \n   ifc_bbs = NULL;\n \n   /* If-conversion is not appropriate for all loops.  First, check if\n-     loop is if-convertible or not.  */\n+     the loop is if-convertible.  */\n   if (!if_convertible_loop_p (loop))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1045,17 +1031,12 @@ tree_if_conversion (struct loop *loop)\n       return false;\n     }\n \n-  /* Do actual work now.  */\n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      tree cond;\n-\n-      bb = ifc_bbs [i];\n-\n-      /* Update condition using predicate list.  */\n-      cond = (tree) bb->aux;\n+      basic_block bb = ifc_bbs [i];\n+      tree cond = (tree) bb->aux;\n \n-      /* Process all statements in this basic block.\n+      /* Process all the statements in this basic block.\n \t Remove conditional expression, if any, and annotate\n \t destination basic block(s) appropriately.  */\n       for (itr = gsi_start_bb (bb); !gsi_end_p (itr); /* empty */)\n@@ -1072,9 +1053,9 @@ tree_if_conversion (struct loop *loop)\n \t{\n \t  basic_block bb_n = single_succ (bb);\n \n-\t  /* Successor bb inherits predicate of its predecessor.  If there\n-\t     is no predicate in predecessor bb, then consider successor bb\n-\t     as always executed.  */\n+\t  /* The successor bb inherits the predicate of its\n+\t     predecessor.  If there is no predicate in the predecessor\n+\t     bb, then consider the successor bb as always executed.  */\n \t  if (cond == NULL_TREE)\n \t    cond = boolean_true_node;\n \n@@ -1083,8 +1064,8 @@ tree_if_conversion (struct loop *loop)\n     }\n \n   /* Now, all statements are if-converted and basic blocks are\n-     annotated appropriately.  Combine all basic block into one huge\n-     basic block.  */\n+     annotated appropriately.  Combine all the basic blocks into one\n+     huge basic block.  */\n   combine_blocks (loop);\n \n   /* clean up */"}]}