{"sha": "70b303049e45c180236a4114f844311652bad002", "node_id": "C_kwDOANBUbNoAKDcwYjMwMzA0OWU0NWMxODAyMzZhNDExNGY4NDQzMTE2NTJiYWQwMDI", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-12-07T19:51:59Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-12-14T18:20:53Z"}, "message": "btf: correct generation for extern funcs [PR106773]\n\nThe eBPF loader expects to find entries for functions declared as extern\nin the corresponding BTF_KIND_DATASEC record, but we were not generating\nthese entries.\n\nThis patch adds support for the 'extern' linkage of function types in\nBTF, and creates entries for for them BTF_KIND_DATASEC records as needed.\n\n\tPR target/106773\n\ngcc/\n\n\t* btfout.cc (get_section_name): New function.\n\t(btf_collect_datasec): Use it here. Process functions, marking them\n\t'extern' and generating DATASEC entries for them as appropriate. Move\n\tcreation of BTF_KIND_FUNC records to here...\n\t(btf_dtd_emit_preprocess_cb): ... from here.\n\ngcc/testsuite/\n\n\t* gcc.dg/debug/btf/btf-datasec-2.c: New test.\n\t* gcc.dg/debug/btf/btf-function-6.c: New test.\n\ninclude/\n\n\t* btf.h (enum btf_func_linkage): New.\n\t(struct btf_var_secinfo): Update comments with notes about extern\n\tfunctions.", "tree": {"sha": "b43b62a7a552c0d8ca4a21596aaf950c50bbd3df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b43b62a7a552c0d8ca4a21596aaf950c50bbd3df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70b303049e45c180236a4114f844311652bad002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b303049e45c180236a4114f844311652bad002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b303049e45c180236a4114f844311652bad002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b303049e45c180236a4114f844311652bad002/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f7aa145b796c044526c93f390e68f3b56a1b30a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7aa145b796c044526c93f390e68f3b56a1b30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7aa145b796c044526c93f390e68f3b56a1b30a"}], "stats": {"total": 194, "additions": 148, "deletions": 46}, "files": [{"sha": "a423fabc0b522bae261be02bd64c879f29a91f8a", "filename": "gcc/btfout.cc", "status": "modified", "additions": 87, "deletions": 42, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b303049e45c180236a4114f844311652bad002/gcc%2Fbtfout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b303049e45c180236a4114f844311652bad002/gcc%2Fbtfout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbtfout.cc?ref=70b303049e45c180236a4114f844311652bad002", "patch": "@@ -290,7 +290,35 @@ btf_datasec_push_entry (ctf_container_ref ctfc, const char *secname,\n   ds.entries.safe_push (info);\n \n   datasecs.safe_push (ds);\n-  num_types_created++;\n+}\n+\n+\n+/* Return the section name, as of interest to btf_collect_datasec, for the\n+   given symtab node.  Note that this deliberately returns NULL for objects\n+   which do not go in a section btf_collect_datasec cares about.  */\n+static const char *\n+get_section_name (symtab_node *node)\n+{\n+  const char *section_name = node->get_section ();\n+\n+  if (section_name == NULL)\n+    {\n+      switch (categorize_decl_for_section (node->decl, 0))\n+\t{\n+\tcase SECCAT_BSS:\n+\t  section_name = \".bss\";\n+\t  break;\n+\tcase SECCAT_DATA:\n+\t  section_name = \".data\";\n+\t  break;\n+\tcase SECCAT_RODATA:\n+\t  section_name = \".rodata\";\n+\t  break;\n+\tdefault:;\n+\t}\n+    }\n+\n+  return section_name;\n }\n \n /* Construct all BTF_KIND_DATASEC records for CTFC. One such record is created\n@@ -301,7 +329,60 @@ btf_datasec_push_entry (ctf_container_ref ctfc, const char *secname,\n static void\n btf_collect_datasec (ctf_container_ref ctfc)\n {\n-  /* See cgraph.h struct symtab_node, which varpool_node extends.  */\n+  cgraph_node *func;\n+  FOR_EACH_FUNCTION (func)\n+    {\n+      dw_die_ref die = lookup_decl_die (func->decl);\n+      if (die == NULL)\n+\tcontinue;\n+\n+      ctf_dtdef_ref dtd = ctf_dtd_lookup (ctfc, die);\n+      if (dtd == NULL)\n+\tcontinue;\n+\n+      /* Functions actually get two types: a BTF_KIND_FUNC_PROTO, and\n+\t also a BTF_KIND_FUNC.  But the CTF container only allocates one\n+\t type per function, which matches closely with BTF_KIND_FUNC_PROTO.\n+\t For each such function, also allocate a BTF_KIND_FUNC entry.\n+\t These will be output later.  */\n+      ctf_dtdef_ref func_dtd = ggc_cleared_alloc<ctf_dtdef_t> ();\n+      func_dtd->dtd_data = dtd->dtd_data;\n+      func_dtd->dtd_data.ctti_type = dtd->dtd_type;\n+      func_dtd->linkage = dtd->linkage;\n+      func_dtd->dtd_type = num_types_added + num_types_created;\n+\n+      /* Only the BTF_KIND_FUNC type actually references the name. The\n+\t BTF_KIND_FUNC_PROTO is always anonymous.  */\n+      dtd->dtd_data.ctti_name = 0;\n+\n+      vec_safe_push (funcs, func_dtd);\n+      num_types_created++;\n+\n+      /* Mark any 'extern' funcs and add DATASEC entries for them.  */\n+      if (DECL_EXTERNAL (func->decl))\n+\t{\n+\t  func_dtd->linkage = BTF_FUNC_EXTERN;\n+\n+\t  const char *section_name = get_section_name (func);\n+\t  /* Note: get_section_name () returns NULL for functions in text\n+\t     section.  This is intentional, since we do not want to generate\n+\t     DATASEC entries for them.  */\n+\t  if (section_name == NULL)\n+\t    continue;\n+\n+\t  struct btf_var_secinfo info;\n+\n+\t  /* +1 for the sentinel type not in the types map.  */\n+\t  info.type = func_dtd->dtd_type + 1;\n+\n+\t  /* Both zero at compile time.  */\n+\t  info.size = 0;\n+\t  info.offset = 0;\n+\n+\t  btf_datasec_push_entry (ctfc, section_name, info);\n+\t}\n+    }\n+\n   varpool_node *node;\n   FOR_EACH_VARIABLE (node)\n     {\n@@ -313,28 +394,13 @@ btf_collect_datasec (ctf_container_ref ctfc)\n       if (dvd == NULL)\n \tcontinue;\n \n-      const char *section_name = node->get_section ();\n       /* Mark extern variables.  */\n       if (DECL_EXTERNAL (node->decl))\n \tdvd->dvd_visibility = BTF_VAR_GLOBAL_EXTERN;\n \n+      const char *section_name = get_section_name (node);\n       if (section_name == NULL)\n-\t{\n-\t  switch (categorize_decl_for_section (node->decl, 0))\n-\t    {\n-\t    case SECCAT_BSS:\n-\t      section_name = \".bss\";\n-\t      break;\n-\t    case SECCAT_DATA:\n-\t      section_name = \".data\";\n-\t      break;\n-\t    case SECCAT_RODATA:\n-\t      section_name = \".rodata\";\n-\t      break;\n-\t    default:\n-\t      continue;\n-\t    }\n-\t}\n+\tcontinue;\n \n       struct btf_var_secinfo info;\n \n@@ -359,6 +425,8 @@ btf_collect_datasec (ctf_container_ref ctfc)\n \n       btf_datasec_push_entry (ctfc, section_name, info);\n     }\n+\n+  num_types_created += datasecs.length ();\n }\n \n /* Return true if the type ID is that of a type which will not be emitted (for\n@@ -463,29 +531,6 @@ btf_dtd_emit_preprocess_cb (ctf_container_ref ctfc, ctf_dtdef_ref dtd)\n   if (!btf_emit_id_p (dtd->dtd_type))\n     return;\n \n-  uint32_t btf_kind\n-    = get_btf_kind (CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info));\n-\n-  if (btf_kind == BTF_KIND_FUNC_PROTO)\n-    {\n-      /* Functions actually get two types: a BTF_KIND_FUNC_PROTO, and\n-\t also a BTF_KIND_FUNC. But the CTF container only allocates one\n-\t type per function, which matches closely with BTF_KIND_FUNC_PROTO.\n-\t For each such function, also allocate a BTF_KIND_FUNC entry.\n-\t These will be output later.  */\n-      ctf_dtdef_ref func_dtd = ggc_cleared_alloc<ctf_dtdef_t> ();\n-      func_dtd->dtd_data = dtd->dtd_data;\n-      func_dtd->dtd_data.ctti_type = dtd->dtd_type;\n-      func_dtd->linkage = dtd->linkage;\n-\n-      vec_safe_push (funcs, func_dtd);\n-      num_types_created++;\n-\n-      /* Only the BTF_KIND_FUNC type actually references the name. The\n-\t BTF_KIND_FUNC_PROTO is always anonymous.  */\n-      dtd->dtd_data.ctti_name = 0;\n-    }\n-\n   ctfc->ctfc_num_vlen_bytes += btf_calc_num_vbytes (dtd);\n }\n "}, {"sha": "f4b298cf019daa08f6bf6e6c92b509cf6ff99550", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-datasec-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b303049e45c180236a4114f844311652bad002/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b303049e45c180236a4114f844311652bad002/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-2.c?ref=70b303049e45c180236a4114f844311652bad002", "patch": "@@ -0,0 +1,28 @@\n+/* Test BTF generation of DATASEC records for extern functions.\n+\n+   Only functions declared extern should have entries in DATASEC records.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Expect one DATASEC with vlen=1 (.foo_sec) and one with vlen=2 (.bar_sec) */\n+/* { dg-final { scan-assembler-times \"0xf000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0xf000001\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* Function entries should have offset and size of 0 at compile time.  */\n+/* { dg-final { scan-assembler-times \"0\\[\\t \\]+\\[^\\n\\]*bts_offset\" 3 } } */\n+/* { dg-final { scan-assembler-times \"0\\[\\t \\]+\\[^\\n\\]*bts_size\" 3 } } */\n+\n+extern int foo (int a) __attribute__((section(\".foo_sec\")));\n+\n+\n+extern int bar (int b) __attribute__((section(\".bar_sec\")));\n+extern void chacha (void) __attribute__((section(\".bar_sec\")));\n+\n+__attribute__((section(\".foo_sec\")))\n+void baz (int *x)\n+{\n+  chacha ();\n+\n+  *x = foo (bar (*x));\n+}"}, {"sha": "48a946ab14b8be71fbe21d01101bb6d872906391", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-function-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b303049e45c180236a4114f844311652bad002/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b303049e45c180236a4114f844311652bad002/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-6.c?ref=70b303049e45c180236a4114f844311652bad002", "patch": "@@ -0,0 +1,19 @@\n+/* Test BTF extern linkage for functions.\n+\n+   We expect to see one BTF_KIND_FUNC type with global linkage (foo), and\n+   one BTF_KIND_FUNC type with extern linkage (extfunc).  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"btt_info: kind=12, kflag=0, linkage=2\" 1 } } */\n+/* { dg-final { scan-assembler-times \"btt_info: kind=12, kflag=0, linkage=1\" 1 } } */\n+\n+extern int extfunc(int a, int b);\n+\n+int foo (int x) {\n+\n+  int y = extfunc (x, x+1);\n+\n+  return y;\n+}"}, {"sha": "2f8f6f68b27a93fbe5eb68fb5a70be5cbb96298c", "filename": "include/btf.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b303049e45c180236a4114f844311652bad002/include%2Fbtf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b303049e45c180236a4114f844311652bad002/include%2Fbtf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fbtf.h?ref=70b303049e45c180236a4114f844311652bad002", "patch": "@@ -178,6 +178,15 @@ struct btf_param\n   uint32_t type;\t/* Type of parameter.  */\n };\n \n+/* BTF_KIND_FUNC records encode linkage information in the VLEN bits\n+   of the type record.  These are the supported values.  */\n+enum btf_func_linkage\n+{\n+  BTF_FUNC_STATIC = 0,\n+  BTF_FUNC_GLOBAL = 1,\n+  BTF_FUNC_EXTERN = 2,\n+};\n+\n /* BTF_KIND_VAR records encode linkage information in a single\n    trailing struct btf_var.  These are the supported values.  */\n enum btf_var_linkage\n@@ -195,12 +204,13 @@ struct btf_var\n };\n \n /* BTF_KIND_DATASEC is followed by VLEN struct btf_var_secinfo entries,\n-   which describe all BTF_KIND_VAR types contained in the section.  */\n+   which describe all BTF_KIND_VAR or extern BTF_KIND_FUNC types contained\n+   in the section.  */\n struct btf_var_secinfo\n {\n-  uint32_t type;\t/* Type of variable.  */\n-  uint32_t offset;\t/* In-section offset of variable (in bytes).  */\n-  uint32_t size;\t/* Size (in bytes) of variable.  */\n+  uint32_t type;\t/* Type of BTF_KIND_VAR or BTF_KIND_FUNC item.  */\n+  uint32_t offset;\t/* In-section offset (in bytes) of item.  */\n+  uint32_t size;\t/* Size (in bytes) of item.  */\n };\n \n /* BTF_KIND_ENUM64 is followed by VLEN struct btf_enum64 entries,"}]}