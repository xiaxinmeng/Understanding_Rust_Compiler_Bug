{"sha": "8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3NGIzOTc2NWIyMjIxMmEzYjRlYzEzOGIyY2MzYjkzOGNjYzlkOA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-07-31T02:33:46Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-07-31T02:33:46Z"}, "message": "Leave the loop_latch basic block empty.\n\n2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* cfgloop.h (create_empty_loop_on_edge): Pass an extra argument.\n\t* cfgloopmanip.c (create_empty_loop_on_edge): Leave the loop_latch\n\tbasic block empty.\n\nFrom-SVN: r150293", "tree": {"sha": "85edd3d66198b38bc8add2a6dbdcd982a8bf9208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85edd3d66198b38bc8add2a6dbdcd982a8bf9208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109e0d57fa2f3bda5793cf58143654a9d042ce5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/109e0d57fa2f3bda5793cf58143654a9d042ce5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/109e0d57fa2f3bda5793cf58143654a9d042ce5f"}], "stats": {"total": 92, "additions": 52, "deletions": 40}, "files": [{"sha": "448a47177a1a8516ee3ee96fb08446d0b7e0cc4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "patch": "@@ -1,3 +1,9 @@\n+2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* cfgloop.h (create_empty_loop_on_edge): Pass an extra argument.\n+\t* cfgloopmanip.c (create_empty_loop_on_edge): Leave the loop_latch\n+\tbasic block empty.\n+\n 2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* doc/invoke.texi (-fgraphite-force-parallel): Documented."}, {"sha": "93fa12e5e3e687e35741004d378d2fb017db725b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "patch": "@@ -283,7 +283,7 @@ extern bool can_duplicate_loop_p (const struct loop *loop);\n \n extern edge create_empty_if_region_on_edge (edge, tree);\n extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n-\t\t\t\t\t       tree *, struct loop *);\n+\t\t\t\t\t       tree *, tree *, struct loop *);\n extern struct loop * duplicate_loop (struct loop *, struct loop *);\n extern bool duplicate_loop_to_header_edge (struct loop *, edge, \n \t\t\t\t\t   unsigned, sbitmap, edge,"}, {"sha": "40e3f8e9a596db5da916b142e29ee1c87e7c955d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e74b39765b22212a3b4ec138b2cc3b938ccc9d8/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=8e74b39765b22212a3b4ec138b2cc3b938ccc9d8", "patch": "@@ -588,52 +588,55 @@ create_empty_if_region_on_edge (edge entry_edge, tree condition)\n \n /* create_empty_loop_on_edge\n    |\n-   |     -------------                 ------------------------\n-   |     |  pred_bb  |                 |  pred_bb              |\n-   |     -------------                 |  IV_0 = INITIAL_VALUE |\n-   |           |                       ------------------------\n-   |           |                       ______    | ENTRY_EDGE\n-   |           | ENTRY_EDGE           /      V   V\n-   |           |             ====>   |     -----------------------------\n-   |           |                     |     | IV_BEFORE = phi (IV_0, IV) |\n-   |           |                     |     | loop_header                |\n-   |           V                     |     | IV_BEFORE <= UPPER_BOUND   |\n-   |     -------------               |     -----------------------\\-----\n-   |     |  succ_bb  |               |         |                   \\\n-   |     -------------               |         |                    \\ exit_e\n-   |                                 |         V                     V---------\n-   |                                 |      --------------           | succ_bb |\n-   |                                 |      | loop_latch  |          ----------\n-   |                                 |      |IV = IV_BEFORE + STRIDE\n-   |                                 |      --------------\n-   |                                  \\       /\n-   |                                   \\ ___ /\n+   |    - pred_bb -                   ------ pred_bb ------\n+   |   |           |                 | iv0 = initial_value |\n+   |    -----|-----                   ---------|-----------\n+   |         |                       ______    | entry_edge\n+   |         | entry_edge           /      |   |\n+   |         |             ====>   |      -V---V- loop_header -------------\n+   |         V                     |     | iv_before = phi (iv0, iv_after) |\n+   |    - succ_bb -                |      ---|-----------------------------\n+   |   |           |               |         |\n+   |    -----------                |      ---V--- loop_body ---------------\n+   |                               |     | iv_after = iv_before + stride   |\n+   |                               |     | if (iv_after <= upper_bound)     |\n+   |                               |      ---|--------------\\--------------\n+   |                               |         |               \\ exit_e\n+   |                               |         V                \\\n+   |                               |       - loop_latch -      V- succ_bb -\n+   |                               |      |              |     |           |\n+   |                               |       /-------------       -----------\n+   |                                \\ ___ /\n \n    Creates an empty loop as shown above, the IV_BEFORE is the SSA_NAME\n    that is used before the increment of IV. IV_BEFORE should be used for \n    adding code to the body that uses the IV.  OUTER is the outer loop in\n-   which the new loop should be inserted.  */\n+   which the new loop should be inserted.  \n+\n+   Both INITIAL_VALUE and UPPER_BOUND expressions are gimplified and\n+   inserted on the loop entry edge.  This implies that this function\n+   should be used only when the UPPER_BOUND expression is a loop\n+   invariant.  */\n \n struct loop *\n create_empty_loop_on_edge (edge entry_edge, \n \t\t\t   tree initial_value,\n \t\t\t   tree stride, tree upper_bound,\n \t\t\t   tree iv,\n \t\t\t   tree *iv_before,\n+\t\t\t   tree *iv_after,\n \t\t\t   struct loop *outer)\n {\n   basic_block loop_header, loop_latch, succ_bb, pred_bb;\n   struct loop *loop;\n   int freq;\n   gcov_type cnt;\n   gimple_stmt_iterator gsi;\n-  bool insert_after;\n   gimple_seq stmts;\n   gimple cond_expr;\n   tree exit_test;\n   edge exit_e;\n   int prob;\n-  tree upper_bound_gimplified;\n   \n   gcc_assert (entry_edge && initial_value && stride && upper_bound && iv);\n \n@@ -667,6 +670,11 @@ create_empty_loop_on_edge (edge entry_edge,\n   /* Update dominators.  */\n   update_dominators_in_loop (loop);\n \n+  /* Modify edge flags.  */\n+  exit_e = single_exit (loop);\n+  exit_e->flags = EDGE_LOOP_EXIT | EDGE_FALSE_VALUE;\n+  single_pred_edge (loop_latch)->flags = EDGE_TRUE_VALUE;\n+\n   /* Construct IV code in loop.  */\n   initial_value = force_gimple_operand (initial_value, &stmts, true, iv);\n   if (stmts)\n@@ -675,24 +683,20 @@ create_empty_loop_on_edge (edge entry_edge,\n       gsi_commit_edge_inserts ();\n     }\n \n-  standard_iv_increment_position (loop, &gsi, &insert_after);\n-  create_iv (initial_value, stride, iv, loop, &gsi, insert_after,\n-\t     iv_before, NULL);\n-\n-  /* Modify edge flags.  */\n-  exit_e = single_exit (loop);\n-  exit_e->flags = EDGE_LOOP_EXIT | EDGE_FALSE_VALUE;\n-  single_pred_edge (loop_latch)->flags = EDGE_TRUE_VALUE;\n+  upper_bound = force_gimple_operand (upper_bound, &stmts, true, NULL);\n+  if (stmts)\n+    {\n+      gsi_insert_seq_on_edge (loop_preheader_edge (loop), stmts);\n+      gsi_commit_edge_inserts ();\n+    }\n \n-  gsi = gsi_last_bb (exit_e->src);\n+  gsi = gsi_last_bb (loop_header);\n+  create_iv (initial_value, stride, iv, loop, &gsi, false,\n+\t     iv_before, iv_after);\n \n-  upper_bound_gimplified = \n-    force_gimple_operand_gsi (&gsi, upper_bound, true, NULL,\n-\t\t\t      false, GSI_NEW_STMT);\n-  gsi = gsi_last_bb (exit_e->src);\n-  \n-  cond_expr = gimple_build_cond \n-    (LE_EXPR, *iv_before, upper_bound_gimplified, NULL_TREE, NULL_TREE);\n+  /* Insert loop exit condition.  */\n+  cond_expr = gimple_build_cond\n+    (LE_EXPR, *iv_after, upper_bound, NULL_TREE, NULL_TREE);\n \n   exit_test = gimple_cond_lhs (cond_expr);\n   exit_test = force_gimple_operand_gsi (&gsi, exit_test, true, NULL,\n@@ -701,6 +705,8 @@ create_empty_loop_on_edge (edge entry_edge,\n   gsi = gsi_last_bb (exit_e->src);\n   gsi_insert_after (&gsi, cond_expr, GSI_NEW_STMT);\n \n+  split_block_after_labels (loop_header);\n+\n   return loop;\n }\n "}]}