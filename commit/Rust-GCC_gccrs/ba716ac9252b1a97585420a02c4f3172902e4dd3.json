{"sha": "ba716ac9252b1a97585420a02c4f3172902e4dd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE3MTZhYzkyNTJiMWE5NzU4NTQyMGEwMmM0ZjMxNzI5MDJlNGRkMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-11-20T07:37:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-11-20T07:37:42Z"}, "message": "function.c (nonlocal_goto_handler_slots): Renamed from nonlocal_goto_handler_slot; now an EXPR_LIST chain.\n\n        * function.c (nonlocal_goto_handler_slots): Renamed from\n        nonlocal_goto_handler_slot; now an EXPR_LIST chain.\n        (push_function_context_to): Adjust for this change.\n        (pop_function_context_from): Likewise.\n        (init_function_start): Likewise.\n        (expand_function_end): Likewise.\n        * function.h (struct function): Likewise.\n        * calls.c (expand_call): Likewise.\n        * explow.c (allocate_dynamic_stack_space): Likewise.\n        * expr.h (nonlocal_goto_handler_slots): Rename its declaration.\n        * stmt.c (declare_nonlocal_label): Make a new handler slot for each\n        label.\n        (expand_goto): When doing a nonlocal goto, find corresponding handler\n        slot for it.  Don't put the label address in the static chain register.\n        (expand_end_bindings): Break out nonlocal goto handling code into\n        three new functions.\n        (expand_nl_handler_label, expand_nl_goto_receiver,\n        expand_nl_goto_receivers): New static functions, broken out of\n        expand_end_bindings and adapted to create one handler per nonlocal\n        label.\n        * function.c (delete_handlers): Delete insn if it references any of\n        the nonlocal goto handler slots.\n        * i960.md (nonlocal_goto): Comment out code that modifies\n        static_chain_rtx.\n        * sparc.md (nonlocal_goto): Likewise.\n        (goto_handler_and_restore_v9): Comment out.\n        (goto_handler_and_restore_v9_sp64): Comment out.\n\nFrom-SVN: r23732", "tree": {"sha": "a92aab8090880174e955a4c9c4a9f38938ea2d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a92aab8090880174e955a4c9c4a9f38938ea2d05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba716ac9252b1a97585420a02c4f3172902e4dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba716ac9252b1a97585420a02c4f3172902e4dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba716ac9252b1a97585420a02c4f3172902e4dd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba716ac9252b1a97585420a02c4f3172902e4dd3/comments", "author": null, "committer": null, "parents": [{"sha": "294377f8a5c1027c9e402a0d1bff73c924c59c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294377f8a5c1027c9e402a0d1bff73c924c59c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294377f8a5c1027c9e402a0d1bff73c924c59c28"}], "stats": {"total": 429, "additions": 265, "deletions": 164}, "files": [{"sha": "efd0cd9f4b7dba6306e3c1a60c0ab04205246e17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -1,4 +1,34 @@\n-Thu Nov 19 23:44:38 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+Fri Nov 20 08:34:00 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* function.c (nonlocal_goto_handler_slots): Renamed from\n+\tnonlocal_goto_handler_slot; now an EXPR_LIST chain.\n+\t(push_function_context_to): Adjust for this change.\n+\t(pop_function_context_from): Likewise.\n+\t(init_function_start): Likewise.\n+\t(expand_function_end): Likewise.\n+\t* function.h (struct function): Likewise.\n+\t* calls.c (expand_call): Likewise.\n+\t* explow.c (allocate_dynamic_stack_space): Likewise.\n+\t* expr.h (nonlocal_goto_handler_slots): Rename its declaration.\n+\t* stmt.c (declare_nonlocal_label): Make a new handler slot for each\n+\tlabel.\n+\t(expand_goto): When doing a nonlocal goto, find corresponding handler\n+\tslot for it.  Don't put the label address in the static chain register.\n+\t(expand_end_bindings): Break out nonlocal goto handling code into\n+\tthree new functions.\n+\t(expand_nl_handler_label, expand_nl_goto_receiver,\n+\texpand_nl_goto_receivers): New static functions, broken out of\n+\texpand_end_bindings and adapted to create one handler per nonlocal\n+\tlabel.\n+\t* function.c (delete_handlers): Delete insn if it references any of\n+\tthe nonlocal goto handler slots.\n+\t* i960.md (nonlocal_goto): Comment out code that modifies\n+\tstatic_chain_rtx.\n+\t* sparc.md (nonlocal_goto): Likewise.\n+\t(goto_handler_and_restore_v9): Comment out.\n+\t(goto_handler_and_restore_v9_sp64): Comment out.\n+\n+Thu Nov 19 23:44:38 1998  \n \n \t* expr.c (STACK_BYTES): Delete unused macro.\n \t* calls.c: Provide default for PREFERRED_STACK_BOUNDARY."}, {"sha": "79cae9f6998ecd60cee472f35d096655cbacd4db", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -2204,7 +2204,7 @@ expand_call (exp, target, ignore)\n      Check for the handler slots since we might not have a save area\n      for non-local gotos.  */\n \n-  if (may_be_alloca && nonlocal_goto_handler_slot != 0)\n+  if (may_be_alloca && nonlocal_goto_handler_slots != 0)\n     emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n \n   pop_temp_slots ();"}, {"sha": "ef8848473d37e7e2a5d521b762c0a64744f4a8a1", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -2343,13 +2343,15 @@\n \t\t\t   plus_constant (fp, 8)),\n \t\t  new_pc);\n \n+#if 0\n   /* Next, we put the value into the static chain register's save\n      area on the stack.  After the ret below, this will be loaded into\n      r3 (the static chain).  */\n      \n   emit_move_insn (gen_rtx (MEM, SImode,\n \t\t\t   plus_constant (fp, 12)),\n \t\t  val);\n+#endif\n \n   /* We now load pfp (the previous frame pointer) with the value that\n      we want fp to be.  */"}, {"sha": "59fcd59afb550d40a2c48cd56ac146ce3b9f930d", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -7686,6 +7686,8 @@\n      really needed.  */\n   /*emit_insn (gen_rtx_USE (VOIDmode, frame_pointer_rtx));*/\n   emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\n+#if 0\n   /* Return, restoring reg window and jumping to goto handler.  */\n   if (TARGET_V9 && GET_CODE (chain) == CONST_INT\n       && ! (INTVAL (chain) & ~(HOST_WIDE_INT)0xffffffff))\n@@ -7697,6 +7699,8 @@\n     }\n   /* Put in the static chain register the nonlocal label address.  */\n   emit_move_insn (static_chain_rtx, chain);\n+#endif\n+\n   emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n   emit_insn (gen_goto_handler_and_restore (labreg));\n   emit_barrier ();\n@@ -7718,27 +7722,27 @@\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n \n-(define_insn \"goto_handler_and_restore_v9\"\n-  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t\t     (match_operand:SI 1 \"register_operand\" \"=r,r\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n-  \"TARGET_V9 && ! TARGET_ARCH64\"\n-  \"@\n-   return\\\\t%0+0\\\\n\\\\tmov\\\\t%2, %Y1\n-   sethi\\\\t%%hi(%2), %1\\\\n\\\\treturn\\\\t%0+0\\\\n\\\\tor\\\\t%Y1, %%lo(%2), %Y1\"\n-  [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"2,3\")])\n-\n-(define_insn \"*goto_handler_and_restore_v9_sp64\"\n-  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t\t     (match_operand:DI 1 \"register_operand\" \"=r,r\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n-  \"TARGET_V9 && TARGET_ARCH64\"\n-  \"@\n-   return\\\\t%0+0\\\\n\\\\tmov\\\\t%2, %Y1\n-   sethi\\\\t%%hi(%2), %1\\\\n\\\\treturn\\\\t%0+0\\\\n\\\\tor\\\\t%Y1, %%lo(%2), %Y1\"\n-  [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"2,3\")])\n+;;(define_insn \"goto_handler_and_restore_v9\"\n+;;  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"=r,r\")\n+;;\t\t     (match_operand:SI 1 \"register_operand\" \"=r,r\")\n+;;\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n+;;  \"TARGET_V9 && ! TARGET_ARCH64\"\n+;;  \"@\n+;;   return\\\\t%0+0\\\\n\\\\tmov\\\\t%2, %Y1\n+;;   sethi\\\\t%%hi(%2), %1\\\\n\\\\treturn\\\\t%0+0\\\\n\\\\tor\\\\t%Y1, %%lo(%2), %Y1\"\n+;;  [(set_attr \"type\" \"misc\")\n+;;   (set_attr \"length\" \"2,3\")])\n+;;\n+;;(define_insn \"*goto_handler_and_restore_v9_sp64\"\n+;;  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"=r,r\")\n+;;\t\t     (match_operand:DI 1 \"register_operand\" \"=r,r\")\n+;;\t\t     (match_operand:SI 2 \"const_int_operand\" \"I,n\")] 3)]\n+;;  \"TARGET_V9 && TARGET_ARCH64\"\n+;;  \"@\n+;;   return\\\\t%0+0\\\\n\\\\tmov\\\\t%2, %Y1\n+;;   sethi\\\\t%%hi(%2), %1\\\\n\\\\treturn\\\\t%0+0\\\\n\\\\tor\\\\t%Y1, %%lo(%2), %Y1\"\n+;;  [(set_attr \"type\" \"misc\")\n+;;   (set_attr \"length\" \"2,3\")])\n \n ;; Pattern for use after a setjmp to store FP and the return register\n ;; into the stack area."}, {"sha": "e4ef27dc37f7b7a0b552acf8809486375338a80e", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -1303,7 +1303,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n #endif\n \n   /* Record the new stack level for nonlocal gotos.  */\n-  if (nonlocal_goto_handler_slot != 0)\n+  if (nonlocal_goto_handler_slots != 0)\n     emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n \n   return target;"}, {"sha": "896bded1456b51b0a853c81d141a6632cc972ad9", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -105,10 +105,12 @@ extern int inhibit_defer_pop;\n \n extern int function_call_count;\n \n-/* RTX for stack slot that holds the current handler for nonlocal gotos.\n+/* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n+   for nonlocal gotos.  There is one for every nonlocal label in the function;\n+   this list matches the one in nonlocal_labels.\n    Zero when function does not have nonlocal labels.  */\n \n-extern rtx nonlocal_goto_handler_slot;\n+extern rtx nonlocal_goto_handler_slots;\n \n /* RTX for stack slot that holds the stack pointer value to restore\n    for a nonlocal goto."}, {"sha": "d9575cc0ca3c9ff42c3705bda7f442c1f30d753f", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -247,10 +247,12 @@ int function_call_count;\n \n tree nonlocal_labels;\n \n-/* RTX for stack slot that holds the current handler for nonlocal gotos.\n+/* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n+   for nonlocal gotos.  There is one for every nonlocal label in the function;\n+   this list matches the one in nonlocal_labels.\n    Zero when function does not have nonlocal labels.  */\n \n-rtx nonlocal_goto_handler_slot;\n+rtx nonlocal_goto_handler_slots;\n \n /* RTX for stack slot that holds the stack pointer value to restore\n    for a nonlocal goto.\n@@ -532,7 +534,7 @@ push_function_context_to (context)\n   p->parm_reg_stack_loc = parm_reg_stack_loc;\n   p->outgoing_args_size = current_function_outgoing_args_size;\n   p->return_rtx = current_function_return_rtx;\n-  p->nonlocal_goto_handler_slot = nonlocal_goto_handler_slot;\n+  p->nonlocal_goto_handler_slots = nonlocal_goto_handler_slots;\n   p->nonlocal_goto_stack_level = nonlocal_goto_stack_level;\n   p->nonlocal_labels = nonlocal_labels;\n   p->cleanup_label = cleanup_label;\n@@ -616,7 +618,7 @@ pop_function_context_from (context)\n   parm_reg_stack_loc = p->parm_reg_stack_loc;\n   current_function_outgoing_args_size = p->outgoing_args_size;\n   current_function_return_rtx = p->return_rtx;\n-  nonlocal_goto_handler_slot = p->nonlocal_goto_handler_slot;\n+  nonlocal_goto_handler_slots = p->nonlocal_goto_handler_slots;\n   nonlocal_goto_stack_level = p->nonlocal_goto_stack_level;\n   nonlocal_labels = p->nonlocal_labels;\n   cleanup_label = p->cleanup_label;\n@@ -3664,13 +3666,22 @@ delete_handlers ()\n \t\tTREE_CHAIN (last_t) = TREE_CHAIN (t);\n \t    }\n \t}\n-      if (GET_CODE (insn) == INSN\n-\t  && ((nonlocal_goto_handler_slot != 0\n-\t       && reg_mentioned_p (nonlocal_goto_handler_slot, PATTERN (insn)))\n+      if (GET_CODE (insn) == INSN)\n+\t{\n+\t  int can_delete = 0;\n+\t  rtx t;\n+\t  for (t = nonlocal_goto_handler_slots; t != 0; t = XEXP (t, 1))\n+\t    if (reg_mentioned_p (t, PATTERN (insn)))\n+\t      {\n+\t\tcan_delete = 1;\n+\t\tbreak;\n+\t      }\n+\t  if (can_delete\n \t      || (nonlocal_goto_stack_level != 0\n \t\t  && reg_mentioned_p (nonlocal_goto_stack_level,\n-\t\t\t\t      PATTERN (insn)))))\n-\tdelete_insn (insn);\n+\t\t\t\t      PATTERN (insn))))\n+\t    delete_insn (insn);\n+\t}\n     }\n }\n \n@@ -5452,7 +5463,7 @@ init_function_start (subr, filename, line)\n   stack_slot_list = 0;\n \n   /* There is no stack slot for handling nonlocal gotos.  */\n-  nonlocal_goto_handler_slot = 0;\n+  nonlocal_goto_handler_slots = 0;\n   nonlocal_goto_stack_level = 0;\n \n   /* No labels have been declared for nonlocal use.  */\n@@ -5972,7 +5983,8 @@ expand_function_end (filename, line, end_bindings)\n     }\n \n   /* Delete handlers for nonlocal gotos if nothing uses them.  */\n-  if (nonlocal_goto_handler_slot != 0 && !current_function_has_nonlocal_label)\n+  if (nonlocal_goto_handler_slots != 0\n+      && ! current_function_has_nonlocal_label)\n     delete_handlers ();\n \n   /* End any sequences that failed to be closed due to syntax errors.  */"}, {"sha": "e78b2e1be9b38e7f6ff7acbe7de8a406380a6d03", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -81,7 +81,7 @@ struct function\n   int has_nonlocal_goto;\n   int contains_functions;\n   int is_thunk;\n-  rtx nonlocal_goto_handler_slot;\n+  rtx nonlocal_goto_handler_slots;\n   rtx nonlocal_goto_stack_level;\n   tree nonlocal_labels;\n   int args_size;"}, {"sha": "affd4b588a4fb58155257c567f1e6a1a35d328c2", "filename": "gcc/stmt.c", "status": "modified", "additions": 177, "deletions": 126, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba716ac9252b1a97585420a02c4f3172902e4dd3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ba716ac9252b1a97585420a02c4f3172902e4dd3", "patch": "@@ -428,6 +428,9 @@ static int using_eh_for_cleanups_p = 0;\n static int n_occurrences\t\tPROTO((int, char *));\n static void expand_goto_internal\tPROTO((tree, rtx, rtx));\n static int expand_fixup\t\t\tPROTO((tree, rtx, rtx));\n+static void expand_nl_handler_label\tPROTO((rtx, rtx));\n+static void expand_nl_goto_receiver\tPROTO((void));\n+static void expand_nl_goto_receivers\tPROTO((struct nesting *));\n static void fixup_gotos\t\t\tPROTO((struct nesting *, rtx, tree,\n \t\t\t\t\t       rtx, int));\n static void expand_null_return_1\tPROTO((rtx, int));\n@@ -632,16 +635,18 @@ void\n declare_nonlocal_label (label)\n      tree label;\n {\n+  rtx slot = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\n   nonlocal_labels = tree_cons (NULL_TREE, label, nonlocal_labels);\n   LABEL_PRESERVE_P (label_rtx (label)) = 1;\n-  if (nonlocal_goto_handler_slot == 0)\n+  if (nonlocal_goto_handler_slots == 0)\n     {\n-      nonlocal_goto_handler_slot\n-\t= assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n       emit_stack_save (SAVE_NONLOCAL,\n \t\t       &nonlocal_goto_stack_level,\n \t\t       PREV_INSN (tail_recursion_reentry));\n     }\n+  nonlocal_goto_handler_slots\n+    = gen_rtx_EXPR_LIST (VOIDmode, slot, nonlocal_goto_handler_slots);\n }\n \n /* Generate RTL code for a `goto' statement with target label LABEL.\n@@ -660,7 +665,15 @@ expand_goto (label)\n     {\n       struct function *p = find_function_data (context);\n       rtx label_ref = gen_rtx_LABEL_REF (Pmode, label_rtx (label));\n-      rtx temp;\n+      rtx temp, handler_slot;\n+      tree link;\n+\n+      /* Find the corresponding handler slot for this label.  */\n+      handler_slot = p->nonlocal_goto_handler_slots;\n+      for (link = p->nonlocal_labels; TREE_VALUE (link) != label;\n+\t   link = TREE_CHAIN (link))\n+\thandler_slot = XEXP (handler_slot, 1);\n+      handler_slot = XEXP (handler_slot, 0);\n \n       p->has_nonlocal_label = 1;\n       current_function_has_nonlocal_goto = 1;\n@@ -673,7 +686,7 @@ expand_goto (label)\n #if HAVE_nonlocal_goto\n       if (HAVE_nonlocal_goto)\n \temit_insn (gen_nonlocal_goto (lookup_static_chain (label),\n-\t\t\t\t      copy_rtx (p->nonlocal_goto_handler_slot),\n+\t\t\t\t      copy_rtx (handler_slot),\n \t\t\t\t      copy_rtx (p->nonlocal_goto_stack_level),\n \t\t\t\t      label_ref));\n       else\n@@ -695,7 +708,7 @@ expand_goto (label)\n \n \t  /* Get addr of containing function's current nonlocal goto handler,\n \t     which will do any cleanups and then jump to the label.  */\n-\t  addr = copy_rtx (p->nonlocal_goto_handler_slot);\n+\t  addr = copy_rtx (handler_slot);\n \t  temp = copy_to_reg (replace_rtx (addr, virtual_stack_vars_rtx,\n \t\t\t\t\t   hard_frame_pointer_rtx));\n \t  \n@@ -708,13 +721,10 @@ expand_goto (label)\n \n \t  emit_stack_restore (SAVE_NONLOCAL, addr, NULL_RTX);\n \n-\t  /* Put in the static chain register the nonlocal label address.  */\n-\t  emit_move_insn (static_chain_rtx, label_ref);\n \t  /* USE of hard_frame_pointer_rtx added for consistency; not clear if\n \t     really needed.  */\n \t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n \t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n \t  emit_indirect_jump (temp);\n \t}\n      }\n@@ -2992,6 +3002,161 @@ remember_end_note (block)\n   last_block_end_note = NULL_RTX;\n }\n \n+/* Emit a handler label for a nonlocal goto handler.\n+   Also emit code to store the handler label in SLOT before BEFORE_INSN.  */\n+\n+static void\n+expand_nl_handler_label (slot, before_insn)\n+     rtx slot, before_insn;\n+{\n+  rtx insns;\n+  rtx handler_label = gen_label_rtx ();\n+\n+  /* Don't let jump_optimize delete the handler.  */\n+  LABEL_PRESERVE_P (handler_label) = 1;\n+\n+  start_sequence ();\n+  emit_move_insn (slot, gen_rtx_LABEL_REF (Pmode, handler_label));\n+  insns = get_insns ();\n+  end_sequence ();\n+  emit_insns_before (insns, before_insn);\n+\n+  emit_label (handler_label);\n+}\n+\n+/* Emit code to restore vital registers at the beginning of a nonlocal goto\n+   handler.  */\n+static void\n+expand_nl_goto_receiver ()\n+{\n+#ifdef HAVE_nonlocal_goto\n+  if (! HAVE_nonlocal_goto)\n+#endif\n+    /* First adjust our frame pointer to its actual value.  It was\n+       previously set to the start of the virtual area corresponding to\n+       the stacked variables when we branched here and now needs to be\n+       adjusted to the actual hardware fp value.\n+\n+       Assignments are to virtual registers are converted by\n+       instantiate_virtual_regs into the corresponding assignment\n+       to the underlying register (fp in this case) that makes\n+       the original assignment true.\n+       So the following insn will actually be\n+       decrementing fp by STARTING_FRAME_OFFSET.  */\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+\n+#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+  if (fixed_regs[ARG_POINTER_REGNUM])\n+    {\n+#ifdef ELIMINABLE_REGS\n+      /* If the argument pointer can be eliminated in favor of the\n+\t frame pointer, we don't need to restore it.  We assume here\n+\t that if such an elimination is present, it can always be used.\n+\t This is the case on all known machines; if we don't make this\n+\t assumption, we do unnecessary saving on many machines.  */\n+      static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+      size_t i;\n+\n+      for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n+\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n+\t  break;\n+\n+      if (i == sizeof elim_regs / sizeof elim_regs [0])\n+#endif\n+\t{\n+\t  /* Now restore our arg pointer from the address at which it\n+\t     was saved in our stack frame.\n+\t     If there hasn't be space allocated for it yet, make\n+\t     some now.  */\n+\t  if (arg_pointer_save_area == 0)\n+\t    arg_pointer_save_area\n+\t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t  /* We need a pseudo here, or else\n+\t\t\t     instantiate_virtual_regs_1 complains.  */\n+\t\t\t  copy_to_reg (arg_pointer_save_area));\n+\t}\n+    }\n+#endif\n+\n+#ifdef HAVE_nonlocal_goto_receiver\n+  if (HAVE_nonlocal_goto_receiver)\n+    emit_insn (gen_nonlocal_goto_receiver ());\n+#endif\n+}\n+\n+/* Make handlers for nonlocal gotos taking place in the function calls in\n+   block THISBLOCK.  */\n+\n+static void\n+expand_nl_goto_receivers (thisblock)\n+     struct nesting *thisblock;\n+{\n+  tree link;\n+  rtx afterward = gen_label_rtx ();\n+  rtx insns, slot;\n+  int any_invalid;\n+\n+  /* Record the handler address in the stack slot for that purpose,\n+     during this block, saving and restoring the outer value.  */\n+  if (thisblock->next != 0)\n+    for (slot = nonlocal_goto_handler_slots; slot; slot = XEXP (slot, 1))\n+      {\n+\trtx save_receiver = gen_reg_rtx (Pmode);\n+\temit_move_insn (XEXP (slot, 0), save_receiver);\n+\n+\tstart_sequence ();\n+\temit_move_insn (save_receiver, XEXP (slot, 0));\n+\tinsns = get_insns ();\n+\tend_sequence ();\n+\temit_insns_before (insns, thisblock->data.block.first_insn);\n+      }\n+\n+  /* Jump around the handlers; they run only when specially invoked.  */\n+  emit_jump (afterward);\n+\n+  /* Make a separate handler for each label.  */\n+  link = nonlocal_labels;\n+  slot = nonlocal_goto_handler_slots;\n+  for (; link; link = TREE_CHAIN (link), slot = XEXP (slot, 1))\n+    /* Skip any labels we shouldn't be able to jump to from here,\n+       we generate one special handler for all of them below which just calls\n+       abort.  */\n+    if (! DECL_TOO_LATE (TREE_VALUE (link)))\n+      {\n+\texpand_nl_handler_label (XEXP (slot, 0),\n+\t\t\t\t thisblock->data.block.first_insn);\n+\texpand_nl_goto_receiver ();\n+\n+\t/* Jump to the \"real\" nonlocal label.  */\n+\texpand_goto (TREE_VALUE (link));\n+      }\n+\n+  /* A second pass over all nonlocal labels; this time we handle those\n+     we should not be able to jump to at this point.  */\n+  link = nonlocal_labels;\n+  slot = nonlocal_goto_handler_slots;\n+  any_invalid = 0;\n+  for (; link; link = TREE_CHAIN (link), slot = XEXP (slot, 1))\n+    if (DECL_TOO_LATE (TREE_VALUE (link)))\n+      {\n+\texpand_nl_handler_label (XEXP (slot, 0),\n+\t\t\t\t thisblock->data.block.first_insn);\n+\tany_invalid = 1;\n+      }\n+\n+  if (any_invalid)\n+    {\n+      expand_nl_goto_receiver ();\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"abort\"), 0,\n+\t\t\t VOIDmode, 0);\n+      emit_barrier ();\n+    }\n+\n+  emit_label (afterward);\n+}\n+\n /* Generate RTL code to terminate a binding contour.\n    VARS is the chain of VAR_DECL nodes\n    for the variables bound in this contour.\n@@ -3042,7 +3207,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       emit_label (thisblock->exit_label);\n     }\n \n-  /* If necessary, make a handler for nonlocal gotos taking\n+  /* If necessary, make handlers for nonlocal gotos taking\n      place in the function calls in this block.  */\n   if (function_call_count != thisblock->data.block.function_call_count\n       && nonlocal_labels\n@@ -3053,119 +3218,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \t     special to do when you jump out of it.  */\n \t  : (thisblock->data.block.cleanups != 0\n \t     || thisblock->data.block.stack_level != 0)))\n-    {\n-      tree link;\n-      rtx afterward = gen_label_rtx ();\n-      rtx handler_label = gen_label_rtx ();\n-      rtx save_receiver = gen_reg_rtx (Pmode);\n-      rtx insns;\n-\n-      /* Don't let jump_optimize delete the handler.  */\n-      LABEL_PRESERVE_P (handler_label) = 1;\n-\n-      /* Record the handler address in the stack slot for that purpose,\n-\t during this block, saving and restoring the outer value.  */\n-      if (thisblock->next != 0)\n-\t{\n-\t  emit_move_insn (nonlocal_goto_handler_slot, save_receiver);\n-\n-\t  start_sequence ();\n-\t  emit_move_insn (save_receiver, nonlocal_goto_handler_slot);\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insns_before (insns, thisblock->data.block.first_insn);\n-\t}\n-\n-      start_sequence ();\n-      emit_move_insn (nonlocal_goto_handler_slot,\n-\t\t      gen_rtx_LABEL_REF (Pmode, handler_label));\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_insns_before (insns, thisblock->data.block.first_insn);\n-\n-      /* Jump around the handler; it runs only when specially invoked.  */\n-      emit_jump (afterward);\n-      emit_label (handler_label);\n-\n-#ifdef HAVE_nonlocal_goto\n-      if (! HAVE_nonlocal_goto)\n-#endif\n-\t/* First adjust our frame pointer to its actual value.  It was\n-\t   previously set to the start of the virtual area corresponding to\n-\t   the stacked variables when we branched here and now needs to be\n-\t   adjusted to the actual hardware fp value.\n-\n-\t   Assignments are to virtual registers are converted by\n-\t   instantiate_virtual_regs into the corresponding assignment\n-\t   to the underlying register (fp in this case) that makes\n-\t   the original assignment true.\n-\t   So the following insn will actually be\n-\t   decrementing fp by STARTING_FRAME_OFFSET.  */\n-\temit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      if (fixed_regs[ARG_POINTER_REGNUM])\n-\t{\n-#ifdef ELIMINABLE_REGS\n-\t  /* If the argument pointer can be eliminated in favor of the\n-\t     frame pointer, we don't need to restore it.  We assume here\n-\t     that if such an elimination is present, it can always be used.\n-\t     This is the case on all known machines; if we don't make this\n-\t     assumption, we do unnecessary saving on many machines.  */\n-\t  static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n-\t  size_t i;\n-\n-\t  for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n-\t    if (elim_regs[i].from == ARG_POINTER_REGNUM\n-\t\t&& elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n-\t      break;\n-\n-\t  if (i == sizeof elim_regs / sizeof elim_regs [0])\n-#endif\n-\t    {\n-\t      /* Now restore our arg pointer from the address at which it\n-\t\t was saved in our stack frame.\n-\t\t If there hasn't be space allocated for it yet, make\n-\t\t some now.  */\n-\t      if (arg_pointer_save_area == 0)\n-\t\targ_pointer_save_area\n-\t\t  = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-\t      emit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t      /* We need a pseudo here, or else\n-\t\t\t\t instantiate_virtual_regs_1 complains.  */\n-\t\t\t      copy_to_reg (arg_pointer_save_area));\n-\t    }\n-\t}\n-#endif\n-\n-#ifdef HAVE_nonlocal_goto_receiver\n-      if (HAVE_nonlocal_goto_receiver)\n-\temit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n-\n-      /* The handler expects the desired label address in the static chain\n-\t register.  It tests the address and does an appropriate jump\n-\t to whatever label is desired.  */\n-      for (link = nonlocal_labels; link; link = TREE_CHAIN (link))\n-\t/* Skip any labels we shouldn't be able to jump to from here.  */\n-\tif (! DECL_TOO_LATE (TREE_VALUE (link)))\n-\t  {\n-\t    rtx not_this = gen_label_rtx ();\n-\t    rtx this = gen_label_rtx ();\n-\t    do_jump_if_equal (static_chain_rtx,\n-\t\t\t      gen_rtx_LABEL_REF (Pmode, DECL_RTL (TREE_VALUE (link))),\n-\t\t\t      this, 0);\n-\t    emit_jump (not_this);\n-\t    emit_label (this);\n-\t    expand_goto (TREE_VALUE (link));\n-\t    emit_label (not_this);\n-\t  }\n-      /* If label is not recognized, abort.  */\n-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"abort\"), 0,\n-\t\t\t VOIDmode, 0);\n-      emit_barrier ();\n-      emit_label (afterward);\n-    }\n+    expand_nl_goto_receivers (thisblock);\n \n   /* Don't allow jumping into a block that has a stack level.\n      Cleanups are allowed, though.  */\n@@ -3219,7 +3272,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \t{\n \t  emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n \t\t\t      thisblock->data.block.stack_level, NULL_RTX);\n-\t  if (nonlocal_goto_handler_slot != 0)\n+\t  if (nonlocal_goto_handler_slots != 0)\n \t    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level,\n \t\t\t     NULL_RTX);\n \t}\n@@ -3266,8 +3319,6 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n   /* Pop the stack slot nesting and free any slots at this level.  */\n   pop_temp_slots ();\n }\n-\n-\n \f\n /* Generate RTL for the automatic variable declaration DECL.\n    (Other kinds of declarations are simply ignored if seen here.)  */"}]}