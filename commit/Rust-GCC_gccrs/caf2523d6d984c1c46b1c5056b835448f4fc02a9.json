{"sha": "caf2523d6d984c1c46b1c5056b835448f4fc02a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmMjUyM2Q2ZDk4NGMxYzQ2YjFjNTA1NmI4MzU0NDhmNGZjMDJhOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-18T22:51:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-18T22:51:57Z"}, "message": "re PR c++/16034 (dtor called prematurely for while-loop scoped variable)\n\n        PR c++/16034\n        * c-gimplify.c (gimplify_condition): Remove.\n        (gimplify_c_loop, gimplify_if_stmt, gimplify_switch_stmt): Don't\n        call it.\ncp/\n        * semantics.c (begin_cond): New.\n        (finish_cond): Rewrite to handle template DECL_STMTs specially.\n        Assume that non-template decls go land before the conditional.\n        (simplify_loop_decl_cond): Likewise.\n        (begin_if_stmt, finish_if_stmt_cond, begin_while_stmt,\n        finish_while_stmt_cond, finish_for_init_stmt, finish_for_cond,\n        begin_switch_stmt, finish_switch_cond): Update to match.\n\nFrom-SVN: r83368", "tree": {"sha": "2762b11388dd64d6b16fe86a4039c2bb93c95ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2762b11388dd64d6b16fe86a4039c2bb93c95ba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf2523d6d984c1c46b1c5056b835448f4fc02a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf2523d6d984c1c46b1c5056b835448f4fc02a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf2523d6d984c1c46b1c5056b835448f4fc02a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf2523d6d984c1c46b1c5056b835448f4fc02a9/comments", "author": null, "committer": null, "parents": [{"sha": "7465ed07083691bf03e737e8709afa0e20c5f82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7465ed07083691bf03e737e8709afa0e20c5f82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7465ed07083691bf03e737e8709afa0e20c5f82f"}], "stats": {"total": 231, "additions": 142, "deletions": 89}, "files": [{"sha": "9ac5634c0272db93c3251c619d134ab5b80b2314", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caf2523d6d984c1c46b1c5056b835448f4fc02a9", "patch": "@@ -1,3 +1,9 @@\n+2004-06-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-gimplify.c (gimplify_condition): Remove.\n+\t(gimplify_c_loop, gimplify_if_stmt, gimplify_switch_stmt): Don't\n+\tcall it.\n+\n 2004-06-18  Richard Henderson  <rth@redhat.com>\n \n \t* tree-eh.c (decide_copy_try_finally): Fix scaling of copy and"}, {"sha": "7334621106aaf7005566dde32231826fe150e130", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=caf2523d6d984c1c46b1c5056b835448f4fc02a9", "patch": "@@ -86,7 +86,6 @@ static tree gimplify_c_loop (tree, tree, tree, bool);\n static void push_context (void);\n static void pop_context (void);\n static void add_block_to_enclosing (tree);\n-static void gimplify_condition (tree *);\n \n enum bc_t { bc_break = 0, bc_continue = 1 };\n static tree begin_bc_block (enum bc_t);\n@@ -417,23 +416,6 @@ gimplify_expr_stmt (tree *stmt_p)\n   return GS_OK;\n }\n \n-/* If the condition for a loop (or the like) is a decl, it will be a\n-   TREE_LIST where the TREE_PURPOSE is a DECL_STMT and the TREE_VALUE is\n-   a use of the decl.  Turn such a thing into a COMPOUND_EXPR.  */\n-\n-static void\n-gimplify_condition (tree *cond_p)\n-{\n-  tree cond = *cond_p;\n-  if (cond && TREE_CODE (cond) == TREE_LIST)\n-    {\n-      tree decl = TREE_PURPOSE (cond);\n-      tree value = TREE_VALUE (cond);\n-      gimplify_stmt (&decl);\n-      *cond_p = build (COMPOUND_EXPR, TREE_TYPE (value), decl, value);\n-    }\n-}\n-\n /* Begin a scope which can be exited by a break or continue statement.  BC\n    indicates which.\n \n@@ -548,7 +530,6 @@ gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n       exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n       if (cond)\n \t{\n-\t  gimplify_condition (&cond);\n \t  t = build_bc_goto (bc_break);\n \t  exit = build (COND_EXPR, void_type_node, cond, exit, t);\n \t  exit = fold (exit);\n@@ -647,7 +628,6 @@ gimplify_if_stmt (tree *stmt_p)\n     else_ = build_empty_stmt ();\n \n   stmt = build (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n-  gimplify_condition (& TREE_OPERAND (stmt, 0));\n   *stmt_p = stmt;\n \n   return GS_OK;\n@@ -664,8 +644,6 @@ gimplify_switch_stmt (tree *stmt_p)\n \n   break_block = begin_bc_block (bc_break);\n \n-  gimplify_condition (&SWITCH_COND (stmt));\n-\n   body = SWITCH_BODY (stmt);\n   if (!body)\n     body = build_empty_stmt ();"}, {"sha": "d830e20ccd72bde1c8e4f18f1cf303598f15f086", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=caf2523d6d984c1c46b1c5056b835448f4fc02a9", "patch": "@@ -1,3 +1,14 @@\n+2004-06-18  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c++/16034\n+\t* semantics.c (begin_cond): New.\n+\t(finish_cond): Rewrite to handle template DECL_STMTs specially.\n+\tAssume that non-template decls go land before the conditional.\n+\t(simplify_loop_decl_cond): Likewise.\n+\t(begin_if_stmt, finish_if_stmt_cond, begin_while_stmt, \n+\tfinish_while_stmt_cond, finish_for_init_stmt, finish_for_cond,\n+\tbegin_switch_stmt, finish_switch_cond): Update to match.\n+\n 2004-06-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/16015"}, {"sha": "74a513a9cd672b32b08c6836840b0c26f4308112", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=caf2523d6d984c1c46b1c5056b835448f4fc02a9", "patch": "@@ -346,68 +346,60 @@ do_pushlevel (scope_kind sk)\n   return ret;\n }\n \n-/* Finish processing a conditional.  COND contains the raw expression;\n-   STMT_P is a stacked statement list that will contain any other stmts\n-   emitting during the processing of this conditional.  Place the \n-   resulting conditional back in STMT_P.  */\n+/* Begin a conditional that might contain a declaration.  When generating\n+   normal code, we want the declaration to appear before the statement\n+   containing the conditional.  When generating template code, we want the\n+   conditional to be rendered as the raw DECL_STMT.  */\n \n static void\n-finish_cond (tree cond, tree *stmt_p)\n-{\n-  tree stmt = *stmt_p;\n-  stmt = pop_stmt_list (stmt);\n-  if (TREE_SIDE_EFFECTS (stmt))\n-    {\n-      /* If stmt is set, it will be a DECL_STMT.  When processing a template, \n-\t using this is enough, because tsubst_expr considers the result of a\n-\t DECL_STMT to be the DECL.  When generating real code, we build a\n-\t funny little TREE_LIST thingy that's handled by the gimplifier.  */\n-      /* ??? The object of this thingy is to get the DECL declared in the\n-\t proper scope.  Seems like this oughtn't be terribly hard with the\n-\t new explicit uses of BIND_EXPR and such.  */\n-      if (processing_template_decl)\n-\t{\n-\t  stmt = expr_only (stmt);\n-\t  if (!stmt)\n-\t    abort ();\n-\t}\n-      else\n-        stmt = build_tree_list (stmt, cond);\n+begin_cond (tree *cond_p)\n+{\n+  if (processing_template_decl)\n+    *cond_p = push_stmt_list ();\n+}\n+\n+/* Finish such a conditional.  */\n+\n+static void\n+finish_cond (tree *cond_p, tree expr)\n+{\n+  if (processing_template_decl)\n+    {\n+      tree cond = pop_stmt_list (*cond_p);\n+      if (TREE_CODE (cond) == DECL_STMT)\n+\texpr = cond;\n     }\n-  else\n-    stmt = cond;\n-  *stmt_p = stmt;\n+  *cond_p = expr;\n }\n \n /* If *COND_P specifies a conditional with a declaration, transform the\n    loop such that\n-\t    while (A x = 42) { }\n-\t    for (; A x = 42;) { }\n+            while (A x = 42) { }\n+            for (; A x = 42;) { }\n    becomes\n-\t    while (true) { A x = 42; if (!x) break; }\n-\t    for (;;) { A x = 42; if (!x) break; }\n-   The statement list for the loop body should have been pushed.  */\n-\n+            while (true) { A x = 42; if (!x) break; }\n+            for (;;) { A x = 42; if (!x) break; }\n+   The statement list for BODY will be empty if the conditional did\n+   not declare anything.  */\n+                                                                                \n static void\n-simplify_loop_decl_cond (tree *cond_p)\n+simplify_loop_decl_cond (tree *cond_p, tree body)\n {\n-  tree cond = *cond_p;\n-  if (TREE_CODE (cond) == TREE_LIST)\n-    {\n-      tree if_stmt;\n+  tree cond, if_stmt;\n \n-      *cond_p = boolean_true_node;\n-  \n-      if_stmt = begin_if_stmt ();\n-      add_stmt (TREE_PURPOSE (cond));\n-      cond = build_unary_op (TRUTH_NOT_EXPR, TREE_VALUE (cond), 0);\n-      finish_if_stmt_cond (cond, if_stmt);\n-      finish_break_stmt ();\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt (if_stmt);\n-    }\n-}\n+  if (!TREE_SIDE_EFFECTS (body))\n+    return;\n \n+  cond = *cond_p;\n+  *cond_p = boolean_true_node;\n+   \n+  if_stmt = begin_if_stmt ();\n+  cond = build_unary_op (TRUTH_NOT_EXPR, cond, 0);\n+  finish_if_stmt_cond (cond, if_stmt);\n+  finish_break_stmt ();\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt (if_stmt);\n+}\n \n /* Finish a goto-statement.  */\n \n@@ -494,8 +486,7 @@ begin_if_stmt (void)\n   scope = do_pushlevel (sk_block);\n   r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n   TREE_CHAIN (r) = scope;\n-  add_stmt (r);\n-  IF_COND (r) = push_stmt_list ();\n+  begin_cond (&IF_COND (r));\n   return r;\n }\n \n@@ -505,8 +496,8 @@ begin_if_stmt (void)\n void \n finish_if_stmt_cond (tree cond, tree if_stmt)\n {\n-  cond = maybe_convert_cond (cond);\n-  finish_cond (cond, &IF_COND (if_stmt));\n+  finish_cond (&IF_COND (if_stmt), maybe_convert_cond (cond));\n+  add_stmt (if_stmt);\n   THEN_CLAUSE (if_stmt) = push_stmt_list ();\n }\n \n@@ -558,7 +549,7 @@ begin_while_stmt (void)\n   r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n   WHILE_BODY (r) = do_pushlevel (sk_block);\n-  WHILE_COND (r) = push_stmt_list ();\n+  begin_cond (&WHILE_COND (r));\n   return r;\n }\n \n@@ -568,9 +559,8 @@ begin_while_stmt (void)\n void \n finish_while_stmt_cond (tree cond, tree while_stmt)\n {\n-  cond = maybe_convert_cond (cond);\n-  finish_cond (cond, &WHILE_COND (while_stmt));\n-  simplify_loop_decl_cond (&WHILE_COND (while_stmt));\n+  finish_cond (&WHILE_COND (while_stmt), maybe_convert_cond (cond));\n+  simplify_loop_decl_cond (&WHILE_COND (while_stmt), WHILE_BODY (while_stmt));\n }\n \n /* Finish a while-statement, which may be given by WHILE_STMT.  */\n@@ -668,7 +658,7 @@ finish_for_init_stmt (tree for_stmt)\n     FOR_INIT_STMT (for_stmt) = pop_stmt_list (FOR_INIT_STMT (for_stmt));\n   add_stmt (for_stmt);\n   FOR_BODY (for_stmt) = do_pushlevel (sk_block);\n-  FOR_COND (for_stmt) = push_stmt_list ();\n+  begin_cond (&FOR_COND (for_stmt));\n }\n \n /* Finish the COND of a for-statement, which may be given by\n@@ -677,10 +667,8 @@ finish_for_init_stmt (tree for_stmt)\n void\n finish_for_cond (tree cond, tree for_stmt)\n {\n-  cond = maybe_convert_cond (cond);\n-  finish_cond (cond, &FOR_COND (for_stmt));\n-  if (FOR_COND (for_stmt))\n-    simplify_loop_decl_cond (&FOR_COND (for_stmt));\n+  finish_cond (&FOR_COND (for_stmt), maybe_convert_cond (cond));\n+  simplify_loop_decl_cond (&FOR_COND (for_stmt), FOR_BODY (for_stmt));\n }\n \n /* Finish the increment-EXPRESSION in a for-statement, which may be\n@@ -747,9 +735,7 @@ begin_switch_stmt (void)\n \n   scope = do_pushlevel (sk_block);\n   TREE_CHAIN (r) = scope;\n-\n-  add_stmt (r);\n-  SWITCH_COND (r) = push_stmt_list ();\n+  begin_cond (&SWITCH_COND (r));\n \n   return r;\n }\n@@ -793,8 +779,9 @@ finish_switch_cond (tree cond, tree switch_stmt)\n \t    cond = index;\n \t}\n     }\n-  finish_cond (cond, &SWITCH_COND (switch_stmt));\n+  finish_cond (&SWITCH_COND (switch_stmt), cond);\n   SWITCH_TYPE (switch_stmt) = orig_type;\n+  add_stmt (switch_stmt);\n   push_switch (switch_stmt);\n   SWITCH_BODY (switch_stmt) = push_stmt_list ();\n }"}, {"sha": "276e0d6e588e8badb4aff5b9f137347adc05ddb9", "filename": "gcc/testsuite/g++.dg/eh/scope1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fscope1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2523d6d984c1c46b1c5056b835448f4fc02a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fscope1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fscope1.C?ref=caf2523d6d984c1c46b1c5056b835448f4fc02a9", "patch": "@@ -0,0 +1,71 @@\n+// Test that we've scoped the destructor properly for variables declared\n+// in a conditional.\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+class C\n+{\n+  bool live;\n+ public:\n+  C();\n+  C(const C &);\n+  ~C ();\n+  operator bool() const;\n+};\n+\n+void f1 ()\n+{\n+  while (C br = C()) abort ();\n+}\n+\n+void f2 ()\n+{\n+  for (; C br = C(); ) abort ();\n+}\n+\n+void f3 ()\n+{\n+  if (C br = C()) abort ();\n+}\n+\n+void f4 ()\n+{\n+  switch (C br = C())\n+    {\n+    default:\n+      abort ();\n+    case false:\n+      break;\n+    }\n+}\n+\n+int main()\n+{\n+  f1(); f2(); f3(); f4();\n+  return 0;\n+}\n+\n+C::C()\n+{\n+  live = true;\n+}\n+\n+C::C(const C &o)\n+{\n+  if (!o.live)\n+    abort ();\n+  live = true;\n+}\n+\n+C::~C()\n+{\n+  live = false;\n+}\n+\n+C::operator bool() const\n+{\n+  if (!live)\n+    abort ();\n+  return false;\n+}"}]}