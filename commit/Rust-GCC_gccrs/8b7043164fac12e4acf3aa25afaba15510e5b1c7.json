{"sha": "8b7043164fac12e4acf3aa25afaba15510e5b1c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI3MDQzMTY0ZmFjMTJlNGFjZjNhYTI1YWZhYmExNTUxMGU1YjFjNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-12-20T00:15:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-12-20T00:15:00Z"}, "message": "array.c (resolve_array_list): Apply C4106.\n\n2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* array.c (resolve_array_list): Apply C4106.\n\t* check.c (gfc_check_same_type_as): Exclude polymorphic\n\tentities from check for extensible types. Improved error\n\tfor disallowed argument types to name the offending type.\n\t* class.c : Update copyright date.\n\t(gfc_class_null_initializer): Add argument for initialization\n\texpression and deal with unlimited polymorphic typespecs.\n\t(get_unique_type_string): Give unlimited polymorphic\n\tentities a type string.\n\t(gfc_intrinsic_hash_value): New function.\n\t(gfc_build_class_symbol): Incorporate unlimited polymorphic\n\tentities.\n\t(gfc_find_derived_vtab): Deal with unlimited polymorphic\n\tentities.\n\t(gfc_find_intrinsic_vtab): New function.\n\t* decl.c (gfc_match_decl_type_spec): Match typespec for\n\tunlimited polymorphic type.\n\t(gfc_match_data_decl): Skip to 'ok' if unlimited polymorphic.\n\texpr.c (gfc_check_pointer_assign): Apply C717.  If unlimited\n\tpolymorphic lvalue, find rvalue vtable for all typespecs,\n\texcept unlimited polymorphic expressions.\n\t(gfc_check_vardef_context): Handle unlimited polymorphic\n\tentities.\n\t* gfortran.h : Add unlimited polymorphic attribute. Add\n\tsecond arg to gfc_class_null_initializer primitive and\n\tprimitive for gfc_find_intrinsic_vtab.  Add UNLIMITED_POLY\n\tto detect unlimited polymorphic expressions.\n\t* interface.c (gfc_compare_types): If expr1 is unlimited\n\tpolymorphic, always return 1. If expr2 is unlimited polymorphic\n\tenforce C717.\n\t(gfc_compare_interfaces): Skip past conditions that do not\n\tapply for unlimited polymorphic entities.\n\t(compare_parameter): Make sure that an unlimited polymorphic,\n\tallocatable or pointer, formal argument is matched by an\n\tunlimited polymorphic actual argument.\n\t(compare_actual_formal): Ensure that an intrinsic vtable exists\n\tto match an unlimited polymorphic formal argument.\n\t* match.c (gfc_match_allocate): Type kind parameter does not\n\tneed to match an unlimited polymorphic allocate-object.\n\t(alloc_opt_list): An unlimited polymorphic allocate-object\n\trequires a typespec or a SOURCE tag.\n\t(select_intrinsic_set_tmp): New function.\n\t(select_type_set_tmp): Call new function.  If it returns NULL,\n\tbuild a derived type or class temporary instead.\n\t(gfc_match_type_is): Remove restriction to derived types only.\n\tBind(C) or sequence derived types not permitted.\n\t* misc (gfc_typename):  Printed CLASS(*) for unlimited\n\tpolymorphism.\n\t* module.c : Add AB_UNLIMITED_POLY to pass unlimited\n\tpolymorphic attribute to and from modules.\n\t* resolve.c (resolve_common_vars): Unlimited polymorphic\n\tentities cannot appear in common blocks.\n\t(resolve_deallocate_expr): Deallocate unlimited polymorphic\n\tenities.\n\t(resolve_allocate_expr): Likewise for allocation.  Make sure\n\tvtable exists.\n\t(gfc_type_is_extensible): Unlimited polymorphic entities are\n\tnot extensible.\n\t(resolve_select_type): Handle unlimited polymorphic selectors.\n\tEnsure that length type parameters are assumed and that names\n\tfor intrinsic types are generated.\n\t(resolve_fl_var_and_proc): Exclude select type temporaries\n\tfrom test of extensibility of type.\n\t(resolve_fl_variable): Likewise for test that assumed character\n\tlength must be a dummy or a parameter.\n\t(resolve_fl_derived0): Return SUCCESS unconditionally for\n\tunlimited polymorphic entities. Also, allow unlimited\n\tpolymorphic components.\n\t(resolve_fl_derived): Return SUCCESS unconditionally for\n\tunlimited polymorphic entities.\n\t(resolve_symbol): Return early with unlimited polymorphic\n\tentities.\n\t* simplifiy.c : Update copyright year.\n\t(gfc_simplify_extends_type_of): No simplification possible\n\tfor unlimited polymorphic arguments.\n\t* symbol.c (gfc_use_derived): Nothing to do for unlimited\n\tpolymorphic \"derived type\".\n\t(gfc_type_compatible): Return unity if ts1 is unlimited\n\tpolymorphic.\n\t* trans-decl.c (create_function_arglist) Formal arguments\n\twithout a character length should be treated in the same way\n\tas passed lengths.\n\t(gfc_trans_deferred_vars): Nullify the vptr of unlimited\n\tpolymorphic pointers. Avoid unlimited polymorphic entities\n\ttriggering gcc_unreachable.\n\t* trans-expr.c (gfc_conv_intrinsic_to_class): New function.\n\t(gfc_trans_class_init_assign): Make indirect reference of\n\tsrc.expr.\n\t(gfc_trans_class_assign): Expression NULL of unknown type\n\tshould set NULL vptr on lhs. Treat C717 cases where lhs is\n\ta derived type and the rhs is unlimited polymorphic.\n\t(gfc_conv_procedure_call): Handle the conversion of a non-class\n\tactual argument to match an unlimited polymorphic formal\n\targument.  Suppress the passing of a character string length\n\tin this case.  Make sure that calls to the character __copy\n\tfunction have two character string length arguments.\n\t(gfc_conv_initializer): Pass the initialization expression to\n\tgfc_class_null_initializer.\n\t(gfc_trans_subcomponent_assign): Ditto.\n\t(gfc_conv_structure): Move handling of _size component.\n\ttrans-intrinsic.c: (gfc_conv_same_type_as): Handle conditions\n\twhere unlimited polymorphic arguments have null vptr.\n\t* trans-stmt.c (trans_associate_var): Correctly treat array\n\ttemporaries associated with unlimited polymorphic selectors.\n\tRecover the overwritten dtype for the descriptor. Use the _size\n\tfield of the vptr for character string lengths.\n\t(gfc_trans_allocate): Cope with unlimited polymorphic allocate\n\tobjects; especially with character source tags.\n\t(reset_vptr): New function.\n\t(gfc_trans_deallocate): Call it.\n\t* trans-types.c (gfc_get_derived_type): Detect unlimited\n\tpolymorphic types and deal with cases where the derived type of\n\tcomponents is null.\n\t* trans.c : Update copyright year.\n\t(trans_code): Call gfc_trans_class_assign for C717 cases where\n\tthe lhs is not unlimited polymorphic.\n\n2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* intrinsics/extends_type_of.c : Return correct results for\n\tnull vptrs.\n\n2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/unlimited_polymorphic_1.f03: New test.\n\t* gfortran.dg/unlimited_polymorphic_2.f03: New test.\n\t* gfortran.dg/unlimited_polymorphic_3.f03: New test.\n\t* gfortran.dg/same_type_as.f03: Correct for improved message.\n\nFrom-SVN: r194622", "tree": {"sha": "2e697d5cae930814fb839a61cea3e7b4e8d95338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e697d5cae930814fb839a61cea3e7b4e8d95338"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b7043164fac12e4acf3aa25afaba15510e5b1c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7043164fac12e4acf3aa25afaba15510e5b1c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7043164fac12e4acf3aa25afaba15510e5b1c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7043164fac12e4acf3aa25afaba15510e5b1c7/comments", "author": null, "committer": null, "parents": [{"sha": "26c08c0323ca8094d4841634c4bf04c14be23811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c08c0323ca8094d4841634c4bf04c14be23811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26c08c0323ca8094d4841634c4bf04c14be23811"}], "stats": {"total": 2059, "additions": 1665, "deletions": 394}, "files": [{"sha": "ab271a4272a185c04e701ed351981bb797ae63e5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 120, "deletions": 1, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,3 +1,122 @@\n+2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* array.c (resolve_array_list): Apply C4106.\n+\t* check.c (gfc_check_same_type_as): Exclude polymorphic\n+\tentities from check for extensible types. Improved error\n+\tfor disallowed argument types to name the offending type.\n+\t* class.c : Update copyright date.\n+\t(gfc_class_null_initializer): Add argument for initialization\n+\texpression and deal with unlimited polymorphic typespecs.\n+\t(get_unique_type_string): Give unlimited polymorphic\n+\tentities a type string.\n+\t(gfc_intrinsic_hash_value): New function.\n+\t(gfc_build_class_symbol): Incorporate unlimited polymorphic\n+\tentities.\n+\t(gfc_find_derived_vtab): Deal with unlimited polymorphic\n+\tentities.\n+\t(gfc_find_intrinsic_vtab): New function.\n+\t* decl.c (gfc_match_decl_type_spec): Match typespec for\n+\tunlimited polymorphic type.\n+\t(gfc_match_data_decl): Skip to 'ok' if unlimited polymorphic.\n+\texpr.c (gfc_check_pointer_assign): Apply C717.  If unlimited\n+\tpolymorphic lvalue, find rvalue vtable for all typespecs,\n+\texcept unlimited polymorphic expressions.\n+\t(gfc_check_vardef_context): Handle unlimited polymorphic\n+\tentities.\n+\t* gfortran.h : Add unlimited polymorphic attribute. Add\n+\tsecond arg to gfc_class_null_initializer primitive and\n+\tprimitive for gfc_find_intrinsic_vtab.  Add UNLIMITED_POLY\n+\tto detect unlimited polymorphic expressions.\n+\t* interface.c (gfc_compare_types): If expr1 is unlimited\n+\tpolymorphic, always return 1. If expr2 is unlimited polymorphic\n+\tenforce C717.\n+\t(gfc_compare_interfaces): Skip past conditions that do not\n+\tapply for unlimited polymorphic entities.\n+\t(compare_parameter): Make sure that an unlimited polymorphic,\n+\tallocatable or pointer, formal argument is matched by an\n+\tunlimited polymorphic actual argument.\n+\t(compare_actual_formal): Ensure that an intrinsic vtable exists\n+\tto match an unlimited polymorphic formal argument.\n+\t* match.c (gfc_match_allocate): Type kind parameter does not\n+\tneed to match an unlimited polymorphic allocate-object.\n+\t(alloc_opt_list): An unlimited polymorphic allocate-object\n+\trequires a typespec or a SOURCE tag.\n+\t(select_intrinsic_set_tmp): New function.\n+\t(select_type_set_tmp): Call new function.  If it returns NULL,\n+\tbuild a derived type or class temporary instead.\n+\t(gfc_match_type_is): Remove restriction to derived types only.\n+\tBind(C) or sequence derived types not permitted.\n+\t* misc (gfc_typename):  Printed CLASS(*) for unlimited\n+\tpolymorphism.\n+\t* module.c : Add AB_UNLIMITED_POLY to pass unlimited\n+\tpolymorphic attribute to and from modules.\n+\t* resolve.c (resolve_common_vars): Unlimited polymorphic\n+\tentities cannot appear in common blocks.\n+\t(resolve_deallocate_expr): Deallocate unlimited polymorphic\n+\tenities.\n+\t(resolve_allocate_expr): Likewise for allocation.  Make sure\n+\tvtable exists.\n+\t(gfc_type_is_extensible): Unlimited polymorphic entities are\n+\tnot extensible.\n+\t(resolve_select_type): Handle unlimited polymorphic selectors.\n+\tEnsure that length type parameters are assumed and that names\n+\tfor intrinsic types are generated.\n+\t(resolve_fl_var_and_proc): Exclude select type temporaries\n+\tfrom test of extensibility of type.\n+\t(resolve_fl_variable): Likewise for test that assumed character\n+\tlength must be a dummy or a parameter.\n+\t(resolve_fl_derived0): Return SUCCESS unconditionally for\n+\tunlimited polymorphic entities. Also, allow unlimited\n+\tpolymorphic components.\n+\t(resolve_fl_derived): Return SUCCESS unconditionally for\n+\tunlimited polymorphic entities.\n+\t(resolve_symbol): Return early with unlimited polymorphic\n+\tentities.\n+\t* simplifiy.c : Update copyright year.\n+\t(gfc_simplify_extends_type_of): No simplification possible\n+\tfor unlimited polymorphic arguments.\n+\t* symbol.c (gfc_use_derived): Nothing to do for unlimited\n+\tpolymorphic \"derived type\".\n+\t(gfc_type_compatible): Return unity if ts1 is unlimited\n+\tpolymorphic.\n+\t* trans-decl.c (create_function_arglist) Formal arguments\n+\twithout a character length should be treated in the same way\n+\tas passed lengths.\n+\t(gfc_trans_deferred_vars): Nullify the vptr of unlimited\n+\tpolymorphic pointers. Avoid unlimited polymorphic entities\n+\ttriggering gcc_unreachable.\n+\t* trans-expr.c (gfc_conv_intrinsic_to_class): New function.\n+\t(gfc_trans_class_init_assign): Make indirect reference of\n+\tsrc.expr.\n+\t(gfc_trans_class_assign): Expression NULL of unknown type\n+\tshould set NULL vptr on lhs. Treat C717 cases where lhs is\n+\ta derived type and the rhs is unlimited polymorphic.\n+\t(gfc_conv_procedure_call): Handle the conversion of a non-class\n+\tactual argument to match an unlimited polymorphic formal\n+\targument.  Suppress the passing of a character string length\n+\tin this case.  Make sure that calls to the character __copy\n+\tfunction have two character string length arguments.\n+\t(gfc_conv_initializer): Pass the initialization expression to\n+\tgfc_class_null_initializer.\n+\t(gfc_trans_subcomponent_assign): Ditto.\n+\t(gfc_conv_structure): Move handling of _size component.\n+\ttrans-intrinsic.c: (gfc_conv_same_type_as): Handle conditions\n+\twhere unlimited polymorphic arguments have null vptr.\n+\t* trans-stmt.c (trans_associate_var): Correctly treat array\n+\ttemporaries associated with unlimited polymorphic selectors.\n+\tRecover the overwritten dtype for the descriptor. Use the _size\n+\tfield of the vptr for character string lengths.\n+\t(gfc_trans_allocate): Cope with unlimited polymorphic allocate\n+\tobjects; especially with character source tags.\n+\t(reset_vptr): New function.\n+\t(gfc_trans_deallocate): Call it.\n+\t* trans-types.c (gfc_get_derived_type): Detect unlimited\n+\tpolymorphic types and deal with cases where the derived type of\n+\tcomponents is null.\n+\t* trans.c : Update copyright year.\n+\t(trans_code): Call gfc_trans_class_assign for C717 cases where\n+\tthe lhs is not unlimited polymorphic.\n+\n 2012-12-19  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/55733\n@@ -51,7 +170,7 @@\n \tPR fortran/55593\n \t* frontend-passes.c (doloop_code):  Use resolved_sym\n \tinstead of n.sym->formal for formal argument list\n-\tto get the correct version for all generic subroutines. \n+\tto get the correct version for all generic subroutines.\n \n 2012-12-05  Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "bc20bb9871d06f943a434d885c5be9b21bfcf680", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -557,7 +557,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \t    goto cleanup;\n \n \t  case AS_ASSUMED_RANK:\n-\t    gcc_unreachable (); \n+\t    gcc_unreachable ();\n \t  }\n \n       if (gfc_match_char (')') == MATCH_YES)\n@@ -666,7 +666,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \t      goto cleanup;\n \n \t    case AS_ASSUMED_RANK:\n-\t      gcc_unreachable (); \n+\t      gcc_unreachable ();\n \t  }\n \n       if (gfc_match_char (']') == MATCH_YES)\n@@ -1414,7 +1414,7 @@ extract_element (gfc_expr *e)\n     gfc_free_expr (e);\n \n   current_expand.extract_count++;\n-  \n+\n   return SUCCESS;\n }\n \n@@ -1815,7 +1815,7 @@ resolve_array_list (gfc_constructor_base base)\n         {\n \t  gfc_symbol *iter_var;\n \t  locus iter_var_loc;\n-\t \n+\n \t  if (gfc_resolve_iterator (iter, false, true) == FAILURE)\n \t    t = FAILURE;\n \n@@ -1847,6 +1847,13 @@ resolve_array_list (gfc_constructor_base base)\n \n       if (gfc_resolve_expr (c->expr) == FAILURE)\n \tt = FAILURE;\n+\n+      if (UNLIMITED_POLY (c->expr))\n+\t{\n+\t  gfc_error (\"Array constructor value at %L shall not be unlimited \"\n+\t\t     \"polymorphic [F2008: C4106]\", &c->expr->where);\n+\t  t = FAILURE;\n+\t}\n     }\n \n   return t;\n@@ -1941,7 +1948,7 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       expr->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n \t\t\t\t\t\tNULL, found_length);\n     }\n-  else \n+  else\n     {\n       /* We've got a character length specified.  It should be an integer,\n \t otherwise an error is signalled elsewhere.  */"}, {"sha": "793ad75d701dc92e6c7c6dad27c7c014ff084134", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -225,7 +225,7 @@ coarray_check (gfc_expr *e, int n)\n     }\n \n   return SUCCESS;\n-} \n+}\n \n \n /* Make sure the expression is a logical array.  */\n@@ -304,7 +304,7 @@ less_than_bitsize1 (const char *arg1, gfc_expr *expr1, const char *arg2,\n     {\n       gfc_extract_int (expr2, &i2);\n       i3 = gfc_validate_kind (BT_INTEGER, expr1->ts.kind, false);\n- \n+\n       /* For ISHFT[C], check that |shift| <= bit_size(i).  */\n       if (arg2 == NULL)\n \t{\n@@ -355,7 +355,7 @@ less_than_bitsizekind (const char *arg, gfc_expr *expr, int k)\n \n   if (expr->expr_type != EXPR_CONSTANT)\n     return SUCCESS;\n- \n+\n   i = gfc_validate_kind (BT_INTEGER, k, false);\n   gfc_extract_int (expr, &val);\n \n@@ -510,7 +510,7 @@ variable_check (gfc_expr *e, int n, bool allow_proc)\n \t\t  || (ref->u.c.component->ts.type != BT_CLASS\n \t\t      && ref->u.c.component->attr.pointer)))\n \t    break;\n-\t} \n+\t}\n \n       if (!ref)\n \t{\n@@ -575,7 +575,7 @@ dim_corank_check (gfc_expr *dim, gfc_expr *array)\n \n   if (dim->expr_type != EXPR_CONSTANT)\n     return SUCCESS;\n-  \n+\n   if (array->ts.type == BT_CLASS)\n     return SUCCESS;\n \n@@ -668,7 +668,7 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n \t{\n \t  if (mpz_cmp (a_size, b_size) != 0)\n \t    ret = 0;\n-  \n+\n \t  mpz_clear (b_size);\n \t}\n       mpz_clear (a_size);\n@@ -841,7 +841,7 @@ gfc_check_allocated (gfc_expr *array)\n     return FAILURE;\n   if (allocatable_check (array, 0) == FAILURE)\n     return FAILURE;\n-  \n+\n   return SUCCESS;\n }\n \n@@ -1881,7 +1881,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n \t\treturn SUCCESS;\n \t      i = mpz_get_si (c->ts.u.cl->length->value.integer);\n \t    }\n-\t  else \n+\t  else\n \t    return SUCCESS;\n \t}\n       else\n@@ -1903,7 +1903,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n \n   if (i != 1)\n     {\n-      gfc_error (\"Argument of %s at %L must be of length one\", \n+      gfc_error (\"Argument of %s at %L must be of length one\",\n \t\t gfc_current_intrinsic, &c->where);\n       return FAILURE;\n     }\n@@ -2037,7 +2037,7 @@ gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n       || type_check (shift, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (size != NULL) \n+  if (size != NULL)\n     {\n       int i2, i3;\n \n@@ -3081,7 +3081,7 @@ gfc_check_rank (gfc_expr *a ATTRIBUTE_UNUSED)\n   bool is_variable = true;\n \n   /* Functions returning pointers are regarded as variable, cf. F2008, R602. */\n-  if (a->expr_type == EXPR_FUNCTION) \n+  if (a->expr_type == EXPR_FUNCTION)\n     is_variable = a->value.function.esym\n \t\t  ? a->value.function.esym->result->attr.pointer\n \t\t  : a->symtree->n.sym->result->attr.pointer;\n@@ -3269,7 +3269,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t  if (order_size != shape_size)\n \t    {\n \t      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t\t \"has wrong number of elements (%d/%d)\", \n+\t\t\t \"has wrong number of elements (%d/%d)\",\n \t\t\t gfc_current_intrinsic_arg[3]->name,\n \t\t\t gfc_current_intrinsic, &order->where,\n \t\t\t order_size, shape_size);\n@@ -3287,7 +3287,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t      if (dim < 1 || dim > order_size)\n \t\t{\n \t\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t\t     \"has out-of-range dimension (%d)\", \n+\t\t\t     \"has out-of-range dimension (%d)\",\n \t\t\t     gfc_current_intrinsic_arg[3]->name,\n \t\t\t     gfc_current_intrinsic, &e->where, dim);\n \t\t  return FAILURE;\n@@ -3319,7 +3319,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t  gfc_constructor *c;\n \t  bool test;\n \n-\t  \n+\n \t  mpz_init_set_ui (size, 1);\n \t  for (c = gfc_constructor_first (shape->value.constructor);\n \t       c; c = gfc_constructor_next (c))\n@@ -3346,17 +3346,17 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n gfc_try\n gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n {\n-\n   if (a->ts.type != BT_DERIVED && a->ts.type != BT_CLASS)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of a derived type\",\n-\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n-\t\t &a->where);\n-      return FAILURE;\n+        gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t   \"cannot be of type %s\",\n+\t\t   gfc_current_intrinsic_arg[0]->name,\n+\t\t   gfc_current_intrinsic,\n+\t\t   &a->where, gfc_typename (&a->ts));\n+        return FAILURE;\n     }\n \n-  if (!gfc_type_is_extensible (a->ts.u.derived))\n+  if (!(gfc_type_is_extensible (a->ts.u.derived) || UNLIMITED_POLY (a)))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n \t\t \"must be of an extensible type\",\n@@ -3367,14 +3367,15 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n \n   if (b->ts.type != BT_DERIVED && b->ts.type != BT_CLASS)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n-\t\t \"must be of a derived type\",\n-\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n-\t\t &b->where);\n+        gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t   \"cannot be of type %s\",\n+\t\t   gfc_current_intrinsic_arg[0]->name,\n+\t\t   gfc_current_intrinsic,\n+\t\t   &b->where, gfc_typename (&b->ts));\n       return FAILURE;\n     }\n \n-  if (!gfc_type_is_extensible (b->ts.u.derived))\n+  if (!(gfc_type_is_extensible (b->ts.u.derived) || UNLIMITED_POLY (b)))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n \t\t \"must be of an extensible type\",\n@@ -3688,7 +3689,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n     return FAILURE;\n \n   /* dim_rank_check() does not apply here.  */\n-  if (dim \n+  if (dim\n       && dim->expr_type == EXPR_CONSTANT\n       && (mpz_cmp_ui (dim->value.integer, 1) < 0\n \t  || mpz_cmp_ui (dim->value.integer, source->rank + 1) > 0))\n@@ -4233,7 +4234,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n   if (mask->rank != field->rank && field->rank != 0)\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L must have \"\n-\t\t \"the same rank as '%s' or be a scalar\", \n+\t\t \"the same rank as '%s' or be a scalar\",\n \t\t gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n \t\t &field->where, gfc_current_intrinsic_arg[1]->name);\n       return FAILURE;\n@@ -4246,7 +4247,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \tif (! identical_dimen_shape (mask, i, field, i))\n \t{\n \t  gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L \"\n-\t\t     \"must have identical shape.\", \n+\t\t     \"must have identical shape.\",\n \t\t     gfc_current_intrinsic_arg[2]->name,\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &field->where);"}, {"sha": "61d65e7a30b921534a6022bd9b206a62ae380637", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 325, "deletions": 38, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of Fortran 2003 Polymorphism.\n-   Copyright (C) 2009, 2010\n+   Copyright (C) 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Richard Thomas <pault@gcc.gnu.org>\n    and Janus Weil <janus@gcc.gnu.org>\n@@ -55,7 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"constructor.h\"\n \n-\n /* Inserts a derived type component reference in a data reference chain.\n     TS: base type of the ref chain so far, in which we will pick the component\n     REF: the address of the GFC_REF pointer to update\n@@ -237,7 +236,7 @@ gfc_add_class_array_ref (gfc_expr *e)\n       ref = ref->next;\n       ref->type = REF_ARRAY;\n       ref->u.ar.type = AR_FULL;\n-      ref->u.ar.as = as;\t  \n+      ref->u.ar.as = as;\n     }\n }\n \n@@ -389,7 +388,7 @@ gfc_is_class_container_ref (gfc_expr *e)\n       if (ref->type != REF_COMPONENT)\n \tresult = false;\n       else if (ref->u.c.component->ts.type == BT_CLASS)\n-\tresult = true; \n+\tresult = true;\n       else\n \tresult = false;\n     }\n@@ -403,20 +402,31 @@ gfc_is_class_container_ref (gfc_expr *e)\n    the _vptr component to the declared type.  */\n \n gfc_expr *\n-gfc_class_null_initializer (gfc_typespec *ts)\n+gfc_class_null_initializer (gfc_typespec *ts, gfc_expr *init_expr)\n {\n   gfc_expr *init;\n   gfc_component *comp;\n-  \n+  gfc_symbol *vtab = NULL;\n+  bool is_unlimited_polymorphic;\n+\n+  is_unlimited_polymorphic = ts->u.derived\n+      && ts->u.derived->components->ts.u.derived\n+      && ts->u.derived->components->ts.u.derived->attr.unlimited_polymorphic;\n+\n+  if (is_unlimited_polymorphic && init_expr)\n+    vtab = gfc_find_intrinsic_vtab (&(init_expr->ts));\n+  else\n+    vtab = gfc_find_derived_vtab (ts->u.derived);\n+\n   init = gfc_get_structure_constructor_expr (ts->type, ts->kind,\n \t\t\t\t\t     &ts->u.derived->declared_at);\n   init->ts = *ts;\n-  \n+\n   for (comp = ts->u.derived->components; comp; comp = comp->next)\n     {\n       gfc_constructor *ctor = gfc_constructor_get();\n-      if (strcmp (comp->name, \"_vptr\") == 0)\n-\tctor->expr = gfc_lval_expr_from_sym (gfc_find_derived_vtab (ts->u.derived));\n+      if (strcmp (comp->name, \"_vptr\") == 0 && vtab)\n+\tctor->expr = gfc_lval_expr_from_sym (vtab);\n       else\n \tctor->expr = gfc_get_null_expr (NULL);\n       gfc_constructor_append (&init->value.constructor, ctor);\n@@ -434,9 +444,14 @@ static void\n get_unique_type_string (char *string, gfc_symbol *derived)\n {\n   char dt_name[GFC_MAX_SYMBOL_LEN+1];\n+  if (derived->attr.unlimited_polymorphic)\n+    sprintf (dt_name, \"%s\", \"$tar\");\n+  else\n   sprintf (dt_name, \"%s\", derived->name);\n   dt_name[0] = TOUPPER (dt_name[0]);\n-  if (derived->module)\n+  if (derived->attr.unlimited_polymorphic)\n+    sprintf (string, \"_%s\", dt_name);\n+  else if (derived->module)\n     sprintf (string, \"%s_%s\", derived->module, dt_name);\n   else if (derived->ns->proc_name)\n     sprintf (string, \"%s_%s\", derived->ns->proc_name->name, dt_name);\n@@ -475,10 +490,30 @@ gfc_hash_value (gfc_symbol *sym)\n   unsigned int hash = 0;\n   char c[2*(GFC_MAX_SYMBOL_LEN+1)];\n   int i, len;\n-  \n+\n   get_unique_type_string (&c[0], sym);\n   len = strlen (c);\n-  \n+\n+  for (i = 0; i < len; i++)\n+    hash = (hash << 6) + (hash << 16) - hash + c[i];\n+\n+  /* Return the hash but take the modulus for the sake of module read,\n+     even though this slightly increases the chance of collision.  */\n+  return (hash % 100000000);\n+}\n+\n+\n+/* Assign a hash value for an intrinsic type. The algorithm is that of SDBM.  */\n+\n+unsigned int\n+gfc_intrinsic_hash_value (gfc_typespec *ts)\n+{\n+  unsigned int hash = 0;\n+  const char *c = gfc_typename (ts);\n+  int i, len;\n+\n+  len = strlen (c);\n+\n   for (i = 0; i < len; i++)\n     hash = (hash << 6) + (hash << 16) - hash + c[i];\n \n@@ -501,6 +536,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   gfc_symbol *fclass;\n   gfc_symbol *vtab;\n   gfc_component *c;\n+  gfc_namespace *ns;\n   int rank;\n \n   gcc_assert (as);\n@@ -518,7 +554,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \n   attr->class_ok = attr->dummy || attr->pointer || attr->allocatable\n \t\t   || attr->select_type_temporary;\n-  \n+\n   if (!attr->class_ok)\n     /* We can not build the class container yet.  */\n     return SUCCESS;\n@@ -539,17 +575,28 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   else\n     sprintf (name, \"__class_%s\", tname);\n \n-  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n+  if (ts->u.derived->attr.unlimited_polymorphic)\n+    {\n+      /* Find the top-level namespace.  */\n+      for (ns = gfc_current_ns; ns; ns = ns->parent)\n+\tif (!ns->parent)\n+\t  break;\n+    }\n+  else\n+    ns = ts->u.derived->ns;\n+\n+  gfc_find_symbol (name, ns, 0, &fclass);\n   if (fclass == NULL)\n     {\n       gfc_symtree *st;\n       /* If not there, create a new symbol.  */\n-      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n-      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n+      fclass = gfc_new_symbol (name, ns);\n+      st = gfc_new_symtree (&ns->sym_root, name);\n       st->n.sym = fclass;\n       gfc_set_sym_referenced (fclass);\n       fclass->refs++;\n       fclass->ts.type = BT_UNKNOWN;\n+      if (!ts->u.derived->attr.unlimited_polymorphic)\n       fclass->attr.abstract = ts->u.derived->attr.abstract;\n       fclass->f2k_derived = gfc_get_namespace (NULL, 0);\n       if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n@@ -569,7 +616,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->attr.allocatable = attr->allocatable;\n       c->attr.dimension = attr->dimension;\n       c->attr.codimension = attr->codimension;\n-      c->attr.abstract = ts->u.derived->attr.abstract;\n+      c->attr.abstract = fclass->attr.abstract;\n       c->as = (*as);\n       c->initializer = NULL;\n \n@@ -591,17 +638,21 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->attr.pointer = 1;\n     }\n \n-  /* Since the extension field is 8 bit wide, we can only have\n-     up to 255 extension levels.  */\n-  if (ts->u.derived->attr.extension == 255)\n+  if (!ts->u.derived->attr.unlimited_polymorphic)\n     {\n-      gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n-\t\t ts->u.derived->name, &ts->u.derived->declared_at);\n-      return FAILURE;\n+      /* Since the extension field is 8 bit wide, we can only have\n+\t up to 255 extension levels.  */\n+      if (ts->u.derived->attr.extension == 255)\n+\t{\n+\t  gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t\t     ts->u.derived->name, &ts->u.derived->declared_at);\n+\treturn FAILURE;\n+\t}\n+\n+      fclass->attr.extension = ts->u.derived->attr.extension + 1;\n+      fclass->attr.alloc_comp = ts->u.derived->attr.alloc_comp;\n     }\n-    \n-  fclass->attr.extension = ts->u.derived->attr.extension + 1;\n-  fclass->attr.alloc_comp = ts->u.derived->attr.alloc_comp;\n+\n   fclass->attr.is_class = 1;\n   ts->u.derived = fclass;\n   attr->allocatable = attr->pointer = attr->dimension = attr->codimension = 0;\n@@ -620,7 +671,7 @@ add_proc_comp (gfc_symbol *vtype, const char *name, gfc_typebound_proc *tb)\n \n   if (tb->non_overridable)\n     return;\n-  \n+\n   c = gfc_find_component (vtype, name, true, true);\n \n   if (c == NULL)\n@@ -670,7 +721,7 @@ add_procs_to_declared_vtab1 (gfc_symtree *st, gfc_symbol *vtype)\n   if (st->right)\n     add_procs_to_declared_vtab1 (st->right, vtype);\n \n-  if (st->n.tb && !st->n.tb->error \n+  if (st->n.tb && !st->n.tb->error\n       && !st->n.tb->is_generic && st->n.tb->u.specific)\n     add_proc_comp (vtype, st->name, st->n.tb);\n }\n@@ -1766,15 +1817,15 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n \n-  /* Find the top-level namespace (MODULE or PROGRAM).  */\n+  /* Find the top-level namespace.  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n     if (!ns->parent)\n       break;\n \n   /* If the type is a class container, use the underlying derived type.  */\n-  if (derived->attr.is_class)\n+  if (!derived->attr.unlimited_polymorphic && derived->attr.is_class)\n     derived = gfc_get_derived_super_type (derived);\n- \n+\n   if (ns)\n     {\n       char name[GFC_MAX_SYMBOL_LEN+1], tname[GFC_MAX_SYMBOL_LEN+1];\n@@ -1844,7 +1895,11 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n-\t      parent = gfc_get_derived_super_type (derived);\n+\t      if (!derived->attr.unlimited_polymorphic)\n+\t\tparent = gfc_get_derived_super_type (derived);\n+\t      else\n+\t\tparent = NULL;\n+\n \t      if (parent)\n \t\t{\n \t\t  parent_vtab = gfc_find_derived_vtab (parent);\n@@ -1862,7 +1917,9 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  c->initializer = gfc_get_null_expr (NULL);\n \t\t}\n \n-\t      if (derived->components == NULL && !derived->attr.zero_comp)\n+\t      if (!derived->attr.unlimited_polymorphic\n+\t\t  && derived->components == NULL\n+\t\t  && !derived->attr.zero_comp)\n \t\t{\n \t\t  /* At this point an error must have occurred.\n \t\t     Prevent further errors on the vtype components.  */\n@@ -1878,7 +1935,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      c->ts.type = BT_DERIVED;\n \t      c->ts.u.derived = derived;\n-\t      if (derived->attr.abstract)\n+\t      if (derived->attr.unlimited_polymorphic\n+\t\t  || derived->attr.abstract)\n \t\tc->initializer = gfc_get_null_expr (NULL);\n \t      else\n \t\t{\n@@ -1905,7 +1963,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      c->tb = XCNEW (gfc_typebound_proc);\n \t      c->tb->ppc = 1;\n-\t      if (derived->attr.abstract)\n+\t      if (derived->attr.unlimited_polymorphic\n+\t\t  || derived->attr.abstract)\n \t\tc->initializer = gfc_get_null_expr (NULL);\n \t      else\n \t\t{\n@@ -1966,7 +2025,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t Note: The actual wrapper function can only be generated\n \t\t at resolution time.  */\n \t    /* FIXME: Enable ABI-breaking \"_final\" generation.  */\n-\t    if (0) \n+\t    if (0)\n \t    {\n \t      if (gfc_add_component (vtype, \"_final\", &c) == FAILURE)\n \t\tgoto cleanup;\n@@ -1978,7 +2037,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t    }\n \n \t      /* Add procedure pointers for type-bound procedures.  */\n-\t      add_procs_to_declared_vtab (derived, vtype);\n+\t      if (!derived->attr.unlimited_polymorphic)\n+\t\tadd_procs_to_declared_vtab (derived, vtype);\n \t  }\n \n have_vtype:\n@@ -2055,6 +2115,233 @@ gfc_is_finalizable (gfc_symbol *derived, gfc_expr **final_expr)\n }\n \n \n+/* Find (or generate) the symbol for an intrinsic type's vtab.  This is\n+   need to support unlimited polymorphism.  */\n+\n+gfc_symbol *\n+gfc_find_intrinsic_vtab (gfc_typespec *ts)\n+{\n+  gfc_namespace *ns;\n+  gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n+  gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n+  int charlen = 0;\n+\n+  if (ts->type == BT_CHARACTER && ts->deferred)\n+    {\n+      gfc_error (\"TODO: Deferred character length variable at %C cannot \"\n+\t\t \"yet be associated with unlimited polymorphic entities\");\n+      return NULL;\n+    }\n+\n+  if (ts->type == BT_UNKNOWN)\n+    return NULL;\n+\n+  /* Sometimes the typespec is passed from a single call.  */\n+  if (ts->type == BT_DERIVED)\n+    return gfc_find_derived_vtab (ts->u.derived);\n+\n+  /* Find the top-level namespace.  */\n+  for (ns = gfc_current_ns; ns; ns = ns->parent)\n+    if (!ns->parent)\n+      break;\n+\n+  if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n+      && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n+\n+  if (ns)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN+1], tname[GFC_MAX_SYMBOL_LEN+1];\n+\n+      if (ts->type == BT_CHARACTER)\n+\tsprintf (tname, \"%s_%d_%d\", gfc_basic_typename (ts->type),\n+\t\t charlen, ts->kind);\n+      else\n+\tsprintf (tname, \"%s_%d_\", gfc_basic_typename (ts->type), ts->kind);\n+\n+      sprintf (name, \"__vtab_%s\", tname);\n+\n+      /* Look for the vtab symbol in various namespaces.  */\n+      gfc_find_symbol (name, gfc_current_ns, 0, &vtab);\n+      if (vtab == NULL)\n+\tgfc_find_symbol (name, ns, 0, &vtab);\n+\n+      if (vtab == NULL)\n+\t{\n+\t  gfc_get_symbol (name, ns, &vtab);\n+\t  vtab->ts.type = BT_DERIVED;\n+\t  if (gfc_add_flavor (&vtab->attr, FL_VARIABLE, NULL,\n+\t                      &gfc_current_locus) == FAILURE)\n+\t    goto cleanup;\n+\t  vtab->attr.target = 1;\n+\t  vtab->attr.save = SAVE_IMPLICIT;\n+\t  vtab->attr.vtab = 1;\n+\t  vtab->attr.access = ACCESS_PUBLIC;\n+\t  gfc_set_sym_referenced (vtab);\n+\t  sprintf (name, \"__vtype_%s\", tname);\n+\n+\t  gfc_find_symbol (name, ns, 0, &vtype);\n+\t  if (vtype == NULL)\n+\t    {\n+\t      gfc_component *c;\n+\t      int hash;\n+\t      gfc_namespace *sub_ns;\n+\t      gfc_namespace *contained;\n+\n+\t      gfc_get_symbol (name, ns, &vtype);\n+\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t\tgoto cleanup;\n+\t      vtype->attr.access = ACCESS_PUBLIC;\n+\t      vtype->attr.vtype = 1;\n+\t      gfc_set_sym_referenced (vtype);\n+\n+\t      /* Add component '_hash'.  */\n+\t      if (gfc_add_component (vtype, \"_hash\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      hash = gfc_intrinsic_hash_value (ts);\n+\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t NULL, hash);\n+\n+\t      /* Add component '_size'.  */\n+\t      if (gfc_add_component (vtype, \"_size\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      if (ts->type == BT_CHARACTER)\n+\t\tc->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t   NULL, charlen*ts->kind);\n+\t      else\n+\t\tc->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t   NULL, ts->kind);\n+\n+\t      /* Add component _extends.  */\n+\t      if (gfc_add_component (vtype, \"_extends\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->attr.pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      /* Avoid segfaults because due to character length.   */\n+\t      c->ts.type = ts->type == BT_CHARACTER ? BT_VOID : ts->type;\n+\t      c->ts.kind = ts->kind;\n+\t      c->initializer = gfc_get_null_expr (NULL);\n+\n+\t      /* Add component _def_init.  */\n+\t      if (gfc_add_component (vtype, \"_def_init\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->attr.pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      /* Avoid segfaults due to missing character length.   */\n+\t      c->ts.type = ts->type == BT_CHARACTER ? BT_VOID : ts->type;\n+\t      c->ts.kind = ts->kind;\n+\t      c->initializer = gfc_get_null_expr (NULL);\n+\n+\t      /* Add component _copy.  */\n+\t      if (gfc_add_component (vtype, \"_copy\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->attr.proc_pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->tb = XCNEW (gfc_typebound_proc);\n+\t      c->tb->ppc = 1;\n+\n+\t      /* Check to see if copy function already exists.  Note\n+\t\t that this is only used for characters of different\n+\t\t lengths.  */\n+\t      contained = ns->contained;\n+\t      for (; contained; contained = contained->sibling)\n+\t\tif (contained->proc_name\n+\t\t    && strcmp (name, contained->proc_name->name) == 0)\n+\t\t  {\n+\t\t    copy = contained->proc_name;\n+\t\t    goto got_char_copy;\n+\t\t  }\n+\n+\t      /* Set up namespace.  */\n+\t      sub_ns = gfc_get_namespace (ns, 0);\n+\t      sub_ns->sibling = ns->contained;\n+\t      ns->contained = sub_ns;\n+\t      sub_ns->resolved = 1;\n+\t      /* Set up procedure symbol.  */\n+\t      if (ts->type != BT_CHARACTER)\n+\t\tsprintf (name, \"__copy_%s\", tname);\n+\t      else\n+\t\t/* __copy is always the same for characters.  */\n+\t\tsprintf (name, \"__copy_character_%d\", ts->kind);\n+\t      gfc_get_symbol (name, sub_ns, &copy);\n+\t      sub_ns->proc_name = copy;\n+\t      copy->attr.flavor = FL_PROCEDURE;\n+\t      copy->attr.subroutine = 1;\n+\t      copy->attr.pure = 1;\n+\t      copy->attr.if_source = IFSRC_DECL;\n+\t      /* This is elemental so that arrays are automatically\n+\t\t treated correctly by the scalarizer.  */\n+\t      copy->attr.elemental = 1;\n+\t      if (ns->proc_name->attr.flavor == FL_MODULE)\n+\t\tcopy->module = ns->proc_name->name;\n+\t\t  gfc_set_sym_referenced (copy);\n+\t      /* Set up formal arguments.  */\n+\t      gfc_get_symbol (\"src\", sub_ns, &src);\n+\t      src->ts.type = ts->type;\n+\t      src->ts.kind = ts->kind;\n+\t      src->attr.flavor = FL_VARIABLE;\n+\t      src->attr.dummy = 1;\n+\t      src->attr.intent = INTENT_IN;\n+\t      gfc_set_sym_referenced (src);\n+\t      copy->formal = gfc_get_formal_arglist ();\n+\t      copy->formal->sym = src;\n+\t      gfc_get_symbol (\"dst\", sub_ns, &dst);\n+\t      dst->ts.type = ts->type;\n+\t      dst->ts.kind = ts->kind;\n+\t      dst->attr.flavor = FL_VARIABLE;\n+\t      dst->attr.dummy = 1;\n+\t      dst->attr.intent = INTENT_OUT;\n+\t      gfc_set_sym_referenced (dst);\n+\t      copy->formal->next = gfc_get_formal_arglist ();\n+\t      copy->formal->next->sym = dst;\n+\t      /* Set up code.  */\n+\t      sub_ns->code = gfc_get_code ();\n+\t      sub_ns->code->op = EXEC_INIT_ASSIGN;\n+\t      sub_ns->code->expr1 = gfc_lval_expr_from_sym (dst);\n+\t      sub_ns->code->expr2 = gfc_lval_expr_from_sym (src);\n+\t    got_char_copy:\n+\t      /* Set initializer.  */\n+\t      c->initializer = gfc_lval_expr_from_sym (copy);\n+\t      c->ts.interface = copy;\n+\t    }\n+\t  vtab->ts.u.derived = vtype;\n+\t  vtab->value = gfc_default_initializer (&vtab->ts);\n+\t}\n+    }\n+\n+  found_sym = vtab;\n+\n+cleanup:\n+  /* It is unexpected to have some symbols added at resolution or code\n+     generation time. We commit the changes in order to keep a clean state.  */\n+  if (found_sym)\n+    {\n+      gfc_commit_symbol (vtab);\n+      if (vtype)\n+\tgfc_commit_symbol (vtype);\n+      if (def_init)\n+\tgfc_commit_symbol (def_init);\n+      if (copy)\n+\tgfc_commit_symbol (copy);\n+      if (src)\n+\tgfc_commit_symbol (src);\n+      if (dst)\n+\tgfc_commit_symbol (dst);\n+    }\n+  else\n+    gfc_undo_symbols ();\n+\n+  return found_sym;\n+}\n+\n+\n /* General worker function to find either a type-bound procedure or a\n    type-bound user operator.  */\n \n@@ -2147,7 +2434,7 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n   /* Try to find it in the current type's namespace.  */\n   if (derived->f2k_derived)\n     res = derived->f2k_derived->tb_op[op];\n-  else  \n+  else\n     res = NULL;\n \n   /* Check access.  */"}, {"sha": "5ed838856a924d4a1f140b26bbbe5d9872b623bd", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -2735,9 +2735,37 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \treturn MATCH_ERROR;\n       else if (m == MATCH_YES)\n \t{\n-\t  gfc_fatal_error (\"Unlimited polymorphism at %C not yet supported\");\n+\t  gfc_symbol *upe;\n+\t  gfc_symtree *st;\n+\t  ts->type = BT_CLASS;\n+\t  gfc_find_symbol (\"$tar\", gfc_current_ns, 1, &upe);\n+\t  if (upe == NULL)\n+\t    {\n+\t      upe = gfc_new_symbol (\"$tar\", gfc_current_ns);\n+\t      st = gfc_new_symtree (&gfc_current_ns->sym_root, \"$tar\");\n+\t      st->n.sym = upe;\n+\t      gfc_set_sym_referenced (upe);\n+\t      upe->refs++;\n+\t      upe->ts.type = BT_VOID;\n+\t      upe->attr.unlimited_polymorphic = 1;\n+\t      /* This is essential to force the construction of\n+\t\t unlimited polymorphic component class containers.  */\n+\t      upe->attr.zero_comp = 1;\n+\t      if (gfc_add_flavor (&upe->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n \t  return MATCH_ERROR;\n \t}\n+\t  else\n+\t    {\n+\t      st = gfc_find_symtree (gfc_current_ns->sym_root, \"$tar\");\n+\t      if (st == NULL)\n+\t\tst = gfc_new_symtree (&gfc_current_ns->sym_root, \"$tar\");\n+\t      st->n.sym = upe;\n+\t      upe->refs++;\n+\t    }\n+\t  ts->u.derived = upe;\n+\t  return m;\n+\t}\n \n       m = gfc_match (\" class ( %n )\", name);\n       if (m != MATCH_YES)\n@@ -4248,6 +4276,10 @@ gfc_match_data_decl (void)\n       goto cleanup;\n     }\n \n+  if (current_ts.type == BT_CLASS\n+\t&& current_ts.u.derived->attr.unlimited_polymorphic)\n+    goto ok;\n+\n   if ((current_ts.type == BT_DERIVED || current_ts.type == BT_CLASS)\n       && current_ts.u.derived->components == NULL\n       && !current_ts.u.derived->attr.zero_comp)"}, {"sha": "5c9ce11c4eec62e3d168bb87e642abdbf2505b16", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -729,10 +729,10 @@ gfc_copy_shape_excluding (mpz_t *shape, int rank, gfc_expr *dim)\n   mpz_t *new_shape, *s;\n   int i, n;\n \n-  if (shape == NULL \n+  if (shape == NULL\n       || rank <= 1\n       || dim == NULL\n-      || dim->expr_type != EXPR_CONSTANT \n+      || dim->expr_type != EXPR_CONSTANT\n       || dim->ts.type != BT_INTEGER)\n     return NULL;\n \n@@ -1389,7 +1389,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n \t  gcc_assert (begin->rank == 1);\n \t  /* Zero-sized arrays have no shape and no elements, stop early.  */\n-\t  if (!begin->shape) \n+\t  if (!begin->shape)\n \t    {\n \t      mpz_init_set_ui (nelts, 0);\n \t      break;\n@@ -1473,7 +1473,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n \t  /* An element reference reduces the rank of the expression; don't\n \t     add anything to the shape array.  */\n-\t  if (ref->u.ar.dimen_type[d] != DIMEN_ELEMENT) \n+\t  if (ref->u.ar.dimen_type[d] != DIMEN_ELEMENT)\n \t    mpz_set (expr->shape[shape_i++], tmp_mpz);\n \t}\n \n@@ -1520,7 +1520,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    }\n \t  else\n \t    {\n-\t      mpz_add (ctr[d], ctr[d], stride[d]); \n+\t      mpz_add (ctr[d], ctr[d], stride[d]);\n \n \t      if (mpz_cmp_ui (stride[d], 0) > 0\n \t\t  ? mpz_cmp (ctr[d], end[d]) > 0\n@@ -1952,7 +1952,7 @@ scalarize_intrinsic_call (gfc_expr *e)\n   gfc_constructor *ci, *new_ctor;\n   gfc_expr *expr, *old;\n   int n, i, rank[5], array_arg;\n-  \n+\n   /* Find which, if any, arguments are arrays.  Assume that the old\n      expression carries the type information and that the first arg\n      that is an array expression carries all the shape information.*/\n@@ -2105,7 +2105,7 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n     case INTRINSIC_LE_OS:\n       if ((*check_function) (op2) == FAILURE)\n \treturn FAILURE;\n-      \n+\n       if (!(et0 (op1) == BT_CHARACTER && et0 (op2) == BT_CHARACTER)\n \t  && !(numeric_type (et0 (op1)) && numeric_type (et0 (op2))))\n \t{\n@@ -2271,7 +2271,7 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \n   name = e->symtree->n.sym->name;\n \n-  functions = (gfc_option.warn_std & GFC_STD_F2003) \n+  functions = (gfc_option.warn_std & GFC_STD_F2003)\n \t\t? inquiry_func_f2003 : inquiry_func_f95;\n \n   for (i = 0; functions[i]; i++)\n@@ -2360,7 +2360,7 @@ check_transformational (gfc_expr *e)\n \n   name = e->symtree->n.sym->name;\n \n-  functions = (gfc_option.allow_std & GFC_STD_F2003) \n+  functions = (gfc_option.allow_std & GFC_STD_F2003)\n \t\t? trans_func_f2003 : trans_func_f95;\n \n   /* NULL() is dealt with below.  */\n@@ -3097,7 +3097,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t\t|| gfc_current_ns->parent->proc_name->attr.subroutine)\n \t      || gfc_current_ns->parent->proc_name->attr.is_main_program))\n \t{\n-\t  /* ... that is not a function...  */ \n+\t  /* ... that is not a function...  */\n \t  if (!gfc_current_ns->proc_name->attr.function)\n \t    bad_proc = true;\n \n@@ -3137,7 +3137,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n     }\n \n   if (rvalue->expr_type == EXPR_NULL)\n-    {  \n+    {\n       if (has_pointer && (ref == NULL || ref->next == NULL)\n \t  && lvalue->symtree->n.sym->attr.data)\n         return SUCCESS;\n@@ -3150,7 +3150,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n     }\n \n   /* This is possibly a typo: x = f() instead of x => f().  */\n-  if (gfc_option.warn_surprising \n+  if (gfc_option.warn_surprising\n       && rvalue->expr_type == EXPR_FUNCTION\n       && rvalue->symtree->n.sym->attr.pointer)\n     gfc_warning (\"POINTER valued function appears on right-hand side of \"\n@@ -3222,15 +3222,15 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \t      mpfr_init (rv);\n \t      gfc_set_model_kind (rvalue->ts.kind);\n \t      mpfr_init (diff);\n-\t      \n+\n \t      mpfr_set (rv, rvalue->value.real, GFC_RND_MODE);\n \t      mpfr_sub (diff, rv, rvalue->value.real, GFC_RND_MODE);\n-\t  \n+\n \t      if (!mpfr_zero_p (diff))\n \t\tgfc_warning (\"Change of value in conversion from \"\n \t\t\t     \" %s to %s at %L\", gfc_typename (&rvalue->ts),\n \t\t\t     gfc_typename (&lvalue->ts), &rvalue->where);\n-\t      \n+\n \t      mpfr_clear (rv);\n \t      mpfr_clear (diff);\n \t    }\n@@ -3550,9 +3550,22 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n   if (!gfc_compare_types (&lvalue->ts, &rvalue->ts))\n     {\n-      gfc_error (\"Different types in pointer assignment at %L; attempted \"\n-\t\t \"assignment of %s to %s\", &lvalue->where, \n-\t\t gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));\n+      /* Check for F03:C717.  */\n+      if (UNLIMITED_POLY (rvalue)\n+\t  && !(UNLIMITED_POLY (lvalue)\n+\t       || (lvalue->ts.type == BT_DERIVED\n+\t\t   && (lvalue->ts.u.derived->attr.is_bind_c\n+\t\t       || lvalue->ts.u.derived->attr.sequence))))\n+\tgfc_error (\"Data-pointer-object &L must be unlimited \"\n+\t\t   \"polymorphic, a sequence derived type or of a \"\n+\t\t   \"type with the BIND attribute assignment at %L \"\n+\t\t   \"to be compatible with an unlimited polymorphic \"\n+\t\t   \"target\", &lvalue->where);\n+      else\n+\tgfc_error (\"Different types in pointer assignment at %L; \"\n+\t\t   \"attempted assignment of %s to %s\", &lvalue->where,\n+\t\t   gfc_typename (&rvalue->ts),\n+\t\t   gfc_typename (&lvalue->ts));\n       return FAILURE;\n     }\n \n@@ -3569,9 +3582,11 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n-  if (lvalue->ts.type == BT_CLASS && rvalue->ts.type == BT_DERIVED)\n     /* Make sure the vtab is present.  */\n+  if (lvalue->ts.type == BT_CLASS && rvalue->ts.type == BT_DERIVED)\n     gfc_find_derived_vtab (rvalue->ts.u.derived);\n+  else if (UNLIMITED_POLY (lvalue) && !UNLIMITED_POLY (rvalue))\n+    gfc_find_intrinsic_vtab (&rvalue->ts);\n \n   /* Check rank remapping.  */\n   if (rank_remap)\n@@ -3647,7 +3662,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n   if (is_implicit_pure && gfc_impure_variable (rvalue->symtree->n.sym))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n-    \n+\n \n   if (gfc_has_vector_index (rvalue))\n     {\n@@ -3747,7 +3762,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n \n   if (r == FAILURE)\n     return r;\n-  \n+\n   if (sym->attr.pointer && rvalue->expr_type != EXPR_NULL)\n     {\n       /* F08:C461. Additional checks for pointer initialization.  */\n@@ -3772,7 +3787,7 @@ gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n \t  return FAILURE;\n \t}\n     }\n-    \n+\n   if (sym->attr.proc_pointer && rvalue->expr_type != EXPR_NULL)\n     {\n       /* F08:C1220. Additional checks for procedure pointer initialization.  */\n@@ -4251,7 +4266,7 @@ gfc_expr_check_typed (gfc_expr* e, gfc_namespace* ns, bool strict)\n static bool\n replace_symbol (gfc_expr *expr, gfc_symbol *sym, int *i ATTRIBUTE_UNUSED)\n {\n-  if ((expr->expr_type == EXPR_VARIABLE \n+  if ((expr->expr_type == EXPR_VARIABLE\n        || (expr->expr_type == EXPR_FUNCTION\n \t   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))\n       && expr->symtree->n.sym->ns == sym->ts.interface->formal_ns\n@@ -4285,7 +4300,7 @@ replace_comp (gfc_expr *expr, gfc_symbol *sym, int *i ATTRIBUTE_UNUSED)\n {\n   gfc_component *comp;\n   comp = (gfc_component *)sym;\n-  if ((expr->expr_type == EXPR_VARIABLE \n+  if ((expr->expr_type == EXPR_VARIABLE\n        || (expr->expr_type == EXPR_FUNCTION\n \t   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))\n       && expr->symtree->n.sym->ns == comp->ts.interface->formal_ns)\n@@ -4421,7 +4436,7 @@ gfc_get_corank (gfc_expr *e)\n   if (e->ts.type == BT_CLASS && e->ts.u.derived->components)\n     corank = e->ts.u.derived->components->as\n \t     ? e->ts.u.derived->components->as->corank : 0;\n-  else \n+  else\n     corank = e->symtree->n.sym->as ? e->symtree->n.sym->as->corank : 0;\n \n   for (ref = e->ref; ref; ref = ref->next)\n@@ -4478,7 +4493,7 @@ gfc_has_ultimate_pointer (gfc_expr *e)\n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_COMPONENT)\n       last = ref;\n- \n+\n   if (last && last->u.c.component->ts.type == BT_CLASS)\n     return CLASS_DATA (last->u.c.component)->attr.pointer_comp;\n   else if (last && last->u.c.component->ts.type == BT_DERIVED)\n@@ -4598,7 +4613,7 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n \t\t\t  ar->as->upper[i]->value.integer) != 0))\n \tcolon = false;\n     }\n-  \n+\n   return true;\n }\n \n@@ -4618,7 +4633,7 @@ gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n \n   isym = gfc_find_function (name);\n   gcc_assert (isym);\n-  \n+\n   result = gfc_get_expr ();\n   result->expr_type = EXPR_FUNCTION;\n   result->ts = isym->ts;\n@@ -4669,6 +4684,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n   bool is_pointer;\n   bool check_intentin;\n   bool ptr_component;\n+  bool unlimited;\n   symbol_attribute attr;\n   gfc_ref* ref;\n \n@@ -4683,6 +4699,8 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       sym = e->value.function.esym ? e->value.function.esym : e->symtree->n.sym;\n     }\n \n+  unlimited = e->ts.type == BT_CLASS && UNLIMITED_POLY (sym);\n+\n   attr = gfc_expr_attr (e);\n   if (!pointer && e->expr_type == EXPR_FUNCTION && attr.pointer)\n     {\n@@ -4722,7 +4740,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n   /* Find out whether the expr is a pointer; this also means following\n      component references to the last one.  */\n   is_pointer = (attr.pointer || attr.proc_pointer);\n-  if (pointer && !is_pointer)\n+  if (pointer && !is_pointer && !unlimited)\n     {\n       if (context)\n \tgfc_error (\"Non-POINTER in pointer association context (%s)\""}, {"sha": "5eda83989da786ab652ecf2063cc84f9ba109287", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -796,10 +796,12 @@ typedef struct\n      components or private components, procedure pointer components,\n      possibly nested.  zero_comp is true if the derived type has no\n      component at all.  defined_assign_comp is true if the derived\n-     type or a (sub-)component has a typebound defined assignment.  */\n+     type or a (sub-)component has a typebound defined assignment.\n+     unlimited_polymorphic flags the type of the container for these\n+     entities.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,\n-\t   defined_assign_comp:1;\n+\t   defined_assign_comp:1, unlimited_polymorphic:1;\n \n   /* This is a temporary selector for SELECT TYPE.  */\n   unsigned select_type_temporary:1;\n@@ -1271,7 +1273,6 @@ typedef struct gfc_symbol\n }\n gfc_symbol;\n \n-\n /* This structure is used to keep track of symbols in common blocks.  */\n typedef struct gfc_common_head\n {\n@@ -2964,11 +2965,12 @@ void gfc_add_class_array_ref (gfc_expr *);\n bool gfc_is_class_array_ref (gfc_expr *, bool *);\n bool gfc_is_class_scalar_expr (gfc_expr *);\n bool gfc_is_class_container_ref (gfc_expr *e);\n-gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n+gfc_expr *gfc_class_null_initializer (gfc_typespec *, gfc_expr *);\n unsigned int gfc_hash_value (gfc_symbol *);\n gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n \t\t\t\tgfc_array_spec **, bool);\n gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);\n+gfc_symbol *gfc_find_intrinsic_vtab (gfc_typespec *);\n gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*,\n \t\t\t\t      const char*, bool, locus*);\n gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n@@ -2980,6 +2982,11 @@ gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n bool gfc_is_finalizable (gfc_symbol *, gfc_expr **);\n \n #define CLASS_DATA(sym) sym->ts.u.derived->components\n+#define UNLIMITED_POLY(sym) \\\n+\t(sym != NULL && sym->ts.type == BT_CLASS \\\n+\t && CLASS_DATA (sym) \\\n+\t && CLASS_DATA (sym)->ts.u.derived \\\n+\t && CLASS_DATA (sym)->ts.u.derived->attr.unlimited_polymorphic)\n \n /* frontend-passes.c */\n "}, {"sha": "908db747c040e1ff5d2782d413c96daed0ecda5e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -214,7 +214,7 @@ gfc_match_interface (void)\n       if (gfc_get_symbol (name, NULL, &sym))\n \treturn MATCH_ERROR;\n \n-      if (!sym->attr.generic \n+      if (!sym->attr.generic\n \t  && gfc_add_generic (&sym->attr, sym->name, NULL) == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -351,7 +351,7 @@ gfc_match_end_interface (void)\n \t      gfc_error (\"Expecting 'END INTERFACE OPERATOR (%s)' at %C, \"\n \t\t\t \"but got %s\", s1, s2);\n \t    }\n-\t\t\n+\n \t}\n \n       break;\n@@ -446,7 +446,7 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n       if (dt1->attr.dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)\n \treturn 0;\n \n-      /* Make sure that link lists do not put this function into an \n+      /* Make sure that link lists do not put this function into an\n \t endless recursive loop!  */\n       if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n \t    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)\n@@ -485,7 +485,17 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n      that is for the formal arg, but oh well.  */\n   if (ts1->type == BT_VOID || ts2->type == BT_VOID)\n     return 1;\n-   \n+\n+  if (ts1->type == BT_CLASS\n+      && ts1->u.derived->components->ts.u.derived->attr.unlimited_polymorphic)\n+    return 1;\n+\n+  /* F2003: C717  */\n+  if (ts2->type == BT_CLASS && ts1->type == BT_DERIVED\n+      && ts2->u.derived->components->ts.u.derived->attr.unlimited_polymorphic\n+      && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))\n+    return 1;\n+\n   if (ts1->type != ts2->type\n       && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n \t  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))\n@@ -523,7 +533,7 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n     return 0;\t\t\t/* Ranks differ.  */\n \n   return gfc_compare_types (&s1->ts, &s2->ts)\n-\t || s1->ts.type == BT_ASSUMED || s2->ts.type == BT_ASSUMED; \n+\t || s1->ts.type == BT_ASSUMED || s2->ts.type == BT_ASSUMED;\n }\n \n \n@@ -1157,7 +1167,7 @@ check_dummy_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \t    }\n \t  }\n     }\n-    \n+\n   return SUCCESS;\n }\n \n@@ -1403,6 +1413,9 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t    return 0;\n \t  }\n \n+\tif (UNLIMITED_POLY (f1->sym))\n+\t  goto next;\n+\n \tif (strict_flag)\n \t  {\n \t    /* Check all characteristics.  */\n@@ -1418,7 +1431,7 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t\t\tf1->sym->name);\n \t    return 0;\n \t  }\n-\n+next:\n \tf1 = f1->next;\n \tf2 = f2->next;\n       }\n@@ -1712,7 +1725,7 @@ gfc_check_interfaces (gfc_namespace *ns)\n       for (ns2 = ns; ns2; ns2 = ns2->parent)\n \t{\n \t  gfc_intrinsic_op other_op;\n-\t  \n+\n \t  if (check_interface1 (ns->op[i], ns2->op[i], 0,\n \t\t\t\tinterface_name, true))\n \t    goto done;\n@@ -1814,7 +1827,7 @@ argument_rank_mismatch (const char *name, locus *where,\n \t\t \"(rank-%d and scalar)\", name, where, rank1);\n     }\n   else\n-    {    \n+    {\n       gfc_error (\"Rank mismatch in argument '%s' at %L \"\n \t\t \"(rank-%d and rank-%d)\", name, where, rank1, rank2);\n     }\n@@ -1900,7 +1913,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       && formal->ts.type != BT_ASSUMED\n       && !gfc_compare_types (&formal->ts, &actual->ts)\n       && !(formal->ts.type == BT_DERIVED && actual->ts.type == BT_CLASS\n-\t   && gfc_compare_derived_types (formal->ts.u.derived, \n+\t   && gfc_compare_derived_types (formal->ts.u.derived,\n \t\t\t\t\t CLASS_DATA (actual)->ts.u.derived)))\n     {\n       if (where)\n@@ -1933,6 +1946,23 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t}\n     }\n \n+  /* F08: 12.5.2.5 Allocatable and pointer dummy variables.  However, this\n+     is necessary also for F03, so retain error for both.\n+     NOTE: Other type/kind errors pre-empt this error.  Since they are F03\n+     compatible, no attempt has been made to channel to this one.  */\n+  if (UNLIMITED_POLY (formal) && !UNLIMITED_POLY (actual)\n+      && (CLASS_DATA (formal)->attr.allocatable\n+\t  ||CLASS_DATA (formal)->attr.class_pointer))\n+    {\n+      if (where)\n+\tgfc_error (\"Actual argument to '%s' at %L must be unlimited \"\n+\t\t   \"polymorphic since the formal argument is a \"\n+\t\t   \"pointer or allocatable unlimited polymorphic \"\n+\t\t   \"entity [F2008: 12.5.2.5]\", formal->name,\n+\t\t   &actual->where);\n+      return 0;\n+    }\n+\n   if (formal->attr.codimension && !gfc_is_coarray (actual))\n     {\n       if (where)\n@@ -2078,7 +2108,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \tis_pointer = ref->u.c.component->attr.pointer;\n       else if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT\n \t       && ref->u.ar.dimen > 0\n-\t       && (!ref->next \n+\t       && (!ref->next\n \t\t   || (ref->next->type == REF_SUBSTRING && !ref->next->next)))\n         break;\n     }\n@@ -2156,7 +2186,7 @@ get_sym_storage_size (gfc_symbol *sym)\n \treturn 0;\n     }\n   else\n-    strlen = 1; \n+    strlen = 1;\n \n   if (symbol_rank (sym) == 0)\n     return strlen;\n@@ -2194,7 +2224,7 @@ get_expr_storage_size (gfc_expr *e)\n \n   if (e == NULL)\n     return 0;\n-  \n+\n   if (e->ts.type == BT_CHARACTER)\n     {\n       if (e->ts.u.cl && e->ts.u.cl->length\n@@ -2455,6 +2485,13 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return 0;\n \t}\n \n+      /* Make sure that intrinsic vtables exist for calls to unlimited\n+\t polymorphic formal arguments.  */\n+      if (UNLIMITED_POLY(f->sym)\n+\t  && a->expr->ts.type != BT_DERIVED\n+\t  && a->expr->ts.type != BT_CLASS)\n+\tgfc_find_intrinsic_vtab (&a->expr->ts);\n+\n       if (a->expr->expr_type == EXPR_NULL\n \t  && ((f->sym->ts.type != BT_CLASS && !f->sym->attr.pointer\n \t       && (f->sym->attr.allocatable || !f->sym->attr.optional\n@@ -2478,7 +2515,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n \t  return 0;\n \t}\n-      \n+\n       if (!compare_parameter (f->sym, a->expr, ranks_must_agree,\n \t\t\t      is_elemental, where))\n \treturn 0;\n@@ -2628,7 +2665,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"pointer dummy '%s'\", &a->expr->where,f->sym->name);\n \t  return 0;\n \t}\n-\t\n+\n \n       /* Fortran 2008, C1242.  */\n       if (f->sym->attr.pointer && gfc_is_coindexed (a->expr))\n@@ -3283,7 +3320,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,\n \thas_null_arg = true;\n \tnull_expr_loc = a->expr->where;\n \tbreak;\n-      } \n+      }\n \n   for (; intr; intr = intr->next)\n     {\n@@ -3310,7 +3347,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,\n \t    }\n \n \t  /* Satisfy 12.4.4.1 such that an elemental match has lower\n-\t     weight than a non-elemental match.  */ \n+\t     weight than a non-elemental match.  */\n \t  if (intr->sym->attr.elemental)\n \t    {\n \t      elem_sym = intr->sym;\n@@ -3613,7 +3650,7 @@ gfc_extend_expr (gfc_expr *e)\n \t      tbo = matching_typebound_op (&tb_base, actual, i, NULL, &gname);\n \t      break;\n \t  }\n-\t      \n+\n       /* If there is a matching typebound-operator, replace the expression with\n \t a call to it and succeed.  */\n       if (tbo)\n@@ -3703,7 +3740,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n       /* See if we find a matching type-bound assignment.  */\n       tbo = matching_typebound_op (&tb_base, actual,\n \t\t\t\t   INTRINSIC_ASSIGN, NULL, &gname);\n-\t      \n+\n       /* If there is one, replace the expression with a call to it and\n \t succeed.  */\n       if (tbo)\n@@ -4028,7 +4065,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t\t     \" FUNCTION\", proc->name, &where);\n \t  return FAILURE;\n \t}\n-\t\n+\n       if (check_result_characteristics (proc_target, old_target,\n \t\t\t\t\terr, sizeof(err)) == FAILURE)\n \t{"}, {"sha": "6322fae6fda92896bed097cd6fb7d3dc3ec4343f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 132, "deletions": 54, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -588,7 +588,7 @@ gfc_match_name_C (const char **buffer)\n   size_t i = 0;\n   gfc_char_t c;\n   char* buf;\n-  size_t cursz = 16; \n+  size_t cursz = 16;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n@@ -605,7 +605,7 @@ gfc_match_name_C (const char **buffer)\n       gfc_current_locus = old_loc;\n       return MATCH_YES;\n     }\n-  \n+\n   if (!ISALPHA (c) && c != '_')\n     {\n       gfc_error (\"Invalid C name in NAME= specifier at %C\");\n@@ -625,9 +625,9 @@ gfc_match_name_C (const char **buffer)\n \t  cursz *= 2;\n \t  buf = XRESIZEVEC (char, buf, cursz);\n \t}\n-      \n+\n       old_loc = gfc_current_locus;\n-      \n+\n       /* Get next char; param means we're in a string.  */\n       c = gfc_next_char_literal (INSTRING_WARN);\n     } while (ISALNUM (c) || c == '_');\n@@ -650,7 +650,7 @@ gfc_match_name_C (const char **buffer)\n           return MATCH_ERROR;\n         }\n     }\n-  \n+\n   /* If we stopped because we had an invalid character for a C name, report\n      that to the user by returning MATCH_NO.  */\n   if (c != '\"' && c != '\\'')\n@@ -708,8 +708,8 @@ gfc_match_symbol (gfc_symbol **matched_symbol, int host_assoc)\n }\n \n \n-/* Match an intrinsic operator.  Returns an INTRINSIC enum. While matching, \n-   we always find INTRINSIC_PLUS before INTRINSIC_UPLUS. We work around this \n+/* Match an intrinsic operator.  Returns an INTRINSIC enum. While matching,\n+   we always find INTRINSIC_PLUS before INTRINSIC_UPLUS. We work around this\n    in matchexp.c.  */\n \n match\n@@ -1441,7 +1441,7 @@ gfc_match_if (gfc_statement *if_type)\n \n   old_loc2 = gfc_current_locus;\n   gfc_current_locus = old_loc;\n-  \n+\n   if (gfc_match_parens () == MATCH_ERROR)\n     return MATCH_ERROR;\n \n@@ -1473,7 +1473,7 @@ gfc_match_if (gfc_statement *if_type)\n \t  gfc_free_expr (expr);\n \t  return MATCH_ERROR;\n \t}\n-      \n+\n       if (gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF \"\n \t\t\t  \"statement at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n@@ -1579,7 +1579,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"write\", gfc_match_write, ST_WRITE)\n \n   /* The gfc_match_assignment() above may have returned a MATCH_NO\n-     where the assignment was to a named constant.  Check that \n+     where the assignment was to a named constant.  Check that\n      special case here.  */\n   m = gfc_match_assignment ();\n   if (m == MATCH_NO)\n@@ -1907,7 +1907,7 @@ static match\n match_derived_type_spec (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  locus old_locus; \n+  locus old_locus;\n   gfc_symbol *derived;\n \n   old_locus = gfc_current_locus;\n@@ -1930,7 +1930,7 @@ match_derived_type_spec (gfc_typespec *ts)\n       return MATCH_YES;\n     }\n \n-  gfc_current_locus = old_locus; \n+  gfc_current_locus = old_locus;\n   return MATCH_NO;\n }\n \n@@ -2194,7 +2194,7 @@ match_forall_header (gfc_forall_iterator **phead, gfc_expr **mask)\n   return MATCH_ERROR;\n }\n \n-/* Match the rest of a simple FORALL statement that follows an \n+/* Match the rest of a simple FORALL statement that follows an\n    IF statement.  */\n \n static match\n@@ -2373,7 +2373,7 @@ gfc_match_do (void)\n     return MATCH_NO;\n \n   /* Check for balanced parens.  */\n-  \n+\n   if (gfc_match_parens () == MATCH_ERROR)\n     return MATCH_ERROR;\n \n@@ -2585,7 +2585,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t\t\t  \" do-construct-name at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n       break;\n-      \n+\n     default:\n       gfc_error (\"%s statement at %C is not applicable to construct '%s'\",\n \t\t gfc_ascii_statement (st), sym->name);\n@@ -3265,7 +3265,7 @@ gfc_match_goto (void)\n       return MATCH_YES;\n     }\n \n-  /* The assigned GO TO statement.  */ \n+  /* The assigned GO TO statement.  */\n \n   if (gfc_match_variable (&expr, 0) == MATCH_YES)\n     {\n@@ -3432,6 +3432,7 @@ gfc_match_allocate (void)\n   match m;\n   locus old_locus, deferred_locus;\n   bool saw_stat, saw_errmsg, saw_source, saw_mold, saw_deferred, b1, b2, b3;\n+  bool saw_unlimited = false;\n \n   head = tail = NULL;\n   stat = errmsg = source = mold = tmp = NULL;\n@@ -3573,7 +3574,7 @@ gfc_match_allocate (void)\n \t    }\n \n \t  /* Enforce F03:C627.  */\n-\t  if (ts.kind != tail->expr->ts.kind)\n+\t  if (ts.kind != tail->expr->ts.kind && !UNLIMITED_POLY (tail->expr))\n \t    {\n \t      gfc_error (\"Kind type parameter for entity at %L differs from \"\n \t\t\t \"the kind type parameter of the typespec\",\n@@ -3585,6 +3586,8 @@ gfc_match_allocate (void)\n       if (tail->expr->ts.type == BT_DERIVED)\n \ttail->expr->ts.u.derived = gfc_use_derived (tail->expr->ts.u.derived);\n \n+      saw_unlimited = saw_unlimited | UNLIMITED_POLY (tail->expr);\n+\n       if (gfc_peek_ascii_char () == '(' && !sym->attr.dimension)\n \t{\n \t  gfc_error (\"Shape specification for allocatable scalar at %C\");\n@@ -3696,7 +3699,7 @@ gfc_match_allocate (void)\n \t      gfc_error (\"Redundant MOLD tag found at %L \", &tmp->where);\n \t      goto cleanup;\n \t    }\n-  \n+\n \t  /* Check F08:C637.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n@@ -3739,7 +3742,20 @@ gfc_match_allocate (void)\n \t\t &deferred_locus);\n       goto cleanup;\n     }\n-  \n+\n+  /* Check F03:C625,  */\n+  if (saw_unlimited && ts.type == BT_UNKNOWN && !source && !mold)\n+    {\n+      for (tail = head; tail; tail = tail->next)\n+\t{\n+\t  if (UNLIMITED_POLY (tail->expr))\n+\t    gfc_error (\"Unlimited polymorphic allocate-object at %L \"\n+\t\t       \"requires either a type-spec or SOURCE tag \"\n+\t\t       \"or a MOLD tag\", &tail->expr->where);\n+\t}\n+      goto cleanup;\n+    }\n+\n   new_st.op = EXEC_ALLOCATE;\n   new_st.expr1 = stat;\n   new_st.expr2 = errmsg;\n@@ -4067,7 +4083,7 @@ gfc_match_return (void)\n }\n \n \n-/* Match the call of a type-bound procedure, if CALL%var has already been \n+/* Match the call of a type-bound procedure, if CALL%var has already been\n    matched and var found to be a derived-type variable.  */\n \n static match\n@@ -4081,7 +4097,7 @@ match_typebound_call (gfc_symtree* varst)\n   base->symtree = varst;\n   base->where = gfc_current_locus;\n   gfc_set_sym_referenced (varst->n.sym);\n-  \n+\n   m = gfc_match_varspec (base, 0, true, true);\n   if (m == MATCH_NO)\n     gfc_error (\"Expected component reference at %C\");\n@@ -4258,7 +4274,7 @@ gfc_match_call (void)\n \n /* Given a name, return a pointer to the common head structure,\n    creating it if it does not exist. If FROM_MODULE is nonzero, we\n-   mangle the name so that it doesn't interfere with commons defined \n+   mangle the name so that it doesn't interfere with commons defined\n    in the using namespace.\n    TODO: Add to global symbol tree.  */\n \n@@ -4403,7 +4419,7 @@ gfc_match_common (void)\n           /* Store a ref to the common block for error checking.  */\n           sym->common_block = t;\n           sym->common_block->refs++;\n-          \n+\n           /* See if we know the current common block is bind(c), and if\n              so, then see if we can check if the symbol is (which it'll\n              need to be).  This can happen if the bind(c) attr stmt was\n@@ -4423,13 +4439,13 @@ gfc_match_common (void)\n                                  sym->name, &(sym->declared_at), t->name,\n                                  t->name);\n                 }\n-              \n+\n               if (sym->attr.is_bind_c == 1)\n                 gfc_error_now (\"Variable '%s' in common block \"\n                                \"'%s' at %C can not be bind(c) since \"\n                                \"it is not global\", sym->name, t->name);\n             }\n-          \n+\n \t  if (sym->attr.in_common)\n \t    {\n \t      gfc_error (\"Symbol '%s' at %C is already in a COMMON block\",\n@@ -4872,7 +4888,7 @@ gfc_match_equivalence (void)\n \n /* Check that a statement function is not recursive. This is done by looking\n    for the statement function symbol(sym) by looking recursively through its\n-   expression(e).  If a reference to sym is found, true is returned.  \n+   expression(e).  If a reference to sym is found, true is returned.\n    12.5.4 requires that any variable of function that is implicitly typed\n    shall have that type confirmed by any subsequent type declaration.  The\n    implicit typing is conveniently done here.  */\n@@ -5207,47 +5223,100 @@ select_type_push (gfc_symbol *sel)\n }\n \n \n+/* Set the temporary for the current intrinsic SELECT TYPE selector.  */\n+\n+static gfc_symtree *\n+select_intrinsic_set_tmp (gfc_typespec *ts)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN];\n+  gfc_symtree *tmp;\n+  int charlen = 0;\n+\n+  if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n+    return NULL;\n+\n+  if (select_type_stack->selector->ts.type == BT_CLASS\n+      && !select_type_stack->selector->attr.class_ok)\n+    return NULL;\n+\n+  if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n+      && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n+\n+  if (ts->type != BT_CHARACTER)\n+    sprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (ts->type),\n+\t     ts->kind);\n+  else\n+    sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (ts->type),\n+\t     charlen, ts->kind);\n+\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n+  gfc_add_type (tmp->n.sym, ts, NULL);\n+\n+  /* Copy across the array spec to the selector.  */\n+  if (select_type_stack->selector->ts.type == BT_CLASS\n+      && (CLASS_DATA (select_type_stack->selector)->attr.dimension\n+\t  || CLASS_DATA (select_type_stack->selector)->attr.codimension))\n+    {\n+      tmp->n.sym->attr.pointer = 1;\n+      tmp->n.sym->attr.dimension\n+\t\t= CLASS_DATA (select_type_stack->selector)->attr.dimension;\n+      tmp->n.sym->attr.codimension\n+\t\t= CLASS_DATA (select_type_stack->selector)->attr.codimension;\n+      tmp->n.sym->as\n+\t= gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n+    }\n+\n+  gfc_set_sym_referenced (tmp->n.sym);\n+  gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n+  tmp->n.sym->attr.select_type_temporary = 1;\n+\n+  return tmp;\n+}\n+\n+\n /* Set up a temporary for the current TYPE IS / CLASS IS branch .  */\n \n static void\n select_type_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n-  gfc_symtree *tmp;\n+  gfc_symtree *tmp = NULL;\n \n   if (!ts)\n     {\n       select_type_stack->tmp = NULL;\n       return;\n     }\n-  \n-  if (!gfc_type_is_extensible (ts->u.derived))\n-    return;\n \n-  if (ts->type == BT_CLASS)\n-    sprintf (name, \"__tmp_class_%s\", ts->u.derived->name);\n-  else\n-    sprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n-  gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n-  gfc_add_type (tmp->n.sym, ts, NULL);\n+  tmp = select_intrinsic_set_tmp (ts);\n \n-  if (select_type_stack->selector->ts.type == BT_CLASS\n-      && select_type_stack->selector->attr.class_ok)\n+  if (tmp == NULL)\n     {\n-      tmp->n.sym->attr.pointer\n-\t\t= CLASS_DATA (select_type_stack->selector)->attr.class_pointer;\n+      if (ts->type == BT_CLASS)\n+\tsprintf (name, \"__tmp_class_%s\", ts->u.derived->name);\n+      else\n+\tsprintf (name, \"__tmp_type_%s\", ts->u.derived->name);\n+      gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n+      gfc_add_type (tmp->n.sym, ts, NULL);\n \n-      /* Copy across the array spec to the selector.  */\n-      if ((CLASS_DATA (select_type_stack->selector)->attr.dimension\n-\t  || CLASS_DATA (select_type_stack->selector)->attr.codimension))\n+      if (select_type_stack->selector->ts.type == BT_CLASS\n+\t&& select_type_stack->selector->attr.class_ok)\n \t{\n-\t  tmp->n.sym->attr.dimension\n+\t  tmp->n.sym->attr.pointer\n+\t\t= CLASS_DATA (select_type_stack->selector)->attr.class_pointer;\n+\n+\t  /* Copy across the array spec to the selector.  */\n+\t  if (CLASS_DATA (select_type_stack->selector)->attr.dimension\n+\t      || CLASS_DATA (select_type_stack->selector)->attr.codimension)\n+\t    {\n+\t      tmp->n.sym->attr.dimension\n \t\t    = CLASS_DATA (select_type_stack->selector)->attr.dimension;\n-\t  tmp->n.sym->attr.codimension\n+\t      tmp->n.sym->attr.codimension\n \t\t    = CLASS_DATA (select_type_stack->selector)->attr.codimension;\n-\t  tmp->n.sym->as\n+\t      tmp->n.sym->as\n \t    = gfc_copy_array_spec (CLASS_DATA (select_type_stack->selector)->as);\n-\t}\n+\t    }\n     }\n \n   gfc_set_sym_referenced (tmp->n.sym);\n@@ -5257,6 +5326,7 @@ select_type_set_tmp (gfc_typespec *ts)\n   if (ts->type == BT_CLASS)\n     gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n \t\t\t    &tmp->n.sym->as, false);\n+    }\n \n   /* Add an association for it, so the rest of the parser knows it is\n      an associate-name.  The target will be set during resolution.  */\n@@ -5267,7 +5337,7 @@ select_type_set_tmp (gfc_typespec *ts)\n   select_type_stack->tmp = tmp;\n }\n \n-  \n+\n /* Match a SELECT TYPE statement.  */\n \n match\n@@ -5356,7 +5426,7 @@ gfc_match_select_type (void)\n   select_type_push (expr1->symtree->n.sym);\n \n   return MATCH_YES;\n-  \n+\n cleanup:\n   parent_ns = gfc_current_ns->parent;\n   gfc_free_namespace (gfc_current_ns);\n@@ -5457,9 +5527,7 @@ gfc_match_type_is (void)\n   c = gfc_get_case ();\n   c->where = gfc_current_locus;\n \n-  /* TODO: Once unlimited polymorphism is implemented, we will need to call\n-     match_type_spec here.  */\n-  if (match_derived_type_spec (&c->ts) == MATCH_ERROR)\n+  if (match_type_spec (&c->ts) == MATCH_ERROR)\n     goto cleanup;\n \n   if (gfc_match_char (')') != MATCH_YES)\n@@ -5474,6 +5542,16 @@ gfc_match_type_is (void)\n   new_st.op = EXEC_SELECT_TYPE;\n   new_st.ext.block.case_list = c;\n \n+  if (c->ts.type == BT_DERIVED && c->ts.u.derived\n+      && (c->ts.u.derived->attr.sequence\n+\t  || c->ts.u.derived->attr.is_bind_c))\n+    {\n+      gfc_error (\"The type-spec shall not specify a sequence derived \"\n+\t\t \"type or a type with the BIND attribute in SELECT \"\n+\t\t \"TYPE at %C [F2003:C815]\");\n+      return MATCH_ERROR;\n+    }\n+\n   /* Create temporary variable.  */\n   select_type_set_tmp (&c->ts);\n \n@@ -5546,7 +5624,7 @@ gfc_match_class_is (void)\n \n   new_st.op = EXEC_SELECT_TYPE;\n   new_st.ext.block.case_list = c;\n-  \n+\n   /* Create temporary variable.  */\n   select_type_set_tmp (&c->ts);\n \n@@ -5564,7 +5642,7 @@ gfc_match_class_is (void)\n \n /********************* WHERE subroutines ********************/\n \n-/* Match the rest of a simple WHERE statement that follows an IF statement.  \n+/* Match the rest of a simple WHERE statement that follows an IF statement.\n  */\n \n static match"}, {"sha": "8aa6df53569a2b0b568f23b8e42556d1a4d6862f", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,5 +1,6 @@\n /* Miscellaneous stuff that doesn't fit anywhere else.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -158,8 +159,11 @@ gfc_typename (gfc_typespec *ts)\n       sprintf (buffer, \"TYPE(%s)\", ts->u.derived->name);\n       break;\n     case BT_CLASS:\n-      sprintf (buffer, \"CLASS(%s)\",\n-\t       ts->u.derived->components->ts.u.derived->name);\n+      ts = &ts->u.derived->components->ts;\n+      if (ts->u.derived->attr.unlimited_polymorphic)\n+\tsprintf (buffer, \"CLASS(*)\");\n+      else\n+\tsprintf (buffer, \"CLASS(%s)\", ts->u.derived->name);\n       break;\n     case BT_ASSUMED:\n       sprintf (buffer, \"TYPE(*)\");"}, {"sha": "168f933936acddd0c54d29b8f31d1b37287652d2", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1844,7 +1844,7 @@ typedef enum\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n-  AB_IMPLICIT_PURE, AB_ARTIFICIAL\n+  AB_IMPLICIT_PURE, AB_ARTIFICIAL, AB_UNLIMITED_POLY\n }\n ab_attribute;\n \n@@ -1898,6 +1898,7 @@ static const mstring attr_bits[] =\n     minit (\"VTAB\", AB_VTAB),\n     minit (\"CLASS_POINTER\", AB_CLASS_POINTER),\n     minit (\"IMPLICIT_PURE\", AB_IMPLICIT_PURE),\n+    minit (\"UNLIMITED_POLY\", AB_UNLIMITED_POLY),\n     minit (NULL, -1)\n };\n \n@@ -2036,6 +2037,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_PURE, attr_bits);\n       if (attr->implicit_pure)\n \tMIO_NAME (ab_attribute) (AB_IMPLICIT_PURE, attr_bits);\n+      if (attr->unlimited_polymorphic)\n+\tMIO_NAME (ab_attribute) (AB_UNLIMITED_POLY, attr_bits);\n       if (attr->recursive)\n \tMIO_NAME (ab_attribute) (AB_RECURSIVE, attr_bits);\n       if (attr->always_explicit)\n@@ -2177,6 +2180,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_IMPLICIT_PURE:\n \t      attr->implicit_pure = 1;\n \t      break;\n+\t    case AB_UNLIMITED_POLY:\n+\t      attr->unlimited_polymorphic = 1;\n+\t      break;\n \t    case AB_RECURSIVE:\n \t      attr->recursive = 1;\n \t      break;"}, {"sha": "6208a819c1340c537486065e13412bd16efbd256", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 96, "deletions": 11, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -929,6 +929,10 @@ resolve_common_vars (gfc_symbol *sym, bool named_common)\n \t\t\t    &csym->declared_at);\n \t}\n \n+      if (UNLIMITED_POLY (csym))\n+\tgfc_error_now (\"'%s' in cannot appear in COMMON at %L \"\n+\t\t       \"[F2008:C5100]\", csym->name, &csym->declared_at);\n+\n       if (csym->ts.type != BT_DERIVED)\n \tcontinue;\n \n@@ -6898,6 +6902,7 @@ resolve_deallocate_expr (gfc_expr *e)\n   gfc_ref *ref;\n   gfc_symbol *sym;\n   gfc_component *c;\n+  bool unlimited;\n \n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n@@ -6906,6 +6911,7 @@ resolve_deallocate_expr (gfc_expr *e)\n     goto bad;\n \n   sym = e->symtree->n.sym;\n+  unlimited = UNLIMITED_POLY(sym);\n \n   if (sym->ts.type == BT_CLASS)\n     {\n@@ -6950,7 +6956,7 @@ resolve_deallocate_expr (gfc_expr *e)\n \n   attr = gfc_expr_attr (e);\n \n-  if (allocatable == 0 && attr.pointer == 0)\n+  if (allocatable == 0 && attr.pointer == 0 && !unlimited)\n     {\n     bad:\n       gfc_error (\"Allocate-object at %L must be ALLOCATABLE or a POINTER\",\n@@ -7118,6 +7124,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   int i, pointer, allocatable, dimension, is_abstract;\n   int codimension;\n   bool coindexed;\n+  bool unlimited;\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n   gfc_expr *e2;\n@@ -7149,6 +7156,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   /* Check whether ultimate component is abstract and CLASS.  */\n   is_abstract = 0;\n \n+  /* Is the allocate-object unlimited polymorphic?  */\n+  unlimited = UNLIMITED_POLY(e);\n+\n   if (e->expr_type != EXPR_VARIABLE)\n     {\n       allocatable = 0;\n@@ -7235,7 +7245,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     }\n \n   /* Check for F08:C628.  */\n-  if (allocatable == 0 && pointer == 0)\n+  if (allocatable == 0 && pointer == 0 && !unlimited)\n     {\n       gfc_error (\"Allocate-object at %L must be ALLOCATABLE or a POINTER\",\n \t\t &e->where);\n@@ -7254,12 +7264,12 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t}\n \n       /* Check F03:C632 and restriction following Note 6.18.  */\n-      if (code->expr3->rank > 0\n+      if (code->expr3->rank > 0 && !unlimited\n \t  && conformable_arrays (code->expr3, e) == FAILURE)\n \tgoto failure;\n \n       /* Check F03:C633.  */\n-      if (code->expr3->ts.kind != e->ts.kind)\n+      if (code->expr3->ts.kind != e->ts.kind && !unlimited)\n \t{\n \t  gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n \t\t      \"shall have the same kind type parameter\",\n@@ -7362,7 +7372,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       code->expr3 = rhs;\n     }\n \n-  if (e->ts.type == BT_CLASS)\n+  if (e->ts.type == BT_CLASS && !unlimited && !UNLIMITED_POLY (code->expr3))\n     {\n       /* Make sure the vtab symbol is present when\n \t the module variables are generated.  */\n@@ -7371,7 +7381,29 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \tts = code->expr3->ts;\n       else if (code->ext.alloc.ts.type == BT_DERIVED)\n \tts = code->ext.alloc.ts;\n+\n       gfc_find_derived_vtab (ts.u.derived);\n+\n+      if (dimension)\n+\te = gfc_expr_to_initialize (e);\n+    }\n+  else if (unlimited && !UNLIMITED_POLY (code->expr3))\n+    {\n+      /* Again, make sure the vtab symbol is present when\n+\t the module variables are generated.  */\n+      gfc_typespec *ts = NULL;\n+      if (code->expr3)\n+\tts = &code->expr3->ts;\n+      else\n+\tts = &code->ext.alloc.ts;\n+\n+      gcc_assert (ts);\n+\n+      if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n+        gfc_find_derived_vtab (ts->u.derived);\n+      else\n+        gfc_find_intrinsic_vtab (ts);\n+\n       if (dimension)\n \te = gfc_expr_to_initialize (e);\n     }\n@@ -8206,7 +8238,9 @@ resolve_select (gfc_code *code)\n bool\n gfc_type_is_extensible (gfc_symbol *sym)\n {\n-  return !(sym->attr.is_bind_c || sym->attr.sequence);\n+  return !(sym->attr.is_bind_c || sym->attr.sequence\n+\t   || (sym->attr.is_class\n+\t       && sym->components->ts.u.derived->attr.unlimited_polymorphic));\n }\n \n \n@@ -8312,6 +8346,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_namespace *ns;\n   int error = 0;\n+  int charlen = 0;\n \n   ns = code->ext.block.ns;\n   gfc_resolve (ns);\n@@ -8344,6 +8379,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       /* Check F03:C815.  */\n       if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t  && !selector_type->attr.unlimited_polymorphic\n \t  && !gfc_type_is_extensible (c->ts.u.derived))\n \t{\n \t  gfc_error (\"Derived type '%s' at %L must be extensible\",\n@@ -8354,6 +8390,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       /* Check F03:C816.  */\n       if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t  && !selector_type->attr.unlimited_polymorphic\n \t  && !gfc_type_is_extension_of (selector_type, c->ts.u.derived))\n \t{\n \t  gfc_error (\"Derived type '%s' at %L must be an extension of '%s'\",\n@@ -8362,6 +8399,15 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  continue;\n \t}\n \n+      /* Check F03:C814.  */\n+      if (c->ts.type == BT_CHARACTER && c->ts.u.cl->length != NULL)\n+\t{\n+\t  gfc_error (\"The type-spec at %L shall specify that each length \"\n+\t\t     \"type parameter is assumed\", &c->where);\n+\t  error++;\n+\t  continue;\n+\t}\n+\n       /* Intercept the DEFAULT case.  */\n       if (c->ts.type == BT_UNKNOWN)\n \t{\n@@ -8420,6 +8466,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n     ns->code->next = new_st;\n   code = new_st;\n   code->op = EXEC_SELECT;\n+\n   gfc_add_vptr_component (code->expr1);\n   gfc_add_hash_component (code->expr1);\n \n@@ -8431,6 +8478,16 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n       if (c->ts.type == BT_DERIVED)\n \tc->low = c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n \t\t\t\t\t     c->ts.u.derived->hash_value);\n+      else if (c->ts.type != BT_CLASS && c->ts.type != BT_UNKNOWN)\n+\t{\n+\t  gfc_symbol *ivtab;\n+\t  gfc_expr *e;\n+\n+\t  ivtab = gfc_find_intrinsic_vtab (&c->ts);\n+\t  gcc_assert (ivtab);\n+\t  e = CLASS_DATA (ivtab)->initializer;\n+\t  c->low = c->high = gfc_copy_expr (e);\n+\t}\n \n       else if (c->ts.type == BT_UNKNOWN)\n \tcontinue;\n@@ -8442,13 +8499,25 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       if (c->ts.type == BT_CLASS)\n \tsprintf (name, \"__tmp_class_%s\", c->ts.u.derived->name);\n-      else\n+      else if (c->ts.type == BT_DERIVED)\n \tsprintf (name, \"__tmp_type_%s\", c->ts.u.derived->name);\n+      else if (c->ts.type == BT_CHARACTER)\n+\t{\n+\t  if (c->ts.u.cl && c->ts.u.cl->length\n+\t      && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n+\t    charlen = mpz_get_si (c->ts.u.cl->length->value.integer);\n+\t  sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (c->ts.type),\n+\t           charlen, c->ts.kind);\n+\t}\n+      else\n+\tsprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (c->ts.type),\n+\t         c->ts.kind);\n+\n       st = gfc_find_symtree (ns->sym_root, name);\n       gcc_assert (st->n.sym->assoc);\n       st->n.sym->assoc->target = gfc_get_variable_expr (code->expr1->symtree);\n       st->n.sym->assoc->target->where = code->expr1->where;\n-      if (c->ts.type == BT_DERIVED)\n+      if (c->ts.type != BT_CLASS && c->ts.type != BT_UNKNOWN)\n \tgfc_add_data_component (st->n.sym->assoc->target);\n \n       new_st = gfc_get_code ();\n@@ -11029,6 +11098,8 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n     {\n       /* F03:C502.  */\n       if (sym->attr.class_ok\n+\t  && !sym->attr.select_type_temporary\n+\t  && !UNLIMITED_POLY(sym)\n \t  && !gfc_type_is_extensible (CLASS_DATA (sym)->ts.u.derived))\n \t{\n \t  gfc_error (\"Type '%s' of CLASS variable '%s' at %L is not extensible\",\n@@ -11167,7 +11238,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t dummy arguments.  */\n       e = sym->ts.u.cl->length;\n       if (e == NULL && !sym->attr.dummy && !sym->attr.result\n-\t  && !sym->ts.deferred)\n+\t  && !sym->ts.deferred && !sym->attr.select_type_temporary)\n \t{\n \t  gfc_error (\"Entity with assumed character length at %L must be a \"\n \t\t     \"dummy argument or a PARAMETER\", &sym->declared_at);\n@@ -12412,6 +12483,9 @@ resolve_fl_derived0 (gfc_symbol *sym)\n   gfc_symbol* super_type;\n   gfc_component *c;\n \n+  if (sym->attr.unlimited_polymorphic)\n+    return SUCCESS;\n+\n   super_type = gfc_get_derived_super_type (sym);\n \n   /* F2008, C432. */\n@@ -12764,7 +12838,8 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       if (c->ts.type == BT_CLASS && c->attr.class_ok\n \t  && CLASS_DATA (c)->attr.class_pointer\n \t  && CLASS_DATA (c)->ts.u.derived->components == NULL\n-\t  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp)\n+\t  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp\n+\t  && !UNLIMITED_POLY (c))\n \t{\n \t  gfc_error (\"The pointer component '%s' of '%s' at %L is a type \"\n \t\t     \"that has not been declared\", c->name, sym->name,\n@@ -12833,6 +12908,9 @@ resolve_fl_derived (gfc_symbol *sym)\n {\n   gfc_symbol *gen_dt = NULL;\n \n+  if (sym->attr.unlimited_polymorphic)\n+    return SUCCESS;\n+\n   if (!sym->attr.is_class)\n     gfc_find_symbol (sym->name, sym->ns, 0, &gen_dt);\n   if (gen_dt && gen_dt->generic && gen_dt->generic->next\n@@ -12859,7 +12937,11 @@ resolve_fl_derived (gfc_symbol *sym)\n       /* Fix up incomplete CLASS symbols.  */\n       gfc_component *data = gfc_find_component (sym, \"_data\", true, true);\n       gfc_component *vptr = gfc_find_component (sym, \"_vptr\", true, true);\n-      if (vptr->ts.u.derived == NULL)\n+\n+      /* Nothing more to do for unlimited polymorphic entities.  */\n+      if (data->ts.u.derived->attr.unlimited_polymorphic)\n+\treturn SUCCESS;\n+      else if (vptr->ts.u.derived == NULL)\n \t{\n \t  gfc_symbol *vtab = gfc_find_derived_vtab (data->ts.u.derived);\n \t  gcc_assert (vtab);\n@@ -13074,6 +13156,9 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->attr.artificial)\n     return;\n \n+  if (sym->attr.unlimited_polymorphic)\n+    return;\n+\n   if (sym->attr.flavor == FL_UNKNOWN\n       || (sym->attr.flavor == FL_PROCEDURE && !sym->attr.intrinsic\n \t  && !sym->attr.generic && !sym->attr.external"}, {"sha": "eb3e8c3cfbb1c461df5a0fda14c8208942af6766", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,6 +1,6 @@\n /* Simplify intrinsic functions at compile-time.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010, 2011 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n This file is part of GCC.\n@@ -82,7 +82,7 @@ range_check (gfc_expr *result, const char *name)\n     {\n       case ARITH_OK:\n \treturn result;\n- \n+\n       case ARITH_OVERFLOW:\n \tgfc_error (\"Result of %s overflows its kind at %L\", name,\n \t\t   &result->where);\n@@ -380,7 +380,7 @@ compute_dot_product (gfc_expr *matrix_a, int stride_a, int offset_a,\n }\n \n \n-/* Build a result expression for transformational intrinsics, \n+/* Build a result expression for transformational intrinsics,\n    depending on DIM. */\n \n static gfc_expr *\n@@ -491,7 +491,7 @@ simplify_transformation_to_scalar (gfc_expr *result, gfc_expr *array, gfc_expr *\n      REAL, PARAMETER :: array(n, m) = ...\n      REAL, PARAMETER :: s(n) = PROD(array, DIM=1)\n \n-  where OP == gfc_multiply(). The result might be post processed using post_op. */ \n+  where OP == gfc_multiply(). The result might be post processed using post_op. */\n \n static gfc_expr *\n simplify_transformation_to_array (gfc_expr *result, gfc_expr *array, gfc_expr *dim,\n@@ -1314,7 +1314,7 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n       mpfr_clear (last1);\n       return result;\n     }\n- \n+\n   /* Get second recursion anchor.  */\n \n   mpfr_init (last2);\n@@ -1335,7 +1335,7 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n     }\n   if (jn)\n     gfc_constructor_insert_expr (&result->value.constructor, e, &x->where, -2);\n-  else \n+  else\n     gfc_constructor_append_expr (&result->value.constructor, e, &x->where);\n \n   if (n1 + 1 == n2)\n@@ -1349,7 +1349,7 @@ gfc_simplify_bessel_n2 (gfc_expr *order1, gfc_expr *order2, gfc_expr *x,\n \n   mpfr_init (x2rev);\n   mpfr_ui_div (x2rev, 2, x->value.real, GFC_RND_MODE);\n- \n+\n   for (i = 2; i <= n2-n1; i++)\n     {\n       e = gfc_get_constant_expr (x->ts.type, x->ts.kind, &x->where);\n@@ -1743,7 +1743,7 @@ gfc_simplify_cosh (gfc_expr *x)\n       case BT_COMPLEX:\n \tmpc_cosh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-\t\n+\n       default:\n \tgcc_unreachable ();\n     }\n@@ -2251,6 +2251,10 @@ gfc_simplify_extends_type_of (gfc_expr *a, gfc_expr *mold)\n     return gfc_get_logical_expr (gfc_default_logical_kind, &a->where,\n \t\t\t\t gfc_type_is_extension_of (mold->ts.u.derived,\n \t\t\t\t\t\t\t   a->ts.u.derived));\n+\n+  if (UNLIMITED_POLY (a) || UNLIMITED_POLY (mold))\n+    return NULL;\n+\n   /* Return .false. if the dynamic type can never be the same.  */\n   if ((a->ts.type == BT_CLASS && mold->ts.type == BT_CLASS\n        && !gfc_type_is_extension_of\n@@ -2676,7 +2680,7 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)\n   int back, len, lensub;\n   int i, j, k, count, index = 0, start;\n \n-  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT \n+  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT\n       || ( b != NULL && b->expr_type !=  EXPR_CONSTANT))\n     return NULL;\n \n@@ -2685,7 +2689,7 @@ gfc_simplify_index (gfc_expr *x, gfc_expr *y, gfc_expr *b, gfc_expr *kind)\n   else\n     back = 0;\n \n-  k = get_kind (BT_INTEGER, kind, \"INDEX\", gfc_default_integer_kind); \n+  k = get_kind (BT_INTEGER, kind, \"INDEX\", gfc_default_integer_kind);\n   if (k == -1)\n     return &gfc_bad_expr;\n \n@@ -3229,7 +3233,7 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n   int k;\n \n   k = get_kind (BT_INTEGER, kind, upper ? \"UBOUND\" : \"LBOUND\",\n-\t\tgfc_default_integer_kind); \n+\t\tgfc_default_integer_kind);\n   if (k == -1)\n     return &gfc_bad_expr;\n \n@@ -3558,7 +3562,7 @@ simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       e->expr_type = EXPR_ARRAY;\n       e->ts.type = BT_INTEGER;\n       k = get_kind (BT_INTEGER, kind, upper ? \"UCOBOUND\" : \"LCOBOUND\",\n-\t\t    gfc_default_integer_kind); \n+\t\t    gfc_default_integer_kind);\n       if (k == -1)\n \t{\n \t  gfc_free_expr (e);\n@@ -3912,7 +3916,7 @@ gfc_simplify_maskr (gfc_expr *i, gfc_expr *kind_arg)\n \n   if (i->expr_type != EXPR_CONSTANT)\n     return NULL;\n- \n+\n   kind = get_kind (BT_INTEGER, kind_arg, \"MASKR\", gfc_default_integer_kind);\n   if (kind == -1)\n     return &gfc_bad_expr;\n@@ -3944,7 +3948,7 @@ gfc_simplify_maskl (gfc_expr *i, gfc_expr *kind_arg)\n \n   if (i->expr_type != EXPR_CONSTANT)\n     return NULL;\n- \n+\n   kind = get_kind (BT_INTEGER, kind_arg, \"MASKL\", gfc_default_integer_kind);\n   if (kind == -1)\n     return &gfc_bad_expr;\n@@ -4066,7 +4070,7 @@ min_max_choose (gfc_expr *arg, gfc_expr *extremum, int sign)\n #undef LENGTH\n #undef STRING\n \tbreak;\n-\t      \n+\n       default:\n \tgfc_internal_error (\"simplify_min_max(): Bad type in arglist\");\n     }\n@@ -4119,14 +4123,14 @@ simplify_min_max (gfc_expr *expr, int sign)\n     return NULL;\n \n   /* Convert to the correct type and kind.  */\n-  if (expr->ts.type != BT_UNKNOWN) \n+  if (expr->ts.type != BT_UNKNOWN)\n     return gfc_convert_constant (expr->value.function.actual->expr,\n \texpr->ts.type, expr->ts.kind);\n \n-  if (specific->ts.type != BT_UNKNOWN) \n+  if (specific->ts.type != BT_UNKNOWN)\n     return gfc_convert_constant (expr->value.function.actual->expr,\n-\tspecific->ts.type, specific->ts.kind); \n- \n+\tspecific->ts.type, specific->ts.kind);\n+\n   return gfc_copy_expr (expr->value.function.actual->expr);\n }\n \n@@ -4176,14 +4180,14 @@ simplify_minval_maxval (gfc_expr *expr, int sign)\n     return NULL;\n \n   /* Convert to the correct type and kind.  */\n-  if (expr->ts.type != BT_UNKNOWN) \n+  if (expr->ts.type != BT_UNKNOWN)\n     return gfc_convert_constant (extremum->expr,\n \texpr->ts.type, expr->ts.kind);\n \n-  if (specific->ts.type != BT_UNKNOWN) \n+  if (specific->ts.type != BT_UNKNOWN)\n     return gfc_convert_constant (extremum->expr,\n-\tspecific->ts.type, specific->ts.kind); \n- \n+\tspecific->ts.type, specific->ts.kind);\n+\n   return gfc_copy_expr (extremum->expr);\n }\n \n@@ -4261,7 +4265,7 @@ gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n \t  }\n \n \tgfc_set_model_kind (kind);\n-\tmpfr_fmod (result->value.real, a->value.real, p->value.real, \n+\tmpfr_fmod (result->value.real, a->value.real, p->value.real,\n \t\t   GFC_RND_MODE);\n \tbreak;\n \n@@ -4310,7 +4314,7 @@ gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n \t  }\n \n \tgfc_set_model_kind (kind);\n-\tmpfr_fmod (result->value.real, a->value.real, p->value.real, \n+\tmpfr_fmod (result->value.real, a->value.real, p->value.real,\n \t\t   GFC_RND_MODE);\n \tif (mpfr_cmp_ui (result->value.real, 0) != 0)\n \t  {\n@@ -4319,7 +4323,7 @@ gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n \t\t\tGFC_RND_MODE);\n \t  }\n \telse\n-\t  mpfr_copysign (result->value.real, result->value.real, \n+\t  mpfr_copysign (result->value.real, result->value.real,\n \t\t\t p->value.real, GFC_RND_MODE);\n \tbreak;\n \n@@ -4621,7 +4625,7 @@ gfc_simplify_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n     }\n   else if (mask->expr_type == EXPR_ARRAY)\n     {\n-      /* Copy only those elements of ARRAY to RESULT whose \n+      /* Copy only those elements of ARRAY to RESULT whose\n \t MASK equals .TRUE..  */\n       mask_ctor = gfc_constructor_first (mask->value.constructor);\n       while (mask_ctor)\n@@ -4921,8 +4925,8 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (len || \n-      (e->ts.u.cl->length && \n+  if (len ||\n+      (e->ts.u.cl->length &&\n        mpz_sgn (e->ts.u.cl->length->value.integer)) != 0)\n     {\n       const char *res = gfc_extract_int (n, &ncop);\n@@ -5740,7 +5744,7 @@ gfc_simplify_spacing (gfc_expr *x)\n     }\n \n   /* In the Fortran 95 standard, the result is b**(e - p) where b, e, and p\n-     are the radix, exponent of x, and precision.  This excludes the \n+     are the radix, exponent of x, and precision.  This excludes the\n      possibility of subnormal numbers.  Fortran 2003 states the result is\n      b**max(e - p, emin - 1).  */\n \n@@ -6025,11 +6029,11 @@ gfc_simplify_transfer (gfc_expr *source, gfc_expr *mold, gfc_expr *size)\n \t\t : mold;\n \n   /* Set result character length, if needed.  Note that this needs to be\n-     set even for array expressions, in order to pass this information into \n+     set even for array expressions, in order to pass this information into\n      gfc_target_interpret_expr.  */\n   if (result->ts.type == BT_CHARACTER && gfc_is_constant_expr (mold_element))\n     result->value.character.length = mold_element->value.character.length;\n-  \n+\n   /* Set the number of elements in the result, and determine its size.  */\n \n   if (mold->expr_type == EXPR_ARRAY || mold->rank || size)\n@@ -6087,7 +6091,7 @@ gfc_simplify_transpose (gfc_expr *matrix)\n       {\n \tgfc_expr *e = gfc_constructor_lookup_expr (matrix->value.constructor,\n \t\t\t\t\t\t   col * matrix_rows + row);\n-\tgfc_constructor_insert_expr (&result->value.constructor, \n+\tgfc_constructor_insert_expr (&result->value.constructor,\n \t\t\t\t     gfc_copy_expr (e), &matrix->where,\n \t\t\t\t     row * matrix_cols + col);\n       }"}, {"sha": "dbd51329350397a4480de32ac36f2a32a66d695a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1955,6 +1955,9 @@ gfc_use_derived (gfc_symbol *sym)\n   if (!sym)\n     return NULL;\n \n+  if (sym->attr.unlimited_polymorphic)\n+    return sym;\n+\n   if (sym->attr.generic)\n     sym = gfc_find_dt_in_generic (sym);\n \n@@ -4905,6 +4908,11 @@ gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n   bool is_derived1 = (ts1->type == BT_DERIVED);\n   bool is_derived2 = (ts2->type == BT_DERIVED);\n \n+  if (is_class1\n+      && ts1->u.derived->components\n+      && ts1->u.derived->components->ts.u.derived->attr.unlimited_polymorphic)\n+    return 1;\n+\n   if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)\n     return (ts1->type == ts2->type);\n "}, {"sha": "88f9c562996bbcc083fd8562a8f2f0dd09911518", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -327,7 +327,7 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n      binding label (mainly those that are bind(c)).  */\n   if (sym->attr.is_bind_c == 1 && sym->binding_label)\n     return get_identifier (sym->binding_label);\n-  \n+\n   if (sym->module == NULL)\n     return gfc_sym_identifier (sym);\n   else\n@@ -433,14 +433,14 @@ gfc_finish_cray_pointee (tree decl, gfc_symbol *sym)\n   tree value;\n \n   /* Parameters need to be dereferenced.  */\n-  if (sym->cp_pointer->attr.dummy) \n+  if (sym->cp_pointer->attr.dummy)\n     ptr_decl = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\tptr_decl);\n \n   /* Check to see if we're dealing with a variable-sized array.  */\n   if (sym->attr.dimension\n-      && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE) \n-    {  \n+      && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)\n+    {\n       /* These decls will be dereferenced later, so we don't dereference\n \t them here.  */\n       value = convert (TREE_TYPE (decl), ptr_decl);\n@@ -483,7 +483,7 @@ gfc_finish_decl (tree decl)\n \n   /* We should know the storage size.  */\n   gcc_assert (DECL_SIZE (decl) != NULL_TREE\n-\t      || (TREE_STATIC (decl) \n+\t      || (TREE_STATIC (decl)\n \t\t  ? (!DECL_INITIAL (decl) || !DECL_CONTEXT (decl))\n \t\t  : DECL_EXTERNAL (decl)));\n \n@@ -550,7 +550,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       TREE_PUBLIC(decl) = 1;\n       DECL_COMMON(decl) = 1;\n     }\n-  \n+\n   /* If a variable is USE associated, it's always external.  */\n   if (sym->attr.use_assoc)\n     {\n@@ -592,7 +592,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       TREE_SIDE_EFFECTS (decl) = 1;\n       new_type = build_qualified_type (TREE_TYPE (decl), TYPE_QUAL_VOLATILE);\n       TREE_TYPE (decl) = new_type;\n-    } \n+    }\n \n   /* Keep variables larger than max-stack-var-size off stack.  */\n   if (!sym->ns->proc_name->attr.recursive\n@@ -948,7 +948,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   /* Do we know the element size?  */\n   known_size = sym->ts.type != BT_CHARACTER\n \t  || INTEGER_CST_P (sym->ts.u.cl->backend_decl);\n-  \n+\n   if (known_size && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type)))\n     {\n       /* For descriptorless arrays with known element size the actual\n@@ -1558,7 +1558,7 @@ get_proc_pointer_decl (gfc_symbol *sym)\n       if (sym->attr.use_assoc)\n \tDECL_IGNORED_P (decl) = 1;\n     }\n-  \n+\n   if ((sym->ns->proc_name\n       && sym->ns->proc_name->backend_decl == current_function_decl)\n       || sym->attr.contained)\n@@ -1984,7 +1984,7 @@ create_function_arglist (gfc_symbol * sym)\n       type = TREE_VALUE (typelist);\n       parm = build_decl (input_location,\n \t\t\t PARM_DECL, get_identifier (\"__entry\"), type);\n-      \n+\n       DECL_CONTEXT (parm) = fndecl;\n       DECL_ARG_TYPE (parm) = type;\n       TREE_READONLY (parm) = 1;\n@@ -2106,7 +2106,7 @@ create_function_arglist (gfc_symbol * sym)\n \t  gfc_finish_decl (length);\n \n \t  /* Remember the passed value.  */\n-          if (f->sym->ts.u.cl->passed_length != NULL)\n+          if (!f->sym->ts.u.cl ||  f->sym->ts.u.cl->passed_length)\n             {\n \t      /* This can happen if the same type is used for multiple\n \t\t arguments. We need to copy cl as otherwise\n@@ -2215,7 +2215,7 @@ create_function_arglist (gfc_symbol * sym)\n \t      gcc_assert (GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) == NULL_TREE);\n \t      GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) = token;\n \t    }\n-\t    \n+\n \t  DECL_CONTEXT (token) = fndecl;\n \t  DECL_ARTIFICIAL (token) = 1;\n \t  DECL_ARG_TYPE (token) = TREE_VALUE (typelist);\n@@ -2314,7 +2314,7 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n       vec<tree, va_gc> *string_args = NULL;\n \n       thunk_sym = el->sym;\n-      \n+\n       build_function_decl (thunk_sym, global);\n       create_function_arglist (thunk_sym);\n \n@@ -2411,7 +2411,7 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t TREE_TYPE (field), union_decl, field,\n \t\t\t\t NULL_TREE);\n-\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, \n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t     TREE_TYPE (DECL_RESULT (current_function_decl)),\n \t\t\t     DECL_RESULT (current_function_decl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n@@ -2985,7 +2985,7 @@ gfc_build_intrinsic_function_decls (void)\n \tgfc_int4_type_node);\n   TREE_READONLY (gfor_fndecl_math_ishftc4) = 1;\n   TREE_NOTHROW (gfor_fndecl_math_ishftc4) = 1;\n-\t\n+\n   gfor_fndecl_math_ishftc8 = gfc_build_library_function_decl (\n \tget_identifier (PREFIX(\"ishftc8\")),\n \tgfc_int8_type_node, 3, gfc_int8_type_node, gfc_int4_type_node,\n@@ -3121,7 +3121,7 @@ gfc_build_builtin_function_decls (void)\n \tvoid_type_node, -2, pchar_type_node, pchar_type_node);\n   /* The runtime_error_at function does not return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_runtime_error_at) = 1;\n-  \n+\n   gfor_fndecl_runtime_warning_at = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"runtime_warning_at\")), \".RR\",\n \tvoid_type_node, -2, pchar_type_node, pchar_type_node);\n@@ -3816,7 +3816,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      if (sym->ts.type == BT_CLASS)\n \t\t{\n \t\t  /* Initialize _vptr to declared type.  */\n-\t\t  gfc_symbol *vtab = gfc_find_derived_vtab (sym->ts.u.derived);\n+\t\t  gfc_symbol *vtab;\n \t\t  tree rhs;\n \n \t\t  gfc_save_backend_locus (&loc);\n@@ -3827,8 +3827,14 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t  se.want_pointer = 1;\n \t\t  gfc_conv_expr (&se, e);\n \t\t  gfc_free_expr (e);\n-\t\t  rhs = gfc_build_addr_expr (TREE_TYPE (se.expr),\n-\t\t\t\t\t     gfc_get_symbol_decl (vtab));\n+\t\t  if (UNLIMITED_POLY (sym))\n+\t\t    rhs = build_int_cst (TREE_TYPE (se.expr), 0);\n+\t\t  else\n+\t\t    {\n+\t\t      vtab = gfc_find_derived_vtab (sym->ts.u.derived);\n+\t\t      rhs = gfc_build_addr_expr (TREE_TYPE (se.expr),\n+\t\t\t\t\t\tgfc_get_symbol_decl (vtab));\n+\t\t    }\n \t\t  gfc_add_modify (&init, se.expr, rhs);\n \t\t  gfc_restore_backend_locus (&loc);\n \t\t}\n@@ -3894,7 +3900,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock),\n \t\t\t\tNULL_TREE);\n \t}\n-      else\n+      else if (!(UNLIMITED_POLY(sym)))\n \tgcc_unreachable ();\n     }\n \n@@ -4347,7 +4353,7 @@ generate_coarray_sym_init (gfc_symbol *sym)\n   tree tmp, size, decl, token;\n \n   if (sym->attr.dummy || sym->attr.allocatable || !sym->attr.codimension\n-      || sym->attr.use_assoc || !sym->attr.referenced) \n+      || sym->attr.use_assoc || !sym->attr.referenced)\n     return;\n \n   decl = sym->backend_decl;\n@@ -4360,7 +4366,7 @@ generate_coarray_sym_init (gfc_symbol *sym)\n \n   size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (decl)));\n \n-  /* Ensure that we do not have size=0 for zero-sized arrays.  */ \n+  /* Ensure that we do not have size=0 for zero-sized arrays.  */\n   size = fold_build2_loc (input_location, MAX_EXPR, size_type_node,\n \t\t\t  fold_convert (size_type_node, size),\n \t\t\t  build_int_cst (size_type_node, 1));\n@@ -4382,7 +4388,7 @@ generate_coarray_sym_init (gfc_symbol *sym)\n \t\t\t     token, null_pointer_node, /* token, stat.  */\n \t\t\t     null_pointer_node, /* errgmsg, errmsg_len.  */\n \t\t\t     build_int_cst (integer_type_node, 0));\n-  \n+\n   gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl), tmp));\n \n \n@@ -4724,7 +4730,7 @@ generate_local_decl (gfc_symbol * sym)\n \t    {\n \t      if (gfc_option.warn_unused_dummy_argument)\n \t\tgfc_warning (\"Unused dummy argument '%s' at %L\", sym->name,\n-\t\t\t     &sym->declared_at);\t     \n+\t\t\t     &sym->declared_at);\n \t    }\n \n \t  /* Silence bogus \"unused parameter\" warnings from the\n@@ -5151,9 +5157,9 @@ create_main_function (tree fndecl)\n \n   /* Coarray: Call _gfortran_caf_finalize(void).  */\n   if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n-    { \n+    {\n       /* Per F2008, 8.5.1 END of the main program implies a\n-\t SYNC MEMORY.  */ \n+\t SYNC MEMORY.  */\n       tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n       tmp = build_call_expr_loc (input_location, tmp, 0);\n       gfc_add_expr_to_block (&body, tmp);"}, {"sha": "ad266845ae7153c04f10defe5643e9ef92972301", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 165, "deletions": 66, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -64,7 +64,7 @@ get_scalar_to_descriptor_type (tree scalar, symbol_attribute attr)\n static tree\n conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n {\n-  tree desc, type;  \n+  tree desc, type;\n \n   type = get_scalar_to_descriptor_type (scalar, attr);\n   desc = gfc_create_var (type, \"desc\");\n@@ -456,9 +456,68 @@ class_scalar_coarray_to_class (gfc_se *parmse, gfc_expr *e,\n }\n \n \n+/* Takes an intrinsic type expression and returns the address of a temporary\n+   class object of the 'declared' type.  */\n+void\n+gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n+\t\t\t     gfc_typespec class_ts)\n+{\n+  gfc_symbol *vtab;\n+  gfc_ss *ss;\n+  tree ctree;\n+  tree var;\n+  tree tmp;\n+\n+  /* The intrinsic type needs to be converted to a temporary\n+     CLASS object.  */\n+  tmp = gfc_typenode_for_spec (&class_ts);\n+  var = gfc_create_var (tmp, \"class\");\n+\n+  /* Set the vptr.  */\n+  ctree =  gfc_class_vptr_get (var);\n+\n+  vtab = gfc_find_intrinsic_vtab (&e->ts);\n+  gcc_assert (vtab);\n+  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+  gfc_add_modify (&parmse->pre, ctree,\n+\t\t  fold_convert (TREE_TYPE (ctree), tmp));\n+\n+  /* Now set the data field.  */\n+  ctree =  gfc_class_data_get (var);\n+  if (parmse->ss && parmse->ss->info->useflags)\n+    {\n+      /* For an array reference in an elemental procedure call we need\n+\t to retain the ss to provide the scalarized array reference.  */\n+      gfc_conv_expr_reference (parmse, e);\n+      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n+    }\n+  else\n+    {\n+      ss = gfc_walk_expr (e);\n+      if (ss == gfc_ss_terminator)\n+\t{\n+\t  parmse->ss = NULL;\n+\t  gfc_conv_expr_reference (parmse, e);\n+\t  tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+\t  gfc_add_modify (&parmse->pre, ctree, tmp);\n+\t}\n+      else\n+\t{\n+\t  parmse->ss = ss;\n+\t  gfc_conv_expr_descriptor (parmse, e);\n+\t  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\t}\n+    }\n+\n+  /* Pass the address of the class object.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+}\n+\n+\n /* Takes a scalarized class array expression and returns the\n    address of a temporary scalar class object of the 'declared'\n-   type.  \n+   type.\n    OOP-TODO: This could be improved by adding code that branched on\n    the dynamic type being the same as the declared type. In this case\n    the original class expression can be passed directly.\n@@ -567,7 +626,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n \n   tmp = NULL_TREE;\n   if (class_ref == NULL\n-\t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS) \n+\t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n     tmp = e->symtree->n.sym->backend_decl;\n   else\n     {\n@@ -813,6 +872,8 @@ gfc_trans_class_init_assign (gfc_code *code)\n       gfc_conv_expr (&src, rhs);\n       gfc_conv_expr (&memsz, sz);\n       gfc_add_block_to_block (&block, &src.pre);\n+      src.expr = gfc_build_addr_expr (NULL_TREE, src.expr);\n+\n       tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n     }\n \n@@ -826,7 +887,7 @@ gfc_trans_class_init_assign (gfc_code *code)\n     }\n \n   gfc_add_expr_to_block (&block, tmp);\n-  \n+\n   return gfc_finish_block (&block);\n }\n \n@@ -867,24 +928,41 @@ gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n       lhs = gfc_copy_expr (expr1);\n       gfc_add_vptr_component (lhs);\n \n+      if (UNLIMITED_POLY (expr1)\n+\t  && expr2->expr_type == EXPR_NULL && expr2->ts.type == BT_UNKNOWN)\n+\t{\n+\t  rhs = gfc_get_null_expr (&expr2->where);\n+ \t  goto assign_vptr;\n+\t}\n+\n       if (expr2->ts.type == BT_DERIVED)\n \tvtab = gfc_find_derived_vtab (expr2->ts.u.derived);\n       else if (expr2->expr_type == EXPR_NULL)\n \tvtab = gfc_find_derived_vtab (expr1->ts.u.derived);\n+      else\n+\tvtab = gfc_find_intrinsic_vtab (&expr2->ts);\n       gcc_assert (vtab);\n \n       rhs = gfc_get_expr ();\n       rhs->expr_type = EXPR_VARIABLE;\n       gfc_find_sym_tree (vtab->name, vtab->ns, 1, &st);\n       rhs->symtree = st;\n       rhs->ts = vtab->ts;\n-\n+assign_vptr:\n       tmp = gfc_trans_pointer_assignment (lhs, rhs);\n       gfc_add_expr_to_block (&block, tmp);\n \n       gfc_free_expr (lhs);\n       gfc_free_expr (rhs);\n     }\n+  else if (expr1->ts.type == BT_DERIVED && UNLIMITED_POLY (expr2))\n+    {\n+      /* F2003:C717 only sequence and bind-C types can come here.  */\n+      gcc_assert (expr1->ts.u.derived->attr.sequence\n+\t\t  || expr1->ts.u.derived->attr.is_bind_c);\n+      gfc_add_data_component (expr2);\n+      goto assign;\n+    }\n   else if (CLASS_DATA (expr2)->attr.dimension)\n     {\n       /* Insert an additional assignment which sets the '_vptr' field.  */\n@@ -1110,7 +1188,7 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n       tmp = gfc_get_int_type (kind);\n       tmp = fold_convert (tmp, build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t\tse->expr));\n-    \n+\n       /* Test for a NULL value.  */\n       tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp), present,\n \t\t\ttmp, fold_convert (TREE_TYPE (tmp), integer_one_node));\n@@ -1147,9 +1225,9 @@ gfc_get_expr_charlen (gfc_expr *e)\n   gfc_ref *r;\n   tree length;\n \n-  gcc_assert (e->expr_type == EXPR_VARIABLE \n+  gcc_assert (e->expr_type == EXPR_VARIABLE\n \t      && e->ts.type == BT_CHARACTER);\n-  \n+\n   length = NULL; /* To silence compiler warning.  */\n \n   if (is_subref_array (e) && e->ts.u.cl->length)\n@@ -1238,8 +1316,8 @@ flatten_array_ctors_without_strlen (gfc_expr* e)\n     {\n \n     case EXPR_OP:\n-      flatten_array_ctors_without_strlen (e->value.op.op1); \n-      flatten_array_ctors_without_strlen (e->value.op.op2); \n+      flatten_array_ctors_without_strlen (e->value.op.op1);\n+      flatten_array_ctors_without_strlen (e->value.op.op2);\n       break;\n \n     case EXPR_COMPCALL:\n@@ -1604,7 +1682,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \tse_expr = gfc_get_fake_result_decl (sym, parent_flag);\n \n       /* Similarly for alternate entry points.  */\n-      else if (alternate_entry \n+      else if (alternate_entry\n \t       && (sym->ns->proc_name->backend_decl == current_function_decl\n \t\t   || parent_flag))\n \t{\n@@ -1640,7 +1718,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \n \n       /* Dereference the expression, where needed. Since characters\n-\t are entirely different from other types, they are treated \n+\t are entirely different from other types, they are treated\n \t separately.  */\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n@@ -1670,7 +1748,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n-\t  /* Dereference non-character pointer variables. \n+\t  /* Dereference non-character pointer variables.\n \t     These must be dummies, results, or scalars.  */\n \t  if ((sym->attr.pointer || sym->attr.allocatable\n \t       || gfc_is_associate_pointer (sym)\n@@ -1828,11 +1906,11 @@ static const unsigned char powi_table[POWI_TABLE_SIZE] =\n     124, 166, 125, 214, 126, 138, 127, 153,  /* 248 - 255 */\n   };\n \n-/* If n is larger than lookup table's max index, we use the \"window \n+/* If n is larger than lookup table's max index, we use the \"window\n    method\".  */\n #define POWI_WINDOW_SIZE 3\n \n-/* Recursive function to expand the power operator. The temporary \n+/* Recursive function to expand the power operator. The temporary\n    values are put in tmpvar. The function returns tmpvar[1] ** n.  */\n static tree\n gfc_conv_powi (gfc_se * se, unsigned HOST_WIDE_INT n, tree * tmpvar)\n@@ -1895,7 +1973,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   /* There's no ABS for HOST_WIDE_INT, so here we go. It also takes care\n      of the asymmetric range of the integer type.  */\n   n = (unsigned HOST_WIDE_INT) (m < 0 ? -m : m);\n-  \n+\n   type = TREE_TYPE (lhs);\n   sgn = tree_int_cst_sgn (rhs);\n \n@@ -2006,7 +2084,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \tcase 4:\n \t  ikind = 0;\n \t  break;\n-\t  \n+\n \tcase 8:\n \t  ikind = 1;\n \t  break;\n@@ -2034,7 +2112,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \tcase 4:\n \t  kind = 0;\n \t  break;\n-\t  \n+\n \tcase 8:\n \t  kind = 1;\n \t  break;\n@@ -2050,7 +2128,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n       switch (expr->value.op.op1->ts.type)\n \t{\n \tcase BT_INTEGER:\n@@ -2068,7 +2146,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t\tcase 0:\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_POWIF);\n \t\t  break;\n-\t\t\n+\n \t\tcase 1:\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_POWI);\n \t\t  break;\n@@ -2078,7 +2156,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t\t  break;\n \n \t\tcase 3:\n-\t\t  /* Use the __builtin_powil() only if real(kind=16) is \n+\t\t  /* Use the __builtin_powil() only if real(kind=16) is\n \t\t     actually the C long double type.  */\n \t\t  if (!gfc_real16_is_float128)\n \t\t    fndecl = builtin_decl_explicit (BUILT_IN_POWIL);\n@@ -2089,7 +2167,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t\t}\n \t    }\n \n-\t  /* If we don't have a good builtin for this, go for the \n+\t  /* If we don't have a good builtin for this, go for the\n \t     library function.  */\n \t  if (!fndecl)\n \t    fndecl = gfor_fndecl_math_powi[kind][ikind].real;\n@@ -2497,7 +2575,7 @@ gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr)\n \t\t\t\t    (int)(*expr)->value.character.string[0]);\n \t  if ((*expr)->ts.kind != gfc_c_int_kind)\n \t    {\n-  \t      /* The expr needs to be compatible with a C int.  If the \n+  \t      /* The expr needs to be compatible with a C int.  If the\n \t\t conversion fails, then the 2 causes an ICE.  */\n \t      ts.type = BT_INTEGER;\n \t      ts.kind = gfc_c_int_kind;\n@@ -2937,8 +3015,8 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   else if (!sym->attr.dimension || sym->attr.pointer || sym->attr.allocatable)\n     value = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     se->expr);\n-  \n-  /* For character(*), use the actual argument's descriptor.  */  \n+\n+  /* For character(*), use the actual argument's descriptor.  */\n   else if (sym->ts.type == BT_CHARACTER && !new_sym->ts.u.cl->length)\n     value = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     se->expr);\n@@ -3347,7 +3425,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   rss = gfc_walk_expr (expr);\n \n   gcc_assert (rss != gfc_ss_terminator);\n- \n+\n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n   gfc_add_ss_to_loop (&loop, rss);\n@@ -3507,7 +3585,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n \n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts, false, false, true);\n   gfc_add_expr_to_block (&body, tmp);\n-  \n+\n   /* Generate the copying loops.  */\n   gfc_trans_scalarizing_loops (&loop2, &body);\n \n@@ -3534,7 +3612,7 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   if (formal_ptr)\n     {\n       size = gfc_index_one_node;\n-      offset = gfc_index_zero_node;  \n+      offset = gfc_index_zero_node;\n       for (n = 0; n < dimen; n++)\n \t{\n \t  tmp = gfc_conv_descriptor_ubound_get (parmse->expr,\n@@ -3635,7 +3713,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t    && !(fsym->attr.pointer || fsym->attr.allocatable)\n \t    && fsym->as->type != AS_ASSUMED_SHAPE;\n \t  f = f || !sym->attr.always_explicit;\n-      \n+\n \t  gfc_conv_array_parameter (se, arg->expr, f, NULL, NULL, NULL);\n \t}\n \n@@ -3654,7 +3732,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       arg->expr->ts.f90_type = sym->ts.u.derived->ts.f90_type;\n       arg->expr->ts.kind = sym->ts.u.derived->ts.kind;\n       gfc_conv_expr_reference (se, arg->expr);\n-  \n+\n       return 1;\n     }\n   else if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n@@ -3756,14 +3834,14 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t       gfc_array_index_type, stride,\n \t\t\t\t       fold_convert (gfc_array_index_type,\n \t\t\t\t\t\t     shapese.expr)));\n-      /* Finish scalarization loop.  */ \n+      /* Finish scalarization loop.  */\n       gfc_trans_scalarizing_loops (&loop, &body);\n       gfc_add_block_to_block (&block, &loop.pre);\n       gfc_add_block_to_block (&block, &loop.post);\n       gfc_add_block_to_block (&block, &fptrse.post);\n       gfc_cleanup_loop (&loop);\n \n-      gfc_add_modify (&block, offset, \n+      gfc_add_modify (&block, offset,\n \t\t      fold_build1_loc (input_location, NEGATE_EXPR,\n \t\t\t\t       gfc_array_index_type, offset));\n       gfc_conv_descriptor_offset_set (&block, desc, offset);\n@@ -3796,7 +3874,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  tree eq_expr;\n \t  tree not_null_expr;\n-\t  \n+\n \t  /* Given two arguments so build the arg2se from second arg.  */\n \t  gfc_init_se (&arg2se, NULL);\n \t  gfc_conv_expr (&arg2se, arg->next->expr);\n@@ -3820,7 +3898,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \n       return 1;\n     }\n-    \n+\n   /* Nothing was done.  */\n   return 0;\n }\n@@ -3994,6 +4072,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n \t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \t}\n+      else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS)\n+\t{\n+\t  /* The intrinsic type needs to be converted to a temporary\n+\t     CLASS object for the unlimited polymorphic formal.  */\n+\t  gfc_init_se (&parmse, se);\n+\t  gfc_conv_intrinsic_to_class (&parmse, e, fsym->ts);\n+\t}\n       else if (se->ss && se->ss->info->useflags)\n \t{\n \t  gfc_ss *ss;\n@@ -4051,7 +4136,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t= fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t   TREE_TYPE (parmse.expr),\n \t\t\t\t   gfc_unlikely (tmp),\n-\t\t\t\t   fold_convert (TREE_TYPE (parmse.expr), \n+\t\t\t\t   fold_convert (TREE_TYPE (parmse.expr),\n \t\t\t\t\t\t null_pointer_node),\n \t\t\t\t   parmse.expr);\n \t    }\n@@ -4192,7 +4277,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n \t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n \n-\t\t  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n+\t\t  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n \t\t     allocated on entry, it must be deallocated.  */\n \t\t  if (fsym && fsym->attr.intent == INTENT_OUT\n \t\t      && (fsym->attr.allocatable\n@@ -4205,7 +4290,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      gfc_init_block  (&block);\n \t\t      ptr = parmse.expr;\n \t\t      if (e->ts.type == BT_CLASS)\n-\t\t\tptr = gfc_class_data_get (ptr);\t\n+\t\t\tptr = gfc_class_data_get (ptr);\n \n \t\t      tmp = gfc_deallocate_with_status (ptr, NULL_TREE,\n \t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n@@ -4327,7 +4412,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t      /* If the argument is a function call that may not create\n \t\t a temporary for the result, we have to check that we\n-\t\t can do it, i.e. that there is no alias between this \n+\t\t can do it, i.e. that there is no alias between this\n \t\t argument and another one.  */\n \t      if (gfc_get_noncopying_intrinsic_argument (e) != NULL)\n \t\t{\n@@ -4387,7 +4472,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, f, fsym, sym->name, NULL);\n \n-\t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n+\t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n \t\t allocated on entry, it must be deallocated.  */\n \t      if (fsym && fsym->attr.allocatable\n \t\t  && fsym->attr.intent == INTENT_OUT)\n@@ -4404,7 +4489,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t       tmp, build_empty_stmt (input_location));\n \t\t  gfc_add_expr_to_block (&se->pre, tmp);\n \t\t}\n-\t    } \n+\t    }\n \t}\n \n       /* The case with fsym->attr.optional is that of a user subroutine\n@@ -4430,7 +4515,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      && ((e->rank != 0 && sym->attr.elemental)\n \t\t  || e->representation.length || e->ts.type == BT_CHARACTER\n \t\t  || (e->rank != 0\n-\t\t      && (fsym == NULL \n+\t\t      && (fsym == NULL\n \t\t\t  || (fsym-> as\n \t\t\t      && (fsym->as->type == AS_ASSUMED_SHAPE\n \t\t\t\t  || fsym->as->type == AS_ASSUMED_RANK\n@@ -4600,7 +4685,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t      fold_convert (TREE_TYPE (tmp),\n \t\t\t\t\t\t    null_pointer_node));\n \t    }\n- \n+\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &e->where,\n \t\t\t\t   msg);\n \t  free (msg);\n@@ -4618,8 +4703,21 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n \n       /* Character strings are passed as two parameters, a length and a\n-         pointer - except for Bind(c) which only passes the pointer.  */\n-      if (parmse.string_length != NULL_TREE && !sym->attr.is_bind_c)\n+\t pointer - except for Bind(c) which only passes the pointer.\n+\t An unlimited polymorphic formal argument likewise does not\n+\t need the length.  */\n+      if (parmse.string_length != NULL_TREE\n+\t  && !sym->attr.is_bind_c\n+\t  && !(fsym && UNLIMITED_POLY (fsym)))\n+\tvec_safe_push (stringargs, parmse.string_length);\n+\n+      /* When calling __copy for character expressions to unlimited\n+\t polymorphic entities, the dst argument needs a string length.  */\n+      if (sym->name[0] == '_' && e && e->ts.type == BT_CHARACTER\n+\t  && strncmp (sym->name, \"__vtab_CHARACTER\", 16) == 0\n+\t  && arg->next && arg->next->expr\n+\t  && arg->next->expr->ts.type == BT_DERIVED\n+\t  && arg->next->expr->ts.u.derived->attr.unlimited_polymorphic)\n \tvec_safe_push (stringargs, parmse.string_length);\n \n       /* For descriptorless coarrays and assumed-shape coarray dummies, we\n@@ -4656,7 +4754,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n \t      tmp = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n \t    }\n-\t  \n+\n \t  vec_safe_push (stringargs, tmp);\n \n \t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n@@ -4752,7 +4850,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    gfc_conv_expr (&parmse, ts.u.cl->length);\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n-\t  \n+\n \t  tmp = fold_convert (gfc_charlen_type_node, parmse.expr);\n \t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n \t\t\t\t gfc_charlen_type_node, tmp,\n@@ -5490,7 +5588,7 @@ gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n \n \n /* Build a static initializer.  EXPR is the expression for the initial value.\n-   The other parameters describe the variable of the component being \n+   The other parameters describe the variable of the component being\n    initialized. EXPR may be null.  */\n \n tree\n@@ -5521,7 +5619,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n       gcc_assert (TREE_CODE (se.expr) != CONSTRUCTOR);\n       return se.expr;\n     }\n-  \n+\n   if (array && !procptr)\n     {\n       tree ctor;\n@@ -5557,7 +5655,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n \tcase BT_CLASS:\n \t  gfc_init_se (&se, NULL);\n \t  if (ts->type == BT_CLASS && expr->expr_type == EXPR_NULL)\n-\t    gfc_conv_structure (&se, gfc_class_null_initializer(ts), 1);\n+\t    gfc_conv_structure (&se, gfc_class_null_initializer(ts, expr), 1);\n \t  else\n \t    gfc_conv_structure (&se, expr, 1);\n \t  gcc_assert (TREE_CODE (se.expr) == CONSTRUCTOR);\n@@ -5579,7 +5677,7 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n \t}\n     }\n }\n-  \n+\n static tree\n gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n {\n@@ -5626,7 +5724,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t       cm->as->lower[n]->value.integer);\n       mpz_add_ui (lss_array->shape[n], lss_array->shape[n], 1);\n     }\n-  \n+\n   /* Associate the SS with the loop.  */\n   gfc_add_ss_to_loop (&loop, lss);\n   gfc_add_ss_to_loop (&loop, rss);\n@@ -5691,7 +5789,7 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n   gfc_start_block (&block);\n   gfc_init_se (&se, NULL);\n \n-  /* Get the descriptor for the expressions.  */ \n+  /* Get the descriptor for the expressions.  */\n   se.want_pointer = 0;\n   gfc_conv_expr_descriptor (&se, expr);\n   gfc_add_block_to_block (&block, &se.pre);\n@@ -5867,7 +5965,7 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n     {\n       /* NULL initialization for CLASS components.  */\n       tmp = gfc_trans_structure_assign (dest,\n-\t\t\t\t\tgfc_class_null_initializer (&cm->ts));\n+\t\t\t\t\tgfc_class_null_initializer (&cm->ts, expr));\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else if (cm->attr.dimension && !cm->attr.proc_pointer)\n@@ -5948,7 +6046,7 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n \t\t      fold_convert (TREE_TYPE (lse.expr), se.expr));\n \n       return gfc_finish_block (&block);\n-    } \n+    }\n \n   for (c = gfc_constructor_first (expr->value.constructor);\n        c; c = gfc_constructor_next (c), cm = cm->next)\n@@ -6004,20 +6102,21 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       if (!c->expr || (cm->attr.allocatable && cm->attr.flavor != FL_PROCEDURE))\n         continue;\n \n-      if (strcmp (cm->name, \"_size\") == 0)\n-\t{\n-\t  val = TYPE_SIZE_UNIT (gfc_get_derived_type (cm->ts.u.derived));\n-\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n-\t}\n-      else if (cm->initializer && cm->initializer->expr_type != EXPR_NULL\n-\t       && strcmp (cm->name, \"_extends\") == 0)\n+      if (cm->initializer && cm->initializer->expr_type != EXPR_NULL\n+\t  && strcmp (cm->name, \"_extends\") == 0\n+\t  && cm->initializer->symtree)\n \t{\n \t  tree vtab;\n \t  gfc_symbol *vtabs;\n \t  vtabs = cm->initializer->symtree->n.sym;\n \t  vtab = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtabs));\n \t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, vtab);\n \t}\n+      else if (cm->ts.u.derived && strcmp (cm->name, \"_size\") == 0)\n+\t{\n+\t  val = TYPE_SIZE_UNIT (gfc_get_derived_type (cm->ts.u.derived));\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+\t}\n       else\n \t{\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,\n@@ -6030,7 +6129,7 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t}\n     }\n   se->expr = build_constructor (type, v);\n-  if (init) \n+  if (init)\n     TREE_CONSTANT (se->expr) = 1;\n }\n \n@@ -6309,7 +6408,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   scalar = ss == gfc_ss_terminator;\n   if (!scalar)\n     gfc_free_ss_chain (ss);\n- \n+\n   if (scalar)\n     {\n       /* Scalar pointers.  */\n@@ -6794,7 +6893,7 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n \n   /* Functions returning pointers or allocatables need temporaries.  */\n   c = expr2->value.function.esym\n-      ? (expr2->value.function.esym->attr.pointer \n+      ? (expr2->value.function.esym->attr.pointer\n \t || expr2->value.function.esym->attr.allocatable)\n       : (expr2->symtree->n.sym->attr.pointer\n \t || expr2->symtree->n.sym->attr.allocatable);\n@@ -7085,7 +7184,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n      correctly take care of the reallocation internally. For intrinsic\n      calls, the array data is freed and the library takes care of allocation.\n      TODO: Add logic of trans-array.c: gfc_alloc_allocatable_for_assignment\n-     to the library.  */    \n+     to the library.  */\n   if (gfc_option.flag_realloc_lhs\n \t&& gfc_is_reallocatable_lhs (expr1)\n \t&& !gfc_expr_attr (expr1).codimension\n@@ -7417,7 +7516,7 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   gfc_init_se (&lse, NULL);\n   lse.want_pointer = 1;\n   gfc_conv_expr (&lse, expr1);\n-  \n+\n   jump_label1 = gfc_build_label_decl (NULL_TREE);\n   jump_label2 = gfc_build_label_decl (NULL_TREE);\n "}, {"sha": "52f24c1d82fde39bae4e39fea1a0a5d462309aad", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -5911,13 +5911,28 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   gfc_expr *a, *b;\n   gfc_se se1, se2;\n   tree tmp;\n+  tree conda = NULL_TREE, condb = NULL_TREE;\n \n   gfc_init_se (&se1, NULL);\n   gfc_init_se (&se2, NULL);\n \n   a = expr->value.function.actual->expr;\n   b = expr->value.function.actual->next->expr;\n \n+  if (UNLIMITED_POLY (a))\n+    {\n+      tmp = gfc_class_vptr_get (a->symtree->n.sym->backend_decl);\n+      conda = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+    }\n+\n+  if (UNLIMITED_POLY (b))\n+    {\n+      tmp = gfc_class_vptr_get (b->symtree->n.sym->backend_decl);\n+      condb = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+    }\n+\n   if (a->ts.type == BT_CLASS)\n     {\n       gfc_add_vptr_component (a);\n@@ -5939,8 +5954,18 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr (&se1, a);\n   gfc_conv_expr (&se2, b);\n \n-  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t se1.expr, fold_convert (TREE_TYPE (se1.expr), se2.expr));\n+  tmp = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t boolean_type_node, se1.expr,\n+\t\t\t fold_convert (TREE_TYPE (se1.expr), se2.expr));\n+\n+  if (conda)\n+    tmp = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t   boolean_type_node, conda, tmp);\n+\n+  if (condb)\n+    tmp = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t   boolean_type_node, condb, tmp);\n+\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n "}, {"sha": "e41a0c7b173c2e831c4d7891c3015fc0ec67fee3", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 114, "deletions": 49, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -247,7 +247,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n       if (e == NULL)\n \tcontinue;\n \n-      /* Obtain the info structure for the current argument.  */ \n+      /* Obtain the info structure for the current argument.  */\n       for (ss = loopse->ss; ss && ss != gfc_ss_terminator; ss = ss->next)\n \tif (ss->info->expr == e)\n \t  break;\n@@ -449,9 +449,9 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       gfc_add_ss_to_loop (&loop, ss);\n \n       gfc_conv_ss_startstride (&loop);\n-      /* TODO: gfc_conv_loop_setup generates a temporary for vector \n-\t subscripts.  This could be prevented in the elemental case  \n-\t as temporaries are handled separatedly \n+      /* TODO: gfc_conv_loop_setup generates a temporary for vector\n+\t subscripts.  This could be prevented in the elemental case\n+\t as temporaries are handled separatedly\n \t (below in gfc_conv_elemental_dependencies).  */\n       gfc_conv_loop_setup (&loop, &code->expr1->where);\n       gfc_mark_ss_chain_used (ss, 1);\n@@ -657,7 +657,7 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n \t\t\t\t ? (gfc_option.coarray == GFC_FCOARRAY_LIB\n \t\t\t\t    ? gfor_fndecl_caf_error_stop\n \t\t\t\t    : gfor_fndecl_error_stop_numeric)\n-\t\t\t\t : gfor_fndecl_stop_numeric_f08, 1, \n+\t\t\t\t : gfor_fndecl_stop_numeric_f08, 1,\n \t\t\t\t fold_convert (gfc_int4_type_node, se.expr));\n     }\n   else\n@@ -689,7 +689,7 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op type ATTRIBUTE_UNUSED)\n   /* Short cut: For single images without STAT= or LOCK_ACQUIRED\n      return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n   if (!code->expr2 && !code->expr4 && gfc_option.coarray != GFC_FCOARRAY_LIB)\n-    return NULL_TREE; \n+    return NULL_TREE;\n \n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n@@ -734,7 +734,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n      return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n   if (!code->expr2 && !(gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n       && gfc_option.coarray != GFC_FCOARRAY_LIB)\n-    return NULL_TREE; \n+    return NULL_TREE;\n \n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n@@ -824,7 +824,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t{\n \t  if (TREE_TYPE (stat) == integer_type_node)\n \t    stat = gfc_build_addr_expr (NULL, stat);\n-\t  \n+\n \t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_all,\n \t\t\t\t     3, stat, errmsg, errmsglen);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n@@ -837,7 +837,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t\t\t\t     3, gfc_build_addr_expr (NULL, tmp_stat),\n \t\t\t\t     errmsg, errmsglen);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n-\t  \n+\n \t  gfc_add_modify (&se.pre, stat,\n \t\t\t  fold_convert (TREE_TYPE (stat), tmp_stat));\n \t}\n@@ -890,7 +890,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t  if (TREE_TYPE (stat) == integer_type_node)\n \t    stat = gfc_build_addr_expr (NULL, stat);\n \n-\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_images, \n+\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_images,\n \t\t\t\t     5, fold_convert (integer_type_node, len),\n \t\t\t\t     images, stat, errmsg, errmsglen);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n@@ -899,13 +899,13 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t{\n \t  tree tmp_stat = gfc_create_var (integer_type_node, \"stat\");\n \n-\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_images, \n+\t  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_images,\n \t\t\t\t     5, fold_convert (integer_type_node, len),\n \t\t\t\t     images, gfc_build_addr_expr (NULL, tmp_stat),\n \t\t\t\t     errmsg, errmsglen);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  gfc_add_modify (&se.pre, stat, \n+\t  gfc_add_modify (&se.pre, stat,\n \t\t\t  fold_convert (TREE_TYPE (stat), tmp_stat));\n \t}\n     }\n@@ -995,7 +995,7 @@ gfc_trans_if_1 (gfc_code * code)\n   loc = code->expr1->where.lb ? code->expr1->where.lb->location : input_location;\n   stmt = fold_build3_loc (loc, COND_EXPR, void_type_node, if_se.expr, stmt,\n \t\t\t  elsestmt);\n-  \n+\n   gfc_add_expr_to_block (&if_se.pre, stmt);\n \n   /* Finish off this statement.  */\n@@ -1141,6 +1141,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   gfc_expr *e;\n   tree tmp;\n   bool class_target;\n+  bool unlimited;\n   tree desc;\n   tree offset;\n   tree dim;\n@@ -1153,6 +1154,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t    && (gfc_is_class_scalar_expr (e)\n \t\t\t|| gfc_is_class_array_ref (e, NULL));\n \n+  unlimited = UNLIMITED_POLY (e);\n+\n   /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n      to array temporary) for arrays with either unknown shape or if associating\n      to a variable.  */\n@@ -1194,9 +1197,10 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t\t    gfc_finish_block (&se.post));\n     }\n \n-  /* Derived type temporaries, arising from TYPE IS, just need the\n-     descriptor of class arrays to be assigned directly.  */\n-  else if (class_target && sym->ts.type == BT_DERIVED && sym->attr.dimension)\n+  /* Temporaries, arising from TYPE IS, just need the descriptor of class\n+     arrays to be assigned directly.  */\n+  else if (class_target && sym->attr.dimension\n+\t   && (sym->ts.type == BT_DERIVED || unlimited))\n     {\n       gfc_se se;\n \n@@ -1208,7 +1212,16 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (sym->backend_decl)));\n \n       gfc_add_modify (&se.pre, sym->backend_decl, se.expr);\n-      \n+\n+      if (unlimited)\n+\t{\n+\t  /* Recover the dtype, which has been overwritten by the\n+\t     assignment from an unlimited polymorphic object.  */\n+\t  tmp = gfc_conv_descriptor_dtype (sym->backend_decl);\n+\t  gfc_add_modify (&se.pre, tmp,\n+\t\t\t  gfc_get_dtype (TREE_TYPE (sym->backend_decl)));\n+\t}\n+\n       gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n \t\t\t    gfc_finish_block (&se.post));\n     }\n@@ -1229,7 +1242,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  /* For a class array we need a descriptor for the selector.  */\n \t  gfc_conv_expr_descriptor (&se, e);\n \n-\t  /* Obtain a temporary class container for the result.  */ \n+\t  /* Obtain a temporary class container for the result.  */\n \t  gfc_conv_class_to_class (&se, e, sym->ts, false, true, false, false);\n \t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \n@@ -1254,7 +1267,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t{\n \t  /* This is bound to be a class array element.  */\n \t  gfc_conv_expr_reference (&se, e);\n-\t  /* Get the _vptr component of the class object.  */ \n+\t  /* Get the _vptr component of the class object.  */\n \t  tmp = gfc_get_vptr_from_expr (se.expr);\n \t  /* Obtain a temporary class container for the result.  */\n \t  gfc_conv_derived_to_class (&se, e, sym->ts, tmp, false, false);\n@@ -1266,7 +1279,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       tmp = TREE_TYPE (sym->backend_decl);\n       tmp = gfc_build_addr_expr (tmp, se.expr);\n       gfc_add_modify (&se.pre, sym->backend_decl, tmp);\n-      \n+\n       gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n \t\t\t    gfc_finish_block (&se.post));\n     }\n@@ -1281,6 +1294,23 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       tmp = gfc_trans_assignment (lhs, e, false, true);\n       gfc_add_init_cleanup (block, tmp, NULL_TREE);\n     }\n+\n+  /* Set the stringlength from the vtable size.  */\n+  if (sym->ts.type == BT_CHARACTER && sym->attr.select_type_temporary)\n+    {\n+      tree charlen;\n+      gfc_se se;\n+      gfc_init_se (&se, NULL);\n+      gcc_assert (UNLIMITED_POLY (e->symtree->n.sym));\n+      tmp = gfc_get_symbol_decl (e->symtree->n.sym);\n+      tmp = gfc_vtable_size_get (tmp);\n+      gfc_get_symbol_decl (sym);\n+      charlen = sym->ts.u.cl->backend_decl;\n+      gfc_add_modify (&se.pre, charlen,\n+\t\t      fold_convert (TREE_TYPE (charlen), tmp));\n+      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n }\n \n \n@@ -1319,7 +1349,7 @@ gfc_trans_block_construct (gfc_code* code)\n   gfc_trans_deferred_vars (sym, &block);\n   for (ass = code->ext.block.assoc; ass; ass = ass->next)\n     trans_associate_var (ass->st->n.sym, &block);\n-    \n+\n   return gfc_finish_wrapped_block (&block);\n }\n \n@@ -1366,15 +1396,15 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   tree cycle_label;\n   tree exit_label;\n   location_t loc;\n-  \n+\n   type = TREE_TYPE (dovar);\n \n   loc = code->ext.iterator->start->where.lb->location;\n \n   /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify_loc (loc, pblock, dovar,\n \t\t      fold_convert (TREE_TYPE(dovar), from));\n-  \n+\n   /* Save value for do-tinkering checking. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n@@ -1612,8 +1642,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, step,\n \t\t\t     build_int_cst (TREE_TYPE (step), 0));\n-      step_sign = fold_build3_loc (loc, COND_EXPR, type, tmp, \n-\t\t\t\t   build_int_cst (type, -1), \n+      step_sign = fold_build3_loc (loc, COND_EXPR, type, tmp,\n+\t\t\t\t   build_int_cst (type, -1),\n \t\t\t\t   build_int_cst (type, 1));\n \n       tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, to, from);\n@@ -3183,7 +3213,7 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   if (INTEGER_CST_P (inner_size))\n     {\n       while (forall_tmp\n-\t     && !forall_tmp->mask \n+\t     && !forall_tmp->mask\n \t     && INTEGER_CST_P (forall_tmp->size))\n \t{\n \t  inner_size = fold_build2_loc (input_location, MULT_EXPR,\n@@ -3707,7 +3737,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   for (n = 0; n < nvar; n++)\n     {\n       /* size = (end + step - start) / step.  */\n-      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (start[n]), \n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (start[n]),\n \t\t\t     step[n], start[n]);\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (end[n]),\n \t\t\t     end[n], tmp);\n@@ -4108,7 +4138,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n   stmtblock_t body;\n   tree index, maskexpr;\n \n-  /* A defined assignment. */  \n+  /* A defined assignment. */\n   if (cnext && cnext->resolved_sym)\n     return gfc_trans_call (cnext, true, mask, count1, invert);\n \n@@ -4893,10 +4923,19 @@ gfc_trans_allocate (gfc_code * code)\n       if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, label_finish,\n \t\t\t       memsz, &nelems, code->expr3))\n \t{\n+\t  bool unlimited_char;\n+\n+\t  unlimited_char = UNLIMITED_POLY (al->expr)\n+\t\t\t   && ((code->expr3 && code->expr3->ts.type == BT_CHARACTER)\n+\t\t\t      || (code->ext.alloc.ts.type == BT_CHARACTER\n+\t\t\t\t  && code->ext.alloc.ts.u.cl\n+\t\t\t\t  && code->ext.alloc.ts.u.cl->length));\n+\n \t  /* A scalar or derived type.  */\n \n \t  /* Determine allocate size.  */\n \t  if (al->expr->ts.type == BT_CLASS\n+\t\t&& !unlimited_char\n \t\t&& code->expr3\n \t\t&& memsz == NULL_TREE)\n \t    {\n@@ -4913,8 +4952,8 @@ gfc_trans_allocate (gfc_code * code)\n \t      else\n \t\tmemsz = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n \t    }\n-\t  else if (al->expr->ts.type == BT_CHARACTER\n-\t\t     && al->expr->ts.deferred && code->expr3)\n+\t  else if (((al->expr->ts.type == BT_CHARACTER && al->expr->ts.deferred)\n+\t\t   || unlimited_char) && code->expr3)\n \t    {\n \t      if (!code->expr3->ts.u.cl->backend_decl)\n \t\t{\n@@ -4968,13 +5007,17 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\tmemsz));\n \n \t      /* Convert to size in bytes, using the character KIND.  */\n+\t      if (unlimited_char)\n+\t\ttmp = TREE_TYPE (gfc_typenode_for_spec (&code->expr3->ts));\n+\t      else\n \t      tmp = TREE_TYPE (gfc_typenode_for_spec (&al->expr->ts));\n \t      tmp = TYPE_SIZE_UNIT (tmp);\n \t      memsz = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t       TREE_TYPE (tmp), tmp,\n \t\t\t\t       fold_convert (TREE_TYPE (tmp), memsz));\n \t    }\n-          else if (al->expr->ts.type == BT_CHARACTER && al->expr->ts.deferred)\n+          else if ((al->expr->ts.type == BT_CHARACTER && al->expr->ts.deferred)\n+\t\t    || unlimited_char)\n \t    {\n \t      gcc_assert (code->ext.alloc.ts.u.cl && code->ext.alloc.ts.u.cl->length);\n \t      gfc_init_se (&se_sz, NULL);\n@@ -5026,7 +5069,7 @@ gfc_trans_allocate (gfc_code * code)\n \t    }\n \t  else if (al->expr->ts.type == BT_CLASS)\n \t    {\n-\t      /* With class objects, it is best to play safe and null the \n+\t      /* With class objects, it is best to play safe and null the\n \t\t memory because we cannot know if dynamic types have allocatable\n \t\t components or not.  */\n \t      tmp = build_call_expr_loc (input_location,\n@@ -5050,8 +5093,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t     build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n- \n-      /* We need the vptr of CLASS objects to be initialized.  */ \n+\n+      /* We need the vptr of CLASS objects to be initialized.  */\n       e = gfc_copy_expr (al->expr);\n       if (e->ts.type == BT_CLASS)\n \t{\n@@ -5090,16 +5133,19 @@ gfc_trans_allocate (gfc_code * code)\n \t\tts = &code->expr3->ts;\n \t      else if (e->ts.type == BT_DERIVED)\n \t\tts = &e->ts;\n-\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n+\t      else if (code->ext.alloc.ts.type == BT_DERIVED || UNLIMITED_POLY (al->expr))\n \t\tts = &code->ext.alloc.ts;\n \t      else if (e->ts.type == BT_CLASS)\n \t\tts = &CLASS_DATA (e)->ts;\n \t      else\n \t\tts = &e->ts;\n \n-\t      if (ts->type == BT_DERIVED)\n+\t      if (ts->type == BT_DERIVED || UNLIMITED_POLY (e))\n \t\t{\n+\t\t  if (ts->type == BT_DERIVED)\n \t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n+\t\t  else\n+\t\t    vtab = gfc_find_intrinsic_vtab (ts);\n \t\t  gcc_assert (vtab);\n \t\t  gfc_init_se (&lse, NULL);\n \t\t  lse.want_pointer = 1;\n@@ -5184,9 +5230,12 @@ gfc_trans_allocate (gfc_code * code)\n \t\t  ppc = gfc_copy_expr (rhs);\n \t\t  gfc_add_vptr_component (ppc);\n \t\t}\n-\t      else\n+\t      else if (rhs->ts.type == BT_DERIVED)\n \t\tppc = gfc_lval_expr_from_sym\n \t\t\t\t(gfc_find_derived_vtab (rhs->ts.u.derived));\n+\t      else\n+\t\tppc = gfc_lval_expr_from_sym\n+\t\t\t\t(gfc_find_intrinsic_vtab (&rhs->ts));\n \t      gfc_add_component_ref (ppc, \"_copy\");\n \n \t      ppc_code = gfc_get_code ();\n@@ -5296,6 +5345,30 @@ gfc_trans_allocate (gfc_code * code)\n }\n \n \n+/* Reset the vptr after deallocation.  */\n+\n+static void\n+reset_vptr (stmtblock_t *block, gfc_expr *e)\n+{\n+  gfc_expr *rhs, *lhs = gfc_copy_expr (e);\n+  gfc_symbol *vtab;\n+  tree tmp;\n+\n+  if (UNLIMITED_POLY (e))\n+    rhs = gfc_get_null_expr (NULL);\n+  else\n+    {\n+      vtab = gfc_find_derived_vtab (e->ts.u.derived);\n+      rhs = gfc_lval_expr_from_sym (vtab);\n+    }\n+  gfc_add_vptr_component (lhs);\n+  tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+  gfc_add_expr_to_block (block, tmp);\n+  gfc_free_expr (lhs);\n+  gfc_free_expr (rhs);\n+}\n+\n+\n /* Translate a DEALLOCATE statement.  */\n \n tree\n@@ -5376,6 +5449,8 @@ gfc_trans_deallocate (gfc_code *code)\n \t  tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,\n \t\t\t\t      label_finish, expr);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n+\t  if (UNLIMITED_POLY (al->expr))\n+\t    reset_vptr (&se.pre, al->expr);\n \t}\n       else\n \t{\n@@ -5388,19 +5463,9 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t\t\t se.expr,\n \t\t\t\t build_int_cst (TREE_TYPE (se.expr), 0));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n-\t  \n+\n \t  if (al->expr->ts.type == BT_CLASS)\n-\t    {\n-\t      /* Reset _vptr component to declared type.  */\n-\t      gfc_expr *rhs, *lhs = gfc_copy_expr (al->expr);\n-\t      gfc_symbol *vtab = gfc_find_derived_vtab (al->expr->ts.u.derived);\n-\t      gfc_add_vptr_component (lhs);\n-\t      rhs = gfc_lval_expr_from_sym (vtab);\n-\t      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-\t      gfc_add_expr_to_block (&se.pre, tmp);\n-\t      gfc_free_expr (lhs);\n-\t      gfc_free_expr (rhs);\n-\t    }\n+\t    reset_vptr (&se.pre, al->expr);\n \t}\n \n       if (code->expr1)"}, {"sha": "8394bf9357625327bcfe129743c6635b1ed57908", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -2338,16 +2338,18 @@ gfc_get_derived_type (gfc_symbol * derived)\n   tree canonical = NULL_TREE;\n   tree *chain = NULL;\n   bool got_canonical = false;\n+  bool unlimited_entity = false;\n   gfc_component *c;\n   gfc_dt_list *dt;\n   gfc_namespace *ns;\n \n+  if (derived->attr.unlimited_polymorphic)\n+    return ptr_type_node;\n+\n   if (derived && derived->attr.flavor == FL_PROCEDURE\n       && derived->attr.generic)\n     derived = gfc_find_dt_in_generic (derived);\n \n-  gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n-\n   /* See if it's one of the iso_c_binding derived types.  */\n   if (derived->attr.is_iso_c == 1)\n     {\n@@ -2431,6 +2433,12 @@ gfc_get_derived_type (gfc_symbol * derived)\n       derived->backend_decl = typenode;\n     }\n \n+  if (derived->components\n+\t&& derived->components->ts.type == BT_DERIVED\n+\t&& strcmp (derived->components->name, \"_data\") == 0\n+\t&& derived->components->ts.u.derived->attr.unlimited_polymorphic)\n+    unlimited_entity = true;\n+\n   /* Go through the derived type components, building them as\n      necessary. The reason for doing this now is that it is\n      possible to recurse back to this derived type through a\n@@ -2511,14 +2519,16 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t\t\t\t\t\t    !c->attr.target);\n \t}\n       else if ((c->attr.pointer || c->attr.allocatable)\n-\t       && !c->attr.proc_pointer)\n+\t       && !c->attr.proc_pointer\n+\t       && !(unlimited_entity && c == derived->components))\n \tfield_type = build_pointer_type (field_type);\n \n       if (c->attr.pointer)\n \tfield_type = gfc_nonrestricted_type (field_type);\n \n       /* vtype fields can point to different types to the base type.  */\n-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.vtype)\n+      if (c->ts.type == BT_DERIVED\n+\t    && c->ts.u.derived && c->ts.u.derived->attr.vtype)\n \t  field_type = build_pointer_type_for_mode (TREE_TYPE (field_type),\n \t\t\t\t\t\t    ptr_mode, true);\n "}, {"sha": "70f06fffe997e224ac1fd27ffb3b2556f82d7a62", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,6 +1,6 @@\n /* Code translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2012 Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of GCC.\n@@ -87,7 +87,7 @@ tree\n gfc_create_var_np (tree type, const char *prefix)\n {\n   tree t;\n-  \n+\n   t = create_tmp_var_raw (type, prefix);\n \n   /* No warnings for anonymous variables.  */\n@@ -139,7 +139,7 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n }\n \n \n-/* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.  \n+/* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.\n    A MODIFY_EXPR is an assignment:\n    LHS <- RHS.  */\n \n@@ -428,7 +428,7 @@ trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   arg = gfc_build_addr_expr (pchar_type_node,\n \t\t\t     gfc_build_localized_cstring_const (message));\n   free (message);\n-  \n+\n   asprintf (&message, \"%s\", _(msgid));\n   arg2 = gfc_build_addr_expr (pchar_type_node,\n \t\t\t      gfc_build_localized_cstring_const (message));\n@@ -440,7 +440,7 @@ trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   argarray[1] = arg2;\n   for (i = 0; i < nargs; i++)\n     argarray[2 + i] = va_arg (ap, tree);\n-  \n+\n   /* Build the function call to runtime_(warning,error)_at; because of the\n      variable number of arguments, we can't use build_call_expr_loc dinput_location,\n      irectly.  */\n@@ -591,14 +591,14 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n \n \n /* Allocate memory, using an optional status argument.\n- \n+\n    This function follows the following pseudo-code:\n \n     void *\n     allocate (size_t size, integer_type stat)\n     {\n       void *newmem;\n-    \n+\n       if (stat requested)\n \tstat = 0;\n \n@@ -661,7 +661,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n \n \n /* Allocate memory, using an optional status argument.\n- \n+\n    This function follows the following pseudo-code:\n \n     void *\n@@ -717,9 +717,9 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n /* Generate code for an ALLOCATE statement when the argument is an\n    allocatable variable.  If the variable is currently allocated, it is an\n    error to allocate it again.\n- \n+\n    This function follows the following pseudo-code:\n-  \n+\n     void *\n     allocate_allocatable (void *mem, size_t size, integer_type stat)\n     {\n@@ -733,7 +733,7 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \t  runtime_error (\"Attempting to allocate already allocated variable\");\n       }\n     }\n-    \n+\n     expr must be set to the original expression being allocated for its locus\n     and variable name in case a runtime error has to be printed.  */\n void\n@@ -866,7 +866,7 @@ gfc_call_free (tree var)\n    even when no status variable is passed to us (this is used for\n    unconditional deallocation generated by the front-end at end of\n    each procedure).\n-   \n+\n    If a runtime-message is possible, `expr' must point to the original\n    expression being deallocated for its locus and variable name.\n \n@@ -1075,7 +1075,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n \n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n-  \n+\n   /* Free allocatable components.  */\n   if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n@@ -1091,7 +1091,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n \t\t\t\t       tmp, 0);\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n-  \n+\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,\n \t\t\t     fold_convert (pvoid_type_node, pointer));\n@@ -1320,6 +1320,12 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_POINTER_ASSIGN:\n \t  if (code->expr1->ts.type == BT_CLASS)\n \t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n+\t  else if (UNLIMITED_POLY (code->expr2)\n+\t\t   && code->expr1->ts.type == BT_DERIVED\n+\t\t   && (code->expr1->ts.u.derived->attr.sequence\n+\t\t       || code->expr1->ts.u.derived->attr.is_bind_c))\n+\t    /* F2003: C717  */\n+\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n \t  else\n \t    res = gfc_trans_pointer_assign (code);\n \t  break;\n@@ -1544,7 +1550,7 @@ trans_code (gfc_code * code, tree cond)\n \t{\n \t  if (TREE_CODE (res) != STATEMENT_LIST)\n \t    SET_EXPR_LOCATION (res, input_location);\n-\t    \n+\n \t  /* Add the new statement to the block.  */\n \t  gfc_add_expr_to_block (&block, res);\n \t}\n@@ -1686,7 +1692,7 @@ gfc_finish_wrapped_block (gfc_wrapped_block* block)\n   if (block->cleanup)\n     result = build2_loc (input_location, TRY_FINALLY_EXPR, void_type_node,\n \t\t\t result, block->cleanup);\n-  \n+\n   /* Clear the block.  */\n   block->init = NULL_TREE;\n   block->code = NULL_TREE;"}, {"sha": "ce4f2870f0738d2c7d7530dc57c36edcdda64fb9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,3 +1,10 @@\n+2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/unlimited_polymorphic_1.f03: New test.\n+\t* gfortran.dg/unlimited_polymorphic_2.f03: New test.\n+\t* gfortran.dg/unlimited_polymorphic_3.f03: New test.\n+\t* gfortran.dg/same_type_as.f03: Correct for improved message.\n+\n 2012-12-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/vmaxnmdf.c: New test."}, {"sha": "3ff1e551ee520dc52da258f57aa973d9aee5d800", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_1.f03", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_1.f03?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -0,0 +1,211 @@\n+! { dg-do run }\r\n+!\r\n+! Basic tests of functionality of unlimited polymorphism\r\n+!\r\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\r\n+!\r\n+MODULE m\r\n+  TYPE :: a\r\n+    integer :: i\r\n+  END TYPE\r\n+\r\n+contains\r\n+  subroutine bar (arg, res)\r\n+    class(*) :: arg\r\n+    character(100) :: res\r\n+    select type (w => arg)\r\n+      type is (a)\r\n+        write (res, '(a, I4)') \"type(a)\", w%i\r\n+      type is (integer)\r\n+        write (res, '(a, I4)') \"integer\", w\r\n+      type is (real(4))\r\n+        write (res, '(a, F4.1)') \"real4\", w\r\n+      type is (real(8))\r\n+        write (res, '(a, F4.1)') \"real8\", w\r\n+      type is (character(*, kind = 4))\r\n+        call abort\r\n+      type is (character(*))\r\n+        write (res, '(a, I2, a, a)') \"char(\", LEN(w), \")\", trim(w)\r\n+    end select\r\n+  end subroutine\r\n+\r\n+  subroutine foo (arg, res)\r\n+    class(*) :: arg (:)\r\n+    character(100) :: res\r\n+    select type (w => arg)\r\n+      type is (a)\r\n+        write (res,'(a, 10I4)') \"type(a) array\", w%i\r\n+      type is (integer)\r\n+        write (res,'(a, 10I4)') \"integer array\", w\r\n+      type is (real)\r\n+        write (res,'(a, 10F4.1)') \"real array\", w\r\n+      type is (character(*))\r\n+        write (res, '(a5, I2, a, I2, a1, 2(a))') &\r\n+               \"char(\",len(w),\",\", size(w,1),\") array \", w\r\n+    end select\r\n+  end subroutine\r\n+END MODULE\r\n+\r\n+\r\n+  USE m\r\n+  TYPE(a), target :: obj1 = a(99)\r\n+  TYPE(a), target :: obj2(3) = a(999)\r\n+  integer, target :: obj3 = 999\r\n+  real(4), target :: obj4(4) = [(real(i), i = 1, 4)]\r\n+  integer, target :: obj5(3) = [(i*99, i = 1, 3)]\r\n+  class(*), pointer :: u1\r\n+  class(*), pointer :: u2(:)\r\n+  class(*), allocatable :: u3\r\n+  class(*), allocatable :: u4(:)\r\n+  type(a), pointer :: aptr(:)\r\n+  character(8) :: sun = \"sunshine\"\r\n+  character(100) :: res\r\n+\r\n+ ! NULL without MOLD used to cause segfault\r\n+  u2 => NULL()\r\n+  u2 => NULL(aptr)\r\n+\r\n+! Test pointing to derived types.\r\n+  u1 => obj1\r\n+  if (SAME_TYPE_AS (obj1, u1) .neqv. .TRUE.) call abort\r\n+  u2 => obj2\r\n+  call bar (u1, res)\r\n+  if (trim (res) .ne. \"type(a)  99\") call abort\r\n+\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"type(a) array 999 999 999\") call abort\r\n+\r\n+  if (SAME_TYPE_AS (obj1, u1) .neqv. .TRUE.) call abort\r\n+\r\n+! Check allocate with an array SOURCE.\r\n+  allocate (u2(5), source = [(a(i), i = 1,5)])\r\n+  if (SAME_TYPE_AS (u1, a(2)) .neqv. .TRUE.) call abort\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"type(a) array   1   2   3   4   5\") call abort\r\n+\r\n+  deallocate (u2)\r\n+\r\n+! Point to intrinsic targets.\r\n+  u1 => obj3\r\n+  call bar (u1, res)\r\n+  if (trim (res) .ne. \"integer 999\") call abort\r\n+\r\n+  u2 => obj4\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"real array 1.0 2.0 3.0 4.0\") call abort\r\n+\r\n+  u2 => obj5\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"integer array  99 198 297\") call abort\r\n+\r\n+! Test allocate with source.\r\n+  allocate (u1, source = sun)\r\n+  call bar (u1, res)\r\n+  if (trim (res) .ne. \"char( 8)sunshine\") call abort\r\n+  deallocate (u1)\r\n+\r\n+  allocate (u2(3), source = [7,8,9])\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"integer array   7   8   9\") call abort\r\n+\r\n+  deallocate (u2)\r\n+\r\n+  if (EXTENDS_TYPE_OF (obj1, u2) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u2, obj1) .neqv. .FALSE.) call abort\r\n+\r\n+  allocate (u2(3), source = [5.0,6.0,7.0])\r\n+  call foo (u2, res)\r\n+  if (trim (res) .ne. \"real array 5.0 6.0 7.0\") call abort\r\n+\r\n+  if (EXTENDS_TYPE_OF (obj1, u2) .neqv. .FALSE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u2, obj1) .neqv. .FALSE.) call abort\r\n+  deallocate (u2)\r\n+\r\n+! Check allocate with a MOLD tag.\r\n+  allocate (u2(3), mold = 8.0)\r\n+  call foo (u2, res)\r\n+  if (res(1:10) .ne. \"real array\") call abort\r\n+  deallocate (u2)\r\n+\r\n+! Test passing an intrinsic type to a CLASS(*) formal.\r\n+  call bar(1, res)\r\n+  if (trim (res) .ne. \"integer   1\") call abort\r\n+\r\n+  call bar(2.0, res)\r\n+  if (trim (res) .ne. \"real4 2.0\") call abort\r\n+\r\n+  call bar(2d0, res)\r\n+  if (trim (res) .ne. \"real8 2.0\") call abort\r\n+\r\n+  call bar(a(3), res)\r\n+  if (trim (res) .ne. \"type(a)   3\") call abort\r\n+\r\n+  call bar(sun, res)\r\n+  if (trim (res) .ne. \"char( 8)sunshine\") call abort\r\n+\r\n+  call bar (obj3, res)\r\n+  if (trim (res) .ne. \"integer 999\") call abort\r\n+\r\n+  call foo([4,5], res)\r\n+  if (trim (res) .ne. \"integer array   4   5\") call abort\r\n+\r\n+  call foo([6.0,7.0], res)\r\n+  if (trim (res) .ne. \"real array 6.0 7.0\") call abort\r\n+\r\n+  call foo([a(8),a(9)], res)\r\n+  if (trim (res) .ne. \"type(a) array   8   9\") call abort\r\n+\r\n+  call foo([sun, \" & rain\"], res)\r\n+  if (trim (res) .ne. \"char( 8, 2)sunshine & rain\") call abort\r\n+\r\n+  call foo([sun//\" never happens\", \" & rain always happens\"], res)\r\n+  if (trim (res) .ne. \"char(22, 2)sunshine never happens & rain always happens\") call abort\r\n+\r\n+  call foo (obj4, res)\r\n+  if (trim (res) .ne. \"real array 1.0 2.0 3.0 4.0\") call abort\r\n+\r\n+  call foo (obj5, res)\r\n+  if (trim (res) .ne. \"integer array  99 198 297\") call abort\r\n+\r\n+! Allocatable entities\r\n+  if (EXTENDS_TYPE_OF (obj1, u3) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u3, obj1) .neqv. .FALSE.) call abort\r\n+  if (EXTENDS_TYPE_OF (obj1, u4) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u4, obj1) .neqv. .FALSE.) call abort\r\n+\r\n+  allocate (u3, source = 2.4)\r\n+  call bar (u3, res)\r\n+  if (trim (res) .ne. \"real4 2.4\") call abort\r\n+\r\n+  allocate (u4(2), source = [a(88), a(99)])\r\n+  call foo (u4, res)\r\n+  if (trim (res) .ne. \"type(a) array  88  99\") call abort\r\n+\r\n+  if (EXTENDS_TYPE_OF (obj1, u3) .neqv. .FALSE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u3, obj1) .neqv. .FALSE.) call abort\r\n+\r\n+  deallocate (u3)\r\n+  if (EXTENDS_TYPE_OF (obj1, u3) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u3, obj1) .neqv. .FALSE.) call abort\r\n+\r\n+  if (EXTENDS_TYPE_OF (obj1, u4) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u4, obj1) .neqv. .TRUE.) call abort\r\n+  deallocate (u4)\r\n+  if (EXTENDS_TYPE_OF (obj1, u4) .neqv. .TRUE.) call abort\r\n+  if (EXTENDS_TYPE_OF (u4, obj1) .neqv. .FALSE.) call abort\r\n+\r\n+\r\n+! Check assumed rank calls\r\n+  call foobar (u3, 0)\r\n+  call foobar (u4, 1)\r\n+contains\r\n+\r\n+  subroutine foobar (arg, ranki)\r\n+    class(*) :: arg (..)\r\n+    integer :: ranki\r\n+    integer i\r\n+    i = rank (arg)\r\n+    if (i .ne. ranki) call abort\r\n+  end subroutine\r\n+\r\n+END\r"}, {"sha": "7c05c84561678afa9a841b7e52cdf1f4edcdca3e", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do compile }\r\n+!\r\n+! Test the most important constraints unlimited polymorphic entities\r\n+!\r\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\r\n+!            and Tobias Burnus <burnus@gcc.gnu.org>\r\n+!\r\n+  CHARACTER(:), allocatable, target :: chr ! { dg-error \"TODO: Deferred character length variable\" }\r\n+! F2008: C5100\r\n+  integer :: i(2)\r\n+  logical :: flag\r\n+  class(*), pointer :: u1, u2(:) ! { dg-error \"cannot appear in COMMON\" }\r\n+  common u1\r\n+  u1 => chr\r\n+! F2003: C625\r\n+  allocate (u1) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\r\n+  allocate (u1, mold = 1.0) ! { dg-error \"requires either a type-spec or SOURCE tag\" }\r\n+  allocate (real :: u1)\r\n+  Allocate (u1, source = 1.0)\r\n+\r\n+! F2008: C4106\r\n+  u2 = [u1] ! { dg-error \"shall not be unlimited polymorphic\" }\r\n+\r\n+  i = u2 ! { dg-error \"Can\\\\'t convert CLASS\\\\(\\\\*\\\\)\" }\r\n+\r\n+! Repeats same_type_as_1.f03 for unlimited polymorphic u2\r\n+  flag = same_type_as (i, u2) ! { dg-error \"cannot be of type INTEGER\" }\r\n+  flag = extends_type_of (i, u2) ! { dg-error \"cannot be of type INTEGER\" }\r\n+\r\n+contains\r\n+\r\n+! C717 (R735) If data-target is unlimited polymorphic,\r\n+! data-pointer-object shall be unlimited polymorphic, of a sequence\r\n+! derived type, or of a type with the BIND attribute.\r\n+!\r\n+  subroutine bar\r\n+\r\n+    type sq\r\n+      sequence\r\n+      integer :: i\r\n+    end type sq\r\n+\r\n+    type(sq), target :: x\r\n+    class(*), pointer :: y\r\n+    integer, pointer :: tgt\r\n+\r\n+    x%i = 42\r\n+    y => x\r\n+    call foo (y)\r\n+\r\n+    y => tgt ! This is OK, of course.\r\n+    tgt => y ! { dg-error \"must be unlimited polymorphic\" }\r\n+\r\n+    select type (y) ! This is the correct way to accomplish the previous\r\n+      type is (integer)\r\n+        tgt => y\r\n+    end select\r\n+\r\n+  end subroutine bar\r\n+\r\n+\r\n+  subroutine foo(tgt)\r\n+    class(*), pointer, intent(in) :: tgt\r\n+    type t\r\n+      sequence\r\n+      integer :: k\r\n+    end type t\r\n+\r\n+    type(t), pointer :: ptr\r\n+\r\n+    ptr => tgt ! C717 allows this.\r\n+\r\n+    select type (tgt)\r\n+! F03:C815 or F08:C839\r\n+      type is (t) ! { dg-error \"shall not specify a sequence derived type\" }\r\n+        ptr => tgt ! { dg-error \"Expected TYPE IS\" }\r\n+    end select\r\n+\r\n+    print *, ptr%k\r\n+  end subroutine foo\r\n+END\r"}, {"sha": "5ed98974d7c1ec87eef4c06d2e5d8e0ae8f6a540", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_3.f03", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_3.f03?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+!\n+! Check that pointer assignments allowed by F2003:C717\n+! work and check null initialization of CLASS(*) pointers.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+program main\n+  interface\n+    subroutine foo(z)\n+      class(*), pointer, intent(in) :: z\n+    end subroutine foo\n+  end interface\n+  type sq\n+    sequence\n+    integer :: i\n+  end type sq\n+  type(sq), target :: x\n+  class(*), pointer :: y, z\n+  x%i = 42\n+  y => x\n+  z => y ! unlimited => unlimited allowed\n+  call foo (z)\n+  call bar\n+contains\n+  subroutine bar\n+    type t\n+    end type t\n+    type(t), pointer :: x\n+    class(*), pointer :: ptr1 => null() ! pointer initialization\n+    class(*), pointer :: ptr2 => null(x) ! pointer initialization\n+    if (same_type_as (ptr1, x) .neqv. .FALSE.) call abort\n+    if (same_type_as (ptr2, x) .neqv. .TRUE.) call abort\n+  end subroutine bar\n+\n+end program main\n+\n+\n+subroutine foo(tgt)\n+  use iso_c_binding\n+  class(*), pointer, intent(in) :: tgt\n+  type, bind(c) :: s\n+    integer (c_int) :: k\n+  end type s\n+  type t\n+    sequence\n+    integer :: k\n+  end type t\n+  type(s), pointer :: ptr1\n+  type(t), pointer :: ptr2\n+  ptr1 => tgt ! bind(c) => unlimited allowed\n+  if (ptr1%k .ne. 42) call abort\n+  ptr2 => tgt ! sequence type => unlimited allowed\n+  if (ptr2%k .ne. 42) call abort\n+end subroutine foo"}, {"sha": "bea7c72970cea427315018d5c3a6d3a7dd5a8eac", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -1,3 +1,8 @@\n+2012-12-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* intrinsics/extends_type_of.c : Return correct results for\n+\tnull vptrs.\n+\n 2012-12-03  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/55548"}, {"sha": "8f8b5a9f7d1978ee996013429bc6239079b09d05", "filename": "libgfortran/intrinsics/extends_type_of.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7043164fac12e4acf3aa25afaba15510e5b1c7/libgfortran%2Fintrinsics%2Fextends_type_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7043164fac12e4acf3aa25afaba15510e5b1c7/libgfortran%2Fintrinsics%2Fextends_type_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fextends_type_of.c?ref=8b7043164fac12e4acf3aa25afaba15510e5b1c7", "patch": "@@ -49,6 +49,14 @@ export_proto(is_extension_of);\n GFC_LOGICAL_4\n is_extension_of (struct vtype *v1, struct vtype *v2)\n {\n+  /* Assume that only unlimited polymorphic entities will pass NULL v1 or v2\n+     if they are unallocated or disassociated.  */\n+\n+  if (!v2)\n+    return 1;\n+  if (!v1)\n+    return 0;\n+\n   while (v1)\n     {\n       if (v1->hash == v2->hash) return 1;"}]}