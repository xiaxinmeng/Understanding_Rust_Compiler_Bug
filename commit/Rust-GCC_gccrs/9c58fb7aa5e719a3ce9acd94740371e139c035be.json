{"sha": "9c58fb7aa5e719a3ce9acd94740371e139c035be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM1OGZiN2FhNWU3MTlhM2NlOWFjZDk0NzQwMzcxZTEzOWMwMzViZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-03T10:04:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-03T10:04:20Z"}, "message": "Ensure PATTERN_DEF_SEQ is empty before recognising patterns\n\nVarious recognisers set PATTERN_DEF_SEQ to null before adding\nstatements to it, but it should always be null at that point anyway.\nThis patch asserts for that in vect_pattern_recog_1 and removes\nthe redundant code.\n\n2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (new_pattern_def_seq): Delete.\n\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n\t(vect_recog_widen_op_pattern, vect_recog_over_widening_pattern)\n\t(vect_recog_rotate_pattern, vect_synth_mult_by_constant): Don't set\n\tSTMT_VINFO_PATTERN_DEF_SEQ to null here.\n\t(vect_recog_pow_pattern, vect_recog_vector_vector_shift_pattern)\n\t(vect_recog_mixed_size_cond_pattern, vect_recog_bool_pattern): Use\n\tappend_pattern_def_seq instead of new_pattern_def_seq.\n\t(vect_recog_divmod_pattern): Do both of the above.\n\t(vect_pattern_recog_1): Assert that STMT_VINO_PATTERN_DEF_SEQ\n\tis null.\n\nFrom-SVN: r262337", "tree": {"sha": "f1957e6b11012f7e10d291c37bd43bfd7908525f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1957e6b11012f7e10d291c37bd43bfd7908525f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c58fb7aa5e719a3ce9acd94740371e139c035be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c58fb7aa5e719a3ce9acd94740371e139c035be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c58fb7aa5e719a3ce9acd94740371e139c035be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c58fb7aa5e719a3ce9acd94740371e139c035be/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9728b0349aa6dbfae020b283ed8ca9f073bf1f"}], "stats": {"total": 43, "additions": 21, "deletions": 22}, "files": [{"sha": "487def02afce904d9f18eed0c0e302f1916a948b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c58fb7aa5e719a3ce9acd94740371e139c035be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c58fb7aa5e719a3ce9acd94740371e139c035be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9c58fb7aa5e719a3ce9acd94740371e139c035be", "patch": "@@ -1,3 +1,17 @@\n+2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (new_pattern_def_seq): Delete.\n+\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n+\t(vect_recog_widen_op_pattern, vect_recog_over_widening_pattern)\n+\t(vect_recog_rotate_pattern, vect_synth_mult_by_constant): Don't set\n+\tSTMT_VINFO_PATTERN_DEF_SEQ to null here.\n+\t(vect_recog_pow_pattern, vect_recog_vector_vector_shift_pattern)\n+\t(vect_recog_mixed_size_cond_pattern, vect_recog_bool_pattern): Use\n+\tappend_pattern_def_seq instead of new_pattern_def_seq.\n+\t(vect_recog_divmod_pattern): Do both of the above.\n+\t(vect_pattern_recog_1): Assert that STMT_VINO_PATTERN_DEF_SEQ\n+\tis null.\n+\n 2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_recog_dot_prod_pattern):"}, {"sha": "fbcfa29b0f56f5cdb6666f8bc8eb15610f84a94f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c58fb7aa5e719a3ce9acd94740371e139c035be/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c58fb7aa5e719a3ce9acd94740371e139c035be/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=9c58fb7aa5e719a3ce9acd94740371e139c035be", "patch": "@@ -150,13 +150,6 @@ append_pattern_def_seq (stmt_vec_info stmt_info, gimple *new_stmt,\n \t\t\t\t      new_stmt);\n }\n \n-static inline void\n-new_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n-{\n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_info) = NULL;\n-  append_pattern_def_seq (stmt_info, stmt);\n-}\n-\n /* The caller wants to perform new operations on vect_external variable\n    VAR, so that the result of the operations would also be vect_external.\n    Return the edge on which the operations can be performed, if one exists.\n@@ -983,7 +976,6 @@ vect_recog_dot_prod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n     return NULL;\n \n   /* Get the inputs in the appropriate types.  */\n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n   tree mult_oprnd[2];\n   vect_convert_inputs (stmt_vinfo, 2, mult_oprnd, half_type,\n \t\t       unprom0, half_vectype);\n@@ -1142,7 +1134,6 @@ vect_recog_sad_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n     return NULL;\n \n   /* Get the inputs to the SAD_EXPR in the appropriate types.  */\n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n   tree sad_oprnd[2];\n   vect_convert_inputs (stmt_vinfo, 2, sad_oprnd, half_type,\n \t\t       unprom, half_vectype);\n@@ -1220,7 +1211,6 @@ vect_recog_widen_op_pattern (stmt_vec_info last_stmt_info, tree *type_out,\n   if (!*type_out)\n     return NULL;\n \n-  STMT_VINFO_PATTERN_DEF_SEQ (last_stmt_info) = NULL;\n   tree oprnd[2];\n   vect_convert_inputs (last_stmt_info, 2, oprnd, half_type, unprom, vectype);\n \n@@ -1342,7 +1332,7 @@ vect_recog_pow_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t\treturn NULL;\n \t      tree def = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n \t      gimple *g = gimple_build_assign (def, MULT_EXPR, exp, logc);\n-\t      new_pattern_def_seq (stmt_vinfo, g);\n+\t      append_pattern_def_seq (stmt_vinfo, g);\n \t      tree res = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n \t      g = gimple_build_call (exp_decl, 1, def);\n \t      gimple_call_set_lhs (g, res);\n@@ -1687,7 +1677,6 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n     }\n \n   /* Calculate the rhs operands for an operation on NEW_TYPE.  */\n-  STMT_VINFO_PATTERN_DEF_SEQ (last_stmt_info) = NULL;\n   tree ops[3] = {};\n   for (unsigned int i = 1; i < first_op; ++i)\n     ops[i - 1] = gimple_op (last_stmt, i);\n@@ -2073,7 +2062,6 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \tdef = rhs1;\n     }\n \n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n   if (def == NULL_TREE)\n     {\n       def = vect_recog_temp_ssa_var (type, NULL);\n@@ -2269,7 +2257,7 @@ vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n \t      set_vinfo_for_stmt (def_stmt, new_stmt_info);\n \t      STMT_VINFO_VECTYPE (new_stmt_info)\n \t\t= get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n-\t      new_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t    }\n \t}\n     }\n@@ -2278,7 +2266,7 @@ vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n     {\n       def = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n       def_stmt = gimple_build_assign (def, NOP_EXPR, oprnd1);\n-      new_pattern_def_seq (stmt_vinfo, def_stmt);\n+      append_pattern_def_seq (stmt_vinfo, def_stmt);\n     }\n \n   /* Pattern detected.  */\n@@ -2472,7 +2460,6 @@ vect_synth_mult_by_constant (tree op, tree val,\n   tree accumulator;\n \n   /* Clear out the sequence of statements so we can populate it below.  */\n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n   gimple *stmt = NULL;\n \n   if (cast_to_unsigned_p)\n@@ -2769,7 +2756,7 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t\t\t\t   fold_build2 (MINUS_EXPR, itype, oprnd1,\n \t\t\t\t\t\tbuild_int_cst (itype, 1)),\n \t\t\t\t   build_int_cst (itype, 0));\n-\t  new_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n \t  var = vect_recog_temp_ssa_var (itype, NULL);\n \t  def_stmt\n \t    = gimple_build_assign (var, PLUS_EXPR, oprnd0,\n@@ -2784,7 +2771,6 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       else\n \t{\n \t  tree signmask;\n-\t  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n \t  if (compare_tree_int (oprnd1, 2) == 0)\n \t    {\n \t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n@@ -2851,8 +2837,6 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   if (!can_mult_highpart_p (TYPE_MODE (vectype), TYPE_UNSIGNED (itype)))\n     return NULL;\n \n-  STMT_VINFO_PATTERN_DEF_SEQ (stmt_vinfo) = NULL;\n-\n   if (TYPE_UNSIGNED (itype))\n     {\n       unsigned HOST_WIDE_INT mh, ml;\n@@ -3234,7 +3218,7 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n \t\t\t\t      NOP_EXPR, gimple_assign_lhs (def_stmt));\n \n-  new_pattern_def_seq (stmt_vinfo, def_stmt);\n+  append_pattern_def_seq (stmt_vinfo, def_stmt);\n   def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n   set_vinfo_for_stmt (def_stmt, def_stmt_info);\n   STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n@@ -3796,7 +3780,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t      new_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n \t      set_vinfo_for_stmt (pattern_stmt, new_stmt_info);\n \t      STMT_VINFO_VECTYPE (new_stmt_info) = new_vectype;\n-\t      new_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t      append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n \n \t      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n \t      pattern_stmt = gimple_build_assign (lhs, CONVERT_EXPR, tmp);\n@@ -4899,6 +4883,7 @@ vect_pattern_recog_1 (vect_recog_func *recog_func, gimple_stmt_iterator si)\n       return;\n     }\n \n+  gcc_assert (!STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n   pattern_stmt = recog_func->fn (stmt_info, &pattern_vectype);\n   if (!pattern_stmt)\n     {"}]}