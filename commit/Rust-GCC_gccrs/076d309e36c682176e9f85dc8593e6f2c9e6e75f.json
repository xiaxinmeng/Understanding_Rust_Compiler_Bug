{"sha": "076d309e36c682176e9f85dc8593e6f2c9e6e75f", "node_id": "C_kwDOANBUbNoAKDA3NmQzMDllMzZjNjgyMTc2ZTlmODVkYzg1OTNlNmYyYzllNmU3NWY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-03-02T16:39:50Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2023-03-02T16:39:50Z"}, "message": "vect: Don't apply masks to operations on invariants [PR108979]\n\nThe loop body in the testcase contains an operation on invariants.\nSLP detects this and can hoist/schedule the operation outside of\nthe loop.  However, after the fix for PR96373, we would try to\napply a loop mask to this operation, even though the mask is\ndefined in the loop.\n\nThe patch does what Richi suggested in the PR: suppress the\nmasking for externs and constants.\n\ngcc/\n\tPR tree-optimization/108979\n\t* tree-vect-stmts.cc (vectorizable_operation): Don't mask\n\toperations on invariants.\n\ngcc/testsuite/\n\tPR tree-optimization/108979\n\t* gfortran.dg/vect/pr108979.f90: New test.", "tree": {"sha": "c49d151b052b7ca152dd38b20b3927d5fe2def20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c49d151b052b7ca152dd38b20b3927d5fe2def20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/076d309e36c682176e9f85dc8593e6f2c9e6e75f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076d309e36c682176e9f85dc8593e6f2c9e6e75f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076d309e36c682176e9f85dc8593e6f2c9e6e75f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076d309e36c682176e9f85dc8593e6f2c9e6e75f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71afd0628419c5d670701cb35bc9860380c7d9fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71afd0628419c5d670701cb35bc9860380c7d9fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71afd0628419c5d670701cb35bc9860380c7d9fb"}], "stats": {"total": 46, "additions": 40, "deletions": 6}, "files": [{"sha": "623eb67826f72198a0ca4b50def95afdaf7d917f", "filename": "gcc/testsuite/gfortran.dg/vect/pr108979.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076d309e36c682176e9f85dc8593e6f2c9e6e75f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr108979.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076d309e36c682176e9f85dc8593e6f2c9e6e75f/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr108979.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr108979.f90?ref=076d309e36c682176e9f85dc8593e6f2c9e6e75f", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fnon-call-exceptions\" }\n+! { dg-additional-options \"-march=armv8.2-a+sve\" { target aarch64*-*-* } }\n+\n+MODULE hfx_contract_block\n+  INTEGER, PARAMETER :: dp=8\n+CONTAINS\n+  SUBROUTINE block_2_1_2_1(kbd,kbc,kad,kac,pbd,pbc,pad,pac,prim,scale)\n+    REAL(KIND=dp) :: kbd(1*1), kbc(1*2), kad(2*1), kac(2*2), pbd(1*1), &\n+      pbc(1*2), pad(2*1), pac(2*2), prim(2*1*2*1), scale\n+      DO md = 1,1\n+        DO mc = 1,2\n+          DO mb = 1,1\n+            DO ma = 1,2\n+              kac((mc-1)*2+ma) = kac((mc-1)*2+ma)-tmp*p_bd\n+            END DO\n+          END DO\n+        END DO\n+      END DO\n+  END SUBROUTINE block_2_1_2_1\n+END MODULE hfx_contract_block"}, {"sha": "b56457617c09d811633acb384e772e70fdc59216", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076d309e36c682176e9f85dc8593e6f2c9e6e75f/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076d309e36c682176e9f85dc8593e6f2c9e6e75f/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=076d309e36c682176e9f85dc8593e6f2c9e6e75f", "patch": "@@ -6254,6 +6254,8 @@ vectorizable_operation (vec_info *vinfo,\n                          \"use not simple.\\n\");\n       return false;\n     }\n+  bool is_invariant = (dt[0] == vect_external_def\n+\t\t       || dt[0] == vect_constant_def);\n   /* If op0 is an external or constant def, infer the vector type\n      from the scalar type.  */\n   if (!vectype)\n@@ -6307,6 +6309,8 @@ vectorizable_operation (vec_info *vinfo,\n                              \"use not simple.\\n\");\n \t  return false;\n \t}\n+      is_invariant &= (dt[1] == vect_external_def\n+\t\t       || dt[1] == vect_constant_def);\n       if (vectype2\n \t  && maybe_ne (nunits_out, TYPE_VECTOR_SUBPARTS (vectype2)))\n \treturn false;\n@@ -6321,6 +6325,8 @@ vectorizable_operation (vec_info *vinfo,\n                              \"use not simple.\\n\");\n \t  return false;\n \t}\n+      is_invariant &= (dt[2] == vect_external_def\n+\t\t       || dt[2] == vect_constant_def);\n       if (vectype3\n \t  && maybe_ne (nunits_out, TYPE_VECTOR_SUBPARTS (vectype3)))\n \treturn false;\n@@ -6426,16 +6432,23 @@ vectorizable_operation (vec_info *vinfo,\n   int reduc_idx = STMT_VINFO_REDUC_IDX (stmt_info);\n   vec_loop_masks *masks = (loop_vinfo ? &LOOP_VINFO_MASKS (loop_vinfo) : NULL);\n   internal_fn cond_fn = get_conditional_internal_fn (code);\n-  bool could_trap = gimple_could_trap_p (stmt);\n+\n+  /* If operating on inactive elements could generate spurious traps,\n+     we need to restrict the operation to active lanes.  Note that this\n+     specifically doesn't apply to unhoisted invariants, since they\n+     operate on the same value for every lane.\n+\n+     Similarly, if this operation is part of a reduction, a fully-masked\n+     loop should only change the active lanes of the reduction chain,\n+     keeping the inactive lanes as-is.  */\n+  bool mask_out_inactive = ((!is_invariant && gimple_could_trap_p (stmt))\n+\t\t\t    || reduc_idx >= 0);\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n-      /* If this operation is part of a reduction, a fully-masked loop\n-\t should only change the active lanes of the reduction chain,\n-\t keeping the inactive lanes as-is.  */\n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n-\t  && (could_trap || reduc_idx >= 0))\n+\t  && mask_out_inactive)\n \t{\n \t  if (cond_fn == IFN_LAST\n \t      || !direct_internal_fn_supported_p (cond_fn, vectype,\n@@ -6578,7 +6591,7 @@ vectorizable_operation (vec_info *vinfo,\n       vop1 = ((op_type == binary_op || op_type == ternary_op)\n \t      ? vec_oprnds1[i] : NULL_TREE);\n       vop2 = ((op_type == ternary_op) ? vec_oprnds2[i] : NULL_TREE);\n-      if (masked_loop_p && (reduc_idx >= 0 || could_trap))\n+      if (masked_loop_p && mask_out_inactive)\n \t{\n \t  tree mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n \t\t\t\t\t  vectype, i);"}]}