{"sha": "c7be0832b54669b39dfb56bd91c783dd91aad766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiZTA4MzJiNTQ2NjliMzlkZmI1NmJkOTFjNzgzZGQ5MWFhZDc2Ng==", "commit": {"author": {"name": "Srinath Parvathaneni", "email": "srinath.parvathaneni@arm.com", "date": "2020-03-16T17:22:39Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-03-16T17:23:40Z"}, "message": "[ARM][GCC][2/x]: MVE ACLE intrinsics framework patch.\n\nThis patch is part of MVE ACLE intrinsics framework.\nThis patches add support to update (read/write) the APSR (Application Program Status Register)\nregister and FPSCR (Floating-point Status and Control Register) register for MVE.\nThis patch also enables thumb2 mov RTL patterns for MVE.\n\nA new feature bit vfp_base is added. This bit is enabled for all VFP, MVE and MVE with floating point\nextensions. This bit is used to enable the macro TARGET_VFP_BASE. For all the VFP instructions, RTL patterns,\nstatus and control registers are guarded by TARGET_HAVE_FLOAT. But this patch modifies that and the\ncommon instructions, RTL patterns, status and control registers bewteen MVE and VFP are guarded by\nTARGET_VFP_BASE macro.\n\nThe RTL pattern set_fpscr and get_fpscr are updated to use VFPCC_REGNUM because few MVE intrinsics\nset/get carry bit of FPSCR register.\n\nPlease refer to Arm reference manual [1] for more details.\n[1] https://developer.arm.com/docs/ddi0553/latest\n\n2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Mihail Ionescu  <mihail.ionescu@arm.com>\n\t    Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* common/config/arm/arm-common.c (arm_asm_auto_mfpu): When vfp_base\n\tfeature bit is on and -mfpu=auto is passed as compiler option, do not\n\tgenerate error on not finding any matching fpu. Because in this case\n\tfpu is not required.\n\t* config/arm/arm-cpus.in (vfp_base): Define feature bit, this bit is\n\tenabled for MVE and also for all VFP extensions.\n\t(VFPv2): Modify fgroup to enable vfp_base feature bit when ever VFPv2\n\tis enabled.\n\t(MVE): Define fgroup to enable feature bits mve, vfp_base and armv7em.\n\t(MVE_FP): Define fgroup to enable feature bits is fgroup MVE and FPv5\n\talong with feature bits mve_float.\n\t(mve): Modify add options in armv8.1-m.main arch for MVE.\n\t(mve.fp): Modify add options in armv8.1-m.main arch for MVE with\n\tfloating point.\n\t* config/arm/arm.c (use_return_insn): Replace the\n\tcheck with TARGET_VFP_BASE.\n\t(thumb2_legitimate_index_p): Replace TARGET_HARD_FLOAT with\n\tTARGET_VFP_BASE.\n\t(arm_rtx_costs_internal): Replace \"TARGET_HARD_FLOAT || TARGET_HAVE_MVE\"\n\twith TARGET_VFP_BASE, to allow cost calculations for copies in MVE as\n\twell.\n\t(arm_get_vfp_saved_size): Replace TARGET_HARD_FLOAT with\n\tTARGET_VFP_BASE, to allow space calculation for VFP registers in MVE\n\tas well.\n\t(arm_compute_frame_layout): Likewise.\n\t(arm_save_coproc_regs): Likewise.\n\t(arm_fixed_condition_code_regs): Modify to enable using VFPCC_REGNUM\n\tin MVE as well.\n\t(arm_hard_regno_mode_ok): Replace \"TARGET_HARD_FLOAT || TARGET_HAVE_MVE\"\n\twith equivalent macro TARGET_VFP_BASE.\n\t(arm_expand_epilogue_apcs_frame): Likewise.\n\t(arm_expand_epilogue): Likewise.\n\t(arm_conditional_register_usage): Likewise.\n\t(arm_declare_function_name): Add check to skip printing .fpu directive\n\tin assembly file when TARGET_VFP_BASE is enabled and fpu_to_print is\n\t\"softvfp\".\n\t* config/arm/arm.h (TARGET_VFP_BASE): Define.\n\t* config/arm/arm.md (arch): Add \"mve\" to arch.\n\t(eq_attr \"arch\" \"mve\"): Enable on TARGET_HAVE_MVE is true.\n\t(vfp_pop_multiple_with_writeback): Replace \"TARGET_HARD_FLOAT\n\t|| TARGET_HAVE_MVE\" with equivalent macro TARGET_VFP_BASE.\n\t* config/arm/constraints.md (Uf): Define to allow modification to FPCCR\n\tin MVE.\n\t* config/arm/thumb2.md (thumb2_movsfcc_soft_insn): Modify target guard\n\tto not allow for MVE.\n\t* config/arm/unspecs.md (UNSPEC_GET_FPSCR): Move to volatile unspecs\n\tenum.\n\t(VUNSPEC_GET_FPSCR): Define.\n\t* config/arm/vfp.md (thumb2_movhi_vfp): Add support for VMSR and VMRS\n\tinstructions which move to general-purpose Register from Floating-point\n\tSpecial register and vice-versa.\n\t(thumb2_movhi_fp16): Likewise.\n\t(thumb2_movsi_vfp): Add support for VMSR and VMRS instructions along\n\twith MCR and MRC instructions which set and get Floating-point Status\n\tand Control Register (FPSCR).\n\t(movdi_vfp): Modify pattern to enable Single-precision scalar float move\n\tin MVE.\n\t(thumb2_movdf_vfp): Modify pattern to enable Double-precision scalar\n\tfloat move patterns in MVE.\n\t(thumb2_movsfcc_vfp): Modify pattern to enable single float conditional\n\tcode move patterns of VFP also in MVE by adding TARGET_VFP_BASE check.\n\t(thumb2_movdfcc_vfp): Modify pattern to enable double float conditional\n\tcode move patterns of VFP also in MVE by adding TARGET_VFP_BASE check.\n\t(push_multi_vfp): Add support to use VFP VPUSH pattern for MVE by adding\n\tTARGET_VFP_BASE check.\n\t(set_fpscr): Add support to set FPSCR register for MVE. Modify pattern\n\tusing VFPCC_REGNUM as few MVE intrinsics use carry bit of FPSCR\n\tregister.\n\t(get_fpscr): Add support to get FPSCR register for MVE. Modify pattern\n\t\tusing VFPCC_REGNUM as few MVE intrinsics use carry bit of FPSCR\n\tregister.\n\n2020-03-16  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* gcc.target/arm/mve/intrinsics/mve_fp_fpu1.c: New test.\n\t* gcc.target/arm/mve/intrinsics/mve_fp_fpu2.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_fpu1.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_fpu2.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_fpu3.c: Likewise.", "tree": {"sha": "9200d0b79eb6023ba2d387467c5f0e2a75c03e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9200d0b79eb6023ba2d387467c5f0e2a75c03e08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7be0832b54669b39dfb56bd91c783dd91aad766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7be0832b54669b39dfb56bd91c783dd91aad766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7be0832b54669b39dfb56bd91c783dd91aad766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7be0832b54669b39dfb56bd91c783dd91aad766/comments", "author": {"login": "sripar01", "id": 115715849, "node_id": "U_kgDOBuWvCQ", "avatar_url": "https://avatars.githubusercontent.com/u/115715849?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sripar01", "html_url": "https://github.com/sripar01", "followers_url": "https://api.github.com/users/sripar01/followers", "following_url": "https://api.github.com/users/sripar01/following{/other_user}", "gists_url": "https://api.github.com/users/sripar01/gists{/gist_id}", "starred_url": "https://api.github.com/users/sripar01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sripar01/subscriptions", "organizations_url": "https://api.github.com/users/sripar01/orgs", "repos_url": "https://api.github.com/users/sripar01/repos", "events_url": "https://api.github.com/users/sripar01/events{/privacy}", "received_events_url": "https://api.github.com/users/sripar01/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63c8f7d6a082b1cd0519fe06d4ed506b04280921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c8f7d6a082b1cd0519fe06d4ed506b04280921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63c8f7d6a082b1cd0519fe06d4ed506b04280921"}], "stats": {"total": 359, "additions": 287, "deletions": 72}, "files": [{"sha": "ec4e4e75d786181c0d60e5406cc11ea7f2e5ea7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -1,3 +1,80 @@\n+2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+            Mihail Ionescu  <mihail.ionescu@arm.com>\n+            Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* common/config/arm/arm-common.c (arm_asm_auto_mfpu): When vfp_base\n+\tfeature bit is on and -mfpu=auto is passed as compiler option, do not\n+\tgenerate error on not finding any matching fpu. Because in this case\n+\tfpu is not required.\n+\t* config/arm/arm-cpus.in (vfp_base): Define feature bit, this bit is\n+\tenabled for MVE and also for all VFP extensions.\n+\t(VFPv2): Modify fgroup to enable vfp_base feature bit when ever VFPv2\n+\tis enabled.\n+\t(MVE): Define fgroup to enable feature bits mve, vfp_base and armv7em.\n+\t(MVE_FP): Define fgroup to enable feature bits is fgroup MVE and FPv5\n+\talong with feature bits mve_float.\n+\t(mve): Modify add options in armv8.1-m.main arch for MVE.\n+\t(mve.fp): Modify add options in armv8.1-m.main arch for MVE with\n+\tfloating point.\n+\t* config/arm/arm.c (use_return_insn): Replace the\n+\tcheck with TARGET_VFP_BASE.\n+\t(thumb2_legitimate_index_p): Replace TARGET_HARD_FLOAT with\n+\tTARGET_VFP_BASE.\n+\t(arm_rtx_costs_internal): Replace \"TARGET_HARD_FLOAT || TARGET_HAVE_MVE\"\n+\twith TARGET_VFP_BASE, to allow cost calculations for copies in MVE as\n+\twell.\n+\t(arm_get_vfp_saved_size): Replace TARGET_HARD_FLOAT with\n+\tTARGET_VFP_BASE, to allow space calculation for VFP registers in MVE\n+\tas well.\n+\t(arm_compute_frame_layout): Likewise.\n+\t(arm_save_coproc_regs): Likewise.\n+\t(arm_fixed_condition_code_regs): Modify to enable using VFPCC_REGNUM\n+\tin MVE as well.\n+\t(arm_hard_regno_mode_ok): Replace \"TARGET_HARD_FLOAT || TARGET_HAVE_MVE\"\n+\twith equivalent macro TARGET_VFP_BASE.\n+\t(arm_expand_epilogue_apcs_frame): Likewise.\n+\t(arm_expand_epilogue): Likewise.\n+\t(arm_conditional_register_usage): Likewise.\n+\t(arm_declare_function_name): Add check to skip printing .fpu directive\n+\tin assembly file when TARGET_VFP_BASE is enabled and fpu_to_print is\n+\t\"softvfp\".\n+\t* config/arm/arm.h (TARGET_VFP_BASE): Define.\n+\t* config/arm/arm.md (arch): Add \"mve\" to arch.\n+\t(eq_attr \"arch\" \"mve\"): Enable on TARGET_HAVE_MVE is true.\n+\t(vfp_pop_multiple_with_writeback): Replace \"TARGET_HARD_FLOAT\n+\t|| TARGET_HAVE_MVE\" with equivalent macro TARGET_VFP_BASE.\n+\t* config/arm/constraints.md (Uf): Define to allow modification to FPCCR\n+\tin MVE.\n+\t* config/arm/thumb2.md (thumb2_movsfcc_soft_insn): Modify target guard\n+\tto not allow for MVE.\n+\t* config/arm/unspecs.md (UNSPEC_GET_FPSCR): Move to volatile unspecs\n+\tenum.\n+\t(VUNSPEC_GET_FPSCR): Define.\n+\t* config/arm/vfp.md (thumb2_movhi_vfp): Add support for VMSR and VMRS\n+\tinstructions which move to general-purpose Register from Floating-point\n+\tSpecial register and vice-versa.\n+\t(thumb2_movhi_fp16): Likewise.\n+\t(thumb2_movsi_vfp): Add support for VMSR and VMRS instructions along\n+\twith MCR and MRC instructions which set and get Floating-point Status\n+\tand Control Register (FPSCR).\n+\t(movdi_vfp): Modify pattern to enable Single-precision scalar float move\n+\tin MVE.\n+\t(thumb2_movdf_vfp): Modify pattern to enable Double-precision scalar\n+\tfloat move patterns in MVE.\n+\t(thumb2_movsfcc_vfp): Modify pattern to enable single float conditional\n+\tcode move patterns of VFP also in MVE by adding TARGET_VFP_BASE check.\n+\t(thumb2_movdfcc_vfp): Modify pattern to enable double float conditional\n+\tcode move patterns of VFP also in MVE by adding TARGET_VFP_BASE check.\n+\t(push_multi_vfp): Add support to use VFP VPUSH pattern for MVE by adding\n+\tTARGET_VFP_BASE check.\n+\t(set_fpscr): Add support to set FPSCR register for MVE. Modify pattern\n+\tusing VFPCC_REGNUM as few MVE intrinsics use carry bit of FPSCR\n+\tregister.\n+\t(get_fpscr): Add support to get FPSCR register for MVE. Modify pattern\n+\tusing VFPCC_REGNUM as few MVE intrinsics use carry bit of FPSCR\n+\tregister.\n+\n+\n 2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n             Mihail Ionescu  <mihail.ionescu@arm.com>\n             Srinath Parvathaneni  <srinath.parvathaneni@arm.com>"}, {"sha": "78a779c935071c534a780821d399cb7d2e170808", "filename": "gcc/common/config/arm/arm-common.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -1009,7 +1009,8 @@ arm_asm_auto_mfpu (int argc, const char **argv)\n \t    }\n \t}\n \n-      gcc_assert (i != TARGET_FPU_auto);\n+      gcc_assert (i != TARGET_FPU_auto\n+\t\t  || bitmap_bit_p (target_isa, isa_bit_vfp_base));\n     }\n \n   auto_fpu = (char *) xmalloc (strlen (fpuname) + sizeof (\"-mfpu=\"));"}, {"sha": "77b43090d69a599d8806cfcc02037e1bbed6e7a1", "filename": "gcc/config/arm/arm-cpus.in", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm-cpus.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm-cpus.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpus.in?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -135,6 +135,10 @@ define feature armv8_1m_main\n # Floating point and Neon extensions.\n # VFPv1 is not supported in GCC.\n \n+# This feature bit is enabled for all VFP, MVE and\n+# MVE with floating point extensions.\n+define feature vfp_base\n+\n # Vector floating point v2.\n define feature vfpv2\n \n@@ -234,7 +238,7 @@ define fgroup ALL_SIMD\tALL_SIMD_INTERNAL ALL_SIMD_EXTERNAL\n \n # List of all FPU bits to strip out if -mfpu is used to override the\n # default.  fp16 is deliberately missing from this list.\n-define fgroup ALL_FPU_INTERNAL\tvfpv2 vfpv3 vfpv4 fpv5 fp16conv fp_dbl ALL_SIMD_INTERNAL\n+define fgroup ALL_FPU_INTERNAL\tvfp_base vfpv2 vfpv3 vfpv4 fpv5 fp16conv fp_dbl ALL_SIMD_INTERNAL\n # Similarly, but including fp16 and other extensions that aren't part of\n # -mfpu support.\n define fgroup ALL_FPU_EXTERNAL fp16 bf16\n@@ -279,10 +283,12 @@ define fgroup ARMv8r      ARMv8a\n define fgroup ARMv8_1m_main ARMv8m_main armv8_1m_main\n \n # Useful combinations.\n-define fgroup VFPv2\tvfpv2\n+define fgroup VFPv2\tvfp_base vfpv2\n define fgroup VFPv3\tVFPv2 vfpv3\n define fgroup VFPv4\tVFPv3 vfpv4 fp16conv\n define fgroup FPv5\tVFPv4 fpv5\n+define fgroup MVE      mve vfp_base armv7em\n+define fgroup MVE_FP   MVE FPv5 fp16 mve_float\n \n define fgroup FP_DBL\tfp_dbl\n define fgroup FP_D32\tFP_DBL fp_d32\n@@ -699,8 +705,8 @@ begin arch armv8.1-m.main\n  option fp add FPv5 fp16\n  option fp.dp add FPv5 FP_DBL fp16\n  option nofp remove ALL_FP\n- option mve add mve armv7em\n- option mve.fp add mve FPv5 fp16 mve_float armv7em\n+ option mve add MVE\n+ option mve.fp add MVE_FP\n end arch armv8.1-m.main\n \n begin arch iwmmxt"}, {"sha": "b40904a40e0979af4285fdbd85bfae55abea25dd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -4295,7 +4295,7 @@ use_return_insn (int iscond, rtx sibling)\n \n   /* Can't be done if any of the VFP regs are pushed,\n      since this also requires an insn.  */\n-  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+  if (TARGET_VFP_BASE)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n       if (df_regs_ever_live_p (regno) && !call_used_or_fixed_reg_p (regno))\n \treturn 0;\n@@ -6289,7 +6289,7 @@ use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)\n     return false;\n \n   return (TARGET_32BIT && TARGET_HARD_FLOAT &&\n-\t  (TARGET_VFP_DOUBLE || !is_double));\n+\t (TARGET_VFP_DOUBLE || !is_double));\n }\n \n /* Return true if an argument whose type is TYPE, or mode is MODE, is\n@@ -8512,7 +8512,7 @@ thumb2_legitimate_index_p (machine_mode mode, rtx index, int strict_p)\n \n   /* ??? Combine arm and thumb2 coprocessor addressing modes.  */\n   /* Standard coprocessor addressing modes.  */\n-  if (TARGET_HARD_FLOAT\n+  if (TARGET_VFP_BASE\n       && (mode == SFmode || mode == DFmode))\n     return (code == CONST_INT && INTVAL (index) < 1024\n \t    /* Thumb-2 allows only > -256 index range for it's core register\n@@ -9905,7 +9905,7 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  /* Assume that most copies can be done with a single insn,\n \t     unless we don't have HW FP, in which case everything\n \t     larger than word mode will require two insns.  */\n-\t  *cost = COSTS_N_INSNS (((!(TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+\t  *cost = COSTS_N_INSNS (((!TARGET_VFP_BASE\n \t\t\t\t   && GET_MODE_SIZE (mode) > 4)\n \t\t\t\t  || mode == DImode)\n \t\t\t\t ? 2 : 1);\n@@ -20821,7 +20821,7 @@ arm_get_vfp_saved_size (void)\n \n   saved = 0;\n   /* Space for saved VFP registers.  */\n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_VFP_BASE)\n     {\n       count = 0;\n       for (regno = FIRST_VFP_REGNUM;\n@@ -22364,7 +22364,7 @@ arm_compute_frame_layout (void)\n       func_type = arm_current_func_type ();\n       /* Space for saved VFP registers.  */\n       if (! IS_VOLATILE (func_type)\n-\t  && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE))\n+\t  && TARGET_VFP_BASE)\n \tsaved += arm_get_vfp_saved_size ();\n \n       /* Allocate space for saving/restoring FPCXTNS in Armv8.1-M Mainline\n@@ -22588,7 +22588,7 @@ arm_save_coproc_regs(void)\n \tsaved_size += 8;\n       }\n \n-  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+  if (TARGET_VFP_BASE)\n     {\n       start_reg = FIRST_VFP_REGNUM;\n \n@@ -24546,7 +24546,7 @@ arm_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n     return false;\n \n   *p1 = CC_REGNUM;\n-  *p2 = TARGET_HARD_FLOAT ? VFPCC_REGNUM : INVALID_REGNUM;\n+  *p2 = TARGET_VFP_BASE ? VFPCC_REGNUM : INVALID_REGNUM;\n   return true;\n }\n \n@@ -24965,7 +24965,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return (regno == CC_REGNUM\n-\t    || ((TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+\t    || (TARGET_VFP_BASE\n \t\t&& regno == VFPCC_REGNUM));\n \n   if (regno == CC_REGNUM && GET_MODE_CLASS (mode) != MODE_CC)\n@@ -24982,7 +24982,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n-  if ((TARGET_HARD_FLOAT || TARGET_HAVE_MVE) && IS_VFP_REGNUM (regno))\n+  if (TARGET_VFP_BASE && IS_VFP_REGNUM (regno))\n     {\n       if (mode == DFmode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n@@ -26933,7 +26933,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n         floats_from_frame += 4;\n       }\n \n-  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+  if (TARGET_VFP_BASE)\n     {\n       int start_reg;\n       rtx ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n@@ -27179,7 +27179,7 @@ arm_expand_epilogue (bool really_return)\n         }\n     }\n \n-  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n+  if (TARGET_VFP_BASE)\n     {\n       /* Generate VFP register multi-pop.  */\n       int end_reg = LAST_VFP_REGNUM + 1;\n@@ -29699,7 +29699,7 @@ arm_conditional_register_usage (void)\n   if (TARGET_THUMB1)\n     fixed_regs[LR_REGNUM] = call_used_regs[LR_REGNUM] = 1;\n \n-  if (TARGET_32BIT && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE))\n+  if (TARGET_32BIT && TARGET_VFP_BASE)\n     {\n       /* VFPv3 registers are disabled when earlier VFP\n \t versions are selected due to the definition of\n@@ -32478,7 +32478,8 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)\n     = TARGET_SOFT_FLOAT\n \t? \"softvfp\" : arm_identify_fpu_from_isa (arm_active_target.isa);\n \n-  if (fpu_to_print != arm_last_printed_arch_string)\n+  if (!(!strcmp (fpu_to_print.c_str (), \"softvfp\") && TARGET_VFP_BASE)\n+      && (fpu_to_print != arm_last_printed_arch_string))\n     {\n       asm_fprintf (asm_out_file, \"\\t.fpu %s\\n\", fpu_to_print.c_str ());\n       arm_last_printed_fpu_string = fpu_to_print;"}, {"sha": "c7453412959f23bf25c2052b4e0bb6a95faf3163", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -334,6 +334,19 @@ emission of floating point pcs attributes.  */\n \t\t\t\t\t\tisa_bit_mve_float) \\\n \t\t\t       && !TARGET_GENERAL_REGS_ONLY)\n \n+/* MVE have few common instructions as VFP, like VLDM alias VPOP, VLDR, VSTM\n+   alia VPUSH, VSTR and VMOV, VMSR and VMRS.  In the same manner it updates few\n+   registers such as FPCAR, FPCCR, FPDSCR, FPSCR, MVFR0, MVFR1 and MVFR2.  All\n+   the VFP instructions, RTL patterns and register are guarded by\n+   TARGET_HARD_FLOAT.  But the common instructions, RTL pattern and registers\n+   between MVE and VFP will be guarded by the following macro TARGET_VFP_BASE\n+   hereafter.  */\n+\n+#define TARGET_VFP_BASE (arm_float_abi != ARM_FLOAT_ABI_SOFT \\\n+\t\t\t && bitmap_bit_p (arm_active_target.isa, \\\n+\t\t\t\t\t  isa_bit_vfp_base) \\\n+\t\t\t && !TARGET_GENERAL_REGS_ONLY)\n+\n /* Nonzero if integer division instructions supported.  */\n #define TARGET_IDIV\t((TARGET_ARM && arm_arch_arm_hwdiv)\t\\\n \t\t\t || (TARGET_THUMB && arm_arch_thumb_hwdiv))"}, {"sha": "5387f972f5a864a153873f21b9423d28446daefc", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -134,7 +134,7 @@\n ; arm_arch6.  \"v6t2\" for Thumb-2 with arm_arch6 and \"v8mb\" for ARMv8-M\n ; Baseline.  This attribute is used to compute attribute \"enabled\",\n ; use type \"any\" to enable an alternative in all cases.\n-(define_attr \"arch\" \"any,a,t,32,t1,t2,v6,nov6,v6t2,v8mb,iwmmxt,iwmmxt2,armv6_or_vfpv3,neon\"\n+(define_attr \"arch\" \"any,a,t,32,t1,t2,v6,nov6,v6t2,v8mb,iwmmxt,iwmmxt2,armv6_or_vfpv3,neon,mve\"\n   (const_string \"any\"))\n \n (define_attr \"arch_enabled\" \"no,yes\"\n@@ -188,6 +188,10 @@\n \t (and (eq_attr \"arch\" \"neon\")\n \t      (match_test \"TARGET_NEON\"))\n \t (const_string \"yes\")\n+\n+\t (and (eq_attr \"arch\" \"mve\")\n+\t      (match_test \"TARGET_HAVE_MVE\"))\n+\t (const_string \"yes\")\n \t]\n \n \t(const_string \"no\")))\n@@ -11758,7 +11762,7 @@\n                    (match_operand:SI 2 \"const_int_I_operand\" \"I\")))\n      (set (match_operand:DF 3 \"vfp_hard_register_operand\" \"\")\n           (mem:DF (match_dup 1)))])]\n-  \"TARGET_32BIT && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\"\n+  \"TARGET_32BIT && TARGET_VFP_BASE\"\n   \"*\n   {\n     int num_regs = XVECLEN (operands[0], 0);"}, {"sha": "bf8f4ff1e5d2d6132d0afdd05255cc697c54159d", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -38,14 +38,17 @@\n ;; in all states: Pf, Pg\n \n ;; The following memory constraints have been used:\n-;; in ARM/Thumb-2 state: Uh, Ut, Uv, Uy, Un, Um, Us, Up\n+;; in ARM/Thumb-2 state: Uh, Ut, Uv, Uy, Un, Um, Us, Up, Uf\n ;; in ARM state: Uq\n ;; in Thumb state: Uu, Uw\n ;; in all states: Q\n \n (define_register_constraint \"Up\" \"TARGET_HAVE_MVE ? VPR_REG : NO_REGS\"\n   \"MVE VPR register\")\n \n+(define_register_constraint \"Uf\" \"TARGET_HAVE_MVE ? VFPCC_REG : NO_REGS\"\n+  \"MVE FPCCR register\")\n+\n (define_register_constraint \"t\" \"TARGET_32BIT ? VFP_LO_REGS : NO_REGS\"\n  \"The VFP registers @code{s0}-@code{s31}.\")\n "}, {"sha": "793f67068687a60abf94c230e5485a1eb2eca6a0", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -517,7 +517,7 @@\n \t\t\t  [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t\t\t (match_operand:SF 1 \"s_register_operand\" \"0,r\")\n \t\t\t (match_operand:SF 2 \"s_register_operand\" \"r,0\")))]\n-  \"TARGET_THUMB2 && TARGET_SOFT_FLOAT\"\n+  \"TARGET_THUMB2 && TARGET_SOFT_FLOAT && !TARGET_HAVE_MVE\"\n   \"@\n    it\\\\t%D3\\;mov%D3\\\\t%0, %2\n    it\\\\t%d3\\;mov%d3\\\\t%0, %1\""}, {"sha": "e76609f79418af38b70746336dd43592a1dc8713", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -170,6 +170,7 @@\n   UNSPEC_TORC\t\t; Used by the intrinsic form of the iWMMXt TORC instruction.\n   UNSPEC_TORVSC\t\t; Used by the intrinsic form of the iWMMXt TORVSC instruction.\n   UNSPEC_TEXTRC\t\t; Used by the intrinsic form of the iWMMXt TEXTRC instruction.\n+  UNSPEC_GET_FPSCR\t; Represent fetch of FPSCR content.\n ])\n \n \n@@ -216,7 +217,6 @@\n   VUNSPEC_SLX\t\t; Represent a store-register-release-exclusive.\n   VUNSPEC_LDA\t\t; Represent a store-register-acquire.\n   VUNSPEC_STL\t\t; Represent a store-register-release.\n-  VUNSPEC_GET_FPSCR\t; Represent fetch of FPSCR content.\n   VUNSPEC_SET_FPSCR\t; Represent assign of FPSCR content.\n   VUNSPEC_PROBE_STACK_RANGE ; Represent stack range probing.\n   VUNSPEC_CDP\t\t; Represent the coprocessor cdp instruction."}, {"sha": "eb6ae7bea7927c666f36219797d54c0127001bc1", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 81, "deletions": 48, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -74,10 +74,10 @@\n (define_insn \"*thumb2_movhi_vfp\"\n  [(set\n    (match_operand:HI 0 \"nonimmediate_operand\"\n-    \"=rk, r, l, r, m, r, *t, r, *t\")\n+    \"=rk, r, l, r, m, r, *t, r, *t, Up, r\")\n    (match_operand:HI 1 \"general_operand\"\n-    \"rk, I, Py, n, r, m, r, *t, *t\"))]\n- \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n+    \"rk, I, Py, n, r, m, r, *t, *t, r, Up\"))]\n+ \"TARGET_THUMB2 && TARGET_VFP_BASE\n   && !TARGET_VFP_FP16INST\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -99,20 +99,24 @@\n       return \"vmov%?\\t%0, %1\\t%@ int\";\n     case 8:\n       return \"vmov%?.f32\\t%0, %1\\t%@ int\";\n+    case 9:\n+      return \"vmsr%?\\t P0, %1\\t@ movhi\";\n+    case 10:\n+      return \"vmrs%?\\t %0, P0\\t@ movhi\";\n     default:\n       gcc_unreachable ();\n     }\n }\n  [(set_attr \"predicable\" \"yes\")\n   (set_attr \"predicable_short_it\"\n-   \"yes, no, yes, no, no, no, no, no, no\")\n+   \"yes, no, yes, no, no, no, no, no, no, no, no\")\n   (set_attr \"type\"\n    \"mov_reg, mov_imm, mov_imm, mov_imm, store_4, load_4,\\\n-    f_mcr, f_mrc, fmov\")\n-  (set_attr \"arch\" \"*, *, *, v6t2, *, *, *, *, *\")\n-  (set_attr \"pool_range\" \"*, *, *, *, *, 4094, *, *, *\")\n-  (set_attr \"neg_pool_range\" \"*, *, *, *, *, 250, *, *, *\")\n-  (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4\")]\n+    f_mcr, f_mrc, fmov, mve_move, mve_move\")\n+  (set_attr \"arch\" \"*, *, *, v6t2, *, *, *, *, *, mve, mve\")\n+  (set_attr \"pool_range\" \"*, *, *, *, *, 4094, *, *, *, *, *\")\n+  (set_attr \"neg_pool_range\" \"*, *, *, *, *, 250, *, *, *, *, *\")\n+  (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4\")]\n )\n \n ;; Patterns for HI moves which provide more data transfer instructions when FP16\n@@ -170,10 +174,10 @@\n (define_insn \"*thumb2_movhi_fp16\"\n  [(set\n    (match_operand:HI 0 \"nonimmediate_operand\"\n-    \"=rk, r, l, r, m, r, *t, r, *t\")\n+    \"=rk, r, l, r, m, r, *t, r, *t, Up, r\")\n    (match_operand:HI 1 \"general_operand\"\n-    \"rk, I, Py, n, r, m, r, *t, *t\"))]\n- \"TARGET_THUMB2 && TARGET_VFP_FP16INST\n+    \"rk, I, Py, n, r, m, r, *t, *t, r, Up\"))]\n+ \"TARGET_THUMB2 && (TARGET_VFP_FP16INST || TARGET_HAVE_MVE)\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n {\n@@ -194,21 +198,25 @@\n       return \"vmov.f16\\t%0, %1\\t%@ int\";\n     case 8:\n       return \"vmov%?.f32\\t%0, %1\\t%@ int\";\n+    case 9:\n+      return \"vmsr%?\\tP0, %1\\t%@ movhi\";\n+    case 10:\n+      return \"vmrs%?\\t%0, P0\\t%@ movhi\";\n     default:\n       gcc_unreachable ();\n     }\n }\n  [(set_attr \"predicable\"\n-   \"yes, yes, yes, yes, yes, yes, no, no, yes\")\n+   \"yes, yes, yes, yes, yes, yes, no, no, yes, yes, yes\")\n   (set_attr \"predicable_short_it\"\n-   \"yes, no, yes, no, no, no, no, no, no\")\n+   \"yes, no, yes, no, no, no, no, no, no, no, no\")\n   (set_attr \"type\"\n    \"mov_reg, mov_imm, mov_imm, mov_imm, store_4, load_4,\\\n-    f_mcr, f_mrc, fmov\")\n-  (set_attr \"arch\" \"*, *, *, v6t2, *, *, *, *, *\")\n-  (set_attr \"pool_range\" \"*, *, *, *, *, 4094, *, *, *\")\n-  (set_attr \"neg_pool_range\" \"*, *, *, *, *, 250, *, *, *\")\n-  (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4\")]\n+    f_mcr, f_mrc, fmov, mve_move, mve_move\")\n+  (set_attr \"arch\" \"*, *, *, v6t2, *, *, *, *, *, mve, mve\")\n+  (set_attr \"pool_range\" \"*, *, *, *, *, 4094, *, *, *, *, *\")\n+  (set_attr \"neg_pool_range\" \"*, *, *, *, *, 250, *, *, *, *, *\")\n+  (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4\")]\n )\n \n ;; SImode moves\n@@ -258,9 +266,11 @@\n ;; is chosen with length 2 when the instruction is predicated for\n ;; arm_restrict_it.\n (define_insn \"*thumb2_movsi_vfp\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,l,r,r,lk*r,m,*t, r,*t,*t,  *Uv\")\n-\t(match_operand:SI 1 \"general_operand\"\t   \"rk,I,Py,K,j,mi,lk*r, r,*t,*t,*UvTu,*t\"))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rk,r,l,r,r,l,*hk,m,*m,*t,\\\n+\t\t\t\t\t\t    r,*t,*t,*Uv, Up, r,Uf,r\")\n+\t(match_operand:SI 1 \"general_operand\" \"rk,I,Py,K,j,mi,*mi,l,*hk,r,*t,\\\n+\t\t\t\t\t       *t,*UvTu,*t, r, Up,r,Uf\"))]\n+  \"TARGET_THUMB2 && TARGET_VFP_BASE\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n   \"*\n@@ -275,43 +285,57 @@\n     case 4:\n       return \\\"movw%?\\\\t%0, %1\\\";\n     case 5:\n+    case 6:\n       /* Cannot load it directly, split to load it via MOV / MOVT.  */\n       if (!MEM_P (operands[1]) && arm_disable_literal_pool)\n \treturn \\\"#\\\";\n       return \\\"ldr%?\\\\t%0, %1\\\";\n-    case 6:\n-      return \\\"str%?\\\\t%1, %0\\\";\n     case 7:\n-      return \\\"vmov%?\\\\t%0, %1\\\\t%@ int\\\";\n     case 8:\n-      return \\\"vmov%?\\\\t%0, %1\\\\t%@ int\\\";\n+      return \\\"str%?\\\\t%1, %0\\\";\n     case 9:\n+      return \\\"vmov%?\\\\t%0, %1\\\\t%@ int\\\";\n+    case 10:\n+      return \\\"vmov%?\\\\t%0, %1\\\\t%@ int\\\";\n+    case 11:\n       return \\\"vmov%?.f32\\\\t%0, %1\\\\t%@ int\\\";\n-    case 10: case 11:\n+    case 12: case 13:\n       return output_move_vfp (operands);\n+    case 14:\n+      return \\\"vmsr\\\\t P0, %1\\\";\n+    case 15:\n+      return \\\"vmrs\\\\t %0, P0\\\";\n+    case 16:\n+      return \\\"mcr\\\\tp10, 7, %1, cr1, cr0, 0\\\\t @SET_FPSCR\\\";\n+    case 17:\n+      return \\\"mrc\\\\tp10, 7, %0, cr1, cr0, 0\\\\t @GET_FPSCR\\\";\n     default:\n       gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"predicable_short_it\" \"yes,no,yes,no,no,no,no,no,no,no,no,no\")\n-   (set_attr \"type\" \"mov_reg,mov_reg,mov_reg,mvn_reg,mov_imm,load_4,store_4,f_mcr,f_mrc,fmov,f_loads,f_stores\")\n-   (set_attr \"length\" \"2,4,2,4,4,4,4,4,4,4,4,4\")\n-   (set_attr \"pool_range\"     \"*,*,*,*,*,1018,*,*,*,*,1018,*\")\n-   (set_attr \"neg_pool_range\" \"*,*,*,*,*,   0,*,*,*,*,1008,*\")]\n+   (set_attr \"predicable_short_it\" \"yes,no,yes,no,no,no,no,no,no,no,no,no,no,\\\n+\t      no,no,no,no,no\")\n+   (set_attr \"type\" \"mov_reg,mov_reg,mov_reg,mvn_reg,mov_imm,load_4,load_4,\\\n+\t     store_4,store_4,f_mcr,f_mrc,fmov,f_loads,f_stores,mve_move,\\\n+\t     mve_move,mrs,mrs\")\n+   (set_attr \"length\" \"2,4,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4\")\n+   (set_attr \"pool_range\"     \"*,*,*,*,*,1018,4094,*,*,*,*,*,1018,*,*,*,*,*\")\n+   (set_attr \"arch\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,mve,mve,mve,mve\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,*,*,   0,   0,*,*,*,*,*,1008,*,*,*,*,*\")]\n )\n \n \n ;; DImode moves\n \n (define_insn \"*movdi_vfp\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,r,r,r,r,m,w,!r,w,w, Uv\")\n-\t(match_operand:DI 1 \"di_operand\"\t      \"r,rDa,Db,Dc,mi,mi,r,r,w,w,UvTu,w\"))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\n+\t(match_operand:DI 1 \"di_operand\"       \"r,rDa,Db,Dc,mi,mi,r,r,w,w,UvTu,w\"))]\n+  \"TARGET_32BIT && TARGET_VFP_BASE\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\n-   && !(TARGET_NEON && CONST_INT_P (operands[1])\n-\t&& simd_immediate_valid_for_move (operands[1], DImode, NULL, NULL))\"\n+   && !((TARGET_NEON || TARGET_HAVE_MVE) && CONST_INT_P (operands[1])\n+       && simd_immediate_valid_for_move (operands[1], DImode, NULL, NULL))\"\n   \"*\n   switch (which_alternative)\n     {\n@@ -333,7 +357,7 @@\n     case 8:\n       return \\\"vmov%?\\\\t%Q0, %R0, %P1\\\\t%@ int\\\";\n     case 9:\n-      if (TARGET_VFP_SINGLE)\n+      if (TARGET_VFP_SINGLE || TARGET_HAVE_MVE)\n \treturn \\\"vmov%?.f32\\\\t%0, %1\\\\t%@ int\\;vmov%?.f32\\\\t%p0, %p1\\\\t%@ int\\\";\n       else\n \treturn \\\"vmov%?.f64\\\\t%P0, %P1\\\\t%@ int\\\";\n@@ -390,9 +414,15 @@\n     case 6: /* S register from immediate.  */\n       return \\\"vmov.f16\\\\t%0, %1\\t%@ __<fporbf>\\\";\n     case 7: /* S register from memory.  */\n-      return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n+      if (TARGET_HAVE_MVE)\n+\treturn \\\"vldr.16\\\\t%0, %A1\\\";\n+      else\n+\treturn \\\"vld1.16\\\\t{%z0}, %A1\\\";\n     case 8: /* Memory from S register.  */\n-      return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n+      if (TARGET_HAVE_MVE)\n+\treturn \\\"vstr.16\\\\t%1, %A0\\\";\n+      else\n+\treturn \\\"vst1.16\\\\t{%z1}, %A0\\\";\n     case 9: /* ARM register from constant.  */\n       {\n \tlong bits;\n@@ -593,7 +623,7 @@\n (define_insn \"*thumb2_movsf_vfp\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=t,?r,t, t  ,Uv,r ,m,t,r\")\n \t(match_operand:SF 1 \"hard_sf_operand\"\t   \" ?r,t,Dv,UvHa,t, mHa,r,t,r\"))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n+  \"TARGET_THUMB2 && TARGET_VFP_BASE\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n   \"*\n@@ -682,7 +712,7 @@\n (define_insn \"*thumb2_movdf_vfp\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,w,w  ,Uv,r ,m,w,r\")\n \t(match_operand:DF 1 \"hard_df_operand\"\t\t   \" ?r,w,Dy,G,UvHa,w, mHa,r, w,r\"))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT\n+  \"TARGET_THUMB2 && TARGET_VFP_BASE\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -760,7 +790,7 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:SF 1 \"s_register_operand\" \"0,t,t,0,?r,?r,0,t,t\")\n \t  (match_operand:SF 2 \"s_register_operand\" \"t,0,t,?r,0,?r,t,0,t\")))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && !arm_restrict_it\"\n+  \"TARGET_THUMB2 && TARGET_VFP_BASE && !arm_restrict_it\"\n   \"@\n    it\\\\t%D3\\;vmov%D3.f32\\\\t%0, %2\n    it\\\\t%d3\\;vmov%d3.f32\\\\t%0, %1\n@@ -806,7 +836,8 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:DF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n \t  (match_operand:DF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE && !arm_restrict_it\"\n+  \"TARGET_THUMB2 && TARGET_VFP_BASE && TARGET_VFP_DOUBLE\n+   && !arm_restrict_it\"\n   \"@\n    it\\\\t%D3\\;vmov%D3.f64\\\\t%P0, %P2\n    it\\\\t%d3\\;vmov%d3.f64\\\\t%P0, %P1\n@@ -1977,7 +2008,7 @@\n     [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n \t  (unspec:BLK [(match_operand:DF 1 \"vfp_register_operand\" \"\")]\n \t\t      UNSPEC_PUSH_MULT))])]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_VFP_BASE\"\n   \"* return vfp_output_vstmd (operands);\"\n   [(set_attr \"type\" \"f_stored\")]\n )\n@@ -2065,16 +2096,18 @@\n \n ;; Write Floating-point Status and Control Register.\n (define_insn \"set_fpscr\"\n-  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")] VUNSPEC_SET_FPSCR)]\n-  \"TARGET_HARD_FLOAT\"\n+  [(set (reg:SI VFPCC_REGNUM)\n+\t(unspec_volatile:SI\n+\t [(match_operand:SI 0 \"register_operand\" \"r\")] VUNSPEC_SET_FPSCR))]\n+  \"TARGET_VFP_BASE\"\n   \"mcr\\\\tp10, 7, %0, cr1, cr0, 0\\\\t @SET_FPSCR\"\n   [(set_attr \"type\" \"mrs\")])\n \n ;; Read Floating-point Status and Control Register.\n (define_insn \"get_fpscr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (unspec_volatile:SI [(const_int 0)] VUNSPEC_GET_FPSCR))]\n-  \"TARGET_HARD_FLOAT\"\n+\t(unspec:SI [(reg:SI VFPCC_REGNUM)] UNSPEC_GET_FPSCR))]\n+  \"TARGET_VFP_BASE\"\n   \"mrc\\\\tp10, 7, %0, cr1, cr0, 0\\\\t @GET_FPSCR\"\n   [(set_attr \"type\" \"mrs\")])\n "}, {"sha": "590fa16029439fed9d54c0ba92c53666600c8dd0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -1,3 +1,12 @@\n+2020-03-16  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* gcc.target/arm/mve/intrinsics/mve_fp_fpu1.c: New test.\n+\t* gcc.target/arm/mve/intrinsics/mve_fp_fpu2.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_fpu1.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_fpu2.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_fpu3.c: Likewise.\n+\n+\n 2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n             Mihail Ionescu  <mihail.ionescu@arm.com>\n             Srinath Parvathaneni  <srinath.parvathaneni@arm.com>"}, {"sha": "17ba616c041378b88463cb7ef150b70b2e7b95ad", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fp_fpu1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu1.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-additional-options \"-march=armv8.1-m.main+mve.fp -mfloat-abi=hard -mthumb\" } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo1 (int8x16_t value)\n+{\n+  int8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"\\.fpu fpv5-sp-d16\" }  } */"}, {"sha": "7b877c4a90c506343d6b4edb750ba06ce3d7a68d", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fp_fpu2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fp_fpu2.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-additional-options \"-march=armv8.1-m.main+mve.fp -mfloat-abi=softfp -mthumb\" } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo1 (int8x16_t value)\n+{\n+  int8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"\\.fpu fpv5-sp-d16\" }  } */"}, {"sha": "85fbb5767edc3c25ceb4d6da780d47afa1ee416c", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu1.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-additional-options \"-march=armv8.1-m.main+mve -mfloat-abi=hard -mthumb\" } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo1 (int8x16_t value)\n+{\n+  int8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\.fpu softvfp\" }  } */"}, {"sha": "23b3683ae559b3f7bf6c3ad11c4070ad2ddb9387", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu2.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-additional-options \"-march=armv8.1-m.main+mve -mfloat-abi=softfp -mthumb\" } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo1 (int8x16_t value)\n+{\n+  int8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\.fpu softvfp\" }  } */"}, {"sha": "8f7fa348d130e8456d5300ac25821fd96f9d5a97", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_fpu3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7be0832b54669b39dfb56bd91c783dd91aad766/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_fpu3.c?ref=c7be0832b54669b39dfb56bd91c783dd91aad766", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-additional-options \"-march=armv8.1-m.main+mve -mfloat-abi=soft -mthumb\" } */\n+\n+int\n+foo1 (int value)\n+{\n+  int b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"\\.fpu softvfp\" }  } */"}]}