{"sha": "61ccbcfd47fc677635169421f8ecb079fa99c5f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFjY2JjZmQ0N2ZjNjc3NjM1MTY5NDIxZjhlY2IwNzlmYTk5YzVmOA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@nerim.net", "date": "2002-07-29T19:31:24Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-07-29T19:31:24Z"}, "message": "Makefile.in (C_OBJS): Include c-pretty-print.o\n\n2002-07-29  Gabriel Dos Reis  <gdr@nerim.net>\n\n\t* Makefile.in (C_OBJS): Include c-pretty-print.o\n\t(c-pretty-print.o): Add depency rule.\n\t* pretty-print.h: Add more macros.\n\t* c-pretty-print.c: New file.\n\t* c-pretty-print.h: Likewise.\n\ncp/\n\n2002-07-29  Gabriel Dos Reis  <gdr@nerim.net>\n\n\t* Make-lang.in (CXX_C_OBJS): Include.\n\nFrom-SVN: r55845", "tree": {"sha": "34373384a7a2f7e16ad1e90fbdd702a5943f0598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34373384a7a2f7e16ad1e90fbdd702a5943f0598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ccbcfd47fc677635169421f8ecb079fa99c5f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ccbcfd47fc677635169421f8ecb079fa99c5f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ccbcfd47fc677635169421f8ecb079fa99c5f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ccbcfd47fc677635169421f8ecb079fa99c5f8/comments", "author": null, "committer": null, "parents": [{"sha": "09101f56b17ce1a29aee10e48eefa3cdd8a6be47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09101f56b17ce1a29aee10e48eefa3cdd8a6be47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09101f56b17ce1a29aee10e48eefa3cdd8a6be47"}], "stats": {"total": 1003, "additions": 1000, "deletions": 3}, "files": [{"sha": "b7a5e9b27f2f778ebfdd37da3ba48b1fa5991a8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -1,3 +1,11 @@\n+2002-07-29  Gabriel Dos Reis  <gdr@nerim.net>\n+\n+\t* Makefile.in (C_OBJS): Include c-pretty-print.o\n+\t(c-pretty-print.o): Add depency rule.\n+\t* pretty-print.h: Add more macros.\n+\t* c-pretty-print.c: New file.\n+\t* c-pretty-print.h: Likewise.\n+\n 2002-07-29  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/spe.h (__internal_ev_mwhgumian): Cast vector"}, {"sha": "0ebba1ed1db225e53a90857927528288c3224525", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -718,7 +718,7 @@ C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-objc-common.o c-dump.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n-C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n+C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n \n@@ -1230,6 +1230,8 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n \tdiagnostic.h tree-inline.h except.h gt-c-common.h real.h langhooks.h\n+c-pretty-print.o : c-pretty-print.c c-pretty-print.h pretty-print.h \\\n+\t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) real.h\n \n # A file used by all variants of C and some other languages.\n "}, {"sha": "c859cd795a5319912700ce3730ff5e124517843d", "filename": "gcc/c-pretty-print.c", "status": "added", "additions": 835, "deletions": 0, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -0,0 +1,835 @@\n+/* Subroutines common to both C and C++ pretty-printers.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"real.h\"\n+#include \"c-pretty-print.h\"\n+\n+/* literal  */\n+static void pp_c_char              PARAMS ((c_pretty_print_info *, int));\n+static void pp_c_character_literal PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_bool_literal      PARAMS ((c_pretty_print_info *, tree));\n+static bool pp_c_enumerator        PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_integer_literal   PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_real_literal      PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_string_literal    PARAMS ((c_pretty_print_info *, tree));\n+\n+static void pp_c_primary_expression PARAMS ((c_pretty_print_info *, tree));\n+\n+static void pp_c_unary_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_multiplicative_expression PARAMS ((c_pretty_print_info *,\n+\t\t\t\t\t\t    tree));\n+static void pp_c_additive_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_shift_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_relational_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_equality_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_and_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_exclusive_or_expression PARAMS ((c_pretty_print_info *,\n+\t\t\t\t\t\t  tree));\n+static void pp_c_inclusive_or_expression PARAMS ((c_pretty_print_info *,\n+\t\t\t\t\t\t  tree));\n+static void pp_c_logical_and_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_conditional_expression PARAMS ((c_pretty_print_info *, tree));\n+static void pp_c_assignment_expression PARAMS ((c_pretty_print_info *, tree));\n+\f\n+/* Declarations.  */\n+\n+/* Print out CV-qualifiers.  Take care of possible extension.  */\n+void\n+pp_c_cv_qualifier (ppi, cv)\n+     c_pretty_print_info *ppi;\n+     int cv;\n+{\n+  if (cv & TYPE_QUAL_CONST)\n+    pp_c_identifier (ppi, \"const\");\n+  if (cv & TYPE_QUAL_VOLATILE)\n+    pp_c_identifier (ppi, \"volatile\");\n+  if (cv & TYPE_QUAL_RESTRICT)\n+    pp_c_identifier (ppi, flag_isoc99 ? \"restrict\" : \"__restrict__\");\n+}\n+\n+\f\n+/* Statements.  */\n+\n+\f\n+/* Expressions.  */\n+\n+/* Print out a c-char.  */\n+static void\n+pp_c_char (ppi, c)\n+     c_pretty_print_info *ppi;\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case TARGET_NEWLINE:\n+      pp_identifier (ppi, \"\\\\n\");\n+      break;\n+    case TARGET_TAB:\n+      pp_identifier (ppi, \"\\\\t\");\n+      break;\n+    case TARGET_VT:\n+      pp_identifier (ppi, \"\\\\v\");\n+      break;\n+    case TARGET_BS:\n+      pp_identifier (ppi, \"\\\\b\");\n+      break;\n+    case TARGET_CR:\n+      pp_identifier (ppi, \"\\\\r\");\n+      break;\n+    case TARGET_FF:\n+      pp_identifier (ppi, \"\\\\f\");\n+      break;\n+    case TARGET_BELL:\n+      pp_identifier (ppi, \"\\\\a\");\n+      break;\n+    case '\\\\':\n+      pp_identifier (ppi, \"\\\\\\\\\");\n+      break;\n+    case '\\'':\n+      pp_identifier (ppi, \"\\\\'\");\n+      break;\n+    case '\\\"':\n+      pp_identifier (ppi, \"\\\\\\\"\");\n+      break;\n+    default:\n+      if (ISPRINT (c))\n+\tpp_character (ppi, c);\n+      else\n+\tpp_format_integer (ppi, \"\\\\%03o\", (unsigned) c);\n+      break;\n+    }\n+}\n+\n+/* Print out a STRING literal.  */\n+static inline void\n+pp_c_string_literal (ppi, s)\n+     c_pretty_print_info *ppi;\n+     tree s;\n+{\n+  const char *p = TREE_STRING_POINTER (s);\n+  int n = TREE_STRING_LENGTH (s) - 1;\n+  int i;\n+  pp_doublequote (ppi);\n+  for (i = 0; i < n; ++i)\n+    pp_c_char (ppi, p[i]);\n+  pp_doublequote (ppi);\n+}\n+\n+/* Print out a CHARACTER literal.  */\n+static inline void\n+pp_c_character_literal (ppi, c)\n+     c_pretty_print_info *ppi;\n+     tree c;\n+{\n+  pp_quote (ppi);\n+  pp_c_char (ppi, tree_low_cst (c, 0));\n+  pp_quote (ppi);\n+}\n+\n+/* Print out a BOOLEAN literal.  */\n+static inline void\n+pp_c_bool_literal (ppi, b)\n+     c_pretty_print_info *ppi;\n+     tree b;\n+{\n+  if (b == boolean_false_node || integer_zerop (b))\n+    {\n+      if (c_language == clk_cplusplus)\n+\tpp_c_identifier (ppi, \"false\");\n+      else if (c_language == clk_c && flag_isoc99)\n+\tpp_c_identifier (ppi, \"_False\");\n+      else\n+\tpp_unsupported_tree (ppi, b);\n+    }\n+  else if (b == boolean_true_node)\n+    {\n+      if (c_language == clk_cplusplus)\n+\tpp_c_identifier (ppi, \"true\");\n+      else if (c_language == clk_c && flag_isoc99)\n+\tpp_c_identifier (ppi, \"_True\");\n+      else\n+\tpp_unsupported_tree (ppi, b);\n+    }\n+  else\n+    pp_unsupported_tree (ppi, b);\n+}\n+\n+/* Attempt to print out an ENUMERATOR.  Return true on success.  Else return \n+   false; that means the value was obtained by a cast, in which case\n+   print out the type-id part of the cast-expression -- the casted value\n+   is then printed by pp_c_integer_literal.  */\n+static bool\n+pp_c_enumerator (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  tree type = TREE_TYPE (e);\n+  tree value;\n+\n+  /* Find the name of this constant.  */\n+  for (value = TYPE_VALUES (type); \n+       value != NULL_TREE && !tree_int_cst_equal (TREE_VALUE (value), e);\n+       value = TREE_CHAIN (value))\n+    ;\n+  \n+  if (value != NULL_TREE)\n+    pp_c_tree_identifier (ppi, TREE_PURPOSE (value));\n+  else\n+    {\n+      /* Value must have been cast.  */\n+      pp_c_left_paren (ppi);\n+      pp_type_id (ppi, type);\n+      pp_c_right_paren (ppi);\n+      return false;\n+    }\n+  \n+  return true;\n+}\n+\n+/* Print out an INTEGER constant value.  */\n+static void\n+pp_c_integer_literal (ppi, i)\n+     c_pretty_print_info *ppi;\n+     tree i;\n+{\n+  tree type = TREE_TYPE (i);\n+  \n+  if (type == boolean_type_node)\n+    pp_c_bool_literal (ppi, i);\n+  else if (type == char_type_node)\n+    pp_c_character_literal (ppi, i);\n+  else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t   && pp_c_enumerator (ppi, i))\n+    ;\n+  else\n+    {\n+      if (host_integerp (i, 0))\n+\tpp_wide_integer (ppi, TREE_INT_CST_LOW (i));\n+      else\n+\t{\n+\t  if (tree_int_cst_sgn (i) < 0)\n+\t    {\n+\t      static char format[10]; /* \"%x%09999x\\0\" */\n+\t      if (!format[0])\n+\t\tsprintf (format, \"%%x%%0%dx\", HOST_BITS_PER_INT / 4);\n+\n+\t      pp_c_char (ppi, '-');\n+\t      i = build_int_2 (-TREE_INT_CST_LOW (i),\n+\t\t\t       ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n+\t      sprintf (pp_buffer (ppi)->digit_buffer, format, \n+\t\t       TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n+\t      pp_identifier (ppi, pp_buffer (ppi)->digit_buffer);\n+\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Print out a REAL value. */\n+static inline void\n+pp_c_real_literal (ppi, r)\n+     c_pretty_print_info *ppi;\n+     tree r;\n+{\n+  REAL_VALUE_TO_DECIMAL (TREE_REAL_CST (r), \"%.16g\",\n+\t\t\t pp_buffer (ppi)->digit_buffer);\n+  pp_identifier (ppi, pp_buffer(ppi)->digit_buffer);\n+}\n+\n+\n+void\n+pp_c_literal (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  switch (TREE_CODE (e))\n+    {\n+    case INTEGER_CST:\n+      pp_c_integer_literal (ppi, e);\n+      break;\n+      \n+    case REAL_CST:\n+      pp_c_real_literal (ppi, e);\n+      break;\n+      \n+    case STRING_CST:\n+      pp_c_string_literal (ppi, e);\n+      break;      \n+\n+    default:\n+      pp_unsupported_tree (ppi, e);\n+      break;\n+    }\n+}\n+\n+/* Pretty-print a C primary-expression.  */\n+static void\n+pp_c_primary_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  switch (TREE_CODE (e))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case CONST_DECL:\n+    case FUNCTION_DECL:\n+    case LABEL_DECL:\n+      e = DECL_NAME (e);\n+      /* Fall through.  */\n+    case IDENTIFIER_NODE:\n+      pp_c_tree_identifier (ppi, e);\n+      break;\n+\n+    case ERROR_MARK:\n+      pp_c_identifier (ppi, \"<erroneous-expression>\");\n+      break;\n+\t\t       \n+    case RESULT_DECL:\n+      pp_c_identifier (ppi, \"<return-value>\");\n+      break;\n+\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case STRING_CST:\n+      pp_c_literal (ppi, e);\n+      break;\n+\n+    default:\n+      /*  Make sure this call won't cause any infinite loop. */\n+      pp_c_left_paren (ppi);\n+      pp_c_expression (ppi, e);\n+      pp_c_right_paren (ppi);\n+      break;\n+    }\n+}\n+\n+void\n+pp_c_postfix_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_identifier (ppi, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n+      break;\n+\n+    case ARRAY_REF:\n+      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_left_bracket (ppi);\n+      pp_c_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_right_bracket (ppi);\n+      break;\n+\n+    case CALL_EXPR:\n+      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_left_paren (ppi);\n+      pp_c_expression_list (ppi, TREE_OPERAND (e, 1));\n+      pp_c_right_paren (ppi);\n+      break;\n+\n+    case COMPONENT_REF:\n+      {\n+\ttree object = TREE_OPERAND (e, 0);\n+\tif (TREE_CODE (object) == INDIRECT_REF)\n+\t  {\n+\t    pp_postfix_expression (ppi, TREE_OPERAND (object, 0));\n+\t    pp_arrow (ppi);\n+\t  }\n+\telse\n+\t  {\n+\t    pp_postfix_expression (ppi, object);\n+\t    pp_dot (ppi);\n+\t  }\n+\tpp_c_expression (ppi, TREE_OPERAND (e, 1));\n+      }\n+      break;\n+\n+    case CONSTRUCTOR:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      pp_unsupported_tree (ppi, e);\n+      break;\n+\n+    default:\n+      pp_primary_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+/* Print out an expession-list; E is expected to be a TREE_LIST  */\n+void\n+pp_c_expression_list (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  for (; e != NULL_TREE; e = TREE_CHAIN (e))\n+    {\n+      pp_c_assignment_expression (ppi, TREE_VALUE (e));\n+      if (TREE_CHAIN (e))\n+\tpp_separate_with (ppi, ',');\n+    }\n+}\n+\n+static void\n+pp_c_unary_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+      pp_identifier (ppi, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n+      pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+      \n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case CONVERT_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+      if (code == ADDR_EXPR)\n+\tpp_ampersand (ppi);\n+      else if (code == INDIRECT_REF)\n+\tpp_star (ppi);\n+      else if (code == NEGATE_EXPR)\n+\tpp_minus (ppi);\n+      else if (code == BIT_NOT_EXPR)\n+\tpp_complement (ppi);\n+      else if (code == TRUTH_NOT_EXPR)\n+\tpp_exclamation (ppi);\n+      pp_c_cast_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+      pp_c_identifier (ppi, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n+      pp_c_whitespace (ppi);\n+      if (TYPE_P (TREE_OPERAND (e, 0)))\n+\t{\n+\t  pp_c_left_paren (ppi);\n+\t  pp_type_id (ppi, TREE_OPERAND (e, 0));\n+\t  pp_c_right_paren (ppi);\n+\t}\n+      else\n+\tpp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+\n+    default:\n+      pp_postfix_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+void\n+pp_c_cast_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == CONVERT_EXPR)\n+    {\n+      pp_c_left_paren (ppi);\n+      pp_type_id (ppi, TREE_TYPE (e));\n+      pp_c_right_paren (ppi);\n+      pp_c_cast_expression (ppi, TREE_OPERAND (e, 0));\n+    }\n+  else\n+    pp_unary_expression (ppi, e);\n+}\n+\n+static void\n+pp_c_multiplicative_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      pp_c_multiplicative_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (ppi);\n+      if (code == MULT_EXPR)\n+\tpp_star (ppi);\n+      else if (code == TRUNC_DIV_EXPR)\n+\tpp_slash (ppi);\n+      else\n+\tpp_modulo (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_cast_expression (ppi, TREE_OPERAND (e, 1));\n+      break;\n+\n+    default:\n+      pp_c_cast_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+static inline void\n+pp_c_additive_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      pp_c_additive_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (ppi);\n+      if (code == PLUS_EXPR)\n+\tpp_plus (ppi);\n+      else\n+\tpp_minus (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 1));\n+      break;\n+\n+    default:\n+      pp_multiplicative_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+static inline void\n+pp_c_shift_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      pp_c_shift_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (ppi);\n+      pp_identifier (ppi, code == LSHIFT_EXPR ? \"<<\" : \">>\");\n+      pp_c_whitespace (ppi);\n+      pp_c_additive_expression (ppi, TREE_OPERAND (e, 1));\n+      break;\n+\n+    default:\n+      pp_c_additive_expression (ppi, e);\n+    }\n+}\n+\n+static void\n+pp_c_relational_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+      pp_c_relational_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (ppi);\n+      if (code == LT_EXPR)\n+\tpp_less (ppi);\n+      else if (code == GT_EXPR)\n+\tpp_greater (ppi);\n+      else if (code == LE_EXPR)\n+\tpp_identifier (ppi, \"<=\");\n+      else if (code == GE_EXPR)\n+\tpp_identifier (ppi, \">=\");\n+      pp_c_whitespace (ppi);\n+      pp_c_shift_expression (ppi, TREE_OPERAND (e, 1));\n+      break;\n+\n+    default:\n+      pp_c_shift_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+static inline void\n+pp_c_equality_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      pp_c_equality_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_identifier (ppi, code == EQ_EXPR ? \"==\" : \"!=\");\n+      pp_c_whitespace (ppi);\n+      pp_c_relational_expression (ppi, TREE_OPERAND (e, 1));\n+      break;\t\n+      \n+    default:\n+      pp_c_relational_expression (ppi, e);\n+      break;\n+    }\n+}\n+\n+static inline void\n+pp_c_and_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == BIT_AND_EXPR)\n+    {\n+      pp_c_and_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_ampersand (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_equality_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_equality_expression (ppi, e);\n+}\n+\n+static inline void\n+pp_c_exclusive_or_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == BIT_XOR_EXPR)\n+    {\n+      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_carret (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_and_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_and_expression (ppi, e);\n+}\n+\n+static inline void\n+pp_c_inclusive_or_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == BIT_IOR_EXPR)\n+    {\n+      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_bar (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_exclusive_or_expression (ppi, e);\n+}\n+\n+static inline void\n+pp_c_logical_and_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == TRUTH_ANDIF_EXPR)\n+    {\n+      pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_identifier (ppi, \"&&\");\n+      pp_c_whitespace (ppi);\n+      pp_c_inclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_inclusive_or_expression (ppi, e);\n+}\n+\n+void\n+pp_c_logical_or_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == TRUTH_ORIF_EXPR)\n+    {\n+      pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_identifier (ppi, \"||\");\n+      pp_c_whitespace (ppi);\n+      pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_logical_and_expression (ppi, e);\n+}\n+\n+static void\n+pp_c_conditional_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == COND_EXPR)\n+    {\n+      pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_question (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_colon (ppi);\n+      pp_c_whitespace (ppi);\n+      pp_c_conditional_expression (ppi, TREE_OPERAND (e, 2));\n+    }\n+  else\n+    pp_c_logical_or_expression (ppi, e);\n+}\n+\n+\n+/* Pretty-print a C assignment-expression.  */\n+static void\n+pp_c_assignment_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  if (TREE_CODE (e) == MODIFY_EXPR)\n+    {\n+      pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (ppi);\n+      pp_equal (ppi);\n+      pp_whitespace (ppi);\n+      pp_c_assignment_expression (ppi, TREE_OPERAND (e, 1));\n+    }\n+  else\n+    pp_c_conditional_expression (ppi, e);\n+}\n+\n+/* Pretty-print an expression.  */\n+void\n+pp_c_expression (ppi, e)\n+     c_pretty_print_info *ppi;\n+     tree e;\n+{\n+  switch (TREE_CODE (e))\n+    {\n+    case INTEGER_CST:\n+      pp_c_integer_literal (ppi, e);\n+      break;\n+      \n+    case REAL_CST:\n+      pp_c_real_literal (ppi, e);\n+      break;\n+\n+    case STRING_CST:\n+      pp_c_string_literal (ppi, e);\n+      break;\n+      \n+    case FUNCTION_DECL:\n+    case VAR_DECL:\n+    case CONST_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case FIELD_DECL:\n+    case LABEL_DECL:\n+    case ERROR_MARK:\n+      pp_c_primary_expression (ppi, e);\n+      break;\n+\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case ARRAY_REF:\n+    case CALL_EXPR:\n+    case COMPONENT_REF:\n+    case CONSTRUCTOR:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+      pp_c_postfix_expression (ppi, e);\n+      break;\n+\n+    case CONVERT_EXPR:\n+      pp_c_cast_expression (ppi, e);\n+      break;\n+\n+    case MULT_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case TRUNC_DIV_EXPR:\n+      pp_c_multiplicative_expression (ppi, e);\n+      break;\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      pp_c_shift_expression (ppi, e);\n+      break;\n+\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+      pp_c_relational_expression (ppi, e);\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      pp_c_and_expression (ppi, e);\n+      break;\n+\n+    case BIT_XOR_EXPR:\n+      pp_c_exclusive_or_expression (ppi, e);\n+      break;\n+\n+    case BIT_IOR_EXPR:\n+      pp_c_inclusive_or_expression (ppi, e);\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+      pp_c_logical_and_expression (ppi, e);\n+      break;\n+\n+    case TRUTH_ORIF_EXPR:\n+      pp_c_logical_or_expression (ppi, e);\n+      break;\n+\n+    case COND_EXPR:\n+      pp_c_conditional_expression (ppi, e);\n+      break;\n+\n+    case MODIFY_EXPR:\n+      pp_c_assignment_expression (ppi, e);\n+      break;\n+\n+    case NOP_EXPR:\n+      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      pp_c_left_paren (ppi);\n+      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_separate_with (ppi, ',');\n+      pp_assignment_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_right_paren (ppi);\n+      break;\n+\t\t     \n+\n+    default:\n+      pp_unsupported_tree (ppi, e);\n+      break;\n+    }\n+}\n+"}, {"sha": "f9b1d6b8bf4650aa4c0d97c746b13f93c5f97c33", "filename": "gcc/c-pretty-print.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -0,0 +1,139 @@\n+/* Various declarations for the C and C++ pretty-printers.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"pretty-print.h\"\n+\n+\n+/* The data type used to bundle information necessary for pretty-printing\n+   a C or C++ entity.  */\n+typedef struct c_pretty_print_info c_pretty_print_info;\n+\n+/* The type of a C pretty-printer 'member' function.  */\n+typedef void (*c_pretty_print_fn) PARAMS ((c_pretty_print_info *, tree));\n+\n+struct c_pretty_print_info\n+{\n+  struct pretty_print_info base;\n+  /* Points to the first element of an array of offset-list.\n+     Not used yet.  */\n+  int *offset_list;\n+\n+  /* These must be overriden by each of the C and C++ front-end to\n+     reflect their understanding of syntatic productions when they differ.  */\n+  c_pretty_print_fn declaration;\n+  c_pretty_print_fn declaration_specifiers;\n+  c_pretty_print_fn type_specifier;\n+  c_pretty_print_fn declarator;\n+  c_pretty_print_fn direct_declarator;\n+  c_pretty_print_fn parameter_declaration;\n+  c_pretty_print_fn type_id;\n+\n+  c_pretty_print_fn statement;\n+\n+  c_pretty_print_fn primary_expression;\n+  c_pretty_print_fn postfix_expression;\n+  c_pretty_print_fn unary_expression;\n+  c_pretty_print_fn multiplicative_expression;\n+  c_pretty_print_fn conditional_expression;\n+  c_pretty_print_fn assignment_expression;\n+};\n+\n+#define pp_buffer(PPI) (PPI)->base.buffer\n+#define pp_c_left_paren(PPI)             \\\n+   do {                                  \\\n+     pp_left_paren (PPI);                \\\n+     (PPI)->base.padding = pp_none;      \\\n+   } while (0)\n+#define pp_c_right_paren(PPI)            \\\n+   do {                                  \\\n+     pp_right_paren (PPI);               \\\n+     (PPI)->base.padding = pp_none;      \\\n+   } while (0)\n+#define pp_c_left_bracket(PPI)           \\\n+   do {                                  \\\n+     pp_left_bracket (PPI);              \\\n+     (PPI)->base.padding = pp_none;      \\\n+   } while (0)\n+#define pp_c_right_bracket(PPI)          \\\n+   do {                                  \\\n+     pp_right_bracket (PPI);             \\\n+     (PPI)->base.padding = pp_none;      \\\n+   } while (0)\n+#define pp_c_whitespace(PPI)             \\\n+   do {                                  \\\n+     pp_whitespace (PPI);                \\\n+     (PPI)->base.padding = pp_none;      \\\n+   } while (0)\n+#define pp_c_maybe_whitespace(PPI)       \\\n+   do {                                  \\\n+     if ((PPI)->base.padding != pp_none) \\\n+       pp_c_whitespace (PPI);            \\\n+   } while (0)\n+#define pp_c_identifier(PPI, ID)         \\\n+   do {                                  \\\n+     pp_c_maybe_whitespace (PPI);        \\\n+     pp_identifier (PPI, ID);            \\\n+     (PPI)->base.padding = pp_before;    \\\n+   } while (0)\n+     \n+#define pp_c_tree_identifier(PPI, ID)    \\\n+   pp_c_identifier (PPI, IDENTIFIER_POINTER (ID))\n+\n+\n+#define pp_declaration(PPI, T)            (*(PPI)->declaration) (PPI, T)\n+#define pp_declaration_specifiers(PPI, D) \\\n+   (*(PPI)->declaration_specifiers) (PPI, D)\n+#define pp_type_specifier(PPI, D)         (*(PPI)->type_specifier) (PPI, D)\n+#define pp_declarator(PPI, D)             (*(PPI)->declarator) (PPI, D)\n+#define pp_direct_declarator(PPI, D)      (*(PPI)->direct_declarator) (PPI, D)\n+#define pp_parameter_declaration(PPI, T)  \\\n+  (*(PPI)->parameter_declaration) (PPI, T)\n+#define pp_type_id(PPI, D)                (*(PPI)->type_id) (PPI, D)\n+\n+#define pp_statement(PPI, S)              (*(PPI)->statement) (PPI, S)\n+\n+#define pp_primary_expression(PPI, E)     (*(PPI)->primary_expression) (PPI, E)\n+#define pp_postfix_expression(PPI, E)     (*(PPI)->postfix_expression) (PPI, E)\n+#define pp_unary_expression(PPI, E)       (*(PPI)->unary_expression) (PPI, E)\n+#define pp_multiplicative_expression(PPI, E)\\\n+   (*(PPI)->multiplicative_expression) (PPI, E)\n+#define pp_conditional_expession(PPI, E)  \\\n+   (*(PPI)->conditional_expression (PPI, E))\n+#define pp_assignment_expression(PPI, E)  \\\n+   (*(PPI)->assignment_expression) (PPI, E)\n+\n+\n+/* Declarations.  */\n+void pp_c_cv_qualifier PARAMS ((c_pretty_print_info *, int));\n+void pp_c_parameter_declaration_clause PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_declaration PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_statement PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_expression PARAMS ((c_pretty_print_info *, tree));\n+\n+/* Expressions.  */\n+void pp_c_expression PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_logical_or_expression PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_expression_list PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_cast_expression PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_postfix_expression PARAMS ((c_pretty_print_info *, tree));\n+void pp_c_literal PARAMS ((c_pretty_print_info *, tree));"}, {"sha": "549380bcf65a5acc611d7d92713f54de8e41eb16", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -96,7 +96,7 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n # The compiler itself.\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n-\tc-dump.o $(CXX_TARGET_OBJS)\n+\tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "958e1ee9e5cb11b4c9b29394b29ea65fe37c8520", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ccbcfd47fc677635169421f8ecb079fa99c5f8/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=61ccbcfd47fc677635169421f8ecb079fa99c5f8", "patch": "@@ -53,7 +53,20 @@ struct pretty_print_info\n #define pp_colon(PPI)           output_add_character (pp_buffer (PPI), ':')\n #define pp_colon_colon(PPI)     output_add_string (pp_buffer (PPI), \"::\")\n #define pp_arrow(PPI)           output_add_string (pp_buffer (PPI), \"->\")\n+#define pp_equal(PPI)           output_add_character (pp_buffer (PPI), '=')\n+#define pp_question(PPI)        output_add_character (pp_buffer (PPI), '?')\n+#define pp_bar(PPI)             output_add_character (pp_buffer (PPI), '|')\n+#define pp_carret(PPI)          output_add_character (pp_buffer (PPI), '^')\n+#define pp_ampersand(PPI)       output_add_character (pp_buffer (PPI), '&')\n+#define pp_less(PPI)            output_add_character (pp_buffer (PPI), '<')\n+#define pp_greater(PPI)         output_add_character (pp_buffer (PPI), '>')\n+#define pp_plus(PPI)            output_add_character (pp_buffer (PPI), '+')\n+#define pp_minus(PPI)           output_add_character (pp_buffer (PPI), '-')\n #define pp_star(PPI)            output_add_character (pp_buffer (PPI), '*')\n+#define pp_slash(PPI)           output_add_character (pp_buffer (PPI), '/')\n+#define pp_modulo(PPI)          output_add_character (pp_buffer (PPI), '%')\n+#define pp_exclamation(PPI)     output_add_character (pp_buffer (PPI), '!')\n+#define pp_complement(PPI)      output_add_character (pp_buffer (PPI), '~')\n #define pp_quote(PPI)           output_add_character (pp_buffer (PPI), '\\'')\n #define pp_backquote(PPI)       output_add_character (pp_buffer (PPI), '`')\n #define pp_doublequote(PPI)     output_add_character (pp_buffer (PPI), '\"')\n@@ -80,7 +93,7 @@ struct pretty_print_info\n #define pp_tree_identifier(PPI, T) pp_identifier(PPI, IDENTIFIER_POINTER (T))\n \n #define pp_unsupported_tree(PPI, T) \\\n-  output_verbatim (pp_buffer((PPI), \"#`%s' not supported by %s#\",\\\n+  output_verbatim (pp_buffer(PPI), \"#`%s' not supported by %s#\",\\\n                    tree_code_name[(int) TREE_CODE (T)], __FUNCTION__)\n \n #endif /* GCC_PRETTY_PRINT_H */"}]}