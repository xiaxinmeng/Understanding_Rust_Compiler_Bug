{"sha": "06d43afd8592777cbc11e78a8b7667fda6c1eace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkNDNhZmQ4NTkyNzc3Y2JjMTFlNzhhOGI3NjY3ZmRhNmMxZWFjZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-22T08:59:56Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-08-22T08:59:56Z"}, "message": "tree-ssa-coalesce.c (struct ssa_conflicts_d): Make contents of this a VEC and add a bitmap obstack.\n\n\t* tree-ssa-coalesce.c (struct ssa_conflicts_d): Make contents\n\tof this a VEC and add a bitmap obstack.\n\t(ssa_conflicts_new): Allocate the obstack and grow the VEC cleared\n\tto the right size.\n\t(ssa_conflicts_delete): Free the VEC and release the obstack.\n\t(ssa_conflicts_test_p, ssa_conflicts_test_p, ssa_conflicts_add_one,\n\tssa_conflicts_merge, ssa_conflicts_dump): Update for above changes.\n\t(truct live_track_d): Add another bitmap obstack here.\n\t(new_live_track): Initialize it and use it for all bitmaps.\n\t(delete_live_track): Don't free the bitmaps one at a time, just\n\trelease the obstack.\n\t(create_outofssa_var_map): Fix to conform to GCC code style rules.\n\nFrom-SVN: r190589", "tree": {"sha": "4fabf4736d4263e7e42c5e5623939fb1d52ac304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fabf4736d4263e7e42c5e5623939fb1d52ac304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d43afd8592777cbc11e78a8b7667fda6c1eace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d43afd8592777cbc11e78a8b7667fda6c1eace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d43afd8592777cbc11e78a8b7667fda6c1eace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d43afd8592777cbc11e78a8b7667fda6c1eace/comments", "author": null, "committer": null, "parents": [{"sha": "130e00bd2407957f9cc32f7c107502848016166e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130e00bd2407957f9cc32f7c107502848016166e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/130e00bd2407957f9cc32f7c107502848016166e"}], "stats": {"total": 107, "additions": 60, "deletions": 47}, "files": [{"sha": "664fd0315182b9a079c1b8fcee102b270b9cff23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d43afd8592777cbc11e78a8b7667fda6c1eace/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d43afd8592777cbc11e78a8b7667fda6c1eace/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06d43afd8592777cbc11e78a8b7667fda6c1eace", "patch": "@@ -1,3 +1,18 @@\n+2012-08-22  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree-ssa-coalesce.c (struct ssa_conflicts_d): Make contents\n+\tof this a VEC and add a bitmap obstack.\n+\t(ssa_conflicts_new): Allocate the obstack and grow the VEC cleared\n+\tto the right size.\n+\t(ssa_conflicts_delete): Free the VEC and release the obstack.\n+\t(ssa_conflicts_test_p, ssa_conflicts_test_p, ssa_conflicts_add_one,\n+\tssa_conflicts_merge, ssa_conflicts_dump): Update for above changes.\n+\t(truct live_track_d): Add another bitmap obstack here.\n+\t(new_live_track): Initialize it and use it for all bitmaps.\n+\t(delete_live_track): Don't free the bitmaps one at a time, just\n+\trelease the obstack.\n+\t(create_outofssa_var_map): Fix to conform to GCC code style rules.\n+\n 2012-08-21  Nathan Froyd  <froydnj@gcc.gnu.org>\n \n \t* config/m32c/constraints.md: New file."}, {"sha": "5d2ce38c5a65f706c4ca828c0bb33ffe0242ad24", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d43afd8592777cbc11e78a8b7667fda6c1eace/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d43afd8592777cbc11e78a8b7667fda6c1eace/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=06d43afd8592777cbc11e78a8b7667fda6c1eace", "patch": "@@ -504,11 +504,10 @@ dump_coalesce_list (FILE *f, coalesce_list_p cl)\n \n typedef struct ssa_conflicts_d\n {\n-  unsigned size;\n-  bitmap *conflicts;\n+  bitmap_obstack obstack;\t/* A place to allocate our bitmaps.  */\n+  VEC(bitmap, heap)* conflicts;\n } * ssa_conflicts_p;\n \n-\n /* Return an empty new conflict graph for SIZE elements.  */\n \n static inline ssa_conflicts_p\n@@ -517,8 +516,9 @@ ssa_conflicts_new (unsigned size)\n   ssa_conflicts_p ptr;\n \n   ptr = XNEW (struct ssa_conflicts_d);\n-  ptr->conflicts = XCNEWVEC (bitmap, size);\n-  ptr->size = size;\n+  bitmap_obstack_initialize (&ptr->obstack);\n+  ptr->conflicts = VEC_alloc (bitmap, heap, size);\n+  VEC_safe_grow_cleared (bitmap, heap, ptr->conflicts, size);\n   return ptr;\n }\n \n@@ -528,12 +528,8 @@ ssa_conflicts_new (unsigned size)\n static inline void\n ssa_conflicts_delete (ssa_conflicts_p ptr)\n {\n-  unsigned x;\n-  for (x = 0; x < ptr->size; x++)\n-    if (ptr->conflicts[x])\n-      BITMAP_FREE (ptr->conflicts[x]);\n-\n-  free (ptr->conflicts);\n+  bitmap_obstack_release (&ptr->obstack);\n+  VEC_free (bitmap, heap, ptr->conflicts);\n   free (ptr);\n }\n \n@@ -543,16 +539,14 @@ ssa_conflicts_delete (ssa_conflicts_p ptr)\n static inline bool\n ssa_conflicts_test_p (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n-  bitmap b;\n+  bitmap bx = VEC_index (bitmap, ptr->conflicts, x);\n+  bitmap by = VEC_index (bitmap, ptr->conflicts, y);\n \n-  gcc_checking_assert (x < ptr->size);\n-  gcc_checking_assert (y < ptr->size);\n   gcc_checking_assert (x != y);\n \n-  b = ptr->conflicts[x];\n-  if (b)\n+  if (bx)\n     /* Avoid the lookup if Y has no conflicts.  */\n-    return ptr->conflicts[y] ? bitmap_bit_p (b, y) : false;\n+    return by ? bitmap_bit_p (bx, y) : false;\n   else\n     return false;\n }\n@@ -563,10 +557,11 @@ ssa_conflicts_test_p (ssa_conflicts_p ptr, unsigned x, unsigned y)\n static inline void\n ssa_conflicts_add_one (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n+  bitmap bx = VEC_index (bitmap, ptr->conflicts, x);\n   /* If there are no conflicts yet, allocate the bitmap and set bit.  */\n-  if (!ptr->conflicts[x])\n-    ptr->conflicts[x] = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (ptr->conflicts[x], y);\n+  if (! bx)\n+    bx = VEC_index (bitmap, ptr->conflicts, x) = BITMAP_ALLOC (&ptr->obstack);\n+  bitmap_set_bit (bx, y);\n }\n \n \n@@ -575,8 +570,6 @@ ssa_conflicts_add_one (ssa_conflicts_p ptr, unsigned x, unsigned y)\n static inline void\n ssa_conflicts_add (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n-  gcc_checking_assert (x < ptr->size);\n-  gcc_checking_assert (y < ptr->size);\n   gcc_checking_assert (x != y);\n   ssa_conflicts_add_one (ptr, x, y);\n   ssa_conflicts_add_one (ptr, y, x);\n@@ -590,29 +583,35 @@ ssa_conflicts_merge (ssa_conflicts_p ptr, unsigned x, unsigned y)\n {\n   unsigned z;\n   bitmap_iterator bi;\n+  bitmap bx = VEC_index (bitmap, ptr->conflicts, x);\n+  bitmap by = VEC_index (bitmap, ptr->conflicts, y);\n \n-  gcc_assert (x != y);\n-  if (!(ptr->conflicts[y]))\n+  gcc_checking_assert (x != y);\n+  if (! by)\n     return;\n \n   /* Add a conflict between X and every one Y has.  If the bitmap doesn't\n      exist, then it has already been coalesced, and we don't need to add a\n      conflict.  */\n-  EXECUTE_IF_SET_IN_BITMAP (ptr->conflicts[y], 0, z, bi)\n-    if (ptr->conflicts[z])\n-      bitmap_set_bit (ptr->conflicts[z], x);\n+  EXECUTE_IF_SET_IN_BITMAP (by, 0, z, bi)\n+    {\n+      bitmap bz = VEC_index (bitmap, ptr->conflicts, z);\n+      if (bz)\n+\tbitmap_set_bit (bz, x);\n+    }\n \n-  if (ptr->conflicts[x])\n+  if (bx)\n     {\n       /* If X has conflicts, add Y's to X.  */\n-      bitmap_ior_into (ptr->conflicts[x], ptr->conflicts[y]);\n-      BITMAP_FREE (ptr->conflicts[y]);\n+      bitmap_ior_into (bx, by);\n+      BITMAP_FREE (by);\n+      VEC_replace (bitmap, ptr->conflicts, y, NULL);\n     }\n   else\n     {\n       /* If X has no conflicts, simply use Y's.  */\n-      ptr->conflicts[x] = ptr->conflicts[y];\n-      ptr->conflicts[y] = NULL;\n+      VEC_replace (bitmap, ptr->conflicts, x, by);\n+      VEC_replace (bitmap, ptr->conflicts, y, NULL);\n     }\n }\n \n@@ -623,14 +622,15 @@ static void\n ssa_conflicts_dump (FILE *file, ssa_conflicts_p ptr)\n {\n   unsigned x;\n+  bitmap b;\n \n   fprintf (file, \"\\nConflict graph:\\n\");\n \n-  for (x = 0; x < ptr->size; x++)\n-    if (ptr->conflicts[x])\n+  FOR_EACH_VEC_ELT (bitmap, ptr->conflicts, x, b);\n+    if (b)\n       {\n \tfprintf (dump_file, \"%d: \", x);\n-\tdump_bitmap (file, ptr->conflicts[x]);\n+\tdump_bitmap (file, b);\n       }\n }\n \n@@ -649,6 +649,7 @@ ssa_conflicts_dump (FILE *file, ssa_conflicts_p ptr)\n \n typedef struct live_track_d\n {\n+  bitmap_obstack obstack;\t/* A place to allocate our bitmaps.  */\n   bitmap live_base_var;\t\t/* Indicates if a basevar is live.  */\n   bitmap *live_base_partitions;\t/* Live partitions for each basevar.  */\n   var_map map;\t\t\t/* Var_map being used for partition mapping.  */\n@@ -670,10 +671,11 @@ new_live_track (var_map map)\n   ptr = (live_track_p) xmalloc (sizeof (struct live_track_d));\n   ptr->map = map;\n   lim = num_basevars (map);\n+  bitmap_obstack_initialize (&ptr->obstack);\n   ptr->live_base_partitions = (bitmap *) xmalloc(sizeof (bitmap *) * lim);\n-  ptr->live_base_var = BITMAP_ALLOC (NULL);\n+  ptr->live_base_var = BITMAP_ALLOC (&ptr->obstack);\n   for (x = 0; x < lim; x++)\n-    ptr->live_base_partitions[x] = BITMAP_ALLOC (NULL);\n+    ptr->live_base_partitions[x] = BITMAP_ALLOC (&ptr->obstack);\n   return ptr;\n }\n \n@@ -683,12 +685,7 @@ new_live_track (var_map map)\n static void\n delete_live_track (live_track_p ptr)\n {\n-  int x, lim;\n-\n-  lim = num_basevars (ptr->map);\n-  for (x = 0; x < lim; x++)\n-    BITMAP_FREE (ptr->live_base_partitions[x]);\n-  BITMAP_FREE (ptr->live_base_var);\n+  bitmap_obstack_release (&ptr->obstack);\n   free (ptr->live_base_partitions);\n   free (ptr);\n }\n@@ -1046,10 +1043,11 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\tnoutputs = gimple_asm_noutputs (stmt);\n \t\tninputs = gimple_asm_ninputs (stmt);\n \t\toutputs = (tree *) alloca (noutputs * sizeof (tree));\n-\t\tfor (i = 0; i < noutputs; ++i) {\n-\t\t  link = gimple_asm_output_op (stmt, i);\n-\t\t  outputs[i] = TREE_VALUE (link);\n-                }\n+\t\tfor (i = 0; i < noutputs; ++i)\n+\t\t  {\n+\t\t    link = gimple_asm_output_op (stmt, i);\n+\t\t    outputs[i] = TREE_VALUE (link);\n+\t\t  }\n \n \t\tfor (i = 0; i < ninputs; ++i)\n \t\t  {"}]}