{"sha": "1be715f31605976d8e4336973d3b81c5b7cea79f", "node_id": "C_kwDOANBUbNoAKDFiZTcxNWYzMTYwNTk3NmQ4ZTQzMzY5NzNkM2I4MWM1YjdjZWE3OWY", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wilco.dijkstra@arm.com", "date": "2022-05-18T15:02:12Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2022-05-20T14:10:37Z"}, "message": "AArch64: Cleanup CPU option processing code\n\nThe --with-cpu/--with-arch configure option processing not only checks valid\narguments but also sets TARGET_CPU_DEFAULT with a CPU and extension bitmask.\nThis isn't used however since a --with-cpu is translated into a -mcpu option\nwhich is processed as if written on the command-line (so TARGET_CPU_DEFAULT\nis never accessed).\n\nSo remove all the complex processing and bitmask, and just validate the\noption. Fix a bug that always reports valid architecture extensions as invalid.\nAs a result the CPU processing in aarch64.c can be simplified.\n\ngcc/\n\t* config.gcc (aarch64*-*-*): Simplify --with-cpu and --with-arch\n\tprocessing.  Add support for architectural extensions.\n\t* config/aarch64/aarch64.h (TARGET_CPU_DEFAULT): Remove\n\tAARCH64_CPU_DEFAULT_FLAGS.\n\t(TARGET_CPU_NBITS): Remove.\n\t(TARGET_CPU_MASK): Remove.\n\t* config/aarch64/aarch64.cc (AARCH64_CPU_DEFAULT_FLAGS): Remove define.\n\t(get_tune_cpu): Assert CPU is always valid.\n\t(get_arch): Assert architecture is always valid.\n\t(aarch64_override_options): Cleanup CPU selection code and simplify logic.\n\t(aarch64_option_restore): Remove unnecessary checks on tune.", "tree": {"sha": "0adb70628d3362e551d54c5edb49a5f3b08116e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0adb70628d3362e551d54c5edb49a5f3b08116e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1be715f31605976d8e4336973d3b81c5b7cea79f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be715f31605976d8e4336973d3b81c5b7cea79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be715f31605976d8e4336973d3b81c5b7cea79f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be715f31605976d8e4336973d3b81c5b7cea79f/comments", "author": {"login": "Wilco1", "id": 58446312, "node_id": "MDQ6VXNlcjU4NDQ2MzEy", "avatar_url": "https://avatars.githubusercontent.com/u/58446312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Wilco1", "html_url": "https://github.com/Wilco1", "followers_url": "https://api.github.com/users/Wilco1/followers", "following_url": "https://api.github.com/users/Wilco1/following{/other_user}", "gists_url": "https://api.github.com/users/Wilco1/gists{/gist_id}", "starred_url": "https://api.github.com/users/Wilco1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Wilco1/subscriptions", "organizations_url": "https://api.github.com/users/Wilco1/orgs", "repos_url": "https://api.github.com/users/Wilco1/repos", "events_url": "https://api.github.com/users/Wilco1/events{/privacy}", "received_events_url": "https://api.github.com/users/Wilco1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff171cb13df671a2a0647a68da0fdc1f9a78b8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff171cb13df671a2a0647a68da0fdc1f9a78b8c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff171cb13df671a2a0647a68da0fdc1f9a78b8c9"}], "stats": {"total": 167, "additions": 32, "deletions": 135}, "files": [{"sha": "b48d5451e8027c93fb1f614812589183d0a88c4b", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=1be715f31605976d8e4336973d3b81c5b7cea79f", "patch": "@@ -4178,32 +4178,13 @@ case \"${target}\" in\n \t\t\t  pattern=AARCH64_CORE\n \t\t\tfi\n \n-\t\t\text_mask=AARCH64_CPU_DEFAULT_FLAGS\n-\n \t\t\t# Find the base CPU or ARCH id in aarch64-cores.def or\n \t\t\t# aarch64-arches.def\n \t\t\tif [ x\"$base_val\" = x ] \\\n \t\t\t    || grep \"^$pattern(\\\"$base_val\\\",\" \\\n \t\t\t\t    ${srcdir}/config/aarch64/$def \\\n \t\t\t\t    > /dev/null; then\n \n-\t\t\t  if [ $which = arch ]; then\n-\t\t\t\tbase_id=`grep \"^$pattern(\\\"$base_val\\\",\" \\\n-\t\t\t\t  ${srcdir}/config/aarch64/$def | \\\n-\t\t\t\t  sed -e 's/^[^,]*,[ \t]*//' | \\\n-\t\t\t\t  sed -e 's/,.*$//'`\n-\t\t\t\t# Extract the architecture flags from aarch64-arches.def\n-\t\t\t\text_mask=`grep \"^$pattern(\\\"$base_val\\\",\" \\\n-\t\t\t\t   ${srcdir}/config/aarch64/$def | \\\n-\t\t\t\t   sed -e 's/)$//' | \\\n-\t\t\t\t   sed -e 's/^.*,//'`\n-\t\t\t  else\n-\t\t\t\tbase_id=`grep \"^$pattern(\\\"$base_val\\\",\" \\\n-\t\t\t\t  ${srcdir}/config/aarch64/$def | \\\n-\t\t\t\t  sed -e 's/^[^,]*,[ \t]*//' | \\\n-\t\t\t\t  sed -e 's/,.*$//'`\n-\t\t\t  fi\n-\n \t\t\t  # Disallow extensions in --with-tune=cortex-a53+crc.\n \t\t\t  if [ $which = tune ] && [ x\"$ext_val\" != x ]; then\n \t\t\t    echo \"Architecture extensions not supported in --with-$which=$val\" 1>&2\n@@ -4234,25 +4215,7 @@ case \"${target}\" in\n \t\t\t\t\tgrep \"^\\\"$base_ext\\\"\"`\n \n \t\t\t\tif [ x\"$base_ext\" = x ] \\\n-\t\t\t\t    || [[ -n $opt_line ]]; then\n-\n-\t\t\t\t  # These regexp extract the elements based on\n-\t\t\t\t  # their group match index in the regexp.\n-\t\t\t\t  ext_canon=`echo -e \"$opt_line\" | \\\n-\t\t\t\t\tsed -e \"s/$sed_patt/\\2/\"`\n-\t\t\t\t  ext_on=`echo -e \"$opt_line\" | \\\n-\t\t\t\t\tsed -e \"s/$sed_patt/\\3/\"`\n-\t\t\t\t  ext_off=`echo -e \"$opt_line\" | \\\n-\t\t\t\t\tsed -e \"s/$sed_patt/\\4/\"`\n-\n-\t\t\t\t  if [ $ext = $base_ext ]; then\n-\t\t\t\t\t# Adding extension\n-\t\t\t\t\text_mask=\"(\"$ext_mask\") | (\"$ext_on\" | \"$ext_canon\")\"\n-\t\t\t\t  else\n-\t\t\t\t\t# Removing extension\n-\t\t\t\t\text_mask=\"(\"$ext_mask\") & ~(\"$ext_off\" | \"$ext_canon\")\"\n-\t\t\t\t  fi\n-\n+\t\t\t\t    || [ x\"$opt_line\" != x ]; then\n \t\t\t\t  true\n \t\t\t\telse\n \t\t\t\t  echo \"Unknown extension used in --with-$which=$val\" 1>&2\n@@ -4261,10 +4224,6 @@ case \"${target}\" in\n \t\t\t\text_val=`echo $ext_val | sed -e 's/[a-z0-9]\\+//'`\n \t\t\t  done\n \n-\t\t\t  ext_mask=\"((\"$ext_mask\") << TARGET_CPU_NBITS)\"\n-\t\t\t  if [ x\"$base_id\" != x ]; then\n-\t\t\t\ttarget_cpu_cname=\"TARGET_CPU_$base_id | $ext_mask\"\n-\t\t\t  fi\n \t\t\t  true\n \t\t\telse\n \t\t\t  # Allow --with-$which=native."}, {"sha": "ba5b6be850a27920a0e35df134cdc9c3e3a223f3", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 30, "deletions": 85, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=1be715f31605976d8e4336973d3b81c5b7cea79f", "patch": "@@ -2760,8 +2760,6 @@ static const struct attribute_spec aarch64_attribute_table[] =\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n };\n \n-#define AARCH64_CPU_DEFAULT_FLAGS ((selected_cpu) ? selected_cpu->flags : 0)\n-\n /* An ISA extension in the co-processor and main instruction set space.  */\n struct aarch64_option_extension\n {\n@@ -18067,39 +18065,24 @@ aarch64_validate_mtune (const char *str, const struct processor **res)\n   return false;\n }\n \n-static_assert (TARGET_CPU_generic < TARGET_CPU_MASK,\n-\t       \"TARGET_CPU_NBITS is big enough\");\n-\n-/* Return the CPU corresponding to the enum CPU.\n-   If it doesn't specify a cpu, return the default.  */\n+/* Return the CPU corresponding to the enum CPU.  */\n \n static const struct processor *\n aarch64_get_tune_cpu (enum aarch64_processor cpu)\n {\n-  if (cpu != aarch64_none)\n-    return &all_cores[cpu];\n+  gcc_assert (cpu != aarch64_none);\n \n-  /* The & TARGET_CPU_MASK is to extract the bottom TARGET_CPU_NBITS bits that\n-     encode the default cpu as selected by the --with-cpu GCC configure option\n-     in config.gcc.\n-     ???: The whole TARGET_CPU_DEFAULT and AARCH64_CPU_DEFAULT_FLAGS\n-     flags mechanism should be reworked to make it more sane.  */\n-  return &all_cores[TARGET_CPU_DEFAULT & TARGET_CPU_MASK];\n+  return &all_cores[cpu];\n }\n \n-/* Return the architecture corresponding to the enum ARCH.\n-   If it doesn't specify a valid architecture, return the default.  */\n+/* Return the architecture corresponding to the enum ARCH.  */\n \n static const struct processor *\n aarch64_get_arch (enum aarch64_arch arch)\n {\n-  if (arch != aarch64_no_arch)\n-    return &all_architectures[arch];\n-\n-  const struct processor *cpu\n-    = &all_cores[TARGET_CPU_DEFAULT & TARGET_CPU_MASK];\n+  gcc_assert (arch != aarch64_no_arch);\n \n-  return &all_architectures[cpu->arch];\n+  return &all_architectures[arch];\n }\n \n /* Return the VG value associated with -msve-vector-bits= value VALUE.  */\n@@ -18137,10 +18120,6 @@ aarch64_override_options (void)\n   uint64_t arch_isa = 0;\n   aarch64_isa_flags = 0;\n \n-  bool valid_cpu = true;\n-  bool valid_tune = true;\n-  bool valid_arch = true;\n-\n   selected_cpu = NULL;\n   selected_arch = NULL;\n   selected_tune = NULL;\n@@ -18155,77 +18134,56 @@ aarch64_override_options (void)\n      If either of -march or -mtune is given, they override their\n      respective component of -mcpu.  */\n   if (aarch64_cpu_string)\n-    valid_cpu = aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu,\n-\t\t\t\t\t&cpu_isa);\n+    aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu, &cpu_isa);\n \n   if (aarch64_arch_string)\n-    valid_arch = aarch64_validate_march (aarch64_arch_string, &selected_arch,\n-\t\t\t\t\t  &arch_isa);\n+    aarch64_validate_march (aarch64_arch_string, &selected_arch, &arch_isa);\n \n   if (aarch64_tune_string)\n-    valid_tune = aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n+    aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n \n-  /* If the user did not specify a processor, choose the default\n-     one for them.  This will be the CPU set during configuration using\n-     --with-cpu, otherwise it is \"generic\".  */\n-  if (!selected_cpu)\n-    {\n-      if (selected_arch)\n-\t{\n-\t  selected_cpu = &all_cores[selected_arch->ident];\n-\t  aarch64_isa_flags = arch_isa;\n-\t  explicit_arch = selected_arch->arch;\n-\t}\n-      else\n-\t{\n-\t  /* Get default configure-time CPU.  */\n-\t  selected_cpu = aarch64_get_tune_cpu (aarch64_none);\n-\t  aarch64_isa_flags = TARGET_CPU_DEFAULT >> TARGET_CPU_NBITS;\n-\t}\n-\n-      if (selected_tune)\n-\texplicit_tune_core = selected_tune->ident;\n-    }\n-  /* If both -mcpu and -march are specified check that they are architecturally\n-     compatible, warn if they're not and prefer the -march ISA flags.  */\n-  else if (selected_arch)\n+  if (selected_cpu && selected_arch)\n     {\n+      /* If both -mcpu and -march are specified, warn if they are not\n+\t architecturally compatible and prefer the -march ISA flags.  */\n       if (selected_arch->arch != selected_cpu->arch)\n \t{\n \t  warning (0, \"switch %<-mcpu=%s%> conflicts with %<-march=%s%> switch\",\n \t\t       aarch64_cpu_string,\n \t\t       aarch64_arch_string);\n \t}\n+\n       aarch64_isa_flags = arch_isa;\n-      explicit_arch = selected_arch->arch;\n-      explicit_tune_core = selected_tune ? selected_tune->ident\n-\t\t\t\t\t  : selected_cpu->ident;\n     }\n-  else\n+  else if (selected_cpu)\n     {\n-      /* -mcpu but no -march.  */\n-      aarch64_isa_flags = cpu_isa;\n-      explicit_tune_core = selected_tune ? selected_tune->ident\n-\t\t\t\t\t  : selected_cpu->ident;\n-      gcc_assert (selected_cpu);\n       selected_arch = &all_architectures[selected_cpu->arch];\n-      explicit_arch = selected_arch->arch;\n+      aarch64_isa_flags = cpu_isa;\n     }\n-\n-  /* Set the arch as well as we will need it when outputing\n-     the .arch directive in assembly.  */\n-  if (!selected_arch)\n+  else if (selected_arch)\n     {\n-      gcc_assert (selected_cpu);\n+      selected_cpu = &all_cores[selected_arch->ident];\n+      aarch64_isa_flags = arch_isa;\n+    }\n+  else\n+    {\n+      /* No -mcpu or -march specified, so use the default CPU.  */\n+      selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n       selected_arch = &all_architectures[selected_cpu->arch];\n+      aarch64_isa_flags = selected_cpu->flags;\n     }\n \n+  explicit_arch = selected_arch->arch;\n   if (!selected_tune)\n     selected_tune = selected_cpu;\n+  explicit_tune_core = selected_tune->ident;\n+\n+  gcc_assert (explicit_tune_core != aarch64_none);\n+  gcc_assert (explicit_arch != aarch64_no_arch);\n \n   if (aarch64_enable_bti == 2)\n     {\n@@ -18261,15 +18219,6 @@ aarch64_override_options (void)\n   if (aarch64_ra_sign_scope != AARCH64_FUNCTION_NONE && TARGET_ILP32)\n     sorry (\"return address signing is only supported for %<-mabi=lp64%>\");\n \n-  /* Make sure we properly set up the explicit options.  */\n-  if ((aarch64_cpu_string && valid_cpu)\n-       || (aarch64_tune_string && valid_tune))\n-    gcc_assert (explicit_tune_core != aarch64_none);\n-\n-  if ((aarch64_cpu_string && valid_cpu)\n-       || (aarch64_arch_string && valid_arch))\n-    gcc_assert (explicit_arch != aarch64_no_arch);\n-\n   /* The pass to insert speculation tracking runs before\n      shrink-wrapping and the latter does not know how to update the\n      tracking status.  So disable it in this case.  */\n@@ -18375,11 +18324,7 @@ aarch64_option_restore (struct gcc_options *opts,\n   opts->x_explicit_arch = ptr->x_explicit_arch;\n   selected_arch = aarch64_get_arch (ptr->x_explicit_arch);\n   opts->x_explicit_tune_core = ptr->x_explicit_tune_core;\n-  if (opts->x_explicit_tune_core == aarch64_none\n-      && opts->x_explicit_arch != aarch64_no_arch)\n-    selected_tune = &all_cores[selected_arch->ident];\n-  else\n-    selected_tune = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n+  selected_tune = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n   opts->x_aarch64_override_tune_string = ptr->x_aarch64_override_tune_string;\n   opts->x_aarch64_branch_protection_string\n     = ptr->x_aarch64_branch_protection_string;"}, {"sha": "f835da33b72f36bbf25a0e1328135411bd8ab4f6", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be715f31605976d8e4336973d3b81c5b7cea79f/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=1be715f31605976d8e4336973d3b81c5b7cea79f", "patch": "@@ -813,16 +813,9 @@ enum target_cpus\n   TARGET_CPU_generic\n };\n \n-/* Define how many bits are used to represent the CPU in TARGET_CPU_DEFAULT.\n-   This needs to be big enough to fit the value of TARGET_CPU_generic.\n-   All bits after this are used to represent the AARCH64_CPU_DEFAULT_FLAGS.  */\n-#define TARGET_CPU_NBITS 8\n-#define TARGET_CPU_MASK ((1 << TARGET_CPU_NBITS) - 1)\n-\n /* If there is no CPU defined at configure, use generic as default.  */\n #ifndef TARGET_CPU_DEFAULT\n-#define TARGET_CPU_DEFAULT \\\n-  (TARGET_CPU_generic | (AARCH64_CPU_DEFAULT_FLAGS << TARGET_CPU_NBITS))\n+# define TARGET_CPU_DEFAULT TARGET_CPU_generic\n #endif\n \n /* If inserting NOP before a mult-accumulate insn remember to adjust the"}]}