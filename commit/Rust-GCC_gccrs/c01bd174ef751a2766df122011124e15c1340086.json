{"sha": "c01bd174ef751a2766df122011124e15c1340086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxYmQxNzRlZjc1MWEyNzY2ZGYxMjIwMTExMjRlMTVjMTM0MDA4Ng==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2019-11-07T23:54:49Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2019-11-07T23:54:49Z"}, "message": "Expand C2x attribute parsing support and factor out from TM attributes.\n\nThere is one place in the C parser that already handles a subset of\nthe C2x [[]] attribute syntax: c_parser_transaction_attributes.\n\nThis patch factors C2x attribute parsing out of there, extending it to\ncover the full C2x attribute syntax (although currently only called\nfrom that one place in the parser - so this is another piece of\npreparation for supporting C2x attributes in the places where C2x says\nthey are valid, not the patch that actually enables such support).\nThe new C2X attribute parsing code uses the same representation for\nscoped attributes as C++ does, so requiring parse_tm_stmt_attr to\nhandle the scoped attributes representation (C++ currently\nspecial-cases TM attributes \"to avoid the pedwarn in C++98 mode\"; in C\nI'm using an argument to c_parser_std_attribute_specifier to disable\nthe pedwarn_c11 call in the TM case).\n\nParsing of arguments to known attributes is shared by GNU and C2x\nattributes.  C2x specifies that unknown attributes are ignored (GCC\npractice in such a case is to warn along with ignoring the attribute)\nand gives a very general balanced-token-sequence syntax for arguments\nto unknown attributes (known ones each have their own syntax which is\na subset of balanced-token-sequence), so support is added for parsing\nand ignoring such balanced-token-sequences as arguments of unknown\nattributes.\n\nSome limited tests are added of different attribute usages in the TM\nattribute case.  The cases that become valid in the TM case include\nextra commas inside [[]], and an explicit \"gnu\" namespace, as the\nextra commas have no semantic effect for C2x attributes, while\naccepting the \"gnu\" namespace seems appropriate because the attribute\nin question is accepted inside __attribute__ (()), which is considered\nequivalent to the \"gnu\" namespace inside [[]].\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\ngcc/c:\n\t* c-parser.c (c_parser_attribute_arguments): New function.\n\tFactored out of c_parser_gnu_attribute.\n\t(c_parser_gnu_attribute): Use c_parser_attribute_arguments.\n\t(c_parser_balanced_token_sequence, c_parser_std_attribute)\n\t(c_parser_std_attribute_specifier): New functions.\n\t(c_parser_transaction_attributes): Use\n\tc_parser_std_attribute_specifier.\n\ngcc/c-family:\n\t* c-attribs.c (parse_tm_stmt_attr): Handle scoped attributes.\n\ngcc/testsuite:\n\t* gcc.dg/tm/attrs-1.c: New test.\n\t* gcc.dg/tm/props-5.c: New test.  Based on props-4.c.\n\nFrom-SVN: r277935", "tree": {"sha": "eb428d933f655e452a70a3c5262045ec3df4e32c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb428d933f655e452a70a3c5262045ec3df4e32c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01bd174ef751a2766df122011124e15c1340086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01bd174ef751a2766df122011124e15c1340086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01bd174ef751a2766df122011124e15c1340086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01bd174ef751a2766df122011124e15c1340086/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4b579686d1cd4cfff2b8c6397e07d6eea2ff45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4b579686d1cd4cfff2b8c6397e07d6eea2ff45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4b579686d1cd4cfff2b8c6397e07d6eea2ff45"}], "stats": {"total": 437, "additions": 357, "deletions": 80}, "files": [{"sha": "39e7d5acb9cd592d01ddc60b365a07ae3983cd31", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -1,3 +1,7 @@\n+2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-attribs.c (parse_tm_stmt_attr): Handle scoped attributes.\n+\n 2019-11-05  Jason Merrill  <jason@redhat.com>\n \n \t* c-opts.c (c_common_post_options): -fconcepts-ts implies"}, {"sha": "c62cebf7bfdbf86f5adcef85af84ab4b0c349027", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -3227,10 +3227,12 @@ parse_tm_stmt_attr (tree attrs, int allowed)\n \n   for ( ; attrs ; attrs = TREE_CHAIN (attrs))\n     {\n-      tree a = TREE_PURPOSE (attrs);\n+      tree a = get_attribute_name (attrs);\n+      tree ns = get_attribute_namespace (attrs);\n       int m = 0;\n \n-      if (is_attribute_p (\"outer\", a))\n+      if (is_attribute_p (\"outer\", a)\n+\t  && (ns == NULL_TREE || strcmp (IDENTIFIER_POINTER (ns), \"gnu\") == 0))\n \tm = TM_STMT_ATTR_OUTER;\n \n       if ((m & allowed) == 0)"}, {"sha": "29be902ebc63c333946dcb8d877534c1ac6d3612", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -1,3 +1,13 @@\n+2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.c (c_parser_attribute_arguments): New function.\n+\tFactored out of c_parser_gnu_attribute.\n+\t(c_parser_gnu_attribute): Use c_parser_attribute_arguments.\n+\t(c_parser_balanced_token_sequence, c_parser_std_attribute)\n+\t(c_parser_std_attribute_specifier): New functions.\n+\t(c_parser_transaction_attributes): Use\n+\tc_parser_std_attribute_specifier.\n+\n 2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c (c_parser): Remove lex_untranslated_string.  Add"}, {"sha": "ed6a9dd74eed26086ecaffd4842f9164527e6f8a", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 269, "deletions": 78, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -4308,6 +4308,70 @@ c_parser_gnu_attribute_any_word (c_parser *parser)\n   return attr_name;\n }\n \n+/* Parse attribute arguments.  This is a common form of syntax\n+   covering all currently valid GNU and standard attributes.\n+\n+   gnu-attribute-arguments:\n+     identifier\n+     identifier , nonempty-expr-list\n+     expr-list\n+\n+   where the \"identifier\" must not be declared as a type.  ??? Why not\n+   allow identifiers declared as types to start the arguments?  */\n+\n+static tree\n+c_parser_attribute_arguments (c_parser *parser, bool takes_identifier)\n+{\n+  vec<tree, va_gc> *expr_list;\n+  tree attr_args;\n+  /* Parse the attribute contents.  If they start with an\n+     identifier which is followed by a comma or close\n+     parenthesis, then the arguments start with that\n+     identifier; otherwise they are an expression list.\n+     In objective-c the identifier may be a classname.  */\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      && (c_parser_peek_token (parser)->id_kind == C_ID_ID\n+\t  || (c_dialect_objc ()\n+\t      && c_parser_peek_token (parser)->id_kind\n+\t      == C_ID_CLASSNAME))\n+      && ((c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n+\t  || (c_parser_peek_2nd_token (parser)->type\n+\t      == CPP_CLOSE_PAREN))\n+      && (takes_identifier\n+\t  || (c_dialect_objc ()\n+\t      && c_parser_peek_token (parser)->id_kind\n+\t      == C_ID_CLASSNAME)))\n+    {\n+      tree arg1 = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tattr_args = build_tree_list (NULL_TREE, arg1);\n+      else\n+\t{\n+\t  tree tree_list;\n+\t  c_parser_consume_token (parser);\n+\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t  NULL, NULL, NULL, NULL);\n+\t  tree_list = build_tree_list_vec (expr_list);\n+\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n+\t  release_tree_vector (expr_list);\n+\t}\n+    }\n+  else\n+    {\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\tattr_args = NULL_TREE;\n+      else\n+\t{\n+\t  expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t  NULL, NULL, NULL, NULL);\n+\t  attr_args = build_tree_list_vec (expr_list);\n+\t  release_tree_vector (expr_list);\n+\t}\n+    }\n+  return attr_args;\n+}\n+\n /* Parse (possibly empty) gnu-attributes.  This is a GNU extension.\n \n    gnu-attributes:\n@@ -4324,16 +4388,12 @@ c_parser_gnu_attribute_any_word (c_parser *parser)\n    gnu-attrib:\n      empty\n      any-word\n-     any-word ( identifier )\n-     any-word ( identifier , nonempty-expr-list )\n-     any-word ( expr-list )\n+     any-word ( gnu-attribute-arguments )\n \n-   where the \"identifier\" must not be declared as a type, and\n-   \"any-word\" may be any identifier (including one declared as a\n+   where \"any-word\" may be any identifier (including one declared as a\n    type), a reserved word storage class specifier, type specifier or\n    type qualifier.  ??? This still leaves out most reserved keywords\n-   (following the old parser), shouldn't we include them, and why not\n-   allow identifiers declared as types to start the arguments?\n+   (following the old parser), shouldn't we include them?\n    When EXPECT_COMMA is true, expect the attribute to be preceded\n    by a comma and fail if it isn't.\n    When EMPTY_OK is true, allow and consume any number of consecutive\n@@ -4381,53 +4441,9 @@ c_parser_gnu_attribute (c_parser *parser, tree attrs,\n     }\n   c_parser_consume_token (parser);\n \n-  vec<tree, va_gc> *expr_list;\n-  tree attr_args;\n-  /* Parse the attribute contents.  If they start with an\n-     identifier which is followed by a comma or close\n-     parenthesis, then the arguments start with that\n-     identifier; otherwise they are an expression list.\n-     In objective-c the identifier may be a classname.  */\n-  if (c_parser_next_token_is (parser, CPP_NAME)\n-      && (c_parser_peek_token (parser)->id_kind == C_ID_ID\n-\t  || (c_dialect_objc ()\n-\t      && c_parser_peek_token (parser)->id_kind\n-\t      == C_ID_CLASSNAME))\n-      && ((c_parser_peek_2nd_token (parser)->type == CPP_COMMA)\n-\t  || (c_parser_peek_2nd_token (parser)->type\n-\t      == CPP_CLOSE_PAREN))\n-      && (attribute_takes_identifier_p (attr_name)\n-\t  || (c_dialect_objc ()\n-\t      && c_parser_peek_token (parser)->id_kind\n-\t      == C_ID_CLASSNAME)))\n-    {\n-      tree arg1 = c_parser_peek_token (parser)->value;\n-      c_parser_consume_token (parser);\n-      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\tattr_args = build_tree_list (NULL_TREE, arg1);\n-      else\n-\t{\n-\t  tree tree_list;\n-\t  c_parser_consume_token (parser);\n-\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t  NULL, NULL, NULL, NULL);\n-\t  tree_list = build_tree_list_vec (expr_list);\n-\t  attr_args = tree_cons (NULL_TREE, arg1, tree_list);\n-\t  release_tree_vector (expr_list);\n-\t}\n-    }\n-  else\n-    {\n-      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\tattr_args = NULL_TREE;\n-      else\n-\t{\n-\t  expr_list = c_parser_expr_list (parser, false, true,\n-\t\t\t\t\t  NULL, NULL, NULL, NULL);\n-\t  attr_args = build_tree_list_vec (expr_list);\n-\t  release_tree_vector (expr_list);\n-\t}\n-    }\n+  tree attr_args\n+    = c_parser_attribute_arguments (parser,\n+\t\t\t\t    attribute_takes_identifier_p (attr_name));\n \n   attr = build_tree_list (attr_name, attr_args);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -4513,6 +4529,202 @@ c_parser_gnu_attributes (c_parser *parser)\n   return attrs;\n }\n \n+/* Parse an optional balanced token sequence.\n+\n+   balanced-token-sequence:\n+     balanced-token\n+     balanced-token-sequence balanced-token\n+\n+   balanced-token:\n+     ( balanced-token-sequence[opt] )\n+     [ balanced-token-sequence[opt] ]\n+     { balanced-token-sequence[opt] }\n+     any token other than ()[]{}\n+*/\n+\n+static void\n+c_parser_balanced_token_sequence (c_parser *parser)\n+{\n+  while (true)\n+    {\n+      c_token *token = c_parser_peek_token (parser);\n+      switch (token->type)\n+\t{\n+\tcase CPP_OPEN_BRACE:\n+\t  {\n+\t    matching_braces braces;\n+\t    braces.consume_open (parser);\n+\t    c_parser_balanced_token_sequence (parser);\n+\t    braces.require_close (parser);\n+\t    break;\n+\t  }\n+\n+\tcase CPP_OPEN_PAREN:\n+\t  {\n+\t    matching_parens parens;\n+\t    parens.consume_open (parser);\n+\t    c_parser_balanced_token_sequence (parser);\n+\t    parens.require_close (parser);\n+\t    break;\n+\t  }\n+\n+\tcase CPP_OPEN_SQUARE:\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_balanced_token_sequence (parser);\n+\t  c_parser_require (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+\t  break;\n+\n+\tcase CPP_CLOSE_BRACE:\n+\tcase CPP_CLOSE_PAREN:\n+\tcase CPP_CLOSE_SQUARE:\n+\tcase CPP_EOF:\n+\t  return;\n+\n+\tdefault:\n+\t  c_parser_consume_token (parser);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Parse standard (C2X) attributes (including GNU attributes in the\n+   gnu:: namespace).\n+\n+   attribute-specifier-sequence:\n+     attribute-specifier-sequence[opt] attribute-specifier\n+\n+   attribute-specifier:\n+     [ [ attribute-list ] ]\n+\n+   attribute-list:\n+     attribute[opt]\n+     attribute-list, attribute[opt]\n+\n+   attribute:\n+     attribute-token attribute-argument-clause[opt]\n+\n+   attribute-token:\n+     standard-attribute\n+     attribute-prefixed-token\n+\n+   standard-attribute:\n+     identifier\n+\n+   attribute-prefixed-token:\n+     attribute-prefix :: identifier\n+\n+   attribute-prefix:\n+     identifier\n+\n+   attribute-argument-clause:\n+     ( balanced-token-sequence[opt] )\n+\n+   Keywords are accepted as identifiers for this purpose.\n+*/\n+\n+static tree\n+c_parser_std_attribute (c_parser *parser)\n+{\n+  c_token *token = c_parser_peek_token (parser);\n+  tree ns, name, attribute;\n+\n+  /* Parse the attribute-token.  */\n+  if (token->type != CPP_NAME && token->type != CPP_KEYWORD)\n+    {\n+      c_parser_error (parser, \"expected identifier\");\n+      return error_mark_node;\n+    }\n+  name = canonicalize_attr_name (token->value);\n+  c_parser_consume_token (parser);\n+  if (c_parser_next_token_is (parser, CPP_SCOPE))\n+    {\n+      ns = name;\n+      c_parser_consume_token (parser);\n+      token = c_parser_peek_token (parser);\n+      if (token->type != CPP_NAME && token->type != CPP_KEYWORD)\n+\t{\n+\t  c_parser_error (parser, \"expected identifier\");\n+\t  return error_mark_node;\n+\t}\n+      name = canonicalize_attr_name (token->value);\n+      c_parser_consume_token (parser);\n+    }\n+  else\n+    ns = NULL_TREE;\n+  attribute = build_tree_list (build_tree_list (ns, name), NULL_TREE);\n+\n+  /* Parse the arguments, if any.  */\n+  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n+    return attribute;\n+  location_t open_loc = c_parser_peek_token (parser)->location;\n+  matching_parens parens;\n+  parens.consume_open (parser);\n+  const attribute_spec *as = lookup_attribute_spec (TREE_PURPOSE (attribute));\n+  if ((as && as->max_length == 0)\n+      /* Special-case the transactional-memory attribute \"outer\",\n+\t which is specially handled but not registered as an\n+\t attribute, to avoid allowing arbitrary balanced token\n+\t sequences as arguments.  */\n+      || is_attribute_p (\"outer\", name))\n+    {\n+      error_at (open_loc, \"%qE attribute does not take any arguments\", name);\n+      parens.skip_until_found_close (parser);\n+      return error_mark_node;\n+    }\n+  if (as)\n+    {\n+      bool takes_identifier\n+\t= (ns != NULL_TREE\n+\t   && strcmp (IDENTIFIER_POINTER (ns), \"gnu\") == 0\n+\t   && attribute_takes_identifier_p (name));\n+      TREE_VALUE (attribute)\n+\t= c_parser_attribute_arguments (parser, takes_identifier);\n+    }\n+  else\n+    c_parser_balanced_token_sequence (parser);\n+  parens.require_close (parser);\n+  return attribute;\n+}\n+\n+static tree\n+c_parser_std_attribute_specifier (c_parser *parser, bool for_tm)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  if (!c_parser_require (parser, CPP_OPEN_SQUARE, \"expected %<[%>\"))\n+    return NULL_TREE;\n+  if (!c_parser_require (parser, CPP_OPEN_SQUARE, \"expected %<[%>\"))\n+    {\n+      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+      return NULL_TREE;\n+    }\n+  if (!for_tm)\n+    pedwarn_c11 (loc, OPT_Wpedantic,\n+\t\t \"ISO C does not support %<[[]]%> attributes before C2X\");\n+  tree attributes = NULL_TREE;\n+  while (true)\n+    {\n+      c_token *token = c_parser_peek_token (parser);\n+      if (token->type == CPP_CLOSE_SQUARE)\n+\tbreak;\n+      if (token->type == CPP_COMMA)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  continue;\n+\t}\n+      tree attribute = c_parser_std_attribute (parser);\n+      if (attribute != error_mark_node)\n+\t{\n+\t  TREE_CHAIN (attribute) = attributes;\n+\t  attributes = attribute;\n+\t}\n+      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n+\tbreak;\n+    }\n+  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+  return nreverse (attributes);\n+}\n+\n /* Parse a type name (C90 6.5.5, C99 6.7.6, C11 6.7.7).  ALIGNAS_OK\n    says whether alignment specifiers are OK (only in cases that might\n    be the type name of a compound literal).\n@@ -20708,39 +20920,18 @@ c_parser_omp_threadprivate (c_parser *parser)\n \n    transaction-attribute:\n      gnu-attributes\n-     [ [ any-word ] ]\n-\n-   The transactional memory language description is written for C++,\n-   and uses the C++0x attribute syntax.  For compatibility, allow the\n-   bracket style for transactions in C as well.  */\n+     attribute-specifier\n+*/\n \n static tree\n c_parser_transaction_attributes (c_parser *parser)\n {\n-  tree attr_name, attr = NULL;\n-\n   if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n     return c_parser_gnu_attributes (parser);\n \n   if (!c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n     return NULL_TREE;\n-  c_parser_consume_token (parser);\n-  if (!c_parser_require (parser, CPP_OPEN_SQUARE, \"expected %<[%>\"))\n-    goto error1;\n-\n-  attr_name = c_parser_gnu_attribute_any_word (parser);\n-  if (attr_name)\n-    {\n-      c_parser_consume_token (parser);\n-      attr = build_tree_list (attr_name, NULL_TREE);\n-    }\n-  else\n-    c_parser_error (parser, \"expected identifier\");\n-\n-  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n- error1:\n-  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n-  return attr;\n+  return c_parser_std_attribute_specifier (parser, true);\n }\n \n /* Parse a __transaction_atomic or __transaction_relaxed statement"}, {"sha": "c0b019d4b14f4960f80457df067732e7f13031e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -1,3 +1,8 @@\n+2019-11-07  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/tm/attrs-1.c: New test.\n+\t* gcc.dg/tm/props-5.c: New test.  Based on props-4.c.\n+\n 2019-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/cpp2a/spaceship-scalar1-neg.C: Change dg-do from run to"}, {"sha": "a9367473e7e8bb2fd053b1d22f0016693d4b3cc1", "filename": "gcc/testsuite/gcc.dg/tm/attrs-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fattrs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fattrs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fattrs-1.c?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -0,0 +1,39 @@\n+/* Test various erroneous or ignored uses of C2X attribute syntax.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void\n+f1 (void)\n+{\n+  __transaction_atomic [[outer()]] {} /* { dg-error \"does not take any arguments\" } */\n+}\n+\n+void\n+f2 (void)\n+{\n+  __transaction_atomic [[not_a_tm_attribute]] {} /* { dg-warning \"attribute directive ignored\" } */\n+}\n+\n+void\n+f3 (void)\n+{\n+  __transaction_atomic [[unknown_attribute(args of *unknown* attributes need only (be {balanced[(({{[[]]}}))]}!), as per standard C)]] {} /* { dg-warning \"attribute directive ignored\" } */\n+}\n+\n+void\n+f4 (void)\n+{\n+  __transaction_atomic [[gnu::const]] {} /* { dg-warning \"attribute directive ignored\" } */\n+}\n+\n+void\n+f5 (void)\n+{\n+  __transaction_atomic [[bad_namespace::outer]] {} /* { dg-warning \"attribute directive ignored\" } */\n+}\n+\n+void\n+f6 (void)\n+{\n+  __transaction_atomic [[outer, outer]] {} /* { dg-warning \"attribute duplicated\" } */\n+}"}, {"sha": "b358f9e288dcdcbe78b83102f6e0d36908416301", "filename": "gcc/testsuite/gcc.dg/tm/props-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01bd174ef751a2766df122011124e15c1340086/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-5.c?ref=c01bd174ef751a2766df122011124e15c1340086", "patch": "@@ -0,0 +1,26 @@\n+/* This is a copy of props-4.c but with variations in the attribute\n+   syntax.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmedge -fdump-tree-tmmark\" } */\n+\n+int a, b;\n+\n+void __attribute((transaction_may_cancel_outer,noinline)) cancel1()\n+{\n+  __transaction_cancel [[,,,outer,,]];\n+}\n+\n+void\n+foo(void)\n+{\n+  __transaction_atomic [[__gnu__::__outer__]] {\n+    a = 2;\n+    __transaction_atomic {\n+      b = 2;\n+      cancel1();\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" instrumentedCode\" 1 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"hasNoAbort\" 0 \"tmedge\" } } */"}]}