{"sha": "3a4833712f129816b9fa1e45b2bfb915cd3143fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E0ODMzNzEyZjEyOTgxNmI5ZmExZTQ1YjJiZmI5MTVjZDMxNDNmYw==", "commit": {"author": {"name": "Volker Reichelt", "email": "v.reichelt@netcologne.de", "date": "2008-04-09T06:37:30Z"}, "committer": {"name": "Volker Reichelt", "email": "reichelt@gcc.gnu.org", "date": "2008-04-09T06:37:30Z"}, "message": "parser.c (cp_parser_asm_specification_opt): Print CPP_CLOSE_PAREN as `)', not as `('.\n\n\t* parser.c (cp_parser_asm_specification_opt): Print CPP_CLOSE_PAREN\n\tas `)', not as `('.  Fix quotation.\n\t(cp_parser_consume_semicolon_at_end_of_statement): Fix quotation.\n\t(cp_parser_primary_expression): Likewise.\n\t(cp_parser_nested_name_specifier_opt): Likewise.\n\t(cp_parser_postfix_expression): Likewise.\n\t(cp_parser_postfix_open_square_expression): Likewise.\n\t(cp_parser_parenthesized_expression_list): Likewise.\n\t(cp_parser_pseudo_destructor_name): Likewise.\n\t(cp_parser_new_expression): Likewise.\n\t(cp_parser_direct_new_declarator): Likewise.\n\t(cp_parser_delete_expression): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_question_colon_clause): Likewise.\n\t(cp_parser_builtin_offsetof): Likewise.\n\t(cp_parser_trait_expr): Likewise.\n\t(cp_parser_label_for_labeled_statement): Likewise.\n\t(cp_parser_compound_statement): Likewise.\n\t(cp_parser_selection_statement): Likewise.\n\t(cp_parser_condition): Likewise.\n\t(cp_parser_iteration_statement): Likewise.\n\t(cp_parser_already_scoped_statement): Likewise.\n\t(cp_parser_simple_declaration): Likewise.\n\t(cp_parser_linkage_specification): Likewise.\n\t(cp_parser_static_assert): Likewise.\n\t(cp_parser_decltype): Likewise.\n\t(cp_parser_conversion_function_id): Likewise.\n\t(cp_parser_operator_function_id): Likewise.\n\t(cp_parser_operator): Likewise.\n\t(cp_parser_type_parameter): Likewise.\n\t(cp_parser_template_id): Likewise.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_explicit_specialization): Likewise.\n\t(cp_parser_enum_specifier): Likewise.\n\t(cp_parser_namespace_definition): Likewise.\n\t(cp_parser_namespace_alias_definition): Likewise.\n\t(cp_parser_using_declaration): Likewise.\n\t(cp_parser_using_directive): Likewise.\n\t(cp_parser_asm_definition): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_ptr_operator): Likewise.\n\t(cp_parser_parameter_declaration_clause): Likewise.\n\t(cp_parser_initializer_clause): Likewise.\n\t(cp_parser_class_specifier): Likewise.\n\t(cp_parser_member_specification_opt): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_pure_specifier): Likewise.\n\t(cp_parser_constant_initializer): Likewise.\n\t(cp_parser_base_clause): Likewise.\n\t(cp_parser_exception_specification_opt): Likewise.\n\t(cp_parser_try_block): Likewise.\n\t(cp_parser_function_try_block): Likewise.\n\t(cp_parser_handler): Likewise.\n\t(cp_parser_throw_expression): Likewise.\n\t(cp_parser_asm_operand_list): Likewise.\n\t(cp_parser_attributes_opt): Likewise.\n\t(cp_parser_label_declaration): Likewise.\n\t(cp_parser_constructor_declarator_p): Likewise.\n\t(cp_parser_template_declaration_after_export): Likewise.\n\t(cp_parser_single_declaration): Likewise.\n\t(cp_parser_objc_message_expression): Likewise.\n\t(cp_parser_objc_message_args): Likewise.\n\t(cp_parser_objc_encode_expression): Likewise.\n\t(cp_parser_objc_defs_expression): Likewise.\n\t(cp_parser_objc_protocol_expression): Likewise.\n\t(cp_parser_objc_selector_expression): Likewise.\n\t(cp_parser_objc_protocol_refs_opt): Likewise.\n\t(cp_parser_objc_typename): Likewise.\n\t(cp_parser_objc_method_keyword_params): Likewise.\n\t(cp_parser_objc_superclass_or_category): Likewise.\n\t(cp_parser_objc_try_catch_finally_statement): Likewise.\n\t(cp_parser_objc_synchronized_statement): Likewise.\n\t(cp_parser_objc_throw_statement): Likewise.\n\t(cp_parser_omp_var_list_no_open): Likewise.\n\t(cp_parser_omp_clause_default): Likewise.\n\t(cp_parser_omp_clause_if): Likewise.\n\t(cp_parser_omp_clause_num_threads): Likewise.\n\t(cp_parser_omp_clause_reduction): Likewise.\n\t(cp_parser_omp_clause_schedule): Likewise.\n\t(cp_parser_omp_critical): Likewise.\n\t(cp_parser_omp_for_loop): Likewise.\n\t(cp_parser_omp_sections_scope): Likewise.\n\nFrom-SVN: r134127", "tree": {"sha": "edfb78c70209bc599ea5d798d718774d1cc42f7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edfb78c70209bc599ea5d798d718774d1cc42f7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a4833712f129816b9fa1e45b2bfb915cd3143fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4833712f129816b9fa1e45b2bfb915cd3143fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a4833712f129816b9fa1e45b2bfb915cd3143fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4833712f129816b9fa1e45b2bfb915cd3143fc/comments", "author": {"login": "VReichelt", "id": 85767072, "node_id": "MDQ6VXNlcjg1NzY3MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/85767072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VReichelt", "html_url": "https://github.com/VReichelt", "followers_url": "https://api.github.com/users/VReichelt/followers", "following_url": "https://api.github.com/users/VReichelt/following{/other_user}", "gists_url": "https://api.github.com/users/VReichelt/gists{/gist_id}", "starred_url": "https://api.github.com/users/VReichelt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VReichelt/subscriptions", "organizations_url": "https://api.github.com/users/VReichelt/orgs", "repos_url": "https://api.github.com/users/VReichelt/repos", "events_url": "https://api.github.com/users/VReichelt/events{/privacy}", "received_events_url": "https://api.github.com/users/VReichelt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de21c14559ce431d6fcc0b645712cff2a9c0dc0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de21c14559ce431d6fcc0b645712cff2a9c0dc0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de21c14559ce431d6fcc0b645712cff2a9c0dc0c"}], "stats": {"total": 434, "additions": 259, "deletions": 175}, "files": [{"sha": "c2dc0faa5afb775ec9266112c1405821b84b4a5f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4833712f129816b9fa1e45b2bfb915cd3143fc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4833712f129816b9fa1e45b2bfb915cd3143fc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a4833712f129816b9fa1e45b2bfb915cd3143fc", "patch": "@@ -1,5 +1,88 @@\n 2008-04-09  Volker Reichelt  <v.reichelt@netcologne.de>\n \n+\t* parser.c (cp_parser_asm_specification_opt): Print CPP_CLOSE_PAREN\n+\tas `)', not as `('.  Fix quotation.\n+\t(cp_parser_consume_semicolon_at_end_of_statement): Fix quotation.\n+\t(cp_parser_primary_expression): Likewise.\n+\t(cp_parser_nested_name_specifier_opt): Likewise.\n+\t(cp_parser_postfix_expression): Likewise.\n+\t(cp_parser_postfix_open_square_expression): Likewise.\n+\t(cp_parser_parenthesized_expression_list): Likewise.\n+\t(cp_parser_pseudo_destructor_name): Likewise.\n+\t(cp_parser_new_expression): Likewise.\n+\t(cp_parser_direct_new_declarator): Likewise.\n+\t(cp_parser_delete_expression): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_question_colon_clause): Likewise.\n+\t(cp_parser_builtin_offsetof): Likewise.\n+\t(cp_parser_trait_expr): Likewise.\n+\t(cp_parser_label_for_labeled_statement): Likewise.\n+\t(cp_parser_compound_statement): Likewise.\n+\t(cp_parser_selection_statement): Likewise.\n+\t(cp_parser_condition): Likewise.\n+\t(cp_parser_iteration_statement): Likewise.\n+\t(cp_parser_already_scoped_statement): Likewise.\n+\t(cp_parser_simple_declaration): Likewise.\n+\t(cp_parser_linkage_specification): Likewise.\n+\t(cp_parser_static_assert): Likewise.\n+\t(cp_parser_decltype): Likewise.\n+\t(cp_parser_conversion_function_id): Likewise.\n+\t(cp_parser_operator_function_id): Likewise.\n+\t(cp_parser_operator): Likewise.\n+\t(cp_parser_type_parameter): Likewise.\n+\t(cp_parser_template_id): Likewise.\n+\t(cp_parser_explicit_instantiation): Likewise.\n+\t(cp_parser_explicit_specialization): Likewise.\n+\t(cp_parser_enum_specifier): Likewise.\n+\t(cp_parser_namespace_definition): Likewise.\n+\t(cp_parser_namespace_alias_definition): Likewise.\n+\t(cp_parser_using_declaration): Likewise.\n+\t(cp_parser_using_directive): Likewise.\n+\t(cp_parser_asm_definition): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_ptr_operator): Likewise.\n+\t(cp_parser_parameter_declaration_clause): Likewise.\n+\t(cp_parser_initializer_clause): Likewise.\n+\t(cp_parser_class_specifier): Likewise.\n+\t(cp_parser_member_specification_opt): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_pure_specifier): Likewise.\n+\t(cp_parser_constant_initializer): Likewise.\n+\t(cp_parser_base_clause): Likewise.\n+\t(cp_parser_exception_specification_opt): Likewise.\n+\t(cp_parser_try_block): Likewise.\n+\t(cp_parser_function_try_block): Likewise.\n+\t(cp_parser_handler): Likewise.\n+\t(cp_parser_throw_expression): Likewise.\n+\t(cp_parser_asm_operand_list): Likewise.\n+\t(cp_parser_attributes_opt): Likewise.\n+\t(cp_parser_label_declaration): Likewise.\n+\t(cp_parser_constructor_declarator_p): Likewise.\n+\t(cp_parser_template_declaration_after_export): Likewise.\n+\t(cp_parser_single_declaration): Likewise.\n+\t(cp_parser_objc_message_expression): Likewise.\n+\t(cp_parser_objc_message_args): Likewise.\n+\t(cp_parser_objc_encode_expression): Likewise.\n+\t(cp_parser_objc_defs_expression): Likewise.\n+\t(cp_parser_objc_protocol_expression): Likewise.\n+\t(cp_parser_objc_selector_expression): Likewise.\n+\t(cp_parser_objc_protocol_refs_opt): Likewise.\n+\t(cp_parser_objc_typename): Likewise.\n+\t(cp_parser_objc_method_keyword_params): Likewise.\n+\t(cp_parser_objc_superclass_or_category): Likewise.\n+\t(cp_parser_objc_try_catch_finally_statement): Likewise.\n+\t(cp_parser_objc_synchronized_statement): Likewise.\n+\t(cp_parser_objc_throw_statement): Likewise.\n+\t(cp_parser_omp_var_list_no_open): Likewise.\n+\t(cp_parser_omp_clause_default): Likewise.\n+\t(cp_parser_omp_clause_if): Likewise.\n+\t(cp_parser_omp_clause_num_threads): Likewise.\n+\t(cp_parser_omp_clause_reduction): Likewise.\n+\t(cp_parser_omp_clause_schedule): Likewise.\n+\t(cp_parser_omp_critical): Likewise.\n+\t(cp_parser_omp_for_loop): Likewise.\n+\t(cp_parser_omp_sections_scope): Likewise.\n+\n \t* parser.c (cp_parser_template_parameter_list): Simplify.\n \n 2008-04-07  James E. Wilson  <wilson@tuliptree.org>"}, {"sha": "363f91c20b8a61d7d79b306068717a12905c5b32", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 176, "deletions": 175, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4833712f129816b9fa1e45b2bfb915cd3143fc/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4833712f129816b9fa1e45b2bfb915cd3143fc/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a4833712f129816b9fa1e45b2bfb915cd3143fc", "patch": "@@ -2545,7 +2545,7 @@ static void\n cp_parser_consume_semicolon_at_end_of_statement (cp_parser *parser)\n {\n   /* Look for the trailing `;'.  */\n-  if (!cp_parser_require (parser, CPP_SEMICOLON, \"`;'\"))\n+  if (!cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\"))\n     {\n       /* If there is additional (erroneous) input, skip to the end of\n \t the statement.  */\n@@ -3199,7 +3199,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tparser->greater_than_is_operator_p\n \t  = saved_greater_than_is_operator_p;\n \t/* Consume the `)'.  */\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n \t  cp_parser_skip_to_end_of_statement (parser);\n \n \treturn expr;\n@@ -3263,16 +3263,16 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       `va_arg'.  Consume the `__builtin_va_arg' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the opening `('.  */\n-\t    cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\t    cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t    /* Now, parse the assignment-expression.  */\n \t    expression = cp_parser_assignment_expression (parser,\n \t\t\t\t\t\t\t  /*cast_p=*/false);\n \t    /* Look for the `,'.  */\n-\t    cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+\t    cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n \t    /* Parse the type-id.  */\n \t    type = cp_parser_type_id (parser);\n \t    /* Look for the closing `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n \t    if (cp_parser_non_integral_constant_expression (parser,\n@@ -3991,7 +3991,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t\t\t     type_p,\n \t\t\t\t\t     is_declaration);\n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n+      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n \n       /* If we found what we wanted, we keep going; otherwise, we're\n \t done.  */\n@@ -4307,18 +4307,18 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  = \"types may not be defined in casts\";\n \n \t/* Look for the opening `<'.  */\n-\tcp_parser_require (parser, CPP_LESS, \"`<'\");\n+\tcp_parser_require (parser, CPP_LESS, \"%<<%>\");\n \t/* Parse the type to which we are casting.  */\n \ttype = cp_parser_type_id (parser);\n \t/* Look for the closing `>'.  */\n-\tcp_parser_require (parser, CPP_GREATER, \"`>'\");\n+\tcp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n \t/* Restore the old message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n \n \t/* And the expression which is being cast.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \texpression = cp_parser_expression (parser, /*cast_p=*/true);\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n \t/* Only type conversions to integral or enumeration types\n \t   can be used in constant-expressions.  */\n@@ -4363,7 +4363,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Consume the `typeid' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Look for the `(' token.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t/* Types cannot be defined in a `typeid' expression.  */\n \tsaved_message = parser->type_definition_forbidden_message;\n \tparser->type_definition_forbidden_message\n@@ -4379,7 +4379,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Look for the `)' token.  Otherwise, we can't be sure that\n \t   we're not looking at an expression: consider `typeid (int\n \t   (3))', for example.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t/* If all went well, simply lookup the type-id.  */\n \tif (cp_parser_parse_definitely (parser))\n \t  postfix_expression = get_typeid (type);\n@@ -4393,7 +4393,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression);\n \t    /* Look for the `)' token.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t  }\n \t/* Restore the saved message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n@@ -4454,9 +4454,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    type = cp_parser_type_id (parser);\n \t    parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t    /* Look for the `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t    /* Look for the `{'.  */\n-\t    cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n+\t    cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n \t    /* If things aren't going well, there's no need to\n \t       keep going.  */\n \t    if (!cp_parser_error_occurred (parser))\n@@ -4469,7 +4469,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\tif (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t/* Look for the final `}'.  */\n-\t\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+\t\tcp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n \t      }\n \t    /* If that worked, we're definitely looking at a\n \t       compound-literal expression.  */\n@@ -4775,7 +4775,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n     index = cp_parser_expression (parser, /*cast_p=*/false);\n \n   /* Look for the closing `]'.  */\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n \n   /* Build the ARRAY_REF.  */\n   postfix_expression = grok_array_decl (postfix_expression, index);\n@@ -5003,7 +5003,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n   if (non_constant_p)\n     *non_constant_p = false;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return error_mark_node;\n \n   /* Within a parenthesized expression, a `>' token is always\n@@ -5083,7 +5083,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \tcp_lexer_consume_token (parser->lexer);\n       }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     {\n       int ending;\n \n@@ -5160,7 +5160,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \t\t\t     /*check_dependency_p=*/false,\n \t\t\t     /*is_declaration=*/true);\n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n+      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n     }\n   /* If the next token is not a `~', then there might be some\n      additional qualification.  */\n@@ -5186,13 +5186,13 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \treturn;\n \n       /* Look for the `::' token.  */\n-      cp_parser_require (parser, CPP_SCOPE, \"`::'\");\n+      cp_parser_require (parser, CPP_SCOPE, \"%<::%>\");\n     }\n   else\n     *scope = NULL_TREE;\n \n   /* Look for the `~'.  */\n-  cp_parser_require (parser, CPP_COMPL, \"`~'\");\n+  cp_parser_require (parser, CPP_COMPL, \"%<~%>\");\n   /* Look for the type-name again.  We are not responsible for\n      checking that it matches the first type-name.  */\n   *type = cp_parser_nonclass_name (parser);\n@@ -5462,7 +5462,7 @@ cp_parser_new_expression (cp_parser* parser)\n \t\t\t\t   /*current_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `new' operator.  */\n-  cp_parser_require_keyword (parser, RID_NEW, \"`new'\");\n+  cp_parser_require_keyword (parser, RID_NEW, \"%<new%>\");\n   /* There's no easy way to tell a new-placement from the\n      `( type-id )' construct.  */\n   cp_parser_parse_tentatively (parser);\n@@ -5481,7 +5481,7 @@ cp_parser_new_expression (cp_parser* parser)\n       /* Parse the type-id.  */\n       type = cp_parser_type_id (parser);\n       /* Look for the closing `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n       /* There should not be a direct-new-declarator in this production,\n \t but GCC used to allowed this, so we check and emit a sensible error\n \t message for this case.  */\n@@ -5660,7 +5660,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       tree expression;\n \n       /* Look for the opening `['.  */\n-      cp_parser_require (parser, CPP_OPEN_SQUARE, \"`['\");\n+      cp_parser_require (parser, CPP_OPEN_SQUARE, \"%<[%>\");\n       /* The first expression is not required to be constant.  */\n       if (!declarator)\n \t{\n@@ -5692,7 +5692,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t\t\t\t\t   /*allow_non_constant=*/false,\n \t\t\t\t\t   NULL);\n       /* Look for the closing `]'.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n \n       /* Add this bound to the declarator.  */\n       declarator = make_array_declarator (declarator, expression);\n@@ -5749,14 +5749,14 @@ cp_parser_delete_expression (cp_parser* parser)\n \t\t\t\t   /*current_scope_valid_p=*/false)\n        != NULL_TREE);\n   /* Look for the `delete' keyword.  */\n-  cp_parser_require_keyword (parser, RID_DELETE, \"`delete'\");\n+  cp_parser_require_keyword (parser, RID_DELETE, \"%<delete%>\");\n   /* See if the array syntax is in use.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n     {\n       /* Consume the `[' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the `]' token.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n       /* Remember that this is the `[]' construct.  */\n       array_p = true;\n     }\n@@ -5845,7 +5845,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t  /* Look for the type-id.  */\n \t  type = cp_parser_type_id (parser);\n \t  /* Look for the closing `)'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t  parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t}\n \n@@ -6118,7 +6118,7 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n     expr = cp_parser_expression (parser, /*cast_p=*/false);\n \n   /* The next token should be a `:'.  */\n-  cp_parser_require (parser, CPP_COLON, \"`:'\");\n+  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n   /* Parse the assignment-expression.  */\n   assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n \n@@ -6416,11 +6416,11 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   /* Consume the \"__builtin_offsetof\" token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Consume the opening `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   /* Parse the type-id.  */\n   type = cp_parser_type_id (parser);\n   /* Look for the `,'.  */\n-  cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+  cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n \n   /* Build the (type *)null that begins the traditional offsetof macro.  */\n   expr = build_static_cast (build_pointer_type (type), null_pointer_node,\n@@ -6454,7 +6454,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \tdefault:\n \t  /* Error.  We know the following require will fail, but\n \t     that gives the proper error message.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n \t  expr = error_mark_node;\n \t  goto failure;\n@@ -6548,7 +6548,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   /* Consume the token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \n   type1 = cp_parser_type_id (parser);\n \n@@ -6565,7 +6565,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \n   if (binary)\n     {\n-      cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+      cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n  \n       type2 = cp_parser_type_id (parser);\n \n@@ -6581,7 +6581,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \t\t\t      /*initialized=*/0, /*attrlist=*/NULL);\n     }\n \n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   /* Complete the trait expression, which may mean either processing\n      the trait expr now or saving it for template instantiation.  */\n@@ -6826,7 +6826,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n     }\n \n   /* Require the `:' token.  */\n-  cp_parser_require (parser, CPP_COLON, \"`:'\");\n+  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n }\n \n /* Parse an expression-statement.\n@@ -6888,7 +6888,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   tree compound_stmt;\n \n   /* Consume the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n     return error_mark_node;\n   /* Begin the compound-statement.  */\n   compound_stmt = begin_compound_stmt (in_try ? BCS_TRY_BLOCK : 0);\n@@ -6900,7 +6900,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   /* Finish the compound-statement.  */\n   finish_compound_stmt (compound_stmt);\n   /* Consume the `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n \n   return compound_stmt;\n }\n@@ -6980,7 +6980,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \ttree condition;\n \n \t/* Look for the `('.  */\n-\tif (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+\tif (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n \t  {\n \t    cp_parser_skip_to_end_of_statement (parser);\n \t    return error_mark_node;\n@@ -6995,7 +6995,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \t/* Look for the `)'.  */\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t\t /*consume_paren=*/true);\n \n@@ -7138,7 +7138,7 @@ cp_parser_condition (cp_parser* parser)\n \n \t looks like a decl-specifier-seq and a declarator -- but then\n \t there is no `=', so this is an expression.  */\n-      cp_parser_require (parser, CPP_EQ, \"`='\");\n+      cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n       /* If we did see an `=', then we are looking at a declaration\n \t for sure.  */\n       if (cp_parser_parse_definitely (parser))\n@@ -7260,13 +7260,13 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the while-statement.  */\n \tstatement = begin_while_stmt ();\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \tfinish_while_stmt_cond (condition, statement);\n \tcheck_empty_body (parser, \"while\");\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t/* Parse the dependent statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_already_scoped_statement (parser);\n@@ -7288,17 +7288,17 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tparser->in_statement = in_statement;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n-\tcp_parser_require_keyword (parser, RID_WHILE, \"`while'\");\n+\tcp_parser_require_keyword (parser, RID_WHILE, \"%<while%>\");\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t/* Parse the expression.  */\n \texpression = cp_parser_expression (parser, /*cast_p=*/false);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \t/* Look for the `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       }\n       break;\n \n@@ -7310,7 +7310,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the for-statement.  */\n \tstatement = begin_for_stmt ();\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+\tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t/* Parse the initialization.  */\n \tcp_parser_for_init_statement (parser);\n \tfinish_for_init_stmt (statement);\n@@ -7320,15 +7320,15 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t  condition = cp_parser_condition (parser);\n \tfinish_for_cond (condition, statement);\n \t/* Look for the `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n \t/* If there's an expression, process it.  */\n \tif (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n \t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n \tfinish_for_expr (expression, statement);\n \tcheck_empty_body (parser, \"for\");\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n \t/* Parse the body of the for-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n@@ -7583,9 +7583,9 @@ cp_parser_already_scoped_statement (cp_parser* parser)\n     {\n       /* Avoid calling cp_parser_compound_statement, so that we\n \t don't create a new scope.  Do everything else by hand.  */\n-      cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n+      cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n       cp_parser_statement_seq_opt (parser, NULL_TREE);\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n     }\n }\n \n@@ -8023,7 +8023,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n     }\n \n   /* Consume the `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n  done:\n   pop_deferring_access_checks ();\n@@ -8375,7 +8375,7 @@ cp_parser_linkage_specification (cp_parser* parser)\n   tree linkage;\n \n   /* Look for the `extern' keyword.  */\n-  cp_parser_require_keyword (parser, RID_EXTERN, \"`extern'\");\n+  cp_parser_require_keyword (parser, RID_EXTERN, \"%<extern%>\");\n \n   /* Look for the string-literal.  */\n   linkage = cp_parser_string_literal (parser, false, false);\n@@ -8405,7 +8405,7 @@ cp_parser_linkage_specification (cp_parser* parser)\n       /* Parse the declarations.  */\n       cp_parser_declaration_seq_opt (parser);\n       /* Look for the closing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n     }\n   /* Otherwise, there's just one declaration.  */\n   else\n@@ -8446,7 +8446,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n \n   /* Look for the `static_assert' keyword.  */\n   if (!cp_parser_require_keyword (parser, RID_STATIC_ASSERT, \n-                                  \"`static_assert'\"))\n+                                  \"%<static_assert%>\"))\n     return;\n \n   /*  We know we are in a static assertion; commit to any tentative\n@@ -8455,7 +8455,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n     cp_parser_commit_to_tentative_parse (parser);\n \n   /* Parse the `(' starting the static assertion condition.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \n   /* Parse the constant-expression.  */\n   condition = \n@@ -8464,22 +8464,22 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n                                    /*non_constant_p=*/NULL);\n \n   /* Parse the separating `,'.  */\n-  cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+  cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n \n   /* Parse the string-literal message.  */\n   message = cp_parser_string_literal (parser, \n                                       /*translate=*/false,\n                                       /*wide_ok=*/true);\n \n   /* A `)' completes the static assertion.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, \n                                            /*recovering=*/true, \n                                            /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n \n   /* A semicolon terminates the declaration.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n   /* Complete the static assertion, which may mean either processing \n      the static assert now or saving it for template instantiation.  */\n@@ -8501,7 +8501,7 @@ cp_parser_decltype (cp_parser *parser)\n   bool saved_non_integral_constant_expression_p;\n \n   /* Look for the `decltype' token.  */\n-  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, \"`decltype'\"))\n+  if (!cp_parser_require_keyword (parser, RID_DECLTYPE, \"%<decltype%>\"))\n     return error_mark_node;\n \n   /* Types cannot be defined in a `decltype' expression.  Save away the\n@@ -8524,7 +8524,7 @@ cp_parser_decltype (cp_parser *parser)\n   ++skip_evaluation;\n \n   /* Parse the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return error_mark_node;\n   \n   /* First, try parsing an id-expression.  */\n@@ -8641,7 +8641,7 @@ cp_parser_decltype (cp_parser *parser)\n     }\n   \n   /* Parse to the closing `)'.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t     /*consume_paren=*/true);\n@@ -8670,7 +8670,7 @@ cp_parser_conversion_function_id (cp_parser* parser)\n   tree pushed_scope = NULL_TREE;\n \n   /* Look for the `operator' token.  */\n-  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"`operator'\"))\n+  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"%<operator%>\"))\n     return error_mark_node;\n   /* When we parse the conversion-type-id, the current scope will be\n      reset.  However, we need that information in able to look up the\n@@ -9005,7 +9005,7 @@ static tree\n cp_parser_operator_function_id (cp_parser* parser)\n {\n   /* Look for the `operator' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"`operator'\"))\n+  if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"%<operator%>\"))\n     return error_mark_node;\n   /* And then the name of the operator itself.  */\n   return cp_parser_operator (parser);\n@@ -9061,7 +9061,7 @@ cp_parser_operator (cp_parser* parser)\n \t    /* Consume the `[' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the `]' token.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n \t    id = ansi_opname (op == NEW_EXPR\n \t\t\t      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);\n \t  }\n@@ -9220,14 +9220,14 @@ cp_parser_operator (cp_parser* parser)\n       /* Consume the `('.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n       return ansi_opname (CALL_EXPR);\n \n     case CPP_OPEN_SQUARE:\n       /* Consume the `['.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `]'.  */\n-      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+      cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n       return ansi_opname (ARRAY_REF);\n \n     default:\n@@ -9510,7 +9510,7 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \n   /* Look for a keyword to tell us what kind of parameter this is.  */\n   token = cp_parser_require (parser, CPP_KEYWORD,\n-\t\t\t     \"`class', `typename', or `template'\");\n+\t\t\t     \"%<class%>, %<typename%>, or %<template%>\");\n   if (!token)\n     return error_mark_node;\n \n@@ -9581,13 +9581,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n \ttree default_argument;\n \n \t/* Look for the `<'.  */\n-\tcp_parser_require (parser, CPP_LESS, \"`<'\");\n+\tcp_parser_require (parser, CPP_LESS, \"%<<%>\");\n \t/* Parse the template-parameter-list.  */\n \tparameter_list = cp_parser_template_parameter_list (parser);\n \t/* Look for the `>'.  */\n-\tcp_parser_require (parser, CPP_GREATER, \"`>'\");\n+\tcp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n \t/* Look for the `class' keyword.  */\n-\tcp_parser_require_keyword (parser, RID_CLASS, \"`class'\");\n+\tcp_parser_require_keyword (parser, RID_CLASS, \"%<class%>\");\n         /* If the next token is an ellipsis, we have a template\n            argument pack. */\n         if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n@@ -9814,7 +9814,7 @@ cp_parser_template_id (cp_parser *parser,\n   else\n     {\n       /* Look for the `<' that starts the template-argument-list.  */\n-      if (!cp_parser_require (parser, CPP_LESS, \"`<'\"))\n+      if (!cp_parser_require (parser, CPP_LESS, \"%<<%>\"))\n \t{\n \t  pop_deferring_access_checks ();\n \t  return error_mark_node;\n@@ -10422,7 +10422,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n     }\n \n   /* Look for the `template' keyword.  */\n-  cp_parser_require_keyword (parser, RID_TEMPLATE, \"`template'\");\n+  cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\");\n   /* Let the front end know that we are processing an explicit\n      instantiation.  */\n   begin_explicit_instantiation ();\n@@ -10504,11 +10504,11 @@ cp_parser_explicit_specialization (cp_parser* parser)\n {\n   bool need_lang_pop;\n   /* Look for the `template' keyword.  */\n-  cp_parser_require_keyword (parser, RID_TEMPLATE, \"`template'\");\n+  cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\");\n   /* Look for the `<'.  */\n-  cp_parser_require (parser, CPP_LESS, \"`<'\");\n+  cp_parser_require (parser, CPP_LESS, \"%<<%>\");\n   /* Look for the `>'.  */\n-  cp_parser_require (parser, CPP_GREATER, \"`>'\");\n+  cp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n   /* We have processed another parameter list.  */\n   ++parser->num_template_parameter_lists;\n   /* [temp]\n@@ -11470,7 +11470,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n     cp_parser_enumerator_list (parser, type);\n \n   /* Consume the final '}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n \n   /* Look for trailing attributes to apply to this enumeration, and\n      apply them if appropriate.  */\n@@ -11648,7 +11648,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n     is_inline = false;\n \n   /* Look for the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n \n   /* Get the name of the namespace.  We do not attempt to distinguish\n      between an original-namespace-definition and an\n@@ -11663,7 +11663,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   attribs = cp_parser_attributes_opt (parser);\n \n   /* Look for the `{' to start the namespace.  */\n-  cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n+  cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\");\n   /* Start the namespace.  */\n   push_namespace (identifier);\n \n@@ -11695,7 +11695,7 @@ cp_parser_namespace_definition (cp_parser* parser)\n   /* Finish the namespace.  */\n   pop_namespace ();\n   /* Look for the final `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n }\n \n /* Parse a namespace-body.\n@@ -11721,7 +11721,7 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n   tree namespace_specifier;\n \n   /* Look for the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n   /* Look for the identifier.  */\n   identifier = cp_parser_identifier (parser);\n   if (identifier == error_mark_node)\n@@ -11737,12 +11737,12 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n \tcp_lexer_consume_token (parser->lexer);\n       return;\n     }\n-  cp_parser_require (parser, CPP_EQ, \"`='\");\n+  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n   /* Look for the qualified-namespace-specifier.  */\n   namespace_specifier\n     = cp_parser_qualified_namespace_specifier (parser);\n   /* Look for the `;' token.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n   /* Register the alias in the symbol table.  */\n   do_namespace_alias (identifier, namespace_specifier);\n@@ -11801,7 +11801,7 @@ cp_parser_using_declaration (cp_parser* parser,\n   else\n     {\n       /* Look for the `using' keyword.  */\n-      cp_parser_require_keyword (parser, RID_USING, \"`using'\");\n+      cp_parser_require_keyword (parser, RID_USING, \"%<using%>\");\n       \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -11898,7 +11898,7 @@ cp_parser_using_declaration (cp_parser* parser,\n     }\n \n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n   \n   return true;\n }\n@@ -11916,9 +11916,9 @@ cp_parser_using_directive (cp_parser* parser)\n   tree attribs;\n \n   /* Look for the `using' keyword.  */\n-  cp_parser_require_keyword (parser, RID_USING, \"`using'\");\n+  cp_parser_require_keyword (parser, RID_USING, \"%<using%>\");\n   /* And the `namespace' keyword.  */\n-  cp_parser_require_keyword (parser, RID_NAMESPACE, \"`namespace'\");\n+  cp_parser_require_keyword (parser, RID_NAMESPACE, \"%<namespace%>\");\n   /* Look for the optional `::' operator.  */\n   cp_parser_global_scope_opt (parser, /*current_scope_valid_p=*/false);\n   /* And the optional nested-name-specifier.  */\n@@ -11934,7 +11934,7 @@ cp_parser_using_directive (cp_parser* parser)\n   /* Update the symbol table.  */\n   parse_using_directive (namespace_decl, attribs);\n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n }\n \n /* Parse an asm-definition.\n@@ -11967,7 +11967,7 @@ cp_parser_asm_definition (cp_parser* parser)\n   bool invalid_outputs_p = false;\n \n   /* Look for the `asm' keyword.  */\n-  cp_parser_require_keyword (parser, RID_ASM, \"`asm'\");\n+  cp_parser_require_keyword (parser, RID_ASM, \"%<asm%>\");\n   /* See if the next token is `volatile'.  */\n   if (cp_parser_allow_gnu_extensions_p (parser)\n       && cp_lexer_next_token_is_keyword (parser->lexer, RID_VOLATILE))\n@@ -11978,7 +11978,7 @@ cp_parser_asm_definition (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n     }\n   /* Look for the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return;\n   /* Look for the string.  */\n   string = cp_parser_string_literal (parser, false, false);\n@@ -12061,10 +12061,10 @@ cp_parser_asm_definition (cp_parser* parser)\n \t}\n     }\n   /* Look for the closing `)'.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t   /*consume_paren=*/true);\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n   if (!invalid_inputs_p && !invalid_outputs_p)\n     {\n@@ -12679,7 +12679,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t    *ctor_dtor_or_conv_p = *ctor_dtor_or_conv_p < 0;\n \t\t  first = false;\n \t\t  /* Consume the `)'.  */\n-\t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n \t\t  /* Parse the cv-qualifier-seq.  */\n \t\t  cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n@@ -12723,7 +12723,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t      first = false;\n \t      /* Expect a `)'.  */\n-\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n \t\tdeclarator = cp_error_declarator;\n \t      if (declarator == cp_error_declarator)\n \t\tbreak;\n@@ -12774,7 +12774,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  else\n \t    bounds = NULL_TREE;\n \t  /* Look for the closing `]'.  */\n-\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\"))\n+\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\"))\n \t    {\n \t      declarator = cp_error_declarator;\n \t      break;\n@@ -13069,7 +13069,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n       /* If we found it, and the next token is a `*', then we are\n \t indeed looking at a pointer-to-member operator.  */\n       if (!cp_parser_error_occurred (parser)\n-\t  && cp_parser_require (parser, CPP_MULT, \"`*'\"))\n+\t  && cp_parser_require (parser, CPP_MULT, \"%<*%>\"))\n \t{\n \t  /* Indicate that the `*' operator was used.  */\n \t  code = INDIRECT_REF;\n@@ -13391,7 +13391,7 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n       /* Expect an ellipsis.  */\n       ellipsis_p\n-\t= (cp_parser_require (parser, CPP_ELLIPSIS, \"`...'\") != NULL);\n+\t= (cp_parser_require (parser, CPP_ELLIPSIS, \"%<...%>\") != NULL);\n     }\n   /* It might also be `...' if the optional trailing `,' was\n      omitted.  */\n@@ -13995,7 +13995,7 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n \t    cp_lexer_consume_token (parser->lexer);\n \t}\n       /* Now, there should be a trailing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n     }\n \n   return initializer;\n@@ -14295,7 +14295,7 @@ cp_parser_class_specifier (cp_parser* parser)\n     }\n \n   /* Look for the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n     {\n       pop_deferring_access_checks ();\n       return error_mark_node;\n@@ -14342,7 +14342,7 @@ cp_parser_class_specifier (cp_parser* parser)\n     cp_parser_member_specification_opt (parser);\n \n   /* Look for the trailing `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n   /* We get better error messages by noticing a common problem: a\n      missing trailing `;'.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -14881,7 +14881,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n \t  /* Remember which access-specifier is active.  */\n \t  current_access_specifier = token->u.value;\n \t  /* Look for the `:'.  */\n-\t  cp_parser_require (parser, CPP_COLON, \"`:'\");\n+\t  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n \t  break;\n \n \tdefault:\n@@ -15300,7 +15300,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t}\n     }\n \n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n }\n \n /* Parse a pure-specifier.\n@@ -15317,15 +15317,15 @@ cp_parser_pure_specifier (cp_parser* parser)\n   cp_token *token;\n \n   /* Look for the `=' token.  */\n-  if (!cp_parser_require (parser, CPP_EQ, \"`='\"))\n+  if (!cp_parser_require (parser, CPP_EQ, \"%<=%>\"))\n     return error_mark_node;\n   /* Look for the `0' token.  */\n   token = cp_lexer_consume_token (parser->lexer);\n   /* c_lex_with_flags marks a single digit '0' with PURE_ZERO.  */\n   if (token->type != CPP_NUMBER || !(token->flags & PURE_ZERO))\n     {\n       cp_parser_error (parser,\n-\t\t       \"invalid pure specifier (only `= 0' is allowed)\");\n+\t\t       \"invalid pure specifier (only %<= 0%> is allowed)\");\n       cp_parser_skip_to_end_of_statement (parser);\n       return error_mark_node;\n     }\n@@ -15349,7 +15349,7 @@ static tree\n cp_parser_constant_initializer (cp_parser* parser)\n {\n   /* Look for the `=' token.  */\n-  if (!cp_parser_require (parser, CPP_EQ, \"`='\"))\n+  if (!cp_parser_require (parser, CPP_EQ, \"%<=%>\"))\n     return error_mark_node;\n \n   /* It is invalid to write:\n@@ -15366,7 +15366,7 @@ cp_parser_constant_initializer (cp_parser* parser)\n       /* Skip the initializer.  */\n       cp_parser_skip_to_closing_brace (parser);\n       /* Look for the trailing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n \n       return error_mark_node;\n     }\n@@ -15400,7 +15400,7 @@ cp_parser_base_clause (cp_parser* parser)\n   tree bases = NULL_TREE;\n \n   /* Look for the `:' that begins the list.  */\n-  cp_parser_require (parser, CPP_COLON, \"`:'\");\n+  cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n \n   /* Scan the base-specifier-list.  */\n   while (true)\n@@ -15606,7 +15606,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);\n \n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -15628,7 +15628,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n     type_id_list = empty_except_spec;\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   return type_id_list;\n }\n@@ -15687,7 +15687,7 @@ cp_parser_try_block (cp_parser* parser)\n {\n   tree try_block;\n \n-  cp_parser_require_keyword (parser, RID_TRY, \"`try'\");\n+  cp_parser_require_keyword (parser, RID_TRY, \"%<try%>\");\n   try_block = begin_try_block ();\n   cp_parser_compound_statement (parser, NULL, true);\n   finish_try_block (try_block);\n@@ -15710,7 +15710,7 @@ cp_parser_function_try_block (cp_parser* parser)\n   bool ctor_initializer_p;\n \n   /* Look for the `try' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_TRY, \"`try'\"))\n+  if (!cp_parser_require_keyword (parser, RID_TRY, \"%<try%>\"))\n     return false;\n   /* Let the rest of the front end know where we are.  */\n   try_block = begin_function_try_block (&compound_stmt);\n@@ -15760,12 +15760,12 @@ cp_parser_handler (cp_parser* parser)\n   tree handler;\n   tree declaration;\n \n-  cp_parser_require_keyword (parser, RID_CATCH, \"`catch'\");\n+  cp_parser_require_keyword (parser, RID_CATCH, \"%<catch%>\");\n   handler = begin_handler ();\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n   cp_parser_compound_statement (parser, NULL, false);\n   finish_handler (handler);\n }\n@@ -15835,7 +15835,7 @@ cp_parser_throw_expression (cp_parser* parser)\n   tree expression;\n   cp_token* token;\n \n-  cp_parser_require_keyword (parser, RID_THROW, \"`throw'\");\n+  cp_parser_require_keyword (parser, RID_THROW, \"%<throw%>\");\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Figure out whether or not there is an assignment-expression\n      following the \"throw\" keyword.  */\n@@ -15880,13 +15880,13 @@ cp_parser_asm_specification_opt (cp_parser* parser)\n   /* Consume the `asm' token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \n   /* Look for the string-literal.  */\n   asm_specification = cp_parser_string_literal (parser, false, false);\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   return asm_specification;\n }\n@@ -15930,19 +15930,19 @@ cp_parser_asm_operand_list (cp_parser* parser)\n \t    name = build_string (IDENTIFIER_LENGTH (name),\n \t\t\t\t IDENTIFIER_POINTER (name));\n \t  /* Look for the closing `]'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n \t}\n       else\n \tname = NULL_TREE;\n       /* Look for the string-literal.  */\n       string_literal = cp_parser_string_literal (parser, false, false);\n \n       /* Look for the `('.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n       /* Parse the expression.  */\n       expression = cp_parser_expression (parser, /*cast_p=*/false);\n       /* Look for the `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n       if (name == error_mark_node \n \t  || string_literal == error_mark_node \n@@ -16026,8 +16026,8 @@ cp_parser_attributes_opt (cp_parser* parser)\n       /* Consume the `__attribute__' keyword.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the two `(' tokens.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -16040,8 +16040,8 @@ cp_parser_attributes_opt (cp_parser* parser)\n \tattribute_list = NULL;\n \n       /* Look for the two `)' tokens.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n       /* Add these new attributes to the list.  */\n       attributes = chainon (attributes, attribute_list);\n@@ -16171,7 +16171,7 @@ static void\n cp_parser_label_declaration (cp_parser* parser)\n {\n   /* Look for the `__label__' keyword.  */\n-  cp_parser_require_keyword (parser, RID_LABEL, \"`__label__'\");\n+  cp_parser_require_keyword (parser, RID_LABEL, \"%<__label__%>\");\n \n   while (true)\n     {\n@@ -16188,11 +16188,11 @@ cp_parser_label_declaration (cp_parser* parser)\n       if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \tbreak;\n       /* Look for the `,' separating the label declarations.  */\n-      cp_parser_require (parser, CPP_COMMA, \"`,'\");\n+      cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n     }\n \n   /* Look for the final `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n }\n \n /* Support Functions */\n@@ -16726,7 +16726,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n      takes one parameter (of type `int') and returns a value of type\n      `S::S'.  */\n   if (constructor_p\n-      && cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+      && cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     {\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN)\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_ELLIPSIS)\n@@ -16933,11 +16933,11 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   bool need_lang_pop;\n \n   /* Look for the `template' keyword.  */\n-  if (!cp_parser_require_keyword (parser, RID_TEMPLATE, \"`template'\"))\n+  if (!cp_parser_require_keyword (parser, RID_TEMPLATE, \"%<template%>\"))\n     return;\n \n   /* And the `<'.  */\n-  if (!cp_parser_require (parser, CPP_LESS, \"`<'\"))\n+  if (!cp_parser_require (parser, CPP_LESS, \"%<<%>\"))\n     return;\n   if (at_class_scope_p () && current_function_decl)\n     {\n@@ -17175,7 +17175,7 @@ cp_parser_single_declaration (cp_parser* parser,\n   /* Look for a trailing `;' after the declaration.  */\n   if (!function_definition_p\n       && (decl == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_SEMICOLON, \"`;'\")))\n+\t  || !cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\")))\n     cp_parser_skip_to_end_of_block_or_statement (parser);\n \n   return decl;\n@@ -18338,7 +18338,7 @@ cp_parser_objc_message_expression (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n   receiver = cp_parser_objc_message_receiver (parser);\n   messageargs = cp_parser_objc_message_args (parser);\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n \n   return objc_build_message_expr (build_tree_list (receiver, messageargs));\n }\n@@ -18410,7 +18410,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n \treturn build_tree_list (selector, NULL_TREE);\n \n       maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, \"`:'\");\n+      cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n       arg = cp_parser_assignment_expression (parser, false);\n \n       sel_args\n@@ -18451,9 +18451,9 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n   tree type;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   type = complete_type (cp_parser_type_id (parser));\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   if (!type)\n     {\n@@ -18472,9 +18472,9 @@ cp_parser_objc_defs_expression (cp_parser *parser)\n   tree name;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   name = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   return objc_get_class_ivars (name);\n }\n@@ -18492,9 +18492,9 @@ cp_parser_objc_protocol_expression (cp_parser* parser)\n   tree proto;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   proto = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   return objc_build_protocol_expr (proto);\n }\n@@ -18522,7 +18522,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n   cp_token *token;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   token = cp_lexer_peek_token (parser->lexer);\n \n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n@@ -18569,7 +18569,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n     }\n \n  finish_selector:\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   return objc_build_selector_expr (sel_seq);\n }\n@@ -18655,7 +18655,7 @@ cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n       protorefs = cp_parser_objc_identifier_list (parser);\n-      cp_parser_require (parser, CPP_GREATER, \"`>'\");\n+      cp_parser_require (parser, CPP_GREATER, \"%<>%>\");\n     }\n \n   return protorefs;\n@@ -18744,7 +18744,7 @@ cp_parser_objc_typename (cp_parser* parser)\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n \tcp_type = cp_parser_type_id (parser);\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n       typename = build_tree_list (proto_quals, cp_type);\n     }\n \n@@ -18816,7 +18816,7 @@ cp_parser_objc_method_keyword_params (cp_parser* parser)\n \treturn selector;\n \n       maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, \"`:'\");\n+      cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n       typename = cp_parser_objc_typename (parser);\n       identifier = cp_parser_identifier (parser);\n \n@@ -19146,7 +19146,7 @@ cp_parser_objc_superclass_or_category (cp_parser *parser, tree *super,\n     {\n       cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n       *categ = cp_parser_identifier (parser);\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n     }\n }\n \n@@ -19266,7 +19266,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n   location_t location;\n   tree stmt;\n \n-  cp_parser_require_keyword (parser, RID_AT_TRY, \"`@try'\");\n+  cp_parser_require_keyword (parser, RID_AT_TRY, \"%<@try%>\");\n   location = cp_lexer_peek_token (parser->lexer)->location;\n   /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n@@ -19280,13 +19280,13 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n       tree parm;\n \n       cp_lexer_consume_token (parser->lexer);\n-      cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+      cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n       parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n       parm = grokdeclarator (parmdecl->declarator,\n \t\t\t     &parmdecl->decl_specifiers,\n \t\t\t     PARM, /*initialized=*/0,\n \t\t\t     /*attrlist=*/NULL);\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n       objc_begin_catch_clause (parm);\n       cp_parser_compound_statement (parser, NULL, false);\n       objc_finish_catch_clause ();\n@@ -19318,12 +19318,12 @@ cp_parser_objc_synchronized_statement (cp_parser *parser) {\n   location_t location;\n   tree lock, stmt;\n \n-  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, \"`@synchronized'\");\n+  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, \"%<@synchronized%>\");\n \n   location = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n   lock = cp_parser_expression (parser, false);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n@@ -19344,7 +19344,7 @@ static tree\n cp_parser_objc_throw_statement (cp_parser *parser) {\n   tree expr = NULL_TREE;\n \n-  cp_parser_require_keyword (parser, RID_AT_THROW, \"`@throw'\");\n+  cp_parser_require_keyword (parser, RID_AT_THROW, \"%<@throw%>\");\n \n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     expr = cp_parser_assignment_expression (parser, false);\n@@ -19509,7 +19509,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     {\n       int ending;\n \n@@ -19533,7 +19533,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n static tree\n cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n {\n-  if (cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return cp_parser_omp_var_list_no_open (parser, kind, list);\n   return list;\n }\n@@ -19547,7 +19547,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n   tree c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -19580,7 +19580,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n       cp_parser_error (parser, \"expected %<none%> or %<shared%>\");\n     }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -19604,13 +19604,13 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list)\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n \n   t = cp_parser_condition (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -19647,13 +19647,13 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list)\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n \n   t = cp_parser_expression (parser, false);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -19694,7 +19694,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n   enum tree_code code;\n   tree nlist, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n \n   switch (cp_lexer_peek_token (parser->lexer)->type)\n@@ -19724,7 +19724,8 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n       code = TRUTH_ORIF_EXPR;\n       break;\n     default:\n-      cp_parser_error (parser, \"`+', `*', `-', `&', `^', `|', `&&', or `||'\");\n+      cp_parser_error (parser, \"%<+%>, %<*%>, %<-%>, %<&%>, %<^%>, %<|%>, \"\n+\t\t\t       \"%<&&%>, or %<||%>\");\n     resync_fail:\n       cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t     /*or_comma=*/false,\n@@ -19733,7 +19734,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n     }\n   cp_lexer_consume_token (parser->lexer);\n \n-  if (!cp_parser_require (parser, CPP_COLON, \"`:'\"))\n+  if (!cp_parser_require (parser, CPP_COLON, \"%<:%>\"))\n     goto resync_fail;\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_REDUCTION, list);\n@@ -19809,10 +19810,10 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n \tgoto resync_fail;\n     }\n-  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`,' or `)'\"))\n+  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<,%> or %<)%>\"))\n     goto resync_fail;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\");\n@@ -20090,7 +20091,7 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n       name = cp_parser_identifier (parser);\n \n       if (name == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -20133,7 +20134,7 @@ cp_parser_omp_for_loop (cp_parser *parser)\n       return NULL;\n     }\n   loc = cp_lexer_consume_token (parser->lexer)->location;\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return NULL;\n \n   init = decl = NULL;\n@@ -20161,7 +20162,7 @@ cp_parser_omp_for_loop (cp_parser *parser)\n \t  attributes = cp_parser_attributes_opt (parser);\n \t  asm_specification = cp_parser_asm_specification_opt (parser);\n \n-\t  cp_parser_require (parser, CPP_EQ, \"`='\");\n+\t  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n \t  if (cp_parser_parse_definitely (parser))\n \t    {\n \t      tree pushed_scope;\n@@ -20191,19 +20192,19 @@ cp_parser_omp_for_loop (cp_parser *parser)\n       if (decl == NULL)\n \tinit = cp_parser_expression (parser, false);\n     }\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n   pre_body = pop_stmt_list (pre_body);\n \n   cond = NULL;\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     cond = cp_parser_condition (parser);\n-  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n   incr = NULL;\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n     incr = cp_parser_expression (parser, false);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -20294,7 +20295,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   bool error_suppress = false;\n   cp_token *tok;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"%<{%>\"))\n     return NULL_TREE;\n \n   stmt = push_stmt_list ();\n@@ -20349,7 +20350,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n \n   substmt = pop_stmt_list (stmt);\n "}]}