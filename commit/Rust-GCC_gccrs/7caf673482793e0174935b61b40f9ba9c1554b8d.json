{"sha": "7caf673482793e0174935b61b40f9ba9c1554b8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhZjY3MzQ4Mjc5M2UwMTc0OTM1YjYxYjQwZjliYTljMTU1NGI4ZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-06-28T19:42:04Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-06-28T19:42:04Z"}, "message": "genpreds.c (generate_switch_p): New function.\n\n\n\t* genpreds.c (generate_switch_p): New function.\n\t(add_mode_tests): Push the new mode test down inside an AND expr\n\tif this allows the switch-suitable MATCH_CODE to be near the root.\n\t(write_match_code_switch): New function to write a MATCH_CODE as\n\ta switch statement.\n\t(write_predicate_stmts): New function to write a predicate RTX\n\texpression as a sequence of statements.\n\t(write_one_predicate_function): Use write_predicate_stmts.\n\t(write_tm_constrs_h): Likewise.\n\nFrom-SVN: r115055", "tree": {"sha": "1b7a5428f281a483e6b154d91478e0ba051645df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b7a5428f281a483e6b154d91478e0ba051645df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7caf673482793e0174935b61b40f9ba9c1554b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7caf673482793e0174935b61b40f9ba9c1554b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7caf673482793e0174935b61b40f9ba9c1554b8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7caf673482793e0174935b61b40f9ba9c1554b8d/comments", "author": null, "committer": null, "parents": [{"sha": "092b194ebfc458d451ca2e930e6a06146fcf52b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/092b194ebfc458d451ca2e930e6a06146fcf52b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/092b194ebfc458d451ca2e930e6a06146fcf52b1"}], "stats": {"total": 136, "additions": 128, "deletions": 8}, "files": [{"sha": "32d28ba3245f512d2aa2341e47807064cf532d0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caf673482793e0174935b61b40f9ba9c1554b8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caf673482793e0174935b61b40f9ba9c1554b8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7caf673482793e0174935b61b40f9ba9c1554b8d", "patch": "@@ -1,3 +1,15 @@\n+2006-06-28  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* genpreds.c (generate_switch_p): New function.\n+\t(add_mode_tests): Push the new mode test down inside an AND expr\n+\tif this allows the switch-suitable MATCH_CODE to be near the root.\n+\t(write_match_code_switch): New function to write a MATCH_CODE as\n+\ta switch statement.\n+\t(write_predicate_stmts): New function to write a predicate RTX\n+\texpression as a sequence of statements.\n+\t(write_one_predicate_function): Use write_predicate_stmts.\n+\t(write_tm_constrs_h): Likewise.\n+\n 2006-06-26  Fred Fish  <fnf@specifix.com>\n \n \t* config/mips/t-sb1: New file."}, {"sha": "41efc546d247e23ccd6d7059b49a57621255c637", "filename": "gcc/genpreds.c", "status": "modified", "additions": 116, "deletions": 8, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7caf673482793e0174935b61b40f9ba9c1554b8d/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7caf673482793e0174935b61b40f9ba9c1554b8d/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=7caf673482793e0174935b61b40f9ba9c1554b8d", "patch": "@@ -316,6 +316,15 @@ mark_mode_tests (rtx exp)\n     }\n }\n \n+/* Determine whether the expression EXP is a MATCH_CODE that should\n+   be written as a switch statement.  */\n+static bool\n+generate_switch_p (rtx exp)\n+{\n+  return GET_CODE (exp) == MATCH_CODE\n+\t && strchr (XSTR (exp, 0), ',');\n+}\n+\n /* Given a predicate, work out where in its RTL expression to add\n    tests for proper modes.  Special predicates do not get any such\n    tests.  We try to avoid adding tests when we don't have to; in\n@@ -361,6 +370,15 @@ add_mode_tests (struct pred_data *p)\n \n       switch (GET_CODE (subexp))\n \t{\n+\tcase AND:\n+\t  /* The switch code generation in write_predicate_stmts prefers\n+\t     rtx code tests to be at the top of the expression tree.  So\n+\t     push this AND down into the second operand of an exisiting\n+\t     AND expression.  */\n+\t  if (generate_switch_p (XEXP (subexp, 0)))\n+\t    pos = &XEXP (subexp, 1);\n+\t  goto break_loop;\n+\n \tcase IOR:\n \t  {\n \t    int test0 = NO_MODE_TEST (XEXP (subexp, 0));\n@@ -520,6 +538,98 @@ write_predicate_expr (rtx exp)\n     }\n }\n \n+/* Write the MATCH_CODE expression EXP as a switch statement.  */\n+\n+static void\n+write_match_code_switch (rtx exp)\n+{\n+  const char *codes = (const char *) XEXP (exp, 0);\n+  const char *path = (const char *) XEXP (exp, 1);\n+  const char *code;\n+\n+  fputs (\"  switch (GET_CODE (\", stdout);\n+  write_extract_subexp (path);\n+  fputs (\"))\\n    {\\n\", stdout);\n+\n+  while ((code = scan_comma_elt (&codes)) != 0)\n+    {\n+      fputs (\"    case \", stdout);\n+      while (code < codes)\n+\t{\n+\t  putchar (TOUPPER (*code));\n+\t  code++;\n+\t}\n+      fputs(\":\\n\", stdout);\n+    }\n+}\n+\n+/* Given a predictate expression EXP, write out a sequence of stmts\n+   to evaluate it.  This is similar to write_predicate_expr but can\n+   generate efficient switch statements.  */\n+\n+static void\n+write_predicate_stmts (rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case MATCH_CODE:\n+      if (generate_switch_p (exp))\n+\t{\n+\t  write_match_code_switch (exp);\n+\t  puts (\"      return true;\\n\"\n+\t\t\"    default:\\n\"\n+\t\t\"      break;\\n\"\n+\t\t\"    }\\n\"\n+\t\t\"  return false;\");\n+\t  return;\n+\t}\n+      break;\n+\n+    case AND:\n+      if (generate_switch_p (XEXP (exp, 0)))\n+\t{\n+\t  write_match_code_switch (XEXP (exp, 0));\n+\t  puts (\"      break;\\n\"\n+\t\t\"    default:\\n\"\n+\t\t\"      return false;\\n\"\n+\t\t\"    }\");\n+\t  exp = XEXP (exp, 1);\n+\t}\n+      break;\n+\n+    case IOR:\n+      if (generate_switch_p (XEXP (exp, 0)))\n+\t{\n+\t  write_match_code_switch (XEXP (exp, 0));\n+\t  puts (\"      return true;\\n\"\n+\t\t\"    default:\\n\"\n+\t\t\"      break;\\n\"\n+\t\t\"    }\");\n+\t  exp = XEXP (exp, 1);\n+\t}\n+\n+    case NOT:\n+      if (generate_switch_p (XEXP (exp, 0)))\n+\t{\n+\t  write_match_code_switch (XEXP (exp, 0));\n+\t  puts (\"      return false;\\n\"\n+\t\t\"    default:\\n\"\n+\t\t\"      break;\\n\"\n+\t\t\"    }\\n\"\n+\t\t\"  return true;\");\n+\t  return;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fputs(\"  return \",stdout);\n+  write_predicate_expr (exp);\n+  fputs(\";\\n\", stdout);\n+}\n+\n /* Given a predicate, write out a complete C function to compute it.  */\n static void\n write_one_predicate_function (struct pred_data *p)\n@@ -532,11 +642,10 @@ write_one_predicate_function (struct pred_data *p)\n \n   /* A normal predicate can legitimately not look at enum machine_mode\n      if it accepts only CONST_INTs and/or CONST_DOUBLEs.  */\n-  printf (\"int\\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\"\n-\t  \"{\\n  return \",\n+  printf (\"int\\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n{\\n\",\n \t  p->name);\n-  write_predicate_expr (p->exp);\n-  fputs (\";\\n}\\n\\n\", stdout);\n+  write_predicate_stmts (p->exp);\n+  fputs (\"}\\n\\n\", stdout);\n }\n \f\n /* Constraints fall into two categories: register constraints\n@@ -995,10 +1104,9 @@ write_tm_constrs_h (void)\n \tif (needs_rval)\n \t  puts (\"  if (GET_CODE (op) == CONST_DOUBLE && mode != VOIDmode)\"\n \t\t\"    rval = CONST_DOUBLE_REAL_VALUE (op);\");\n-\t  \n-\tfputs (\"  return \", stdout);\n-\twrite_predicate_expr (c->exp);\n-\tfputs (\";\\n}\\n\", stdout);\n+\n+\twrite_predicate_stmts (c->exp);\n+\tfputs (\"}\\n\", stdout);\n       }\n   puts (\"#endif /* tm-constrs.h */\");\n }"}]}