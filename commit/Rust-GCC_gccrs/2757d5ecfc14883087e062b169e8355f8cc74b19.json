{"sha": "2757d5ecfc14883087e062b169e8355f8cc74b19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1N2Q1ZWNmYzE0ODgzMDg3ZTA2MmIxNjllODM1NWY4Y2M3NGIxOQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-03-21T07:14:42Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-03-21T07:14:42Z"}, "message": "re PR fortran/22572 (Double occurrence of matmul intrinsic not optimised)\n\n2010-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/22572\n\t* gfortran.h (gfc_option_t) : Add\n\tflag_aggressive_function_elimination.\n\t(gfc_dep_compare_functions):  Add prototype.\n\t* lang.opt: Add faggressive-function-elimination.\n\t* invoke.texi: Document -faggressive-function-elimination.\n\t* frontend_passes (expr_array):  New static variable.\n\t(expr_size):  Likewise.\n\t(expr_count):  Likewise.\n\t(current_code):  Likewise.\n\t(current_ns):  Likewise.\n\t(gfc_run_passes):  Allocate and free space for expressions.\n\t(cfe_register_funcs):  New function.\n\t(create_var):  New function.\n\t(cfc_expr_0):  New function.\n\t(cfe_code):  New function.\n\t(optimize_namespace):  Invoke gfc_code_walker with cfe_code\n\tand cfe_expr_0.\n\t* dependency.c (gfc_dep_compare_functions):  New function.\n\t(gfc_dep_compare_expr):  Use it.\n\t* options.c (gfc_init_options):  Handle\n\tflag_aggressive_function_elimination.\n\t(gfc_handle_option):  Likewise.\n\n2010-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/22572\n\t* gfortran.dg/function_optimize_1.f90:  New test.\n\t* gfortran.dg/function_optimize_2.f90:  New test.\n\nFrom-SVN: r171207", "tree": {"sha": "e7fa9989715e0c8733622fdf2e9e11eb709cdcb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7fa9989715e0c8733622fdf2e9e11eb709cdcb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2757d5ecfc14883087e062b169e8355f8cc74b19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2757d5ecfc14883087e062b169e8355f8cc74b19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2757d5ecfc14883087e062b169e8355f8cc74b19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2757d5ecfc14883087e062b169e8355f8cc74b19/comments", "author": null, "committer": null, "parents": [{"sha": "14a41392aab6bc963db2b4248b16aa2b5af09aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14a41392aab6bc963db2b4248b16aa2b5af09aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14a41392aab6bc963db2b4248b16aa2b5af09aa5"}], "stats": {"total": 448, "additions": 417, "deletions": 31}, "files": [{"sha": "4e0a792c1a84e9ef95e34715ab9949078bc59f8f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -1,3 +1,29 @@\n+2010-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/22572\n+\t* gfortran.h (gfc_option_t) : Add\n+\tflag_aggressive_function_elimination.\n+\t(gfc_dep_compare_functions):  Add prototype.\n+\t* lang.opt: Add faggressive-function-elimination.\n+\t* invoke.texi: Document -faggressive-function-elimination.\n+\t* frontend_passes (expr_array):  New static variable.\n+\t(expr_size):  Likewise.\n+\t(expr_count):  Likewise.\n+\t(current_code):  Likewise.\n+\t(current_ns):  Likewise.\n+\t(gfc_run_passes):  Allocate and free space for expressions.\n+\t(cfe_register_funcs):  New function.\n+\t(create_var):  New function.\n+\t(cfc_expr_0):  New function.\n+\t(cfe_code):  New function.\n+\t(optimize_namespace):  Invoke gfc_code_walker with cfe_code\n+\tand cfe_expr_0.\n+\t* dependency.c (gfc_dep_compare_functions):  New function.\n+\t(gfc_dep_compare_expr):  Use it.\n+\t* options.c (gfc_init_options):  Handle\n+\tflag_aggressive_function_elimination.\n+\t(gfc_handle_option):  Likewise.\n+\n 2011-03-15  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* arith.c (arith_power): Plug memory leak."}, {"sha": "adfcd2a31329336f95f5bb7b31aea17c3003a268", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -177,6 +177,49 @@ gfc_are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n   return true;\n }\n \n+/* Compare two functions for equality.  Returns 0 if e1==e2, -2 otherwise.  If\n+   impure_ok is false, only return 0 for pure functions.  */\n+\n+int\n+gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n+{\n+\n+  gfc_actual_arglist *args1;\n+  gfc_actual_arglist *args2;\n+  \n+  if (e1->expr_type != EXPR_FUNCTION || e2->expr_type != EXPR_FUNCTION)\n+    return -2;\n+\n+  if ((e1->value.function.esym && e2->value.function.esym\n+       && e1->value.function.esym == e2->value.function.esym\n+       && (e1->value.function.esym->result->attr.pure || impure_ok))\n+       || (e1->value.function.isym && e2->value.function.isym\n+\t   && e1->value.function.isym == e2->value.function.isym\n+\t   && (e1->value.function.isym->pure || impure_ok)))\n+    {\n+      args1 = e1->value.function.actual;\n+      args2 = e2->value.function.actual;\n+\n+      /* Compare the argument lists for equality.  */\n+      while (args1 && args2)\n+\t{\n+\t  /*  Bitwise xor, since C has no non-bitwise xor operator.  */\n+\t  if ((args1->expr == NULL) ^ (args2->expr == NULL))\n+\t    return -2;\n+\t  \n+\t  if (args1->expr != NULL && args2->expr != NULL\n+\t      && gfc_dep_compare_expr (args1->expr, args2->expr) != 0)\n+\t    return -2;\n+\t  \n+\t  args1 = args1->next;\n+\t  args2 = args2->next;\n+\t}\n+      return (args1 || args2) ? -2 : 0;\n+    }\n+      else\n+\treturn -2;      \n+}\n+\n /* Compare two values.  Returns 0 if e1 == e2, -1 if e1 < e2, +1 if e1 > e2,\n    and -2 if the relationship could not be determined.  */\n \n@@ -399,36 +442,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n       return -2;\n \n     case EXPR_FUNCTION:\n-\n-      /* PURE functions can be compared for argument equality.  */\n-      if ((e1->value.function.esym && e2->value.function.esym\n-\t   && e1->value.function.esym == e2->value.function.esym\n-\t   && e1->value.function.esym->result->attr.pure)\n-\t  || (e1->value.function.isym && e2->value.function.isym\n-\t      && e1->value.function.isym == e2->value.function.isym\n-\t      && e1->value.function.isym->pure))\n-\t{\n-\t  args1 = e1->value.function.actual;\n-\t  args2 = e2->value.function.actual;\n-\n-\t  /* Compare the argument lists for equality.  */\n-\t  while (args1 && args2)\n-\t    {\n-\t      /*  Bitwise xor, since C has no non-bitwise xor operator.  */\n-\t      if ((args1->expr == NULL) ^ (args2->expr == NULL))\n-\t\treturn -2;\n-\n-\t      if (args1->expr != NULL && args2->expr != NULL\n-\t\t  && gfc_dep_compare_expr (args1->expr, args2->expr) != 0)\n-\t\treturn -2;\n-\n-\t      args1 = args1->next;\n-\t      args2 = args2->next;\n-\t    }\n-\t  return (args1 || args2) ? -2 : 0;\n-\t}\n-      else\n-\treturn -2;\n+      return gfc_dep_compare_functions (e1, e2, false);\n       break;\n \n     default:"}, {"sha": "e26ae68a5a9aef85328ced7085151f045837c255", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -40,6 +40,21 @@ static bool optimize_trim (gfc_expr *);\n \n static int count_arglist;\n \n+/* Pointer to an array of gfc_expr ** we operate on, plus its size\n+   and counter.  */\n+\n+static gfc_expr ***expr_array;\n+static int expr_size, expr_count;\n+\n+/* Pointer to the gfc_code we currently work on - to be able to insert\n+   a statement before.  */\n+\n+static gfc_code **current_code;\n+\n+/* The namespace we are currently dealing with.  */\n+\n+gfc_namespace *current_ns;\n+\n /* Entry point - run all passes for a namespace.  So far, only an\n    optimization pass is run.  */\n \n@@ -48,9 +63,16 @@ gfc_run_passes (gfc_namespace *ns)\n {\n   if (optimize)\n     {\n+      expr_size = 20;\n+      expr_array = XNEWVEC(gfc_expr **, expr_size);\n+\n       optimize_namespace (ns);\n       if (gfc_option.dump_fortran_optimized)\n \tgfc_dump_parse_tree (ns, stdout);\n+\n+      /* FIXME: The following should be XDELETEVEC(expr_array);\n+      but we cannot do that because it depends on free.  */\n+      gfc_free (expr_array);\n     }\n }\n \n@@ -106,11 +128,214 @@ optimize_expr (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+\n+/* Callback function for common function elimination, called from cfe_expr_0.\n+   Put all eligible function expressions into expr_array.  We can't do\n+   allocatable functions.  */\n+\n+static int\n+cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  if ((*e)->expr_type != EXPR_FUNCTION)\n+    return 0;\n+\n+  /* We don't do character functions (yet).  */\n+  if ((*e)->ts.type == BT_CHARACTER)\n+    return 0;\n+\n+  /* If we don't know the shape at compile time, we do not create a temporary\n+     variable to hold the intermediate result.  FIXME: Change this later when\n+     allocation on assignment works for intrinsics.  */\n+\n+  if ((*e)->rank > 0 && (*e)->shape == NULL)\n+    return 0;\n+  \n+  /* Skip the test for pure functions if -faggressive-function-elimination\n+     is specified.  */\n+  if ((*e)->value.function.esym)\n+    {\n+      if ((*e)->value.function.esym->attr.allocatable)\n+\treturn 0;\n+\n+      /* Don't create an array temporary for elemental functions.  */\n+      if ((*e)->value.function.esym->attr.elemental && (*e)->rank > 0)\n+\treturn 0;\n+\n+      /* Only eliminate potentially impure functions if the\n+\t user specifically requested it.  */\n+      if (!gfc_option.flag_aggressive_function_elimination\n+\t  && !(*e)->value.function.esym->attr.pure\n+\t  && !(*e)->value.function.esym->attr.implicit_pure)\n+\treturn 0;\n+    }\n+\n+  if ((*e)->value.function.isym)\n+    {\n+      /* Conversions are handled on the fly by the middle end,\n+\t transpose during trans-* stages.  */\n+      if ((*e)->value.function.isym->id == GFC_ISYM_CONVERSION\n+\t  || (*e)->value.function.isym->id == GFC_ISYM_TRANSPOSE)\n+\treturn 0;\n+\n+      /* Don't create an array temporary for elemental functions,\n+\t as this would be wasteful of memory.\n+\t FIXME: Create a scalar temporary during scalarization.  */\n+      if ((*e)->value.function.isym->elemental && (*e)->rank > 0)\n+\treturn 0;\n+\n+      if (!(*e)->value.function.isym->pure)\n+\treturn 0;\n+    }\n+\n+  if (expr_count >= expr_size)\n+    {\n+      expr_size += expr_size;\n+      expr_array = XRESIZEVEC(gfc_expr **, expr_array, expr_size);\n+    }\n+  expr_array[expr_count] = e;\n+  expr_count ++;\n+  return 0;\n+}\n+\n+/* Returns a new expression (a variable) to be used in place of the old one,\n+   with an an assignment statement before the current statement to set\n+   the value of the variable.  */\n+\n+static gfc_expr*\n+create_var (gfc_expr * e)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN +1];\n+  static int num = 1;\n+  gfc_symtree *symtree;\n+  gfc_symbol *symbol;\n+  gfc_expr *result;\n+  gfc_code *n;\n+  int i;\n+\n+  sprintf(name, \"__var_%d\",num++);\n+  if (gfc_get_sym_tree (name, current_ns, &symtree, false) != 0)\n+    gcc_unreachable ();\n+\n+  symbol = symtree->n.sym;\n+  symbol->ts = e->ts;\n+  symbol->as = gfc_get_array_spec ();\n+  symbol->as->rank = e->rank;\n+  symbol->as->type = AS_EXPLICIT;\n+  for (i=0; i<e->rank; i++)\n+    {\n+      gfc_expr *p, *q;\n+      \n+      p = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t &(e->where));\n+      mpz_set_si (p->value.integer, 1);\n+      symbol->as->lower[i] = p;\n+\t  \n+      q = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,\n+\t\t\t\t &(e->where));\n+      mpz_set (q->value.integer, e->shape[i]);\n+      symbol->as->upper[i] = q;\n+    }\n+\n+  symbol->attr.flavor = FL_VARIABLE;\n+  symbol->attr.referenced = 1;\n+  symbol->attr.dimension = e->rank > 0;\n+  gfc_commit_symbol (symbol);\n+\n+  result = gfc_get_expr ();\n+  result->expr_type = EXPR_VARIABLE;\n+  result->ts = e->ts;\n+  result->rank = e->rank;\n+  result->shape = gfc_copy_shape (e->shape, e->rank);\n+  result->symtree = symtree;\n+  result->where = e->where;\n+  if (e->rank > 0)\n+    {\n+      result->ref = gfc_get_ref ();\n+      result->ref->type = REF_ARRAY;\n+      result->ref->u.ar.type = AR_FULL;\n+      result->ref->u.ar.where = e->where;\n+      result->ref->u.ar.as = symbol->as;\n+    }\n+\n+  /* Generate the new assignment.  */\n+  n = XCNEW (gfc_code);\n+  n->op = EXEC_ASSIGN;\n+  n->loc = (*current_code)->loc;\n+  n->next = *current_code;\n+  n->expr1 = gfc_copy_expr (result);\n+  n->expr2 = e;\n+  *current_code = n;\n+\n+  return result;\n+}\n+\n+/* Callback function for the code walker for doing common function\n+   elimination.  This builds up the list of functions in the expression\n+   and goes through them to detect duplicates, which it then replaces\n+   by variables.  */\n+\n+static int\n+cfe_expr_0 (gfc_expr **e, int *walk_subtrees,\n+\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  int i,j;\n+  gfc_expr *newvar;\n+\n+  expr_count = 0;\n+\n+  gfc_expr_walker (e, cfe_register_funcs, NULL);\n+\n+  /* Walk backwards through all the functions to make sure we\n+     catch the leaf functions first.  */\n+  for (i=expr_count-1; i>=1; i--)\n+    {\n+      /* Skip if the function has been replaced by a variable already.  */\n+      if ((*(expr_array[i]))->expr_type == EXPR_VARIABLE)\n+\tcontinue;\n+\n+      newvar = NULL;\n+      for (j=i-1; j>=0; j--)\n+\t{\n+\t  if (gfc_dep_compare_functions(*(expr_array[i]),\n+\t\t\t\t\t*(expr_array[j]), true)\t== 0)\n+\t    {\n+\t      if (newvar == NULL)\n+\t\tnewvar = create_var (*(expr_array[i]));\n+\t      gfc_free (*(expr_array[j]));\n+\t      *(expr_array[j]) = gfc_copy_expr (newvar);\n+\t    }\n+\t}\n+      if (newvar)\n+\t*(expr_array[i]) = newvar;\n+    }\n+\n+  /* We did all the necessary walking in this function.  */\n+  *walk_subtrees = 0;\n+  return 0;\n+}\n+\n+/* Callback function for common function elimination, called from\n+   gfc_code_walker.  This keeps track of the current code, in order\n+   to insert statements as needed.  */\n+\n+static int\n+cfe_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  current_code = c;\n+  return 0;\n+}\n+\n /* Optimize a namespace, including all contained namespaces.  */\n \n static void\n optimize_namespace (gfc_namespace *ns)\n {\n+\n+  current_ns = ns;\n+\n+  gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);\n   gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n \n   for (ns = ns->contained; ns; ns = ns->sibling)"}, {"sha": "cd71f3b1de3226224a8c5de19362d7be2a34e597", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -2232,6 +2232,7 @@ typedef struct\n   int flag_whole_file;\n   int flag_protect_parens;\n   int flag_realloc_lhs;\n+  int flag_aggressive_function_elimination;\n \n   int fpe;\n   int rtcheck;\n@@ -2865,6 +2866,7 @@ void gfc_global_used (gfc_gsymbol *, locus *);\n gfc_namespace* gfc_build_block_ns (gfc_namespace *);\n \n /* dependency.c */\n+int gfc_dep_compare_functions (gfc_expr *, gfc_expr *, bool);\n int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);\n \n /* check.c */"}, {"sha": "d7388d0616c519e6de8b3a4154653bb3bd8f45f7", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -1468,14 +1468,25 @@ need to be in effect.\n An allocatable left-hand side of an intrinsic assignment is automatically\n (re)allocated if it is either unallocated or has a different shape. The\n option is enabled by default except when @option{-std=f95} is given.\n+\n+@item -faggressive-function-elimination\n+@opindex @code{faggressive-function-elimination}\n+@cindex Elimination of functions with identical argument lists\n+Functions with identical argument lists are eliminated within\n+statements, regardless of whether these functions are marked\n+@code{PURE} or not. For example, in\n+@smallexample\n+  a = f(b,c) + f(b,c)\n+@end smallexample\n+there will only be a single call to @code{f}.\n+\n @end table\n \n @xref{Code Gen Options,,Options for Code Generation Conventions,\n gcc,Using the GNU Compiler Collection (GCC)}, for information on more options\n offered by the GBE\n shared by @command{gfortran}, @command{gcc}, and other GNU compilers.\n \n-\n @c man end\n \n @node Environment Variables"}, {"sha": "9de70aca04a5f184617cad2a114371a8d7eace04", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -278,6 +278,10 @@ d\n Fortran Joined\n ; Documented in common.opt\n \n+faggressive-function-elimination\n+Fortran\n+Eliminate multiple function invokations also for impure functions\n+\n falign-commons\n Fortran\n Enable alignment of COMMON blocks"}, {"sha": "172fed8b49af692ef7446152567a220e5408dc3b", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -150,6 +150,7 @@ gfc_init_options (unsigned int decoded_options_count,\n   gfc_option.flag_align_commons = 1;\n   gfc_option.flag_protect_parens = 1;\n   gfc_option.flag_realloc_lhs = -1;\n+  gfc_option.flag_aggressive_function_elimination = 0;\n   \n   gfc_option.fpe = 0;\n   gfc_option.rtcheck = 0;\n@@ -972,6 +973,10 @@ gfc_handle_option (size_t scode, const char *arg, int value,\n       gfc_option.flag_align_commons = value;\n       break;\n \n+    case  OPT_faggressive_function_elimination:\n+      gfc_option.flag_aggressive_function_elimination = value;\n+      break;\n+\n     case OPT_fprotect_parens:\n       gfc_option.flag_protect_parens = value;\n       break;"}, {"sha": "259bcc0bab291f42c292c0718439900553fb6da3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -1,3 +1,9 @@\n+2010-03-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/22572\n+\t* gfortran.dg/function_optimize_1.f90:  New test.\n+\t* gfortran.dg/function_optimize_2.f90:  New test.\n+\n 2011-03-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR rtl-optimization/47502"}, {"sha": "eaa915fc871b2240a243514a15460d285880c6aa", "filename": "gcc/testsuite/gfortran.dg/function_optimize_1.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_1.f90?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  real, dimension(2,2) :: a, b, c, d\n+  integer :: i\n+  real :: x, z\n+  character(60) :: line\n+  real, external :: ext_func\n+  interface\n+     elemental function element(x)\n+       real, intent(in) :: x\n+       real :: elem\n+     end function element\n+     pure function mypure(x)\n+       real, intent(in) :: x\n+       integer :: mypure\n+     end function mypure\n+     elemental impure function elem_impure(x)\n+       real, intent(in) :: x\n+       real :: elem_impure\n+     end function elem_impure\n+  end interface\n+\n+  data a /2., 3., 5., 7./\n+  data b /11., 13., 17., 23./\n+  write (unit=line, fmt='(4F7.2)') matmul(a,b) + matmul(a,b)\n+  z = sin(x) + cos(x) + sin(x) + cos(x)\n+  print *,z\n+  x = ext_func(a) + 23 + ext_func(a)\n+  print *,d,x\n+  z = element(x) + element(x)\n+  print *,z\n+  i = mypure(x) - mypure(x)\n+  print *,i\n+  z = elem_impure(x) - elem_impure(x)\n+  print *,z\n+end program main\n+! { dg-final { scan-tree-dump-times \"matmul_r4\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_sinf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_cosf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"ext_func\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"element\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"mypure\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"elem_impure\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "8105661b8f59d5e0486ba4d89f233933b0d0842c", "filename": "gcc/testsuite/gfortran.dg/function_optimize_2.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2757d5ecfc14883087e062b169e8355f8cc74b19/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_2.f90?ref=2757d5ecfc14883087e062b169e8355f8cc74b19", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do compile }\n+! { dg-options \"-O -faggressive-function-elimination -fdump-tree-original\" }\n+program main\n+  implicit none\n+  real, dimension(2,2) :: a, b, c, d\n+  real :: x, z\n+  integer :: i\n+  character(60) :: line\n+  real, external :: ext_func\n+  interface\n+     elemental function element(x)\n+       real, intent(in) :: x\n+       real :: elem\n+     end function element\n+     pure function mypure(x)\n+       real, intent(in) :: x\n+       integer :: mypure\n+     end function mypure\n+     elemental impure function elem_impure(x)\n+       real, intent(in) :: x\n+       real :: elem_impure\n+     end function elem_impure\n+  end interface\n+\n+  data a /2., 3., 5., 7./\n+  data b /11., 13., 17., 23./\n+  write (unit=line, fmt='(4F7.2)') matmul(a,b) + matmul(a,b)\n+  x = 1.2\n+  z = sin(x) + cos(x) + sin(x) + cos(x)\n+  print *,z\n+  x = ext_func(a) + 23 + ext_func(a)\n+  print *,d,x\n+  z = element(x) + element(x)\n+  print *,z\n+  i = mypure(x) - mypure(x)\n+  print *,i\n+  z = elem_impure(x) - elem_impure(x)\n+  print *,z\n+end program main\n+! { dg-final { scan-tree-dump-times \"matmul_r4\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_sinf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_cosf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"ext_func\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"element\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"mypure\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"elem_impure\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}