{"sha": "5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZkNDI0MjM4YjI1ZmQ4ZmY2YWM0MDNlZjkyM2JkY2UyYjJiMjM0Nw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2008-11-13T15:19:02Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2008-11-13T15:19:02Z"}, "message": "invoke.texi: Document --fix-cortex-m3.\n\n2008-11-13  Paul Brook  <paul@codesourcery.com>\n\n\tgcc/\n\t* doc/invoke.texi: Document --fix-cortex-m3.\n\t* config/arm/arm.c (arm_override_options): Set fix_cm3_ldrd if\n\tCortex-M3 cpu is selected.\n\t(output_move_double): Avoid overlapping base register and first\n\tdestination register when fix_cm3_ldrd.\n\t* config/arm/arm.opt: Add mfix-cortex-m3-ldrd.\n\nFrom-SVN: r141822", "tree": {"sha": "c0fb255f1910301b63c8be710bb26c06656095ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0fb255f1910301b63c8be710bb26c06656095ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/comments", "author": null, "committer": null, "parents": [{"sha": "255e5b0481a06f5fb7cf41c8b1d511cf506b943f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255e5b0481a06f5fb7cf41c8b1d511cf506b943f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255e5b0481a06f5fb7cf41c8b1d511cf506b943f"}], "stats": {"total": 98, "additions": 74, "deletions": 24}, "files": [{"sha": "2ae685a51e83c31d87cb7678428da9627b15bba2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "patch": "@@ -1,3 +1,12 @@\n+2008-11-13  Paul Brook  <paul@codesourcery.com>\n+\n+\t* doc/invoke.texi: Document --fix-cortex-m3.\n+\t* config/arm/arm.c (arm_override_options): Set fix_cm3_ldrd if\n+\tCortex-M3 cpu is selected.\n+\t(output_move_double): Avoid overlapping base register and first\n+\tdestination register when fix_cm3_ldrd.\n+\t* config/arm/arm.opt: Add mfix-cortex-m3-ldrd.\n+\n 2008-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/38100"}, {"sha": "a1cef0bd103b4f671ad267e2abd231202a0e9b88", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "patch": "@@ -1037,6 +1037,7 @@ arm_override_options (void)\n {\n   unsigned i;\n   enum processor_type target_arch_cpu = arm_none;\n+  enum processor_type selected_cpu = arm_none;\n \n   /* Set up the flags based on the cpu/architecture selected by the user.  */\n   for (i = ARRAY_SIZE (arm_select); i--;)\n@@ -1069,6 +1070,9 @@ arm_override_options (void)\n \t\tif (i == ARM_OPT_SET_ARCH)\n \t\t  target_arch_cpu = sel->core;\n \n+\t\tif (i == ARM_OPT_SET_CPU)\n+\t\t  selected_cpu = (enum processor_type) (sel - ptr->processors);\n+\t\t  \n \t\tif (i != ARM_OPT_SET_TUNE)\n \t\t  {\n \t\t    /* If we have been given an architecture and a processor\n@@ -1099,21 +1103,20 @@ arm_override_options (void)\n     {\n       const struct processors * sel;\n       unsigned int        sought;\n-      enum processor_type cpu;\n \n-      cpu = TARGET_CPU_DEFAULT;\n-      if (cpu == arm_none)\n+      selected_cpu = TARGET_CPU_DEFAULT;\n+      if (selected_cpu == arm_none)\n \t{\n #ifdef SUBTARGET_CPU_DEFAULT\n \t  /* Use the subtarget default CPU if none was specified by\n \t     configure.  */\n-\t  cpu = SUBTARGET_CPU_DEFAULT;\n+\t  selected_cpu = SUBTARGET_CPU_DEFAULT;\n #endif\n \t  /* Default to ARM6.  */\n-\t  if (cpu == arm_none)\n-\t    cpu = arm6;\n+\t  if (selected_cpu == arm_none)\n+\t    selected_cpu = arm6;\n \t}\n-      sel = &all_cores[cpu];\n+      sel = &all_cores[selected_cpu];\n \n       insn_flags = sel->flags;\n \n@@ -1505,6 +1508,15 @@ arm_override_options (void)\n \tarm_pic_register = pic_register;\n     }\n \n+  /* Enable -mfix-cortex-m3-ldrd by default for Cortex-M3 cores.  */\n+  if (fix_cm3_ldrd == 2)\n+    {\n+      if (selected_cpu == cortexm3)\n+\tfix_cm3_ldrd = 1;\n+      else\n+\tfix_cm3_ldrd = 0;\n+    }\n+\n   /* ??? We might want scheduling for thumb2.  */\n   if (TARGET_THUMB && flag_schedule_insns)\n     {\n@@ -9978,7 +9990,8 @@ output_move_double (rtx *operands)\n       switch (GET_CODE (XEXP (operands[1], 0)))\n \t{\n \tcase REG:\n-\t  if (TARGET_LDRD)\n+\t  if (TARGET_LDRD\n+\t      && !(fix_cm3_ldrd && reg0 == REGNO(XEXP (operands[1], 0))))\n \t    output_asm_insn (\"ldr%(d%)\\t%0, [%m1]\", operands);\n \t  else\n \t    output_asm_insn (\"ldm%(ia%)\\t%m1, %M0\", operands);\n@@ -10010,6 +10023,10 @@ output_move_double (rtx *operands)\n \n \tcase PRE_MODIFY:\n \tcase POST_MODIFY:\n+\t  /* Autoicrement addressing modes should never have overlapping\n+\t     base and destination registers, and overlapping index registers\n+\t     are already prohibited, so this doesn't need to worry about\n+\t     fix_cm3_ldrd.  */\n \t  otherops[0] = operands[0];\n \t  otherops[1] = XEXP (XEXP (XEXP (operands[1], 0), 1), 0);\n \t  otherops[2] = XEXP (XEXP (XEXP (operands[1], 0), 1), 1);\n@@ -10062,11 +10079,15 @@ output_move_double (rtx *operands)\n \t  /* We might be able to use ldrd %0, %1 here.  However the range is\n \t     different to ldr/adr, and it is broken on some ARMv7-M\n \t     implementations.  */\n-\t  output_asm_insn (\"adr%?\\t%0, %1\", operands);\n+\t  /* Use the second register of the pair to avoid problematic\n+\t     overlap.  */\n+\t  otherops[1] = operands[1];\n+\t  output_asm_insn (\"adr%?\\t%0, %1\", otherops);\n+\t  operands[1] = otherops[0];\n \t  if (TARGET_LDRD)\n-\t    output_asm_insn (\"ldr%(d%)\\t%0, [%0]\", operands);\n+\t    output_asm_insn (\"ldr%(d%)\\t%0, [%1]\", operands);\n \t  else\n-\t    output_asm_insn (\"ldm%(ia%)\\t%0, %M0\", operands);\n+\t    output_asm_insn (\"ldm%(ia%)\\t%1, %M0\", operands);\n \t  break;\n \n \t  /* ??? This needs checking for thumb2.  */\n@@ -10099,30 +10120,37 @@ output_move_double (rtx *operands)\n \t\t\t  return \"\";\n \t\t\t}\n \t\t    }\n+\t\t  otherops[0] = gen_rtx_REG(SImode, REGNO(operands[0]) + 1);\n+\t\t  operands[1] = otherops[0];\n \t\t  if (TARGET_LDRD\n \t\t      && (GET_CODE (otherops[2]) == REG\n \t\t\t  || (GET_CODE (otherops[2]) == CONST_INT\n \t\t\t      && INTVAL (otherops[2]) > -256\n \t\t\t      && INTVAL (otherops[2]) < 256)))\n \t\t    {\n-\t\t      if (reg_overlap_mentioned_p (otherops[0],\n+\t\t      if (reg_overlap_mentioned_p (operands[0],\n \t\t\t\t\t\t   otherops[2]))\n \t\t\t{\n+\t\t\t  rtx tmp;\n \t\t\t  /* Swap base and index registers over to\n \t\t\t     avoid a conflict.  */\n-\t\t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 1);\n-\t\t\t  otherops[2] = XEXP (XEXP (operands[1], 0), 0);\n+\t\t\t  tmp = otherops[1];\n+\t\t\t  otherops[1] = otherops[2];\n+\t\t\t  otherops[2] = tmp;\n \t\t\t}\n \t\t      /* If both registers conflict, it will usually\n \t\t\t have been fixed by a splitter.  */\n-\t\t      if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n+\t\t      if (reg_overlap_mentioned_p (operands[0], otherops[2])\n+\t\t\t  || (fix_cm3_ldrd && reg0 == REGNO (otherops[1])))\n \t\t\t{\n-\t\t\t  output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n-\t\t\t  output_asm_insn (\"ldr%(d%)\\t%0, [%1]\",\n-\t\t\t\t\t   otherops);\n+\t\t\t  output_asm_insn (\"add%?\\t%0, %1, %2\", otherops);\n+\t\t\t  output_asm_insn (\"ldr%(d%)\\t%0, [%1]\", operands);\n \t\t\t}\n \t\t      else\n-\t\t\toutput_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]\", otherops);\n+\t\t\t{\n+\t\t\t  otherops[0] = operands[0];\n+\t\t\t  output_asm_insn (\"ldr%(d%)\\t%0, [%1, %2]\", otherops);\n+\t\t\t}\n \t\t      return \"\";\n \t\t    }\n \n@@ -10140,9 +10168,9 @@ output_move_double (rtx *operands)\n \t\toutput_asm_insn (\"sub%?\\t%0, %1, %2\", otherops);\n \n \t      if (TARGET_LDRD)\n-\t\treturn \"ldr%(d%)\\t%0, [%0]\";\n+\t\treturn \"ldr%(d%)\\t%0, [%1]\";\n \n-\t      return \"ldm%(ia%)\\t%0, %M0\";\n+\t      return \"ldm%(ia%)\\t%1, %M0\";\n \t    }\n \t  else\n \t    {"}, {"sha": "1d07cedf0de9288e822b4f1d1aea47dd3705e0ae", "filename": "gcc/config/arm/arm.opt", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fconfig%2Farm%2Farm.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fconfig%2Farm%2Farm.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.opt?ref=5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "patch": "@@ -159,4 +159,9 @@ Use Neon quad-word (rather than double-word) registers for vectorization\n \n mword-relocations\n Target Report Var(target_word_relocations) Init(TARGET_DEFAULT_WORD_RELOCATIONS)\n-+Only generate absolute relocations on word sized values.\n+Only generate absolute relocations on word sized values.\n+\n+mfix-cortex-m3-ldrd\n+Target Report Var(fix_cm3_ldrd) Init(2)\n+Avoid overlapping destination and address registers on LDRD instructions\n+that may trigger Cortex-M3 errata."}, {"sha": "ce621520fce423822d5dbc4f7179f1ff7f2b6103", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fd424238b25fd8ff6ac403ef923bdce2b2b2347/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5fd424238b25fd8ff6ac403ef923bdce2b2b2347", "patch": "@@ -452,8 +452,9 @@ Objective-C and Objective-C++ Dialects}.\n -mthumb  -marm @gol\n -mtpcs-frame  -mtpcs-leaf-frame @gol\n -mcaller-super-interworking  -mcallee-super-interworking @gol\n--mtp=@var{name}\n--mword-relocations}\n+-mtp=@var{name} @gol\n+-mword-relocations @gol\n+-mfix-cortex-m3-ldrd}\n \n @emph{AVR Options}\n @gccoptlist{-mmcu=@var{mcu}  -msize  -minit-stack=@var{n}  -mno-interrupts @gol\n@@ -8708,6 +8709,13 @@ Put functions, data, and readonly data in @var{text-section},\n by default.  This can be overridden with the @code{section} attribute.\n @xref{Variable Attributes}.\n \n+@item -mfix-cortex-m3-ldrd\n+@opindex mfix-cortex-m3-ldrd\n+Some Cortex-M3 cores can cause data corruption when @code{ldrd} instructions\n+with overlapping destination and base registers are used.  This option avoids\n+generating these instructions.  This option is enabled by default when\n+@option{-mcpu=cortex-m3} is specified.\n+\n @end table\n \n @node ARM Options"}]}