{"sha": "1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY4MGVhOTUyZDAzNWUyZDM1NGJkMjBiNmU4YWEzYzIyMzVmYmI1Ng==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2000-11-30T06:41:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-11-30T06:41:29Z"}, "message": "pa.c (restore_unscaled_index_insn_codes): Delete procedure.\n\n\t* pa.c (restore_unscaled_index_insn_codes): Delete procedure.\n\t(record_unscaled_index_insn_codes): Likewise.\n\t(unscaled_index_insn_codes): Delete.\n\t(max_unscaled_index_insn_codes_uid): Delete.\n\t(output_function_prologue, output_function_epilogue, pa_reorg):\n\tDon't use the unscaled index insn hack.\n\nFrom-SVN: r37865", "tree": {"sha": "06b2307be1445fff2c619d59ede09fccdeb844f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06b2307be1445fff2c619d59ede09fccdeb844f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56/comments", "author": null, "committer": null, "parents": [{"sha": "d16ca6a6703335e99c8c295af01bdf43cafefdf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16ca6a6703335e99c8c295af01bdf43cafefdf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d16ca6a6703335e99c8c295af01bdf43cafefdf3"}], "stats": {"total": 123, "additions": 7, "deletions": 116}, "files": [{"sha": "39cc7dc7f507a357382a4df5f98720f94e40b71c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "patch": "@@ -1,5 +1,12 @@\n 2000-11-29  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n+\t* pa.c (restore_unscaled_index_insn_codes): Delete procedure.\n+\t(record_unscaled_index_insn_codes): Likewise.\n+\t(unscaled_index_insn_codes): Delete.\n+\t(max_unscaled_index_insn_codes_uid): Delete.\n+\t(output_function_prologue, output_function_epilogue, pa_reorg):\n+\tDon't use the unscaled index insn hack.\n+\n \t* pa.md: Remove hack from all index insns to reverse the operand\n \torder of frame and stack pointer references incorrectly created\n \tin the reload pass."}, {"sha": "6a4f989096c94e7a2c2563dbe2a52805b2276a1d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f80ea952d035e2d354bd20b6e8aa3c2235fbb56/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1f80ea952d035e2d354bd20b6e8aa3c2235fbb56", "patch": "@@ -43,8 +43,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"tm_p.h\"\n \n-static void restore_unscaled_index_insn_codes\t\tPARAMS ((rtx));\n-static void record_unscaled_index_insn_codes\t\tPARAMS ((rtx));\n static void pa_combine_instructions\t\t\tPARAMS ((rtx));\n static int pa_can_combine_p\tPARAMS ((rtx, rtx, rtx, int, rtx, rtx, rtx));\n static int forward_branch_p\t\t\t\tPARAMS ((rtx));\n@@ -100,13 +98,6 @@ struct deferred_plabel\n } *deferred_plabels = 0;\n int n_deferred_plabels = 0;\n \n-/* Array indexed by INSN_UIDs holding the INSN_CODE of an insn which\n-   uses an unscaled indexed address before delay slot scheduling.  */\n-static int *unscaled_index_insn_codes;\n-\n-/* Upper bound for the array.  */\n-static int max_unscaled_index_insn_codes_uid;\n-\n void\n override_options ()\n {\n@@ -2924,9 +2915,6 @@ output_function_prologue (file, size)\n     total_code_bytes = -1;\n \n   remove_useless_addtr_insns (get_insns (), 0);\n-\n-  /* Restore INSN_CODEs for insn which use unscaled indexed addresses.  */\n-  restore_unscaled_index_insn_codes (get_insns ());\n }\n \n void\n@@ -3211,11 +3199,6 @@ output_function_epilogue (file, size)\n     fputs (\"\\tnop\\n\", file);\n \n   fputs (\"\\t.EXIT\\n\\t.PROCEND\\n\", file);\n-\n-  /* Free up stuff we don't need anymore.  */\n-  if (unscaled_index_insn_codes)\n-    free (unscaled_index_insn_codes);\n-  max_unscaled_index_insn_codes_uid = 0;\n }\n \n void\n@@ -6346,101 +6329,6 @@ following_call (insn)\n   return 0;\n }\n \n-/* Restore any INSN_CODEs for insns with unscaled indexed addresses since\n-   the INSN_CODE might be clobberd by rerecognition triggered by reorg.  */\n-\n-static void\n-restore_unscaled_index_insn_codes (insns)\n-     rtx insns;\n-{\n-  rtx insn;\n-\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_UID (insn) < max_unscaled_index_insn_codes_uid\n-\t  && unscaled_index_insn_codes[INSN_UID (insn)] != -1)\n-\tINSN_CODE (insn) = unscaled_index_insn_codes[INSN_UID (insn)];\n-    }\n-}\n-\n-/* Severe braindamage:\n-\n-   On the PA, address computations within MEM expressions are not\n-   commutative because of the implicit space register selection\n-   from the base register (instead of the entire effective address).\n-\n-   Because of this mis-feature we have to know which register in a reg+reg\n-   address is the base and which is the index.\n-\n-   Before reload, the base can be identified by REG_POINTER.  We use\n-   this to force base + index addresses to match a different insn than\n-   index + base addresses.\n-\n-   We assume that no pass during or after reload creates new unscaled indexed\n-   addresses, so any unscaled indexed address we find after reload must have\n-   at one time been recognized a base + index or index + base and we accept\n-   any register as a base register.\n-\n-   This scheme assumes that no pass during/after reload will rerecognize an\n-   insn with an unscaled indexed address.  This failed due to a reorg call\n-   to rerecognize certain insns.\n-\n-   So, we record if an insn uses an unscaled indexed address and which\n-   register is the base (via recording of the INSN_CODE for such insns).\n-\n-   Just before we output code for the function, we make sure all the insns\n-   using unscaled indexed addresses have the same INSN_CODE as they did\n-   immediately before delay slot scheduling.\n-\n-   This is extremely gross.  Long term, I'd like to use REG_POINTER to\n-   handle these kinds of problems.\n-\n-   FIXME: Is this still necessary now that the pointer flag is stored\n-   in REG rtx's and basereg_operand properly checks for the flag after\n-   reload?  */\n- \n-static void\n-record_unscaled_index_insn_codes (insns)\n-     rtx insns;\n-{\n-  rtx insn;\n-\n-  max_unscaled_index_insn_codes_uid = get_max_uid ();\n-  unscaled_index_insn_codes\n-    = (int *)xmalloc (max_unscaled_index_insn_codes_uid * sizeof (int));\n-  memset (unscaled_index_insn_codes, -1,\n-\t  max_unscaled_index_insn_codes_uid * sizeof (int));\n-\n-  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx set = single_set (insn);\n-      rtx mem = NULL_RTX;\n-\n-      /* Ignore anything that isn't a normal SET.  */\n-      if (set == NULL_RTX)\n-\tcontinue;\n-\n-      /* No insns can have more than one MEM.  */\n-      if (GET_CODE (SET_SRC (set)) == MEM)\n-\tmem = SET_SRC (set);\n-\n-      if (GET_CODE (SET_DEST (set)) == MEM)\n-\tmem = SET_DEST (set);\n-\t\n-      /* If neither operand is a mem, then there's nothing to do.  */\n-      if (mem == NULL_RTX)\n-\tcontinue;\n-\n-      if (GET_CODE (XEXP (mem, 0)) != PLUS)\n-\tcontinue;\n-\n-      /* If both are REGs (or SUBREGs), then record the insn code for\n-\t this insn.  */\n-      if (REG_P (XEXP (XEXP (mem, 0), 0)) && REG_P (XEXP (XEXP (mem, 0), 1)))\n-        unscaled_index_insn_codes[INSN_UID (insn)] = INSN_CODE (insn);\n-    }\n-}\n-\n /* We use this hook to perform a PA specific optimization which is difficult\n    to do in earlier passes.\n \n@@ -6480,10 +6368,6 @@ pa_reorg (insns)\n {\n   rtx insn;\n \n-  /* Keep track of which insns have unscaled indexed addresses, and which\n-     register is the base address in such insns.  */\n-  record_unscaled_index_insn_codes (insns);\n-\n   remove_useless_addtr_insns (insns, 1);\n \n   if (pa_cpu < PROCESSOR_8000)"}]}