{"sha": "a7d08a38447bb6dce90573562211e93fc032763a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdkMDhhMzg0NDdiYjZkY2U5MDU3MzU2MjIxMWU5M2ZjMDMyNzYzYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:07:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T14:07:57Z"}, "message": "[multiple changes]\n\n2013-10-17  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb (Resolve_Short_Circuit): Only\n\tgenerate expression-with-action when full expansion is set.\n\n2013-10-17  Yannick Moy  <moy@adacore.com>\n\n\t* debug.adb Remove obsolete comment.\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Process_Transient_Object.Find_Enclosing_Contexts):\n\tAvoid late insertion when expanding an expression with action\n\tnested within a transient block; Do not inconditionally generate\n\ta finalization call if the generated object is from a specific\n\tbranch of a conditional expression.\n\n2013-10-17  Pascal Obry  <obry@adacore.com>\n\n\t* g-arrspl.adb: Ensure Finalize call is idempotent.\n\t* g-arrspl.adb (Finalize): Makes the call idempotent.\n\nFrom-SVN: r203768", "tree": {"sha": "b86dd1066e33deeb638fb8adb817f1b91b7ee3bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b86dd1066e33deeb638fb8adb817f1b91b7ee3bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7d08a38447bb6dce90573562211e93fc032763a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d08a38447bb6dce90573562211e93fc032763a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7d08a38447bb6dce90573562211e93fc032763a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7d08a38447bb6dce90573562211e93fc032763a/comments", "author": null, "committer": null, "parents": [{"sha": "a9895094b3e88b913cee8a9115ffae8fd89e8c55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9895094b3e88b913cee8a9115ffae8fd89e8c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9895094b3e88b913cee8a9115ffae8fd89e8c55"}], "stats": {"total": 90, "additions": 52, "deletions": 38}, "files": [{"sha": "acda7cfc691374d8fbe65ca2040c8229409f2325", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=a7d08a38447bb6dce90573562211e93fc032763a", "patch": "@@ -665,10 +665,6 @@ package body Debug is\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode.\n \n-   --  d.Y  Prevents the use of the N_Expression_With_Actions node even in the\n-   --       case of the gcc back end. Provided as a back up in case the new\n-   --       scheme has problems.\n-\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "ad65378cffb600d26c33c18d6f554f1dd2e80403", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a7d08a38447bb6dce90573562211e93fc032763a", "patch": "@@ -12158,23 +12158,21 @@ package body Exp_Ch4 is\n          Par : Node_Id;\n          Top : Node_Id;\n \n-      begin\n-         --  In most cases an expression that creates a controlled object\n-         --  generates a transient scope around it. If this is the case then\n-         --  other controlled values can reuse it.\n-\n-         if Scope_Is_Transient then\n-            Hook_Context := Node_To_Be_Wrapped;\n+         Wrapped_Node : Node_Id;\n+         --  Note: if we are in a transient scope, we want to reuse it as\n+         --  the context for actions insertion, if possible. But if N is itself\n+         --  part of the stored actions for the current transient scope,\n+         --  then we need to insert at the appropriate (inner) location in\n+         --  the not as an action on Node_To_Be_Wrapped.\n \n-         --  In some cases, such as return statements, no transient scope is\n-         --  generated, in which case we have to look up in the tree to find\n-         --  the proper list on which to place the transient.\n+         In_Cond_Expr : constant Boolean := Within_Case_Or_If_Expression (N);\n \n+      begin\n          --  When the node is inside a case/if expression, the lifetime of any\n          --  temporary controlled object is extended. Find a suitable insertion\n          --  node by locating the topmost case or if expressions.\n \n-         elsif Within_Case_Or_If_Expression (N) then\n+         if In_Cond_Expr then\n             Par := N;\n             Top := N;\n             while Present (Par) loop\n@@ -12256,8 +12254,16 @@ package body Exp_Ch4 is\n \n             --    Proc (... and then Ctrl_Func_Call ...);\n \n+            if Scope_Is_Transient then\n+               Wrapped_Node := Node_To_Be_Wrapped;\n+            else\n+               Wrapped_Node := Empty;\n+            end if;\n+\n             while Present (Par) loop\n-               if Nkind_In (Par, N_Assignment_Statement,\n+               if Par = Wrapped_Node\n+                    or else\n+                  Nkind_In (Par, N_Assignment_Statement,\n                                  N_Object_Declaration,\n                                  N_Pragma,\n                                  N_Procedure_Call_Statement,\n@@ -12292,9 +12298,14 @@ package body Exp_Ch4 is\n             --  In this case, the finalization context is chosen so that\n             --  we know at finalization point that the hook pointer is\n             --  never null, so no need for a test, we can call the finalizer\n-            --  unconditionally.\n+            --  unconditionally, except in the case where the object is\n+            --  created in a specific branch of a conditional expression.\n \n-            Finalize_Always := True;\n+            Finalize_Always :=\n+               not (In_Cond_Expr\n+                      or else\n+                    Nkind_In (Original_Node (N), N_Case_Expression,\n+                                                 N_If_Expression));\n \n             declare\n                Loc  : constant Source_Ptr := Sloc (N);\n@@ -12382,6 +12393,13 @@ package body Exp_Ch4 is\n \n       --  Step 3: Hook the transient object to the temporary\n \n+      --  This must be inserted right after the object declaration, so that\n+      --  the assignment is executed if, and only if, the object is actually\n+      --  created (whereas the declaration of the hook pointer, and the\n+      --  finalization call, may be inserted at an outer level, and may\n+      --  remain unused for some executions, if the actual creation of\n+      --  the object is conditional).\n+\n       --  The use of unchecked conversion / unrestricted access is needed to\n       --  avoid an accessibility violation. Note that the finalization code is\n       --  structured in such a way that the \"hook\" is processed only when it\n@@ -12401,18 +12419,10 @@ package body Exp_Ch4 is\n       --      <or>\n       --    Temp := Obj_Id'Unrestricted_Access;\n \n-      if Finalization_Context /= Hook_Context then\n-         Insert_Action (Finalization_Context,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Temp_Id, Loc),\n-             Expression => Expr));\n-\n-      else\n-         Insert_After_And_Analyze (Decl,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (Temp_Id, Loc),\n-             Expression => Expr));\n-      end if;\n+      Insert_After_And_Analyze (Decl,\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Reference_To (Temp_Id, Loc),\n+          Expression => Expr));\n \n       --  Step 4: Finalize the transient controlled object after the context\n       --  has been evaluated/elaborated. Generate:"}, {"sha": "9229610554fc8bf4e2d9f7492c8d0afc8cb3ab52", "filename": "gcc/ada/g-arrspl.adb", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fg-arrspl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fg-arrspl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-arrspl.adb?ref=a7d08a38447bb6dce90573562211e93fc032763a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -118,14 +118,22 @@ package body GNAT.Array_Split is\n       procedure Free is\n          new Ada.Unchecked_Deallocation (Natural, Counter);\n \n+      Ref_Counter : Counter := S.Ref_Counter;\n+\n    begin\n-      S.Ref_Counter.all := S.Ref_Counter.all - 1;\n+      --  Ensure call is idempotent\n+\n+      S.Ref_Counter := null;\n \n-      if S.Ref_Counter.all = 0 then\n-         Free (S.Source);\n-         Free (S.Indexes);\n-         Free (S.Slices);\n-         Free (S.Ref_Counter);\n+      if Ref_Counter /= null then\n+         Ref_Counter.all := Ref_Counter.all - 1;\n+\n+         if Ref_Counter.all = 0 then\n+            Free (S.Source);\n+            Free (S.Indexes);\n+            Free (S.Slices);\n+            Free (Ref_Counter);\n+         end if;\n       end if;\n    end Finalize;\n "}, {"sha": "9a76e04adf61f39b2ad3ce1505ed829b87ecf692", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7d08a38447bb6dce90573562211e93fc032763a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a7d08a38447bb6dce90573562211e93fc032763a", "patch": "@@ -9022,7 +9022,7 @@ package body Sem_Res is\n       --  helpful for coverage analysis. However this should not happen in\n       --  generics.\n \n-      if Expander_Active then\n+      if Full_Expander_Active then\n          declare\n             Reloc_L : constant Node_Id := Relocate_Node (L);\n          begin"}]}