{"sha": "80746f5d88a60d13bc63f2f76a9dc547261b9601", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3NDZmNWQ4OGE2MGQxM2JjNjNmMmY3NmE5ZGM1NDcyNjFiOTYwMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-20T10:27:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-20T10:27:37Z"}, "message": "utils.c (maybe_pad_type): In type_annotate_only mode...\n\n\t* gcc-interface/utils.c (maybe_pad_type): In type_annotate_only mode,\n\tretrieve the component type if this is an array and do not issue the\n\twarning for concurrent types.\n\nFrom-SVN: r231859", "tree": {"sha": "b1b6049a89422cb89eb4659b44f9a0ae9c121903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1b6049a89422cb89eb4659b44f9a0ae9c121903"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80746f5d88a60d13bc63f2f76a9dc547261b9601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80746f5d88a60d13bc63f2f76a9dc547261b9601", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80746f5d88a60d13bc63f2f76a9dc547261b9601", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80746f5d88a60d13bc63f2f76a9dc547261b9601/comments", "author": null, "committer": null, "parents": [{"sha": "afeb246c1bb0b5496dfd133c70fef9d9fff722ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afeb246c1bb0b5496dfd133c70fef9d9fff722ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afeb246c1bb0b5496dfd133c70fef9d9fff722ac"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "0de7c0a8cdc6a8b821a6afc0b14839d1eb80a6b4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80746f5d88a60d13bc63f2f76a9dc547261b9601/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80746f5d88a60d13bc63f2f76a9dc547261b9601/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80746f5d88a60d13bc63f2f76a9dc547261b9601", "patch": "@@ -1,3 +1,9 @@\n+2015-12-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (maybe_pad_type): In type_annotate_only mode,\n+\tretrieve the component type if this is an array and do not issue the\n+\twarning for concurrent types.\n+\n 2015-12-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TYPE_DEBUG_TYPE): Remove duplicate."}, {"sha": "779c376c2f18e5adc0869e8321b635b7ef3ebb96", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80746f5d88a60d13bc63f2f76a9dc547261b9601/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80746f5d88a60d13bc63f2f76a9dc547261b9601/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=80746f5d88a60d13bc63f2f76a9dc547261b9601", "patch": "@@ -1411,19 +1411,28 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   rest_of_record_type_compilation (record);\n \n built:\n-  /* If the size was widened explicitly, maybe give a warning.  Take the\n-     original size as the maximum size of the input if there was an\n-     unconstrained record involved and round it up to the specified alignment,\n-     if one was specified.  But don't do it if we are just annotating types\n-     and the type is tagged, since tagged types aren't fully laid out in this\n-     mode.  */\n+  /* If a simple size was explicitly given, maybe issue a warning.  */\n   if (!size\n       || TREE_CODE (size) == COND_EXPR\n       || TREE_CODE (size) == MAX_EXPR\n-      || No (gnat_entity)\n-      || (type_annotate_only && Is_Tagged_Type (Etype (gnat_entity))))\n+      || No (gnat_entity))\n     return record;\n \n+  /* But don't do it if we are just annotating types and the type is tagged or\n+     concurrent, since these types aren't fully laid out in this mode.  */\n+  if (type_annotate_only)\n+    {\n+      Entity_Id gnat_type\n+\t= is_component_type\n+\t  ? Component_Type (gnat_entity) : Etype (gnat_entity);\n+\n+      if (Is_Tagged_Type (gnat_type) || Is_Concurrent_Type (gnat_type))\n+\treturn record;\n+    }\n+\n+  /* Take the original size as the maximum size of the input if there was an\n+     unconstrained record involved and round it up to the specified alignment,\n+     if one was specified, but only for aggregate types.  */\n   if (CONTAINS_PLACEHOLDER_P (orig_size))\n     orig_size = max_size (orig_size, true);\n "}]}