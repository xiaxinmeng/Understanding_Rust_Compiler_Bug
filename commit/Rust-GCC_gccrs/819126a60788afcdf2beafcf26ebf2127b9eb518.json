{"sha": "819126a60788afcdf2beafcf26ebf2127b9eb518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5MTI2YTYwNzg4YWZjZGYyYmVhZmNmMjZlYmYyMTI3YjllYjUxOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-07-30T10:49:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-07-30T10:49:23Z"}, "message": "(mult_is_very_cheap): Delete.\n\n(mult_cost): Delete.\n(init_expmed): Delete computation of mult_cost and mult_is_very_cheap.\n(expand_mult): Compute mult_cost here for every constant multiplier.\n(synth_mult): Return found algorithms through a struct pointer.\n\nFrom-SVN: r5045", "tree": {"sha": "9786b18a710ae16545920354a6efca90bf4142ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9786b18a710ae16545920354a6efca90bf4142ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/819126a60788afcdf2beafcf26ebf2127b9eb518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819126a60788afcdf2beafcf26ebf2127b9eb518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819126a60788afcdf2beafcf26ebf2127b9eb518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819126a60788afcdf2beafcf26ebf2127b9eb518/comments", "author": null, "committer": null, "parents": [{"sha": "0d4d42c3657c4fb51806312e2af9297d91da3657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4d42c3657c4fb51806312e2af9297d91da3657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4d42c3657c4fb51806312e2af9297d91da3657"}], "stats": {"total": 214, "additions": 106, "deletions": 108}, "files": [{"sha": "ef6a519ff219706f23ef8cae0cd5b64f3aa939fe", "filename": "gcc/expmed.c", "status": "modified", "additions": 106, "deletions": 108, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819126a60788afcdf2beafcf26ebf2127b9eb518/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819126a60788afcdf2beafcf26ebf2127b9eb518/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=819126a60788afcdf2beafcf26ebf2127b9eb518", "patch": "@@ -39,9 +39,6 @@ static rtx lshift_value ();\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n-/* Non-zero means multiply instructions are cheaper than shifts.  */\n-int mult_is_very_cheap;\n-\n /* Non-zero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead. \n    Usually, this will mean that the MD file will emit non-branch\n@@ -58,7 +55,7 @@ static int sdiv_pow2_cheap, smod_pow2_cheap;\n #endif\n \n /* Cost of various pieces of RTL.  */\n-static int add_cost, mult_cost, negate_cost, zero_cost;\n+static int add_cost, negate_cost, zero_cost;\n static int shift_cost[MAX_BITS_PER_WORD];\n static int shiftadd_cost[MAX_BITS_PER_WORD];\n static int shiftsub_cost[MAX_BITS_PER_WORD];\n@@ -125,17 +122,8 @@ init_expmed ()\n \tshiftsub_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftsub_insn)), SET);\n     }\n \n-  mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n-  /* For gcc 2.4 keep MULT_COST small to avoid really slow searches\n-     in synth_mult.  */\n-  mult_cost = MIN (12 * add_cost, mult_cost);\n   negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n \n-  /* 999999 is chosen to avoid any plausible faster special case.  */\n-  mult_is_very_cheap\n-    = (rtx_cost (gen_rtx (MULT, word_mode, reg, GEN_INT (999999)), SET)\n-       < rtx_cost (gen_rtx (ASHIFT, word_mode, reg, GEN_INT (7)), SET));\n-\n   sdiv_pow2_cheap\n     = (rtx_cost (gen_rtx (DIV, word_mode, reg, GEN_INT (32)), SET)\n        <= 2 * add_cost);\n@@ -1818,8 +1806,9 @@ struct algorithm\n    If retval.cost >= COST_LIMIT, no algorithm was found and all\n    other field of the returned struct are undefined.  */\n \n-static struct algorithm\n-synth_mult (t, cost_limit)\n+static void\n+synth_mult (alg_out, t, cost_limit)\n+     struct algorithm *alg_out;\n      unsigned HOST_WIDE_INT t;\n      int cost_limit;\n {\n@@ -1833,33 +1822,32 @@ synth_mult (t, cost_limit)\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n-  best_alg->cost = cost_limit;\n+  alg_out->cost = cost_limit;\n \n   if (cost_limit <= 0)\n-    return *best_alg;\n+    return;\n \n   /* t == 1 can be done in zero cost.  */\n   if (t == 1)\n     {\n-      best_alg->ops = 1;\n-      best_alg->cost = 0;\n-      best_alg->op[0] = alg_m;\n-      return *best_alg;\n+      alg_out->ops = 1;\n+      alg_out->cost = 0;\n+      alg_out->op[0] = alg_m;\n+      return;\n     }\n \n   /* t == 0 sometimes has a cost.  If it does and it exceeds our limit,\n      fail now.  */\n-\n-  else if (t == 0)\n+  if (t == 0)\n     {\n       if (zero_cost >= cost_limit)\n-\treturn *best_alg;\n+\treturn;\n       else\n \t{\n-\t  best_alg->ops = 1;\n-\t  best_alg->cost = zero_cost;\n-\t  best_alg->op[0] = alg_zero;\n-\t  return *best_alg;\n+\t  alg_out->ops = 1;\n+\t  alg_out->cost = zero_cost;\n+\t  alg_out->op[0] = alg_zero;\n+\t  return;\n \t}\n     }\n \n@@ -1871,67 +1859,64 @@ synth_mult (t, cost_limit)\n       m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n       q = t >> m;\n       cost = shift_cost[m];\n+      synth_mult (alg_in, q, cost_limit - cost);\n+\n+      cost += alg_in->cost;\n       if (cost < cost_limit)\n \t{\n-\t  *alg_in = synth_mult (q, cost_limit - cost);\n+\t  struct algorithm *x;\n+\t  x = alg_in, alg_in = best_alg, best_alg = x;\n+\t  best_alg->log[best_alg->ops] = m;\n+\t  best_alg->op[best_alg->ops] = alg_shift;\n+\t  cost_limit = cost;\n+\t}\n+    }\n+\n+  /* If we have an odd number, add or subtract one.  */\n+  if ((t & 1) != 0)\n+    {\n+      unsigned HOST_WIDE_INT w;\n+\n+      for (w = 1; (w & t) != 0; w <<= 1)\n+\t;\n+      if (w > 2\n+\t  /* Reject the case where t is 3.\n+\t     Thus we prefer addition in that case.  */\n+\t  && t != 3)\n+\t{\n+\t  /* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n+\n+\t  cost = add_cost;\n+\t  synth_mult (alg_in, t + 1, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n+\t  if (cost < cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n-\t      best_alg->log[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_shift;\n-\t      best_alg->cost = cost_limit = cost;\n+\t      best_alg->log[best_alg->ops] = 0;\n+\t      best_alg->op[best_alg->ops] = alg_sub_t_m2;\n+\t      cost_limit = cost;\n \t    }\n \t}\n-    }\n+      else\n+\t{\n+\t  /* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n \n-  /* If we have an odd number, add or subtract one.  */\n-  if ((t & 1) != 0)\n-  {\n-    unsigned HOST_WIDE_INT w;\n-\n-    for (w = 1; (w & t) != 0; w <<= 1)\n-      ;\n-    if (w > 2\n-\t/* Reject the case where t is 3.\n-\t   Thus we prefer addition in that case.  */\n-\t&& t != 3)\n-      {\n-\t/* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */\n-\n-\tcost = add_cost;\n-\t*alg_in = synth_mult (t + 1, cost_limit - cost);\n-\n-\tcost += alg_in->cost;\n-\tif (cost < best_alg->cost)\n-\t  {\n-\t    struct algorithm *x;\n-\t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->log[best_alg->ops] = 0;\n-\t    best_alg->op[best_alg->ops++] = alg_sub_t_m2;\n-\t    best_alg->cost = cost_limit = cost;\n-\t  }\n-      }\n-    else\n-      {\n-\t/* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */\n-\n-\tcost = add_cost;\n-\t*alg_in = synth_mult (t - 1, cost_limit - cost);\n-\n-\tcost += alg_in->cost;\n-\tif (cost < best_alg->cost)\n-\t  {\n-\t    struct algorithm *x;\n-\t    x = alg_in, alg_in = best_alg, best_alg = x;\n-\t    best_alg->log[best_alg->ops] = 0;\n-\t    best_alg->op[best_alg->ops++] = alg_add_t_m2;\n-\t    best_alg->cost = cost_limit = cost;\n-\t  }\n-      }\n-  }\n+\t  cost = add_cost;\n+\t  synth_mult (alg_in, t - 1, cost_limit - cost);\n+\n+\t  cost += alg_in->cost;\n+\t  if (cost < cost_limit)\n+\t    {\n+\t      struct algorithm *x;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->log[best_alg->ops] = 0;\n+\t      best_alg->op[best_alg->ops] = alg_add_t_m2;\n+\t      cost_limit = cost;\n+\t    }\n+\t}\n+    }\n \n   /* Look for factors of t of the form\n      t = q(2**m +- 1), 2 <= m <= floor(log2(t - 1)).\n@@ -1951,33 +1936,33 @@ synth_mult (t, cost_limit)\n       if (t % d == 0 && t > d)\n \t{\n \t  cost = MIN (shiftadd_cost[m], add_cost + shift_cost[m]);\n-\t  *alg_in = synth_mult (t / d, cost_limit - cost);\n+\t  synth_mult (alg_in, t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n+\t  if (cost < cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_add_factor;\n-\t      best_alg->cost = cost_limit = cost;\n+\t      best_alg->op[best_alg->ops] = alg_add_factor;\n+\t      cost_limit = cost;\n \t    }\n \t}\n \n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n       if (t % d == 0 && t > d)\n \t{\n \t  cost = MIN (shiftsub_cost[m], add_cost + shift_cost[m]);\n-\t  *alg_in = synth_mult (t / d, cost_limit - cost);\n+\t  synth_mult (alg_in, t / d, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n+\t  if (cost < cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_sub_factor;\n-\t      best_alg->cost = cost_limit = cost;\n+\t      best_alg->op[best_alg->ops] = alg_sub_factor;\n+\t      cost_limit = cost;\n \t    }\n \t}\n     }\n@@ -1992,16 +1977,16 @@ synth_mult (t, cost_limit)\n       if (m >= 0)\n \t{\n \t  cost = shiftadd_cost[m];\n-\t  *alg_in = synth_mult ((t - 1) >> m, cost_limit - cost);\n+\t  synth_mult (alg_in, (t - 1) >> m, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n+\t  if (cost < cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_add_t2_m;\n-\t      best_alg->cost = cost_limit = cost;\n+\t      best_alg->op[best_alg->ops] = alg_add_t2_m;\n+\t      cost_limit = cost;\n \t    }\n \t}\n \n@@ -2011,26 +1996,37 @@ synth_mult (t, cost_limit)\n       if (m >= 0)\n \t{\n \t  cost = shiftsub_cost[m];\n-\t  *alg_in = synth_mult ((t + 1) >> m, cost_limit - cost);\n+\t  synth_mult (alg_in, (t + 1) >> m, cost_limit - cost);\n \n \t  cost += alg_in->cost;\n-\t  if (cost < best_alg->cost)\n+\t  if (cost < cost_limit)\n \t    {\n \t      struct algorithm *x;\n \t      x = alg_in, alg_in = best_alg, best_alg = x;\n \t      best_alg->log[best_alg->ops] = m;\n-\t      best_alg->op[best_alg->ops++] = alg_sub_t2_m;\n-\t      best_alg->cost = cost_limit = cost;\n+\t      best_alg->op[best_alg->ops] = alg_sub_t2_m;\n+\t      cost_limit = cost;\n \t    }\n \t}\n     }\n \n   /* If we are getting a too long sequence for `struct algorithm'\n-     to record, store a fake cost to make this search fail.  */\n+     to record, make this search fail.  */\n   if (best_alg->ops == MAX_BITS_PER_WORD)\n-    best_alg->cost = cost_limit;\n-\n-  return *best_alg;\n+    return;\n+\n+  /* If cost_limit has not decreased since we stored it in alg_out->cost,\n+     we have not found any algorithm.  */\n+  if (cost_limit == alg_out->cost)\n+    return;\n+\n+  /* Copy the algorithm from temporary space to the space at alg_out.\n+     We avoid using structure assignment because the majority of\n+     best_alg is normally undefined, and this is a critical function.  */\n+  alg_out->ops = best_alg->ops + 1;\n+  alg_out->cost = cost_limit;\n+  bcopy (best_alg->op, alg_out->op, alg_out->ops * sizeof *alg_out->op);\n+  bcopy (best_alg->log, alg_out->log, alg_out->ops * sizeof *alg_out->log);\n }\n \f\n /* Perform a multiplication and return an rtx for the result.\n@@ -2065,14 +2061,15 @@ expand_mult (mode, op0, op1, target, unsignedp)\n      But this causes such a terrible slowdown sometimes\n      that it seems better to use synth_mult always.  */\n \n-  if (GET_CODE (const_op1) == CONST_INT && ! mult_is_very_cheap)\n+  if (GET_CODE (const_op1) == CONST_INT)\n     {\n       struct algorithm alg;\n       struct algorithm neg_alg;\n       int negate = 0;\n       HOST_WIDE_INT val = INTVAL (op1);\n       HOST_WIDE_INT val_so_far;\n       rtx insn;\n+      int mult_cost;\n \n       /* Try to do the computation two ways: multiply by the negative of OP1\n \t and then negate, or do the multiplication directly.  The latter is\n@@ -2081,10 +2078,12 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t has a factor of 2**m +/- 1, while the negated value does not or\n \t vice versa.  */\n \n-      alg = synth_mult (val, mult_cost);\n-      neg_alg = synth_mult (- val,\n-\t\t\t    (alg.cost < mult_cost ? alg.cost : mult_cost)\n-\t\t\t    - negate_cost);\n+      mult_cost = rtx_cost (gen_rtx (MULT, mode, op0, op1), SET);\n+      mult_cost = MIN (12 * add_cost, mult_cost);\n+\n+      synth_mult (&alg, val, mult_cost);\n+      synth_mult (&neg_alg, - val,\n+\t\t  (alg.cost < mult_cost ? alg.cost : mult_cost) - negate_cost);\n \n       if (neg_alg.cost + negate_cost < alg.cost)\n \talg = neg_alg, negate = 1;\n@@ -2112,7 +2111,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t    }\n \t  else if (alg.op[0] == alg_m)\n \t    {\n-\t      accum  = copy_to_mode_reg (mode, op0);\n+\t      accum = copy_to_mode_reg (mode, op0);\n \t      val_so_far = 1;\n \t    }\n \t  else\n@@ -2207,9 +2206,8 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t}\n     }\n \n-  /* This used to use umul_optab if unsigned,\n-     but for non-widening multiply there is no difference\n-     between signed and unsigned.  */\n+  /* This used to use umul_optab if unsigned, but for non-widening multiply\n+     there is no difference between signed and unsigned.  */\n   op0 = expand_binop (mode, smul_optab,\n \t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);\n   if (op0 == 0)"}]}