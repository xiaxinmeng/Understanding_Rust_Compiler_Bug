{"sha": "3843dc1460259fbca1f336b0259f0b6b527d77ae", "node_id": "C_kwDOANBUbNoAKDM4NDNkYzE0NjAyNTlmYmNhMWYzMzZiMDI1OWYwYjZiNTI3ZDc3YWU", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-03-01T14:11:53Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-03-01T14:24:36Z"}, "message": "OpenMP: Ignore side-effects when finding struct comps [PR108545]\n\nWith volatile, two 'x.data' comp refs aren't regarded as identical,\ncausing that the two items in the first map of\n  map(to:x.a, x.a.data) map(pset: x.a.data)\nend up in separate 'map(struct:x)', which will cause a later ICE.\n\nSolution: Ignore side effects when checking the operands in the hash\nfor being equal. (Do so by creating a variant of tree_operand_hash\nthat calls operand_equal_p with OEP_MATCH_SIDE_EFFECTS.)\n\ngcc/ChangeLog:\n\n\tPR middle-end/108545\n\t* gimplify.cc (struct tree_operand_hash_no_se): New.\n\t(omp_index_mapping_groups_1, omp_index_mapping_groups,\n\tomp_reindex_mapping_groups, omp_mapped_by_containing_struct,\n\tomp_tsort_mapping_groups_1, omp_tsort_mapping_groups,\n\toacc_resolve_clause_dependencies, omp_build_struct_sibling_lists,\n\tgimplify_scan_omp_clauses): Use tree_operand_hash_no_se instead\n\tof tree_operand_hash.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/108545\n\t* c-c++-common/gomp/map-8.c: New test.\n\t* gfortran.dg/gomp/map-9.f90: New test.", "tree": {"sha": "91c22dcf53dde512f6f7c8b868bee57bcc7c0b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91c22dcf53dde512f6f7c8b868bee57bcc7c0b4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3843dc1460259fbca1f336b0259f0b6b527d77ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3843dc1460259fbca1f336b0259f0b6b527d77ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3843dc1460259fbca1f336b0259f0b6b527d77ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3843dc1460259fbca1f336b0259f0b6b527d77ae/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070523b9d4c6cfa69060255893006efaf39bf617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070523b9d4c6cfa69060255893006efaf39bf617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070523b9d4c6cfa69060255893006efaf39bf617"}], "stats": {"total": 83, "additions": 65, "deletions": 18}, "files": [{"sha": "ade6e335da7b18c5fe5d879e18fd87264b7420eb", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=3843dc1460259fbca1f336b0259f0b6b527d77ae", "patch": "@@ -8958,6 +8958,22 @@ enum omp_tsort_mark {\n   PERMANENT\n };\n \n+/* Hash for trees based on operand_equal_p.  Like tree_operand_hash\n+   but ignores side effects in the equality comparisons.  */\n+\n+struct tree_operand_hash_no_se : tree_operand_hash\n+{\n+  static inline bool equal (const value_type &,\n+\t\t\t    const compare_type &);\n+};\n+\n+inline bool\n+tree_operand_hash_no_se::equal (const value_type &t1,\n+\t\t\t\tconst compare_type &t2)\n+{\n+  return operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS);\n+}\n+\n /* A group of OMP_CLAUSE_MAP nodes that correspond to a single \"map\"\n    clause.  */\n \n@@ -9400,10 +9416,10 @@ omp_group_base (omp_mapping_group *grp, unsigned int *chained,\n }\n \n /* Given a vector of omp_mapping_groups, build a hash table so we can look up\n-   nodes by tree_operand_hash.  */\n+   nodes by tree_operand_hash_no_se.  */\n \n static void\n-omp_index_mapping_groups_1 (hash_map<tree_operand_hash,\n+omp_index_mapping_groups_1 (hash_map<tree_operand_hash_no_se,\n \t\t\t\t     omp_mapping_group *> *grpmap,\n \t\t\t    vec<omp_mapping_group> *groups,\n \t\t\t    tree reindex_sentinel)\n@@ -9432,7 +9448,6 @@ omp_index_mapping_groups_1 (hash_map<tree_operand_hash,\n \t   node = OMP_CLAUSE_CHAIN (node), j++)\n \t{\n \t  tree decl = OMP_CLAUSE_DECL (node);\n-\n \t  /* Sometimes we see zero-offset MEM_REF instead of INDIRECT_REF,\n \t     meaning node-hash lookups don't work.  This is a workaround for\n \t     that, but ideally we should just create the INDIRECT_REF at\n@@ -9478,11 +9493,11 @@ omp_index_mapping_groups_1 (hash_map<tree_operand_hash,\n     }\n }\n \n-static hash_map<tree_operand_hash, omp_mapping_group *> *\n+static hash_map<tree_operand_hash_no_se, omp_mapping_group *> *\n omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n {\n-  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n-    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n+  hash_map<tree_operand_hash_no_se, omp_mapping_group *> *grpmap\n+    = new hash_map<tree_operand_hash_no_se, omp_mapping_group *>;\n \n   omp_index_mapping_groups_1 (grpmap, groups, NULL_TREE);\n \n@@ -9502,14 +9517,14 @@ omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n    so, we can do the reindex operation in two parts, on the processed and\n    then the unprocessed halves of the list.  */\n \n-static hash_map<tree_operand_hash, omp_mapping_group *> *\n+static hash_map<tree_operand_hash_no_se, omp_mapping_group *> *\n omp_reindex_mapping_groups (tree *list_p,\n \t\t\t    vec<omp_mapping_group> *groups,\n \t\t\t    vec<omp_mapping_group> *processed_groups,\n \t\t\t    tree sentinel)\n {\n-  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n-    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n+  hash_map<tree_operand_hash_no_se, omp_mapping_group *> *grpmap\n+    = new hash_map<tree_operand_hash_no_se, omp_mapping_group *>;\n \n   processed_groups->truncate (0);\n \n@@ -9550,7 +9565,7 @@ omp_containing_struct (tree expr)\n    that maps that structure, if present.  */\n \n static bool\n-omp_mapped_by_containing_struct (hash_map<tree_operand_hash,\n+omp_mapped_by_containing_struct (hash_map<tree_operand_hash_no_se,\n \t\t\t\t\t  omp_mapping_group *> *grpmap,\n \t\t\t\t tree decl,\n \t\t\t\t omp_mapping_group **mapped_by_group)\n@@ -9590,8 +9605,8 @@ omp_mapped_by_containing_struct (hash_map<tree_operand_hash,\n static bool\n omp_tsort_mapping_groups_1 (omp_mapping_group ***outlist,\n \t\t\t    vec<omp_mapping_group> *groups,\n-\t\t\t    hash_map<tree_operand_hash, omp_mapping_group *>\n-\t\t\t      *grpmap,\n+\t\t\t    hash_map<tree_operand_hash_no_se,\n+\t\t\t\t     omp_mapping_group *> *grpmap,\n \t\t\t    omp_mapping_group *grp)\n {\n   if (grp->mark == PERMANENT)\n@@ -9670,7 +9685,7 @@ omp_tsort_mapping_groups_1 (omp_mapping_group ***outlist,\n \n static omp_mapping_group *\n omp_tsort_mapping_groups (vec<omp_mapping_group> *groups,\n-\t\t\t  hash_map<tree_operand_hash, omp_mapping_group *>\n+\t\t\t  hash_map<tree_operand_hash_no_se, omp_mapping_group *>\n \t\t\t    *grpmap)\n {\n   omp_mapping_group *grp, *outlist = NULL, **cursor;\n@@ -9986,7 +10001,7 @@ omp_check_mapping_compatibility (location_t loc,\n \n void\n oacc_resolve_clause_dependencies (vec<omp_mapping_group> *groups,\n-\t\t\t\t  hash_map<tree_operand_hash,\n+\t\t\t\t  hash_map<tree_operand_hash_no_se,\n \t\t\t\t\t   omp_mapping_group *> *grpmap)\n {\n   int i;\n@@ -10520,8 +10535,8 @@ static bool\n omp_build_struct_sibling_lists (enum tree_code code,\n \t\t\t\tenum omp_region_type region_type,\n \t\t\t\tvec<omp_mapping_group> *groups,\n-\t\t\t\thash_map<tree_operand_hash, omp_mapping_group *>\n-\t\t\t\t  **grpmap,\n+\t\t\t\thash_map<tree_operand_hash_no_se,\n+\t\t\t\t\t omp_mapping_group *> **grpmap,\n \t\t\t\ttree *list_p)\n {\n   unsigned i;\n@@ -10747,7 +10762,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n       groups = omp_gather_mapping_groups (list_p);\n       if (groups)\n \t{\n-\t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n+\t  hash_map<tree_operand_hash_no_se, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n \n \t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap,\n@@ -10783,7 +10798,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n       groups = omp_gather_mapping_groups (list_p);\n       if (groups)\n \t{\n-\t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n+\t  hash_map<tree_operand_hash_no_se, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n \n \t  oacc_resolve_clause_dependencies (groups, grpmap);"}, {"sha": "cc7dac8bd0fcf8f6040362fe67ed579ef7c90425", "filename": "gcc/testsuite/c-c++-common/gomp/map-8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmap-8.c?ref=3843dc1460259fbca1f336b0259f0b6b527d77ae", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-additional-options \"-fdump-tree-omplower\" } */\n+\n+/* PR fortran/108545 */\n+\n+/* { dg-final { scan-tree-dump \"#pragma omp target enter data map\\\\(struct:my_struct \\\\\\[len: 1\\\\\\]\\\\) map\\\\(to:my_struct.u \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"#pragma omp target enter data map\\\\(to:my_struct3 \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" \"omplower\" } } */\n+\n+\n+volatile struct t {\n+  struct t2 { int *a; int c; } u;\n+  int b;\n+} my_struct;\n+volatile struct t3 { int *a; int c; } my_struct3;\n+\n+void f()\n+{\n+  #pragma omp target enter data map(to:my_struct.u) map(to:my_struct.u.a)\n+  #pragma omp target enter data map(to:my_struct3) map(to:my_struct3.a)\n+}"}, {"sha": "9e7b811c8af162ef2e123e8d18bc154ab1090e36", "filename": "gcc/testsuite/gfortran.dg/gomp/map-9.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3843dc1460259fbca1f336b0259f0b6b527d77ae/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-9.f90?ref=3843dc1460259fbca1f336b0259f0b6b527d77ae", "patch": "@@ -0,0 +1,13 @@\n+! { dg-additional-options \"-fdump-tree-omplower\" }\n+\n+! PR fortran/108545\n+\n+! { dg-final { scan-tree-dump \"#pragma omp target enter data map\\\\(struct:x \\\\\\[len: 1\\\\\\]\\\\) map\\\\(to:x.a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(to:MEM <integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\]> \\\\\\[\\\\(integer\\\\(kind=4\\\\)\\\\\\[0:\\\\\\] \\\\*\\\\)_\\[0-9\\]+] \\\\\\[len: _\\[0-9\\]+\\\\\\]\\\\) map\\\\(always_pointer:x.a.data \\\\\\[pointer assign, bias: 0\\\\\\]\\\\)\" \"omplower\" } }\n+\n+program p\n+   type t\n+      integer, pointer :: a(:)\n+   end type\n+   type(t), volatile :: x\n+   !$omp target enter data map(to: x%a)\n+end"}]}