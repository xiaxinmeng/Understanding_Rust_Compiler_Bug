{"sha": "6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM3N2JiOWFhNTI5ODk2YjFmOGQwMWY1YjQ0MGU0ZjRkYmZlODBlZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-30T18:34:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-30T18:34:32Z"}, "message": "expr.c (expand_expr_addr_expr): New.\n\n        * expr.c (expand_expr_addr_expr): New.\n        (expand_expr_real_1) <case ADDR_EXPR>: Use it.\n\nFrom-SVN: r86792", "tree": {"sha": "2b5723a88b38ce6def64e6a6957db8e58f5e2914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b5723a88b38ce6def64e6a6957db8e58f5e2914"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef/comments", "author": null, "committer": null, "parents": [{"sha": "308cd611711b0cd8924c2a6081e7a50c75cc2d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308cd611711b0cd8924c2a6081e7a50c75cc2d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308cd611711b0cd8924c2a6081e7a50c75cc2d5a"}], "stats": {"total": 272, "additions": 143, "deletions": 129}, "files": [{"sha": "13856adf6a3047594b2a57d20d4d0ea4ffec0e67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "patch": "@@ -1,3 +1,8 @@\n+2004-08-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (expand_expr_addr_expr): New.\n+\t(expand_expr_real_1) <case ADDR_EXPR>: Use it.\n+\n 2004-08-30  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (MIPS_FP_CONDITIONS): New macro."}, {"sha": "d3c3e89799c3a215df8a1cfc784f8525ee58abd7", "filename": "gcc/expr.c", "status": "modified", "additions": 138, "deletions": 129, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6377bb9aa529896b1f8d01f5b440e4f4dbfe80ef", "patch": "@@ -6063,6 +6063,142 @@ expand_operands (tree exp0, tree exp1, rtx target, rtx *op0, rtx *op1,\n }\n \n \f\n+/* A subroutine of expand_expr.  Evaluate the address of EXP.\n+   The TARGET, TMODE and MODIFIER arguments are as for expand_expr.  */\n+\n+static rtx\n+expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n+\t\t       enum expand_modifier modifier)\n+{\n+  rtx result, subtarget;\n+  tree inner, offset;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  int volatilep, unsignedp;\n+  enum machine_mode mode1;\n+\n+  /* If we are taking the address of a constant and are at the top level,\n+     we have to use output_constant_def since we can't call force_const_mem\n+     at top level.  */\n+  /* ??? This should be considered a front-end bug.  We should not be\n+     generating ADDR_EXPR of something that isn't an LVALUE.  The only\n+     exception here is STRING_CST.  */\n+  if (TREE_CODE (exp) == CONSTRUCTOR\n+      || TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+    return XEXP (output_constant_def (exp, 0), 0);\n+\n+  /* Everything must be something allowed by is_gimple_addressable.  */\n+  switch (TREE_CODE (exp))\n+    {\n+    case INDIRECT_REF:\n+      /* This case will happen via recursion for &a->b.  */\n+      return expand_expr (TREE_OPERAND (exp, 0), target, tmode, EXPAND_NORMAL);\n+\n+    case CONST_DECL:\n+      /* Recurse and make the output_constant_def clause above handle this.  */\n+      return expand_expr_addr_expr (DECL_INITIAL (exp), target,\n+\t\t\t\t    tmode, modifier);\n+\n+    case REALPART_EXPR:\n+      /* The real part of the complex number is always first, therefore\n+\t the address is the same as the address of the parent object.  */\n+      offset = 0;\n+      bitpos = 0;\n+      inner = TREE_OPERAND (exp, 0);\n+      break;\n+\n+    case IMAGPART_EXPR:\n+      /* The imaginary part of the complex number is always second.\n+\t The expresion is therefore always offset by the size of the\n+\t scalar type.  */\n+      offset = 0;\n+      bitpos = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (exp)));\n+      inner = TREE_OPERAND (exp, 0);\n+      break;\n+\n+    default:\n+      /* If the object is a DECL, then expand it for its rtl.  Don't bypass\n+\t expand_expr, as that can have various side effects; LABEL_DECLs for\n+\t example, may not have their DECL_RTL set yet.  Assume language\n+\t specific tree nodes can be expanded in some interesting way.  */\n+      if (DECL_P (exp)\n+\t  || TREE_CODE (exp) >= LAST_AND_UNUSED_TREE_CODE)\n+\t{\n+\t  result = expand_expr (exp, target, tmode,\n+\t\t\t\tmodifier == EXPAND_INITIALIZER\n+\t\t\t\t? EXPAND_INITIALIZER : EXPAND_CONST_ADDRESS);\n+\n+\t  /* If the DECL isn't in memory, then the DECL wasn't properly\n+\t     marked TREE_ADDRESSABLE, which will be either a front-end\n+\t     or a tree optimizer bug.  */\n+\t  if (GET_CODE (result) != MEM)\n+\t    abort ();\n+\t  result = XEXP (result, 0);\n+\n+\t  /* ??? Is this needed anymore?  */\n+\t  if (!TREE_USED (exp) == 0)\n+\t    {\n+\t      assemble_external (exp);\n+\t      TREE_USED (exp) = 1;\n+\t    }\n+\n+\t  if (modifier != EXPAND_INITIALIZER\n+\t      && modifier != EXPAND_CONST_ADDRESS)\n+\t    result = force_operand (result, target);\n+\t  return result;\n+\t}\n+\n+      inner = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t\t   &mode1, &unsignedp, &volatilep);\n+      break;\n+    }\n+\n+  /* We must have made progress.  */\n+  if (inner == exp)\n+    abort ();\n+\n+  subtarget = offset || bitpos ? NULL_RTX : target;\n+  result = expand_expr_addr_expr (inner, subtarget, tmode, modifier);\n+\n+  if (tmode == VOIDmode)\n+    {\n+      tmode = GET_MODE (result);\n+      if (tmode == VOIDmode)\n+\ttmode = Pmode;\n+    }\n+\n+  if (offset)\n+    {\n+      rtx tmp;\n+\n+      if (modifier != EXPAND_NORMAL)\n+\tresult = force_operand (result, NULL);\n+      tmp = expand_expr (offset, NULL, tmode, EXPAND_NORMAL);\n+\n+      if (modifier == EXPAND_SUM)\n+\tresult = gen_rtx_PLUS (tmode, result, tmp);\n+      else\n+\t{\n+\t  subtarget = bitpos ? NULL_RTX : target;\n+\t  result = expand_simple_binop (tmode, PLUS, result, tmp, subtarget,\n+\t\t\t\t\t1, OPTAB_LIB_WIDEN);\n+\t}\n+    }\n+\n+  if (bitpos)\n+    {\n+      /* Someone beforehand should have rejected taking the address\n+\t of such an object.  */\n+      if (bitpos % BITS_PER_UNIT != 0)\n+\tabort ();\n+\n+      result = plus_constant (result, bitpos / BITS_PER_UNIT);\n+      if (modifier < EXPAND_SUM)\n+\tresult = force_operand (result, target);\n+    }\n+\n+  return result;\n+}\n+\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.\n@@ -7952,135 +8088,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return const0_rtx;\n \n     case ADDR_EXPR:\n-      if (modifier == EXPAND_STACK_PARM)\n-\ttarget = 0;\n-      /* If we are taking the address of something erroneous, just\n-\t return a zero.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n-\treturn const0_rtx;\n-      /* If we are taking the address of a constant and are at the\n-\t top level, we have to use output_constant_def since we can't\n-\t call force_const_mem at top level.  */\n-      else if (cfun == 0\n-\t       && (TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n-\t\t   || (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0)))\n-\t\t       == 'c')))\n-\top0 = XEXP (output_constant_def (TREE_OPERAND (exp, 0), 0), 0);\n-      else\n-\t{\n-\t  /* We make sure to pass const0_rtx down if we came in with\n-\t     ignore set, to avoid doing the cleanups twice for something.  */\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0),\n-\t\t\t     ignore ? const0_rtx : NULL_RTX, VOIDmode,\n-\t\t\t     (modifier == EXPAND_INITIALIZER\n-\t\t\t      ? modifier : EXPAND_CONST_ADDRESS));\n-\n-\t  /* If we are going to ignore the result, OP0 will have been set\n-\t     to const0_rtx, so just return it.  Don't get confused and\n-\t     think we are taking the address of the constant.  */\n-\t  if (ignore)\n-\t    return op0;\n-\n-\t  /* We would like the object in memory.  If it is a constant, we can\n-\t     have it be statically allocated into memory.  For a non-constant,\n-\t     we need to allocate some memory and store the value into it.  */\n-\n-\t  if (CONSTANT_P (op0))\n-\t    op0 = force_const_mem (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))),\n-\t\t\t\t   op0);\n-\t  else if (REG_P (op0) || GET_CODE (op0) == SUBREG\n-\t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == PARALLEL\n-\t\t   || GET_CODE (op0) == LO_SUM)\n-\t    {\n-\t      /* If this object is in a register, it can't be BLKmode.  */\n-\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t      rtx memloc = assign_temp (inner_type, 1, 1, 1);\n-\n-\t      if (GET_CODE (op0) == PARALLEL)\n-\t        /* Handle calls that pass values in multiple\n-\t\t   non-contiguous locations.  The Irix 6 ABI has examples\n-\t\t   of this.  */\n-\t\temit_group_store (memloc, op0, inner_type,\n-\t\t\t\t  int_size_in_bytes (inner_type));\n-\t      else\n-\t\temit_move_insn (memloc, op0);\n-\n-\t      op0 = memloc;\n-\t    }\n-\n-\t  if (!MEM_P (op0))\n-\t    abort ();\n-\n-\t  mark_temp_addr_taken (op0);\n-\t  if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n-\t    {\n-\t      op0 = XEXP (op0, 0);\n-\t      if (GET_MODE (op0) == Pmode && mode == ptr_mode)\n-\t\top0 = convert_memory_address (ptr_mode, op0);\n-\t      return op0;\n-\t    }\n-\n-\t  /* If OP0 is not aligned as least as much as the type requires, we\n-\t     need to make a temporary, copy OP0 to it, and take the address of\n-\t     the temporary.  We want to use the alignment of the type, not of\n-\t     the operand.  Note that this is incorrect for FUNCTION_TYPE, but\n-\t     the test for BLKmode means that can't happen.  The test for\n-\t     BLKmode is because we never make mis-aligned MEMs with\n-\t     non-BLKmode.\n-\n-\t     We don't need to do this at all if the machine doesn't have\n-\t     strict alignment.  */\n-\t  if (STRICT_ALIGNMENT && GET_MODE (op0) == BLKmode\n-\t      && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t  > MEM_ALIGN (op0))\n-\t      && MEM_ALIGN (op0) < BIGGEST_ALIGNMENT)\n-\t    {\n-\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t      rtx new;\n-\n-\t      if (TYPE_ALIGN_OK (inner_type))\n-\t\tabort ();\n-\n-\t      if (TREE_ADDRESSABLE (inner_type))\n-\t\t{\n-\t\t  /* We can't make a bitwise copy of this object, so fail.  */\n-\t\t  error (\"cannot take the address of an unaligned member\");\n-\t\t  return const0_rtx;\n-\t\t}\n-\n-\t      new = assign_stack_temp_for_type\n-\t\t(TYPE_MODE (inner_type),\n-\t\t MEM_SIZE (op0) ? INTVAL (MEM_SIZE (op0))\n-\t\t : int_size_in_bytes (inner_type),\n-\t\t 1, build_qualified_type (inner_type,\n-\t\t\t\t\t  (TYPE_QUALS (inner_type)\n-\t\t\t\t\t   | TYPE_QUAL_CONST)));\n-\n-\t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)),\n-\t\t\t       (modifier == EXPAND_STACK_PARM\n-\t\t\t\t? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n-\n-\t      op0 = new;\n-\t    }\n-\n-\t  op0 = force_operand (XEXP (op0, 0), target);\n-\t}\n-\n-      if (flag_force_addr\n-\t  && !REG_P (op0)\n-\t  && modifier != EXPAND_CONST_ADDRESS\n-\t  && modifier != EXPAND_INITIALIZER\n-\t  && modifier != EXPAND_SUM)\n-\top0 = force_reg (Pmode, op0);\n-\n-      if (REG_P (op0)\n-\t  && ! REG_USERVAR_P (op0))\n-\tmark_reg_pointer (op0, TYPE_ALIGN (TREE_TYPE (type)));\n-\n-      if (GET_MODE (op0) == Pmode && mode == ptr_mode)\n-\top0 = convert_memory_address (ptr_mode, op0);\n-\n-      return op0;\n+      return expand_expr_addr_expr (TREE_OPERAND (exp, 0), target,\n+\t\t\t\t    tmode, modifier);\n \n     /* COMPLEX type for Extended Pascal & Fortran  */\n     case COMPLEX_EXPR:"}]}