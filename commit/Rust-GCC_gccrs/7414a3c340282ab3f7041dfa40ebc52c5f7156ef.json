{"sha": "7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQxNGEzYzM0MDI4MmFiM2Y3MDQxZGZhNDBlYmM1MmM1ZjcxNTZlZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-06-06T09:08:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-06-06T09:08:56Z"}, "message": "gigi.h (finish_subprog_decl): Add ASM_NAME parameter.\n\n\t* gcc-interface/gigi.h (finish_subprog_decl): Add ASM_NAME parameter.\n\t* gcc-interface/decl.c (gnu_ext_name_for_subprog): New function.\n\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Do not check compatibility\n\tof profiles for builtins here...  Call gnu_ext_name_for_subprog.\n\tAlso update profiles if pointers to limited_with'ed types are\n\tupdated.\n\t(gnat_to_gnu_param): Restore the correct source location information\n\tfor vector ABI warnings.\n\t(associate_subprog_with_dummy_type): Add comment about AI05-019.\n\tSet TYPE_DUMMY_IN_PROFILE_P flag unconditionally.\n\t(update_profile): Deal with builtin declarations.\n\tCall gnu_ext_name_for_subprog.  Adjust call to finish_subprog_decl.\n\t(update_profiles_with): Add comment.\n\t(gnat_to_gnu_subprog_type): Reuse the return type if it is complete.\n\tLikewise for parameter declarations in most cases.  Do not change\n\tthe return type for the CICO mechanism if the profile is incomplete.\n\t...but here instead.  Always reset the slot for the parameters.\n\t* gcc-interface/utils.c (create_subprog_decl): Call\n\tgnu_ext_name_for_subprog.  Do not set the assembler name here but...\n\t(finish_subprog_decl): ...but here instead.  Add ASM_NAME parameter.\n\nFrom-SVN: r237119", "tree": {"sha": "18ed91aff77182fe03021fe69c55a9301f21761d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18ed91aff77182fe03021fe69c55a9301f21761d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/comments", "author": null, "committer": null, "parents": [{"sha": "128a98eacef4f47310de212932389f740acfa881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128a98eacef4f47310de212932389f740acfa881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/128a98eacef4f47310de212932389f740acfa881"}], "stats": {"total": 430, "additions": 279, "deletions": 151}, "files": [{"sha": "19078b9982c7feeb4f969d5fef1e01bbcef8291f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "patch": "@@ -1,3 +1,26 @@\n+2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (finish_subprog_decl): Add ASM_NAME parameter.\n+\t* gcc-interface/decl.c (gnu_ext_name_for_subprog): New function.\n+\t(gnat_to_gnu_entity) <E_Subprogram_Type>: Do not check compatibility\n+\tof profiles for builtins here...  Call gnu_ext_name_for_subprog.\n+\tAlso update profiles if pointers to limited_with'ed types are\n+\tupdated.\n+\t(gnat_to_gnu_param): Restore the correct source location information\n+\tfor vector ABI warnings.\n+\t(associate_subprog_with_dummy_type): Add comment about AI05-019.\n+\tSet TYPE_DUMMY_IN_PROFILE_P flag unconditionally.\n+\t(update_profile): Deal with builtin declarations.\n+\tCall gnu_ext_name_for_subprog.  Adjust call to finish_subprog_decl.\n+\t(update_profiles_with): Add comment.\n+\t(gnat_to_gnu_subprog_type): Reuse the return type if it is complete.\n+\tLikewise for parameter declarations in most cases.  Do not change\n+\tthe return type for the CICO mechanism if the profile is incomplete.\n+\t...but here instead.  Always reset the slot for the parameters.\n+\t* gcc-interface/utils.c (create_subprog_decl): Call\n+\tgnu_ext_name_for_subprog.  Do not set the assembler name here but...\n+\t(finish_subprog_decl): ...but here instead.  Add ASM_NAME parameter.\n+\n 2016-06-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): Insert the"}, {"sha": "c0100addd26fde89d79dfb22dc12300a69da861a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 229, "deletions": 126, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "patch": "@@ -204,6 +204,7 @@ static tree elaborate_reference (tree, Entity_Id, bool, tree *);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n+static tree gnu_ext_name_for_subprog (Entity_Id, tree);\n static tree change_qualified_type (tree, int);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n@@ -4109,7 +4110,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Function:\n     case E_Procedure:\n       {\n-\ttree gnu_ext_name = create_concat_name (gnat_entity, NULL);\n+\ttree gnu_ext_name\n+\t  = gnu_ext_name_for_subprog (gnat_entity, gnu_entity_name);\n \tenum inline_status_t inline_status\n \t  = Has_Pragma_No_Inline (gnat_entity)\n \t    ? is_suppressed\n@@ -4191,49 +4193,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tgnu_type\n \t  = gnat_to_gnu_subprog_type (gnat_entity, definition, debug_info_p,\n \t\t\t\t      &gnu_param_list);\n-\n-\t/* If this subprogram is expectedly bound to a GCC builtin, fetch the\n-\t   corresponding DECL node and check the parameter association.  */\n-\tif (Convention (gnat_entity) == Convention_Intrinsic\n-\t    && Present (Interface_Name (gnat_entity)))\n+\tif (DECL_P (gnu_type))\n \t  {\n-\t    tree gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n-\n-\t    /* If we have a builtin DECL for that function, use it.  Check if\n-\t       the profiles are compatible and warn if they are not.  Note that\n-\t       the checker is expected to post diagnostics in this case.  */\n-\t    if (gnu_builtin_decl)\n-\t      {\n-\t\tintrin_binding_t inb\n-\t\t  = { gnat_entity, gnu_type, TREE_TYPE (gnu_builtin_decl) };\n-\n-\t\tif (!intrin_profiles_compatible_p (&inb))\n-\t\t  post_error\n-\t\t    (\"?profile of& doesn''t match the builtin it binds!\",\n-\t\t     gnat_entity);\n-\n-\t\tgnu_decl = gnu_builtin_decl;\n-\t\tgnu_type = TREE_TYPE (gnu_builtin_decl);\n-\t\tbreak;\n-\t      }\n-\n-\t    /* Inability to find the builtin DECL most often indicates a\n-\t       genuine mistake, but imports of unregistered intrinsics are\n-\t       sometimes issued on purpose to allow hooking in alternate\n-\t       bodies.  We post a warning conditioned on Wshadow in this case,\n-\t       to let developers be notified on demand without risking false\n-\t       positives with common default sets of options.  */\n-\t    else if (warn_shadow)\n-\t      post_error (\"?gcc intrinsic not found for&!\", gnat_entity);\n+\t    gnu_decl = gnu_type;\n+\t    gnu_type = TREE_TYPE (gnu_decl);\n+\t    break;\n \t  }\n \n-\t/* If there was no specified Interface_Name and the external and\n-\t   internal names of the subprogram are the same, only use the\n-\t   internal name to allow disambiguation of nested subprograms.  */\n-\tif (No (Interface_Name (gnat_entity))\n-\t    && gnu_ext_name == gnu_entity_name)\n-\t  gnu_ext_name = NULL_TREE;\n-\n \t/* Deal with platform-specific calling conventions.  */\n \tif (Has_Stdcall_Convention (gnat_entity))\n \t  prepend_one_attribute\n@@ -5008,6 +4974,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    update_pointer_to (TYPE_MAIN_VARIANT (p->old_type),\n \t\t\t       TREE_TYPE (gnu_decl));\n+\t    if (TYPE_DUMMY_IN_PROFILE_P (p->old_type))\n+\t      update_profiles_with (p->old_type);\n \t    p->old_type = NULL_TREE;\n \t  }\n     }\n@@ -5321,8 +5289,13 @@ gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n   bool by_return = false, by_component_ptr = false;\n   bool by_ref = false;\n   bool restricted_aliasing_p = false;\n+  location_t saved_location = input_location;\n   tree gnu_param;\n \n+  /* Make sure to use the proper SLOC for vector ABI warnings.  */\n+  if (VECTOR_TYPE_P (gnu_param_type))\n+    Sloc_to_locus (Sloc (gnat_subprog), &input_location);\n+\n   /* Builtins are expanded inline and there is no real call sequence involved.\n      So the type expected by the underlying expander is always the type of the\n      argument \"as is\".  */\n@@ -5454,6 +5427,8 @@ gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n   else if (!in_param)\n     *cico = true;\n \n+  input_location = saved_location;\n+\n   if (mech == By_Copy && (by_ref || by_component_ptr))\n     post_error (\"?cannot pass & by copy\", gnat_param);\n \n@@ -5507,7 +5482,14 @@ gnat_to_gnu_param (Entity_Id gnat_param, bool first, Entity_Id gnat_subprog,\n }\n \n /* Associate GNAT_SUBPROG with GNU_TYPE, which must be a dummy type, so that\n-   GNAT_SUBPROG is updated when TYPE is completed.  */\n+   GNAT_SUBPROG is updated when TYPE is completed.\n+\n+   Ada 2012 (AI05-019) says that freezing a subprogram does not always freeze\n+   the corresponding profile, which means that, by the time the freeze node\n+   of the subprogram is encountered, types involved in its profile may still\n+   be not frozen yet.  That's why we do not update GNAT_SUBPROG when we see\n+   its freeze node but only when we see the freeze node of types involved in\n+   its profile, either types of formal parameters or the return type.  */\n \n static void\n associate_subprog_with_dummy_type (Entity_Id gnat_subprog, tree gnu_type)\n@@ -5524,8 +5506,15 @@ associate_subprog_with_dummy_type (Entity_Id gnat_subprog, tree gnu_type)\n       e->base.from = gnu_type;\n       e->to = NULL;\n       *slot = e;\n-      TYPE_DUMMY_IN_PROFILE_P (gnu_type) = 1;\n     }\n+\n+  /* Even if there is already a slot for GNU_TYPE, we need to set the flag\n+     because the vector might have been just emptied by update_profiles_with.\n+     This can happen when there are 2 freeze nodes associated with different\n+     views of the same type; the type will be really complete only after the\n+     second freeze node is encountered.  */\n+  TYPE_DUMMY_IN_PROFILE_P (gnu_type) = 1;\n+\n   vec<Entity_Id, va_gc_atomic> *v = (*slot)->to;\n \n   /* Make sure GNAT_SUBPROG is not associated twice with the same dummy type,\n@@ -5567,6 +5556,15 @@ update_profile (Entity_Id gnat_subprog)\n   tree gnu_type = gnat_to_gnu_subprog_type (gnat_subprog, true,\n \t\t\t\t\t    Needs_Debug_Info (gnat_subprog),\n \t\t\t\t\t    &gnu_param_list);\n+  if (DECL_P (gnu_type))\n+    {\n+      /* Builtins cannot have their address taken so we can reset them.  */\n+      gcc_assert (DECL_BUILT_IN (gnu_type));\n+      save_gnu_tree (gnat_subprog, NULL_TREE, false);\n+      save_gnu_tree (gnat_subprog, gnu_type, false);\n+      return;\n+    }\n+\n   tree gnu_subprog = get_gnu_tree (gnat_subprog);\n \n   TREE_TYPE (gnu_subprog) = gnu_type;\n@@ -5575,8 +5573,12 @@ update_profile (Entity_Id gnat_subprog)\n      and needs to be adjusted too.  */\n   if (Ekind (gnat_subprog) != E_Subprogram_Type)\n     {\n+      tree gnu_entity_name = get_entity_name (gnat_subprog);\n+      tree gnu_ext_name\n+\t= gnu_ext_name_for_subprog (gnat_subprog, gnu_entity_name);\n+\n       DECL_ARGUMENTS (gnu_subprog) = gnu_param_list;\n-      finish_subprog_decl (gnu_subprog, gnu_type);\n+      finish_subprog_decl (gnu_subprog, gnu_ext_name, gnu_type);\n     }\n }\n \n@@ -5592,6 +5594,9 @@ update_profiles_with (tree gnu_type)\n   gcc_assert (e);\n   vec<Entity_Id, va_gc_atomic> *v = e->to;\n   e->to = NULL;\n+\n+  /* The flag needs to be reset before calling update_profile, in case\n+     associate_subprog_with_dummy_type is again invoked on GNU_TYPE.  */\n   TYPE_DUMMY_IN_PROFILE_P (gnu_type) = 0;\n \n   unsigned int i;\n@@ -5678,7 +5683,9 @@ gnat_to_gnu_profile_type (Entity_Id gnat_type)\n /* Return a GCC tree for a subprogram type corresponding to GNAT_SUBPROG.\n    DEFINITION is true if this is for a subprogram being defined.  DEBUG_INFO_P\n    is true if we need to write debug information for other types that we may\n-   create in the process.  Also set PARAM_LIST to the list of parameters.  */\n+   create in the process.  Also set PARAM_LIST to the list of parameters.\n+   If GNAT_SUBPROG is bound to a GCC builtin, return the DECL for the builtin\n+   directly instead of its type.  */\n \n static tree\n gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n@@ -5687,6 +5694,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   const Entity_Kind kind = Ekind (gnat_subprog);\n   Entity_Id gnat_return_type = Etype (gnat_subprog);\n   Entity_Id gnat_param;\n+  tree gnu_type = present_gnu_tree (gnat_subprog)\n+\t\t  ? TREE_TYPE (get_gnu_tree (gnat_subprog)) : NULL_TREE;\n   tree gnu_return_type;\n   tree gnu_param_type_list = NULL_TREE;\n   tree gnu_param_list = NULL_TREE;\n@@ -5698,6 +5707,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n      is the PARM_DECL corresponding to that field.  This list will be saved in\n      the TYPE_CI_CO_LIST field of the FUNCTION_TYPE node we create.  */\n   tree gnu_cico_list = NULL_TREE;\n+  tree gnu_cico_return_type = NULL_TREE;\n   /* Fields in return type of procedure with copy-in copy-out parameters.  */\n   tree gnu_field_list = NULL_TREE;\n   /* The semantics of \"pure\" in Ada essentially matches that of \"const\"\n@@ -5715,10 +5725,22 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   bool incomplete_profile_p = false;\n   unsigned int num;\n \n-  /* Look into the return type and get its associated GCC tree.  If it is not\n-     void, compute various flags for the subprogram type.  */\n+  /* Look into the return type and get its associated GCC tree if it is not\n+     void, and then compute various flags for the subprogram type.  But make\n+     sure not to do this processing multiple times.  */\n   if (Ekind (gnat_return_type) == E_Void)\n     gnu_return_type = void_type_node;\n+\n+  else if (gnu_type\n+\t   && TREE_CODE (gnu_type) == FUNCTION_TYPE\n+\t   && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_type)))\n+    {\n+      gnu_return_type = TREE_TYPE (gnu_type);\n+      return_unconstrained_p = TYPE_RETURN_UNCONSTRAINED_P (gnu_type);\n+      return_by_direct_ref_p = TYPE_RETURN_BY_DIRECT_REF_P (gnu_type);\n+      return_by_invisi_ref_p = TREE_ADDRESSABLE (gnu_type);\n+    }\n+\n   else\n     {\n       gnu_return_type = gnat_to_gnu_profile_type (gnat_return_type);\n@@ -5828,7 +5850,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t returns by reference, then the return type is only linked indirectly\n \t in the profile, so the profile can be seen as complete since it need\n \t not be further modified, only the reference types need be adjusted;\n-\t otherwise the profile itself is incomplete and need be adjusted.  */\n+\t otherwise the profile is incomplete and need be adjusted too.  */\n       if (TYPE_IS_DUMMY_P (gnu_return_type))\n \t{\n \t  associate_subprog_with_dummy_type (gnat_subprog, gnu_return_type);\n@@ -5858,81 +5880,107 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n        Present (gnat_param);\n        gnat_param = Next_Formal_With_Extras (gnat_param), num++)\n     {\n-      Entity_Id gnat_param_type = Etype (gnat_param);\n+      const bool mech_is_by_ref\n+\t= Mechanism (gnat_param) == By_Reference\n+\t  && !(num == 0 && Is_Valued_Procedure (gnat_subprog));\n       tree gnu_param_name = get_entity_name (gnat_param);\n-      tree gnu_param_type = gnat_to_gnu_profile_type (gnat_param_type);\n-      tree gnu_param, gnu_field;\n+      tree gnu_param, gnu_param_type;\n       bool cico = false;\n \n-      /* If the parameter type is incomplete, there are 2 cases: if it is\n-\t passed by reference, then the type is only linked indirectly in\n-\t the profile, so the profile can be seen as complete since it need\n-\t not be further modified, only the reference types need be adjusted;\n-\t otherwise the profile itself is incomplete and need be adjusted.  */\n-      if (TYPE_IS_DUMMY_P (gnu_param_type))\n+      /* Fetch an existing parameter with complete type and reuse it.  But we\n+\t didn't save the CICO property so we can only do it for In parameters\n+\t or parameters passed by reference.  */\n+      if ((Ekind (gnat_param) == E_In_Parameter || mech_is_by_ref)\n+\t  && present_gnu_tree (gnat_param)\n+\t  && (gnu_param = get_gnu_tree (gnat_param))\n+\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_param)))\n \t{\n-\t  Node_Id gnat_decl;\n+\t  DECL_CHAIN (gnu_param) = NULL_TREE;\n+\t  gnu_param_type = TREE_TYPE (gnu_param);\n+\t}\n \n-\t  if (Mechanism (gnat_param) == By_Reference\n-\t      || (TYPE_REFERENCE_TO (gnu_param_type)\n-\t\t  && TYPE_IS_FAT_POINTER_P (TYPE_REFERENCE_TO (gnu_param_type)))\n-\t      || TYPE_IS_BY_REFERENCE_P (gnu_param_type))\n+      /* Otherwise translate the parameter type and act accordingly.  */\n+      else\n+\t{\n+\t  Entity_Id gnat_param_type = Etype (gnat_param);\n+\t  gnu_param_type = gnat_to_gnu_profile_type (gnat_param_type);\n+\n+\t  /* If the parameter type is incomplete, there are 2 cases: if it is\n+\t     passed by reference, then the type is only linked indirectly in\n+\t     the profile, so the profile can be seen as complete since it need\n+\t     not be further modified, only the reference type need be adjusted;\n+\t     otherwise the profile is incomplete and need be adjusted too.  */\n+\t  if (TYPE_IS_DUMMY_P (gnu_param_type))\n \t    {\n-\t      gnu_param_type = build_reference_type (gnu_param_type);\n-\t      gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n-\t      TREE_READONLY (gnu_param) = 1;\n-\t      DECL_BY_REF_P (gnu_param) = 1;\n-\t      DECL_POINTS_TO_READONLY_P (gnu_param)\n-\t\t= (Ekind (gnat_param) == E_In_Parameter\n-\t\t   && !Address_Taken (gnat_param));\n-\t      Set_Mechanism (gnat_param, By_Reference);\n-\t      Sloc_to_locus (Sloc (gnat_param),\n-\t\t\t     &DECL_SOURCE_LOCATION (gnu_param));\n-\t    }\n+\t      Node_Id gnat_decl;\n+\n+\t      if (mech_is_by_ref\n+\t\t  || (TYPE_REFERENCE_TO (gnu_param_type)\n+\t\t      && TYPE_IS_FAT_POINTER_P\n+\t\t\t (TYPE_REFERENCE_TO (gnu_param_type)))\n+\t\t  || TYPE_IS_BY_REFERENCE_P (gnu_param_type))\n+\t\t{\n+\t\t  gnu_param_type = build_reference_type (gnu_param_type);\n+\t\t  gnu_param\n+\t\t    = create_param_decl (gnu_param_name, gnu_param_type);\n+\t\t  TREE_READONLY (gnu_param) = 1;\n+\t\t  DECL_BY_REF_P (gnu_param) = 1;\n+\t\t  DECL_POINTS_TO_READONLY_P (gnu_param)\n+\t\t    = (Ekind (gnat_param) == E_In_Parameter\n+\t\t       && !Address_Taken (gnat_param));\n+\t\t  Set_Mechanism (gnat_param, By_Reference);\n+\t\t  Sloc_to_locus (Sloc (gnat_param),\n+\t\t\t\t &DECL_SOURCE_LOCATION (gnu_param));\n+\t\t}\n \n-\t  /* ??? This is a kludge to support null procedures in spec taking a\n-\t     parameter with an untagged incomplete type coming from a limited\n-\t     context.  The front-end creates a body without knowing anything\n-\t     about the non-limited view, which is illegal Ada and cannot be\n-\t     reasonably supported.  Create a parameter with a fake type.  */\n-\t  else if (kind == E_Procedure\n-\t\t   && (gnat_decl = Parent (gnat_subprog))\n-\t\t   && Nkind (gnat_decl) == N_Procedure_Specification\n-\t\t   && Null_Present (gnat_decl)\n-\t\t   && IN (Ekind (gnat_param_type), Incomplete_Kind))\n-\t    gnu_param = create_param_decl (gnu_param_name, ptr_type_node);\n+\t      /* ??? This is a kludge to support null procedures in spec taking\n+\t\t a parameter with an untagged incomplete type coming from a\n+\t\t limited context.  The front-end creates a body without knowing\n+\t\t anything about the non-limited view, which is illegal Ada and\n+\t\t cannot be supported.  Create a parameter with a fake type.  */\n+\t      else if (kind == E_Procedure\n+\t\t       && (gnat_decl = Parent (gnat_subprog))\n+\t\t       && Nkind (gnat_decl) == N_Procedure_Specification\n+\t\t       && Null_Present (gnat_decl)\n+\t\t       && IN (Ekind (gnat_param_type), Incomplete_Kind))\n+\t\tgnu_param = create_param_decl (gnu_param_name, ptr_type_node);\n \n-\t  else\n-\t    {\n-\t      gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n-\t      associate_subprog_with_dummy_type (gnat_subprog, gnu_param_type);\n-\t      incomplete_profile_p = true;\n+\t      else\n+\t\t{\n+\t\t  gnu_param\n+\t\t    = create_param_decl (gnu_param_name, gnu_param_type);\n+\t\t  associate_subprog_with_dummy_type (gnat_subprog,\n+\t\t\t\t\t\t     gnu_param_type);\n+\t\t  incomplete_profile_p = true;\n+\t\t}\n \t    }\n-\t}\n-\n-      else\n-\t{\n-\t  gnu_param\n-\t    = gnat_to_gnu_param (gnat_param, num == 0, gnat_subprog, &cico);\n \n-\t  /* We are returned either a PARM_DECL or a type if no parameter\n-\t     needs to be passed; in either case, adjust the type.  */\n-\t  if (DECL_P (gnu_param))\n-\t    gnu_param_type = TREE_TYPE (gnu_param);\n+\t  /* Otherwise build the parameter declaration normally.  */\n \t  else\n \t    {\n-\t      gnu_param_type = gnu_param;\n-\t      gnu_param = NULL_TREE;\n+\t      gnu_param\n+\t\t= gnat_to_gnu_param (gnat_param, num == 0, gnat_subprog,\n+\t\t\t\t     &cico);\n+\n+\t      /* We are returned either a PARM_DECL or a type if no parameter\n+\t\t needs to be passed; in either case, adjust the type.  */\n+\t      if (DECL_P (gnu_param))\n+\t\tgnu_param_type = TREE_TYPE (gnu_param);\n+\t      else\n+\t\t{\n+\t\t  gnu_param_type = gnu_param;\n+\t\t  gnu_param = NULL_TREE;\n+\t\t}\n \t    }\n \t}\n \n-      /* If we built a GCC tree for the parameter, register it.  */\n+      /* If we have a GCC tree for the parameter, register it.  */\n+      save_gnu_tree (gnat_param, NULL_TREE, false);\n       if (gnu_param)\n \t{\n \t  gnu_param_type_list\n \t    = tree_cons (NULL_TREE, gnu_param_type, gnu_param_type_list);\n \t  gnu_param_list = chainon (gnu_param, gnu_param_list);\n-\t  save_gnu_tree (gnat_param, NULL_TREE, false);\n \t  save_gnu_tree (gnat_param, gnu_param, false);\n \n \t  /* If a parameter is a pointer, a function may modify memory through\n@@ -5950,16 +5998,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t{\n \t  if (!gnu_cico_list)\n \t    {\n-\t      tree gnu_new_ret_type = make_node (RECORD_TYPE);\n+\t      gnu_cico_return_type = make_node (RECORD_TYPE);\n \n \t      /* If this is a function, we also need a field for the\n \t\t return value to be placed.  */\n-\t      if (TREE_CODE (gnu_return_type) != VOID_TYPE)\n+\t      if (!VOID_TYPE_P (gnu_return_type))\n \t\t{\n-\t\t  gnu_field\n+\t\t  tree gnu_field\n \t\t    = create_field_decl (get_identifier (\"RETVAL\"),\n \t\t\t\t         gnu_return_type,\n-\t\t\t\t         gnu_new_ret_type, NULL_TREE,\n+\t\t\t\t         gnu_cico_return_type, NULL_TREE,\n \t\t\t\t         NULL_TREE, 0, 0);\n \t\t  Sloc_to_locus (Sloc (gnat_subprog),\n \t\t\t         &DECL_SOURCE_LOCATION (gnu_field));\n@@ -5968,17 +6016,18 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t    = tree_cons (gnu_field, void_type_node, NULL_TREE);\n \t\t}\n \n-\t      gnu_return_type = gnu_new_ret_type;\n-\t      TYPE_NAME (gnu_return_type) = get_identifier (\"RETURN\");\n+\t      TYPE_NAME (gnu_cico_return_type) = get_identifier (\"RETURN\");\n \t      /* Set a default alignment to speed up accesses.  But we should\n \t\t not increase the size of the structure too much, lest it does\n \t\t not fit in return registers anymore.  */\n-\t      SET_TYPE_ALIGN (gnu_return_type, get_mode_alignment (ptr_mode));\n+\t      SET_TYPE_ALIGN (gnu_cico_return_type,\n+\t\t\t      get_mode_alignment (ptr_mode));\n \t    }\n \n-\t  gnu_field\n+\t  tree gnu_field\n \t    = create_field_decl (gnu_param_name, gnu_param_type,\n-\t\t\t\t gnu_return_type, NULL_TREE, NULL_TREE, 0, 0);\n+\t\t\t\t gnu_cico_return_type, NULL_TREE, NULL_TREE,\n+\t\t\t\t 0, 0);\n \t  Sloc_to_locus (Sloc (gnat_param),\n \t\t\t &DECL_SOURCE_LOCATION (gnu_field));\n \t  DECL_CHAIN (gnu_field) = gnu_field_list;\n@@ -5994,22 +6043,23 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n       /* If we have a CICO list but it has only one entry, we convert\n \t this function into a function that returns this object.  */\n       if (list_length (gnu_cico_list) == 1)\n-\tgnu_return_type = TREE_TYPE (TREE_PURPOSE (gnu_cico_list));\n+\tgnu_cico_return_type = TREE_TYPE (TREE_PURPOSE (gnu_cico_list));\n \n       /* Do not finalize the return type if the subprogram is stubbed\n \t since structures are incomplete for the back-end.  */\n       else if (Convention (gnat_subprog) != Convention_Stubbed)\n \t{\n-\t  finish_record_type (gnu_return_type, nreverse (gnu_field_list), 0,\n-\t\t\t      false);\n+\t  finish_record_type (gnu_cico_return_type, nreverse (gnu_field_list),\n+\t\t\t      0, false);\n \n \t  /* Try to promote the mode of the return type if it is passed\n \t     in registers, again to speed up accesses.  */\n-\t  if (TYPE_MODE (gnu_return_type) == BLKmode\n-\t      && !targetm.calls.return_in_memory (gnu_return_type, NULL_TREE))\n+\t  if (TYPE_MODE (gnu_cico_return_type) == BLKmode\n+\t      && !targetm.calls.return_in_memory (gnu_cico_return_type,\n+\t\t\t\t\t\t  NULL_TREE))\n \t    {\n \t      unsigned int size\n-\t\t= TREE_INT_CST_LOW (TYPE_SIZE (gnu_return_type));\n+\t\t= TREE_INT_CST_LOW (TYPE_SIZE (gnu_cico_return_type));\n \t      unsigned int i = BITS_PER_UNIT;\n \t      machine_mode mode;\n \n@@ -6018,18 +6068,21 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t      mode = mode_for_size (i, MODE_INT, 0);\n \t      if (mode != BLKmode)\n \t\t{\n-\t\t  SET_TYPE_MODE (gnu_return_type, mode);\n-\t\t  SET_TYPE_ALIGN (gnu_return_type, GET_MODE_ALIGNMENT (mode));\n-\t\t  TYPE_SIZE (gnu_return_type)\n+\t\t  SET_TYPE_MODE (gnu_cico_return_type, mode);\n+\t\t  SET_TYPE_ALIGN (gnu_cico_return_type,\n+\t\t\t\t  GET_MODE_ALIGNMENT (mode));\n+\t\t  TYPE_SIZE (gnu_cico_return_type)\n \t\t    = bitsize_int (GET_MODE_BITSIZE (mode));\n-\t\t  TYPE_SIZE_UNIT (gnu_return_type)\n+\t\t  TYPE_SIZE_UNIT (gnu_cico_return_type)\n \t\t    = size_int (GET_MODE_SIZE (mode));\n \t\t}\n \t    }\n \n \t  if (debug_info_p)\n-\t    rest_of_record_type_compilation (gnu_return_type);\n+\t    rest_of_record_type_compilation (gnu_cico_return_type);\n \t}\n+\n+      gnu_return_type = gnu_cico_return_type;\n     }\n \n   /* The lists have been built in reverse.  */\n@@ -6041,9 +6094,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   /* If the profile is incomplete, we only set the (temporary) return and\n      parameter types; otherwise, we build the full type.  In either case,\n      we reuse an already existing GCC tree that we built previously here.  */\n-  tree gnu_type = present_gnu_tree (gnat_subprog)\n-\t\t  ? TREE_TYPE (get_gnu_tree (gnat_subprog)) : NULL_TREE;\n-\n   if (incomplete_profile_p)\n     {\n       if (gnu_type && TREE_CODE (gnu_type) == FUNCTION_TYPE)\n@@ -6052,6 +6102,9 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \tgnu_type = make_node (FUNCTION_TYPE);\n       TREE_TYPE (gnu_type) = gnu_return_type;\n       TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n+      TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n+      TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n+      TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n     }\n   else\n     {\n@@ -6091,11 +6144,61 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \n       if (No_Return (gnat_subprog))\n \tgnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+\n+      /* If this subprogram is expectedly bound to a GCC builtin, fetch the\n+\t corresponding DECL node and check the parameter association.  */\n+      if (Convention (gnat_subprog) == Convention_Intrinsic\n+\t  && Present (Interface_Name (gnat_subprog)))\n+\t{\n+\t  tree gnu_ext_name = create_concat_name (gnat_subprog, NULL);\n+\t  tree gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n+\n+\t  /* If we have a builtin DECL for that function, use it.  Check if\n+\t     the profiles are compatible and warn if they are not.  Note that\n+\t     the checker is expected to post diagnostics in this case.  */\n+\t  if (gnu_builtin_decl)\n+\t    {\n+\t      intrin_binding_t inb\n+\t\t= { gnat_subprog, gnu_type, TREE_TYPE (gnu_builtin_decl) };\n+\n+\t      if (!intrin_profiles_compatible_p (&inb))\n+\t\tpost_error\n+\t\t  (\"?profile of& doesn''t match the builtin it binds!\",\n+\t\t   gnat_subprog);\n+\n+\t      return gnu_builtin_decl;\n+\t    }\n+\n+\t  /* Inability to find the builtin DECL most often indicates a genuine\n+\t     mistake, but imports of unregistered intrinsics are sometimes used\n+\t     on purpose to allow hooking in alternate bodies; we post a warning\n+\t     conditioned on Wshadow in this case, to let developers be notified\n+\t     on demand without risking false positives with common default sets\n+\t     of options.  */\n+\t  if (warn_shadow)\n+\t    post_error (\"?gcc intrinsic not found for&!\", gnat_subprog);\n+\t}\n     }\n \n   return gnu_type;\n }\n \n+/* Return the external name for GNAT_SUBPROG given its entity name.  */\n+\n+static tree\n+gnu_ext_name_for_subprog (Entity_Id gnat_subprog, tree gnu_entity_name)\n+{\n+  tree gnu_ext_name = create_concat_name (gnat_subprog, NULL);\n+\n+  /* If there was no specified Interface_Name and the external and\n+     internal names of the subprogram are the same, only use the\n+     internal name to allow disambiguation of nested subprograms.  */\n+  if (No (Interface_Name (gnat_subprog)) && gnu_ext_name == gnu_entity_name)\n+    gnu_ext_name = NULL_TREE;\n+\n+  return gnu_ext_name;\n+}\n+\n /* Like build_qualified_type, but TYPE_QUALS is added to the existing\n    qualifiers on TYPE.  */\n "}, {"sha": "fcd866c37cca5d21dd49a72e814086388d15e414", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "patch": "@@ -737,9 +737,9 @@ extern tree create_subprog_decl (tree name, tree asm_name, tree type,\n \t\t\t\t bool artificial_p, bool debug_info_p,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n-/* Given a subprogram declaration DECL and its TYPE, finish constructing the\n-   subprogram declaration from TYPE.  */\n-extern void finish_subprog_decl (tree decl, tree type);\n+/* Given a subprogram declaration DECL, its assembler name and its type,\n+   finish constructing the subprogram declaration from ASM_NAME and TYPE.  */\n+extern void finish_subprog_decl (tree decl, tree asm_name, tree type);\n \n /* Process the attributes in ATTR_LIST for NODE, which is either a DECL or\n    a TYPE.  If IN_PLACE is true, the tree pointed to by NODE should not be"}, {"sha": "6a55796a442487afbcdc32f71dd0c03cea0f05e3", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7414a3c340282ab3f7041dfa40ebc52c5f7156ef/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7414a3c340282ab3f7041dfa40ebc52c5f7156ef", "patch": "@@ -3137,7 +3137,6 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n {\n   tree subprog_decl = build_decl (input_location, FUNCTION_DECL, name, type);\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n-  finish_subprog_decl (subprog_decl, type);\n \n   DECL_ARTIFICIAL (subprog_decl) = artificial_p;\n   DECL_EXTERNAL (subprog_decl) = extern_flag;\n@@ -3175,38 +3174,23 @@ create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n \n   process_attributes (&subprog_decl, &attr_list, true, gnat_node);\n \n+  /* Once everything is processed, finish the subprogram declaration.  */\n+  finish_subprog_decl (subprog_decl, asm_name, type);\n+\n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (subprog_decl, gnat_node);\n \n-  if (asm_name)\n-    {\n-      /* Let the target mangle the name if this isn't a verbatim asm.  */\n-      if (*IDENTIFIER_POINTER (asm_name) != '*')\n-\tasm_name = targetm.mangle_decl_assembler_name (subprog_decl, asm_name);\n-\n-      SET_DECL_ASSEMBLER_NAME (subprog_decl, asm_name);\n-\n-      /* The expand_main_function circuitry expects \"main_identifier_node\" to\n-\t designate the DECL_NAME of the 'main' entry point, in turn expected\n-\t to be declared as the \"main\" function literally by default.  Ada\n-\t program entry points are typically declared with a different name\n-\t within the binder generated file, exported as 'main' to satisfy the\n-\t system expectations.  Force main_identifier_node in this case.  */\n-      if (asm_name == main_identifier_node)\n-\tDECL_NAME (subprog_decl) = main_identifier_node;\n-    }\n-\n   /* Output the assembler code and/or RTL for the declaration.  */\n   rest_of_decl_compilation (subprog_decl, global_bindings_p (), 0);\n \n   return subprog_decl;\n }\n \n-/* Given a subprogram declaration DECL and its TYPE, finish constructing the\n-   subprogram declaration from TYPE.  */\n+/* Given a subprogram declaration DECL, its assembler name and its type,\n+   finish constructing the subprogram declaration from ASM_NAME and TYPE.  */\n \n void\n-finish_subprog_decl (tree decl, tree type)\n+finish_subprog_decl (tree decl, tree asm_name, tree type)\n {\n   tree result_decl\n     = build_decl (DECL_SOURCE_LOCATION (decl), RESULT_DECL, NULL_TREE,\n@@ -3219,6 +3203,24 @@ finish_subprog_decl (tree decl, tree type)\n \n   TREE_READONLY (decl) = TYPE_READONLY (type);\n   TREE_SIDE_EFFECTS (decl) = TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);\n+\n+  if (asm_name)\n+    {\n+      /* Let the target mangle the name if this isn't a verbatim asm.  */\n+      if (*IDENTIFIER_POINTER (asm_name) != '*')\n+\tasm_name = targetm.mangle_decl_assembler_name (decl, asm_name);\n+\n+      SET_DECL_ASSEMBLER_NAME (decl, asm_name);\n+\n+      /* The expand_main_function circuitry expects \"main_identifier_node\" to\n+\t designate the DECL_NAME of the 'main' entry point, in turn expected\n+\t to be declared as the \"main\" function literally by default.  Ada\n+\t program entry points are typically declared with a different name\n+\t within the binder generated file, exported as 'main' to satisfy the\n+\t system expectations.  Force main_identifier_node in this case.  */\n+      if (asm_name == main_identifier_node)\n+\tDECL_NAME (decl) = main_identifier_node;\n+    }\n }\n \f\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram"}]}