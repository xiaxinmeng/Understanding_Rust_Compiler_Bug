{"sha": "7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjMDhhMjBlZDE1MmE1YWIyZTVkZDQ3ZDYzMGI1ODY2NWEyMzhlMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-10-20T06:52:00Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-20T06:52:00Z"}, "message": "codecvt_unicode_char.cc (test01): Adjust creation of state_type for unicode_codecvt to take into account the byte...\n\n\n2000-10-19  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* testsuite/22_locale/codecvt_unicode_char.cc (test01): Adjust\n\tcreation of state_type for unicode_codecvt to take into account\n\tthe byte order markings. Add distinct tests for UCS-2BE and UCS-2LE.\n\t* testsuite/22_locale/codecvt_unicode_wchar_t.cc (test01): Same.\n\t* include/bits/codecvt.h (__enc_traits): Add support for encodings\n\tthat need a byte order marker. Needed for correct unicode support.\n\n\t* src/locale.cc: Remove explicit qualification std::.\n\t(locale::locale(const char* __name)): Revert, as named locale\n\tsupport not finished.\n\t* src/localename.cc (locale::_Impl:: _Impl(size_t __numfacets,\n\tsize_t __refs, bool __has_name = false, string __name): Move\n\tdefault argument...\n\t* include/bits/localefwd.h: Here.\n\nFrom-SVN: r36959", "tree": {"sha": "f636463967a6165e1d3ebad73afbe65d2073ecbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f636463967a6165e1d3ebad73afbe65d2073ecbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/comments", "author": null, "committer": null, "parents": [{"sha": "c20118a81159621ad3f438d7b24146328929ccc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c20118a81159621ad3f438d7b24146328929ccc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c20118a81159621ad3f438d7b24146328929ccc7"}], "stats": {"total": 338, "additions": 240, "deletions": 98}, "files": [{"sha": "bc5b215f693647a662526376877b1db0fe7b1835", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -1,8 +1,25 @@\n+2000-10-19  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* testsuite/22_locale/codecvt_unicode_char.cc (test01): Adjust\n+\tcreation of state_type for unicode_codecvt to take into account\n+\tthe byte order markings. Add distinct tests for UCS-2BE and UCS-2LE.\n+\t* testsuite/22_locale/codecvt_unicode_wchar_t.cc (test01): Same.\n+\t* include/bits/codecvt.h (__enc_traits): Add support for encodings\n+\tthat need a byte order marker. Needed for correct unicode support.\n+\n+\t* src/locale.cc: Remove explicit qualification std::.\n+\t(locale::locale(const char* __name)): Revert, as named locale\n+\tsupport not finished.\n+\t* src/localename.cc (locale::_Impl:: _Impl(size_t __numfacets,\n+\tsize_t __refs, bool __has_name = false, string __name): Move\n+\tdefault argument...\n+\t* include/bits/localefwd.h: Here.\n+\t\n 2000-10-18  Chip Salzenberg  <chip@valinux.com>\n \n         * libio/libio.h (_IO_USER_LOCK): Define.\n \n-2000-10-18   Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+2000-10-18  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n \t* libsupc++/Makefile.am (exception): Change exception.cc to\n \texception_support.cc."}, {"sha": "148bebc20c65a571247dab4b241c9125d974a067", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 83, "deletions": 20, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -65,33 +65,41 @@ namespace std\n     // Max size of charset encoding name\n     static const int \t_S_max_size = 32;\n     // Name of internal character set encoding.\n-    char\t       \t_M_intc_enc[_S_max_size];\n+    char\t       \t_M_int_enc[_S_max_size];\n     // Name of external character set encoding.\n-    char  \t       \t_M_extc_enc[_S_max_size];\n+    char  \t       \t_M_ext_enc[_S_max_size];\n \n     // Conversion descriptor between external encoding to internal encoding.\n     __desc_type\t\t_M_in_desc;\n     // Conversion descriptor between internal encoding to external encoding.\n     __desc_type\t\t_M_out_desc;\n \n+    // Details the byte-order marker for the external encoding, if necessary.\n+    int\t\t\t_M_ext_bom;\n+\n+    // Details the byte-order marker for the internal encoding, if necessary.\n+    int\t\t\t_M_int_bom;\n+\n   public:\n-    __enc_traits() : _M_in_desc(0), _M_out_desc(0)\n+    __enc_traits()\n+    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)\n     {\n       // __intc_end = whatever we are using internally, which is\n       // UCS4 (linux) \n       // UCS2 == UNICODE  (microsoft, java, aix, whatever...)\n       // XXX Currently don't know how to get this data from target system...\n-      strcpy(_M_intc_enc, \"UCS4\");\n+      strcpy(_M_int_enc, \"UCS4\");\n \n       // __extc_end = external codeset in current locale\n-      strcpy(_M_extc_enc, nl_langinfo(CODESET));\n+      strcpy(_M_ext_enc, nl_langinfo(CODESET));\n     }\n \n-    __enc_traits(const char* __int, const char* __ext)\n-    : _M_in_desc(0), _M_out_desc(0)\n+    __enc_traits(const char* __int, const char* __ext, int __ibom = 0, \n+\t\t int __ebom = 0)\n+    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)\n     {\n-      strncpy(_M_intc_enc, __int, _S_max_size);\n-      strncpy(_M_extc_enc, __ext, _S_max_size);\n+      strncpy(_M_int_enc, __int, _S_max_size);\n+      strncpy(_M_ext_enc, __ext, _S_max_size);\n     }\n \n     // 21.1.2 traits typedefs\n@@ -101,8 +109,10 @@ namespace std\n     // CopyConstructible types (20.1.3)\n     __enc_traits(const __enc_traits& __obj)\n     {\n-      strncpy(_M_intc_enc, __obj._M_intc_enc, _S_max_size);\n-      strncpy(_M_extc_enc, __obj._M_extc_enc, _S_max_size);\n+      strncpy(_M_int_enc, __obj._M_int_enc, _S_max_size);\n+      strncpy(_M_ext_enc, __obj._M_ext_enc, _S_max_size);\n+      _M_ext_bom = __obj._M_ext_bom;\n+      _M_int_bom = __obj._M_int_bom;\n     }\n \n     ~__enc_traits()\n@@ -115,8 +125,8 @@ namespace std\n     void\n     _M_init()\n     {\n-      _M_in_desc = iconv_open(_M_intc_enc, _M_extc_enc);\n-      _M_out_desc = iconv_open(_M_extc_enc, _M_intc_enc);\n+      _M_in_desc = iconv_open(_M_int_enc, _M_ext_enc);\n+      _M_out_desc = iconv_open(_M_ext_enc, _M_int_enc);\n       if (_M_out_desc == iconv_t(-1) || _M_in_desc == iconv_t(-1))\n \t{\n \t  // XXX Extended error checking.\n@@ -140,11 +150,19 @@ namespace std\n \n    const char* \n     _M_get_internal_enc()\n-    { return _M_intc_enc; }\n+    { return _M_int_enc; }\n \n     const char* \n     _M_get_external_enc()\n-    { return _M_extc_enc; }\n+    { return _M_ext_enc; }\n+\n+    int \n+    _M_get_external_bom()\n+    { return _M_ext_bom; }\n+\n+    int \n+    _M_get_internal_bom()\n+    { return _M_int_bom; }\n   };\n #endif //_GLIBCPP_USE_WCHAR_T\n \n@@ -372,10 +390,32 @@ namespace std\n \t  \n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n-\t  char* __cfrom = reinterpret_cast<char*>(const_cast<intern_type*>(__from));\n \t  char* __cto = reinterpret_cast<char*>(__to);\n-\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n-\t  \n+\t  char* __cfrom;\n+\t  size_t __conv;\n+\n+\t  // Some encodings need a byte order marker as the first item\n+\t  // in the byte stream, to designate endian-ness. The default\n+\t  // value for the byte order marker is NULL, so if this is\n+\t  // the case, it's not necessary and we can just go on our\n+\t  // merry way.\n+\t  int __int_bom = __state._M_get_internal_bom();\n+\t  if (__int_bom)\n+\t    {\t  \n+\t      size_t __size = __from_end - __from;\n+\t      intern_type __cfixed[__size + 1];\n+\t      __cfixed[0] = static_cast<intern_type>(__int_bom);\n+\t      char_traits<intern_type>::copy(__cfixed + 1, __from, __size);\n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t    }\n+\t  else\n+\t    {\n+\t      intern_type* __cfixed = const_cast<intern_type*>(__from);\n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t    }\n+\n \t  if (__conv != size_t(-1))\n \t    {\n \t      __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n@@ -452,9 +492,32 @@ namespace std\n \t  \n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n-\t  char* __cfrom = reinterpret_cast<char*>(const_cast<extern_type*>(__from));\n \t  char* __cto = reinterpret_cast<char*>(__to);\n-\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t  char* __cfrom;\n+\t  size_t __conv;\n+\n+\t  // Some encodings need a byte order marker as the first item\n+\t  // in the byte stream, to designate endian-ness. The default\n+\t  // value for the byte order marker is NULL, so if this is\n+\t  // the case, it's not necessary and we can just go on our\n+\t  // merry way.\n+\t  int __ext_bom = __state._M_get_external_bom();\n+\t  if (__ext_bom)\n+\t    {\t  \n+\t      size_t __size = __from_end - __from;\n+\t      extern_type __cfixed[__size + 1];\n+\t      __cfixed[0] = static_cast<extern_type>(__ext_bom);\n+\t      char_traits<extern_type>::copy(__cfixed + 1, __from, __size);\n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t    }\n+\t  else\n+\t    {\n+\t      extern_type* __cfixed = const_cast<extern_type*>(__from);\n+\t      __cfrom = reinterpret_cast<char*>(__cfixed);\n+\t      __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t    }\n+\n \t  \n \t  if (__conv != size_t(-1))\n \t    {"}, {"sha": "e57321ae2a363e0b0d93d2a22758f56c0da2984c", "filename": "libstdc++-v3/include/bits/localefwd.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -369,7 +369,8 @@ namespace std\n \n     _Impl(const _Impl&, size_t __refs);\n     _Impl(const _Impl&, const string&, category, size_t __refs);\n-    _Impl(size_t __facets, size_t __refs, bool __has_name, string __name);\n+    _Impl(size_t __facets, size_t __refs, bool __has_name, \n+\t  string __name = \"*\");\n    ~_Impl() throw();\n \n     void "}, {"sha": "4f886dcf56512d996df0bedd502d9f46ef1943ef", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -76,85 +76,85 @@ namespace std {\n #ifdef _GLIBCPP_USE_WCHAR_T\n     &std::ctype<wchar_t>::id,\n #endif\n-    &std::codecvt<char, char, mbstate_t>::id,\n+    &codecvt<char, char, mbstate_t>::id,\n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::codecvt<wchar_t, char, mbstate_t>::id,\n+    &codecvt<wchar_t, char, mbstate_t>::id,\n #endif\n     0\n   };\n \n   const locale::id* const\n   locale::_Impl::_S_id_monetary[] =\n   {\n-    &std::moneypunct<char, false>::id, \n+    &moneypunct<char, false>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::moneypunct<wchar_t, false>::id,\n+    &moneypunct<wchar_t, false>::id,\n #endif\n     &std::moneypunct<char,true >::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::moneypunct<wchar_t,true >::id,\n+    &moneypunct<wchar_t,true >::id,\n #endif\n-    &std::money_get<char>::id,        \n+    &money_get<char>::id,        \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::money_get<wchar_t>::id,\n+    &money_get<wchar_t>::id,\n #endif\n-    &std::money_put<char>::id,        \n+    &money_put<char>::id,        \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::money_put<wchar_t>::id,\n+    &money_put<wchar_t>::id,\n #endif\n     0\n   };\n \n   const locale::id* const\n   locale::_Impl::_S_id_numeric[] =\n   {\n-    &std::numpunct<char>::id, \n+    &numpunct<char>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::numpunct<wchar_t>::id,\n+    &numpunct<wchar_t>::id,\n #endif\n-    &std::num_get<char>::id,  \n+    &num_get<char>::id,  \n  #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::num_get<wchar_t>::id,\n+    &num_get<wchar_t>::id,\n #endif\n-    &std::num_put<char>::id,  \n+    &num_put<char>::id,  \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::num_put<wchar_t>::id,\n+    &num_put<wchar_t>::id,\n #endif\n     0\n   };\n   \n   const locale::id* const\n   locale::_Impl::_S_id_time[] =\n   {\n-    &std::time_get<char>::id, \n+    &time_get<char>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_get<wchar_t>::id,\n+    &time_get<wchar_t>::id,\n #endif\n-    &std::time_put<char>::id, \n+    &time_put<char>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_put<wchar_t>::id,\n+    &time_put<wchar_t>::id,\n #endif\n     0\n   };\n   \n   const locale::id* const\n   locale::_Impl::_S_id_messages[] =\n   {\n-    &std::time_get<char>::id, \n+    &time_get<char>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_get<wchar_t>::id,\n+    &time_get<wchar_t>::id,\n #endif\n-    &std::time_put<char>::id, \n+    &time_put<char>::id, \n #ifdef _GLIBCPP_USE_WCHAR_T\n-    &std::time_put<wchar_t>::id,\n+    &time_put<wchar_t>::id,\n #endif\n     0\n   };\n   \n   const locale::id* const* const\n   locale::_Impl::_S_facet_categories[] =\n   {\n-    //  order must match the decl order in class locale.\n+    // Order must match the decl order in class locale.\n     locale::_Impl::_S_id_collate,\n     locale::_Impl::_S_id_ctype,\n     locale::_Impl::_S_id_monetary,\n@@ -566,7 +566,9 @@ namespace std {\n \t  (_M_impl = _S_classic)->_M_add_reference();\n \t// Might throw:\n \telse\n-\t  _M_impl = new _Impl(_S_facets_num, 1, true, __name);\n+\t  // XXX Named locale support not finished.\n+\t  // _M_impl = new _Impl(_S_facets_num, 1, true, __name);\n+\t  _M_impl = new _Impl(*_S_classic, __name, all, 1);\n       }\n     else\n       throw runtime_error(\"attempt to create named locale from NULL name\");\n@@ -649,7 +651,6 @@ namespace std {\n \ttry {\n \t  // 26 Standard facets, 2 references.\n \t  // One reference for _M_classic, one for _M_global\n-\t  // XXX _S_classic = _S_global = new _Impl(26, 2);\n \t  _S_classic = new _Impl(_S_facets_num, 2, true, \"C\");\n \t  _S_global = _S_classic; \n "}, {"sha": "3d91e51e36bfa9516c010b4bc6a85c1d771a16a1", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -74,10 +74,10 @@ namespace std {\n   // including the standard \"C\" locale.\n   locale::_Impl::\n   _Impl(size_t __numfacets, size_t __refs, bool __has_name = false, \n-\tstring __name = \"*\")\n+\tstring __name)\n   : _M_references(__refs - 1), _M_facets(0), _M_category_names(0), \n     _M_has_name(__has_name), _M_name(__name)\n-  { \n+  {\n     try\n       {  _M_facets = new __vec_facet(__numfacets, NULL); }\n     catch(...) "}, {"sha": "fef0c3dbc06826723e9d2d8eadd007bf44a4c77e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_unicode_char.cc", "status": "modified", "additions": 99, "deletions": 39, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_char.cc?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -47,43 +47,14 @@ your result\n it shows that the other byte-order is used (25856 == 0x6500).\n */\n \n-#if 0\n-void  \n-create_internal_literal(unsigned short* i_lit)\n-{\n-  i_lit[00] = 25088; //b\n-  i_lit[01] = 27648; //l\n-  i_lit[02] = 24832; //a\n-  i_lit[03] = 25344; //c\n-  i_lit[04] = 27392; //k\n-  i_lit[05] = 8192;\n-  i_lit[06] = 28672; //p\n-  i_lit[07] = 25856; //e\n-  i_lit[08] = 24832; //a\n-  i_lit[09] = 29148; //r\n-  i_lit[10] = 27648; //l\n-  i_lit[11] = 8192;\n-  i_lit[12] = 27136; //j\n-  i_lit[13] = 24832;\n-  i_lit[14] = 29440;\n-  i_lit[15] = 27904;\n-  i_lit[16] = 26880;\n-  i_lit[17] = 28160;\n-  i_lit[18] = 25856; //e\n-  i_lit[19] = 8192;\n-  i_lit[20] = 29696; //t\n-  i_lit[21] = 25856; //e\n-  i_lit[22] = 24832; //a\n-  i_lit[23] = 2560;\n-}\n-#endif\n \n void\n initialize_state(__enc_traits& state)\n { state._M_init(); }\n \n // Partial specialization using __enc_traits.\n // codecvt<unicode_t, char, __enc_traits>\n+// UNICODE - UCS2 (big endian)\n void test01()\n {\n   typedef codecvt_base::result\t\t\tresult;\n@@ -99,10 +70,97 @@ void test01()\n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n   int \t\t\tsize = strlen(e_lit);\n \n-  int_type \t\ti_lit_base[24] = \n-  { 25088, 27648, 24832, 25344, 27392, 8192, 28672, 25856, 24832, 29184, \n-    27648, 8192, 27136, 24832, 29440, 27904, 26880, 28160, 25856, 8192, 29696,\n-    25856, 24832, 2560\n+  int_type \t\ti_lit_base[25] = \n+  { \n+    0x6200, 0x6c00, 0x6100, 0x6300, 0x6b00, 0x2000, 0x7000, 0x6500, 0x6100, \n+    0x7200, 0x6c00, 0x2000, 0x6a00, 0x6100, 0x7300, 0x6d00, 0x6900, 0x6e00, \n+    0x6500, 0x2000, 0x7400, 0x6500, 0x6100, 0xa000\n+  };\n+  const int_type* \ti_lit = i_lit_base;\n+\n+  const ext_type*       efrom_next;\n+  const int_type*       ifrom_next;\n+  ext_type* \t\te_arr = new ext_type[size + 1];\n+  ext_type*\t\teto_next;\n+  int_type* \t\ti_arr = new int_type[size + 1];\n+  int_type*\t\tito_next;\n+\n+  // construct a locale object with the specialized facet.\n+  locale \t\tloc(locale::classic(), new unicode_codecvt);\n+  // sanity check the constructed locale has the specialized facet.\n+  VERIFY( has_facet<unicode_codecvt>(loc) );\n+  const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n+\n+  // in\n+  unicode_codecvt::state_type state01(\"UCS-2BE\", \"ISO-8859-15\", 0xfeff, 0);\n+  initialize_state(state01);\n+  // internal encoding is bigger because of bom\n+  result r1 = cvt.in(state01, e_lit, e_lit + size, efrom_next, \n+\t\t     i_arr, i_arr + size + 1, ito_next);\n+  VERIFY( r1 == codecvt_base::ok );\n+  VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n+  VERIFY( efrom_next == e_lit + size );\n+  VERIFY( ito_next == i_arr + size );\n+\n+  // out\n+  unicode_codecvt::state_type state02(\"UCS-2BE\", \"ISO-8859-15\", 0xfeff, 0);\n+  initialize_state(state02);  \n+  result r2 = cvt.out(state02, i_lit, i_lit + size, ifrom_next, \n+\t\t       e_arr, e_arr + size, eto_next);\n+  VERIFY( r2 == codecvt_base::ok );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n+  VERIFY( ifrom_next == i_lit + size );\n+  VERIFY( eto_next == e_arr + size );\n+\n+  // unshift\n+  ext_traits::copy(e_arr, e_lit, size);\n+  unicode_codecvt::state_type state03(\"UCS-2BE\", \"ISO-8859-15\", 0xfeff, 0);\n+  initialize_state(state03);\n+  result r3 = cvt.unshift(state03, e_arr, e_arr + size, eto_next);\n+  VERIFY( r3 == codecvt_base::noconv );\n+  VERIFY( !ext_traits::compare(e_arr, e_lit, size) ); \n+  VERIFY( eto_next == e_arr );\n+\n+  int i = cvt.encoding();\n+  VERIFY( i == 0 );\n+\n+  VERIFY( !cvt.always_noconv() );\n+\n+  unicode_codecvt::state_type state04(\"UCS-2BE\", \"ISO-8859-15\", 0xfeff, 0);\n+  initialize_state(state04);\n+  int j = cvt.length(state03, e_lit, e_lit + size, 5);\n+  VERIFY( j == 5 );\n+\n+  int k = cvt.max_length();\n+  VERIFY( k == 1 );\n+\n+  delete [] e_arr;\n+  delete [] i_arr;\n+}\n+\n+// Partial specialization using __enc_traits.\n+// codecvt<unicode_t, char, __enc_traits>\n+// UNICODE - UCS2 (little endian)\n+void test02()\n+{\n+  typedef codecvt_base::result\t\t\tresult;\n+  typedef unsigned short\t\t\tunicode_t;\n+  typedef unicode_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef __enc_traits\t\t\t\tenc_type;\n+  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+  typedef char_traits<int_type>\t\t\tint_traits;\n+  typedef char_traits<ext_type>\t\t\text_traits;\n+\n+  bool \t\t\ttest = true;\n+  const ext_type* \te_lit = \"black pearl jasmine tea\";\n+  int \t\t\tsize = strlen(e_lit);\n+\n+  int_type \t\ti_lit_base[25] = \n+  { \n+    0x0062, 0x006c, 0x0061, 0x0063, 0x006b, 0x0020, 0x0070, 0x0065, 0x0061, \n+    0x0072, 0x006c, 0x0020, 0x006a, 0x0061, 0x0073, 0x006d, 0x0069, 0x006e, \n+    0x0065, 0x0020, 0x0074, 0x0065, 0x0061, 0x00a0\n   };\n   const int_type* \ti_lit = i_lit_base;\n \n@@ -120,17 +178,18 @@ void test01()\n   const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n \n   // in\n-  unicode_codecvt::state_type state01(\"UNICODE\", \"ISO-8859-15\");\n+  unicode_codecvt::state_type state01(\"UCS-2LE\", \"ISO-8859-15\", 0xfeff, 0);\n   initialize_state(state01);\n+  // internal encoding is bigger because of bom\n   result r1 = cvt.in(state01, e_lit, e_lit + size, efrom_next, \n-\t\t     i_arr, i_arr + size, ito_next);\n+\t\t     i_arr, i_arr + size + 1, ito_next);\n   VERIFY( r1 == codecvt_base::ok );\n   VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n   VERIFY( efrom_next == e_lit + size );\n   VERIFY( ito_next == i_arr + size );\n \n   // out\n-  unicode_codecvt::state_type state02(\"UNICODE\", \"ISO-8859-15\");\n+  unicode_codecvt::state_type state02(\"UCS-2LE\", \"ISO-8859-15\", 0xfeff, 0);\n   initialize_state(state02);  \n   result r2 = cvt.out(state02, i_lit, i_lit + size, ifrom_next, \n \t\t       e_arr, e_arr + size, eto_next);\n@@ -141,7 +200,7 @@ void test01()\n \n   // unshift\n   ext_traits::copy(e_arr, e_lit, size);\n-  unicode_codecvt::state_type state03(\"UNICODE\", \"ISO-8859-15\");\n+  unicode_codecvt::state_type state03(\"UCS-2LE\", \"ISO-8859-15\", 0xfeff, 0);\n   initialize_state(state03);\n   result r3 = cvt.unshift(state03, e_arr, e_arr + size, eto_next);\n   VERIFY( r3 == codecvt_base::noconv );\n@@ -153,7 +212,7 @@ void test01()\n \n   VERIFY( !cvt.always_noconv() );\n \n-  unicode_codecvt::state_type state04(\"UNICODE\", \"ISO-8859-15\");\n+  unicode_codecvt::state_type state04(\"UCS-2LE\", \"ISO-8859-15\", 0xfeff, 0);\n   initialize_state(state04);\n   int j = cvt.length(state03, e_lit, e_lit + size, 5);\n   VERIFY( j == 5 );\n@@ -168,6 +227,7 @@ void test01()\n int main ()\n {\n   test01();\n+  test02();\n \n   return 0;\n }"}, {"sha": "8f894cccea5e765599fc762fd0cd18a2001d344e", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_unicode_wchar_t.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dc08a20ed152a5ab2e5dd47d630b58665a238e0/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_unicode_wchar_t.cc?ref=7dc08a20ed152a5ab2e5dd47d630b58665a238e0", "patch": "@@ -53,10 +53,10 @@ void test01()\n   const ext_type* \te_lit = e_lit_base;\n \n   int_type \t\ti_lit_base[24] = \n-  { 25088, 27648, 24832, 25344, 27392, 8192, \n-    28672, 25856, 24832, 29184, 27648, 8192, \n-    27136, 24832, 29440, 27904, 26880, 28160, \n-    25856, 8192, 29696, 25856, 24832, 2560\n+  { \n+    0x6200, 0x6c00, 0x6100, 0x6300, 0x6b00, 0x2000, 0x7000, 0x6500, 0x6100, \n+    0x7200, 0x6c00, 0x2000, 0x6a00, 0x6100, 0x7300, 0x6d00, 0x6900, 0x6e00, \n+    0x6500, 0x2000, 0x7400, 0x6500, 0x6100, 0xa000\n   };\n   const int_type* \ti_lit = i_lit_base;\n \n@@ -74,17 +74,17 @@ void test01()\n   const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n \n   // in\n-  unicode_codecvt::state_type state01(\"UNICODE\", \"UCS4\");\n+  unicode_codecvt::state_type state01(\"UCS-2BE\", \"UCS4\", 0xfeff, 0);\n   initialize_state(state01);\n   result r1 = cvt.in(state01, e_lit, e_lit + size, efrom_next, \n-\t\t     i_arr, i_arr + size, ito_next);\n+\t\t     i_arr, i_arr + size + 1, ito_next);\n   VERIFY( r1 == codecvt_base::ok );\n   VERIFY( !int_traits::compare(i_arr, i_lit, size) ); \n   VERIFY( efrom_next == e_lit + size );\n   VERIFY( ito_next == i_arr + size );\n \n   // out\n-  unicode_codecvt::state_type state02(\"UNICODE\", \"UCS4\");\n+  unicode_codecvt::state_type state02(\"UCS-2BE\", \"UCS4\", 0xfeff, 0);\n   initialize_state(state02);  \n   result r2 = cvt.out(state02, i_lit, i_lit + size, ifrom_next, \n \t\t       e_arr, e_arr + size, eto_next);\n@@ -95,7 +95,7 @@ void test01()\n \n   // unshift\n   ext_traits::copy(e_arr, e_lit, size);\n-  unicode_codecvt::state_type state03(\"UNICODE\", \"UCS4\");\n+  unicode_codecvt::state_type state03(\"UCS-2BE\", \"UCS4\", 0xfeff, 0);\n   initialize_state(state03);\n   result r3 = cvt.unshift(state03, e_arr, e_arr + size, eto_next);\n   VERIFY( r3 == codecvt_base::noconv );\n@@ -107,7 +107,7 @@ void test01()\n \n   VERIFY( !cvt.always_noconv() );\n \n-  unicode_codecvt::state_type state04(\"UNICODE\", \"UCS4\");\n+  unicode_codecvt::state_type state04(\"UCS-2BE\", \"UCS4\", 0xfeff, 0);\n   initialize_state(state04);\n   int j = cvt.length(state03, e_lit, e_lit + size, 5);\n   VERIFY( j == 5 );"}]}