{"sha": "3949c4a710360edb924d4c88a8974ed0bbfa9f20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0OWM0YTcxMDM2MGVkYjkyNGQ0Yzg4YTg5NzRlZDBiYmZhOWYyMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-08-05T13:23:07Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-08-05T13:23:07Z"}, "message": "ipa-prop.h (enum ipa_lattice_type): Changed comments.\n\n2010-08-05  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (enum ipa_lattice_type): Changed comments.\n\t(struct ipa_param_descriptor): New fields types and\n\tcannot_devirtualize.\n\t(ipa_param_cannot_devirtualize_p): New function.\n\t(ipa_param_types_vec_empty): Likewise.\n\t(ipa_make_edge_direct_to_target): Declare.\n\t* ipa-cp.c: Fixed first stage driver name in initial comment,\n\tdescribed devirtualization there too.\n\t(ipcp_analyze_node): Call ipa_analyze_params_uses.\n\t(ipcp_print_all_lattices): Print devirtualization info.\n\t(ipa_set_param_cannot_devirtualize): New function.\n\t(ipcp_initialize_node_lattices): Set cannot_devirtualize when setting\n\tlattice to BOTTOM.\n\t(ipcp_init_stage): Merged into...\n\t(ipcp_generate_summary): ...its caller.\n\t(ipcp_change_tops_to_bottom): Also process type lists.\n\t(ipcp_add_param_type): New function.\n\t(ipcp_copy_types): Likewise.\n\t(ipcp_propagate_types): Likewise.\n\t(ipcp_propagate_stage): Also propagate types.\n\t(ipcp_need_redirect_p): Variable jump_func moved to its scope block.\n\tAlso return true if propagated types require it.\n\t(ipcp_update_callgraph): Dump redirection info.\n\t(ipcp_process_devirtualization_opportunities): New function.\n\t(ipcp_const_param_count): Include known type information.\n\t(ipcp_insert_stage): Call ipcp_process_devirtualization_opportunities\n\ton new node.  Fixed formatting.\n\t* ipa-prop.c (make_edge_direct_to_target): Renamed to\n\tipa_make_edge_direct_to_target and changed all callers.  Made\n\texternally visible.\n\t(ipa_node_duplication_hook): Duplicate types vector.\n\t* cgraphunit.c (cgraph_redirect_edge_call_stmt_to_callee): Also try to\n\tredirect outgoing calls for which we can't get a decl from the\n\tstatement.  Check that we can get a decl from the call statement.\n\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n\tipa_analyze_params_uses only when ipa-cp is disabled.\n\t* tree-inline.c (get_indirect_callee_fndecl): Removed.\n\t(expand_call_inline): Do not call get_indirect_callee_fndecl.\n\t* params.def (PARAM_DEVIRT_TYPE_LIST_SIZE): New parameter.\n\t* Makefile.in (ipa-cp.o): Add gimple.h to dependencies.\n\n\t* testsuite/g++.dg/ipa/devirt-1.C: New test.\n\t* testsuite/g++.dg/ipa/devirt-2.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-3.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-4.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-5.C: Likewise.\n\t* testsuite/gcc.dg/ipa/iinline-3.c: Likewise.\n\nFrom-SVN: r162911", "tree": {"sha": "d7635a83c603a76ecd0568209e0c2e2385f551c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7635a83c603a76ecd0568209e0c2e2385f551c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3949c4a710360edb924d4c88a8974ed0bbfa9f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3949c4a710360edb924d4c88a8974ed0bbfa9f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3949c4a710360edb924d4c88a8974ed0bbfa9f20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3949c4a710360edb924d4c88a8974ed0bbfa9f20/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4caa21a13b14b333714d1f8dcce3adefe6fe910e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4caa21a13b14b333714d1f8dcce3adefe6fe910e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4caa21a13b14b333714d1f8dcce3adefe6fe910e"}], "stats": {"total": 836, "additions": 762, "deletions": 74}, "files": [{"sha": "a3ea02be2f02c0ee43be98a53104bb21debed412", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -1,3 +1,46 @@\n+2010-08-05  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (enum ipa_lattice_type): Changed comments.\n+\t(struct ipa_param_descriptor): New fields types and\n+\tcannot_devirtualize.\n+\t(ipa_param_cannot_devirtualize_p): New function.\n+\t(ipa_param_types_vec_empty): Likewise.\n+\t(ipa_make_edge_direct_to_target): Declare.\n+\t* ipa-cp.c: Fixed first stage driver name in initial comment,\n+\tdescribed devirtualization there too.\n+\t(ipcp_analyze_node): Call ipa_analyze_params_uses.\n+\t(ipcp_print_all_lattices): Print devirtualization info.\n+\t(ipa_set_param_cannot_devirtualize): New function.\n+\t(ipcp_initialize_node_lattices): Set cannot_devirtualize when setting\n+\tlattice to BOTTOM.\n+\t(ipcp_init_stage): Merged into...\n+\t(ipcp_generate_summary): ...its caller.\n+\t(ipcp_change_tops_to_bottom): Also process type lists.\n+\t(ipcp_add_param_type): New function.\n+\t(ipcp_copy_types): Likewise.\n+\t(ipcp_propagate_types): Likewise.\n+\t(ipcp_propagate_stage): Also propagate types.\n+\t(ipcp_need_redirect_p): Variable jump_func moved to its scope block.\n+\tAlso return true if propagated types require it.\n+\t(ipcp_update_callgraph): Dump redirection info.\n+\t(ipcp_process_devirtualization_opportunities): New function.\n+\t(ipcp_const_param_count): Include known type information.\n+\t(ipcp_insert_stage): Call ipcp_process_devirtualization_opportunities\n+\ton new node.  Fixed formatting.\n+\t* ipa-prop.c (make_edge_direct_to_target): Renamed to\n+\tipa_make_edge_direct_to_target and changed all callers.  Made\n+\texternally visible.\n+\t(ipa_node_duplication_hook): Duplicate types vector.\n+\t* cgraphunit.c (cgraph_redirect_edge_call_stmt_to_callee): Also try to\n+\tredirect outgoing calls for which we can't get a decl from the\n+\tstatement.  Check that we can get a decl from the call statement.\n+\t* ipa-inline.c (inline_indirect_intraprocedural_analysis): Call\n+\tipa_analyze_params_uses only when ipa-cp is disabled.\n+\t* tree-inline.c (get_indirect_callee_fndecl): Removed.\n+\t(expand_call_inline): Do not call get_indirect_callee_fndecl.\n+\t* params.def (PARAM_DEVIRT_TYPE_LIST_SIZE): New parameter.\n+\t* Makefile.in (ipa-cp.o): Add gimple.h to dependencies.\n+\n 2010-08-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* expmed.c (expand_mult_const) <case alg_shift>: Expand shift into"}, {"sha": "d87d4e2f66dbe027ad451d7bf129761b5d322db5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -3013,7 +3013,7 @@ ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) \n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n-   $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n+   $(TREE_H) $(TARGET_H) $(GIMPLE_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n    $(TREE_INLINE_H) $(FIBHEAP_H) $(PARAMS_H) tree-pretty-print.h\n ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\"}, {"sha": "4d02057420ae9e09f85c59586f7c26e38c97342a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -2362,14 +2362,18 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   struct cgraph_node *node;\n #endif\n \n-  if (!decl || decl == e->callee->decl\n+  if (e->indirect_unknown_callee\n+      || decl == e->callee->decl\n       /* Don't update call from same body alias to the real function.  */\n-      || cgraph_get_node (decl) == cgraph_get_node (e->callee->decl))\n+      || (decl && cgraph_get_node (decl) == cgraph_get_node (e->callee->decl)))\n     return e->call_stmt;\n \n #ifdef ENABLE_CHECKING\n-  node = cgraph_get_node (decl);\n-  gcc_assert (!node || !node->clone.combined_args_to_skip);\n+  if (decl)\n+    {\n+      node = cgraph_get_node (decl);\n+      gcc_assert (!node || !node->clone.combined_args_to_skip);\n+    }\n #endif\n \n   if (cgraph_dump_file)"}, {"sha": "fb33b728e93d8ab11ab133b36f0b637a6f90495e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -8731,6 +8731,12 @@ loop in the loop nest by a given number of iterations.  The strip\n length can be changed using the @option{loop-block-tile-size}\n parameter.  The default value is 51 iterations.\n \n+@item devirt-type-list-size\n+IPA-CP attempts to track all possible types passed to a function's\n+parameter in order to perform devirtualization.\n+@option{devirt-type-list-size} is the maximum number of types it\n+stores per a single formal parameter of a function.\n+\n @end table\n @end table\n "}, {"sha": "354a404d36f23212598cf24f11d4bfc6a49c3795", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 275, "deletions": 41, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -70,7 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n    modified_flags are defined in ipa_node_params structure\n    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n \n-   -ipcp_init_stage() is the first stage driver.\n+   -ipcp_generate_summary() is the first stage driver.\n \n    Second stage - interprocedural analysis\n    ========================================\n@@ -117,13 +117,25 @@ along with GCC; see the file COPYING3.  If not see\n \n    -ipcp_insert_stage() is the third phase driver.\n \n+\n+   This pass also performs devirtualization - turns virtual calls into direct\n+   ones if it can prove that all invocations of the function call the same\n+   callee.  This is achieved by building a list of all base types (actually,\n+   their BINFOs) that individual parameters can have in an iterative matter\n+   just like propagating scalar constants and then examining whether virtual\n+   calls which take a parameter as their object fold to the same target for all\n+   these types.  If we cannot enumerate all types or there is a type which does\n+   not have any BINFO associated with it, cannot_devirtualize of the associated\n+   parameter descriptor is set which is an equivalent of BOTTOM lattice value\n+   in standard IPA constant propagation.\n */\n \n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"target.h\"\n+#include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"ipa-prop.h\"\n #include \"tree-flow.h\"\n@@ -393,12 +405,17 @@ ipcp_print_all_lattices (FILE * f)\n \t\t  print_generic_expr (f, DECL_INITIAL (TREE_OPERAND (cst, 0)),\n \t\t\t\t\t\t       0);\n \t\t}\n-\t      fprintf (f, \"\\n\");\n \t    }\n \t  else if (lat->type == IPA_TOP)\n-\t    fprintf (f, \"type is TOP\\n\");\n+\t    fprintf (f, \"type is TOP\");\n+\t  else\n+\t    fprintf (f, \"type is BOTTOM\");\n+\t  if (ipa_param_cannot_devirtualize_p (info, i))\n+\t    fprintf (f, \" - cannot_devirtualize set\\n\");\n+\t  else if (ipa_param_types_vec_empty (info, i))\n+\t    fprintf (f, \" - type list empty\\n\");\n \t  else\n-\t    fprintf (f, \"type is BOTTOM\\n\");\n+\t    fprintf (f, \"\\n\");\n \t}\n     }\n }\n@@ -523,6 +540,19 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   return true;\n }\n \n+/* Mark parameter with index I of function described by INFO as unsuitable for\n+   devirtualization.  Return true if it has already been marked so.  */\n+\n+static bool\n+ipa_set_param_cannot_devirtualize (struct ipa_node_params *info, int i)\n+{\n+  bool ret = info->params[i].cannot_devirtualize;\n+  info->params[i].cannot_devirtualize = true;\n+  if (info->params[i].types)\n+    VEC_free (tree, heap, info->params[i].types);\n+  return ret;\n+}\n+\n /* Initialize ipcp_lattices array.  The lattices corresponding to supported\n    types (integers, real types and Fortran constants defined as const_decls)\n    are initialized to IPA_TOP, the rest of them to IPA_BOTTOM.  */\n@@ -545,7 +575,11 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n     type = IPA_BOTTOM;\n \n   for (i = 0; i < ipa_get_param_count (info) ; i++)\n-    ipcp_get_lattice (info, i)->type = type;\n+    {\n+      ipcp_get_lattice (info, i)->type = type;\n+      if (type == IPA_BOTTOM)\n+\tipa_set_param_cannot_devirtualize (info, i);\n+    }\n }\n \n /* build INTEGER_CST tree with type TREE_TYPE and value according to LAT.\n@@ -599,26 +633,6 @@ ipcp_compute_node_scale (struct cgraph_node *node)\n     ipcp_set_node_scale (node, sum * REG_BR_PROB_BASE / node->count);\n }\n \n-/* Initialization and computation of IPCP data structures.  This is the initial\n-   intraprocedural analysis of functions, which gathers information to be\n-   propagated later on.  */\n-\n-static void\n-ipcp_init_stage (void)\n-{\n-  struct cgraph_node *node;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n-      {\n-\t/* Unreachable nodes should have been eliminated before ipcp.  */\n-\tgcc_assert (node->needed || node->reachable);\n-\n-\tnode->local.versionable = tree_versionable_function_p (node->decl);\n-\tipa_analyze_node (node);\n-      }\n-}\n-\n /* Return true if there are some formal parameters whose value is IPA_TOP (in\n    the whole compilation unit).  Change their values to IPA_BOTTOM, since they\n    most probably get their values from outside of this compilation unit.  */\n@@ -649,11 +663,148 @@ ipcp_change_tops_to_bottom (void)\n \t\t}\n \t      lat->type = IPA_BOTTOM;\n \t    }\n+\t  if (!ipa_param_cannot_devirtualize_p (info, i)\n+\t      && ipa_param_types_vec_empty (info, i))\n+\t    {\n+\t      prop_again = true;\n+\t      ipa_set_param_cannot_devirtualize (info, i);\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"Marking param \");\n+\t\t  print_generic_expr (dump_file, ipa_get_param (info, i), 0);\n+\t\t  fprintf (dump_file, \" of node %s as unusable for \"\n+\t\t\t   \"devirtualization.\\n\",\n+\t\t\t   cgraph_node_name (node));\n+\t\t}\n+\t    }\n \t}\n     }\n   return prop_again;\n }\n \n+/* Insert BINFO to the list of known types of parameter number I of the\n+   function described by CALLEE_INFO.  Return true iff the type information\n+   associated with the callee parameter changed in any way.  */\n+\n+static bool\n+ipcp_add_param_type (struct ipa_node_params *callee_info, int i, tree binfo)\n+{\n+  int j, count;\n+\n+  if (ipa_param_cannot_devirtualize_p (callee_info, i))\n+    return false;\n+\n+  if (callee_info->params[i].types)\n+    {\n+      count = VEC_length (tree, callee_info->params[i].types);\n+      for (j = 0; j < count; j++)\n+\tif (VEC_index (tree, callee_info->params[i].types, j) == binfo)\n+\t  return false;\n+    }\n+\n+  if (VEC_length (tree, callee_info->params[i].types)\n+      == (unsigned) PARAM_VALUE (PARAM_DEVIRT_TYPE_LIST_SIZE))\n+    return !ipa_set_param_cannot_devirtualize (callee_info, i);\n+\n+  VEC_safe_push (tree, heap, callee_info->params[i].types, binfo);\n+  return true;\n+}\n+\n+/* Copy known types information for parameter number CALLEE_IDX of CALLEE_INFO\n+   from a parameter of CALLER_INFO as described by JF.  Return true iff the\n+   type information changed in any way.  JF must be a pass-through or an\n+   ancestor jump function.  */\n+\n+static bool\n+ipcp_copy_types (struct ipa_node_params *caller_info,\n+\t\t struct ipa_node_params *callee_info,\n+\t\t int callee_idx, struct ipa_jump_func *jf)\n+{\n+  int caller_idx, j, count;\n+  bool res;\n+\n+  if (ipa_param_cannot_devirtualize_p (callee_info, callee_idx))\n+    return false;\n+\n+  if (jf->type == IPA_JF_PASS_THROUGH)\n+    {\n+      if (jf->value.pass_through.operation != NOP_EXPR)\n+\t{\n+\t  ipa_set_param_cannot_devirtualize (callee_info, callee_idx);\n+\t  return true;\n+\t}\n+      caller_idx = jf->value.pass_through.formal_id;\n+    }\n+  else\n+    caller_idx = jf->value.ancestor.formal_id;\n+\n+  if (ipa_param_cannot_devirtualize_p (caller_info, caller_idx))\n+    {\n+      ipa_set_param_cannot_devirtualize (callee_info, callee_idx);\n+      return true;\n+    }\n+\n+  if (!caller_info->params[caller_idx].types)\n+    return false;\n+\n+  res = false;\n+  count = VEC_length (tree, caller_info->params[caller_idx].types);\n+  for (j = 0; j < count; j++)\n+    {\n+      tree binfo = VEC_index (tree, caller_info->params[caller_idx].types, j);\n+      if (jf->type == IPA_JF_ANCESTOR)\n+\t{\n+\t  binfo = get_binfo_at_offset (binfo, jf->value.ancestor.offset,\n+\t\t\t\t       jf->value.ancestor.type);\n+\t  if (!binfo)\n+\t    {\n+\t      ipa_set_param_cannot_devirtualize (callee_info, callee_idx);\n+\t      return true;\n+\t    }\n+\t}\n+      res |= ipcp_add_param_type (callee_info, callee_idx, binfo);\n+    }\n+  return res;\n+}\n+\n+/* Propagate type information for parameter of CALLEE_INFO number I as\n+   described by JF.  CALLER_INFO describes the caller.  Return true iff the\n+   type information changed in any way.  */\n+\n+static bool\n+ipcp_propagate_types (struct ipa_node_params *caller_info,\n+\t\t      struct ipa_node_params *callee_info,\n+\t\t      struct ipa_jump_func *jf, int i)\n+{\n+  tree cst, binfo;\n+\n+  switch (jf->type)\n+    {\n+    case IPA_JF_UNKNOWN:\n+    case IPA_JF_CONST_MEMBER_PTR:\n+      break;\n+\n+    case IPA_JF_KNOWN_TYPE:\n+      return ipcp_add_param_type (callee_info, i, jf->value.base_binfo);\n+\n+    case IPA_JF_CONST:\n+      cst = jf->value.constant;\n+      if (TREE_CODE (cst) != ADDR_EXPR)\n+\tbreak;\n+      binfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (cst, 0), NULL_TREE);\n+      if (!binfo)\n+\tbreak;\n+      return ipcp_add_param_type (callee_info, i, binfo);\n+\n+    case IPA_JF_PASS_THROUGH:\n+    case IPA_JF_ANCESTOR:\n+      return ipcp_copy_types (caller_info, callee_info, i, jf);\n+    }\n+\n+  /* If we reach this we cannot use this parameter for devirtualization.  */\n+  return !ipa_set_param_cannot_devirtualize (callee_info, i);\n+}\n+\n /* Interprocedural analysis. The algorithm propagates constants from the\n    caller's parameters to the callee's arguments.  */\n static void\n@@ -701,6 +852,9 @@ ipcp_propagate_stage (void)\n \t\t  dest_lat->constant = new_lat.constant;\n \t\t  ipa_push_func_to_list (&wl, cs->callee);\n \t\t}\n+\n+\t      if (ipcp_propagate_types (info, callee_info, jump_func, i))\n+\t\tipa_push_func_to_list (&wl, cs->callee);\n \t    }\n \t}\n     }\n@@ -852,7 +1006,6 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n {\n   struct ipa_node_params *orig_callee_info;\n   int i, count;\n-  struct ipa_jump_func *jump_func;\n   struct cgraph_node *node = cs->callee, *orig;\n \n   if (!n_cloning_candidates)\n@@ -868,12 +1021,16 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   for (i = 0; i < count; i++)\n     {\n       struct ipcp_lattice *lat = ipcp_get_lattice (orig_callee_info, i);\n-      if (ipcp_lat_is_const (lat))\n-\t{\n-\t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  if (jump_func->type != IPA_JF_CONST)\n-\t    return true;\n-\t}\n+      struct ipa_jump_func *jump_func;\n+\n+      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+      if ((ipcp_lat_is_const (lat)\n+\t   && jump_func->type != IPA_JF_CONST)\n+\t  || (!ipa_param_cannot_devirtualize_p (orig_callee_info, i)\n+\t      && !ipa_param_types_vec_empty (orig_callee_info, i)\n+\t      && jump_func->type != IPA_JF_CONST\n+\t      && jump_func->type != IPA_JF_KNOWN_TYPE))\n+\treturn true;\n     }\n \n   return false;\n@@ -912,7 +1069,15 @@ ipcp_update_callgraph (void)\n \t  {\n \t    next = cs->next_caller;\n \t    if (!ipcp_node_is_clone (cs->caller) && ipcp_need_redirect_p (cs))\n-\t      cgraph_redirect_edge_callee (cs, orig_node);\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Redirecting edge %s/%i -> %s/%i \"\n+\t\t\t   \"back to %s/%i.\",\n+\t\t\t   cgraph_node_name (cs->caller), cs->caller->uid,\n+\t\t\t   cgraph_node_name (cs->callee), cs->callee->uid,\n+\t\t\t   cgraph_node_name (orig_node), orig_node->uid);\n+\t\tcgraph_redirect_edge_callee (cs, orig_node);\n+\t      }\n \t  }\n       }\n }\n@@ -1031,6 +1196,57 @@ ipcp_estimate_cloning_cost (struct cgraph_node *node)\n   return cost + 1;\n }\n \n+/* Walk indirect calls of NODE and if any polymorphic can be turned into a\n+   direct one now, do so.  */\n+\n+static void\n+ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  struct cgraph_edge *ie, *next_ie;\n+\n+  for (ie = node->indirect_calls; ie; ie = next_ie)\n+    {\n+      int param_index, types_count, j;\n+      HOST_WIDE_INT token;\n+      tree target;\n+\n+      next_ie = ie->next_callee;\n+      if (!ie->indirect_info->polymorphic)\n+\tcontinue;\n+      param_index = ie->indirect_info->param_index;\n+      if (param_index == -1\n+\t  || ipa_param_cannot_devirtualize_p (info, param_index)\n+\t  || ipa_param_types_vec_empty (info, param_index))\n+\tcontinue;\n+\n+      token = ie->indirect_info->otr_token;\n+      target = NULL_TREE;\n+      types_count = VEC_length (tree, info->params[param_index].types);\n+      for (j = 0; j < types_count; j++)\n+\t{\n+\t  tree binfo = VEC_index (tree, info->params[param_index].types, j);\n+\t  tree t = gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+\n+\t  if (!t)\n+\t    {\n+\t      target = NULL_TREE;\n+\t      break;\n+\t    }\n+\t  else if (!target)\n+\t    target = t;\n+\t  else if (target != t)\n+\t    {\n+\t      target = NULL_TREE;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (target)\n+\tipa_make_edge_direct_to_target (ie, target);\n+    }\n+}\n+\n /* Return number of live constant parameters.  */\n static int\n ipcp_const_param_count (struct cgraph_node *node)\n@@ -1043,9 +1259,11 @@ ipcp_const_param_count (struct cgraph_node *node)\n   for (i = 0; i < count; i++)\n     {\n       struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n-      if (ipcp_lat_is_insertable (lat)\n+      if ((ipcp_lat_is_insertable (lat)\n \t  /* Do not count obviously unused arguments.  */\n-          && ipa_is_param_used (info, i))\n+\t   && ipa_is_param_used (info, i))\n+\t  || (!ipa_param_cannot_devirtualize_p (info, i)\n+\t      && !ipa_param_types_vec_empty (info, i)))\n \tconst_param++;\n     }\n   return const_param;\n@@ -1087,7 +1305,8 @@ ipcp_insert_stage (void)\n     max_new_size = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n   max_new_size = max_new_size * PARAM_VALUE (PARAM_IPCP_UNIT_GROWTH) / 100 + 1;\n \n-  /* First collect all functions we proved to have constant arguments to heap.  */\n+  /* First collect all functions we proved to have constant arguments to\n+     heap.  */\n   heap = fibheap_new ();\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n@@ -1099,7 +1318,8 @@ ipcp_insert_stage (void)\n       if (ipa_is_called_with_var_arguments (info))\n \tcontinue;\n       if (ipcp_const_param_count (node))\n-\tnode->aux = fibheap_insert (heap, ipcp_estimate_cloning_cost (node), node);\n+\tnode->aux = fibheap_insert (heap, ipcp_estimate_cloning_cost (node),\n+\t\t\t\t    node);\n      }\n \n   /* Now clone in priority order until code size growth limits are met or\n@@ -1183,6 +1403,8 @@ ipcp_insert_stage (void)\n \n       if (node1 == NULL)\n \tcontinue;\n+      ipcp_process_devirtualization_opportunities (node1);\n+\n       if (dump_file)\n \tfprintf (dump_file, \"versioned function %s with growth %i, overall %i\\n\",\n \t\t cgraph_node_name (node), (int)growth, (int)new_size);\n@@ -1245,18 +1467,30 @@ ipcp_driver (void)\n   return 0;\n }\n \n-/* Note function body size.  */\n+/* Initialization and computation of IPCP data structures.  This is the initial\n+   intraprocedural analysis of functions, which gathers information to be\n+   propagated later on.  */\n+\n static void\n ipcp_generate_summary (void)\n {\n+  struct cgraph_node *node;\n+\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   ipa_register_cgraph_hooks ();\n-  /* 1. Call the init stage to initialize\n-     the ipa_node_params and ipa_edge_args structures.  */\n-  ipcp_init_stage ();\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->analyzed)\n+      {\n+\t/* Unreachable nodes should have been eliminated before ipcp.  */\n+\tgcc_assert (node->needed || node->reachable);\n+\n+\tnode->local.versionable = tree_versionable_function_p (node->decl);\n+\tipa_analyze_node (node);\n+      }\n }\n \n /* Write ipcp summary for nodes in SET.  */"}, {"sha": "9d7df0752929e0205995b6d29ede811aac47678b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -1430,8 +1430,8 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n /* If TARGET is an addr_expr of a function declaration, make it the destination\n    of an indirect edge IE and return the edge.  Otherwise, return NULL.  */\n \n-static struct cgraph_edge *\n-make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n+struct cgraph_edge *\n+ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n {\n   struct cgraph_node *callee;\n \n@@ -1484,7 +1484,7 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   else\n     return NULL;\n \n-  return make_edge_direct_to_target (ie, target);\n+  return ipa_make_edge_direct_to_target (ie, target);\n }\n \n /* Try to find a destination for indirect edge IE that corresponds to a\n@@ -1525,7 +1525,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n     return NULL;\n \n   if (target)\n-    return make_edge_direct_to_target (ie, target);\n+    return ipa_make_edge_direct_to_target (ie, target);\n   else\n     return NULL;\n }\n@@ -1794,7 +1794,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_node_params *old_info, *new_info;\n-  int param_count;\n+  int param_count, i;\n \n   ipa_check_create_node_params ();\n   old_info = IPA_NODE_REF (src);\n@@ -1805,8 +1805,15 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   new_info->params = (struct ipa_param_descriptor *)\n     duplicate_array (old_info->params,\n \t\t     sizeof (struct ipa_param_descriptor) * param_count);\n+  for (i = 0; i < param_count; i++)\n+    new_info->params[i].types = VEC_copy (tree, heap,\n+ \t\t\t\t\t  old_info->params[i].types);\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n   new_info->count_scale = old_info->count_scale;\n+\n+  new_info->called_with_var_arguments = old_info->called_with_var_arguments;\n+  new_info->uses_analysis_done = old_info->uses_analysis_done;\n+  new_info->node_enqueued = old_info->node_enqueued;\n }\n \n /* Register our cgraph hooks if they are not already there.  */"}, {"sha": "8244a7f79e32054faaeadc28976d6e54777aae0f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -133,11 +133,12 @@ struct GTY (()) ipa_jump_func\n    computed by the interprocedural stage of IPCP.\n    There are three main values of the lattice:\n    IPA_TOP - unknown,\n-   IPA_BOTTOM - non constant,\n+   IPA_BOTTOM - variable,\n    IPA_CONST_VALUE - simple scalar constant,\n-   Cval of formal f will have a constant value if all callsites to this\n-   function have the same constant value passed to f.\n-   Integer and real constants are represented as IPA_CONST_VALUE.  */\n+\n+   We also use this type to propagate types accross the call graph for the\n+   purpose of devirtualization.  In that case, IPA_CONST_VALUE denotes a known\n+   type, rather than a constant.  */\n enum ipa_lattice_type\n {\n   IPA_BOTTOM,\n@@ -161,8 +162,14 @@ struct ipa_param_descriptor\n   struct ipcp_lattice ipcp_lattice;\n   /* PARAM_DECL of this parameter.  */\n   tree decl;\n+  /* Vector of BINFOs of types that this argument might encounter.  NULL\n+     basically means a top value, bottom is marked by the cannot_devirtualize\n+     flag below.*/\n+  VEC (tree, heap) *types;\n   /* The parameter is used.  */\n   unsigned used : 1;\n+  /* Set when parameter type cannot be used for devirtualization.  */\n+  unsigned cannot_devirtualize : 1;\n };\n \n /* ipa_node_params stores information related to formal parameters of functions\n@@ -232,6 +239,25 @@ ipa_is_param_used (struct ipa_node_params *info, int i)\n   return info->params[i].used;\n }\n \n+/* Return the cannot_devirtualize flag corresponding to the Ith formal\n+   parameter of the function associated with INFO.  The corresponding function\n+   to set the flag is ipa_set_param_cannot_devirtualize.  */\n+\n+static inline bool\n+ipa_param_cannot_devirtualize_p (struct ipa_node_params *info, int i)\n+{\n+  return info->params[i].cannot_devirtualize;\n+}\n+\n+/* Return true iff the vector of possible types of the Ith formal parameter of\n+   the function associated with INFO is empty.  */\n+\n+static inline bool\n+ipa_param_types_vec_empty (struct ipa_node_params *info, int i)\n+{\n+  return info->params[i].types == NULL;\n+}\n+\n /* Flag this node as having callers with variable number of arguments.  */\n \n static inline void\n@@ -402,6 +428,10 @@ void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) **new_edges);\n \n+/* Indirect edge and binfo processing.  */\n+struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n+\n+\n /* Debugging interface.  */\n void ipa_print_node_params (FILE *, struct cgraph_node *node);\n void ipa_print_all_params (FILE *);"}, {"sha": "d470539c9c424645a8701aaf8d6ebf5d939c0a03", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -832,6 +832,12 @@ DEFPARAM (PARAM_IPA_SRA_PTR_GROWTH_FACTOR,\n \t  \"a pointer to an aggregate with\",\n \t  2, 0, 0)\n \n+DEFPARAM (PARAM_DEVIRT_TYPE_LIST_SIZE,\n+\t  \"devirt-type-list-size\",\n+\t  \"Maximum size of a type list associated with each parameter for \"\n+\t  \"devirtualization\",\n+\t  8, 0, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "59bde3f29dfc9baf62deed7459dc52dda24a2646", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -1,3 +1,12 @@\n+2010-08-05  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-1.C: New test.\n+\t* g++.dg/ipa/devirt-2.C: Likewise.\n+\t* g++.dg/ipa/devirt-3.C: Likewise.\n+\t* g++.dg/ipa/devirt-4.C: Likewise.\n+\t* g++.dg/ipa/devirt-5.C: Likewise.\n+\t* gcc.dg/ipa/iinline-3.c: Likewise.\n+\n 2010-08-05  Jie Zhang  <jie@codesourcery.com>\n \n \tPR tree-optimization/45144"}, {"sha": "de0f665c4513d54e4b4b59fd2abdecf2a5c7729f", "filename": "gcc/testsuite/g++.dg/ipa/devirt-1.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-1.C?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,62 @@\n+/* Verify that simple virtual calls are converted to direct calls by ipa-cp.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  if (middleman (&b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d3181e4c0f79a643994822567f658660d3c6f679", "filename": "gcc/testsuite/g++.dg/ipa/devirt-2.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-2.C?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,62 @@\n+/* Verify that simple virtual calls using this pointer are converted\n+   to direct calls by ipa-cp.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+  int middleman (int i)\n+  {\n+    return foo (i);\n+  }\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+  for (i = 0; i < get_input(); i++)\n+    if (b.middleman (get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}, {"sha": "2d7bb0ab04eac1d7a5842591ca65afab51d5a1b5", "filename": "gcc/testsuite/g++.dg/ipa/devirt-3.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-3.C?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,63 @@\n+/* Verify that simple virtual calls on an object refrence are\n+   converted to simple calls by ipa-cp.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int middleman (class A &obj, int i)\n+{\n+  return obj.foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  if (middleman (b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "72c883b3f6ada964360a432fbf538deb4320d077", "filename": "gcc/testsuite/g++.dg/ipa/devirt-4.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-4.C?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,68 @@\n+/* Verify that ipa-co can convert virtual calls to direct ones even\n+   when a typecast to an ancestor is involved along the way.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  if (middleman_2 (&b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "575bc0271e6136383c722347dfdfed0676efaf1b", "filename": "gcc/testsuite/g++.dg/ipa/devirt-5.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-5.C?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,79 @@\n+/* Verify that ipa-cp can convert simple virtual calls to a direct\n+   ones even when a typecast to an ancestor is involved along the way\n+   and that ancestor is not the first one with virtual functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline -fdump-ipa-cp -fdump-tree-optimized\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+\n+  if (middleman_2 (&b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Discovered a virtual call to a known target.*B::foo\"  \"cp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b39957162ab8ba839f3f09a532e1a4fff379f84b", "filename": "gcc/testsuite/gcc.dg/ipa/iinline-3.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fiinline-3.c?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -0,0 +1,33 @@\n+/* Verify that call declarations are not redirected according to indirect\n+   inlining edges too early.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining\"  } */\n+\n+extern void abort (void);\n+\n+int bar (int k)\n+{\n+  return k+2;\n+}\n+\n+int baz (int k)\n+{\n+  return k+1;\n+}\n+\n+static int foo (int (*p)(int), int i)\n+{\n+  return p (i+1);\n+}\n+\n+int (*g)(int) = baz;\n+\n+int main (int argc, char *argv[])\n+{\n+  if (foo (bar, 0) != 3)\n+    abort ();\n+  if (foo (g, 1) != 3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "a4785d800ff96b40662cdeb58d7522ca1c325840", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3949c4a710360edb924d4c88a8974ed0bbfa9f20/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3949c4a710360edb924d4c88a8974ed0bbfa9f20", "patch": "@@ -3707,20 +3707,6 @@ add_local_variables (struct function *callee, struct function *caller,\n       }\n }\n \n-/* Fetch callee declaration from the call graph edge going from NODE and\n-   associated with STMR call statement.  Return NULL_TREE if not found.  */\n-static tree\n-get_indirect_callee_fndecl (struct cgraph_node *node, gimple stmt)\n-{\n-  struct cgraph_edge *cs;\n-\n-  cs = cgraph_edge (node, stmt);\n-  if (cs && !cs->indirect_unknown_callee)\n-    return cs->callee->decl;\n-\n-  return NULL_TREE;\n-}\n-\n /* If STMT is a GIMPLE_CALL, replace it with its inline expansion.  */\n \n static bool\n@@ -3754,11 +3740,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      If we cannot, then there is no hope of inlining the function.  */\n   fn = gimple_call_fndecl (stmt);\n   if (!fn)\n-    {\n-      fn = get_indirect_callee_fndecl (id->dst_node, stmt);\n-      if (!fn)\n-\tgoto egress;\n-    }\n+    goto egress;\n \n   /* Turn forward declarations into real ones.  */\n   fn = cgraph_node (fn)->decl;"}]}