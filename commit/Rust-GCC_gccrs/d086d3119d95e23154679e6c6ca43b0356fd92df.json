{"sha": "d086d3119d95e23154679e6c6ca43b0356fd92df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4NmQzMTE5ZDk1ZTIzMTU0Njc5ZTZjNmNhNDNiMDM1NmZkOTJkZg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-12T15:20:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-12T15:20:48Z"}, "message": "gsstruct.def (GSS_CALL): New.\n\n2010-04-12  Richard Guenther  <rguenther@suse.de>\n\n\t* gsstruct.def (GSS_CALL): New.\n\t* gimple.def (GIMPLE_CALL): Change to GSS_CALL.\n\t* gimple.h: Include tree-ssa-alias.h.\n\t(struct gimple_statement_call): New.\n\t(union gimple_statement_struct_d): Add gimple_call member.\n\t(gimple_call_reset_alias_info): Declare.\n\t(gimple_call_use_set): New function.\n\t(gimple_call_clobber_set): Likewise.\n\t* Makefile.in (GIMPLE_H): Add tree-ssa-alias.h.\n\t* gimple.c (gimple_call_reset_alias_info): New function.\n\t(gimple_build_call_1): Call it.\n\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n\t* tree-inline.c (remap_gimple_stmt): Likewise.\n\t(expand_call_inline): Remove callused handling.\n\t* cfgexpand.c (update_alias_info_with_stack_vars): Likewise.\n\t* tree-dfa.c (dump_variable): Likewise.\n\t* tree-parloops.c (parallelize_loops): Likewise.\n\t* tree-ssa.c (init_tree_ssa): Likewise.\n\t(delete_tree_ssa): Likewise.\n\t* tree-flow-inline.h (is_call_used): Remove.\n\t* tree-flow.h (struct gimple_df): Remove callused member.\n\t* tree-nrv.c (dest_safe_for_nrv_p): Adjust predicate.\n\t* tree-ssa-alias.c (dump_alias_info): Remove callused handling.\n\t(ref_maybe_used_by_call_p_1): Simplify.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t* tree-ssa-structalias.c (compute_points_to_sets): Set\n\tthe call stmt used and clobbered sets.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Adjust predicate.\n\t(find_tail_calls): Verify the tail call.\n\nFrom-SVN: r158226", "tree": {"sha": "a5f4bc000b917f934f12c45b1b6e764ac0256de6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f4bc000b917f934f12c45b1b6e764ac0256de6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d086d3119d95e23154679e6c6ca43b0356fd92df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d086d3119d95e23154679e6c6ca43b0356fd92df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d086d3119d95e23154679e6c6ca43b0356fd92df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d086d3119d95e23154679e6c6ca43b0356fd92df/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af961c7f461a46db81d59c997b513509f6e32ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af961c7f461a46db81d59c997b513509f6e32ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af961c7f461a46db81d59c997b513509f6e32ae8"}], "stats": {"total": 275, "additions": 197, "deletions": 78}, "files": [{"sha": "136ffae67033aae0ce9572f058c94fefb16db6f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -1,3 +1,35 @@\n+2010-04-12  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gsstruct.def (GSS_CALL): New.\n+\t* gimple.def (GIMPLE_CALL): Change to GSS_CALL.\n+\t* gimple.h: Include tree-ssa-alias.h.\n+\t(struct gimple_statement_call): New.\n+\t(union gimple_statement_struct_d): Add gimple_call member.\n+\t(gimple_call_reset_alias_info): Declare.\n+\t(gimple_call_use_set): New function.\n+\t(gimple_call_clobber_set): Likewise.\n+\t* Makefile.in (GIMPLE_H): Add tree-ssa-alias.h.\n+\t* gimple.c (gimple_call_reset_alias_info): New function.\n+\t(gimple_build_call_1): Call it.\n+\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* tree-inline.c (remap_gimple_stmt): Likewise.\n+\t(expand_call_inline): Remove callused handling.\n+\t* cfgexpand.c (update_alias_info_with_stack_vars): Likewise.\n+\t* tree-dfa.c (dump_variable): Likewise.\n+\t* tree-parloops.c (parallelize_loops): Likewise.\n+\t* tree-ssa.c (init_tree_ssa): Likewise.\n+\t(delete_tree_ssa): Likewise.\n+\t* tree-flow-inline.h (is_call_used): Remove.\n+\t* tree-flow.h (struct gimple_df): Remove callused member.\n+\t* tree-nrv.c (dest_safe_for_nrv_p): Adjust predicate.\n+\t* tree-ssa-alias.c (dump_alias_info): Remove callused handling.\n+\t(ref_maybe_used_by_call_p_1): Simplify.\n+\t(call_may_clobber_ref_p_1): Likewise.\n+\t* tree-ssa-structalias.c (compute_points_to_sets): Set\n+\tthe call stmt used and clobbered sets.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Adjust predicate.\n+\t(find_tail_calls): Verify the tail call.\n+\n 2010-04-12  Richard Guenther  <rguenther@suse.de>\n \n \t* ipa.c (cgraph_postorder): Adjust postorder to guarantee"}, {"sha": "c1cec39725311fa7ecab725c90866008ff7caed5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -876,7 +876,8 @@ BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h $(PREDICT_H) vec.h $(FUNCTION_H) \\\n           cfghooks.h $(OBSTACK_H)\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h vec.h \\\n-\t$(GGC_H) $(BASIC_BLOCK_H) $(TM_H) $(TARGET_H) tree-ssa-operands.h\n+\t$(GGC_H) $(BASIC_BLOCK_H) $(TM_H) $(TARGET_H) tree-ssa-operands.h \\\n+\ttree-ssa-alias.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n COVERAGE_H = coverage.h $(GCOV_IO_H)\n DEMANGLE_H = $(srcdir)/../include/demangle.h"}, {"sha": "ce1f75a884e80b949c9140a891957309b35f93c9", "filename": "gcc/gimple.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -198,6 +198,21 @@ gimple_build_return (tree retval)\n   return s;\n }\n \n+/* Reset alias information on call S.  */\n+\n+void\n+gimple_call_reset_alias_info (gimple s)\n+{\n+  if (gimple_call_flags (s) & ECF_CONST)\n+    memset (gimple_call_use_set (s), 0, sizeof (struct pt_solution));\n+  else\n+    pt_solution_reset (gimple_call_use_set (s));\n+  if (gimple_call_flags (s) & (ECF_CONST|ECF_PURE|ECF_NOVOPS))\n+    memset (gimple_call_clobber_set (s), 0, sizeof (struct pt_solution));\n+  else\n+    pt_solution_reset (gimple_call_clobber_set (s));\n+}\n+\n /* Helper for gimple_build_call, gimple_build_call_vec and\n    gimple_build_call_from_tree.  Build the basic components of a\n    GIMPLE_CALL statement to function FN with NARGS arguments.  */\n@@ -209,6 +224,7 @@ gimple_build_call_1 (tree fn, unsigned nargs)\n   if (TREE_CODE (fn) == FUNCTION_DECL)\n     fn = build_fold_addr_expr (fn);\n   gimple_set_op (s, 1, fn);\n+  gimple_call_reset_alias_info (s);\n   return s;\n }\n "}, {"sha": "49aa88eab337c37e6a677ba23812f45249ccba35", "filename": "gcc/gimple.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -122,7 +122,7 @@ DEFGSCODE(GIMPLE_ASM, \"gimple_asm\", GSS_ASM)\n    is_gimple_operand.\n \n     CHAIN is the optional static chain link for nested functions.  */\n-DEFGSCODE(GIMPLE_CALL, \"gimple_call\", GSS_WITH_MEM_OPS)\n+DEFGSCODE(GIMPLE_CALL, \"gimple_call\", GSS_CALL)\n \n /* GIMPLE_RETURN <RETVAL> represents return statements.\n "}, {"sha": "9df6e92dacfb31dbc9901ed260a61a260d9f82cb", "filename": "gcc/gimple.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-operands.h\"\n+#include \"tree-ssa-alias.h\"\n \n DEF_VEC_P(gimple);\n DEF_VEC_ALLOC_P(gimple,heap);\n@@ -390,6 +391,25 @@ struct GTY(()) gimple_statement_with_memory_ops\n };\n \n \n+/* Call statements that take both memory and register operands.  */\n+\n+struct GTY(()) gimple_statement_call\n+{\n+  /* [ WORD 1-8 ]  */\n+  struct gimple_statement_with_memory_ops_base membase;\n+\n+  /* [ WORD 9-12 ]  */\n+  struct pt_solution call_used;\n+  struct pt_solution call_clobbered;\n+\n+  /* [ WORD 13 ]\n+     Operand vector.  NOTE!  This must always be the last field\n+     of this structure.  In particular, this means that this\n+     structure cannot be embedded inside another one.  */\n+  tree GTY((length (\"%h.membase.opbase.gsbase.num_ops\"))) op[1];\n+};\n+\n+\n /* OpenMP statements (#pragma omp).  */\n \n struct GTY(()) gimple_statement_omp {\n@@ -739,6 +759,7 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"))) gimple_statement_d {\n   struct gimple_statement_with_ops GTY ((tag (\"GSS_WITH_OPS\"))) gsops;\n   struct gimple_statement_with_memory_ops_base GTY ((tag (\"GSS_WITH_MEM_OPS_BASE\"))) gsmembase;\n   struct gimple_statement_with_memory_ops GTY ((tag (\"GSS_WITH_MEM_OPS\"))) gsmem;\n+  struct gimple_statement_call GTY ((tag (\"GSS_CALL\"))) gimple_call;\n   struct gimple_statement_omp GTY ((tag (\"GSS_OMP\"))) omp;\n   struct gimple_statement_bind GTY ((tag (\"GSS_BIND\"))) gimple_bind;\n   struct gimple_statement_catch GTY ((tag (\"GSS_CATCH\"))) gimple_catch;\n@@ -836,6 +857,7 @@ void gimple_seq_free (gimple_seq);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n gimple_seq gimple_seq_copy (gimple_seq);\n int gimple_call_flags (const_gimple);\n+void gimple_call_reset_alias_info (gimple);\n bool gimple_assign_copy_p (gimple);\n bool gimple_assign_ssa_name_copy_p (gimple);\n bool gimple_assign_single_p (gimple);\n@@ -2200,6 +2222,28 @@ gimple_call_copy_flags (gimple dest_call, gimple orig_call)\n }\n \n \n+/* Return a pointer to the points-to solution for the set of call-used\n+   variables of the call CALL.  */\n+\n+static inline struct pt_solution *\n+gimple_call_use_set (gimple call)\n+{\n+  GIMPLE_CHECK (call, GIMPLE_CALL);\n+  return &call->gimple_call.call_used;\n+}\n+\n+\n+/* Return a pointer to the points-to solution for the set of call-used\n+   variables of the call CALL.  */\n+\n+static inline struct pt_solution *\n+gimple_call_clobber_set (gimple call)\n+{\n+  GIMPLE_CHECK (call, GIMPLE_CALL);\n+  return &call->gimple_call.call_clobbered;\n+}\n+\n+\n /* Returns true if this is a GIMPLE_ASSIGN or a GIMPLE_CALL with a\n    non-NULL lhs.  */\n "}, {"sha": "578d2c19e80907efd073841d7491398c8acfe69a", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -29,6 +29,7 @@ DEFGSSTRUCT(GSS_BASE, gimple_statement_base, false)\n DEFGSSTRUCT(GSS_WITH_OPS, gimple_statement_with_ops, true)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS_BASE, gimple_statement_with_memory_ops_base, false)\n DEFGSSTRUCT(GSS_WITH_MEM_OPS, gimple_statement_with_memory_ops, true)\n+DEFGSSTRUCT(GSS_CALL, gimple_statement_call, true)\n DEFGSSTRUCT(GSS_ASM, gimple_statement_asm, true)\n DEFGSSTRUCT(GSS_BIND, gimple_statement_bind, false)\n DEFGSSTRUCT(GSS_PHI, gimple_statement_phi, false)"}, {"sha": "6afad5b612c2729d203e80debcf1d4b426d2d398", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -1157,6 +1157,10 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t}\n     }\n \n+  /* Reset alias information.  */\n+  if (code == GIMPLE_CALL)\n+    gimple_call_reset_alias_info (stmt);\n+\n   /* Fixup reference tree operands for substituted prevailing decls\n      with mismatched types.  */\n   maybe_fixup_decls (stmt);"}, {"sha": "bd91e3b60a872362fd578151e96fd4caabc0f923", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -284,8 +284,6 @@ dump_variable (FILE *file, tree var)\n \n   if (is_call_clobbered (var))\n     fprintf (file, \", call clobbered\");\n-  else if (is_call_used (var))\n-    fprintf (file, \", call used\");\n \n   if (ann && ann->noalias_state == NO_ALIAS)\n     fprintf (file, \", NO_ALIAS (does not alias other NO_ALIAS symbols)\");"}, {"sha": "2430f0355f7b4aca833bf9ce796886d3b8dda831", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -633,15 +633,6 @@ is_call_clobbered (const_tree var)\n \t      && pt_solution_includes (&cfun->gimple_df->escaped, var)));\n }\n \n-/* Return true if VAR is used by function calls.  */\n-static inline bool\n-is_call_used (const_tree var)\n-{\n-  return (is_call_clobbered (var)\n-\t  || (may_be_aliased (var)\n-\t      && pt_solution_includes (&cfun->gimple_df->callused, var)));\n-}\n-\n /*  -----------------------------------------------------------------------  */\n \n /* The following set of routines are used to iterator over various type of"}, {"sha": "82b810999bc6c521421843fbd688e7b08edec9c5", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -56,9 +56,6 @@ struct GTY(()) gimple_df {\n   /* The PTA solution for the ESCAPED artificial variable.  */\n   struct pt_solution escaped;\n \n-  /* The PTA solution for the CALLUSED artificial variable.  */\n-  struct pt_solution callused;\n-\n   /* A map of decls to artificial ssa-names that point to the partition\n      of the decl.  */\n   struct pointer_map_t * GTY((skip(\"\"))) decls_to_pointers;"}, {"sha": "922ce52dd9dbd1ed0444a6912ac2d189aca9d91b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -1391,6 +1391,13 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t\t  default:\n \t\t    break;\n \t\t  }\n+\n+\t      /* Reset alias info.\n+\t         ???  By maintaining DECL_PT_UID this should not\n+\t\t be necessary, but the plan is to only maintain\n+\t\t it when IPA-PTA was run.  It's not too easy to\n+\t\t detect this here ...  */\n+\t      gimple_call_reset_alias_info (copy);\n \t    }\n \t    break;\n \n@@ -3724,12 +3731,9 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   \t     cg_edge->frequency * REG_BR_PROB_BASE / CGRAPH_FREQ_BASE,\n \t     bb, return_block);\n \n-  /* Reset the escaped and callused solutions.  */\n+  /* Reset the escaped solution.  */\n   if (cfun->gimple_df)\n-    {\n-      pt_solution_reset (&cfun->gimple_df->escaped);\n-      pt_solution_reset (&cfun->gimple_df->callused);\n-    }\n+    pt_solution_reset (&cfun->gimple_df->escaped);\n \n   /* Clean up.  */\n   if (id->debug_map)"}, {"sha": "b85c5a76c67481716f2bd818ccaac146cf06b15b", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -307,7 +307,7 @@ dest_safe_for_nrv_p (tree dest)\n   if (TREE_CODE (dest) == SSA_NAME)\n     dest = SSA_NAME_VAR (dest);\n \n-  if (is_call_used (dest))\n+  if (is_call_clobbered (dest))\n     return false;\n \n   return true;"}, {"sha": "c4ac89b001abde290c31b63aadec8f8b8ffdc3a2", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -1977,13 +1977,10 @@ parallelize_loops (void)\n   htab_delete (reduction_list);\n \n   /* Parallelization will cause new function calls to be inserted through\n-     which local variables will escape.  Reset the points-to solutions\n-     for ESCAPED and CALLUSED.  */\n+     which local variables will escape.  Reset the points-to solution\n+     for ESCAPED.  */\n   if (changed)\n-    {\n-      pt_solution_reset (&cfun->gimple_df->escaped);\n-      pt_solution_reset (&cfun->gimple_df->callused);\n-    }\n+    pt_solution_reset (&cfun->gimple_df->escaped);\n \n   return changed;\n }"}, {"sha": "7f09df8d16c3a58a3825eb0a9dfa9c0e87b70ead", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -336,8 +336,6 @@ dump_alias_info (FILE *file)\n \n   fprintf (file, \"\\nESCAPED\");\n   dump_points_to_solution (file, &cfun->gimple_df->escaped);\n-  fprintf (file, \"\\nCALLUSED\");\n-  dump_points_to_solution (file, &cfun->gimple_df->callused);\n \n   fprintf (file, \"\\n\\nFlow-insensitive points-to information\\n\\n\");\n \n@@ -1070,51 +1068,24 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n \tgoto process_args;\n     }\n \n-  /* If the base variable is call-used or call-clobbered then\n-     it may be used.  */\n-  if (flags & (ECF_PURE|ECF_CONST|ECF_LOOPING_CONST_OR_PURE|ECF_NOVOPS))\n+  /* Check if the base variable is call-used.  */\n+  if (DECL_P (base))\n     {\n-      if (DECL_P (base))\n-\t{\n-\t  if (is_call_used (base))\n-\t    return true;\n-\t}\n-      else if (INDIRECT_REF_P (base)\n-\t       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-\t{\n-\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n-\t  if (!pi)\n-\t    return true;\n-\n-\t  if (pt_solution_includes_global (&pi->pt)\n-\t      || pt_solutions_intersect (&cfun->gimple_df->callused, &pi->pt)\n-\t      || pt_solutions_intersect (&cfun->gimple_df->escaped, &pi->pt))\n-\t    return true;\n-\t}\n-      else\n+      if (pt_solution_includes (gimple_call_use_set (call), base))\n \treturn true;\n     }\n-  else\n+  else if (INDIRECT_REF_P (base)\n+\t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n-      if (DECL_P (base))\n-\t{\n-\t  if (is_call_clobbered (base))\n-\t    return true;\n-\t}\n-      else if (INDIRECT_REF_P (base)\n-\t       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-\t{\n-\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n-\t  if (!pi)\n-\t    return true;\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n+      if (!pi)\n+\treturn true;\n \n-\t  if (pt_solution_includes_global (&pi->pt)\n-\t      || pt_solutions_intersect (&cfun->gimple_df->escaped, &pi->pt))\n-\t    return true;\n-\t}\n-      else\n+      if (pt_solutions_intersect (gimple_call_use_set (call), &pi->pt))\n \treturn true;\n     }\n+  else\n+    return true;\n \n   /* Inspect call arguments for passed-by-value aliases.  */\n process_args:\n@@ -1347,17 +1318,17 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n \treturn false;\n     }\n \n+  /* Check if the base variable is call-clobbered.  */\n   if (DECL_P (base))\n-    return is_call_clobbered (base);\n+    return pt_solution_includes (gimple_call_clobber_set (call), base);\n   else if (INDIRECT_REF_P (base)\n \t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n       if (!pi)\n \treturn true;\n \n-      return (pt_solution_includes_global (&pi->pt)\n-\t      || pt_solutions_intersect (&cfun->gimple_df->escaped, &pi->pt));\n+      return pt_solutions_intersect (gimple_call_clobber_set (call), &pi->pt);\n     }\n \n   return true;"}, {"sha": "e14b97a97f56fe3f907835b1d7b44b5e01d6b2fc", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -5480,6 +5480,7 @@ compute_points_to_sets (void)\n   basic_block bb;\n   unsigned i;\n   varinfo_t vi;\n+  struct pt_solution callused;\n \n   timevar_push (TV_TREE_PTA);\n \n@@ -5516,8 +5517,7 @@ compute_points_to_sets (void)\n      call-clobber analysis.  */\n   find_what_var_points_to (get_varinfo (escaped_id),\n \t\t\t   &cfun->gimple_df->escaped);\n-  find_what_var_points_to (get_varinfo (callused_id),\n-\t\t\t   &cfun->gimple_df->callused);\n+  find_what_var_points_to (get_varinfo (callused_id), &callused);\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -5541,6 +5541,48 @@ compute_points_to_sets (void)\n \tfind_what_p_points_to (ptr);\n     }\n \n+  /* Compute the call-used/clobbered sets.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  struct pt_solution *pt;\n+\t  if (!is_gimple_call (stmt))\n+\t    continue;\n+\n+\t  pt = gimple_call_use_set (stmt);\n+\t  if (gimple_call_flags (stmt) & ECF_CONST)\n+\t    memset (pt, 0, sizeof (struct pt_solution));\n+\t  else if (gimple_call_flags (stmt) & ECF_PURE)\n+\t    {\n+\t      /* For const calls we should now be able to compute the\n+\t\t call-used set per function.  */\n+\t      *pt = callused;\n+\t      /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t always escaped.  */\n+\t      pt->nonlocal = 1;\n+\t      pt->escaped = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      *pt = cfun->gimple_df->escaped;\n+\t      pt->nonlocal = 1;\n+\t    }\n+\n+\t  pt = gimple_call_clobber_set (stmt);\n+\t  if (gimple_call_flags (stmt) & (ECF_CONST|ECF_PURE|ECF_NOVOPS))\n+\t    memset (pt, 0, sizeof (struct pt_solution));\n+\t  else\n+\t    {\n+\t      *pt = cfun->gimple_df->escaped;\n+\t      pt->nonlocal = 1;\n+\t    }\n+\t}\n+    }\n+\n   timevar_pop (TV_TREE_PTA);\n }\n "}, {"sha": "7915bb88b222352967426cca104f7a9be88aeb1a", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -1123,7 +1123,6 @@ init_tree_ssa (struct function *fn)\n   fn->gimple_df->default_defs = htab_create_ggc (20, uid_ssaname_map_hash,\n \t\t\t\t                 uid_ssaname_map_eq, NULL);\n   pt_solution_reset (&fn->gimple_df->escaped);\n-  pt_solution_reset (&fn->gimple_df->callused);\n   init_ssanames (fn, 0);\n   init_phinodes ();\n }\n@@ -1163,7 +1162,6 @@ delete_tree_ssa (void)\n   htab_delete (cfun->gimple_df->default_defs);\n   cfun->gimple_df->default_defs = NULL;\n   pt_solution_reset (&cfun->gimple_df->escaped);\n-  pt_solution_reset (&cfun->gimple_df->callused);\n   if (cfun->gimple_df->decls_to_pointers != NULL)\n     pointer_map_destroy (cfun->gimple_df->decls_to_pointers);\n   cfun->gimple_df->decls_to_pointers = NULL;"}, {"sha": "e0d3f4844e98f006d59b71726f319eb53f65e310", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d086d3119d95e23154679e6c6ca43b0356fd92df/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=d086d3119d95e23154679e6c6ca43b0356fd92df", "patch": "@@ -136,11 +136,23 @@ suitable_for_tail_opt_p (void)\n   if (cfun->stdarg)\n     return false;\n \n-  /* No local variable nor structure field should be call-used.  */\n+  /* No local variable nor structure field should escape to callees.  */\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       if (!is_global_var (var)\n-\t  && is_call_used (var))\n+\t  /* ???  We do not have a suitable predicate for escaping to\n+\t     callees.  With IPA-PTA the following might be incorrect.\n+\t     We want to catch\n+\t       foo {\n+\t         int i;\n+\t\t bar (&i);\n+\t\t foo ();\n+\t       }\n+\t     where bar might store &i somewhere and in the next\n+\t     recursion should not be able to tell if it got the\n+\t     same (with tail-recursion applied) or a different\n+\t     address.  */\n+\t  && is_call_clobbered (var))\n \treturn false;\n     }\n \n@@ -430,7 +442,9 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   func = gimple_call_fndecl (call);\n   if (func == current_function_decl)\n     {\n-      tree arg;\n+      tree arg, var;\n+      referenced_var_iterator rvi;\n+\n       for (param = DECL_ARGUMENTS (func), idx = 0;\n \t   param && idx < gimple_call_num_args (call);\n \t   param = TREE_CHAIN (param), idx ++)\n@@ -460,6 +474,15 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t}\n       if (idx == gimple_call_num_args (call) && !param)\n \ttail_recursion = true;\n+\n+      /* Make sure the tail invocation of this function does not refer\n+\t to local variables.  */\n+      FOR_EACH_REFERENCED_VAR (var, rvi)\n+\t{\n+\t  if (!is_global_var (var)\n+\t      && ref_maybe_used_by_stmt_p (call, var))\n+\t    return;\n+\t}\n     }\n \n   /* Now check the statements after the call.  None of them has virtual"}]}