{"sha": "f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRiMTg5ZDUzYmJjNWRlZjQ3YzE3Y2RjMDRjMWM3ZmQyOTFmMjliMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-09-09T07:23:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-09-09T07:23:11Z"}, "message": "re PR c/67495 (#pragma omp atomic ICEs)\n\n\tPR c/67495\n\t* c-parser.c (c_parser_omp_atomic): Use c_parser_cast_expression\n\tinstead of c_parser_unary_expression.  If the result is !lvalue_p,\n\twrap the result of c_fully_fold into NON_LVALUE_EXPR.\n\n\t* gcc.dg/gomp/pr67495.c: New test.\n\nFrom-SVN: r227576", "tree": {"sha": "5f941573079243b9c93eaa04c1a90288a8a88bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f941573079243b9c93eaa04c1a90288a8a88bf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04e49571a086621e33261b8e25b35a577195f2d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e49571a086621e33261b8e25b35a577195f2d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04e49571a086621e33261b8e25b35a577195f2d6"}], "stats": {"total": 94, "additions": 84, "deletions": 10}, "files": [{"sha": "dadec059618e166473b4d4d1e0eda30111d398d5", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "patch": "@@ -1,3 +1,10 @@\n+2015-09-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/67495\n+\t* c-parser.c (c_parser_omp_atomic): Use c_parser_cast_expression\n+\tinstead of c_parser_unary_expression.  If the result is !lvalue_p,\n+\twrap the result of c_fully_fold into NON_LVALUE_EXPR.\n+\n 2015-09-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/67279"}, {"sha": "86ccbe7730c5fe91bab3db8f273c84e795dcd9c5", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "patch": "@@ -12422,6 +12422,7 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n   bool structured_block = false;\n   bool swapped = false;\n   bool seq_cst = false;\n+  bool non_lvalue_p;\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -12475,20 +12476,33 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n     {\n     case OMP_ATOMIC_READ:\n     case NOP_EXPR: /* atomic write */\n-      v = c_parser_unary_expression (parser).value;\n+      v = c_parser_cast_expression (parser, NULL).value;\n+      non_lvalue_p = !lvalue_p (v);\n       v = c_fully_fold (v, false, NULL);\n       if (v == error_mark_node)\n \tgoto saw_error;\n+      if (non_lvalue_p)\n+\tv = non_lvalue (v);\n       loc = c_parser_peek_token (parser)->location;\n       if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n \tgoto saw_error;\n       if (code == NOP_EXPR)\n-\tlhs = c_parser_expression (parser).value;\n+\t{\n+\t  lhs = c_parser_expression (parser).value;\n+\t  lhs = c_fully_fold (lhs, false, NULL);\n+\t  if (lhs == error_mark_node)\n+\t    goto saw_error;\n+\t}\n       else\n-\tlhs = c_parser_unary_expression (parser).value;\n-      lhs = c_fully_fold (lhs, false, NULL);\n-      if (lhs == error_mark_node)\n-\tgoto saw_error;\n+\t{\n+\t  lhs = c_parser_cast_expression (parser, NULL).value;\n+\t  non_lvalue_p = !lvalue_p (lhs);\n+\t  lhs = c_fully_fold (lhs, false, NULL);\n+\t  if (lhs == error_mark_node)\n+\t    goto saw_error;\n+\t  if (non_lvalue_p)\n+\t    lhs = non_lvalue (lhs);\n+\t}\n       if (code == NOP_EXPR)\n \t{\n \t  /* atomic write is represented by OMP_ATOMIC with NOP_EXPR\n@@ -12507,10 +12521,13 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n \t}\n       else\n \t{\n-\t  v = c_parser_unary_expression (parser).value;\n+\t  v = c_parser_cast_expression (parser, NULL).value;\n+\t  non_lvalue_p = !lvalue_p (v);\n \t  v = c_fully_fold (v, false, NULL);\n \t  if (v == error_mark_node)\n \t    goto saw_error;\n+\t  if (non_lvalue_p)\n+\t    v = non_lvalue (v);\n \t  if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n \t    goto saw_error;\n \t}\n@@ -12523,7 +12540,7 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n      old or new x should be captured.  */\n restart:\n   eloc = c_parser_peek_token (parser)->location;\n-  expr = c_parser_unary_expression (parser);\n+  expr = c_parser_cast_expression (parser, NULL);\n   lhs = expr.value;\n   expr = default_function_array_conversion (eloc, expr);\n   unfolded_lhs = expr.value;\n@@ -12616,6 +12633,8 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n \t}\n       /* FALLTHRU */\n     default:\n+      if (!lvalue_p (unfolded_lhs))\n+\tlhs = non_lvalue (lhs);\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_MULT_EQ:\n@@ -12730,20 +12749,25 @@ c_parser_omp_atomic (location_t loc, c_parser *parser)\n     {\n       if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n \tgoto saw_error;\n-      v = c_parser_unary_expression (parser).value;\n+      v = c_parser_cast_expression (parser, NULL).value;\n+      non_lvalue_p = !lvalue_p (v);\n       v = c_fully_fold (v, false, NULL);\n       if (v == error_mark_node)\n \tgoto saw_error;\n+      if (non_lvalue_p)\n+\tv = non_lvalue (v);\n       if (!c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n \tgoto saw_error;\n       eloc = c_parser_peek_token (parser)->location;\n-      expr = c_parser_unary_expression (parser);\n+      expr = c_parser_cast_expression (parser, NULL);\n       lhs1 = expr.value;\n       expr = default_function_array_read_conversion (eloc, expr);\n       unfolded_lhs1 = expr.value;\n       lhs1 = c_fully_fold (lhs1, false, NULL);\n       if (lhs1 == error_mark_node)\n \tgoto saw_error;\n+      if (!lvalue_p (unfolded_lhs1))\n+\tlhs1 = non_lvalue (lhs1);\n     }\n   if (structured_block)\n     {"}, {"sha": "4afb642ac93c9a78db13e277c8e6e04b881c090b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "patch": "@@ -1,3 +1,8 @@\n+2015-09-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/67495\n+\t* gcc.dg/gomp/pr67495.c: New test.\n+\n 2015-09-09  Aditya Kumar  <hiraditya@msn.com>\n             Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "1011a266972657fa67449dbee32bc6e473951039", "filename": "gcc/testsuite/gcc.dg/gomp/pr67495.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr67495.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b189d53bbc5def47c17cdc04c1c7fd291f29b1/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr67495.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr67495.c?ref=f4b189d53bbc5def47c17cdc04c1c7fd291f29b1", "patch": "@@ -0,0 +1,38 @@\n+/* PR c/67495 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int a, b, c;\n+\n+void\n+foo (void)\n+{\n+#pragma omp atomic capture\n+  a = (float)a + b;\t/* { dg-error \"invalid operator\" } */\n+#pragma omp atomic read\n+  (float) a = b;\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic write\n+  (float) a = b;\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic read\n+  a = (float) b;\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  (float) a = b += c;\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  { a += b; (float) c = a; }\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  { a += b; c = (float) a; }\t/* { dg-error \"uses two different expressions for memory\" } */\n+#pragma omp atomic capture\n+  a = (int)a + b;\t/* { dg-error \"invalid operator\" } */\n+#pragma omp atomic read\n+  (int) a = b;\t\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic write\n+  (int) a = b;\t\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic read\n+  a = (int) b;\t\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  (int) a = b += c;\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  { a += b; (int) c = a; }\t/* { dg-error \"lvalue required\" } */\n+#pragma omp atomic capture\n+  { a += b; c = (int) a; }\t/* { dg-error \"lvalue required\" } */\n+}"}]}