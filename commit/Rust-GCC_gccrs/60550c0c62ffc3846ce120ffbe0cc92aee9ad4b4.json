{"sha": "60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1NTBjMGM2MmZmYzM4NDZjZTEyMGZmYmUwY2M5MmFlZTlhZDRiNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-28T14:18:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-28T14:18:29Z"}, "message": "global.c (earlyclobber_regclass): Change the type to VEC(int,heap).\n\n\t* global.c (earlyclobber_regclass): Change the type to\n\tVEC(int,heap).\n\t(check_earlyclobber): Update uses of earlyclobber_regclass.\n\t(mark_reg_use_for_earlyclobber): Likewise.\n\t(calculate_local_reg_bb_info): Allocate and free\n\tearlyclobber_regclass using the VEC API.\n\nFrom-SVN: r98922", "tree": {"sha": "b8ec510c39a0dda2aba09142719909661f9c3693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8ec510c39a0dda2aba09142719909661f9c3693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4/comments", "author": null, "committer": null, "parents": [{"sha": "781e1004f3eee23f946442b7829118a11212898c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781e1004f3eee23f946442b7829118a11212898c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/781e1004f3eee23f946442b7829118a11212898c"}], "stats": {"total": 67, "additions": 46, "deletions": 21}, "files": [{"sha": "f1be015cedb2d680b26eb13ac95ff08732ea799f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "patch": "@@ -1,3 +1,12 @@\n+2005-04-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* global.c (earlyclobber_regclass): Change the type to\n+\tVEC(int,heap).\n+\t(check_earlyclobber): Update uses of earlyclobber_regclass.\n+\t(mark_reg_use_for_earlyclobber): Likewise.\n+\t(calculate_local_reg_bb_info): Allocate and free\n+\tearlyclobber_regclass using the VEC API.\n+\n 2005-04-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree-ssa-alias.c (push_fields_onto_fieldstack): Remove bogus"}, {"sha": "4771ef06d0fc86273f99130094d98f9f35b3a2a3", "filename": "gcc/global.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=60550c0c62ffc3846ce120ffbe0cc92aee9ad4b4", "patch": "@@ -2098,7 +2098,10 @@ mark_reg_change (rtx reg, rtx setter, void *data)\n /* Classes of registers which could be early clobbered in the current\n    insn.  */\n \n-static varray_type earlyclobber_regclass;\n+DEF_VEC_P(int);\n+DEF_VEC_ALLOC_P(int,heap);\n+\n+static VEC(int,heap) *earlyclobber_regclass;\n \n /* This function finds and stores register classes that could be early\n    clobbered in INSN.  If any earlyclobber classes are found, the function\n@@ -2112,7 +2115,7 @@ check_earlyclobber (rtx insn)\n \n   extract_insn (insn);\n \n-  VARRAY_POP_ALL (earlyclobber_regclass);\n+  VEC_truncate (int, earlyclobber_regclass, 0);\n   for (opno = 0; opno < recog_data.n_operands; opno++)\n     {\n       char c;\n@@ -2149,13 +2152,23 @@ check_earlyclobber (rtx insn)\n \t    case ',':\n \t      if (amp_p && class != NO_REGS)\n \t\t{\n+\t\t  int rc;\n+\n \t\t  found = true;\n-\t\t  for (i = VARRAY_ACTIVE_SIZE (earlyclobber_regclass) - 1;\n-\t\t       i >= 0; i--)\n-\t\t    if (VARRAY_INT (earlyclobber_regclass, i) == (int) class)\n-\t\t      break;\n-\t\t  if (i < 0)\n-\t\t    VARRAY_PUSH_INT (earlyclobber_regclass, (int) class);\n+\t\t  for (i = 0;\n+\t\t       VEC_iterate (int, earlyclobber_regclass, i, rc);\n+\t\t       i++)\n+\t\t    {\n+\t\t      if (rc == (int) class)\n+\t\t\tgoto found_rc;\n+\t\t    }\n+\n+\t\t  /* We use VEC_quick_push here because\n+\t\t     earlyclobber_regclass holds no more than\n+\t\t     N_REG_CLASSES elements. */\n+\t\t  VEC_quick_push (int, earlyclobber_regclass, (int) class);\n+\t\tfound_rc:\n+\t\t  ;\n \t\t}\n \t      \n \t      amp_p = false;\n@@ -2194,23 +2207,24 @@ mark_reg_use_for_earlyclobber (rtx *x, void *data ATTRIBUTE_UNUSED)\n \n   if (REG_P (*x) && REGNO (*x) >= FIRST_PSEUDO_REGISTER)\n     {\n+      int rc;\n+\n       regno = REGNO (*x);\n       if (bitmap_bit_p (bb_info->killed, regno)\n \t  || bitmap_bit_p (bb_info->avloc, regno))\n \treturn 0;\n       pref_class = reg_preferred_class (regno);\n       alt_class = reg_alternate_class (regno);\n-      for (i = VARRAY_ACTIVE_SIZE (earlyclobber_regclass) - 1; i >= 0; i--)\n-\tif (reg_classes_intersect_p (VARRAY_INT (earlyclobber_regclass, i),\n-\t\t\t\t     pref_class)\n-\t    || (VARRAY_INT (earlyclobber_regclass, i) != NO_REGS\n-\t\t&& reg_classes_intersect_p (VARRAY_INT (earlyclobber_regclass,\n-\t\t\t\t\t\t\ti),\n-\t\t\t\t\t    alt_class)))\n-\t  {\n-\t    bitmap_set_bit (bb_info->earlyclobber, regno);\n-\t    break;\n-\t  }\n+      for (i = 0; VEC_iterate (int, earlyclobber_regclass, i, rc); i++)\n+\t{\n+\t  if (reg_classes_intersect_p (rc, pref_class)\n+\t      || (rc != NO_REGS\n+\t\t  && reg_classes_intersect_p (rc, alt_class)))\n+\t    {\n+\t      bitmap_set_bit (bb_info->earlyclobber, regno);\n+\t      break;\n+\t    }\n+\t}\n     }\n   return 0;\n }\n@@ -2232,8 +2246,9 @@ calculate_local_reg_bb_info (void)\n   basic_block bb;\n   rtx insn, bound;\n \n-  VARRAY_INT_INIT (earlyclobber_regclass, 20,\n-\t\t   \"classes of registers early clobbered in an insn\");\n+  /* We know that earlyclobber_regclass holds no more than\n+    N_REG_CLASSES elements.  See check_earlyclobber.  */\n+  earlyclobber_regclass = VEC_alloc (int, heap, N_REG_CLASSES);\n   FOR_EACH_BB (bb)\n     {\n       bound = NEXT_INSN (BB_END (bb));\n@@ -2245,6 +2260,7 @@ calculate_local_reg_bb_info (void)\n \t      note_uses (&PATTERN (insn), mark_reg_use_for_earlyclobber_1, bb);\n \t  }\n     }\n+  VEC_free (int, heap, earlyclobber_regclass);\n }\n \n /* The function sets up reverse post-order number of each basic"}]}