{"sha": "22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlZWQxZTY3ODRhZjFkODhhNGUwZjE3NzNmMmQ2OTUyYzJjNDkzYw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-10-28T13:06:17Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-10-28T13:06:17Z"}, "message": "class.c (layout_class): Don't mangle <finit>, produce __finit<class> instead.\n\nWed Oct 28 08:03:31 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (layout_class): Don't mangle <finit>, produce\n \t__finit<class> instead. Don't verify artificial methods.\n\t* decl.c (finit_identifier_node): New declared global.\n\t(init_decl_processing): finit_identifier_node initialized.\n\t* java-tree.def (CONDITIONAL_EXPR): New Java tree code.\n\t* java-tree.h (finit_identifier_node): Declared as extern.\n\t(struct lang_decl): New field called_constructor.\n\t(DECL_CONSTRUCTOR_CALLS): Access macro to called_constructor.\n\t(CLASS_HAS_FINIT_P): New macro.\n\t(CALL_CONSTRUCTOR_P): Leading comment changed. Macro now checks\n \texplicit constructor invocation.\n\t(CALL_EXPLICIT_CONSTRUCTOR_P, CALL_THIS_CONSTRUCTOR_P,\n \tCALL_SUPER_CONSTRUCTOR_P): New macros.\n\t(write_classfile): Added prototype.\n\t* jcf-parse.c (jcf_parse_source): Parse and remember for\n \tgeneration if the file was seen on the command line.\n\t(parse_source_file): Don't write the class file here.\n\t(yyparse): Loop on files rewritten. Set current_jcf.\n\t(parse_zip_file_entries): Parse class file only if it was found.\n\t* lang.c (init_parse): Don't open command line provided filename\n \there.\n\t(lang_parse): Don't set main_jcf anymore.\n\t* parse.h (ABSTRAC_CHECK): Capitalized arguments.\n\t(JCONSTRUCTOR_CHECK): New macro.\n\t(JBSC_TYPE_P): New macro.\n\t(IN_TRY_BLOCK_P, EXCEPTIONS_P): Fixed leading comment.\n\t(COMPLETE_CHECK_OP_2): New macro.\n\t(struct parse_ctxt): New field explicit_constructor_p.\n\t(check_class_interface_creation): Fixed prototype indentation.\n\t(patch_method_invocation_stmt): Prototype reflects added argument.\n\t(patch_invoke): Likewise.\n\t(complete_method_declaration, build_super_invocation,\n \tverify_constructor_circularity,\n \tbuild_this_super_qualified_invocation, get_printable_method_name,\n \tpatch_conditional_expr, maybe_generate_finit, fix_constructors,\n \tverify_constructor_super, create_artificial_method,\n \tstart_artificial_method_body, end_artificial_method_body,\n \tgenerate_field_initialization_code): New function prototypes.\n\t* parse.y: Fixed leading comment\n\t(constructor_header:, constructor_body:, block_end:): Rules tagged\n \t<node>.\n\t(type_declaration:): Call maybe_generate_finit.\n\t(method_declaration:): Action for method_body: placed in new\n \tfunction complete_method_declaration, called here.\n\t(constructor_declaration:): Defined actions. Removed leading\n \tFIXME.\n\t(constructor_header:): New rule with action.\n\t(constructor_body:): Rule rewritten using block_begin: and\n \tblock_end:. Defined actions.\n\t(constructor_declarator:, explicit_constructor_invocation:):\n \tDefined actions.\n\t(block:): Use new rules block_begin: block_end:.\n\t(block_begin:, block_end:): New rules and actions.\n\t(block_statements:): Fixed error message for explicit\n \tconstructors.\n\t(method_invocation:): Call build_this_super_qualified_invocation\n \tif primary is `this' or `super' was seen.\n\t(conditional_expression:): Action defined.\n\t(extra_ctxp_pushed_p): New static global flag.\n\t(java_parser_context_save_global): Create parser context if\n \tnecessary. Use extra_ctxp_pushed_p to remember it.\n\t(java_parser_context_restore_global): Pop extra parser context if\n \tone exists.\n\t(build_array_from_name): Array on primitive types are marked\n \tloaded.\n\t(register_fields): Restore new name in field initializer\n \texpression if type was altered. Non static fields initialized upon\n \tdeclaration marked initialized.\n\t(maybe_generate_finit): New function.\n\t(maybe_generate_clinit): Use create_artificial_method,\n \tstart_artificial_method_body, end_artificial_method_body. Generate\n \tdebug info for enclosed initialization statements.\n\t(method_header): Fixed leading comment. Check constructor\n \tflags. Detect constructor declarations and set DECL_CONSTRUCTOR_P\n \taccordingly.\n\t(complete_method_declaration, constructor_circularity_msg,\n \tverify_constructor_circularity): New functions.\n\t(get_printable_method_name): New function.\n\t(check_method_redefinition): Don't rename <finit> methods. Fix\n \tdeclared constructor names. Error message for\n \tconstructors modified.\n\t(java_check_regular_methods): Local variable seen_constructor\n \trenamed saw_constructor. Skip verification on constructors. Create\n \tdefault constructor with create_artificial_method.\n\t(java_check_methods): Removed unnecessary empty line.\n\t(create_artificial_method, start_artificial_method_body,\n \tend_artificial_method_body): New functions.\n\t(java_layout_classes): Changed leading comment. Reverse fields\n \tlist if necessary. Always layout java.lang.Object if being\n \tdefined.\n\t(java_complete_expand_methods): Verify constructor circularity.\n\t(java_complete_expand_method): Call fix_constructor on\n \tconstructors.  Local variable no_ac_found removed. Restore\n \tbindings if method body expansion failed.\n\t(fix_constructors, verify_constructor_super,\n \tgenerate_field_initialization_code): New function.\n\t(java_expand_classes): Fixed leading comment. Write class file\n \there.\n\t(resolve_expression_name): Check for illegal instance variable\n \tusage within the argument scope of an explicit constructor\n \tinvocation.\n\t(resolve_qualified_expression_name): Pass extra from_super flag\n \twhen invoking patch_method_invocation_stmt. New case for\n \tconditional expression when used as a primary. Check for error\n \twhen acquiring super.\n\t(patch_method_invocation_stmt): Added extra argument super. New\n \tlocal variable is_static_flag. Set class_to_search according to\n \tthe nature of the constructor invocation. Don't add `this'\n \targument when expanding NEW_CLASS_EXPR. Check for illegal method\n \tinvocation within the argument scope of explicit constructor\n \tinvocation. Set is_static according to is_static_flag. Provide\n \textra `super' argument to patch_invoke invocation.\n\t(patch_invoke): New argument from_super. Loop on arguments\n \tindentation fixed. Pass from_super to invocation_mode. New switch\n \tcase INVOKE_SUPER. Fixed error message in switch default case.\n  \tDon't use CALL_CONSTRUCTOR_P but rather a test on the tree node\n \tvalue.\n\t(invocation_mode): Return INVOKE_SUPER mode when appropriate.\n\t(lookup_method_invoke): Fixed prototypes in candidates list. Error\n \tmessage takes constructors into account.\n\t(find_applicable_accessible_methods_list): Fixed indentation.\n\t(qualify_ambiguous_name): Take explicit constructor invocation\n \tinto account. Deal with a conditional expression as a primary to\n \ta method call.\n\t(java_complete_tree): Added local wfl_op3. New CONDITIONAL_EXPR\n \tcase. Added extra argument to patch_method_invocation_stmt.\n \tRegister calls made to explicit constructor `this'. Don't call\n \tsave_expr in ARRAY_REF case when emitting class files. Check for\n \tillegal use of this when expanding explicit constructor invocation\n \targuments.\n\t(complete_function_arguments): Set and reset parser context\n \texplicit_constructor_p field value when appropriate.\n\t(build_super_invocation, build_this_super_qualified_invocation):\n \tNew functions.\n\t(patch_assignment): Fixed typo.\n\t(patch_unaryop): Check on final fields occurs only when a decl\n \texits.\n\t(patch_return): Take constructors into account.\n\t(patch_conditional_expr): New function.\n\t* typeck.c (build_java_signature): Removed unnecessary empty line.\nThis patch implements the conditional operator, fixes the super\ninvokation mode, implements most of what is required for constructors\nand changes the way source files are handled by the front-end.\n\nFrom-SVN: r23403", "tree": {"sha": "1e2db7c201bd3c8f9335f1992e5cdc9df79988e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e2db7c201bd3c8f9335f1992e5cdc9df79988e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/comments", "author": null, "committer": null, "parents": [{"sha": "a05273d4c812079f544e9777438354d1904c0f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05273d4c812079f544e9777438354d1904c0f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05273d4c812079f544e9777438354d1904c0f87"}], "stats": {"total": 6591, "additions": 4009, "deletions": 2582}, "files": [{"sha": "2f4383ed21c5a58e2aa3a746cd9fd055e3004961", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -1,3 +1,146 @@\n+Wed Oct 28 08:03:31 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class): Don't mangle <finit>, produce\n+ \t__finit<class> instead. Don't verify artificial methods.\n+\t* decl.c (finit_identifier_node): New declared global.\n+\t(init_decl_processing): finit_identifier_node initialized.\n+\t* java-tree.def (CONDITIONAL_EXPR): New Java tree code.\n+\t* java-tree.h (finit_identifier_node): Declared as extern.\n+\t(struct lang_decl): New field called_constructor.\n+\t(DECL_CONSTRUCTOR_CALLS): Access macro to called_constructor.\n+\t(CLASS_HAS_FINIT_P): New macro.\n+\t(CALL_CONSTRUCTOR_P): Leading comment changed. Macro now checks\n+ \texplicit constructor invocation.\n+\t(CALL_EXPLICIT_CONSTRUCTOR_P, CALL_THIS_CONSTRUCTOR_P,\n+ \tCALL_SUPER_CONSTRUCTOR_P): New macros.\n+\t(write_classfile): Added prototype.\n+\t* jcf-parse.c (jcf_parse_source): Parse and remember for\n+ \tgeneration if the file was seen on the command line.\n+\t(parse_source_file): Don't write the class file here.\n+\t(yyparse): Loop on files rewritten. Set current_jcf.\n+\t(parse_zip_file_entries): Parse class file only if it was found.\n+\t* lang.c (init_parse): Don't open command line provided filename\n+ \there.\n+\t(lang_parse): Don't set main_jcf anymore.\n+\t* parse.h (ABSTRAC_CHECK): Capitalized arguments.\n+\t(JCONSTRUCTOR_CHECK): New macro.\n+\t(JBSC_TYPE_P): New macro.\n+\t(IN_TRY_BLOCK_P, EXCEPTIONS_P): Fixed leading comment.\n+\t(COMPLETE_CHECK_OP_2): New macro.\n+\t(struct parse_ctxt): New field explicit_constructor_p.\n+\t(check_class_interface_creation): Fixed prototype indentation.\n+\t(patch_method_invocation_stmt): Prototype reflects added argument.\n+\t(patch_invoke): Likewise.\n+\t(complete_method_declaration, build_super_invocation,\n+ \tverify_constructor_circularity,\n+ \tbuild_this_super_qualified_invocation, get_printable_method_name,\n+ \tpatch_conditional_expr, maybe_generate_finit, fix_constructors,\n+ \tverify_constructor_super, create_artificial_method,\n+ \tstart_artificial_method_body, end_artificial_method_body,\n+ \tgenerate_field_initialization_code): New function prototypes.\n+\t* parse.y: Fixed leading comment\n+\t(constructor_header:, constructor_body:, block_end:): Rules tagged\n+ \t<node>.\n+\t(type_declaration:): Call maybe_generate_finit.\n+\t(method_declaration:): Action for method_body: placed in new\n+ \tfunction complete_method_declaration, called here.\n+\t(constructor_declaration:): Defined actions. Removed leading\n+ \tFIXME.\n+\t(constructor_header:): New rule with action.\n+\t(constructor_body:): Rule rewritten using block_begin: and\n+ \tblock_end:. Defined actions.\n+\t(constructor_declarator:, explicit_constructor_invocation:):\n+ \tDefined actions.\n+\t(block:): Use new rules block_begin: block_end:.\n+\t(block_begin:, block_end:): New rules and actions.\n+\t(block_statements:): Fixed error message for explicit\n+ \tconstructors.\n+\t(method_invocation:): Call build_this_super_qualified_invocation\n+ \tif primary is `this' or `super' was seen.\n+\t(conditional_expression:): Action defined.\n+\t(extra_ctxp_pushed_p): New static global flag.\n+\t(java_parser_context_save_global): Create parser context if\n+ \tnecessary. Use extra_ctxp_pushed_p to remember it.\n+\t(java_parser_context_restore_global): Pop extra parser context if\n+ \tone exists.\n+\t(build_array_from_name): Array on primitive types are marked\n+ \tloaded.\n+\t(register_fields): Restore new name in field initializer\n+ \texpression if type was altered. Non static fields initialized upon\n+ \tdeclaration marked initialized.\n+\t(maybe_generate_finit): New function.\n+\t(maybe_generate_clinit): Use create_artificial_method,\n+ \tstart_artificial_method_body, end_artificial_method_body. Generate\n+ \tdebug info for enclosed initialization statements.\n+\t(method_header): Fixed leading comment. Check constructor\n+ \tflags. Detect constructor declarations and set DECL_CONSTRUCTOR_P\n+ \taccordingly.\n+\t(complete_method_declaration, constructor_circularity_msg,\n+ \tverify_constructor_circularity): New functions.\n+\t(get_printable_method_name): New function.\n+\t(check_method_redefinition): Don't rename <finit> methods. Fix\n+ \tdeclared constructor names. Error message for\n+ \tconstructors modified.\n+\t(java_check_regular_methods): Local variable seen_constructor\n+ \trenamed saw_constructor. Skip verification on constructors. Create\n+ \tdefault constructor with create_artificial_method.\n+\t(java_check_methods): Removed unnecessary empty line.\n+\t(create_artificial_method, start_artificial_method_body,\n+ \tend_artificial_method_body): New functions.\n+\t(java_layout_classes): Changed leading comment. Reverse fields\n+ \tlist if necessary. Always layout java.lang.Object if being\n+ \tdefined.\n+\t(java_complete_expand_methods): Verify constructor circularity.\n+\t(java_complete_expand_method): Call fix_constructor on\n+ \tconstructors.  Local variable no_ac_found removed. Restore\n+ \tbindings if method body expansion failed.\n+\t(fix_constructors, verify_constructor_super,\n+ \tgenerate_field_initialization_code): New function.\n+\t(java_expand_classes): Fixed leading comment. Write class file\n+ \there.\n+\t(resolve_expression_name): Check for illegal instance variable\n+ \tusage within the argument scope of an explicit constructor\n+ \tinvocation.\n+\t(resolve_qualified_expression_name): Pass extra from_super flag\n+ \twhen invoking patch_method_invocation_stmt. New case for\n+ \tconditional expression when used as a primary. Check for error\n+ \twhen acquiring super.\n+\t(patch_method_invocation_stmt): Added extra argument super. New\n+ \tlocal variable is_static_flag. Set class_to_search according to\n+ \tthe nature of the constructor invocation. Don't add `this'\n+ \targument when expanding NEW_CLASS_EXPR. Check for illegal method\n+ \tinvocation within the argument scope of explicit constructor\n+ \tinvocation. Set is_static according to is_static_flag. Provide\n+ \textra `super' argument to patch_invoke invocation.\n+\t(patch_invoke): New argument from_super. Loop on arguments\n+ \tindentation fixed. Pass from_super to invocation_mode. New switch\n+ \tcase INVOKE_SUPER. Fixed error message in switch default case.\n+  \tDon't use CALL_CONSTRUCTOR_P but rather a test on the tree node\n+ \tvalue.\n+\t(invocation_mode): Return INVOKE_SUPER mode when appropriate.\n+\t(lookup_method_invoke): Fixed prototypes in candidates list. Error\n+ \tmessage takes constructors into account.\n+\t(find_applicable_accessible_methods_list): Fixed indentation.\n+\t(qualify_ambiguous_name): Take explicit constructor invocation\n+ \tinto account. Deal with a conditional expression as a primary to\n+ \ta method call.\n+\t(java_complete_tree): Added local wfl_op3. New CONDITIONAL_EXPR\n+ \tcase. Added extra argument to patch_method_invocation_stmt.\n+ \tRegister calls made to explicit constructor `this'. Don't call\n+ \tsave_expr in ARRAY_REF case when emitting class files. Check for\n+ \tillegal use of this when expanding explicit constructor invocation\n+ \targuments.\n+\t(complete_function_arguments): Set and reset parser context\n+ \texplicit_constructor_p field value when appropriate.\n+\t(build_super_invocation, build_this_super_qualified_invocation):\n+ \tNew functions.\n+\t(patch_assignment): Fixed typo.\n+\t(patch_unaryop): Check on final fields occurs only when a decl\n+ \texits.\n+\t(patch_return): Take constructors into account.\n+\t(patch_conditional_expr): New function.\n+\t* typeck.c (build_java_signature): Removed unnecessary empty line.\n+\t\n Wed Oct 28 00:46:15 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (jcf-dump, gcjh): Link in $(LIBS) too."}, {"sha": "4a382b99506ca52d37ed9ed00ade52fef3b27ac7", "filename": "gcc/java/class.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -1400,7 +1400,8 @@ layout_class (this_class)\n \t{\n \t  int len;  tree arg, arglist, t;\n \t  int method_name_needs_escapes = 0;\n-\t  if (method_name != init_identifier_node)\n+\t  if (method_name != init_identifier_node \n+\t      && method_name != finit_identifier_node)\n \t    {\n \t      int encoded_len\n \t\t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n@@ -1421,6 +1422,8 @@ layout_class (this_class)\n \t    }\n \n \t  obstack_grow (&temporary_obstack, \"__\", 2);\n+\t  if (method_name == finit_identifier_node)\n+\t    obstack_grow (&temporary_obstack, \"finit\", 5);\n \t  append_gpp_mangled_type (&temporary_obstack, this_class);\n \t  TREE_PUBLIC (method_decl) = 1;\n \n@@ -1492,7 +1495,7 @@ layout_class (this_class)\n \t  DECL_NAME (method_decl) = get_identifier (p);\n \t  DECL_CONSTRUCTOR_P (method_decl) = 1;\n \t}\n-      else if (! METHOD_STATIC (method_decl))\n+      else if (! METHOD_STATIC (method_decl) && !DECL_ARTIFICIAL (method_decl))\n \t{\n \t  tree method_sig = build_java_argument_signature (TREE_TYPE (method_decl));\n \t  tree super_method = lookup_argument_method (super_class, method_name,"}, {"sha": "a49f22b31fd874a96018c4d2a78d1c36cbb80c74", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -325,6 +325,7 @@ tree boolean_true_node, boolean_false_node;\n tree TYPE_identifier_node;\n tree init_identifier_node;\n tree clinit_identifier_node;\n+tree finit_identifier_node;\n tree void_signature_node;\n tree length_identifier_node;\n tree this_identifier_node;\n@@ -533,6 +534,7 @@ init_decl_processing ()\n   TYPE_identifier_node = get_identifier (\"TYPE\");\n   init_identifier_node = get_identifier (\"<init>\");\n   clinit_identifier_node = get_identifier (\"<clinit>\");\n+  finit_identifier_node = get_identifier (\"<finit>\");\n   void_signature_node = get_identifier (\"()V\");\n   length_identifier_node = get_identifier (\"length\");\n   this_identifier_node = get_identifier (\"this\");"}, {"sha": "5bd63c4ec69b23c10b450c21b1331d06e1e5c8ff", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -64,3 +64,9 @@ DEFTREECODE (SYNCHRONIZED_EXPR, \"synchronized\", 'e', 2)\n /* Throw statement.\n    Operand 0 is the throw expresion.  */\n DEFTREECODE (THROW_EXPR, \"throw\", '1', 1)\n+\n+/* Conditional operator.\n+   Operand 0 is the condition expression\n+   Operand 1 is the then-value\n+   Operand 2 is the else-value.  */\n+DEFTREECODE (CONDITIONAL_EXPR, \"?:\", 'e', 3)"}, {"sha": "711e4414e2cfa1288b8233a7d03207d8c39bc880", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -61,6 +61,7 @@ struct JCF;\n    3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n    4: CLASS_P (in RECORD_TYPE).\n    5: CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P (in RECORD_TYPE)\n+   6: CLASS_HAS_FINIT_P (in RECORD_TYPE)\n \n    Usage of DECL_LANG_FLAG_?:\n    1: METHOD_PUBLIC (in FUNCTION_DECL).\n@@ -195,6 +196,7 @@ extern tree string_array_type_node;\n extern tree TYPE_identifier_node;      /* \"TYPE\" */\n extern tree init_identifier_node;      /* \"<init>\" */\n extern tree clinit_identifier_node;      /* \"<clinit>\" */\n+extern tree finit_identifier_node;      /* \"<finit>\" */\n extern tree void_signature_node;       /* \"()V\" */\n extern tree length_identifier_node;  /* \"length\" */\n extern tree this_identifier_node;  /* \"this\" */\n@@ -324,6 +326,10 @@ struct lang_identifier\n /* List of checked thrown exceptions, as specified with the `throws'\n    keyword */\n #define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->throws_list)\n+/* List of other constructors of the same class that this constructor\n+   calls */\n+#define DECL_CONSTRUCTOR_CALLS(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->called_constructor)\n /* Pointer to the function's current's COMPOUND_EXPR tree (while\n    completing its body) or the function's block */\n #define DECL_FUNCTION_BODY(DECL) (DECL_LANG_SPECIFIC(DECL)->function_decl_body)\n@@ -403,6 +409,8 @@ struct lang_decl\n   int max_locals, max_stack, arg_slot_count;\n   tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n+  tree called_constructor;\t/* When decl is a constructor, the\n+\t\t\t\t   list of other constructor it calls. */\n };\n \n /* DECL_LANG_SPECIFIC for VAR_DECL and PARM_DECL. */\n@@ -524,6 +532,7 @@ extern void register_class PROTO (());\n extern int alloc_name_constant PROTO ((int, tree));\n extern void emit_register_classes PROTO (());\n extern void lang_init_source PROTO ((int));\n+extern void write_classfile PROTO ((tree));\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n@@ -661,6 +670,9 @@ extern tree *type_map;\n #define CLASS_FROM_CURRENTLY_COMPILED_SOURCE_P(TYPE) \\\n   TYPE_LANG_FLAG_5 (TYPE)\n \n+/* True if class TYPE has a field initializer <finit> function */\n+#define CLASS_HAS_FINIT_P(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+\n /* True if identifier ID was seen while processing a single type import stmt */\n #define IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P(ID) TREE_LANG_FLAG_0 (ID)\n \n@@ -754,8 +766,20 @@ extern tree *type_map;\n #define FINISH_RECORD_CONSTRUCTOR(CONS) \\\n   CONSTRUCTOR_ELTS(CONS) = nreverse (CONSTRUCTOR_ELTS(CONS))\n \n-/* Macro(s) using the definitions above */\n-#define CALL_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == NEW_CLASS_EXPR)\n+/* Macros on constructors invocations.  */\n+#define CALL_CONSTRUCTOR_P(NODE)\t\t\\\n+  (TREE_CODE (NODE) == NEW_CLASS_EXPR || CALL_EXPLICIT_CONSTRUCTOR_P (NODE))\n+\n+#define CALL_EXPLICIT_CONSTRUCTOR_P(NODE)\t\t\t\t\\\n+  (CALL_THIS_CONSTRUCTOR_P (NODE) || CALL_SUPER_CONSTRUCTOR_P (NODE))\n+\n+#define CALL_THIS_CONSTRUCTOR_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == CALL_EXPR\t\t\t\t\t\\\n+   && EXPR_WFL_NODE (TREE_OPERAND (NODE, 0)) == this_identifier_node)\n+\n+#define CALL_SUPER_CONSTRUCTOR_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == CALL_EXPR\t\t\t\t\t\\\n+   && EXPR_WFL_NODE (TREE_OPERAND (NODE, 0)) == super_identifier_node)\n \n /* Using a FINALLY_EXPR node */\n #define FINALLY_EXPR_LABEL(NODE) TREE_OPERAND ((NODE), 0)"}, {"sha": "0761362b454d83d7d8422d54307ea830ee1a2bd6", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -506,13 +506,14 @@ int\n jcf_parse_source (jcf)\n      JCF *jcf;\n {\n+  tree filename = get_identifier (input_filename);\n   java_parser_context_save_global ();\n \n   input_filename = current_jcf->filename;\n   if (!(finput = fopen (input_filename, \"r\")))\n     fatal (\"input file `%s' just disappeared - jcf_parse_source\",\n \t   input_filename);\n-  parse_source_file (1);\t/* Parse only */\n+  parse_source_file (IS_A_COMMAND_LINE_FILENAME_P (filename));\n   java_parser_context_restore_global ();\n }\n \n@@ -686,9 +687,6 @@ parse_source_file (parse_only)\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n \n-  if (flag_emit_class_files)\n-    write_classfile (current_class);\n-\n   /* If only parsing, make sure that the currently parsed file isn't\n      also present in the argument list. If it's the case, remember\n      that we should generate it. */\n@@ -737,33 +735,35 @@ yyparse ()\n     }\n   while (next);\n \n+  current_jcf = main_jcf;\n   current_file_list = nreverse (current_file_list);\n   for (node = current_file_list; node; node = TREE_CHAIN (node))\n     {\n-      /* Don't substitute if INPUT_FILENAME doesn't feature the &\n-         separator: we have only one file to deal with, we're fine */\n-      if (several_files)\n-\t{\n-\t  tree name = TREE_VALUE (node);\n+      tree name = TREE_VALUE (node);\n \n-\t  /* Skip already parsed files */\n-\t  if (HAS_BEEN_ALREADY_PARSED_P (name))\n-\t    continue;\n-\n-\t  /* Close previous descriptor, if any */\n-\t  if (main_jcf->read_state && fclose (main_jcf->read_state))\n-\t    fatal (\"failed to close input file `%s' - yyparse\",\n-\t\t   (main_jcf->filename ? main_jcf->filename : \"<unknown>\"));\n-\n-\t  /* Open new file */\n-\t  main_jcf->read_state = fopen (IDENTIFIER_POINTER (name), \"r\");\n-\t  if (main_jcf->read_state == NULL)\n-\t    pfatal_with_name (IDENTIFIER_POINTER (name));\n-\n-\t  /* Set new input_filename and finput */\n-\t  input_filename = IDENTIFIER_POINTER (name);\n-\t  finput = main_jcf->read_state;\n-\t}\n+      /* Skip already parsed files */\n+      if (HAS_BEEN_ALREADY_PARSED_P (name))\n+\tcontinue;\n+      \n+      /* Close previous descriptor, if any */\n+      if (main_jcf->read_state && fclose (main_jcf->read_state))\n+\tfatal (\"failed to close input file `%s' - yyparse\",\n+\t       (main_jcf->filename ? main_jcf->filename : \"<unknown>\"));\n+      \n+      /* Set jcf up and open a new file */\n+      JCF_ZERO (main_jcf);\n+      main_jcf->read_state = fopen (IDENTIFIER_POINTER (name), \"r\");\n+      if (main_jcf->read_state == NULL)\n+\tpfatal_with_name (IDENTIFIER_POINTER (name));\n+      \n+      /* Set new input_filename and finput */\n+      finput = main_jcf->read_state;\n+#ifdef IO_BUFFER_SIZE\n+      setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE),\n+\t       _IOFBF, IO_BUFFER_SIZE);\n+#endif\n+      input_filename = IDENTIFIER_POINTER (name);\n+      main_jcf->filbuf = jcf_filbuf_from_stdio;\n \n       switch (jcf_figure_file_type (current_jcf))\n \t{\n@@ -813,14 +813,16 @@ parse_zip_file_entries (void)\n \t  jcf_parse (current_jcf);\n \t}\n \n-      input_filename = current_jcf->filename;\n-\n-      parse_class_file ();\n-      FREE (current_jcf->buffer); /* No longer necessary */\n-      /* Note: there is a way to free this buffer right after a class seen\n-\t in a zip file has been parsed. The idea is the set its jcf in such\n-\t a way that buffer will be reallocated the time the code for the class\n-\t will be generated. FIXME.  */\n+      if (TYPE_SIZE (current_class) != error_mark_node)\n+\t{\n+\t  input_filename = current_jcf->filename;\n+\t  parse_class_file ();\n+\t  FREE (current_jcf->buffer); /* No longer necessary */\n+\t  /* Note: there is a way to free this buffer right after a\n+\t     class seen in a zip file has been parsed. The idea is the\n+\t     set its jcf in such a way that buffer will be reallocated\n+\t     the time the code for the class will be generated. FIXME. */\n+\t}\n     }\n }\n "}, {"sha": "14c0ed3787df36b0a1d24c8ede7501d349b38b61", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -259,15 +259,7 @@ init_parse (filename)\n \t      free (buf);\n \t    }\n \t}\n-\n-      finput = fopen (filename, \"r\");\n     }\n-  if (finput == 0)\n-    pfatal_with_name (filename);\n-\n-#ifdef IO_BUFFER_SIZE\n-  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n-#endif\n   init_lex ();\n \n   return filename;\n@@ -454,11 +446,6 @@ lang_init ()\n   print_error_function = lang_print_error;\n   lang_expand_expr = java_lang_expand_expr;\n \n-  JCF_ZERO (main_jcf);\n-  main_jcf->read_state = finput;\n-  main_jcf->filbuf = jcf_filbuf_from_stdio;\n-  current_jcf = main_jcf;\n-\n   flag_exceptions = 1;\n \n   /* Append to Gcc tree node definition arrays */"}, {"sha": "2775f3cacba51ef8cfe09f1440e37b98b5cde1c8", "filename": "gcc/java/parse.c", "status": "modified", "additions": 2902, "deletions": 2291, "changes": 5193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c"}, {"sha": "bb9477ab265919bfe3695558929b64cf7b3ee846", "filename": "gcc/java/parse.h", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -99,10 +99,14 @@ extern tree stabilize_reference PROTO ((tree));\n       count++;\t\t\t\t\t\t\t\t\\\n     }\n \n-#define ABSTRACT_CHECK(flag, v, cl, s)\t\t\t\t\\\n-  if ((flag) & (v))\t\t\t\t\t\t\\\n-    parse_error_context (cl, s \" method can't be abstract\");\n-\n+#define ABSTRACT_CHECK(FLAG, V, CL, S)\t\t\t\t\\\n+  if ((FLAG) & (V))\t\t\t\t\t\t\\\n+    parse_error_context ((CL), S \" method can't be abstract\");\n+\n+#define JCONSTRUCTOR_CHECK(FLAG, V, CL, S)\t\t\t\\\n+  if ((FLAG) & (V))\t\t\t\t\t\t\\\n+    parse_error_context ((CL), \"Constructor can't be %s\", (S));\t\\\n+      \n /* Misc. */\n #define exit_java_complete_class()\t\t\\\n   {\t\t\t\t\t\t\\\n@@ -159,6 +163,10 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t\t\t  && (JNUMERIC_TYPE_P ((TYPE))\t\t  \\\n \t\t\t\t  || TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n \n+#define JBSC_TYPE_P(TYPE) ((TYPE) && (((TYPE) == byte_type_node)\t\\\n+\t\t\t\t      || ((TYPE) == short_type_node)\t\\\n+\t\t\t\t      || ((TYPE) == char_type_node)))\n+\n /* Not defined in the LRM */\n #define JSTRING_TYPE_P(TYPE) ((TYPE) \t\t\t\t\t   \\\n \t\t\t      && ((TYPE) == string_type_node ||\t\t   \\\n@@ -269,17 +277,16 @@ extern tree stabilize_reference PROTO ((tree));\n #define POP_EXCEPTIONS()\t\t\t\t\t\t\\\n   currently_caught_type_list = TREE_CHAIN (currently_caught_type_list)\n \n-/* Check that we're inside a try block */\n+/* Check that we're inside a try block.  */\n #define IN_TRY_BLOCK_P()\t\t\t\t\\\n   (currently_caught_type_list \t\t\t\t\\\n    && ((TREE_VALUE (currently_caught_type_list) !=\t\\\n \tDECL_FUNCTION_THROWS (current_function_decl))\t\\\n        || TREE_CHAIN (currently_caught_type_list)))\n \n-/* Check that we have exceptions in E */\n+/* Check that we have exceptions in E.  */\n #define EXCEPTIONS_P(E) ((E) ? TREE_VALUE (E) : NULL_TREE)\n \n-\n /* Invocation modes, as returned by invocation_mode (). */\n enum {\n   INVOKE_STATIC,\n@@ -462,6 +469,7 @@ static jdeplist *reverse_jdep_list ();\n }\n #define COMPLETE_CHECK_OP_0(NODE) COMPLETE_CHECK_OP(NODE, 0)\n #define COMPLETE_CHECK_OP_1(NODE) COMPLETE_CHECK_OP(NODE, 1)\n+#define COMPLETE_CHECK_OP_2(NODE) COMPLETE_CHECK_OP(NODE, 2)\n \n /* Building invocations: append(ARG) and StringBuffer(ARG) */\n #define BUILD_APPEND(ARG)\t\t\t\t\t\t     \\\n@@ -567,6 +575,12 @@ struct parser_ctxt {\n \t\t\t\t\tlabeled blocks. */\n \n   int pending_block;\t\t     /* Pending block to close */\n+\n+  int explicit_constructor_p;\t     /* True when processing an\n+\t\t\t\t\texplicit constructor. This flag is \n+\t\t\t\t\tused to trap illegal argument usage \n+\t\t\t\t\tduring an explicit constructor\n+\t\t\t\t\tinvocation. */\n #endif /* JC1_LITE */\n };\n \n@@ -611,16 +625,18 @@ static void check_abstract_method_header PROTO ((tree));\n static tree lookup_java_interface_method2 PROTO ((tree, tree));\n static tree resolve_expression_name PROTO ((tree));\n static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n-static int check_class_interface_creation PROTO ((int, int, tree, tree, tree, tree));\n-static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, int *, tree *));\n+static int check_class_interface_creation PROTO ((int, int, tree, \n+\t\t\t\t\t\t  tree, tree, tree));\n+static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, \n+\t\t\t\t\t\t int *, tree *, int));\n static int breakdown_qualified PROTO ((tree *, tree *, tree));\n static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n static int invocation_mode PROTO ((tree, int));\n static tree find_applicable_accessible_methods_list PROTO ((tree, tree, tree));\n static tree find_most_specific_methods_list PROTO ((tree));\n static int argument_types_convertible PROTO ((tree, tree));\n-static tree patch_invoke PROTO ((tree, tree, tree));\n+static tree patch_invoke PROTO ((tree, tree, tree, int));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n static tree obtain_incomplete_type PROTO ((tree));\n@@ -704,6 +720,21 @@ static void check_thrown_exceptions PROTO ((int, tree));\n static int check_thrown_exceptions_do PROTO ((tree));\n static void purge_unchecked_exceptions PROTO ((tree));\n static void check_throws_clauses PROTO ((tree, tree, tree));\n+static void complete_method_declaration PROTO ((tree));\n+static tree build_super_invocation PROTO (());\n+static int verify_constructor_circularity PROTO ((tree, tree));\n+static char *constructor_circularity_msg PROTO ((tree, tree));\n+static tree build_this_super_qualified_invocation PROTO ((int, tree, tree,\n+\t\t\t\t\t\t\t  int, int));\n+static char *get_printable_method_name PROTO ((tree));\n+static tree patch_conditional_expr PROTO ((tree, tree, tree));\n+static void maybe_generate_finit PROTO (());\n+static void fix_constructors PROTO ((tree));\n+static int verify_constructor_super PROTO (());\n+static tree create_artificial_method PROTO ((tree, int, tree, tree, tree));\n+static void start_artificial_method_body PROTO ((tree));\n+static void end_artificial_method_body PROTO ((tree));\n+static tree generate_field_initialization_code PROTO ((tree));\n \n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));"}, {"sha": "c71178fd4e4c2f07056d702eedd1f4b10176a3e8", "filename": "gcc/java/parse.y", "status": "modified", "additions": 846, "deletions": 227, "changes": 1073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -35,7 +35,6 @@ Language Specification. J. Gosling, B. Joy, G. Steele. Addison Wesley\n The following modifications were brought to the original grammar:\n \n method_body: added the rule '| block SC_TK'\n-constructor_declaration: added two rules to accept SC_TK. \n static_initializer: added the rule 'static block SC_TK'. \n \n Note: All the extra rules described above should go away when the\n@@ -196,16 +195,16 @@ static tree wfl_to_string = NULL_TREE;\n \t\t\tabstract_method_declaration interface_type_list\n %type\t <node>\t\tclass_body_declaration class_member_declaration\n \t\t\tstatic_initializer constructor_declaration block\n-%type\t <node>\t\tclass_body_declarations\n+%type\t <node>\t\tclass_body_declarations constructor_header\n %type    <node>\t\tclass_or_interface_type class_type class_type_list\n \t\t\tconstructor_declarator explicit_constructor_invocation\n %type    <node>         dim_expr dim_exprs this_or_super throws\n \n %type\t <node>\t\tvariable_declarator_id variable_declarator\n \t\t\tvariable_declarators variable_initializer\n-\t\t\tvariable_initializers\n+\t\t\tvariable_initializers constructor_body\n \n-%type\t <node>\t\tclass_body\n+%type\t <node>\t\tclass_body block_end\n %type\t <node>\t\tblock_statement local_variable_declaration_statement\n \t\t\tblock_statements local_variable_declaration\n %type\t <node>\t\tstatement statement_without_trailing_substatement\n@@ -448,6 +447,7 @@ type_declaration:\n \tclass_declaration\n \t\t{\n \t\t  maybe_generate_clinit ();\n+\t\t  maybe_generate_finit ();\n \t\t  $$ = $1;\n \t\t}\n |\tinterface_declaration\n@@ -644,18 +644,7 @@ method_declaration:\n \t\t  source_start_java_method (current_function_decl);\n \t\t}\n \tmethod_body\n-\t\t{ \n-\t\t  BLOCK_EXPR_BODY \n-\t\t    (DECL_FUNCTION_BODY (current_function_decl)) = $3;\n-\t\t  maybe_absorb_scoping_blocks ();\n-\t\t  exit_block (); /* Exit function's body. */\n-\n-\t\t  /* Merge last line of the function with first line,\n-\t\t     directly in the function decl. It will be used to\n-\t\t     emit correct debug info. */\n-\t\t  DECL_SOURCE_LINE_MERGE (current_function_decl,\n-\t\t\t\t\t  ctxp->last_ccb_indent1);\n-\t\t}\n+\t\t{ complete_method_declaration ($3); }\n |\tmethod_header error\n \t\t{YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;}\n ;\n@@ -774,51 +763,61 @@ static:\t\t\t\t/* Test lval.sub_token here */\n ;\n \n /* 19.8.5 Productions from 8.6: Constructor Declarations  */\n-/* NOTE FOR FURTHER WORK ON CONSTRUCTORS:\n-   - If a forbidded modifier is found, the the error is either the use of\n-     a forbidded modifier for a constructor OR bogus attempt to declare a\n-     method without having specified the return type. FIXME */\n constructor_declaration:\n-\tconstructor_declarator throws constructor_body\n-\t\t{\n-\t\t  RULE (\"CONSTRUCTOR_DECLARATION\");\n-\t\t}\n-|\tmodifiers constructor_declarator throws constructor_body\n+\tconstructor_header\n \t\t{\n-\t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", $1));\n-\t\t  RULE (\"CONSTRUCTOR_DECLARATION (modifier)\");\n-\t\t}\n-/* extra SC_TK, FIXME */\n-|\tconstructor_declarator throws constructor_body SC_TK\n-\t\t{\n-\t\t  RULE (\"CONSTRUCTOR_DECLARATION\");\n-\t\t}\n-/* extra SC_TK, FIXME */\n-|\tmodifiers constructor_declarator throws constructor_body SC_TK\n-\t\t{\n-\t\t  SOURCE_FRONTEND_DEBUG ((\"Modifiers: %d\", $1));\n-\t\t  RULE (\"CONSTRUCTOR_DECLARATION (modifier)\");\n+\t\t  current_function_decl = $1;\n+\t\t  source_start_java_method (current_function_decl);\n \t\t}\n-/* I'm not happy with the SC_TK addition. It isn't in the grammer and should\n-   probably be matched by and empty statement. But it doesn't work. FIXME */\n+\tconstructor_body\n+\t\t{ complete_method_declaration ($3); }\n+;\n+\n+constructor_header:\n+\tconstructor_declarator throws\n+\t\t{ $$ = method_header (0, NULL_TREE, $1, $2); }\n+|\tmodifiers constructor_declarator throws\n+\t\t{ $$ = method_header ($1, NULL_TREE, $2, $3); }\n ;\n \n constructor_declarator:\n \tsimple_name OP_TK CP_TK\n+\t\t{ $$ = method_declarator ($1, NULL_TREE); }\n |\tsimple_name OP_TK formal_parameter_list CP_TK\n+\t\t{ $$ = method_declarator ($1, $3); }\n ;\n \n constructor_body:\n-\tOCB_TK CCB_TK\n-|\tOCB_TK explicit_constructor_invocation CCB_TK\n-|\tOCB_TK block_statements CCB_TK\n-|       OCB_TK explicit_constructor_invocation block_statements CCB_TK\n+\t/* Unlike regular method, we always need a complete (empty)\n+\t   body so we can safely perform all the required code\n+\t   addition (super invocation and field initialization) */\n+\tblock_begin block_end\n+\t\t{ \n+\t\t  BLOCK_EXPR_BODY ($2) = size_zero_node;\n+\t\t  $$ = $2;\n+\t\t}\n+|\tblock_begin explicit_constructor_invocation block_end\n+\t\t{ $$ = $3; }\n+|\tblock_begin block_statements block_end\n+\t\t{ $$ = $3; }\n+|       block_begin explicit_constructor_invocation block_statements block_end\n+\t\t{ $$ = $4; }\n ;\n \n /* Error recovery for that rule moved down expression_statement: rule.  */\n explicit_constructor_invocation:\n \tthis_or_super OP_TK CP_TK SC_TK\n+\t\t{ \n+\t\t  $$ = build_method_invocation ($1, NULL_TREE); \n+\t\t  $$ = build_debugable_stmt (EXPR_WFL_LINECOL ($1), $$);\n+\t\t  $$ = java_method_add_stmt (current_function_decl, $$);\n+\t\t}\n |\tthis_or_super OP_TK argument_list CP_TK SC_TK\n+\t\t{ \n+\t\t  $$ = build_method_invocation ($1, $3); \n+\t\t  $$ = build_debugable_stmt (EXPR_WFL_LINECOL ($1), $$);\n+\t\t  $$ = java_method_add_stmt (current_function_decl, $$);\n+\t\t}\n         /* Added, JDK1.1 inner classes. Modified because the rule\n \t   'primary' couldn't work.  */\n |\tname DOT_TK SUPER_TK OP_TK argument_list CP_TK SC_TK\n@@ -960,9 +959,16 @@ variable_initializers:\n block:\n \tOCB_TK CCB_TK\n \t\t{ $$ = size_zero_node; }\n-|\tOCB_TK \n+|\tblock_begin block_statements block_end\n+\t\t{ $$ = $3; }\n+;\n+\n+block_begin:\n+\tOCB_TK\n \t\t{ enter_block (); }\n-\tblock_statements\n+;\n+\n+block_end:\n \tCCB_TK\n \t\t{ \n \t\t  maybe_absorb_scoping_blocks ();\n@@ -1101,11 +1107,19 @@ expression_statement:\n |       this_or_super OP_TK error\n \t\t{yyerror (\"')' expected\"); RECOVER;}\n |       this_or_super OP_TK CP_TK error\n-\t\t{yyerror (\"';' expected\"); RECOVER;}\n+\t\t{\n+\t\t  yyerror (\"Constructor invocation must be first \"\n+\t\t\t   \"thing in a constructor\"); \n+\t\t  RECOVER;\n+\t\t}\n |       this_or_super OP_TK argument_list error\n \t\t{yyerror (\"')' expected\"); RECOVER;}\n |       this_or_super OP_TK argument_list CP_TK error\n-\t\t{yyerror (\"';' expected\"); RECOVER;}\n+\t\t{\n+\t\t  yyerror (\"Constructor invocation must be first \"\n+\t\t\t   \"thing in a constructor\"); \n+\t\t  RECOVER;\n+\t\t}\n |\tname DOT_TK SUPER_TK error\n \t\t{yyerror (\"'(' expected\"); RECOVER;}\n |\tname DOT_TK SUPER_TK OP_TK error\n@@ -1666,31 +1680,35 @@ method_invocation:\n \t\t{ $$ = build_method_invocation ($1, $3); }\n |\tprimary DOT_TK identifier OP_TK CP_TK\n \t\t{ \n-\t\t  tree invok = build_method_invocation ($3, NULL_TREE);\n-\t\t  $$ = make_qualified_primary ($1, invok, $2.location);\n+\t\t  if (TREE_CODE ($1) == THIS_EXPR)\n+\t\t    $$ = build_this_super_qualified_invocation \n+\t\t      (1, $3, NULL_TREE, 0, $2.location);\n+\t\t  else\n+\t\t    {\n+\t\t      tree invok = build_method_invocation ($3, NULL_TREE);\n+\t\t      $$ = make_qualified_primary ($1, invok, $2.location);\n+\t\t    }\n \t\t}\n |\tprimary DOT_TK identifier OP_TK argument_list CP_TK\n \t\t{ \n-\t\t  tree invok = build_method_invocation ($3, $5);\n-\t\t  $$ = make_qualified_primary ($1, invok, $2.location);\n+\t\t  if (TREE_CODE ($1) == THIS_EXPR)\n+\t\t    $$ = build_this_super_qualified_invocation \n+\t\t      (1, $3, $5, 0, $2.location);\n+\t\t  else\n+\t\t    {\n+\t\t      tree invok = build_method_invocation ($3, $5);\n+\t\t      $$ = make_qualified_primary ($1, invok, $2.location);\n+\t\t    }\n \t\t}\n |\tSUPER_TK DOT_TK identifier OP_TK CP_TK\n-\t\t{\n-\t\t  tree invok;\n-\t\t  tree wfl = build_wfl_node (super_identifier_node, \n-\t\t\t\t\t     input_filename, 0, 0);\n-\t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n-\t\t  invok = build_method_invocation ($3, NULL_TREE);\n-\t\t  $$ = make_qualified_primary (wfl, invok, $2.location);\n+\t\t{ \n+\t\t  $$ = build_this_super_qualified_invocation \n+\t\t    (0, $3, NULL_TREE, $1.location, $2.location);\n \t\t}\n |\tSUPER_TK DOT_TK identifier OP_TK argument_list CP_TK\n \t\t{\n-\t\t  tree invok;\n-\t\t  tree wfl = build_wfl_node (super_identifier_node, \n-\t\t\t\t\t     input_filename, 0, 0);\n-\t\t  EXPR_WFL_LINECOL (wfl) = $1.location;\n-\t\t  invok = build_method_invocation ($3, $5);\n-\t\t  $$ = make_qualified_primary (wfl, invok, $2.location);\n+\t\t  $$ = build_this_super_qualified_invocation \n+\t\t    (0, $3, $5, $1.location, $2.location);\n \t\t}\n         /* Screws up thing. I let it here until I'm convinced it can\n            be removed. FIXME\n@@ -2006,6 +2024,10 @@ conditional_or_expression:\n conditional_expression:\t\t/* Error handling here is weak */\n \tconditional_or_expression\n |\tconditional_or_expression REL_QM_TK expression REL_CL_TK conditional_expression\n+\t\t{\n+\t\t  $$ = build (CONDITIONAL_EXPR, NULL_TREE, $1, $3, $5);\n+\t\t  EXPR_WFL_LINECOL ($$) = $2.location;\n+\t\t}\n |\tconditional_or_expression REL_QM_TK REL_CL_TK error\n \t\t{\n \t\t  YYERROR_NOW;\n@@ -2079,9 +2101,20 @@ java_push_parser_context ()\n     ctxp->incomplete_class = ctxp->next->incomplete_class;\n }  \n \n+/* If the first file of a file list was a class file, no context\n+   exists for a source file to be parsed. This boolean remembers that\n+   java_parser_context_save_global might have created a dummy one, so\n+   that java_parser_context_restore_global can pop it.  */\n+static int extra_ctxp_pushed_p = 0;\n+\n void\n java_parser_context_save_global ()\n {\n+  if (!ctxp)\n+    {\n+      java_push_parser_context ();\n+      extra_ctxp_pushed_p = 1;\n+    }\n   ctxp->finput = finput;\n   ctxp->lineno = lineno;\n   ctxp->current_class = current_class;\n@@ -2097,6 +2130,11 @@ java_parser_context_restore_global ()\n   current_class = ctxp->current_class;\n   input_filename = ctxp->filename;\n   current_function_decl = ctxp->current_function_decl;\n+  if (extra_ctxp_pushed_p)\n+    {\n+      java_pop_parser_context (0);\n+      extra_ctxp_pushed_p = 0;\n+    }\n }\n \n void \n@@ -2375,6 +2413,7 @@ build_array_from_name (type, type_wfl, name, ret_name)\n       if (JPRIMITIVE_TYPE_P (type))\n \t{\n \t  type = build_java_array_type (type, -1);\n+\t  CLASS_LOADED_P (type) = 1;\n \t  more_dims--;\n \t}\n       /* Otherwise, if we have a WFL for this type, use it (the type\n@@ -2804,10 +2843,15 @@ register_fields (flags, type, variable_list)\n \n       /* Type adjustment. We may have just readjusted TYPE because\n \t the variable specified more dimensions. Make sure we have\n-\t a reference if we can and don't have one already. */\n-      if (type != saved_type && !must_chain \n-\t  && (TREE_CODE (type) == RECORD_TYPE))\n-\ttype = promote_type (type);\n+\t a reference if we can and don't have one already. Also\n+\t change the name if we have an init. */\n+      if (type != saved_type)\n+\t{\n+\t  if (!must_chain && (TREE_CODE (type) == RECORD_TYPE))\n+\t    type = promote_type (type);\n+\t  if (init)\n+\t    EXPR_WFL_NODE (TREE_OPERAND (init, 0)) = current_name;\n+\t}\n \n       /* Set lineno to the line the field was found and create a\n          declaration for it */\n@@ -2848,6 +2892,7 @@ register_fields (flags, type, variable_list)\n \t     time of the generation of <init>. */\n \t  else\n \t    {\n+\t      INITIALIZED_P (field_decl) = 1;\n \t      TREE_CHAIN (init) = ctxp->non_static_initialized;\n \t      ctxp->non_static_initialized = init;\n \t    }\n@@ -2856,36 +2901,49 @@ register_fields (flags, type, variable_list)\n   lineno = saved_lineno;\n }\n \n+/* Generate the method <finit> that initializes fields initialized\n+   upon declaration.  */\n+\n+static void\n+maybe_generate_finit ()\n+{\n+  tree mdecl, current;\n+  \n+  if (!ctxp->non_static_initialized || java_error_count)\n+    return;\n+\n+  mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n+\t\t\t\t    ACC_PRIVATE|ACC_FINAL, void_type_node,\n+\t\t\t\t    finit_identifier_node, NULL_TREE);\n+  start_artificial_method_body (mdecl);\n+\n+  ctxp->non_static_initialized = nreverse (ctxp->non_static_initialized);\n+  for (current = ctxp->non_static_initialized; current;\n+       current = TREE_CHAIN (current))\n+    java_method_add_stmt (mdecl, \n+\t\t\t  build_debugable_stmt (EXPR_WFL_LINECOL (current), \n+\t\t\t\t\t\tcurrent));\n+\n+  end_artificial_method_body (mdecl);\n+  CLASS_HAS_FINIT_P (TREE_TYPE (ctxp->current_parsed_class)) = 1;\n+  ctxp->non_static_initialized = NULL_TREE;\n+}\n+\n /* Check whether it is necessary to generate a <clinit> for the class\n    we just parsed. */\n \n static void\n maybe_generate_clinit ()\n {\n-  int saved_lineno;\n-  tree meth, mdecl, c;\n-  tree cclass, class_wfl;\n+  tree mdecl, c;\n \n   if (!ctxp->static_initialized || java_error_count)\n     return;\n \n-  cclass = TREE_TYPE (ctxp->current_parsed_class);\n-  class_wfl = build_expr_wfl (DECL_NAME (TYPE_NAME (cclass)),\n-\t\t\t      input_filename, 0, 0);\n-  \n-  saved_lineno = lineno;\n-  lineno = 0;\n-  meth = make_node (FUNCTION_TYPE);\n-  TREE_TYPE (meth) = void_type_node;\n-  TYPE_ARG_TYPES (meth) = NULL_TREE;\n-  mdecl = add_method (cclass, ACC_STATIC, clinit_identifier_node,\n-\t\t     build_java_signature (meth));\n-  lineno = saved_lineno;\n-\n-  DECL_SOURCE_LINE (mdecl) = 1;\n-  DECL_SOURCE_LINE_MERGE (mdecl, 1);\n-  source_start_java_method (mdecl);\n-  enter_block ();\n+  mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n+\t\t\t\t    ACC_STATIC, void_type_node,\n+\t\t\t\t    clinit_identifier_node, NULL_TREE);\n+  start_artificial_method_body (mdecl);\n \n   /* Keep initialization in order to enforce 8.5 */\n   ctxp->static_initialized = nreverse (ctxp->static_initialized);\n@@ -2898,11 +2956,11 @@ maybe_generate_clinit ()\n       /* We build the assignment expression that will initialize the\n \t field to its value. There are strict rules on static\n \t initializers (8.5). FIXME */\n-      java_method_add_stmt (mdecl, c);\n+      java_method_add_stmt (mdecl, \n+\t\t\t    build_debugable_stmt (EXPR_WFL_LINECOL (c), c));\n     }\n \n-  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = exit_block ();\n-  exit_block ();\n+  end_artificial_method_body (mdecl);\n   ctxp->static_initialized = NULL_TREE;\n }\n \n@@ -2917,7 +2975,8 @@ static int patch_stage;\n /* Check the method declaration and add the method to its current\n    class.  If the argument list is known to contain incomplete types,\n    the method is partially added and the registration will be resume\n-   once the method arguments resolved  */\n+   once the method arguments resolved. If TYPE is NULL, we're dealing\n+   with a constructor.  */\n \n static tree\n method_header (flags, type, mdecl, throws)\n@@ -2929,12 +2988,13 @@ method_header (flags, type, mdecl, throws)\n   tree this_class = TREE_TYPE (ctxp->current_parsed_class);\n   tree meth_name, returned_type, current;\n   int saved_lineno;\n+  int constructor_ok = 0;\n   \n   check_modifiers_consistency (flags);\n   \n   /* There are some forbidden modifiers for an abstract method and its\n      class must be abstract as well.  */\n-  if (flags & ACC_ABSTRACT)\n+  if (type && (flags & ACC_ABSTRACT))\n     {\n       ABSTRACT_CHECK (flags, ACC_PRIVATE, id, \"Private\");\n       ABSTRACT_CHECK (flags, ACC_STATIC, id, \"Static\");\n@@ -2948,7 +3008,30 @@ method_header (flags, type, mdecl, throws)\n \t   IDENTIFIER_POINTER (DECL_NAME (ctxp->current_parsed_class)),\n \t   IDENTIFIER_POINTER (EXPR_WFL_NODE (id)));\n     }\n-\n+  /* Things to be checked when declaring a constructor */\n+  if (!type)\n+    {\n+      int ec = java_error_count;\n+      /* 8.6: Constructor declarations: we might be trying to define a\n+         method without specifying a return type. */\n+      if (EXPR_WFL_NODE (id) != DECL_NAME (ctxp->current_parsed_class))\n+\tparse_error_context \n+\t  (id, \"Invalid method declaration, return type required\");\n+      /* 8.6.3: Constructor modifiers */\n+      else\n+\t{\n+\t  JCONSTRUCTOR_CHECK (flags, ACC_ABSTRACT, id, \"abstract\");\n+\t  JCONSTRUCTOR_CHECK (flags, ACC_STATIC, id, \"static\");\n+\t  JCONSTRUCTOR_CHECK (flags, ACC_FINAL, id, \"final\");\n+\t  JCONSTRUCTOR_CHECK (flags, ACC_NATIVE, id, \"native\");\n+\t  JCONSTRUCTOR_CHECK (flags, ACC_SYNCHRONIZED, id, \"synchronized\");\n+\t}\n+      /* If we found error here, we don't consider it's OK to tread\n+\t the method definition as a constructor, for the rest of this\n+\t function */\n+      if (ec == java_error_count)\n+\tconstructor_ok = 1;\n+    }\n \n   /* Method declared within the scope of an interface are implicitly\n      abstract and public. Conflicts with other erroneously provided\n@@ -2970,7 +3053,17 @@ method_header (flags, type, mdecl, throws)\n   /* Modifiers context reset moved up, so abstract method declaration\n      modifiers can be later checked.  */\n \n-  meth_name = EXPR_WFL_NODE (id);\n+  /* Set constructor returned type to void and method name to <init>,\n+     unless we found an error identifier the constructor (in which\n+     case we retain the original name) */\n+  if (!type)\n+    {\n+      type = void_type_node;\n+      if (constructor_ok)\n+\tmeth_name = init_identifier_node;\n+    }\n+  else\n+    meth_name = EXPR_WFL_NODE (id);\n \n   if (unresolved_type_p (type, &returned_type))\n     {\n@@ -3055,12 +3148,92 @@ method_header (flags, type, mdecl, throws)\n      redefinition error accurately. When method are verified,\n      DECL_NAME is reinstalled properly (using the content of the\n      WFL node ID) (see check_method_redefinition). We don't do that\n-     when Object is being defined. */\n+     when Object is being defined. Constructor <init> names will be\n+     reinstalled the same way. */\n   if (TREE_TYPE (ctxp->current_parsed_class) != object_type_node)\n     DECL_NAME (meth) = id;\n+\n+  /* Set the flag if we correctly processed a constructor */\n+  if (constructor_ok)\n+    DECL_CONSTRUCTOR_P (meth) = 1;\n+\n   return meth;\n }\n \n+/* Complete the method declaration with METHOD_BODY.  */\n+\n+static void\n+complete_method_declaration (method_body)\n+     tree method_body;\n+{\n+  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (current_function_decl)) = method_body;\n+  maybe_absorb_scoping_blocks ();\n+  /* Exit function's body */\n+  exit_block ();\n+  /* Merge last line of the function with first line, directly in the\n+     function decl. It will be used to emit correct debug info. */\n+  DECL_SOURCE_LINE_MERGE (current_function_decl, ctxp->last_ccb_indent1);\n+}\n+\n+/* Build a an error message for constructor circularity errors.  */\n+\n+static char *\n+constructor_circularity_msg (from, to)\n+     tree from, to;\n+{\n+  static char string [4096];\n+  char *t = strdup (lang_printable_name (from, 0));\n+  sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 0));\n+  free (t);\n+  return string;\n+}\n+\n+/* Verify a circular call to METH. Return 1 if an error is found, 0\n+   otherwise.  */\n+\n+static int\n+verify_constructor_circularity (meth, current)\n+     tree meth, current;\n+{\n+  static tree list = NULL_TREE;\n+  tree c;\n+  for (c = DECL_CONSTRUCTOR_CALLS (current); c; c = TREE_CHAIN (c))\n+    {\n+      if (TREE_VALUE (c) == meth)\n+\t{\n+\t  char *t;\n+\t  if (list)\n+\t    {\n+\t      tree liste;\n+\t      list = nreverse (list);\n+\t      for (liste = list; liste; liste = TREE_CHAIN (liste))\n+\t\t{\n+\t\t  parse_error_context \n+\t\t    (TREE_PURPOSE (TREE_PURPOSE (liste)),\n+\t\t     constructor_circularity_msg\n+\t\t      (TREE_VALUE (liste), TREE_VALUE (TREE_PURPOSE (liste)))); \n+\t\t  java_error_count--;\n+\t\t}\n+\t    }\n+\t  t = strdup (lang_printable_name (meth, 0));\n+\t  parse_error_context (TREE_PURPOSE (c), \n+\t\t\t       \"%s: recursive invocation of constructor `%s'\",\n+\t\t\t       constructor_circularity_msg (current, meth), t);\n+\t  free (t);\n+\t  list = NULL_TREE;\n+\t  return 1;\n+\t}\n+    }\n+  for (c = DECL_CONSTRUCTOR_CALLS (current); c; c = TREE_CHAIN (c))\n+    {\n+      list = tree_cons (c, current, list);\n+      if (verify_constructor_circularity (meth, TREE_VALUE (c)))\n+\treturn 1;\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n /* Check modifiers that can be declared but exclusively */\n \n static void\n@@ -3797,21 +3970,54 @@ java_check_final ()\n {\n }\n \n+/* Return a static string containing the DECL prototype string. If\n+   DECL is a constructor, use the class name instead of the form\n+   <init> */\n+\n+static char *\n+get_printable_method_name (decl)\n+     tree decl;\n+{\n+  char *to_return;\n+  tree name;\n+\n+  if (DECL_CONSTRUCTOR_P (decl))\n+    {\n+      name = DECL_NAME (decl);\n+      DECL_NAME (decl) = \n+\tDECL_NAME (ctxp->current_parsed_class ? \n+\t\t   ctxp->current_parsed_class : current_class);\n+    }\n+      \n+  to_return = lang_printable_name (decl, 0);\n+  if (DECL_CONSTRUCTOR_P (decl))\n+    DECL_NAME (decl) = name;\n+  \n+  return to_return;\n+}\n+\n+/* Track method being redefined inside the same class. As a side\n+   effect, set DECL_NAME to an IDENTIFIER (prior entering this\n+   function it's a FWL, so we can track errors more accurately */\n+\n static int\n check_method_redefinition (class, method)\n      tree class, method;\n {\n   tree redef, name;\n   tree cl = DECL_NAME (method);\n   tree sig = TYPE_LANG_SPECIFIC (TREE_TYPE (method))->signature;\n-  /* decl name of generated <clinit> doesn't need to be fixed and\n+  /* decl name of artificial <clinit> and <finit> doesn't need to be fixed and\n      checked */\n-  if (DECL_NAME (method) != clinit_identifier_node)\n+  if (DECL_NAME (method) != clinit_identifier_node\n+      && DECL_NAME (method) != finit_identifier_node)\n     {\n       /* NAME is just the plain name when Object is being defined */\n       if (class != object_type_node)\n-\tname = DECL_NAME (method) = EXPR_WFL_NODE (DECL_NAME (method));\n-      else\n+\tname = DECL_NAME (method) = (DECL_CONSTRUCTOR_P (method) ? \n+\t\t\t\t     init_identifier_node :\n+\t\t\t\t     EXPR_WFL_NODE (DECL_NAME (method)));\n+      else \n \tname = DECL_NAME (method);\n     }\n   else \n@@ -3825,7 +4031,10 @@ check_method_redefinition (class, method)\n \tbreak;\n       if (DECL_NAME (redef) == name && sig == t->signature)\n \t{\n-\t  parse_error_context (cl, \"Duplicate method declaration\");\n+\t  parse_error_context \n+\t    (cl, \"Duplicate %s declaration `%s'\",\n+\t     (DECL_CONSTRUCTOR_P (redef) ? \"constructor\" : \"method\"),\n+\t     get_printable_method_name (redef));\n \t  return 1;\n \t}\n     }\n@@ -3843,7 +4052,7 @@ java_check_regular_methods (class_decl)\n   tree method;\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n   tree super_class = CLASSTYPE_SUPER (class);\n-  int seen_constructor = 0;\n+  int saw_constructor = 0;\n \n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n@@ -3854,13 +4063,19 @@ java_check_regular_methods (class_decl)\n       tree method_wfl = DECL_NAME (method);\n       int aflags;\n \n-     if (DECL_CONSTRUCTOR_P (method))\n-\tseen_constructor = 1;\n-\n       /* Check for redefinitions */\n       if (check_method_redefinition (class, method))\n \tcontinue;\n \n+      /* If we see one constructor a mark so we don't generate the\n+\t default one. Also skip other verifications: constructors\n+\t can't be inherited hence hiden or overriden */\n+     if (DECL_CONSTRUCTOR_P (method))\n+       {\n+\t saw_constructor = 1;\n+\t continue;\n+       }\n+\n       sig = build_java_argument_signature (TREE_TYPE (method));\n \n       found = lookup_argument_method (super_class, DECL_NAME (method), sig);\n@@ -3951,19 +4166,20 @@ java_check_regular_methods (class_decl)\n   \n   TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n-  if (!seen_constructor)\n+  if (!saw_constructor)\n     {\n       /* No constructor seen, we craft one, at line 0 */\n-      int saved_lineno = lineno;\n-      tree meth, decl;\n-      lineno = 0;\n-      meth = make_node (FUNCTION_TYPE);\n-      TREE_TYPE (meth) = void_type_node;\n-      TYPE_ARG_TYPES (meth) = NULL_TREE; \n-      decl = add_method (class, 0, init_identifier_node,\n-\t\t\t build_java_signature (meth));\n+      int flags;\n+      tree decl;\n+\n+      /* If the class is declared PUBLIC, the default constructor is\n+         PUBLIC otherwise it has default access implied by no access\n+         modifiers. */\n+      flags = (get_access_flags_from_decl (class_decl) & ACC_PUBLIC ?\n+\t       ACC_PUBLIC : 0);\n+      decl = create_artificial_method (class, flags, void_type_node, \n+\t\t\t\t       init_identifier_node, NULL_TREE);\n       DECL_CONSTRUCTOR_P (decl) = 1;\n-      lineno = saved_lineno;\n     }\n }\n \n@@ -4075,7 +4291,6 @@ java_check_abstract_methods (interface)\n void\n java_check_methods ()\n {\n-\n   tree current;\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     if (CLASS_FROM_SOURCE_P (TREE_TYPE (current)))\n@@ -4633,6 +4848,47 @@ source_start_java_method (fndecl)\n   DECL_ARG_SLOT_COUNT (current_function_decl) = i;\n }\n \n+/* Called during parsing. Creates an artificial method declaration.  */\n+\n+static tree\n+create_artificial_method (class, flags, type, name, args)\n+     tree class;\n+     int flags;\n+     tree type, name, args;\n+{\n+  int saved_lineno = lineno;\t\t\t\t\t    \n+  tree mdecl;\n+\n+  lineno = 0;\t\t\t\t\t\t\t\t    \n+  mdecl = make_node (FUNCTION_TYPE);\t\t\t\t    \n+  TREE_TYPE (mdecl) = type;\n+  TYPE_ARG_TYPES (mdecl) = args;\n+  mdecl = add_method (class, flags, name, build_java_signature (mdecl)); \n+  lineno = saved_lineno;\t\t\t\t\t\t    \n+  DECL_ARTIFICIAL (mdecl) = 1;\t\t\t\t\t    \n+  return mdecl;\n+}\n+\n+/* Starts the body if an artifical method.  */\n+\n+static void\n+start_artificial_method_body (mdecl)\n+     tree mdecl;\n+{\n+  DECL_SOURCE_LINE (mdecl) = 1;\n+  DECL_SOURCE_LINE_MERGE (mdecl, 1);\n+  source_start_java_method (mdecl);\n+  enter_block ();\n+}\n+\n+static void\n+end_artificial_method_body (mdecl)\n+     tree mdecl;\n+{\n+  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = exit_block ();\n+  exit_block ();\n+}\n+\n /* Called during expansion. Push decls formerly built from argument\n    list so they're usable during expansion. */\n \n@@ -4765,7 +5021,8 @@ add_stmt_to_compound (existing, type, stmt)\n /* Hold THIS for the scope of the current public method decl.  */\n static tree current_this;\n \n-/* Layout all class found during parsing */\n+/* Layout all class found during parsing. Also fixes the order of\n+   several field related lists. */\n \n void\n java_layout_classes ()\n@@ -4774,8 +5031,16 @@ java_layout_classes ()\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (current);\n-      TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n-      if (!TYPE_SIZE (current_class))\n+\n+      /* Reverse the fields if it's necessary (they've already\n+         reversed if the dummy field has been inserted at the\n+         beginning of the list */\n+      if (TYPE_FIELDS (current_class)\n+\t  && !DECL_IGNORED_P (TYPE_FIELDS (current_class)))\n+\tTYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n+      \n+      /* Do a layout if necessary */\n+      if (!TYPE_SIZE (current_class) || (current_class == object_type_node))\n \tsafe_layout_class (current_class);\n     }\n }\n@@ -4819,6 +5084,14 @@ java_complete_expand_methods ()\n \t      java_complete_expand_method (decl);\n \t  }\n \n+      /* Now verify constructor circularity (stop after the first one\n+         we find) */\n+      if (!CLASS_INTERFACE (TYPE_NAME (current_class)))\n+\tfor (decl = TYPE_METHODS (class_type); decl; decl = TREE_CHAIN (decl))\n+\t  if (DECL_CONSTRUCTOR_P (decl) && \n+\t      verify_constructor_circularity (decl, decl))\n+\t    break;\n+\n       /* Make the class data, register it and run the rest of decl\n          compilation on it */\n       if (!java_error_count && ! flag_emit_class_files)\n@@ -4841,51 +5114,11 @@ static void\n java_complete_expand_method (mdecl)\n      tree mdecl;\n {\n-  int no_ac_found = 1;\n-\n-  /* We generate some code for an empty constructor */\n-  if (DECL_CONSTRUCTOR_P (mdecl) && !DECL_FUNCTION_BODY (mdecl))\n-    {\n-      tree arg_list, func, call;\n-      tree method_type = TREE_TYPE (mdecl);\n-      tree class_type = CLASS_TO_HANDLE_TYPE (current_class);\n-      tree self_type = (CLASSTYPE_SUPER (class_type) ? \n-\t\t\tCLASSTYPE_SUPER (class_type) : class_type);\n-      tree method_signature = \n-\tTYPE_LANG_SPECIFIC (method_type)->signature;\n-      tree method = \n-\tlookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),\n-\t\t\t\t method_signature);\n-      tree block, compound;\n-\n-      /* Fixe the begining/ending lines of the method so that with\n-         no_line_numbers set to 1 it doesn't generate debug info at\n-         line 1 for this artificial constructor. */\n-      DECL_SOURCE_LINE (mdecl) = 1;\n-      DECL_SOURCE_LINE_MERGE (mdecl, 1);\n-      source_start_java_method (mdecl);\n-      arg_list = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl));\n-      enter_block ();\n-      func = build_known_method_ref (method, method_type, self_type,\n-\t\t\t\t     method_signature, arg_list);\n-      \n-      if (! flag_emit_class_files)\n-\tfunc = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n-      call = build (CALL_EXPR, TREE_TYPE (method_type), func, \n-\t\t    build_tree_list (NULL_TREE, arg_list), NULL_TREE);\n-      TREE_SIDE_EFFECTS (call) = 1;\n-      call = build_class_init (self_type, call);\n-      compound = java_method_add_stmt (mdecl, call);\n-      block = exit_block ();\n-      BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) = block;\n-      /* The function decl, its block and the compound statement\n-         within this block are all of void type. */\n-      TREE_TYPE (block) = TREE_TYPE (compound) = \n-\tTREE_TYPE (DECL_FUNCTION_BODY (mdecl)) = void_type_node;\n-      exit_block ();\n-      no_ac_found = 0;\n-    }\n+  /* Fix constructors before expanding them */\n+  if (DECL_CONSTRUCTOR_P (mdecl))\n+    fix_constructors (mdecl);\n   \n+  /* Expand functions that have a body */\n   if (DECL_FUNCTION_BODY (mdecl))\n     {\n       expand_start_java_method (mdecl);\n@@ -4900,12 +5133,17 @@ java_complete_expand_method (mdecl)\n       /* Install exceptions thrown with `throws' */\n       PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n \n-      if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)) && no_ac_found)\n+      if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)))\n \tjava_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n \tsource_end_java_method ();\n+      else\n+\t{\n+\t  pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n+\t  poplevel (1, 0, 1);\n+\t}\n \n       /* Pop the exceptions and sanity check */\n       POP_EXCEPTIONS();\n@@ -4914,14 +5152,144 @@ java_complete_expand_method (mdecl)\n     }\n }\n \n+/* Craft a body for default constructor. Patch existing constructor\n+   bodies with call to super() and field initialization statements if\n+   necessary.  */\n+\n+static void\n+fix_constructors (mdecl)\n+     tree mdecl;\n+{\n+  tree body = DECL_FUNCTION_BODY (mdecl);\n+  tree field_init;\n+\n+  /* The constructor body must be crafted by hand. It's the\n+     constructor we defined when we realize we didn't have the\n+     CLASSNAME() constructor */\n+  if (!body)\n+    {\n+      tree compound;\n+\n+      /* It is an error for the compiler to generate a default\n+\t constructor if the superclass doesn't have a constructor that\n+\t takes no argument */\n+      if (verify_constructor_super ())\n+\t{\n+\t  tree sclass_decl = TYPE_NAME (CLASSTYPE_SUPER (current_class));\n+\t  char *n = IDENTIFIER_POINTER (DECL_NAME (sclass_decl));\n+\t  parse_error_context (lookup_cl (TYPE_NAME (current_class)), \n+\t\t\t       \"No constructor matching `%s()' found in \"\n+\t\t\t       \"class `%s'\", n, n);\n+\t}\n+      \n+      start_artificial_method_body (mdecl);\n+      \n+      /* We don't generate a super constructor invocation if we're\n+\t compiling java.lang.Object. build_super_invocation takes care\n+\t of that. */\n+      compound = java_method_add_stmt (mdecl, build_super_invocation ());\n+      \n+      /* Takes care of non static field initialization */\n+      field_init = generate_field_initialization_code (current_class);\n+      if (field_init)\n+\tcompound = java_method_add_stmt (mdecl, field_init);\n+\n+      end_artificial_method_body (mdecl);\n+    }\n+  /* Search for an explicit constructor invocation */\n+  else \n+    {\n+      int found = 0;\n+      tree main_block = BLOCK_EXPR_BODY (body);\n+      tree compound = NULL_TREE;\n+      \n+      while (body)\n+\tswitch (TREE_CODE (body))\n+\t  {\n+\t  case CALL_EXPR:\n+\t    found = CALL_EXPLICIT_CONSTRUCTOR_P (body);\n+\t    body = NULL_TREE;\n+\t    break;\n+\t  case COMPOUND_EXPR:\n+\t  case EXPR_WITH_FILE_LOCATION:\n+\t    body = TREE_OPERAND (body, 0);\n+\t    break;\n+\t  case BLOCK:\n+\t    body = BLOCK_EXPR_BODY (body);\n+\t    break;\n+\t  default:\n+\t    found = 0;\n+\t    body = NULL_TREE;\n+\t  }\n+      /* The constructor is missing an invocation of super() */\n+      if (!found)\n+\tcompound = add_stmt_to_compound (compound, NULL_TREE,\n+\t\t\t\t\t build_super_invocation ());\n+      \n+      /* Also fix its initialized fields initialization */\n+      field_init = generate_field_initialization_code (current_class);\n+      if (field_init)\n+\tcompound = add_stmt_to_compound (compound, NULL_TREE, field_init);\n+      \n+      /* Fix the constructor main block if we're adding extra stmts */\n+      if (compound)\n+\t{\n+\t  compound = add_stmt_to_compound (compound, NULL_TREE,\n+\t\t\t\t\t   BLOCK_EXPR_BODY (main_block));\n+\t  BLOCK_EXPR_BODY (main_block) = compound;\n+\t}\n+    }\n+}\n+\n+/* Browse constructors in the super class, searching for a constructor\n+   that doesn't take any argument. Return 0 if one is found, 1\n+   otherwise. */\n+\n+static int\n+verify_constructor_super ()\n+{\n+  tree class = CLASSTYPE_SUPER (current_class);\n+  if (!class)\n+    return 0;\n+\n+  if (class)\n+    {\n+      tree mdecl;\n+      for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n+\t{\n+\t  if (DECL_CONSTRUCTOR_P (mdecl)\n+\t      && !TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))))\n+\t    return 0;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Generate the code used to initialize field declared with an\n+   initialization statement. For now, it returns a call the the\n+   artificial function <finit>, if required. Always returns NULL if\n+   nothing needs to be generated. */\n+\n+static tree\n+generate_field_initialization_code (class)\n+     tree class;\n+{\n+  if (CLASS_HAS_FINIT_P (class))\n+    return build_method_invocation (build_expr_wfl (finit_identifier_node, \n+\t\t\t\t\t\t    input_filename, 0, 0), \n+\t\t\t\t    NULL_TREE);\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Expand finals.  */\n \n void\n java_expand_finals ()\n {\n }\n \n-/* Generate code for all context remembered for code generation */\n+/* Generate code for all context remembered for code generation.  */\n \n void\n java_expand_classes ()\n@@ -4936,6 +5304,8 @@ java_expand_classes ()\n       java_parse_abort_on_error ();\n       java_check_final ();            /* Check unitialized final  */\n       java_parse_abort_on_error ();\n+      if (flag_emit_class_files)\n+\twrite_classfile (current_class);\n     }\n }\n \n@@ -5089,6 +5459,15 @@ resolve_expression_name (id)\n \t\t\t\t\t (TYPE_NAME (current_class))));\n \t\t  return error_mark_node;\n \t\t}\n+\t      /* Instance variables can't appear as an argument of\n+\t\t an explicit constructor invocation */\n+\t      if (!fs && ctxp->explicit_constructor_p)\n+\t\t{\n+\t\t  parse_error_context\n+\t\t    (id, \"Can't reference `%s' before the superclass \"\n+\t\t     \"constructor has been called\", IDENTIFIER_POINTER (name));\n+\t\t  return error_mark_node;\n+\t\t}\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n \t\t\t\t      current_class, name);\n \t      return (fs ? build_class_init (current_class, decl) : decl);\n@@ -5210,7 +5589,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t    return 1;\n \t  *where_found = \n \t    patch_method_invocation_stmt (qual_wfl, decl, type,\n-\t\t\t\t\t  &is_static, NULL);\n+\t\t\t\t\t  &is_static, NULL, from_super);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n@@ -5239,6 +5618,13 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  from_cast = 1;\n \t  continue;\n \n+\tcase CONDITIONAL_EXPR:\n+\t  *where_found = decl = java_complete_tree (qual_wfl);\n+\t  if (decl == error_mark_node)\n+\t    return 1;\n+\t  *type_found = type = QUAL_DECL_TYPE (decl);\n+\t  continue;\n+\n \tcase ARRAY_REF:\n \t  /* If the access to the function call is a non static field,\n \t     build the code to access it. */\n@@ -5295,6 +5681,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t\t     CLASSTYPE_SUPER (current_class),\n \t\t\t     build_this (EXPR_WFL_LINECOL (qual_wfl)));\n \t  *where_found = decl = java_complete_tree (node);\n+\t  if (decl == error_mark_node)\n+\t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (decl);\n \t  from_super = from_type = 1;\n \t  continue;\n@@ -5560,15 +5948,17 @@ maybe_access_field (decl, where, type)\n    used. IS_STATIC is set to 1 if the invoked function is static. */\n \n static tree\n-patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n+patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl, super)\n      tree patch, primary, where;\n      int *is_static;\n      tree *ret_decl;\n+     int super;\n {\n   tree wfl = TREE_OPERAND (patch, 0);\n   tree args = TREE_OPERAND (patch, 1);\n   tree name = EXPR_WFL_NODE (wfl);\n   tree list, class_type;\n+  int is_static_flag = 0;\n   \n   /* Should be overriden if everything goes well. Otherwise, if\n      something fails, it should keep this value. It stop the\n@@ -5678,24 +6068,49 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n       /* We search constructor in their target class */\n       if (CALL_CONSTRUCTOR_P (patch))\n \t{\n-\t  class_to_search = resolve_no_layout (EXPR_WFL_NODE (wfl), NULL_TREE);\n-\t  if (!class_to_search)\n+\t  if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n+\t    class_to_search = EXPR_WFL_NODE (wfl);\n+\t  else if (EXPR_WFL_NODE (TREE_OPERAND (patch, 0)) == \n+\t\t   this_identifier_node)\n+\t    class_to_search = NULL_TREE;\n+\t  else if (EXPR_WFL_NODE (TREE_OPERAND (patch, 0)) ==\n+\t\t   super_identifier_node)\n \t    {\n-\t      parse_error_context \n-\t\t(wfl, \"Class `%s' not found in type declaration\",\n-\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-\t      PATCH_METHOD_RETURN_ERROR ();\n+\t      if (CLASSTYPE_SUPER (current_class))\n+\t\tclass_to_search = \n+\t\t  DECL_NAME (TYPE_NAME (CLASSTYPE_SUPER (current_class)));\n+\t      else\n+\t\t{\n+\t\t  parse_error_context (wfl, \"Can't invoke super constructor \"\n+\t\t\t\t       \"on java.lang.Object\");\n+\t\t  PATCH_METHOD_RETURN_ERROR ();\n+\t\t}\n \t    }\n-\t  \n-\t  /* Can't instantiate an abstract class */\n-\t  if (CLASS_ABSTRACT (class_to_search))\n+\n+\t  /* Class to search is NULL if we're searching the current one */\n+\t  if (class_to_search)\n \t    {\n-\t      parse_error_context \n-\t\t(wfl, \"Class `%s' is an abstract class. It can't be \"\n-\t\t \"instantiated\", IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n-\t      PATCH_METHOD_RETURN_ERROR ();\n+\t      class_to_search = resolve_no_layout (class_to_search, NULL_TREE);\n+\t      if (!class_to_search)\n+\t\t{\n+\t\t  parse_error_context \n+\t\t    (wfl, \"Class `%s' not found in type declaration\",\n+\t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+\t\t  PATCH_METHOD_RETURN_ERROR ();\n+\t\t}\n+\t      \n+\t      /* Can't instantiate an abstract class */\n+\t      if (CLASS_ABSTRACT (class_to_search))\n+\t\t{\n+\t\t  parse_error_context \n+\t\t    (wfl, \"Class `%s' is an abstract class. It can't be \"\n+\t\t     \"instantiated\", IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl)));\n+\t\t  PATCH_METHOD_RETURN_ERROR ();\n+\t\t}\n+\t      class_to_search = TREE_TYPE (class_to_search);\n \t    }\n-\t  class_to_search = TREE_TYPE (class_to_search);\n+\t  else\n+\t    class_to_search = current_class;\n \t  lc = 1;\n \t}\n       /* This is a regular search in the local class, unless an\n@@ -5721,11 +6136,12 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n \t\t\t\t\t     class_to_search, primary))\n \tPATCH_METHOD_RETURN_ERROR ();\n \n-      /* Non static/constructor methods are called with the current\n-\t object extra argument. If method is resolved as a primary,\n-\t use the primary otherwise use the current THIS. */\n+      /* Non static methods are called with the current object extra\n+\t argument. If patch a `new TYPE()', the argument is the value\n+\t returned by the object allocator. If method is resolved as a\n+\t primary, use the primary otherwise use the current THIS. */\n       args = nreverse (args);\n-      if (!CALL_CONSTRUCTOR_P (patch) && !METHOD_STATIC (list))\n+      if (!METHOD_STATIC (list) && TREE_CODE (patch) != NEW_CLASS_EXPR)\n \targs = tree_cons (NULL_TREE, primary ? primary : current_this, args);\n \n       class_type = class_to_search;\n@@ -5750,15 +6166,27 @@ patch_method_invocation_stmt (patch, primary, where, is_static, ret_decl)\n       free (fct_name);\n       PATCH_METHOD_RETURN_ERROR ();\n     }\n-  \n-  if (is_static) \n-    *is_static = METHOD_STATIC (list);\n+\n+  is_static_flag = METHOD_STATIC (list);\n+\n+  /* In the context of an explicit constructor invocation, we can't invoke\n+     any method relying on `this' */\n+  if (ctxp->explicit_constructor_p \n+      && !is_static_flag && (!primary || primary == current_this))\n+    {\n+      parse_error_context \n+\t(wfl, \"Can't reference `this' before the superclass constructor has \"\n+\t \"been called\");\n+      PATCH_METHOD_RETURN_ERROR ();\n+    }\n   java_parser_context_restore_global ();\n+  if (is_static) \n+    *is_static = is_static_flag;\n   /* Sometimes, we want the decl of the selected method. Such as for\n      EH checking */\n   if (ret_decl)\n     *ret_decl = list;\n-  return patch_invoke (patch, list, args);\n+  return patch_invoke (patch, list, args, super);\n }\n \n /* Check that we're not trying to do a static reference to a method in\n@@ -5786,35 +6214,37 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n    mode.  */\n \n static tree\n-patch_invoke (patch, method, args)\n+patch_invoke (patch, method, args, from_super)\n      tree patch, method, args;\n+     int from_super;\n {\n   int im;\n   tree dtable, func;\n   tree signature = build_java_signature (TREE_TYPE (method));\n   tree original_call, t, ta;\n \n-  /* Last step for args: convert build-in types */\n-  for (t = TYPE_ARG_TYPES (TREE_TYPE (method)),\n-       ta = args; t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n+  /* Last step for args: convert build-in types. */\n+  for (t = TYPE_ARG_TYPES (TREE_TYPE (method)), ta = args;\n+       t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n-       \n-  switch ((im = invocation_mode (method, 0)))\n+  \n+  switch ((im = invocation_mode (method, from_super)))\n     {\n     case INVOKE_VIRTUAL:\n       dtable = invoke_build_dtable (0, args);\n       func = build_invokevirtual (dtable, method);\n       break;\n \n+    case INVOKE_SUPER:\n     case INVOKE_STATIC:\n       func = build_known_method_ref (method, TREE_TYPE (method),\n \t\t\t\t     DECL_CONTEXT (method), signature, args);\n       break;\n \n     default:\n-      fatal (\"Unknown invocation mode - build_invoke\");\n+      fatal (\"Unknown invocation mode `%d' - build_invoke\", im);\n       return NULL_TREE;\n     }\n \n@@ -5825,11 +6255,12 @@ patch_invoke (patch, method, args)\n   TREE_OPERAND (patch, 1) = args;\n   original_call = patch;\n \n-  /* We're calling a constructor. New is called an its returned value\n-     is an argument to the constructor. We build a COMPOUND_EXPR and\n-     use saved expression so that the overall NEW expression value is\n-     a pointer to a newly created and initialized class. */\n-  if (CALL_CONSTRUCTOR_P (original_call))\n+  /* We're processing a `new TYPE ()' form. New is called an its\n+     returned value is the first argument to the constructor. We build\n+     a COMPOUND_EXPR and use saved expression so that the overall NEW\n+     expression value is a pointer to a newly created and initialized\n+     class. */\n+  if (TREE_CODE (original_call) == NEW_CLASS_EXPR)\n     {\n       tree class = DECL_CONTEXT (method);\n       tree c1, saved_new, size, new;\n@@ -5859,21 +6290,21 @@ invocation_mode (method, super)\n {\n   int access = get_access_flags_from_decl (method);\n \n+  if (super)\n+    return INVOKE_SUPER;\n+\n   if (access & ACC_STATIC || access & ACC_FINAL)\n     return INVOKE_STATIC;\n \n   if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n     return INVOKE_STATIC;\n   \n-  if (super)\n-    return INVOKE_SUPER;\n-  \n   if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n     return INVOKE_INTERFACE;\n   \n   if (DECL_CONSTRUCTOR_P (method))\n     return INVOKE_STATIC;\n-  \n+\n   return INVOKE_VIRTUAL;\n }\n \n@@ -5932,11 +6363,9 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n \t  char string [4096];\n \t  if (!cm || not_accessible_p (class, cm, 0))\n \t    continue;\n-\t  signature = build_java_argument_signature (TREE_TYPE (cm));\n \t  sprintf \n-\t    (string, \"  `%s(%s)' in `%s'%s\",\n-\t     IDENTIFIER_POINTER (name), \n-\t     IDENTIFIER_POINTER (signature),\n+\t    (string, \"  `%s' in `%s'%s\",\n+\t     get_printable_method_name (cm),\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (cm)))),\n \t     (TREE_CHAIN (current) ? \"\\n\" : \"\"));\n \t  obstack_grow (&temporary_obstack, string, strlen (string));\n@@ -5946,8 +6375,11 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n     }\n   /* Issue the error message */\n   signature = build_java_argument_signature (method);\n-  parse_error_context (cl, \"Can't find method `%s(%s)' in class `%s'%s\",\n-\t\t       IDENTIFIER_POINTER (name),\n+  parse_error_context (cl, \"Can't find %s `%s(%s)' in class `%s'%s\",\n+\t\t       (lc ? \"constructor\" : \"method\"),\n+\t\t       (lc ? \n+\t\t\tIDENTIFIER_POINTER(DECL_NAME (TYPE_NAME (class))) :\n+\t\t\tIDENTIFIER_POINTER (name)),\n \t\t       IDENTIFIER_POINTER (signature),\n \t\t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class))),\n \t\t       (candidates ? candidates : \"\"));\n@@ -5969,8 +6401,7 @@ find_applicable_accessible_methods_list (class, name, arglist)\n \t   method != NULL_TREE;  method = TREE_CHAIN (method))\n \t{\n \t  /* Names have to match and we're not looking for constructor */\n-\t  if (DECL_NAME (method) != name\n-\t      || DECL_CONSTRUCTOR_P (method))\n+\t  if (DECL_NAME (method) != name || DECL_CONSTRUCTOR_P (method))\n \t    continue;\n \n \t  if (argument_types_convertible (method, arglist))\n@@ -6145,7 +6576,10 @@ qualify_ambiguous_name (id)\n       {\n \tqual = TREE_CHAIN (qual);\n \tqual_wfl = QUAL_WFL (qual);\n-\tname = EXPR_WFL_NODE (qual_wfl);\n+\tif (TREE_CODE (qual_wfl) == CALL_EXPR)\n+\t  again = 1;\n+\telse\n+\t  name = EXPR_WFL_NODE (qual_wfl);\n \tthis_found = 1;\n       }\n     /* If we have a SUPER, we set the context accordingly */\n@@ -6164,6 +6598,13 @@ qualify_ambiguous_name (id)\n \t/* Do one more interation to set things up */\n \tsuper_found = again = 1;\n       }\n+    /* Loop one more time if we're dealing with ?: up front */\n+    if (TREE_CODE (qual_wfl) == CONDITIONAL_EXPR)\n+      {\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+\tagain = 1;\n+      }\n   } while (again);\n   \n   /* If name appears within the scope of a location variable\n@@ -6283,7 +6724,7 @@ static tree\n java_complete_tree (node)\n      tree node;\n {\n-  tree nn, cn, wfl_op1, wfl_op2;\n+  tree nn, cn, wfl_op1, wfl_op2, wfl_op3;\n   int flag;\n \n   /* CONVERT_EXPR always has its type set, even though it needs to be\n@@ -6394,6 +6835,16 @@ java_complete_tree (node)\n       return patch_if_else_statement (node);\n       break;\n \n+    case CONDITIONAL_EXPR:\n+      /* Condition */\n+      wfl_op1 = TREE_OPERAND (node, 0);\n+      COMPLETE_CHECK_OP_0 (node);\n+      wfl_op2 = TREE_OPERAND (node, 1);\n+      COMPLETE_CHECK_OP_1 (node);\n+      wfl_op3 = TREE_OPERAND (node, 2);\n+      COMPLETE_CHECK_OP_2 (node);\n+      return patch_conditional_expr (node, wfl_op1, wfl_op2);\n+\n       /* 3- Expression section */\n     case COMPOUND_EXPR:\n       TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n@@ -6459,11 +6910,21 @@ java_complete_tree (node)\n \treturn error_mark_node;\n       else\n \t{\n-\t  tree decl;\n+\t  tree decl, wfl = TREE_OPERAND (node, 0);\n+\t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n+\n \t  node = patch_method_invocation_stmt (node, NULL_TREE, \n-\t\t\t\t\t       NULL_TREE, 0, &decl);\n+\t\t\t\t\t       NULL_TREE, 0, &decl, 0);\n \t  if (node != error_mark_node)\n-\t    check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t    {\n+\t      check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t      /* If we call this(...), register signature and positions */\n+\t      if (in_this)\n+\t\tDECL_CONSTRUCTOR_CALLS (current_function_decl) = \n+\t\t  tree_cons (wfl, decl,\n+\t\t\t     DECL_CONSTRUCTOR_CALLS (current_function_decl));\n+\t\t\n+\t    }\n \t  return node;\n \t}\n \n@@ -6585,7 +7046,8 @@ java_complete_tree (node)\n       TREE_OPERAND (node, 1) = java_complete_tree (wfl_op2);\n       if (TREE_OPERAND (node, 1) == error_mark_node)\n \treturn error_mark_node;\n-      TREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n+      if (!flag_emit_class_files)\n+\tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node, wfl_op1, wfl_op2);\n \n     case THIS_EXPR:\n@@ -6598,6 +7060,15 @@ java_complete_tree (node)\n \t  TREE_TYPE (node) = error_mark_node;\n \t  return error_mark_node;\n \t}\n+      if (ctxp->explicit_constructor_p)\n+\t{\n+\t  EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n+\t  parse_error_context \n+\t    (wfl_operator, \"Can't reference `this' or `super' before the \"\n+\t     \"superclass constructor has been called\");\n+\t  TREE_TYPE (node) = error_mark_node;\n+\t  return error_mark_node;\n+\t}\n       return current_this;\n \n     default:\n@@ -6622,6 +7093,7 @@ complete_function_arguments (node)\n   int flag = 0;\n   tree cn;\n \n+  ctxp->explicit_constructor_p += (CALL_THIS_CONSTRUCTOR_P (node) ? 1 : 0);\n   for (cn = TREE_OPERAND (node, 1); cn; cn = TREE_CHAIN (cn))\n     {\n       tree wfl = TREE_VALUE (cn), parm, temp;\n@@ -6644,6 +7116,7 @@ complete_function_arguments (node)\n \t  INITIALIZED_P (parm) = 1;\n \t}\n     }\n+  ctxp->explicit_constructor_p -= (CALL_THIS_CONSTRUCTOR_P (node) ? 1 : 0);\n   return flag;\n }\n \n@@ -6769,6 +7242,40 @@ maybe_absorb_scoping_blocks ()\n    are building incomplete tree nodes and the patch_* functions that\n    are completing them.  */\n \n+/* Build a super() constructor invocation. Returns size_zero_node if\n+   we're currently dealing with the class java.lang.Object. */\n+\n+static tree\n+build_super_invocation ()\n+{\n+  if (current_class == object_type_node)\n+    return size_zero_node;\n+  else\n+    {\n+      tree super_wfl = build_wfl_node (super_identifier_node, \n+\t\t\t\t       input_filename, 0, 0);\n+      return build_method_invocation (super_wfl, NULL_TREE);\n+    }\n+}\n+\n+/* Build a SUPER/THIS qualified method invocation.  */\n+\n+static tree\n+build_this_super_qualified_invocation (use_this, name, args, lloc, rloc)\n+     int use_this;\n+     tree name, args;\n+     int lloc, rloc;\n+\n+{\n+  tree invok;\n+  tree wfl = \n+    build_wfl_node ((use_this ? this_identifier_node : super_identifier_node),\n+\t\t    input_filename, 0, 0);\n+  EXPR_WFL_LINECOL (wfl) = lloc;\n+  invok = build_method_invocation (name, args);\n+  return make_qualified_primary (wfl, invok, rloc);\n+}\n+\n /* Build an incomplete CALL_EXPR node. */\n \n static tree\n@@ -6962,7 +7469,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n      assignment into an array element, return it here. */\n   if (TREE_CODE (node) == COMPOUND_EXPR)\n     return node;\n-      \n+\n   TREE_OPERAND (node, 0) = lvalue;\n   TREE_OPERAND (node, 1) = new_rhs;\n   TREE_TYPE (node) = lhs_type;\n@@ -7845,7 +8352,7 @@ patch_unaryop (node, wfl_op)\n \t  TREE_TYPE (node) = error_mark_node;\n \t  error_found = 1;\n \t}\n-      else if (FIELD_FINAL (op))\n+      else if (DECL_P (op) && FIELD_FINAL (op))\n \t{\n \t  parse_error_context \n \t    (wfl_op, \"Can't assign a value to the final variable `%s'\",\n@@ -8315,11 +8822,19 @@ patch_return (node)\n \n   if (error_found)\n     {\n-      char *t = strdup (lang_printable_name (mtype, 0));\n-      parse_error_context (wfl_operator, \"`return' with%s value from `%s %s'\",\n-\t\t\t   (error_found == 1 ? \"\" : \"out\"), t,\n-\t\t\t   lang_printable_name (meth, 0));\n-      free (t);\n+      if (!DECL_CONSTRUCTOR_P (meth))\n+\t{\n+\t  char *t = strdup (lang_printable_name (mtype, 0));\n+\t  parse_error_context (wfl_operator, \n+\t\t\t       \"`return' with%s value from `%s %s'\",\n+\t\t\t       (error_found == 1 ? \"\" : \"out\"), \n+\t\t\t       t, lang_printable_name (meth, 0));\n+\t  free (t);\n+\t}\n+      else\n+\tparse_error_context (wfl_operator, \n+\t\t\t     \"`return' with value from constructor `%s'\",\n+\t\t\t     lang_printable_name (meth, 0));\n       return error_mark_node;\n     }\n \n@@ -9364,3 +9879,107 @@ purge_unchecked_exceptions (mdecl)\n   /* List is inverted here, but it doesn't matter */\n   DECL_FUNCTION_THROWS (mdecl) = new;\n }\n+\n+/* 15.24 Conditional Operator ?: */\n+\n+static tree\n+patch_conditional_expr (node, wfl_cond, wfl_op1)\n+     tree node, wfl_cond, wfl_op1;\n+{\n+  tree cond = TREE_OPERAND (node, 0);\n+  tree op1 = TREE_OPERAND (node, 1);\n+  tree op2 = TREE_OPERAND (node, 2);\n+  tree t1 = TREE_TYPE (op1);\n+  tree t2 = TREE_TYPE (op2);\n+  tree resulting_type = NULL_TREE;\n+  int error_found = 0;\n+\n+  /* The first expression must be a boolean */\n+  if (TREE_TYPE (cond) != boolean_type_node)\n+    {\n+      SET_WFL_OPERATOR (wfl_operator, node, wfl_cond);\n+      parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n+\t\t\t   \"convert `%s' to `boolean'\",\n+\t\t\t   lang_printable_name (TREE_TYPE (cond), 0));\n+      error_found = 1;\n+    }\n+\n+  /* Second and third can be numeric, boolean (i.e. primitive),\n+     references or null. Anything else results in an error */\n+  if (!((JNUMERIC_TYPE_P (t1) && JNUMERIC_TYPE_P (t2))\n+\t|| ((JREFERENCE_TYPE_P (t1) || op1 == null_pointer_node) \n+\t    && (JREFERENCE_TYPE_P (t2) || op2 == null_pointer_node))\n+\t|| (t1 == boolean_type_node && t2 == boolean_type_node)))\n+    error_found = 1;\n+\n+  /* Determine the type of the conditional expression. Same types are\n+     easy to deal with */\n+  else if (t1 == t2)\n+    resulting_type = t1;\n+\n+  /* There are different rules for numeric types */\n+  else if (JNUMERIC_TYPE_P (t1))\n+    {\n+      /* if byte/short found, the resulting type is short */\n+      if ((t1 == byte_type_node && t2 == short_type_node)\n+\t  || (t1 == short_type_node && t2 == byte_type_node))\n+\tresulting_type = short_type_node;\n+\n+      /* If t1 is a constant int and t2 is of type byte, short or char\n+\t and t1's value fits in t2, then the resulting type is t2 */\n+      else if ((t1 == int_type_node && TREE_CONSTANT (TREE_OPERAND (node, 1)))\n+\t  && JBSC_TYPE_P (t2) && int_fits_type_p (TREE_OPERAND (node, 1), t2))\n+\tresulting_type = t2;\n+\n+      /* If t2 is a constant int and t1 is of type byte, short or char\n+\t and t2's value fits in t1, then the resulting type is t1 */\n+      else if ((t2 == int_type_node && TREE_CONSTANT (TREE_OPERAND (node, 2)))\n+\t  && JBSC_TYPE_P (t1) && int_fits_type_p (TREE_OPERAND (node, 2), t1))\n+\tresulting_type = t1;\n+\n+      /* Otherwise, binary numeric promotion is applied and the\n+\t resulting type is the promoted type of operand 1 and 2 */\n+      else \n+\tresulting_type = binary_numeric_promotion (t2, t2, \n+\t\t\t\t\t\t   &TREE_OPERAND (node, 1), \n+\t\t\t\t\t\t   &TREE_OPERAND (node, 2));\n+    }\n+\n+  /* Cases of a reference and a null type */\n+  else if (JREFERENCE_TYPE_P (t1) && op2 == null_pointer_node)\n+    resulting_type = t1;\n+\n+  else if (JREFERENCE_TYPE_P (t2) && op1 == null_pointer_node)\n+    resulting_type = t2;\n+\n+  /* Last case: different reference types. If a type can be converted\n+     into the other one by assignment conversion, the latter\n+     determines the type of the expression */\n+  else if ((resulting_type = try_reference_assignconv (t1, op2)))\n+    resulting_type = promote_type (t1);\n+\n+  else if ((resulting_type = try_reference_assignconv (t2, op1)))\n+    resulting_type = promote_type (t2);\n+\n+  /* If we don't have any resulting type, we're in trouble */\n+  if (!resulting_type)\n+    {\n+      char *t = strdup (lang_printable_name (t1, 0));\n+      SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n+      parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n+\t\t\t   \"convert `%s' to `%s'\", t,\n+\t\t\t   lang_printable_name (t2, 0));\n+      free (t);\n+      error_found = 1;\n+    }\n+\n+  if (error_found)\n+    {\n+      TREE_TYPE (node) = error_mark_node;\n+      return error_mark_node;\n+    }\n+\n+  TREE_TYPE (node) = resulting_type;\n+  TREE_SET_CODE (node, COND_EXPR);\n+  return node;\n+}"}, {"sha": "9aad0fbb161f25f2dde67c477e30eb64eabe98a8", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eed1e6784af1d88a4e0f1773f2d6952c2c493c/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=22eed1e6784af1d88a4e0f1773f2d6952c2c493c", "patch": "@@ -546,7 +546,6 @@ build_java_signature (type)\n     {\n       TYPE_LANG_SPECIFIC (type) = (struct lang_type *)\n \tperm_calloc (1, sizeof (struct lang_type));\n-\n     }\n   sig = TYPE_LANG_SPECIFIC (type)->signature;\n   if (sig == NULL_TREE)\n@@ -600,7 +599,7 @@ build_java_signature (type)\n \t    obstack_grow (&temporary_obstack,\n \t\t\t  IDENTIFIER_POINTER (sig), IDENTIFIER_LENGTH (sig));\n \t    obstack_1grow (&temporary_obstack, ')');\n-  \n+\n \t    t = build_java_signature (TREE_TYPE (type));\n \t    obstack_grow0 (&temporary_obstack,\n \t\t\t   IDENTIFIER_POINTER (t), IDENTIFIER_LENGTH (t));"}]}