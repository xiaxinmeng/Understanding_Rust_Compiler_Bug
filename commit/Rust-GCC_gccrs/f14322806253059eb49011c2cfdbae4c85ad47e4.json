{"sha": "f14322806253059eb49011c2cfdbae4c85ad47e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0MzIyODA2MjUzMDU5ZWI0OTAxMWMyY2ZkYmFlNGM4NWFkNDdlNA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2019-02-22T15:54:08Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2019-02-22T15:54:08Z"}, "message": "i386: Add pass_remove_partial_avx_dependency\n\nWith -mavx, for\n\n$ cat foo.i\nextern float f;\nextern double d;\nextern int i;\n\nvoid\nfoo (void)\n{\n  d = f;\n  f = i;\n}\n\nwe need to generate\n\n\tvxorp[ds]\t%xmmN, %xmmN, %xmmN\n\t...\n\tvcvtss2sd\tf(%rip), %xmmN, %xmmX\n\t...\n\tvcvtsi2ss\ti(%rip), %xmmN, %xmmY\n\nto avoid partial XMM register stall.  This patch adds a pass to generate\na single\n\n\tvxorps\t\t%xmmN, %xmmN, %xmmN\n\nat entry of the nearest dominator for basic blocks with SF/DF conversions,\nwhich is in the fake loop that contains the whole function, instead of\ngenerating one\n\n\tvxorp[ds]\t%xmmN, %xmmN, %xmmN\n\nfor each SF/DF conversion.\n\nNB: The LCM algorithm isn't appropriate here since it may place a vxorps\ninside the loop.  Simple testcase show this:\n\n$ cat badcase.c\n\nextern float f;\nextern double d;\n\nvoid\nfoo (int n, int k)\n{\n  for (int j = 0; j != n; j++)\n    if (j < k)\n      d = f;\n}\n\nIt generates\n\n    ...\n    loop:\n      if(j < k)\n        vxorps    %xmm0, %xmm0, %xmm0\n        vcvtss2sd f(%rip), %xmm0, %xmm0\n      ...\n    loopend\n    ...\n\nThis is because LCM only works when there is a certain benifit.  But for\nconditional branch, LCM wouldn't move\n\n   vxorps  %xmm0, %xmm0, %xmm0\n\nout of loop.  SPEC CPU 2017 on Intel Xeon with AVX512 shows:\n\n1. The nearest dominator\n\n|RATE\t\t\t|Improvement|\n|500.perlbench_r\t| 0.55%\t|\n|538.imagick_r\t\t| 8.43%\t|\n|544.nab_r\t\t| 0.71%\t|\n\n2. LCM\n\n|RATE\t\t\t|Improvement|\n|500.perlbench_r\t| -0.76% |\n|538.imagick_r\t\t| 7.96%  |\n|544.nab_r\t\t| -0.13% |\n\nPerformance impacts of SPEC CPU 2017 rate on Intel Xeon with AVX512\nusing\n\n-Ofast -flto -march=skylake-avx512 -funroll-loops\n\nbefore\n\ncommit e739972ad6ad05e32a1dd5c29c0b950a4c4bd576\nAuthor: uros <uros@138bc75d-0d04-0410-961f-82ee72b054a4>\nDate:   Thu Jan 31 20:06:42 2019 +0000\n\n            PR target/89071\n            * config/i386/i386.md (*extendsfdf2): Split out reg->reg\n            alternative to avoid partial SSE register stall for TARGET_AVX.\n            (truncdfsf2): Ditto.\n            (sse4_1_round<mode>2): Ditto.\n\n    git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@268427 138bc75d-0d04-0410-961f-82ee72b054a4\n\nare:\n\n|INT RATE\t\t|Improvement|\n|500.perlbench_r\t| 0.55%\t|\n|502.gcc_r\t\t| 0.14%\t|\n|505.mcf_r\t\t| 0.08%\t|\n|523.xalancbmk_r\t| 0.18%\t|\n|525.x264_r\t\t|-0.49%\t|\n|531.deepsjeng_r\t|-0.04%\t|\n|541.leela_r\t\t|-0.26%\t|\n|548.exchange2_r\t|-0.3%\t|\n|557.xz_r\t\t|BuildSame|\n\n|FP RATE\t\t|Improvement|\n|503.bwaves_r\t        |-0.29% |\n|507.cactuBSSN_r\t| 0.04%\t|\n|508.namd_r\t\t|-0.74%\t|\n|510.parest_r\t\t|-0.01%\t|\n|511.povray_r\t\t| 2.23%\t|\n|519.lbm_r\t\t| 0.1%\t|\n|521.wrf_r\t\t| 0.49%\t|\n|526.blender_r\t\t| 0.13%\t|\n|527.cam4_r\t\t| 0.65%\t|\n|538.imagick_r\t\t| 8.43%\t|\n|544.nab_r\t\t| 0.71%\t|\n|549.fotonik3d_r\t| 0.15%\t|\n|554.roms_r\t\t| 0.08%\t|\n\nAfter commit e739972ad6ad05e32a1dd5c29c0b950a4c4bd576, on Skylake client,\nimpacts on 538.imagick_r with\n\n-fno-unsafe-math-optimizations -march=native -Ofast -funroll-loops -flto\n\n1. Size comparision:\n\nbefore:\n\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n2436377\t   8352\t   4528\t2449257\t 255f69 imagick_r\n\nafter:\n\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n2425249\t   8352\t   4528\t2438129\t 2533f1 imagick_r\n\n2. Number of vxorps:\n\nbefore\t\tafter\t\tdifference\n4948            4135            -19.66%\n\n3. Performance improvement:\n\n|RATE\t\t\t|Improvement|\n|538.imagick_r\t\t| 5.5%  |\n\ngcc/\n\n2019-02-22  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Hongtao Liu  <hongtao.liu@intel.com>\n\t    Sunil K Pandey  <sunil.k.pandey@intel.com>\n\n\tPR target/87007\n\t* config/i386/i386-passes.def: Add\n\tpass_remove_partial_avx_dependency.\n\t* config/i386/i386-protos.h\n\t(make_pass_remove_partial_avx_dependency): New.\n\t* config/i386/i386.c (make_pass_remove_partial_avx_dependency):\n\tNew function.\n\t(pass_data_remove_partial_avx_dependency): New.\n\t(pass_remove_partial_avx_dependency): Likewise.\n\t(make_pass_remove_partial_avx_dependency): Likewise.\n\t* config/i386/i386.md (avx_partial_xmm_update): New attribute.\n\t(*extendsfdf2): Add avx_partial_xmm_update.\n\t(truncdfsf2): Likewise.\n\t(*float<SWI48:mode><MODEF:mode>2): Likewise.\n\t(SF/DF conversion splitters): Disabled for TARGET_AVX.\n\ngcc/testsuite/\n\n2019-02-22  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Hongtao Liu  <hongtao.liu@intel.com>\n\t    Sunil K Pandey  <sunil.k.pandey@intel.com>\n\n\tPR target/87007\n\t* gcc.target/i386/pr87007-1.c: New test.\n\t* gcc.target/i386/pr87007-2.c: Likewise.\n\nCo-Authored-By: Hongtao Liu <hongtao.liu@intel.com>\nCo-Authored-By: Sunil K Pandey <sunil.k.pandey@intel.com>\n\nFrom-SVN: r269119", "tree": {"sha": "ec05edc6d020eb2a3f7877c68288cd415f08d978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec05edc6d020eb2a3f7877c68288cd415f08d978"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f14322806253059eb49011c2cfdbae4c85ad47e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14322806253059eb49011c2cfdbae4c85ad47e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14322806253059eb49011c2cfdbae4c85ad47e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14322806253059eb49011c2cfdbae4c85ad47e4/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "965779b4ad0f0abbdc8ab0addd2fae14165a08f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965779b4ad0f0abbdc8ab0addd2fae14165a08f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965779b4ad0f0abbdc8ab0addd2fae14165a08f4"}], "stats": {"total": 255, "additions": 252, "deletions": 3}, "files": [{"sha": "41deb1c46566aff5dc5cc81a5ae92c591b0390ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -1,3 +1,23 @@\n+2019-02-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Hongtao Liu  <hongtao.liu@intel.com>\n+\t    Sunil K Pandey  <sunil.k.pandey@intel.com>\n+\n+\tPR target/87007\n+\t* config/i386/i386-passes.def: Add\n+\tpass_remove_partial_avx_dependency.\n+\t* config/i386/i386-protos.h\n+\t(make_pass_remove_partial_avx_dependency): New.\n+\t* config/i386/i386.c (make_pass_remove_partial_avx_dependency):\n+\tNew function.\n+\t(pass_data_remove_partial_avx_dependency): New.\n+\t(pass_remove_partial_avx_dependency): Likewise.\n+\t(make_pass_remove_partial_avx_dependency): Likewise.\n+\t* config/i386/i386.md (avx_partial_xmm_update): New attribute.\n+\t(*extendsfdf2): Add avx_partial_xmm_update.\n+\t(truncdfsf2): Likewise.\n+\t(*float<SWI48:mode><MODEF:mode>2): Likewise.\n+\t(SF/DF conversion splitters): Disabled for TARGET_AVX.\n+\n 2019-02-22  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR middle-end/85598"}, {"sha": "f4facdc65d4c7162205f79bb706ef8b8b2b854a2", "filename": "gcc/config/i386/i386-passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-passes.def?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -31,3 +31,5 @@ along with GCC; see the file COPYING3.  If not see\n   INSERT_PASS_BEFORE (pass_cse2, 1, pass_stv, true /* timode_p */);\n \n   INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_endbranch);\n+\n+  INSERT_PASS_AFTER (pass_combine, 1, pass_remove_partial_avx_dependency);"}, {"sha": "83645e89a812155c2714a447c51dd6a4ae7c0cd7", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -369,3 +369,5 @@ class rtl_opt_pass;\n extern rtl_opt_pass *make_pass_insert_vzeroupper (gcc::context *);\n extern rtl_opt_pass *make_pass_stv (gcc::context *);\n extern rtl_opt_pass *make_pass_insert_endbranch (gcc::context *);\n+extern rtl_opt_pass *make_pass_remove_partial_avx_dependency\n+  (gcc::context *);"}, {"sha": "e77653d66a41cbb20ce74de32bccd40548c85aa5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -2793,6 +2793,180 @@ make_pass_insert_endbranch (gcc::context *ctxt)\n   return new pass_insert_endbranch (ctxt);\n }\n \n+/* At entry of the nearest common dominator for basic blocks with\n+   conversions, generate a single\n+\tvxorps %xmmN, %xmmN, %xmmN\n+   for all\n+\tvcvtss2sd  op, %xmmN, %xmmX\n+\tvcvtsd2ss  op, %xmmN, %xmmX\n+\tvcvtsi2ss  op, %xmmN, %xmmX\n+\tvcvtsi2sd  op, %xmmN, %xmmX\n+\n+   NB: We want to generate only a single vxorps to cover the whole\n+   function.  The LCM algorithm isn't appropriate here since it may\n+   place a vxorps inside the loop.  */\n+\n+static unsigned int\n+remove_partial_avx_dependency (void)\n+{\n+  timevar_push (TV_MACH_DEP);\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap convert_bbs = BITMAP_ALLOC (NULL);\n+\n+  basic_block bb;\n+  rtx_insn *insn, *set_insn;\n+  rtx set;\n+  rtx v4sf_const0 = NULL_RTX;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  set = single_set (insn);\n+\t  if (!set)\n+\t    continue;\n+\n+\t  if (get_attr_avx_partial_xmm_update (insn)\n+\t      != AVX_PARTIAL_XMM_UPDATE_TRUE)\n+\t    continue;\n+\n+\t  if (!v4sf_const0)\n+\t    v4sf_const0 = gen_reg_rtx (V4SFmode);\n+\n+\t  /* Convert PARTIAL_XMM_UPDATE_TRUE insns, DF -> SF, SF -> DF,\n+\t     SI -> SF, SI -> DF, DI -> SF, DI -> DF, to vec_dup and\n+\t     vec_merge with subreg.  */\n+\t  rtx src = SET_SRC (set);\n+\t  rtx dest = SET_DEST (set);\n+\t  machine_mode dest_mode = GET_MODE (dest);\n+\n+\t  rtx zero;\n+\t  machine_mode dest_vecmode;\n+\t  if (dest_mode == E_SFmode)\n+\t    {\n+\t      dest_vecmode = V4SFmode;\n+\t      zero = v4sf_const0;\n+\t    }\n+\t  else\n+\t    {\n+\t      dest_vecmode = V2DFmode;\n+\t      zero = gen_rtx_SUBREG (V2DFmode, v4sf_const0, 0);\n+\t    }\n+\n+\t  /* Change source to vector mode.  */\n+\t  src = gen_rtx_VEC_DUPLICATE (dest_vecmode, src);\n+\t  src = gen_rtx_VEC_MERGE (dest_vecmode, src, zero,\n+\t\t\t\t   GEN_INT (HOST_WIDE_INT_1U));\n+\t  /* Change destination to vector mode.  */\n+\t  rtx vec = gen_reg_rtx (dest_vecmode);\n+\t  /* Generate an XMM vector SET.  */\n+\t  set = gen_rtx_SET (vec, src);\n+\t  set_insn = emit_insn_before (set, insn);\n+\t  df_insn_rescan (set_insn);\n+\n+\t  src = gen_rtx_SUBREG (dest_mode, vec, 0);\n+\t  set = gen_rtx_SET (dest, src);\n+\n+\t  /* Drop possible dead definitions.  */\n+\t  PATTERN (insn) = set;\n+\n+\t  INSN_CODE (insn) = -1;\n+\t  recog_memoized (insn);\n+\t  df_insn_rescan (insn);\n+\t  bitmap_set_bit (convert_bbs, bb->index);\n+\t}\n+    }\n+\n+  if (v4sf_const0)\n+    {\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      df_set_flags (DF_DEFER_INSN_RESCAN);\n+      df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);\n+      df_md_add_problem ();\n+      df_analyze ();\n+\n+      /* (Re-)discover loops so that bb->loop_father can be used in the\n+\t analysis below.  */\n+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+\n+      /* Generate a vxorps at entry of the nearest dominator for basic\n+\t blocks with conversions, which is in the the fake loop that\n+\t contains the whole function, so that there is only a single\n+\t vxorps in the whole function.   */\n+      bb = nearest_common_dominator_for_set (CDI_DOMINATORS,\n+\t\t\t\t\t     convert_bbs);\n+      while (bb->loop_father->latch\n+\t     != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\tbb = get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t      bb->loop_father->header);\n+\n+      insn = BB_HEAD (bb);\n+      if (!NONDEBUG_INSN_P (insn))\n+\tinsn = next_nonnote_nondebug_insn (insn);\n+      set = gen_rtx_SET (v4sf_const0, CONST0_RTX (V4SFmode));\n+      set_insn = emit_insn_before (set, insn);\n+      df_insn_rescan (set_insn);\n+      df_process_deferred_rescans ();\n+      loop_optimizer_finalize ();\n+    }\n+\n+  bitmap_obstack_release (NULL);\n+  BITMAP_FREE (convert_bbs);\n+\n+  timevar_pop (TV_MACH_DEP);\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_remove_partial_avx_dependency =\n+{\n+  RTL_PASS, /* type */\n+  \"rpad\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_MACH_DEP, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_remove_partial_avx_dependency : public rtl_opt_pass\n+{\n+public:\n+  pass_remove_partial_avx_dependency (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_remove_partial_avx_dependency, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return (TARGET_AVX\n+\t      && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+\t      && TARGET_SSE_MATH\n+\t      && optimize\n+\t      && optimize_function_for_speed_p (cfun));\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return remove_partial_avx_dependency ();\n+    }\n+}; // class pass_rpad\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_remove_partial_avx_dependency (gcc::context *ctxt)\n+{\n+  return new pass_remove_partial_avx_dependency (ctxt);\n+}\n+\n /* Return true if a red-zone is in use.  We can't use red-zone when\n    there are local indirect jumps, like \"indirect_jump\" or \"tablejump\",\n    which jumps to another place in the function, since \"call\" in the"}, {"sha": "90f16608787c71265ff1d118fc1b1eb347098a27", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -778,6 +778,10 @@\n (define_attr \"i387_cw\" \"trunc,floor,ceil,uninitialized,any\"\n   (const_string \"any\"))\n \n+;; Define attribute to indicate AVX insns with partial XMM register update.\n+(define_attr \"avx_partial_xmm_update\" \"false,true\"\n+  (const_string \"false\"))\n+\n ;; Define attribute to classify add/sub insns that consumes carry flag (CF)\n (define_attr \"use_carry\" \"0,1\" (const_string \"0\"))\n \n@@ -4392,6 +4396,7 @@\n     }\n }\n   [(set_attr \"type\" \"fmov,fmov,ssecvt,ssecvt\")\n+   (set_attr \"avx_partial_xmm_update\" \"false,false,false,true\")\n    (set_attr \"prefix\" \"orig,orig,maybe_vex,maybe_vex\")\n    (set_attr \"mode\" \"SF,XF,DF,DF\")\n    (set (attr \"enabled\")\n@@ -4481,7 +4486,8 @@\n   [(set (match_operand:DF 0 \"sse_reg_operand\")\n         (float_extend:DF\n           (match_operand:SF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+  \"!TARGET_AVX\n+   && TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n    && (!REG_P (operands[1])\n        || (!TARGET_AVX && REGNO (operands[0]) != REGNO (operands[1])))\n@@ -4558,6 +4564,7 @@\n     }\n }\n   [(set_attr \"type\" \"fmov,fmov,ssecvt,ssecvt\")\n+   (set_attr \"avx_partial_xmm_update\" \"false,false,false,true\")\n    (set_attr \"mode\" \"SF\")\n    (set (attr \"enabled\")\n      (if_then_else\n@@ -4641,7 +4648,8 @@\n   [(set (match_operand:SF 0 \"sse_reg_operand\")\n         (float_truncate:SF\n \t  (match_operand:DF 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+  \"!TARGET_AVX\n+   && TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n    && (!REG_P (operands[1])\n        || (!TARGET_AVX && REGNO (operands[0]) != REGNO (operands[1])))\n@@ -5017,6 +5025,7 @@\n    %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\n    %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n   [(set_attr \"type\" \"fmov,sseicvt,sseicvt\")\n+   (set_attr \"avx_partial_xmm_update\" \"false,true,true\")\n    (set_attr \"prefix\" \"orig,maybe_vex,maybe_vex\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n    (set (attr \"prefix_rex\")\n@@ -5145,7 +5154,8 @@\n (define_split\n   [(set (match_operand:MODEF 0 \"sse_reg_operand\")\n \t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n-  \"TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n+  \"!TARGET_AVX\n+   && TARGET_SSE_PARTIAL_REG_DEPENDENCY && epilogue_completed\n    && optimize_function_for_speed_p (cfun)\n    && (!EXT_REX_SSE_REG_P (operands[0])\n        || TARGET_AVX512VL)\""}, {"sha": "5b2714478a2a8994997dc50163b91fde425dd86b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -1,3 +1,11 @@\n+2019-02-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Hongtao Liu  <hongtao.liu@intel.com>\n+\t    Sunil K Pandey  <sunil.k.pandey@intel.com>\n+\n+\tPR target/87007\n+\t* gcc.target/i386/pr87007-1.c: New test.\n+\t* gcc.target/i386/pr87007-2.c: Likewise.\n+\n 2019-02-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/89440"}, {"sha": "93cf1dcdfa552c1e8d8d6043af8005999e6ab561", "filename": "gcc/testsuite/gcc.target/i386/pr87007-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-1.c?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake\" } */\n+\n+extern float f;\n+extern double d;\n+extern int i;\n+\n+void\n+foo (void)\n+{\n+  d = f;\n+  f = i;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */"}, {"sha": "cca7ae7afbce4404e9b3167dd942fd1b3f2383b6", "filename": "gcc/testsuite/gcc.target/i386/pr87007-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14322806253059eb49011c2cfdbae4c85ad47e4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr87007-2.c?ref=f14322806253059eb49011c2cfdbae4c85ad47e4", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake\" } */\n+\n+extern float f;\n+extern double d;\n+extern int i;\n+\n+void\n+foo (int n, int k)\n+{\n+  for (int i = 0; i != n; i++)\n+    if(i < k)\n+      d = f;\n+    else\n+      f = i;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vxorps\\[^\\n\\r\\]*xmm\\[0-9\\]\" 1 } } */"}]}