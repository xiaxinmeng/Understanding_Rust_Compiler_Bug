{"sha": "ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4ZTA5OGQzZDlhZGViMDQ1MTIxNjk5NzRmZDY3YWNkOWI5Y2EwZg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-03-03T08:35:33Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-03-03T08:35:33Z"}, "message": "alias.c (rtx_equal_for_memref_p): Use predicates to test rtx classes and new rtx class codes...\n\n2004-02-07  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* alias.c (rtx_equal_for_memref_p): Use predicates\n\tto test rtx classes and new rtx class codes, possibly\n\tsplitting conditionals that tested against '<' and 'o'.\n\t* caller-save.c (save_call_clobbered_regs): Likewise.\n\t* combine.c (contains_muldiv, find_split_point, subst,\n\tcombine_simplify_rtx, simplify_if_then_else,\n\tsimplify_set, simplify_logical, expand_compound_operation,\n\tmake_compound_operation, if_then_else_cond, known_cond,\n\tapply_distributive_law, cached_nonzero_bits,\n\tcached_num_sign_bit_copies, simplify_shift_const,\n\tgen_binary, simplify_comparison, update_table_tick,\n\trecord_value_for_reg, get_lsat_value_validate): Likewise.\n\t* cse.c (mention_regs, find_best_addr, find_comparison_args,\n\tfold_rtx, cse_insn, invalidate_memory, cse_basic_block):\n\tLikewise.\n\t* emit-rtl.c (copy_insn_1): Likewise.\n\t* expr.c (force_operand): Likewise.\n\t* final.c (final_scan_insn, get_mem_expr_from_op): Likewise.\n\t* flow.c (notice_stack_pointer_modification_1,\n\tinvalidate_mems_from_autoinc, ior_reg_cond, not_reg_cond,\n\tand_reg_cond, elim_reg_cond): Likewise.\n\t* function.c (update_epilogue_consts): Likewise.\n\t* genattrtab.c (attr_rtx_1): Likewise.\n\t* genopinit.c (gen_insn): Likewise.\n\t* integrate.c (subst_constants): Likewise.\n\t* jump.c (reversed_comparison_code_parts,\n\treversed_comparison_code, delete_related_insns,\n\trtx_renumbered_equal_p): Likewise.\n\t* local-alloc.c (block_alloc): Likewise.\n\t* loop.c (rtx_equal_for_prefetch_p, maybe_eliminate_biv,\n\tcanonicalize_condition): Likewise.\n\t* loop-iv.c (simplify_using_conditions, iv_number_of_iterations):\n\tLikewise.\n\t* optabs.c (add_equal_node, expand_binop): Likewise.\n\t* predict.c (estimate_probability): Likewise.\n\t* ra-debug.c (ra_print_rtx_2op, ra_print_rtx): Likewise.\n\t* recog.c (validate_replace_rtx_1, comparison_operator,\n\toffsettable_address_p, constrain_operands): Likewise.\n\t* reg-stack.c (swap_rtx_condition_1, subst_stack_regs_pat):\n\tLikewise.\n\t* regclass.c (scan_one_insn): Likewise.\n\t* regmove.c (stable_and_no_regs_but_for_p): Likewise.\n\t* regrename.c (kill_autoinc_value): Likewise.\n\t* reload.c (find_reusable_reload, find_reloads,\n\treg_overlap_mentioned_for_reload_p): Likewise.\n\t* reload1.c (gen_reload, delete_address_reloads_1): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* rtl.h (CONSTANT_P, INSN_P): Likewise.\n\t* rtlanal.c (commutative_operand_precedence): Likewise.\n\t* sched-deps.c (conditions_mutex_p): Likewise.\n\t* sched-rgn.c (is_cfg_nonregular): Likewise.\n\t* simplify-rtx.c (simplify_gen_binary,\n\tsimplify_gen_relational, simplify_replace_rtx,\n\tsimplify_unary_operation, simplify_binary_operation,\n\tsimplify_ternary_operation, simplify_rtx): Likewise.\n\t* unroll.c (reg_dead_after_loop): Likewise.\n\t* config/alpha/alpha.c (alpha_swapped_comparison_operator,\n\tprint_operand): Likewise.\n\t* config/arc/arc.c (proper_comparison_operator): Likewise.\n\t* config/arm/arm.c (arm_arm_address_cost, arm_select_cc_mode):\n\tLikewise.\n\t* config/avr/avr.c (_reg_unused_after): Likewise.\n\t* config/frv/frv.c (frv_ifcvt_modify_tests,\n\tfrv_ifcvt_modify_insn, frv_pack_insn): Likewise.\n\t* config/i386/i386.c (ix86_comparison_operator,\n\tix86_carry_flag_operator, fcmov_comparison_operator,\n\tarith_or_logical_operator, print_operand,\n\tix86_expand_binary_operator, ix86_binary_operator_ok):\n\tLikewise.\n\t* config/i386/i386.md: Likewise.\n\t* config/ia64/ia64.c (not_postinc_memory_operand,\n\tia64_print_operand, update_set_flags, errata_emit_nops):\n\tLikewise.\n\t* config/ia64/ia64.h (PREFERRED_RELOAD_CLASS,\n\tCONSTRAINT_OK_FOR_S): Likewise.\n\t* config/ip2k/ip2k.c (mdr_resequence_xy_yx,\n\tmdr_try_move_dp_reload, ip2k_check_can_adjust_stack_ref,\n\tip2k_xexp_not_uses_reg_for_mem, ip2k_xexp_not_uses_reg_p,\n\tip2k_composite_xexp_not_uses_reg_p, ip2k_unary_operator):\n\tLikewise.\n\t* config/iq2000/iq2000.c (cmp_op, symbolic_expression_p,\n\teqne_comparison_operator, signed_comparison_operator):\n\tLikewise.\n\t* config/mips/mips.c (cmp_op, symbolic_expression_p):\n\tLikewise.\n\t* config/mmix/mmix (mmix_foldable_comparison_operator,\n\tmmix_comparison_operator): Likewise.\n\t* config/pa/pa.c (hppa_legitimize_address): Likewise.\n\t* config/rs6000/rs6000.c (stmw_operation,\n\tbranch_comparison_operator, trap_comparison_operator,\n\tccr_bit): Likewise.\n\t* config/rs6000/rs6000.h (SELECT_CC_MODE): Likewise.\n\t* config/s390/s390.c (s390_alc_comparison,\n\ts390_slb_comparison):L Likewise.\n\t* config/sh/sh.c (gen_block_redirect, reg_unused_after):\n\tLikewise.\n\t* config/sparc/sparc.c (eq_or_neq, normal_comp_operator,\n\tnoov_compare_op, noov_compare64_op, v9_regcmp_op,\n\temit_hard_tfmode_operation, reg_unused_after)\n\t* doc/md.texi, doc/rtl.texi: Likewise.\n\n\t* ra-debug.c: Add 2004 to list of copyright years.\n\t* unroll.c: Likewise.\n\n\t* combine.c (simplify_logical): Remove dummy test,\n\t(apply_distributive_law): Fix typo in comment.\n\tGET_CODE (x) == AND so x is a commutative binary op.\n\t* jump.c (delete_related_insns): simplify loop\n\tcondition, move testing of RTX codes inside the loop.\n\t(rtx_renumbered_equal_p): do not use RTX_CODE.\n\t* rtl.c (rtx_class): Declare as enum rtx_class.\n\t* rtl.def (EQ, NE, UNEQ, LTGT, UNORDERED, ORDERED):\n\tMove to RTX_COMM_COMPARE class.\n\t(HIGH, SYMBOL_REF, LABEL_REF, CONST, CONST_INT, CONST_DOUBLE):\n\tMove to RTX_CONST_OBJ class.\n\t* rtl.h (enum rtx_class): New declaration,\n\t(RTX_OBJ_MASK, RTX_OBJ_RESULT, RTX_COMPARE_MASK,\n\tRTX_COMPARE_RESULT, RTX_ARITHMETIC_MASK, RTX_ARITHMETIC_RESULT,\n\tRTX_BINARY_MASK, RTX_BINARY_RESULT, RTX_COMMUTATIVE_MASK,\n\tRTX_COMMUTATIVE_RESULT, RTX_NON_COMMUTATIVE_RESULT,\n\tRTX_EXPR_FIRST, RTX_EXPR_LAST, UNARY_P, BINARY_P,\n\tARITHMETIC_P, COMMUTATIVE_ARITHMETIC_P, COMPARISON_P,\n\tSWAPPABLE_OPERANDS_P, NON_COMMUTATIVE_P, COMMUTATIVE_P,\n\tOBJECT_P): New macros.\n\t* config/sparc/sparc.c (noov_compare_op): Remove register\n\tfrom parameter.\n\nFrom-SVN: r78824", "tree": {"sha": "79c63a2ca1f9598f1822ace38905a1fe19aeb364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79c63a2ca1f9598f1822ace38905a1fe19aeb364"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a841ab8b3ea849b3146285b09ecb60ad81c011bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a841ab8b3ea849b3146285b09ecb60ad81c011bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a841ab8b3ea849b3146285b09ecb60ad81c011bf"}], "stats": {"total": 1635, "additions": 935, "deletions": 700}, "files": [{"sha": "e5e5266dde674655a4bb38f7d8521e6c36dbc344", "filename": "gcc/ChangeLog", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1,3 +1,132 @@\n+2004-03-03  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* alias.c (rtx_equal_for_memref_p): Use predicates\n+\tto test rtx classes and new rtx class codes, possibly\n+\tsplitting conditionals that tested against '<' and 'o'.\n+\t* caller-save.c (save_call_clobbered_regs): Likewise.\n+\t* combine.c (contains_muldiv, find_split_point, subst,\n+\tcombine_simplify_rtx, simplify_if_then_else,\n+\tsimplify_set, simplify_logical, expand_compound_operation,\n+\tmake_compound_operation, if_then_else_cond, known_cond,\n+\tapply_distributive_law, cached_nonzero_bits,\n+\tcached_num_sign_bit_copies, simplify_shift_const,\n+\tgen_binary, simplify_comparison, update_table_tick,\n+\trecord_value_for_reg, get_lsat_value_validate): Likewise.\n+\t* cse.c (mention_regs, find_best_addr, find_comparison_args,\n+\tfold_rtx, cse_insn, invalidate_memory, cse_basic_block):\n+\tLikewise.\n+\t* emit-rtl.c (copy_insn_1): Likewise.\n+\t* expr.c (force_operand): Likewise.\n+\t* final.c (final_scan_insn, get_mem_expr_from_op): Likewise.\n+\t* flow.c (notice_stack_pointer_modification_1,\n+\tinvalidate_mems_from_autoinc, ior_reg_cond, not_reg_cond,\n+\tand_reg_cond, elim_reg_cond): Likewise.\n+\t* function.c (update_epilogue_consts): Likewise.\n+\t* genattrtab.c (attr_rtx_1): Likewise.\n+\t* genopinit.c (gen_insn): Likewise.\n+\t* integrate.c (subst_constants): Likewise.\n+\t* jump.c (reversed_comparison_code_parts,\n+\treversed_comparison_code, delete_related_insns,\n+\trtx_renumbered_equal_p): Likewise.\n+\t* local-alloc.c (block_alloc): Likewise.\n+\t* loop.c (rtx_equal_for_prefetch_p, maybe_eliminate_biv,\n+\tcanonicalize_condition): Likewise.\n+\t* loop-iv.c (simplify_using_conditions, iv_number_of_iterations):\n+\tLikewise.\n+\t* optabs.c (add_equal_node, expand_binop): Likewise.\n+\t* predict.c (estimate_probability): Likewise.\n+\t* ra-debug.c (ra_print_rtx_2op, ra_print_rtx): Likewise.\n+\t* recog.c (validate_replace_rtx_1, comparison_operator,\n+\toffsettable_address_p, constrain_operands): Likewise.\n+\t* reg-stack.c (swap_rtx_condition_1, subst_stack_regs_pat):\n+\tLikewise.\n+\t* regclass.c (scan_one_insn): Likewise.\n+\t* regmove.c (stable_and_no_regs_but_for_p): Likewise.\n+\t* regrename.c (kill_autoinc_value): Likewise.\n+\t* reload.c (find_reusable_reload, find_reloads,\n+\treg_overlap_mentioned_for_reload_p): Likewise.\n+\t* reload1.c (gen_reload, delete_address_reloads_1): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* rtl.h (CONSTANT_P, INSN_P): Likewise.\n+\t* rtlanal.c (commutative_operand_precedence): Likewise.\n+\t* sched-deps.c (conditions_mutex_p): Likewise.\n+\t* sched-rgn.c (is_cfg_nonregular): Likewise.\n+\t* simplify-rtx.c (simplify_gen_binary,\n+\tsimplify_gen_relational, simplify_replace_rtx,\n+\tsimplify_unary_operation, simplify_binary_operation,\n+\tsimplify_ternary_operation, simplify_rtx): Likewise.\n+\t* unroll.c (reg_dead_after_loop): Likewise.\n+\t* config/alpha/alpha.c (alpha_swapped_comparison_operator,\n+\tprint_operand): Likewise.\n+\t* config/arc/arc.c (proper_comparison_operator): Likewise.\n+\t* config/arm/arm.c (arm_arm_address_cost, arm_select_cc_mode):\n+\tLikewise.\n+\t* config/avr/avr.c (_reg_unused_after): Likewise.\n+\t* config/frv/frv.c (frv_ifcvt_modify_tests,\n+\tfrv_ifcvt_modify_insn, frv_pack_insn): Likewise.\n+\t* config/i386/i386.c (ix86_comparison_operator,\n+\tix86_carry_flag_operator, fcmov_comparison_operator,\n+\tarith_or_logical_operator, print_operand,\n+\tix86_expand_binary_operator, ix86_binary_operator_ok):\n+\tLikewise.\n+\t* config/i386/i386.md: Likewise.\n+\t* config/ia64/ia64.c (not_postinc_memory_operand,\n+\tia64_print_operand, update_set_flags, errata_emit_nops):\n+\tLikewise.\n+\t* config/ia64/ia64.h (PREFERRED_RELOAD_CLASS,\n+\tCONSTRAINT_OK_FOR_S): Likewise.\n+\t* config/ip2k/ip2k.c (mdr_resequence_xy_yx,\n+\tmdr_try_move_dp_reload, ip2k_check_can_adjust_stack_ref,\n+\tip2k_xexp_not_uses_reg_for_mem, ip2k_xexp_not_uses_reg_p,\n+\tip2k_composite_xexp_not_uses_reg_p, ip2k_unary_operator):\n+\tLikewise.\n+\t* config/iq2000/iq2000.c (cmp_op, symbolic_expression_p,\n+\teqne_comparison_operator, signed_comparison_operator):\n+\tLikewise.\n+\t* config/mips/mips.c (cmp_op, symbolic_expression_p):\n+\tLikewise.\n+\t* config/mmix/mmix (mmix_foldable_comparison_operator,\n+\tmmix_comparison_operator): Likewise.\n+\t* config/pa/pa.c (hppa_legitimize_address): Likewise.\n+\t* config/rs6000/rs6000.c (stmw_operation,\n+\tbranch_comparison_operator, trap_comparison_operator,\n+\tccr_bit): Likewise.\n+\t* config/rs6000/rs6000.h (SELECT_CC_MODE): Likewise.\n+\t* config/s390/s390.c (s390_alc_comparison,\n+\ts390_slb_comparison):L Likewise.\n+\t* config/sh/sh.c (gen_block_redirect, reg_unused_after):\n+\tLikewise.\n+\t* config/sparc/sparc.c (eq_or_neq, normal_comp_operator,\n+\tnoov_compare_op, noov_compare64_op, v9_regcmp_op,\n+\temit_hard_tfmode_operation, reg_unused_after)\n+\t* doc/md.texi, doc/rtl.texi: Likewise.\n+\n+\t* ra-debug.c: Add 2004 to list of copyright years.\n+\t* unroll.c: Likewise.\n+\n+\t* combine.c (simplify_logical): Remove dummy test,\n+\t(apply_distributive_law): Fix typo in comment.\n+\tGET_CODE (x) == AND so x is a commutative binary op.\n+\t* jump.c (delete_related_insns): simplify loop\n+\tcondition, move testing of RTX codes inside the loop.\n+\t(rtx_renumbered_equal_p): do not use RTX_CODE.\n+\t* rtl.c (rtx_class): Declare as enum rtx_class.\n+\t* rtl.def (EQ, NE, UNEQ, LTGT, UNORDERED, ORDERED):\n+\tMove to RTX_COMM_COMPARE class.\n+\t(HIGH, SYMBOL_REF, LABEL_REF, CONST, CONST_INT, CONST_DOUBLE):\n+\tMove to RTX_CONST_OBJ class.\n+\t* rtl.h (enum rtx_class): New declaration,\n+\t(RTX_OBJ_MASK, RTX_OBJ_RESULT, RTX_COMPARE_MASK,\n+\tRTX_COMPARE_RESULT, RTX_ARITHMETIC_MASK, RTX_ARITHMETIC_RESULT,\n+\tRTX_BINARY_MASK, RTX_BINARY_RESULT, RTX_COMMUTATIVE_MASK,\n+\tRTX_COMMUTATIVE_RESULT, RTX_NON_COMMUTATIVE_RESULT,\n+\tRTX_EXPR_FIRST, RTX_EXPR_LAST, UNARY_P, BINARY_P,\n+\tARITHMETIC_P, COMMUTATIVE_ARITHMETIC_P, COMPARISON_P,\n+\tSWAPPABLE_OPERANDS_P, NON_COMMUTATIVE_P, COMMUTATIVE_P,\n+\tOBJECT_P): New macros.\n+\t* config/sparc/sparc.c (noov_compare_op): Remove register\n+\tfrom parameter.\n+\n 2004-03-03  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* target.h: Remove texi jargons in comments."}, {"sha": "d670a7db19e9591a047742eb60ea58554409bae7", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1173,7 +1173,7 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n \t\t&& rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 0))));\n   /* For commutative operations, the RTX match if the operand match in any\n      order.  Also handle the simple binary and unary cases without a loop.  */\n-  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n+  if (COMMUTATIVE_P (x))\n     {\n       rtx xop0 = canon_rtx (XEXP (x, 0));\n       rtx yop0 = canon_rtx (XEXP (y, 0));\n@@ -1184,14 +1184,14 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n \t      || (rtx_equal_for_memref_p (xop0, yop1)\n \t\t  && rtx_equal_for_memref_p (canon_rtx (XEXP (x, 1)), yop0)));\n     }\n-  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n+  else if (NON_COMMUTATIVE_P (x))\n     {\n       return (rtx_equal_for_memref_p (canon_rtx (XEXP (x, 0)),\n \t\t\t\t      canon_rtx (XEXP (y, 0)))\n \t      && rtx_equal_for_memref_p (canon_rtx (XEXP (x, 1)),\n \t\t\t\t\t canon_rtx (XEXP (y, 1))));\n     }\n-  else if (GET_RTX_CLASS (code) == '1')\n+  else if (UNARY_P (x))\n     return rtx_equal_for_memref_p (canon_rtx (XEXP (x, 0)),\n \t\t\t\t   canon_rtx (XEXP (y, 0)));\n \n@@ -1261,7 +1261,7 @@ find_symbolic_term (rtx x)\n   code = GET_CODE (x);\n   if (code == SYMBOL_REF || code == LABEL_REF)\n     return x;\n-  if (GET_RTX_CLASS (code) == 'o')\n+  if (OBJECT_P (x))\n     return 0;\n \n   fmt = GET_RTX_FORMAT (code);"}, {"sha": "da083da144685a65c761f4e6f6735a5bef6474be", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -384,7 +384,7 @@ save_call_clobbered_regs (void)\n       if (chain->is_caller_save_insn)\n \tabort ();\n \n-      if (GET_RTX_CLASS (code) == 'i')\n+      if (INSN_P (insn))\n \t{\n \t  /* If some registers have been saved, see if INSN references\n \t     any of them.  We must restore them before the insn if so.  */"}, {"sha": "c21d5c90f99cee9a8bcd2bcb67796ee57550463c", "filename": "gcc/combine.c", "status": "modified", "additions": 104, "deletions": 135, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1340,18 +1340,14 @@ contains_muldiv (rtx x)\n       return ! (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t\t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0);\n     default:\n-      switch (GET_RTX_CLASS (GET_CODE (x)))\n-\t{\n-\tcase 'c':  case '<':  case '2':\n-\t  return contains_muldiv (XEXP (x, 0))\n+      if (BINARY_P (x))\n+\treturn contains_muldiv (XEXP (x, 0))\n \t    || contains_muldiv (XEXP (x, 1));\n \n-\tcase '1':\n-\t  return contains_muldiv (XEXP (x, 0));\n+      if (UNARY_P (x))\n+\treturn contains_muldiv (XEXP (x, 0));\n \n-\tdefault:\n-\t  return 0;\n-\t}\n+      return 0;\n     }\n }\n \f\n@@ -2959,10 +2955,9 @@ find_split_point (rtx *loc, rtx insn)\n \t     This will occur on machines that just support REG + CONST\n \t     and have a constant moved through some previous computation.  */\n \n-\t  else if (GET_RTX_CLASS (GET_CODE (XEXP (XEXP (x, 0), 0))) != 'o'\n+\t  else if (!OBJECT_P (XEXP (XEXP (x, 0), 0))\n \t\t   && ! (GET_CODE (XEXP (XEXP (x, 0), 0)) == SUBREG\n-\t\t\t && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (XEXP (x, 0), 0))))\n-\t\t\t     == 'o')))\n+\t\t\t && OBJECT_P (SUBREG_REG (XEXP (XEXP (x, 0), 0)))))\n \t    return &XEXP (XEXP (x, 0), 0);\n \t}\n       break;\n@@ -2977,9 +2972,9 @@ find_split_point (rtx *loc, rtx insn)\n       if (SET_DEST (x) == cc0_rtx\n \t  && GET_CODE (SET_SRC (x)) != COMPARE\n \t  && GET_CODE (SET_SRC (x)) != ZERO_EXTRACT\n-\t  && GET_RTX_CLASS (GET_CODE (SET_SRC (x))) != 'o'\n+\t  && !OBJECT_P (SET_SRC (x))\n \t  && ! (GET_CODE (SET_SRC (x)) == SUBREG\n-\t\t&& GET_RTX_CLASS (GET_CODE (SUBREG_REG (SET_SRC (x)))) == 'o'))\n+\t\t&& OBJECT_P (SUBREG_REG (SET_SRC (x)))))\n \treturn &SET_SRC (x);\n #endif\n \n@@ -3170,25 +3165,19 @@ find_split_point (rtx *loc, rtx insn)\n       /* See if this is a simple operation with a constant as the second\n \t operand.  It might be that this constant is out of range and hence\n \t could be used as a split point.  */\n-      if ((GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == 'c'\n-\t   || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '<')\n+      if (BINARY_P (SET_SRC (x))\n \t  && CONSTANT_P (XEXP (SET_SRC (x), 1))\n-\t  && (GET_RTX_CLASS (GET_CODE (XEXP (SET_SRC (x), 0))) == 'o'\n+\t  && (OBJECT_P (XEXP (SET_SRC (x), 0))\n \t      || (GET_CODE (XEXP (SET_SRC (x), 0)) == SUBREG\n-\t\t  && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (SET_SRC (x), 0))))\n-\t\t      == 'o'))))\n+\t\t  && OBJECT_P (SUBREG_REG (XEXP (SET_SRC (x), 0))))))\n \treturn &XEXP (SET_SRC (x), 1);\n \n       /* Finally, see if this is a simple operation with its first operand\n \t not in a register.  The operation might require this operand in a\n \t register, so return it as a split point.  We can always do this\n \t because if the first operand were another operation, we would have\n \t already found it as a split point.  */\n-      if ((GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == 'c'\n-\t   || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '<'\n-\t   || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '1')\n+      if ((BINARY_P (SET_SRC (x)) || UNARY_P (SET_SRC (x)))\n \t  && ! register_operand (XEXP (SET_SRC (x), 0), VOIDmode))\n \treturn &XEXP (SET_SRC (x), 0);\n \n@@ -3228,20 +3217,21 @@ find_split_point (rtx *loc, rtx insn)\n   /* Otherwise, select our actions depending on our rtx class.  */\n   switch (GET_RTX_CLASS (code))\n     {\n-    case 'b':\t\t\t/* This is ZERO_EXTRACT and SIGN_EXTRACT.  */\n-    case '3':\n+    case RTX_BITFIELD_OPS:\t\t/* This is ZERO_EXTRACT and SIGN_EXTRACT.  */\n+    case RTX_TERNARY:\n       split = find_split_point (&XEXP (x, 2), insn);\n       if (split)\n \treturn split;\n       /* ... fall through ...  */\n-    case '2':\n-    case 'c':\n-    case '<':\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n       split = find_split_point (&XEXP (x, 1), insn);\n       if (split)\n \treturn split;\n       /* ... fall through ...  */\n-    case '1':\n+    case RTX_UNARY:\n       /* Some machines have (and (shift ...) ...) insns.  If X is not\n \t an AND, but XEXP (X, 0) is, use it as our split point.  */\n       if (GET_CODE (x) != AND && GET_CODE (XEXP (x, 0)) == AND)\n@@ -3251,10 +3241,11 @@ find_split_point (rtx *loc, rtx insn)\n       if (split)\n \treturn split;\n       return loc;\n-    }\n \n-  /* Otherwise, we don't have a split point.  */\n-  return 0;\n+    default:\n+      /* Otherwise, we don't have a split point.  */\n+      return 0;\n+    }\n }\n \f\n /* Throughout X, replace FROM with TO, and return the result.\n@@ -3313,7 +3304,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \n   /* If this is an object, we are done unless it is a MEM or LO_SUM, both\n      of which may contain things that can be combined.  */\n-  if (code != MEM && code != LO_SUM && GET_RTX_CLASS (code) == 'o')\n+  if (code != MEM && code != LO_SUM && OBJECT_P (x))\n     return x;\n \n   /* It is possible to have a subexpression appear twice in the insn.\n@@ -3560,7 +3551,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \n   /* If this is a commutative operation, put a constant last and a complex\n      expression first.  We don't need to do this for comparisons here.  */\n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (COMMUTATIVE_ARITH_P (x)\n       && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n     {\n       temp = XEXP (x, 0);\n@@ -3616,36 +3607,31 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \n      Don't do anything if all operands are very simple.  */\n \n-  if (((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c'\n-\t|| GET_RTX_CLASS (code) == '<')\n-       && ((GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n+  if ((BINARY_P (x)\n+       && ((!OBJECT_P (XEXP (x, 0))\n \t    && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t\t  && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0))))\n-\t\t      == 'o')))\n-\t   || (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) != 'o'\n+\t\t  && OBJECT_P (SUBREG_REG (XEXP (x, 0)))))\n+\t   || (!OBJECT_P (XEXP (x, 1))\n \t       && ! (GET_CODE (XEXP (x, 1)) == SUBREG\n-\t\t     && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 1))))\n-\t\t\t == 'o')))))\n-      || (GET_RTX_CLASS (code) == '1'\n-\t  && ((GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n+\t\t     && OBJECT_P (SUBREG_REG (XEXP (x, 1)))))))\n+      || (UNARY_P (x)\n+          && (!OBJECT_P (XEXP (x, 0))\n \t       && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t\t     && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0))))\n-\t\t\t == 'o'))))))\n+\t\t     && OBJECT_P (SUBREG_REG (XEXP (x, 0)))))))\n     {\n       rtx cond, true_rtx, false_rtx;\n \n       cond = if_then_else_cond (x, &true_rtx, &false_rtx);\n       if (cond != 0\n \t  /* If everything is a comparison, what we have is highly unlikely\n \t     to be simpler, so don't use it.  */\n-\t  && ! (GET_RTX_CLASS (code) == '<'\n-\t\t&& (GET_RTX_CLASS (GET_CODE (true_rtx)) == '<'\n-\t\t    || GET_RTX_CLASS (GET_CODE (false_rtx)) == '<')))\n+\t  && ! (COMPARISON_P (x)\n+\t\t&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx))))\n \t{\n \t  rtx cop1 = const0_rtx;\n \t  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);\n \n-\t  if (cond_code == NE && GET_RTX_CLASS (GET_CODE (cond)) == '<')\n+\t  if (cond_code == NE && COMPARISON_P (cond))\n \t    return x;\n \n \t  /* Simplify the alternative arms; this may collapse the true and\n@@ -3711,12 +3697,13 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n   temp = 0;\n   switch (GET_RTX_CLASS (code))\n     {\n-    case '1':\n+    case RTX_UNARY:\n       if (op0_mode == VOIDmode)\n \top0_mode = GET_MODE (XEXP (x, 0));\n       temp = simplify_unary_operation (code, mode, XEXP (x, 0), op0_mode);\n       break;\n-    case '<':\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n       {\n \tenum machine_mode cmp_mode = GET_MODE (XEXP (x, 0));\n \tif (cmp_mode == VOIDmode)\n@@ -3739,15 +3726,17 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t}\n #endif\n       break;\n-    case 'c':\n-    case '2':\n+    case RTX_COMM_ARITH:\n+    case RTX_BIN_ARITH:\n       temp = simplify_binary_operation (code, mode, XEXP (x, 0), XEXP (x, 1));\n       break;\n-    case 'b':\n-    case '3':\n+    case RTX_BITFIELD_OPS:\n+    case RTX_TERNARY:\n       temp = simplify_ternary_operation (code, mode, op0_mode, XEXP (x, 0),\n \t\t\t\t\t XEXP (x, 1), XEXP (x, 2));\n       break;\n+    default:\n+      break;\n     }\n \n   if (temp)\n@@ -3785,7 +3774,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \n \t  /* Make sure we pass the constant operand if any as the second\n \t     one if this is a commutative operation.  */\n-\t  if (CONSTANT_P (inner_op0) && GET_RTX_CLASS (code) == 'c')\n+\t  if (CONSTANT_P (inner_op0) && COMMUTATIVE_ARITH_P (x))\n \t    {\n \t      rtx tem = inner_op0;\n \t      inner_op0 = inner_op1;\n@@ -3798,7 +3787,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \n \t  /* For commutative operations, try the other pair if that one\n \t     didn't simplify.  */\n-\t  if (inner == 0 && GET_RTX_CLASS (code) == 'c')\n+\t  if (inner == 0 && COMMUTATIVE_ARITH_P (x))\n \t    {\n \t      other = XEXP (XEXP (x, 0), 1);\n \t      inner = simplify_binary_operation (code, mode,\n@@ -4006,7 +3995,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n          but it works even if the comparison is done in a mode larger\n          than HOST_BITS_PER_WIDE_INT.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && COMPARISON_P (XEXP (x, 0))\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n \treturn gen_lowpart (mode, XEXP (x, 0));\n \n@@ -4016,7 +4005,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0\n \t  && (temp = get_last_value (XEXP (x, 0)))\n-\t  && GET_RTX_CLASS (GET_CODE (temp)) == '<')\n+\t  && COMPARISON_P (temp))\n \treturn gen_lowpart (mode, XEXP (x, 0));\n \n       break;\n@@ -4182,7 +4171,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t C is 1 and STORE_FLAG_VALUE is -1 or if C is -1 and STORE_FLAG_VALUE\n \t is 1.  This produces better code than the alternative immediately\n \t below.  */\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+      if (COMPARISON_P (XEXP (x, 0))\n \t  && ((STORE_FLAG_VALUE == -1 && XEXP (x, 1) == const1_rtx)\n \t      || (STORE_FLAG_VALUE == 1 && XEXP (x, 1) == constm1_rtx))\n \t  && (reversed = reversed_comparison (XEXP (x, 0), mode,\n@@ -4232,7 +4221,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int last,\n \t by reversing the comparison code if valid.  */\n       if (STORE_FLAG_VALUE == 1\n \t  && XEXP (x, 0) == const1_rtx\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<'\n+\t  && COMPARISON_P (XEXP (x, 1))\n \t  && (reversed = reversed_comparison (XEXP (x, 1), mode,\n \t\t\t\t\t      XEXP (XEXP (x, 1), 0),\n \t\t\t\t\t      XEXP (XEXP (x, 1), 1))))\n@@ -4625,7 +4614,7 @@ simplify_if_then_else (rtx x)\n   rtx true_rtx = XEXP (x, 1);\n   rtx false_rtx = XEXP (x, 2);\n   enum rtx_code true_code = GET_CODE (cond);\n-  int comparison_p = GET_RTX_CLASS (true_code) == '<';\n+  int comparison_p = COMPARISON_P (cond);\n   rtx temp;\n   int i;\n   enum rtx_code false_code;\n@@ -4710,11 +4699,9 @@ simplify_if_then_else (rtx x)\n \t  || (CONSTANT_P (true_rtx)\n \t      && GET_CODE (false_rtx) != CONST_INT && false_rtx != pc_rtx)\n \t  || true_rtx == const0_rtx\n-\t  || (GET_RTX_CLASS (GET_CODE (true_rtx)) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (false_rtx)) != 'o')\n-\t  || (GET_CODE (true_rtx) == SUBREG\n-\t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (true_rtx))) == 'o'\n-\t      && GET_RTX_CLASS (GET_CODE (false_rtx)) != 'o')\n+\t  || (OBJECT_P (true_rtx) && !OBJECT_P (false_rtx))\n+\t  || (GET_CODE (true_rtx) == SUBREG && OBJECT_P (SUBREG_REG (true_rtx))\n+\t      && !OBJECT_P (false_rtx))\n \t  || reg_mentioned_p (true_rtx, false_rtx)\n \t  || rtx_equal_p (false_rtx, XEXP (cond, 0))))\n     {\n@@ -4731,7 +4718,7 @@ simplify_if_then_else (rtx x)\n \n       /* It is possible that the conditional has been simplified out.  */\n       true_code = GET_CODE (cond);\n-      comparison_p = GET_RTX_CLASS (true_code) == '<';\n+      comparison_p = COMPARISON_P (cond);\n     }\n \n   /* If the two arms are identical, we don't need the comparison.  */\n@@ -4984,7 +4971,7 @@ simplify_set (rtx x)\n        || CC0_P (dest))\n       && (cc_use = find_single_use (dest, subst_insn, &other_insn)) != 0\n       && (undobuf.other_insn == 0 || other_insn == undobuf.other_insn)\n-      && GET_RTX_CLASS (GET_CODE (*cc_use)) == '<'\n+      && COMPARISON_P (*cc_use)\n       && rtx_equal_p (XEXP (*cc_use, 0), dest))\n     {\n       enum rtx_code old_code = GET_CODE (*cc_use);\n@@ -5147,7 +5134,7 @@ simplify_set (rtx x)\n      as long as M1 and M2 have the same number of words.  */\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n-      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (src))) != 'o'\n+      && !OBJECT_P (SUBREG_REG (src))\n       && (((GET_MODE_SIZE (GET_MODE (src)) + (UNITS_PER_WORD - 1))\n \t   / UNITS_PER_WORD)\n \t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n@@ -5351,9 +5338,8 @@ simplify_logical (rtx x, int last)\n \t  if (GET_CODE (x) != AND)\n \t    return x;\n \n-\t  if (GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-\t      || GET_RTX_CLASS (GET_CODE (x)) == '2')\n-\t    op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n+\t  op0 = XEXP (x, 0);\n+\t  op1 = XEXP (x, 1);\n \t}\n \n       /* Convert (A | B) & A to A.  */\n@@ -5548,7 +5534,7 @@ simplify_logical (rtx x, int last)\n \t comparison if STORE_FLAG_VALUE is 1.  */\n       if (STORE_FLAG_VALUE == 1\n \t  && op1 == const1_rtx\n-\t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n+\t  && COMPARISON_P (op0)\n \t  && (reversed = reversed_comparison (op0, mode, XEXP (op0, 0),\n \t\t\t\t\t      XEXP (op0, 1))))\n \treturn reversed;\n@@ -5570,7 +5556,7 @@ simplify_logical (rtx x, int last)\n \t  && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n \t      == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t  && op1 == const_true_rtx\n-\t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n+\t  && COMPARISON_P (op0)\n \t  && (reversed = reversed_comparison (op0, mode, XEXP (op0, 0),\n \t\t\t\t\t      XEXP (op0, 1))))\n \treturn reversed;\n@@ -5734,7 +5720,7 @@ expand_compound_operation (rtx x)\n          than HOST_WIDE_INT.  */\n       if (GET_CODE (XEXP (x, 0)) == TRUNCATE\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (XEXP (x, 0), 0))) == '<'\n+\t  && COMPARISON_P (XEXP (XEXP (x, 0), 0))\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n@@ -5745,7 +5731,7 @@ expand_compound_operation (rtx x)\n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t  && GET_MODE (SUBREG_REG (XEXP (x, 0))) == GET_MODE (x)\n \t  && subreg_lowpart_p (XEXP (x, 0))\n-\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0)))) == '<'\n+\t  && COMPARISON_P (SUBREG_REG (XEXP (x, 0)))\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n@@ -6426,7 +6412,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n      but once inside, go back to our default of SET.  */\n \n   next_code = (code == MEM || code == PLUS || code == MINUS ? MEM\n-\t       : ((code == COMPARE || GET_RTX_CLASS (code) == '<')\n+\t       : ((code == COMPARE || COMPARISON_P (x))\n \t\t  && XEXP (x, 1) == const0_rtx) ? COMPARE\n \t       : in_code == COMPARE ? SET : in_code);\n \n@@ -6592,9 +6578,9 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t also do this for some cases of SIGN_EXTRACT, but it doesn't\n \t seem worth the effort; the case checked for occurs on Alpha.  */\n \n-      if (GET_RTX_CLASS (GET_CODE (lhs)) != 'o'\n+      if (!OBJECT_P (lhs)\n \t  && ! (GET_CODE (lhs) == SUBREG\n-\t\t&& (GET_RTX_CLASS (GET_CODE (SUBREG_REG (lhs))) == 'o'))\n+\t\t&& (OBJECT_P (SUBREG_REG (lhs))))\n \t  && GET_CODE (rhs) == CONST_INT\n \t  && INTVAL (rhs) < HOST_BITS_PER_WIDE_INT\n \t  && (new = extract_left_shift (lhs, INTVAL (rhs))) != 0)\n@@ -7277,7 +7263,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \n   /* If this is a unary operation whose operand has one of two values, apply\n      our opcode to compute those values.  */\n-  else if (GET_RTX_CLASS (code) == '1'\n+  else if (UNARY_P (x)\n \t   && (cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0)) != 0)\n     {\n       *ptrue = simplify_gen_unary (code, mode, true0, GET_MODE (XEXP (x, 0)));\n@@ -7294,8 +7280,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n   /* If this is a binary operation, see if either side has only one of two\n      values.  If either one does or if both do and they are conditional on\n      the same value, compute the new true and false values.  */\n-  else if (GET_RTX_CLASS (code) == 'c' || GET_RTX_CLASS (code) == '2'\n-\t   || GET_RTX_CLASS (code) == '<')\n+  else if (BINARY_P (x))\n     {\n       cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0);\n       cond1 = if_then_else_cond (XEXP (x, 1), &true1, &false1);\n@@ -7331,8 +7316,8 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t  cond0 = XEXP (XEXP (x, 0), 0);\n \t  cond1 = XEXP (XEXP (x, 1), 0);\n \n-\t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n-\t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n+\t  if (COMPARISON_P (cond0)\n+\t      && COMPARISON_P (cond1)\n \t      && ((GET_CODE (cond0) == combine_reversed_comparison_code (cond1)\n \t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n \t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n@@ -7362,8 +7347,8 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t  cond0 = XEXP (XEXP (x, 0), 0);\n \t  cond1 = XEXP (XEXP (x, 1), 0);\n \n-\t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n-\t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n+\t  if (COMPARISON_P (cond0)\n+\t      && COMPARISON_P (cond1)\n \t      && ((GET_CODE (cond0) == combine_reversed_comparison_code (cond1)\n \t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n \t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n@@ -7497,14 +7482,14 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n   /* The only other cases we handle are MIN, MAX, and comparisons if the\n      operands are the same as REG and VAL.  */\n \n-  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n+  else if (COMPARISON_P (x) || COMMUTATIVE_ARITH_P (x))\n     {\n       if (rtx_equal_p (XEXP (x, 0), val))\n \tcond = swap_condition (cond), temp = val, val = reg, reg = temp;\n \n       if (rtx_equal_p (XEXP (x, 0), reg) && rtx_equal_p (XEXP (x, 1), val))\n \t{\n-\t  if (GET_RTX_CLASS (code) == '<')\n+\t  if (COMPARISON_P (x))\n \t    {\n \t      if (comparison_dominates_p (cond, code))\n \t\treturn const_true_rtx;\n@@ -7796,8 +7781,7 @@ apply_distributive_law (rtx x)\n \n   /* If either operand is a primitive we can't do anything, so get out\n      fast.  */\n-  if (GET_RTX_CLASS (GET_CODE (lhs)) == 'o'\n-      || GET_RTX_CLASS (GET_CODE (rhs)) == 'o')\n+  if (OBJECT_P (lhs) || OBJECT_P (rhs))\n     return x;\n \n   lhs = expand_compound_operation (lhs);\n@@ -7859,15 +7843,15 @@ apply_distributive_law (rtx x)\n \n   /* Set LHS and RHS to the inner operands (A and B in the example\n      above) and set OTHER to the common operand (C in the example).\n-     These is only one way to do this unless the inner operation is\n+     There is only one way to do this unless the inner operation is\n      commutative.  */\n-  if (GET_RTX_CLASS (inner_code) == 'c'\n+  if (COMMUTATIVE_ARITH_P (lhs)\n       && rtx_equal_p (XEXP (lhs, 0), XEXP (rhs, 0)))\n     other = XEXP (lhs, 0), lhs = XEXP (lhs, 1), rhs = XEXP (rhs, 1);\n-  else if (GET_RTX_CLASS (inner_code) == 'c'\n+  else if (COMMUTATIVE_ARITH_P (lhs)\n \t   && rtx_equal_p (XEXP (lhs, 0), XEXP (rhs, 1)))\n     other = XEXP (lhs, 0), lhs = XEXP (lhs, 1), rhs = XEXP (rhs, 0);\n-  else if (GET_RTX_CLASS (inner_code) == 'c'\n+  else if (COMMUTATIVE_ARITH_P (lhs)\n \t   && rtx_equal_p (XEXP (lhs, 1), XEXP (rhs, 0)))\n     other = XEXP (lhs, 1), lhs = XEXP (lhs, 0), rhs = XEXP (rhs, 1);\n   else if (rtx_equal_p (XEXP (lhs, 1), XEXP (rhs, 1)))\n@@ -8036,8 +8020,7 @@ cached_nonzero_bits (rtx x, enum machine_mode mode, rtx known_x,\n      nonzero_bits1 on X with the subexpressions as KNOWN_X and the\n      precomputed value for the subexpression as KNOWN_RET.  */\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n+  if (ARITHMETIC_P (x))\n     {\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n@@ -8048,14 +8031,12 @@ cached_nonzero_bits (rtx x, enum machine_mode mode, rtx known_x,\n \t\t\t      nonzero_bits_with_known (x0, mode));\n \n       /* Check the second level.  */\n-      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+      if (ARITHMETIC_P (x0)\n \t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \treturn nonzero_bits1 (x, mode, x1, mode,\n \t\t\t      nonzero_bits_with_known (x1, mode));\n \n-      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+      if (ARITHMETIC_P (x1)\n \t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \treturn nonzero_bits1 (x, mode, x0, mode,\n \t\t\t nonzero_bits_with_known (x0, mode));\n@@ -8565,8 +8546,7 @@ cached_num_sign_bit_copies (rtx x, enum machine_mode mode, rtx known_x,\n      num_sign_bit_copies1 on X with the subexpressions as KNOWN_X and\n      the precomputed value for the subexpression as KNOWN_RET.  */\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n+  if (ARITHMETIC_P (x))\n     {\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n@@ -8578,15 +8558,13 @@ cached_num_sign_bit_copies (rtx x, enum machine_mode mode, rtx known_x,\n \t\t\t\tnum_sign_bit_copies_with_known (x0, mode));\n \n       /* Check the second level.  */\n-      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+      if (ARITHMETIC_P (x0)\n \t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \treturn\n \t  num_sign_bit_copies1 (x, mode, x1, mode,\n \t\t\t\tnum_sign_bit_copies_with_known (x1, mode));\n \n-      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n-\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+      if (ARITHMETIC_P (x1)\n \t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \treturn\n \t  num_sign_bit_copies1 (x, mode, x0, mode,\n@@ -9801,7 +9779,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n      If we were passed a value for X, see if we can use any pieces of\n      it.  If not, make new rtx.  */\n \n-  if (x && GET_RTX_CLASS (GET_CODE (x)) == '2'\n+  if (x && GET_RTX_CLASS (GET_CODE (x)) == RTX_BIN_ARITH\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && (unsigned HOST_WIDE_INT) INTVAL (XEXP (x, 1)) == count)\n     const_rtx = XEXP (x, 1);\n@@ -9860,7 +9838,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \t/* This means that we have determined that the result is\n \t   equivalent to a constant.  This should be rare.  */\n \tx = GEN_INT (outer_const);\n-      else if (GET_RTX_CLASS (outer_op) == '1')\n+      else if (GET_RTX_CLASS (outer_op) == RTX_UNARY)\n \tx = simplify_gen_unary (outer_op, result_mode, x, result_mode);\n       else\n \tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n@@ -10069,7 +10047,7 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n \n   /* If X is a comparison operator, rewrite it in a new mode.  This\n      probably won't match, but may allow further simplifications.  */\n-  else if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n+  else if (COMPARISON_P (x))\n     return gen_rtx_fmt_ee (GET_CODE (x), mode, XEXP (x, 0), XEXP (x, 1));\n \n   /* If we couldn't simplify X any other way, just enclose it in a\n@@ -10110,11 +10088,12 @@ gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n   else if (GET_CODE (op1) == CLOBBER)\n     return op1;\n   \n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n       && swap_commutative_operands_p (op0, op1))\n     tem = op0, op0 = op1, op1 = tem;\n \n-  if (GET_RTX_CLASS (code) == '<')\n+  if (GET_RTX_CLASS (code) == RTX_COMPARE\n+      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n     {\n       enum machine_mode op_mode = GET_MODE (op0);\n \n@@ -10138,7 +10117,7 @@ gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0, rtx op1)\n     return result;\n \n   /* Put complex operands first and constants second.  */\n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n       && swap_commutative_operands_p (op0, op1))\n     return gen_rtx_fmt_ee (code, mode, op1, op0);\n \n@@ -10338,8 +10317,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n       if (GET_MODE_CLASS (mode) != MODE_INT\n \t  && ! (mode == VOIDmode\n-\t\t&& (GET_CODE (op0) == COMPARE\n-\t\t    || GET_RTX_CLASS (GET_CODE (op0)) == '<')))\n+\t\t&& (GET_CODE (op0) == COMPARE || COMPARISON_P (op0))))\n \tbreak;\n \n       /* Get the constant we are comparing against and turn off all bits\n@@ -10914,9 +10892,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      mask = ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n \t\t      << INTVAL (XEXP (XEXP (op0, 0), 1)));\n \t      if ((~STORE_FLAG_VALUE & mask) == 0\n-\t\t  && (GET_RTX_CLASS (GET_CODE (XEXP (XEXP (op0, 0), 0))) == '<'\n+\t\t  && (COMPARISON_P (XEXP (XEXP (op0, 0), 0))\n \t\t      || ((tem = get_last_value (XEXP (XEXP (op0, 0), 0))) != 0\n-\t\t\t  && GET_RTX_CLASS (GET_CODE (tem)) == '<')))\n+\t\t\t  && COMPARISON_P (tem))))\n \t\t{\n \t\t  op0 = XEXP (XEXP (op0, 0), 0);\n \t\t  continue;\n@@ -11396,9 +11374,7 @@ update_table_tick (rtx x)\n \t/* Check for identical subexpressions.  If x contains\n \t   identical subexpression we only have to traverse one of\n \t   them.  */\n-\tif (i == 0\n-\t    && (GET_RTX_CLASS (code) == '2'\n-\t\t|| GET_RTX_CLASS (code) == 'c'))\n+\tif (i == 0 && ARITHMETIC_P (x))\n \t  {\n \t    /* Note that at this point x1 has already been\n \t       processed.  */\n@@ -11413,15 +11389,13 @@ update_table_tick (rtx x)\n \t    /* If x0 is identical to a subexpression of x1 then while\n \t       processing x1, x0 has already been processed.  Thus we\n \t       are done with x.  */\n-\t    if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n-\t\t || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t    if (ARITHMETIC_P (x1)\n \t\t&& (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \t      break;\n \n \t    /* If x1 is identical to a subexpression of x0 then we\n \t       still have to process the rest of x0.  */\n-\t    if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n-\t\t || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t    if (ARITHMETIC_P (x0)\n \t\t&& (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \t      {\n \t\tupdate_table_tick (XEXP (x0, x1 == XEXP (x0, 0) ? 1 : 0));\n@@ -11464,8 +11438,7 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n       if (tem)\n \t{\n-\t  if ((GET_RTX_CLASS (GET_CODE (tem)) == '2'\n-\t       || GET_RTX_CLASS (GET_CODE (tem)) == 'c')\n+\t  if (ARITHMETIC_P (tem)\n \t      && GET_CODE (XEXP (tem, 0)) == CLOBBER\n \t      && GET_CODE (XEXP (tem, 1)) == CLOBBER)\n \t    tem = XEXP (tem, 0);\n@@ -11775,9 +11748,7 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \t  /* Check for identical subexpressions.  If x contains\n \t     identical subexpression we only have to traverse one of\n \t     them.  */\n-\t  if (i == 1\n-\t      && (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-\t\t  || GET_RTX_CLASS (GET_CODE (x)) == 'c'))\n+\t  if (i == 1 && ARITHMETIC_P (x))\n \t    {\n \t      /* Note that at this point x0 has already been checked\n \t\t and found valid.  */\n@@ -11791,15 +11762,13 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n \t      /* If x1 is identical to a subexpression of x0 then\n \t\t while checking x0, x1 has already been checked.  Thus\n \t\t it is valid and so as x.  */\n-\t      if ((GET_RTX_CLASS (GET_CODE (x0)) == '2'\n-\t\t   || GET_RTX_CLASS (GET_CODE (x0)) == 'c')\n+\t      if (ARITHMETIC_P (x0)\n \t\t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \t\treturn 1;\n \n \t      /* If x0 is identical to a subexpression of x1 then x is\n \t\t valid iff the rest of x1 is valid.  */\n-\t      if ((GET_RTX_CLASS (GET_CODE (x1)) == '2'\n-\t\t   || GET_RTX_CLASS (GET_CODE (x1)) == 'c')\n+\t      if (ARITHMETIC_P (x1)\n \t\t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \t\treturn\n \t\t  get_last_value_validate (&XEXP (x1,"}, {"sha": "0e534f35678a56573b5804bc0970540b03a250f3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1134,13 +1134,13 @@ alpha_zero_comparison_operator (rtx op, enum machine_mode mode)\n int\n alpha_swapped_comparison_operator (rtx op, enum machine_mode mode)\n {\n-  enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code;\n \n   if ((mode != GET_MODE (op) && mode != VOIDmode)\n-      || GET_RTX_CLASS (code) != '<')\n+      || COMPARISON_P (op));\n     return 0;\n \n-  code = swap_condition (code);\n+  code = swap_condition (GET_CODE (op));\n   return (code == EQ || code == LE || code == LT\n \t  || code == LEU || code == LTU);\n }\n@@ -5637,7 +5637,7 @@ print_operand (FILE *file, rtx x, int code)\n       {\n \tenum rtx_code c = GET_CODE (x);\n \n-        if (GET_RTX_CLASS (c) != '<')\n+        if (!COMPARISON_P (x))\n \t  output_operand_lossage (\"invalid %%C value\");\n \n \telse if (code == 'D')"}, {"sha": "b50c50fdd05d993c0f4a9756296470c82b7619de", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -709,11 +709,11 @@ const_uint32_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n proper_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (op);\n-\n-  if (GET_RTX_CLASS (code) != '<')\n+  enum rtx_code code;\n+  if (!COMPARISON_P (op))\n     return 0;\n \n+  code = GET_CODE (op);\n   if (GET_MODE (XEXP (op, 0)) == CCZNmode)\n     return (code == EQ || code == NE);\n   if (GET_MODE (XEXP (op, 0)) == CCZNCmode)"}, {"sha": "aa249ff92e0a9c42c558edd0772ae6f6a1b21e11", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -3938,13 +3938,10 @@ arm_arm_address_cost (rtx x)\n \n   if (c == PLUS || c == MINUS)\n     {\n-      char cl0 = GET_RTX_CLASS (GET_CODE (XEXP (x, 0)));\n-      char cl1 = GET_RTX_CLASS (GET_CODE (XEXP (x, 1)));\n-\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \treturn 2;\n \n-      if (cl0 == '2' || cl0 == 'c' || cl1 == '2' || cl1 == 'c')\n+      if (ARITHMETIC_P (XEXP (x, 0)) || ARITHMETIC_P (XEXP (x, 1)))\n \treturn 3;\n \n       return 4;\n@@ -6175,21 +6172,21 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n   if (GET_CODE (x) == IF_THEN_ELSE\n       && (XEXP (x, 2) == const0_rtx\n \t  || XEXP (x, 2) == const1_rtx)\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+      && COMPARISON_P (XEXP (x, 0))\n+      && COMPARISON_P (XEXP (x, 1)))\n     return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1), \n \t\t\t\t\t INTVAL (XEXP (x, 2)));\n \n   /* Alternate canonicalizations of the above.  These are somewhat cleaner.  */\n   if (GET_CODE (x) == AND\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+      && COMPARISON_P (XEXP (x, 0))\n+      && COMPARISON_P (XEXP (x, 1)))\n     return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1),\n \t\t\t\t\t DOM_CC_X_AND_Y);\n \n   if (GET_CODE (x) == IOR\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-      && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<')\n+      && COMPARISON_P (XEXP (x, 0))\n+      && COMPARISON_P (XEXP (x, 1)))\n     return arm_select_dominance_cc_mode (XEXP (x, 0), XEXP (x, 1),\n \t\t\t\t\t DOM_CC_X_OR_Y);\n "}, {"sha": "705e07b52e92619c7ae471d64b461d44bfdc492e", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -4251,6 +4251,7 @@ _reg_unused_after (rtx insn, rtx reg)\n \n   while ((insn = NEXT_INSN (insn)))\n     {\n+      rtx set;\n       code = GET_CODE (insn);\n \n #if 0\n@@ -4263,6 +4264,9 @@ _reg_unused_after (rtx insn, rtx reg)\n       /* else */\n #endif\n \n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n       if (code == JUMP_INSN)\n \treturn 0;\n \n@@ -4320,17 +4324,14 @@ _reg_unused_after (rtx insn, rtx reg)\n \t    return 1;\n \t}\n \n-      if (GET_RTX_CLASS (code) == 'i')\n-\t{\n-\t  rtx set = single_set (insn);\n+      set = single_set (insn);\n \n-\t  if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n-\t    return 0;\n-\t  if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t    return GET_CODE (SET_DEST (set)) != MEM;\n-\t  if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n-\t    return 0;\n-\t}\n+      if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n+\treturn 0;\n+      if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\treturn GET_CODE (SET_DEST (set)) != MEM;\n+      if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\treturn 0;\n     }\n   return 1;\n }"}, {"sha": "242dfcde9ceb75bd9f21d2212c7de367964e090a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -6831,7 +6831,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n \t\t      else if (CR_P (regno)\n \t\t\t       && (src_code == IF_THEN_ELSE\n-\t\t\t\t   || GET_RTX_CLASS (src_code) == '<'))\n+\t\t\t\t   || COMPARISON_P (src)))\n \t\t\tskip_nested_if = TRUE;\n \t\t    }\n \t\t}\n@@ -7371,9 +7371,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n       enum machine_mode mode = GET_MODE (dest);\n \n       /* Check for normal binary operators.  */\n-      if (mode == SImode\n-\t  && (GET_RTX_CLASS (GET_CODE (src)) == '2'\n-\t      || GET_RTX_CLASS (GET_CODE (src)) == 'c'))\n+      if (mode == SImode && ARITHMETIC_P (src))\n \t{\n \t  op0 = XEXP (src, 0);\n \t  op1 = XEXP (src, 1);\n@@ -7486,7 +7484,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n       /* Rewrite a nested set cccr in terms of IF_THEN_ELSE.  Also deal with\n          rewriting the CC register to be the same as the paired CC/CR register\n          for nested ifs.  */\n-      else if (mode == CC_CCRmode && GET_RTX_CLASS (GET_CODE (src)) == '<')\n+      else if (mode == CC_CCRmode && COMPARISON_P (src))\n \t{\n \t  int regno = REGNO (XEXP (src, 0));\n \t  rtx if_else;\n@@ -8830,7 +8828,7 @@ frv_pack_insns (void)\n \t}\n \n       /* Things like labels reset everything.  */\n-      if (GET_RTX_CLASS (code) != 'i')\n+      if (!INSN_P (insn))\n \t{\n \t  next_start_vliw_p = TRUE;\n \t  continue;"}, {"sha": "d90d616c6feec99970347efb66c1c48a4bfb9ae3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -4006,7 +4006,7 @@ ix86_comparison_operator (rtx op, enum machine_mode mode)\n   enum rtx_code code = GET_CODE (op);\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n   inmode = GET_MODE (XEXP (op, 0));\n \n@@ -4048,7 +4048,7 @@ ix86_carry_flag_operator (rtx op, enum machine_mode mode)\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n   inmode = GET_MODE (XEXP (op, 0));\n   if (GET_CODE (XEXP (op, 0)) != REG\n@@ -4080,7 +4080,7 @@ fcmov_comparison_operator (rtx op, enum machine_mode mode)\n \n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n   inmode = GET_MODE (XEXP (op, 0));\n   if (inmode == CCFPmode || inmode == CCFPUmode)\n@@ -4199,8 +4199,7 @@ int\n arith_or_logical_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n-          && (GET_RTX_CLASS (GET_CODE (op)) == 'c'\n-              || GET_RTX_CLASS (GET_CODE (op)) == '2'));\n+          && ARITHMETIC_P (op));\n }\n \n /* Returns 1 if OP is memory operand with a displacement.  */\n@@ -7416,7 +7415,7 @@ print_operand (FILE *file, rtx x, int code)\n \tcase 'c':\n \t  /* Check to see if argument to %c is really a constant\n \t     and not a condition code which needs to be reversed.  */\n-\t  if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n+\t  if (!COMPARISON_P (x))\n \t  {\n \t    output_operand_lossage (\"operand is neither a constant nor a condition code, invalid operand code 'c'\");\n \t     return;\n@@ -8439,7 +8438,7 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n   src2 = operands[2];\n \n   /* Recognize <var1> = <value> <op> <var1> for commutative operators */\n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n       && (rtx_equal_p (dst, src2)\n \t  || immediate_operand (src1, mode)))\n     {\n@@ -8455,7 +8454,7 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n     {\n       if (rtx_equal_p (dst, src1))\n \tmatching_memory = 1;\n-      else if (GET_RTX_CLASS (code) == 'c'\n+      else if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n \t       && rtx_equal_p (dst, src2))\n \tmatching_memory = 2;\n       else\n@@ -8475,7 +8474,7 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n      or non-matching memory.  */\n   if ((CONSTANT_P (src1)\n        || (!matching_memory && GET_CODE (src1) == MEM))\n-      && GET_RTX_CLASS (code) != 'c')\n+      && GET_RTX_CLASS (code) != RTX_COMM_ARITH)\n     src1 = force_reg (mode, src1);\n \n   /* If optimizing, copy to regs to improve CSE */\n@@ -8523,18 +8522,18 @@ ix86_binary_operator_ok (enum rtx_code code,\n   if (GET_CODE (operands[1]) == MEM && GET_CODE (operands[2]) == MEM)\n     return 0;\n   /* If the operation is not commutable, source 1 cannot be a constant.  */\n-  if (CONSTANT_P (operands[1]) && GET_RTX_CLASS (code) != 'c')\n+  if (CONSTANT_P (operands[1]) && GET_RTX_CLASS (code) != RTX_COMM_ARITH)\n     return 0;\n   /* If the destination is memory, we must have a matching source operand.  */\n   if (GET_CODE (operands[0]) == MEM\n       && ! (rtx_equal_p (operands[0], operands[1])\n-\t    || (GET_RTX_CLASS (code) == 'c'\n+\t    || (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n \t\t&& rtx_equal_p (operands[0], operands[2]))))\n     return 0;\n   /* If the operation is not commutable and the source 1 is memory, we must\n      have a matching destination.  */\n   if (GET_CODE (operands[1]) == MEM\n-      && GET_RTX_CLASS (code) != 'c'\n+      && GET_RTX_CLASS (code) != RTX_COMM_ARITH\n       && ! rtx_equal_p (operands[0], operands[1]))\n     return 0;\n   return 1;"}, {"sha": "56c1a8c187880e55a15e31f4c6409933b7b6e27d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -14300,7 +14300,7 @@\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")]))]\n   \"TARGET_80387 && !TARGET_SSE_MATH\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+   && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14315,7 +14315,7 @@\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm#x,xm#f\")]))]\n   \"TARGET_80387 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+   && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14333,7 +14333,7 @@\n \t(match_operator:SF 3 \"binary_fp_operator\"\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"%0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE_MATH && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+  \"TARGET_SSE_MATH && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14348,7 +14348,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")]))]\n   \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_SSE_MATH)\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+   && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14363,7 +14363,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm#Y,Ym#f\")]))]\n   \"TARGET_80387 && TARGET_SSE_MATH && TARGET_SSE2 && TARGET_MIX_SSE_I387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+   && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14382,7 +14382,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"%0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\")]))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\n+   && COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14397,7 +14397,7 @@\n \t\t\t[(match_operand:XF 1 \"register_operand\" \"%0\")\n \t\t\t (match_operand:XF 2 \"register_operand\" \"f\")]))]\n   \"TARGET_80387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) == 'c'\"\n+   && COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (if_then_else (match_operand:XF 3 \"mult_operator\" \"\") \n@@ -14411,7 +14411,7 @@\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n   \"TARGET_80387 && !TARGET_SSE_MATH\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14429,7 +14429,7 @@\n \t\t\t[(match_operand:SF 1 \"nonimmediate_operand\" \"0,fm,0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0,xm#f\")]))]\n   \"TARGET_80387 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14455,7 +14455,7 @@\n \t\t\t[(match_operand:SF 1 \"register_operand\" \"0\")\n \t\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]))]\n   \"TARGET_SSE_MATH\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n+   && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:SF 3 \"mult_operator\" \"\")\n@@ -14509,7 +14509,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n   \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_SSE_MATH)\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14528,7 +14528,7 @@\n \t\t\t[(match_operand:DF 1 \"nonimmediate_operand\" \"0,fm,0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm,0,Ym#f\")]))]\n   \"TARGET_80387 && TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\n+   && !COMMUTATIVE_ARITH_P (operands[3])\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n@@ -14554,7 +14554,7 @@\n \t\t\t[(match_operand:DF 1 \"register_operand\" \"0\")\n \t\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"Ym\")]))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n+   && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set_attr \"mode\" \"DF\")\n    (set (attr \"type\") \n@@ -14660,7 +14660,7 @@\n \t\t\t[(match_operand:XF 1 \"register_operand\" \"0,f\")\n \t\t\t (match_operand:XF 2 \"register_operand\" \"f,0\")]))]\n   \"TARGET_80387\n-   && GET_RTX_CLASS (GET_CODE (operands[3])) != 'c'\"\n+   && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\") \n         (cond [(match_operand:XF 3 \"mult_operator\" \"\") "}, {"sha": "d7513ff4a3dc8d5fe3f34b35bdba6d336d1b900b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -863,7 +863,7 @@ int\n not_postinc_memory_operand (rtx op, enum machine_mode mode)\n {\n   return (memory_operand (op, mode)\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != 'a');\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC);\n }\n \n /* Return 1 if this is a comparison operator, which accepts a normal 8-bit\n@@ -4356,7 +4356,7 @@ ia64_print_operand (FILE * file, rtx x, int code)\n     case MEM:\n       {\n \trtx addr = XEXP (x, 0);\n-\tif (GET_RTX_CLASS (GET_CODE (addr)) == 'a')\n+\tif (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC)\n \t  addr = XEXP (addr, 0);\n \tfprintf (file, \"[%s]\", reg_names [REGNO (addr)]);\n \tbreak;\n@@ -5159,7 +5159,7 @@ update_set_flags (rtx x, struct reg_flags *pflags, int *ppred, rtx *pcond)\n       /* ... fall through ...  */\n \n     default:\n-      if (GET_RTX_CLASS (GET_CODE (src)) == '<'\n+      if (COMPARISON_P (src)\n \t  && GET_MODE_CLASS (GET_MODE (XEXP (src, 0))) == MODE_FLOAT)\n \t/* Set pflags->is_fp to 1 so that we know we're dealing\n \t   with a floating point comparison when processing the\n@@ -5883,8 +5883,8 @@ errata_emit_nops (rtx insn)\n \t  || GET_CODE (XEXP (SET_SRC (set), 0)) != POST_MODIFY)\n       && GENERAL_REGNO_P (REGNO (SET_DEST (set))))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (cond)) != '<'\n-\t  || ! REG_P (XEXP (cond, 0)))\n+      if (!COMPARISON_P (cond)\n+\t  || !REG_P (XEXP (cond, 0)))\n \tabort ();\n \n       if (TEST_HARD_REG_BIT (prev_group->p_reg_set, REGNO (XEXP (cond, 0))))"}, {"sha": "c52c7516ac1cd21b3445abebabf40e5fe1deae44", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1021,7 +1021,7 @@ enum reg_class\n #define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n   (CLASS == FR_REGS && GET_CODE (X) == MEM && MEM_VOLATILE_P (X) ? NO_REGS   \\\n    : CLASS == FR_REGS && GET_CODE (X) == CONST_DOUBLE ? NO_REGS\t\t     \\\n-   : GET_RTX_CLASS (GET_CODE (X)) != 'o'\t\t\t\t     \\\n+   : !OBJECT_P (X)\t\t\t\t\t\t\t     \\\n      && (CLASS == AR_M_REGS || CLASS == AR_I_REGS) ? NO_REGS\t\t     \\\n    : CLASS)\n \n@@ -1124,9 +1124,9 @@ enum reg_class\n #define CONSTRAINT_OK_FOR_R(VALUE) \\\n   (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) >= 1 && INTVAL (VALUE) <= 4)\n /* Non-post-inc memory for asms and other unsavory creatures.  */\n-#define CONSTRAINT_OK_FOR_S(VALUE)\t\t\t\t\\\n-  (GET_CODE (VALUE) == MEM\t\t\t\t\t\\\n-   && GET_RTX_CLASS (GET_CODE (XEXP ((VALUE), 0))) != 'a'\t\\\n+#define CONSTRAINT_OK_FOR_S(VALUE)\t\t\t\t\t\\\n+  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n+   && GET_RTX_CLASS (GET_CODE (XEXP ((VALUE), 0))) != RTX_AUTOINC\t\\\n    && (reload_in_progress || memory_operand ((VALUE), VOIDmode)))\n /* Symbol ref to small-address-area: */\n #define CONSTRAINT_OK_FOR_T(VALUE)\t\t\t\t\t\t\\"}, {"sha": "c6fd0d1b968fbb20e1d57e7bbe88f81b88ba113f", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -3428,7 +3428,7 @@ mdr_resequence_xy_yx (first_insn)\n \t     appropriate, try to do the same thing with the second operand.\n \t     Of course there are fewer operations that can match here\n \t     because they must be commutative.  */\n-          if (GET_RTX_CLASS (GET_CODE (XEXP (set, 1))) == 'c'\n+          if (GET_RTX_CLASS (GET_CODE (XEXP (set, 1))) == RTX_COMM_ARITH\n \t      && (GET_CODE (XEXP (XEXP (set, 1), 1)) == REG\n \t          || GET_CODE (XEXP (XEXP (set, 1), 1)) == MEM)\n \t      && rtx_equal_p (XEXP (set2, 0), XEXP (XEXP (set, 1), 1))\n@@ -4104,12 +4104,11 @@ mdr_try_move_dp_reload (first_insn)\n static int\n ip2k_check_can_adjust_stack_ref (rtx x, int offset)\n {\n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c')\n+  if (ARITHMETIC_P (x))\n     return (ip2k_check_can_adjust_stack_ref (XEXP (x, 0), offset)\n \t    && ip2k_check_can_adjust_stack_ref (XEXP (x, 1), offset));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1')\n+  if (UNARY_P (x))\n     return ip2k_check_can_adjust_stack_ref (XEXP (x, 0), offset);\n \n   switch (GET_CODE (x))\n@@ -4150,15 +4149,14 @@ ip2k_check_can_adjust_stack_ref (rtx x, int offset)\n static void\n ip2k_adjust_stack_ref (rtx *x, int offset)\n {\n-  if (GET_RTX_CLASS (GET_CODE (*x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (*x)) == 'c')\n+  if (ARITHMETIC_P (*x))\n     {\n       ip2k_adjust_stack_ref (&XEXP (*x, 0), offset);\n       ip2k_adjust_stack_ref (&XEXP (*x, 1), offset);\n       return;\n     }\n \n-  if (GET_RTX_CLASS (GET_CODE (*x)) == '1')\n+  if (UNARY_P (*x))\n     {\n       ip2k_adjust_stack_ref (&XEXP (*x, 0), offset);\n       return;\n@@ -4642,21 +4640,6 @@ ip2k_xexp_not_uses_reg_for_mem (rtx x, unsigned int regno)\n   if (regno & 1)\n     regno &= 0xfffffffe;\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'b')\n-    return (ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno)\n-\t    && ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 1), regno)\n-\t    && ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 2), regno));\n-\n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '<')\n-    return (ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno)\n-\t    && ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 1), regno));\n-\n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '3')\n-    return ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno);\n-\n   switch (GET_CODE (x))\n     {\n     case REG:\n@@ -4682,6 +4665,19 @@ ip2k_xexp_not_uses_reg_for_mem (rtx x, unsigned int regno)\n       return 1;\n \n     default:\n+      if (GET_RTX_CLASS (GET_CODE (x)) == RTX_BITFIELD_OPS)\n+\treturn (ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno)\n+\t\t&& ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 1), regno)\n+\t\t&& ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 2), regno));\n+\n+      if (BINARY_P (x))\n+\treturn (ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno)\n+\t\t&& ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 1), regno));\n+\n+      if (UNARY_P (x)\n+\t  || GET_RTX_CLASS (GET_CODE (x)) == '3')\n+\treturn ip2k_xexp_not_uses_reg_for_mem (XEXP (x, 0), regno);\n+\n       return 0;\n     }\n }\n@@ -5972,19 +5968,17 @@ ip2k_xexp_not_uses_reg_p (rtx x, unsigned int r, int rsz)\n int\n ip2k_composite_xexp_not_uses_reg_p (rtx x, unsigned int r, int rsz)\n {\n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'b')\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_BITFIELD_OPS)\n     return (ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 0), r, rsz)\n \t    && ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 1), r, rsz)\n \t    && ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 2), r, rsz));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '<')\n+  if (BINARY_P (x)\n     return (ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 0), r, rsz)\n \t    && ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 1), r, rsz));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '3')\n+  if (UNARY_P (x)\n+      || GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY)\n     return ip2k_composite_xexp_not_uses_reg_p (XEXP (x, 0), r, rsz);\n \n   return ip2k_xexp_not_uses_reg_p (x, r, rsz);\n@@ -5996,19 +5990,17 @@ ip2k_composite_xexp_not_uses_reg_p (rtx x, unsigned int r, int rsz)\n int\n ip2k_composite_xexp_not_uses_cc0_p (rtx x)\n {\n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'b')\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_BITFIELD_OPS)\n     return (ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 0))\n \t    && ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 1))\n \t    && ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 2)));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '2'\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '<')\n+  if (BINARY_P (x))\n     return (ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 0))\n \t    && ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 1)));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '3')\n+  if (UNARY_P (x)\n+      || GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY)\n     return ip2k_composite_xexp_not_uses_cc0_p (XEXP (x, 0));\n \n   return GET_CODE (x) != CC0;\n@@ -6158,15 +6150,14 @@ int\n ip2k_unary_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '1');\n+\t  && UNARY_P (op);\n }\n \n int\n ip2k_binary_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (GET_RTX_CLASS (GET_CODE (op)) == 'c'\n-\t      || GET_RTX_CLASS (GET_CODE (op)) == '2'));\n+\t  && ARITHMETIC_P (op);\n }\n \n int"}, {"sha": "07934ee60b0772175c11d6dd1639fd6fa00b6d69", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -357,7 +357,7 @@ cmp_op (rtx op, enum machine_mode mode)\n   if (mode != GET_MODE (op))\n     return 0;\n \n-  return GET_RTX_CLASS (GET_CODE (op)) == '<';\n+  return COMPARISON_P (op);\n }\n \n /* Return nonzero if the operand is either the PC or a label_ref.  */\n@@ -2583,11 +2583,10 @@ symbolic_expression_p (rtx x)\n   if (GET_CODE (x) == CONST)\n     return symbolic_expression_p (XEXP (x, 0));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1')\n+  if (UNARY_P (x))\n     return symbolic_expression_p (XEXP (x, 0));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '2')\n+  if (ARITHMETIC_P (x))\n     return (symbolic_expression_p (XEXP (x, 0))\n \t    || symbolic_expression_p (XEXP (x, 1)));\n "}, {"sha": "a6c69942a202a5105285145eb4fcb9510786a46a", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -908,8 +908,6 @@ eqne_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n-  if (GET_RTX_CLASS (code) != '<')\n-    return 0;\n   return (code == EQ || code == NE);\n }\n \n@@ -920,10 +918,9 @@ signed_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n-  if (GET_RTX_CLASS (code) != '<')\n-    return 0;\n-  return (code == EQ || code == NE\n-\t  || code == LT || code == LE || code == GT || code == GE);\n+  return (COMPARISON_P (op)\n+  \t  && (code == EQ || code == NE\n+\t      || code == LT || code == LE || code == GT || code == GE);\n }\n \n /* Return 1 if OP is (mem (reg ...))."}, {"sha": "ee69fa3b8a2e0cac893ac4626bddd5ba02dd914e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1465,7 +1465,7 @@ cmp_op (rtx op, enum machine_mode mode)\n   if (mode != GET_MODE (op))\n     return 0;\n \n-  return GET_RTX_CLASS (GET_CODE (op)) == '<';\n+  return COMPARISON_P (op);\n }\n \n /* Return nonzero if the code is a relational operation suitable for a\n@@ -7213,11 +7213,10 @@ symbolic_expression_p (rtx x)\n   if (GET_CODE (x) == CONST)\n     return symbolic_expression_p (XEXP (x, 0));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '1')\n+  if (UNARY_P (x))\n     return symbolic_expression_p (XEXP (x, 0));\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'c'\n-      || GET_RTX_CLASS (GET_CODE (x)) == '2')\n+  if (ARITHMETIC_P (x))\n     return (symbolic_expression_p (XEXP (x, 0))\n \t    || symbolic_expression_p (XEXP (x, 1)));\n "}, {"sha": "4d239dd0d9e519957652d562afb5d7efe873dc02", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -2498,7 +2498,7 @@ mmix_foldable_comparison_operator (rtx op, enum machine_mode mode)\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n \n-  if (mode == VOIDmode && GET_RTX_CLASS (GET_CODE (op)) == '<')\n+  if (mode == VOIDmode && COMPARISON_P (op))\n     mode = GET_MODE (XEXP (op, 0));\n \n   return ((mode == CCmode || mode == DImode)\n@@ -2526,13 +2526,13 @@ mmix_comparison_operator (rtx op, enum machine_mode mode)\n     mode = GET_MODE (op);\n \n   /* Get the mode from the first operand if we don't have one.  */\n-  if (mode == VOIDmode && GET_RTX_CLASS (GET_CODE (op)) == '<')\n+  if (mode == VOIDmode && COMPARISON_P (op))\n     mode = GET_MODE (XEXP (op, 0));\n \n   /* FIXME: This needs to be kept in sync with the tables in\n      mmix_output_condition.  */\n   return\n-    (mode == VOIDmode && GET_RTX_CLASS (GET_CODE (op)) == '<')\n+    (mode == VOIDmode && COMPARISON_P (op))\n     || (mode == CC_FUNmode\n \t&& (code == ORDERED || code == UNORDERED))\n     || (mode == CC_FPmode"}, {"sha": "6c6fe043d0a2a786e4cc5e176ef6e255fb80bb5b", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1100,7 +1100,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n       && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n-      && (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == 'o'\n+      && (OBJECT_P (XEXP (x, 1))\n \t  || GET_CODE (XEXP (x, 1)) == SUBREG)\n       && GET_CODE (XEXP (x, 1)) != CONST)\n     {"}, {"sha": "5648d65099833794a96b013958e6bbeaa09d1810", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -8105,7 +8105,8 @@ stmw_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n static void\n validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n {\n-  if (GET_RTX_CLASS (code) != '<' \n+  if ((GET_RTX_CLASS (code) != RTX_COMPARE\n+       && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n       || GET_MODE_CLASS (mode) != MODE_CC)\n     abort ();\n \n@@ -8149,7 +8150,7 @@ branch_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   enum rtx_code code = GET_CODE (op);\n   enum machine_mode cc_mode;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n   cc_mode = GET_MODE (XEXP (op, 0));\n@@ -8194,7 +8195,7 @@ trap_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n-  return GET_RTX_CLASS (GET_CODE (op)) == '<';\n+  return COMPARISON_P (op);\n }\n \n int\n@@ -8574,7 +8575,7 @@ ccr_bit (rtx op, int scc_p)\n   int base_bit;\n   rtx reg;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return -1;\n \n   reg = XEXP (op, 0);"}, {"sha": "641e4bbb8af46c09022f0f976ba7315cff7d2da4", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -2287,7 +2287,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define SELECT_CC_MODE(OP,X,Y) \\\n   (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n    : (OP) == GTU || (OP) == LTU || (OP) == GEU || (OP) == LEU ? CCUNSmode \\\n-   : (((OP) == EQ || (OP) == NE) && GET_RTX_CLASS (GET_CODE (X)) == '<'   \\\n+   : (((OP) == EQ || (OP) == NE) && COMPARISON_P (X)\t\t\t  \\\n       ? CCEQmode : CCmode))\n \n /* Can the condition code MODE be safely reversed?  This is safe in"}, {"sha": "7e7489a2635a1f2b982e35a9b0385d7dc79f0b81", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -467,7 +467,7 @@ s390_alc_comparison (rtx op, enum machine_mode mode)\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n-  if (GET_RTX_CLASS (GET_CODE (op)) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n   if (GET_CODE (XEXP (op, 0)) != REG\n@@ -509,7 +509,7 @@ s390_slb_comparison (rtx op, enum machine_mode mode)\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n-  if (GET_RTX_CLASS (GET_CODE (op)) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n   if (GET_CODE (XEXP (op, 0)) != REG"}, {"sha": "32c8ef99d0f3632ad59839a03efeeb7a72b797f2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -3514,7 +3514,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n \t  if (INSN_DELETED_P (scan))\n \t    continue;\n \t  code = GET_CODE (scan);\n-\t  if (GET_RTX_CLASS (code) == 'i')\n+\t  if (INSN_P (scan))\n \t    {\n \t      used |= regs_used (PATTERN (scan), 0);\n \t      if (code == CALL_INSN)\n@@ -7667,6 +7667,10 @@ reg_unused_after (rtx reg, rtx insn)\n \n   while ((insn = NEXT_INSN (insn)))\n     {\n+      rtx set;\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n       code = GET_CODE (insn);\n \n #if 0\n@@ -7723,17 +7727,14 @@ reg_unused_after (rtx reg, rtx insn)\n \t  else if (code == JUMP_INSN)\n \t    return 0;\n \t}\n-      else if (GET_RTX_CLASS (code) == 'i')\n-\t{\n-\t  rtx set = single_set (insn);\n \n-\t  if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n-\t    return 0;\n-\t  if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\t    return GET_CODE (SET_DEST (set)) != MEM;\n-\t  if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n-\t    return 0;\n-\t}\n+      set = single_set (insn);\n+      if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n+\treturn 0;\n+      if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\treturn GET_CODE (SET_DEST (set)) != MEM;\n+      if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\treturn 0;\n \n       if (code == CALL_INSN && call_used_regs[REGNO (reg)])\n \treturn 1;"}, {"sha": "4f564b130e6240da09da69d6cafc44efaeffb1c7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -958,29 +958,31 @@ eq_or_neq (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n normal_comp_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n   if (GET_MODE (XEXP (op, 0)) == CCFPmode\n       || GET_MODE (XEXP (op, 0)) == CCFPEmode)\n     return 1;\n \n+  code = GET_CODE (op);\n   return (code != NE && code != EQ && code != GEU && code != LTU);\n }\n \n /* Return 1 if this is a comparison operator.  This allows the use of\n    MATCH_OPERATOR to recognize all the branch insns.  */\n \n int\n-noov_compare_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+noov_compare_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n+  code = GET_CODE (op);\n   if (GET_MODE (XEXP (op, 0)) == CC_NOOVmode\n       || GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n     /* These are the only branches which work with CC_NOOVmode.  */\n@@ -994,14 +996,15 @@ noov_compare_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n noov_compare64_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code;\n \n   if (! TARGET_V9)\n     return 0;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op));\n     return 0;\n \n+  code = GET_CODE (op);\n   if (GET_MODE (XEXP (op, 0)) == CCX_NOOVmode)\n     /* These are the only branches which work with CCX_NOOVmode.  */\n     return (code == EQ || code == NE || code == GE || code == LT);\n@@ -1012,13 +1015,14 @@ noov_compare64_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    conditional move or branch on register contents instructions.  */\n \n int\n-v9_regcmp_op (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+v9_regcmp_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code;\n \n-  if (GET_RTX_CLASS (code) != '<')\n+  if (!COMPARISON_P (op))\n     return 0;\n \n+  code = GET_CODE (op);\n   return v9_regcmp_p (code);\n }\n \n@@ -2687,7 +2691,7 @@ emit_hard_tfmode_operation (enum rtx_code code, rtx *operands)\n {\n   rtx op, dest;\n \n-  if (GET_RTX_CLASS (code) == '1')\n+  if (GET_RTX_CLASS (code) == RTX_UNARY)\n     {\n       operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n       op = gen_rtx_fmt_e (code, GET_MODE (operands[0]), operands[1]);\n@@ -3073,7 +3077,7 @@ reg_unused_after (rtx reg, rtx insn)\n       if (GET_CODE (insn) == CODE_LABEL)\n \treturn 1;\n \n-      if (GET_RTX_CLASS (code) == 'i')\n+      if (INSN_P (insn))\n \t{\n \t  rtx set = single_set (insn);\n \t  int in_src = set && reg_overlap_mentioned_p (reg, SET_SRC (set));"}, {"sha": "1d3d3a193e914db6c5e88302b0da3a66db671e5a", "filename": "gcc/cse.c", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1214,7 +1214,7 @@ mention_regs (rtx x)\n      call that expensive function in the most common case where the only\n      use of the register is in the comparison.  */\n \n-  if (code == COMPARE || GET_RTX_CLASS (code) == '<')\n+  if (code == COMPARE || COMPARISON_P (x))\n     {\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n@@ -2953,8 +2953,7 @@ find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n      code on the Alpha for unaligned byte stores.  */\n \n   if (flag_expensive_optimizations\n-      && (GET_RTX_CLASS (GET_CODE (*loc)) == '2'\n-\t  || GET_RTX_CLASS (GET_CODE (*loc)) == 'c')\n+      && ARITHMETIC_P (*loc)\n       && GET_CODE (XEXP (*loc, 0)) == REG)\n     {\n       rtx op1 = XEXP (*loc, 1);\n@@ -3068,7 +3067,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n       /* If ARG1 is a comparison operator and CODE is testing for\n \t STORE_FLAG_VALUE, get the inner arguments.  */\n \n-      else if (GET_RTX_CLASS (GET_CODE (arg1)) == '<')\n+      else if (COMPARISON_P (arg1))\n \t{\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t  REAL_VALUE_TYPE fsfv;\n@@ -3157,7 +3156,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t\t\t   REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t   )\n-\t\t  && GET_RTX_CLASS (GET_CODE (p->exp)) == '<'))\n+\t\t  && COMPARISON_P (p->exp)))\n \t    {\n \t      x = p->exp;\n \t      break;\n@@ -3177,7 +3176,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t\t\t    REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t    )\n-\t\t   && GET_RTX_CLASS (GET_CODE (p->exp)) == '<')\n+\t\t   && COMPARISON_P (p->exp))\n \t    {\n \t      reverse_code = 1;\n \t      x = p->exp;\n@@ -3210,7 +3209,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t  else\n \t    code = reversed;\n \t}\n-      else if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n+      else if (COMPARISON_P (x))\n \tcode = GET_CODE (x);\n       arg1 = XEXP (x, 0), arg2 = XEXP (x, 1);\n     }\n@@ -3391,9 +3390,9 @@ fold_rtx (rtx x, rtx insn)\n \t\tenum rtx_code eltcode = GET_CODE (elt->exp);\n \n \t        /* Just check for unary and binary operations.  */\n-\t        if (GET_RTX_CLASS (GET_CODE (elt->exp)) == '1'\n-\t\t    && GET_CODE (elt->exp) != SIGN_EXTEND\n-\t\t    && GET_CODE (elt->exp) != ZERO_EXTEND\n+\t        if (UNARY_P (elt->exp)\n+\t\t    && eltcode != SIGN_EXTEND\n+\t\t    && eltcode != ZERO_EXTEND\n \t\t    && GET_CODE (XEXP (elt->exp, 0)) == SUBREG\n \t\t    && GET_MODE (SUBREG_REG (XEXP (elt->exp, 0))) == mode\n \t\t    && (GET_MODE_CLASS (mode)\n@@ -3409,8 +3408,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t      new = simplify_unary_operation (GET_CODE (elt->exp), mode,\n \t\t\t\t\t\t      op0, mode);\n \t\t  }\n-\t        else if ((GET_RTX_CLASS (GET_CODE (elt->exp)) == '2'\n-\t\t\t  || GET_RTX_CLASS (GET_CODE (elt->exp)) == 'c')\n+\t        else if (ARITHMETIC_P (elt->exp)\n \t\t         && eltcode != DIV && eltcode != MOD\n \t\t         && eltcode != UDIV && eltcode != UMOD\n \t\t         && eltcode != ASHIFTRT && eltcode != LSHIFTRT\n@@ -3768,9 +3766,8 @@ fold_rtx (rtx x, rtx insn)\n \t    if (validate_change (insn, &XEXP (x, i), replacements[j], 0))\n \t      break;\n \n-\t    if (code == NE || code == EQ || GET_RTX_CLASS (code) == 'c'\n-\t\t|| code == LTGT || code == UNEQ || code == ORDERED\n-\t\t|| code == UNORDERED)\n+\t    if (GET_RTX_CLASS (code) == RTX_COMM_COMPARE\n+\t\t|| GET_RTX_CLASS (code) == RTX_COMM_ARITH)\n \t      {\n \t\tvalidate_change (insn, &XEXP (x, i), XEXP (x, 1 - i), 1);\n \t\tvalidate_change (insn, &XEXP (x, 1 - i), replacements[j], 1);\n@@ -3802,9 +3799,7 @@ fold_rtx (rtx x, rtx insn)\n      operand unless the first operand is also a constant integer.  Otherwise,\n      place any constant second unless the first operand is also a constant.  */\n \n-  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c'\n-      || code == LTGT || code == UNEQ || code == ORDERED\n-      || code == UNORDERED)\n+  if (COMMUTATIVE_P (x))\n     {\n       if (must_swap\n \t  || swap_commutative_operands_p (const_arg0 ? const_arg0\n@@ -3834,7 +3829,7 @@ fold_rtx (rtx x, rtx insn)\n \n   switch (GET_RTX_CLASS (code))\n     {\n-    case '1':\n+    case RTX_UNARY:\n       {\n \tint is_const = 0;\n \n@@ -3857,7 +3852,8 @@ fold_rtx (rtx x, rtx insn)\n       }\n       break;\n \n-    case '<':\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n       /* See what items are actually being compared and set FOLDED_ARG[01]\n \t to those values and CODE to the actual comparison code.  If any are\n \t constant, set CONST_ARG0 and CONST_ARG1 appropriately.  We needn't\n@@ -4039,8 +4035,8 @@ fold_rtx (rtx x, rtx insn)\n #endif\n       break;\n \n-    case '2':\n-    case 'c':\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n       switch (code)\n \t{\n \tcase PLUS:\n@@ -4245,23 +4241,23 @@ fold_rtx (rtx x, rtx insn)\n \t\t\t\t       const_arg1 ? const_arg1 : folded_arg1);\n       break;\n \n-    case 'o':\n+    case RTX_OBJ:\n       /* (lo_sum (high X) X) is simply X.  */\n       if (code == LO_SUM && const_arg0 != 0\n \t  && GET_CODE (const_arg0) == HIGH\n \t  && rtx_equal_p (XEXP (const_arg0, 0), const_arg1))\n \treturn const_arg1;\n       break;\n \n-    case '3':\n-    case 'b':\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n       new = simplify_ternary_operation (code, mode, mode_arg0,\n \t\t\t\t\tconst_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t\tconst_arg1 ? const_arg1 : folded_arg1,\n \t\t\t\t\tconst_arg2 ? const_arg2 : XEXP (x, 2));\n       break;\n \n-    case 'x':\n+    case RTX_EXTRA:\n       /* Eliminate CONSTANT_P_RTX if its constant.  */\n       if (code == CONSTANT_P_RTX)\n \t{\n@@ -4271,6 +4267,9 @@ fold_rtx (rtx x, rtx insn)\n \t    return const0_rtx;\n \t}\n       break;\n+\n+    default:\n+      break;\n     }\n \n   return new ? new : x;\n@@ -5647,7 +5646,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n #ifdef PUSH_ROUNDING\n \t  /* Stack pushes invalidate the stack pointer.  */\n \t  rtx addr = XEXP (dest, 0);\n-\t  if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n+\t  if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC\n \t      && XEXP (addr, 0) == stack_pointer_rtx)\n \t    invalidate (stack_pointer_rtx, Pmode);\n #endif\n@@ -6313,7 +6312,7 @@ invalidate_memory (void)\n static int\n addr_affects_sp_p (rtx addr)\n {\n-  if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n+  if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC\n       && GET_CODE (XEXP (addr, 0)) == REG\n       && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {\n@@ -7193,7 +7192,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n       if (GET_MODE (insn) == QImode)\n \tPUT_MODE (insn, VOIDmode);\n \n-      if (GET_RTX_CLASS (code) == 'i')\n+      if (GET_RTX_CLASS (code) == RTX_INSN)\n \t{\n \t  rtx p;\n "}, {"sha": "2997c4581b28e4729bf7554b340b65e7e5e3968f", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -367,14 +367,14 @@ commutative arithmetic operators of RTL and whose mode is @var{mode}:\n \n @smallexample\n int\n-commutative_operator (x, mode)\n+commutative_integer_operator (x, mode)\n      rtx x;\n      enum machine_mode mode;\n @{\n   enum rtx_code code = GET_CODE (x);\n   if (GET_MODE (x) != mode)\n     return 0;\n-  return (GET_RTX_CLASS (code) == 'c'\n+  return (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n           || code == EQ || code == NE);\n @}\n @end smallexample"}, {"sha": "ecc18521294b6930c787b30be4e4302f9d7fa0f7", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -140,58 +140,67 @@ of an RTX code with the macro @code{GET_RTX_CLASS (@var{code})}.\n Currently, @file{rtx.def} defines these classes:\n \n @table @code\n-@item o\n+@item RTX_OBJ\n An RTX code that represents an actual object, such as a register\n (@code{REG}) or a memory location (@code{MEM}, @code{SYMBOL_REF}).\n-Constants and basic transforms on objects (@code{ADDRESSOF},\n-@code{HIGH}, @code{LO_SUM}) are also included.  Note that @code{SUBREG}\n-and @code{STRICT_LOW_PART} are not in this class, but in class @code{x}.\n+@code{LO_SUM}) is also included; instead, @code{SUBREG} and\n+@code{STRICT_LOW_PART} are not in this class, but in class @code{x}.\n \n-@item <\n-An RTX code for a comparison, such as @code{NE} or @code{LT}.\n+@item RTX_CONST_OBJ\n+An RTX code that represents a constant object.  @code{HIGH} is also\n+included in this class.\n \n-@item 1\n+@item RTX_COMPARE\n+An RTX code for a non-symmetric comparison, such as @code{GEU} or\n+@code{LT}.\n+\n+@item RTX_COMM_COMPARE\n+An RTX code for a symmetric (commutative) comparison, such as @code{EQ}\n+or @code{ORDERED}.\n+\n+@item RTX_UNARY\n An RTX code for a unary arithmetic operation, such as @code{NEG},\n @code{NOT}, or @code{ABS}.  This category also includes value extension\n (sign or zero) and conversions between integer and floating point.\n \n-@item c\n+@item RTX_COMM_ARITH\n An RTX code for a commutative binary operation, such as @code{PLUS} or\n @code{AND}.  @code{NE} and @code{EQ} are comparisons, so they have class\n @code{<}.\n \n-@item 2\n+@item RTX_BIN_ARITH\n An RTX code for a non-commutative binary operation, such as @code{MINUS},\n @code{DIV}, or @code{ASHIFTRT}.\n \n-@item b\n+@item RTX_BITFIELD_OPS\n An RTX code for a bit-field operation.  Currently only\n @code{ZERO_EXTRACT} and @code{SIGN_EXTRACT}.  These have three inputs\n and are lvalues (so they can be used for insertion as well).\n @xref{Bit-Fields}.\n \n-@item 3\n+@item RTX_TERNARY\n An RTX code for other three input operations.  Currently only\n-@code{IF_THEN_ELSE}.\n+@code{IF_THEN_ELSE} and @code{VEC_MERGE}.\n \n-@item i\n+@item RTX_INSN\n An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and\n @code{CALL_INSN}.  @xref{Insns}.\n \n-@item m\n+@item RTX_MATCH\n An RTX code for something that matches in insns, such as\n @code{MATCH_DUP}.  These only occur in machine descriptions.\n \n-@item a\n+@item RTX_AUTOINC\n An RTX code for an auto-increment addressing mode, such as\n @code{POST_INC}.\n \n-@item x\n+@item RTX_EXTRA\n All other RTX codes.  This category includes the remaining codes used\n only in machine descriptions (@code{DEFINE_*}, etc.).  It also includes\n all the codes describing side effects (@code{SET}, @code{USE},\n @code{CLOBBER}, etc.) and the non-insns that may appear on an insn\n chain, such as @code{NOTE}, @code{BARRIER}, and @code{CODE_LABEL}.\n+@code{SUBREG} is also part of this class.\n @end table\n \n @cindex RTL format"}, {"sha": "6872afa33011fa44aa6d24f412e38d19105e649f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -4982,7 +4982,7 @@ copy_insn_1 (rtx orig)\n   RTX_FLAG (copy, used) = 0;\n \n   /* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */\n-  if (GET_RTX_CLASS (code) == 'i')\n+  if (INSN_P (orig))\n     {\n       RTX_FLAG (copy, jump) = 0;\n       RTX_FLAG (copy, call) = 0;"}, {"sha": "e2063c1950f06a69a32c522d4e8f883980a125a7", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -5624,7 +5624,7 @@ force_operand (rtx value, rtx target)\n       return target;\n     }\n \n-  if (GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n+  if (ARITHMETIC_P (value))\n     {\n       op2 = XEXP (value, 1);\n       if (!CONSTANT_P (op2) && !(GET_CODE (op2) == REG && op2 != subtarget))\n@@ -5693,7 +5693,7 @@ force_operand (rtx value, rtx target)\n \t\t\t\t      target, 1, OPTAB_LIB_WIDEN);\n \t}\n     }\n-  if (GET_RTX_CLASS (code) == '1')\n+  if (UNARY_P (value))\n     {\n       op1 = force_operand (XEXP (value, 0), NULL_RTX);\n       return expand_simple_unop (GET_MODE (value), code, op1, target, 0);"}, {"sha": "832b3335cd1c45307f72a3171601ac8f07fe1123", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -2217,7 +2217,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t    && GET_CODE (body) == SET\n \t    && SET_DEST (body) == pc_rtx\n \t    && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n-\t    && GET_RTX_CLASS (GET_CODE (XEXP (SET_SRC (body), 0))) == '<'\n+\t    && COMPARISON_P (XEXP (SET_SRC (body), 0))\n \t    && XEXP (XEXP (SET_SRC (body), 0), 0) == cc0_rtx\n \t    /* This is done during prescan; it is not done again\n \t       in final scan when prescan has been done.  */\n@@ -2845,8 +2845,8 @@ get_mem_expr_from_op (rtx op, int *paddressp)\n \t   && (expr = get_mem_expr_from_op (XEXP (op, 1), &inner_addressp)))\n     return expr;\n \n-  while (GET_RTX_CLASS (GET_CODE (op)) == '1'\n-\t || GET_RTX_CLASS (GET_CODE (op)) == '2')\n+  while (GET_RTX_CLASS (GET_CODE (op)) == RTX_UNARY\n+\t || GET_RTX_CLASS (GET_CODE (op)) == RTX_BIN_ARITH)\n     op = XEXP (op, 0);\n \n   expr = get_mem_expr_from_op (op, &inner_addressp);"}, {"sha": "99c943ae797929fa857c96aa3a0108b8e7955fab", "filename": "gcc/flow.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -914,7 +914,7 @@ notice_stack_pointer_modification_1 (rtx x, rtx pat ATTRIBUTE_UNUSED,\n \t of a push until later in flow.  See the comments in rtl.texi\n \t regarding Embedded Side-Effects on Addresses.  */\n       || (GET_CODE (x) == MEM\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == 'a'\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == RTX_AUTOINC\n \t  && XEXP (XEXP (x, 0), 0) == stack_pointer_rtx))\n     current_function_sp_is_unchanging = 0;\n }\n@@ -2439,7 +2439,7 @@ invalidate_mems_from_autoinc (rtx *px, void *data)\n   rtx x = *px;\n   struct propagate_block_info *pbi = data;\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'a')\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n     {\n       invalidate_mems_from_set (pbi, XEXP (x, 0));\n       return -1;\n@@ -3054,9 +3054,9 @@ ior_reg_cond (rtx old, rtx x, int add)\n {\n   rtx op0, op1;\n \n-  if (GET_RTX_CLASS (GET_CODE (old)) == '<')\n+  if (COMPARISON_P (old))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (x)) == '<'\n+      if (COMPARISON_P (x))\n \t  && REVERSE_CONDEXEC_PREDICATES_P (GET_CODE (x), GET_CODE (old))\n \t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n \treturn const1_rtx;\n@@ -3149,7 +3149,7 @@ not_reg_cond (rtx x)\n   x_code = GET_CODE (x);\n   if (x_code == NOT)\n     return XEXP (x, 0);\n-  if (GET_RTX_CLASS (x_code) == '<'\n+  if (COMPARISON_P (x)\n       && GET_CODE (XEXP (x, 0)) == REG)\n     {\n       if (XEXP (x, 1) != const0_rtx)\n@@ -3166,9 +3166,9 @@ and_reg_cond (rtx old, rtx x, int add)\n {\n   rtx op0, op1;\n \n-  if (GET_RTX_CLASS (GET_CODE (old)) == '<')\n+  if (COMPARISON_P (old))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (x)) == '<'\n+      if (COMPARISON_P (x))\n \t  && GET_CODE (x) == reverse_condition (GET_CODE (old))\n \t  && REGNO (XEXP (x, 0)) == REGNO (XEXP (old, 0)))\n \treturn const0_rtx;\n@@ -3259,7 +3259,7 @@ elim_reg_cond (rtx x, unsigned int regno)\n {\n   rtx op0, op1;\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n+  if (COMPARISON_P (x))\n     {\n       if (REGNO (XEXP (x, 0)) == regno)\n \treturn const0_rtx;"}, {"sha": "a42b806551689446d44c9f8d1193d5885224060d", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -7677,8 +7677,7 @@ update_epilogue_consts (rtx dest, rtx x, void *data)\n \n   /* If this is a binary operation between a register we have been tracking\n      and a constant, see if we can compute a new constant value.  */\n-  else if ((GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == 'c'\n-\t    || GET_RTX_CLASS (GET_CODE (SET_SRC (x))) == '2')\n+  else if (ARITHMETIC_P (SET_SRC (x))\n \t   && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n \t   && REGNO (XEXP (SET_SRC (x), 0)) < FIRST_PSEUDO_REGISTER\n \t   && p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))] != 0"}, {"sha": "a3c035f4ef79973b0098fedad3c485cfdb17d68e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -565,7 +565,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n      Use that entry if one is found; otherwise create a new RTL and add it\n      to the table.  */\n \n-  if (GET_RTX_CLASS (code) == '1')\n+  if (GET_RTX_CLASS (code) == RTX_UNARY)\n     {\n       rtx arg0 = va_arg (p, rtx);\n \n@@ -591,9 +591,10 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \t  XEXP (rt_val, 0) = arg0;\n \t}\n     }\n-  else if (GET_RTX_CLASS (code) == 'c'\n-\t   || GET_RTX_CLASS (code) == '2'\n-\t   || GET_RTX_CLASS (code) == '<')\n+  else if (GET_RTX_CLASS (code) == RTX_BIN_ARITH\n+  \t   || GET_RTX_CLASS (code) == RTX_COMM_ARITH\n+  \t   || GET_RTX_CLASS (code) == RTX_COMPARE\n+  \t   || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n     {\n       rtx arg0 = va_arg (p, rtx);\n       rtx arg1 = va_arg (p, rtx);"}, {"sha": "52a224e6d538049f635cec6d3dfa2bf026897206", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -222,7 +222,9 @@ gen_insn (rtx insn)\n \t\t    /* We have to be concerned about matching \"gt\" and\n \t\t       missing \"gtu\", e.g., so verify we have reached the\n \t\t       end of thing we are to match.  */\n-\t\t    if (*p == 0 && *q == 0 && GET_RTX_CLASS(op) == '<')\n+\t\t    if (*p == 0 && *q == 0\n+\t\t\t&& (GET_RTX_CLASS (op) == RTX_COMPARE\n+\t\t\t    || GET_RTX_CLASS (op) == RTX_COMM_COMPARE))\n \t\t      break;\n \t\t  }\n "}, {"sha": "f30e3b950d567ee661c3fc095eae45c77ebf520f", "filename": "gcc/integrate.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -2711,7 +2711,8 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n   /* If this is a commutative operation, move a constant to the second\n      operand unless the second operand is already a CONST_INT.  */\n   if (! memonly\n-      && (GET_RTX_CLASS (code) == 'c' || code == NE || code == EQ)\n+      && (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n+\t  || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n       && CONSTANT_P (XEXP (x, 0)) && GET_CODE (XEXP (x, 1)) != CONST_INT)\n     {\n       rtx tem = XEXP (x, 0);\n@@ -2723,14 +2724,15 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n   if (! memonly)\n     switch (GET_RTX_CLASS (code))\n       {\n-      case '1':\n+      case RTX_UNARY:\n \tif (op0_mode == MAX_MACHINE_MODE)\n \t  abort ();\n \tnew = simplify_unary_operation (code, GET_MODE (x),\n \t\t\t\t\tXEXP (x, 0), op0_mode);\n \tbreak;\n \n-      case '<':\n+      case RTX_COMPARE:\n+      case RTX_COMM_COMPARE:\n \t{\n \t  enum machine_mode op_mode = GET_MODE (XEXP (x, 0));\n \n@@ -2757,22 +2759,22 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \t  break;\n \t}\n \n-      case '2':\n-      case 'c':\n+      case RTX_BIN_ARITH:\n+      case RTX_COMM_ARITH:\n \tnew = simplify_binary_operation (code, GET_MODE (x),\n \t\t\t\t\t XEXP (x, 0), XEXP (x, 1));\n \tbreak;\n \n-      case 'b':\n-      case '3':\n+      case RTX_BITFIELD_OPS:\n+      case RTX_TERNARY:\n \tif (op0_mode == MAX_MACHINE_MODE)\n \t  abort ();\n \n \tif (code == IF_THEN_ELSE)\n \t  {\n \t    rtx op0 = XEXP (x, 0);\n \n-\t    if (GET_RTX_CLASS (GET_CODE (op0)) == '<'\n+\t    if (COMPARISON_P (op0)\n \t\t&& GET_MODE (op0) == VOIDmode\n \t\t&& ! side_effects_p (op0)\n \t\t&& XEXP (op0, 0) == map->compare_src\n@@ -2797,6 +2799,9 @@ subst_constants (rtx *loc, rtx insn, struct inline_remap *map, int memonly)\n \t\t\t\t\t    XEXP (x, 0), XEXP (x, 1),\n \t\t\t\t\t    XEXP (x, 2));\n \tbreak;\n+\n+      default:\n+\tbreak;\n       }\n \n   if (new)"}, {"sha": "6fd2de4fa81ae1eb0c7957d3d803d16be521a123", "filename": "gcc/jump.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -637,7 +637,8 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n   enum machine_mode mode;\n \n   /* If this is not actually a comparison, we can't reverse it.  */\n-  if (GET_RTX_CLASS (code) != '<')\n+  if (GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n     return UNKNOWN;\n \n   mode = GET_MODE (arg0);\n@@ -748,7 +749,7 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n enum rtx_code\n reversed_comparison_code (rtx comparison, rtx insn)\n {\n-  if (GET_RTX_CLASS (GET_CODE (comparison)) != '<')\n+  if (!COMPARISON_P (comparison))\n     return UNKNOWN;\n   return reversed_comparison_code_parts (GET_CODE (comparison),\n \t\t\t\t\t XEXP (comparison, 0),\n@@ -1764,24 +1765,24 @@ delete_related_insns (rtx insn)\n \n   if (was_code_label && prev && GET_CODE (prev) == BARRIER)\n     {\n-      RTX_CODE code;\n-      while (next != 0\n-\t     && (GET_RTX_CLASS (code = GET_CODE (next)) == 'i'\n-\t\t || code == NOTE || code == BARRIER\n-\t\t || (code == CODE_LABEL && INSN_DELETED_P (next))))\n+      enum rtx_code code;\n+      while (next)\n \t{\n+\t  code = GET_CODE (next);\n \t  if (code == NOTE\n \t      && NOTE_LINE_NUMBER (next) != NOTE_INSN_FUNCTION_END)\n \t    next = NEXT_INSN (next);\n \t  /* Keep going past other deleted labels to delete what follows.  */\n \t  else if (code == CODE_LABEL && INSN_DELETED_P (next))\n \t    next = NEXT_INSN (next);\n-\t  else\n+\t  else if (code == BARRIER || INSN_P (next))\n \t    /* Note: if this deletes a jump, it can cause more\n \t       deletion of unreachable code, after a different label.\n \t       As long as the value from this recursive call is correct,\n \t       this invocation functions correctly.  */\n \t    next = delete_related_insns (next);\n+\t  else\n+\t    break;\n \t}\n     }\n \n@@ -2186,7 +2187,7 @@ int\n rtx_renumbered_equal_p (rtx x, rtx y)\n {\n   int i;\n-  RTX_CODE code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n \n   if (x == y)\n@@ -2296,16 +2297,15 @@ rtx_renumbered_equal_p (rtx x, rtx y)\n      order.  Also handle the simple binary and unary cases without a loop.\n \n      ??? Don't consider PLUS a commutative operator; see comments above.  */\n-  if ((code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n-      && code != PLUS)\n+  if (COMMUTATIVE_P (x) && code != PLUS)\n     return ((rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0))\n \t     && rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 1)))\n \t    || (rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 1))\n \t\t&& rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 0))));\n-  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n+  else if (NON_COMMUTATIVE_P (x))\n     return (rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0))\n \t    && rtx_renumbered_equal_p (XEXP (x, 1), XEXP (y, 1)));\n-  else if (GET_RTX_CLASS (code) == '1')\n+  else if (UNARY_P (x))\n     return rtx_renumbered_equal_p (XEXP (x, 0), XEXP (y, 0));\n \n   /* Compare the elements.  If any pair of corresponding elements"}, {"sha": "d71acab4daeb7283331fb3efb6a420ce708bf196", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1392,9 +1392,7 @@ block_alloc (int b)\n \n \t      /* Here we care if the operation to be computed is\n \t\t commutative.  */\n-\t      else if ((GET_CODE (XEXP (note, 0)) == EQ\n-\t\t\t|| GET_CODE (XEXP (note, 0)) == NE\n-\t\t\t|| GET_RTX_CLASS (GET_CODE (XEXP (note, 0))) == 'c')\n+\t      else if (COMMUTATIVE_P (XEXP (note, 0))\n \t\t       && (r1 = XEXP (XEXP (note, 0), 1),\n \t\t\t   (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n \t\t       && no_conflict_p (insn, r0, r1))"}, {"sha": "97cfdf7c07e18a9b6564a0d061a4649e5a370031", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1469,7 +1469,7 @@ simplify_using_condition (rtx cond, rtx *expr, regset altered)\n {\n   rtx rev, reve, exp = *expr;\n \n-  if (GET_RTX_CLASS (GET_CODE (*expr)) != '<')\n+  if (!COMPARISON_P (exp))\n     return;\n \n   /* If some register gets altered later, we do not really speak about its\n@@ -1894,7 +1894,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   desc->niter_max = 0;\n \n   cond = GET_CODE (condition);\n-  if (GET_RTX_CLASS (cond) != '<')\n+  if (!COMPARISON_P (condition))\n     abort ();\n \n   mode = GET_MODE (XEXP (condition, 0));"}, {"sha": "d4e891007c24a19bf5e4cfde6aaa30f8637a3e35", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -3678,15 +3678,14 @@ rtx_equal_for_prefetch_p (rtx x, rtx y)\n   if (code != GET_CODE (y))\n     return 0;\n \n-  code = GET_CODE (x);\n-\n-  if (GET_RTX_CLASS (code) == 'c')\n+  if (COMMUTATIVE_ARITH_P (x))\n     {\n       return ((rtx_equal_for_prefetch_p (XEXP (x, 0), XEXP (y, 0))\n \t       && rtx_equal_for_prefetch_p (XEXP (x, 1), XEXP (y, 1)))\n \t      || (rtx_equal_for_prefetch_p (XEXP (x, 0), XEXP (y, 1))\n \t          && rtx_equal_for_prefetch_p (XEXP (x, 1), XEXP (y, 0))));\n     }\n+\n   /* Compare the elements.  If any pair of corresponding elements fails to\n      match, return 0 for the whole thing.  */\n \n@@ -8607,7 +8606,7 @@ maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n       rtx note;\n \n       /* If this is a libcall that sets a giv, skip ahead to its end.  */\n-      if (GET_RTX_CLASS (code) == 'i')\n+      if (INSN_P (p))\n \t{\n \t  note = find_reg_note (p, REG_LIBCALL, NULL_RTX);\n \n@@ -9222,7 +9221,8 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args\n      in cse.c  */\n \n-  while (GET_RTX_CLASS (code) == '<'\n+  while ((GET_RTX_CLASS (code) == RTX_COMPARE\n+\t  || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n \t && op1 == CONST0_RTX (GET_MODE (op0))\n \t && op0 != want_reg)\n     {\n@@ -9312,7 +9312,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t     ))\n-\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'))\n+\t\t   && COMPARISON_P (SET_SRC (set))))\n \t      && (((GET_MODE_CLASS (mode) == MODE_CC)\n \t\t   == (GET_MODE_CLASS (inner_mode) == MODE_CC))\n \t\t  || mode == VOIDmode || inner_mode == VOIDmode))\n@@ -9332,7 +9332,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n #endif\n \t\t     ))\n-\t\t   && GET_RTX_CLASS (GET_CODE (SET_SRC (set))) == '<'\n+\t\t   && COMPARISON_P (SET_SRC (set))\n \t\t   && (((GET_MODE_CLASS (mode) == MODE_CC)\n \t\t\t== (GET_MODE_CLASS (inner_mode) == MODE_CC))\n \t\t       || mode == VOIDmode || inner_mode == VOIDmode))\n@@ -9351,7 +9351,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \n       if (x)\n \t{\n-\t  if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n+\t  if (COMPARISON_P (x))\n \t    code = GET_CODE (x);\n \t  if (reverse_code)\n \t    {"}, {"sha": "4fd6ae6aa1e5381ce7a8e3480a22be167c642fb9", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -153,8 +153,11 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n       || NEXT_INSN (insns) == NULL_RTX)\n     abort ();\n \n-  if (GET_RTX_CLASS (code) != '1' && GET_RTX_CLASS (code) != '2'\n-      && GET_RTX_CLASS (code) != 'c' && GET_RTX_CLASS (code) != '<')\n+  if (GET_RTX_CLASS (code) != RTX_COMM_ARITH\n+      && GET_RTX_CLASS (code) != RTX_BIN_ARITH\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_UNARY)\n     return 1;\n \n   if (GET_CODE (target) == ZERO_EXTRACT)\n@@ -190,7 +193,7 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n \t}\n     }\n \n-  if (GET_RTX_CLASS (code) == '1')\n+  if (GET_RTX_CLASS (code) == RTX_UNARY)\n     note = gen_rtx_fmt_e (code, GET_MODE (target), copy_rtx (op0));\n   else\n     note = gen_rtx_fmt_ee (code, GET_MODE (target), copy_rtx (op0), copy_rtx (op1));\n@@ -718,7 +721,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      try to make the first operand a register.\n      Even better, try to make it the same as the target.\n      Also try to make the last operand a constant.  */\n-  if (GET_RTX_CLASS (binoptab->code) == 'c'\n+  if (GET_RTX_CLASS (binoptab->code) == RTX_COMM_ARITH\n       || binoptab == smul_widen_optab\n       || binoptab == umul_widen_optab\n       || binoptab == smul_highpart_optab"}, {"sha": "a7a1f235cc720bc4b5fa2795bc6c1b99fc0c7b3e", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -533,7 +533,7 @@ estimate_probability (struct loops *loops_info)\n       /* Try \"pointer heuristic.\"\n \t A comparison ptr == 0 is predicted as false.\n \t Similarly, a comparison ptr1 == ptr2 is predicted as false.  */\n-      if (GET_RTX_CLASS (GET_CODE (cond)) == '<'\n+      if (COMPARISON_P (cond)\n \t  && ((REG_P (XEXP (cond, 0)) && REG_POINTER (XEXP (cond, 0)))\n \t      || (REG_P (XEXP (cond, 1)) && REG_POINTER (XEXP (cond, 1)))))\n \t{"}, {"sha": "4936898ae8b06b9cfdf4625ed94de25208d56dc4", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1,5 +1,5 @@\n /* Graph coloring register allocator\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Michael Matz <matz@suse.de>\n    and Daniel Berlin <dan@cgsoftware.com>.\n \n@@ -130,9 +130,11 @@ ra_print_rtx_2op (FILE *file, rtx x)\n       case AND: opname = \"&\"; break;\n       case IOR: opname = \"|\"; break;\n       case XOR: opname = \"^\"; break;\n-      /* class '<' */\n+      /* class '=' */\n       case NE: opname = \"!=\"; break;\n       case EQ: opname = \"==\"; break;\n+      case LTGT: opname = \"<>\"; break;\n+      /* class '<' */\n       case GE: opname = \"s>=\"; break;\n       case GT: opname = \"s>\"; break;\n       case LE: opname = \"s<=\"; break;\n@@ -196,7 +198,7 @@ ra_print_rtx_3op (FILE *file, rtx x)\n     }\n }\n \n-/* Print rtx X, which represents an object (class 'o' or some constructs\n+/* Print rtx X, which represents an object (class 'o', 'C', or some constructs\n    of class 'x' (e.g. subreg)), to FILE.\n    (reg XX) rtl is represented as \"pXX\", of XX was a pseudo,\n    as \"name\" it name is the nonnull hardreg name, or as \"hXX\", if XX\n@@ -340,12 +342,10 @@ void\n ra_print_rtx (FILE *file, rtx x, int with_pn)\n {\n   enum rtx_code code;\n-  char class;\n   int unhandled = 0;\n   if (!x)\n     return;\n   code = GET_CODE (x);\n-  class = GET_RTX_CLASS (code);\n \n   /* First handle the insn like constructs.  */\n   if (INSN_P (x) || code == NOTE || code == CODE_LABEL || code == BARRIER)\n@@ -492,16 +492,24 @@ ra_print_rtx (FILE *file, rtx x, int with_pn)\n     }\n   if (!unhandled)\n     return;\n-  if (class == '1')\n-    ra_print_rtx_1op (file, x);\n-  else if (class == '2' || class == 'c' || class == '<')\n-    ra_print_rtx_2op (file, x);\n-  else if (class == '3' || class == 'b')\n-    ra_print_rtx_3op (file, x);\n-  else if (class == 'o')\n-    ra_print_rtx_object (file, x);\n-  else\n-    print_inline_rtx (file, x, 0);\n+  switch (GET_RTX_CLASS (code))\n+    {\n+      case RTX_UNARY:\n+        ra_print_rtx_1op (file, x);\n+      case RTX_BIN_ARITH:\n+      case RTX_COMM_ARITH:\n+      case RTX_COMPARE:\n+      case RTX_COMM_COMPARE:\n+        ra_print_rtx_2op (file, x);\n+      case RTX_TERNARY:\n+      case RTX_BITFIELD_OPS:\n+        ra_print_rtx_3op (file, x);\n+      case RTX_OBJ:\n+      case RTX_CONST_OBJ:\n+        ra_print_rtx_object (file, x);\n+      default:\n+        print_inline_rtx (file, x, 0);\n+    }\n }\n \n /* This only calls ra_print_rtx(), but emits a final newline.  */"}, {"sha": "c3cf522d827ad656342d020b773c7e7cf4849ec8", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -521,11 +521,11 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n   /* Do changes needed to keep rtx consistent.  Don't do any other\n      simplifications, as it is not our job.  */\n \n-  if ((GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n+  if (SWAPPABLE_OPERANDS_P (x)\n       && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n     {\n       validate_change (object, loc,\n-\t\t       gen_rtx_fmt_ee (GET_RTX_CLASS (code) == 'c' ? code\n+\t\t       gen_rtx_fmt_ee (COMMUTATIVE_ARITH_P (x) ? code\n \t\t\t\t       : swap_condition (code),\n \t\t\t\t       GET_MODE (x), XEXP (x, 1),\n \t\t\t\t       XEXP (x, 0)), 1);\n@@ -1370,7 +1370,7 @@ int\n comparison_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '<');\n+\t  && COMPARISON_P (op));\n }\n \f\n /* If BODY is an insn body that uses ASM_OPERANDS,\n@@ -1931,7 +1931,7 @@ offsettable_address_p (int strictp, enum machine_mode mode, rtx y)\n       return good;\n     }\n \n-  if (GET_RTX_CLASS (ycode) == 'a')\n+  if (GET_RTX_CLASS (ycode) == RTX_AUTOINC)\n     return 0;\n \n   /* The offset added here is chosen as the maximum offset that\n@@ -2304,7 +2304,7 @@ constrain_operands (int strict)\n \n \t  /* A unary operator may be accepted by the predicate, but it\n \t     is irrelevant for matching constraints.  */\n-\t  if (GET_RTX_CLASS (GET_CODE (op)) == '1')\n+\t  if (UNARY_P (op))\n \t    op = XEXP (op, 0);\n \n \t  if (GET_CODE (op) == SUBREG)\n@@ -2377,9 +2377,9 @@ constrain_operands (int strict)\n \n \t\t      /* A unary operator may be accepted by the predicate,\n \t\t\t but it is irrelevant for matching constraints.  */\n-\t\t      if (GET_RTX_CLASS (GET_CODE (op1)) == '1')\n+\t\t      if (UNARY_P (op1))\n \t\t\top1 = XEXP (op1, 0);\n-\t\t      if (GET_RTX_CLASS (GET_CODE (op2)) == '1')\n+\t\t      if (UNARY_P (op2))\n \t\t\top2 = XEXP (op2, 0);\n \n \t\t      val = operands_match_p (op1, op2);"}, {"sha": "22b290fd5cbd093dc0ba8b3165ab16bbd49a0168", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1178,7 +1178,7 @@ swap_rtx_condition_1 (rtx pat)\n   const char *fmt;\n   int i, r = 0;\n \n-  if (GET_RTX_CLASS (GET_CODE (pat)) == '<')\n+  if (COMPARISON_P (pat))\n     {\n       PUT_CODE (pat, swap_condition (GET_CODE (pat)));\n       r = 1;\n@@ -1654,7 +1654,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t      }\n \n \t    /* Keep operand 1 matching with destination.  */\n-\t    if (GET_RTX_CLASS (GET_CODE (pat_src)) == 'c'\n+\t    if (COMMUTATIVE_ARITH_P (pat_src)\n \t\t&& REG_P (*src1) && REG_P (*src2)\n \t\t&& REGNO (*src1) != REGNO (*dest))\n \t     {"}, {"sha": "0203d8aa3ff99ce183eaeb43065edf9e1c1f58e5", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1008,13 +1008,12 @@ record_operand_costs (rtx insn, struct costs *op_costs,\n static rtx\n scan_one_insn (rtx insn, int pass)\n {\n-  enum rtx_code code = GET_CODE (insn);\n   enum rtx_code pat_code;\n   rtx set, note;\n   int i, j;\n   struct costs op_costs[MAX_RECOG_OPERANDS];\n \n-  if (GET_RTX_CLASS (code) != 'i')\n+  if (!INSN_P (insn))\n     return insn;\n \n   pat_code = GET_CODE (PATTERN (insn));"}, {"sha": "671d9c824c06d5a481b17063eb2568f7789cf0b9", "filename": "gcc/regmove.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -2046,7 +2046,13 @@ stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n   RTX_CODE code = GET_CODE (x);\n   switch (GET_RTX_CLASS (code))\n     {\n-    case '<': case '1': case 'c': case '2': case 'b': case '3':\n+    case RTX_UNARY:\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n       {\n \tint i;\n \tconst char *fmt = GET_RTX_FORMAT (code);\n@@ -2056,7 +2062,7 @@ stable_and_no_regs_but_for_p (rtx x, rtx src, rtx dst)\n \t      return 0;\n \treturn 1;\n       }\n-    case 'o':\n+    case RTX_OBJ:\n       if (code == REG)\n \treturn x == src || x == dst;\n       /* If this is a MEM, look inside - there might be a register hidden in"}, {"sha": "e15bd87f861c386ce004f7adc8cede0f8fa741cd", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1173,7 +1173,7 @@ kill_autoinc_value (rtx *px, void *data)\n   rtx x = *px;\n   struct value_data *vd = data;\n \n-  if (GET_RTX_CLASS (GET_CODE (x)) == 'a')\n+  if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n     {\n       x = XEXP (x, 0);\n       kill_value (x, vd);"}, {"sha": "d3cdaa844a712e868f8cc39e2180d5620794055a", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -771,10 +771,10 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n \t\t\t\t  true_regnum (rld[i].reg_rtx)))\n \t&& out == 0 && rld[i].out == 0 && rld[i].in != 0\n \t&& ((GET_CODE (in) == REG\n-\t     && GET_RTX_CLASS (GET_CODE (rld[i].in)) == 'a'\n+\t     && GET_RTX_CLASS (GET_CODE (rld[i].in)) == RTX_AUTOINC\n \t     && MATCHES (XEXP (rld[i].in, 0), in))\n \t    || (GET_CODE (rld[i].in) == REG\n-\t\t&& GET_RTX_CLASS (GET_CODE (in)) == 'a'\n+\t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n@@ -2706,7 +2706,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  /* If we now have a simple operand where we used to have a\n \t     PLUS or MULT, re-recognize and try again.  */\n-\t  if ((GET_RTX_CLASS (GET_CODE (*recog_data.operand_loc[i])) == 'o'\n+\t  if ((OBJECT_P (*recog_data.operand_loc[i])\n \t       || GET_CODE (*recog_data.operand_loc[i]) == SUBREG)\n \t      && (GET_CODE (recog_data.operand[i]) == MULT\n \t\t  || GET_CODE (recog_data.operand[i]) == PLUS))\n@@ -2762,7 +2762,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t  substed_operand[i] = recog_data.operand[i] = op;\n \t}\n-      else if (code == PLUS || GET_RTX_CLASS (code) == '1')\n+      else if (code == PLUS || GET_RTX_CLASS (code) == RTX_UNARY)\n \t/* We can get a PLUS as an \"operand\" as a result of register\n \t   elimination.  See eliminate_regs and gen_reload.  We handle\n \t   a unary operator by reloading the operand.  */\n@@ -2890,7 +2890,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  /* If the predicate accepts a unary operator, it means that\n \t     we need to reload the operand, but do not do this for\n \t     match_operator and friends.  */\n-\t  if (GET_RTX_CLASS (GET_CODE (operand)) == '1' && *p != 0)\n+\t  if (UNARY_P (operand) && *p != 0)\n \t    operand = XEXP (operand, 0);\n \n \t  /* If the operand is a SUBREG, extract\n@@ -6271,7 +6271,7 @@ reg_overlap_mentioned_for_reload_p (rtx x, rtx in)\n \n   /* Overly conservative.  */\n   if (GET_CODE (x) == STRICT_LOW_PART\n-      || GET_RTX_CLASS (GET_CODE (x)) == 'a')\n+      || GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n     x = XEXP (x, 0);\n \n   /* If either argument is a constant, then modifying X can not affect IN.  */"}, {"sha": "870570c0956d2112ac5094b62de2d6369d2382c0", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -7512,7 +7512,7 @@ gen_reload (rtx out, rtx in, int opnum, enum reload_type type)\n #endif\n \n   /* If IN is a simple operand, use gen_move_insn.  */\n-  else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n+  else if (OBJECT_P (in) || GET_CODE (in) == SUBREG)\n     emit_insn (gen_move_insn (out, in));\n \n #ifdef HAVE_reload_load_address\n@@ -7779,7 +7779,7 @@ delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n       code = GET_CODE (prev);\n       if (code == CODE_LABEL || code == JUMP_INSN)\n \treturn;\n-      if (GET_RTX_CLASS (code) != 'i')\n+      if (!INSN_P (prev))\n \tcontinue;\n       if (reg_set_p (x, PATTERN (prev)))\n \tbreak;"}, {"sha": "a14c8e1b4f02806eb677ed5a0455bce46a070c02", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -90,7 +90,7 @@ const char * const rtx_format[NUM_RTX_CODE] = {\n /* Indexed by rtx code, gives a character representing the \"class\" of\n    that rtx code.  See rtl.def for documentation on the defined classes.  */\n \n-const char rtx_class[NUM_RTX_CODE] = {\n+const enum rtx_class rtx_class[NUM_RTX_CODE] = {\n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   CLASS,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n #undef DEF_RTL_EXPR\n@@ -260,7 +260,7 @@ copy_rtx (rtx orig)\n   RTX_FLAG (copy, used) = 0;\n \n   /* We do not copy FRAME_RELATED for INSNs.  */\n-  if (GET_RTX_CLASS (code) == 'i')\n+  if (INSN_P (orig))\n     RTX_FLAG (copy, frame_related) = 0;\n   RTX_FLAG (copy, jump) = RTX_FLAG (orig, jump);\n   RTX_FLAG (copy, call) = RTX_FLAG (orig, call);"}, {"sha": "c3653f49dfe2c42a654d42f5ac203d795b080ab3", "filename": "gcc/rtl.def", "status": "modified", "additions": 194, "deletions": 179, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -46,18 +46,33 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    4.  The class of the rtx.  These are stored in rtx_class and are accessed\n    via the GET_RTX_CLASS macro.  They are defined as follows:\n \n-     \"o\" an rtx code that can be used to represent an object (e.g, REG, MEM)\n-     \"<\" an rtx code for a comparison (e.g, EQ, NE, LT)\n-     \"1\" an rtx code for a unary arithmetic expression (e.g, NEG, NOT)\n-     \"c\" an rtx code for a commutative binary operation (e.g,, PLUS, MULT)\n-     \"3\" an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)\n-     \"2\" an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)\n-     \"b\" an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)\n-     \"i\" an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n-     \"m\" an rtx code for something that matches in insns (e.g, MATCH_DUP)\n-     \"g\" an rtx code for grouping insns together (e.g, GROUP_PARALLEL)\n-     \"a\" an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n-     \"x\" everything else\n+     RTX_CONST_OBJ\n+         an rtx code that can be used to represent a constant object\n+         (e.g, CONST_INT)\n+     RTX_OBJ\n+         an rtx code that can be used to represent an object (e.g, REG, MEM)\n+     RTX_COMPARE\n+         an rtx code for a comparison (e.g, LT, GT)\n+     RTX_COMM_COMPARE\n+         an rtx code for a commutative comparison (e.g, EQ, NE, ORDERED)\n+     RTX_UNARY\n+         an rtx code for a unary arithmetic expression (e.g, NEG, NOT)\n+     RTX_COMM_ARITH\n+         an rtx code for a commutative binary operation (e.g,, PLUS, MULT)\n+     RTX_TERNARY\n+         an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)\n+     RTX_BIN_ARITH\n+         an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)\n+     RTX_BITFIELD_OPS\n+         an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)\n+     RTX_INSN\n+         an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n+     RTX_MATCH\n+         an rtx code for something that matches in insns (e.g, MATCH_DUP)\n+     RTX_AUTOINC\n+         an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n+     RTX_EXTRA\n+         everything else\n      \n    */\n \n@@ -67,27 +82,27 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    --------------------------------------------------------------------- */\n \n /* an expression code name unknown to the reader */\n-DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", 'x')\n+DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n \n /* (NIL) is used by rtl reader and printer to represent a null pointer.  */\n \n-DEF_RTL_EXPR(NIL, \"nil\", \"*\", 'x')\n+DEF_RTL_EXPR(NIL, \"nil\", \"*\", RTX_EXTRA)\n \n \n /* include a file */\n \n-DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", 'x')\n+DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", RTX_EXTRA)\n \n /* ---------------------------------------------------------------------\n    Expressions used in constructing lists.\n    --------------------------------------------------------------------- */\n \n /* a linked list of expressions */\n-DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", 'x')\n+DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", RTX_EXTRA)\n \n /* a linked list of instructions.\n    The insns are represented in print by their uids.  */\n-DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n+DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Expression types for machine descriptions.\n@@ -126,27 +141,27 @@ DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n    There must be a 1 to 1 correspondence between these sets of classes in\n    all operands for an instruction.\n    */\n-DEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", 'm')\n+DEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means match a SCRATCH or a register.  When used to generate rtl, a\n    SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n    the desired mode and the first argument is the operand number.\n    The second argument is the constraint.  */\n-DEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", 'm')\n+DEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means match only something equal to what is stored in the operand table\n    at the index specified by the argument.  */\n-DEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", 'm')\n+DEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means apply a predicate, AND match recursively the operands of the rtx.\n    Operand 0 is the operand-number, as in match_operand.\n    Operand 1 is a predicate to apply (as a string, a function name).\n    Operand 2 is a vector of expressions, each of which must match\n    one subexpression of the rtx this construct is matching.  */\n-DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", 'm')\n+DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means to match a PARALLEL of arbitrary length.  The predicate is applied\n@@ -155,17 +170,17 @@ DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", 'm')\n    Operand 1 is a predicate to apply to the PARALLEL.\n    Operand 2 is a vector of expressions, each of which must match the \n    corresponding element in the PARALLEL.  */\n-DEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", 'm')\n+DEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means match only something equal to what is stored in the operand table\n    at the index specified by the argument.  For MATCH_OPERATOR.  */\n-DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", 'm')\n+DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Means match only something equal to what is stored in the operand table\n    at the index specified by the argument.  For MATCH_PARALLEL.  */\n-DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", 'm')\n+DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", RTX_MATCH)\n \n /* Appears only in machine descriptions.\n    Defines the pattern for one kind of instruction.\n@@ -184,15 +199,15 @@ DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", 'm')\n       template to use.\n    4: optionally, a vector of attributes for this insn.\n      */\n-DEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", 'x')\n+DEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", RTX_EXTRA)\n \n /* Definition of a peephole optimization.\n    1st operand: vector of insn patterns to match\n    2nd operand: C expression that must be true\n    3rd operand: template or C code to produce assembler output.\n    4: optionally, a vector of attributes for this insn.\n      */\n-DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", 'x')\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", RTX_EXTRA)\n \n /* Definition of a split operation.\n    1st operand: insn pattern to match\n@@ -203,7 +218,7 @@ DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", 'x')\n \telements of `recog_data.operand' for use by the vector of\n \tinsn-patterns.\n \t(`operands' is an alias here for `recog_data.operand').  */\n-DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n+DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", RTX_EXTRA)\n \n /* Definition of an insn and associated split.\n    This is the concatenation, with a few modifications, of a define_insn\n@@ -231,11 +246,11 @@ DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n \tinsn-patterns.\n \t(`operands' is an alias here for `recog_data.operand').  \n    7: optionally, a vector of attributes for this insn.  */\n-DEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", 'x')\n+DEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", RTX_EXTRA)\n \n /* Definition of an RTL peephole operation.\n    Follows the same arguments as define_split.  */\n-DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", 'x')\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", RTX_EXTRA)\n \n /* Define how to generate multiple insns for a standard insn name.\n    1st operand: the insn name.\n@@ -248,7 +263,7 @@ DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", 'x')\n \telements of `recog_data.operand' for use by the vector of\n \tinsn-patterns.\n \t(`operands' is an alias here for `recog_data.operand').  */\n-DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", 'x')\n+DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", RTX_EXTRA)\n    \n /* Define a requirement for delay slots.\n    1st operand: Condition involving insn attributes that, if true,\n@@ -264,7 +279,7 @@ DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", 'x')\n \n    Multiple DEFINE_DELAYs may be present.  They indicate differing\n    requirements for delay slots.  */\n-DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", 'x')\n+DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", RTX_EXTRA)\n \n /* Define a set of insns that requires a function unit.  This means that\n    these insns produce their result after a delay and that there may be\n@@ -305,10 +320,10 @@ DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", 'x')\n \t\tthe insn can be immediately scheduled (subject to the limit\n \t\ton the number of simultaneous operations executing on the\n \t\tunit.)  */\n-DEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", 'x')\n+DEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", RTX_EXTRA)\n \n /* Define attribute computation for `asm' instructions.  */\n-DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n+DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", RTX_EXTRA)\n \n /* Definition of a conditional execution meta operation.  Automatically\n    generates new instances of DEFINE_INSN, selected by having attribute\n@@ -321,16 +336,16 @@ DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n    1: A C expression giving an additional condition for recognizing\n       the generated pattern.\n    2: A template or C code to produce assembler output.  */\n-DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", 'x')\n+DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", RTX_EXTRA)\n \n /* SEQUENCE appears in the result of a `gen_...' function\n    for a DEFINE_EXPAND that wants to make several insns.\n    Its elements are the bodies of the insns that should be made.\n    `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\n-DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n+DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", RTX_EXTRA)\n \n /* Refers to the address of its argument.  This is only used in alias.c.  */\n-DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n+DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", RTX_MATCH)\n \n /* ----------------------------------------------------------------------\n    Constructions for CPU pipeline description described by NDFAs.\n@@ -346,12 +361,12 @@ DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n    All define_reservations, define_cpu_units, and\n    define_query_cpu_units should have unique names which may not be\n    \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", 'x')\n+DEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", RTX_EXTRA)\n \n /* (define_query_cpu_unit string [string]) describes cpu functional\n    units analogously to define_cpu_unit.  The reservation of such\n    units can be queried for automaton state.  */\n-DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n+DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", RTX_EXTRA)\n \n /* (exclusion_set string string) means that each CPU functional unit\n    in the first string can not be reserved simultaneously with any\n@@ -361,7 +376,7 @@ DEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n    unit which can execute simultaneously only single floating point\n    insns or only double floating point insns.  All CPU functional\n    units in a set should belong to the same automaton.  */\n-DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n+DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", RTX_EXTRA)\n \n /* (presence_set string string) means that each CPU functional unit in\n    the first string can not be reserved unless at least one of pattern\n@@ -383,7 +398,7 @@ DEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n \n    All CPU functional units in a set should belong to the same\n    automaton.  */\n-DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n+DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", RTX_EXTRA)\n \n /* (final_presence_set string string) is analogous to `presence_set'.\n    The difference between them is when checking is done.  When an\n@@ -404,7 +419,7 @@ DEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n       (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n \n    but it can be issued if we use analogous `final_presence_set'.  */\n-DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", 'x')\n+DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", RTX_EXTRA)\n \n /* (absence_set string string) means that each CPU functional unit in\n    the first string can be reserved only if each pattern of units\n@@ -427,12 +442,12 @@ DEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", 'x')\n \n    All CPU functional units in a set should to belong the same\n    automaton.  */\n-DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", 'x')\n+DEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", RTX_EXTRA)\n \n /* (final_absence_set string string) is analogous to `absence_set' but\n    checking is done on the result (state) reservation.  See comments\n    for `final_presence_set'.  */\n-DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", 'x')\n+DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", RTX_EXTRA)\n \n /* (define_bypass number out_insn_names in_insn_names) names bypass\n    with given latency (the first number) from insns given by the first\n@@ -443,7 +458,7 @@ DEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", 'x')\n    parameters.  If the function returns zero the bypass will be\n    ignored for this case.  Additional guard is necessary to recognize\n    complicated bypasses, e.g. when consumer is load address.  */\n-DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", 'x')\n+DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", RTX_EXTRA)\n \n /* (define_automaton string) describes names of automata generated and\n    used for pipeline hazards recognition.  The names are separated by\n@@ -452,7 +467,7 @@ DEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", 'x')\n    automata, the summary size of the automata usually is less than the\n    single one.  The automaton name is used in define_cpu_unit and\n    define_query_cpu_unit.  All automata should have unique names.  */\n-DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n+DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", RTX_EXTRA)\n \n /* (automata_option string) describes option for generation of\n    automata.  Currently there are the following options:\n@@ -475,7 +490,7 @@ DEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n \n    o \"progress\" which means output of a progress bar showing how many\n      states were generated so far for automaton being processed.  */\n-DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", 'x')\n+DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", RTX_EXTRA)\n \n /* (define_reservation string string) names reservation (the first\n    string) of cpu functional units (the 2nd string).  Sometimes unit\n@@ -484,7 +499,7 @@ DEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", 'x')\n    parameter) in regular expression in define_insn_reservation.  All\n    define_reservations, define_cpu_units, and define_query_cpu_units\n    should have unique names which may not be \"nothing\".  */\n-DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n+DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", RTX_EXTRA)\n \n /* (define_insn_reservation name default_latency condition regexpr)\n    describes reservation of cpu functional units (the 3nd operand) for\n@@ -532,7 +547,7 @@ DEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n \n        7. string \"nothing\" means no units reservation.  */\n \n-DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", 'x')\n+DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Expressions used for insn attributes.  These also do not appear in\n@@ -543,18 +558,18 @@ DEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", 'x')\n    1st operand: name of the attribute\n    2nd operand: comma-separated list of possible attribute values\n    3rd operand: expression for the default value of the attribute.  */\n-DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", 'x')\n+DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", RTX_EXTRA)\n \n /* Marker for the name of an attribute.  */\n-DEF_RTL_EXPR(ATTR, \"attr\", \"s\", 'x')\n+DEF_RTL_EXPR(ATTR, \"attr\", \"s\", RTX_EXTRA)\n \n /* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n    in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n    pattern.\n \n    (set_attr \"name\" \"value\") is equivalent to\n    (set (attr \"name\") (const_string \"value\"))  */\n-DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", 'x')\n+DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", RTX_EXTRA)\n \n /* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n    specify that attribute values are to be assigned according to the\n@@ -569,16 +584,16 @@ DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", 'x')\n \t\t\t\t (const_string \"a3\")])\n    (set_attr \"att\" \"a1,a2,a3\")\n  */\n-DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", 'x')\n+DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", RTX_EXTRA)\n \n /* A conditional expression true if the value of the specified attribute of\n    the current insn equals the specified value.  The first operand is the\n    attribute name and the second is the comparison value.  */\n-DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", 'x')\n+DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", RTX_EXTRA)\n \n /* A special case of the above representing a set of alternatives.  The first\n    operand is bitmap of the set, the second one is the default value.  */\n-DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", 'x')\n+DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", RTX_EXTRA)\n \n /* A conditional expression which is true if the specified flag is\n    true for the insn being scheduled in reorg.\n@@ -588,7 +603,7 @@ DEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", 'x')\n \n    forward, backward, very_likely, likely, very_unlikely, and unlikely.  */\n \n-DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n+DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Expression types used for things in the instruction chain.\n@@ -601,36 +616,36 @@ DEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n    ---------------------------------------------------------------------- */\n \n /* An instruction that cannot jump.  */\n-DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", 'i')\n+DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", RTX_INSN)\n \n /* An instruction that can possibly jump.\n    Fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", 'i')\n+DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", RTX_INSN)\n \n /* An instruction that can possibly call a subroutine\n    but which will not change which instruction comes next\n    in the current function.\n    Field ( rtx->u.fld[9] ) is CALL_INSN_FUNCTION_USAGE.\n    All other fields ( rtx->u.fld[] ) have exact same meaning as INSN's.  */\n-DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", 'i')\n+DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", RTX_INSN)\n \n /* A marker that indicates that control will not flow through.  */\n-DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", 'x')\n+DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", RTX_EXTRA)\n \n /* Holds a label that is followed by instructions.\n    Operand:\n    4: is used in jump.c for the use-count of the label.\n    5: is used in flow.c to point to the chain of label_ref's to this label.\n    6: is a number that is unique in the entire compilation.\n    7: is the user-given name of the label, if any.  */\n-DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", 'x')\n+DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", RTX_EXTRA)\n \n /* Say where in the code a source line starts, for symbol table's sake.\n    Operand:\n    4: filename, if line number > 0, note-specific data otherwise.\n    5: line number if > 0, enum note_insn otherwise.\n    6: unique number if line number == note_insn_deleted_label.  */\n-DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", 'x')\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n@@ -643,18 +658,18 @@ DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", 'x')\n    Semantics are that there are no side effects if the condition\n    is false.  This pattern is created automatically by the if_convert\n    pass run after reload or by target-specific splitters.  */\n-DEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", 'x')\n+DEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", RTX_EXTRA)\n \n /* Several operations to be done in parallel (perhaps under COND_EXEC).  */\n-DEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", 'x')\n+DEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", RTX_EXTRA)\n \n /* A string that is passed through to the assembler as input.\n      One can obviously pass comments through by using the\n      assembler comment syntax.\n      These occur in an insn all by themselves as the PATTERN.\n      They also appear inside an ASM_OPERANDS\n      as a convenient way to hold a string.  */\n-DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", 'x')\n+DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", RTX_EXTRA)\n \n /* An assembler instruction with operands.\n    1st operand is the instruction template.\n@@ -668,7 +683,7 @@ DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", 'x')\n      and whose mode indicates the mode of the input operand.\n    6th is the name of the containing source file.\n    7th is the source line number.  */\n-DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n+DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", RTX_EXTRA)\n \n /* A machine-specific operation.\n    1st operand is a vector of operands being used by the operation so that\n@@ -679,14 +694,14 @@ DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n    genrecog.c record positions within an insn.)\n    This can occur all by itself in a PATTERN, as a component of a PARALLEL,\n    or inside an expression.  */\n-DEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", 'x')\n+DEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", RTX_EXTRA)\n \n /* Similar, but a volatile operation and one which may trap.  */\n-DEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", 'x')\n+DEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", RTX_EXTRA)\n \n /* Vector of addresses, stored as full words.  */\n /* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\n-DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n+DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", RTX_EXTRA)\n \n /* Vector of address differences X0 - BASE, X1 - BASE, ...\n    First operand is BASE; the vector contains the X's.\n@@ -711,7 +726,7 @@ DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n    CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n    compilations.  */\n      \n-DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", 'x')\n+DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", RTX_EXTRA)\n \n /* Memory prefetch, with attributes supported on some targets.\n    Operand 1 is the address of the memory to fetch.\n@@ -722,7 +737,7 @@ DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", 'x')\n \n    The attributes specified by operands 2 and 3 are ignored for targets\n    whose prefetch instructions do not support them.  */\n-DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", 'x')\n+DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    At the top level of an instruction (perhaps under PARALLEL).\n@@ -734,69 +749,69 @@ DEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", 'x')\n    ALL assignment must use SET.\n    Instructions that do multiple assignments must use multiple SET,\n    under PARALLEL.  */\n-DEF_RTL_EXPR(SET, \"set\", \"ee\", 'x')\n+DEF_RTL_EXPR(SET, \"set\", \"ee\", RTX_EXTRA)\n \n /* Indicate something is used in a way that we don't want to explain.\n    For example, subroutine calls will use the register\n    in which the static chain is passed.  */\n-DEF_RTL_EXPR(USE, \"use\", \"e\", 'x')\n+DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n \n /* Indicate something is clobbered in a way that we don't want to explain.\n    For example, subroutine calls will clobber some physical registers\n    (the ones that are by convention not saved).  */\n-DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", 'x')\n+DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", RTX_EXTRA)\n \n /* Call a subroutine.\n    Operand 1 is the address to call.\n    Operand 2 is the number of arguments.  */\n \n-DEF_RTL_EXPR(CALL, \"call\", \"ee\", 'x')\n+DEF_RTL_EXPR(CALL, \"call\", \"ee\", RTX_EXTRA)\n \n /* Return from a subroutine.  */\n \n-DEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n+DEF_RTL_EXPR(RETURN, \"return\", \"\", RTX_EXTRA)\n \n /* Conditional trap.\n    Operand 1 is the condition.\n    Operand 2 is the trap code.\n    For an unconditional trap, make the condition (const_int 1).  */\n-DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n+DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", RTX_EXTRA)\n \n /* Placeholder for _Unwind_Resume before we know if a function call\n    or a branch is needed.  Operand 1 is the exception region from\n    which control is flowing.  */\n-DEF_RTL_EXPR(RESX, \"resx\", \"i\", 'x')\n+DEF_RTL_EXPR(RESX, \"resx\", \"i\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Primitive values for use in expressions.\n    ---------------------------------------------------------------------- */\n \n /* numeric integer constant */\n-DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n+DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", RTX_CONST_OBJ)\n \n /* numeric floating point constant.\n    Operands hold the value.  They are all 'w' and there may be from 2 to 6;\n    see real.h.  */\n-DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, 'o')\n+DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, RTX_CONST_OBJ)\n \n /* Describes a vector constant.  */\n-DEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", 'x')\n+DEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", RTX_EXTRA)\n \n /* String constant.  Used only for attributes right now.  */\n-DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')\n+DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", RTX_OBJ)\n \n /* This is used to encapsulate an expression whose value is constant\n    (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n    recognized as a constant operand rather than by arithmetic instructions.  */\n \n-DEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n+DEF_RTL_EXPR(CONST, \"const\", \"e\", RTX_CONST_OBJ)\n \n /* program counter.  Ordinary jumps are represented\n    by a SET whose first operand is (PC).  */\n-DEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n+DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n \n /* Used in the cselib routines to describe a value.  */\n-DEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n+DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n \n /* A register.  The \"operand\" is the register number, accessed with\n    the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n@@ -805,14 +820,14 @@ DEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n    pseudo register that got turned into a hard register.\n    This rtx needs to have as many (or more) fields as a MEM, since we\n    can change REG rtx's into MEMs during reload.  */\n-DEF_RTL_EXPR(REG, \"reg\", \"i00\", 'o')\n+DEF_RTL_EXPR(REG, \"reg\", \"i00\", RTX_OBJ)\n \n /* A scratch register.  This represents a register used only within a\n    single insn.  It will be turned into a REG during register allocation\n    or reload unless the constraint indicates that the register won't be\n    needed, in which case it can remain a SCRATCH.  This code is\n    marked as having one operand so it can be turned into a REG.  */\n-DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", 'o')\n+DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", RTX_OBJ)\n \n /* One word of a multi-word value.\n    The first operand is the complete value; the second says which word.\n@@ -822,7 +837,7 @@ DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", 'o')\n    This is also used to refer to a value in a different machine mode.\n    For example, it can be used to refer to a SImode value as if it were\n    Qimode, or vice versa.  Then the word number is always 0.  */\n-DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", 'x')\n+DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", RTX_EXTRA)\n \n /* This one-argument rtx is used for move instructions\n    that are guaranteed to alter only the low part of a destination.\n@@ -835,38 +850,38 @@ DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", 'x')\n    but the register constraints may be tighter when STRICT_LOW_PART\n    is in use.  */\n \n-DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", 'x')\n+DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", RTX_EXTRA)\n \n /* (CONCAT a b) represents the virtual concatenation of a and b\n    to make a value that has as many bits as a and b put together.\n    This is used for complex values.  Normally it appears only\n    in DECL_RTLs and during RTL generation, but not in the insn chain.  */\n-DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", 'o')\n+DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", RTX_OBJ)\n \n /* A memory location; operand is the address.  The second operand is the\n    alias set to which this MEM belongs.  We use `0' instead of `w' for this\n    field so that the field need not be specified in machine descriptions.  */\n-DEF_RTL_EXPR(MEM, \"mem\", \"e0\", 'o')\n+DEF_RTL_EXPR(MEM, \"mem\", \"e0\", RTX_OBJ)\n \n /* Reference to an assembler label in the code for this function.\n    The operand is a CODE_LABEL found in the insn chain.\n    The unprinted fields 1 and 2 are used in flow.c for the\n    LABEL_NEXTREF and CONTAINING_INSN.  */\n-DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", 'o')\n+DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", RTX_CONST_OBJ)\n \n /* Reference to a named label: \n    Operand 0: label name\n    Operand 1: flags (see SYMBOL_FLAG_* in rtl.h)\n    Operand 2: tree from which this symbol is derived, or null.\n    This is either a DECL node, or some kind of constant.  */\n-DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", 'o')\n+DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", RTX_CONST_OBJ)\n \n /* The condition code register is represented, in our imagination,\n    as a register holding a value that can be compared to zero.\n    In fact, the machine has already compared them and recorded the\n    results; but instructions that look at the condition code\n    pretend to be looking at the entire value and comparing it.  */\n-DEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n+DEF_RTL_EXPR(CC0, \"cc0\", \"\", RTX_OBJ)\n \n /* Reference to the address of a register.  Removed by purge_addressof after\n    CSE has elided as many as possible.\n@@ -875,7 +890,7 @@ DEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n    3rd operand: the decl for the object in the register, for\n      put_reg_in_stack.  */\n \n-DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", 'o')\n+DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", RTX_OBJ)\n \n /* =====================================================================\n    A QUEUED expression really points to a member of the queue of instructions\n@@ -893,7 +908,7 @@ DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", 'o')\n    4. the next QUEUED expression in the queue.\n    ====================================================================== */\n \n-DEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", 'x')\n+DEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Expressions for operators in an rtl pattern\n@@ -905,7 +920,7 @@ DEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", 'x')\n      0:  condition\n      1:  then expr\n      2:  else expr */\n-DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", '3')\n+DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", RTX_TERNARY)\n \n /* General conditional. The first operand is a vector composed of pairs of\n    expressions.  The first element of each pair is evaluated, in turn.\n@@ -914,57 +929,57 @@ DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", '3')\n    true, the second operand will be used as the value of the conditional.\n \n    This should be replaced with use of IF_THEN_ELSE.  */\n-DEF_RTL_EXPR(COND, \"cond\", \"Ee\", 'x')\n+DEF_RTL_EXPR(COND, \"cond\", \"Ee\", RTX_EXTRA)\n \n /* Comparison, produces a condition code result.  */\n-DEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", '2')\n+DEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", RTX_BIN_ARITH)\n \n /* plus */\n-DEF_RTL_EXPR(PLUS, \"plus\", \"ee\", 'c')\n+DEF_RTL_EXPR(PLUS, \"plus\", \"ee\", RTX_COMM_ARITH)\n \n /* Operand 0 minus operand 1.  */\n-DEF_RTL_EXPR(MINUS, \"minus\", \"ee\", '2')\n+DEF_RTL_EXPR(MINUS, \"minus\", \"ee\", RTX_BIN_ARITH)\n \n /* Minus operand 0.  */\n-DEF_RTL_EXPR(NEG, \"neg\", \"e\", '1')\n+DEF_RTL_EXPR(NEG, \"neg\", \"e\", RTX_UNARY)\n \n-DEF_RTL_EXPR(MULT, \"mult\", \"ee\", 'c')\n+DEF_RTL_EXPR(MULT, \"mult\", \"ee\", RTX_COMM_ARITH)\n \n /* Operand 0 divided by operand 1.  */\n-DEF_RTL_EXPR(DIV, \"div\", \"ee\", '2')\n+DEF_RTL_EXPR(DIV, \"div\", \"ee\", RTX_BIN_ARITH)\n /* Remainder of operand 0 divided by operand 1.  */\n-DEF_RTL_EXPR(MOD, \"mod\", \"ee\", '2')\n+DEF_RTL_EXPR(MOD, \"mod\", \"ee\", RTX_BIN_ARITH)\n \n /* Unsigned divide and remainder.  */\n-DEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", '2')\n-DEF_RTL_EXPR(UMOD, \"umod\", \"ee\", '2')\n+DEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", RTX_BIN_ARITH)\n+DEF_RTL_EXPR(UMOD, \"umod\", \"ee\", RTX_BIN_ARITH)\n \n /* Bitwise operations.  */\n-DEF_RTL_EXPR(AND, \"and\", \"ee\", 'c')\n+DEF_RTL_EXPR(AND, \"and\", \"ee\", RTX_COMM_ARITH)\n \n-DEF_RTL_EXPR(IOR, \"ior\", \"ee\", 'c')\n+DEF_RTL_EXPR(IOR, \"ior\", \"ee\", RTX_COMM_ARITH)\n \n-DEF_RTL_EXPR(XOR, \"xor\", \"ee\", 'c')\n+DEF_RTL_EXPR(XOR, \"xor\", \"ee\", RTX_COMM_ARITH)\n \n-DEF_RTL_EXPR(NOT, \"not\", \"e\", '1')\n+DEF_RTL_EXPR(NOT, \"not\", \"e\", RTX_UNARY)\n \n /* Operand:\n      0:  value to be shifted.\n      1:  number of bits.  */\n-DEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", '2') /* shift left */\n-DEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", '2') /* rotate left */\n-DEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", '2') /* arithmetic shift right */\n-DEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", '2') /* logical shift right */\n-DEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", '2') /* rotate right */\n+DEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", RTX_BIN_ARITH) /* shift left */\n+DEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", RTX_BIN_ARITH) /* rotate left */\n+DEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", RTX_BIN_ARITH) /* arithmetic shift right */\n+DEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", RTX_BIN_ARITH) /* logical shift right */\n+DEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", RTX_BIN_ARITH) /* rotate right */\n \n /* Minimum and maximum values of two operands.  We need both signed and\n    unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n    with a macro of the same name.) */\n \n-DEF_RTL_EXPR(SMIN, \"smin\", \"ee\", 'c')\n-DEF_RTL_EXPR(SMAX, \"smax\", \"ee\", 'c')\n-DEF_RTL_EXPR(UMIN, \"umin\", \"ee\", 'c')\n-DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n+DEF_RTL_EXPR(SMIN, \"smin\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(SMAX, \"smax\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(UMIN, \"umin\", \"ee\", RTX_COMM_ARITH)\n+DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", RTX_COMM_ARITH)\n \n /* These unary operations are used to represent incrementation\n    and decrementation as they occur in memory addresses.\n@@ -973,10 +988,10 @@ DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n    containing MEM.  These operations exist in only two cases:\n    1. pushes onto the stack.\n    2. created automatically by the life_analysis pass in flow.c.  */\n-DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'a')\n-DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'a')\n-DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'a')\n-DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'a')\n+DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", RTX_AUTOINC)\n \n /* These binary operations are used to represent generic address\n    side-effects in memory addresses, except for simple incrementation\n@@ -990,92 +1005,92 @@ DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'a')\n    form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n    the first operand of the PLUS has to be the same register as\n    the first operand of the *_MODIFY.  */\n-DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", 'a')\n-DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", 'a')\n+DEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", RTX_AUTOINC)\n+DEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", RTX_AUTOINC)\n \n /* Comparison operations.  The ordered comparisons exist in two\n    flavors, signed and unsigned.  */\n-DEF_RTL_EXPR(NE, \"ne\", \"ee\", '<')\n-DEF_RTL_EXPR(EQ, \"eq\", \"ee\", '<')\n-DEF_RTL_EXPR(GE, \"ge\", \"ee\", '<')\n-DEF_RTL_EXPR(GT, \"gt\", \"ee\", '<')\n-DEF_RTL_EXPR(LE, \"le\", \"ee\", '<')\n-DEF_RTL_EXPR(LT, \"lt\", \"ee\", '<')\n-DEF_RTL_EXPR(GEU, \"geu\", \"ee\", '<')\n-DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\n-DEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\n-DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n+DEF_RTL_EXPR(NE, \"ne\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(EQ, \"eq\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(GE, \"ge\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GT, \"gt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LE, \"le\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LT, \"lt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GEU, \"geu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LEU, \"leu\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", RTX_COMPARE)\n \n /* Additional floating point unordered comparison flavors.  */\n-DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\n-DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n+DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", RTX_COMM_COMPARE)\n \n /* These are equivalent to unordered or ...  */\n-DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", '<')\n-DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", '<')\n-DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", '<')\n-DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", '<')\n-DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", '<')\n+DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", RTX_COMM_COMPARE)\n+DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", RTX_COMPARE)\n+DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", RTX_COMPARE)\n \n /* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\n-DEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", '<')\n+DEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", RTX_COMM_COMPARE)\n \n /* Represents the result of sign-extending the sole operand.\n    The machine modes of the operand and of the SIGN_EXTEND expression\n    determine how much sign-extension is going on.  */\n-DEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", '1')\n+DEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", RTX_UNARY)\n \n /* Similar for zero-extension (such as unsigned short to int).  */\n-DEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", '1')\n+DEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", RTX_UNARY)\n \n /* Similar but here the operand has a wider mode.  */\n-DEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", '1')\n+DEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", RTX_UNARY)\n \n /* Similar for extending floating-point values (such as SFmode to DFmode).  */\n-DEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", '1')\n-DEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", '1')\n+DEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", RTX_UNARY)\n+DEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", RTX_UNARY)\n \n /* Conversion of fixed point operand to floating point value.  */\n-DEF_RTL_EXPR(FLOAT, \"float\", \"e\", '1')\n+DEF_RTL_EXPR(FLOAT, \"float\", \"e\", RTX_UNARY)\n \n /* With fixed-point machine mode:\n    Conversion of floating point operand to fixed point value.\n    Value is defined only when the operand's value is an integer.\n    With floating-point machine mode (and operand with same mode):\n    Operand is rounded toward zero to produce an integer value\n    represented in floating point.  */\n-DEF_RTL_EXPR(FIX, \"fix\", \"e\", '1')\n+DEF_RTL_EXPR(FIX, \"fix\", \"e\", RTX_UNARY)\n \n /* Conversion of unsigned fixed point operand to floating point value.  */\n-DEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", '1')\n+DEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", RTX_UNARY)\n \n /* With fixed-point machine mode:\n    Conversion of floating point operand to *unsigned* fixed point value.\n    Value is defined only when the operand's value is an integer.  */\n-DEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", '1')\n+DEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", RTX_UNARY)\n \n /* Absolute value */\n-DEF_RTL_EXPR(ABS, \"abs\", \"e\", '1')\n+DEF_RTL_EXPR(ABS, \"abs\", \"e\", RTX_UNARY)\n \n /* Square root */\n-DEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", '1')\n+DEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", RTX_UNARY)\n \n /* Find first bit that is set.\n    Value is 1 + number of trailing zeros in the arg.,\n    or 0 if arg is 0.  */\n-DEF_RTL_EXPR(FFS, \"ffs\", \"e\", '1')\n+DEF_RTL_EXPR(FFS, \"ffs\", \"e\", RTX_UNARY)\n \n /* Count leading zeros.  */\n-DEF_RTL_EXPR(CLZ, \"clz\", \"e\", '1')\n+DEF_RTL_EXPR(CLZ, \"clz\", \"e\", RTX_UNARY)\n \n /* Count trailing zeros.  */\n-DEF_RTL_EXPR(CTZ, \"ctz\", \"e\", '1')\n+DEF_RTL_EXPR(CTZ, \"ctz\", \"e\", RTX_UNARY)\n \n /* Population count (number of 1 bits).  */\n-DEF_RTL_EXPR(POPCOUNT, \"popcount\", \"e\", '1')\n+DEF_RTL_EXPR(POPCOUNT, \"popcount\", \"e\", RTX_UNARY)\n \n /* Population parity (number of 1 bits modulo 2).  */\n-DEF_RTL_EXPR(PARITY, \"parity\", \"e\", '1')\n+DEF_RTL_EXPR(PARITY, \"parity\", \"e\", RTX_UNARY)\n \n /* Reference to a signed bit-field of specified size and position.\n    Operand 0 is the memory unit (usually SImode or QImode) which\n@@ -1086,19 +1101,19 @@ DEF_RTL_EXPR(PARITY, \"parity\", \"e\", '1')\n    operand 2 counts from the msb of the memory unit.\n    Otherwise, the first bit is the lsb and operand 2 counts from\n    the lsb of the memory unit.  */\n-DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", 'b')\n+DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n /* Similar for unsigned bit-field.  */\n-DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", 'b')\n+DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", RTX_BITFIELD_OPS)\n \n /* For RISC machines.  These save memory when splitting insns.  */\n \n /* HIGH are the high-order bits of a constant expression.  */\n-DEF_RTL_EXPR(HIGH, \"high\", \"e\", 'o')\n+DEF_RTL_EXPR(HIGH, \"high\", \"e\", RTX_CONST_OBJ)\n \n /* LO_SUM is the sum of a register and the low-order bits\n    of a constant expression.  */\n-DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n+DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", RTX_OBJ)\n \n /* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_BEG insn.\n    Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n@@ -1111,7 +1126,7 @@ DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n    is a bitmap of the registers live at the end of the range.  Operand 11 is\n    marker number for the start of the range.  Operand 12 is the marker number\n    for the end of the range.  */\n-DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", 'x')\n+DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", RTX_EXTRA)\n \n /* Registers that can be substituted within the range.  Operand 0 is the\n    original pseudo register number.  Operand 1 will be filled in with the\n@@ -1126,22 +1141,22 @@ DEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", 'x')\n    across.  Operand 8 is the symbol node of the variable if the register is a\n    user variable.  Operand 9 is the block node that the variable is declared\n    in if the register is a user variable.  */\n-DEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", 'x')\n+DEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", RTX_EXTRA)\n \n /* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n    the different ranges a variable is in where it is copied to a different\n    pseudo register.  Operand 1 is the block that the variable is declared in.\n    Operand 2 is the number of distinct ranges.  */\n-DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", 'x')\n+DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", RTX_EXTRA)\n \n /* Information about the registers that are live at the current point.  Operand\n    0 is the live bitmap.  Operand 1 is the original block number.  */\n-DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", 'x')\n+DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", RTX_EXTRA)\n \n /* A unary `__builtin_constant_p' expression.  These are only emitted\n    during RTL generation, and then only if optimize > 0.  They are\n    eliminated by the first CSE pass.  */\n-DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n+DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", RTX_EXTRA)\n \n /* A placeholder for a CALL_INSN which may be turned into a normal call,\n    a sibling (tail) call or tail recursion.\n@@ -1162,49 +1177,49 @@ DEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n \n    This method of tail-call elimination is intended to be replaced by\n    tree-based optimizations once front-end conversions are complete.  */\n-DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n+DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", RTX_EXTRA)\n \n /* Describes a merge operation between two vector values.\n    Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n    that specifies where the parts of the result are taken from.  Set bits\n    indicate operand 0, clear bits indicate operand 1.  The parts are defined\n    by the mode of the vectors.  */\n-DEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", '3')\n+DEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", RTX_TERNARY)\n \n /* Describes an operation that selects parts of a vector.\n    Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n    a CONST_INT for each of the subparts of the result vector, giving the\n    number of the source subpart that should be stored into it.  */\n-DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", '2')\n+DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", RTX_BIN_ARITH)\n \n /* Describes a vector concat operation.  Operands 0 and 1 are the source\n    vectors, the result is a vector that is as long as operands 0 and 1\n    combined and is the concatenation of the two source vectors.  */\n-DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", '2')\n+DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", RTX_BIN_ARITH)\n \n /* Describes an operation that converts a small vector into a larger one by\n    duplicating the input values.  The output vector mode must have the same\n    submodes as the input vector mode, and the number of output parts must be\n    an integer multiple of the number of input parts.  */\n-DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", '1')\n+DEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", RTX_UNARY)\n      \n /* Addition with signed saturation */\n-DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", 'c')\n+DEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", RTX_COMM_ARITH)\n \n /* Addition with unsigned saturation */\n-DEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", 'c')\n+DEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", RTX_COMM_ARITH)\n \n /* Operand 0 minus operand 1, with signed saturation.  */\n-DEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", '2')\n+DEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", RTX_BIN_ARITH)\n \n /* Operand 0 minus operand 1, with unsigned saturation.  */\n-DEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", '2')\n+DEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", RTX_BIN_ARITH)\n \n /* Signed saturating truncate.  */\n-DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n+DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", RTX_UNARY)\n \n /* Unsigned saturating truncate.  */\n-DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n+DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n \n /* Information about the variable and its location.  */\n DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"te\", 'x')"}, {"sha": "3cec0c466fb1b161160d17f6050b5ddf6a911d5b", "filename": "gcc/rtl.h", "status": "modified", "additions": 100, "deletions": 7, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -52,6 +52,48 @@ enum rtx_code  {\n #define NUM_RTX_CODE ((int) LAST_AND_UNUSED_RTX_CODE)\n \t\t\t\t/* The cast here, saves many elsewhere.  */\n \n+/* Register Transfer Language EXPRESSIONS CODE CLASSES */\n+\n+enum rtx_class  {\n+  /* We check bit 0-1 of some rtx class codes in the predicates below.  */\n+\n+  /* Bit 0 = comparison if 0, arithmetic is 1\n+     Bit 1 = 1 if commutative.  */\n+  RTX_COMPARE,\t\t/* 0 */\n+  RTX_COMM_COMPARE,\n+  RTX_BIN_ARITH,\n+  RTX_COMM_ARITH,\n+\n+  /* Must follow the four preceding values.  */\n+  RTX_UNARY,\t\t/* 4 */\n+\n+  RTX_EXTRA,\n+  RTX_MATCH,\n+  RTX_INSN,\n+\n+  /* Bit 0 = 1 if constant.  */\n+  RTX_OBJ,\t\t/* 8 */\n+  RTX_CONST_OBJ,\n+\n+  RTX_TERNARY,\n+  RTX_BITFIELD_OPS,\n+  RTX_AUTOINC\n+};\n+\n+#define RTX_OBJ_MASK (~1)\n+#define RTX_OBJ_RESULT (RTX_OBJ & RTX_OBJ_MASK)\n+#define RTX_COMPARE_MASK (~1)\n+#define RTX_COMPARE_RESULT (RTX_COMPARE & RTX_COMPARE_MASK)\n+#define RTX_ARITHMETIC_MASK (~1)\n+#define RTX_ARITHMETIC_RESULT (RTX_COMM_ARITH & RTX_ARITHMETIC_MASK)\n+#define RTX_BINARY_MASK (~3)\n+#define RTX_BINARY_RESULT (RTX_COMPARE & RTX_BINARY_MASK)\n+#define RTX_COMMUTATIVE_MASK (~2)\n+#define RTX_COMMUTATIVE_RESULT (RTX_COMM_COMPARE & RTX_COMMUTATIVE_MASK)\n+#define RTX_NON_COMMUTATIVE_RESULT (RTX_COMPARE & RTX_COMMUTATIVE_MASK)\n+#define RTX_EXPR_FIRST (RTX_COMPARE)\n+#define RTX_EXPR_LAST (RTX_UNARY)\n+\n extern const unsigned char rtx_length[NUM_RTX_CODE];\n #define GET_RTX_LENGTH(CODE)\t\t(rtx_length[(int) (CODE)])\n \n@@ -61,7 +103,7 @@ extern const char * const rtx_name[NUM_RTX_CODE];\n extern const char * const rtx_format[NUM_RTX_CODE];\n #define GET_RTX_FORMAT(CODE)\t\t(rtx_format[(int) (CODE)])\n \n-extern const char rtx_class[NUM_RTX_CODE];\n+extern const enum rtx_class rtx_class[NUM_RTX_CODE];\n #define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int) (CODE)])\n \n extern const unsigned char rtx_size[NUM_RTX_CODE];\n@@ -288,15 +330,69 @@ struct rtvec_def GTY(()) {\n   (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n \t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n \n+\n+/* 1 if X is an insn.  */\n+#define INSN_P(X)    \\\n+  (GET_RTX_CLASS (GET_CODE(X)) == RTX_INSN)\n+\n+/* 1 if X is a unary operator.  */\n+\n+#define UNARY_P(X)   \\\n+  (GET_RTX_CLASS (GET_CODE (X)) == RTX_UNARY)\n+\n+/* 1 if X is a binary operator.  */\n+\n+#define BINARY_P(X)   \\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_BINARY_MASK) == RTX_BINARY_RESULT)\n+\n+/* 1 if X is an arithmetic operator.  */\n+\n+#define ARITHMETIC_P(X)   \\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_ARITHMETIC_MASK)\t\t\t\\\n+    == RTX_ARITHMETIC_RESULT)\n+\n+/* 1 if X is an arithmetic operator.  */\n+\n+#define COMMUTATIVE_ARITH_P(X)   \\\n+  (GET_RTX_CLASS (GET_CODE (X)) == RTX_COMM_ARITH)\n+\n+/* 1 if X is a commutative arithmetic operator or a comparison operator.\n+   These two are sometimes selected together because it is possible to\n+   swap the two operands.  */\n+\n+#define SWAPPABLE_OPERANDS_P(X)   \\\n+  ((1 << GET_RTX_CLASS (GET_CODE (X)))\t\t\t\t\t\\\n+    & ((1 << RTX_COMM_ARITH) | (1 << RTX_COMM_COMPARE)\t\t\t\\\n+       | (1 << RTX_COMPARE)))\n+\n+/* 1 if X is a non-commutative operator.  */\n+\n+#define NON_COMMUTATIVE_P(X)   \\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_COMMUTATIVE_MASK)\t\t\\\n+    == RTX_NON_COMMUTATIVE_RESULT)\n+\n+/* 1 if X is a commutative operator on integers.  */\n+\n+#define COMMUTATIVE_P(X)   \\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_COMMUTATIVE_MASK)\t\t\\\n+    == RTX_COMMUTATIVE_RESULT)\n+\n+/* 1 if X is a relational operator.  */\n+\n+#define COMPARISON_P(X)   \\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_COMPARE_MASK) == RTX_COMPARE_RESULT)\n+\n /* 1 if X is a constant value that is an integer.  */\n \n #define CONSTANT_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n-   || GET_CODE (X) == CONST || GET_CODE (X) == HIGH\t\t\t\\\n+  (GET_RTX_CLASS (GET_CODE (X)) == RTX_CONST_OBJ\t\t\t\\\n    || GET_CODE (X) == CONST_VECTOR\t                                \\\n    || GET_CODE (X) == CONSTANT_P_RTX)\n \n+/* 1 if X can be used to represent an object.  */\n+#define OBJECT_P(X)\t\t\t\t\t\t\t\\\n+  ((GET_RTX_CLASS (GET_CODE (X)) & RTX_OBJ_MASK) == RTX_OBJ_RESULT)\n+\n /* General accessor macros for accessing the fields of an rtx.  */\n \n #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n@@ -555,9 +651,6 @@ do {\t\t\t\t\\\n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n-/* Determines whether X is an insn.  */\n-#define INSN_P(X)       (GET_RTX_CLASS (GET_CODE(X)) == 'i')\n-\n /* Holds a unique number for each insn.\n    These are not necessarily sequentially increasing.  */\n #define INSN_UID(INSN)  XINT (INSN, 0)"}, {"sha": "d37bba1d8072c35472f5a8f98debfb54b87272ee", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -3031,49 +3031,59 @@ int\n commutative_operand_precedence (rtx op)\n {\n   enum rtx_code code = GET_CODE (op);\n-  char class;\n   \n   /* Constants always come the second operand.  Prefer \"nice\" constants.  */\n   if (code == CONST_INT)\n     return -7;\n   if (code == CONST_DOUBLE)\n     return -6;\n   op = avoid_constant_pool_reference (op);\n-  if (code == CONST_INT)\n-    return -5;\n-  if (code == CONST_DOUBLE)\n-    return -4;\n-  if (CONSTANT_P (op))\n-    return -3;\n-\n-  /* SUBREGs of objects should come second.  */\n-  if (code == SUBREG\n-      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op))) == 'o')\n-    return -2;\n-\n-  class = GET_RTX_CLASS (code);\n-\n-  /* Prefer operands that are themselves commutative to be first.\n-     This helps to make things linear.  In particular,\n-     (and (and (reg) (reg)) (not (reg))) is canonical.  */\n-  if (class == 'c')\n-    return 4;\n-\n-  /* If only one operand is a binary expression, it will be the first\n-     operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))\n-     is canonical, although it will usually be further simplified.  */\n-  if (class == '2')\n-    return 2;\n+\n+  switch (GET_RTX_CLASS (code))\n+    {\n+    case RTX_CONST_OBJ:\n+      if (code == CONST_INT)\n+        return -5;\n+      if (code == CONST_DOUBLE)\n+        return -4;\n+      return -3;\n+\n+    case RTX_EXTRA:\n+      /* SUBREGs of objects should come second.  */\n+      if (code == SUBREG && OBJECT_P (SUBREG_REG (op)))\n+        return -2;\n+\n+      if (!CONSTANT_P (op))\n+        return 0;\n+      else\n+\t/* As for RTX_CONST_OBJ.  */\n+\treturn -3;\n+\n+    case RTX_OBJ:\n+      /* Complex expressions should be the first, so decrease priority\n+         of objects.  */\n+      return -1;\n+\n+    case RTX_COMM_ARITH:\n+      /* Prefer operands that are themselves commutative to be first.\n+         This helps to make things linear.  In particular,\n+         (and (and (reg) (reg)) (not (reg))) is canonical.  */\n+      return 4;\n+\n+    case RTX_BIN_ARITH:\n+      /* If only one operand is a binary expression, it will be the first\n+         operand.  In particular,  (plus (minus (reg) (reg)) (neg (reg)))\n+         is canonical, although it will usually be further simplified.  */\n+      return 2;\n   \n-  /* Then prefer NEG and NOT.  */\n-  if (code == NEG || code == NOT)\n-    return 1;\n+    case RTX_UNARY:\n+      /* Then prefer NEG and NOT.  */\n+      if (code == NEG || code == NOT)\n+        return 1;\n \n-  /* Complex expressions should be the first, so decrease priority\n-     of objects.  */\n-  if (GET_RTX_CLASS (code) == 'o')\n-    return -1;\n-  return 0;\n+    default:\n+      return 0;\n+    }\n }\n \n /* Return 1 iff it is necessary to swap operands of commutative operation"}, {"sha": "ccd9a32f91533dbd772a2331dea8ecad36974f89", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -171,8 +171,8 @@ get_condition (rtx insn)\n static int\n conditions_mutex_p (rtx cond1, rtx cond2)\n {\n-  if (GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n-      && GET_RTX_CLASS (GET_CODE (cond2)) == '<'\n+  if (COMPARISON_P (cond1)\n+      && COMPARISON_P (cond2)\n       && GET_CODE (cond1) == reverse_condition (GET_CODE (cond2))\n       && XEXP (cond1, 0) == XEXP (cond2, 0)\n       && XEXP (cond1, 1) == XEXP (cond2, 1))"}, {"sha": "673416fca071a52511faae8f960e66835edc4188", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -346,7 +346,7 @@ is_cfg_nonregular (void)\n     for (insn = BB_HEAD (b); ; insn = NEXT_INSN (insn))\n       {\n \tcode = GET_CODE (insn);\n-\tif (GET_RTX_CLASS (code) == 'i' && code != JUMP_INSN)\n+\tif (INSN_P (insn) && code != JUMP_INSN)\n \t  {\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n "}, {"sha": "bae37f870a2eafd3637348dcb36f54de79c460e9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -77,7 +77,7 @@ simplify_gen_binary (enum rtx_code code, enum machine_mode mode, rtx op0,\n   rtx tem;\n \n   /* Put complex operands first and constants second if commutative.  */\n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n       && swap_commutative_operands_p (op0, op1))\n     tem = op0, op0 = op1, op1 = tem;\n \n@@ -236,7 +236,7 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n \t\t\t\t    XEXP (op0, 0), XEXP (op0, 1));\n \n   /* If op0 is a comparison, extract the comparison arguments form it.  */\n-  if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && op1 == const0_rtx)\n+  if (COMPARISON_P (op0) && op1 == const0_rtx)\n     {\n       if (code == NE)\n \t{\n@@ -277,23 +277,24 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \n   switch (GET_RTX_CLASS (code))\n     {\n-    case '1':\n+    case RTX_UNARY:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n       op0 = simplify_replace_rtx (op0, old, new);\n       if (op0 == XEXP (x, 0))\n \treturn x;\n       return simplify_gen_unary (code, mode, op0, op_mode);\n \n-    case '2':\n-    case 'c':\n+    case RTX_BIN_ARITH:\n+    case RTX_COMM_ARITH:\n       op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n       op1 = simplify_replace_rtx (XEXP (x, 1), old, new);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn x;\n       return simplify_gen_binary (code, mode, op0, op1);\n \n-    case '<':\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n       op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n@@ -303,8 +304,8 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \treturn x;\n       return simplify_gen_relational (code, mode, op_mode, op0, op1);\n \n-    case '3':\n-    case 'b':\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n       op0 = simplify_replace_rtx (op0, old, new);\n@@ -316,7 +317,7 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \top_mode = GET_MODE (op0);\n       return simplify_gen_ternary (code, mode, op_mode, op0, op1, op2);\n \n-    case 'x':\n+    case RTX_EXTRA:\n       /* The only case we try to handle is a SUBREG.  */\n       if (code == SUBREG)\n \t{\n@@ -330,7 +331,7 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \t}\n       break;\n \n-    case 'o':\n+    case RTX_OBJ:\n       if (code == MEM)\n \t{\n \t  op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n@@ -902,7 +903,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    return XEXP (op, 0);\n \n \t  /* (not (eq X Y)) == (ne X Y), etc.  */\n-\t  if (GET_RTX_CLASS (GET_CODE (op)) == '<'\n+\t  if (COMPARISON_P (op)\n \t      && (mode == BImode || STORE_FLAG_VALUE == -1)\n \t      && ((reversed = reversed_comparison_code (op, NULL_RTX))\n \t\t  != UNKNOWN))\n@@ -942,7 +943,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  /* If STORE_FLAG_VALUE is -1, (not (comparison X Y)) can be done\n \t     by reversing the comparison code if valid.  */\n \t  if (STORE_FLAG_VALUE == -1\n-\t      && GET_RTX_CLASS (GET_CODE (op)) == '<'\n+\t      && COMPARISON_P (op)\n \t      && (reversed = reversed_comparison_code (op, NULL_RTX))\n \t\t != UNKNOWN)\n \t    return simplify_gen_relational (reversed, mode, VOIDmode,\n@@ -1165,16 +1166,19 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n   rtx trueop0, trueop1;\n   rtx tem;\n \n+#ifdef ENABLE_CHECKING\n   /* Relational operations don't work here.  We must know the mode\n      of the operands in order to do the comparison correctly.\n      Assuming a full word can give incorrect results.\n      Consider comparing 128 with -128 in QImode.  */\n \n-  if (GET_RTX_CLASS (code) == '<')\n+  if (GET_RTX_CLASS (code) == RTX_COMPARE\n+      || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n     abort ();\n+#endif\n \n   /* Make sure the constant is second.  */\n-  if (GET_RTX_CLASS (code) == 'c'\n+  if (GET_RTX_CLASS (code) == RTX_COMM_ARITH\n       && swap_commutative_operands_p (op0, op1))\n     {\n       tem = op0, op0 = op1, op1 = tem;\n@@ -2885,7 +2889,7 @@ simplify_ternary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t  && rtx_equal_p (XEXP (op0, 1), op1))))\n \treturn op2;\n \n-      if (GET_RTX_CLASS (GET_CODE (op0)) == '<' && ! side_effects_p (op0))\n+      if (COMPARISON_P (op0) && ! side_effects_p (op0))\n \t{\n \t  enum machine_mode cmp_mode = (GET_MODE (XEXP (op0, 0)) == VOIDmode\n \t\t\t\t\t? GET_MODE (XEXP (op0, 1))\n@@ -3536,25 +3540,26 @@ simplify_rtx (rtx x)\n \n   switch (GET_RTX_CLASS (code))\n     {\n-    case '1':\n+    case RTX_UNARY:\n       return simplify_unary_operation (code, mode,\n \t\t\t\t       XEXP (x, 0), GET_MODE (XEXP (x, 0)));\n-    case 'c':\n+    case RTX_COMM_ARITH:\n       if (swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n \treturn simplify_gen_binary (code, mode, XEXP (x, 1), XEXP (x, 0));\n \n       /* Fall through....  */\n \n-    case '2':\n+    case RTX_BIN_ARITH:\n       return simplify_binary_operation (code, mode, XEXP (x, 0), XEXP (x, 1));\n \n-    case '3':\n-    case 'b':\n+    case RTX_TERNARY:\n+    case RTX_BITFIELD_OPS:\n       return simplify_ternary_operation (code, mode, GET_MODE (XEXP (x, 0)),\n \t\t\t\t\t XEXP (x, 0), XEXP (x, 1),\n \t\t\t\t\t XEXP (x, 2));\n \n-    case '<':\n+    case RTX_COMPARE:\n+    case RTX_COMM_COMPARE:\n       temp = simplify_relational_operation (code,\n \t\t\t\t\t    ((GET_MODE (XEXP (x, 0))\n \t\t\t\t\t      != VOIDmode)\n@@ -3573,7 +3578,7 @@ simplify_rtx (rtx x)\n #endif\n       return temp;\n \n-    case 'x':\n+    case RTX_EXTRA:\n       if (code == SUBREG)\n \treturn simplify_gen_subreg (mode, SUBREG_REG (x),\n \t\t\t\t    GET_MODE (SUBREG_REG (x)),\n@@ -3585,7 +3590,7 @@ simplify_rtx (rtx x)\n \t}\n       break;\n \n-    case 'o':\n+    case RTX_OBJ:\n       if (code == LO_SUM)\n \t{\n \t  /* Convert (lo_sum (high FOO) FOO) to FOO.  */"}, {"sha": "9ba2e916d93aef7dcc61eb97c801fb32f3af437e", "filename": "gcc/unroll.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8e098d3d9adeb04512169974fd67acd9b9ca0f/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "patch": "@@ -1,6 +1,6 @@\n /* Try to unroll loops, and split induction variables.\n    Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003\n+   2002, 2003, 2004\n    Free Software Foundation, Inc.\n    Contributed by James E. Wilson, Cygnus Support/UC Berkeley.\n \n@@ -2872,7 +2872,6 @@ static int\n reg_dead_after_loop (const struct loop *loop, rtx reg)\n {\n   rtx insn, label;\n-  enum rtx_code code;\n   int jump_count = 0;\n   int label_count = 0;\n \n@@ -2902,8 +2901,7 @@ reg_dead_after_loop (const struct loop *loop, rtx reg)\n       insn = NEXT_INSN (XEXP (label, 0));\n       while (insn)\n \t{\n-\t  code = GET_CODE (insn);\n-\t  if (GET_RTX_CLASS (code) == 'i')\n+\t  if (INSN_P (insn))\n \t    {\n \t      rtx set, note;\n \n@@ -2917,18 +2915,18 @@ reg_dead_after_loop (const struct loop *loop, rtx reg)\n \t      set = single_set (insn);\n \t      if (set && rtx_equal_p (SET_DEST (set), reg))\n \t\tbreak;\n-\t    }\n \n-\t  if (code == JUMP_INSN)\n-\t    {\n-\t      if (GET_CODE (PATTERN (insn)) == RETURN)\n-\t\tbreak;\n-\t      else if (!any_uncondjump_p (insn)\n-\t\t       /* Prevent infinite loop following infinite loops.  */\n-\t\t       || jump_count++ > 20)\n-\t\treturn 0;\n-\t      else\n-\t\tinsn = JUMP_LABEL (insn);\n+\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t\t{\n+\t\t  if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t\t    break;\n+\t\t  else if (!any_uncondjump_p (insn)\n+\t\t           /* Prevent infinite loop following infinite loops.  */\n+\t\t           || jump_count++ > 20)\n+\t\t    return 0;\n+\t\t  else\n+\t\t    insn = JUMP_LABEL (insn);\n+\t\t}\n \t    }\n \n \t  insn = NEXT_INSN (insn);"}]}