{"sha": "173b24b9828c474251cc3bb2515d19399330e8c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTczYjI0Yjk4MjhjNDc0MjUxY2MzYmIyNTE1ZDE5Mzk5MzMwZThjNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-01T11:00:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-01T11:00:47Z"}, "message": "function.c (keep_stack_depressed): Don't use delete_insn.\n\n\t* function.c (keep_stack_depressed): Don't use delete_insn.\n\n\t* expr.h (set_mem_alias_set): Move decl to here.\n\t* rtl.h (mem_attrs): New typedef and struct.\n\t(union rtunion_def): Add field for mem_attrs.\n\t(X0MEMATTR, MEM_ATTRS): New macros.\n\t(MEM_ALIAS_SET): Use MEM_ATTRS.\n\t(MEM_DECL, MEM_OFFSET, MEM_SIZE, MEM_ALIGN): New macros.\n\t(MEM_COPY_ATTRIBUTES): Copy MEM_ATTRS.\n\t(set_mem_alias_set): Delete decl from here.\n\n\t* alias.c (set_mem_alias_set): Delete from here.\n\t* emit-rtl.c (mem_attrs_htab): New variable.\n\t(rtx_htab_mark, rtx_htab_mark_1): Deleted.\n\t(mem_attrs_htab_hash, mem_attrs_htab_eq): New functions.\n\t(mem_attrs_mark, get_mem_attrs): Likewise.\n\t(gen_rtx_MEM): Clear MEM_ATTRS.\n\t(set_mem_attributes): Move to here.\n\t(set_mem_alias_set): Likewise, and call get_mem_attrs.\n\t(init_emit_once): const_int_htab now deletable htab.\n\tInitialize mem_attrs_htab.\n\t* explow.c (set_mem_attributes): Delete from here.\n\t* function.c (put_var_into_stack): Clear MEM_ATTRS.\n\t(gen_mem_addressof): Likewise; rework to use set_mem_attributes.\n\t* ggc-common.c (ggc_mark_rtx_children, case MEM): New case.\n\t* reload1.c (reload): Rework changing REG to MEM.\n\nFrom-SVN: r45922", "tree": {"sha": "a2295f973363e17dc793a7b1597e907c1198e6a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2295f973363e17dc793a7b1597e907c1198e6a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/173b24b9828c474251cc3bb2515d19399330e8c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173b24b9828c474251cc3bb2515d19399330e8c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173b24b9828c474251cc3bb2515d19399330e8c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173b24b9828c474251cc3bb2515d19399330e8c5/comments", "author": null, "committer": null, "parents": [{"sha": "bab3db73e98108edfe0319d2c36a07bebbce2aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bab3db73e98108edfe0319d2c36a07bebbce2aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bab3db73e98108edfe0319d2c36a07bebbce2aac"}], "stats": {"total": 451, "additions": 298, "deletions": 153}, "files": [{"sha": "8993b5ac05b97df1694083fb599e383d38631889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -1,3 +1,32 @@\n+Mon Oct  1 06:43:41 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (keep_stack_depressed): Don't use delete_insn.\n+\n+\t* expr.h (set_mem_alias_set): Move decl to here.\n+\t* rtl.h (mem_attrs): New typedef and struct.\n+\t(union rtunion_def): Add field for mem_attrs.\n+\t(X0MEMATTR, MEM_ATTRS): New macros.\n+\t(MEM_ALIAS_SET): Use MEM_ATTRS.\n+\t(MEM_DECL, MEM_OFFSET, MEM_SIZE, MEM_ALIGN): New macros.\n+\t(MEM_COPY_ATTRIBUTES): Copy MEM_ATTRS.\n+\t(set_mem_alias_set): Delete decl from here.\n+\t\n+\t* alias.c (set_mem_alias_set): Delete from here.\n+\t* emit-rtl.c (mem_attrs_htab): New variable.\n+\t(rtx_htab_mark, rtx_htab_mark_1): Deleted.\n+\t(mem_attrs_htab_hash, mem_attrs_htab_eq): New functions.\n+\t(mem_attrs_mark, get_mem_attrs): Likewise.\n+\t(gen_rtx_MEM): Clear MEM_ATTRS.\n+\t(set_mem_attributes): Move to here.\n+\t(set_mem_alias_set): Likewise, and call get_mem_attrs.\n+\t(init_emit_once): const_int_htab now deletable htab.\n+\tInitialize mem_attrs_htab.\n+\t* explow.c (set_mem_attributes): Delete from here.\n+\t* function.c (put_var_into_stack): Clear MEM_ATTRS.\n+\t(gen_mem_addressof): Likewise; rework to use set_mem_attributes.\n+\t* ggc-common.c (ggc_mark_rtx_children, case MEM): New case.\n+\t* reload1.c (reload): Rework changing REG to MEM.\n+\n 2001-09-30  H.J. Lu <hjl@gnu.org>\n \n \t* acconfig.h (PREFIX_INCLUDE_DIR): New variable."}, {"sha": "bf7c5e33e4fa1bca5e3c6b7b40098a5727a528cd", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -276,24 +276,6 @@ alias_sets_conflict_p (set1, set2)\n   return 0;\n }\n \f\n-/* Set the alias set of MEM to SET.  */\n-\n-void\n-set_mem_alias_set (mem, set)\n-     rtx mem;\n-     HOST_WIDE_INT set;\n-{\n-  /* We would like to do this test but can't yet since when converting a\n-     REG to a MEM, the alias set field is undefined.  */\n-#if 0\n-  /* If the new and old alias sets don't conflict, something is wrong.  */\n-  if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n-    abort ();\n-#endif\n-\n-  MEM_ALIAS_SET (mem) = set;\n-}\n-\f\n /* Return 1 if TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE and has\n    has any readonly fields.  If any of the fields have types that\n    contain readonly fields, return true as well.  */"}, {"sha": "eeb5128fec97120372e903ec418ad9c3abfa036a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 185, "deletions": 23, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -144,6 +144,9 @@ rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n static htab_t const_int_htab;\n \n+/* A hash table storing memory attribute structures.  */\n+static htab_t mem_attrs_htab;\n+\n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n \n@@ -182,13 +185,16 @@ static void mark_label_nuses\t\tPARAMS ((rtx));\n static hashval_t const_int_htab_hash    PARAMS ((const void *));\n static int const_int_htab_eq            PARAMS ((const void *,\n \t\t\t\t\t\t const void *));\n-static int rtx_htab_mark_1              PARAMS ((void **, void *));\n-static void rtx_htab_mark               PARAMS ((void *));\n+static hashval_t mem_attrs_htab_hash    PARAMS ((const void *));\n+static int mem_attrs_htab_eq            PARAMS ((const void *,\n+\t\t\t\t\t\t const void *));\n+static void mem_attrs_mark\t\tPARAMS ((const void *));\n+static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n+\t\t\t\t\t\t rtx, unsigned int));\n \n /* Probability of the conditional branch currently proceeded by try_split.\n    Set to -1 otherwise.  */\n int split_branch_probability = -1;\n-\n \f\n /* Returns a hash code for X (which is a really a CONST_INT).  */\n \n@@ -211,26 +217,83 @@ const_int_htab_eq (x, y)\n   return (INTVAL ((const struct rtx_def *) x) == *((const HOST_WIDE_INT *) y));\n }\n \n-/* Mark the hash-table element X (which is really a pointer to an\n-   rtx).  */\n+/* Returns a hash code for X (which is a really a mem_attrs *).  */\n+\n+static hashval_t\n+mem_attrs_htab_hash (x)\n+     const void *x;\n+{\n+  mem_attrs *p = (mem_attrs *) x;\n+\n+  return (p->alias ^ (p->align * 1000)\n+\t  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)\n+\t  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)\n+\t  ^ (long) p->decl);\n+}\n+\n+/* Returns non-zero if the value represented by X (which is really a\n+   mem_attrs *) is the same as that given by Y (which is also really a\n+   mem_attrs *).  */\n \n static int\n-rtx_htab_mark_1 (x, data)\n-     void **x;\n-     void *data ATTRIBUTE_UNUSED;\n+mem_attrs_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n {\n-  ggc_mark_rtx (*x);\n-  return 1;\n+  mem_attrs *p = (mem_attrs *) x;\n+  mem_attrs *q = (mem_attrs *) y;\n+\n+  return (p->alias == q->alias && p->decl == q->decl && p->offset == q->offset\n+\t  && p->size == q->size && p->align == q->align);\n }\n \n-/* Mark all the elements of HTAB (which is really an htab_t full of\n-   rtxs).  */\n+/* This routine is called when we determine that we need a mem_attrs entry.\n+   It marks the associated decl and RTL as being used, if present.  */\n \n static void\n-rtx_htab_mark (htab)\n-     void *htab;\n+mem_attrs_mark (x)\n+     const void *x;\n {\n-  htab_traverse (*((htab_t *) htab), rtx_htab_mark_1, NULL);\n+  mem_attrs *p = (mem_attrs *) x;\n+\n+  if (p->decl)\n+    ggc_mark_tree (p->decl);\n+\n+  if (p->offset)\n+    ggc_mark_rtx (p->offset);\n+\n+  if (p->size)\n+    ggc_mark_rtx (p->size);\n+}\n+\n+/* Allocate a new mem_attrs structure and insert it into the hash table if\n+   one identical to it is not already in the table.  */\n+\n+static mem_attrs *\n+get_mem_attrs (alias, decl, offset, size, align)\n+     HOST_WIDE_INT alias;\n+     tree decl;\n+     rtx offset;\n+     rtx size;\n+     unsigned int align;\n+{\n+  mem_attrs attrs;\n+  void **slot;\n+\n+  attrs.alias = alias;\n+  attrs.decl = decl;\n+  attrs.offset = offset;\n+  attrs.size = size;\n+  attrs.align = align;\n+\n+  slot = htab_find_slot (mem_attrs_htab, &attrs, INSERT);\n+  if (*slot == 0)\n+    {\n+      *slot = ggc_alloc (sizeof (mem_attrs));\n+      memcpy (*slot, &attrs, sizeof (mem_attrs));\n+    }\n+\n+  return *slot;\n }\n \n /* Generate a new REG rtx.  Make sure ORIGINAL_REGNO is set properly, and\n@@ -350,7 +413,7 @@ gen_rtx_MEM (mode, addr)\n \n   /* This field is not cleared by the mere allocation of the rtx, so\n      we clear it here.  */\n-  MEM_ALIAS_SET (rt) = 0;\n+  MEM_ATTRS (rt) = 0;\n \n   return rt;\n }\n@@ -377,9 +440,9 @@ gen_rtx_SUBREG (mode, reg, offset)\n   return gen_rtx_fmt_ei (SUBREG, mode, reg, offset);\n }\n \n-/* Generate a SUBREG representing the least-significant part\n- * of REG if MODE is smaller than mode of REG, otherwise\n- * paradoxical SUBREG.  */\n+/* Generate a SUBREG representing the least-significant part of REG if MODE\n+   is smaller than mode of REG, otherwise paradoxical SUBREG.  */\n+\n rtx\n gen_lowpart_SUBREG (mode, reg)\n      enum machine_mode mode;\n@@ -556,7 +619,6 @@ gen_rtvec_v (n, argp)\n \n   return rt_val;\n }\n-\n \f\n /* Generate a REG rtx for a new pseudo register of mode MODE.\n    This pseudo is assigned the next sequential register number.  */\n@@ -1569,6 +1631,103 @@ reverse_comparison (insn)\n     }\n }\n \f\n+\n+/* Given REF, a MEM, and T, either the type of X or the expression\n+   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n+   if we are making a new object of this type.  */\n+\n+void\n+set_mem_attributes (ref, t, objectp)\n+     rtx ref;\n+     tree t;\n+     int objectp;\n+{\n+  tree type;\n+\n+  /* It can happen that type_for_mode was given a mode for which there\n+     is no language-level type.  In which case it returns NULL, which\n+     we can see here.  */\n+  if (t == NULL_TREE)\n+    return;\n+\n+  type = TYPE_P (t) ? t : TREE_TYPE (t);\n+\n+  /* Get the alias set from the expression or type (perhaps using a\n+     front-end routine) and then copy bits from the type.  */\n+\n+  /* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY (type)\n+     here, because, in C and C++, the fact that a location is accessed\n+     through a const expression does not mean that the value there can\n+     never change.  */\n+\n+  /* If we have already set DECL_RTL = ref, get_alias_set will get the\n+     wrong answer, as it assumes that DECL_RTL already has the right alias\n+     info.  Callers should not set DECL_RTL until after the call to\n+     set_mem_attributes.  */\n+  if (DECL_P (t) && ref == DECL_RTL_IF_SET (t))\n+    abort ();\n+\n+  set_mem_alias_set (ref, get_alias_set (t));\n+\n+  MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n+  MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n+\n+  /* If we are making an object of this type, we know that it is a scalar if\n+     the type is not an aggregate.  */\n+  if (objectp && ! AGGREGATE_TYPE_P (type))\n+    MEM_SCALAR_P (ref) = 1;\n+\n+  /* If T is a type, this is all we can do.  Otherwise, we may be able\n+     to deduce some more information about the expression.  */\n+  if (TYPE_P (t))\n+    return;\n+\n+  maybe_set_unchanging (ref, t);\n+  if (TREE_THIS_VOLATILE (t))\n+    MEM_VOLATILE_P (ref) = 1;\n+\n+  /* Now see if we can say more about whether it's an aggregate or\n+     scalar.  If we already know it's an aggregate, don't bother.  */\n+  if (MEM_IN_STRUCT_P (ref))\n+    return;\n+\n+  /* Now remove any NOPs: they don't change what the underlying object is.\n+     Likewise for SAVE_EXPR.  */\n+  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n+\t || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  /* Since we already know the type isn't an aggregate, if this is a decl,\n+     it must be a scalar.  Or if it is a reference into an aggregate,\n+     this is part of an aggregate.   Otherwise we don't know.  */\n+  if (DECL_P (t))\n+    MEM_SCALAR_P (ref) = 1;\n+  else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n+\t   || TREE_CODE (t) == ARRAY_RANGE_REF\n+\t   || TREE_CODE (t) == BIT_FIELD_REF)\n+    MEM_IN_STRUCT_P (ref) = 1;\n+}\n+\n+/* Set the alias set of MEM to SET.  */\n+\n+void\n+set_mem_alias_set (mem, set)\n+     rtx mem;\n+     HOST_WIDE_INT set;\n+{\n+  /* It would be nice to enable this check, but we can't quite yet.  */\n+#if 0\n+#ifdef ENABLE_CHECKING\t\n+  /* If the new and old alias sets don't conflict, something is wrong.  */\n+  if (!alias_sets_conflict_p (set, MEM_ALIAS_SET (mem)))\n+    abort ();\n+#endif\n+#endif\n+\n+  MEM_ATTRS (mem) = get_mem_attrs (set, MEM_DECL (mem), MEM_OFFSET (mem),\n+\t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem));\n+}\n+\f\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n@@ -4281,11 +4440,14 @@ init_emit_once (line_numbers)\n   enum machine_mode mode;\n   enum machine_mode double_mode;\n \n-  /* Initialize the CONST_INT hash table.  */\n+  /* Initialize the CONST_INT and memory attribute hash tables.  */\n   const_int_htab = htab_create (37, const_int_htab_hash,\n \t\t\t\tconst_int_htab_eq, NULL);\n-  ggc_add_root (&const_int_htab, 1, sizeof (const_int_htab),\n-\t\trtx_htab_mark);\n+  ggc_add_deletable_htab (const_int_htab, 0, 0);\n+\n+  mem_attrs_htab = htab_create (37, mem_attrs_htab_hash,\n+\t\t\t\tmem_attrs_htab_eq, NULL);\n+  ggc_add_deletable_htab (mem_attrs_htab, 0, mem_attrs_mark);\n \n   no_line_numbers = ! line_numbers;\n "}, {"sha": "85c3a7dc77b8d8d514324a70791dc2d846eb5893", "filename": "gcc/explow.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -642,82 +642,6 @@ maybe_set_unchanging (ref, t)\n       || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n     RTX_UNCHANGING_P (ref) = 1;\n }\n-\n-/* Given REF, a MEM, and T, either the type of X or the expression\n-   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n-   if we are making a new object of this type.  */\n-\n-void\n-set_mem_attributes (ref, t, objectp)\n-     rtx ref;\n-     tree t;\n-     int objectp;\n-{\n-  tree type;\n-\n-  /* It can happen that type_for_mode was given a mode for which there\n-     is no language-level type.  In which case it returns NULL, which\n-     we can see here.  */\n-  if (t == NULL_TREE)\n-    return;\n-\n-  type = TYPE_P (t) ? t : TREE_TYPE (t);\n-\n-  /* Get the alias set from the expression or type (perhaps using a\n-     front-end routine) and then copy bits from the type.  */\n-\n-  /* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY (type)\n-     here, because, in C and C++, the fact that a location is accessed\n-     through a const expression does not mean that the value there can\n-     never change.  */\n-\n-  /* If we have already set DECL_RTL = ref, get_alias_set will get the\n-     wrong answer, as it assumes that DECL_RTL already has the right alias\n-     info.  Callers should not set DECL_RTL until after the call to\n-     set_mem_attributes.  */\n-  if (DECL_P (t) && ref == DECL_RTL_IF_SET (t))\n-    abort ();\n-\n-  set_mem_alias_set (ref, get_alias_set (t));\n-\n-  MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n-  MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n-\n-  /* If we are making an object of this type, we know that it is a scalar if\n-     the type is not an aggregate.  */\n-  if (objectp && ! AGGREGATE_TYPE_P (type))\n-    MEM_SCALAR_P (ref) = 1;\n-\n-  /* If T is a type, this is all we can do.  Otherwise, we may be able\n-     to deduce some more information about the expression.  */\n-  if (TYPE_P (t))\n-    return;\n-\n-  maybe_set_unchanging (ref, t);\n-  if (TREE_THIS_VOLATILE (t))\n-    MEM_VOLATILE_P (ref) = 1;\n-\n-  /* Now see if we can say more about whether it's an aggregate or\n-     scalar.  If we already know it's an aggregate, don't bother.  */\n-  if (MEM_IN_STRUCT_P (ref))\n-    return;\n-\n-  /* Now remove any NOPs: they don't change what the underlying object is.\n-     Likewise for SAVE_EXPR.  */\n-  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n-\t || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* Since we already know the type isn't an aggregate, if this is a decl,\n-     it must be a scalar.  Or if it is a reference into an aggregate,\n-     this is part of an aggregate.   Otherwise we don't know.  */\n-  if (DECL_P (t))\n-    MEM_SCALAR_P (ref) = 1;\n-  else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n-\t   || TREE_CODE (t) == ARRAY_RANGE_REF\n-\t   || TREE_CODE (t) == BIT_FIELD_REF)\n-    MEM_IN_STRUCT_P (ref) = 1;\n-}\n \f\n /* Return a modified copy of X with its memory address copied\n    into a temporary register to protect it from side effects."}, {"sha": "9addf7f732640f7ea6ece47cc0353eb4c49de940", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -602,6 +602,9 @@ extern rtx memory_address PARAMS ((enum machine_mode, rtx));\n /* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n \n+/* Set the alias set of MEM to SET.  */\n+extern void set_mem_alias_set PARAMS ((rtx, HOST_WIDE_INT));\n+\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode."}, {"sha": "fed2b3b68c7453fbb8c9ba23ea47ff44373ef101", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -1406,6 +1406,7 @@ put_var_into_stack (decl)\n \n       /* Change the CONCAT into a combined MEM for both parts.  */\n       PUT_CODE (reg, MEM);\n+      MEM_ATTRS (reg) = 0;\n \n       /* set_mem_attributes uses DECL_RTL to avoid re-generating of\n          already computed alias sets.  Here we want to re-generate.  */\n@@ -1476,6 +1477,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n   PUT_CODE (reg, MEM);\n   PUT_MODE (reg, decl_mode);\n   XEXP (reg, 0) = XEXP (new, 0);\n+  MEM_ATTRS (reg) = 0;\n   /* `volatil' bit means one thing for MEMs, another entirely for REGs.  */\n   MEM_VOLATILE_P (reg) = volatile_p;\n \n@@ -1490,6 +1492,7 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n \t\t\t   AGGREGATE_TYPE_P (type) || MEM_IN_STRUCT_P (new));\n       set_mem_alias_set (reg, get_alias_set (type));\n     }\n+\n   if (used_p)\n     schedule_fixup_var_refs (function, reg, type, promoted_mode, ht);\n }\n@@ -2840,29 +2843,35 @@ gen_mem_addressof (reg, decl)\n   RTX_UNCHANGING_P (XEXP (r, 0)) = RTX_UNCHANGING_P (reg);\n \n   PUT_CODE (reg, MEM);\n+  MEM_ATTRS (reg) = 0;\n   XEXP (reg, 0) = r;\n+\n   if (decl)\n     {\n       tree type = TREE_TYPE (decl);\n       enum machine_mode decl_mode\n \t= (TREE_CODE (decl) == SAVE_EXPR ? TYPE_MODE (TREE_TYPE (decl))\n \t   : DECL_MODE (decl));\n+      rtx decl_rtl = decl ? DECL_RTL_IF_SET (decl) : 0;\n \n       PUT_MODE (reg, decl_mode);\n-      MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n-      MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));\n+\n+      /* Clear DECL_RTL momentarily so functions below will work\n+\t properly, then set it again.  */\n+      if (decl_rtl == reg)\n+\tSET_DECL_RTL (decl, 0);\n+\n+      set_mem_attributes (reg, decl, 1);\n       set_mem_alias_set (reg, set);\n \n+      if (decl_rtl == reg)\n+\tSET_DECL_RTL (decl, reg);\n+\n       if (TREE_USED (decl) || DECL_INITIAL (decl) != 0)\n \tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);\n     }\n   else\n-    {\n-      /* We have no alias information about this newly created MEM.  */\n-      set_mem_alias_set (reg, 0);\n-\n-      fixup_var_refs (reg, GET_MODE (reg), 0, 0);\n-    }\n+    fixup_var_refs (reg, GET_MODE (reg), 0, 0);\n \n   return reg;\n }\n@@ -7141,8 +7150,11 @@ keep_stack_depressed (seq)\n \t  else\n \t    sp_modified_unknown = 1;\n \n-\t  /* Don't allow the SP modification to happen.  */\n-\t  delete_insn (insn);\n+\t  /* Don't allow the SP modification to happen.  We don't call\n+\t     delete_insn here since INSN isn't in any chain.  */\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n \t}\n       else if (reg_referenced_p (stack_pointer_rtx, PATTERN (insn)))\n \t{"}, {"sha": "53057c8a75b7bc876e7b5211e3349cf29c9e5b46", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -298,6 +298,9 @@ ggc_mark_rtx_children (r)\n \t have any right poking our noses in?  */\n       switch (code)\n \t{\n+\tcase MEM:\n+\t  ggc_mark (MEM_ATTRS (r));\n+\t  break;\n \tcase JUMP_INSN:\n \t  ggc_mark_rtx (JUMP_LABEL (r));\n \t  break;"}, {"sha": "7828bf5a27bbb68a1afb339af8c5d48d7f39f6be", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -1130,16 +1130,6 @@ reload (first, global)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n       rtx addr = 0;\n-      int in_struct = 0;\n-      int is_scalar = 0;\n-      int is_readonly = 0;\n-\n-      if (reg_equiv_memory_loc[i])\n-\t{\n-\t  in_struct = MEM_IN_STRUCT_P (reg_equiv_memory_loc[i]);\n-\t  is_scalar = MEM_SCALAR_P (reg_equiv_memory_loc[i]);\n-\t  is_readonly = RTX_UNCHANGING_P (reg_equiv_memory_loc[i]);\n-\t}\n \n       if (reg_equiv_mem[i])\n \taddr = XEXP (reg_equiv_mem[i], 0);\n@@ -1152,15 +1142,18 @@ reload (first, global)\n \t  if (reg_renumber[i] < 0)\n \t    {\n \t      rtx reg = regno_reg_rtx[i];\n+\n \t      PUT_CODE (reg, MEM);\n \t      XEXP (reg, 0) = addr;\n \t      REG_USERVAR_P (reg) = 0;\n-\t      RTX_UNCHANGING_P (reg) = is_readonly;\n-\t      MEM_IN_STRUCT_P (reg) = in_struct;\n-\t      MEM_SCALAR_P (reg) = is_scalar;\n-\t      /* We have no alias information about this newly created\n-\t\t MEM.  */\n-\t      set_mem_alias_set (reg, 0);\n+\t      if (reg_equiv_memory_loc[i])\n+\t\tMEM_COPY_ATTRIBUTES (reg, reg_equiv_memory_loc[i]);\n+\t      else\n+\t\t{\n+\t\t  RTX_UNCHANGING_P (reg) = MEM_IN_STRUCT_P (reg)\n+\t\t    = MEM_SCALAR_P (reg) = 0;\n+\t\t  MEM_ATTRS (reg) = 0;\n+\t\t}\n \t    }\n \t  else if (reg_equiv_mem[i])\n \t    XEXP (reg_equiv_mem[i], 0) = addr;"}, {"sha": "983036fae1b31505c3012f09889f405eba377d35", "filename": "gcc/rtl.h", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b24b9828c474251cc3bb2515d19399330e8c5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=173b24b9828c474251cc3bb2515d19399330e8c5", "patch": "@@ -31,8 +31,8 @@ struct function;\n #undef ABS /* Likewise.  */\n #undef PC /* Likewise.  */\n \n-/* Value used by some passes to \"recognize\" noop moves as valid instructions.\n- */\n+/* Value used by some passes to \"recognize\" noop moves as valid\n+ instructions. */\n #define NOOP_MOVE_INSN_CODE\tINT_MAX\n \n /* Register Transfer Language EXPRESSIONS CODES */\n@@ -71,16 +71,33 @@ typedef struct\n   unsigned min_align: 8;\n   /* Flags: */\n   unsigned base_after_vec: 1; /* BASE is after the ADDR_DIFF_VEC.  */\n-  unsigned min_after_vec: 1;  /* minimum address target label is after the ADDR_DIFF_VEC.  */\n-  unsigned max_after_vec: 1;  /* maximum address target label is after the ADDR_DIFF_VEC.  */\n-  unsigned min_after_base: 1; /* minimum address target label is after BASE.  */\n-  unsigned max_after_base: 1; /* maximum address target label is after BASE.  */\n+  unsigned min_after_vec: 1;  /* minimum address target label is\n+\t\t\t\t after the ADDR_DIFF_VEC.  */\n+  unsigned max_after_vec: 1;  /* maximum address target label is\n+\t\t\t\t after the ADDR_DIFF_VEC.  */\n+  unsigned min_after_base: 1; /* minimum address target label is\n+\t\t\t\t after BASE.  */\n+  unsigned max_after_base: 1; /* maximum address target label is\n+\t\t\t\t after BASE.  */\n   /* Set by the actual branch shortening process - ONLY WHEN OPTIMIZING - : */\n   unsigned offset_unsigned: 1; /* offsets have to be treated as unsigned.  */\n   unsigned : 2;\n   unsigned scale : 8;\n } addr_diff_vec_flags;\n \n+/* Structure used to describe the attributes of a MEM.  These are hashed\n+   so MEMs that the same attributes share a data structure.  This means\n+   they cannot be modified in place.  If any element is nonzero, it means\n+   the value of the corresponding attribute is unknown.  */\n+typedef struct\n+{\n+  HOST_WIDE_INT alias;\t\t/* Memory alias set. */\n+  tree decl;\t\t\t/* decl corresponding to MEM. */\n+  rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT. */\n+  rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n+  unsigned int align;\t\t/* Alignment of MEM in bytes.  */\n+} mem_attrs;\n+\n /* Common union for an element of an rtx.  */\n \n typedef union rtunion_def\n@@ -97,6 +114,7 @@ typedef union rtunion_def\n   struct bitmap_head_def *rtbit;\n   tree rttree;\n   struct basic_block_def *bb;\n+  mem_attrs *rtmem;\n } rtunion;\n \n /* RTL expression (\"rtx\").  */\n@@ -340,6 +358,7 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n #define X0BBDEF(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').bb)\n #define X0ADVFLAGS(RTX, N) (RTL_CHECK1(RTX, N, '0').rt_addr_diff_vec_flags)\n #define X0CSELIB(RTX, N)   (RTL_CHECK1(RTX, N, '0').rt_cselib)\n+#define X0MEMATTR(RTX, N)  (RTL_CHECK1(RTX, N, '0').rtmem)\n \n #define XCWINT(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rtwint)\n #define XCINT(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtint)\n@@ -862,6 +881,10 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n     }\t\t\t\t\t\t\\\n } while (0)\n \n+/* The memory attribute block.  We provide access macros for each value\n+   in the block and provide defaults if none specified.  */\n+#define MEM_ATTRS(RTX) X0MEMATTR (RTX, 1)\n+\n /* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n    set, and may alias anything.  Otherwise, the MEM can only alias\n    MEMs in the same alias set.  This value is set in a\n@@ -871,15 +894,30 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n    some front-ends, these numbers may correspond in some way to types,\n    or other language-level entities, but they need not, and the\n    back-end makes no such assumptions.  */\n-#define MEM_ALIAS_SET(RTX) XCWINT(RTX, 1, MEM)\n+#define MEM_ALIAS_SET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->alias)\n+\n+/* For a MEM rtx, the decl it is known to refer to, if it is known to\n+   refer to part of a DECL.  */\n+#define MEM_DECL(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->decl)\n+\n+/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a\n+   RTX that is always a CONST_INT.  */\n+#define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)\n+\n+/* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that\n+   is always a CONST_INT.  */\n+#define MEM_SIZE(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->size)\n+\n+/* For a MEM rtx, the alignment in bytes.  */\n+#define MEM_ALIGN(RTX) (MEM_ATTRS (RTX) == 0 ? 1 : MEM_ATTRS (RTX)->align)\n \n /* Copy the attributes that apply to memory locations from RHS to LHS.  */\n #define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\\n   (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\\\n    MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\\\n    MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\\\n-   MEM_ALIAS_SET (LHS) = MEM_ALIAS_SET (RHS),\t\t\\\n-   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS))\n+   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\\\n+   MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */\n@@ -2010,7 +2048,6 @@ extern void init_alias_once\t\tPARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n-extern void set_mem_alias_set\t\tPARAMS ((rtx, HOST_WIDE_INT));\n \n /* In sibcall.c */\n typedef enum {"}]}