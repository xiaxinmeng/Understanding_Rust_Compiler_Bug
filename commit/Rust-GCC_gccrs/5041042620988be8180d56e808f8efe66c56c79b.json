{"sha": "5041042620988be8180d56e808f8efe66c56c79b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA0MTA0MjYyMDk4OGJlODE4MGQ1NmU4MDhmOGVmZTY2YzU2Yzc5Yg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-15T10:18:03Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-15T10:18:03Z"}, "message": "cpphash.h (struct cpp_reader): Remove lexer_pos, directive_pos.\n\n\t* cpphash.h (struct cpp_reader): Remove lexer_pos, directive_pos.\n\tSplit mlstring_pos into mls_line and mls_col.\n\t* cppinit.c (cpp_create_reader): Initialize line to 1.\n\t(cpp_destroy): Free tokenruns.\n\t(push_include): Don't update lexer_pos.\n\t* cpplex.c (unterminated, parse_string): Update.\n\t(lex_token): Don't update lexer_pos, update.\n\t* cpplib.c (if_stack): Save line instead of line + col.\n\t(start_directive, _cpp_do__Pragma, do_else, do_elif,\n\tpush_conditional, _cpp_pop_buffer): Update.\n\t* cppmacro.c (funlike_invocation_p): Don't save lexer_pos.\n\t(_cpp_create_definition): Update.\n\nFrom-SVN: r45627", "tree": {"sha": "8e0d501bff80d035729518382d4a712cf34238c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0d501bff80d035729518382d4a712cf34238c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5041042620988be8180d56e808f8efe66c56c79b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5041042620988be8180d56e808f8efe66c56c79b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5041042620988be8180d56e808f8efe66c56c79b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5041042620988be8180d56e808f8efe66c56c79b/comments", "author": null, "committer": null, "parents": [{"sha": "6131fd23f505853e49b7f394b2dcb5de50076ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6131fd23f505853e49b7f394b2dcb5de50076ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6131fd23f505853e49b7f394b2dcb5de50076ad1"}], "stats": {"total": 98, "additions": 60, "deletions": 38}, "files": [{"sha": "aa960763844559130561c36cc94eaf890ca6fd6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -1,3 +1,18 @@\n+2001-09-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct cpp_reader): Remove lexer_pos, directive_pos.\n+\tSplit mlstring_pos into mls_line and mls_col.\n+\t* cppinit.c (cpp_create_reader): Initialize line to 1.\n+\t(cpp_destroy): Free tokenruns.\n+\t(push_include): Don't update lexer_pos.\n+\t* cpplex.c (unterminated, parse_string): Update.\n+\t(lex_token): Don't update lexer_pos, update.\n+\t* cpplib.c (if_stack): Save line instead of line + col.\n+\t(start_directive, _cpp_do__Pragma, do_else, do_elif,\n+\tpush_conditional, _cpp_pop_buffer): Update.\n+\t* cppmacro.c (funlike_invocation_p): Don't save lexer_pos.\n+\t(_cpp_create_definition): Update.\n+\n 2001-09-15  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/abi64.h: Add support for MEABI."}, {"sha": "292b05e87a85503a1296c3645109578b2b491fbd", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -242,9 +242,7 @@ struct cpp_reader\n   const struct line_map *map;\n   unsigned int line;\n \n-  /* The position of the last lexed token and last lexed directive.  */\n-  cpp_lexer_pos lexer_pos;\n-  cpp_lexer_pos directive_pos;\n+  /* The line of the '#' of the current directive.  */\n   unsigned int directive_line;\n \n   /* Memory pools.  */\n@@ -278,7 +276,8 @@ struct cpp_reader\n \n   /* Line and column where a newline was first seen in a string\n      constant (multi-line strings).  */\n-  cpp_lexer_pos mlstring_pos;\n+  unsigned int mls_line;\n+  unsigned int mls_col;\n \n   /* Buffer to hold macro definition string.  */\n   unsigned char *macro_buffer;"}, {"sha": "7c7f8dcdf054352b1f899bf46aa5e63e322a6a0a", "filename": "gcc/cppinit.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -502,8 +502,10 @@ cpp_create_reader (table, lang)\n      be needed.  */\n   pfile->deps = deps_init ();\n \n-  /* Initialise the line map.  */\n+  /* Initialise the line map.  Start at logical line 1, so we can use\n+     a line number of zero for special states.  */\n   init_line_maps (&pfile->line_maps);\n+  pfile->line = 1;\n \n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n@@ -564,6 +566,7 @@ cpp_destroy (pfile)\n   int result;\n   struct search_path *dir, *dirn;\n   cpp_context *context, *contextn;\n+  tokenrun *run, *runn;\n \n   while (CPP_BUFFER (pfile) != NULL)\n     _cpp_pop_buffer (pfile);\n@@ -585,6 +588,14 @@ cpp_destroy (pfile)\n   _cpp_free_pool (&pfile->macro_pool);\n   _cpp_free_pool (&pfile->argument_pool);\n \n+  for (run = &pfile->base_run; run; run = runn)\n+    {\n+      runn = run->next;\n+      free (run->base);\n+      if (run != &pfile->base_run)\n+\tfree (run);\n+    }\n+\n   for (dir = CPP_OPTION (pfile, quote_include); dir; dir = dirn)\n     {\n       dirn = dir->next;\n@@ -886,7 +897,7 @@ push_include (pfile, p)\n   header.val.str.text = (const unsigned char *) p->arg;\n   header.val.str.len = strlen (p->arg);\n   /* Make the command line directive take up a line.  */\n-  pfile->lexer_pos.line = ++pfile->line;\n+  pfile->line++;\n \n   return _cpp_execute_include (pfile, &header, IT_CMDLINE);\n }"}, {"sha": "f57d482fc4b6e5aac3b98380e25b137fead8540a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -656,13 +656,11 @@ unterminated (pfile, term)\n {\n   cpp_error (pfile, \"missing terminating %c character\", term);\n \n-  if (term == '\\\"' && pfile->mlstring_pos.line\n-      && pfile->mlstring_pos.line != pfile->lexer_pos.line)\n+  if (term == '\\\"' && pfile->mls_line && pfile->mls_line != pfile->line)\n     {\n-      cpp_error_with_line (pfile, pfile->mlstring_pos.line,\n-\t\t\t   pfile->mlstring_pos.col,\n+      cpp_error_with_line (pfile, pfile->mls_line, pfile->mls_col,\n \t\t\t   \"possible start of unterminated string literal\");\n-      pfile->mlstring_pos.line = 0;\n+      pfile->mls_line = 0;\n     }\n }\n \n@@ -760,8 +758,11 @@ parse_string (pfile, token, terminator)\n \t      cpp_pedwarn (pfile, \"multi-line string literals are deprecated\");\n \t    }\n \n-\t  if (pfile->mlstring_pos.line == 0)\n-\t    pfile->mlstring_pos = pfile->lexer_pos;\n+\t  if (pfile->mls_line == 0)\n+\t    {\n+\t      pfile->mls_line = token->line;\n+\t      pfile->mls_col = token->col;\n+\t    }\n \t      \n \t  c = handle_newline (pfile, c);\n \t  *dest++ = '\\n';\n@@ -998,15 +999,13 @@ lex_token (pfile, result)\n   result->flags = buffer->saved_flags;\n   buffer->saved_flags = 0;\n  update_tokens_line:\n-  pfile->lexer_pos.line = pfile->line;\n   result->line = pfile->line;\n \n  skipped_white:\n   c = buffer->read_ahead;\n   if (c == EOF && buffer->cur < buffer->rlimit)\n     c = *buffer->cur++;\n   result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n-  pfile->lexer_pos.col = result->col;\n   buffer->read_ahead = EOF;\n \n  trigraph:\n@@ -1171,9 +1170,7 @@ lex_token (pfile, result)\n \n \t  /* Skip_line_comment updates buffer->read_ahead.  */\n \t  if (skip_line_comment (pfile) && CPP_OPTION (pfile, warn_comments))\n-\t    cpp_warning_with_line (pfile, pfile->lexer_pos.line,\n-\t\t\t\t   pfile->lexer_pos.col,\n-\t\t\t\t   \"multi-line comment\");\n+\t    cpp_warning (pfile, \"multi-line comment\");\n \t}\n \n       /* Skipping the comment has updated buffer->read_ahead.  */"}, {"sha": "e8065f6584e6f042d38dd99006ba504cd82b70c3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -40,7 +40,7 @@ struct answer\n struct if_stack\n {\n   struct if_stack *next;\n-  cpp_lexer_pos pos;\t\t/* line and column where condition started */\n+  unsigned int line;\t\t/* Line where condition started.  */\n   const cpp_hashnode *mi_cmacro;/* macro name for #ifndef around entire file */\n   bool skip_elses;\t\t/* Can future #else / #elif be skipped?  */\n   bool was_skipping;\t\t/* If were skipping on entry.  */\n@@ -220,8 +220,6 @@ start_directive (pfile)\n   pfile->state.save_comments = 0;\n \n   /* Some handlers need the position of the # for diagnostics.  */\n-  pfile->directive_pos = pfile->lexer_pos;\n-  pfile->directive_pos.line = pfile->line;\n   pfile->directive_line = pfile->line;\n }\n \n@@ -1154,18 +1152,27 @@ _cpp_do__Pragma (pfile)\n   cpp_token string;\n   unsigned char *buffer;\n   unsigned int len;\n-  cpp_lexer_pos orig_pos;\n \n-  orig_pos = pfile->lexer_pos;\n   if (get__Pragma_string (pfile, &string))\n     cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n   else\n     {\n+      /* Ideally, we'd like\n+\t\t\ttoken1 _Pragma (\"foo\") token2\n+\t to be output as\n+\t\t\ttoken1\n+\t\t\t# 7 \"file.c\"\n+\t\t\t#pragma foo\n+\t\t\t# 7 \"file.c\"\n+\t\t\t\t\t       token2\n+\t Getting these correct line markers is a little tricky.  */\n+\n+      unsigned int orig_line = pfile->line;\n       buffer = destringize (&string.val.str, &len);\n       run_directive (pfile, T_PRAGMA, (char *) buffer, len);\n       free ((PTR) buffer);\n-      pfile->lexer_pos = orig_pos;\n-      pfile->line = pfile->lexer_pos.line;\n+      pfile->line = orig_line;\n+      pfile->buffer->saved_flags = BOL;\n     }\n }\n \n@@ -1254,7 +1261,7 @@ do_else (pfile)\n       if (ifs->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"#else after #else\");\n-\t  cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t  cpp_error_with_line (pfile, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELSE;\n@@ -1289,7 +1296,7 @@ do_elif (pfile)\n       if (ifs->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"#elif after #else\");\n-\t  cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+\t  cpp_error_with_line (pfile, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELIF;\n@@ -1355,7 +1362,7 @@ push_conditional (pfile, skip, type, cmacro)\n   cpp_buffer *buffer = pfile->buffer;\n \n   ifs = xobnew (&pfile->buffer_ob, struct if_stack);\n-  ifs->pos = pfile->directive_pos;\n+  ifs->line = pfile->directive_line;\n   ifs->next = buffer->if_stack;\n   ifs->skip_elses = pfile->state.skipping || !skip;\n   ifs->was_skipping = pfile->state.skipping;\n@@ -1778,7 +1785,7 @@ _cpp_pop_buffer (pfile)\n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n   for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n-    cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n+    cpp_error_with_line (pfile, ifs->line, 0,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n   /* In case of a missing #endif.  */"}, {"sha": "5c64767b656cefd5bd47c99db7fc36659a310be7", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5041042620988be8180d56e808f8efe66c56c79b/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=5041042620988be8180d56e808f8efe66c56c79b", "patch": "@@ -605,9 +605,7 @@ funlike_invocation_p (pfile, node, list)\n {\n   cpp_token maybe_paren;\n   macro_arg *args = 0;\n-  cpp_lexer_pos macro_pos;\n \n-  macro_pos = pfile->lexer_pos;\n   pfile->state.parsing_args = 1;\n   pfile->state.prevent_expansion++;\n \n@@ -630,10 +628,6 @@ funlike_invocation_p (pfile, node, list)\n   pfile->state.parsing_args = 0;\n   pfile->keep_tokens--;\n \n-  /* Reset the position in case of failure.  If success, the macro's\n-     expansion appears where the name would have.  */\n-  pfile->lexer_pos = macro_pos;\n-\n   if (args)\n     {\n       if (node->value.macro->paramc > 0)\n@@ -1247,7 +1241,7 @@ _cpp_create_definition (pfile, node)\n \n   macro = (cpp_macro *) _cpp_pool_alloc (&pfile->macro_pool,\n \t\t\t\t\t sizeof (cpp_macro));\n-  macro->line = pfile->directive_pos.line;\n+  macro->line = pfile->directive_line;\n   macro->params = 0;\n   macro->paramc = 0;\n   macro->fun_like = 0;\n@@ -1345,8 +1339,7 @@ _cpp_create_definition (pfile, node)\n     {\n       if (warn_of_redefinition (pfile, node, macro))\n \t{\n-\t  cpp_pedwarn_with_line (pfile, pfile->directive_pos.line,\n-\t\t\t\t pfile->directive_pos.col,\n+\t  cpp_pedwarn_with_line (pfile, pfile->directive_line, 0,\n \t\t\t\t \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n \t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))"}]}