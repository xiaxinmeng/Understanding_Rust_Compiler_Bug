{"sha": "82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJlZGE3N2VkNWM0NTQ4YmQ1Y2JiM2Y1YmJlNmYzNDUzYTNkMWVlYQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-04T13:07:06Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-04T13:07:06Z"}, "message": "cpphash.h (FIRST, [...]): New.\n\n\t* cpphash.h (FIRST, LAST, CUR, RLIMIT): New.\n\t(struct cpp_context): Add traditional fields.\n\t* cppmacro.c (paste_all_tokens, push_ptoken_context,\n\tpush_token_context, cpp_get_token, _cpp_backup_tokens): Update.\n\t* cpptrad.c (skip_comment, lex_identifier,\n\t_cpp_read_logical_line_trad, scan_out_logical_line): Update.\n\nFrom-SVN: r54242", "tree": {"sha": "3c0127db39d15911aba3137af7f41daa9c7866bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0127db39d15911aba3137af7f41daa9c7866bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/comments", "author": null, "committer": null, "parents": [{"sha": "589005ff217dde6c3c22842e27315d597a8fe710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/589005ff217dde6c3c22842e27315d597a8fe710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/589005ff217dde6c3c22842e27315d597a8fe710"}], "stats": {"total": 95, "additions": 64, "deletions": 31}, "files": [{"sha": "8a198ec0031620549298bba3ac5c9882ebccd728", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "patch": "@@ -1,3 +1,12 @@\n+2002-06-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (FIRST, LAST, CUR, RLIMIT): New.\n+\t(struct cpp_context): Add traditional fields.\n+\t* cppmacro.c (paste_all_tokens, push_ptoken_context,\n+\tpush_token_context, cpp_get_token, _cpp_backup_tokens): Update.\n+\t* cpptrad.c (skip_comment, lex_identifier,\n+\t_cpp_read_logical_line_trad, scan_out_logical_line): Update.\n+\n 2002-06-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gbl-ctors.h: Fix formatting."}, {"sha": "6d3f1b9fb09b25b036e4f325aba27ec765f0e4d4", "filename": "gcc/cpphash.h", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "patch": "@@ -126,16 +126,36 @@ struct tokenrun\n   cpp_token *base, *limit;\n };\n \n+/* Accessor macros for struct cpp_context.  */\n+#define FIRST(c) (c->u.iso.first)\n+#define LAST(c) (c->u.iso.last)\n+#define CUR(c) (c->u.trad.cur)\n+#define RLIMIT(c) (c->u.trad.rlimit)\n+\n typedef struct cpp_context cpp_context;\n struct cpp_context\n {\n   /* Doubly-linked list.  */\n   cpp_context *next, *prev;\n \n-  /* Contexts other than the base context are contiguous tokens.\n-     e.g. macro expansions, expanded argument tokens.  */\n-  union utoken first;\n-  union utoken last;\n+  union\n+  {\n+    /* For ISO macro expansion.  Contexts other than the base context\n+       are contiguous tokens.  e.g. macro expansions, expanded\n+       argument tokens.  */\n+    struct\n+    {\n+      union utoken first;\n+      union utoken last;\n+    } iso;\n+\n+    /* For traditional macro expansion.  */\n+    struct\n+    {\n+      const uchar *cur;\n+      const uchar *rlimit;\n+    } trad;\n+  } u;\n \n   /* If non-NULL, a buffer used for storage related to this context.\n      When the context is popped, the buffer is released.  */"}, {"sha": "ae5dfa92ec966d9af0244b0020e33ef5a4171a09", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "patch": "@@ -425,9 +425,9 @@ paste_all_tokens (pfile, lhs)\n \t inserted.  In either case, the constraints to #define\n \t guarantee we have at least one more token.  */\n       if (context->direct_p)\n-\trhs = context->first.token++;\n+\trhs = FIRST (context).token++;\n       else\n-\trhs = *context->first.ptoken++;\n+\trhs = *FIRST (context).ptoken++;\n \n       if (rhs->type == CPP_PADDING)\n \tabort ();\n@@ -896,8 +896,8 @@ push_ptoken_context (pfile, macro, buff, first, count)\n   context->direct_p = false;\n   context->macro = macro;\n   context->buff = buff;\n-  context->first.ptoken = first;\n-  context->last.ptoken = first + count;\n+  FIRST (context).ptoken = first;\n+  LAST (context).ptoken = first + count;\n }\n \n /* Push a list of tokens.  */\n@@ -913,8 +913,8 @@ push_token_context (pfile, macro, first, count)\n   context->direct_p = true;\n   context->macro = macro;\n   context->buff = NULL;\n-  context->first.token = first;\n-  context->last.token = first + count;\n+  FIRST (context).token = first;\n+  LAST (context).token = first + count;\n }\n \n /* Expand an argument ARG before replacing parameters in a\n@@ -1004,12 +1004,12 @@ cpp_get_token (pfile)\n       /* Context->prev == 0 <=> base context.  */\n       if (!context->prev)\n \tresult = _cpp_lex_token (pfile);\n-      else if (context->first.token != context->last.token)\n+      else if (FIRST (context).token != LAST (context).token)\n \t{\n \t  if (context->direct_p)\n-\t    result = context->first.token++;\n+\t    result = FIRST (context).token++;\n \t  else\n-\t    result = *context->first.ptoken++;\n+\t    result = *FIRST (context).ptoken++;\n \n \t  if (result->flags & PASTE_LEFT)\n \t    {\n@@ -1118,9 +1118,9 @@ _cpp_backup_tokens (pfile, count)\n       if (count != 1)\n \tabort ();\n       if (pfile->context->direct_p)\n-\tpfile->context->first.token--;\n+\tFIRST (pfile->context).token--;\n       else\n-\tpfile->context->first.ptoken--;\n+\tFIRST (pfile->context).ptoken--;\n     }\n }\n "}, {"sha": "4f4d97c9ca7eefbede90c5c99c5e0d98aeca032c", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=82eda77ed5c4548bd5cbb3f5bbe6f3453a3d1eea", "patch": "@@ -23,7 +23,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* Lexing TODO: Handle -C, maybe -CC, and space in escaped newlines.\n    Stop cpplex.c from recognizing comments and directives during its\n-   lexing pass.  */\n+   lexing pass.  Get rid of line_base usage - seems pointless?  */\n \n static const uchar *handle_newline PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n@@ -90,8 +90,8 @@ skip_comment (pfile, cur)\n      const uchar *cur;\n {\n   unsigned int from_line = pfile->line;\n-  unsigned int c = 0, prevc;\n-  const uchar *limit = pfile->buffer->rlimit;\n+  unsigned int c = 0, prevc = 0;\n+  const uchar *limit = RLIMIT (pfile->context);\n \n   while (cur < limit)\n     {\n@@ -138,7 +138,7 @@ lex_identifier (pfile, cur)\n     }\n   while (ISIDNUM (*cur));\n \n-  pfile->buffer->cur = cur;\n+  CUR (pfile->context) = cur;\n   len = out - pfile->trad_out_cur;\n   pfile->trad_out_cur = out;\n   return (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->trad_out_cur,\n@@ -206,8 +206,12 @@ _cpp_read_logical_line_trad (pfile)\n \treturn false;\n     }\n \n+  CUR (pfile->context) = buffer->cur;\n+  RLIMIT (pfile->context) = buffer->rlimit;\n   pfile->trad_out_cur = pfile->trad_out_base;\n   scan_out_logical_line (pfile);\n+  buffer->cur = CUR (pfile->context);\n+\n   pfile->trad_line = pfile->line;\n   pfile->line = first_line;\n   _cpp_overlay_buffer (pfile, pfile->trad_out_base,\n@@ -222,12 +226,12 @@ static void\n scan_out_logical_line (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  const uchar *cur = buffer->cur;\n+  cpp_context *context = pfile->context;\n+  const uchar *cur = CUR (context);\n   unsigned int c, quote = 0;\n   uchar *out;\n \n-  check_output_buffer (pfile, buffer->rlimit - cur);\n+  check_output_buffer (pfile, RLIMIT (context) - cur);\n   out = pfile->trad_out_cur;\n \n   for (;;)\n@@ -240,20 +244,20 @@ scan_out_logical_line (pfile)\n       switch (c)\n \t{\n \tcase '\\0':\n-\t  if (cur - 1 != buffer->rlimit)\n+\t  if (cur - 1 != RLIMIT (context))\n \t    break;\n \t  cur--;\n-\t  if (!buffer->from_stage3)\n+\t  if (!pfile->buffer->from_stage3)\n \t    cpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n \t  pfile->line++;\n-\t  if (0)\n-\t    {\n-\t    case '\\r': case '\\n':\n-\t      cur = handle_newline (pfile, cur - 1);\n-\t    }\n+\t  goto finish_output;\n+\n+\tcase '\\r': case '\\n':\n+\t  cur = handle_newline (pfile, cur - 1);\n+\tfinish_output:\n \t  out[-1] = '\\n';\n \t  out[0] = '\\0';\n-\t  buffer->cur = cur;\n+\t  CUR (context) = cur;\n \t  pfile->trad_out_cur = out;\n \t  return;\n \n@@ -306,7 +310,7 @@ scan_out_logical_line (pfile)\n \t    pfile->trad_out_cur = --out;\n \t    node = lex_identifier (pfile, cur - 1);\n \t    out = pfile->trad_out_cur;\n-\t    cur = buffer->cur;\n+\t    cur = CUR (context);\n \t  }\n \t  break;\n "}]}