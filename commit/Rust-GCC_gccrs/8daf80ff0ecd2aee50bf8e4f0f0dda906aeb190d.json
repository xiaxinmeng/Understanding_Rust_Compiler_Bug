{"sha": "8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "node_id": "C_kwDOANBUbNoAKDhkYWY4MGZmMGVjZDJhZWU1MGJmOGU0ZjBmMGRkYTkwNmFlYjE5MGQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-28T16:36:32Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-16T14:44:54Z"}, "message": "ada: Optimize interface objects initialized with function calls\n\nThis optimizes the implementation of (class-wide) interface objects that are\ninitialized with function calls, by avoiding an unnecessary copy operation.\nThis also removes useless access checks generated by the expansion of return\nstatements involving class-wide types.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Factor out conditions\n\tneeded for an initializating expression that is a function call to\n\tbe renamable into the Is_Renamable_Function_Call predicate.\n\tUse it to implement the renaming in the case of class-wide interface\n\tobjects.  Remove an interface conversion on all paths, separate and\n\toptimize the renaming path in the special expansion for interfaces.\n\t(Is_Renamable_Function_Call): New predicate.\n\t(Make_Allocator_For_Return): Put back an interface conversion.\n\t* exp_ch6.adb (Apply_CW_Accessibility_Check): Remove useless access\n\tchecks on RE_Tag_Ptr.", "tree": {"sha": "c459c050e664056134b0efb0e5e81fdd5e4f3335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c459c050e664056134b0efb0e5e81fdd5e4f3335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "967592488c64a86f37bef3dabebb56364f14acdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967592488c64a86f37bef3dabebb56364f14acdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967592488c64a86f37bef3dabebb56364f14acdd"}], "stats": {"total": 313, "additions": 187, "deletions": 126}, "files": [{"sha": "536ae0c36e425afa8b64110aa8c8485399d696a0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 171, "deletions": 112, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "patch": "@@ -6306,6 +6306,38 @@ package body Exp_Ch3 is\n       --  Generate all initialization actions for return object Def_Id. Any\n       --  new code is inserted after node After.\n \n+      function Is_Renamable_Function_Call (Expr : Node_Id) return Boolean;\n+      --  If we are not at library level and the object declaration originally\n+      --  appears in the form:\n+\n+      --    Obj : Typ := Func (...);\n+\n+      --  and has been rewritten as the dereference of a captured reference\n+      --  to the function result built either on the primary or the secondary\n+      --  stack, then the declaration can be rewritten as the renaming of this\n+      --  dereference:\n+\n+      --    type Ann is access all Typ;\n+      --    Rnn : constant Axx := Func (...)'reference;\n+      --    Obj : Typ renames Rnn.all;\n+\n+      --  This will avoid making an extra copy and, in the case where Typ needs\n+      --  finalization, a pair of calls to the Adjust and Finalize primitives,\n+      --  or Deep_Adjust and Deep_Finalize routines, depending on whether Typ\n+      --  has components that themselves need finalization.\n+\n+      --  However, in the case of a special return object, we need to make sure\n+      --  that the object Rnn is recognized by the Is_Related_To_Func_Return\n+      --  predicate; otherwise, if it is of a type that needs finalization,\n+      --  then Requires_Cleanup_Actions would return true because of this and\n+      --  Build_Finalizer would finalize it prematurely because of this (see\n+      --  also Expand_Simple_Function_Return for the same test in the case of\n+      --  a simple return).\n+\n+      --  Finally, in the case of a special return object, we also need to make\n+      --  sure that the two functions return on the same stack, otherwise we\n+      --  would create a dangling reference.\n+\n       function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id;\n       --  Make an allocator for a return object initialized with Expr\n \n@@ -7100,12 +7132,28 @@ package body Exp_Ch3 is\n          end if;\n       end Initialize_Return_Object;\n \n+      --------------------------------\n+      -- Is_Renamable_Function_Call --\n+      --------------------------------\n+\n+      function Is_Renamable_Function_Call (Expr : Node_Id) return Boolean is\n+      begin\n+         return not Is_Library_Level_Entity (Def_Id)\n+           and then Is_Captured_Function_Call (Expr)\n+           and then (not Special_Ret_Obj\n+                      or else\n+                        (Is_Related_To_Func_Return (Entity (Prefix (Expr)))\n+                          and then Needs_Secondary_Stack (Etype (Expr)) =\n+                                   Needs_Secondary_Stack (Etype (Func_Id))));\n+      end Is_Renamable_Function_Call;\n+\n       -------------------------------\n       -- Make_Allocator_For_Return --\n       -------------------------------\n \n       function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id is\n-         Alloc : Node_Id;\n+         Alloc      : Node_Id;\n+         Alloc_Expr : Entity_Id;\n \n       begin\n          --  If the return object's declaration includes an expression and the\n@@ -7131,6 +7179,18 @@ package body Exp_Ch3 is\n                Apply_CW_Accessibility_Check (Expr, Func_Id);\n             end if;\n \n+            Alloc_Expr := New_Copy_Tree (Expr);\n+\n+            --  In the interface case, put back a conversion that we may have\n+            --  remove earlier in the processing.\n+\n+            if Is_Interface (Typ)\n+              and then Is_Interface (Etype (Alloc_Expr))\n+              and then Typ /= Etype (Alloc_Expr)\n+            then\n+               Alloc_Expr := Convert_To (Typ, Alloc_Expr);\n+            end if;\n+\n             --  We always use the type of the expression for the qualified\n             --  expression, rather than the return object's type. We cannot\n             --  always use the return object's type because the expression\n@@ -7141,8 +7201,8 @@ package body Exp_Ch3 is\n                 Expression =>\n                   Make_Qualified_Expression (Loc,\n                     Subtype_Mark =>\n-                      New_Occurrence_Of (Etype (Expr), Loc),\n-                    Expression   => New_Copy_Tree (Expr)));\n+                      New_Occurrence_Of (Etype (Alloc_Expr), Loc),\n+                    Expression   => Alloc_Expr));\n \n          else\n             Alloc :=\n@@ -7479,12 +7539,42 @@ package body Exp_Ch3 is\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n+            --  If the original node of the expression was a conversion\n+            --  to this specific class-wide interface type then restore\n+            --  the original node because we must copy the object before\n+            --  displacing the pointer to reference the secondary tag\n+            --  component. This code must be kept synchronized with the\n+            --  expansion done by routine Expand_Interface_Conversion\n+\n+            if not Comes_From_Source (Expr)\n+              and then Nkind (Expr) = N_Explicit_Dereference\n+              and then Nkind (Original_Node (Expr)) = N_Type_Conversion\n+              and then Etype (Original_Node (Expr)) = Typ\n+            then\n+               Rewrite (Expr, Original_Node (Expression (N)));\n+            end if;\n+\n+            --  Avoid expansion of redundant interface conversion\n+\n+            if Nkind (Expr) = N_Type_Conversion\n+              and then Etype (Expr) = Typ\n+            then\n+               Expr_Q := Expression (Expr);\n+            else\n+               Expr_Q := Expr;\n+            end if;\n+\n+            --  We may use a renaming if the initializing expression is a\n+            --  captured function call that meets a few conditions.\n+\n+            Rewrite_As_Renaming := Is_Renamable_Function_Call (Expr_Q);\n+\n             --  If the object is a special return object, then bypass special\n             --  treatment of class-wide interface initialization below. In this\n-            --  case, the expansion of the return statement will take care of\n-            --  creating the object (via allocator) and initializing it.\n+            --  case, the expansion of the return object will take care of this\n+            --  initialization via the expansion of the allocator.\n \n-            if Special_Ret_Obj then\n+            if Special_Ret_Obj and then not Rewrite_As_Renaming then\n \n                --  If the type needs finalization and is not inherently\n                --  limited, then the target is adjusted after the copy\n@@ -7511,45 +7601,25 @@ package body Exp_Ch3 is\n                   Tag_Comp     : Node_Id;\n \n                begin\n-                  --  If the original node of the expression was a conversion\n-                  --  to this specific class-wide interface type then restore\n-                  --  the original node because we must copy the object before\n-                  --  displacing the pointer to reference the secondary tag\n-                  --  component. This code must be kept synchronized with the\n-                  --  expansion done by routine Expand_Interface_Conversion\n-\n-                  if not Comes_From_Source (Expr)\n-                    and then Nkind (Expr) = N_Explicit_Dereference\n-                    and then Nkind (Original_Node (Expr)) = N_Type_Conversion\n-                    and then Etype (Original_Node (Expr)) = Typ\n-                  then\n-                     Rewrite (Expr, Original_Node (Expression (N)));\n+                  Expr_Typ := Base_Type (Etype (Expr_Q));\n+                  if Is_Class_Wide_Type (Expr_Typ) then\n+                     Expr_Typ := Root_Type (Expr_Typ);\n                   end if;\n \n-                  --  Avoid expansion of redundant interface conversion\n+                  --  Rename limited objects since they cannot be copied\n \n-                  if Is_Interface (Etype (Expr))\n-                    and then Nkind (Expr) = N_Type_Conversion\n-                    and then Etype (Expr) = Typ\n-                  then\n-                     Expr_Q := Expression (Expr);\n-                  else\n-                     Expr_Q := Expr;\n+                  if Is_Limited_Record (Expr_Typ) then\n+                     Rewrite_As_Renaming := True;\n                   end if;\n \n-                  Obj_Id   := Make_Temporary (Loc, 'D', Expr_Q);\n-                  Expr_Typ := Base_Type (Etype (Expr_Q));\n-\n-                  if Is_Class_Wide_Type (Expr_Typ) then\n-                     Expr_Typ := Root_Type (Expr_Typ);\n-                  end if;\n+                  Obj_Id := Make_Temporary (Loc, 'D', Expr_Q);\n \n                   --  Replace\n                   --     CW : I'Class := Obj;\n                   --  by\n-                  --     Tmp : Typ := Obj;\n+                  --     Dnn : Typ := Obj;\n                   --     type Ityp is not null access I'Class;\n-                  --     Rnn : constant Ityp := Ityp (Tmp.I_Tag'Address);\n+                  --     Rnn : constant Ityp := Ityp (Dnn.I_Tag'Address);\n                   --     CW  : I'Class renames Rnn.all;\n \n                   if Comes_From_Source (Expr_Q)\n@@ -7580,14 +7650,55 @@ package body Exp_Ch3 is\n                              (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n \n                   --  Replace\n-                  --     IW : I'Class := Obj;\n+                  --     IW : I'Class := Expr;\n+                  --  by\n+                  --     Dnn : Tag renames Tag_Ptr!(Expr'Address).all;\n+                  --     type Ityp is not null access I'Class;\n+                  --     Rnn : constant Ityp :=\n+                  --             Ityp!(Displace (Dnn'Address, I'Tag));\n+                  --     IW : I'Class renames Rnn.all;\n+\n+                  elsif Rewrite_As_Renaming then\n+                     New_Expr :=\n+                       Make_Explicit_Dereference (Loc,\n+                         Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => Relocate_Node (Expr_Q),\n+                             Attribute_Name => Name_Address)));\n+\n+                     --  Suppress junk access checks on RE_Tag_Ptr\n+\n+                     Insert_Action (N,\n+                       Make_Object_Renaming_Declaration (Loc,\n+                         Defining_Identifier => Obj_Id,\n+                         Subtype_Mark        =>\n+                           New_Occurrence_Of (RTE (RE_Tag), Loc),\n+                         Name                => New_Expr),\n+                       Suppress => Access_Check);\n+\n+                     --  Dynamically reference the tag associated with the\n+                     --  interface.\n+\n+                     Tag_Comp :=\n+                       Make_Function_Call (Loc,\n+                         Name => New_Occurrence_Of (RTE (RE_Displace), Loc),\n+                         Parameter_Associations => New_List (\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix => New_Occurrence_Of (Obj_Id, Loc),\n+                             Attribute_Name => Name_Address),\n+                           New_Occurrence_Of\n+                             (Node (First_Elmt (Access_Disp_Table (Iface))),\n+                              Loc)));\n+\n+                  --  Replace\n+                  --     IW : I'Class := Expr;\n                   --  by\n                   --     type Equiv_Record is record ... end record;\n                   --     implicit subtype CW is <Class_Wide_Subtype>;\n-                  --     Tmp : CW := CW!(Obj);\n+                  --     Dnn : CW := CW!(Expr);\n                   --     type Ityp is not null access I'Class;\n                   --     Rnn : constant Ityp :=\n-                  --             Ityp!(Displace (Tmp'Address, I'Tag));\n+                  --             Ityp!(Displace (Dnn'Address, I'Tag));\n                   --     IW : I'Class renames Rnn.all;\n \n                   else\n@@ -7600,47 +7711,34 @@ package body Exp_Ch3 is\n                         Subtype_Indic => Obj_Def,\n                         Exp           => Expr_Q);\n \n-                     if not Is_Interface (Etype (Expr_Q)) then\n-                        New_Expr := Relocate_Node (Expr_Q);\n-\n                      --  For interface types we use 'Address which displaces\n-                     --  the pointer to the base of the object (if required)\n+                     --  the pointer to the base of the object (if required).\n \n-                     else\n+                     if Is_Interface (Etype (Expr_Q)) then\n                         New_Expr :=\n                           Unchecked_Convert_To (Etype (Obj_Def),\n                             Make_Explicit_Dereference (Loc,\n                               Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n                                 Make_Attribute_Reference (Loc,\n                                   Prefix => Relocate_Node (Expr_Q),\n                                   Attribute_Name => Name_Address))));\n-                     end if;\n-\n-                     --  Copy the object\n \n-                     if not Is_Limited_Record (Expr_Typ) then\n-                        Insert_Action (N,\n-                          Make_Object_Declaration (Loc,\n-                            Defining_Identifier => Obj_Id,\n-                            Object_Definition   =>\n-                              New_Occurrence_Of (Etype (Obj_Def), Loc),\n-                            Expression => New_Expr));\n-\n-                     --  Rename limited type object since they cannot be copied\n-                     --  This case occurs when the initialization expression\n-                     --  has been previously expanded into a temporary object.\n+                     --  For other types, no displacement is needed\n \n                      else\n-                        Insert_Action (N,\n-                          Make_Object_Renaming_Declaration (Loc,\n-                            Defining_Identifier => Obj_Id,\n-                            Subtype_Mark        =>\n-                              New_Occurrence_Of (Etype (Obj_Def), Loc),\n-                            Name                =>\n-                              Unchecked_Convert_To\n-                                (Etype (Obj_Def), New_Expr)));\n+                        New_Expr := Relocate_Node (Expr_Q);\n                      end if;\n \n+                     --  Suppress junk access checks on RE_Tag_Ptr\n+\n+                     Insert_Action (N,\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Obj_Id,\n+                         Object_Definition   =>\n+                           New_Occurrence_Of (Etype (Obj_Def), Loc),\n+                         Expression          => New_Expr),\n+                       Suppress => Access_Check);\n+\n                      --  Dynamically reference the tag associated with the\n                      --  interface.\n \n@@ -7684,6 +7782,7 @@ package body Exp_Ch3 is\n                   Set_Prefix (Tag_Comp, New_Occurrence_Of (Ptr_Obj_Id, Loc));\n                   Expr_Q := Tag_Comp;\n                   Set_Etype (Expr_Q, Typ);\n+                  Set_Parent (Expr_Q, N);\n \n                   Rewrite_As_Renaming := True;\n                end;\n@@ -7863,7 +7962,6 @@ package body Exp_Ch3 is\n             Rewrite_As_Renaming :=\n \n               --  The declaration cannot be rewritten if it has got constraints\n-              --  in other words the nominal subtype must be unconstrained.\n \n               Is_Entity_Name (Original_Node (Obj_Def))\n \n@@ -7872,57 +7970,18 @@ package body Exp_Ch3 is\n \n                 and then not Aliased_Present (N)\n \n-                --  If the object declaration originally appears in the form\n-\n-                --    Obj : Typ := Func (...);\n-\n-                --  and has been rewritten as the dereference of a reference\n-                --  to the function result built either on the primary or the\n-                --  secondary stack, then the declaration can be rewritten as\n-                --  the renaming of this dereference:\n-\n-                --    type Ann is access all Typ;\n-                --    Rnn : constant Axx := Func (...)'reference;\n-                --    Obj : Typ renames Rnn.all;\n-\n-                --  This avoids an extra copy and, in the case where Typ needs\n-                --  finalization, a pair of Adjust/Finalize calls (see below).\n-\n-                --  However, in the case of a special return object, we need to\n-                --  make sure that the object Rnn is properly recognized by the\n-                --  Is_Related_To_Func_Return predicate; otherwise, if it is of\n-                --  a type that needs finalization, Requires_Cleanup_Actions\n-                --  would return true because of this and Build_Finalizer would\n-                --  finalize it prematurely (see Expand_Simple_Function_Return\n-                --  for the same test in the case of a simple return).\n-\n-                --  Moreover, in the case of a special return object, we also\n-                --  need to make sure that the two functions return on the same\n-                --  stack, otherwise we would create a dangling reference.\n+                --  We may use a renaming if the initializing expression is a\n+                --  captured function call that meets a few conditions.\n \n                 and then\n-                  ((not Is_Library_Level_Entity (Def_Id)\n-                     and then Is_Captured_Function_Call (Expr_Q)\n-                     and then\n-                       (not Special_Ret_Obj\n-                         or else\n-                          (Is_Related_To_Func_Return (Entity (Prefix (Expr_Q)))\n-                            and then Needs_Secondary_Stack (Etype (Expr_Q)) =\n-                                     Needs_Secondary_Stack (Etype (Func_Id)))))\n-\n-                   --  If the initializing expression is a variable with the\n-                   --  flag OK_To_Rename set, then transform:\n-\n-                   --     Obj : Typ := Expr;\n-\n-                   --  into\n+                  (Is_Renamable_Function_Call (Expr_Q)\n \n-                   --     Obj : Typ renames Expr;\n+                   --  Or else if it is a variable with OK_To_Rename set\n \n                    or else (OK_To_Rename_Ref (Expr_Q)\n                              and then not Special_Ret_Obj)\n \n-                   --  Likewise if it is a slice of such a variable\n+                   --  Or else if it is a slice of such a variable\n \n                    or else (Nkind (Expr_Q) = N_Slice\n                              and then OK_To_Rename_Ref (Prefix (Expr_Q))\n@@ -8117,8 +8176,8 @@ package body Exp_Ch3 is\n \n       if Is_Build_In_Place_Return_Object (Def_Id) then\n          declare\n-            Init_Stmt       : Node_Id;\n-            Obj_Acc_Formal  : Entity_Id;\n+            Init_Stmt      : Node_Id;\n+            Obj_Acc_Formal : Entity_Id;\n \n          begin\n             --  Retrieve the implicit access parameter passed by the caller"}, {"sha": "503fdc1ee6b6da1e5bf302d53ff6c36a265bad3b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8daf80ff0ecd2aee50bf8e4f0f0dda906aeb190d", "patch": "@@ -687,7 +687,11 @@ package body Exp_Ch6 is\n       Loc : constant Source_Ptr := Sloc (Exp);\n \n    begin\n+       --  CodePeer does not do anything useful on Ada.Tags.Type_Specific_Data\n+       --  components.\n+\n       if Ada_Version >= Ada_2005\n+        and then not CodePeer_Mode\n         and then Tagged_Type_Expansion\n         and then not Scope_Suppress.Suppress (Accessibility_Check)\n         and then\n@@ -770,20 +774,18 @@ package body Exp_Ch6 is\n                    Attribute_Name => Name_Tag);\n             end if;\n \n-            --  CodePeer does not do anything useful with\n-            --  Ada.Tags.Type_Specific_Data components.\n-\n-            if not CodePeer_Mode then\n-               Insert_Action (Exp,\n-                 Make_Raise_Program_Error (Loc,\n-                   Condition =>\n-                     Make_Op_Gt (Loc,\n-                       Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc,\n-                           Scope_Depth (Enclosing_Dynamic_Scope (Func)))),\n-                   Reason    => PE_Accessibility_Check_Failed));\n-            end if;\n+            --  Suppress junk access chacks on RE_Tag_Ptr\n+\n+            Insert_Action (Exp,\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd  => Build_Get_Access_Level (Loc, Tag_Node),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Scope_Depth (Enclosing_Dynamic_Scope (Func)))),\n+                Reason    => PE_Accessibility_Check_Failed),\n+              Suppress => Access_Check);\n          end;\n       end if;\n    end Apply_CW_Accessibility_Check;"}]}