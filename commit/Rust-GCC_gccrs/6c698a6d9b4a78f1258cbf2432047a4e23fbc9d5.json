{"sha": "6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2OThhNmQ5YjRhNzhmMTI1OGNiZjI0MzIwNDdhNGUyM2ZiYzlkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-09-29T11:40:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-09-29T11:40:24Z"}, "message": "final.c (final_scan_insn): Remove extra extract_insn call; Use caching for constrain_operands.\n\n\n\t* final.c (final_scan_insn): Remove extra extract_insn call;\n\tUse caching for constrain_operands.\n\t(cleanup_subreg_operands): Use caching for extract_insn.\n\t* recog.c (constrain_operands_cached): New.\n\t* recog.h (constrain_operands_cached): Declare.\n\t* i386.c (ix86_attr_length_immediate_default,\n\tix86_attr_length_address_default, ix86_agi_dependant): Cache\n\textract_insn call.\n\n\t* recog.c (asm_noperands): Tweak.\n\t(extract_insn): Do not call asm_noperads for non-asm instructions.\n\nFrom-SVN: r36665", "tree": {"sha": "86f0f02c1cd763e7136d740c442a6c1fed6e56af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86f0f02c1cd763e7136d740c442a6c1fed6e56af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/comments", "author": null, "committer": null, "parents": [{"sha": "b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc"}], "stats": {"total": 202, "additions": 138, "deletions": 64}, "files": [{"sha": "055714bfd59dcc73f632ceeea1022a39c098bac3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "patch": "@@ -1,3 +1,48 @@\n+Fri Sep 29 13:37:59 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* final.c (final_scan_insn): Remove extra extract_insn call;\n+\tUse caching for constrain_operands.\n+\t(cleanup_subreg_operands): Use caching for extract_insn.\n+\t* recog.c (constrain_operands_cached): New.\n+\t* recog.h (constrain_operands_cached): Declare.\n+\t* i386.c (ix86_attr_length_immediate_default,\n+\tix86_attr_length_address_default, ix86_agi_dependant): Cache\n+\textract_insn call.\n+\n+\t* recog.c (asm_noperands): Tweak.\n+\t(extract_insn): Do not call asm_noperads for non-asm instructions.\n+\n+Fri Sep 29 13:20:42 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* recog.c (recog_memoized): Rename to recog_memoized_1.\n+\t* recog.h (recog_memoized): Rename to recog_memoized_1.\n+\t(recog_memoized): New macro.\n+\t* rtl.h (single_set): Rename to single_set_1\n+\t(single_set): New macro.\n+\t* rtlanal.c (single_set): Rename to single_set_1;  expect clobbers\n+\tto be last.\n+\n+\t* i386.md (strmovsi_1, strmovhi_1 strmovqi_1):\n+\tDo not use match_dup of input operands at outputs.\n+\tUse register_operand for memory expression.\n+\t(rep_movsi): Put use last, canonicalize.\n+\tUse register_operand for memory expression.\n+\t(rep_movqi): Put use last.\n+\tUse register_operand for memory expression.\n+\t(strsetsi_1, strset_hi_1, strsetqi_1): Do not use match_dup\n+\tof input operands at outputs.  Use register_operand for memory\n+\texpression.\n+\t(rep_stossi): Put use last; canonicalize; fix match_dup in\n+\tthe address expression\n+\t(rep_stosqi): Likewise.\n+\t(memcmp expander): Update calls.\n+\t(cmpstrsi_nz_1, cmpstrsi_1, strlensi_1): Avoid match_dups in\n+\tthe clobbers.\n+\n+\t* i386.md (fp_jcc_3, fp_jcc_4, jp_fcc_5): if_then_else operand is\n+\tVOIDmode.\n+\t(fp_jcc_4, fp_jcc_3): Refuse unordered comparisons.\n+\n 2000-09-28  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config/i386/freebsd-aout.h: New, FreeBSD a.out config file."}, {"sha": "b66e5a4df56c0885298a7601d8361cd2604d4753", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "patch": "@@ -6272,7 +6272,7 @@ ix86_attr_length_immediate_default (insn, shortform)\n {\n   int len = 0;\n   int i;\n-  extract_insn (insn);\n+  extract_insn_cached (insn);\n   for (i = recog_data.n_operands - 1; i >= 0; --i)\n     if (CONSTANT_P (recog_data.operand[i]))\n       {\n@@ -6308,7 +6308,7 @@ ix86_attr_length_address_default (insn)\n      rtx insn;\n {\n   int i;\n-  extract_insn (insn);\n+  extract_insn_cached (insn);\n   for (i = recog_data.n_operands - 1; i >= 0; --i)\n     if (GET_CODE (recog_data.operand[i]) == MEM)\n       {\n@@ -6409,7 +6409,7 @@ ix86_agi_dependant (insn, dep_insn, insn_type)\n   else\n     {\n       int i;\n-      extract_insn (insn);\n+      extract_insn_cached (insn);\n       for (i = recog_data.n_operands - 1; i >= 0; --i)\n \tif (GET_CODE (recog_data.operand[i]) == MEM)\n \t  {"}, {"sha": "0e22b069461c6c1a9e109ea77bdc7664b343a617", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "patch": "@@ -2919,7 +2919,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t   since `reload' should have changed them so that they do.  */\n \n \tinsn_code_number = recog_memoized (insn);\n-\textract_insn (insn);\n \tcleanup_subreg_operands (insn);\n \n        /* Dump the insn in the assembly for debugging.  */\n@@ -2930,7 +2929,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n            print_rtx_head = \"\";\n          }\n        \n-\tif (! constrain_operands (1))\n+\tif (! constrain_operands_cached (1))\n \t  fatal_insn_not_found (insn);\n \n \t/* Some target machines need to prescan each insn before\n@@ -3138,8 +3137,7 @@ cleanup_subreg_operands (insn)\n      rtx insn;\n {\n   int i;\n-\n-  extract_insn (insn);\n+  extract_insn_cached (insn);\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)"}, {"sha": "d88ac05aaf94d20bf8d6b08f61fe121635014863", "filename": "gcc/recog.c", "status": "modified", "additions": 84, "deletions": 56, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "patch": "@@ -1401,68 +1401,75 @@ int\n asm_noperands (body)\n      rtx body;\n {\n-  if (GET_CODE (body) == ASM_OPERANDS)\n-    /* No output operands: return number of input operands.  */\n-    return ASM_OPERANDS_INPUT_LENGTH (body);\n-  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-    /* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */\n-    return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body)) + 1;\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET\n-\t   && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n+  switch (GET_CODE (body))\n     {\n-      /* Multiple output operands, or 1 output plus some clobbers:\n-\t body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */\n-      int i;\n-      int n_sets;\n-\n-      /* Count backwards through CLOBBERs to determine number of SETs.  */\n-      for (i = XVECLEN (body, 0); i > 0; i--)\n+    case ASM_OPERANDS:\n+      /* No output operands: return number of input operands.  */\n+      return ASM_OPERANDS_INPUT_LENGTH (body);\n+    case SET:\n+      if (GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+\t/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */\n+\treturn ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body)) + 1;\n+      else\n+\treturn -1;\n+    case PARALLEL:\n+      if (GET_CODE (XVECEXP (body, 0, 0)) == SET\n+\t  && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n \t{\n-\t  if (GET_CODE (XVECEXP (body, 0, i - 1)) == SET)\n-\t    break;\n-\t  if (GET_CODE (XVECEXP (body, 0, i - 1)) != CLOBBER)\n-\t    return -1;\n-\t}\n+\t  /* Multiple output operands, or 1 output plus some clobbers:\n+\t     body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */\n+\t  int i;\n+\t  int n_sets;\n \n-      /* N_SETS is now number of output operands.  */\n-      n_sets = i;\n+\t  /* Count backwards through CLOBBERs to determine number of SETs.  */\n+\t  for (i = XVECLEN (body, 0); i > 0; i--)\n+\t    {\n+\t      if (GET_CODE (XVECEXP (body, 0, i - 1)) == SET)\n+\t\tbreak;\n+\t      if (GET_CODE (XVECEXP (body, 0, i - 1)) != CLOBBER)\n+\t\treturn -1;\n+\t    }\n \n-      /* Verify that all the SETs we have\n-\t came from a single original asm_operands insn\n-\t (so that invalid combinations are blocked).  */\n-      for (i = 0; i < n_sets; i++)\n-\t{\n-\t  rtx elt = XVECEXP (body, 0, i);\n-\t  if (GET_CODE (elt) != SET)\n-\t    return -1;\n-\t  if (GET_CODE (SET_SRC (elt)) != ASM_OPERANDS)\n-\t    return -1;\n-\t  /* If these ASM_OPERANDS rtx's came from different original insns\n-\t     then they aren't allowed together.  */\n-\t  if (ASM_OPERANDS_INPUT_VEC (SET_SRC (elt))\n-\t      != ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (body, 0, 0))))\n-\t    return -1;\n+\t  /* N_SETS is now number of output operands.  */\n+\t  n_sets = i;\n+\n+\t  /* Verify that all the SETs we have\n+\t     came from a single original asm_operands insn\n+\t     (so that invalid combinations are blocked).  */\n+\t  for (i = 0; i < n_sets; i++)\n+\t    {\n+\t      rtx elt = XVECEXP (body, 0, i);\n+\t      if (GET_CODE (elt) != SET)\n+\t\treturn -1;\n+\t      if (GET_CODE (SET_SRC (elt)) != ASM_OPERANDS)\n+\t\treturn -1;\n+\t      /* If these ASM_OPERANDS rtx's came from different original insns\n+\t         then they aren't allowed together.  */\n+\t      if (ASM_OPERANDS_INPUT_VEC (SET_SRC (elt))\n+\t\t  != ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (body, 0, 0))))\n+\t\treturn -1;\n+\t    }\n+\t  return (ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)))\n+\t\t  + n_sets);\n \t}\n-      return (ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)))\n-\t      + n_sets);\n-    }\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    {\n-      /* 0 outputs, but some clobbers:\n-\t body is [(asm_operands ...) (clobber (reg ...))...].  */\n-      int i;\n+      else if (GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+\t{\n+\t  /* 0 outputs, but some clobbers:\n+\t     body is [(asm_operands ...) (clobber (reg ...))...].  */\n+\t  int i;\n \n-      /* Make sure all the other parallel things really are clobbers.  */\n-      for (i = XVECLEN (body, 0) - 1; i > 0; i--)\n-\tif (GET_CODE (XVECEXP (body, 0, i)) != CLOBBER)\n-\t  return -1;\n+\t  /* Make sure all the other parallel things really are clobbers.  */\n+\t  for (i = XVECLEN (body, 0) - 1; i > 0; i--)\n+\t    if (GET_CODE (XVECEXP (body, 0, i)) != CLOBBER)\n+\t      return -1;\n \n-      return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n+\t  return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n+\t}\n+      else\n+\treturn -1;\n+    default:\n+      return -1;\n     }\n-  else\n-    return -1;\n }\n \n /* Assuming BODY is an insn body that uses ASM_OPERANDS,\n@@ -2069,6 +2076,16 @@ extract_constrain_insn_cached (insn)\n       && !constrain_operands (reload_completed))\n     fatal_insn_not_found (insn);\n }\n+/* Do cached constrain_operand and complain about failures.  */\n+int\n+constrain_operands_cached (strict)\n+\tint strict;\n+{\n+  if (which_alternative == -1)\n+    return constrain_operands (strict);\n+  else\n+    return 1;\n+}\n \f\n /* Analyze INSN and fill in recog_data.  */\n \n@@ -2097,8 +2114,19 @@ extract_insn (insn)\n       return;\n \n     case SET:\n+      if (GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+\tgoto asm_insn;\n+      else\n+\tgoto normal_insn;\n     case PARALLEL:\n+      if ((GET_CODE (XVECEXP (body, 0, 0)) == SET\n+\t   && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n+\t  || GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+\tgoto asm_insn;\n+      else\n+\tgoto normal_insn;\n     case ASM_OPERANDS:\n+    asm_insn:\n       recog_data.n_operands = noperands = asm_noperands (body);\n       if (noperands >= 0)\n \t{\n@@ -2122,10 +2150,10 @@ extract_insn (insn)\n \t    }\n \t  break;\n \t}\n-\n-      /* FALLTHROUGH */\n+      fatal_insn_not_found (insn);\n \n     default:\n+    normal_insn:\n       /* Ordinary insn: recognize it, get the operands via insn_extract\n \t and get the constraints.  */\n "}, {"sha": "5987cfcbc33c3ed7c14799ae00b6f5fc52ca9c52", "filename": "gcc/recog.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=6c698a6d9b4a78f1258cbf2432047a4e23fbc9d5", "patch": "@@ -21,6 +21,8 @@ Boston, MA 02111-1307, USA.  */\n \n /* Random number that should be large enough for all purposes.  */\n #define MAX_RECOG_ALTERNATIVES 30\n+#define recog_memoized(I) (INSN_CODE (I) >= 0 \\\n+\t\t\t   ? INSN_CODE (I) : recog_memoized_1 (I))\n \n /* Types of operands.  */\n enum op_type {\n@@ -69,14 +71,15 @@ struct operand_alternative\n \n extern void init_recog\t\t\tPARAMS ((void));\n extern void init_recog_no_volatile\tPARAMS ((void));\n-extern int recog_memoized\t\tPARAMS ((rtx));\n+extern int recog_memoized_1\t\tPARAMS ((rtx));\n extern int check_asm_operands\t\tPARAMS ((rtx));\n extern int asm_operand_ok\t\tPARAMS ((rtx, const char *));\n extern int validate_change\t\tPARAMS ((rtx, rtx *, rtx, int));\n extern int apply_change_group\t\tPARAMS ((void));\n extern int num_validated_changes\tPARAMS ((void));\n extern void cancel_changes\t\tPARAMS ((int));\n extern int constrain_operands\t\tPARAMS ((int));\n+extern int constrain_operands_cached\tPARAMS ((int));\n extern int memory_address_p\t\tPARAMS ((enum machine_mode, rtx));\n extern int strict_memory_address_p\tPARAMS ((enum machine_mode, rtx));\n extern int validate_replace_rtx_subexp\tPARAMS ((rtx, rtx, rtx, rtx *));"}]}