{"sha": "d7bc7a9850ac55871f1108c491585118e10afd04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiYzdhOTg1MGFjNTU4NzFmMTEwOGM0OTE1ODUxMThlMTBhZmQwNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-21T06:20:18Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-21T06:20:18Z"}, "message": "cpphash.h (_cpp_push_next_buffer): New.\n\n\t* cpphash.h (_cpp_push_next_buffer): New.\n\t* cppinit.c (do_includes): Remove.\n\t(push_include, free_chain, _cpp_push_next_buffer): New.\n\t(cpp_start_read): Use them to rework command line option handling.\n\t(cpp_handle_option): Combine handling of -include and -imacros.\n\t* cpplex.c (_cpp_lex_token): Push a new -include buffer if\n\tappropriate.  Always insert missing \\n at EOF.\n\t* cpplib.c (start_directive): Get the directive position right.\n\t* cppmain.c (cb_file_change): Always print the first line, unless\n\tpreprocessed.\n\nFrom-SVN: r45070", "tree": {"sha": "d3294a0e95ec060c7d36c19a66723166c94ce0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3294a0e95ec060c7d36c19a66723166c94ce0f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7bc7a9850ac55871f1108c491585118e10afd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bc7a9850ac55871f1108c491585118e10afd04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7bc7a9850ac55871f1108c491585118e10afd04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bc7a9850ac55871f1108c491585118e10afd04/comments", "author": null, "committer": null, "parents": [{"sha": "bb1a503c19ca810ff94db1674cbe607f903d1ffc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1a503c19ca810ff94db1674cbe607f903d1ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1a503c19ca810ff94db1674cbe607f903d1ffc"}], "stats": {"total": 225, "additions": 136, "deletions": 89}, "files": [{"sha": "8f715052e83be1c99176ebaca7cd126f33fa010f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -1,3 +1,16 @@\n+2001-08-21  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (_cpp_push_next_buffer): New.\n+\t* cppinit.c (do_includes): Remove.\n+\t(push_include, free_chain, _cpp_push_next_buffer): New.\n+\t(cpp_start_read): Use them to rework command line option handling.\n+\t(cpp_handle_option): Combine handling of -include and -imacros.\n+\t* cpplex.c (_cpp_lex_token): Push a new -include buffer if\n+\tappropriate.  Always insert missing \\n at EOF.\n+\t* cpplib.c (start_directive): Get the directive position right.\n+\t* cppmain.c (cb_file_change): Always print the first line, unless\n+\tpreprocessed.\n+\n 2001-08-20  Andreas Jaeger  <aj@suse.de>\n \n \t* profile.c (compute_branch_probabilities): Remove extra new-line"}, {"sha": "f530e5596ea73ac839c5565612da2ad746a05e08", "filename": "gcc/cpphash.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -419,6 +419,9 @@ extern unsigned char *_cpp_next_chunk\tPARAMS ((cpp_pool *, unsigned int,\n extern void _cpp_lock_pool\t\tPARAMS ((cpp_pool *));\n extern void _cpp_unlock_pool\t\tPARAMS ((cpp_pool *));\n \n+/* In cppinit.c.  */\n+extern bool _cpp_push_next_buffer\tPARAMS ((cpp_reader *));\n+\n /* In cpplib.c */\n extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));\n extern int _cpp_handle_directive PARAMS ((cpp_reader *, int));"}, {"sha": "0c4aa01da973b867525357954e18b5768c27456f", "filename": "gcc/cppinit.c", "status": "modified", "additions": 94, "deletions": 72, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -105,9 +105,9 @@ static struct search_path * remove_dup_dir\tPARAMS ((cpp_reader *,\n static struct search_path * remove_dup_dirs PARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct search_path *));\n static void merge_include_chains\tPARAMS ((cpp_reader *));\n-static void do_includes\t\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct pending_option *,\n-\t\t\t\t\t\t int));\n+static bool push_include\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t struct pending_option *));\n+static void free_chain\t\t\tPARAMS ((struct pending_option *));\n static void set_lang\t\t\tPARAMS ((cpp_reader *, enum c_lang));\n static void init_dependency_output\tPARAMS ((cpp_reader *));\n static void init_standard_includes\tPARAMS ((cpp_reader *));\n@@ -867,36 +867,38 @@ init_standard_includes (pfile)\n     }\n }\n \n-/* Handles -imacro and -include from the command line.  */\n-static void\n-do_includes (pfile, p, scan)\n+/* Pushes a -imacro and -include file given on the command line onto\n+   the buffer stack.  Returns non-zero if successful.  */\n+static bool\n+push_include (pfile, p)\n      cpp_reader *pfile;\n      struct pending_option *p;\n-     int scan;\n {\n-  while (p)\n-    {\n-      struct pending_option *q;\n+  cpp_token header;\n \n-      /* Don't handle if -fpreprocessed.  Later: maybe update this to\n-\t use the #include \"\" search path if cpp_read_file fails.  */\n-      if (CPP_OPTION (pfile, preprocessed))\n-\tcpp_error (pfile, \"-include and -imacros cannot be used with -fpreprocessed\");\n-      else\n-\t{\n-\t  cpp_token header;\n-\t  header.type = CPP_STRING;\n-\t  header.val.str.text = (const unsigned char *) p->arg;\n-\t  header.val.str.len = strlen (p->arg);\n-\t  if (_cpp_execute_include (pfile, &header, IT_CMDLINE) && scan)\n-\t    {\n-\t      pfile->buffer->return_at_eof = true;\n-\t      cpp_scan_nooutput (pfile);\n-\t    }\n-\t}\n-      q = p->next;\n-      free (p);\n-      p = q;\n+  /* Later: maybe update this to use the #include \"\" search path\n+     if cpp_read_file fails.  */\n+  header.type = CPP_STRING;\n+  header.val.str.text = (const unsigned char *) p->arg;\n+  header.val.str.len = strlen (p->arg);\n+  /* Make the command line directive take up a line.  */\n+  pfile->lexer_pos.line = pfile->lexer_pos.output_line = ++pfile->line;\n+\n+  return _cpp_execute_include (pfile, &header, IT_CMDLINE);\n+}\n+\n+/* Frees a pending_option chain.  */\n+static void\n+free_chain (head)\n+     struct pending_option *head;\n+{\n+  struct pending_option *next;\n+\n+  while (head)\n+    {\n+      next = head->next;\n+      free (head);\n+      head = next;\n     }\n }\n \n@@ -908,8 +910,6 @@ cpp_start_read (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  struct pending_option *p, *q;\n-\n   /* Set up the include search path now.  */\n   if (! CPP_OPTION (pfile, no_standard_includes))\n     init_standard_includes (pfile);\n@@ -939,42 +939,73 @@ cpp_start_read (pfile, fname)\n   if (!_cpp_read_file (pfile, fname))\n     return 0;\n \n-  /* FIXME: we want to set up linemaps with _(\"<builtin>\") and\n-     _(\"<command line>\") somewhere round here.  Harder than it looks.  */\n-\n-  /* If already preprocessed, don't install __LINE__, etc., and ignore\n-     command line definitions and assertions.  Handle -U's, -D's and\n-     -A's in the order they were seen.  */\n+  /* Install builtins and process command line macros etc. in the order\n+     they appeared, but only if not already preprocessed.  */\n   if (! CPP_OPTION (pfile, preprocessed))\n-    init_builtins (pfile);\n-\n-  p = CPP_OPTION (pfile, pending)->directive_head;\n-  while (p)\n     {\n-      if (! CPP_OPTION (pfile, preprocessed))\n+      struct pending_option *p;\n+\n+      _cpp_do_file_change (pfile, LC_RENAME, _(\"<builtin>\"), 1, 0);\n+      init_builtins (pfile);\n+      _cpp_do_file_change (pfile, LC_RENAME, _(\"<command line>\"), 1, 0);\n+      for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n \t(*p->handler) (pfile, p->arg);\n-      q = p->next;\n-      free (p);\n-      p = q;\n+\n+      /* Scan -imacros files after command line defines, but before\n+\t files given with -include.  */\n+      for (p = CPP_OPTION (pfile, pending)->imacros_head; p; p = p->next)\n+\t{\n+\t  if (push_include (pfile, p))\n+\t    {\n+\t      pfile->buffer->return_at_eof = true;\n+\t      cpp_scan_nooutput (pfile);\n+\t    }\n+\t}\n     }\n \n-  /* Hopefully a short-term kludge.  We stacked the main file at line\n-     zero.  The intervening macro definitions have messed up line\n-     numbering, so we need to restore it.  */\n-  pfile->lexer_pos.output_line = pfile->line = 0;\n+  free_chain (CPP_OPTION (pfile, pending)->directive_head);\n+  free_chain (CPP_OPTION (pfile, pending)->imacros_head);\n+  _cpp_push_next_buffer (pfile);\n \n-  /* The -imacros files can be scanned now, but the -include files\n-     have to be pushed onto the buffer stack and processed later,\n-     otherwise cppmain.c won't see the tokens.  include_head was built\n-     up as a stack, and popping this stack onto the buffer stack means\n-     we preserve the order of the command line.  */\n-  do_includes (pfile, CPP_OPTION (pfile, pending)->imacros_head, 1);\n-  do_includes (pfile, CPP_OPTION (pfile, pending)->include_head, 0);\n+  return 1;\n+}\n \n-  free (CPP_OPTION (pfile, pending));\n-  CPP_OPTION (pfile, pending) = NULL;\n+/* Called to push the next buffer on the stack given by -include.  If\n+   there are none, free the pending structure and restore the line map\n+   for the main file.  */\n+bool\n+_cpp_push_next_buffer (pfile)\n+     cpp_reader *pfile;\n+{\n+  bool pushed = false;\n \n-  return 1;\n+  if (CPP_OPTION (pfile, pending))\n+    {\n+      while (!pushed)\n+\t{\n+\t  struct pending_option *p = CPP_OPTION (pfile, pending)->include_head;\n+\n+\t  if (p == NULL)\n+\t    break;\n+\t  if (! CPP_OPTION (pfile, preprocessed))\n+\t    pushed = push_include (pfile, p);\n+\t  CPP_OPTION (pfile, pending)->include_head = p->next;\n+\t  free (p);\n+\t}\n+\n+      if (!pushed)\n+\t{\n+\t  free (CPP_OPTION (pfile, pending));\n+\t  CPP_OPTION (pfile, pending) = NULL;\n+\n+\t  /* Restore the line map for the main file.  */\n+\t  if (! CPP_OPTION (pfile, preprocessed))\n+\t    _cpp_do_file_change (pfile, LC_RENAME,\n+\t\t\t\t pfile->line_maps.maps[0].to_file, 1, 0);\n+\t}\n+    }\n+\n+  return pushed;\n }\n \n /* Use mkdeps.c to output dependency information.  */\n@@ -1563,26 +1594,17 @@ cpp_handle_option (pfile, argc, argv)\n \t  append_include_chain (pfile, xstrdup (arg), SYSTEM, 0);\n \t  break;\n \tcase OPT_include:\n-\t  {\n-\t    struct pending_option *o = (struct pending_option *)\n-\t      xmalloc (sizeof (struct pending_option));\n-\t    o->arg = arg;\n-\n-\t    /* This list has to be built in reverse order so that\n-\t       when cpp_start_read pushes all the -include files onto\n-\t       the buffer stack, they will be scanned in forward order.  */\n-\t    o->next = pend->include_head;\n-\t    pend->include_head = o;\n-\t  }\n-\t  break;\n \tcase OPT_imacros:\n \t  {\n \t    struct pending_option *o = (struct pending_option *)\n \t      xmalloc (sizeof (struct pending_option));\n \t    o->arg = arg;\n \t    o->next = NULL;\n \n-\t    APPEND (pend, imacros, o);\n+\t    if (opt_code == OPT_include)\n+\t      APPEND (pend, include, o);\n+\t    else\n+\t      APPEND (pend, imacros, o);\n \t  }\n \t  break;\n \tcase OPT_iwithprefix:"}, {"sha": "a24acabd5789bc7d621726e968382eb447e132d7", "filename": "gcc/cpplex.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -890,30 +890,33 @@ _cpp_lex_token (pfile, result)\n   switch (c)\n     {\n     case EOF:\n+      /* Non-empty files should end in a newline.  Don't warn for\n+\t command line and _Pragma buffers.  */\n+      if (pfile->lexer_pos.col != 0)\n+\t{\n+\t  /* Account for the missing \\n, prevent multiple warnings.  */\n+\t  pfile->line++;\n+\t  pfile->lexer_pos.col = 0;\n+\t  if (!buffer->from_stage3)\n+\t    cpp_pedwarn (pfile, \"no newline at end of file\");\n+\t}\n+\n       /* To prevent bogus diagnostics, only pop the buffer when\n \t in-progress directives and arguments have been taken care of.\n \t Decrement the line to terminate an in-progress directive.  */\n       if (pfile->state.in_directive)\n \tpfile->lexer_pos.output_line = pfile->line--;\n       else if (! pfile->state.parsing_args)\n \t{\n-\t  /* Non-empty files should end in a newline.  Don't warn for\n-\t     command line and _Pragma buffers.  */\n-\t  if (pfile->lexer_pos.col != 0)\n-\t    {\n-\t      /* Account for the missing \\n, prevent multiple warnings.  */\n-\t      pfile->line++;\n-\t      pfile->lexer_pos.col = 0;\n-\t      if (!buffer->from_stage3)\n-\t\tcpp_pedwarn (pfile, \"no newline at end of file\");\n-\t    }\n-\n-\t  /* Don't pop the last file.  */\n+\t  /* Don't pop the last buffer.  */\n \t  if (buffer->prev)\n \t    {\n \t      unsigned char stop = buffer->return_at_eof;\n \n \t      _cpp_pop_buffer (pfile);\n+\t      /* Push the next -included file, if any.  */\n+\t      if (!pfile->buffer->prev)\n+\t\t_cpp_push_next_buffer (pfile);\n \t      if (!stop)\n \t\tgoto next_token;\n \t    }"}, {"sha": "e02ab696c85c57325e68c2d8368c56f09b181f42", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -226,6 +226,7 @@ start_directive (pfile)\n \n   /* Some handlers need the position of the # for diagnostics.  */\n   pfile->directive_pos = pfile->lexer_pos;\n+  pfile->directive_pos.line = pfile->line;\n   pfile->directive_line = pfile->line;\n \n   /* Don't save directive tokens for external clients.  */"}, {"sha": "b710dadc576ca0046f3cff2f37f5380fa0208bc2", "filename": "gcc/cppmain.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bc7a9850ac55871f1108c491585118e10afd04/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=d7bc7a9850ac55871f1108c491585118e10afd04", "patch": "@@ -399,11 +399,17 @@ cb_file_change (pfile, map)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const struct line_map *map;\n {\n-  /* Not first time?  */\n-  if (print.map)\n-    {\n-      const char *flags = \"\";\n+  const char *flags = \"\";\n \n+  /* First time?  */\n+  if (print.map == NULL)\n+    {\n+      /* Avoid printing foo.i when the main file is foo.c.  */\n+      if (!options->preprocessed)\n+\tprint_line (map, map->from_line, flags);\n+    }\n+  else\n+    {\n       /* Bring current file to correct line when entering a new file.  */\n       if (map->reason == LC_ENTER)\n \tmaybe_print_line (map - 1, map->from_line - 1);\n@@ -412,7 +418,6 @@ cb_file_change (pfile, map)\n \tflags = \" 1\";\n       else if (map->reason == LC_LEAVE)\n \tflags = \" 2\";\n-\n       print_line (map, map->from_line, flags);\n     }\n "}]}