{"sha": "6d77ee895770e48e516009e4c72dc7bb481fde50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3N2VlODk1NzcwZTQ4ZTUxNjAwOWU0YzcyZGM3YmI0ODFmZGU1MA==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1992-11-13T01:55:58Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1992-11-13T01:55:58Z"}, "message": "Initial revision\n\nFrom-SVN: r2749", "tree": {"sha": "d99c33df0442721c9be707f27cce26433c68fbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d99c33df0442721c9be707f27cce26433c68fbd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d77ee895770e48e516009e4c72dc7bb481fde50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d77ee895770e48e516009e4c72dc7bb481fde50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d77ee895770e48e516009e4c72dc7bb481fde50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d77ee895770e48e516009e4c72dc7bb481fde50/comments", "author": null, "committer": null, "parents": [{"sha": "b0193a92bcb62746a6018bfe75e4381d38ec3e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0193a92bcb62746a6018bfe75e4381d38ec3e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0193a92bcb62746a6018bfe75e4381d38ec3e6f"}], "stats": {"total": 632, "additions": 632, "deletions": 0}, "files": [{"sha": "2ebee91236cfbbd40f4cd4116554857a43902b01", "filename": "gcc/tree.def", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d77ee895770e48e516009e4c72dc7bb481fde50/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d77ee895770e48e516009e4c72dc7bb481fde50/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=6d77ee895770e48e516009e4c72dc7bb481fde50", "patch": "@@ -0,0 +1,632 @@\n+/* This file contains the definitions and documentation for the\n+   tree codes used in the GNU C compiler.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+ \n+/* The third argument can be:\n+   \"x\" for an exceptional code (fits no category).\n+   \"t\" for a type object code.\n+   \"b\" for a lexical block.\n+   \"c\" for codes for constants.\n+   \"d\" for codes for declarations (also serving as variable refs).\n+   \"r\" for codes for references to storage.\n+   \"<\" for codes for comparison expressions.\n+   \"1\" for codes for unary arithmetic expressions.\n+   \"2\" for codes for binary arithmetic expressions.\n+   \"s\" for codes for expressions with inherent side effects.\n+   \"e\" for codes for other kinds of expressions.  */\n+\n+/* For `r', `e', `<', `1', `2', `s' and `x' nodes,\n+   the 4th element is the number of argument slots to allocate.\n+   This determines the size of the tree node object.  */\n+\n+/* Any erroneous construct is parsed into a node of this type.\n+   This type of node is accepted without complaint in all contexts\n+   by later parsing activities, to avoid multiple error messages\n+   for one error.\n+   No fields in these nodes are used except the TREE_CODE.  */\n+DEFTREECODE (ERROR_MARK, \"error_mark\", \"x\", 0)\n+\n+/* Used to represent a name (such as, in the DECL_NAME of a decl node).\n+   Internally it looks like a STRING_CST node.\n+   There is only one IDENTIFIER_NODE ever made for any particular name.\n+   Use `get_identifier' to get it (or create it, the first time).  */\n+DEFTREECODE (IDENTIFIER_NODE, \"identifier_node\", \"x\", -1)\n+\n+/* Used to hold information to identify an operator (or combination\n+   of two operators) considered as a `noun' rather than a `verb'.\n+   The first operand is encoded in the TREE_TYPE field.  */\n+DEFTREECODE (OP_IDENTIFIER, \"op_identifier\", \"x\", 2)\n+\n+/* Has the TREE_VALUE and TREE_PURPOSE fields.  */\n+/* These nodes are made into lists by chaining through the\n+   TREE_CHAIN field.  The elements of the list live in the\n+   TREE_VALUE fields, while TREE_PURPOSE fields are occasionally\n+   used as well to get the effect of Lisp association lists.  */\n+DEFTREECODE (TREE_LIST, \"tree_list\", \"x\", 2)\n+\n+/* These nodes contain an array of tree nodes.  */\n+DEFTREECODE (TREE_VEC, \"tree_vec\", \"x\", 2)\n+\n+/* A symbol binding block.  These are arranged in a tree,\n+   where the BLOCK_SUBBLOCKS field contains a chain of subblocks\n+   chained through the BLOCK_CHAIN field.\n+   BLOCK_SUPERCONTEXT points to the parent block.\n+     For a block which represents the outermost scope of a function, it\n+     points to the FUNCTION_DECL node.\n+   BLOCK_VARS points to a chain of decl nodes.\n+   BLOCK_TYPE_TAGS points to a chain of types which have their own names.\n+   BLOCK_CHAIN points to the next BLOCK at the same level.\n+   BLOCK_ABSTRACT_ORIGIN points to the original (abstract) tree node which\n+   this block is an instance of, or else is NULL to indicate that this\n+   block is not an instance of anything else.  When non-NULL, the value\n+   could either point to another BLOCK node or it could point to a\n+   FUNCTION_DECL node (e.g. in the case of a block representing the\n+   outermost scope of a particular inlining of a function).\n+   BLOCK_ABSTRACT is non-zero if the block represents an abstract\n+   instance of a block (i.e. one which is nested within an abstract\n+   instance of a inline function. */\n+DEFTREECODE (BLOCK, \"block\", \"b\", 0)\n+\f\n+/* Each data type is represented by a tree node whose code is one of\n+   the following:  */\n+/* Each node that represents a data type has a component TYPE_SIZE\n+   containing a tree that is an expression for the size in bits.\n+   The TYPE_MODE contains the machine mode for values of this type.\n+   The TYPE_POINTER_TO field contains a type for a pointer to this type,\n+     or zero if no such has been created yet.\n+   The TYPE_NEXT_VARIANT field is used to chain together types\n+     that are variants made by type modifiers such as \"const\" and \"volatile\".\n+   The TYPE_MAIN_VARIANT field, in any member of such a chain,\n+     points to the start of the chain.\n+   The TYPE_NONCOPIED_PARTS field is a list specifying which parts\n+     of an object of this type should *not* be copied by assignment.\n+     The TREE_PURPOSE of each element is the offset of the part\n+     and the TREE_VALUE is the size in bits of the part.\n+   The TYPE_NAME field contains info on the name used in the program\n+     for this type (for GDB symbol table output).  It is either a\n+     TYPE_DECL node, for types that are typedefs, or an IDENTIFIER_NODE\n+     in the case of structs, unions or enums that are known with a tag,\n+     or zero for types that have no special name.\n+   The TYPE_CONTEXT for any sort of type which could have a name or\n+    which could have named members (e.g. tagged types in C/C++) will\n+    point to the node which represents the scope of the given type, or\n+    will be NULL_TREE if the type has \"file scope\".  For most types, this\n+    will point to a BLOCK node or a FUNCTION_DECL node, but it could also\n+    point to a FUNCTION_TYPE node (for types whose scope is limited to the\n+    formal parameter list of some function type specification) or it\n+    could point to a RECORD_TYPE or UNION_TYPE node (for C++ \"member\" types).\n+    For non-tagged-types, TYPE_CONTEXT need not be set to anything in\n+    particular, since any type which is of some type category  (e.g.\n+    an array type or a function type) which cannot either have a name\n+    itself or have named members doesn't really have a \"scope\" per se.  */\n+/* TREE_CHAIN is used for ENUMERAL_TYPE, RECORD_TYPE and UNION_TYPE\n+   nodes used as forward-references to names; see below.  */\n+\n+DEFTREECODE (VOID_TYPE, \"void_type\", \"t\", 0)\t/* The void type in C */\n+\n+/* Integer types in all languages, including char in C.  */\n+/* Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)\n+   and TYPE_PRECISION (number of bits used by this type).\n+   In the case of a subrange type in Pascal, the TREE_TYPE\n+   of this will point at the supertype (another INTEGER_TYPE).\n+   Otherwise, the TREE_TYPE is zero.  */\n+DEFTREECODE (INTEGER_TYPE, \"integer_type\", \"t\", 0)\n+\n+/* C's float and double.  Different floating types are distinguished\n+   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\n+DEFTREECODE (REAL_TYPE, \"real_type\", \"t\", 0)\n+\n+/* Complex number types.  The TREE_TYPE field is the data type\n+   of the real and imaginary parts.  */\n+DEFTREECODE (COMPLEX_TYPE, \"complex_type\", \"t\", 0)\n+\n+/* C enums.  The type node looks just like an INTEGER_TYPE node.\n+   The symbols for the values of the enum type are defined by\n+   CONST_DECL nodes, but the type does not point to them;\n+   however, the TREE_VALUES is a list in which each elements' TREE_PURPOSE\n+   is a name and the TREE_VALUE is the value (an INTEGER_CST node).  */\n+/* A forward reference `enum foo' when no enum named foo is defined yet\n+   has zero (a null pointer) in its TYPE_SIZE.  The tag name is in\n+   the TYPE_NAME field.  If the type is later defined, the normal\n+   fields are filled in.\n+   RECORD_TYPE and UNION_TYPE forward refs are treated similarly.  */\n+DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", \"t\", 0)\n+\n+/* Pascal's boolean type (true or false are the only values);\n+   no special fields needed.  */\n+DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", \"t\", 0)\n+\n+/* CHAR in Pascal; not used in C.\n+   No special fields needed.  */\n+DEFTREECODE (CHAR_TYPE, \"char_type\", \"t\", 0)\n+\n+/* All pointer-to-x types have code POINTER_TYPE.\n+   The TREE_TYPE points to the node for the type pointed to.  */\n+DEFTREECODE (POINTER_TYPE, \"pointer_type\", \"t\", 0)\n+\n+/* An offset is a pointer relative to an object.\n+   The TREE_TYPE field is the type of the object at the offset.\n+   The TYPE_OFFSET_BASETYPE points to the node for the type of object\n+   that the offset is relative to.  */\n+DEFTREECODE (OFFSET_TYPE, \"offset_type\", \"t\", 0)\n+\n+/* A reference is like a pointer except that it is coerced\n+   automatically to the value it points to.  Used in C++.  */\n+DEFTREECODE (REFERENCE_TYPE, \"reference_type\", \"t\", 0)\n+\n+/* METHOD_TYPE is the type of a function which takes an extra first\n+   argument for \"self\", which is not present in the declared argument list.\n+   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n+   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n+   includes the hidden argument for \"self\".  */\n+DEFTREECODE (METHOD_TYPE, \"method_type\", \"t\", 0)\n+\n+/* Used for Pascal; details not determined right now.  */\n+DEFTREECODE (FILE_TYPE, \"file_type\", \"t\", 0)\n+\n+/* Types of arrays.  Special fields:\n+   TREE_TYPE\t\t  Type of an array element.\n+   TYPE_DOMAIN\t\t  Type to index by.\n+\t\t\t    Its range of values specifies the array length.\n+   TYPE_SEP\t\t  Expression for units from one elt to the next.\n+   TYPE_SEP_UNIT\t  Number of bits in a unit for previous.\n+ The field TYPE_POINTER_TO (TREE_TYPE (array_type)) is always nonzero\n+ and holds the type to coerce a value of that array type to in C.  */\n+/* Array types in C or Pascal */\n+DEFTREECODE (ARRAY_TYPE, \"array_type\", \"t\", 0)\n+\n+/* Types of sets for Pascal.  Special fields are the same as\n+   in an array type.  The target type is always a boolean type.  */\n+DEFTREECODE (SET_TYPE, \"set_type\", \"t\", 0)\n+\n+/* Not known whether Pascal really needs this\n+   or what it should contain.  */\n+DEFTREECODE (STRING_TYPE, \"string_type\", \"t\", 0)\n+\n+/* Struct in C, or record in Pascal.  */\n+/* Special fields:\n+   TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct.\n+   A few may need to be added for Pascal.  */\n+/* See the comment above, before ENUMERAL_TYPE, for how\n+   forward references to struct tags are handled in C.  */\n+DEFTREECODE (RECORD_TYPE, \"record_type\", \"t\", 0)\n+\n+/* Union in C.  Like a struct, except that the offsets of the fields\n+   will all be zero.  */\n+/* See the comment above, before ENUMERAL_TYPE, for how\n+   forward references to union tags are handled in C.  */\n+DEFTREECODE (UNION_TYPE, \"union_type\", \"t\", 0)\t/* C union type */\n+\n+/* Type of functions.  Special fields:\n+   TREE_TYPE\t\t    type of value returned.\n+   TYPE_ARG_TYPES      list of types of arguments expected.\n+\tthis list is made of TREE_LIST nodes.\n+   Types of \"Procedures\" in languages where they are different from functions\n+   have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\n+DEFTREECODE (FUNCTION_TYPE, \"function_type\", \"t\", 0)\n+\n+/* This is a language-specific kind of type.\n+   Its meaning is defined by the language front end.\n+   layout_type does not know how to lay this out,\n+   so the front-end must do so manually.  */\n+DEFTREECODE (LANG_TYPE, \"lang_type\", \"t\", 0)\n+\f\n+/* Expressions */\n+\n+/* First, the constants.  */\n+\n+/* Contents are in TREE_INT_CST_LOW and TREE_INT_CST_HIGH fields,\n+   32 bits each, giving us a 64 bit constant capability.\n+   Note: constants of type char in Pascal are INTEGER_CST,\n+   and so are pointer constants such as nil in Pascal or NULL in C.\n+   `(int *) 1' in C also results in an INTEGER_CST.  */\n+DEFTREECODE (INTEGER_CST, \"integer_cst\", \"c\", 2)\n+\n+/* Contents are in TREE_REAL_CST field.  Also there is TREE_CST_RTL.  */\n+DEFTREECODE (REAL_CST, \"real_cst\", \"c\", 3)\n+\n+/* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n+   whose contents are other constant nodes.\n+   Also there is TREE_CST_RTL.  */\n+DEFTREECODE (COMPLEX_CST, \"complex_cst\", \"c\", 3)\n+\n+/* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.\n+   Also there is TREE_CST_RTL.  */\n+DEFTREECODE (STRING_CST, \"string_cst\", \"c\", 3)\n+\n+/* Declarations.  All references to names are represented as ..._DECL nodes.\n+   The decls in one binding context are chained through the TREE_CHAIN field.\n+   Each DECL has a DECL_NAME field which contains an IDENTIFIER_NODE.\n+    (Some decls, most often labels, may have zero as the DECL_NAME).\n+   DECL_CONTEXT points to the node representing the context in which\n+    this declaration has its scope.  For FIELD_DECLs, this is the\n+    RECORD_TYPE or UNION_TYPE node that the field is a member of.  For\n+    VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes,\n+    this points to the FUNCTION_DECL for the containing function, or else\n+    yields NULL_TREE if the given decl has \"file scope\".\n+   DECL_ABSTRACT_ORIGIN, if non-NULL, points to the original (abstract)\n+    ..._DECL node of which this decl is an (inlined or template expanded)\n+    instance.\n+   The TREE_TYPE field holds the data type of the object, when relevant.\n+    LABEL_DECLs have no data type.  For TYPE_DECL, the TREE_TYPE field\n+    contents are the type whose name is being declared.\n+   The DECL_ALIGN, DECL_SIZE,\n+    and DECL_MODE fields exist in decl nodes just as in type nodes.\n+    They are unused in LABEL_DECL, TYPE_DECL and CONST_DECL nodes.\n+\n+   DECL_OFFSET holds an integer number of bits offset for the location.\n+   DECL_VOFFSET holds an expression for a variable offset; it is\n+   to be multiplied by DECL_VOFFSET_UNIT (an integer).\n+   These fields are relevant only in FIELD_DECLs and PARM_DECLs.\n+\n+   DECL_INITIAL holds the value to initialize a variable to,\n+   or the value of a constant.  For a function, it holds the body\n+   (a node of type BLOCK representing the function's binding contour\n+   and whose body contains the function's statements.)  For a LABEL_DECL\n+   in C, it is a flag, nonzero if the label's definition has been seen.\n+\n+   PARM_DECLs use a special field:\n+   DECL_ARG_TYPE is the type in which the argument is actually\n+    passed, which may be different from its type within the function.\n+\n+   FUNCTION_DECLs use four special fields:\n+   DECL_ARGUMENTS holds a chain of PARM_DECL nodes for the arguments.\n+   DECL_RESULT holds a RESULT_DECL node for the value of a function,\n+    or it is 0 for a function that returns no value.\n+    (C functions returning void have zero here.)\n+   DECL_RESULT_TYPE holds the type in which the result is actually\n+    returned.  This is usually the same as the type of DECL_RESULT,\n+    but (1) it may be a wider integer type and\n+    (2) it remains valid, for the sake of inlining, even after the\n+    function's compilation is done.\n+   DECL_FUNCTION_CODE is a code number that is nonzero for\n+    built-in functions.  Its value is an enum built_in_function\n+    that says which built-in function it is.\n+\n+   DECL_SOURCE_FILE holds a filename string and DECL_SOURCE_LINE\n+   holds a line number.  In some cases these can be the location of\n+   a reference, if no definition has been seen.\n+\n+   DECL_ABSTRACT is non-zero if the decl represents an abstract instance\n+   of a decl (i.e. one which is nested within an abstract instance of a\n+   inline function.  */\n+\n+DEFTREECODE (FUNCTION_DECL, \"function_decl\", \"d\", 0)\n+DEFTREECODE (LABEL_DECL, \"label_decl\", \"d\", 0)\n+DEFTREECODE (CONST_DECL, \"const_decl\", \"d\", 0)\n+DEFTREECODE (TYPE_DECL, \"type_decl\", \"d\", 0)\n+DEFTREECODE (VAR_DECL, \"var_decl\", \"d\", 0)\n+DEFTREECODE (PARM_DECL, \"parm_decl\", \"d\", 0)\n+DEFTREECODE (RESULT_DECL, \"result_decl\", \"d\", 0)\n+DEFTREECODE (FIELD_DECL, \"field_decl\", \"d\", 0)\n+\f\n+/* References to storage.  */\n+\n+/* Value is structure or union component.\n+   Operand 0 is the structure or union (an expression);\n+   operand 1 is the field (a node of type FIELD_DECL).  */\n+DEFTREECODE (COMPONENT_REF, \"component_ref\", \"r\", 2)\n+\n+/* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n+   except the position is given explicitly rather than via a FIELD_DECL.\n+   Operand 0 is the structure or union expression;\n+   operand 1 is a tree giving the number of bits being referenced;\n+   operand 2 is a tree giving the position of the first referenced bit.\n+   The field can be either a signed or unsigned field;\n+   TREE_UNSIGNED says which.  */\n+DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", \"r\", 3)\n+   \n+/* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n+DEFTREECODE (INDIRECT_REF, \"indirect_ref\", \"r\", 1)\n+\n+/* Reference to the contents of an offset\n+   (a value whose type is an OFFSET_TYPE).\n+   Operand 0 is the object within which the offset is taken.\n+   Operand 1 is the offset.  */\n+DEFTREECODE (OFFSET_REF, \"offset_ref\", \"r\", 2)\n+\n+/* Pascal `^` on a file.  One operand, an expression for the file.  */\n+DEFTREECODE (BUFFER_REF, \"buffer_ref\", \"r\", 1)\n+\n+/* Array indexing in languages other than C.\n+   Operand 0 is the array; operand 1 is a list of indices\n+   stored as a chain of TREE_LIST nodes.  */\n+DEFTREECODE (ARRAY_REF, \"array_ref\", \"r\", 2)\n+\n+/* Constructor: return an aggregate value made from specified components.\n+   In C, this is used only for structure and array initializers.\n+   The first \"operand\" is really a pointer to the RTL,\n+   for constant constructors only.\n+   The second operand is a list of component values\n+   made out of a chain of TREE_LIST nodes.  */\n+DEFTREECODE (CONSTRUCTOR, \"constructor\", \"e\", 2)\n+\n+/* The expression types are mostly straightforward,\n+   with the fourth argument of DEFTREECODE saying\n+   how many operands there are.\n+   Unless otherwise specified, the operands are expressions.  */\n+\n+/* Contains two expressions to compute, one followed by the other.\n+   the first value is ignored.  The second one's value is used.  */\n+DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", \"e\", 2)\n+\n+/* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\n+DEFTREECODE (MODIFY_EXPR, \"modify_expr\", \"e\", 2)\n+\n+/* Initialization expression.  Operand 0 is the variable to initialize;\n+   Operand 1 is the initializer.  */\n+DEFTREECODE (INIT_EXPR, \"init_expr\", \"e\", 2)\n+\n+/* For TARGET_EXPR, operand 0 is the target of an initialization,\n+   operand 1 is the initializer for the target,\n+   and operand 2 is the cleanup for this node, if any.  */\n+DEFTREECODE (TARGET_EXPR, \"target_expr\", \"e\", 3)\n+\n+/* Conditional expression ( ... ? ... : ...  in C).\n+   Operand 0 is the condition.\n+   Operand 1 is the then-value.\n+   Operand 2 is the else-value.  */\n+DEFTREECODE (COND_EXPR, \"cond_expr\", \"e\", 3)\n+\n+/* Declare local variables, including making RTL and allocating space.\n+   Operand 0 is a chain of VAR_DECL nodes for the variables.\n+   Operand 1 is the body, the expression to be computed using \n+   the variables.  The value of operand 1 becomes that of the BIND_EXPR.\n+   Operand 2 is the BLOCK that corresponds to these bindings\n+   for debugging purposes.  If this BIND_EXPR is actually expanded,\n+   that sets the TREE_USED flag in the BLOCK.\n+\n+   The BIND_EXPR is not responsible for informing parsers\n+   about these variables.  If the body is coming from the input file,\n+   then the code that creates the BIND_EXPR is also responsible for \n+   informing the parser of the variables.\n+\n+   If the BIND_EXPR is ever expanded, its TREE_USED flag is set.\n+   This tells the code for debugging symbol tables not to ignore the BIND_EXPR.\n+   If the BIND_EXPR should be output for debugging but will not be expanded, \n+   set the TREE_USED flag by hand.\n+\n+   In order for the BIND_EXPR to be known at all, the code that creates it\n+   must also install it as a subblock in the tree of BLOCK\n+   nodes for the function.  */\n+DEFTREECODE (BIND_EXPR, \"bind_expr\", \"e\", 3)\n+\n+/* Function call.  Operand 0 is the function.\n+   Operand 1 is the argument list, a list of expressions\n+   made out of a chain of TREE_LIST nodes.\n+   There is no operand 2.  That slot is used for the\n+   CALL_EXPR_RTL macro (see preexpand_calls).  */\n+DEFTREECODE (CALL_EXPR, \"call_expr\", \"e\", 3)\n+\n+/* Call a method.  Operand 0 is the method, whose type is a METHOD_TYPE.\n+   Operand 1 is the expression for \"self\".\n+   Operand 2 is the list of explicit arguments.  */\n+DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n+\n+/* Specify a value to compute along with its corresponding cleanup.\n+   Operand 0 argument is an expression whose value needs a cleanup.\n+   Operand 1 is an RTL_EXPR which will eventually represent that value.\n+   Operand 2 is the cleanup expression for the object.\n+     The RTL_EXPR is used in this expression, which is how the expression\n+     manages to act on the proper value.\n+   The cleanup is executed when the value is no longer needed,\n+   which is not at precisely the same time that this value is computed.  */\n+DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n+\n+/* Simple arithmetic.  Operands must have the same machine mode\n+   and the value shares that mode.  */\n+DEFTREECODE (PLUS_EXPR, \"plus_expr\", \"2\", 2)\n+DEFTREECODE (MINUS_EXPR, \"minus_expr\", \"2\", 2)\n+DEFTREECODE (MULT_EXPR, \"mult_expr\", \"2\", 2)\n+\n+/* Division for integer result that rounds the quotient toward zero.  */\n+/* Operands must have the same machine mode.\n+   In principle they may be real, but that is not currently supported.\n+   The result is always fixed point, and it has the same type as the\n+   operands if they are fixed point.   */\n+DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", \"2\", 2)\n+\n+/* Division for integer result that rounds the quotient toward infinity.  */\n+DEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", \"2\", 2)\n+\n+/* Division for integer result that rounds toward minus infinity.  */\n+DEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", \"2\", 2)\n+\n+/* Division for integer result that rounds toward nearest integer.  */\n+DEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", \"2\", 2)\n+\n+/* Four kinds of remainder that go with the four kinds of division.  */\n+DEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", \"2\", 2)\n+DEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", \"2\", 2)\n+DEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", \"2\", 2)\n+DEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", \"2\", 2)\n+\n+/* Division for real result.  The two operands must have the same type.\n+   In principle they could be integers, but currently only real\n+   operands are supported.  The result must have the same type\n+   as the operands.  */\n+DEFTREECODE (RDIV_EXPR, \"rdiv_expr\", \"2\", 2)\n+\n+/* Division which is not supposed to need rounding.\n+   Used for pointer subtraction in C.  */\n+DEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", \"2\", 2)\n+\n+/* Conversion of real to fixed point: four ways to round,\n+   like the four ways to divide.\n+   CONVERT_EXPR can also be used to convert a real to an integer,\n+   and that is what is used in languages that do not have ways of\n+   specifying which of these is wanted.  Maybe these are not needed.  */\n+DEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", \"1\", 1)\n+DEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", \"1\", 1)\n+DEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", \"1\", 1)\n+DEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", \"1\", 1)\n+\n+/* Conversion of an integer to a real.  */\n+DEFTREECODE (FLOAT_EXPR, \"float_expr\", \"1\", 1)\n+\n+/* Exponentiation.  Operands may have any types;\n+   constraints on value type are not known yet.  */\n+DEFTREECODE (EXPON_EXPR, \"expon_expr\", \"2\", 2)\n+\n+/* Unary negation.  Value has same type as operand.  */\n+DEFTREECODE (NEGATE_EXPR, \"negate_expr\", \"1\", 1)\n+\n+DEFTREECODE (MIN_EXPR, \"min_expr\", \"2\", 2)\n+DEFTREECODE (MAX_EXPR, \"max_expr\", \"2\", 2)\n+DEFTREECODE (ABS_EXPR, \"abs_expr\", \"1\", 1)\n+DEFTREECODE (FFS_EXPR, \"ffs_expr\", \"1\", 1)\n+\n+/* Shift operations for shift and rotate.\n+   Shift is supposed to mean logical shift if done on an\n+   unsigned type, arithmetic shift on a signed type.\n+   The second operand is the number of bits to\n+   shift by, and must always have mode SImode.\n+   The result has the same mode as the first operand.  */\n+DEFTREECODE (LSHIFT_EXPR, \"alshift_expr\", \"2\", 2)\n+DEFTREECODE (RSHIFT_EXPR, \"arshift_expr\", \"2\", 2)\n+DEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", \"2\", 2)\n+DEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", \"2\", 2)\n+\n+/* Bitwise operations.  Operands have same mode as result.  */\n+DEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", \"2\", 2)\n+DEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", \"2\", 2)\n+DEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", \"2\", 2)\n+DEFTREECODE (BIT_ANDTC_EXPR, \"bit_andtc_expr\", \"2\", 2)\n+DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", \"1\", 1)\n+\n+/* Combination of boolean values or of integers considered only\n+   as zero or nonzero.  ANDIF and ORIF allow the second operand\n+   not to be computed if the value of the expression is determined\n+   from the first operand.  AND and OR always compute the second\n+   operand whether its value is needed or not (for side effects).  */\n+DEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", \"e\", 2)\n+DEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", \"e\", 2)\n+DEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", \"2\", 2)\n+DEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", \"2\", 2)\n+DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", \"e\", 1)\n+\n+/* Relational operators.\n+   `EQ_EXPR' and `NE_EXPR' are allowed for any types.\n+   The others are allowed only for integer (or pointer or enumeral)\n+   or real types.\n+   In all cases the operands will have the same type,\n+   and the value is always the type used by the language for booleans.  */\n+DEFTREECODE (LT_EXPR, \"lt_expr\", \"<\", 2)\n+DEFTREECODE (LE_EXPR, \"le_expr\", \"<\", 2)\n+DEFTREECODE (GT_EXPR, \"gt_expr\", \"<\", 2)\n+DEFTREECODE (GE_EXPR, \"ge_expr\", \"<\", 2)\n+DEFTREECODE (EQ_EXPR, \"eq_expr\", \"<\", 2)\n+DEFTREECODE (NE_EXPR, \"ne_expr\", \"<\", 2)\n+\n+/* Operations for Pascal sets.  Not used now.  */\n+DEFTREECODE (IN_EXPR, \"in_expr\", \"2\", 2)\n+DEFTREECODE (SET_LE_EXPR, \"set_le_expr\", \"<\", 2)\n+DEFTREECODE (CARD_EXPR, \"card_expr\", \"1\", 1)\n+DEFTREECODE (RANGE_EXPR, \"range_expr\", \"2\", 2)\n+\n+/* Represents a conversion of type of a value.\n+   All conversions, including implicit ones, must be\n+   represented by CONVERT_EXPR nodes.  */\n+DEFTREECODE (CONVERT_EXPR, \"convert_expr\", \"1\", 1)\n+\n+/* Represents a conversion expected to require no code to be generated.  */\n+DEFTREECODE (NOP_EXPR, \"nop_expr\", \"1\", 1)\n+\n+/* Value is same as argument, but guaranteed not an lvalue.  */\n+DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", \"1\", 1)\n+\n+/* Represents something we computed once and will use multiple times.\n+   First operand is that expression.  Second is the function decl\n+   in which the SAVE_EXPR was created.  The third operand is the RTL,\n+   nonzero only after the expression has been computed.  */\n+DEFTREECODE (SAVE_EXPR, \"save_expr\", \"e\", 3)\n+\n+/* Represents something whose RTL has already been expanded\n+   as a sequence which should be emitted when this expression is expanded.\n+   The first operand is the RTL to emit.  It is the first of a chain of insns.\n+   The second is the RTL expression for the result.  */\n+DEFTREECODE (RTL_EXPR, \"rtl_expr\", \"e\", 2)\n+\n+/* & in C.  Value is the address at which the operand's value resides.\n+   Operand may have any mode.  Result mode is Pmode.  */\n+DEFTREECODE (ADDR_EXPR, \"addr_expr\", \"e\", 1)\n+\n+/* Non-lvalue reference or pointer to an object.  */\n+DEFTREECODE (REFERENCE_EXPR, \"reference_expr\", \"e\", 1)\n+\n+/* Operand is a function constant; result is a function variable value\n+   of typeEPmode.  Used only for languages that need static chains.  */\n+DEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", \"e\", 1)\n+\n+/* Given two real or integer operands of the same type,\n+   returns a complex value of the corresponding complex type.  */\n+DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", \"2\", 2)\n+\n+/* Complex conjugate of operand.  Used only on complex types.\n+   The value has the same type as the operand.  */\n+DEFTREECODE (CONJ_EXPR, \"conj_expr\", \"1\", 1)\n+\n+/* Used only on an operand of complex type, these return\n+   a value of the corresponding component type.  */\n+DEFTREECODE (REALPART_EXPR, \"realpart_expr\", \"1\", 1)\n+DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", \"1\", 1)\n+\n+/* Nodes for ++ and -- in C.\n+   The second arg is how much to increment or decrement by.\n+   For a pointer, it would be the size of the object pointed to.  */\n+DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", \"e\", 2)\n+DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", \"e\", 2)\n+DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", \"e\", 2)\n+DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", \"e\", 2)\n+\f\n+/* These types of expressions have no useful value,\n+   and always have side effects.  */\n+\n+/* A label definition, encapsulated as a statement.\n+   Operand 0 is the LABEL_DECL node for the label that appears here.\n+   The type should be void and the value should be ignored.  */\n+DEFTREECODE (LABEL_EXPR, \"label_expr\", \"s\", 1)\n+\n+/* GOTO.  Operand 0 is a LABEL_DECL node.\n+   The type should be void and the value should be ignored.  */\n+DEFTREECODE (GOTO_EXPR, \"goto_expr\", \"s\", 1)\n+\n+/* RETURN.  Evaluates operand 0, then returns from the current function.\n+   Presumably that operand is an assignment that stores into the\n+   RESULT_DECL that hold the value to be returned.\n+   The operand may be null.\n+   The type should be void and the value should be ignored.  */\n+DEFTREECODE (RETURN_EXPR, \"return_expr\", \"s\", 1)\n+\n+/* Exit the inner most loop conditionally.  Operand 0 is the condition.\n+   The type should be void and the value should be ignored.  */\n+DEFTREECODE (EXIT_EXPR, \"exit_expr\", \"s\", 1)\n+\n+/* A loop.  Operand 0 is the body of the loop.\n+   It must contain an EXIT_EXPR or is an infinite loop.\n+   The type should be void and the value should be ignored.  */\n+DEFTREECODE (LOOP_EXPR, \"loop_expr\", \"s\", 1)\n+\n+/*\n+Local variables:\n+mode:c\n+version-control: t\n+End:\n+*/"}]}