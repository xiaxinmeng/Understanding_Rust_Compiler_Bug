{"sha": "61ab980a026071f14cb132d01dc1f4c18611b5f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhYjk4MGEwMjYwNzFmMTRjYjEzMmQwMWRjMWY0YzE4NjExYjVmMw==", "commit": {"author": {"name": "Kenneth Block", "email": "kenneth.block@compaq.com", "date": "2000-11-15T11:54:53Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2000-11-15T11:54:53Z"}, "message": "cplus_dem.c: Add gnat demangler.\n\n\t* cplus_dem.c: Add gnat demangler.  Add java to demangle style\n\tlist.\n\nFrom-SVN: r37475", "tree": {"sha": "1256bb9f23d235bd0de14dcec1972e9e7318117c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1256bb9f23d235bd0de14dcec1972e9e7318117c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ab980a026071f14cb132d01dc1f4c18611b5f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ab980a026071f14cb132d01dc1f4c18611b5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ab980a026071f14cb132d01dc1f4c18611b5f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ab980a026071f14cb132d01dc1f4c18611b5f3/comments", "author": null, "committer": null, "parents": [{"sha": "7ecdd10b6d803718d36a2e9537836902ae4fe0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecdd10b6d803718d36a2e9537836902ae4fe0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecdd10b6d803718d36a2e9537836902ae4fe0fa"}], "stats": {"total": 153, "additions": 153, "deletions": 0}, "files": [{"sha": "02b4ce0b505a50b47ab4e4de906ec291609f1d4f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ab980a026071f14cb132d01dc1f4c18611b5f3/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ab980a026071f14cb132d01dc1f4c18611b5f3/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=61ab980a026071f14cb132d01dc1f4c18611b5f3", "patch": "@@ -1,3 +1,8 @@\n+2000-11-15  Kenneth Block <kenneth.block@compaq.com>\n+\n+\t* cplus_dem.c: Add gnat demangler.  Add java to demangle style\n+\tlist.\n+\n 2000-11-04  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* hashtab.c (htab_expand): Change to return int.  Use calloc or"}, {"sha": "53549caf9629fbbddada9327a01826a13925645c", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ab980a026071f14cb132d01dc1f4c18611b5f3/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ab980a026071f14cb132d01dc1f4c18611b5f3/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=61ab980a026071f14cb132d01dc1f4c18611b5f3", "patch": "@@ -52,6 +52,8 @@ char * realloc ();\n \n #include \"libiberty.h\"\n \n+static char *ada_demangle  PARAMS ((const char*, int));\n+\n #define min(X,Y) (((X) < (Y)) ? (X) : (Y))\n \n /* A value at least one greater than the maximum number of characters\n@@ -297,6 +299,18 @@ struct demangler_engine libiberty_demanglers[] =\n     \"GNU (g++) new-ABI-style demangling\"\n   }\n   ,\n+  {\n+    JAVA_DEMANGLING_STYLE_STRING,\n+    java_demangling,\n+    \"Java style demangling\"\n+  }\n+  ,\n+  {\n+    GNAT_DEMANGLING_STYLE_STRING,\n+    gnat_demangling,\n+    \"GNAT style demangling\"\n+  }\n+  ,\n   {\n     NULL, unknown_demangling, NULL\n   }\n@@ -900,12 +914,146 @@ cplus_demangle (mangled, options)\n   if (GNU_NEW_ABI_DEMANGLING)\n     return cplus_demangle_new_abi (mangled);\n \n+  if (GNAT_DEMANGLING)\n+    return ada_demangle(mangled,options);\n+\n   ret = internal_cplus_demangle (work, mangled);\n   squangle_mop_up (work);\n   return (ret);\n }\n \n \n+/* Assuming *OLD_VECT points to an array of *SIZE objects of size\n+   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,\n+   updating *OLD_VECT and *SIZE as necessary. */\n+static void\n+DEFUN (grow_vect, (old_vect, size, min_size, element_size),\n+       void** old_vect\n+       AND size_t* size\n+       AND size_t min_size\n+       AND int element_size)\n+{\n+  if (*size < min_size) {\n+    *size *= 2;\n+    if (*size < min_size)\n+      *size = min_size;\n+    *old_vect = xrealloc (*old_vect, *size * element_size);\n+  }\n+}\n+\n+/* Demangle ada names:\n+   1. Discard final __{DIGIT}+ or ${DIGIT}+\n+   2. Convert other instances of embedded \"__\" to `.'.\n+   3. Discard leading _ada_.\n+   4. Remove everything after first ___ if it is followed by\n+   'X'.\n+   5. Put symbols that should be suppressed in <...> brackets.\n+   The resulting string is valid until the next call of ada_demangle.\n+*/\n+static char *\n+DEFUN (ada_demangle, (mangled, style, option),\n+       const char* mangled\n+       AND int option ATTRIBUTE_UNUSED)\n+{\n+  int i, j;\n+  int len0;\n+  const char* p;\n+  char* demangled = NULL;\n+  int at_start_name;\n+  int changed;\n+  char* demangling_buffer = NULL;\n+  size_t demangling_buffer_size = 0;\n+  \n+  changed = 0;\n+\n+  if (strncmp (mangled, \"_ada_\", 5) == 0)\n+    {\n+      mangled += 5;\n+      changed = 1;\n+    }\n+  \n+  if (mangled[0] == '_' || mangled[0] == '<')\n+    goto Suppress;\n+  \n+  p = strstr (mangled, \"___\");\n+  if (p == NULL)\n+    len0 = strlen (mangled);\n+  else\n+    {\n+      if (p[3] == 'X')\n+\t{\n+\t  len0 = p - mangled;\n+\t  changed = 1;\n+\t}\n+      else\n+\tgoto Suppress;\n+    }\n+  \n+  /* Make demangled big enough for possible expansion by operator name. */\n+  grow_vect ((void**) &(demangling_buffer),\n+\t     &demangling_buffer_size,  2 * len0 + 1,\n+\t     sizeof (char));\n+  demangled = demangling_buffer;\n+  \n+  if (isdigit (mangled[len0 - 1])) {\n+    for (i = len0-2; i >= 0 && isdigit (mangled[i]); i -= 1)\n+      ;\n+    if (i > 1 && mangled[i] == '_' && mangled[i-1] == '_')\n+      {\n+\tlen0 = i - 1;\n+\tchanged = 1;\n+      }\n+    else if (mangled[i] == '$')\n+      {\n+\tlen0 = i;\n+\tchanged = 1;\n+      }\n+  }\n+  \n+  for (i = 0, j = 0; i < len0 && ! isalpha (mangled[i]); i += 1, j += 1)\n+    demangled[j] = mangled[i];\n+  \n+  at_start_name = 1;\n+  while (i < len0)\n+    {\n+      at_start_name = 0;\n+      \n+      if (i < len0-2 && mangled[i] == '_' && mangled[i+1] == '_')\n+\t{\n+\t  demangled[j] = '.';\n+\t  changed = at_start_name = 1;\n+\t  i += 2; j += 1;\n+\t}\n+      else\n+\t{\n+\t  demangled[j] = mangled[i];\n+\t  i += 1;  j += 1;\n+\t}\n+    }\n+  demangled[j] = '\\000';\n+  \n+  for (i = 0; demangled[i] != '\\0'; i += 1)\n+    if (isupper (demangled[i]) || demangled[i] == ' ')\n+      goto Suppress;\n+\n+  if (! changed)\n+    return NULL;\n+  else\n+    return demangled;\n+  \n+ Suppress:\n+  grow_vect ((void**) &(demangling_buffer),\n+\t     &demangling_buffer_size,  strlen (mangled) + 3,\n+\t     sizeof (char));\n+  demangled = demangling_buffer;\n+  if (mangled[0] == '<')\n+     strcpy (demangled, mangled);\n+  else\n+    sprintf (demangled, \"<%s>\", mangled);\n+\n+  return demangled;\n+}\n+\n /* This function performs most of what cplus_demangle use to do, but\n    to be able to demangle a name with a B, K or n code, we need to\n    have a longer term memory of what types have been seen. The original"}]}