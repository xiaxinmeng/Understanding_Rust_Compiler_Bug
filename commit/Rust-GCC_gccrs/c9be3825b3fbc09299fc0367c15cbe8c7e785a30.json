{"sha": "c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzliZTM4MjViM2ZiYzA5Mjk5ZmMwMzY3YzE1Y2JlOGM3ZTc4NWEzMA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-03-24T21:32:14Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-03-24T21:32:14Z"}, "message": "[multiple changes]\n\n2002-03-24  Eric Blake  <ebb9@email.byu.edu>\n\n        * java/beans/IntrospectionException.java: Update to 1.4.\n        * java/beans/PropertyVetoException.java: Ditto.\n\n2002-03-24  Eric Blake  <ebb9@email.byu.edu>\n\n        * gnu/java/beans/BeanInfoEmbryo.java (hasMethod): Use\n        Arrays.equals instead of ArrayHelper.equalsArray.\n\n2002-03-24  C. Brian Jones <cbj@gnu.org>\n\n        * java/beans/Introspector.java: added new static final fields\n        introduced in 1.2, lots of other updates remain to be done\n\n2002-03-24  C. Brian Jones <cbj@gnu.org>\n\n        * java/beans/Introspector.java: reformatting\n\n2002-03-24  C. Brian Jones <cbj@gnu.org>\n\n        * java/beans/Introspector.java: default beanInfoSearchPath will\n        not include sun.beans.infos given we provide no such package and\n        the API doesn't really require it; gnu.java.beans.info is the\n        default.\n\n2002-03-24  Mark Wielaard  <mark@klomp.org>\n\n        Thanks to Orp developers\n        * gnu/java/beans/editors/NativeBooleanEditor.java (setAsText(String)):\n        switch TRUE and FALSE return values.\n\nFrom-SVN: r51273", "tree": {"sha": "6cb628794db014ae21693c54f293e3c35d7adbde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cb628794db014ae21693c54f293e3c35d7adbde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/comments", "author": null, "committer": null, "parents": [{"sha": "3ddbb8a977c1e7060088501b8fc5d07483774847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddbb8a977c1e7060088501b8fc5d07483774847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddbb8a977c1e7060088501b8fc5d07483774847"}], "stats": {"total": 1034, "additions": 595, "deletions": 439}, "files": [{"sha": "aec5a2914692ef580b338405f1ac3548d3e65756", "filename": "libjava/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -1,3 +1,35 @@\n+2002-03-24  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/beans/IntrospectionException.java: Update to 1.4.\n+\t* java/beans/PropertyVetoException.java: Ditto.\n+\n+2002-03-24  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* gnu/java/beans/BeanInfoEmbryo.java (hasMethod): Use\n+\tArrays.equals instead of ArrayHelper.equalsArray.\n+\n+2002-03-24  C. Brian Jones <cbj@gnu.org>\n+\n+\t* java/beans/Introspector.java: added new static final fields\n+\tintroduced in 1.2, lots of other updates remain to be done\n+\n+2002-03-24  C. Brian Jones <cbj@gnu.org>\n+\n+\t* java/beans/Introspector.java: reformatting\n+\n+2002-03-24  C. Brian Jones <cbj@gnu.org>\n+\n+\t* java/beans/Introspector.java: default beanInfoSearchPath will\n+\tnot include sun.beans.infos given we provide no such package and\n+\tthe API doesn't really require it; gnu.java.beans.info is the\n+\tdefault.\n+\n+2002-03-24  Mark Wielaard  <mark@klomp.org>\n+\n+\tThanks to Orp developers\n+\t* gnu/java/beans/editors/NativeBooleanEditor.java (setAsText(String)):\n+\tswitch TRUE and FALSE return values.\n+\n 2002-03-23  Tom Tromey  <tromey@redhat.com>\n \n \t* include/name-finder.h (_Jv_name_finder::myclose): New method."}, {"sha": "473aa790cbad83285f9ceb43f471e4c4de384a88", "filename": "libjava/gnu/java/beans/BeanInfoEmbryo.java", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2FBeanInfoEmbryo.java?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -1,5 +1,5 @@\n /* gnu.java.beans.BeanInfoEmbryo\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -130,14 +130,15 @@ public void addEvent(EventSetDescriptor e) {\n \t}\n \n \tpublic boolean hasMethod(MethodDescriptor m) {\n-\t\tfor(int i=0;i<methods.size();i++) {\n-\t\t\tMethod thisMethod = ((MethodDescriptor)methods.elementAt(i)).getMethod();\n-\t\t\tif(m.getMethod().getName().equals(thisMethod.getName())\n-\t\t\t   && ArrayHelper.equalsArray(m.getMethod().getParameterTypes(), thisMethod.getParameterTypes())) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+          for(int i=0;i<methods.size();i++) {\n+            Method thisMethod = ((MethodDescriptor)methods.elementAt(i)).getMethod();\n+            if(m.getMethod().getName().equals(thisMethod.getName())\n+               && Arrays.equals(m.getMethod().getParameterTypes(),\n+                                thisMethod.getParameterTypes())) {\n+              return true;\n+            }\n+          }\n+          return false;\n \t}\n \tpublic void addMethod(MethodDescriptor m) {\n \t\tmethods.addElement(m);"}, {"sha": "9fb14381bb5d1f1908638d3b4a5255bcce1a451e", "filename": "libjava/gnu/java/beans/editors/NativeBooleanEditor.java", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fbeans%2Feditors%2FNativeBooleanEditor.java?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -1,5 +1,5 @@\n /* gnu.java.beans.editors.NativeBooleanEditor\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -54,12 +54,15 @@\n public class NativeBooleanEditor extends PropertyEditorSupport {\n \tString[] tags = {\"true\",\"false\"};\n \n-\t/** setAsText for boolean checks for true or false or t or f. \"\" also means false. **/\n+\t/**\n+\t * setAsText for boolean checks for true or false or t or f.\n+\t * \"\" also means false.\n+\t **/\n \tpublic void setAsText(String val) throws IllegalArgumentException {\n \t\tif(val.equalsIgnoreCase(\"true\") || val.equalsIgnoreCase(\"t\")) {\n-\t\t\tsetValue(Boolean.FALSE);\n-\t\t} else if(val.equalsIgnoreCase(\"false\") || val.equalsIgnoreCase(\"f\") || val.equals(\"\")) {\n \t\t\tsetValue(Boolean.TRUE);\n+\t\t} else if(val.equalsIgnoreCase(\"false\") || val.equalsIgnoreCase(\"f\") || val.equals(\"\")) {\n+\t\t\tsetValue(Boolean.FALSE);\n \t\t} else {\n \t\t\tthrow new IllegalArgumentException(\"Value must be true, false, t, f or empty.\");\n \t\t}"}, {"sha": "9883c9ab45938fc0ebc61466fd5f8efee4c232c4", "filename": "libjava/java/beans/IntrospectionException.java", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FIntrospectionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FIntrospectionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FIntrospectionException.java?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.IntrospectionException\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* IntrospectionException -- thrown when an exception occurs in introspection\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,19 +39,29 @@\n package java.beans;\n \n /**\n- ** IntrospectionException is thrown when the Introspector fails.  Surprise, surprise.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 31 May 1998\n- ** @see java.beans.Introspector\n- **/\n-\n-public class IntrospectionException extends Exception {\n-\t/** Instantiate this exception with the given message.\n-\t ** @param msg the message for the exception.\n-\t **/\n-\tpublic IntrospectionException(String msg) {\n-\t\tsuper(msg);\n-\t}\n+ * IntrospectionException is thrown when the Introspector fails. Typical\n+ * causes are the inability to map a name to its Class, or specifying a\n+ * wrong type signature.\n+ *\n+ * @author John Keiser\n+ * @see Introspector\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public class IntrospectionException extends Exception\n+{\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = -3728150539969542619L;\n+\n+  /**\n+   * Instantiate this exception with the given message.\n+   *\n+   * @param msg the message for the exception\n+   */\n+  public IntrospectionException(String msg)\n+  {\n+    super(msg);\n+  }\n }"}, {"sha": "fa98c69ae9d5bcd399a52ea356340b8595420953", "filename": "libjava/java/beans/Introspector.java", "status": "modified", "additions": 475, "deletions": 382, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FIntrospector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FIntrospector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FIntrospector.java?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -44,395 +44,488 @@\n import gnu.java.lang.*;\n \n /**\n- ** Introspector is the class that does the bulk of the\n- ** design-time work in Java Beans.  Every class must have\n- ** a BeanInfo in order for an RAD tool to use it; but, as\n- ** promised, you don't have to write the BeanInfo class\n- ** yourself if you don't want to.  All you have to do is\n- ** call getBeanInfo() in the Introspector and it will use\n- ** standard JavaBeans-defined method signatures to\n- ** determine the information about your class.<P>\n- **\n- ** Don't worry about it too much, though: you can provide\n- ** JavaBeans with as much customized information as you\n- ** want, or as little as you want, using the BeanInfo\n- ** interface (see BeanInfo for details).<P>\n- **\n- ** <STRONG>Order of Operations</STRONG><P>\n- **\n- ** When you call getBeanInfo(class c), the Introspector\n- ** first searches for BeanInfo class to see if you\n- ** provided any explicit information.  It searches for a\n- ** class named <bean class name>BeanInfo in different\n- ** packages, first searching the bean class's package\n- ** and then moving on to search the beanInfoSearchPath.<P>\n- **\n- ** If it does not find a BeanInfo class, it acts as though\n- ** it had found a BeanInfo class returning null from all\n- ** methods (meaning it should discover everything through\n- ** Introspection).  If it does, then it takes the\n- ** information it finds in the BeanInfo class to be\n- ** canonical (that is, the information speaks for its\n- ** class as well as all superclasses).<P>\n- **\n- ** When it has introspected the class, calls\n- ** getBeanInfo(c.getSuperclass) and adds that information\n- ** to the information it has, not adding to any information\n- ** it already has that is canonical.<P>\n- **\n- ** <STRONG>Introspection Design Patterns</STRONG><P>\n- **\n- ** When the Introspector goes in to read the class, it\n- ** follows a well-defined order in order to not leave any\n- ** methods unaccounted for.  Its job is to step over all\n- ** of the public methods in a class and determine whether\n- ** they are part of a property, an event, or a method (in\n- ** that order).\n- **\n- **\n- ** <STRONG>Properties:</STRONG><P>\n- ** \n- ** <OL>\n- ** <LI>If there is a <CODE>public boolean isXXX()</CODE>\n- **     method, then XXX is a read-only boolean property.\n- **     <CODE>boolean getXXX()</CODE> may be supplied in\n- **     addition to this method, although isXXX() is the\n- **     one that will be used in this case and getXXX()\n- **     will be ignored.  If there is a\n- **     <CODE>public void setXXX(boolean)</CODE> method,\n- **     it is part of this group and makes it a read-write\n- **     property.</LI>\n- ** <LI>If there is a\n- **     <CODE>public &lt;type&gt; getXXX(int)</CODE>\n- **     method, then XXX is a read-only indexed property of\n- **     type &lt;type&gt;.  If there is a\n- **     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n- **     method, then it is a read-write indexed property of\n- **     type &lt;type&gt;.  There may also be a\n- **     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n- **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n- **     method as well.</CODE></LI>\n- ** <LI>If there is a\n- **     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n- **     method, then it is a write-only indexed property of\n- **     type &lt;type&gt;.  There may also be a\n- **     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n- **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n- **     method as well.</CODE></LI>\n- ** <LI>If there is a\n- **     <CODE>public &lt;type&gt; getXXX()</CODE> method,\n- **     then XXX is a read-only property of type\n- **     &lt;type&gt;.  If there is a\n- **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n- **     method, then it will be used for the property and\n- **     the property will be considered read-write.</LI>\n- ** <LI>If there is a\n- **     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n- **     method, then as long as XXX is not already used as\n- **     the name of a property, XXX is assumed to be a\n- **     write-only property of type &lt;type&gt;.</LI>\n- ** <LI>In all of the above cases, if the setXXX() method\n- **     throws <CODE>PropertyVetoException</CODE>, then the\n- **     property in question is assumed to be constrained.\n- **     No properties are ever assumed to be bound\n- **     (<STRONG>Spec Note:</STRONG> this is not in the\n- **     spec, it just makes sense).  See PropertyDescriptor\n- **     for a description of bound and constrained\n- **     properties.</LI>\n- ** </OL>\n- **\n- ** <STRONG>Events:</STRONG><P>\n- **\n- ** If there is a pair of methods,\n- ** <CODE>public void addXXX(&lt;type&gt;)</CODE> and\n- ** <CODE>public void removeXXX(&lt;type&gt;)</CODE>, where\n- ** &lt;type&gt; is a descendant of\n- ** <CODE>java.util.EventListener</CODE>, then the pair of\n- ** methods imply that this Bean will fire events to\n- ** listeners of type &lt;type&gt;.<P>\n- **\n- ** If the addXXX() method throws\n- ** <CODE>java.util.TooManyListenersException</CODE>, then\n- ** the event set is assumed to be <EM>unicast</EM>.  See\n- ** EventSetDescriptor for a discussion of unicast event\n- ** sets.<P>\n- **\n- ** <STRONG>Spec Note:</STRONG> the spec seems to say that\n- ** the listener type's classname must be equal to the XXX\n- ** part of addXXX() and removeXXX(), but that is not the\n- ** case in Sun's implementation, so I am assuming it is\n- ** not the case in general.<P>\n- **\n- ** <STRONG>Methods:</STRONG><P>\n- ** \n- ** Any public methods (including those which were used\n- ** for Properties or Events) are used as Methods.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 29 Jul 1998\n- ** @see java.beans.BeanInfo\n- **/\n-\n+ * Introspector is the class that does the bulk of the\n+ * design-time work in Java Beans.  Every class must have\n+ * a BeanInfo in order for an RAD tool to use it; but, as\n+ * promised, you don't have to write the BeanInfo class\n+ * yourself if you don't want to.  All you have to do is\n+ * call getBeanInfo() in the Introspector and it will use\n+ * standard JavaBeans-defined method signatures to\n+ * determine the information about your class.<P>\n+ *\n+ * Don't worry about it too much, though: you can provide\n+ * JavaBeans with as much customized information as you\n+ * want, or as little as you want, using the BeanInfo\n+ * interface (see BeanInfo for details).<P>\n+ *\n+ * <STRONG>Order of Operations</STRONG><P>\n+ *\n+ * When you call getBeanInfo(class c), the Introspector\n+ * first searches for BeanInfo class to see if you\n+ * provided any explicit information.  It searches for a\n+ * class named <bean class name>BeanInfo in different\n+ * packages, first searching the bean class's package\n+ * and then moving on to search the beanInfoSearchPath.<P>\n+ *\n+ * If it does not find a BeanInfo class, it acts as though\n+ * it had found a BeanInfo class returning null from all\n+ * methods (meaning it should discover everything through\n+ * Introspection).  If it does, then it takes the\n+ * information it finds in the BeanInfo class to be\n+ * canonical (that is, the information speaks for its\n+ * class as well as all superclasses).<P>\n+ *\n+ * When it has introspected the class, calls\n+ * getBeanInfo(c.getSuperclass) and adds that information\n+ * to the information it has, not adding to any information\n+ * it already has that is canonical.<P>\n+ *\n+ * <STRONG>Introspection Design Patterns</STRONG><P>\n+ *\n+ * When the Introspector goes in to read the class, it\n+ * follows a well-defined order in order to not leave any\n+ * methods unaccounted for.  Its job is to step over all\n+ * of the public methods in a class and determine whether\n+ * they are part of a property, an event, or a method (in\n+ * that order).\n+ *\n+ *\n+ * <STRONG>Properties:</STRONG><P>\n+ * \n+ * <OL>\n+ * <LI>If there is a <CODE>public boolean isXXX()</CODE>\n+ *     method, then XXX is a read-only boolean property.\n+ *     <CODE>boolean getXXX()</CODE> may be supplied in\n+ *     addition to this method, although isXXX() is the\n+ *     one that will be used in this case and getXXX()\n+ *     will be ignored.  If there is a\n+ *     <CODE>public void setXXX(boolean)</CODE> method,\n+ *     it is part of this group and makes it a read-write\n+ *     property.</LI>\n+ * <LI>If there is a\n+ *     <CODE>public &lt;type&gt; getXXX(int)</CODE>\n+ *     method, then XXX is a read-only indexed property of\n+ *     type &lt;type&gt;.  If there is a\n+ *     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n+ *     method, then it is a read-write indexed property of\n+ *     type &lt;type&gt;.  There may also be a\n+ *     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n+ *     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ *     method as well.</CODE></LI>\n+ * <LI>If there is a\n+ *     <CODE>public void setXXX(int,&lt;type&gt;)</CODE>\n+ *     method, then it is a write-only indexed property of\n+ *     type &lt;type&gt;.  There may also be a\n+ *     <CODE>public &lt;type&gt;[] getXXX()</CODE> and a\n+ *     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ *     method as well.</CODE></LI>\n+ * <LI>If there is a\n+ *     <CODE>public &lt;type&gt; getXXX()</CODE> method,\n+ *     then XXX is a read-only property of type\n+ *     &lt;type&gt;.  If there is a\n+ *     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ *     method, then it will be used for the property and\n+ *     the property will be considered read-write.</LI>\n+ * <LI>If there is a\n+ *     <CODE>public void setXXX(&lt;type&gt;)</CODE>\n+ *     method, then as long as XXX is not already used as\n+ *     the name of a property, XXX is assumed to be a\n+ *     write-only property of type &lt;type&gt;.</LI>\n+ * <LI>In all of the above cases, if the setXXX() method\n+ *     throws <CODE>PropertyVetoException</CODE>, then the\n+ *     property in question is assumed to be constrained.\n+ *     No properties are ever assumed to be bound\n+ *     (<STRONG>Spec Note:</STRONG> this is not in the\n+ *     spec, it just makes sense).  See PropertyDescriptor\n+ *     for a description of bound and constrained\n+ *     properties.</LI>\n+ * </OL>\n+ *\n+ * <STRONG>Events:</STRONG><P>\n+ *\n+ * If there is a pair of methods,\n+ * <CODE>public void addXXX(&lt;type&gt;)</CODE> and\n+ * <CODE>public void removeXXX(&lt;type&gt;)</CODE>, where\n+ * &lt;type&gt; is a descendant of\n+ * <CODE>java.util.EventListener</CODE>, then the pair of\n+ * methods imply that this Bean will fire events to\n+ * listeners of type &lt;type&gt;.<P>\n+ *\n+ * If the addXXX() method throws\n+ * <CODE>java.util.TooManyListenersException</CODE>, then\n+ * the event set is assumed to be <EM>unicast</EM>.  See\n+ * EventSetDescriptor for a discussion of unicast event\n+ * sets.<P>\n+ *\n+ * <STRONG>Spec Note:</STRONG> the spec seems to say that\n+ * the listener type's classname must be equal to the XXX\n+ * part of addXXX() and removeXXX(), but that is not the\n+ * case in Sun's implementation, so I am assuming it is\n+ * not the case in general.<P>\n+ *\n+ * <STRONG>Methods:</STRONG><P>\n+ * \n+ * Any public methods (including those which were used\n+ * for Properties or Events) are used as Methods.\n+ *\n+ * @author John Keiser\n+ * @since JDK1.1\n+ * @see java.beans.BeanInfo\n+ */\n public class Introspector {\n-\tstatic String[] beanInfoSearchPath = {\"gnu.java.beans.info\", \"sun.beans.infos\"};\n-\tstatic Hashtable beanInfoCache = new Hashtable();\n-\n-\tprivate Introspector() {}\n-\n-\t/** Get the BeanInfo for class <CODE>beanClass</CODE>,\n-\t ** first by looking for explicit information, next by\n-\t ** using standard design patterns to determine\n-\t ** information about the class.\n-\t ** @param beanClass the class to get BeanInfo about.\n-\t ** @return the BeanInfo object representing the class.\n-\t **/\n-\tpublic static BeanInfo getBeanInfo(Class beanClass) throws IntrospectionException {\n-\t\tBeanInfo cachedInfo;\n-\t\tsynchronized(beanClass) {\n-\t\tcachedInfo = (BeanInfo)beanInfoCache.get(beanClass);\n-\t\tif(cachedInfo != null) {\n-\t\t\treturn cachedInfo;\n-\t\t}\n-\t\tcachedInfo = getBeanInfo(beanClass,null);\n-\t\tbeanInfoCache.put(beanClass,cachedInfo);\n-\t\treturn cachedInfo;\n-\t\t}\n-\t}\n-\n-\t/** Get the BeanInfo for class <CODE>beanClass</CODE>,\n-\t ** first by looking for explicit information, next by\n-\t ** using standard design patterns to determine\n-\t ** information about the class.  It crawls up the\n-\t ** inheritance tree until it hits <CODE>topClass</CODE>.\n-\t ** @param beanClass the Bean class.\n-\t ** @param stopClass the class to stop at.\n-\t ** @return the BeanInfo object representing the class.\n-\t **/\n-\tpublic static BeanInfo getBeanInfo(Class beanClass, Class stopClass) throws IntrospectionException {\n-\t\tExplicitInfo explicit = new ExplicitInfo(beanClass,stopClass);\n-\n-\t\tIntrospectionIncubator ii = new IntrospectionIncubator();\n-\t\tii.setPropertyStopClass(explicit.propertyStopClass);\n-\t\tii.setEventStopClass(explicit.eventStopClass);\n-\t\tii.setMethodStopClass(explicit.methodStopClass);\n-\t\tii.addMethods(beanClass.getMethods());\n-\n-\t\tBeanInfoEmbryo currentInfo = ii.getBeanInfoEmbryo();\n-\t\tPropertyDescriptor[] p = explicit.explicitPropertyDescriptors;\n-\t\tif(p!=null) {\n-\t\t\tfor(int i=0;i<p.length;i++) {\n-\t\t\t\tif(!currentInfo.hasProperty(p[i])) {\n-\t\t\t\t\tcurrentInfo.addProperty(p[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif(explicit.defaultProperty != -1) {\n-\t\t\t\tcurrentInfo.setDefaultPropertyName(p[explicit.defaultProperty].getName());\n-\t\t\t}\n-\t\t}\n-\t\tEventSetDescriptor[] e = explicit.explicitEventSetDescriptors;\n-\t\tif(e!=null) {\n-\t\t\tfor(int i=0;i<e.length;i++) {\n-\t\t\t\tif(!currentInfo.hasEvent(e[i])) {\n-\t\t\t\t\tcurrentInfo.addEvent(e[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif(explicit.defaultEvent != -1) {\n-\t\t\t\tcurrentInfo.setDefaultEventName(e[explicit.defaultEvent].getName());\n-\t\t\t}\n-\t\t}\n-\t\tMethodDescriptor[] m = explicit.explicitMethodDescriptors;\n-\t\tif(m!=null) {\n-\t\t\tfor(int i=0;i<m.length;i++) {\n-\t\t\t\tif(!currentInfo.hasMethod(m[i])) {\n-\t\t\t\t\tcurrentInfo.addMethod(m[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif(explicit.explicitBeanDescriptor != null) {\n-\t\t\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,explicit.explicitBeanDescriptor.getCustomizerClass()));\n-\t\t} else {\n-\t\t\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,null));\n-\t\t}\n-\n-\t\tcurrentInfo.setAdditionalBeanInfo(explicit.explicitBeanInfo);\n-\t\tcurrentInfo.setIcons(explicit.im);\n-\n-\t\treturn currentInfo.getBeanInfo();\n-\t}\n-\n-\t/** Get the search path for BeanInfo classes.\n-\t ** @return the BeanInfo search path.\n-\t **/\n-\tpublic static String[] getBeanInfoSearchPath() {\n-\t\treturn beanInfoSearchPath;\n-\t}\n-\n-\t/** Set the search path for BeanInfo classes.\n-\t ** @param beanInfoSearchPath the new BeanInfo search\n-\t **        path.\n-\t **/\n-\tpublic static void setBeanInfoSearchPath(String[] beanInfoSearchPath) {\n-\t\tIntrospector.beanInfoSearchPath = beanInfoSearchPath;\n-\t}\n+  \n+  public static final int USE_ALL_BEANINFO = 1;\n+  public static final int IGNORE_IMMEDIATE_BEANINFO = 2;\n+  public static final int IGNORE_ALL_BEANINFO = 3;\n \n-\t/** A helper method to convert a name to standard Java\n-\t ** naming conventions: anything with two capitals as the\n-\t ** first two letters remains the same, otherwise the\n-\t ** first letter is decapitalized.  URL = URL, I = i,\n-\t ** MyMethod = myMethod.\n-\t ** @param name the name to decapitalize.\n-\t ** @return the decapitalized name.\n-\t **/\n-\tpublic static String decapitalize(String name) {\n-\t\ttry {\n-\t\t\tif(!Character.isUpperCase(name.charAt(0))) {\n-\t\t\t\treturn name;\n-\t\t\t} else {\n-\t\t\t\ttry {\n-\t\t\t\t\tif(Character.isUpperCase(name.charAt(1))) {\n-\t\t\t\t\t\treturn name;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tchar[] c = name.toCharArray();\n-\t\t\t\t\t\tc[0] = Character.toLowerCase(c[0]);\n-\t\t\t\t\t\treturn new String(c);\n-\t\t\t\t\t}\n-\t\t\t\t} catch(StringIndexOutOfBoundsException E) {\n-\t\t\t\t\tchar[] c = new char[1];\n-\t\t\t\t\tc[0] = Character.toLowerCase(name.charAt(0));\n-\t\t\t\t\treturn new String(c);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch(StringIndexOutOfBoundsException E) {\n-\t\t\treturn name;\n-\t\t} catch(NullPointerException E) {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n+  static String[] beanInfoSearchPath = {\"gnu.java.beans.info\"};\n+  static Hashtable beanInfoCache = new Hashtable();\n+  \n+  private Introspector() {}\n+  \n+  /** \n+   * Get the BeanInfo for class <CODE>beanClass</CODE>,\n+   * first by looking for explicit information, next by\n+   * using standard design patterns to determine\n+   * information about the class.\n+   *\n+   * @param beanClass the class to get BeanInfo about.\n+   * @return the BeanInfo object representing the class.\n+   */\n+  public static BeanInfo getBeanInfo(Class beanClass) \n+    throws IntrospectionException \n+  {\n+    BeanInfo cachedInfo;\n+    synchronized(beanClass) \n+      {\n+\tcachedInfo = (BeanInfo)beanInfoCache.get(beanClass);\n+\tif(cachedInfo != null) \n+\t  {\n+\t    return cachedInfo;\n+\t  }\n+\tcachedInfo = getBeanInfo(beanClass,null);\n+\tbeanInfoCache.put(beanClass,cachedInfo);\n+\treturn cachedInfo;\n+      }\n+  }\n \n-\tstatic BeanInfo copyBeanInfo(BeanInfo b) {\n-\t\tjava.awt.Image[] icons = new java.awt.Image[4];\n-\t\tfor(int i=1;i<=4;i++) {\n-\t\t\ticons[i-1] = b.getIcon(i);\n-\t\t}\n-\t\treturn new ExplicitBeanInfo(b.getBeanDescriptor(),b.getAdditionalBeanInfo(),\n-\t\t                            b.getPropertyDescriptors(),b.getDefaultPropertyIndex(),\n-\t\t                            b.getEventSetDescriptors(),b.getDefaultEventIndex(),\n-\t\t                            b.getMethodDescriptors(),icons);\n+  /** \n+   * Get the BeanInfo for class <CODE>beanClass</CODE>,\n+   * first by looking for explicit information, next by\n+   * using standard design patterns to determine\n+   * information about the class.  It crawls up the\n+   * inheritance tree until it hits <CODE>topClass</CODE>.\n+   *\n+   * @param beanClass the Bean class.\n+   * @param stopClass the class to stop at.\n+   * @return the BeanInfo object representing the class.\n+   */\n+  public static BeanInfo getBeanInfo(Class beanClass, Class stopClass) \n+    throws IntrospectionException \n+  {\n+    ExplicitInfo explicit = new ExplicitInfo(beanClass,stopClass);\n+    \n+    IntrospectionIncubator ii = new IntrospectionIncubator();\n+    ii.setPropertyStopClass(explicit.propertyStopClass);\n+    ii.setEventStopClass(explicit.eventStopClass);\n+    ii.setMethodStopClass(explicit.methodStopClass);\n+    ii.addMethods(beanClass.getMethods());\n+    \n+    BeanInfoEmbryo currentInfo = ii.getBeanInfoEmbryo();\n+    PropertyDescriptor[] p = explicit.explicitPropertyDescriptors;\n+    if(p!=null) \n+      {\n+\tfor(int i=0;i<p.length;i++) \n+\t  {\n+\t    if(!currentInfo.hasProperty(p[i])) \n+\t      {\n+\t\tcurrentInfo.addProperty(p[i]);\n+\t      }\n+\t  }\n+\tif(explicit.defaultProperty != -1) \n+\t  {\n+\t    currentInfo.setDefaultPropertyName(p[explicit.defaultProperty].getName());\n+\t  }\n+      }\n+    EventSetDescriptor[] e = explicit.explicitEventSetDescriptors;\n+    if(e!=null) \n+      {\n+\tfor(int i=0;i<e.length;i++) \n+\t  {\n+\t    if(!currentInfo.hasEvent(e[i])) \n+\t      {\n+\t\tcurrentInfo.addEvent(e[i]);\n+\t      }\n+\t  }\n+\tif(explicit.defaultEvent != -1) \n+\t  {\n+\t    currentInfo.setDefaultEventName(e[explicit.defaultEvent].getName());\n+\t  }\n+      }\n+    MethodDescriptor[] m = explicit.explicitMethodDescriptors;\n+    if(m!=null) \n+      {\n+\tfor(int i=0;i<m.length;i++) \n+\t  {\n+\t    if(!currentInfo.hasMethod(m[i])) \n+\t      {\n+\t\tcurrentInfo.addMethod(m[i]);\n+\t      }\n+\t  }\n+      }\n+    \n+    if(explicit.explicitBeanDescriptor != null) \n+      {\n+\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,explicit.explicitBeanDescriptor.getCustomizerClass()));\n+      } \n+    else \n+      {\n+\tcurrentInfo.setBeanDescriptor(new BeanDescriptor(beanClass,null));\n+      }\n+    \n+    currentInfo.setAdditionalBeanInfo(explicit.explicitBeanInfo);\n+    currentInfo.setIcons(explicit.im);\n+    \n+    return currentInfo.getBeanInfo();\n+  }\n+  \n+  /** \n+   * Get the search path for BeanInfo classes.\n+   *\n+   * @return the BeanInfo search path.\n+   */\n+  public static String[] getBeanInfoSearchPath() \n+  {\n+    return beanInfoSearchPath;\n+  }\n+  \n+  /** \n+   * Set the search path for BeanInfo classes.\n+   * @param beanInfoSearchPath the new BeanInfo search\n+   *        path.\n+   */\n+  public static void setBeanInfoSearchPath(String[] beanInfoSearchPath) \n+  {\n+    Introspector.beanInfoSearchPath = beanInfoSearchPath;\n+  }\n+  \n+  /** \n+   * A helper method to convert a name to standard Java\n+   * naming conventions: anything with two capitals as the\n+   * first two letters remains the same, otherwise the\n+   * first letter is decapitalized.  URL = URL, I = i,\n+   * MyMethod = myMethod.\n+   *\n+   * @param name the name to decapitalize.\n+   * @return the decapitalized name.\n+   */\n+  public static String decapitalize(String name) \n+  {\n+    try \n+      {\n+      if(!Character.isUpperCase(name.charAt(0))) \n+\t{\n+\t  return name;\n+\t} \n+      else \n+\t{\n+\ttry \n+\t  {\n+\t  if(Character.isUpperCase(name.charAt(1))) \n+\t    {\n+\t      return name;\n+\t    } \n+\t  else \n+\t    {\n+\t      char[] c = name.toCharArray();\n+\t      c[0] = Character.toLowerCase(c[0]);\n+\t      return new String(c);\n+\t    }\n+\t  } \n+\tcatch(StringIndexOutOfBoundsException E) \n+\t  {\n+\t    char[] c = new char[1];\n+\t    c[0] = Character.toLowerCase(name.charAt(0));\n+\t    return new String(c);\n+\t  }\n \t}\n+      } \n+    catch(StringIndexOutOfBoundsException E) \n+      {\n+\treturn name;\n+      } \n+    catch(NullPointerException E) \n+      {\n+\treturn null;\n+      }\n+  }\n+  \n+  static BeanInfo copyBeanInfo(BeanInfo b) \n+  {\n+    java.awt.Image[] icons = new java.awt.Image[4];\n+    for(int i=1;i<=4;i++) \n+      {\n+\ticons[i-1] = b.getIcon(i);\n+      }\n+    return new ExplicitBeanInfo(b.getBeanDescriptor(),\n+\t\t\t\tb.getAdditionalBeanInfo(),\n+\t\t\t\tb.getPropertyDescriptors(),\n+\t\t\t\tb.getDefaultPropertyIndex(),\n+\t\t\t\tb.getEventSetDescriptors(),\n+\t\t\t\tb.getDefaultEventIndex(),\n+\t\t\t\tb.getMethodDescriptors(),icons);\n+  }\n }\n \n-class ExplicitInfo {\n-\tBeanDescriptor explicitBeanDescriptor;\n-\tBeanInfo[] explicitBeanInfo;\n-\n-\tPropertyDescriptor[] explicitPropertyDescriptors;\n-\tEventSetDescriptor[] explicitEventSetDescriptors;\n-\tMethodDescriptor[] explicitMethodDescriptors;\n-\n-\tint defaultProperty;\n-\tint defaultEvent;\n-\n-\tjava.awt.Image[] im = new java.awt.Image[4];\n-\n-\tClass propertyStopClass;\n-\tClass eventStopClass;\n-\tClass methodStopClass;\n-\n-\tExplicitInfo(Class beanClass, Class stopClass) {\n-\t\twhile(beanClass != null && !beanClass.equals(stopClass)) {\n-\t\t\tBeanInfo explicit = findExplicitBeanInfo(beanClass);\n-\t\t\tif(explicit != null) {\n-\t\t\t\tif(explicitBeanDescriptor == null) {\n-\t\t\t\t\texplicitBeanDescriptor = explicit.getBeanDescriptor();\n-\t\t\t\t}\n-\t\t\t\tif(explicitBeanInfo == null) {\n-\t\t\t\t\texplicitBeanInfo = explicit.getAdditionalBeanInfo();\n-\t\t\t\t}\n-\t\t\t\tif(explicitPropertyDescriptors == null) {\n-\t\t\t\t\tif(explicit.getPropertyDescriptors() != null) {\n-\t\t\t\t\t\texplicitPropertyDescriptors = explicit.getPropertyDescriptors();\n-\t\t\t\t\t\tdefaultProperty = explicit.getDefaultPropertyIndex();\n-\t\t\t\t\t\tpropertyStopClass = beanClass;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(explicitEventSetDescriptors == null) {\n-\t\t\t\t\tif(explicit.getEventSetDescriptors() != null) {\n-\t\t\t\t\t\texplicitEventSetDescriptors = explicit.getEventSetDescriptors();\n-\t\t\t\t\t\tdefaultEvent = explicit.getDefaultEventIndex();\n-\t\t\t\t\t\teventStopClass = beanClass;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(explicitMethodDescriptors == null) {\n-\t\t\t\t\tif(explicit.getMethodDescriptors() != null) {\n-\t\t\t\t\t\texplicitMethodDescriptors = explicit.getMethodDescriptors();\n-\t\t\t\t\t\tmethodStopClass = beanClass;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(im[0] == null\n-\t\t\t\t   && im[1] == null\n-\t\t\t\t   && im[2] == null\n-\t\t\t\t   && im[3] == null) {\n-\t\t\t\t\tim[0] = explicit.getIcon(0);\n-\t\t\t\t\tim[1] = explicit.getIcon(1);\n-\t\t\t\t\tim[2] = explicit.getIcon(2);\n-\t\t\t\t\tim[3] = explicit.getIcon(3);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tbeanClass = beanClass.getSuperclass();\n-\t\t}\n-\t\tif(propertyStopClass == null) {\n-\t\t\tpropertyStopClass = stopClass;\n-\t\t}\n-\t\tif(eventStopClass == null) {\n-\t\t\teventStopClass = stopClass;\n-\t\t}\n-\t\tif(methodStopClass == null) {\n-\t\t\tmethodStopClass = stopClass;\n-\t\t}\n-\t}\n-\n-\tstatic Hashtable explicitBeanInfos = new Hashtable();\n-\tstatic Vector emptyBeanInfos = new Vector();\n-\n-\tstatic BeanInfo findExplicitBeanInfo(Class beanClass) {\n-\t\tBeanInfo retval = (BeanInfo)explicitBeanInfos.get(beanClass);\n-\t\tif(retval != null) {\n-\t\t\treturn retval;\n-\t\t} else if(emptyBeanInfos.indexOf(beanClass) != -1) {\n-\t\t\treturn null;\n-\t\t} else {\n-\t\t\tretval = reallyFindExplicitBeanInfo(beanClass);\n-\t\t\tif(retval != null) {\n-\t\t\t\texplicitBeanInfos.put(beanClass,retval);\n-\t\t\t} else {\n-\t\t\t\temptyBeanInfos.addElement(beanClass);\n-\t\t\t}\n-\t\t\treturn retval;\n-\t\t}\n+class ExplicitInfo \n+{\n+  BeanDescriptor explicitBeanDescriptor;\n+  BeanInfo[] explicitBeanInfo;\n+  \n+  PropertyDescriptor[] explicitPropertyDescriptors;\n+  EventSetDescriptor[] explicitEventSetDescriptors;\n+  MethodDescriptor[] explicitMethodDescriptors;\n+  \n+  int defaultProperty;\n+  int defaultEvent;\n+  \n+  java.awt.Image[] im = new java.awt.Image[4];\n+  \n+  Class propertyStopClass;\n+  Class eventStopClass;\n+  Class methodStopClass;\n+  \n+  ExplicitInfo(Class beanClass, Class stopClass) \n+  {\n+    while(beanClass != null && !beanClass.equals(stopClass)) \n+      {\n+\tBeanInfo explicit = findExplicitBeanInfo(beanClass);\n+\tif(explicit != null) \n+\t  {\n+\t    if(explicitBeanDescriptor == null) \n+\t      {\n+\t\texplicitBeanDescriptor = explicit.getBeanDescriptor();\n+\t      }\n+\t    if(explicitBeanInfo == null) \n+\t      {\n+\t\texplicitBeanInfo = explicit.getAdditionalBeanInfo();\n+\t      }\n+\t    if(explicitPropertyDescriptors == null) \n+\t      {\n+\t\tif(explicit.getPropertyDescriptors() != null) \n+\t\t  {\n+\t\t    explicitPropertyDescriptors = explicit.getPropertyDescriptors();\n+\t\t    defaultProperty = explicit.getDefaultPropertyIndex();\n+\t\t    propertyStopClass = beanClass;\n+\t\t  }\n+\t      }\n+\t    if(explicitEventSetDescriptors == null) \n+\t      {\n+\t\tif(explicit.getEventSetDescriptors() != null) \n+\t\t  {\n+\t\t    explicitEventSetDescriptors = explicit.getEventSetDescriptors();\n+\t\t    defaultEvent = explicit.getDefaultEventIndex();\n+\t\t    eventStopClass = beanClass;\n+\t\t  }\n+\t      }\n+\t    if(explicitMethodDescriptors == null) \n+\t      {\n+\t\tif(explicit.getMethodDescriptors() != null) \n+\t\t  {\n+\t\t    explicitMethodDescriptors = explicit.getMethodDescriptors();\n+\t\t    methodStopClass = beanClass;\n+\t\t  }\n+\t      }\n+\t    if(im[0] == null && im[1] == null \n+\t       && im[2] == null && im[3] == null) \n+\t      {\n+\t\tim[0] = explicit.getIcon(0);\n+\t\tim[1] = explicit.getIcon(1);\n+\t\tim[2] = explicit.getIcon(2);\n+\t\tim[3] = explicit.getIcon(3);\n+\t      }\n+\t  }\n+\tbeanClass = beanClass.getSuperclass();\n+      }\n+    if(propertyStopClass == null) \n+      {\n+\tpropertyStopClass = stopClass;\n+      }\n+    if(eventStopClass == null) \n+      {\n+\teventStopClass = stopClass;\n+      }\n+    if(methodStopClass == null) \n+      {\n+\tmethodStopClass = stopClass;\n+      }\n+  }\n+  \n+  static Hashtable explicitBeanInfos = new Hashtable();\n+  static Vector emptyBeanInfos = new Vector();\n+  \n+  static BeanInfo findExplicitBeanInfo(Class beanClass) \n+  {\n+    BeanInfo retval = (BeanInfo)explicitBeanInfos.get(beanClass);\n+    if(retval != null) \n+      {\n+\treturn retval;\n+      } \n+    else if(emptyBeanInfos.indexOf(beanClass) != -1) \n+      {\n+\treturn null;\n+      } \n+    else \n+      {\n+\tretval = reallyFindExplicitBeanInfo(beanClass);\n+\tif(retval != null) \n+\t  {\n+\t    explicitBeanInfos.put(beanClass,retval);\n+\t  } \n+\telse \n+\t  {\n+\t    emptyBeanInfos.addElement(beanClass);\n+\t  }\n+\treturn retval;\n+      }\n+  }\n+  \n+  static BeanInfo reallyFindExplicitBeanInfo(Class beanClass) \n+  {\n+    try \n+      {\n+      try \n+\t{\n+\t  return (BeanInfo)Class.forName(beanClass.getName()+\"BeanInfo\").newInstance();\n+\t} \n+      catch(ClassNotFoundException E) \n+\t{\n \t}\n-\n-\tstatic BeanInfo reallyFindExplicitBeanInfo(Class beanClass) {\n-\t\ttry {\n-\t\ttry {\n-\t\t\treturn (BeanInfo)Class.forName(beanClass.getName()+\"BeanInfo\").newInstance();\n-\t\t} catch(ClassNotFoundException E) {\n-\t\t}\n-\t\tString newName = ClassHelper.getTruncatedClassName(beanClass) + \"BeanInfo\";\n-\t\tfor(int i=0;i<Introspector.beanInfoSearchPath.length;i++) {\n-\t\t\ttry {\n-\t\t\t\tif(Introspector.beanInfoSearchPath[i].equals(\"\")) {\n-\t\t\t\t\treturn (BeanInfo)Class.forName(newName).newInstance();\n-\t\t\t\t} else {\n-\t\t\t\t\treturn (BeanInfo)Class.forName(Introspector.beanInfoSearchPath[i] + \".\" + newName).newInstance();\n-\t\t\t\t}\n-\t\t\t} catch(ClassNotFoundException E) {\n-\t\t\t}\n-\t\t}\n-\t\t} catch(IllegalAccessException E) {\n-\t\t} catch(InstantiationException E) {\n+      String newName = ClassHelper.getTruncatedClassName(beanClass) + \"BeanInfo\";\n+      for(int i=0;i<Introspector.beanInfoSearchPath.length;i++) \n+\t{\n+\t  try \n+\t    {\n+\t      if(Introspector.beanInfoSearchPath[i].equals(\"\")) \n+\t\t{\n+\t\t  return (BeanInfo)Class.forName(newName).newInstance();\n+\t\t} \n+\t      else \n+\t\t{\n+\t\t  return (BeanInfo)Class.forName(Introspector.beanInfoSearchPath[i] + \".\" + newName).newInstance();\n \t\t}\n-\t\treturn null;\n+\t    } \n+\t  catch(ClassNotFoundException E) \n+\t    {\n+\t    }\n \t}\n+      } \n+    catch(IllegalAccessException E) \n+      {\n+      } \n+    catch(InstantiationException E) \n+      {\n+      }\n+    return null;\n+  }\n }"}, {"sha": "31f01d8b16ee60644a537880f2136490b87f2d7d", "filename": "libjava/java/beans/PropertyVetoException.java", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9be3825b3fbc09299fc0367c15cbe8c7e785a30/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyVetoException.java?ref=c9be3825b3fbc09299fc0367c15cbe8c7e785a30", "patch": "@@ -1,13 +1,13 @@\n-/* java.beans.PropertyVetoException\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+/* PropertyVetoException.java -- thrown to veto a proposed property change\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,30 +39,47 @@\n package java.beans;\n \n /**\n- ** PropertyVetoException is thrown when a VetoableChangeListener doesn't like the proposed change.\n- **\n- ** @author John Keiser\n- ** @since JDK1.1\n- ** @version 1.1.0, 31 May 1998\n- ** @see java.beans.VetoableChangeListener\n- **/\n-\n-public class PropertyVetoException extends Exception {\n-\tPropertyChangeEvent evt;\n+ * PropertyVetoException is thrown when a VetoableChangeListener doesn't\n+ * like the proposed change.\n+ *\n+ * @author John Keiser\n+ * @see VetoableChangeListener\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n+public class PropertyVetoException extends Exception\n+{\n+  /**\n+   * Compatible with JDK 1.1+.\n+   */\n+  private static final long serialVersionUID = 129596057694162164L;\n \n-\tprivate static final long serialVersionUID = 129596057694162164L;\n+  /**\n+   * The vetoed change.\n+   *\n+   * @serial the event that was vetoed\n+   */\n+  private final PropertyChangeEvent evt;\n \n-\t/** Instantiate this exception with the given message and property change.\n-\t ** @param msg the reason for the veto.\n-\t ** @param changeEvent the PropertyChangeEvent that was thrown.\n-\t **/\n-\tpublic PropertyVetoException(String msg, PropertyChangeEvent changeEvent) {\n-\t\tsuper(msg);\n-\t\tevt = changeEvent;\n-\t}\n+  /**\n+   * Instantiate this exception with the given message and property change.\n+   *\n+   * @param msg the reason for the veto\n+   * @param changeEvent the PropertyChangeEvent that was thrown\n+   */\n+  public PropertyVetoException(String msg, PropertyChangeEvent changeEvent)\n+  {\n+    super(msg);\n+    evt = changeEvent;\n+  }\n \n-\t/** Get the PropertyChange event that was vetoed. **/\n-\tpublic PropertyChangeEvent getPropertyChangeEvent() {\n-\t\treturn evt;\n-\t}\n+  /**\n+   * Get the PropertyChange event that was vetoed.\n+   *\n+   * @return the vetoed change\n+   */\n+  public PropertyChangeEvent getPropertyChangeEvent()\n+  {\n+    return evt;\n+  }\n }"}]}