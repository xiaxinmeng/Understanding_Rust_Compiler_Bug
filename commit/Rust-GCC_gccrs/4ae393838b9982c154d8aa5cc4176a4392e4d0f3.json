{"sha": "4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFlMzkzODM4Yjk5ODJjMTU0ZDhhYTVjYzQxNzZhNDM5MmU0ZDBmMw==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2008-11-07T09:32:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-11-07T09:32:43Z"}, "message": "trans.c (build_binary_op_trapv): Use more efficient overflow check for addition/subtraction if...\n\n\t* gcc-interface/trans.c (build_binary_op_trapv): Use more efficient\n\toverflow check for addition/subtraction if neither operand is constant.\n\nFrom-SVN: r141665", "tree": {"sha": "df1e51efc140aabbb9a93c50a6ac54a7a55c28dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df1e51efc140aabbb9a93c50a6ac54a7a55c28dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae393838b9982c154d8aa5cc4176a4392e4d0f3/comments", "author": null, "committer": null, "parents": [{"sha": "218da972364c1f57281ae917c74f42f97341f358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/218da972364c1f57281ae917c74f42f97341f358", "html_url": "https://github.com/Rust-GCC/gccrs/commit/218da972364c1f57281ae917c74f42f97341f358"}], "stats": {"total": 104, "additions": 74, "deletions": 30}, "files": [{"sha": "f9d899309bad4cd2e69b2c191a48e792e7eab495", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae393838b9982c154d8aa5cc4176a4392e4d0f3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae393838b9982c154d8aa5cc4176a4392e4d0f3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "patch": "@@ -1,3 +1,8 @@\n+2008-11-07  Geert Bosch  <bosch@adacore.com>\n+\n+\t* gcc-interface/trans.c (build_binary_op_trapv): Use more efficient\n+\toverflow check for addition/subtraction if neither operand is constant.\n+\n 2008-11-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in (SPARC/Solaris): Use a common set of"}, {"sha": "5d56ef84cb1911ad38157ad75582166dccff6010", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 69, "deletions": 30, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae393838b9982c154d8aa5cc4176a4392e4d0f3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae393838b9982c154d8aa5cc4176a4392e4d0f3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4ae393838b9982c154d8aa5cc4176a4392e4d0f3", "patch": "@@ -5998,58 +5998,93 @@ build_binary_op_trapv (enum tree_code code,\n   tree gnu_expr;\n   tree tmp1, tmp2;\n   tree zero = convert (gnu_type, integer_zero_node);\n-  tree rhs_ge_zero;\n+  tree rhs_lt_zero;\n   tree check_pos;\n   tree check_neg;\n+  tree check;\n \n   int precision = TYPE_PRECISION (gnu_type);\n \n-  /* Prefer a constant rhs to simplify checks */\n+  gcc_assert (!(precision & (precision - 1))); /* ensure power of 2 */\n \n-  if (TREE_CONSTANT (lhs) && !TREE_CONSTANT (rhs)\n-      && commutative_tree_code (code))\n+  /* Prefer a constant or known-positive rhs to simplify checks */\n+\n+  if (!TREE_CONSTANT (rhs)\n+      && commutative_tree_code (code)\n+      && (TREE_CONSTANT (lhs) || (!tree_expr_nonnegative_p (rhs)\n+\t\t\t\t  && tree_expr_nonnegative_p (lhs))))\n     {\n-      tree tmp = lhs;\n-      lhs = rhs;\n-      rhs = tmp;\n-   }\n+\t  tree tmp = lhs;\n+\t  lhs = rhs;\n+\t  rhs = tmp;\n+    }\n+\n+  rhs_lt_zero = tree_expr_nonnegative_p (rhs)\n+    ? integer_zero_node \n+    : build_binary_op (LT_EXPR, integer_type_node, rhs, zero);\n+\n+  /* Should use more efficient check for operand_equal_p (lhs, rhs, 0) ??? */\n \n-  /* In the case the right-hand size is still not constant, try to\n-     use an exact operation in a wider type. */\n+  /* Try a few strategies that may be cheaper than the general\n+     code at the end of the function, if the RHS is not known.\n+     The strategies are:\n+       - Call library function for 64-bit multiplication (complex)\n+       - Widen, if input arguments are sufficiently small\n+       - Determine overflow using wrapped result for addition/subtraction */\n \n   if (!TREE_CONSTANT (rhs))\n     {\n-      int needed_precision = code == MULT_EXPR ? 2 * precision : precision + 1;\n+      /* Even for add/subtract double size in order to get another basetype */\n+      int needed_precision = precision * 2;\n \n       if (code == MULT_EXPR && precision == 64)\n \t{\n \t  return build_call_2_expr (mulv64_decl, lhs, rhs);\n \t}\n-      else if (needed_precision <= LONG_LONG_TYPE_SIZE)\n+      else if (needed_precision <= BITS_PER_WORD\n+\t       || (code == MULT_EXPR \n+\t\t   && needed_precision <= LONG_LONG_TYPE_SIZE))\n \t{\n-\t  tree calc_type = gnat_type_for_size (needed_precision, 0);\n-\t  tree result;\n-\t  tree check;\n+\t  tree wide_type = gnat_type_for_size (needed_precision, 0);\n \n-\t  result = build_binary_op (code, calc_type,\n-\t\t\t\t    convert (calc_type, lhs),\n-\t\t\t\t    convert (calc_type, rhs));\n+\t  tree wide_result = build_binary_op (code, wide_type,\n+\t\t\t\t\t      convert (wide_type, lhs),\n+\t\t\t\t\t      convert (wide_type, rhs));\n \n-\t  check = build_binary_op\n+\t  tree check = build_binary_op\n \t    (TRUTH_ORIF_EXPR, integer_type_node,\n-\t     build_binary_op (LT_EXPR, integer_type_node, result,\n-\t\t\t      convert (calc_type, type_min)),\n-\t     build_binary_op (GT_EXPR, integer_type_node, result,\n-\t\t\t      convert (calc_type, type_max)));\n+\t     build_binary_op (LT_EXPR, integer_type_node, wide_result,\n+\t\t\t      convert (wide_type, type_min)),\n+\t     build_binary_op (GT_EXPR, integer_type_node, wide_result,\n+\t\t\t      convert (wide_type, type_max)));\n+\n+\t  tree result = convert (gnu_type, wide_result);\n \n-\t  result = convert (gnu_type, result);\n \n \t  return emit_check (check, result, CE_Overflow_Check_Failed);\n \t}\n-    }\n+      else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+\t{\n+\t  tree unsigned_type = gnat_type_for_size (precision, 1);\n+\t  tree wrapped_expr = convert\n+\t    (gnu_type, build_binary_op (code, unsigned_type,\n+\t\t\t\t\tconvert (unsigned_type, lhs),\n+\t\t\t\t\tconvert (unsigned_type, rhs)));\n \n-  gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n-  rhs_ge_zero = build_binary_op (GE_EXPR, integer_type_node, rhs, zero);\n+\t  tree result = convert\n+\t    (gnu_type, build_binary_op (code, gnu_type, lhs, rhs));\n+\n+\t  /* Overflow when (rhs < 0) ^ (wrapped_expr < lhs)), for addition\n+\t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction */\n+\n+\t  tree check = build_binary_op\n+\t    (TRUTH_XOR_EXPR, integer_type_node, rhs_lt_zero,\n+\t     build_binary_op (code == PLUS_EXPR ? LT_EXPR : GT_EXPR,\n+\t\t\t      integer_type_node, wrapped_expr, lhs));\n+\n+\t  return emit_check (check, result, CE_Overflow_Check_Failed);\n+\t}\n+   }\n \n   switch (code)\n     {\n@@ -6079,6 +6114,7 @@ build_binary_op_trapv (enum tree_code code,\n \n     case MULT_EXPR:\n       /* The check here is designed to be efficient if the rhs is constant,\n+         but it will work for any rhs by using integer division.\n          Four different check expressions determine wether X * C overflows,\n \t depending on C.\n \t   C ==  0  =>  false\n@@ -6108,9 +6144,12 @@ build_binary_op_trapv (enum tree_code code,\n       gcc_unreachable();\n     }\n \n-  return emit_check (fold_build3 (COND_EXPR, integer_type_node, rhs_ge_zero,\n-\t\t\t\t  check_pos, check_neg),\n-\t\t     gnu_expr, CE_Overflow_Check_Failed);\n+  gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n+\n+  check = fold_build3 (COND_EXPR, integer_type_node,\n+\t\t       rhs_lt_zero,  check_neg, check_pos);\n+\n+  return emit_check (check, gnu_expr, CE_Overflow_Check_Failed);\n }\n \n /* Emit code for a range check. GNU_EXPR is the expression to be checked,"}]}