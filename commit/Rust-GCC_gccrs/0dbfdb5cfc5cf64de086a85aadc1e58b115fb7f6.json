{"sha": "0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "node_id": "C_kwDOANBUbNoAKDBkYmZkYjVjZmM1Y2Y2NGRlMDg2YTg1YWFkYzFlNThiMTE1ZmI3ZjY", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-15T10:25:33Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-06-15T16:16:39Z"}, "message": "parser: Add base for parsing const generic application\n\n1. Refactor const generic declaration\n\nThe default value for const generics now benefits from using the same\nfunction as parsing a regular const generic expression\n\n2. `Parser::parse_type` should not always add errors\n\nIn the case that we are parsing a const generic and not a type, we\nshould not emit bogus errors from `parse_type` such as \"unexpected token\nin type: LITERAL\". Thus, we add a flag to the function to not always\nadd errors to the error table\n\n3. Figure out how to deal with ambiguities\n\nIn the following cases, parsing is ambiguous:\n\n```rust\nlet a: Foo<N>;\n```\n\nWhat is N? Is it a type to be used as a generic argument? Is it a const\nvalue to be used for a const generic argument? We need to keep both\npossibilities and differentiate later during typechecking. We need to\nfigure out if it would be better to keep the ambiguity in our future\n`ConstGenericArg` type (something like Kind::ConstVarOrType) or modify\nour current `AST::Type` to maybe get differentiated later as a const\nvariable, which seems more annoying.\n\nFinally, since the const evaluation is not implemented yet, we are\ngetting some bogus errors in the testcase. This commit simply serves as\na necessary base: parsing const generics before we can apply them.", "tree": {"sha": "7e6233b81959b0908909c956b047bbf0c748fc89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6233b81959b0908909c956b047bbf0c748fc89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08e407e977e78bfebb2faa71be377c58369b8b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e407e977e78bfebb2faa71be377c58369b8b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e407e977e78bfebb2faa71be377c58369b8b0d"}], "stats": {"total": 190, "additions": 128, "deletions": 62}, "files": [{"sha": "a1f88d83205401e9499c2f92ddeeb691c6511a08", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "patch": "@@ -134,6 +134,8 @@ struct GenericArgs\n   std::vector<Lifetime> lifetime_args;\n   std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n+  // TODO: Handle const generics here as well.\n+  // We can probably keep a vector of `Expr`s for this.\n   Location locus;\n \n public:"}, {"sha": "3a76d748d6a5703a208b7f52f3748d441cd1c34e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 98, "deletions": 61, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "patch": "@@ -2885,37 +2885,14 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \t  {\n \t    lexer.skip_token ();\n \t    auto tok = lexer.peek_token ();\n+\t    auto default_expr = parse_const_generic_expression ();\n \n-\t    switch (tok->get_id ())\n-\t      {\n-\t\tcase LEFT_CURLY: {\n-\t\t  auto block = parse_block_expr ();\n-\t\t  // pass block to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t\tcase IDENTIFIER: {\n-\t\t  auto ident = tok->get_str ();\n-\t\t  // pass identifier to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t      case MINUS:\n-\t      case STRING_LITERAL:\n-\t      case CHAR_LITERAL:\n-\t      case INT_LITERAL:\n-\t      case FLOAT_LITERAL:\n-\t      case TRUE_LITERAL:\n-\t\tcase FALSE_LITERAL: {\n-\t\t  auto literal = parse_literal_expr ();\n-\t\t  // pass literal to `const_generic`\n-\t\t  break;\n-\t\t}\n-\t      default:\n-\t\trust_error_at (tok->get_locus (),\n-\t\t\t       \"invalid token for start of default value for \"\n-\t\t\t       \"const generic parameter: expected %<block%>, \"\n-\t\t\t       \"%<identifier%> or %<literal%>, got %qs\",\n-\t\t\t       token_id_to_str (tok->get_id ()));\n-\t      }\n+\t    if (!default_expr)\n+\t      rust_error_at (tok->get_locus (),\n+\t\t\t     \"invalid token for start of default value for \"\n+\t\t\t     \"const generic parameter: expected %<block%>, \"\n+\t\t\t     \"%<identifier%> or %<literal%>, got %qs\",\n+\t\t\t     token_id_to_str (tok->get_id ()));\n \t  }\n \n \t// param = std::unique_ptr<AST::GenericParam> (const_generic)\n@@ -6182,6 +6159,39 @@ Parser<ManagedTokenSource>::parse_type_path ()\n \t\t\thas_opening_scope_resolution);\n }\n \n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::Expr>\n+Parser<ManagedTokenSource>::parse_const_generic_expression ()\n+{\n+  auto tok = lexer.peek_token ();\n+  switch (tok->get_id ())\n+    {\n+    case LEFT_CURLY:\n+      return parse_block_expr ();\n+      case IDENTIFIER: {\n+\tlexer.skip_token ();\n+\n+\t// TODO: This is ambiguous with regular generic types. We probably need\n+\t// to differentiate later on during type checking, and thus keep a\n+\t// special variant here\n+\n+\t// return this\n+\treturn std::unique_ptr<AST::IdentifierExpr> (\n+\t  new AST::IdentifierExpr (tok->get_str (), {}, tok->get_locus ()));\n+      }\n+    case MINUS:\n+    case STRING_LITERAL:\n+    case CHAR_LITERAL:\n+    case INT_LITERAL:\n+    case FLOAT_LITERAL:\n+    case TRUE_LITERAL:\n+    case FALSE_LITERAL:\n+      return parse_literal_expr ();\n+    default:\n+      return nullptr;\n+    }\n+}\n+\n // Parses the generic arguments in each path segment.\n template <typename ManagedTokenSource>\n AST::GenericArgs\n@@ -6193,6 +6203,9 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n       return AST::GenericArgs::create_empty ();\n     }\n \n+  // We need to parse all lifetimes, then parse types and const generics in\n+  // any order.\n+\n   // try to parse lifetimes first\n   std::vector<AST::Lifetime> lifetime_args;\n \n@@ -6222,35 +6235,42 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   // try to parse types second\n   std::vector<std::unique_ptr<AST::Type>> type_args;\n+  std::vector<std::unique_ptr<AST::Expr>> const_args;\n+\n+  // TODO: Keep list of const expressions as well\n \n   // TODO: think of better control structure\n   t = lexer.peek_token ();\n   while (!is_right_angle_tok (t->get_id ()))\n     {\n+      // FIXME: Is it fine to break if there is one binding? Can't there be\n+      // bindings in between types?\n+\n       // ensure not binding being parsed as type accidently\n       if (t->get_id () == IDENTIFIER\n \t  && lexer.peek_token (1)->get_id () == EQUAL)\n+\tbreak;\n+\n+      auto type = parse_type (false);\n+      if (type)\n \t{\n-\t  break;\n+\t  type_args.emplace_back (std::move (type));\n \t}\n-\n-      std::unique_ptr<AST::Type> type = parse_type ();\n-      if (type == nullptr)\n+      else\n \t{\n-\t  // not necessarily an error\n-\t  break;\n+\t  auto const_generic_expr = parse_const_generic_expression ();\n+\t  if (const_generic_expr)\n+\t    const_args.emplace_back (std::move (const_generic_expr));\n+\t  else\n+\t    break;\n \t}\n \n-      type_args.push_back (std::move (type));\n-\n       // if next token isn't comma, then it must be end of list\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n+\tbreak;\n+\n       // skip comma\n       lexer.skip_token ();\n-\n       t = lexer.peek_token ();\n     }\n \n@@ -8982,7 +9002,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n // Parses a type (will further disambiguate any type).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Type>\n-Parser<ManagedTokenSource>::parse_type ()\n+Parser<ManagedTokenSource>::parse_type (bool save_errors)\n {\n   /* rules for all types:\n    * NeverType:               '!'\n@@ -9034,9 +9054,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n \tif (path.is_error ())\n \t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"failed to parse qualified path in type\");\n-\t    add_error (std::move (error));\n+\t    if (save_errors)\n+\t      {\n+\t\tError error (t->get_locus (),\n+\t\t\t     \"failed to parse qualified path in type\");\n+\t\tadd_error (std::move (error));\n+\t      }\n \n \t    return nullptr;\n \t  }\n@@ -9085,9 +9108,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \tAST::TypePath path = parse_type_path ();\n \tif (path.is_error ())\n \t  {\n-\t    Error error (t->get_locus (),\n-\t\t\t \"failed to parse path as first component of type\");\n-\t    add_error (std::move (error));\n+\t    if (save_errors)\n+\t      {\n+\t\tError error (t->get_locus (),\n+\t\t\t     \"failed to parse path as first component of type\");\n+\t\tadd_error (std::move (error));\n+\t      }\n \n \t    return nullptr;\n \t  }\n@@ -9103,10 +9129,13 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      AST::SimplePath macro_path = path.as_simple_path ();\n \t      if (macro_path.is_empty ())\n \t\t{\n-\t\t  Error error (t->get_locus (),\n-\t\t\t       \"failed to parse simple path in macro \"\n-\t\t\t       \"invocation (for type)\");\n-\t\t  add_error (std::move (error));\n+\t\t  if (save_errors)\n+\t\t    {\n+\t\t      Error error (t->get_locus (),\n+\t\t\t\t   \"failed to parse simple path in macro \"\n+\t\t\t\t   \"invocation (for type)\");\n+\t\t      add_error (std::move (error));\n+\t\t    }\n \n \t\t  return nullptr;\n \t\t}\n@@ -9190,9 +9219,12 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  std::unique_ptr<AST::TraitBound> initial_bound = parse_trait_bound ();\n \t  if (initial_bound == nullptr)\n \t    {\n-\t      Error error (lexer.peek_token ()->get_locus (),\n-\t\t\t   \"failed to parse ImplTraitType initial bound\");\n-\t      add_error (std::move (error));\n+\t      if (save_errors)\n+\t\t{\n+\t\t  Error error (lexer.peek_token ()->get_locus (),\n+\t\t\t       \"failed to parse ImplTraitType initial bound\");\n+\t\t  add_error (std::move (error));\n+\t\t}\n \n \t      return nullptr;\n \t    }\n@@ -9265,9 +9297,13 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      = parse_trait_bound ();\n \t    if (initial_bound == nullptr)\n \t      {\n-\t\tError error (lexer.peek_token ()->get_locus (),\n-\t\t\t     \"failed to parse TraitObjectType initial bound\");\n-\t\tadd_error (std::move (error));\n+\t\tif (save_errors)\n+\t\t  {\n+\t\t    Error error (\n+\t\t      lexer.peek_token ()->get_locus (),\n+\t\t      \"failed to parse TraitObjectType initial bound\");\n+\t\t    add_error (std::move (error));\n+\t\t  }\n \n \t\treturn nullptr;\n \t      }\n@@ -9313,8 +9349,9 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     default:\n-      add_error (Error (t->get_locus (), \"unrecognised token %qs in type\",\n-\t\t\tt->get_token_description ()));\n+      if (save_errors)\n+\tadd_error (Error (t->get_locus (), \"unrecognised token %qs in type\",\n+\t\t\t  t->get_token_description ()));\n \n       return nullptr;\n     }"}, {"sha": "f0aedfe6a227b3a40803f2d36eb87bc05bc10a2d", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "patch": "@@ -138,7 +138,7 @@ template <typename ManagedTokenSource> class Parser\n    */\n   std::unique_ptr<AST::Stmt> parse_stmt (ParseRestrictions restrictions\n \t\t\t\t\t = ParseRestrictions ());\n-  std::unique_ptr<AST::Type> parse_type ();\n+  std::unique_ptr<AST::Type> parse_type (bool save_errors = true);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n   std::unique_ptr<AST::TraitItem> parse_trait_item ();\n   std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n@@ -177,6 +177,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::TypePath parse_type_path ();\n   std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n   AST::PathIdentSegment parse_path_ident_segment ();\n+  std::unique_ptr<AST::Expr> parse_const_generic_expression ();\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function (Location locus);"}, {"sha": "6a3a0fe27bf3ccdaed81abf8198bd7e7c57b4b62", "filename": "gcc/testsuite/rust/compile/const_generics_3.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_3.rs?ref=0dbfdb5cfc5cf64de086a85aadc1e58b115fb7f6", "patch": "@@ -0,0 +1,26 @@\n+// { dg-additional-options \"-w\" }\n+\n+const M: usize = 4;\n+\n+struct Foo<T, const N: usize = 1> {\n+    // FIXME: This error is bogus. But having it means parsing is valid!\n+    value: [i32; N], // { dg-error \"failed to find name: N\" }\n+}\n+\n+fn main() {\n+    let foo = Foo::<i32> { value: [15] };\n+    let foo = Foo::<i32, 2> { value: [15, 13] };\n+    let foo: Foo<i32, 2> = Foo { value: [15, 13] };\n+    let foo: Foo<i32, 2> = Foo::<i32, 2> { value: [15, 13] };\n+    let foo: Foo<i32, { 1 + 1 }> = Foo { value: [15, 13] };\n+    let foo = Foo::<i32, { 1 + 1 }> { value: [15, 13] };\n+    let foo: Foo<i32, { 1 + 1 }> = Foo::<i32, { 1 + 1 }> { value: [15, 13] };\n+    let foo: Foo<i32, M> = Foo::<i32, 4> {\n+        value: [15, 13, 11, 9],\n+    };\n+\n+    // FIXME: Add proper const typecheck errors here\n+    let invalid_foo: Foo<i32, { 1 + 1 }> = Foo::<i32, 3> { value: [15, 13] };\n+    let invalid_foo: Foo<i32, { 1 + 1 }> = Foo::<i32, M> { value: [15, 13] };\n+    let invalid_foo: Foo<i32> = Foo::<i32, 2> { value: [15, 13] };\n+}"}]}