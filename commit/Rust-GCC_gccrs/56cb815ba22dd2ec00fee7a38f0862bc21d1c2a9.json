{"sha": "56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjYjgxNWJhMjJkZDJlYzAwZmVlN2EzOGYwODYyYmMyMWQxYzJhOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-13T07:19:54Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-13T07:19:54Z"}, "message": "Fix tramp3d PGO misoptimization\n\nthis patch fixes tramp3d ICE with PGO.  It has turned out to be by a misupdate\nin ignore_edge I introduced in previous patch that made us to not compute\nSCCs correctly with -fno-lto.\n\nWhile looking for problem I proofread the sources and also fortified the\nsrouces for situation where we insert a summary for no good reason and noticed\na problem that early ipa-modref disabled itself in some cases.\nI also noticed that param_index is treamed as uhwi while it is signed (that\nwastes file space).\n\nBootstrapping/regtesting x86_64-linux, will commit it tomorrow if that passes.\n\ngcc/ChangeLog:\n\n2020-10-13  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/97389\n\t* ipa-modref.c (dump_lto_records): Fix formating of dump file.\n\t(modref_summary::dump): Do not check loads to be non-null.\n\t(modref_summary_lto::dump): Do not check loads to be non-null.\n\t(merge_call_side_effects): Improve debug output.\n\t(analyze_call): Crash when cur_summary->loads is NULL.\n\t(analyze_function): Update.\n\t(modref_summaries::insert): Insert only into summaries, not\n\toptimization_summaries.\n\t(modref_summaries::duplicate): Likewise; crash when load or sotres\n\tare NULL.\n\t(modref_summaries_lto::duplicate): Crash when loads or stores are NULL.\n\t(write_modref_records): param_index is signed.\n\t(read_modref_records): param_index is signed.\n\t(modref_write): Crash when loads or stores are NULL.\n\t(read_section): Compensate previous change.\n\t(pass_modref::execute): Do not check optimization_summaries t be\n\tnon-NULL.\n\t(ignore_edge): Fix.\n\t(compute_parm_map): Fix formating.\n\t(modref_propagate_in_scc): Do not expect loads/stores to be NULL.", "tree": {"sha": "fce42e506c77890252363c750ace48f038d9e6ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fce42e506c77890252363c750ace48f038d9e6ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9/comments", "author": null, "committer": null, "parents": [{"sha": "8be127cac959d0f0ca0f8f9aa311828a9ee03f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8be127cac959d0f0ca0f8f9aa311828a9ee03f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8be127cac959d0f0ca0f8f9aa311828a9ee03f24"}], "stats": {"total": 188, "additions": 84, "deletions": 104}, "files": [{"sha": "4f86b9ccea166a93a4b0de7f66f00591462e17f1", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 84, "deletions": 104, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "patch": "@@ -298,7 +298,7 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n \t\t   r->ref ? get_alias_set (r->ref) : 0);\n \t  if (r->every_access)\n \t    {\n-\t      fprintf (out, \"      Every access\\n\");\n+\t      fprintf (out, \"          Every access\\n\");\n \t      continue;\n \t    }\n \t  size_t k;\n@@ -314,33 +314,21 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n void\n modref_summary::dump (FILE *out)\n {\n-  if (loads)\n-    {\n-      fprintf (out, \"  loads:\\n\");\n-      dump_records (loads, out);\n-    }\n-  if (stores)\n-    {\n-      fprintf (out, \"  stores:\\n\");\n-      dump_records (stores, out);\n-    }\n+  fprintf (out, \"  loads:\\n\");\n+  dump_records (loads, out);\n+  fprintf (out, \"  stores:\\n\");\n+  dump_records (stores, out);\n }\n \n /* Dump summary.  */\n \n void\n modref_summary_lto::dump (FILE *out)\n {\n-  if (loads)\n-    {\n-      fprintf (out, \"  loads:\\n\");\n-      dump_lto_records (loads, out);\n-    }\n-  if (stores)\n-    {\n-      fprintf (out, \"  stores:\\n\");\n-      dump_lto_records (stores, out);\n-    }\n+  fprintf (out, \"  loads:\\n\");\n+  dump_lto_records (loads, out);\n+  fprintf (out, \"  stores:\\n\");\n+  dump_lto_records (stores, out);\n }\n \n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n@@ -530,16 +518,19 @@ ignore_stores_p (tree caller, int flags)\n bool\n merge_call_side_effects (modref_summary *cur_summary,\n \t\t\t gimple *stmt, modref_summary *callee_summary,\n-\t\t\t bool ignore_stores)\n+\t\t\t bool ignore_stores, cgraph_node *callee_node)\n {\n   auto_vec <modref_parm_map, 32> parm_map;\n   bool changed = false;\n \n+  if (dump_file)\n+    fprintf (dump_file, \" - Merging side effects of %s with parm map:\",\n+\t     callee_node->dump_name ());\n+\n   parm_map.safe_grow_cleared (gimple_call_num_args (stmt));\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n       tree op = gimple_call_arg (stmt, i);\n-      STRIP_NOPS (op);\n       if (TREE_CODE (op) == SSA_NAME\n \t  && SSA_NAME_IS_DEFAULT_DEF (op)\n \t  && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n@@ -563,17 +554,17 @@ merge_call_side_effects (modref_summary *cur_summary,\n \tparm_map[i].parm_index = -2;\n       else\n \tparm_map[i].parm_index = -1;\n+      if (dump_file)\n+\tfprintf (dump_file, \" %i\", parm_map[i].parm_index);\n     }\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n \n   /* Merge with callee's summary.  */\n-  if (cur_summary->loads)\n-    changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n+  changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n   if (!ignore_stores)\n-    {\n-      if (cur_summary->stores)\n-\tchanged |= cur_summary->stores->merge (callee_summary->stores,\n-\t\t\t\t\t       &parm_map);\n-    }\n+    changed |= cur_summary->stores->merge (callee_summary->stores,\n+\t\t\t\t\t   &parm_map);\n   return changed;\n }\n \n@@ -672,16 +663,16 @@ analyze_call (modref_summary *cur_summary,\n     {\n       if (ignore_stores)\n \t{\n-\t  if (cur_summary->loads)\n-\t    cur_summary->loads->collapse ();\n+\t  cur_summary->loads->collapse ();\n \t  return true;\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \" - No modref summary available for callee.\\n\");\n       return false;\n     }\n \n-  merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores);\n+  merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n+\t\t\t   callee_node);\n \n   return true;\n }\n@@ -853,7 +844,10 @@ analyze_function (function *f, bool ipa)\n       else /* Remove existing summary if we are re-running the pass.  */\n \t{\n \t  if (dump_file\n-\t      && optimization_summaries->get (cgraph_node::get (f->decl)))\n+\t      && (summary\n+\t\t  = optimization_summaries->get (cgraph_node::get (f->decl)))\n+\t\t != NULL\n+\t      && summary->loads)\n \t    {\n \t      fprintf (dump_file, \"Past summary:\\n\");\n \t      optimization_summaries->get\n@@ -950,7 +944,8 @@ analyze_function (function *f, bool ipa)\n \t\t\t  (summary, recursive_calls[i], summary,\n \t\t\t   ignore_stores_p (current_function_decl,\n \t\t\t\t\t    gimple_call_flags\n-\t\t\t\t\t\t (recursive_calls[i])));\n+\t\t\t\t\t\t (recursive_calls[i])),\n+\t\t\t   fnode);\n \t      if (!summary->useful_p (ecf_flags))\n \t\t{\n \t\t  remove_summary (lto, nolto, ipa);\n@@ -1005,18 +1000,19 @@ modref_generate (void)\n void\n modref_summaries::insert (struct cgraph_node *node, modref_summary *)\n {\n-  if (!DECL_STRUCT_FUNCTION (node->decl))\n+  /* Local passes ought to be executed by the pass manager.  */\n+  if (this == optimization_summaries)\n     {\n       optimization_summaries->remove (node);\n+      return;\n+    }\n+  if (!DECL_STRUCT_FUNCTION (node->decl))\n+    {\n       summaries->remove (node);\n+      return;\n     }\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  /* This is not very pretty: We do not know if we insert into optimization\n-     summary or summary.  Do both but check for duplicated effort.  */\n-  if (optimization_summaries && !optimization_summaries->get (node)->loads)\n-    analyze_function (DECL_STRUCT_FUNCTION (node->decl), false);\n-  if (summaries && !summaries->get (node)->loads)\n-    analyze_function (DECL_STRUCT_FUNCTION (node->decl), true);\n+  analyze_function (DECL_STRUCT_FUNCTION (node->decl), true);\n   pop_cfun ();\n }\n \n@@ -1042,26 +1038,27 @@ modref_summaries_lto::insert (struct cgraph_node *node, modref_summary_lto *)\n /* Called when new clone is inserted to callgraph late.  */\n \n void\n-modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n+modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n \t\t\t     modref_summary *src_data,\n \t\t\t     modref_summary *dst_data)\n {\n-  if (src_data->stores)\n+  /* Do not duplicte optimization summaries; we do not handle parameter\n+     transforms on them.  */\n+  if (this == optimization_summaries)\n     {\n-      dst_data->stores = modref_records::create_ggc\n-\t\t\t    (src_data->stores->max_bases,\n-\t\t\t     src_data->stores->max_refs,\n-\t\t\t     src_data->stores->max_accesses);\n-      dst_data->stores->copy_from (src_data->stores);\n-    }\n-  if (src_data->loads)\n-    {\n-      dst_data->loads = modref_records::create_ggc\n-\t\t\t    (src_data->loads->max_bases,\n-\t\t\t     src_data->loads->max_refs,\n-\t\t\t     src_data->loads->max_accesses);\n-      dst_data->loads->copy_from (src_data->loads);\n+      optimization_summaries->remove (dst);\n+      return;\n     }\n+  dst_data->stores = modref_records::create_ggc\n+\t\t\t(src_data->stores->max_bases,\n+\t\t\t src_data->stores->max_refs,\n+\t\t\t src_data->stores->max_accesses);\n+  dst_data->stores->copy_from (src_data->stores);\n+  dst_data->loads = modref_records::create_ggc\n+\t\t\t(src_data->loads->max_bases,\n+\t\t\t src_data->loads->max_refs,\n+\t\t\t src_data->loads->max_accesses);\n+  dst_data->loads->copy_from (src_data->loads);\n }\n \n /* Called when new clone is inserted to callgraph late.  */\n@@ -1071,22 +1068,16 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t\t modref_summary_lto *src_data,\n \t\t\t\t modref_summary_lto *dst_data)\n {\n-  if (src_data->stores)\n-    {\n-      dst_data->stores = modref_records_lto::create_ggc\n-\t\t\t    (src_data->stores->max_bases,\n-\t\t\t     src_data->stores->max_refs,\n-\t\t\t     src_data->stores->max_accesses);\n-      dst_data->stores->copy_from (src_data->stores);\n-    }\n-  if (src_data->loads)\n-    {\n-      dst_data->loads = modref_records_lto::create_ggc\n-\t\t\t    (src_data->loads->max_bases,\n-\t\t\t     src_data->loads->max_refs,\n-\t\t\t     src_data->loads->max_accesses);\n-      dst_data->loads->copy_from (src_data->loads);\n-    }\n+  dst_data->stores = modref_records_lto::create_ggc\n+\t\t\t(src_data->stores->max_bases,\n+\t\t\t src_data->stores->max_refs,\n+\t\t\t src_data->stores->max_accesses);\n+  dst_data->stores->copy_from (src_data->stores);\n+  dst_data->loads = modref_records_lto::create_ggc\n+\t\t\t(src_data->loads->max_bases,\n+\t\t\t src_data->loads->max_refs,\n+\t\t\t src_data->loads->max_accesses);\n+  dst_data->loads->copy_from (src_data->loads);\n }\n \n namespace\n@@ -1154,7 +1145,7 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n \t  modref_access_node *access_node;\n \t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n \t    {\n-\t      streamer_write_uhwi (ob, access_node->parm_index);\n+\t      streamer_write_hwi (ob, access_node->parm_index);\n \t      if (access_node->parm_index != -1)\n \t\t{\n \t\t  streamer_write_uhwi (ob, access_node->parm_offset_known);\n@@ -1278,7 +1269,7 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \n \t  for (size_t k = 0; k < naccesses; k++)\n \t    {\n-\t      int parm_index = streamer_read_uhwi (ib);\n+\t      int parm_index = streamer_read_hwi (ib);\n \t      bool parm_offset_known = false;\n \t      poly_int64 parm_offset = 0;\n \t      poly_int64 offset = 0;\n@@ -1358,12 +1349,8 @@ modref_write ()\n \n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n \n-\t  streamer_write_uhwi (ob, r->loads ? 1 : 0);\n-\t  streamer_write_uhwi (ob, r->stores ? 1 : 0);\n-\t  if (r->loads)\n-\t    write_modref_records (r->loads, ob);\n-\t  if (r->stores)\n-\t    write_modref_records (r->stores, ob);\n+\t  write_modref_records (r->loads, ob);\n+\t  write_modref_records (r->stores, ob);\n \t}\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n@@ -1406,8 +1393,6 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n       modref_summary_lto *modref_sum_lto = summaries_lto\n \t\t\t\t\t   ? summaries_lto->get_create (node)\n \t\t\t\t\t   : NULL;\n-      int have_loads = streamer_read_uhwi (&ib);\n-      int have_stores = streamer_read_uhwi (&ib);\n \n       if (optimization_summaries)\n \tmodref_sum = optimization_summaries->get_create (node);\n@@ -1416,14 +1401,12 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \t\t\t\t  && !modref_sum->stores));\n       gcc_assert (!modref_sum_lto || (!modref_sum_lto->loads\n \t\t\t\t      && !modref_sum_lto->stores));\n-      if (have_loads)\n-\t read_modref_records (&ib, data_in,\n-\t\t\t      modref_sum ? &modref_sum->loads : NULL,\n-\t\t\t      modref_sum_lto ? &modref_sum_lto->loads : NULL);\n-      if (have_stores)\n-\t read_modref_records (&ib, data_in,\n-\t\t\t      modref_sum ? &modref_sum->stores : NULL,\n-\t\t\t      modref_sum_lto ? &modref_sum_lto->stores : NULL);\n+      read_modref_records (&ib, data_in,\n+\t\t\t   modref_sum ? &modref_sum->loads : NULL,\n+\t\t\t   modref_sum_lto ? &modref_sum_lto->loads : NULL);\n+      read_modref_records (&ib, data_in,\n+\t\t\t   modref_sum ? &modref_sum->stores : NULL,\n+\t\t\t   modref_sum_lto ? &modref_sum_lto->stores : NULL);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Read modref for %s\\n\",\n@@ -1598,9 +1581,6 @@ class pass_ipa_modref : public ipa_opt_pass_d\n \n unsigned int pass_modref::execute (function *f)\n {\n-  /* If new function is being added during IPA, we can skip analysis.  */\n-  if (!optimization_summaries)\n-    return 0;\n   analyze_function (f, false);\n   return 0;\n }\n@@ -1628,7 +1608,7 @@ ignore_edge (struct cgraph_edge *e)\n \t\t\t  (&avail, e->caller);\n \n   return (avail <= AVAIL_INTERPOSABLE\n-\t  || ((!summaries || !summaries->get (callee))\n+\t  || ((!optimization_summaries || !optimization_summaries->get (callee))\n \t      && (!summaries_lto || !summaries_lto->get (callee)))\n \t  || flags_from_decl_or_type (e->callee->decl)\n \t     & (ECF_CONST | ECF_NOVOPS));\n@@ -1684,7 +1664,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t  if (jf && jf->type == IPA_JF_PASS_THROUGH)\n \t    {\n \t      (*parm_map)[i].parm_index\n-\t\t = ipa_get_jf_pass_through_formal_id (jf);\n+\t\t= ipa_get_jf_pass_through_formal_id (jf);\n \t      (*parm_map)[i].parm_offset_known\n \t\t= ipa_get_jf_pass_through_operation (jf) == NOP_EXPR;\n \t      (*parm_map)[i].parm_offset = 0;\n@@ -1921,6 +1901,8 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t\toptimization_summaries->remove (node);\n \t\t      if (summaries_lto)\n \t\t\tsummaries_lto->remove (node);\n+\t\t      cur_summary = NULL;\n+\t\t      cur_summary_lto = NULL;\n \t\t      changed = true;\n \t\t      break;\n \t\t    }\n@@ -2009,19 +1991,17 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      /* Merge in callee's information.  */\n \t      if (callee_summary)\n \t\t{\n-\t\t  if (callee_summary->loads)\n-\t\t    changed |= cur_summary->loads->merge\n-\t\t\t\t    (callee_summary->loads, &parm_map);\n-\t\t  if (callee_summary->stores)\n+\t\t  changed |= cur_summary->loads->merge\n+\t\t\t\t  (callee_summary->loads, &parm_map);\n+\t\t  if (!ignore_stores)\n \t\t    changed |= cur_summary->stores->merge\n \t\t\t\t    (callee_summary->stores, &parm_map);\n \t\t}\n \t      if (callee_summary_lto)\n \t\t{\n-\t\t  if (callee_summary_lto->loads)\n-\t\t    changed |= cur_summary_lto->loads->merge\n-\t\t\t\t    (callee_summary_lto->loads, &parm_map);\n-\t\t  if (callee_summary_lto->stores)\n+\t\t  changed |= cur_summary_lto->loads->merge\n+\t\t\t\t  (callee_summary_lto->loads, &parm_map);\n+\t\t  if (!ignore_stores)\n \t\t    changed |= cur_summary_lto->stores->merge\n \t\t\t\t    (callee_summary_lto->stores, &parm_map);\n \t\t}"}]}