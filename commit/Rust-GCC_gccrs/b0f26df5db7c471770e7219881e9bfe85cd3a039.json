{"sha": "b0f26df5db7c471770e7219881e9bfe85cd3a039", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmMjZkZjVkYjdjNDcxNzcwZTcyMTk4ODFlOWJmZTg1Y2QzYTAzOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-24T13:02:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-24T13:02:42Z"}, "message": "re PR ada/12014 (strcpy used with overlapping arguments)\n\n\t* adadecode.c (ostrcpy): New function.\n\t(__gnat_decode): Use ostrcpy of strcpy.\n\t(has_prefix): Set first parameter a const.\n\t(has_suffix): Set first parameter a const.\n\tUpdate copyright notice. Fix source name in header.\n\tRemoves a trailing space.\n\tPR ada/12014.\n\n\t* exp_disp.adb:\n\tRemove the test against being in No_Run_Time_Mode before generating a\n\tcall to Register_Tag. It is redundant with the test against the\n\tavailability of the function Register_Tag.\n\n\t* g-catiio.adb: (Month_Name): Correct spelling of February\n\n\t* make.adb: (Mains): New package\n\t(Initialize): Call Mains.Delete\n\t(Gnatmake): Check that each main on the command line is a source of a\n\tproject file and, if there are several mains, each of them is a source\n\tof the same project file.\n\t(Gnatmake): When a foreign language is specified in attribute Languages,\n\tno main is specified on the command line and attribute Mains is not\n\tempty, only build the Ada main. If there is no Ada main, just compile\n\tthe Ada sources and their closure.\n\t(Gnatmake): If a main is specified on the command line with directory\n\tinformation, check that the source exists and, if it does, that the path\n\tis the actual path of a source of a project.\n\n\t* prj-env.adb:\n\t(File_Name_Of_Library_Unit_Body): New Boolean parameter Full_Path. When\n\tFull_Path is True, return the full path instead of the simple file name.\n\t(Project_Of): New function\n\n\t* prj-env.ads:\n\t(File_Name_Of_Library_Unit_Body): New Boolean parameter Full_Path,\n\tdefaulted to False.\n\t(Project_Of): New function\n\n\t* Makefile.generic:\n\tEnsure objects of main project are always checked and rebuilt if needed.\n\tSet CC to gcc by default.\n\tPrepare new handling of link by creating a global archive (not activated\n\tyet).\n\n\t* adadecode.h, atree.h, elists.h, nlists.h, raise.h,\n\tstringt.h: Update copyright notice. Remove trailing blanks.\n\tFix source name in header.\n\n\t* sem_ch12.adb: Minor reformatting\n\n\t* sem_ch3.adb:\n\tMinor reformatting (including new function return style throughout)\n\n\t* sem_ch3.ads:\n\tMinor reformatting (including new function return style throughout)\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r72893", "tree": {"sha": "897ca34543cba57ab757439fcdd09dd83b34f5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897ca34543cba57ab757439fcdd09dd83b34f5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0f26df5db7c471770e7219881e9bfe85cd3a039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f26df5db7c471770e7219881e9bfe85cd3a039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0f26df5db7c471770e7219881e9bfe85cd3a039", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f26df5db7c471770e7219881e9bfe85cd3a039/comments", "author": null, "committer": null, "parents": [{"sha": "bf22935f99c213b406b368ccdbff2572a8d08df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf22935f99c213b406b368ccdbff2572a8d08df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf22935f99c213b406b368ccdbff2572a8d08df0"}], "stats": {"total": 2696, "additions": 1380, "deletions": 1316}, "files": [{"sha": "4ce68a6057dea6b97c53aae60f708cb29857c52c", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 797, "deletions": 1202, "changes": 1999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039"}, {"sha": "bdba19c5052ee46062976a42769a039f3d610b62", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -47,6 +47,7 @@\n # CXX              name of the C++ compiler (optional, default to gcc)\n # AR_CMD           command to create an archive (optional, default to \"ar rc\")\n # AR_EXT           file extension of an archive (optional, default to \".a\")\n+# RANLIB        command to generate an index (optional, default to \"ranlib\")\n # GNATMAKE         name of the GNAT builder (optional, default to \"gnatmake\")\n # ADAFLAGS         additional Ada compilation switches, e.g \"-gnatf\" (optional)\n # CFLAGS           default C compilation switches, e.g \"-O2 -g\" (optional)\n@@ -56,6 +57,7 @@\n # ADA_SOURCES      list of main Ada sources (optional)\n # EXEC             name of the final executable (optional)\n # MAIN             language of the main program (optional)\n+# MAIN_OBJECT      main object file (optional)\n # PROJECT_FILE     name of the project file, without the .gpr extension\n # DEPS_PROJECTS    list of project dependencies (optional)\n \n@@ -65,6 +67,10 @@ ifndef MAIN\n    MAIN=ada\n endif\n \n+ifndef CC\n+   CC=gcc\n+endif\n+\n ifndef ADA_SPEC\n    ADA_SPEC=.ads\n endif\n@@ -100,10 +106,18 @@ ifndef AR_CMD\n    AR_CMD=ar rc\n endif\n \n+ifndef RANLIB\n+   RANLIB=ranlib\n+endif\n+\n ifndef GNATMAKE\n    GNATMAKE=gnatmake\n endif\n \n+ifndef ARCHIVE\n+   ARCHIVE=$(OBJ_DIR)/lib$(PROJECT_BASE)-full$(AR_EXT)\n+endif\n+\n ifeq ($(EXEC_DIR),)\n    EXEC_DIR=$(OBJ_DIR)\n endif\n@@ -120,6 +134,7 @@ vpath %$(AR_EXT) $(OBJ_DIR)\n \n clean_deps = $(subst :,|,$(DEPS_PROJECTS:%=clean_%))\n compile_deps = $(subst :,|,$(DEPS_PROJECTS:%=compile_%))\n+object_deps = $(subst :,|,$(DEPS_PROJECTS:%=object_%))\n ada_deps = $(subst :,|,$(DEPS_PROJECTS:%=ada_%))\n c_deps = $(subst :,|,$(DEPS_PROJECTS:%=c_%))\n c++_deps = $(subst :,|,$(DEPS_PROJECTS:%=c++_%))\n@@ -131,6 +146,7 @@ clean: $(clean_deps) internal-clean\n build: $(compile_deps) internal-compile internal-build\n compile: $(compile_deps) internal-compile $(ADA_SOURCES)\n ada: $(ada_deps) internal-ada\n+archive-objects: $(object_deps) internal-archive-objects\n c: $(c_deps) internal-c\n c++: $(c++deps) internal-c++\n \n@@ -140,6 +156,9 @@ $(clean_deps): force\n $(compile_deps): force\n \t@$(MAKE) -C $(dir $(subst |,:,$(@:compile_%=%))) -f Makefile.$(notdir $@) internal-compile\n \n+$(object_deps): force\n+\t@$(MAKE) -C $(dir $(@:object_%=%)) -f Makefile.$(notdir $@) internal-archive-objects ARCHIVE=$(ARCHIVE)\n+\n $(ada_deps): force\n \t@$(MAKE) -C $(dir $(subst |,:,$(@:ada_%=%))) -f Makefile.$(notdir $@) internal-ada\n \n@@ -238,14 +257,21 @@ DEP_FILES := $(OBJ_FILES:$(OBJ_EXT)=.d)\n \n ifeq ($(strip $(OBJECTS)),)\n internal-compile:\n+internal-archive-objects:\n \n else\n internal-compile: lib$(PROJECT_BASE)$(AR_EXT)\n \n lib$(PROJECT_BASE)$(AR_EXT): $(OBJECTS)\n \t@echo creating archive file for $(PROJECT_BASE)\n \tcd $(OBJ_DIR); $(AR_CMD) $@ $(strip $(OBJECTS))\n-\t-ranlib $(OBJ_DIR)/$@\n+\t-$(RANLIB) $(OBJ_DIR)/$@\n+\n+internal-archive-objects: $(OBJECTS)\n+#\t@echo $(AR_CMD) $(ARCHIVE) $(strip $(OBJECTS))\n+#\tcd $(OBJ_DIR); $(AR_CMD) $(ARCHIVE) $(strip $(OBJECTS))\n+#\t-$(RANLIB) $(OBJ_DIR)/$@\n+\n endif\n \n # Linking rules\n@@ -260,9 +286,24 @@ endif\n \n ifeq ($(strip $(filter-out c c++,$(LANGUAGES))),)\n # link with C/C++\n-link: $(EXEC_DIR)/$(EXEC)\n+ifeq ($(MAIN_OBJECT),)\n+link:\n+\t@echo link: no main object specified, exiting...\n+\texit 1\n+else\n+ifeq ($(EXEC),)\n+\n+link:\n+\t@echo link: no executable specified, exiting...\n+\texit 1\n+else\n+\n+link: $(EXEC_DIR)/$(EXEC) archive-objects\n $(EXEC_DIR)/$(EXEC): $(OBJ_FILES)\n-\t$(LINKER) $(OBJ_FILES) -o $(EXEC_DIR)/$(EXEC) $(LDFLAGS)\n+\t@echo $(LINKER) -o $(EXEC_DIR)/$(EXEC) $(OBJ_DIR)/$(MAIN_OBJECT) $(LDFLAGS)\n+\t$(LINKER) -o $(EXEC_DIR)/$(EXEC) $(OBJ_DIR)/$(MAIN_OBJECT) $(LDFLAGS)\n+endif\n+endif\n \n internal-build: internal-compile link\n \n@@ -272,11 +313,11 @@ ifeq ($(strip $(filter-out c c++ ada,$(LANGUAGES))),)\n \n ifeq ($(MAIN),ada)\n # Ada main\n-link: $(LINKER) force\n+link: $(LINKER) archive-objects force\n \t$(GNATMAKE) -b -l -P$(PROJECT_FILE) $(ADA_SOURCES) \\\n \t\t -largs $(LARGS) $(LDFLAGS)\n \n-internal-build: $(LINKER) force\n+internal-build: $(LINKER) archive-objects force\n \t@echo $(GNATMAKE) -P$(PROJECT_FILE) $(ADA_SOURCES) $(EXEC_RULE) $(ADAFLAGS)\n \t@$(GNATMAKE) -P$(PROJECT_FILE) $(EXEC_RULE) $(ADA_SOURCES) $(ADAFLAGS) \\\n \t -largs $(LARGS) $(LDFLAGS)\n@@ -288,11 +329,11 @@ else\n # close enough to our needs, and the usual -n gnatbind switch and --LINK=\n # gnatlink switch.\n \n-link: $(LINKER) force\n+link: $(LINKER) archive-objects force\n \t$(GNATMAKE) $(EXEC_RULE) -z -P$(PROJECT_FILE) $(ADA_SOURCES) \\\n \t\t -bargs -n -largs $(LARGS) $(LDFLAGS)\n \n-internal-build: $(LINKER) force\n+internal-build: $(LINKER) archive-objects force\n \t@echo $(GNATMAKE) -z -P$(PROJECT_FILE) $(ADA_SOURCES) $(EXEC_RULE) $(ADAFLAGS)\n \t@$(GNATMAKE) $(EXEC_RULE) -z \\\n \t\t -P$(PROJECT_FILE) $(ADA_SOURCES) $(ADAFLAGS) \\\n@@ -385,7 +426,7 @@ internal-c : $(C_OBJECTS)\n # Compile all C++ files in the project\n internal-c++ : $(CXX_OBJECTS)\n \n-.PHONY: force internal-clean internal-build internal-compile internal-ada internal-c internal-c++ build compile clean ada c c++\n+.PHONY: force internal-clean internal-archive internal-build internal-compile internal-ada internal-c internal-c++ build compile clean ada c c++\n \n internal-clean:\n \t@echo $(RM) $(OBJ_DIR)/*$(OBJ_EXT)"}, {"sha": "928b838ab197089b223d94e0b8bfc32e6970da75", "filename": "gcc/ada/adadecode.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fadadecode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fadadecode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.c?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -2,11 +2,11 @@\n  *                                                                          *\n  *                         GNAT COMPILER COMPONENTS                         *\n  *                                                                          *\n- *                             G N A T D E C O                              *\n+ *                            A D A D E C O D E                             *\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *           Copyright (C) 2001-2002, Free Software Foundation, Inc.        *\n+ *           Copyright (C) 2001-2003, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -42,8 +42,12 @@\n #include \"adadecode.h\"\n \n static void add_verbose\tPARAMS ((const char *, char *));\n-static int has_prefix\tPARAMS ((char *, const char *));\n-static int has_suffix\tPARAMS ((char *, const char *));\n+static int has_prefix\tPARAMS ((const char *, const char *));\n+static int has_suffix\tPARAMS ((const char *, const char *));\n+\n+/* This is a safe version of strcpy that can be used with overlapped\n+   pointers. Does nothing if s2 <= s1.  */\n+static void ostrcpy (char *s1, char *s2);\n \n /* Set to nonzero if we have written any verbose info.  */\n static int verbose_info;\n@@ -65,7 +69,7 @@ static void add_verbose (text, ada_name)\n \n static int\n has_prefix (name, prefix)\n-     char *name;\n+     const char *name;\n      const char *prefix;\n {\n   return strncmp (name, prefix, strlen (prefix)) == 0;\n@@ -75,7 +79,7 @@ has_prefix (name, prefix)\n \n static int\n has_suffix (name, suffix)\n-     char *name;\n+     const char *name;\n      const char *suffix;\n {\n   int nlen = strlen (name);\n@@ -84,6 +88,18 @@ has_suffix (name, suffix)\n   return nlen > slen && strncmp (name + nlen - slen, suffix, slen) == 0;\n }\n \n+/* Safe overlapped pointers version of strcpy.  */\n+\n+static void\n+ostrcpy (char *s1, char *s2)\n+{\n+  if (s2 > s1)\n+    {\n+      while (*s2) *s1++ = *s2++;\n+      *s1 = '\\0';\n+    }\n+}\n+\n /* This function will return the Ada name from the encoded form.\n    The Ada coding is done in exp_dbug.ads and this is the inverse function.\n    see exp_dbug.ads for full encoding rules, a short description is added\n@@ -142,16 +158,14 @@ __gnat_decode (coded_name, ada_name, verbose)\n   int in_task = 0;\n   int body_nested = 0;\n \n-  /* Copy the coded name into the ada name string, the rest of the code will\n-     just replace or add characters into the ada_name.  */\n-  strcpy (ada_name, coded_name);\n-\n   /* Check for library level subprogram.  */\n-  if (has_prefix (ada_name, \"_ada_\"))\n+  if (has_prefix (coded_name, \"_ada_\"))\n     {\n-      strcpy (ada_name, ada_name + 5);\n+      strcpy (ada_name, coded_name + 5);\n       lib_subprog = 1;\n     }\n+  else\n+    strcpy (ada_name, coded_name);\n \n   /* Check for task body.  */\n   if (has_suffix (ada_name, \"TKB\"))\n@@ -191,7 +205,7 @@ __gnat_decode (coded_name, ada_name, verbose)\n \n     while ((tktoken = (char *) strstr (ada_name, \"TK__\")) != NULL)\n       {\n-\tstrcpy (tktoken, tktoken + 2);\n+\tostrcpy (tktoken, tktoken + 2);\n \tin_task = 1;\n       }\n   }\n@@ -229,7 +243,7 @@ __gnat_decode (coded_name, ada_name, verbose)\n \tif (ada_name[k] == '_' && ada_name[k+1] == '_')\n \t  {\n \t    ada_name[k] = '.';\n-\t    strcpy (ada_name + k + 1, ada_name + k + 2);\n+\t    ostrcpy (ada_name + k + 1, ada_name + k + 2);\n \t    len = len - 1;\n \t  }\n \tk++;\n@@ -259,7 +273,7 @@ __gnat_decode (coded_name, ada_name, verbose)\n \n \t    if (codedlen > oplen)\n \t      /* We shrink the space.  */\n-\t      strcpy (optoken, optoken + codedlen - oplen);\n+\t      ostrcpy (optoken, optoken + codedlen - oplen);\n \t    else if (oplen > codedlen)\n \t      {\n \t\t/* We need more space.  */\n@@ -285,7 +299,7 @@ __gnat_decode (coded_name, ada_name, verbose)\n   }\n \n   /* If verbose mode is on, we add some information to the Ada name.  */\n-  if (verbose) \n+  if (verbose)\n     {\n       if (overloaded)\n \tadd_verbose (\"overloaded\", ada_name);"}, {"sha": "12220908b0114b0cbb5dc743a14f16fb0c6638b2", "filename": "gcc/ada/adadecode.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fadadecode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fadadecode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.h?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -2,11 +2,11 @@\n  *                                                                          *\n  *                         GNAT COMPILER COMPONENTS                         *\n  *                                                                          *\n- *                             G N A T D E C O                              *\n+ *                            A D A D E C O D E                             *\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *           Copyright (C) 2001-2002, Free Software Foundation, Inc.        *\n+ *           Copyright (C) 2001-2003, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "3c40799f4bbff83b209969175f09368a52d6c36d", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -235,7 +235,7 @@ struct Extended\n   Int\t       field8;\n   Int\t       field9;\n   Int\t       field10;\n-  union     \n+  union\n     {\n       Int      field11;\n       struct Flag_Word3 fw3;"}, {"sha": "3358792e14534bc1e1d6ff43b9a2014dd58bff40", "filename": "gcc/ada/elists.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Felists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Felists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.h?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2001 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "c9ba3be354f90497c9dd27fe1e15e79cf57f6bdd", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -922,11 +922,10 @@ package body Exp_Disp is\n \n       --        Register_Tag (Dt_Ptr);\n \n-      --  Skip this if routine not available, or in No_Run_Time mode\n+      --  Skip this if routine not available\n \n          if RTE_Available (RE_Register_Tag)\n            and then Is_RTE (Generalized_Tag, RE_Tag)\n-           and then not No_Run_Time_Mode\n          then\n             Append_To (Elab_Code,\n               Make_Procedure_Call_Statement (Loc,"}, {"sha": "615dfbd54b55d0308f49845da114bd41462f6fb9", "filename": "gcc/ada/g-catiio.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fg-catiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fg-catiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -44,7 +44,7 @@ package body GNAT.Calendar.Time_IO is\n \n    type Month_Name is\n      (January,\n-      Febuary,\n+      February,\n       March,\n       April,\n       May,"}, {"sha": "3ebec3d7d839e6a4a9257427ad89e2e0614221a7", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 317, "deletions": 6, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -28,6 +28,7 @@ with Ada.Exceptions;   use Ada.Exceptions;\n with Ada.Command_Line; use Ada.Command_Line;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.Case_Util;            use GNAT.Case_Util;\n \n with ALI;      use ALI;\n with ALI.Util; use ALI.Util;\n@@ -178,6 +179,31 @@ package body Make is\n      Table_Name           => \"Make.Q\");\n    --  This is the actual Q.\n \n+\n+   --  Package Mains is used to store the mains specified on the command line\n+   --  and to retrieve them when a project file is used, to verify that the\n+   --  files exist and that they belong to a project file.\n+\n+   package Mains is\n+\n+      --  Mains are stored in a table. An index is used to retrieve the mains\n+      --  from the table.\n+\n+      procedure Add_Main (Name : String);\n+      --  Add one main to the table\n+\n+      procedure Delete;\n+      --  Empty the table\n+\n+      procedure Reset;\n+      --  Reset the index to the beginning of the table\n+\n+      function Next_Main return String;\n+      --  Increase the index and return the next main.\n+      --  If table is exhausted, return an empty string.\n+\n+   end Mains;\n+\n    --  The following instantiations and variables are necessary to save what\n    --  is found on the command line, in case there is a project file specified.\n \n@@ -3340,6 +3366,147 @@ package body Make is\n             if Projects.Table (Main_Project).Library then\n                Make_Failed (\"cannot specify a main program \" &\n                             \"on the command line for a library project file\");\n+\n+            else\n+               --  Check that each main on the command line is a source of a\n+               --  project file and, if there are several mains, each of them\n+               --  is a source of the same project file.\n+\n+               Mains.Reset;\n+\n+               declare\n+                  Real_Main_Project : Project_Id := No_Project;\n+                  --  The project of the first main\n+\n+                  Proj : Project_Id := No_Project;\n+                  --  The project of the current main\n+\n+               begin\n+                  --  Check each main\n+\n+                  loop\n+                     declare\n+                        Main      : constant String := Mains.Next_Main;\n+                        --  The name specified on the command line may include\n+                        --  directory information.\n+\n+                        File_Name : constant String := Base_Name (Main);\n+                        --  The simple file name of the current main main\n+\n+                     begin\n+                        exit when Main = \"\";\n+\n+                        --  Get the project of the current main\n+\n+                        Proj := Prj.Env.Project_Of (File_Name, Main_Project);\n+\n+                        --  Fail if the current main is not a source of a\n+                        --  project.\n+\n+                        if Proj = No_Project then\n+                           Make_Failed\n+                             (\"\"\"\" & Main &\n+                              \"\"\" is not a source of any project\");\n+\n+                        else\n+                           --  If there is directory information, check that\n+                           --  the source exists and, if it does, that the path\n+                           --  is the actual path of a source of a project.\n+\n+                           if Main /= File_Name then\n+                              declare\n+                                 Data : constant Project_Data :=\n+                                   Projects.Table (Main_Project);\n+\n+                                 Project_Path : constant String :=\n+                                   Prj.Env.File_Name_Of_Library_Unit_Body\n+                                     (Name              => File_Name,\n+                                      Project           => Main_Project,\n+                                      Main_Project_Only => False,\n+                                      Full_Path         => True);\n+                                 Real_Path : String_Access :=\n+                                   Locate_Regular_File\n+                                     (Main &\n+                                      Get_Name_String\n+                                        (Data.Naming.Current_Body_Suffix),\n+                                      \"\");\n+                              begin\n+                                 if Real_Path = null then\n+                                    Real_Path :=\n+                                      Locate_Regular_File\n+                                        (Main &\n+                                         Get_Name_String\n+                                           (Data.Naming.Current_Spec_Suffix),\n+                                         \"\");\n+                                 end if;\n+\n+                                 if Real_Path = null then\n+                                    Real_Path :=\n+                                      Locate_Regular_File (Main, \"\");\n+                                 end if;\n+\n+                                 --  Fail if the file cannot be found\n+\n+                                 if Real_Path = null then\n+                                    Make_Failed\n+                                      (\"file \"\"\" & Main & \"\"\" does not exist\");\n+                                 end if;\n+\n+                                 declare\n+                                    Normed_Path : constant String :=\n+                                      Normalize_Pathname\n+                                        (Real_Path.all,\n+                                         Case_Sensitive => False);\n+                                 begin\n+                                    Free (Real_Path);\n+\n+                                    --  Fail if it is not the correct path\n+\n+                                    if Normed_Path /= Project_Path then\n+                                       if Verbose_Mode then\n+                                          Write_Str (Normed_Path);\n+                                          Write_Str (\" /= \");\n+                                          Write_Line (Project_Path);\n+                                       end if;\n+\n+                                       Make_Failed\n+                                         (\"\"\"\" & Main &\n+                                          \"\"\" is not a source of any project\");\n+                                    end if;\n+                                 end;\n+                              end;\n+                           end if;\n+\n+                           if not Unique_Compile then\n+                              --  Record the project, if it is the first main\n+\n+                              if Real_Main_Project = No_Project then\n+                                 Real_Main_Project := Proj;\n+\n+                              elsif Proj /= Real_Main_Project then\n+                                 --  Fail, as the current main is not a source\n+                                 --  of the same project as the first main.\n+\n+                                 Make_Failed\n+                                   (\"\"\"\" & Main &\n+                                    \"\"\" is not a source of project \" &\n+                                    Get_Name_String\n+                                      (Projects.Table\n+                                         (Real_Main_Project).Name));\n+                              end if;\n+                           end if;\n+                        end if;\n+\n+                        --  If -u and -U are not used, we may have mains that\n+                        --  are sources of a project that is not the one\n+                        --  specified with switch -P.\n+\n+                        if not Unique_Compile then\n+                           Main_Project := Real_Main_Project;\n+                        end if;\n+                     end;\n+                  end loop;\n+               end;\n             end if;\n \n          --  If no mains have been specified on the command line,\n@@ -3383,13 +3550,92 @@ package body Make is\n                else\n                   --  The attribute Main is not an empty list.\n                   --  Put all the main subprograms in the list as if there\n-                  --  were specified on the command line.\n+                  --  were specified on the command line. However, if attribute\n+                  --  Languages includes a language other than Ada, only\n+                  --  include the Ada mains; if there is no Ada main, compile\n+                  --  all the sources of the project.\n \n-                  while Value /= Prj.Nil_String loop\n-                     Get_Name_String (String_Elements.Table (Value).Value);\n-                     Osint.Add_File (Name_Buffer (1 .. Name_Len));\n-                     Value := String_Elements.Table (Value).Next;\n-                  end loop;\n+                  declare\n+                     Data : Project_Data := Projects.Table (Main_Project);\n+                     Languages : Variable_Value :=\n+                       Prj.Util.Value_Of\n+                         (Name_Languages, Data.Decl.Attributes);\n+                     Current : String_List_Id;\n+                     Element : String_Element;\n+                     Foreign_Language  : Boolean := False;\n+                     At_Least_One_Main : Boolean := False;\n+\n+                  begin\n+                     --  First, determine if there is a foreign language in\n+                     --  attribute Languages.\n+\n+                     if not Languages.Default then\n+                        Current := Languages.Values;\n+\n+                        Look_For_Foreign :\n+                        while Current /= Nil_String loop\n+                           Element := String_Elements.Table (Current);\n+                           Get_Name_String (Element.Value);\n+                           To_Lower (Name_Buffer (1 .. Name_Len));\n+\n+                           if Name_Buffer (1 .. Name_Len) /= \"ada\" then\n+                              Foreign_Language := True;\n+                              exit Look_For_Foreign;\n+                           end if;\n+\n+                           Current := Element.Next;\n+                        end loop Look_For_Foreign;\n+                     end if;\n+\n+                     --  The, find all mains, or if there is a foreign\n+                     --  language, all the Ada mains.\n+\n+                     while Value /= Prj.Nil_String loop\n+                        Get_Name_String (String_Elements.Table (Value).Value);\n+\n+                        --  To know if a main is an Ada main, get its project;\n+                        --  it should be the project specified on the command\n+                        --  line.\n+\n+                        if (not Foreign_Language) or else\n+                            Prj.Env.Project_Of\n+                              (Name_Buffer (1 .. Name_Len), Main_Project) =\n+                             Main_Project\n+                        then\n+                           At_Least_One_Main := True;\n+                           Osint.Add_File\n+                             (Get_Name_String\n+                                (String_Elements.Table (Value).Value));\n+                        end if;\n+\n+                        Value := String_Elements.Table (Value).Next;\n+                     end loop;\n+\n+                     --  If we did not get any main, it means that all mains\n+                     --  in attribute Mains are in a foreign language. So,\n+                     --  we put all sources of the main project in the Q.\n+\n+                     if not At_Least_One_Main then\n+                        --  First make sure that the binder and the linker\n+                        --  will not be invoked.\n+\n+                        Do_Bind_Step := False;\n+                        Do_Link_Step := False;\n+\n+                        --  Put all the sources in the queue\n+\n+                        Insert_Project_Sources\n+                          (The_Project  => Main_Project,\n+                           All_Projects => Unique_Compile_All_Projects,\n+                           Into_Q       => False);\n+\n+                        --  If there are no sources to compile, we fail\n+\n+                        if Osint.Number_Of_Files = 0 then\n+                           Make_Failed (\"no sources to compile\");\n+                        end if;\n+                     end if;\n+                  end;\n \n                end if;\n             end;\n@@ -5256,6 +5502,8 @@ package body Make is\n \n       RTS_Specified := null;\n \n+      Mains.Delete;\n+\n       Next_Arg := 1;\n       Scan_Args : while Next_Arg <= Argument_Count loop\n          Scan_Make_Arg (Argument (Next_Arg), And_Save => True);\n@@ -5850,6 +6098,68 @@ package body Make is\n       Set_Standard_Error;\n    end List_Depend;\n \n+   -----------\n+   -- Mains --\n+   -----------\n+\n+   package body Mains is\n+\n+      package Names is new Table.Table\n+        (Table_Component_Type => File_Name_Type,\n+         Table_Index_Type     => Integer,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 10,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Make.Mains.Names\");\n+      --  The table that stores the main\n+\n+      Current : Natural := 0;\n+      --  The index of the last main retrieved from the table\n+\n+      --------------\n+      -- Add_Main --\n+      --------------\n+\n+      procedure Add_Main (Name : String) is\n+      begin\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Name);\n+         Names.Increment_Last;\n+         Names.Table (Names.Last) := Name_Find;\n+      end Add_Main;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete is\n+      begin\n+         Names.Set_Last (0);\n+         Reset;\n+      end Delete;\n+\n+      ---------------\n+      -- Next_Main --\n+      ---------------\n+\n+      function Next_Main return String is\n+      begin\n+         if Current >= Names.Last then\n+            return \"\";\n+\n+         else\n+            Current := Current + 1;\n+            return Get_Name_String (Names.Table (Current));\n+         end if;\n+      end Next_Main;\n+\n+      procedure Reset is\n+      begin\n+         Current := 0;\n+      end Reset;\n+\n+   end Mains;\n+\n    ----------\n    -- Mark --\n    ----------\n@@ -6521,6 +6831,7 @@ package body Make is\n \n       else\n          Add_File (Argv);\n+         Mains.Add_Main (Argv);\n       end if;\n    end Scan_Make_Arg;\n "}, {"sha": "3ae87aa2184bbcf61d8fe27665fba4b66f61d33b", "filename": "gcc/ada/nlists.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fnlists.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fnlists.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.h?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "588352fc29f450cdf194d204eb2ad14f4b4e6559", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 126, "deletions": 5, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -1060,7 +1060,8 @@ package body Prj.Env is\n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n-      Main_Project_Only : Boolean := True)\n+      Main_Project_Only : Boolean := True;\n+      Full_Path         : Boolean := False)\n       return              String\n    is\n       The_Project   : Project_Id := Project;\n@@ -1151,7 +1152,13 @@ package body Prj.Env is\n                            Write_Line (\"   OK\");\n                         end if;\n \n-                        return Get_Name_String (Current_Name);\n+                        if Full_Path then\n+                           return Get_Name_String\n+                             (Unit.File_Names (Body_Part).Path);\n+\n+                        else\n+                           return Get_Name_String (Current_Name);\n+                        end if;\n \n                         --  If it has the name of the extended body name,\n                         --  return the extended body name\n@@ -1161,7 +1168,13 @@ package body Prj.Env is\n                            Write_Line (\"   OK\");\n                         end if;\n \n-                        return Extended_Body_Name;\n+                        if Full_Path then\n+                           return Get_Name_String\n+                             (Unit.File_Names (Body_Part).Path);\n+\n+                        else\n+                           return Extended_Body_Name;\n+                        end if;\n \n                      else\n                         if Current_Verbosity = High then\n@@ -1202,7 +1215,14 @@ package body Prj.Env is\n                            Write_Line (\"   OK\");\n                         end if;\n \n-                        return Get_Name_String (Current_Name);\n+\n+                        if Full_Path then\n+                           return Get_Name_String\n+                             (Unit.File_Names (Specification).Path);\n+\n+                        else\n+                           return Get_Name_String (Current_Name);\n+                        end if;\n \n                         --  If it has the same name as the extended spec name,\n                         --  return the extended spec name.\n@@ -1212,7 +1232,13 @@ package body Prj.Env is\n                            Write_Line (\"   OK\");\n                         end if;\n \n-                        return Extended_Spec_Name;\n+                        if Full_Path then\n+                           return Get_Name_String\n+                             (Unit.File_Names (Specification).Path);\n+\n+                        else\n+                           return Extended_Spec_Name;\n+                        end if;\n \n                      else\n                         if Current_Verbosity = High then\n@@ -1701,6 +1727,101 @@ package body Prj.Env is\n       Write_Line (\"end of List of Sources.\");\n    end Print_Sources;\n \n+   ----------------\n+   -- Project_Of --\n+   ----------------\n+\n+   function Project_Of\n+     (Name         : String;\n+      Main_Project : Project_Id)\n+      return         Project_Id\n+   is\n+      Result : Project_Id := No_Project;\n+\n+      Original_Name : String := Name;\n+\n+      Data : constant Project_Data := Projects.Table (Main_Project);\n+\n+      Extended_Spec_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                      (Data.Naming.Current_Spec_Suffix);\n+      Extended_Body_Name : String :=\n+                             Name & Namet.Get_Name_String\n+                                      (Data.Naming.Current_Body_Suffix);\n+\n+      Unit : Unit_Data;\n+\n+      Current_Name : Name_Id;\n+\n+      The_Original_Name : Name_Id;\n+      The_Spec_Name     : Name_Id;\n+      The_Body_Name     : Name_Id;\n+\n+   begin\n+      Canonical_Case_File_Name (Original_Name);\n+      Name_Len := Original_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Original_Name;\n+      The_Original_Name := Name_Find;\n+\n+      Canonical_Case_File_Name (Extended_Spec_Name);\n+      Name_Len := Extended_Spec_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n+      The_Spec_Name := Name_Find;\n+\n+      Canonical_Case_File_Name (Extended_Body_Name);\n+      Name_Len := Extended_Body_Name'Length;\n+      Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n+      The_Body_Name := Name_Find;\n+\n+      for Current in reverse Units.First .. Units.Last loop\n+         Unit := Units.Table (Current);\n+\n+         --  Check for body\n+         Current_Name := Unit.File_Names (Body_Part).Name;\n+         --  Case of a body present\n+\n+         if Current_Name /= No_Name then\n+            --  If it has the name of the original name or the body name,\n+            --  we have found the project.\n+\n+            if Unit.Name = The_Original_Name\n+              or else Current_Name = The_Original_Name\n+              or else Current_Name = The_Body_Name\n+            then\n+               Result := Unit.File_Names (Body_Part).Project;\n+               exit;\n+            end if;\n+         end if;\n+\n+         --  Check for spec\n+\n+         Current_Name := Unit.File_Names (Specification).Name;\n+\n+         if Current_Name /= No_Name then\n+            --  If name same as the original name, or the spec name, we have\n+            --  found the project.\n+\n+            if Unit.Name = The_Original_Name\n+              or else Current_Name = The_Original_Name\n+              or else Current_Name = The_Spec_Name\n+            then\n+               Result := Unit.File_Names (Specification).Project;\n+               exit;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Get the ultimate extending project\n+\n+      if Result /= No_Project then\n+         while Projects.Table (Result).Extended_By /= No_Project loop\n+            Result := Projects.Table (Result).Extended_By;\n+         end loop;\n+      end if;\n+\n+      return Result;\n+   end Project_Of;\n+\n    -------------------\n    -- Set_Ada_Paths --\n    -------------------"}, {"sha": "7ea0287019800da1e631bbc5f9c10138e2fdf32b", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -101,17 +101,29 @@ package Prj.Env is\n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n-      Main_Project_Only : Boolean := True)\n+      Main_Project_Only : Boolean := True;\n+      Full_Path         : Boolean := False)\n       return              String;\n    --  Returns the file name of a library unit, in canonical case. Name may or\n    --  may not have an extension (corresponding to the naming scheme of the\n    --  project). If there is no body with this name, but there is a spec, the\n-   --  name of the spec is returned. If neither a body or a spec can be found,\n-   --  return an empty string.\n+   --  name of the spec is returned.\n+   --  If Full_Path is False (the default), the simple file name is returned.\n+   --  If Full_Path is True, the absolute path name is returned.\n+   --  If neither a body nor a spec can be found, an empty string is returned.\n    --  If Main_Project_Only is True, the unit must be an immediate source of\n    --  Project. If it is False, it may be a source of one of its imported\n    --  projects.\n \n+   function Project_Of\n+     (Name         : String;\n+      Main_Project : Project_Id)\n+      return         Project_Id;\n+   --  Get the project of a source. The source file name may be truncated\n+   --  (\".adb\" or \".ads\" may be missing). If the source is in a project being\n+   --  extended, return the ultimate extending project. If it is not a source\n+   --  of any project, return No_Project.\n+\n    procedure Get_Reference\n      (Source_File_Name : String;\n       Project          : out Project_Id;"}, {"sha": "1176be4611cb0fdbd51efb18dd8ff739be2e296f", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2002, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}, {"sha": "60dbbe595c33ee5ed1827d8f0bab7dd3230a5721", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -7688,7 +7688,6 @@ package body Sem_Ch12 is\n           or else\n             Ekind (Get_Instance_Of (A_Gen_T)) = E_Record_Type_With_Private\n          then\n-\n             --  Check whether the parent is another derived formal type\n             --  in the same generic unit.\n \n@@ -7697,19 +7696,19 @@ package body Sem_Ch12 is\n               and then Scope (Etype (A_Gen_T)) = Scope (A_Gen_T)\n               and then Etype (Etype (A_Gen_T)) /= Etype (A_Gen_T)\n             then\n-\n                --  Locate ancestor of parent from the subtype declaration\n                --  created for the actual.\n \n                declare\n                   Decl : Node_Id;\n+\n                begin\n                   Decl := First (Actual_Decls);\n \n                   while (Present (Decl)) loop\n                      if Nkind (Decl) = N_Subtype_Declaration\n-                       and then Chars (Defining_Identifier (Decl))\n-                         = Chars (Etype (A_Gen_T))\n+                       and then Chars (Defining_Identifier (Decl)) =\n+                                                    Chars (Etype (A_Gen_T))\n                      then\n                         Ancestor := Generic_Parent_Type (Decl);\n                         exit;"}, {"sha": "839081dbbfd6ad2a59d0f9320863d0c2740d30a6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -169,8 +169,7 @@ package body Sem_Ch3 is\n       Derived_Base  : Entity_Id;\n       Is_Tagged     : Boolean;\n       Inherit_Discr : Boolean;\n-      Discs         : Elist_Id)\n-      return          Elist_Id;\n+      Discs         : Elist_Id) return Elist_Id;\n    --  Called from Build_Derived_Record_Type to inherit the components of\n    --  Parent_Base (a base type) into the Derived_Base (the derived base type).\n    --  For more information on derived types and component inheritance please\n@@ -217,8 +216,7 @@ package body Sem_Ch3 is\n    function Build_Discriminant_Constraints\n      (T           : Entity_Id;\n       Def         : Node_Id;\n-      Derived_Def : Boolean := False)\n-      return        Elist_Id;\n+      Derived_Def : Boolean := False) return Elist_Id;\n    --  Validate discriminant constraints, and return the list of the\n    --  constraints in order of discriminant declarations. T is the\n    --  discriminated unconstrained type. Def is the N_Subtype_Indication\n@@ -256,8 +254,7 @@ package body Sem_Ch3 is\n    function Build_Scalar_Bound\n      (Bound : Node_Id;\n       Par_T : Entity_Id;\n-      Der_T : Entity_Id)\n-      return  Node_Id;\n+      Der_T : Entity_Id) return Node_Id;\n    --  The bounds of a derived scalar type are conversions of the bounds of\n    --  the parent type. Optimize the representation if the bounds are literals.\n    --  Needs a more complete spec--what are the parameters exactly, and what\n@@ -356,8 +353,7 @@ package body Sem_Ch3 is\n       Constrained_Typ : Entity_Id;\n       Related_Node    : Node_Id;\n       Typ             : Entity_Id;\n-      Constraints     : Elist_Id)\n-      return            Entity_Id;\n+      Constraints     : Elist_Id) return Entity_Id;\n    --  Given a discriminated base type Typ, a list of discriminant constraint\n    --  Constraints for Typ and the type of a component of Typ, Compon_Type,\n    --  create and return the type corresponding to Compon_type where all\n@@ -419,8 +415,7 @@ package body Sem_Ch3 is\n      (Prot_Subt   : Entity_Id;\n       Corr_Rec    : Entity_Id;\n       Related_Nod : Node_Id;\n-      Related_Id  : Entity_Id)\n-      return Entity_Id;\n+      Related_Id  : Entity_Id) return Entity_Id;\n    --  When constraining a protected type or task type with discriminants,\n    --  constrain the corresponding record with the same discriminant values.\n \n@@ -521,17 +516,15 @@ package body Sem_Ch3 is\n \n    function Expand_To_Stored_Constraint\n      (Typ        : Entity_Id;\n-      Constraint : Elist_Id)\n-      return       Elist_Id;\n+      Constraint : Elist_Id) return Elist_Id;\n    --  Given a Constraint (ie a list of expressions) on the discriminants of\n    --  Typ, expand it into a constraint on the stored discriminants and\n    --  return the new list of expressions constraining the stored\n    --  discriminants.\n \n    function Find_Type_Of_Object\n      (Obj_Def     : Node_Id;\n-      Related_Nod : Node_Id)\n-      return        Entity_Id;\n+      Related_Nod : Node_Id) return Entity_Id;\n    --  Get type entity for object referenced by Obj_Def, attaching the\n    --  implicit types generated to Related_Nod\n \n@@ -546,8 +539,7 @@ package body Sem_Ch3 is\n \n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n-      Constraint_Kind : Node_Kind)\n-      return Boolean;\n+      Constraint_Kind : Node_Kind) return Boolean;\n    --  Returns True if it is legal to apply the given kind of constraint\n    --  to the given kind of type (index constraint to an array type,\n    --  for example).\n@@ -670,8 +662,7 @@ package body Sem_Ch3 is\n \n    function Access_Definition\n      (Related_Nod : Node_Id;\n-      N           : Node_Id)\n-      return        Entity_Id\n+      N           : Node_Id) return Entity_Id\n    is\n       Anon_Type : constant Entity_Id :=\n                     Create_Itype (E_Anonymous_Access_Type, Related_Nod,\n@@ -727,6 +718,7 @@ package body Sem_Ch3 is\n    is\n       Formals : constant List_Id   := Parameter_Specifications (T_Def);\n       Formal  : Entity_Id;\n+\n       Desig_Type : constant Entity_Id :=\n                    Create_Itype (E_Subprogram_Type, Parent (T_Def));\n \n@@ -739,6 +731,7 @@ package body Sem_Ch3 is\n             Error_Msg_N\n              (\"expect type in function specification\", Subtype_Mark (T_Def));\n          end if;\n+\n       else\n          Set_Etype (Desig_Type, Standard_Void_Type);\n       end if;\n@@ -5322,8 +5315,7 @@ package body Sem_Ch3 is\n    function Build_Discriminant_Constraints\n      (T           : Entity_Id;\n       Def         : Node_Id;\n-      Derived_Def : Boolean := False)\n-      return        Elist_Id\n+      Derived_Def : Boolean := False) return Elist_Id\n    is\n       C          : constant Node_Id := Constraint (Def);\n       Nb_Discr   : constant Nat     := Number_Discriminants (T);\n@@ -5734,8 +5726,7 @@ package body Sem_Ch3 is\n    function Build_Scalar_Bound\n      (Bound : Node_Id;\n       Par_T : Entity_Id;\n-      Der_T : Entity_Id)\n-      return  Node_Id\n+      Der_T : Entity_Id) return Node_Id\n    is\n       New_Bound : Entity_Id;\n \n@@ -6918,26 +6909,22 @@ package body Sem_Ch3 is\n       Constrained_Typ : Entity_Id;\n       Related_Node    : Node_Id;\n       Typ             : Entity_Id;\n-      Constraints     : Elist_Id)\n-      return            Entity_Id\n+      Constraints     : Elist_Id) return Entity_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Constrained_Typ);\n \n       function Build_Constrained_Array_Type\n-        (Old_Type : Entity_Id)\n-         return     Entity_Id;\n+        (Old_Type : Entity_Id) return Entity_Id;\n       --  If Old_Type is an array type, one of whose indices is\n       --  constrained by a discriminant, build an Itype whose constraint\n       --  replaces the discriminant with its value in the constraint.\n \n       function Build_Constrained_Discriminated_Type\n-        (Old_Type : Entity_Id)\n-         return     Entity_Id;\n+        (Old_Type : Entity_Id) return Entity_Id;\n       --  Ditto for record components.\n \n       function Build_Constrained_Access_Type\n-        (Old_Type : Entity_Id)\n-         return     Entity_Id;\n+        (Old_Type : Entity_Id) return Entity_Id;\n       --  Ditto for access types. Makes use of previous two functions, to\n       --  constrain designated type.\n \n@@ -6956,8 +6943,7 @@ package body Sem_Ch3 is\n       -----------------------------------\n \n       function Build_Constrained_Access_Type\n-        (Old_Type : Entity_Id)\n-        return      Entity_Id\n+        (Old_Type : Entity_Id) return Entity_Id\n       is\n          Desig_Type    : constant Entity_Id := Designated_Type (Old_Type);\n          Itype         : Entity_Id;\n@@ -7043,8 +7029,7 @@ package body Sem_Ch3 is\n       ----------------------------------\n \n       function Build_Constrained_Array_Type\n-        (Old_Type : Entity_Id)\n-         return     Entity_Id\n+        (Old_Type : Entity_Id) return Entity_Id\n       is\n          Lo_Expr     : Node_Id;\n          Hi_Expr     : Node_Id;\n@@ -7104,8 +7089,7 @@ package body Sem_Ch3 is\n       ------------------------------------------\n \n       function Build_Constrained_Discriminated_Type\n-        (Old_Type : Entity_Id)\n-         return     Entity_Id\n+        (Old_Type : Entity_Id) return Entity_Id\n       is\n          Expr           : Node_Id;\n          Constr_List    : List_Id;\n@@ -7374,8 +7358,7 @@ package body Sem_Ch3 is\n      (Prot_Subt   : Entity_Id;\n       Corr_Rec    : Entity_Id;\n       Related_Nod : Node_Id;\n-      Related_Id  : Entity_Id)\n-      return Entity_Id\n+      Related_Id  : Entity_Id) return Entity_Id\n    is\n       T_Sub : constant Entity_Id\n         := Create_Itype (E_Record_Subtype, Related_Nod, Related_Id, 'V');\n@@ -9249,8 +9232,7 @@ package body Sem_Ch3 is\n \n    function Expand_To_Stored_Constraint\n      (Typ        : Entity_Id;\n-      Constraint : Elist_Id)\n-      return       Elist_Id\n+      Constraint : Elist_Id) return Elist_Id\n    is\n       Explicitly_Discriminated_Type : Entity_Id;\n       Expansion    : Elist_Id;\n@@ -9517,8 +9499,7 @@ package body Sem_Ch3 is\n \n    function Find_Type_Of_Object\n      (Obj_Def     : Node_Id;\n-      Related_Nod : Node_Id)\n-      return        Entity_Id\n+      Related_Nod : Node_Id) return Entity_Id\n    is\n       Def_Kind : constant Node_Kind := Nkind (Obj_Def);\n       P        : constant Node_Id   := Parent (Obj_Def);\n@@ -9810,14 +9791,12 @@ package body Sem_Ch3 is\n    function Get_Discriminant_Value\n      (Discriminant       : Entity_Id;\n       Typ_For_Constraint : Entity_Id;\n-      Constraint         : Elist_Id)\n-      return               Node_Id\n+      Constraint         : Elist_Id) return Node_Id\n    is\n       function Search_Derivation_Levels\n         (Ti                    : Entity_Id;\n          Discrim_Values        : Elist_Id;\n-         Stored_Discrim_Values : Boolean)\n-         return                  Node_Or_Entity_Id;\n+         Stored_Discrim_Values : Boolean) return Node_Or_Entity_Id;\n       --  This is the routine that performs the recursive search of levels\n       --  as described above.\n \n@@ -9828,8 +9807,7 @@ package body Sem_Ch3 is\n       function Search_Derivation_Levels\n         (Ti                    : Entity_Id;\n          Discrim_Values        : Elist_Id;\n-         Stored_Discrim_Values : Boolean)\n-         return                  Node_Or_Entity_Id\n+         Stored_Discrim_Values : Boolean) return Node_Or_Entity_Id\n       is\n          Assoc          : Elmt_Id;\n          Disc           : Entity_Id;\n@@ -10051,8 +10029,7 @@ package body Sem_Ch3 is\n       Derived_Base  : Entity_Id;\n       Is_Tagged     : Boolean;\n       Inherit_Discr : Boolean;\n-      Discs         : Elist_Id)\n-      return          Elist_Id\n+      Discs         : Elist_Id) return Elist_Id\n    is\n       Assoc_List : constant Elist_Id := New_Elmt_List;\n \n@@ -10288,8 +10265,7 @@ package body Sem_Ch3 is\n \n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n-      Constraint_Kind : Node_Kind)\n-      return            Boolean\n+      Constraint_Kind : Node_Kind) return Boolean\n    is\n    begin\n       case T_Kind is\n@@ -12003,8 +11979,7 @@ package body Sem_Ch3 is\n      (S           : Node_Id;\n       Related_Nod : Node_Id;\n       Related_Id  : Entity_Id := Empty;\n-      Suffix      : Character := ' ')\n-      return        Entity_Id\n+      Suffix      : Character := ' ') return Entity_Id\n    is\n       P               : Node_Id;\n       Def_Id          : Entity_Id;"}, {"sha": "3cae7d3d739647154bc0d7fff5c7a706333a0d42", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f26df5db7c471770e7219881e9bfe85cd3a039/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=b0f26df5db7c471770e7219881e9bfe85cd3a039", "patch": "@@ -42,8 +42,7 @@ package Sem_Ch3  is\n \n    function Access_Definition\n      (Related_Nod : Node_Id;\n-      N           : Node_Id)\n-      return        Entity_Id;\n+      N           : Node_Id) return Entity_Id;\n    --  An access definition defines a general access type for a formal\n    --  parameter.  The procedure is called when processing formals, when\n    --  the current scope is the subprogram. The Implicit type is attached\n@@ -129,10 +128,9 @@ package Sem_Ch3  is\n    --  private type.\n \n    function Get_Discriminant_Value\n-     (Discriminant         : Entity_Id;\n-      Typ_For_Constraint   : Entity_Id;\n-      Constraint           : Elist_Id)\n-      return                 Node_Id;\n+     (Discriminant       : Entity_Id;\n+      Typ_For_Constraint : Entity_Id;\n+      Constraint         : Elist_Id) return Node_Id;\n    --  ??? MORE DOCUMENTATION\n    --  Given a discriminant somewhere in the Typ_For_Constraint tree\n    --  and a Constraint, return the value of that discriminant.\n@@ -195,8 +193,7 @@ package Sem_Ch3  is\n      (S           : Node_Id;\n       Related_Nod : Node_Id;\n       Related_Id  : Entity_Id := Empty;\n-      Suffix      : Character := ' ')\n-      return        Entity_Id;\n+      Suffix      : Character := ' ') return Entity_Id;\n    --  Process a subtype indication S and return corresponding entity.\n    --  Related_Nod is the node where the potential generated implicit types\n    --  will be inserted. The Related_Id and Suffix parameters are used to"}]}