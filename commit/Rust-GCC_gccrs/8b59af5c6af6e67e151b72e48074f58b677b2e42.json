{"sha": "8b59af5c6af6e67e151b72e48074f58b677b2e42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1OWFmNWM2YWY2ZTY3ZTE1MWI3MmU0ODA3NGY1OGI2NzdiMmU0Mg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-03-04T21:05:32Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-03-04T21:05:32Z"}, "message": "re PR fortran/50981 ([OOP] Wrong-code for scalarizing ELEMENTAL call with absent OPTIONAL argument)\n\nfortran/\n\tPR fortran/50981\n\t* trans-expr.c (gfc_conv_procedure_call): Save se->ss's value. \n\tHandle the case of unallocated arrays passed to elemental procedures.\n\ntestsuite/\n\tPR fortran/50981\n\t* gfortran.dg/elemental_optional_args_5.f03: Add array checks.\n\nFrom-SVN: r184896", "tree": {"sha": "22c98d925987f45bb13bb999df6db82c3c2dfe91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c98d925987f45bb13bb999df6db82c3c2dfe91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b59af5c6af6e67e151b72e48074f58b677b2e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b59af5c6af6e67e151b72e48074f58b677b2e42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b59af5c6af6e67e151b72e48074f58b677b2e42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b59af5c6af6e67e151b72e48074f58b677b2e42/comments", "author": null, "committer": null, "parents": [{"sha": "173be4663db901aefba2e0083a9c5cad8337c700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173be4663db901aefba2e0083a9c5cad8337c700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173be4663db901aefba2e0083a9c5cad8337c700"}], "stats": {"total": 97, "additions": 95, "deletions": 2}, "files": [{"sha": "005c9bcf4f129335ce1d0596e87994b85328a108", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8b59af5c6af6e67e151b72e48074f58b677b2e42", "patch": "@@ -1,3 +1,9 @@\n+2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* trans-expr.c (gfc_conv_procedure_call): Save se->ss's value. \n+\tHandle the case of unallocated arrays passed to elemental procedures.\n+\n 2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss_info): Move can_be_null_ref component from"}, {"sha": "83e3c9c86854515f17b99c4b6b162a554a199f73", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8b59af5c6af6e67e151b72e48074f58b677b2e42", "patch": "@@ -3522,12 +3522,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else if (se->ss && se->ss->info->useflags)\n \t{\n+\t  gfc_ss *ss;\n+\n+\t  ss = se->ss;\n+\n \t  /* An elemental function inside a scalarized loop.  */\n \t  gfc_init_se (&parmse, se);\n \t  parm_kind = ELEMENTAL;\n \n-\t  if (se->ss->dimen > 0 && e->expr_type == EXPR_VARIABLE\n-\t      && se->ss->info->data.array.ref == NULL)\n+\t  if (ss->dimen > 0 && e->expr_type == EXPR_VARIABLE\n+\t      && ss->info->data.array.ref == NULL)\n \t    {\n \t      gfc_conv_tmp_array_ref (&parmse);\n \t      if (e->ts.type == BT_CHARACTER)\n@@ -3538,6 +3542,29 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);\n \n+\t  /* If we are passing an absent array as optional dummy to an\n+\t     elemental procedure, make sure that we pass NULL when the data\n+\t     pointer is NULL.  We need this extra conditional because of\n+\t     scalarization which passes arrays elements to the procedure,\n+\t     ignoring the fact that the array can be absent/unallocated/...  */\n+\t  if (ss->info->can_be_null_ref && ss->info->type != GFC_SS_REFERENCE)\n+\t    {\n+\t      tree descriptor_data;\n+\n+\t      descriptor_data = ss->info->data.array.data;\n+\t      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t     descriptor_data,\n+\t\t\t\t     fold_convert (TREE_TYPE (descriptor_data),\n+\t\t\t\t\t\t   null_pointer_node));\n+\t      parmse.expr\n+\t\t= fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t   TREE_TYPE (parmse.expr),\n+\t\t\t\t   gfc_unlikely (tmp),\n+\t\t\t\t   fold_convert (TREE_TYPE (parmse.expr), \n+\t\t\t\t\t\t null_pointer_node),\n+\t\t\t\t   parmse.expr);\n+\t    }\n+\n \t  /* The scalarizer does not repackage the reference to a class\n \t     array - instead it returns a pointer to the data element.  */\n \t  if (fsym && fsym->ts.type == BT_CLASS && e->ts.type == BT_CLASS)"}, {"sha": "80ce63f02587aa5f523f98268cc4ae7d2010939f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b59af5c6af6e67e151b72e48074f58b677b2e42", "patch": "@@ -1,3 +1,8 @@\n+2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* gfortran.dg/elemental_optional_args_5.f03: Add array checks.\n+\n 2012-03-04  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* gcc.dg/torture/pr52402.c: Add dg-require-effective-target"}, {"sha": "74c1fa04f42cfb2daa69f3aad8026b60685d2d1e", "filename": "gcc/testsuite/gfortran.dg/elemental_optional_args_5.f03", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b59af5c6af6e67e151b72e48074f58b677b2e42/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03?ref=8b59af5c6af6e67e151b72e48074f58b677b2e42", "patch": "@@ -69,6 +69,51 @@\n if (any (v /= [5*2, 5*2])) call abort()\n \n \n+! ARRAY COMPONENTS: Non alloc/assoc\n+\n+v = [9, 33]\n+\n+call sub1 (v, x%a2, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub1 (v, x%p2, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+\n+! ARRAY COMPONENTS: alloc/assoc\n+\n+allocate (x%a2(2), x%p2(2))\n+x%a2(:) = [84, 82]\n+x%p2    = [35, 58]\n+\n+call sub1 (v, x%a2, .true.)\n+!print *, v\n+if (any (v /= [84*2, 82*2])) call abort()\n+\n+call sub1 (v, x%p2, .true.)\n+!print *, v\n+if (any (v /= [35*2, 58*2])) call abort()\n+\n+\n+! =============== sub_t ==================\n+! SCALAR DT: Non alloc/assoc\n+\n+s = 3\n+v = [9, 33]\n+\n+call sub_t (s, ta, .false.)\n+call sub_t (v, ta, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub_t (s, tp, .false.)\n+call sub_t (v, tp, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n \n contains\n \n@@ -82,5 +127,15 @@ elemental subroutine sub1 (x, y, alloc)\n       x = y*2\n   end subroutine sub1\n \n+  elemental subroutine sub_t(x, y, alloc)\n+    integer, intent(inout) :: x\n+    type(t), intent(in), optional :: y\n+    logical, intent(in) :: alloc\n+    if (alloc .neqv. present (y)) &\n+      x = -99\n+    if (present(y)) &\n+      x = y%a*2\n+  end subroutine sub_t\n+\n end\n "}]}