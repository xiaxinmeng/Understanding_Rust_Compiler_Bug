{"sha": "5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5N2IxNTU5YTA5ZjA1ZjQxZjk5ZTdmMjBmNjcwZmZjN2IyZDM4ZQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-06-26T21:36:58Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-06-26T21:36:58Z"}, "message": "ssa.c (struct rename_set_data): Change the name of field 'set_dest' to 'old_reg'.\n\n* ssa.c (struct rename_set_data): Change the name of field\n'set_dest' to 'old_reg'.  Add comments.\n(struct rename_context): Change the name of 'set_data' to\n'new_renames'.  Add new field 'done_renames'.\n(create_delayed_rename): New function.\n(apply_delayed_renames): New function.\n(rename_insn_1): Use the new functions.  Handle CLOBBERS.  Handle\nSUBREGs and similar by emitting a move.\n(new_registers_for_updates): Delete, functionality moved to\napply_delayed_renames.\n(rename_block): Handle moves emitted by rename_insn_1 by putting\nthem into a SEQUENCE with the original insn.  Add sanity checks\nand comments.\n(rename_equivalent_regs_in_insn): Don't handle SUBREGs specially.\n(rename_equivalent_regs): Expand SEQUENCEs out to individual insns.\n\nFrom-SVN: r34720", "tree": {"sha": "d41cf1ef354820028f1a54b7d1c55acb4d34f4fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d41cf1ef354820028f1a54b7d1c55acb4d34f4fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5397b1559a09f05f41f99e7f20f670ffc7b2d38e/comments", "author": null, "committer": null, "parents": [{"sha": "644638bc02e9875d61844d38832c1d534a8f05fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644638bc02e9875d61844d38832c1d534a8f05fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/644638bc02e9875d61844d38832c1d534a8f05fa"}], "stats": {"total": 338, "additions": 203, "deletions": 135}, "files": [{"sha": "3ad4f50028e3307234bdb7b80d7f73f53b55f0d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5397b1559a09f05f41f99e7f20f670ffc7b2d38e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5397b1559a09f05f41f99e7f20f670ffc7b2d38e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "patch": "@@ -1,3 +1,21 @@\n+2000-06-26  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* ssa.c (struct rename_set_data): Change the name of field\n+\t'set_dest' to 'old_reg'.  Add comments.\n+\t(struct rename_context): Change the name of 'set_data' to\n+\t'new_renames'.  Add new field 'done_renames'.\n+\t(create_delayed_rename): New function.\n+\t(apply_delayed_renames): New function.\n+\t(rename_insn_1): Use the new functions.  Handle CLOBBERS.  Handle\n+\tSUBREGs and similar by emitting a move.\n+\t(new_registers_for_updates): Delete, functionality moved to\n+\tapply_delayed_renames.\n+\t(rename_block): Handle moves emitted by rename_insn_1 by putting\n+\tthem into a SEQUENCE with the original insn.  Add sanity checks\n+\tand comments.\n+\t(rename_equivalent_regs_in_insn): Don't handle SUBREGs specially.\n+\t(rename_equivalent_regs): Expand SEQUENCEs out to individual insns.\n+\t\n 2000-06-26  Andrew Macleod <amacleod@cygnus.com>\n \t    Jason Merrill <jason@redhat.com>\n "}, {"sha": "46fa38f8253aa30062ac5f3e0f0166cc562943a5", "filename": "gcc/ssa.c", "status": "modified", "additions": 185, "deletions": 135, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5397b1559a09f05f41f99e7f20f670ffc7b2d38e/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5397b1559a09f05f41f99e7f20f670ffc7b2d38e/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "patch": "@@ -93,6 +93,8 @@ static unsigned int ssa_max_reg_num;\n \n /* Local function prototypes.  */\n \n+struct rename_context;\n+\n static inline rtx * phi_alternative\n   PARAMS ((rtx, int));\n \n@@ -114,6 +116,10 @@ static void insert_phi_node\n   PARAMS ((int regno, int b));\n static void insert_phi_nodes\n   PARAMS ((sbitmap *idfs, sbitmap *evals, int nregs));\n+static void create_delayed_rename \n+  PARAMS ((struct rename_context *, rtx *));\n+static void apply_delayed_renames \n+  PARAMS ((struct rename_context *));\n static int rename_insn_1 \n   PARAMS ((rtx *ptr, void *data));\n static void rename_block \n@@ -521,24 +527,49 @@ insert_phi_nodes (idfs, evals, nregs)\n struct rename_set_data\n {\n   struct rename_set_data *next;\n+  /* This is the SET_DEST of the (first) SET that sets the REG.  */\n   rtx *reg_loc;\n-  rtx set_dest;\n+  /* This is what used to be at *REG_LOC.  */\n+  rtx old_reg;\n+  /* This is the REG that will replace OLD_REG.  It's set only\n+     when the rename data is moved onto the DONE_RENAMES queue.  */\n   rtx new_reg;\n+  /* This is what to restore ssa_rename_to[REGNO (old_reg)] to. \n+     It is usually the previous contents of ssa_rename_to[REGNO (old_reg)].  */\n   rtx prev_reg;\n+  /* This is the insn that contains all the SETs of the REG.  */\n   rtx set_insn;\n };\n \n /* This struct is used to pass information to callback functions while\n    renaming registers.  */\n struct rename_context\n {\n-  struct rename_set_data *set_data;\n+  struct rename_set_data *new_renames;\n+  struct rename_set_data *done_renames;\n   rtx current_insn;\n };\n \n-static void new_registers_for_updates \n-  PARAMS ((struct rename_set_data *set_data,\n-\t   struct rename_set_data *old_set_data, rtx insn));\n+/* Queue the rename of *REG_LOC.  */\n+static void\n+create_delayed_rename (c, reg_loc)\n+     struct rename_context *c;\n+     rtx *reg_loc;\n+{\n+  struct rename_set_data *r;\n+  r = (struct rename_set_data *) xmalloc (sizeof(*r));\n+  \n+  if (GET_CODE (*reg_loc) != REG\n+      || REGNO (*reg_loc) < FIRST_PSEUDO_REGISTER)\n+    abort();\n+\n+  r->reg_loc = reg_loc;\n+  r->old_reg = *reg_loc;\n+  r->prev_reg = ssa_rename_to [REGNO (r->old_reg) - FIRST_PSEUDO_REGISTER];\n+  r->set_insn = c->current_insn;\n+  r->next = c->new_renames;\n+  c->new_renames = r;\n+}\n \n /* This is part of a rather ugly hack to allow the pre-ssa regno to be\n    reused.  If, during processing, a register has not yet been touched,\n@@ -549,6 +580,60 @@ static void new_registers_for_updates\n    already been reused.  */\n #define RENAME_NO_RTX  pc_rtx\n \n+/* Move all the entries from NEW_RENAMES onto DONE_RENAMES by\n+   applying all the renames on NEW_RENAMES.  */\n+\n+static void\n+apply_delayed_renames (c)\n+       struct rename_context *c;\n+{\n+  struct rename_set_data *r;\n+  struct rename_set_data *last_r = NULL;\n+  \n+  for (r = c->new_renames; r != NULL; r = r->next)\n+    {\n+      int regno = REGNO (r->old_reg);\n+      int new_regno;\n+      \n+      /* Failure here means that someone has a PARALLEL that sets\n+\t a register twice (bad!).  */\n+      if (ssa_rename_to [regno - FIRST_PSEUDO_REGISTER] != r->prev_reg)\n+\tabort();\n+      /* Failure here means we have changed REG_LOC before applying\n+\t the rename.  */\n+      /* For the first set we come across, reuse the original regno.  */\n+      if (r->prev_reg == NULL_RTX)\n+\t{\n+\t  r->new_reg = r->old_reg;\n+\t  /* We want to restore RENAME_NO_RTX rather than NULL_RTX. */\n+\t  r->prev_reg = RENAME_NO_RTX;\n+\t}\n+      else\n+\tr->new_reg = gen_reg_rtx (GET_MODE (r->old_reg));\n+      new_regno = REGNO (r->new_reg);\n+      ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] = r->new_reg;\n+\n+      if (new_regno >= (int) ssa_definition->num_elements)\n+\t{\n+\t  int new_limit = new_regno * 5 / 4;\n+\t  ssa_definition = VARRAY_GROW (ssa_definition, new_limit);\n+\t  ssa_uses = VARRAY_GROW (ssa_uses, new_limit);\n+\t  ssa_rename_from = VARRAY_GROW (ssa_rename_from, new_limit);\n+\t}\n+\n+      VARRAY_RTX (ssa_definition, new_regno) = r->set_insn;\n+      VARRAY_RTX (ssa_rename_from, new_regno) = r->old_reg;\n+\n+      last_r = r;\n+    }\n+  if (last_r != NULL)\n+    {\n+      last_r->next = c->done_renames;\n+      c->done_renames = c->new_renames;\n+      c->new_renames = NULL;\n+    }\n+}\n+\n /* Part one of the first step of rename_block, called through for_each_rtx. \n    Mark pseudos that are set for later update.  Transform uses of pseudos.  */\n \n@@ -559,47 +644,76 @@ rename_insn_1 (ptr, data)\n {\n   rtx x = *ptr;\n   struct rename_context *context = data;\n-  struct rename_set_data **set_datap = &(context->set_data);\n \n   if (x == NULL_RTX)\n     return 0;\n \n   switch (GET_CODE (x))\n     {\n+    case CLOBBER:\n     case SET:\n       {\n \trtx *destp = &SET_DEST (x);\n \trtx dest = SET_DEST (x);\n \n-\t/* Subregs at word 0 are interesting.  Subregs at word != 0 are\n-\t   presumed to be part of a contiguous multi-word set sequence.  */\n-\twhile (GET_CODE (dest) == SUBREG\n-\t       && SUBREG_WORD (dest) == 0)\n+\t/* Some SETs also use the REG specified in their LHS.\n+\t   These can be detected by the presence of\n+\t   STRICT_LOW_PART, SUBREG, SIGN_EXTRACT, and ZERO_EXTRACT\n+\t   in the LHS.  Handle these by changing\n+\t   (set (subreg (reg foo)) ...)\n+\t   into\n+\t   (sequence [(set (reg foo_1) (reg foo))\n+\t              (set (subreg (reg foo_1)) ...)])  \n+\n+\t   FIXME: Much of the time this is too much.  For many libcalls,\n+\t   paradoxical SUBREGs, etc., the input register is dead.  We should\n+\t   recognise this in rename_block or here and not make a false\n+\t   dependency.  */\n+\t   \n+\tif (GET_CODE (dest) == STRICT_LOW_PART\n+\t    || GET_CODE (dest) == SUBREG\n+\t    || GET_CODE (dest) == SIGN_EXTRACT\n+\t    || GET_CODE (dest) == ZERO_EXTRACT)\n \t  {\n-\t    destp = &SUBREG_REG (dest);\n-\t    dest = SUBREG_REG (dest);\n+\t    rtx i, reg;\n+\t    reg = dest;\n+\t    \n+\t    while (GET_CODE (reg) == STRICT_LOW_PART\n+\t\t   || GET_CODE (reg) == SUBREG\n+\t\t   || GET_CODE (reg) == SIGN_EXTRACT\n+\t\t   || GET_CODE (reg) == ZERO_EXTRACT)\n+\t\treg = XEXP (reg, 0);\n+\t    \n+\t    if (GET_CODE (reg) == REG\n+\t\t&& REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+\t      {\n+\t\t/* Generate (set reg reg), and do renaming on it so\n+\t\t   that it becomes (set reg_1 reg_0), and we will\n+\t\t   replace reg with reg_1 in the SUBREG.  */\n+\n+\t\tstruct rename_set_data *saved_new_renames;\n+\t\tsaved_new_renames = context->new_renames;\n+\t\tcontext->new_renames = NULL;\n+\t\ti = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));\n+\t\tfor_each_rtx (&i, rename_insn_1, data);\n+\t\tapply_delayed_renames (context);\n+\t\tcontext->new_renames = saved_new_renames;\n+\t      }\n \t  }\n-\n-\tif (GET_CODE (dest) == REG\n-\t    && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n+\telse if (GET_CODE (dest) == REG\n+\t\t && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    /* We found a genuine set of an interesting register.  Tag\n \t       it so that we can create a new name for it after we finish\n \t       processing this insn.  */\n \n-\t    struct rename_set_data *r;\n-\t    r = (struct rename_set_data *) xmalloc (sizeof(*r));\n-\n-\t    r->reg_loc = destp;\n-\t    r->set_dest = SET_DEST (x);\n-\t    r->set_insn = context->current_insn;\n-\t    r->next = *set_datap;\n-\t    *set_datap = r;\n+\t    create_delayed_rename (context, destp);\n \n \t    /* Since we do not wish to (directly) traverse the\n \t       SET_DEST, recurse through for_each_rtx for the SET_SRC\n \t       and return.  */\n-\t    for_each_rtx (&SET_SRC (x), rename_insn_1, data);\n+\t    if (GET_CODE (x) == SET)\n+\t      for_each_rtx (&SET_SRC (x), rename_insn_1, data);\n \t    return -1;\n \t  }\n \n@@ -634,55 +748,6 @@ rename_insn_1 (ptr, data)\n     }\n }\n \n-/* Second part of the first step of rename_block.  The portion of the list\n-   beginning at SET_DATA through OLD_SET_DATA contain the sets present in\n-   INSN.  Update data structures accordingly.  */\n-\n-static void\n-new_registers_for_updates (set_data, old_set_data, insn)\n-     struct rename_set_data *set_data, *old_set_data;\n-     rtx insn;\n-{\n-  while (set_data != old_set_data)\n-    {\n-      int regno, new_regno;\n-      rtx old_reg, new_reg, prev_reg;\n-\n-      old_reg = *set_data->reg_loc;\n-      regno = REGNO (*set_data->reg_loc);\n-\n-      /* For the first set we come across, reuse the original regno.  */\n-      if (ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] == NULL_RTX)\n-\t{\n-\t  new_reg = old_reg;\n-\t  prev_reg = RENAME_NO_RTX;\n-\t}\n-      else\n-\t{\n-\t  prev_reg = ssa_rename_to[regno - FIRST_PSEUDO_REGISTER];\n-\t  new_reg = gen_reg_rtx (GET_MODE (old_reg));\n-\t}\n-\n-      set_data->new_reg = new_reg;\n-      set_data->prev_reg = prev_reg;\n-      new_regno = REGNO (new_reg);\n-      ssa_rename_to[regno - FIRST_PSEUDO_REGISTER] = new_reg;\n-\n-      if (new_regno >= (int) ssa_definition->num_elements)\n-\t{\n-\t  int new_limit = new_regno * 5 / 4;\n-\t  ssa_definition = VARRAY_GROW (ssa_definition, new_limit);\n-\t  ssa_uses = VARRAY_GROW (ssa_uses, new_limit);\n-\t  ssa_rename_from = VARRAY_GROW (ssa_rename_from, new_limit);\n-\t}\n-\n-      VARRAY_RTX (ssa_definition, new_regno) = insn;\n-      VARRAY_RTX (ssa_rename_from, new_regno) = old_reg;\n-\n-      set_data = set_data->next;\n-    }\n-}\n-\n static void\n rename_block (bb, idom)\n      int bb;\n@@ -705,14 +770,29 @@ rename_block (bb, idom)\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  struct rename_context context;\n-\t  context.set_data = set_data;\n+\t  context.done_renames = set_data;\n+\t  context.new_renames = NULL;\n \t  context.current_insn = insn;\n \n+\t  start_sequence ();\n \t  for_each_rtx (&PATTERN (insn), rename_insn_1, &context);\n \t  for_each_rtx (&REG_NOTES (insn), rename_insn_1, &context);\n+\n+\t  /* Sometimes, we end up with a sequence of insns that\n+\t     SSA needs to treat as a single insn.  Wrap these in a\n+\t     SEQUENCE.  (Any notes now get attached to the SEQUENCE,\n+\t     not to the old version inner insn.)  */\n+\t  if (get_insns () != NULL_RTX)\n+\t    {\n+\t      int i;\n+\t      \n+\t      emit (PATTERN (insn));\n+\t      PATTERN (insn) = gen_sequence ();\n+\t    }\n+\t  end_sequence ();\n \t  \n-\t  new_registers_for_updates (context.set_data, set_data, insn);\n-\t  set_data = context.set_data;\n+\t  apply_delayed_renames (&context);\n+\t  set_data = context.done_renames;\n \t}\n \n       next = NEXT_INSN (insn);\n@@ -780,29 +860,18 @@ rename_block (bb, idom)\n     if (idom[c] == bb)\n       rename_block (c, idom);\n \n-  /* Step Four: Update the sets to refer to their new register.  */\n+  /* Step Four: Update the sets to refer to their new register,\n+     and restore ssa_rename_to to its previous state.  */\n \n   while (set_data)\n     {\n       struct rename_set_data *next;\n       rtx old_reg = *set_data->reg_loc;\n \n-      /* If the set is of a subreg only, copy the entire reg first so\n-\t that unmodified bits are preserved.  Of course, we don't\n-\t strictly have SSA any more, but that's the best we can do\n-\t without a lot of hard work.  */\n-\n-      if (GET_CODE (set_data->set_dest) == SUBREG) \n-\t{\n-\t  if (old_reg != set_data->new_reg)\n-\t    {\n-\t      rtx copy = gen_rtx_SET (GET_MODE (old_reg), \n-\t\t\t\t      set_data->new_reg, old_reg);\n-\t      emit_insn_before (copy, set_data->set_insn);\n-\t    }\n-\t}\n-\n+      if (*set_data->reg_loc != set_data->old_reg)\n+\tabort();\n       *set_data->reg_loc = set_data->new_reg;\n+\n       ssa_rename_to[REGNO (old_reg)-FIRST_PSEUDO_REGISTER]\n \t= set_data->prev_reg;\n \n@@ -1478,14 +1547,6 @@ coalesce_regs_in_copies (bb, p, conflicts)\n       src = SET_SRC (pattern);\n       dest = SET_DEST (pattern);\n \n-      /* If src or dest are subregs, find the underlying reg.  */\n-      while (GET_CODE (src) == SUBREG\n-\t     && SUBREG_WORD (src) != 0)\n-\tsrc = SUBREG_REG (src);\n-      while (GET_CODE (dest) == SUBREG\n-\t     && SUBREG_WORD (dest) != 0)\n-\tdest = SUBREG_REG (dest);\n-\n       /* We're only looking for copies.  */\n       if (GET_CODE (src) != REG || GET_CODE (dest) != REG)\n \tcontinue;\n@@ -1709,40 +1770,6 @@ rename_equivalent_regs_in_insn (ptr, data)\n \n   switch (GET_CODE (x))\n     {\n-    case SET:\n-      {\n-\trtx *destp = &SET_DEST (x);\n-\trtx dest = SET_DEST (x);\n-\n-\t/* Subregs at word 0 are interesting.  Subregs at word != 0 are\n-\t   presumed to be part of a contiguous multi-word set sequence.  */\n-\twhile (GET_CODE (dest) == SUBREG\n-\t       && SUBREG_WORD (dest) == 0)\n-\t  {\n-\t    destp = &SUBREG_REG (dest);\n-\t    dest = SUBREG_REG (dest);\n-\t  }\n-\n-\tif (GET_CODE (dest) == REG\n-\t    && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    /* Got a pseudo; replace it.  */\n-\t    int regno = REGNO (dest);\n-\t    int new_regno = partition_find (reg_partition, regno);\n-\t    if (regno != new_regno)\n-\t      *destp = regno_reg_rtx[new_regno];\n-\n-\t    for_each_rtx (&SET_SRC (x), \n-\t\t\t  rename_equivalent_regs_in_insn, \n-\t\t\t  data);\n-\t    return -1;\n-\t  }\n-\n-\t/* Otherwise, this was not an interesting destination.  Continue\n-\t   on, marking uses as normal.  */\n-\treturn 0;\n-      }\n-\n     case REG:\n       if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n \t{\n@@ -1769,7 +1796,8 @@ rename_equivalent_regs_in_insn (ptr, data)\n     }\n }\n \n-/* Rename regs that are equivalent in REG_PARTITION.  */\n+/* Rename regs that are equivalent in REG_PARTITION.  \n+   Also collapse any SEQUENCE insns.  */\n \n static void\n rename_equivalent_regs (reg_partition)\n@@ -1795,6 +1823,28 @@ rename_equivalent_regs (reg_partition)\n \t      for_each_rtx (&REG_NOTES (insn), \n \t\t\t    rename_equivalent_regs_in_insn, \n \t\t\t    reg_partition);\n+\n+\t      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t\t{\n+\t\t  rtx s = PATTERN (insn);\n+\t\t  int slen = XVECLEN (s, 0);\n+\t\t  int i;\n+\n+\t\t  if (slen <= 1)\n+\t\t    abort();\n+\n+\t\t  PATTERN (insn) = PATTERN (XVECEXP (s, 0, slen-1));\n+\t\t  for (i = 0; i < slen - 1; i++)\n+\t\t    {\n+\t\t      rtx new_insn;\n+\t\t      rtx old_insn = XVECEXP (s, 0, i);\n+\t\t      \n+\t\t      new_insn = emit_block_insn_before (PATTERN (old_insn),\n+\t\t\t\t\t\t\t insn, b);\n+\t\t      REG_NOTES (new_insn) = REG_NOTES (old_insn);\n+\t\t    }\n+\t\t  \n+\t\t}\n \t    }\n \n \t  next = NEXT_INSN (insn);"}]}