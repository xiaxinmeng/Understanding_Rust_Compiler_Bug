{"sha": "cc0017a98304173d1d7ba32764086dfcbea8ce7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwMDE3YTk4MzA0MTczZDFkN2JhMzI3NjQwODZkZmNiZWE4Y2U3Yg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2002-10-27T09:14:04Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2002-10-27T09:14:04Z"}, "message": "Makefile.in (dwarf2out.o): Add dependendcy on hashtab.h.\n\n\t* Makefile.in (dwarf2out.o): Add dependendcy on hashtab.h.\n\t* dwarf2out.c: Include hashtab.h.\n\t(is_main_source): New static variable.\n\t(attr_checksum, die_checksum): Modified to handle die references.\n\t(same_loc_p, same_dw_val_p, same_attr_p, same_die_p, same_die_p_wrap,\n\tunmark_all_dies, htab_cu_hash, htab_cu_eq, htab_cu_del, check_duplicate_cu,\n\trecord_comdat_symbol_number): New static functions.\n\t(output_comp_unit, compute_section_prefix, is_type_die, break_out_includes,\n\tmark_dies, unmark_dies, dwarf2out_start_source_file): Modified.\n\t* toplev.c (rest_of_decl_compilation): Call of dwarf2out_decl for type\n\tdeclarations added.\n\nFrom-SVN: r58578", "tree": {"sha": "19bcd9d6ce8522c7469e493cdbed2bbafeb9dd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19bcd9d6ce8522c7469e493cdbed2bbafeb9dd96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc0017a98304173d1d7ba32764086dfcbea8ce7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0017a98304173d1d7ba32764086dfcbea8ce7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc0017a98304173d1d7ba32764086dfcbea8ce7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0017a98304173d1d7ba32764086dfcbea8ce7b/comments", "author": null, "committer": null, "parents": [{"sha": "085825b83b283c7533aa4d95ceda37231c4c99dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/085825b83b283c7533aa4d95ceda37231c4c99dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/085825b83b283c7533aa4d95ceda37231c4c99dd"}], "stats": {"total": 428, "additions": 402, "deletions": 26}, "files": [{"sha": "ef1dbff25b1d9c1d323766b5d5c01de3b3015e26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc0017a98304173d1d7ba32764086dfcbea8ce7b", "patch": "@@ -1,3 +1,17 @@\n+2002-10-27  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (dwarf2out.o): Add dependendcy on hashtab.h.\n+\t* dwarf2out.c: Include hashtab.h.\n+\t(is_main_source): New static variable.\n+\t(attr_checksum, die_checksum): Modified to handle die references.\n+\t(same_loc_p, same_dw_val_p, same_attr_p, same_die_p, same_die_p_wrap,\n+\tunmark_all_dies, htab_cu_hash, htab_cu_eq, htab_cu_del, check_duplicate_cu,\n+\trecord_comdat_symbol_number): New static functions.\n+\t(output_comp_unit, compute_section_prefix, is_type_die, break_out_includes,\n+\tmark_dies, unmark_dies, dwarf2out_start_source_file): Modified.\n+\t* toplev.c (rest_of_decl_compilation): Call of dwarf2out_decl for type\n+\tdeclarations added.\n+\n 2002-10-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (initial_offset): Change to"}, {"sha": "e97c3025a4208693ed119913c4310a0c80ceabd0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cc0017a98304173d1d7ba32764086dfcbea8ce7b", "patch": "@@ -1455,7 +1455,7 @@ dwarfout.o : dwarfout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) dwarf.h \\\n dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) dwarf2.h \\\n    debug.h flags.h insn-config.h reload.h output.h diagnostic.h real.h \\\n    hard-reg-set.h $(REGS_H) $(EXPR_H) libfuncs.h toplev.h dwarf2out.h varray.h \\\n-   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h gt-dwarf2out.h\n+   $(GGC_H) except.h dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) flags.h $(RTL_H) $(TREE_H) \\\n    output.h dwarf2asm.h $(TM_P_H) $(GGC_H)\n vmsdbgout.o : vmsdbgout.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) flags.h \\"}, {"sha": "ed2a0ecd00e9ebe9df6cafba310fe553ef9c8085", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 376, "deletions": 25, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cc0017a98304173d1d7ba32764086dfcbea8ce7b", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"hashtable.h\"\n+#include \"hashtab.h\"\n \n #ifdef DWARF2_DEBUGGING_INFO\n static void dwarf2out_source_line\tPARAMS ((unsigned int, const char *));\n@@ -3333,6 +3334,10 @@ static unsigned long next_die_offset;\n /* Record the root of the DIE's built for the current compilation unit.  */\n static dw_die_ref comp_unit_die;\n \n+/* We need special handling in dwarf2out_start_source_file if it is\n+   first one.  */\n+static int is_main_source;\n+\n /* A list of DIEs with a NULL parent waiting to be relocated.  */\n static limbo_die_node *limbo_die_list = 0;\n \n@@ -3569,15 +3574,29 @@ static dw_die_ref pop_compile_unit\tPARAMS ((dw_die_ref));\n static void loc_checksum\t \tPARAMS ((dw_loc_descr_ref,\n \t\t\t\t\t\t struct md5_ctx *));\n static void attr_checksum\t\tPARAMS ((dw_attr_ref,\n-\t\t\t\t\t\t struct md5_ctx *));\n+\t\t\t\t\t\t struct md5_ctx *,\n+\t\t\t\t\t\t int *));\n static void die_checksum\t\tPARAMS ((dw_die_ref,\n-\t\t\t\t\t\t struct md5_ctx *));\n+\t\t\t\t\t\t struct md5_ctx *,\n+\t\t\t\t\t\t int *));\n+static int same_loc_p\t \t\tPARAMS ((dw_loc_descr_ref,\n+\t\t\t\t\t\t dw_loc_descr_ref, int *));\n+static int same_dw_val_p\t\tPARAMS ((dw_val_node *, dw_val_node *,\n+\t\t\t\t\t\t int *));\n+static int same_attr_p\t\t\tPARAMS ((dw_attr_ref, dw_attr_ref, int *));\n+static int same_die_p\t\t\tPARAMS ((dw_die_ref, dw_die_ref, int *));\n+static int same_die_p_wrap\t\tPARAMS ((dw_die_ref, dw_die_ref));\n static void compute_section_prefix\tPARAMS ((dw_die_ref));\n static int is_type_die\t\t\tPARAMS ((dw_die_ref));\n static int is_comdat_die \t\tPARAMS ((dw_die_ref));\n static int is_symbol_die \t\tPARAMS ((dw_die_ref));\n static void assign_symbol_names\t\tPARAMS ((dw_die_ref));\n static void break_out_includes\t\tPARAMS ((dw_die_ref));\n+static hashval_t htab_cu_hash\t\tPARAMS ((const void *));\n+static int htab_cu_eq\t\t\tPARAMS ((const void *, const void *));\n+static void htab_cu_del\t\t\tPARAMS ((void *));\n+static int check_duplicate_cu\t\tPARAMS ((dw_die_ref, htab_t, unsigned *));\n+static void record_comdat_symbol_number\tPARAMS ((dw_die_ref, htab_t, unsigned));\n static void add_sibling_attributes\tPARAMS ((dw_die_ref));\n static void build_abbrev_table\t\tPARAMS ((dw_die_ref));\n static void output_location_lists   \tPARAMS ((dw_die_ref));\n@@ -3586,6 +3605,7 @@ static unsigned long size_of_die\tPARAMS ((dw_die_ref));\n static void calc_die_sizes\t\tPARAMS ((dw_die_ref));\n static void mark_dies\t\t\tPARAMS ((dw_die_ref));\n static void unmark_dies\t\t\tPARAMS ((dw_die_ref));\n+static void unmark_all_dies             PARAMS ((dw_die_ref));\n static unsigned long size_of_pubnames\tPARAMS ((void));\n static unsigned long size_of_aranges\tPARAMS ((void));\n static enum dwarf_form value_format\tPARAMS ((dw_attr_ref));\n@@ -3594,7 +3614,7 @@ static void output_abbrev_section\tPARAMS ((void));\n static void output_die_symbol\t\tPARAMS ((dw_die_ref));\n static void output_die\t\t\tPARAMS ((dw_die_ref));\n static void output_compilation_unit_header PARAMS ((void));\n-static void output_comp_unit\t\tPARAMS ((dw_die_ref));\n+static void output_comp_unit\t\tPARAMS ((dw_die_ref, int));\n static const char *dwarf2_name\t\tPARAMS ((tree, int));\n static void add_pubname\t\t\tPARAMS ((tree, dw_die_ref));\n static void output_pubnames\t\tPARAMS ((void));\n@@ -5420,9 +5440,10 @@ loc_checksum (loc, ctx)\n /* Calculate the checksum of an attribute.  */\n \n static void\n-attr_checksum (at, ctx)\n+attr_checksum (at, ctx, mark)\n      dw_attr_ref at;\n      struct md5_ctx *ctx;\n+     int *mark;\n {\n   dw_loc_descr_ref loc;\n   rtx r;\n@@ -5480,9 +5501,8 @@ attr_checksum (at, ctx)\n       break;\n \n     case dw_val_class_die_ref:\n-      if (AT_ref (at)->die_offset)\n-\tCHECKSUM (AT_ref (at)->die_offset);\n-      /* FIXME else use target die name or something.  */\n+      die_checksum (AT_ref (at), ctx, mark);\n+      break;\n \n     case dw_val_class_fde_ref:\n     case dw_val_class_lbl_id:\n@@ -5497,25 +5517,195 @@ attr_checksum (at, ctx)\n /* Calculate the checksum of a DIE.  */\n \n static void\n-die_checksum (die, ctx)\n+die_checksum (die, ctx, mark)\n      dw_die_ref die;\n      struct md5_ctx *ctx;\n+     int *mark;\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n \n+  /* To avoid infinite recursion.  */\n+  if (die->die_mark)\n+    {\n+      CHECKSUM (die->die_mark);\n+      return;\n+    }\n+  die->die_mark = ++(*mark);\n+\n   CHECKSUM (die->die_tag);\n \n   for (a = die->die_attr; a; a = a->dw_attr_next)\n-    attr_checksum (a, ctx);\n+    attr_checksum (a, ctx, mark);\n \n   for (c = die->die_child; c; c = c->die_sib)\n-    die_checksum (c, ctx);\n+    die_checksum (c, ctx, mark);\n }\n \n #undef CHECKSUM\n #undef CHECKSUM_STRING\n \n+/* Do the location expressions look same?  */\n+static inline int\n+same_loc_p (loc1, loc2, mark)\n+     dw_loc_descr_ref loc1;\n+     dw_loc_descr_ref loc2;\n+     int *mark;\n+{\n+  return loc1->dw_loc_opc == loc2->dw_loc_opc\n+\t && same_dw_val_p (&loc1->dw_loc_oprnd1, &loc2->dw_loc_oprnd1, mark)\n+\t && same_dw_val_p (&loc1->dw_loc_oprnd2, &loc2->dw_loc_oprnd2, mark);\n+}\n+\n+/* Do the values look the same?  */\n+static int\n+same_dw_val_p (v1, v2, mark)\n+     dw_val_node *v1;\n+     dw_val_node *v2;\n+     int *mark;\n+{\n+  dw_loc_descr_ref loc1, loc2;\n+  rtx r1, r2;\n+  unsigned i;\n+\n+  if (v1->val_class != v2->val_class)\n+    return 0;\n+\n+  switch (v1->val_class)\n+    {\n+    case dw_val_class_const:\n+      return v1->v.val_int == v2->v.val_int;\n+    case dw_val_class_unsigned_const:\n+      return v1->v.val_unsigned == v2->v.val_unsigned;\n+    case dw_val_class_long_long:\n+      return v1->v.val_long_long.hi == v2->v.val_long_long.hi\n+             && v1->v.val_long_long.low == v2->v.val_long_long.low;\n+    case dw_val_class_float:\n+      if (v1->v.val_float.length != v2->v.val_float.length)\n+\treturn 0;\n+      for (i = 0; i < v1->v.val_float.length; i++)\n+        if (v1->v.val_float.array[i] != v2->v.val_float.array[i])\n+\t  return 0;\n+      return 1;\n+    case dw_val_class_flag:\n+      return v1->v.val_flag == v2->v.val_flag;\n+    case dw_val_class_str:\n+      return !strcmp((const char *) HT_STR (&v1->v.val_str->id),\n+\t\t     (const char *) HT_STR (&v2->v.val_str->id));\n+\n+    case dw_val_class_addr:\n+      r1 = v1->v.val_addr;\n+      r2 = v2->v.val_addr;\n+      if (GET_CODE (r1) != GET_CODE (r2))\n+\treturn 0;\n+      switch (GET_CODE (r1))\n+\t{\n+\tcase SYMBOL_REF:\n+\t  return !strcmp (XSTR (r1, 0), XSTR (r2, 0));\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+    case dw_val_class_offset:\n+      return v1->v.val_offset == v2->v.val_offset;\n+\n+    case dw_val_class_loc:\n+      for (loc1 = v1->v.val_loc, loc2 = v2->v.val_loc;\n+\t   loc1 && loc2;\n+\t   loc1 = loc1->dw_loc_next, loc2 = loc2->dw_loc_next)\n+\tif (!same_loc_p (loc1, loc2, mark))\n+\t  return 0;\n+      return !loc1 && !loc2;\n+\n+    case dw_val_class_die_ref:\n+      return same_die_p (v1->v.val_die_ref.die, v2->v.val_die_ref.die, mark);\n+\n+    case dw_val_class_fde_ref:\n+    case dw_val_class_lbl_id:\n+    case dw_val_class_lbl_offset:\n+      return 1;\n+\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Do the attributes look the same?  */\n+\n+static int\n+same_attr_p (at1, at2, mark)\n+     dw_attr_ref at1;\n+     dw_attr_ref at2;\n+     int *mark;\n+{\n+  if (at1->dw_attr != at2->dw_attr)\n+    return 0;\n+\n+  /* We don't care about differences in file numbering.  */\n+  if (at1->dw_attr == DW_AT_decl_file\n+      /* Or that this was compiled with a different compiler snapshot; if\n+\t the output is the same, that's what matters.  */\n+      || at1->dw_attr == DW_AT_producer)\n+    return 1;\n+\n+  return same_dw_val_p (&at1->dw_attr_val, &at2->dw_attr_val, mark);\n+}\n+\n+/* Do the dies look the same?  */\n+\n+static int\n+same_die_p (die1, die2, mark)\n+     dw_die_ref die1;\n+     dw_die_ref die2;\n+     int *mark;\n+{\n+  dw_die_ref c1, c2;\n+  dw_attr_ref a1, a2;\n+\n+  /* To avoid infinite recursion.  */\n+  if (die1->die_mark)\n+    return die1->die_mark == die2->die_mark;\n+  die1->die_mark = die2->die_mark = ++(*mark);\n+\n+  if (die1->die_tag != die2->die_tag)\n+    return 0;\n+\n+  for (a1 = die1->die_attr, a2 = die2->die_attr;\n+       a1 && a2;\n+       a1 = a1->dw_attr_next, a2 = a2->dw_attr_next)\n+    if (!same_attr_p (a1, a2, mark))\n+      return 0;\n+  if (a1 || a2)\n+    return 0;\n+\n+  for (c1 = die1->die_child, c2 = die2->die_child;\n+       c1 && c2;\n+       c1 = c1->die_sib, c2 = c2->die_sib)\n+    if (!same_die_p (c1, c2, mark))\n+      return 0;\n+  if (c1 || c2)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Do the dies look the same?  Wrapper around same_die_p.  */\n+\n+static int\n+same_die_p_wrap (die1, die2)\n+     dw_die_ref die1;\n+     dw_die_ref die2;\n+{\n+  int mark = 0;\n+  int ret = same_die_p (die1, die2, &mark);\n+\n+  unmark_all_dies (die1);\n+  unmark_all_dies (die2);\n+\n+  return ret;\n+}\n+\n /* The prefix to attach to symbols on DIEs in the current comdat debug\n    info section.  */\n static char *comdat_symbol_id;\n@@ -5530,18 +5720,21 @@ static void\n compute_section_prefix (unit_die)\n      dw_die_ref unit_die;\n {\n-  const char *base = lbasename (get_AT_string (unit_die, DW_AT_name));\n+  const char *die_name = get_AT_string (unit_die, DW_AT_name);\n+  const char *base = die_name ? lbasename (die_name) : \"anonymous\";\n   char *name = (char *) alloca (strlen (base) + 64);\n   char *p;\n-  int i;\n+  int i, mark;\n   unsigned char checksum[16];\n   struct md5_ctx ctx;\n \n   /* Compute the checksum of the DIE, then append part of it as hex digits to\n      the name filename of the unit.  */\n \n   md5_init_ctx (&ctx);\n-  die_checksum (unit_die, &ctx);\n+  mark = 0;\n+  die_checksum (unit_die, &ctx, &mark);\n+  unmark_all_dies (unit_die);\n   md5_finish_ctx (&ctx, checksum);\n \n   sprintf (name, \"%s.\", base);\n@@ -5583,6 +5776,7 @@ is_type_die (die)\n     case DW_TAG_file_type:\n     case DW_TAG_packed_type:\n     case DW_TAG_volatile_type:\n+    case DW_TAG_typedef:\n       return 1;\n     default:\n       return 0;\n@@ -5668,6 +5862,104 @@ assign_symbol_names (die)\n     assign_symbol_names (c);\n }\n \n+struct cu_hash_table_entry\n+{\n+  dw_die_ref cu;\n+  unsigned min_comdat_num, max_comdat_num;\n+  struct cu_hash_table_entry *next;\n+};\n+\n+/* Routines to manipulate hash table of CUs.  */\n+static hashval_t\n+htab_cu_hash (of)\n+     const void *of;\n+{\n+  const struct cu_hash_table_entry *entry = of;\n+\n+  return htab_hash_string (entry->cu->die_symbol);\n+}\n+\n+static int\n+htab_cu_eq (of1, of2)\n+     const void *of1;\n+     const void *of2;\n+{\n+  const struct cu_hash_table_entry *entry1 = of1;\n+  const struct die_struct *entry2 = of2;\n+\n+  return !strcmp (entry1->cu->die_symbol, entry2->die_symbol);\n+}\n+\n+static void\n+htab_cu_del (what)\n+     void *what;\n+{\n+  struct cu_hash_table_entry *next, *entry = what;\n+\n+  while (entry)\n+    {\n+      next = entry->next;\n+      free (entry);\n+      entry = next;\n+    }\n+}\n+\n+/* Check whether we have already seen this CU and set up SYM_NUM\n+   accordingly.  */\n+static int\n+check_duplicate_cu (cu, htable, sym_num)\n+     dw_die_ref cu;\n+     htab_t htable;\n+     unsigned *sym_num;\n+{\n+  struct cu_hash_table_entry dummy;\n+  struct cu_hash_table_entry **slot, *entry, *last = &dummy;\n+\n+  dummy.max_comdat_num = 0;\n+\n+  slot = (struct cu_hash_table_entry **)\n+    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_symbol),\n+\tINSERT);\n+  entry = *slot;\n+\n+  for (; entry; last = entry, entry = entry->next)\n+    {\n+      if (same_die_p_wrap (cu, entry->cu))\n+\tbreak;\n+    }\n+\n+  if (entry)\n+    {\n+      *sym_num = entry->min_comdat_num;\n+      return 1;\n+    }\n+\n+  entry = xcalloc (1, sizeof (struct cu_hash_table_entry));\n+  entry->cu = cu;\n+  entry->min_comdat_num = *sym_num = last->max_comdat_num;\n+  entry->next = *slot;\n+  *slot = entry;\n+\n+  return 0;\n+}\n+\n+/* Record SYM_NUM to record of CU in HTABLE.  */\n+static void\n+record_comdat_symbol_number (cu, htable, sym_num)\n+     dw_die_ref cu;\n+     htab_t htable;\n+     unsigned sym_num;\n+{\n+  struct cu_hash_table_entry **slot, *entry;\n+\n+  slot = (struct cu_hash_table_entry **)\n+    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_symbol),\n+\tNO_INSERT);\n+  entry = *slot;\n+\n+  entry->max_comdat_num = sym_num;\n+}\n+\n /* Traverse the DIE (which is always comp_unit_die), and set up\n    additional compilation units for each of the include files we see\n    bracketed by BINCL/EINCL.  */\n@@ -5678,7 +5970,8 @@ break_out_includes (die)\n {\n   dw_die_ref *ptr;\n   dw_die_ref unit = NULL;\n-  limbo_die_node *node;\n+  limbo_die_node *node, **pnode;\n+  htab_t cu_hash_table;\n \n   for (ptr = &(die->die_child); *ptr;)\n     {\n@@ -5719,11 +6012,27 @@ break_out_includes (die)\n #endif\n \n   assign_symbol_names (die);\n-  for (node = limbo_die_list; node; node = node->next)\n+  cu_hash_table = htab_create (10, htab_cu_hash, htab_cu_eq, htab_cu_del);\n+  for (node = limbo_die_list, pnode = &limbo_die_list;\n+       node;\n+       node = node->next)\n     {\n+      int is_dupl;\n+\n       compute_section_prefix (node->die);\n+      is_dupl = check_duplicate_cu (node->die, cu_hash_table,\n+\t\t\t&comdat_symbol_number);\n       assign_symbol_names (node->die);\n+      if (is_dupl)\n+\t*pnode = node->next;\n+      else\n+        {\n+\t  pnode = &node->next;\n+\t  record_comdat_symbol_number (node->die, cu_hash_table,\n+\t\tcomdat_symbol_number);\n+\t}\n     }\n+  htab_delete (cu_hash_table);\n }\n \n /* Traverse the DIE and add a sibling attribute if it may have the\n@@ -5968,6 +6277,9 @@ mark_dies (die)\n {\n   dw_die_ref c;\n \n+  if (die->die_mark)\n+    abort ();\n+  \n   die->die_mark = 1;\n   for (c = die->die_child; c; c = c->die_sib)\n     mark_dies (c);\n@@ -5981,11 +6293,35 @@ unmark_dies (die)\n {\n   dw_die_ref c;\n \n+  if (!die->die_mark)\n+    abort ();\n+  \n   die->die_mark = 0;\n   for (c = die->die_child; c; c = c->die_sib)\n     unmark_dies (c);\n }\n \n+/* Clear the marks for a die, its children and referred dies.  */\n+\n+static void\n+unmark_all_dies (die)\n+     dw_die_ref die;\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+\n+  if (!die->die_mark)\n+    return;\n+  die->die_mark = 0;\n+\n+  for (c = die->die_child; c; c = c->die_sib)\n+    unmark_all_dies (c);\n+\n+  for (a = die->die_attr; a; a = a->dw_attr_next)\n+    if (AT_class (a) == dw_val_class_die_ref)\n+      unmark_all_dies (AT_ref (a));\n+}\n+\n /* Return the size of the .debug_pubnames table  generated for the\n    compilation unit.  */\n \n@@ -6455,10 +6791,16 @@ output_compilation_unit_header ()\n /* Output the compilation unit DIE and its children.  */\n \n static void\n-output_comp_unit (die)\n+output_comp_unit (die, output_if_empty)\n      dw_die_ref die;\n+     int output_if_empty;\n {\n   const char *secname;\n+  char *oldsym, *tmp;\n+\n+  /* Unless we are outputting main CU, we may throw away empty ones.  */\n+  if (!output_if_empty && die->die_child == NULL)\n+    return;\n \n   /* Even if there are no children of this DIE, we must output the information\n      about the compilation unit.  Otherwise, on an empty translation unit, we\n@@ -6473,11 +6815,12 @@ output_comp_unit (die)\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n   calc_die_sizes (die);\n \n-  if (die->die_symbol)\n+  oldsym = die->die_symbol;\n+  if (oldsym)\n     {\n-      char *tmp = (char *) alloca (strlen (die->die_symbol) + 24);\n+      tmp = (char *) alloca (strlen (oldsym) + 24);\n \n-      sprintf (tmp, \".gnu.linkonce.wi.%s\", die->die_symbol);\n+      sprintf (tmp, \".gnu.linkonce.wi.%s\", oldsym);\n       secname = tmp;\n       die->die_symbol = NULL;\n     }\n@@ -6491,8 +6834,11 @@ output_comp_unit (die)\n \n   /* Leave the marks on the main CU, so we can check them in\n      output_pubnames.  */\n-  if (die->die_symbol)\n-    unmark_dies (die);\n+  if (oldsym)\n+    {\n+      unmark_dies (die);\n+      die->die_symbol = oldsym;\n+    }\n }\n \n /* The DWARF2 pubname for a nested thingy looks like \"A::f\".  The\n@@ -11981,13 +12327,17 @@ dwarf2out_start_source_file (lineno, filename)\n      unsigned int lineno;\n      const char *filename;\n {\n-  if (flag_eliminate_dwarf2_dups)\n+  if (flag_eliminate_dwarf2_dups && !is_main_source)\n     {\n       /* Record the beginning of the file for break_out_includes.  */\n-      dw_die_ref bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die, NULL);\n+      dw_die_ref bincl_die;\n+\n+      bincl_die = new_die (DW_TAG_GNU_BINCL, comp_unit_die, NULL);\n       add_AT_string (bincl_die, DW_AT_name, filename);\n     }\n \n+  is_main_source = 0;\n+\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n       named_section_flags (DEBUG_MACINFO_SECTION, SECTION_DEBUG);\n@@ -12100,6 +12450,7 @@ dwarf2out_init (main_input_filename)\n      taken as being relative to the directory from which the compiler was\n      invoked when the given (base) source file was compiled.  */\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n+  is_main_source = 1;\n \n   VARRAY_TREE_INIT (incomplete_types, 64, \"incomplete_types\");\n \n@@ -12317,9 +12668,9 @@ dwarf2out_finish (input_filename)\n   /* Output all of the compilation units.  We put the main one last so that\n      the offsets are available to output_pubnames.  */\n   for (node = limbo_die_list; node; node = node->next)\n-    output_comp_unit (node->die);\n+    output_comp_unit (node->die, 0);\n \n-  output_comp_unit (comp_unit_die);\n+  output_comp_unit (comp_unit_die, 0);\n \n   /* Output the abbreviation table.  */\n   named_section_flags (DEBUG_ABBREV_SECTION, SECTION_DEBUG);"}, {"sha": "a811c4be8ca2b7e38258678f7af8a13b5b28cb69", "filename": "gcc/toplev.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0017a98304173d1d7ba32764086dfcbea8ce7b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=cc0017a98304173d1d7ba32764086dfcbea8ce7b", "patch": "@@ -2316,6 +2316,17 @@ rest_of_decl_compilation (decl, asmspec, top_level, at_end)\n       timevar_pop (TV_SYMOUT);\n     }\n #endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+  else if ((write_symbols == DWARF2_DEBUG\n+\t   || write_symbols == VMS_AND_DWARF2_DEBUG)\n+\t   && top_level\n+\t   && TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      timevar_push (TV_SYMOUT);\n+      dwarf2out_decl (decl);\n+      timevar_pop (TV_SYMOUT);\n+    }\n+#endif\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}]}