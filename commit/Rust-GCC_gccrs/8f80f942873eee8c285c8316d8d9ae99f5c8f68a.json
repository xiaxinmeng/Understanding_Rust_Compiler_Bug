{"sha": "8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY4MGY5NDI4NzNlZWU4YzI4NWM4MzE2ZDhkOWFlOTlmNWM4ZjY4YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-03T18:39:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-03T18:39:27Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1144", "tree": {"sha": "43de0442e270b5fa1e8e5792cb910e23a59809ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43de0442e270b5fa1e8e5792cb910e23a59809ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f80f942873eee8c285c8316d8d9ae99f5c8f68a/comments", "author": null, "committer": null, "parents": [{"sha": "7cb2a67c24d60c745195e774f1a55c5bcde6d354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb2a67c24d60c745195e774f1a55c5bcde6d354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cb2a67c24d60c745195e774f1a55c5bcde6d354"}], "stats": {"total": 132, "additions": 89, "deletions": 43}, "files": [{"sha": "2e2a46427e745fdf88018fb744a1cc437652e34e", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f80f942873eee8c285c8316d8d9ae99f5c8f68a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f80f942873eee8c285c8316d8d9ae99f5c8f68a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "patch": "@@ -438,6 +438,25 @@ large_int (op, mode)\n   return TRUE;\n }\n \n+/* Return truth value of whether OP is an integer which can be loaded\n+   with an lui instruction.  */\n+\n+int\n+lui_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  long value;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return FALSE;\n+\n+  if ((value & 0x0000ffff) == 0)\t\t/* lui reg,value>>16 */\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n /* Return truth value of whether OP is a register or the constant 0.  */\n \n int\n@@ -3544,6 +3563,71 @@ mips_output_lineno (stream, line)\n     }\n }\n \n+\f\n+/* If defined, a C statement to be executed just prior to the\n+   output of assembler code for INSN, to modify the extracted\n+   operands so they will be output differently.\n+\n+   Here the argument OPVEC is the vector containing the operands\n+   extracted from INSN, and NOPERANDS is the number of elements of\n+   the vector which contain meaningful data for this insn.  The\n+   contents of this vector are what will be used to convert the\n+   insn template into assembler code, so you can change the\n+   assembler output by changing the contents of the vector.\n+\n+   We use it to check if the current insn needs a nop in front of it\n+   because of load delays, and also to update the delay slot\n+   statistics.  */\n+\n+void\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx opvec[];\n+     int noperands;\n+{\n+  if (dslots_number_nops > 0)\n+    {\n+      enum machine_mode mode = GET_MODE (mips_load_reg);\n+      rtx pattern = PATTERN (insn);\n+      int length = get_attr_length (insn);\n+\n+      /* If this operand is really safe to fill the delay slot, such as an\n+\t AND with a large constant integer as operand[2], mark the delay\n+\t slot filled.  */\n+      if (get_attr_safe (insn) == SAFE_YES && length > 1)\n+\tdslots_load_filled++;\n+\n+      /* Do we need to emit a NOP? */\n+      else if (length == 0\n+\t       || (mips_load_reg  != (rtx)0 && reg_mentioned_p (mips_load_reg,  pattern))\n+\t       || (mips_load_reg2 != (rtx)0 && reg_mentioned_p (mips_load_reg2, pattern))\n+\t       || (mips_load_reg3 != (rtx)0 && reg_mentioned_p (mips_load_reg3, pattern))\n+\t       || (mips_load_reg4 != (rtx)0 && reg_mentioned_p (mips_load_reg4, pattern)))\n+\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\n+      else\n+\tdslots_load_filled++;\n+\n+      while (--dslots_number_nops > 0)\n+\tfputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file);\n+\n+      mips_load_reg  = (rtx)0;\n+      mips_load_reg2 = (rtx)0;\n+      mips_load_reg3 = (rtx)0;\n+      mips_load_reg4 = (rtx)0;\n+\n+      if (set_noreorder && --set_noreorder == 0)\n+\tfputs (\"\\t.set\\treorder\\n\", asm_out_file);\n+    }\n+\n+  if (TARGET_STATS)\n+    {\n+      enum rtx_code code = GET_CODE (insn);\n+      if (code == JUMP_INSN || code == CALL_INSN)\n+\tdslots_jump_total++;\n+    }\n+}\n+\n \f\n /* Output at beginning of assembler file.\n    If we are optimizing to use the global pointer, create a temporary"}, {"sha": "fc069d898b021dc439fba3ec3cbb724ee69141e7", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f80f942873eee8c285c8316d8d9ae99f5c8f68a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f80f942873eee8c285c8316d8d9ae99f5c8f68a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8f80f942873eee8c285c8316d8d9ae99f5c8f68a", "patch": "@@ -125,6 +125,7 @@ extern unsigned long\tcompute_frame_size ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n extern int\t\tfcmp_op ();\n+extern void\t\tfinal_prescan_insn ();\n extern int\t\tfpsw_register_operand ();\n extern struct rtx_def *\tfunction_arg ();\n extern void\t\tfunction_arg_advance ();\n@@ -135,6 +136,7 @@ extern void\t\tgen_conditional_branch ();\n extern struct rtx_def * gen_int_relational ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n+extern int\t\tlui_int ();\n extern int\t\tmd_register_operand ();\n extern int\t\tmips_address_cost ();\n extern void\t\tmips_asm_file_end ();\n@@ -428,7 +430,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 19]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 20]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -2442,8 +2444,8 @@ while (0)\n #define CLASS_DIVMOD_OP\t\t0x02\t/* operator is {,U}{DIV,MOD} */\n #define CLASS_UNSIGNED_OP\t0x04\t/* operator is U{DIV,MOD} */\n #define CLASS_CMP_OP\t\t0x08\t/* operator is comparison */\n-#define CLASS_EQUALITY_OP\t0x10\t/* operator is == or != */\n #define CLASS_FCMP_OP\t\t0x08\t/* operator is fp. compare */\n+#define CLASS_EQUALITY_OP\t0x10\t/* operator is == or != */\n \n #define CLASS_UNS_CMP_OP\t(CLASS_UNSIGNED_OP | CLASS_CMP_OP)\n \n@@ -2504,47 +2506,7 @@ while (0)\n    statistics.  */\n \n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (dslots_number_nops > 0 && mips_load_reg != (rtx)0)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tenum machine_mode mode = GET_MODE (mips_load_reg);\t\t\\\n-\trtx pattern = PATTERN (INSN);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (reg_mentioned_p (mips_load_reg, pattern)\t\t\t\\\n-\t    || (mips_load_reg2 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg2, pattern))\t\t\\\n-\t    || (mips_load_reg3 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg3, pattern))\t\t\\\n-\t    || (mips_load_reg4 != (rtx)0\t\t\t\t\\\n-\t\t&& reg_mentioned_p (mips_load_reg4, pattern))\t\t\\\n-\t    || get_attr_length (INSN) == 0)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    fputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  dslots_load_filled++;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\twhile (--dslots_number_nops > 0)\t\t\t\t\\\n-\t  fputs ((set_noreorder) ? \"\\tnop\\n\" : \"\\t#nop\\n\", asm_out_file); \\\n-\t\t\t\t\t\t\t\t\t\\\n-\tmips_load_reg  = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg2 = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg3 = (rtx)0;\t\t\t\t\t\\\n-\tmips_load_reg4 = (rtx)0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (set_noreorder && --set_noreorder == 0)\t\t\t\\\n-\t  fputs (\"\\t.set\\treorder\\n\", asm_out_file);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_STATS)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tenum rtx_code code = GET_CODE (INSN);\t\t\t\t\\\n-\tif (code == JUMP_INSN || code == CALL_INSN)\t\t\t\\\n-\t  dslots_jump_total++;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+  final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n \f\n /* Tell final.c how to eliminate redundant test instructions."}]}