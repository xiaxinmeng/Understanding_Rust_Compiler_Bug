{"sha": "8e73afcf40a43a88c9e2ca5406570f0189e6d903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3M2FmY2Y0MGE0M2E4OGM5ZTJjYTU0MDY1NzBmMDE4OWU2ZDkwMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-06-08T15:52:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-06-08T15:52:38Z"}, "message": "re PR fortran/90786 (ICE on procedure pointer assignment to function with class pointer result)\n\n2019-06-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/90786\n\t* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as\n\tit is very simple and only called from one place.\n\t(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign\n\tas non_proc_ptr_assign. Assign to it directly, rather than call\n\tto above, deleted function and use gfc_expr_attr instead of\n\tonly checking the reference chain.\n\n2019-06-08  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/90786\n\t* gfortran.dg/proc_ptr_51.f90 : New test.\n\nFrom-SVN: r272084", "tree": {"sha": "6366e9a41b1377422463f779226690bbc0b348d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6366e9a41b1377422463f779226690bbc0b348d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e73afcf40a43a88c9e2ca5406570f0189e6d903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e73afcf40a43a88c9e2ca5406570f0189e6d903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e73afcf40a43a88c9e2ca5406570f0189e6d903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e73afcf40a43a88c9e2ca5406570f0189e6d903/comments", "author": null, "committer": null, "parents": [{"sha": "ec332875f8e2456bd104c16a553ac5ecad9024b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec332875f8e2456bd104c16a553ac5ecad9024b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec332875f8e2456bd104c16a553ac5ecad9024b3"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "35e575a8d70a536d1eaa41d49d64c18e8c9c7532", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e73afcf40a43a88c9e2ca5406570f0189e6d903", "patch": "@@ -1,3 +1,13 @@\n+2019-06-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/90786\n+\t* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as\n+\tit is very simple and only called from one place.\n+\t(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign\n+\tas non_proc_ptr_assign. Assign to it directly, rather than call\n+\tto above, deleted function and use gfc_expr_attr instead of\n+\tonly checking the reference chain.\n+\n 2019-06-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \tTom\u00e1\u0161 Trnka  <trnka@scm.com>\n "}, {"sha": "dc173a00b11f91c939cb388dfb56ba36af5c117a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8e73afcf40a43a88c9e2ca5406570f0189e6d903", "patch": "@@ -4881,7 +4881,7 @@ gfc_conv_subref_array_arg (gfc_se *se, gfc_expr * expr, int g77,\n     parmse->expr = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n \n   /* Basically make this into\n-     \n+\n      if (present)\n        {\n \t if (contiguous)\n@@ -8979,23 +8979,6 @@ trans_caf_token_assign (gfc_se *lse, gfc_se *rse, gfc_expr *expr1,\n     }\n }\n \n-/* Indentify class valued proc_pointer assignments.  */\n-\n-static bool\n-pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)\n-{\n-  gfc_ref * ref;\n-\n-  ref = expr1->ref;\n-  while (ref && ref->next)\n-     ref = ref->next;\n-\n-  return ref && ref->type == REF_COMPONENT\n-      && ref->u.c.component->attr.proc_pointer\n-      && expr2->expr_type == EXPR_VARIABLE\n-      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;\n-}\n-\n \n /* Do everything that is needed for a CLASS function expr2.  */\n \n@@ -9048,15 +9031,17 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   tree desc;\n   tree tmp;\n   tree expr1_vptr = NULL_TREE;\n-  bool scalar, non_proc_pointer_assign;\n+  bool scalar, non_proc_ptr_assign;\n   gfc_ss *ss;\n \n   gfc_start_block (&block);\n \n   gfc_init_se (&lse, NULL);\n \n   /* Usually testing whether this is not a proc pointer assignment.  */\n-  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);\n+  non_proc_ptr_assign = !(gfc_expr_attr (expr1).proc_pointer\n+\t\t\t&& expr2->expr_type == EXPR_VARIABLE\n+\t\t\t&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE);\n \n   /* Check whether the expression is a scalar or not; we cannot use\n      expr1->rank as it can be nonzero for proc pointers.  */\n@@ -9066,7 +9051,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     gfc_free_ss_chain (ss);\n \n   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS\n-      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)\n+      && expr2->expr_type != EXPR_FUNCTION && non_proc_ptr_assign)\n     {\n       gfc_add_data_component (expr2);\n       /* The following is required as gfc_add_data_component doesn't\n@@ -9086,7 +9071,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       else\n \tgfc_conv_expr (&rse, expr2);\n \n-      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)\n+      if (non_proc_ptr_assign && expr1->ts.type == BT_CLASS)\n \t{\n \t  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,\n \t\t\t\t\t   NULL);"}, {"sha": "df3d0061b5008c9f942b8629c8cfdd151550983b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e73afcf40a43a88c9e2ca5406570f0189e6d903", "patch": "@@ -1,3 +1,8 @@\n+2019-06-08  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/90786\n+\t* gfortran.dg/proc_ptr_51.f90 : New test.\n+\n 2019-06-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/52269\n@@ -57,7 +62,7 @@\n \t* gfortran.dg/fmt_f_default_field_width_3.f90: Modify dg-error\n \tto allow use when kind=16 is not supported.\n \t* gfortran.dg/fmt_g_default_field_width_3.f90: Modify dg-error\n-\tto allow use when kind=16 is not supported. \n+\tto allow use when kind=16 is not supported.\n \n 2019-06-07  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "62b5d71e30bfa4de271300d06957ad3197f0fe0d", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_51.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_51.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e73afcf40a43a88c9e2ca5406570f0189e6d903/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_51.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_51.f90?ref=8e73afcf40a43a88c9e2ca5406570f0189e6d903", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR90786.\n+!\n+! Contributed by Andrew benson  <abensonca@gmail.com>\n+!\n+module f\n+procedure(c), pointer :: c_\n+\n+ type :: s\n+   integer :: i = 42\n+ end type s\n+ class(s), pointer :: res, tgt\n+\n+contains\n+\n+ function c()\n+   implicit none\n+   class(s), pointer ::  c\n+   c => tgt\n+   return\n+ end function c\n+\n+ subroutine fs()\n+   implicit none\n+   c_ => c  ! This used to ICE\n+   return\n+ end subroutine fs\n+\n+end module f\n+\n+  use f\n+  allocate (tgt, source = s(99))\n+  call fs()\n+  res => c_()\n+  if (res%i .ne. 99) stop 1\n+  deallocate (tgt)\n+end"}]}