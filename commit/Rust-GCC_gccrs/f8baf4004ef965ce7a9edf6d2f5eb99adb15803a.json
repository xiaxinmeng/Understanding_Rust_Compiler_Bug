{"sha": "f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "node_id": "C_kwDOANBUbNoAKGY4YmFmNDAwNGVmOTY1Y2U3YTllZGY2ZDJmNWViOTlhZGIxNTgwM2E", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-06-13T14:24:34Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-06-13T14:24:34Z"}, "message": "Add a general mapping from internal fns to target insns\n\nSeveral existing internal functions map directly to an instruction\ndefined in target-insns.def.  This patch makes it easier to define\nmore such functions in future.\n\nThis should help to reduce cut-&-paste, but more importantly, it allows\nthe difference between optab functions and target-insns.def functions\nto be abstracted away; both are now treated as \u201cdirectly-mapped\u201d.\n\ngcc/\n\t* internal-fn.def (DEF_INTERNAL_INSN_FN): New macro.\n\t(GOMP_SIMT_ENTER_ALLOC, GOMP_SIMT_EXIT, GOMP_SIMT_LANE)\n\t(GOMP_SIMT_LAST_LANE, GOMP_SIMT_ORDERED_PRED, GOMP_SIMT_VOTE_ANY)\n\t(GOMP_SIMT_XCHG_BFLY, GOMP_SIMT_XCHG_IDX): Use it.\n\t* internal-fn.h (direct_internal_fn_info::directly_mapped): New\n\tmember variable.\n\t(direct_internal_fn_info::vectorizable): Reduce to 1 bit.\n\t(direct_internal_fn_p): Also return true for internal functions\n\tthat map directly to instructions defined target-insns.def.\n\t(direct_internal_fn): Adjust comment accordingly.\n\t* internal-fn.cc (direct_insn, optab1, optab2, vectorizable_optab1)\n\t(vectorizable_optab2): New local macros.\n\t(not_direct): Initialize directly_mapped.\n\t(mask_load_direct, load_lanes_direct, mask_load_lanes_direct)\n\t(gather_load_direct, len_load_direct, mask_store_direct)\n\t(store_lanes_direct, mask_store_lanes_direct, vec_cond_mask_direct)\n\t(vec_cond_direct, scatter_store_direct, len_store_direct)\n\t(vec_set_direct, unary_direct, binary_direct, ternary_direct)\n\t(cond_unary_direct, cond_binary_direct, cond_ternary_direct)\n\t(while_direct, fold_extract_direct, fold_left_direct)\n\t(mask_fold_left_direct, check_ptrs_direct): Use the macros above.\n\t(expand_GOMP_SIMT_ENTER_ALLOC, expand_GOMP_SIMT_EXIT): Delete\n\t(expand_GOMP_SIMT_LANE, expand_GOMP_SIMT_LAST_LANE): Likewise;\n\t(expand_GOMP_SIMT_ORDERED_PRED, expand_GOMP_SIMT_VOTE_ANY): Likewise.\n\t(expand_GOMP_SIMT_XCHG_BFLY, expand_GOMP_SIMT_XCHG_IDX): Likewise.\n\t(direct_internal_fn_types): Handle functions that map to instructions\n\tdefined in target-insns.def.\n\t(direct_internal_fn_types): Likewise.\n\t(direct_internal_fn_supported_p): Likewise.\n\t(internal_fn_expanders): Likewise.", "tree": {"sha": "68d014d08676f3fadcef262effb1672f649bbcd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68d014d08676f3fadcef262effb1672f649bbcd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d205dbac1e1754c01c22a31bd1688126545401e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d205dbac1e1754c01c22a31bd1688126545401e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d205dbac1e1754c01c22a31bd1688126545401e"}], "stats": {"total": 206, "additions": 87, "deletions": 119}, "files": [{"sha": "a809953ce6fe8ba2babee5f7b03667118d22dd40", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 50, "deletions": 102, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "patch": "@@ -105,37 +105,44 @@ init_internal_fns ()\n \n /* Create static initializers for the information returned by\n    direct_internal_fn.  */\n-#define not_direct { -2, -2, false }\n-#define mask_load_direct { -1, 2, false }\n-#define load_lanes_direct { -1, -1, false }\n-#define mask_load_lanes_direct { -1, -1, false }\n-#define gather_load_direct { 3, 1, false }\n-#define len_load_direct { -1, -1, false }\n-#define mask_store_direct { 3, 2, false }\n-#define store_lanes_direct { 0, 0, false }\n-#define mask_store_lanes_direct { 0, 0, false }\n-#define vec_cond_mask_direct { 1, 0, false }\n-#define vec_cond_direct { 2, 0, false }\n-#define scatter_store_direct { 3, 1, false }\n-#define len_store_direct { 3, 3, false }\n-#define vec_set_direct { 3, 3, false }\n-#define unary_direct { 0, 0, true }\n-#define binary_direct { 0, 0, true }\n-#define ternary_direct { 0, 0, true }\n-#define cond_unary_direct { 1, 1, true }\n-#define cond_binary_direct { 1, 1, true }\n-#define cond_ternary_direct { 1, 1, true }\n-#define while_direct { 0, 2, false }\n-#define fold_extract_direct { 2, 2, false }\n-#define fold_left_direct { 1, 1, false }\n-#define mask_fold_left_direct { 1, 1, false }\n-#define check_ptrs_direct { 0, 0, false }\n+#define not_direct\t\t\t{ -2, -2, false, false }\n+#define direct_insn\t\t\t{ -2, -2, true, false }\n+#define optab1(TYPE0)\t\t\t{ TYPE0, TYPE0, true, false }\n+#define optab2(TYPE0, TYPE1)\t\t{ TYPE0, TYPE1, true, false }\n+#define vectorizable_optab1(TYPE0)\t{ TYPE0, TYPE0, true, true }\n+\n+#define mask_load_direct\t\toptab2 (-1, 2)\n+#define load_lanes_direct\t\toptab1 (-1)\n+#define mask_load_lanes_direct\t\toptab1 (-1)\n+#define gather_load_direct\t\toptab2 (3, 1)\n+#define len_load_direct\t\t\toptab1 (-1)\n+#define mask_store_direct\t\toptab2 (3, 2)\n+#define store_lanes_direct\t\toptab1 (0)\n+#define mask_store_lanes_direct\t\toptab1 (0)\n+#define vec_cond_mask_direct\t\toptab2 (1, 0)\n+#define vec_cond_direct\t\t\toptab2 (2, 0)\n+#define scatter_store_direct\t\toptab2 (3, 1)\n+#define len_store_direct\t\toptab1 (3)\n+#define vec_set_direct\t\t\toptab1 (3)\n+#define unary_direct\t\t\tvectorizable_optab1 (0)\n+#define binary_direct\t\t\tvectorizable_optab1 (0)\n+#define ternary_direct\t\t\tvectorizable_optab1 (0)\n+#define cond_unary_direct\t\tvectorizable_optab1 (1)\n+#define cond_binary_direct\t\tvectorizable_optab1 (1)\n+#define cond_ternary_direct\t\tvectorizable_optab1 (1)\n+#define while_direct\t\t\toptab2 (0, 2)\n+#define fold_extract_direct\t\toptab1 (2)\n+#define fold_left_direct\t\toptab1 (1)\n+#define mask_fold_left_direct\t\toptab1 (1)\n+#define check_ptrs_direct\t\toptab1 (0)\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n #define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) TYPE##_direct,\n #define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n \t\t\t\t     UNSIGNED_OPTAB, TYPE) TYPE##_direct,\n+#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n+  direct_insn,\n #include \"internal-fn.def\"\n   not_direct\n };\n@@ -308,34 +315,6 @@ expand_GOMP_SIMT_ENTER (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n-/* Allocate per-lane storage and begin non-uniform execution region.  */\n-\n-static void\n-expand_GOMP_SIMT_ENTER_ALLOC (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_enter ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_enter, 1, 2);\n-}\n-\n-/* Deallocate per-lane storage and leave non-uniform execution region.  */\n-\n-static void\n-expand_GOMP_SIMT_EXIT (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_exit ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_exit, 0, 1);\n-}\n-\n-/* Lane index on SIMT targets: thread index in the warp on NVPTX.  On targets\n-   without SIMT execution this should be expanded in omp_device_lower pass.  */\n-\n-static void\n-expand_GOMP_SIMT_LANE (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_lane ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_lane, 1, 0);\n-}\n-\n /* This should get expanded in omp_device_lower pass.  */\n \n static void\n@@ -344,55 +323,6 @@ expand_GOMP_SIMT_VF (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n-/* Lane index of the first SIMT lane that supplies a non-zero argument.\n-   This is a SIMT counterpart to GOMP_SIMD_LAST_LANE, used to represent the\n-   lane that executed the last iteration for handling OpenMP lastprivate.  */\n-\n-static void\n-expand_GOMP_SIMT_LAST_LANE (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_last_lane ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_last_lane, 1, 1);\n-}\n-\n-/* Non-transparent predicate used in SIMT lowering of OpenMP \"ordered\".  */\n-\n-static void\n-expand_GOMP_SIMT_ORDERED_PRED (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_ordered ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_ordered, 1, 1);\n-}\n-\n-/* \"Or\" boolean reduction across SIMT lanes: return non-zero in all lanes if\n-   any lane supplies a non-zero argument.  */\n-\n-static void\n-expand_GOMP_SIMT_VOTE_ANY (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_vote_any ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_vote_any, 1, 1);\n-}\n-\n-/* Exchange between SIMT lanes with a \"butterfly\" pattern: source lane index\n-   is destination lane index XOR given offset.  */\n-\n-static void\n-expand_GOMP_SIMT_XCHG_BFLY (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_xchg_bfly ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_xchg_bfly, 1, 2);\n-}\n-\n-/* Exchange between SIMT lanes according to given source lane index.  */\n-\n-static void\n-expand_GOMP_SIMT_XCHG_IDX (internal_fn, gcall *stmt)\n-{\n-  gcc_assert (targetm.have_omp_simt_xchg_idx ());\n-  expand_fn_using_insn (stmt, targetm.code_for_omp_simt_xchg_idx, 1, 2);\n-}\n-\n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n@@ -3633,6 +3563,10 @@ tree_pair\n direct_internal_fn_types (internal_fn fn, tree return_type, tree *args)\n {\n   const direct_internal_fn_info &info = direct_internal_fn (fn);\n+  if (info.type0 == -2)\n+    /* Functions created by DEF_INTERNAL_INSN_FN are not type-dependent.  */\n+    return tree_pair {};\n+\n   tree type0 = (info.type0 < 0 ? return_type : TREE_TYPE (args[info.type0]));\n   tree type1 = (info.type1 < 0 ? return_type : TREE_TYPE (args[info.type1]));\n   return tree_pair (type0, type1);\n@@ -3646,6 +3580,10 @@ tree_pair\n direct_internal_fn_types (internal_fn fn, gcall *call)\n {\n   const direct_internal_fn_info &info = direct_internal_fn (fn);\n+  if (info.type0 == -2)\n+    /* Functions created by DEF_INTERNAL_INSN_FN are not type-dependent.  */\n+    return tree_pair {};\n+\n   tree op0 = (info.type0 < 0\n \t      ? gimple_call_lhs (call)\n \t      : gimple_call_arg (call, info.type0));\n@@ -3790,6 +3728,8 @@ direct_internal_fn_supported_p (internal_fn fn, tree_pair types,\n \treturn direct_##TYPE##_optab_supported_p (which_optab, types,\t\\\n \t\t\t\t\t\t  opt_type);\t\t\\\n       }\n+#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n+    case IFN_##CODE: return targetm.have_##INSN ();\n #include \"internal-fn.def\"\n \n     case IFN_LAST:\n@@ -3941,6 +3881,14 @@ set_edom_supported_p (void)\n     optab which_optab = direct_internal_fn_optab (fn, types);\t\t\\\n     expand_##TYPE##_optab_fn (fn, stmt, which_optab);\t\t\t\\\n   }\n+#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS)\t\\\n+  static void\t\t\t\t\t\t\t\t\\\n+  expand_##CODE (internal_fn, gcall *stmt)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    gcc_assert (targetm.have_##INSN ());\t\t\t\t\\\n+    expand_fn_using_insn (stmt, targetm.code_for_##INSN,\t\t\\\n+\t\t\t  NOUTPUTS, NINPUTS);\t\t\t\t\\\n+  }\n #include \"internal-fn.def\"\n \n /* Routines to expand each internal function, indexed by function number."}, {"sha": "76fd050b57c8784a7623b8091502622fe6220ee2", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t   UNSIGNED_OPTAB, TYPE)\n      DEF_INTERNAL_FLT_FN (NAME, FLAGS, OPTAB, TYPE)\n      DEF_INTERNAL_INT_FN (NAME, FLAGS, OPTAB, TYPE)\n+     DEF_INTERNAL_INSN_FN (NAME, FLAGS, INSN, NOUTPUTS, NINPUTS)\n \n    where NAME is the name of the function, FLAGS is a set of\n    ECF_* flags and FNSPEC is a string describing functions fnspec.\n@@ -82,6 +83,11 @@ along with GCC; see the file COPYING3.  If not see\n    says that the function extends the C-level BUILT_IN_<NAME>{,L,LL,IMAX}\n    group of functions to any integral mode (including vector modes).\n \n+   DEF_INTERNAL_INSN_FN defines an internal function that maps to target\n+   instruction INSN, which is one of those defined in target-insns.def.\n+   The instruction has NOUTPUTS output operands (either 0 or 1) and\n+   NINPUTS input operands.\n+\n    Each entry must have a corresponding expander of the form:\n \n      void expand_NAME (gimple_call stmt)\n@@ -120,6 +126,11 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_INTERNAL_OPTAB_FN (NAME, FLAGS, OPTAB, TYPE)\n #endif\n \n+#ifndef DEF_INTERNAL_INSN_FN\n+#define DEF_INTERNAL_INSN_FN(NAME, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n+  DEF_INTERNAL_FN (NAME, FLAGS | ECF_LEAF, NULL)\n+#endif\n+\n DEF_INTERNAL_OPTAB_FN (MASK_LOAD, ECF_PURE, maskload, mask_load)\n DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_LOAD_LANES, ECF_PURE,\n@@ -315,15 +326,21 @@ DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST | ECF_NOTHROW, popcount, unary)\n \n DEF_INTERNAL_FN (GOMP_USE_SIMT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_ENTER, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_ENTER_ALLOC, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_EXIT, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_ENTER_ALLOC, ECF_NOTHROW, omp_simt_enter, 1, 2)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_EXIT, ECF_NOTHROW, omp_simt_exit, 0, 1)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_NOTHROW,\n+\t\t      omp_simt_lane, 1, 0)\n DEF_INTERNAL_FN (GOMP_SIMT_VF, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_ORDERED_PRED, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_VOTE_ANY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_XCHG_BFLY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_FN (GOMP_SIMT_XCHG_IDX, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_NOTHROW,\n+\t\t      omp_simt_last_lane, 1, 1)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_ORDERED_PRED, ECF_NOTHROW,\n+\t\t      omp_simt_ordered, 1, 1)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_VOTE_ANY, ECF_NOVOPS | ECF_NOTHROW,\n+\t\t      omp_simt_vote_any, 1, 1)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_XCHG_BFLY, ECF_NOVOPS | ECF_NOTHROW,\n+\t\t      omp_simt_xchg_bfly, 1, 2)\n+DEF_INTERNAL_INSN_FN (GOMP_SIMT_XCHG_IDX, ECF_NOVOPS | ECF_NOTHROW,\n+\t\t      omp_simt_xchg_idx, 1, 2)\n DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n@@ -433,6 +450,7 @@ DEF_INTERNAL_FN (SHUFFLEVECTOR, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n /* <=> optimization.  */\n DEF_INTERNAL_FN (SPACESHIP, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n \n+#undef DEF_INTERNAL_INSN_FN\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_FLT_FLOATN_FN"}, {"sha": "3409c42e4d0bbe8b40695974fa3f48a6bdf708d4", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8baf4004ef965ce7a9edf6d2f5eb99adb15803a/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=f8baf4004ef965ce7a9edf6d2f5eb99adb15803a", "patch": "@@ -133,7 +133,8 @@ internal_fn_fnspec (enum internal_fn fn)\n   return internal_fn_fnspec_array[(int) fn];\n }\n \n-/* Describes an internal function that maps directly to an optab.  */\n+/* Describes an internal function that maps directly to either an optab\n+   or an instruction defined in target-insns.def.  */\n struct direct_internal_fn_info\n {\n   /* optabs can be parameterized by one or two modes.  These fields describe\n@@ -144,24 +145,25 @@ struct direct_internal_fn_info\n      function isn't directly mapped to an optab.  */\n   signed int type0 : 8;\n   signed int type1 : 8;\n+  /* True if the function is directly mapped to either an optab or an\n+     instruction defined in target-insns.def.  */\n+  unsigned int directly_mapped : 1;\n   /* True if the function is pointwise, so that it can be vectorized by\n      converting the return type and all argument types to vectors of the\n      same number of elements.  E.g. we can vectorize an IFN_SQRT on\n-     floats as an IFN_SQRT on vectors of N floats.\n-\n-     This only needs 1 bit, but occupies the full 16 to ensure a nice\n-     layout.  */\n-  unsigned int vectorizable : 16;\n+     floats as an IFN_SQRT on vectors of N floats.  */\n+  unsigned int vectorizable : 1;\n };\n \n extern const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1];\n \n-/* Return true if FN is mapped directly to an optab.  */\n+/* Return true if FN is mapped directly to either an optab or an instruction\n+   defined in target-insns.def.  */\n \n inline bool\n direct_internal_fn_p (internal_fn fn)\n {\n-  return direct_internal_fn_array[fn].type0 >= -1;\n+  return direct_internal_fn_array[fn].directly_mapped;\n }\n \n /* Return true if FN is a direct internal function that can be vectorized by\n@@ -175,7 +177,7 @@ vectorizable_internal_fn_p (internal_fn fn)\n   return direct_internal_fn_array[fn].vectorizable;\n }\n \n-/* Return optab information about internal function FN.  Only meaningful\n+/* Return information about internal function FN.  Only meaningful\n    if direct_internal_fn_p (FN).  */\n \n inline const direct_internal_fn_info &"}]}