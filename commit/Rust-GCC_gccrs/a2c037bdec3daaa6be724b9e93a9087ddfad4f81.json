{"sha": "a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjMDM3YmRlYzNkYWFhNmJlNzI0YjllOTNhOTA4N2RkZmFkNGY4MQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-02-23T06:59:51Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-02-23T06:59:51Z"}, "message": "PR 47694 Read from named pipe fails\n\nCo-Authored-By: Jerry DeLisle <jvdelisle@gcc.gnu.org>\n\nFrom-SVN: r170432", "tree": {"sha": "abae9394bf2e2aeea9c461c5aa49689d59efe2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abae9394bf2e2aeea9c461c5aa49689d59efe2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/comments", "author": null, "committer": null, "parents": [{"sha": "ff72e86dfda00631473eca57b8d2af3ef7475c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff72e86dfda00631473eca57b8d2af3ef7475c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff72e86dfda00631473eca57b8d2af3ef7475c73"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "bed097214581930abae7e0c0762b6e6d20697659", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "patch": "@@ -1,3 +1,11 @@\n+2011-02-23  Janne Blomqvist  <jb@gcc.gnu.org>\n+\t    Jerry DeLisle    <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/47694\n+\t* io/fbuf.h (fbuf_getptr): New inline function.\n+\t* io/transfer.c (read_sf): Use fbuf_getptr and fbuf_getc to scan\n+\tthrough the string instead of fbuf_read.\n+\n 2011-02-22  Tobias Burnus  <burnus@net-b.de>\n \t    Kai-Uwe Eckhardt  <kuehro@gmx.de>\n "}, {"sha": "3a2883bc59a7f29adf252a7ecba066db70429f10", "filename": "libgfortran/io/fbuf.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2Fio%2Ffbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2Fio%2Ffbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.h?ref=a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "patch": "@@ -78,4 +78,10 @@ fbuf_getc (gfc_unit * u)\n   return fbuf_getc_refill (u);\n }\n \n+static inline char *\n+fbuf_getptr (gfc_unit * u)\n+{\n+  return (char*) (u->fbuf->buf + u->fbuf->pos);\n+}\n+\n #endif"}, {"sha": "ad5d19d2bf5c84a1c20656662ca3972e4547d65b", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c037bdec3daaa6be724b9e93a9087ddfad4f81/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=a2c037bdec3daaa6be724b9e93a9087ddfad4f81", "patch": "@@ -284,7 +284,8 @@ static char *\n read_sf (st_parameter_dt *dtp, int * length)\n {\n   static char *empty_string[0];\n-  char *base, *p, q;\n+  char *base;\n+  int q, q2;\n   int n, lorig, seen_comma;\n \n   /* If we have seen an eor previously, return a length of 0.  The\n@@ -301,18 +302,18 @@ read_sf (st_parameter_dt *dtp, int * length)\n \n   /* Read data into format buffer and scan through it.  */\n   lorig = *length;\n-  base = p = fbuf_read (dtp->u.p.current_unit, length);\n+  base = fbuf_getptr (dtp->u.p.current_unit);\n   if (base == NULL)\n     return NULL;\n \n   while (n < *length)\n     {\n-      q = *p;\n-\n-      if (q == '\\n' || q == '\\r')\n+      q = fbuf_getc (dtp->u.p.current_unit);\n+      if (q == EOF)\n+\tbreak;\n+      else if (q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line. Set the position.  */\n-\t  fbuf_seek (dtp->u.p.current_unit, n + 1 ,SEEK_CUR);\n \t  dtp->u.p.sf_seen_eor = 1;\n \n \t  /* If we see an EOR during non-advancing I/O, we need to skip\n@@ -323,15 +324,12 @@ read_sf (st_parameter_dt *dtp, int * length)\n \t  /* If we encounter a CR, it might be a CRLF.  */\n \t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n-\t      /* See if there is an LF. Use fbuf_read rather then fbuf_getc so\n-\t\t the position is not advanced unless it really is an LF.  */\n-\t      int readlen = 1;\n-\t      p = fbuf_read (dtp->u.p.current_unit, &readlen);\n-\t      if (*p == '\\n' && readlen == 1)\n-\t        {\n-\t\t  dtp->u.p.sf_seen_eor = 2;\n-\t\t  fbuf_seek (dtp->u.p.current_unit, 1 ,SEEK_CUR);\n-\t\t}\n+\t      /* See if there is an LF.  */\n+\t      q2 = fbuf_getc (dtp->u.p.current_unit);\n+\t      if (q2 == '\\n')\n+\t\tdtp->u.p.sf_seen_eor = 2;\n+\t      else if (q2 != EOF) /* Oops, seek back.  */\n+\t\tfbuf_seek (dtp->u.p.current_unit, -1, SEEK_CUR);\n \t    }\n \n \t  /* Without padding, terminate the I/O statement without assigning\n@@ -349,20 +347,18 @@ read_sf (st_parameter_dt *dtp, int * length)\n       /*  Short circuit the read if a comma is found during numeric input.\n \t  The flag is set to zero during character reads so that commas in\n \t  strings are not ignored  */\n-      if (q == ',')\n+      else if (q == ',')\n \tif (dtp->u.p.sf_read_comma == 1)\n \t  {\n             seen_comma = 1;\n \t    notify_std (&dtp->common, GFC_STD_GNU,\n \t\t\t\"Comma in formatted numeric read.\");\n-\t    *length = n;\n \t    break;\n \t  }\n       n++;\n-      p++;\n-    } \n+    }\n \n-  fbuf_seek (dtp->u.p.current_unit, n + seen_comma, SEEK_CUR);\n+  *length = n;\n \n   /* A short read implies we hit EOF, unless we hit EOR, a comma, or\n      some other stuff. Set the relevant flags.  */"}]}