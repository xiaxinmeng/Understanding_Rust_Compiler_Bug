{"sha": "e15762df9d0d7f48680b2d839a3da37536461b1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1NzYyZGY5ZDBkN2Y0ODY4MGIyZDgzOWEzZGEzNzUzNjQ2MWIxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-27T18:27:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-27T18:27:18Z"}, "message": "(put_var_into_stack, fixup_var_refs_insns): Minor cleanups.\n\n(fixup_var_refs_1, case SET): Correctly check for simple insns that don't\nneed fixups.\n\nFrom-SVN: r3367", "tree": {"sha": "24ee8c12a2f6f16e9877fbbf4e8a936024a7765c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24ee8c12a2f6f16e9877fbbf4e8a936024a7765c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e15762df9d0d7f48680b2d839a3da37536461b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15762df9d0d7f48680b2d839a3da37536461b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e15762df9d0d7f48680b2d839a3da37536461b1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15762df9d0d7f48680b2d839a3da37536461b1a/comments", "author": null, "committer": null, "parents": [{"sha": "4b7179be95c25b5298d116896980223cc0319517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7179be95c25b5298d116896980223cc0319517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7179be95c25b5298d116896980223cc0319517"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "dfc8aaf2ab2f0dce6b865c081aa582051d66a697", "filename": "gcc/function.c", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15762df9d0d7f48680b2d839a3da37536461b1a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15762df9d0d7f48680b2d839a3da37536461b1a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e15762df9d0d7f48680b2d839a3da37536461b1a", "patch": "@@ -852,6 +852,7 @@ put_var_into_stack (decl)\n       reg = XEXP (reg, 0);\n       decl_mode = promoted_mode = GET_MODE (reg);\n     }\n+\n   if (GET_CODE (reg) != REG)\n     return;\n \n@@ -860,17 +861,15 @@ put_var_into_stack (decl)\n       if (REGNO (reg) < function->max_parm_reg)\n \tnew = function->parm_reg_stack_loc[REGNO (reg)];\n       if (new == 0)\n-\tnew = assign_outer_stack_local (GET_MODE (reg),\n-\t\t\t\t\tGET_MODE_SIZE (decl_mode),\n+\tnew = assign_outer_stack_local (decl_mode, GET_MODE_SIZE (decl_mode),\n \t\t\t\t\t0, function);\n     }\n   else\n     {\n       if (REGNO (reg) < max_parm_reg)\n \tnew = parm_reg_stack_loc[REGNO (reg)];\n       if (new == 0)\n-\tnew = assign_stack_local (GET_MODE (reg),\n-\t\t\t\t  GET_MODE_SIZE (decl_mode), 0);\n+\tnew = assign_stack_local (decl_mode, GET_MODE_SIZE (decl_mode), 0);\n     }\n \n   XEXP (reg, 0) = XEXP (new, 0);\n@@ -1004,8 +1003,7 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n     {\n       rtx next = NEXT_INSN (insn);\n       rtx note;\n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n-\t  || GET_CODE (insn) == JUMP_INSN)\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n \t  /* The insn to load VAR from a home in the arglist\n \t     is now a no-op.  When we see it, just delete it.  */\n@@ -1464,28 +1462,55 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t   must be left alone, to avoid an infinite loop here.\n \t   If the reference to VAR is by a subreg, fix that up,\n \t   since SUBREG is not valid for a memref.\n-\t   Also fix up the address of the stack slot.  */\n+\t   Also fix up the address of the stack slot.\n+\n+\t   Note that we must not try to recognize the insn until\n+\t   after we know that we have valid addresses and no\n+\t   (subreg (mem ...) ...) constructs, since these interfere\n+\t   with determining the validity of the insn.  */\n \n \tif ((SET_SRC (x) == var\n \t     || (GET_CODE (SET_SRC (x)) == SUBREG\n \t\t && SUBREG_REG (SET_SRC (x)) == var))\n \t    && (GET_CODE (SET_DEST (x)) == REG\n \t\t|| (GET_CODE (SET_DEST (x)) == SUBREG\n \t\t    && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG))\n-\t    && recog_memoized (insn) >= 0)\n+\t    && x == single_set (PATTERN (insn)))\n \t  {\n+\t    rtx pat;\n+\n \t    replacement = find_fixup_replacement (replacements, SET_SRC (x));\n \t    if (replacement->new)\n-\t      {\n \t      SET_SRC (x) = replacement->new;\n-\t      return;\n-\t    }\n \t    else if (GET_CODE (SET_SRC (x)) == SUBREG)\n \t      SET_SRC (x) = replacement->new\n \t\t= fixup_memory_subreg (SET_SRC (x), insn, 0);\n \t    else\n \t      SET_SRC (x) = replacement->new\n \t\t= fixup_stack_1 (SET_SRC (x), insn);\n+\n+\t    if (recog_memoized (insn) >= 0)\n+\t      return;\n+\n+\t    /* INSN is not valid, but we know that we want to\n+\t       copy SET_SRC (x) to SET_DEST (x) in some way.  So\n+\t       we generate the move and see whether it requires more\n+\t       than one insn.  If it does, we emit those insns and\n+\t       delete INSN.  Otherwise, we an just replace the pattern \n+\t       of INSN; we have already verified above that INSN has\n+\t       no other function that to do X.  */\n+\n+\t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n+\t    if (GET_CODE (pat) == SEQUENCE)\n+\t      {\n+\t\temit_insn_after (pat, insn);\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t      }\n+\t    else\n+\t      PATTERN (insn) = pat;\n+\n \t    return;\n \t  }\n \n@@ -1495,12 +1520,29 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    && (GET_CODE (SET_SRC (x)) == REG\n \t\t|| (GET_CODE (SET_SRC (x)) == SUBREG\n \t\t    && GET_CODE (SUBREG_REG (SET_SRC (x))) == REG))\n-\t    && recog_memoized (insn) >= 0)\n+\t    && x == single_set (PATTERN (insn)))\n \t  {\n+\t    rtx pat;\n+\n \t    if (GET_CODE (SET_DEST (x)) == SUBREG)\n \t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, 0);\n \t    else\n \t      SET_DEST (x) = fixup_stack_1 (SET_DEST (x), insn);\n+\n+\t    if (recog_memoized (insn) >= 0)\n+\t      return;\n+\n+\t    pat = gen_move_insn (SET_DEST (x), SET_SRC (x));\n+\t    if (GET_CODE (pat) == SEQUENCE)\n+\t      {\n+\t\temit_insn_after (pat, insn);\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t      }\n+\t    else\n+\t      PATTERN (insn) = pat;\n+\n \t    return;\n \t  }\n "}]}