{"sha": "6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2NjM2ZWM4YjUwNDRhN2FiMmI0NjRmNmU3ZDdkNzFhZGU0MjM1Ng==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-10-02T12:59:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T12:59:17Z"}, "message": "s-bignum.adb (Big_Exp): 0**0 should be 1, not 0.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* s-bignum.adb (Big_Exp): 0**0 should be 1, not 0.\n\t(Big_Exp): Fix possible error for (-1)**0.\n\t(Big_Exp): Fix error in computing 2**K for small K.\n\t(Big_Mod): Fix wrong sign for negative operands.\n\t(Div_Rem): Fix bad results for operands close to 2**63.\n\t* s-bignum.ads: Add documentation and an assertion to require\n\tLLI size to be 64 bits.\n\t* sem_prag.adb (Analyze_Pragma, case Overflow_Checks): Do not\n\tallow ELIMINATED if LLI'Size is other than 64 bits.\n\t* switch-c.adb (Scan_Switches): Do not allow -gnato3 if LLI'Size\n\tis not 64 bits.\n\t* switch.ads (Bad_Switch): Add missing pragma No_Return.\n\t* gnat_ugn.texi: Added appendix on Overflow Check Handling in GNAT.\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_type.adb: Minor reformatting.\n\nFrom-SVN: r191979", "tree": {"sha": "bd1180312057b27717b504e3498a14d80f2da58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd1180312057b27717b504e3498a14d80f2da58f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/comments", "author": null, "committer": null, "parents": [{"sha": "00bf6feed1ba6566d593073044b3fb133f2305ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bf6feed1ba6566d593073044b3fb133f2305ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00bf6feed1ba6566d593073044b3fb133f2305ec"}], "stats": {"total": 785, "additions": 644, "deletions": 141}, "files": [{"sha": "837baff5fd56425818491e5329fa6d8cd6b2487b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -1,3 +1,23 @@\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-bignum.adb (Big_Exp): 0**0 should be 1, not 0.\n+\t(Big_Exp): Fix possible error for (-1)**0.\n+\t(Big_Exp): Fix error in computing 2**K for small K.\n+\t(Big_Mod): Fix wrong sign for negative operands.\n+\t(Div_Rem): Fix bad results for operands close to 2**63.\n+\t* s-bignum.ads: Add documentation and an assertion to require\n+\tLLI size to be 64 bits.\n+\t* sem_prag.adb (Analyze_Pragma, case Overflow_Checks): Do not\n+\tallow ELIMINATED if LLI'Size is other than 64 bits.\n+\t* switch-c.adb (Scan_Switches): Do not allow -gnato3 if LLI'Size\n+\tis not 64 bits.\n+\t* switch.ads (Bad_Switch): Add missing pragma No_Return.\n+\t* gnat_ugn.texi: Added appendix on Overflow Check Handling in GNAT.\n+\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_type.adb: Minor reformatting.\n+\n 2012-10-02  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch8.adb: Minor reformatting."}, {"sha": "45c02d84b18c2ed1ee55943ea3ba13f287f1f9d7", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 544, "deletions": 84, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -208,6 +208,7 @@ AdaCore@*\n * Platform-Specific Information for the Run-Time Libraries::\n * Example of Binder Output File::\n * Elaboration Order Handling in GNAT::\n+* Overflow Check Handling in GNAT::\n * Conditional Compilation::\n * Inline Assembler::\n * Compatibility and Porting Guide::\n@@ -611,6 +612,13 @@ Elaboration Order Handling in GNAT\n * Summary of Procedures for Elaboration Control::\n * Other Elaboration Order Considerations::\n \n+Overflow Check Handling in GNAT\n+* Background::\n+* Overflow Checking Modes in GNAT::\n+* Specifying the Desired Mode::\n+* Default Settings::\n+* Implementation Notes::\n+\n Conditional Compilation\n * Use of Boolean Constants::\n * Debugging - A Special Case::\n@@ -890,6 +898,10 @@ output file for a sample program.\n @ref{Elaboration Order Handling in GNAT}, describes how GNAT helps\n you deal with elaboration order issues.\n \n+@item\n+@ref{Overflow Check Handling in GNAT}, describes how GNAT helps\n+you deal with arithmetic overflow issues.\n+\n @item\n @ref{Conditional Compilation}, describes how to model conditional compilation,\n both with Ada in general and with GNAT facilities in particular.\n@@ -4327,26 +4339,35 @@ inlining, but that is no longer the case.\n \n @item -gnato??\n @cindex @option{-gnato??} (@command{gcc})\n-Set default overflow cheecking mode. If ?? is a single digit, in the\n-range 0-3, it sets the overflow checking mode for all expressions,\n-including those outside and within assertions. The meaning of nnn is:\n+Set default overflow checking mode. Here `@code{??}' is two digits, a\n+single digit, or nothing. Each digit is one of the digits `@code{0}'\n+through `@code{3}':\n \n-  0   suppress overflow checks (SUPPRESSED)\n-  1   all intermediate overflows checked (CHECKED)\n-  2   minimize intermediate overflows (MINIMIZED)\n-  3   eliminate intermediate overflows (ELIMINATED)\n+@itemize @bullet\n+@item   @code{0}:\n+suppress overflow checks (@code{SUPPRESSED})\n+@item   @code{1}:\n+all intermediate overflows checked (@code{CHECKED})\n+@item   @code{2}:\n+minimize intermediate overflows (@code{MINIMIZED})\n+@item   @code{3}:\n+eliminate intermediate overflows (@code{ELIMINATED})\n+@end itemize\n \n-Otherwise ?? can be two digits, both 0-3, and in this case the first\n-digit sets the mode (using the above code) for expressions outside an\n-assertion, and the second digit sets the mode for expressions within\n-an assertion.\n+If only one digit appears then it applies to all\n+cases; if two digits are given, then the first applies outside\n+assertions, and the second within assertions.\n \n-@item -gnato\n-@cindex @option{-gnato} (@command{gcc})\n-Enable numeric overflow checking (which is not normally enabled by\n-default). Note that division by zero is a separate check that is not\n+If no digits follow the @option{-gnato}, then it is equivalent to\n+@option{-gnato11},\n+causing all intermediate overflows to be checked.\n+\n+The default if no option @option{-gnato} is given is that overflows are not\n+checked, which is equivalent to @option{-gnato00}.\n+Note that division by zero is a separate check that is not\n controlled by this switch (division by zero checking is on by default).\n-The checking mode is set to CHECKED (equivalent to @option{^-gnato11^/OVERFLOW_CHECKS=11^}).\n+\n+See also @ref{Specifying the Desired Mode}.\n \n @item -gnatp\n @cindex @option{-gnatp} (@command{gcc})\n@@ -6881,78 +6902,103 @@ The @option{-gnatp} switch has no effect if a subsequent\n @findex Suppress\n This switch cancels the effect of a previous @option{gnatp} switch.\n \n-@item -gnato\n-@cindex @option{-gnato} (@command{gcc})\n+@item -gnato??\n+@cindex @option{-gnato??} (@command{gcc})\n @cindex Overflow checks\n @cindex Check, overflow\n-Enables overflow checking for integer operations.\n-This causes GNAT to generate slower and larger executable\n-programs by adding code to check for overflow (resulting in raising\n-@code{Constraint_Error} as required by standard Ada\n-semantics). These overflow checks correspond to situations in which\n-the true value of the result of an operation may be outside the base\n-range of the result type. The following example shows the distinction:\n+In @code{CHECKED} and @code{MINIMIZED} modes (@option{-gnato1} and\n+@option{-gnato2}), it enables overflow checking for integer operations.\n+In @code{ELIMINATED} mode (@option{-gnato3}), it enables arbitrary\n+precision arithmetic for integer operations. In all these modes, this\n+causes @value{EDITION} to generate slower and larger executable programs\n+by adding code to either check for overflow (resulting in raising\n+@code{Constraint_Error} as required by standard Ada semantics) or avoid\n+overflows. In mode @code{CHECKED}, overflow checks correspond to\n+situations in which the true value of the result of an operation may be\n+outside the base range of the result type. In mode @code{MINIMIZED},\n+overflow checks correspond to situations in which the true value of the\n+result of an operation may be outside the largest available machine\n+integer type (@code{Long_Long_Integer}). The following example shows the\n+distinction:\n \n @smallexample @c ada\n-X1 : Integer := \"Integer'Last\";\n-X2 : Integer range 1 .. 5 := \"5\";\n-X3 : Integer := \"Integer'Last\";\n-X4 : Integer range 1 .. 5 := \"5\";\n-F  : Float := \"2.0E+20\";\n-@dots{}\n-X1 := X1 + 1;\n-X2 := X2 + 1;\n-X3 := Integer (F);\n-X4 := Integer (F);\n-@end smallexample\n-\n-@noindent\n-Note that if explicit values are assigned at compile time, the\n-compiler may be able to detect overflow at compile time, in which case\n-no actual run-time checking code is required, and Constraint_Error\n-will be raised unconditionally, with or without\n-@option{-gnato}. That's why the assigned values in the above fragment\n-are in quotes, the meaning is \"assign a value not known to the\n-compiler that happens to be equal to ...\". The remaining discussion\n-assumes that the compiler cannot detect the values at compile time.\n-\n-Here the first addition results in a value that is outside the base range\n-of Integer, and hence requires an overflow check for detection of the\n-constraint error. Thus the first assignment to @code{X1} raises a\n-@code{Constraint_Error} exception only if @option{-gnato} is set.\n-\n-The second increment operation results in a violation of the explicit\n-range constraint; such range checks are performed by default, and are\n-unaffected by @option{-gnato}.\n-\n-The two conversions of @code{F} both result in values that are outside\n-the base range of type @code{Integer} and thus will raise\n-@code{Constraint_Error} exceptions only if @option{-gnato} is used.\n-The fact that the result of the second conversion is assigned to\n-variable @code{X4} with a restricted range is irrelevant, since the problem\n-is in the conversion, not the assignment.\n-\n-Basically the rule is that in the default mode (@option{-gnato} not\n-used), the generated code assures that all integer variables stay\n-within their declared ranges, or within the base range if there is\n-no declared range. This prevents any serious problems like indexes\n-out of range for array operations.\n-\n-What is not checked in default mode is an overflow that results in\n-an in-range, but incorrect value. In the above example, the assignments\n-to @code{X1}, @code{X2}, @code{X3} all give results that are within the\n-range of the target variable, but the result is wrong in the sense that\n-it is too large to be represented correctly. Typically the assignment\n-to @code{X1} will result in wrap around to the largest negative number.\n-The conversions of @code{F} will result in some @code{Integer} value\n-and if that integer value is out of the @code{X4} range then the\n-subsequent assignment would generate an exception.\n+procedure Add_And_Subtract (X : in out Integer; Y, Z : in Integer) is\n+begin\n+   X := X + Y - Z;\n+end Add_And_Subtract;\n+\n+X1 : Integer := Integer'Last;\n+X2 : Integer range 1 .. 5 := 5;\n+\n+Add_And_Subtract (X1, 1, 0);  --  first addition and subtraction\n+Add_And_Subtract (X1, 1, 1);  --  second addition and subtraction\n+Add_And_Subtract (X2, 1, 0);  --  third addition and subtraction\n+Add_And_Subtract (X2, 1, 1);  --  fourth addition and subtraction\n+@end smallexample\n+\n+@noindent\n+Note that if explicit values are assigned at compile time, the compiler\n+may be able to detect overflow at compile time, in which case no actual\n+run-time checking code is required, and @code{Constraint_Error} will be\n+raised unconditionally, with or without @option{-gnato}.\n+\n+The first addition results in a value that is outside the base range of\n+@code{Integer}. In mode @code{CHECKED}, this raises\n+@code{Constraint_Error} at run time. In mode @code{MINIMIZED}, the\n+addition and subtraction are performed in type @code{Long_Long_Integer},\n+which is 64 bits for most machines. The compiler detects that no\n+overflow check is needed on these operations. The program still raises\n+@code{Constraint_Error} at run time because the resulting value is too\n+large to be assigned to @code{X}. The assignment results in a violation\n+of the explicit range constraint; such range checks are performed by\n+default, and are unaffected by @option{-gnato??}.  In mode\n+@code{ELIMINATED}, the compiler uses type @code{Long_Long_Integer} for\n+intermediate computations, as this type is sufficient here to avoid all\n+overflows. When it is not sufficient, the compiler uses instead a\n+library for multiple-precision arithmetic, which may cause a significant\n+run-time overhead. The program still raises @code{Constraint_Error} at\n+run time when assigning to @code{X}.\n+\n+The second addition results in a value that is outside the base range of\n+@code{Integer}. In mode @code{CHECKED}, this raises\n+@code{Constraint_Error} at run time, like in the previous case. In mode\n+@code{MINIMIZED}, the addition and subtraction are performed in type\n+@code{Long_Long_Integer}, resulting in a final value that fits in an\n+@code{Integer}. Thus, no @code{Constraint_Error} is raised. In mode\n+@code{ELIMINATED}, the compiler generates the same code as in mode\n+@code{MINIMIZED}, which avoids all overflows.\n+\n+The third addition and subtraction result in an intermediate value and a\n+result well in the base range of @code{Integer}, so no\n+@code{Constraint_Error} exception is raised at run time in any\n+mode. However, the copy to @code{X2} when returning from the call to\n+@code{Add_And_Subtract} fails the range check for the type of\n+@code{X2}. Hence, a @code{Constraint_Error} exception is raised at run\n+time in all modes.\n+\n+The fourth addition and subtraction result in an intermediate value and\n+a result well in the base range of @code{Integer}, and in a final value\n+that fits in the type of @code{X2}. Hence, no exception is raised at run\n+time in any mode.\n+\n+Basically the rule is that in the default mode (@option{-gnato??} not\n+used), the generated code assures that all integer variables stay within\n+their declared ranges, or within the base range if there is no declared\n+range. This prevents any serious problems like indexes out of range for\n+array operations.\n+\n+What is not checked in default mode is an overflow that results in an\n+in-range, but incorrect value. In the above example, the first\n+assignment to @code{X1} gives a result that is within the range of the\n+target variable, but the result is wrong in the sense that it is too\n+large to be represented correctly. Typically the assignment to @code{X1}\n+will result in wrap around to the largest negative number.\n \n @findex Machine_Overflows\n-Note that the @option{-gnato} switch does not affect the code generated\n+Note that the @option{-gnato??} switch does not affect the code generated\n for any floating-point operations; it applies only to integer\n-semantics).\n-For floating-point, GNAT has the @code{Machine_Overflows}\n+semantics.\n+For floating-point, @value{EDITION} has the @code{Machine_Overflows}\n attribute set to @code{False} and the normal mode of operation is to\n generate IEEE NaN and infinite values on overflow or invalid operations\n (such as dividing 0.0 by 0.0).\n@@ -6965,12 +7011,12 @@ subscript), or a wild jump (from an out of range case value). Overflow\n checking is also quite expensive in time and space, since in general it\n requires the use of double length arithmetic.\n \n-Note again that @option{-gnato} is off by default, so overflow checking is\n+Note again that the default is @option{-gnato00}, so overflow checking is\n not performed in default mode. This means that out of the box, with the\n-default settings, GNAT does not do all the checks expected from the\n+default settings, @value{EDITION} does not do all the checks expected from the\n language description in the Ada Reference Manual. If you want all constraint\n checks to be performed, as described in this Manual, then you must\n-explicitly use the -gnato switch either on the @command{gnatmake} or\n+explicitly use the @option{-gnato??} switch either on the @command{gnatmake} or\n @command{gcc} command.\n \n @item -gnatE\n@@ -25480,6 +25526,420 @@ and figuring out which is correct, and then adding the necessary\n @code{Elaborate} or @code{Elaborate_All} pragmas to ensure the desired order.\n \n \n+@c **********************************\n+@node Overflow Check Handling in GNAT\n+@appendix Overflow Check Handling in GNAT\n+@cindex Overflow checks\n+@cindex Checks (overflow)\n+@c **********************************\n+\n+@menu\n+* Background::\n+* Overflow Checking Modes in GNAT::\n+* Specifying the Desired Mode::\n+* Default Settings::\n+* Implementation Notes::\n+@end menu\n+\n+\n+@node Background\n+@section Background\n+\n+@noindent\n+Overflow checks are checks that the compiler may make to ensure\n+that intermediate results are not out of range. For example:\n+\n+@smallexample @c ada\n+   A : Integer;\n+   ...\n+   A := A + 1;\n+@end smallexample\n+\n+@noindent\n+if @code{A} has the value @code{Integer'Last}, then the addition may cause\n+overflow since the result is out of range of the type @code{Integer}.\n+In this case @code{Constraint_Error} will be raised if checks are\n+enabled.\n+\n+A trickier situation arises in examples like the following:\n+\n+@smallexample @c ada\n+  A, C : Integer;\n+  ...\n+  A := (A + 1) + C;\n+@end smallexample\n+\n+@noindent\n+where @code{A} is @code{Integer'Last} and @code{C} is @code{-1}.\n+Now the final result of the expression on the right hand side is\n+@code{Integer'Last} which is in range, but the question arises whether the\n+intermediate addition of @code{(A + 1)} raises an overflow error.\n+\n+The (perhaps surprising) answer is that the Ada language\n+definition does not answer this question. Instead it leaves\n+it up to the implementation to do one of two things:\n+\n+@itemize @bullet\n+@item\n+raise an exception (@code{Constraint_Error}), or\n+\n+@item\n+yield the correct mathematical result which is then used in\n+subsequent operations.\n+@end itemize\n+\n+@noindent\n+If the compiler chooses the first approach, then the assignment of this\n+example will indeed raise @code{Constraint_Error}. But if the compiler\n+chooses the second approach, then it can perform both additions yielding\n+the correct mathematical result, which is in range, so no exception\n+will be raised.\n+\n+Note that in the first example an\n+exception will be raised in either case, since if the compiler\n+gives the correct mathematical result for the addition, it will\n+be out of range of the target type of the assignment, and thus\n+fails the range check.\n+\n+This lack of specified behavior in the handling of overflow for\n+intermediate results is a source of non-portability, and can thus\n+be problematic when programs are ported. Most typically this arises\n+in a situation where the original compiler did not raise an exception,\n+and then the application is moved to a compiler where the check is\n+performed on the intermediate result and an unexpected exception is\n+raised.\n+\n+Furthermore, when using Ada 2012's preconditions and other\n+assertion forms, another issue arises. Consider:\n+\n+@smallexample @c ada\n+     procedure P (A, B : Integer) with\n+       Pre => A + B <= Integer'Last;\n+@end smallexample\n+\n+@noindent\n+One often wants to regard arithmetic in a context like this from\n+a mathematical point of view. So for example, if the two actual parameters\n+for a call to @code{P} are both @code{Integer'Last}, then\n+the precondition should be regarded as False. If we are executing\n+in a mode with run-time checks enabled for preconditions, then we would\n+like this precondition to fail, rather than raising an exception\n+because of the intermediate overflow.\n+\n+However, the language definition leaves the specification of\n+whether the above condition fails (raising @code{Assert_Error}) or\n+causes an intermediate overflow (raising @code{Constraint_Error})\n+up to the implementation.\n+\n+The situation is worse in a case such as the following:\n+\n+@smallexample @c ada\n+     procedure Q (A, B, C : Integer) with\n+       Pre => A + B + C <= Integer'Last;\n+@end smallexample\n+\n+@noindent\n+Consider the call\n+\n+@smallexample @c ada\n+     Q (A => Integer'Last, B => 1, C => -1);\n+@end smallexample\n+\n+@noindent\n+From a mathematical point of view the precondition\n+is True, but at run time we may (but are not guaranteed to) get an\n+exception raised because of the intermediate overflow (and we really\n+would prefer this precondition to be considered True at run time).\n+\n+@node Overflow Checking Modes in GNAT\n+@section Overflow Checking Modes in GNAT\n+\n+@noindent\n+To deal with the portability issue, and with the problem of\n+mathematical versus run-time intepretation of the expressions in\n+assertions, GNAT provides comprehensive control over the handling\n+of intermediate overflow. GNAT can operate in four modes, and\n+furthemore, permits separate selection of operating modes for\n+the expressions within assertions (here the term ``assertions''\n+is used in the technical sense, which includes preconditions and so forth)\n+and for expressions appearing outside assertions.\n+\n+The four modes are:\n+\n+@itemize @bullet\n+@item   @i{Checks suppressed} (@code{SUPPRESSED})\n+\n+     This is the normal defined language mode, as specified by a pragma\n+     @code{Suppress (Overflow_Check)}. If any intermediate overflow occurs,\n+     then the program execution is erroneous, which means that anything\n+     could happen. Note in particular, that the result of evaluating\n+     a precondition may be plain wrong if there is an intermediate\n+     overflow, as in our examples above.\n+\n+@item   @i{All intermediate overflows checked} (@code{CHECKED})\n+\n+     In this mode, all intermediate results for predefined arithmetic\n+     operators must be in range of the base type. If this is not the\n+     case a constraint error is raised. This is the normal default mode\n+     specified by use of the pragma @code{Unsuppress (Overflow_Check)}.\n+\n+@item   @i{Most intermediate overflows avoided} (@code{MINIMIZED})\n+\n+     In this mode, the compiler attempts to avoid intermediate overflows by\n+     using @code{Long_Long_Integer} as the type in which arithmetic is\n+     performed for predefined arithmetic operators. This is slightly more\n+     expensive at\n+     run time (compared to suppressing intermediate overflow checks), though\n+     the cost is minimal on modern 64-bit machines. For the examples given\n+     earlier, no intermediate overflows would have resulted in exceptions,\n+     since the intermediate results are all in the range of\n+     @code{Long_Long_Integer} (typically 64-bits on nearly all implementations\n+     of GNAT).\n+\n+     However, there are cases where @code{Long_Long_Integer} is not large\n+     enough, consider the following example:\n+\n+@smallexample @c ada\n+       procedure R (A, B, C, D : Integer) with\n+         Pre => (A**2 * B**2) / (C**2 * D**2) <= 10;\n+@end smallexample\n+\n+     where @code{A} = @code{B} = @code{C} = @code{D} = @code{Integer'Last}.\n+     Now the intermediate results are\n+     out of the range of @code{Long_Long_Integer} even though the final result\n+     is in range and the precondition is True (from a mathematical point\n+     of view). In such a case, operating in this mode, an exception will\n+     be raised for the intermediate overflow (which is why this mode\n+     says @i{most} intermediate overflows are avoided).\n+\n+@item   @i{All intermediate overflows avoided} (@code{ELIMINATED})\n+\n+     In this mode, the compiler  avoids all intermediate overflows\n+     by using arbitrary precision arithmetic as required. In this\n+     mode, the above example with @code{A**2 * B**2} would\n+     not cause intermediate overflow, because the intermediate result\n+     would be evaluated using sufficient precision, and the result\n+     of evaluating the precondition would be True.\n+\n+     This mode has the advantage of avoiding any intermediate\n+     overflows, but at the expense of significant run-time overhead,\n+     including the use of a library (included automatically in this\n+     mode) for multiple-precision arithmetic.\n+\n+     This mode provides cleaner semantics for assertions, since now\n+     the run-time behavior emulates true arithmetic behavior for the\n+     predefined arithmetic operators, meaning that there is never a\n+     conflict between the mathematical view of the assertion, and its\n+     run-time behavior.\n+@end itemize\n+\n+@noindent\n+  Note that these modes apply only to the evaluation of predefined\n+  arithmetic, membership, and comparison operators for signed integer\n+  aritmetic.\n+\n+  For fixed-point arithmetic, checks can be suppressed. But if checks\n+  are enabled (any of the three non-suppress modes will enable checks),\n+  then fixed-point values are always checked for overflow against the\n+  base type for intermediate expressions.\n+\n+  For floating-point, on nearly all architectures, @code{Machine_Overflows}\n+  is False, and IEEE infinities are generated, so overflow exceptions\n+  are never raised. If you want to avoid infinities, and check that\n+  final results of expressions are in range, then you can declare a\n+  constrained floating-point type, and range checks will be carried\n+  out in the normal manner (with infinite values always failing all\n+  range checks).\n+\n+\n+@c -------------------------\n+@node Specifying the Desired Mode\n+@section Specifying the Desired Mode\n+\n+@noindent\n+The desired mode of overflow checking can be specified using\n+either the @code{Overflow_Checks} pragma or an equivalent compiler switch.\n+The pragma has the form\n+@cindex pragma @code{Overflow_Checks}\n+\n+@smallexample @c ada\n+    pragma Overflow_Checks ([General =>] MODE [, [Assertions =>] MODE]);\n+@end smallexample\n+\n+@noindent\n+where @code{MODE} is one of\n+\n+@itemize @bullet\n+@item   @code{SUPPRESSED}: suppress overflow checks\n+@item   @code{CHECKED}:  all intermediate overflows checked\n+@item   @code{MINIMIZED}: minimize intermediate overflows\n+@item   @code{ELIMINATED}: eliminate intermediate overflows\n+@end itemize\n+\n+@noindent\n+The case is ignored, so @code{MINIMIZED}, @code{Minimized} and\n+@code{minimized} all have the same effect.\n+\n+If only the @code{General} parameter is present, then the given @code{MODE}\n+applies\n+to expressions both within and outside assertions. If both arguments\n+are present, then @code{General} applies to expressions outside assertions,\n+and @code{Assertions} applies to expressions within assertions. For example:\n+\n+@smallexample @c ada\n+   pragma Overflow_Checks\n+     (General => Minimized, Assertions => Eliminated);\n+@end smallexample\n+\n+@noindent\n+specifies that general expressions outside assertions be evaluated\n+in ``minimize intermediate overflows'' mode, and expressions within\n+assertions be evaluated in ``eliminate intermediate overflows'' mode.\n+This is often a reasonable choice, avoiding excessive overhead\n+outside assertions, but assuring a high degree of portability\n+when importing code from another compiler, while incurring\n+the extra overhead for assertion expressions to ensure that\n+the behavior at run time matches the expected mathematical\n+behavior.\n+\n+The @code{Overflow_Checks} pragma has the same scoping and placement\n+rules as pragma @code{Suppress}, so it can occur either as a\n+configuration pragma, specifying a default for the whole\n+program, or in a declarative scope, where it applies to the\n+remaining declarations and statements in that scope.\n+\n+Additionally, a compiler switch @option{-gnato?} or @option{-gnato??}\n+can be used to control the checking mode default (which can be subsequently\n+overridden using the pragma form).\n+@cindex @option{-gnato?} (gcc)\n+@cindex @option{-gnato??} (gcc)\n+\n+Here `@code{?}' is one of the digits `@code{0}' through `@code{3}':\n+\n+@itemize @bullet\n+@item   @code{0}:\n+suppress overflow checks (@code{SUPPRESSED})\n+@item   @code{1}:\n+all intermediate overflows checked (@code{CHECKED})\n+@item   @code{2}:\n+minimize intermediate overflows (@code{MINIMIZED})\n+@item   @code{3}:\n+eliminate intermediate overflows (@code{ELIMINATED})\n+@end itemize\n+\n+@noindent\n+As with the pragma, if only one digit appears then it applies to all\n+cases; if two digits are given, then the first applies outside\n+assertions, and the second within assertions. Thus the equivalent\n+of the example pragma above would be @option{-gnato23}.\n+\n+If no digits follow the @option{-gnato}, then it is equivalent to\n+@option{-gnato11},\n+causing all intermediate overflows to be checked.\n+\n+\n+@c -------------------------\n+@node Default Settings\n+@section Default Settings\n+\n+The default mode for overflow checks is\n+\n+@smallexample\n+   General => Suppressed\n+@end smallexample\n+\n+@noindent\n+which suppresses checks inside and outside assertions,\n+This retains compatibility with previous versions of\n+GNAT which suppressed overflow checks by default.\n+\n+The switch @option{-gnato} (with no digits following) is equivalent to\n+@cindex @option{-gnato} (gcc)\n+\n+@smallexample\n+   General => Checked\n+@end smallexample\n+\n+@noindent\n+which causes overflow checking of all intermediate overflows\n+both inside and outside assertions. This provides compatibility\n+with this switch as implemented in previous versions of GNAT.\n+\n+The pragma @code{Suppress (Overflow_Check)} sets mode\n+\n+@smallexample\n+   General => Suppressed\n+@end smallexample\n+\n+@noindent\n+suppressing all overflow checking within and outside\n+assertions.\n+@cindex @code{Overflow_Check} (argument to pragma Suppress)\n+\n+The pragam @code{Unsuppress (Overflow_Check)} sets mode\n+\n+@smallexample\n+   General => Checked\n+@end smallexample\n+\n+@noindent\n+which causes overflow checking of all intermediate overflows.\n+This applies both inside and outside assertions.\n+@cindex @code{Overflow_Check} (argument to pragma Unsuppress)\n+\n+\n+@c -------------------------\n+@node Implementation Notes\n+@section Implementation Notes\n+\n+In practice on typical 64-bit machines, the @code{MINIMIZED} mode is\n+reasonably efficient, and can be generally used. It also helps\n+to ensure compatibility with code imported from some other\n+compiler to GNAT.\n+\n+Setting all intermediate overflows checking (@code{CHECKED} mode)\n+makes sense if you want to\n+make sure that your code is compatible with any other possible\n+Ada implementation. This may be useful in ensuring portability\n+for code that is to be exported to some other compiler than GNAT.\n+It is also appropriate if you intend to turn off checks for\n+the final delivered software, since in @code{SUPPRESSED} mode, the\n+assumption is that all intermediate results are in range. In\n+this situation, it is likely that you are also suppressing\n+assertions in the final executable, so in that case it does not\n+matter which mode is selected for assertions during development.\n+\n+The Ada standard allows the reassociation of expressions at\n+the same precedence level if no parentheses are present. For\n+example, @w{@code{A+B+C}} parses as though it were @w{@code{(A+B)+C}}, but\n+the compiler can reintepret this as @w{@code{A+(B+C)}}, possibly\n+introducing or eliminating an overflow exception. The GNAT\n+compiler never takes advantage of this freedom, and the\n+expression @w{@code{A+B+C}} will be evaluated as @w{@code{(A+B)+C}}.\n+If you need the other order, you can write the parentheses\n+explicitly @w{@code{A+(B+C)}} and GNAT will respect this order.\n+\n+The use of @code{ELIMINATED} mode will cause the compiler to\n+automatically include an appropriate arbitrary precision\n+integer arithmetic package. The compiler will make calls\n+to this package, though only in cases where it cannot be\n+sure that @code{Long_Long_Integer} is sufficient to guard against\n+intermediate overflows. This package does not use dynamic\n+alllocation, but it does use the secondary stack, so an\n+appropriate secondary stack package must be present (this\n+is always true for standard full Ada, but may require\n+specific steps for restricted run times such as ZFP).\n+\n+Although @code{ELIMINATED} mode causes expressions to use arbitrary\n+precision arithmetic, avoiding overflow, the final result\n+must be in an appropriate range. This is true even if the\n+final result is of type @code{[Long_[Long_]]Integer'Base}, which\n+still has the same bounds as its associated constrained\n+type at run-time.\n+\n+Currently, the @code{ELIMINATED} mode is only available on target\n+platforms for which @code{Long_Long_Integer} is 64-bits (nearly all GNAT\n+platforms).\n \n @c *******************************\n @node Conditional Compilation"}, {"sha": "69772772f558a87b8d20eda1a7b86ae9f89e69be", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -42,7 +42,7 @@ package body System.Bignums is\n    use Interfaces;\n    --  So that operations on Unsigned_32 are available\n \n-   type DD is mod SD'Modulus ** 2;\n+   type DD is mod Base ** 2;\n    --  Double length digit used for intermediate computations\n \n    function MSD (X : DD) return SD is (SD (X / Base));\n@@ -361,7 +361,12 @@ package body System.Bignums is\n       if Y.Neg then\n          raise Constraint_Error with \"exponentiation to negative power\";\n \n-      --  0 ** X is always 0\n+      --  X ** 0 is always 1 (including 0 ** 0, so do this test first)\n+\n+      elsif Y.Len = 0 then\n+         return Normalize (One_Data);\n+\n+      --  0 ** X is always 0 (for X non-zero)\n \n       elsif X.Len = 0 then\n          return Normalize (Zero_Data);\n@@ -380,12 +385,12 @@ package body System.Bignums is\n       elsif Y.Len > 1 then\n          raise Storage_Error with \"exponentiation result is too large\";\n \n-      --  Special case (+/-)2 ** K, where K is 31 or less using a shift\n+      --  Special case (+/-)2 ** K, where K is 1 .. 31 using a shift\n \n       elsif X.Len = 1 and then X.D (1) = 2 and then Y.D (1) < 32 then\n          declare\n             D : constant Digit_Vector (1 .. 1) :=\n-                  (1 => Shift_Left (SD'(1), Natural (Y.D (1) - 1)));\n+                  (1 => Shift_Left (SD'(1), Natural (Y.D (1))));\n          begin\n             return Normalize (D, X.Neg);\n          end;\n@@ -492,7 +497,7 @@ package body System.Bignums is\n             declare\n                T1 : constant Bignum := Big_Sub (Y, R);\n             begin\n-               T1.Neg := X.Neg;\n+               T1.Neg := Y.Neg;\n                Free_Bignum (R);\n                return T1;\n             end;\n@@ -597,7 +602,7 @@ package body System.Bignums is\n \n    function Big_Sub (X, Y : Bignum) return Bignum is\n    begin\n-      --  If right operand zero, return left operand\n+      --  If right operand zero, return left operand (avoiding sharing)\n \n       if Y.Len = 0 then\n          return Normalize (X.D, X.Neg);\n@@ -668,13 +673,13 @@ package body System.Bignums is\n          Quotient  := Normalize (Zero_Data);\n          return;\n \n-      --  If both X and Y are comfortably less than 2**63-1, we can just use\n-      --  Long_Long_Integer arithmetic. Note it is good not to do an accurate\n-      --  range check here since -2**63 / -1 overflows!\n+      --  If both X and Y are less than 2**63-1, we can use Long_Long_Integer\n+      --  arithmetic. Note it is good not to do an accurate range check against\n+      --  Long_Long_Integer since -2**63 / -1 overflows!\n \n-      elsif (X.Len <= 1 or else (X.Len = 2 and then X.D (1) <= 2**31))\n+      elsif (X.Len <= 1 or else (X.Len = 2 and then X.D (1) < 2**31))\n               and then\n-            (Y.Len <= 1 or else (Y.Len = 2 and then Y.D (1) <= 2**31))\n+            (Y.Len <= 1 or else (Y.Len = 2 and then Y.D (1) < 2**31))\n       then\n          declare\n             A : constant LLI := abs (From_Bignum (X));"}, {"sha": "7236774bfe2524f9676616e405244ce85464203a", "filename": "gcc/ada/s-bignum.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fs-bignum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fs-bignum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.ads?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -31,12 +31,17 @@\n \n --  This package provides arbitrary precision signed integer arithmetic for\n --  use in computing intermediate values in expressions for the case where\n---  pragma Overflow_Check (Eliminate) is in effect.\n+--  pragma Overflow_Check (Eliminated) is in effect.\n \n with Interfaces;\n \n package System.Bignums is\n \n+   pragma Assert (Long_Long_Integer'Size = 64);\n+   --  This package assumes that Long_Long_Integer size is 64 bit (i.e. that it\n+   --  has a range of -2**63 to 2**63-1). The front end ensures that the mode\n+   --  ELIMINATED is not allowed for overflow checking if this is not the case.\n+\n    subtype Length is Natural range 0 .. 2 ** 23 - 1;\n    --  Represent number of words in Digit_Vector\n \n@@ -65,6 +70,10 @@ package System.Bignums is\n    end record;\n \n    type Bignum is access all Bignum_Data;\n+   --  This the type that is used externally. Possibly this could be a private\n+   --  type, but we leave the structure exposed for now. For one thing it helps\n+   --  with debugging. Note that this package never shares an allocated Bignum\n+   --  value, so for example for X + 0, a copy of X is returned, not X itself.\n \n    --  Note: none of the subprograms in this package modify the Bignum_Data\n    --  records referenced by Bignum arguments of mode IN."}, {"sha": "f7e32a50607b28041dc430eb488a733b51204e02", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -11773,6 +11773,9 @@ package body Sem_Prag is\n \n          --  MODE := SUPPRESSED | CHECKED | MINIMIZED | ELIMINATED\n \n+         --  Note: MINIMIZED is allowed only if Long_Long_Integer'Size is 64\n+         --  since System.Bignums makes this assumption.\n+\n          when Pragma_Overflow_Checks => Overflow_Checks : declare\n             function Get_Check_Mode\n               (Name : Name_Id;\n@@ -11797,12 +11800,21 @@ package body Sem_Prag is\n \n                if Chars (Argx) = Name_Suppressed then\n                   return Suppressed;\n+\n                elsif Chars (Argx) = Name_Checked then\n                   return Checked;\n+\n                elsif Chars (Argx) = Name_Minimized then\n                   return Minimized;\n+\n                elsif Chars (Argx) = Name_Eliminated then\n-                  return Eliminated;\n+                  if Ttypes.Standard_Long_Long_Integer_Size /= 64 then\n+                     Error_Pragma_Arg\n+                       (\"Eliminated not implemented on this target\", Argx);\n+                  else\n+                     return Eliminated;\n+                  end if;\n+\n                else\n                   Error_Pragma_Arg (\"invalid argument for pragma%\", Argx);\n                end if;"}, {"sha": "0c46536e9613dadbe17f91014bdae76f6026a010", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -741,7 +741,6 @@ package body Sem_Type is\n    ------------\n \n    function Covers (T1, T2 : Entity_Id) return Boolean is\n-\n       BT1 : Entity_Id;\n       BT2 : Entity_Id;\n "}, {"sha": "7dbbd8a86b6284218de6082770046516e2dbe6cc", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -33,6 +33,7 @@ with Osint;    use Osint;\n with Opt;      use Opt;\n with Validsw;  use Validsw;\n with Stylesw;  use Stylesw;\n+with Ttypes;   use Ttypes;\n with Warnsw;   use Warnsw;\n \n with Ada.Unchecked_Deallocation;\n@@ -50,6 +51,10 @@ package body Switch.C is\n       new Ada.Unchecked_Deallocation (String_List, String_List_Access);\n    --  Avoid using System.Strings.Free, which also frees the designated strings\n \n+   function Get_Overflow_Mode (C : Character) return Overflow_Check_Type;\n+   --  Given a digit in the range 0 .. 3, returns the corresponding value of\n+   --  Overflow_Check_Type. Raises program error if C is outside this range.\n+\n    function Switch_Subsequently_Cancelled\n      (C        : String;\n       Args     : String_List;\n@@ -72,7 +77,6 @@ package body Switch.C is\n          declare\n             New_Symbol_Definitions : constant String_List_Access :=\n               new String_List (1 .. 2 * Preprocessing_Symbol_Last);\n-\n          begin\n             New_Symbol_Definitions (Preprocessing_Symbol_Defs'Range) :=\n               Preprocessing_Symbol_Defs.all;\n@@ -86,6 +90,37 @@ package body Switch.C is\n         new String'(Def);\n    end Add_Symbol_Definition;\n \n+   -----------------------\n+   -- Get_Overflow_Mode --\n+   -----------------------\n+\n+   function Get_Overflow_Mode (C : Character) return Overflow_Check_Type is\n+   begin\n+      case C is\n+         when '0' =>\n+            return Suppressed;\n+\n+         when '1' =>\n+            return Checked;\n+\n+         when '2' =>\n+            return Minimized;\n+\n+         --  Eliminated allowed only if Long_Long_Integer is 64 bits (since\n+         --  the current implementation of System.Bignums assumes this).\n+\n+         when '3' =>\n+            if Standard_Long_Long_Integer_Size /= 64 then\n+               Bad_Switch (\"-gnato3 not implemented for this configuration\");\n+            else\n+               return Eliminated;\n+            end if;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Get_Overflow_Mode;\n+\n    -----------------------------\n    -- Scan_Front_End_Switches --\n    -----------------------------\n@@ -778,27 +813,8 @@ package body Switch.C is\n                else\n                   --  Handle first digit after -gnato\n \n-                  case Switch_Chars (Ptr) is\n-                     when '0' =>\n-                        Suppress_Options.Overflow_Checks_General :=\n-                          Suppressed;\n-\n-                     when '1' =>\n-                        Suppress_Options.Overflow_Checks_General :=\n-                          Checked;\n-\n-                     when '2' =>\n-                        Suppress_Options.Overflow_Checks_General :=\n-                          Minimized;\n-\n-                     when '3' =>\n-                        Suppress_Options.Overflow_Checks_General :=\n-                          Eliminated;\n-\n-                     when others =>\n-                        raise Program_Error;\n-                  end case;\n-\n+                  Suppress_Options.Overflow_Checks_General :=\n+                    Get_Overflow_Mode (Switch_Chars (Ptr));\n                   Ptr := Ptr + 1;\n \n                   --  Only one digit after -gnato, set assertions mode to\n@@ -813,27 +829,8 @@ package body Switch.C is\n                   --  Process second digit after -gnato\n \n                   else\n-                     case Switch_Chars (Ptr) is\n-                        when '0' =>\n-                           Suppress_Options.Overflow_Checks_Assertions :=\n-                             Suppressed;\n-\n-                        when '1' =>\n-                           Suppress_Options.Overflow_Checks_Assertions :=\n-                             Checked;\n-\n-                        when '2' =>\n-                           Suppress_Options.Overflow_Checks_Assertions :=\n-                             Minimized;\n-\n-                        when '3' =>\n-                           Suppress_Options.Overflow_Checks_Assertions :=\n-                             Eliminated;\n-\n-                        when others =>\n-                           raise Program_Error;\n-                     end case;\n-\n+                     Suppress_Options.Overflow_Checks_Assertions :=\n+                       Get_Overflow_Mode (Switch_Chars (Ptr));\n                      Ptr := Ptr + 1;\n                   end if;\n                end if;"}, {"sha": "9a01384b6abadb47d8a4dc0c1947a3897bce3c9c", "filename": "gcc/ada/switch.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fswitch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6636ec8b5044a7ab2b464f6e7d7d71ade42356/gcc%2Fada%2Fswitch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch.ads?ref=6e6636ec8b5044a7ab2b464f6e7d7d71ade42356", "patch": "@@ -128,6 +128,7 @@ private\n \n    procedure Bad_Switch (Switch : Character);\n    procedure Bad_Switch (Switch : String);\n+   pragma No_Return (Bad_Switch);\n    --  Fail with an appropriate message when a switch is not recognized\n \n end Switch;"}]}