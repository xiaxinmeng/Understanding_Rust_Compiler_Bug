{"sha": "f2ce41608ae0f55e6910756054cddf08aa3678ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJjZTQxNjA4YWUwZjU1ZTY5MTA3NTYwNTRjZGRmMDhhYTM2NzhmZg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-07-25T13:31:10Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-07-25T13:31:19Z"}, "message": "Support RangeFrom ([x..]) and RangeFromTo ([x..y]) in the parser\n\nParsing the .. (DOT_DOT) operator to get a range had two\nissues. Trying to compile:\n\n  let block = [1,2,3,4,5];\n  let _rf = &block[1..];\n  let _rt = &block[..3];\n  let _rft = &block[2..4];\n\nrange.rs:4:23: error: found unexpected token \u2018]\u2019 in null denotation\n    4 |   let _rf = &block[1..];\n      |                       ^\nrange.rs:4:24: error: expecting \u2018]\u2019 but \u2018;\u2019 found\n    4 |   let _rf = &block[1..];\n      |                        ^\n\nSince .. can represent either a range from or a range from-to it can\nbe followed by an expression or not. We do have a hack in our\npratt-parser so that it is allowed to return a nullptr. But even in\nthat case it will have swallowed the next token. Add another hack to\nthe pratt-parser so that if the next token is one that cannot start an\nexpression and the caller allows a nullptr return then don't skip the\ntoken and return immediately.\n\nAfter this patch we can parse the above range expressions, but we\nstill don't handle them fully:\n\nrange.rs:4:20: fatal error: Failed to lower expr: [1..]\n    4 |   let _rf = &block[1..];\n      |                    ^\n\nRanges are actually syntactic sugar for std::ops::Range[From|To].", "tree": {"sha": "c4968ed914f23bd613ebb1ef644f71cf571d924b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4968ed914f23bd613ebb1ef644f71cf571d924b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ce41608ae0f55e6910756054cddf08aa3678ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ce41608ae0f55e6910756054cddf08aa3678ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ce41608ae0f55e6910756054cddf08aa3678ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ce41608ae0f55e6910756054cddf08aa3678ff/comments", "author": null, "committer": null, "parents": [{"sha": "314b62ec787abdf320fcca8ceb09b8c9bcf72512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314b62ec787abdf320fcca8ceb09b8c9bcf72512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314b62ec787abdf320fcca8ceb09b8c9bcf72512"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "7b128fff1572b83ab134bdeb0a4dcc5e6e3fd06e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ce41608ae0f55e6910756054cddf08aa3678ff/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ce41608ae0f55e6910756054cddf08aa3678ff/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=f2ce41608ae0f55e6910756054cddf08aa3678ff", "patch": "@@ -12348,6 +12348,18 @@ Parser<ManagedTokenSource>::parse_expr (int right_binding_power,\n \t\t\t\t\tParseRestrictions restrictions)\n {\n   const_TokenPtr current_token = lexer.peek_token ();\n+  // Special hack because we are allowed to return nullptr, in that case we\n+  // don't want to skip the token, since we don't actually parse it. But if\n+  // null isn't allowed it indicates an error, and we want to skip past that.\n+  // So return early if it is one of the tokens that ends an expression\n+  // (or at least cannot start a new expression).\n+  if (restrictions.expr_can_be_null)\n+    {\n+      TokenId id = current_token->get_id ();\n+      if (id == SEMICOLON || id == RIGHT_PAREN || id == RIGHT_CURLY\n+\t  || id == RIGHT_SQUARE)\n+\treturn nullptr;\n+    }\n   lexer.skip_token ();\n \n   // parse null denotation (unary part of expression)\n@@ -14028,6 +14040,9 @@ Parser<ManagedTokenSource>::parse_led_range_exclusive_expr (\n {\n   // FIXME: this probably parses expressions accidently or whatever\n   // try parsing RHS (as tok has already been consumed in parse_expression)\n+  // Can be nullptr, in which case it is a RangeFromExpr, otherwise a\n+  // RangeFromToExpr.\n+  restrictions.expr_can_be_null = true;\n   std::unique_ptr<AST::Expr> right\n     = parse_expr (LBP_DOT_DOT, AST::AttrVec (), restrictions);\n "}]}