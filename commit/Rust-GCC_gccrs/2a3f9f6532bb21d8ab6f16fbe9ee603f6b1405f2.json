{"sha": "2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzZjlmNjUzMmJiMjFkOGFiNmYxNmZiZTllZTYwM2Y2YjE0MDVmMg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-29T20:16:52Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-09-17T19:04:30Z"}, "message": "openacc: Shared memory layout optimisation\n\nThis patch implements an algorithm to lay out local data-share (LDS)\nspace.  It currently works for AMD GCN.  At the moment, LDS is used for\nthree things:\n\n  1. Gang-private variables\n  2. Reduction temporaries (accumulators)\n  3. Broadcasting for worker partitioning\n\nAfter the patch is applied, (2) and (3) are placed at preallocated\nlocations in LDS, and (1) continues to be handled by the backend (as it\nis at present prior to this patch being applied). LDS now looks like this:\n\n  +--------------+ (gang-private size + 1024, = 1536)\n  | free space   |\n  |    ...       |\n  | - - - - - - -|\n  | worker bcast |\n  +--------------+\n  | reductions   |\n  +--------------+ <<< -mgang-private-size=<number> (def. 512)\n  | gang-private |\n  |    vars      |\n  +--------------+ (32)\n  | low LDS vars |\n  +--------------+ LDS base\n\nSo, gang-private space is fixed at a constant amount at compile time\n(which can be increased with a command-line switch if necessary\nfor some given code). The layout algorithm takes out a slice of the\nremainder of usable space for reduction vars, and uses the rest for\nworker partitioning.\n\nThe partitioning algorithm works as follows.\n\n 1. An \"adjacency\" set is built up for each basic block that might\n    do a broadcast. This is calculated by starting at each such block,\n    and doing a recursive DFS walk over successors to find the next\n    block (or blocks) that *also* does a broadcast\n    (dfs_broadcast_reachable_1).\n\n 2. The adjacency set is inverted to get adjacent predecessor blocks also.\n\n 3. Blocks that will perform a broadcast are sorted by size of that\n    broadcast: the biggest blocks are handled first.\n\n 4. A splay tree structure is used to calculate the spans of LDS memory\n    that are already allocated by the blocks adjacent to this one\n    (merge_ranges{,_1}.\n\n 5. The current block's broadcast space is allocated from the first free\n    span not allocated in the splay tree structure calculated above\n    (first_fit_range). This seems to work quite nicely and efficiently\n    with the splay tree structure.\n\n 6. Continue with the next-biggest broadcast block until we're done.\n\nIn this way, \"adjacent\" broadcasts will not use the same piece of\nLDS memory.\n\nPR96334 \"openacc: Unshare reduction temporaries for GCN\" got merged in:\n\nThe GCN backend uses tree nodes like MEM((__lds TYPE *) <constant>)\nfor reduction temporaries. Unlike e.g. var decls and SSA names, these\nnodes cannot be shared during gimplification, but are so in some\ncircumstances. This is detected when appropriate --enable-checking\noptions are used. This patch unshares such nodes when they are reused\nmore than once.\n\ngcc/\n\t* config/gcn/gcn-protos.h\n\t(gcn_goacc_create_worker_broadcast_record): Update prototype.\n\t* config/gcn/gcn-tree.c (gcn_goacc_get_worker_red_decl): Use\n\tpreallocated block of LDS memory.  Do not cache/share decls for\n\treduction temporaries between invocations.\n\t(gcn_goacc_reduction_teardown): Unshare VAR on second use.\n\t(gcn_goacc_create_worker_broadcast_record): Add OFFSET parameter\n\tand return temporary LDS space at that offset.  Return pointer in\n\t\"sender\" case.\n\t* config/gcn/gcn.c (acc_lds_size, gang_private_hwm, lds_allocs):\n\tNew global vars.\n\t(ACC_LDS_SIZE): Define as acc_lds_size.\n\t(gcn_init_machine_status): Don't initialise lds_allocated,\n\tlds_allocs, reduc_decls fields of machine function struct.\n\t(gcn_option_override): Handle default size for gang-private\n\tvariables and -mgang-private-size option.\n\t(gcn_expand_prologue): Use LDS_SIZE instead of LDS_SIZE-1 when\n\tinitialising M0_REG.\n\t(gcn_shared_mem_layout): New function.\n\t(gcn_print_lds_decl): Update comment. Use global lds_allocs map and\n\tgang_private_hwm variable.\n\t(TARGET_GOACC_SHARED_MEM_LAYOUT): Define target hook.\n\t* config/gcn/gcn.h (machine_function): Remove lds_allocated,\n\tlds_allocs, reduc_decls. Add reduction_base, reduction_limit.\n\t* config/gcn/gcn.opt (gang_private_size_opt): New global.\n\t(mgang-private-size=): New option.\n\t* doc/tm.texi.in (TARGET_GOACC_SHARED_MEM_LAYOUT): Place\n\tdocumentation hook.\n\t* doc/tm.texi: Regenerate.\n\t* omp-oacc-neuter-broadcast.cc (targhooks.h, diagnostic-core.h):\n\tAdd includes.\n\t(build_sender_ref): Handle sender_decl being pointer.\n\t(worker_single_copy): Add PLACEMENT and ISOLATE_BROADCASTS\n\tparameters.  Pass placement argument to\n\tcreate_worker_broadcast_record hook invocations.  Handle\n\tsender_decl being pointer and isolate_broadcasts inserting extra\n\tbarriers.\n\t(blk_offset_map_t): Add typedef.\n\t(neuter_worker_single): Add BLK_OFFSET_MAP parameter.  Pass\n\tpreallocated range to worker_single_copy call.\n\t(dfs_broadcast_reachable_1): New function.\n\t(idx_decl_pair_t, used_range_vec_t): New typedefs.\n\t(sort_size_descending): New function.\n\t(addr_range): New class.\n\t(splay_tree_compare_addr_range, splay_tree_free_key)\n\t(first_fit_range, merge_ranges_1, merge_ranges): New functions.\n\t(execute_omp_oacc_neuter_broadcast): Rename to...\n\t(oacc_do_neutering): ... this.  Add BOUNDS_LO, BOUNDS_HI\n\tparameters.  Arrange layout of shared memory for broadcast\n\toperations.\n\t(execute_omp_oacc_neuter_broadcast): New function.\n\t(pass_omp_oacc_neuter_broadcast::gate): Remove num_workers==1\n\thandling from here.  Enable pass for all OpenACC routines in order\n\tto call shared memory-layout hook.\n\t* target.def (create_worker_broadcast_record): Add OFFSET\n\tparameter.\n\t(shared_mem_layout): New hook.\nlibgomp/\n\t* testsuite/libgomp.oacc-c-c++-common/broadcast-many.c: Update.", "tree": {"sha": "c379c6735b785ada2f503df3f50cfae67f33af48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c379c6735b785ada2f503df3f50cfae67f33af48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82792cc407d7a7ab99f37e8501d19be2e6164e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82792cc407d7a7ab99f37e8501d19be2e6164e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82792cc407d7a7ab99f37e8501d19be2e6164e50"}], "stats": {"total": 627, "additions": 538, "deletions": 89}, "files": [{"sha": "2d385e0f10438d20c0e8fd36aadc1dd0c8fa27f7", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -41,7 +41,8 @@ extern bool gcn_global_address_p (rtx);\n extern tree gcn_goacc_adjust_private_decl (location_t, tree var, int level);\n extern tree gcn_goacc_create_worker_broadcast_record (tree record_type,\n \t\t\t\t\t\t      bool sender,\n-\t\t\t\t\t\t      const char *name);\n+\t\t\t\t\t\t      const char *name,\n+\t\t\t\t\t\t      unsigned HOST_WIDE_INT offset);\n extern void gcn_goacc_reduction (gcall *call);\n extern bool gcn_hard_regno_rename_ok (unsigned int from_reg,\n \t\t\t\t      unsigned int to_reg);"}, {"sha": "d8b913b88cf7eda0ad61108821dd8322a459a16e", "filename": "gcc/config/gcn/gcn-tree.c", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -309,7 +309,6 @@ static tree\n gcn_goacc_get_worker_red_decl (tree type, unsigned offset)\n {\n   machine_function *machfun = cfun->machine;\n-  tree existing_decl;\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n@@ -319,31 +318,12 @@ gcn_goacc_get_worker_red_decl (tree type, unsigned offset)\n \t\t\t    (TYPE_QUALS (type)\n \t\t\t     | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_LDS)));\n \n-  if (machfun->reduc_decls\n-      && offset < machfun->reduc_decls->length ()\n-      && (existing_decl = (*machfun->reduc_decls)[offset]))\n-    {\n-      gcc_assert (TREE_TYPE (existing_decl) == var_type);\n-      return existing_decl;\n-    }\n-  else\n-    {\n-      char name[50];\n-      sprintf (name, \".oacc_reduction_%u\", offset);\n-      tree decl = create_tmp_var_raw (var_type, name);\n-\n-      DECL_CONTEXT (decl) = NULL_TREE;\n-      TREE_STATIC (decl) = 1;\n-\n-      varpool_node::finalize_decl (decl);\n-\n-      vec_safe_grow_cleared (machfun->reduc_decls, offset + 1, true);\n-      (*machfun->reduc_decls)[offset] = decl;\n+  gcc_assert (offset\n+\t      < (machfun->reduction_limit - machfun->reduction_base));\n+  tree ptr_type = build_pointer_type (var_type);\n+  tree addr = build_int_cst (ptr_type, machfun->reduction_base + offset);\n \n-      return decl;\n-    }\n-\n-  return NULL_TREE;\n+  return build_simple_mem_ref (addr);\n }\n \n /* Expand IFN_GOACC_REDUCTION_SETUP.  */\n@@ -500,7 +480,7 @@ gcn_goacc_reduction_teardown (gcall *call)\n     }\n \n   if (lhs)\n-    gimplify_assign (lhs, var, &seq);\n+    gimplify_assign (lhs, unshare_expr (var), &seq);\n \n   pop_gimplify_context (NULL);\n \n@@ -581,27 +561,24 @@ gcn_goacc_adjust_private_decl (location_t, tree var, int level)\n \n tree\n gcn_goacc_create_worker_broadcast_record (tree record_type, bool sender,\n-\t\t\t\t\t  const char *name)\n+\t\t\t\t\t  const char *name,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT offset)\n {\n-  tree type = record_type;\n-\n-  TYPE_ADDR_SPACE (type) = ADDR_SPACE_LDS;\n+  tree type = build_qualified_type (record_type,\n+\t\t\t\t    TYPE_QUALS_NO_ADDR_SPACE (record_type)\n+\t\t\t\t    | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_LDS));\n \n   if (!sender)\n-    type = build_pointer_type (type);\n-\n-  tree decl = create_tmp_var_raw (type, name);\n-\n-  if (sender)\n     {\n-      DECL_CONTEXT (decl) = NULL_TREE;\n-      TREE_STATIC (decl) = 1;\n+      tree ptr_type = build_pointer_type (type);\n+      return create_tmp_var_raw (ptr_type, name);\n     }\n \n-  if (sender)\n-    varpool_node::finalize_decl (decl);\n+  if (record_type == char_type_node)\n+    offset = 1;\n \n-  return decl;\n+  tree ptr_type = build_pointer_type (type);\n+  return build_int_cst (ptr_type, offset);\n }\n \n /* }}}  */"}, {"sha": "b1bfdeac7b64082cb3930fa0c7f6f23534ba3f93", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 65, "deletions": 22, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -73,14 +73,21 @@ int gcn_isa = 3;\t\t/* Default to GCN3.  */\n  \n    We want to permit full occupancy, so size accordingly.  */\n \n+/* Use this as a default, but allow it to grow if the user requests a large\n+   amount of gang-private shared-memory space.  */\n+static int acc_lds_size = 0x600;\n+\n #define OMP_LDS_SIZE 0x600    /* 0x600 is 1/40 total, rounded down.  */\n-#define ACC_LDS_SIZE 32768    /* Half of the total should be fine.  */\n+#define ACC_LDS_SIZE acc_lds_size\n #define OTHER_LDS_SIZE 65536  /* If in doubt, reserve all of it.  */\n \n #define LDS_SIZE (flag_openacc ? ACC_LDS_SIZE \\\n \t\t  : flag_openmp ? OMP_LDS_SIZE \\\n \t\t  : OTHER_LDS_SIZE)\n \n+static int gang_private_hwm = 32;\n+static hash_map<tree, int> lds_allocs;\n+\n /* The number of registers usable by normal non-kernel functions.\n    The SGPR count includes any special extra registers such as VCC.  */\n \n@@ -99,13 +106,6 @@ gcn_init_machine_status (void)\n \n   f = ggc_cleared_alloc<machine_function> ();\n \n-  /* Set up LDS allocation for broadcasting for this function.  */\n-  f->lds_allocated = 32;\n-  f->lds_allocs = hash_map<tree, int>::create_ggc (64);\n-\n-  /* And LDS temporary decls for worker reductions.  */\n-  vec_alloc (f->reduc_decls, 0);\n-\n   if (TARGET_GCN3)\n     f->use_flat_addressing = true;\n \n@@ -145,6 +145,24 @@ gcn_option_override (void)\n \tstack_size_opt = 1048576;\n     }\n \n+  /* Reserve 1Kb (somewhat arbitrarily) of LDS space for reduction results and\n+     worker broadcasts.  */\n+  if (gang_private_size_opt == -1)\n+    gang_private_size_opt = 512;\n+  else if (gang_private_size_opt < gang_private_hwm)\n+    gang_private_size_opt = gang_private_hwm;\n+  else if (gang_private_size_opt >= acc_lds_size - 1024)\n+    {\n+      /* We need some space for reductions and worker broadcasting.  If the\n+\t user requests a large amount of gang-private LDS space, we might not\n+\t have enough left for the former.  Increase the LDS allocation in that\n+\t case, although this may reduce the maximum occupancy on the\n+\t hardware.  */\n+      acc_lds_size = gang_private_size_opt + 1024;\n+      if (acc_lds_size > 32768)\n+\tacc_lds_size = 32768;\n+    }\n+\n   /* The xnack option is a placeholder, for now.  */\n   if (flag_xnack)\n     sorry (\"XNACK support\");\n@@ -3066,7 +3084,7 @@ gcn_expand_prologue ()\n      The low-part is the address of the topmost addressable byte, which is\n      size-1.  The high-part is an offset and should be zero.  */\n   emit_move_insn (gen_rtx_REG (SImode, M0_REG),\n-\t\t  gen_int_mode (LDS_SIZE-1, SImode));\n+\t\t  gen_int_mode (LDS_SIZE, SImode));\n \n   emit_insn (gen_prologue_use (gen_rtx_REG (SImode, M0_REG)));\n \n@@ -5161,6 +5179,28 @@ gcn_fixup_accel_lto_options (tree fndecl)\n     }\n }\n \n+/* Implement TARGET_GOACC_SHARED_MEM_LAYOUT hook.  */\n+\n+static void\n+gcn_shared_mem_layout (unsigned HOST_WIDE_INT *lo,\n+\t\t       unsigned HOST_WIDE_INT *hi,\n+\t\t       int ARG_UNUSED (dims[GOMP_DIM_MAX]),\n+\t\t       unsigned HOST_WIDE_INT\n+\t\t\t ARG_UNUSED (private_size[GOMP_DIM_MAX]),\n+\t\t       unsigned HOST_WIDE_INT reduction_size[GOMP_DIM_MAX])\n+{\n+  *lo = gang_private_size_opt + reduction_size[GOMP_DIM_WORKER];\n+  /* !!! We can maybe use dims[] to estimate the maximum number of work\n+     groups/wavefronts/etc. we will launch, and therefore tune the maximum\n+     amount of LDS we should use.  For now, use a minimal amount to try to\n+     maximise occupancy.  */\n+  *hi = acc_lds_size;\n+  machine_function *machfun = cfun->machine;\n+  machfun->reduction_base = gang_private_size_opt;\n+  machfun->reduction_limit\n+    = gang_private_size_opt + reduction_size[GOMP_DIM_WORKER];\n+}\n+\n /* }}}  */\n /* {{{ ASM Output.  */\n \n@@ -5488,17 +5528,18 @@ gcn_section_type_flags (tree decl, const char *name, int reloc)\n \n /* Helper function for gcn_asm_output_symbol_ref.\n \n-   FIXME: If we want to have propagation blocks allocated separately and\n-   statically like this, it would be better done via symbol refs and the\n-   assembler/linker.  This is a temporary hack.  */\n+   FIXME: This function is used to lay out gang-private variables in LDS\n+   on a per-CU basis.\n+   There may be cases in which gang-private variables in different compilation\n+   units could clobber each other.  In that case we should be relying on the\n+   linker to lay out gang-private LDS space, but that doesn't appear to be\n+   possible at present.  */\n \n static void\n gcn_print_lds_decl (FILE *f, tree var)\n {\n   int *offset;\n-  machine_function *machfun = cfun->machine;\n-\n-  if ((offset = machfun->lds_allocs->get (var)))\n+  if ((offset = lds_allocs.get (var)))\n     fprintf (f, \"%u\", (unsigned) *offset);\n   else\n     {\n@@ -5508,14 +5549,14 @@ gcn_print_lds_decl (FILE *f, tree var)\n       if (size > align && size > 4 && align < 8)\n \talign = 8;\n \n-      machfun->lds_allocated = ((machfun->lds_allocated + align - 1)\n-\t\t\t\t& ~(align - 1));\n+      gang_private_hwm = ((gang_private_hwm + align - 1) & ~(align - 1));\n \n-      machfun->lds_allocs->put (var, machfun->lds_allocated);\n-      fprintf (f, \"%u\", machfun->lds_allocated);\n-      machfun->lds_allocated += size;\n-      if (machfun->lds_allocated > LDS_SIZE)\n-\terror (\"local data-share memory exhausted\");\n+      lds_allocs.put (var, gang_private_hwm);\n+      fprintf (f, \"%u\", gang_private_hwm);\n+      gang_private_hwm += size;\n+      if (gang_private_hwm > gang_private_size_opt)\n+\terror (\"gang-private data-share memory exhausted (increase with \"\n+\t       \"%<-mgang-private-size=<number>%>)\");\n     }\n }\n \n@@ -6515,6 +6556,8 @@ gcn_dwarf_register_span (rtx rtl)\n #define TARGET_GOACC_REDUCTION gcn_goacc_reduction\n #undef  TARGET_GOACC_VALIDATE_DIMS\n #define TARGET_GOACC_VALIDATE_DIMS gcn_goacc_validate_dims\n+#undef  TARGET_GOACC_SHARED_MEM_LAYOUT\n+#define TARGET_GOACC_SHARED_MEM_LAYOUT gcn_shared_mem_layout\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK gcn_hard_regno_mode_ok\n #undef  TARGET_HARD_REGNO_NREGS"}, {"sha": "b97ec482d852a3a931c9b233dd08368be0d9225b", "filename": "gcc/config/gcn/gcn.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.h?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -576,10 +576,8 @@ struct GTY(()) machine_function\n   HOST_WIDE_INT local_vars;\n   HOST_WIDE_INT callee_saves;\n \n-  unsigned lds_allocated;\n-  hash_map<tree, int> *lds_allocs;\n-\n-  vec<tree, va_gc> *reduc_decls;\n+  unsigned HOST_WIDE_INT reduction_base;\n+  unsigned HOST_WIDE_INT reduction_limit;\n \n   bool use_flat_addressing;\n };"}, {"sha": "09cf191db016fd7e599fa77f69a5bb4cc051d3fe", "filename": "gcc/config/gcn/gcn.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.opt?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -68,6 +68,12 @@ mstack-size=\n Target RejectNegative Joined UInteger Var(stack_size_opt) Init(-1)\n -mstack-size=<number>\tSet the private segment size per wave-front, in bytes.\n \n+int gang_private_size_opt = -1\n+\n+mgang-private-size=\n+Target RejectNegative Joined UInteger Var(gang_private_size_opt) Init(-1)\n+Amount of local data-share (LDS) memory to reserve for gang-private variables.\n+\n Wopenacc-dims\n Target Var(warn_openacc_dims) Warning\n Warn about invalid OpenACC dimensions."}, {"sha": "902402d75032fdce2cfeaa23a0c82da98d2d47b3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -6415,7 +6415,7 @@ private variables at OpenACC device-lowering time using the\n @code{TARGET_GOACC_ADJUST_PRIVATE_DECL} target hook.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD (tree @var{rec}, bool @var{sender}, const char *@var{name})\n+@deftypefn {Target Hook} tree TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD (tree @var{rec}, bool @var{sender}, const char *@var{name}, unsigned HOST_WIDE_INT @var{offset})\n Create a record used to propagate local-variable state from an active\n worker to other workers.  A possible implementation might adjust the type\n of REC to place the new variable in shared GPU memory.\n@@ -6424,6 +6424,13 @@ Presence of this target hook indicates that middle end neutering/broadcasting\n be used.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_GOACC_SHARED_MEM_LAYOUT (unsigned HOST_WIDE_INT *@var{}, unsigned HOST_WIDE_INT *@var{}, @var{int[]}, unsigned @var{HOST_WIDE_INT[]}, unsigned @var{HOST_WIDE_INT[]})\n+Lay out a fixed shared-memory region on the target.  The LO and HI\n+arguments should be set to a range of addresses that can be used for worker\n+broadcasting. The dimensions, reduction size and gang-private size\n+arguments are for the current offload region.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "86352dc9bd2146587a95b7561151b3f84db8021f", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -4228,6 +4228,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD\n \n+@hook TARGET_GOACC_SHARED_MEM_LAYOUT\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "e0bd01311ee1245509edc6142241e509029d3162", "filename": "gcc/omp-oacc-neuter-broadcast.cc", "status": "modified", "additions": 421, "deletions": 20, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fomp-oacc-neuter-broadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Fomp-oacc-neuter-broadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-neuter-broadcast.cc?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -53,6 +53,8 @@\n #include \"tree-cfg.h\"\n #include \"omp-offload.h\"\n #include \"attribs.h\"\n+#include \"targhooks.h\"\n+#include \"diagnostic-core.h\"\n \n /* Loop structure of the function.  The entire function is described as\n    a NULL loop.  */\n@@ -968,6 +970,8 @@ build_receiver_ref (tree var, tree receiver_decl, field_map_t *fields)\n static tree\n build_sender_ref (tree var, tree sender_decl, field_map_t *fields)\n {\n+  if (POINTER_TYPE_P (TREE_TYPE (sender_decl)))\n+    sender_decl = build_simple_mem_ref (sender_decl);\n   tree field = *fields->get (var);\n   return oacc_build_component_ref (sender_decl, field);\n }\n@@ -1005,7 +1009,9 @@ static void\n worker_single_copy (basic_block from, basic_block to,\n \t\t    hash_set<tree> *def_escapes_block,\n \t\t    hash_set<tree> *worker_partitioned_uses,\n-\t\t    tree record_type, record_field_map_t *record_field_map)\n+\t\t    tree record_type, record_field_map_t *record_field_map,\n+\t\t    unsigned HOST_WIDE_INT placement,\n+\t\t    bool isolate_broadcasts)\n {\n   /* If we only have virtual defs, we'll have no record type, but we still want\n      to emit single_copy_start and (particularly) single_copy_end to act as\n@@ -1016,10 +1022,12 @@ worker_single_copy (basic_block from, basic_block to,\n \n   tree sender_decl\n     = targetm.goacc.create_worker_broadcast_record (record_type, true,\n-\t\t\t\t\t\t    \".oacc_worker_o\");\n+\t\t\t\t\t\t    \".oacc_worker_o\",\n+\t\t\t\t\t\t    placement);\n   tree receiver_decl\n     = targetm.goacc.create_worker_broadcast_record (record_type, false,\n-\t\t\t\t\t\t    \".oacc_worker_i\");\n+\t\t\t\t\t\t    \".oacc_worker_i\",\n+\t\t\t\t\t\t    placement);\n \n   gimple_stmt_iterator gsi = gsi_last_bb (to);\n   if (EDGE_COUNT (to->succs) > 1)\n@@ -1033,12 +1041,23 @@ worker_single_copy (basic_block from, basic_block to,\n \n   tree lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)));\n \n-  gimple *call = gimple_build_call (decl, 1,\n-\t\t\t\t    build_fold_addr_expr (sender_decl));\n+  gimple *call\n+    = gimple_build_call (decl, 1,\n+\t\t\t POINTER_TYPE_P (TREE_TYPE (sender_decl))\n+\t\t\t ? sender_decl : build_fold_addr_expr (sender_decl));\n   gimple_call_set_lhs (call, lhs);\n   gsi_insert_before (&start, call, GSI_NEW_STMT);\n   update_stmt (call);\n \n+  /* The shared-memory range for this block overflowed.  Add a barrier before\n+     the GOACC_single_copy_start call.  */\n+  if (isolate_broadcasts)\n+    {\n+      decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+      gimple *acc_bar = gimple_build_call (decl, 0);\n+      gsi_insert_before (&start, acc_bar, GSI_SAME_STMT);\n+    }\n+\n   tree conv_tmp = make_ssa_name (TREE_TYPE (receiver_decl));\n \n   gimple *conv = gimple_build_assign (conv_tmp,\n@@ -1206,13 +1225,26 @@ worker_single_copy (basic_block from, basic_block to,\n \t}\n     }\n \n+  /* The shared-memory range for this block overflowed.  Add a barrier at the\n+     end.  */\n+  if (isolate_broadcasts)\n+    {\n+      gsi = gsi_start_bb (exit_block);\n+      decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+      gimple *acc_bar = gimple_build_call (decl, 0);\n+      gsi_insert_before (&gsi, acc_bar, GSI_SAME_STMT);\n+    }\n+\n   /* It's possible for the ET->DEST block (the work done by the active thread)\n      to finish with a control-flow insn, e.g. a UNIQUE function call.  Split\n      the block and add SENDER_SEQ in the latter part to avoid having control\n      flow in the middle of a BB.  */\n \n   decl = builtin_decl_explicit (BUILT_IN_GOACC_SINGLE_COPY_END);\n-  call = gimple_build_call (decl, 1, build_fold_addr_expr (sender_decl));\n+  call = gimple_build_call (decl, 1,\n+\t\t\t    POINTER_TYPE_P (TREE_TYPE (sender_decl))\n+\t\t\t    ? sender_decl\n+\t\t\t    : build_fold_addr_expr (sender_decl));\n   gimple_seq_add_stmt (&sender_seq, call);\n \n   gsi = gsi_last_bb (body);\n@@ -1222,12 +1254,16 @@ worker_single_copy (basic_block from, basic_block to,\n   gsi_insert_seq_after (&gsi, sender_seq, GSI_CONTINUE_LINKING);\n }\n \n+typedef hash_map<basic_block, std::pair<unsigned HOST_WIDE_INT, bool> >\n+  blk_offset_map_t;\n+\n static void\n neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \t\t      bitmap worker_single, bitmap vector_single,\n \t\t      vec<propagation_set *> *prop_set,\n \t\t      hash_set<tree> *partitioned_var_uses,\n-\t\t      record_field_map_t *record_field_map)\n+\t\t      record_field_map_t *record_field_map,\n+\t\t      blk_offset_map_t *blk_offset_map)\n {\n   unsigned mask = outer_mask | par->mask;\n \n@@ -1316,9 +1352,19 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \t  tree record_type = (tree) block->aux;\n \n \t  if (has_defs)\n-\t    worker_single_copy (block, block, &def_escapes_block,\n-\t\t\t\t&worker_partitioned_uses, record_type,\n-\t\t\t\trecord_field_map);\n+\t    {\n+\t      std::pair<unsigned HOST_WIDE_INT, bool> *off_rngalloc\n+\t\t= blk_offset_map->get (block);\n+\t      gcc_assert (!record_type || off_rngalloc);\n+\t      unsigned HOST_WIDE_INT offset\n+\t\t= off_rngalloc ? off_rngalloc->first : 0;\n+\t      bool range_allocated\n+\t\t= off_rngalloc ? off_rngalloc->second : true;\n+\t      worker_single_copy (block, block, &def_escapes_block,\n+\t\t\t\t  &worker_partitioned_uses, record_type,\n+\t\t\t\t  record_field_map,\n+\t\t\t\t  offset, !range_allocated);\n+\t    }\n \t  else\n \t    worker_single_simple (block, block, &def_escapes_block);\n \t}\n@@ -1354,14 +1400,159 @@ neuter_worker_single (parallel_g *par, unsigned outer_mask,\n \n   if (par->inner)\n     neuter_worker_single (par->inner, mask, worker_single, vector_single,\n-\t\t\t  prop_set, partitioned_var_uses, record_field_map);\n+\t\t\t  prop_set, partitioned_var_uses, record_field_map,\n+\t\t\t  blk_offset_map);\n   if (par->next)\n     neuter_worker_single (par->next, outer_mask, worker_single, vector_single,\n-\t\t\t  prop_set, partitioned_var_uses, record_field_map);\n+\t\t\t  prop_set, partitioned_var_uses, record_field_map,\n+\t\t\t  blk_offset_map);\n+}\n+\n+static void\n+dfs_broadcast_reachable_1 (basic_block bb, sbitmap reachable)\n+{\n+  if (bb->flags & BB_VISITED)\n+    return;\n+\n+  bb->flags |= BB_VISITED;\n+\n+  if (bb->succs)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  basic_block dest = e->dest;\n+\t  if (dest->aux)\n+\t    bitmap_set_bit (reachable, dest->index);\n+\t  else\n+\t    dfs_broadcast_reachable_1 (dest, reachable);\n+\t}\n+    }\n }\n \n+typedef std::pair<int, tree> idx_decl_pair_t;\n+\n+typedef auto_vec<splay_tree> used_range_vec_t;\n+\n static int\n-execute_omp_oacc_neuter_broadcast ()\n+sort_size_descending (const void *a, const void *b)\n+{\n+  const idx_decl_pair_t *pa = (const idx_decl_pair_t *) a;\n+  const idx_decl_pair_t *pb = (const idx_decl_pair_t *) b;\n+  unsigned HOST_WIDE_INT asize = tree_to_uhwi (TYPE_SIZE_UNIT (pa->second));\n+  unsigned HOST_WIDE_INT bsize = tree_to_uhwi (TYPE_SIZE_UNIT (pb->second));\n+  return bsize - asize;\n+}\n+\n+class addr_range\n+{\n+public:\n+  addr_range (unsigned HOST_WIDE_INT addr_lo, unsigned HOST_WIDE_INT addr_hi)\n+    : lo (addr_lo), hi (addr_hi)\n+    { }\n+  addr_range (const addr_range &ar) : lo (ar.lo), hi (ar.hi)\n+    { }\n+  addr_range () : lo (0), hi (0)\n+    { }\n+\n+  bool invalid () { return lo == 0 && hi == 0; }\n+\n+  unsigned HOST_WIDE_INT lo;\n+  unsigned HOST_WIDE_INT hi;\n+};\n+\n+static int\n+splay_tree_compare_addr_range (splay_tree_key a, splay_tree_key b)\n+{\n+  addr_range *ar = (addr_range *) a;\n+  addr_range *br = (addr_range *) b;\n+  if (ar->lo == br->lo && ar->hi == br->hi)\n+    return 0;\n+  if (ar->hi <= br->lo)\n+    return -1;\n+  else if (ar->lo >= br->hi)\n+    return 1;\n+  return 0;\n+}\n+\n+static void\n+splay_tree_free_key (splay_tree_key k)\n+{\n+  addr_range *ar = (addr_range *) k;\n+  delete ar;\n+}\n+\n+static addr_range\n+first_fit_range (splay_tree s, unsigned HOST_WIDE_INT size,\n+\t\t unsigned HOST_WIDE_INT align, addr_range *bounds)\n+{\n+  splay_tree_node min = splay_tree_min (s);\n+  if (min)\n+    {\n+      splay_tree_node next;\n+      while ((next = splay_tree_successor (s, min->key)))\n+\t{\n+\t  unsigned HOST_WIDE_INT lo = ((addr_range *) min->key)->hi;\n+\t  unsigned HOST_WIDE_INT hi = ((addr_range *) next->key)->lo;\n+\t  unsigned HOST_WIDE_INT base = (lo + align - 1) & ~(align - 1);\n+\t  if (base + size <= hi)\n+\t    return addr_range (base, base + size);\n+\t  min = next;\n+\t}\n+\n+      unsigned HOST_WIDE_INT base = ((addr_range *)min->key)->hi;\n+      base = (base + align - 1) & ~(align - 1);\n+      if (base + size <= bounds->hi)\n+\treturn addr_range (base, base + size);\n+      else\n+\treturn addr_range ();\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT lo = bounds->lo;\n+      lo = (lo + align - 1) & ~(align - 1);\n+      if (lo + size <= bounds->hi)\n+\treturn addr_range (lo, lo + size);\n+      else\n+\treturn addr_range ();\n+    }\n+}\n+\n+static int\n+merge_ranges_1 (splay_tree_node n, void *ptr)\n+{\n+  splay_tree accum = (splay_tree) ptr;\n+  addr_range ar = *(addr_range *) n->key;\n+\n+  splay_tree_node old = splay_tree_lookup (accum, n->key);\n+\n+  /* We might have an overlap.  Create a new range covering the\n+     overlapping parts.  */\n+  if (old)\n+    {\n+      addr_range *old_ar = (addr_range *) old->key;\n+      ar.lo = MIN (old_ar->lo, ar.lo);\n+      ar.hi = MAX (old_ar->hi, ar.hi);\n+      splay_tree_remove (accum, old->key);\n+    }\n+\n+  addr_range *new_ar = new addr_range (ar);\n+\n+  splay_tree_insert (accum, (splay_tree_key) new_ar, n->value);\n+\n+  return 0;\n+}\n+\n+static void\n+merge_ranges (splay_tree accum, splay_tree sp)\n+{\n+  splay_tree_foreach (sp, merge_ranges_1, (void *) accum);\n+}\n+\n+static void\n+oacc_do_neutering (unsigned HOST_WIDE_INT bounds_lo,\n+\t\t   unsigned HOST_WIDE_INT bounds_hi)\n {\n   bb_stmt_map_t bb_stmt_map;\n   auto_bitmap worker_single, vector_single;\n@@ -1450,8 +1641,123 @@ execute_omp_oacc_neuter_broadcast ()\n \t}\n     }\n \n+  sbitmap *reachable\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    last_basic_block_for_fn (cfun));\n+\n+  bitmap_vector_clear (reachable, last_basic_block_for_fn (cfun));\n+\n+  auto_vec<std::pair<int, tree> > priority;\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      if (bb->aux)\n+\t{\n+\t  tree record_type = (tree) bb->aux;\n+\n+\t  basic_block bb2;\n+\t  FOR_ALL_BB_FN (bb2, cfun)\n+\t    bb2->flags &= ~BB_VISITED;\n+\n+\t  priority.safe_push (std::make_pair (bb->index, record_type));\n+\t  dfs_broadcast_reachable_1 (bb, reachable[bb->index]);\n+\t}\n+    }\n+\n+  sbitmap *inverted\n+    = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t    last_basic_block_for_fn (cfun));\n+\n+  bitmap_vector_clear (inverted, last_basic_block_for_fn (cfun));\n+\n+  for (int i = 0; i < last_basic_block_for_fn (cfun); i++)\n+    {\n+      sbitmap_iterator bi;\n+      unsigned int j;\n+      EXECUTE_IF_SET_IN_BITMAP (reachable[i], 0, j, bi)\n+\tbitmap_set_bit (inverted[j], i);\n+    }\n+\n+  for (int i = 0; i < last_basic_block_for_fn (cfun); i++)\n+    bitmap_ior (reachable[i], reachable[i], inverted[i]);\n+\n+  sbitmap_vector_free (inverted);\n+\n+  used_range_vec_t used_ranges;\n+\n+  used_ranges.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+\n+  blk_offset_map_t blk_offset_map;\n+\n+  addr_range worker_shm_bounds (bounds_lo, bounds_hi);\n+\n+  priority.qsort (sort_size_descending);\n+  for (unsigned int i = 0; i < priority.length (); i++)\n+    {\n+      idx_decl_pair_t p = priority[i];\n+      int blkno = p.first;\n+      tree record_type = p.second;\n+      HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE_UNIT (record_type));\n+      HOST_WIDE_INT align = TYPE_ALIGN_UNIT (record_type);\n+\n+      splay_tree conflicts = splay_tree_new (splay_tree_compare_addr_range,\n+\t\t\t\t\t     splay_tree_free_key, NULL);\n+\n+      if (!used_ranges[blkno])\n+\tused_ranges[blkno] = splay_tree_new (splay_tree_compare_addr_range,\n+\t\t\t\t\t     splay_tree_free_key, NULL);\n+      else\n+\tmerge_ranges (conflicts, used_ranges[blkno]);\n+\n+      sbitmap_iterator bi;\n+      unsigned int j;\n+      EXECUTE_IF_SET_IN_BITMAP (reachable[blkno], 0, j, bi)\n+\tif (used_ranges[j])\n+\t  merge_ranges (conflicts, used_ranges[j]);\n+\n+      addr_range ar\n+\t= first_fit_range (conflicts, size, align, &worker_shm_bounds);\n+\n+      splay_tree_delete (conflicts);\n+\n+      if (ar.invalid ())\n+\t{\n+\t  unsigned HOST_WIDE_INT base;\n+\t  base = bounds_lo + random () % 512;\n+\t  base = (base + align - 1) & ~(align - 1);\n+\t  if (base + size > bounds_hi)\n+\t    error_at (UNKNOWN_LOCATION, \"shared-memory region overflow\");\n+\t  std::pair<unsigned HOST_WIDE_INT, bool> base_inrng\n+\t    = std::make_pair (base, false);\n+\t  blk_offset_map.put (BASIC_BLOCK_FOR_FN (cfun, blkno), base_inrng);\n+\t}\n+      else\n+\t{\n+\t  splay_tree_node old = splay_tree_lookup (used_ranges[blkno],\n+\t\t\t\t\t\t   (splay_tree_key) &ar);\n+\t  if (old)\n+\t    {\n+\t      fprintf (stderr, \"trying to map [%d..%d] but [%d..%d] is \"\n+\t\t       \"already mapped in block %d\\n\", (int) ar.lo,\n+\t\t       (int) ar.hi, (int) ((addr_range *) old->key)->lo,\n+\t\t       (int) ((addr_range *) old->key)->hi, blkno);\n+\t      abort ();\n+\t    }\n+\n+\t  addr_range *arp = new addr_range (ar);\n+\t  splay_tree_insert (used_ranges[blkno], (splay_tree_key) arp,\n+\t\t\t     (splay_tree_value) blkno);\n+\t  std::pair<unsigned HOST_WIDE_INT, bool> base_inrng\n+\t    = std::make_pair (ar.lo, true);\n+\t  blk_offset_map.put (BASIC_BLOCK_FOR_FN (cfun, blkno), base_inrng);\n+\t}\n+    }\n+\n+  sbitmap_vector_free (reachable);\n+\n   neuter_worker_single (par, mask, worker_single, vector_single, &prop_set,\n-\t\t\t&partitioned_var_uses, &record_field_map);\n+\t\t\t&partitioned_var_uses, &record_field_map,\n+\t\t\t&blk_offset_map);\n \n   for (auto it : record_field_map)\n     delete it.second;\n@@ -1478,6 +1784,107 @@ execute_omp_oacc_neuter_broadcast ()\n       fprintf (dump_file, \"\\n\\nAfter neutering:\\n\\n\");\n       dump_function_to_file (current_function_decl, dump_file, dump_flags);\n     }\n+}\n+\n+static int\n+execute_omp_oacc_neuter_broadcast ()\n+{\n+  unsigned HOST_WIDE_INT reduction_size[GOMP_DIM_MAX];\n+  unsigned HOST_WIDE_INT private_size[GOMP_DIM_MAX];\n+\n+  for (unsigned i = 0; i < GOMP_DIM_MAX; i++)\n+    {\n+      reduction_size[i] = 0;\n+      private_size[i] = 0;\n+    }\n+\n+  /* Calculate shared memory size required for reduction variables and\n+     gang-private memory for this offloaded function.  */\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (!is_gimple_call (stmt))\n+\t    continue;\n+\t  gcall *call = as_a <gcall *> (stmt);\n+\t  if (!gimple_call_internal_p (call))\n+\t    continue;\n+\t  enum internal_fn ifn_code = gimple_call_internal_fn (call);\n+\t  switch (ifn_code)\n+\t    {\n+\t    default: break;\n+\t    case IFN_GOACC_REDUCTION:\n+\t      if (integer_minus_onep (gimple_call_arg (call, 3)))\n+\t\tcontinue;\n+\t      else\n+\t\t{\n+\t\t  unsigned code = TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+\t\t  /* Only count reduction variables once: the choice to pick\n+\t\t     the setup call is fairly arbitrary.  */\n+\t\t  if (code == IFN_GOACC_REDUCTION_SETUP)\n+\t\t    {\n+\t\t      int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+\t\t      tree var = gimple_call_arg (call, 2);\n+\t\t      tree offset = gimple_call_arg (call, 5);\n+\t\t      tree var_type = TREE_TYPE (var);\n+\t\t      unsigned HOST_WIDE_INT limit\n+\t\t\t= (tree_to_uhwi (offset)\n+\t\t\t   + tree_to_uhwi (TYPE_SIZE_UNIT (var_type)));\n+\t\t      reduction_size[level]\n+\t\t\t= MAX (reduction_size[level], limit);\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    case IFN_UNIQUE:\n+\t      {\n+\t\tenum ifn_unique_kind kind\n+\t\t  = ((enum ifn_unique_kind)\n+\t\t     TREE_INT_CST_LOW (gimple_call_arg (call, 0)));\n+\n+\t\tif (kind == IFN_UNIQUE_OACC_PRIVATE)\n+\t\t  {\n+\t\t    HOST_WIDE_INT level\n+\t\t      = TREE_INT_CST_LOW (gimple_call_arg (call, 2));\n+\t\t    if (level == -1)\n+\t\t      break;\n+\t\t    for (unsigned i = 3;\n+\t\t\t i < gimple_call_num_args (call);\n+\t\t\t i++)\n+\t\t      {\n+\t\t\ttree arg = gimple_call_arg (call, i);\n+\t\t\tgcc_assert (TREE_CODE (arg) == ADDR_EXPR);\n+\t\t\ttree decl = TREE_OPERAND (arg, 0);\n+\t\t\tunsigned HOST_WIDE_INT align = DECL_ALIGN_UNIT (decl);\n+\t\t\tprivate_size[level] = ((private_size[level] + align - 1)\n+\t\t\t\t\t       & ~(align - 1));\n+\t\t\tunsigned HOST_WIDE_INT decl_size\n+\t\t\t  = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n+\t\t\tprivate_size[level] += decl_size;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  int dims[GOMP_DIM_MAX];\n+  for (unsigned i = 0; i < GOMP_DIM_MAX; i++)\n+    dims[i] = oacc_get_fn_dim_size (current_function_decl, i);\n+\n+  /* Find bounds of shared-memory buffer space we can use.  */\n+  unsigned HOST_WIDE_INT bounds_lo = 0, bounds_hi = 0;\n+  if (targetm.goacc.shared_mem_layout)\n+    targetm.goacc.shared_mem_layout (&bounds_lo, &bounds_hi, dims,\n+\t\t\t\t     private_size, reduction_size);\n+\n+  /* Perform worker partitioning unless we know 'num_workers(1)'.  */\n+  if (dims[GOMP_DIM_WORKER] != 1)\n+    oacc_do_neutering (bounds_lo, bounds_hi);\n \n   return 0;\n }\n@@ -1518,12 +1925,6 @@ class pass_omp_oacc_neuter_broadcast : public gimple_opt_pass\n     if (!attr)\n       return false;\n \n-    /* Not relevant for 'num_workers(1)'.  */\n-    int worker_dim\n-      = oacc_get_fn_dim_size (fun->decl, GOMP_DIM_WORKER);\n-    if (worker_dim == 1)\n-      return false;\n-\n     return true;\n   }\n "}, {"sha": "c5d90cace80d75ef17cd5eddf657db8334f786de", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -1764,7 +1764,17 @@ of REC to place the new variable in shared GPU memory.\\n\\\n \\n\\\n Presence of this target hook indicates that middle end neutering/broadcasting\\n\\\n be used.\",\n-tree, (tree rec, bool sender, const char *name),\n+tree, (tree rec, bool sender, const char *name, unsigned HOST_WIDE_INT offset),\n+NULL)\n+\n+DEFHOOK\n+(shared_mem_layout,\n+\"Lay out a fixed shared-memory region on the target.  The LO and HI\\n\\\n+arguments should be set to a range of addresses that can be used for worker\\n\\\n+broadcasting. The dimensions, reduction size and gang-private size\\n\\\n+arguments are for the current offload region.\",\n+void, (unsigned HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, int[],\n+       unsigned HOST_WIDE_INT[], unsigned HOST_WIDE_INT[]),\n NULL)\n \n HOOK_VECTOR_END (goacc)"}, {"sha": "37839edfb0938fd66a0ef7cf3d8a17ad70cc694c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/broadcast-many.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fbroadcast-many.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fbroadcast-many.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fbroadcast-many.c?ref=2a3f9f6532bb21d8ab6f16fbe9ee603f6b1405f2", "patch": "@@ -1,3 +1,7 @@\n+/* To avoid 'error: shared-memory region overflow':\n+   { dg-additional-options \"-foffload-options=amdgcn-amdhsa=-mgang-private-size=64\" { target openacc_radeon_accel_selected } }\n+*/\n+\n #include <assert.h>\n #include <stdio.h>\n "}]}