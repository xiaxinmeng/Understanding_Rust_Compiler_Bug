{"sha": "ba355842e8ff8cbcb8552b99f6098b333512cc81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzNTU4NDJlOGZmOGNiY2I4NTUyYjk5ZjYwOThiMzMzNTEyY2M4MQ==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2005-09-05T08:05:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:05:32Z"}, "message": "a-cihase.adb, [...]: Synchronized with latest draft (Draft 13, August 2005) of Ada Amendment 1.\n\n2005-09-01  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cihase.adb, a-coorse.ads, a-coorse.adb, a-cohama.adb,\n\ta-ciorse.ads, a-ciorse.adb, a-cihama.adb, a-cdlili.adb,\n\ta-cidlli.adb, a-chtgop.adb, a-cihase.adb, a-cihase.ads,\n\ta-cohase.adb, a-cohase.adb, a-cohase.ads: Synchronized with latest\n\tdraft (Draft 13, August 2005) of Ada Amendment 1.\n\nFrom-SVN: r103892", "tree": {"sha": "7b4be4425a576dfefafcfd6533af08d710bea8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b4be4425a576dfefafcfd6533af08d710bea8f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba355842e8ff8cbcb8552b99f6098b333512cc81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba355842e8ff8cbcb8552b99f6098b333512cc81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba355842e8ff8cbcb8552b99f6098b333512cc81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba355842e8ff8cbcb8552b99f6098b333512cc81/comments", "author": null, "committer": null, "parents": [{"sha": "c1cd0d96753eff81ceba44eaa371931e993e539d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cd0d96753eff81ceba44eaa371931e993e539d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1cd0d96753eff81ceba44eaa371931e993e539d"}], "stats": {"total": 3474, "additions": 1751, "deletions": 1723}, "files": [{"sha": "a0a6f3277f5e23c2e11bfa45cd24511affe01fd0", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 308, "deletions": 419, "changes": 727, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -38,18 +38,19 @@ with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Doubly_Linked_Lists is\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Free (X : in out Node_Access);\n+\n    procedure Insert_Internal\n      (Container : in out List;\n       Before    : Node_Access;\n       New_Node  : Node_Access);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -110,7 +111,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Container.Length := 1;\n \n       Src := Src.Next;\n-\n       while Src /= null loop\n          Container.Last.Next := new Node_Type'(Element => Src.Element,\n                                                Prev    => Container.Last,\n@@ -162,9 +162,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          pragma Assert (X.Next.Prev = Container.First);\n \n          Container.First := X.Next;\n-         X.Next := null;  --  prevent mischief\n-\n          Container.First.Prev := null;\n+\n          Container.Length := Container.Length - 1;\n \n          Free (X);\n@@ -181,7 +180,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Clear;\n \n    --------------\n-   -- Continue --\n+   -- Contains --\n    --------------\n \n    function Contains\n@@ -203,28 +202,16 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Container.Length > 0);\n-      pragma Assert (Container.First.Prev = null);\n-      pragma Assert (Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Container.Last);\n-\n       if Position.Node = Container.First then\n          Delete_First (Container, Count);\n          Position := First (Container);\n@@ -249,7 +236,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             Container.Last := X.Prev;\n             Container.Last.Next := null;\n \n-            X.Prev := null;  --  prevent mischief\n             Free (X);\n             return;\n          end if;\n@@ -259,8 +245,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          X.Next.Prev := X.Prev;\n          X.Prev.Next := X.Next;\n \n-         X.Next := null;\n-         X.Prev := null;\n          Free (X);\n       end loop;\n    end Delete;\n@@ -298,7 +282,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n          Container.Length := Container.Length - 1;\n \n-         X.Next := null;  --  prevent mischief\n          Free (X);\n       end loop;\n    end Delete_First;\n@@ -336,7 +319,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n          Container.Length := Container.Length - 1;\n \n-         X.Prev := null;  --  prevent mischief\n          Free (X);\n       end loop;\n    end Delete_Last;\n@@ -347,20 +329,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n       return Position.Node.Element;\n    end Element;\n@@ -379,23 +352,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.First;\n+\n       else\n-         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n-\n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Position.Node.Prev = null\n-                          or else Position.Node.Prev.Next = Position.Node);\n-         pragma Assert (Position.Node.Next = null\n-                          or else Position.Node.Next.Prev = Position.Node);\n-         pragma Assert (Position.Node.Prev /= null\n-                          or else Position.Node = Container.First);\n-         pragma Assert (Position.Node.Next /= null\n-                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -428,9 +391,27 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function First_Element (Container : List) return Element_Type is\n    begin\n+      if Container.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.First.Element;\n    end First_Element;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      X.Prev := X;\n+      X.Next := X;\n+      Deallocate (X);\n+   end Free;\n+\n    ---------------------\n    -- Generic_Sorting --\n    ---------------------\n@@ -605,26 +586,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ------------\n@@ -641,23 +604,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n+      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n \n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Container.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Container.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Count = 0 then\n@@ -704,23 +656,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n+      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n \n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Container.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Container.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Count = 0 then\n@@ -853,6 +794,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type is\n    begin\n+      if Container.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Last.Element;\n    end Last_Element;\n \n@@ -900,25 +845,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Next (Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in procedure Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       Position.Node := Position.Node.Next;\n \n       if Position.Node = null then\n@@ -928,25 +860,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -977,25 +896,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Previous (Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in procedure Previous\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       Position.Node := Position.Node.Prev;\n \n       if Position.Node = null then\n@@ -1005,25 +911,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    function Previous (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Previous\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -1043,42 +936,34 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      E : Element_Type renames Position.Node.Element;\n-\n-      C : List renames Position.Container.all'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n-\n    begin\n-      B := B + 1;\n-      L := L + 1;\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1141,29 +1026,18 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Position : Cursor;\n       By       : Element_Type)\n    is\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      E : Element_Type renames Position.Node.Element;\n-\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       if Position.Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      E := By;\n+      Position.Node.Element := By;\n    end Replace_Element;\n \n    ------------------\n@@ -1180,23 +1054,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Node = null then\n          Node := Container.Last;\n+\n       else\n-         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n-\n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Position.Node.Prev = null\n-                          or else Position.Node.Prev.Next = Position.Node);\n-         pragma Assert (Position.Node.Next = null\n-                          or else Position.Node.Next.Prev = Position.Node);\n-         pragma Assert (Position.Node.Prev /= null\n-                          or else Position.Node = Container.First);\n-         pragma Assert (Position.Node.Next /= null\n-                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -1336,23 +1200,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Vet (Before), \"bad cursor in Splice\");\n \n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Target'Address = Source'Address\n@@ -1421,46 +1274,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Position : Cursor)\n    is\n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n+      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n-\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unchecked_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Target'Unchecked_Access) then\n+      if Position.Container /= Target'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Target.Length >= 1);\n-      pragma Assert (Target.First.Prev = null);\n-      pragma Assert (Target.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Target.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Target.Last);\n-\n       if Position.Node = Before.Node\n         or else Position.Node.Next = Before.Node\n       then\n@@ -1548,46 +1378,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n+      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n-\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Source'Unchecked_Access) then\n+      if Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Source.Length >= 1);\n-      pragma Assert (Source.First.Prev = null);\n-      pragma Assert (Source.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Source.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Source.Last);\n-\n       if Target.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n@@ -1600,12 +1407,14 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       if Position.Node = Source.First then\n          Source.First := Position.Node.Next;\n-         Source.First.Prev := null;\n \n          if Position.Node = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n+\n+         else\n+            Source.First.Prev := null;\n          end if;\n \n       elsif Position.Node = Source.Last then\n@@ -1667,8 +1476,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Swap (I, J : Cursor) is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n+      if I.Node = null\n+        or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n@@ -1677,51 +1489,22 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n-      declare\n-         C : List renames I.Container.all;\n-      begin\n-         pragma Assert (C.Length >= 1);\n-         pragma Assert (C.First.Prev = null);\n-         pragma Assert (C.Last.Next = null);\n-\n-         pragma Assert (I.Node /= null);\n-         pragma Assert (I.Node.Prev = null\n-                          or else I.Node.Prev.Next = I.Node);\n-         pragma Assert (I.Node.Next = null\n-                          or else I.Node.Next.Prev = I.Node);\n-         pragma Assert (I.Node.Prev /= null\n-                          or else I.Node = C.First);\n-         pragma Assert (I.Node.Next /= null\n-                          or else I.Node = C.Last);\n-\n-         if I.Node = J.Node then\n-            return;\n-         end if;\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n \n-         pragma Assert (C.Length >= 2);\n-         pragma Assert (J.Node /= null);\n-         pragma Assert (J.Node.Prev = null\n-                          or else J.Node.Prev.Next = J.Node);\n-         pragma Assert (J.Node.Next = null\n-                          or else J.Node.Next.Prev = J.Node);\n-         pragma Assert (J.Node.Prev /= null\n-                          or else J.Node = C.First);\n-         pragma Assert (J.Node.Next /= null\n-                          or else J.Node = C.Last);\n-\n-         if C.Lock > 0 then\n-            raise Program_Error;\n-         end if;\n+      if I.Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n \n-         declare\n-            EI : Element_Type renames I.Node.Element;\n-            EJ : Element_Type renames J.Node.Element;\n+      declare\n+         EI : Element_Type renames I.Node.Element;\n+         EJ : Element_Type renames J.Node.Element;\n \n-            EI_Copy : constant Element_Type := EI;\n-         begin\n-            EI := EJ;\n-            EJ := EI_Copy;\n-         end;\n+         EI_Copy : constant Element_Type := EI;\n+      begin\n+         EI := EJ;\n+         EJ := EI_Copy;\n       end;\n    end Swap;\n \n@@ -1733,50 +1516,25 @@ package body Ada.Containers.Doubly_Linked_Lists is\n      (Container : in out List;\n       I, J      : Cursor) is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n+      if I.Node = null\n+        or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n-      end if;\n-\n-      if J.Container /= I.Container then\n+      if I.Container /= Container'Unrestricted_Access\n+        or else I.Container /= J.Container\n+      then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Container.Length >= 1);\n-      pragma Assert (Container.First.Prev = null);\n-      pragma Assert (Container.Last.Next = null);\n-\n-      pragma Assert (I.Node /= null);\n-      pragma Assert (I.Node.Prev = null\n-                       or else I.Node.Prev.Next = I.Node);\n-      pragma Assert (I.Node.Next = null\n-                       or else I.Node.Next.Prev = I.Node);\n-      pragma Assert (I.Node.Prev /= null\n-                       or else I.Node = Container.First);\n-      pragma Assert (I.Node.Next /= null\n-                       or else I.Node = Container.Last);\n-\n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      pragma Assert (Container.Length >= 2);\n-\n-      pragma Assert (J.Node /= null);\n-      pragma Assert (J.Node.Prev = null\n-                       or else J.Node.Prev.Next = J.Node);\n-      pragma Assert (J.Node.Next = null\n-                       or else J.Node.Next.Prev = J.Node);\n-      pragma Assert (J.Node.Prev /= null\n-                       or else J.Node = Container.First);\n-      pragma Assert (J.Node.Next /= null\n-                       or else J.Node = Container.Last);\n-\n       if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n@@ -1813,46 +1571,177 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Update_Element\n      (Position : Cursor;\n-      Process  : not null access procedure (Element : in out Element_Type)) is\n-\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length >= 1);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      E : Element_Type renames Position.Node.Element;\n-\n-      C : List renames Position.Container.all'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n-\n+      Process  : not null access procedure (Element : in out Element_Type))\n+   is\n    begin\n-      B := B + 1;\n-      L := L + 1;\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Update_Element;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Prev = Position.Node then\n+         return False;\n+      end if;\n+\n+      declare\n+         L : List renames Position.Container.all;\n+      begin\n+         if L.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if L.First = null then\n+            return False;\n+         end if;\n+\n+         if L.Last = null then\n+            return False;\n+         end if;\n+\n+         if L.First.Prev /= null then\n+            return False;\n+         end if;\n+\n+         if L.Last.Next /= null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev = null\n+           and then Position.Node /= L.First\n+         then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Next = null\n+           and then Position.Node /= L.Last\n+         then\n+            return False;\n+         end if;\n+\n+         if L.Length = 1 then\n+            return L.First = L.Last;\n+         end if;\n+\n+         if L.First = L.Last then\n+            return False;\n+         end if;\n+\n+         if L.First.Next = null then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev = null then\n+            return False;\n+         end if;\n+\n+         if L.First.Next.Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev.Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Length = 2 then\n+            if L.First.Next /= L.Last then\n+               return False;\n+            end if;\n+\n+            if L.Last.Prev /= L.First then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end if;\n+\n+         if L.First.Next = L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev = L.First then\n+            return False;\n+         end if;\n+\n+         if Position.Node = L.First then\n+            return True;\n+         end if;\n+\n+         if Position.Node = L.Last then\n+            return True;\n+         end if;\n+\n+         if Position.Node.Next = null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev = null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Next.Prev /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev.Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if L.Length = 3 then\n+            if L.First.Next /= Position.Node then\n+               return False;\n+            end if;\n+\n+            if L.Last.Prev /= Position.Node then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------"}, {"sha": "9793f967e01feaad206ba438c58e38dc388e8aad", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 132, "deletions": 160, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -42,14 +42,6 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Buckets_Type, Buckets_Access);\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Rehash\n-     (HT   : in out Hash_Table_Type;\n-      Size : Hash_Type);\n-\n    ------------\n    -- Adjust --\n    ------------\n@@ -405,27 +397,33 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n    begin\n       Clear (HT);\n \n-      declare\n-         B : Buckets_Access := HT.Buckets;\n-      begin\n-         HT.Buckets := null;\n-         HT.Length := 0;\n-         Free (B); -- can this fail???\n-      end;\n-\n       Hash_Type'Read (Stream, Last);\n \n-      --  TODO: don't immediately deallocate the buckets array we\n-      --  already have. Instead, allocate a new buckets array only\n-      --  if it needs to expanded because of the value of Last.\n+      Count_Type'Base'Read (Stream, N);\n+      pragma Assert (N >= 0);\n+\n+      if N = 0 then\n+         return;\n+      end if;\n \n-      if Last /= 0 then\n+      if HT.Buckets = null\n+        or else HT.Buckets'Last /= Last\n+      then\n+         Free (HT.Buckets);\n          HT.Buckets := new Buckets_Type (0 .. Last);\n       end if;\n \n-      Count_Type'Base'Read (Stream, N);\n-      pragma Assert (N >= 0);\n-      while N > 0 loop\n+      --  TODO: should we rewrite this algorithm so that it doesn't\n+      --  depend on preserving the exactly length of the hash table\n+      --  array?  We would prefer to not have to (re)allocate a\n+      --  buckets array (the array that HT already has might be large\n+      --  enough), and to not have to stream the count of the number\n+      --  of nodes in each bucket.  The algorithm below is vestigial,\n+      --  as it was written prior to the meeting in Palma, when the\n+      --  semantics of equality were changed (and which obviated the\n+      --  need to preserve the hash table length).\n+\n+      loop\n          Hash_Type'Read (Stream, I);\n          pragma Assert (I in HT.Buckets'Range);\n          pragma Assert (HT.Buckets (I) = null);\n@@ -454,6 +452,8 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          end loop;\n \n          N := N - M;\n+\n+         exit when N = 0;\n       end loop;\n    end Generic_Read;\n \n@@ -481,6 +481,8 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n          return;\n       end if;\n \n+      --  TODO: see note in Generic_Read???\n+\n       for Indx in HT.Buckets'Range loop\n          X := HT.Buckets (Indx);\n \n@@ -577,104 +579,6 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       return null;\n    end Next;\n \n-   ------------\n-   -- Rehash --\n-   ------------\n-\n-   procedure Rehash\n-     (HT   : in out Hash_Table_Type;\n-      Size : Hash_Type)\n-   is\n-      subtype Buckets_Range is Hash_Type range 0 .. Size - 1;\n-\n-      Dst_Buckets : Buckets_Access := new Buckets_Type (Buckets_Range);\n-      Src_Buckets : Buckets_Access := HT.Buckets;\n-\n-      L  : Count_Type renames HT.Length;\n-      LL : constant Count_Type := L;\n-\n-   begin\n-      if Src_Buckets = null then\n-         pragma Assert (L = 0);\n-         HT.Buckets := Dst_Buckets;\n-         return;\n-      end if;\n-\n-      if L = 0 then\n-         HT.Buckets := Dst_Buckets;\n-         Free (Src_Buckets);\n-         return;\n-      end if;\n-\n-      --  We might want to change this to iter from 1 .. L instead ???\n-\n-      for Src_Index in Src_Buckets'Range loop\n-\n-         declare\n-            Src_Bucket : Node_Access renames Src_Buckets (Src_Index);\n-         begin\n-            while Src_Bucket /= null loop\n-               declare\n-                  Src_Node   : constant Node_Access := Src_Bucket;\n-                  Dst_Index  : constant Hash_Type :=\n-                                 Index (Dst_Buckets.all, Src_Node);\n-                  Dst_Bucket : Node_Access renames Dst_Buckets (Dst_Index);\n-               begin\n-                  Src_Bucket := Next (Src_Node);\n-                  Set_Next (Src_Node, Dst_Bucket);\n-                  Dst_Bucket := Src_Node;\n-               end;\n-\n-               pragma Assert (L > 0);\n-               L := L - 1;\n-\n-            end loop;\n-\n-         exception\n-            when others =>\n-\n-               --  NOTE: see todo below.\n-               --  Not clear that we can deallocate the nodes,\n-               --  because they may be designated by outstanding\n-               --  iterators.  Which means they're now lost... ???\n-\n-               --                 for J in NB'Range loop\n-               --                    declare\n-               --                       Dst : Node_Access renames NB (J);\n-               --                       X   : Node_Access;\n-               --                    begin\n-               --                       while Dst /= null loop\n-               --                          X := Dst;\n-               --                          Dst := Succ (Dst);\n-               --                          Free (X);\n-               --                       end loop;\n-               --                    end;\n-               --                 end loop;\n-\n-               --  TODO: 17 Apr 2005\n-               --  What I should do instead is go ahead and deallocate the\n-               --  nodes, since when assertions are enabled, we vet the\n-               --  cursors, and we modify the state of a node enough when\n-               --  it is deallocated in order to detect mischief.\n-               --  END TODO.\n-\n-               Free (Dst_Buckets);\n-               raise;  --  TODO: raise Program_Error instead\n-         end;\n-\n-         --  exit when L = 0;\n-         --  need to bother???\n-\n-      end loop;\n-\n-      pragma Assert (L = 0);\n-\n-      HT.Buckets := Dst_Buckets;\n-      HT.Length := LL;\n-\n-      Free (Src_Buckets);\n-   end Rehash;\n-\n    ----------------------\n    -- Reserve_Capacity --\n    ----------------------\n@@ -686,74 +590,142 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       NN : Hash_Type;\n \n    begin\n-      if N = 0 then\n-         if HT.Length = 0 then\n-            Free (HT.Buckets);\n+      if HT.Buckets = null then\n+         if N > 0 then\n+            NN := Prime_Numbers.To_Prime (N);\n+            HT.Buckets := new Buckets_Type (0 .. NN - 1);\n+         end if;\n \n-         elsif HT.Length < HT.Buckets'Length then\n-            NN := Prime_Numbers.To_Prime (HT.Length);\n+         return;\n+      end if;\n \n-            --  ASSERT: NN >= HT.Length\n+      if HT.Length = 0 then\n+         if N = 0 then\n+            Free (HT.Buckets);\n+            return;\n+         end if;\n \n-            if NN < HT.Buckets'Length then\n-               if HT.Busy > 0 then\n-                  raise Program_Error;\n-               end if;\n+         if N = HT.Buckets'Length then\n+            return;\n+         end if;\n \n-               Rehash (HT, Size => NN);\n-            end if;\n+         NN := Prime_Numbers.To_Prime (N);\n+\n+         if NN = HT.Buckets'Length then\n+            return;\n          end if;\n \n+         declare\n+            X : Buckets_Access := HT.Buckets;\n+         begin\n+            HT.Buckets := new Buckets_Type (0 .. NN - 1);\n+            Free (X);\n+         end;\n+\n          return;\n       end if;\n \n-      if HT.Buckets = null then\n-         NN := Prime_Numbers.To_Prime (N);\n-\n-         --  ASSERT: NN >= N\n-\n-         Rehash (HT, Size => NN);\n+      if N = HT.Buckets'Length then\n          return;\n       end if;\n \n-      if N <= HT.Length then\n+      if N < HT.Buckets'Length then\n          if HT.Length >= HT.Buckets'Length then\n             return;\n          end if;\n \n          NN := Prime_Numbers.To_Prime (HT.Length);\n \n-         --  ASSERT: NN >= HT.Length\n+         if NN >= HT.Buckets'Length then\n+            return;\n+         end if;\n \n-         if NN < HT.Buckets'Length then\n-            if HT.Busy > 0 then\n-               raise Program_Error;\n-            end if;\n+      else\n+         NN := Prime_Numbers.To_Prime (Count_Type'Max (N, HT.Length));\n \n-            Rehash (HT, Size => NN);\n+         if NN = HT.Buckets'Length then -- can't expand any more\n+            return;\n          end if;\n+      end if;\n \n-         return;\n+      if HT.Busy > 0 then\n+         raise Program_Error;\n       end if;\n \n-      --  ASSERT: N > HT.Length\n+      Rehash : declare\n+         Dst_Buckets : Buckets_Access := new Buckets_Type (0 .. NN - 1);\n+         Src_Buckets : Buckets_Access := HT.Buckets;\n \n-      if N = HT.Buckets'Length then\n-         return;\n-      end if;\n+         L : Count_Type renames HT.Length;\n+         LL : constant Count_Type := L;\n \n-      NN := Prime_Numbers.To_Prime (N);\n+         Src_Index : Hash_Type := Src_Buckets'First;\n \n-      --  ASSERT: NN >= N\n-      --  ASSERT: NN > HT.Length\n+      begin\n+         while L > 0 loop\n+            declare\n+               Src_Bucket : Node_Access renames Src_Buckets (Src_Index);\n \n-      if NN /= HT.Buckets'Length then\n-         if HT.Busy > 0 then\n-            raise Program_Error;\n-         end if;\n+            begin\n+               while Src_Bucket /= null loop\n+                  declare\n+                     Src_Node : constant Node_Access := Src_Bucket;\n+\n+                     Dst_Index : constant Hash_Type :=\n+                       Index (Dst_Buckets.all, Src_Node);\n+\n+                     Dst_Bucket : Node_Access renames Dst_Buckets (Dst_Index);\n+\n+                  begin\n+                     Src_Bucket := Next (Src_Node);\n+\n+                     Set_Next (Src_Node, Dst_Bucket);\n+\n+                     Dst_Bucket := Src_Node;\n+                  end;\n+\n+                  pragma Assert (L > 0);\n+                  L := L - 1;\n+               end loop;\n+            exception\n+               when others =>\n+                  --  If there's an error computing a hash value during a\n+                  --  rehash, then AI-302 says the nodes \"become lost.\"  The\n+                  --  issue is whether to actually deallocate these lost nodes,\n+                  --  since they might be designated by extant cursors.  Here\n+                  --  we decide to deallocate the nodes, since it's better to\n+                  --  solve real problems (storage consumption) rather than\n+                  --  imaginary ones (the user might, or might not, dereference\n+                  --  a cursor designating a node that has been deallocated),\n+                  --  and because we have a way to vet a dangling cursor\n+                  --  reference anyway, and hence can actually detect the\n+                  --  problem.\n+\n+                  for Dst_Index in Dst_Buckets'Range loop\n+                     declare\n+                        B : Node_Access renames Dst_Buckets (Dst_Index);\n+                        X : Node_Access;\n+                     begin\n+                        while B /= null loop\n+                           X := B;\n+                           B := Next (X);\n+                           Free (X);\n+                        end loop;\n+                     end;\n+                  end loop;\n+\n+                  Free (Dst_Buckets);\n+                  raise Program_Error;\n+            end;\n \n-         Rehash (HT, Size => NN);\n-      end if;\n+            Src_Index := Src_Index + 1;\n+         end loop;\n+\n+         HT.Buckets := Dst_Buckets;\n+         HT.Length := LL;\n+\n+         Free (Src_Buckets);\n+      end Rehash;\n    end Reserve_Capacity;\n \n end Ada.Containers.Hash_Tables.Generic_Operations;"}, {"sha": "becdae2ecb57ffcd1f9be2fb791d2b5879c60007", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 343, "deletions": 502, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -39,21 +39,22 @@ with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Free (X : in out Node_Access);\n+\n    procedure Insert_Internal\n      (Container : in out List;\n       Before    : Node_Access;\n       New_Node  : Node_Access);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    ---------\n    -- \"=\" --\n    ---------\n@@ -188,18 +189,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          Container.First := X.Next;\n          Container.First.Prev := null;\n-         Container.Length := Container.Length - 1;\n-\n-         X.Next := null;  --  prevent mischief\n \n-         begin\n-            Free (X.Element);\n-         exception\n-            when others =>\n-               X.Element := null;\n-               Free (X);\n-               raise;\n-         end;\n+         Container.Length := Container.Length - 1;\n \n          Free (X);\n       end loop;\n@@ -211,15 +202,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Container.Last := null;\n       Container.Length := 0;\n \n-      begin\n-         Free (X.Element);\n-      exception\n-         when others =>\n-            X.Element := null;\n-            Free (X);\n-            raise;\n-      end;\n-\n       Free (X);\n    end Clear;\n \n@@ -246,28 +228,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       X : Node_Access;\n \n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Container.Length > 0);\n-      pragma Assert (Container.First.Prev = null);\n-      pragma Assert (Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Container.Last);\n-\n       if Position.Node = Container.First then\n          Delete_First (Container, Count);\n          Position := First (Container);\n@@ -292,17 +262,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             Container.Last := X.Prev;\n             Container.Last.Next := null;\n \n-            X.Prev := null;  --  prevent mischief\n-\n-            begin\n-               Free (X.Element);\n-            exception\n-               when others =>\n-                  X.Element := null;\n-                  Free (X);\n-                  raise;\n-            end;\n-\n             Free (X);\n             return;\n          end if;\n@@ -312,18 +271,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          X.Next.Prev := X.Prev;\n          X.Prev.Next := X.Next;\n \n-         X.Prev := null;\n-         X.Next := null;\n-\n-         begin\n-            Free (X.Element);\n-         exception\n-            when others =>\n-               X.Element := null;\n-               Free (X);\n-               raise;\n-         end;\n-\n          Free (X);\n       end loop;\n    end Delete;\n@@ -361,17 +308,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          Container.Length := Container.Length - 1;\n \n-         X.Next := null;  --  prevent mischief\n-\n-         begin\n-            Free (X.Element);\n-         exception\n-            when others =>\n-               X.Element := null;\n-               Free (X);\n-               raise;\n-         end;\n-\n          Free (X);\n       end loop;\n    end Delete_First;\n@@ -409,17 +345,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          Container.Length := Container.Length - 1;\n \n-         X.Prev := null;  --  prevent mischief\n-\n-         begin\n-            Free (X.Element);\n-         exception\n-            when others =>\n-               X.Element := null;\n-               Free (X);\n-               raise;\n-         end;\n-\n          Free (X);\n       end loop;\n    end Delete_Last;\n@@ -430,21 +355,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n+      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n       return Position.Node.Element.all;\n    end Element;\n@@ -465,23 +380,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Node := Container.First;\n \n       else\n-         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n-\n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Position.Node.Element /= null);\n-         pragma Assert (Position.Node.Prev = null\n-                          or else Position.Node.Prev.Next = Position.Node);\n-         pragma Assert (Position.Node.Next = null\n-                          or else Position.Node.Next.Prev = Position.Node);\n-         pragma Assert (Position.Node.Prev /= null\n-                          or else Position.Node = Container.First);\n-         pragma Assert (Position.Node.Next /= null\n-                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -514,9 +417,37 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function First_Element (Container : List) return Element_Type is\n    begin\n+      if Container.First = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.First.Element.all;\n    end First_Element;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      X.Next := X;\n+      X.Prev := X;\n+\n+      begin\n+         Free (X.Element);\n+      exception\n+         when others =>\n+            X.Element := null;\n+            Deallocate (X);\n+            raise;\n+      end;\n+\n+      Deallocate (X);\n+   end Free;\n+\n    ---------------------\n    -- Generic_Sorting --\n    ---------------------\n@@ -686,27 +617,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ------------\n@@ -723,24 +635,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       New_Node : Node_Access;\n \n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Container'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n+      pragma Assert (Vet (Before), \"bad cursor in Insert\");\n \n-         pragma Assert (Before.Node.Element /= null);\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Container.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Container.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Container'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Count = 0 then\n@@ -883,32 +783,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       B := B - 1;\n    end Iterate;\n \n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out List; Source : in out List) is\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error;\n-      end if;\n-\n-      Clear (Target);\n-\n-      Target.First := Source.First;\n-      Source.First := null;\n-\n-      Target.Last := Source.Last;\n-      Source.Last := null;\n-\n-      Target.Length := Source.Length;\n-      Source.Length := 0;\n-   end Move;\n-\n    ----------\n    -- Last --\n    ----------\n@@ -928,6 +802,10 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Last_Element (Container : List) return Element_Type is\n    begin\n+      if Container.Last = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Container.Last.Element.all;\n    end Last_Element;\n \n@@ -940,32 +818,44 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       return Container.Length;\n    end Length;\n \n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out List; Source : in out List) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error;\n+      end if;\n+\n+      Clear (Target);\n+\n+      Target.First := Source.First;\n+      Source.First := null;\n+\n+      Target.Last := Source.Last;\n+      Source.Last := null;\n+\n+      Target.Length := Source.Length;\n+      Source.Length := 0;\n+   end Move;\n+\n    ----------\n    -- Next --\n    ----------\n \n    procedure Next (Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in procedure Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       Position.Node := Position.Node.Next;\n \n       if Position.Node = null then\n@@ -975,26 +865,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       declare\n          Next_Node : constant Node_Access := Position.Node.Next;\n       begin\n@@ -1025,26 +901,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    procedure Previous (Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in procedure Previous\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       Position.Node := Position.Node.Prev;\n \n       if Position.Node = null then\n@@ -1054,26 +916,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    function Previous (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Previous\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n       declare\n          Prev_Node : constant Node_Access := Position.Node.Prev;\n       begin\n@@ -1093,43 +941,34 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in Element_Type))\n    is\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      E : Element_Type renames Position.Node.Element.all;\n-\n-      C : List renames Position.Container.all'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n-\n    begin\n-      B := B + 1;\n-      L := L + 1;\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element.all);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1193,31 +1032,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       By       : Element_Type)\n    is\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      X : Element_Access := Position.Node.Element;\n-\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      if Position.Container = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       if Position.Container.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      Position.Node.Element := new Element_Type'(By);\n-      Free (X);\n+      declare\n+         X : Element_Access := Position.Node.Element;\n+      begin\n+         Position.Node.Element := new Element_Type'(By);\n+         Free (X);\n+      end;\n    end Replace_Element;\n \n    ------------------\n@@ -1236,23 +1067,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Node := Container.Last;\n \n       else\n-         if Position.Container /= List_Access'(Container'Unchecked_Access) then\n+         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n-\n-         pragma Assert (Container.Length > 0);\n-         pragma Assert (Container.First.Prev = null);\n-         pragma Assert (Container.Last.Next = null);\n-\n-         pragma Assert (Position.Node.Element /= null);\n-         pragma Assert (Position.Node.Prev = null\n-                          or else Position.Node.Prev.Next = Position.Node);\n-         pragma Assert (Position.Node.Next = null\n-                          or else Position.Node.Next.Prev = Position.Node);\n-         pragma Assert (Position.Node.Prev /= null\n-                          or else Position.Node = Container.First);\n-         pragma Assert (Position.Node.Next /= null\n-                          or else Position.Node = Container.Last);\n       end if;\n \n       while Node /= null loop\n@@ -1392,24 +1211,12 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Source : in out List)\n    is\n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Vet (Before), \"bad cursor in Splice\");\n \n-         pragma Assert (Before.Node.Element /= null);\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Target'Address = Source'Address\n@@ -1477,48 +1284,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position : Cursor)\n    is\n    begin\n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-         pragma Assert (Before.Node.Element /= null);\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unchecked_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Target'Unchecked_Access) then\n+      if Position.Container /= Target'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Target.Length >= 1);\n-      pragma Assert (Target.First.Prev = null);\n-      pragma Assert (Target.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Target.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Target.Last);\n-\n       if Position.Node = Before.Node\n         or else Position.Node.Next = Before.Node\n       then\n@@ -1606,48 +1388,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      if Before.Node /= null then\n-         if Before.Container /= List_Access'(Target'Unchecked_Access) then\n-            raise Program_Error;\n-         end if;\n-\n-         pragma Assert (Target.Length >= 1);\n-         pragma Assert (Target.First.Prev = null);\n-         pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-         pragma Assert (Before.Node.Element /= null);\n-         pragma Assert (Before.Node.Prev = null\n-                          or else Before.Node.Prev.Next = Before.Node);\n-         pragma Assert (Before.Node.Next = null\n-                          or else Before.Node.Next.Prev = Before.Node);\n-         pragma Assert (Before.Node.Prev /= null\n-                          or else Before.Node = Target.First);\n-         pragma Assert (Before.Node.Next /= null\n-                          or else Before.Node = Target.Last);\n+      if Before.Container /= null\n+        and then Before.Container /= Target'Unrestricted_Access\n+      then\n+         raise Program_Error;\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= List_Access'(Source'Unchecked_Access) then\n+      if Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Source.Length >= 1);\n-      pragma Assert (Source.First.Prev = null);\n-      pragma Assert (Source.Last.Next = null);\n-\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Source.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Source.Last);\n-\n       if Target.Length = Count_Type'Last then\n          raise Constraint_Error;\n       end if;\n@@ -1660,12 +1417,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       if Position.Node = Source.First then\n          Source.First := Position.Node.Next;\n-         Source.First.Prev := null;\n \n          if Position.Node = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n+\n+         else\n+            Source.First.Prev := null;\n          end if;\n \n       elsif Position.Node = Source.Last then\n@@ -1727,8 +1486,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n    procedure Swap (I, J : Cursor) is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n+      pragma Assert (Vet (I), \"bad I cursor in Swap\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap\");\n+\n+      if I.Node = null\n+        or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n@@ -1737,50 +1499,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n-      declare\n-         C : List renames I.Container.all;\n-      begin\n-         pragma Assert (C.Length > 0);\n-         pragma Assert (C.First.Prev = null);\n-         pragma Assert (C.Last.Next = null);\n-\n-         pragma Assert (I.Node /= null);\n-         pragma Assert (I.Node.Element /= null);\n-         pragma Assert (I.Node.Prev = null\n-                          or else I.Node.Prev.Next = I.Node);\n-         pragma Assert (I.Node.Next = null\n-                          or else I.Node.Next.Prev = I.Node);\n-         pragma Assert (I.Node.Prev /= null\n-                          or else I.Node = C.First);\n-         pragma Assert (I.Node.Next /= null\n-                          or else I.Node = C.Last);\n-\n-         if I.Node = J.Node then\n-            return;\n-         end if;\n+      if I.Node = J.Node then\n+         return;\n+      end if;\n \n-         pragma Assert (C.Length > 1);\n-         pragma Assert (J.Node /= null);\n-         pragma Assert (J.Node.Element /= null);\n-         pragma Assert (J.Node.Prev = null\n-                          or else J.Node.Prev.Next = J.Node);\n-         pragma Assert (J.Node.Next = null\n-                          or else J.Node.Next.Prev = J.Node);\n-         pragma Assert (J.Node.Prev /= null\n-                          or else J.Node = C.First);\n-         pragma Assert (J.Node.Next /= null\n-                          or else J.Node = C.Last);\n-\n-         if C.Lock > 0 then\n-            raise Program_Error;\n-         end if;\n+      if I.Container.Lock > 0 then\n+         raise Program_Error;\n+      end if;\n \n-         declare\n-            EI_Copy : constant Element_Access := I.Node.Element;\n-         begin\n-            I.Node.Element := J.Node.Element;\n-            J.Node.Element := EI_Copy;\n-         end;\n+      declare\n+         EI_Copy : constant Element_Access := I.Node.Element;\n+      begin\n+         I.Node.Element := J.Node.Element;\n+         J.Node.Element := EI_Copy;\n       end;\n    end Swap;\n \n@@ -1793,51 +1524,25 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n+      pragma Assert (Vet (I), \"bad I cursor in Swap_Links\");\n+      pragma Assert (Vet (J), \"bad J cursor in Swap_Links\");\n+\n+      if I.Node = null\n+        or else J.Node = null\n       then\n          raise Constraint_Error;\n       end if;\n \n-      if I.Container /= List_Access'(Container'Unchecked_Access) then\n-         raise Program_Error;\n-      end if;\n-\n-      if J.Container /= I.Container then\n+      if I.Container /= Container'Unrestricted_Access\n+        or else I.Container /= J.Container\n+      then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Container.Length >= 1);\n-      pragma Assert (Container.First.Prev = null);\n-      pragma Assert (Container.Last.Next = null);\n-\n-      pragma Assert (I.Node /= null);\n-      pragma Assert (I.Node.Element /= null);\n-      pragma Assert (I.Node.Prev = null\n-                       or else I.Node.Prev.Next = I.Node);\n-      pragma Assert (I.Node.Next = null\n-                       or else I.Node.Next.Prev = I.Node);\n-      pragma Assert (I.Node.Prev /= null\n-                       or else I.Node = Container.First);\n-      pragma Assert (I.Node.Next /= null\n-                       or else I.Node = Container.Last);\n-\n       if I.Node = J.Node then\n          return;\n       end if;\n \n-      pragma Assert (Container.Length >= 2);\n-      pragma Assert (J.Node /= null);\n-      pragma Assert (J.Node.Element /= null);\n-      pragma Assert (J.Node.Prev = null\n-                       or else J.Node.Prev.Next = J.Node);\n-      pragma Assert (J.Node.Next = null\n-                       or else J.Node.Next.Prev = J.Node);\n-      pragma Assert (J.Node.Prev /= null\n-                       or else J.Node = Container.First);\n-      pragma Assert (J.Node.Next /= null\n-                       or else J.Node = Container.Last);\n-\n       if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n@@ -1878,45 +1583,179 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : in out Element_Type))\n    is\n-      pragma Assert (Position.Container /= null);\n-      pragma Assert (Position.Container.Length > 0);\n-      pragma Assert (Position.Container.First.Prev = null);\n-      pragma Assert (Position.Container.Last.Next = null);\n-\n-      pragma Assert (Position.Node /= null);\n-      pragma Assert (Position.Node.Element /= null);\n-      pragma Assert (Position.Node.Prev = null\n-                       or else Position.Node.Prev.Next = Position.Node);\n-      pragma Assert (Position.Node.Next = null\n-                       or else Position.Node.Next.Prev = Position.Node);\n-      pragma Assert (Position.Node.Prev /= null\n-                       or else Position.Node = Position.Container.First);\n-      pragma Assert (Position.Node.Next /= null\n-                       or else Position.Node = Position.Container.Last);\n-\n-      E : Element_Type renames Position.Node.Element.all;\n-\n-      C : List renames Position.Container.all'Unrestricted_Access.all;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n-\n    begin\n-      B := B + 1;\n-      L := L + 1;\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         C : List renames Position.Container.all'Unrestricted_Access.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element.all);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Update_Element;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Prev = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         L : List renames Position.Container.all;\n+      begin\n+         if L.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if L.First = null then\n+            return False;\n+         end if;\n+\n+         if L.Last = null then\n+            return False;\n+         end if;\n+\n+         if L.First.Prev /= null then\n+            return False;\n+         end if;\n+\n+         if L.Last.Next /= null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev = null\n+           and then Position.Node /= L.First\n+         then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Next = null\n+           and then Position.Node /= L.Last\n+         then\n+            return False;\n+         end if;\n+\n+         if L.Length = 1 then\n+            return L.First = L.Last;\n+         end if;\n+\n+         if L.First = L.Last then\n+            return False;\n+         end if;\n+\n+         if L.First.Next = null then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev = null then\n+            return False;\n+         end if;\n+\n+         if L.First.Next.Prev /= L.First then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev.Next /= L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Length = 2 then\n+            if L.First.Next /= L.Last then\n+               return False;\n+            end if;\n+\n+            if L.Last.Prev /= L.First then\n+               return False;\n+            end if;\n+\n+            return True;\n+         end if;\n+\n+         if L.First.Next = L.Last then\n+            return False;\n+         end if;\n+\n+         if L.Last.Prev = L.First then\n+            return False;\n+         end if;\n+\n+         if Position.Node = L.First then\n+            return True;\n+         end if;\n+\n+         if Position.Node = L.Last then\n+            return True;\n+         end if;\n+\n+         if Position.Node.Next = null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev = null then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Next.Prev /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if Position.Node.Prev.Next /= Position.Node then\n+            return False;\n+         end if;\n+\n+         if L.Length = 3 then\n+            if L.First.Next /= Position.Node then\n+               return False;\n+            end if;\n+\n+            if L.Last.Prev /= Position.Node then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------\n@@ -1926,8 +1765,10 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Item   : List)\n    is\n       Node : Node_Access := Item.First;\n+\n    begin\n       Count_Type'Base'Write (Stream, Item.Length);\n+\n       while Node /= null loop\n          Element_Type'Output (Stream, Node.Element.all);  --  X.all\n          Node := Node.Next;"}, {"sha": "dc5fa0f82cb5084f876a14facb530f8726c8e5af", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 138, "deletions": 74, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -194,19 +194,16 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n-         return;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Position.Node.Next /= Position.Node);\n-      pragma Assert (Position.Node.Key /= null);\n-      pragma Assert (Position.Node.Element /= null);\n-\n       if Container.HT.Busy > 0 then\n          raise Program_Error;\n       end if;\n@@ -222,14 +219,24 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    -------------\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      C : constant Cursor := Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n    begin\n-      return C.Node.Element.all;\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Node.Element.all;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position));\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -251,8 +258,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean is\n    begin\n-      pragma Assert (Vet (Left));\n-      pragma Assert (Vet (Right));\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -261,7 +275,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Key_Type) return Boolean\n    is\n    begin\n-      pragma Assert (Vet (Left));\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right);\n    end Equivalent_Keys;\n \n@@ -270,7 +289,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Right : Cursor) return Boolean\n    is\n    begin\n-      pragma Assert (Vet (Right));\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -338,6 +362,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function First (Container : Map) return Cursor is\n       Node : constant Node_Access := HT_Ops.First (Container.HT);\n+\n    begin\n       if Node = null then\n          return No_Element;\n@@ -396,13 +421,8 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      pragma Assert (Vet (Position));\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ---------------\n@@ -468,7 +488,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    is\n       function New_Node (Next : Node_Access) return Node_Access;\n \n-      procedure Insert is\n+      procedure Local_Insert is\n         new Key_Ops.Generic_Conditional_Insert (New_Node);\n \n       --------------\n@@ -478,6 +498,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       function New_Node (Next : Node_Access) return Node_Access is\n          K  : Key_Access := new Key_Type'(Key);\n          E  : Element_Access;\n+\n       begin\n          E := new Element_Type'(New_Item);\n          return new Node_Type'(K, E, Next);\n@@ -493,12 +514,18 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    --  Start of processing for Insert\n \n    begin\n-      if HT.Length >= HT_Ops.Capacity (HT) then\n-         --  TODO: see note in a-cohama.adb.\n-         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      if HT_Ops.Capacity (HT) = 0 then\n+         HT_Ops.Reserve_Capacity (HT, 1);\n+      end if;\n+\n+      Local_Insert (HT, Key, Position.Node, Inserted);\n+\n+      if Inserted\n+        and then HT.Length > HT_Ops.Capacity (HT)\n+      then\n+         HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n \n-      Insert (HT, Key, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -562,7 +589,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      pragma Assert (Vet (Position));\n+      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Position.Node.Key.all;\n    end Key;\n \n@@ -603,13 +635,13 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n       declare\n-         pragma Assert (Vet (Position));\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n \n@@ -631,32 +663,40 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type))\n    is\n-      pragma Assert (Vet (Position));\n-\n-      K : Key_Type renames Position.Node.Key.all;\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      M  : Map renames Position.Container.all;\n-      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n+      declare\n+         M  : Map renames Position.Container.all;\n+         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key.all;\n+            E : Element_Type renames Position.Node.Element.all;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -748,15 +788,24 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    ---------------------\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n-      pragma Assert (Vet (Position));\n-      X : Element_Access := Position.Node.Element;\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       if Position.Container.HT.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      Position.Node.Element := new Element_Type'(By);\n-      Free_Element (X);\n+      declare\n+         X : Element_Access := Position.Node.Element;\n+\n+      begin\n+         Position.Node.Element := new Element_Type'(By);\n+         Free_Element (X);\n+      end;\n    end Replace_Element;\n \n    ----------------------\n@@ -789,32 +838,40 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : in out Element_Type))\n    is\n-      pragma Assert (Vet (Position));\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n-      K : Key_Type renames Position.Node.Key.all;\n-      E : Element_Type renames Position.Node.Element.all;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      M  : Map renames Position.Container.all;\n-      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+      declare\n+         M  : Map renames Position.Container.all;\n+         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n-\n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         declare\n+            K : Key_Type renames Position.Node.Key.all;\n+            E : Element_Type renames Position.Node.Element.all;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Update_Element;\n \n    ---------\n@@ -824,6 +881,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    function Vet (Position : Cursor) return Boolean is\n    begin\n       if Position.Node = null then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n          return False;\n       end if;\n \n@@ -842,12 +903,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       declare\n          HT : Hash_Table_Type renames Position.Container.HT;\n          X  : Node_Access;\n+\n       begin\n          if HT.Length = 0 then\n             return False;\n          end if;\n \n-         if HT.Buckets = null then\n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+         then\n             return False;\n          end if;\n \n@@ -862,7 +926,7 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n                return False;\n             end if;\n \n-            if X = X.Next then -- weird\n+            if X = X.Next then -- to prevent endless loop\n                return False;\n             end if;\n "}, {"sha": "8e747eadf08196c7ef50ac049d94aa268e154a64", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 245, "deletions": 87, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -84,13 +84,15 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    pragma Inline (Read_Node);\n \n    procedure Replace_Element\n-     (HT      : in out Hash_Table_Type;\n-      Node    : Node_Access;\n-      Element : Element_Type);\n+     (HT       : in out Hash_Table_Type;\n+      Node     : Node_Access;\n+      New_Item : Element_Type);\n \n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    procedure Write_Node\n      (Stream : access Root_Stream_Type'Class;\n       Node   : Node_Access);\n@@ -217,11 +219,17 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n@@ -232,7 +240,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n-\n       Position.Container := null;\n    end Delete;\n \n@@ -351,6 +358,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Position.Node.Element = null then  --  handle dangling reference\n+         raise Program_Error;\n+      end if;\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -370,6 +387,21 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null  --  handle dangling cursor reference\n+        or else Right.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Elements\n                (Left.Node.Element.all,\n                 Right.Node.Element.all);\n@@ -378,12 +410,32 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Left.Node.Element = null then  --  handling dangling reference\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Elements (Left.Node.Element.all, Right);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      if Right.Node.Element = null then  --  handle dangling cursor reference\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Elements (Left, Right.Node.Element.all);\n    end Equivalent_Elements;\n \n@@ -520,6 +572,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          return;\n       end if;\n \n+      X.Next := X;  --  detect mischief (in Vet)\n+\n       begin\n          Free_Element (X.Element);\n       exception\n@@ -538,12 +592,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ---------------\n@@ -597,7 +647,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       function New_Node (Next : Node_Access) return Node_Access;\n       pragma Inline (New_Node);\n \n-      procedure Insert is\n+      procedure Local_Insert is\n          new Element_Keys.Generic_Conditional_Insert (New_Node);\n \n       --------------\n@@ -620,12 +670,18 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    --  Start of processing for Insert\n \n    begin\n-      if HT.Length >= HT_Ops.Capacity (HT) then\n-         --  TODO: optimize this (see a-cohase.adb)\n-         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      if HT_Ops.Capacity (HT) = 0 then\n+         HT_Ops.Reserve_Capacity (HT, 1);\n+      end if;\n+\n+      Local_Insert (HT, New_Item, Position.Node, Inserted);\n+\n+      if Inserted\n+        and then HT.Length > HT_Ops.Capacity (HT)\n+      then\n+         HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n \n-      Insert (HT, New_Item, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -763,7 +819,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Is_Empty (Container : Set) return Boolean is\n    begin\n-      return Container.Length = 0;\n+      return Container.HT.Length = 0;\n    end Is_Empty;\n \n    -----------\n@@ -833,22 +889,14 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       end Process_Node;\n \n       HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-      B  : Natural renames HT.Busy;\n \n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      --  TODO: resolve whether HT_Ops.Generic_Iteration should\n+      --  manipulate busy bit.\n \n-      B := B - 1;\n+      Iterate (HT);\n    end Iterate;\n \n    ------------\n@@ -880,11 +928,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -939,29 +992,40 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element.all;\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      HT : Hash_Table_Type renames\n-             Position.Container'Unrestricted_Access.all.HT;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+      declare\n+         HT : Hash_Table_Type renames\n+                Position.Container'Unrestricted_Access.all.HT;\n+\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n \n-      L := L - 1;\n-      B := B - 1;\n+         begin\n+            Process (Position.Node.Element.all);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -1027,13 +1091,13 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    ---------------------\n \n    procedure Replace_Element\n-     (HT      : in out Hash_Table_Type;\n-      Node    : Node_Access;\n-      Element : Element_Type)\n+     (HT       : in out Hash_Table_Type;\n+      Node     : Node_Access;\n+      New_Item : Element_Type)\n    is\n    begin\n-      if Equivalent_Elements (Node.Element.all, Element) then\n-         pragma Assert (Hash (Node.Element.all) = Hash (Element));\n+      if Equivalent_Elements (Node.Element.all, New_Item) then\n+         pragma Assert (Hash (Node.Element.all) = Hash (New_Item));\n \n          if HT.Lock > 0 then\n             raise Program_Error;\n@@ -1042,7 +1106,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          declare\n             X : Element_Access := Node.Element;\n          begin\n-            Node.Element := new Element_Type'(Element);  --  OK if fails\n+            Node.Element := new Element_Type'(New_Item);  --  OK if fails\n             Free_Element (X);\n          end;\n \n@@ -1068,7 +1132,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          function New_Node (Next : Node_Access) return Node_Access is\n          begin\n-            Node.Element := new Element_Type'(Element);  -- OK if fails\n+            Node.Element := new Element_Type'(New_Item);  -- OK if fails\n             Node.Next := Next;\n             return Node;\n          end New_Node;\n@@ -1084,7 +1148,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Attempt_Insert : begin\n             Insert\n               (HT       => HT,\n-               Key      => Element,\n+               Key      => New_Item,\n                Node     => Result,\n                Inserted => Inserted);\n          exception\n@@ -1093,7 +1157,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          end Attempt_Insert;\n \n          if Inserted then\n-            pragma Assert (Result = Node);\n             Free_Element (X);  -- Just propagate if fails\n             return;\n          end if;\n@@ -1137,22 +1200,26 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-     (Container : Set;\n+     (Container : in out Set;\n       Position  : Cursor;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n-      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unrestricted_Access) then\n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (HT, Position.Node, By);\n+      Replace_Element (Container.HT, Position.Node, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -1613,6 +1680,65 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       return (Controlled with HT => (Buckets, Length, 0, 0));\n    end Union;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Element = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         HT : Hash_Table_Type renames Position.Container.HT;\n+         X  : Node_Access;\n+\n+      begin\n+         if HT.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+         then\n+            return False;\n+         end if;\n+\n+         X := HT.Buckets (Element_Keys.Index (HT, Position.Node.Element.all));\n+\n+         for J in 1 .. HT.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = null then\n+               return False;\n+            end if;\n+\n+            if X = X.Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := X.Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------\n@@ -1714,29 +1840,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n         (Key  : Key_Type;\n          Node : Node_Access) return Boolean is\n       begin\n-         return Equivalent_Keys (Key, Node.Element.all);\n+         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element.all));\n       end Equivalent_Key_Node;\n \n-      ---------------------\n-      -- Equivalent_Keys --\n-      ---------------------\n-\n-      function Equivalent_Keys\n-        (Left  : Cursor;\n-         Right : Key_Type) return Boolean\n-      is\n-      begin\n-         return Equivalent_Keys (Right, Left.Node.Element.all);\n-      end Equivalent_Keys;\n-\n-      function Equivalent_Keys\n-        (Left  : Key_Type;\n-         Right : Cursor) return Boolean\n-      is\n-      begin\n-         return Equivalent_Keys (Left, Right.Node.Element.all);\n-      end Equivalent_Keys;\n-\n       -------------\n       -- Exclude --\n       -------------\n@@ -1775,6 +1881,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         if Position.Node.Element = null then\n+            raise Program_Error;\n+         end if;\n+\n          return Key (Position.Node.Element.all);\n       end Key;\n \n@@ -1804,20 +1920,40 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Process   : not null access\n            procedure (Element : in out Element_Type))\n       is\n-         HT : Hash_Table_Type renames Container.HT;\n+         HT   : Hash_Table_Type renames Container.HT;\n+         Indx : Hash_Type;\n \n       begin\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n          if Position.Node = null then\n             raise Constraint_Error;\n          end if;\n \n-         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         if Position.Node.Element = null\n+           or else Position.Node.Next = Position.Node\n+         then\n             raise Program_Error;\n          end if;\n \n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error;\n+         end if;\n+\n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+           or else HT.Length = 0\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         Indx := HT_Ops.Index (HT, Position.Node);\n+\n          declare\n             E : Element_Type renames Position.Node.Element.all;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n@@ -1838,16 +1974,38 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, E) then\n+            if Equivalent_Keys (K, Key (E)) then\n                pragma Assert (Hash (K) = Hash (E));\n                return;\n             end if;\n          end;\n \n+         if HT.Buckets (Indx) = Position.Node then\n+            HT.Buckets (Indx) := Position.Node.Next;\n+\n+         else\n+            declare\n+               Prev : Node_Access := HT.Buckets (Indx);\n+\n+            begin\n+               while Prev.Next /= Position.Node loop\n+                  Prev := Prev.Next;\n+\n+                  if Prev = null then\n+                     raise Program_Error;\n+                  end if;\n+               end loop;\n+\n+               Prev.Next := Position.Node.Next;\n+            end;\n+         end if;\n+\n+         HT.Length := HT.Length - 1;\n+\n          declare\n             X : Node_Access := Position.Node;\n+\n          begin\n-            HT_Ops.Delete_Node_Sans_Free (HT, X);\n             Free (X);\n          end;\n "}, {"sha": "4ecca1ca0bfce6d8ebdfbd88815938ca6d72b4a7", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -49,8 +49,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Indefinite_Hashed_Sets is\n-\n-   pragma Preelaborate (Indefinite_Hashed_Sets);\n+   pragma Preelaborate;\n \n    type Set is tagged private;\n \n@@ -64,6 +63,12 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function Capacity (Container : Set) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type);\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -72,15 +77,15 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n    procedure Move\n      (Target : in out Set;\n       Source : in out Set);\n@@ -97,37 +102,11 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type);\n \n-   procedure Delete  (Container : in out Set; Item : Element_Type);\n-\n-   procedure Delete (Container : in out Set; Position  : in out Cursor);\n-\n    procedure Exclude (Container : in out Set; Item : Element_Type);\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function First (Container : Set) return Cursor;\n-\n-   function Next (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   function Has_Element (Position : Cursor) return Boolean;\n-\n-   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n-\n-   function Equivalent_Elements\n-     (Left  : Cursor;\n-      Right : Element_Type) return Boolean;\n-\n-   function Equivalent_Elements\n-     (Left  : Element_Type;\n-      Right : Cursor) return Boolean;\n+   procedure Delete  (Container : in out Set; Item : Element_Type);\n \n-   procedure Iterate\n-     (Container : Set;\n-      Process   : not null access procedure (Position : Cursor));\n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n \n    procedure Union (Target : in out Set; Source : Set);\n \n@@ -158,55 +137,66 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Capacity (Container : Set) return Count_Type;\n+   function First (Container : Set) return Cursor;\n \n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type);\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n \n    generic\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n       with function Hash (Key : Key_Type) return Hash_Type;\n \n-      with function Equivalent_Keys\n-        (Key     : Key_Type;\n-         Element : Element_Type) return Boolean;\n+      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    package Generic_Keys is\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n-\n       function Key (Position : Cursor) return Key_Type;\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Replace\n+      procedure Replace           -- TODO: ask Randy why this is still here\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);\n \n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n-      procedure Exclude (Container : in out Set; Key : Key_Type);\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n \n-      function Equivalent_Keys\n-        (Left  : Cursor;\n-         Right : Key_Type) return Boolean;\n-\n-      function Equivalent_Keys\n-        (Left  : Key_Type;\n-         Right : Cursor) return Boolean;\n    end Generic_Keys;\n \n private"}, {"sha": "2de8cda37e34d684e755f06ad3054f8bfc22adbe", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -369,6 +369,21 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Position.Node.Element.all;\n    end Element;\n \n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n    ---------------------\n    -- Equivalent_Sets --\n    ---------------------\n@@ -528,34 +543,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ---------\n-      -- \"<\" --\n-      ---------\n-\n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left < Right.Node.Element.all;\n-      end \"<\";\n-\n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right > Left.Node.Element.all;\n-      end \"<\";\n-\n-      ---------\n-      -- \">\" --\n-      ---------\n-\n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left > Right.Node.Element.all;\n-      end \">\";\n-\n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right < Left.Node.Element.all;\n-      end \">\";\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -609,6 +596,21 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          return Node.Element.all;\n       end Element;\n \n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n       -------------\n       -- Exclude --\n       -------------\n@@ -663,7 +665,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n         (Left  : Key_Type;\n          Right : Node_Access) return Boolean is\n       begin\n-         return Left > Right.Element.all;\n+         return Key (Right.Element.all) < Left;\n       end Is_Greater_Key_Node;\n \n       ----------------------\n@@ -674,7 +676,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n         (Left  : Key_Type;\n          Right : Node_Access) return Boolean is\n       begin\n-         return Left < Right.Element.all;\n+         return Left < Key (Right.Element.all);\n       end Is_Less_Key_Node;\n \n       ---------\n@@ -728,7 +730,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n          declare\n             E : Element_Type renames Position.Node.Element.all;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n@@ -749,11 +751,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if K < E\n-              or else K > E\n-            then\n-               null;\n-            else\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -1365,12 +1363,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-    (Container : Set;\n+    (Container : in out Set;\n      Position  : Cursor;\n-     By        : Element_Type)\n+     New_Item  : Element_Type)\n    is\n-      Tree : Tree_Type renames Position.Container.Tree'Unrestricted_Access.all;\n-\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n@@ -1380,7 +1376,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (Tree, Position.Node, By);\n+      Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n    ---------------------"}, {"sha": "763496000604aeca9fcc889f6143d2b73794843c", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -45,7 +45,9 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Indefinite_Ordered_Sets is\n-pragma Preelaborate (Indefinite_Ordered_Sets);\n+   pragma Preelaborate;\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n    type Set is tagged private;\n \n@@ -67,15 +69,15 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;   --  TODO: need ruling from ARG\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -96,6 +98,10 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n      (Container : in out Set;\n       New_Item  : Element_Type);\n \n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type);\n@@ -108,10 +114,6 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    procedure Delete_Last (Container : in out Set);\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type);\n-\n    procedure Union (Target : in out Set; Source : Set);\n \n    function Union (Left, Right : Set) return Set;\n@@ -124,8 +126,7 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n-   procedure Difference (Target : in out Set;\n-                         Source : Set);\n+   procedure Difference (Target : in out Set; Source : Set);\n \n    function Difference (Left, Right : Set) return Set;\n \n@@ -141,14 +142,6 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Floor (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n-\n    function First (Container : Set) return Cursor;\n \n    function First_Element (Container : Set) return Element_Type;\n@@ -165,6 +158,14 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -188,21 +189,28 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n       Process   : not null access procedure (Position : Cursor));\n \n    generic\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n-      with function \"<\" (Left : Key_Type; Right : Element_Type)\n-          return Boolean is <>;\n-\n-      with function \">\" (Left : Key_Type; Right : Element_Type)\n-          return Boolean is <>;\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n \n    package Generic_Keys is\n \n-      function Contains\n-        (Container : Set;\n-         Key       : Key_Type) return Boolean;\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+      function Key (Position : Cursor) return Key_Type;\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n \n       function Find\n         (Container : Set;\n@@ -216,28 +224,9 @@ pragma Preelaborate (Indefinite_Ordered_Sets);\n         (Container : Set;\n          Key       : Key_Type) return Cursor;\n \n-      function Key (Position : Cursor) return Key_Type;\n-\n-      function Element\n+      function Contains\n         (Container : Set;\n-         Key       : Key_Type) return Element_Type;\n-\n-      procedure Replace\n-        (Container : in out Set;  --  TODO: need ruling from ARG\n-         Key       : Key_Type;\n-         New_Item  : Element_Type);\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type);\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type);\n-\n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n-\n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n-\n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n-\n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+         Key       : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;"}, {"sha": "1a165499f9078293f0a57892ba1c29af730b4b2a", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 135, "deletions": 94, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -188,16 +188,16 @@ package body Ada.Containers.Hashed_Maps is\n \n    procedure Delete (Container : in out Map; Position : in out Cursor) is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Map_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      pragma Assert (Position.Node.Next /= Position.Node);\n-\n       if Container.HT.Busy > 0 then\n          raise Program_Error;\n       end if;\n@@ -213,14 +213,24 @@ package body Ada.Containers.Hashed_Maps is\n    -------------\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      C : constant Cursor := Find (Container, Key);\n+      Node : constant Node_Access := Key_Ops.Find (Container.HT, Key);\n+\n    begin\n-      return C.Node.Element;\n+      if Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      return Node.Element;\n    end Element;\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      pragma Assert (Vet (Position));\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -242,20 +252,37 @@ package body Ada.Containers.Hashed_Maps is\n    function Equivalent_Keys (Left, Right : Cursor)\n      return Boolean is\n    begin\n-      pragma Assert (Vet (Left));\n-      pragma Assert (Vet (Right));\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key, Right.Node.Key);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n-      pragma Assert (Vet (Left));\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key, Right);\n    end Equivalent_Keys;\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n-      pragma Assert (Vet (Right));\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left, Right.Node.Key);\n    end Equivalent_Keys;\n \n@@ -352,13 +379,8 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      pragma Assert (Vet (Position));\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ---------------\n@@ -435,25 +457,18 @@ package body Ada.Containers.Hashed_Maps is\n    --  Start of processing for Insert\n \n    begin\n-      if HT.Length >= HT_Ops.Capacity (HT) then\n+      if HT_Ops.Capacity (HT) = 0 then\n+         HT_Ops.Reserve_Capacity (HT, 1);\n+      end if;\n \n-         --  TODO: 17 Apr 2005\n-         --  We should defer the expansion until we're sure that the\n-         --  element was successfully inserted.  We can do that by\n-         --  first performing the insertion attempt, and allowing the\n-         --  invariant len <= cap to be violated temporarily.  After\n-         --  the insertion we can restore the invariant.  The\n-         --  worst that can happen is that the insertion succeeds\n-         --  (new element is added to the map), but the\n-         --  invariant is broken (len > cap).  But it's only\n-         --  broken by a little (since len = cap + 1), so the\n-         --  effect is benign.\n-         --  END TODO.\n+      Local_Insert (HT, Key, Position.Node, Inserted);\n \n-         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      if Inserted\n+        and then HT.Length > HT_Ops.Capacity (HT)\n+      then\n+         HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n \n-      Local_Insert (HT, Key, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -485,12 +500,18 @@ package body Ada.Containers.Hashed_Maps is\n    --  Start of processing for Insert\n \n    begin\n-      if HT.Length >= HT_Ops.Capacity (HT) then\n-         --  TODO: see note above.\n-         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      if HT_Ops.Capacity (HT) = 0 then\n+         HT_Ops.Reserve_Capacity (HT, 1);\n       end if;\n \n       Local_Insert (HT, Key, Position.Node, Inserted);\n+\n+      if Inserted\n+        and then HT.Length > HT_Ops.Capacity (HT)\n+      then\n+         HT_Ops.Reserve_Capacity (HT, HT.Length);\n+      end if;\n+\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -553,7 +574,12 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Key (Position : Cursor) return Key_Type is\n    begin\n-      pragma Assert (Vet (Position));\n+      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Position.Node.Key;\n    end Key;\n \n@@ -589,16 +615,15 @@ package body Ada.Containers.Hashed_Maps is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n       declare\n-         pragma Assert (Vet (Position));\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n-\n       begin\n          if Node = null then\n             return No_Element;\n@@ -621,34 +646,41 @@ package body Ada.Containers.Hashed_Maps is\n      (Position : Cursor;\n       Process  : not null access\n                    procedure (Key : Key_Type; Element : Element_Type))\n-\n    is\n-      pragma Assert (Vet (Position));\n-\n-      K : Key_Type renames Position.Node.Key;\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      M  : Map renames Position.Container.all;\n-      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n+      declare\n+         M  : Map renames Position.Container.all;\n+         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            K : Key_Type renames Position.Node.Key;\n+            E : Element_Type renames Position.Node.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n       end;\n-\n-      L := L - 1;\n-      B := B - 1;\n    end Query_Element;\n \n    ----------\n@@ -712,15 +744,18 @@ package body Ada.Containers.Hashed_Maps is\n    ---------------------\n \n    procedure Replace_Element (Position : Cursor; By : Element_Type) is\n-      pragma Assert (Vet (Position));\n-      E : Element_Type renames Position.Node.Element;\n-\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       if Position.Container.HT.Lock > 0 then\n          raise Program_Error;\n       end if;\n \n-      E := By;\n+      Position.Node.Element := By;\n    end Replace_Element;\n \n    ----------------------\n@@ -753,32 +788,40 @@ package body Ada.Containers.Hashed_Maps is\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : in out Element_Type))\n    is\n-      pragma Assert (Vet (Position));\n-\n-      K : Key_Type renames Position.Node.Key;\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n-      M  : Map renames Position.Container.all;\n-      HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n+      declare\n+         M  : Map renames Position.Container.all;\n+         HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (K, E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+            K : Key_Type renames Position.Node.Key;\n+            E : Element_Type renames Position.Node.Element;\n+\n+         begin\n+            Process (K, E);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n       end;\n-\n-      L := L - 1;\n-      B := B - 1;\n    end Update_Element;\n \n    ---------\n@@ -788,34 +831,32 @@ package body Ada.Containers.Hashed_Maps is\n    function Vet (Position : Cursor) return Boolean is\n    begin\n       if Position.Node = null then\n-         return False;\n+         return Position.Container = null;\n       end if;\n \n-      if Position.Node.Next = Position.Node then\n+      if Position.Container = null then\n          return False;\n       end if;\n \n-      if Position.Container = null then\n+      if Position.Node.Next = Position.Node then\n          return False;\n       end if;\n \n       declare\n          HT : Hash_Table_Type renames Position.Container.HT;\n          X  : Node_Access;\n+\n       begin\n          if HT.Length = 0 then\n             return False;\n          end if;\n \n-         if HT.Buckets = null then\n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+         then\n             return False;\n          end if;\n \n---       NOTE: see notes in Insert.\n---       if HT.Length > HT.Buckets'Length then\n---          return False;\n---       end if;\n-\n          X := HT.Buckets (Key_Ops.Index (HT, Position.Node.Key));\n \n          for J in 1 .. HT.Length loop\n@@ -827,7 +868,7 @@ package body Ada.Containers.Hashed_Maps is\n                return False;\n             end if;\n \n-            if X = X.Next then  --  weird\n+            if X = X.Next then  --  to prevent endless loop\n                return False;\n             end if;\n "}, {"sha": "05a2416c7b5af4e829890a4da53ef66886130007", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 210, "deletions": 93, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -67,6 +67,8 @@ package body Ada.Containers.Hashed_Sets is\n      (R_HT   : Hash_Table_Type;\n       L_Node : Node_Access) return Boolean;\n \n+   procedure Free (X : in out Node_Access);\n+\n    function Hash_Node (Node : Node_Access) return Hash_Type;\n    pragma Inline (Hash_Node);\n \n@@ -83,13 +85,15 @@ package body Ada.Containers.Hashed_Sets is\n    pragma Inline (Read_Node);\n \n    procedure Replace_Element\n-     (HT      : in out Hash_Table_Type;\n-      Node    : Node_Access;\n-      Element : Element_Type);\n+     (HT       : in out Hash_Table_Type;\n+      Node     : Node_Access;\n+      New_Item : Element_Type);\n \n    procedure Set_Next (Node : Node_Access; Next : Node_Access);\n    pragma Inline (Set_Next);\n \n+   function Vet (Position : Cursor) return Boolean;\n+\n    procedure Write_Node\n      (Stream : access Root_Stream_Type'Class;\n       Node   : Node_Access);\n@@ -99,9 +103,6 @@ package body Ada.Containers.Hashed_Sets is\n    -- Local Instantiations --\n    --------------------------\n \n-   procedure Free is\n-      new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    package HT_Ops is\n       new Hash_Tables.Generic_Operations\n        (HT_Types  => HT_Types,\n@@ -211,11 +212,13 @@ package body Ada.Containers.Hashed_Sets is\n       Position  : in out Cursor)\n    is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n@@ -226,7 +229,6 @@ package body Ada.Containers.Hashed_Sets is\n       HT_Ops.Delete_Node_Sans_Free (Container.HT, Position.Node);\n \n       Free (Position.Node);\n-\n       Position.Container := null;\n    end Delete;\n \n@@ -345,6 +347,12 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Position.Node.Element;\n    end Element;\n \n@@ -364,18 +372,39 @@ package body Ada.Containers.Hashed_Sets is\n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null\n+        or else Right.Node = null\n+      then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Elements (Left.Node.Element, Right.Node.Element);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Keys\");\n+\n+      if Left.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Elements (Left.Node.Element, Right);\n    end Equivalent_Elements;\n \n    function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n      return Boolean is\n    begin\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Keys\");\n+\n+      if Right.Node = null then\n+         raise Constraint_Error;\n+      end if;\n+\n       return Equivalent_Elements (Left, Right.Node.Element);\n    end Equivalent_Elements;\n \n@@ -499,18 +528,29 @@ package body Ada.Containers.Hashed_Sets is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end First;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (X : in out Node_Access) is\n+      procedure Deallocate is\n+         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n+   begin\n+      if X /= null then\n+         X.Next := X;     --  detect mischief (in Vet)\n+         Deallocate (X);\n+      end if;\n+   end Free;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n \n    function Has_Element (Position : Cursor) return Boolean is\n    begin\n-      if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n-         return False;\n-      end if;\n-\n-      return True;\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= null;\n    end Has_Element;\n \n    ---------------\n@@ -576,18 +616,18 @@ package body Ada.Containers.Hashed_Sets is\n    --  Start of processing for Insert\n \n    begin\n-      if HT.Length >= HT_Ops.Capacity (HT) then\n+      if HT_Ops.Capacity (HT) = 0 then\n+         HT_Ops.Reserve_Capacity (HT, 1);\n+      end if;\n \n-         --  TODO:\n-         --  Perform the insertion first, and then reserve\n-         --  capacity, but only if the insertion succeeds and\n-         --  the (new) length is greater then current capacity.\n-         --  END TODO.\n+      Local_Insert (HT, New_Item, Position.Node, Inserted);\n \n-         HT_Ops.Reserve_Capacity (HT, HT.Length + 1);\n+      if Inserted\n+        and then HT.Length > HT_Ops.Capacity (HT)\n+      then\n+         HT_Ops.Reserve_Capacity (HT, HT.Length);\n       end if;\n \n-      Local_Insert (HT, New_Item, Position.Node, Inserted);\n       Position.Container := Container'Unchecked_Access;\n    end Insert;\n \n@@ -725,7 +765,7 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Is_Empty (Container : Set) return Boolean is\n    begin\n-      return Container.Length = 0;\n+      return Container.HT.Length = 0;\n    end Is_Empty;\n \n    -----------\n@@ -790,23 +830,13 @@ package body Ada.Containers.Hashed_Sets is\n          Process (Cursor'(Container'Unrestricted_Access, Node));\n       end Process_Node;\n \n-      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-      B  : Natural renames HT.Busy;\n-\n    --  Start of processing for Iterate\n \n    begin\n-      B := B + 1;\n-\n-      begin\n-         Iterate (HT);\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n+      --  TODO: resolve whether HT_Ops.Generic_Iteration should\n+      --  manipulate busy bit.\n \n-      B := B - 1;\n+      Iterate (Container.HT);\n    end Iterate;\n \n    ------------\n@@ -838,8 +868,9 @@ package body Ada.Containers.Hashed_Sets is\n \n    function Next (Position : Cursor) return Cursor is\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n       if Position.Node = null then\n-         pragma Assert (Position.Container = null);\n          return No_Element;\n       end if;\n \n@@ -896,28 +927,35 @@ package body Ada.Containers.Hashed_Sets is\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n-      E : Element_Type renames Position.Node.Element;\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      HT : Hash_Table_Type renames Position.Container.HT;\n+      if Position.Node = null then\n+         raise Constraint_Error;\n+      end if;\n \n-      B : Natural renames HT.Busy;\n-      L : Natural renames HT.Lock;\n+      declare\n+         HT : Hash_Table_Type renames Position.Container.HT;\n \n-   begin\n-      B := B + 1;\n-      L := L + 1;\n+         B : Natural renames HT.Busy;\n+         L : Natural renames HT.Lock;\n \n       begin\n-         Process (E);\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (Position.Node.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n \n-      L := L - 1;\n-      B := B - 1;\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n    end Query_Element;\n \n    ----------\n@@ -955,7 +993,7 @@ package body Ada.Containers.Hashed_Sets is\n    -------------\n \n    procedure Replace\n-     (Container : in out Set;    --  TODO: need ruling from ARG\n+     (Container : in out Set;\n       New_Item  : Element_Type)\n    is\n       Node : constant Node_Access :=\n@@ -978,19 +1016,19 @@ package body Ada.Containers.Hashed_Sets is\n    ---------------------\n \n    procedure Replace_Element\n-     (HT      : in out Hash_Table_Type;\n-      Node    : Node_Access;\n-      Element : Element_Type)\n+     (HT       : in out Hash_Table_Type;\n+      Node     : Node_Access;\n+      New_Item : Element_Type)\n    is\n    begin\n-      if Equivalent_Elements (Node.Element, Element) then\n-         pragma Assert (Hash (Node.Element) = Hash (Element));\n+      if Equivalent_Elements (Node.Element, New_Item) then\n+         pragma Assert (Hash (Node.Element) = Hash (New_Item));\n \n          if HT.Lock > 0 then\n             raise Program_Error;\n          end if;\n \n-         Node.Element := Element;  --  Note that this assignment can fail\n+         Node.Element := New_Item;  --  Note that this assignment can fail\n          return;\n       end if;\n \n@@ -1013,7 +1051,7 @@ package body Ada.Containers.Hashed_Sets is\n \n          function New_Node (Next : Node_Access) return Node_Access is\n          begin\n-            Node.Element := Element;  -- Note that this assignment can fail\n+            Node.Element := New_Item;  -- Note that this assignment can fail\n             Node.Next := Next;\n             return Node;\n          end New_Node;\n@@ -1026,12 +1064,11 @@ package body Ada.Containers.Hashed_Sets is\n       begin\n          Local_Insert\n            (HT       => HT,\n-            Key      => Element,\n+            Key      => New_Item,\n             Node     => Result,\n             Inserted => Inserted);\n \n          if Inserted then\n-            pragma Assert (Result = Node);\n             return;\n          end if;\n       exception\n@@ -1076,22 +1113,22 @@ package body Ada.Containers.Hashed_Sets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-     (Container : Set;\n+     (Container : in out Set;\n       Position  : Cursor;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n-      HT : Hash_Table_Type renames Container'Unrestricted_Access.all.HT;\n-\n    begin\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n       if Position.Node = null then\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Set_Access'(Container'Unrestricted_Access) then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (HT, Position.Node, By);\n+      Replace_Element (Container.HT, Position.Node, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -1491,6 +1528,61 @@ package body Ada.Containers.Hashed_Sets is\n       return (Controlled with HT => (Buckets, Length, 0, 0));\n    end Union;\n \n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = null then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      if Position.Node.Next = Position.Node then\n+         return False;\n+      end if;\n+\n+      declare\n+         HT : Hash_Table_Type renames Position.Container.HT;\n+         X  : Node_Access;\n+\n+      begin\n+         if HT.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+         then\n+            return False;\n+         end if;\n+\n+         X := HT.Buckets (Element_Keys.Index (HT, Position.Node.Element));\n+\n+         for J in 1 .. HT.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = null then\n+               return False;\n+            end if;\n+\n+            if X = X.Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := X.Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n    -----------\n    -- Write --\n    -----------\n@@ -1594,27 +1686,9 @@ package body Ada.Containers.Hashed_Sets is\n          Node : Node_Access) return Boolean\n       is\n       begin\n-         return Equivalent_Keys (Key, Node.Element);\n+         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n       end Equivalent_Key_Node;\n \n-      ---------------------\n-      -- Equivalent_Keys --\n-      ---------------------\n-\n-      function Equivalent_Keys\n-        (Left  : Cursor;\n-         Right : Key_Type) return Boolean is\n-      begin\n-         return Equivalent_Keys (Right, Left.Node.Element);\n-      end Equivalent_Keys;\n-\n-      function Equivalent_Keys\n-        (Left  : Key_Type;\n-         Right : Cursor) return Boolean is\n-      begin\n-         return Equivalent_Keys (Left, Right.Node.Element);\n-      end Equivalent_Keys;\n-\n       -------------\n       -- Exclude --\n       -------------\n@@ -1654,6 +1728,12 @@ package body Ada.Containers.Hashed_Sets is\n \n       function Key (Position : Cursor) return Key_Type is\n       begin\n+         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+         if Position.Node = null then\n+            raise Constraint_Error;\n+         end if;\n+\n          return Key (Position.Node.Element);\n       end Key;\n \n@@ -1687,20 +1767,35 @@ package body Ada.Containers.Hashed_Sets is\n          Process   : not null access\n                        procedure (Element : in out Element_Type))\n       is\n-         HT : Hash_Table_Type renames Container.HT;\n+         HT   : Hash_Table_Type renames Container.HT;\n+         Indx : Hash_Type;\n \n       begin\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n          if Position.Node = null then\n             raise Constraint_Error;\n          end if;\n \n-         if Position.Container /= Set_Access'(Container'Unchecked_Access) then\n+         if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error;\n          end if;\n \n+         if HT.Buckets = null\n+           or else HT.Buckets'Length = 0\n+           or else HT.Length = 0\n+           or else Position.Node.Next = Position.Node\n+         then\n+            raise Program_Error;\n+         end if;\n+\n+         Indx := HT_Ops.Index (HT, Position.Node);\n+\n          declare\n             E : Element_Type renames Position.Node.Element;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames HT.Busy;\n             L : Natural renames HT.Lock;\n@@ -1721,16 +1816,38 @@ package body Ada.Containers.Hashed_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if Equivalent_Keys (K, E) then\n+            if Equivalent_Keys (K, Key (E)) then\n                pragma Assert (Hash (K) = Hash (E));\n                return;\n             end if;\n          end;\n \n+         if HT.Buckets (Indx) = Position.Node then\n+            HT.Buckets (Indx) := Position.Node.Next;\n+\n+         else\n+            declare\n+               Prev : Node_Access := HT.Buckets (Indx);\n+\n+            begin\n+               while Prev.Next /= Position.Node loop\n+                  Prev := Prev.Next;\n+\n+                  if Prev = null then\n+                     raise Program_Error;\n+                  end if;\n+               end loop;\n+\n+               Prev.Next := Position.Node.Next;\n+            end;\n+         end if;\n+\n+         HT.Length := HT.Length - 1;\n+\n          declare\n             X : Node_Access := Position.Node;\n+\n          begin\n-            HT_Ops.Delete_Node_Sans_Free (HT, X);\n             Free (X);\n          end;\n "}, {"sha": "e4734c885cc1202a95482ced8c34edaabba64366", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -48,7 +48,7 @@ generic\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Hashed_Sets is\n-pragma Preelaborate (Hashed_Sets);\n+   pragma Preelaborate;\n \n    type Set is tagged private;\n \n@@ -62,6 +62,12 @@ pragma Preelaborate (Hashed_Sets);\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n \n+   function Capacity (Container : Set) return Count_Type;\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type);\n+\n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n@@ -70,15 +76,15 @@ pragma Preelaborate (Hashed_Sets);\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n    procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n@@ -93,39 +99,11 @@ pragma Preelaborate (Hashed_Sets);\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type);\n \n-   procedure Delete  (Container : in out Set; Item     : Element_Type);\n-\n-   procedure Delete (Container : in out Set; Position  : in out Cursor);\n-\n    procedure Exclude (Container : in out Set; Item     : Element_Type);\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor;\n-\n-   function First (Container : Set) return Cursor;\n-\n-   function Next (Position : Cursor) return Cursor;\n-\n-   procedure Next (Position : in out Cursor);\n-\n-   function Has_Element (Position : Cursor) return Boolean;\n-\n-   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n-\n-   function Equivalent_Elements\n-     (Left  : Cursor;\n-      Right : Element_Type) return Boolean;\n-\n-   function Equivalent_Elements\n-     (Left  : Element_Type;\n-      Right : Cursor) return Boolean;\n+   procedure Delete  (Container : in out Set; Item     : Element_Type);\n \n-   procedure Iterate\n-     (Container : Set;\n-      Process   : not null access procedure (Position : Cursor));\n+   procedure Delete (Container : in out Set; Position  : in out Cursor);\n \n    procedure Union (Target : in out Set; Source : Set);\n \n@@ -156,60 +134,71 @@ pragma Preelaborate (Hashed_Sets);\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Capacity (Container : Set) return Count_Type;\n+   function First (Container : Set) return Cursor;\n \n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type);\n+   function Next (Position : Cursor) return Cursor;\n+\n+   procedure Next (Position : in out Cursor);\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n \n    generic\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n       with function Hash (Key : Key_Type) return Hash_Type;\n \n-      with function Equivalent_Keys\n-        (Key     : Key_Type;\n-         Element : Element_Type) return Boolean;\n+      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n    package Generic_Keys is\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n-\n       function Key (Position : Cursor) return Key_Type;\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n-      procedure Replace\n+      procedure Replace          --  TODO: ask Randy why this wasn't removed\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);\n \n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+\n       procedure Delete (Container : in out Set; Key : Key_Type);\n \n-      procedure Exclude (Container : in out Set; Key : Key_Type);\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n \n-      function Equivalent_Keys\n-        (Left  : Cursor;\n-         Right : Key_Type) return Boolean;\n-\n-      function Equivalent_Keys\n-        (Left  : Key_Type;\n-         Right : Cursor) return Boolean;\n-\n    end Generic_Keys;\n \n private\n-\n    type Node_Type;\n    type Node_Access is access Node_Type;\n "}, {"sha": "04652f80444911a79ff69d7918124e296567922c", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -359,6 +359,21 @@ package body Ada.Containers.Ordered_Sets is\n       return Position.Node.Element;\n    end Element;\n \n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n+   begin\n+      if Left < Right\n+        or else Right < Left\n+      then\n+         return False;\n+      else\n+         return True;\n+      end if;\n+   end Equivalent_Elements;\n+\n    ---------------------\n    -- Equivalent_Sets --\n    ---------------------\n@@ -490,34 +505,6 @@ package body Ada.Containers.Ordered_Sets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n-      ---------\n-      -- \"<\" --\n-      ---------\n-\n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left < Right.Node.Element;\n-      end \"<\";\n-\n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right > Left.Node.Element;\n-      end \"<\";\n-\n-      ---------\n-      -- \">\" --\n-      ---------\n-\n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n-      begin\n-         return Left > Right.Node.Element;\n-      end \">\";\n-\n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n-      begin\n-         return Right < Left.Node.Element;\n-      end \">\";\n-\n       -------------\n       -- Ceiling --\n       -------------\n@@ -573,6 +560,21 @@ package body Ada.Containers.Ordered_Sets is\n          return Node.Element;\n       end Element;\n \n+      ---------------------\n+      -- Equivalent_Keys --\n+      ---------------------\n+\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n+      begin\n+         if Left < Right\n+           or else Right < Left\n+         then\n+            return False;\n+         else\n+            return True;\n+         end if;\n+      end Equivalent_Keys;\n+\n       -------------\n       -- Exclude --\n       -------------\n@@ -626,7 +628,7 @@ package body Ada.Containers.Ordered_Sets is\n          Right : Node_Access) return Boolean\n       is\n       begin\n-         return Left > Right.Element;\n+         return Key (Right.Element) < Left;\n       end Is_Greater_Key_Node;\n \n       ----------------------\n@@ -638,7 +640,7 @@ package body Ada.Containers.Ordered_Sets is\n          Right : Node_Access) return Boolean\n       is\n       begin\n-         return Left < Right.Element;\n+         return Left < Key (Right.Element);\n       end Is_Less_Key_Node;\n \n       ---------\n@@ -691,7 +693,7 @@ package body Ada.Containers.Ordered_Sets is\n \n          declare\n             E : Element_Type renames Position.Node.Element;\n-            K : Key_Type renames Key (E);\n+            K : constant Key_Type := Key (E);\n \n             B : Natural renames Tree.Busy;\n             L : Natural renames Tree.Lock;\n@@ -712,11 +714,7 @@ package body Ada.Containers.Ordered_Sets is\n             L := L - 1;\n             B := B - 1;\n \n-            if K < E\n-              or else K > E\n-            then\n-               null;\n-            else\n+            if Equivalent_Keys (K, Key (E)) then\n                return;\n             end if;\n          end;\n@@ -1319,12 +1317,10 @@ package body Ada.Containers.Ordered_Sets is\n    end Replace_Element;\n \n    procedure Replace_Element\n-     (Container : Set;\n+     (Container : in out Set;\n       Position  : Cursor;\n-      By        : Element_Type)\n+      New_Item  : Element_Type)\n    is\n-      Tree : Tree_Type renames Container.Tree'Unrestricted_Access.all;\n-\n    begin\n       if Position.Node = null then\n          raise Constraint_Error;\n@@ -1334,7 +1330,7 @@ package body Ada.Containers.Ordered_Sets is\n          raise Program_Error;\n       end if;\n \n-      Replace_Element (Tree, Position.Node, By);\n+      Replace_Element (Container.Tree, Position.Node, New_Item);\n    end Replace_Element;\n \n    ---------------------"}, {"sha": "db5cfe5eae6098f5ca6343aed998bbb4d26ceca3", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba355842e8ff8cbcb8552b99f6098b333512cc81/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=ba355842e8ff8cbcb8552b99f6098b333512cc81", "patch": "@@ -38,14 +38,15 @@ with Ada.Finalization;\n with Ada.Streams;\n \n generic\n-\n    type Element_Type is private;\n \n    with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n \n package Ada.Containers.Ordered_Sets is\n-pragma Preelaborate (Ordered_Sets);\n+   pragma Preelaborate;\n+\n+   function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n    type Set is tagged private;\n \n@@ -67,18 +68,16 @@ pragma Preelaborate (Ordered_Sets);\n \n    function Element (Position : Cursor) return Element_Type;\n \n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+\n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n \n-   procedure Replace_Element\n-     (Container : Set;  --  TODO: need ARG ruling\n-      Position  : Cursor;\n-      By        : Element_Type);\n-\n-   procedure Move\n-     (Target : in out Set;\n-      Source : in out Set);\n+   procedure Move (Target : in out Set; Source : in out Set);\n \n    procedure Insert\n      (Container : in out Set;\n@@ -95,9 +94,13 @@ pragma Preelaborate (Ordered_Sets);\n       New_Item  : Element_Type);\n \n    procedure Replace\n-     (Container : in out Set;  --  TODO: need ARG ruling\n+     (Container : in out Set;\n       New_Item  : Element_Type);\n \n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type);\n+\n    procedure Delete\n      (Container : in out Set;\n       Item      : Element_Type);\n@@ -110,10 +113,6 @@ pragma Preelaborate (Ordered_Sets);\n \n    procedure Delete_Last (Container : in out Set);\n \n-   procedure Exclude\n-     (Container : in out Set;\n-      Item      : Element_Type);\n-\n    procedure Union (Target : in out Set; Source : Set);\n \n    function Union (Left, Right : Set) return Set;\n@@ -126,8 +125,7 @@ pragma Preelaborate (Ordered_Sets);\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n-   procedure Difference (Target : in out Set;\n-                         Source : Set);\n+   procedure Difference (Target : in out Set; Source : Set);\n \n    function Difference (Left, Right : Set) return Set;\n \n@@ -143,14 +141,6 @@ pragma Preelaborate (Ordered_Sets);\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n-   function Contains (Container : Set; Item : Element_Type) return Boolean;\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Floor (Container : Set; Item : Element_Type) return Cursor;\n-\n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n-\n    function First (Container : Set) return Cursor;\n \n    function First_Element (Container : Set) return Element_Type;\n@@ -167,6 +157,14 @@ pragma Preelaborate (Ordered_Sets);\n \n    procedure Previous (Position : in out Cursor);\n \n+   function Find (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Floor (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Ceiling (Container : Set; Item : Element_Type) return Cursor;\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+\n    function Has_Element (Position : Cursor) return Boolean;\n \n    function \"<\" (Left, Right : Cursor) return Boolean;\n@@ -190,48 +188,36 @@ pragma Preelaborate (Ordered_Sets);\n       Process   : not null access procedure (Position : Cursor));\n \n    generic\n-      type Key_Type (<>) is limited private;\n+      type Key_Type (<>) is private;\n \n       with function Key (Element : Element_Type) return Key_Type;\n \n-      with function \"<\"\n-        (Left  : Key_Type;\n-         Right : Element_Type) return Boolean is <>;\n-\n-      with function \">\"\n-        (Left  : Key_Type;\n-         Right : Element_Type) return Boolean is <>;\n+      with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n \n    package Generic_Keys is\n \n-      function Contains (Container : Set; Key : Key_Type) return Boolean;\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Floor (Container : Set; Key : Key_Type) return Cursor;\n-\n-      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n+      function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n       function Key (Position : Cursor) return Key_Type;\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n \n       procedure Replace\n-        (Container : in out Set;  --  TODO: need ARG ruling\n+        (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);\n \n-      procedure Delete (Container : in out Set; Key : Key_Type);\n-\n       procedure Exclude (Container : in out Set; Key : Key_Type);\n \n-      function \"<\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \">\" (Left : Cursor; Right : Key_Type) return Boolean;\n+      function Floor (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \"<\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Ceiling (Container : Set; Key : Key_Type) return Cursor;\n \n-      function \">\" (Left : Key_Type; Right : Cursor) return Boolean;\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;"}]}