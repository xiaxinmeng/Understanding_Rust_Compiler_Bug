{"sha": "255b2d916ec794078cfd0c351d3e921f8701142a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU1YjJkOTE2ZWM3OTQwNzhjZmQwYzM1MWQzZTkyMWY4NzAxMTQyYQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2019-01-21T21:16:06Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-01-21T21:16:06Z"}, "message": "Merge dmd upstream 180465274\n\nReduces the memory footprint of the CTFE interpreter by replacing new\nwith emplacement new in many places.\n\ngcc/d/ChangeLog:\n\n2019-01-21  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* d-frontend.cc (Compiler::paintAsType): Update for new signature.\n\nFrom-SVN: r268124", "tree": {"sha": "3dee0722fb17b5496011bd698f924c31f5e56833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dee0722fb17b5496011bd698f924c31f5e56833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/255b2d916ec794078cfd0c351d3e921f8701142a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255b2d916ec794078cfd0c351d3e921f8701142a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255b2d916ec794078cfd0c351d3e921f8701142a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255b2d916ec794078cfd0c351d3e921f8701142a/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d50114960965a85deb3ba6a19ac4f7640ed97e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50114960965a85deb3ba6a19ac4f7640ed97e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50114960965a85deb3ba6a19ac4f7640ed97e7e"}], "stats": {"total": 826, "additions": 502, "deletions": 324}, "files": [{"sha": "7014b215f5a6415adab857b8b6dae5cb5077e566", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -1,3 +1,7 @@\n+2019-01-21  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* d-frontend.cc (Compiler::paintAsType): Update for new signature.\n+\n 2019-01-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* d-builtins.cc (d_init_versions): Check value of"}, {"sha": "d1d3c78ec8653072124b1b19de2fcffda2b3f4a7", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -446,7 +446,7 @@ Compiler::genCmain (Scope *sc)\n    so we just lower the value to GCC and return the converted CST.  */\n \n Expression *\n-Compiler::paintAsType (Expression *expr, Type *type)\n+Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n {\n   /* We support up to 512-bit values.  */\n   unsigned char buffer[64];"}, {"sha": "e8ab8df4f7bfe43028d83b4dce756bc917ea18d2", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -1,4 +1,4 @@\n-cd2034cd7b157dd8f3e94c684061bb1aa630b2b6\n+180465274b72a2ff218449f6793af0fbaabbcaa3\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "a8520788f989397e7ad5ae0d028c58a91dc53fc4", "filename": "gcc/d/dmd/compiler.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.h?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -19,6 +19,7 @@ class Expression;\n class Module;\n class Type;\n struct Scope;\n+struct UnionExp;\n \n // DMD-generated module `__entrypoint` where the C main resides\n extern Module *entrypoint;\n@@ -28,7 +29,7 @@ extern Module *rootHasMain;\n struct Compiler\n {\n     // CTFE support for cross-compilation.\n-    static Expression *paintAsType(Expression *, Type *);\n+    static Expression *paintAsType(UnionExp *, Expression *, Type *);\n     // Backend\n     static void loadModule(Module *);\n     static void genCmain(Scope *);"}, {"sha": "ddd356bb966a7196581dd2054f98e26e18550844", "filename": "gcc/d/dmd/constfold.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -1457,8 +1457,7 @@ UnionExp Slice(Type *type, Expression *e1, Expression *lwr, Expression *upr)\n             memcpy(elements->tdata(),\n                    es1->elements->tdata() + ilwr,\n                    (size_t)(iupr - ilwr) * sizeof((*es1->elements)[0]));\n-            new(&ue) ArrayLiteralExp(e1->loc, elements);\n-            ue.exp()->type = type;\n+            new(&ue) ArrayLiteralExp(e1->loc, type, elements);\n         }\n     }\n     else\n@@ -1606,6 +1605,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n \n             new(&ue) StringExp(loc, s, len);\n             StringExp *es = (StringExp *)ue.exp();\n+            es->type = type;\n             es->sz = sz;\n             es->committed = 1;\n         }\n@@ -1614,9 +1614,8 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n             // Create an ArrayLiteralExp\n             Expressions *elements = new Expressions();\n             elements->push(e);\n-            new(&ue) ArrayLiteralExp(e->loc, elements);\n+            new(&ue) ArrayLiteralExp(e->loc, type, elements);\n         }\n-        ue.exp()->type = type;\n         assert(ue.exp()->type);\n         return ue;\n     }\n@@ -1627,8 +1626,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n             // Handle null ~= null\n             if (t1->ty == Tarray && t2 == t1->nextOf())\n             {\n-                new(&ue) ArrayLiteralExp(e1->loc, e2);\n-                ue.exp()->type = type;\n+                new(&ue) ArrayLiteralExp(e1->loc, type, e2);\n                 assert(ue.exp()->type);\n                 return ue;\n             }\n@@ -1695,9 +1693,8 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         {\n             (*elems)[i] = ea->getElement(i);\n         }\n-        new(&ue) ArrayLiteralExp(e1->loc, elems);\n+        new(&ue) ArrayLiteralExp(e1->loc, type, elems);\n         ArrayLiteralExp *dest = (ArrayLiteralExp *)ue.exp();\n-        dest->type = type;\n         sliceAssignArrayLiteralFromString(dest, es, ea->elements->dim);\n         assert(ue.exp()->type);\n         return ue;\n@@ -1715,9 +1712,8 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         {\n             (*elems)[es->len + i] = ea->getElement(i);\n         }\n-        new(&ue) ArrayLiteralExp(e1->loc, elems);\n+        new(&ue) ArrayLiteralExp(e1->loc, type, elems);\n         ArrayLiteralExp *dest = (ArrayLiteralExp *)ue.exp();\n-        dest->type = type;\n         sliceAssignArrayLiteralFromString(dest, es, 0);\n         assert(ue.exp()->type);\n         return ue;\n@@ -1783,7 +1779,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         // Concatenate the arrays\n         Expressions *elems = ArrayLiteralExp::copyElements(e1, e2);\n \n-        new(&ue) ArrayLiteralExp(e1->loc, elems);\n+        new(&ue) ArrayLiteralExp(e1->loc, NULL, elems);\n \n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n@@ -1809,7 +1805,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         // Concatenate the array with null\n         Expressions *elems = ArrayLiteralExp::copyElements(e);\n \n-        new(&ue) ArrayLiteralExp(e->loc, elems);\n+        new(&ue) ArrayLiteralExp(e->loc, NULL, elems);\n \n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n@@ -1829,7 +1825,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n             ? ArrayLiteralExp::copyElements(e1) : new Expressions();\n         elems->push(e2);\n \n-        new(&ue) ArrayLiteralExp(e1->loc, elems);\n+        new(&ue) ArrayLiteralExp(e1->loc, NULL, elems);\n \n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n@@ -1846,7 +1842,7 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n     {\n         Expressions *elems = ArrayLiteralExp::copyElements(e1, e2);\n \n-        new(&ue) ArrayLiteralExp(e2->loc, elems);\n+        new(&ue) ArrayLiteralExp(e2->loc, NULL, elems);\n \n         e = ue.exp();\n         if (type->toBasetype()->ty == Tsarray)\n@@ -1874,9 +1870,8 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)\n         {\n             Expressions *expressions = new Expressions();\n             expressions->push(e);\n-            new(&ue) ArrayLiteralExp(loc, expressions);\n+            new(&ue) ArrayLiteralExp(loc, t, expressions);\n             e = ue.exp();\n-            e->type = t;\n         }\n         else\n         {"}, {"sha": "0e49432e1b635fbab6914abd68a7adc6e530b6dd", "filename": "gcc/d/dmd/ctfe.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fctfe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fctfe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfe.h?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -134,6 +134,7 @@ UnionExp copyLiteral(Expression *e);\n \n /// Set this literal to the given type, copying it if necessary\n Expression *paintTypeOntoLiteral(Type *type, Expression *lit);\n+Expression *paintTypeOntoLiteral(UnionExp *pue, Type *type, Expression *lit);\n UnionExp paintTypeOntoLiteralCopy(Type *type, Expression *lit);\n \n /// Convert from a CTFE-internal slice, into a normal Expression\n@@ -143,11 +144,11 @@ Expression *resolveSlice(Expression *e, UnionExp *pue = NULL);\n uinteger_t resolveArrayLength(Expression *e);\n \n /// Create an array literal consisting of 'elem' duplicated 'dim' times.\n-ArrayLiteralExp *createBlockDuplicatedArrayLiteral(Loc loc, Type *type,\n+ArrayLiteralExp *createBlockDuplicatedArrayLiteral(UnionExp *pue, Loc loc, Type *type,\n         Expression *elem, size_t dim);\n \n /// Create a string literal consisting of 'value' duplicated 'dim' times.\n-StringExp *createBlockDuplicatedStringLiteral(Loc loc, Type *type,\n+StringExp *createBlockDuplicatedStringLiteral(UnionExp *pue, Loc loc, Type *type,\n         unsigned value, size_t dim, unsigned char sz);\n \n \n@@ -209,7 +210,7 @@ UnionExp pointerArithmetic(Loc loc, TOK op, Type *type,\n bool isFloatIntPaint(Type *to, Type *from);\n \n // Reinterpret float/int value 'fromVal' as a float/integer of type 'to'.\n-Expression *paintFloatInt(Expression *fromVal, Type *to);\n+Expression *paintFloatInt(UnionExp *pue, Expression *fromVal, Type *to);\n \n /// Return true if t is an AA\n bool isAssocArray(Type *t);\n@@ -264,4 +265,4 @@ UnionExp ctfeCat(Loc loc, Type *type, Expression *e1, Expression *e2);\n Expression *ctfeIndex(Loc loc, Type *type, Expression *e1, uinteger_t indx);\n \n /// Cast 'e' of type 'type' to type 'to'.\n-Expression *ctfeCast(Loc loc, Type *type, Type *to, Expression *e);\n+Expression *ctfeCast(UnionExp *pue, Loc loc, Type *type, Type *to, Expression *e);"}, {"sha": "1050e93699ea70ec2a9c6d544a3210af5177d2b9", "filename": "gcc/d/dmd/ctfeexpr.c", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -264,10 +264,9 @@ UnionExp copyLiteral(Expression *e)\n         ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n         Expressions *elements = copyLiteralArray(ale->elements, ale->basis);\n \n-        new(&ue) ArrayLiteralExp(e->loc, elements);\n+        new(&ue) ArrayLiteralExp(e->loc, e->type, elements);\n \n         ArrayLiteralExp *r = (ArrayLiteralExp *)ue.exp();\n-        r->type = e->type;\n         r->ownedByCtfe = OWNEDctfe;\n         return ue;\n     }\n@@ -314,7 +313,10 @@ UnionExp copyLiteral(Expression *e)\n                 {\n                     TypeSArray *tsa = (TypeSArray *)v->type;\n                     size_t len = (size_t)tsa->dim->toInteger();\n-                    m = createBlockDuplicatedArrayLiteral(e->loc, v->type, m, len);\n+                    UnionExp uex;\n+                    m = createBlockDuplicatedArrayLiteral(&uex, e->loc, v->type, m, len);\n+                    if (m == uex.exp())\n+                        m = uex.copy();\n                 }\n             }\n             (*newelems)[i] = m;\n@@ -414,6 +416,14 @@ Expression *paintTypeOntoLiteral(Type *type, Expression *lit)\n     return paintTypeOntoLiteralCopy(type, lit).copy();\n }\n \n+Expression *paintTypeOntoLiteral(UnionExp *pue, Type *type, Expression *lit)\n+{\n+    if (lit->type->equals(type))\n+        return lit;\n+    *pue = paintTypeOntoLiteralCopy(type, lit);\n+    return pue->exp();\n+}\n+\n UnionExp paintTypeOntoLiteralCopy(Type *type, Expression *lit)\n {\n     UnionExp ue;\n@@ -539,22 +549,26 @@ uinteger_t resolveArrayLength(Expression *e)\n  * Helper for NewExp\n  * Create an array literal consisting of 'elem' duplicated 'dim' times.\n  * Params:\n+ *      pue = where to store result\n  *      loc = source location where the interpretation occurs\n  *      type = target type of the result\n  *      elem = the source of array element, it will be owned by the result\n  *      dim = element number of the result\n  * Returns:\n  *      Constructed ArrayLiteralExp\n  */\n-ArrayLiteralExp *createBlockDuplicatedArrayLiteral(Loc loc, Type *type,\n+ArrayLiteralExp *createBlockDuplicatedArrayLiteral(UnionExp *pue, Loc loc, Type *type,\n         Expression *elem, size_t dim)\n {\n     if (type->ty == Tsarray && type->nextOf()->ty == Tsarray && elem->type->ty != Tsarray)\n     {\n         // If it is a multidimensional array literal, do it recursively\n         TypeSArray *tsa = (TypeSArray *)type->nextOf();\n         size_t len = (size_t)tsa->dim->toInteger();\n-        elem = createBlockDuplicatedArrayLiteral(loc, type->nextOf(), elem, len);\n+        UnionExp ue;\n+        elem = createBlockDuplicatedArrayLiteral(&ue, loc, type->nextOf(), elem, len);\n+        if (elem == ue.exp())\n+            elem = ue.copy();\n     }\n \n     // Buzilla 15681\n@@ -567,8 +581,8 @@ ArrayLiteralExp *createBlockDuplicatedArrayLiteral(Loc loc, Type *type,\n     {\n         (*elements)[i] = mustCopy ? copyLiteral(elem).copy() : elem;\n     }\n-    ArrayLiteralExp *ale = new ArrayLiteralExp(loc, elements);\n-    ale->type = type;\n+    new(pue) ArrayLiteralExp(loc, type, elements);\n+    ArrayLiteralExp *ale = (ArrayLiteralExp *)pue->exp();\n     ale->ownedByCtfe = OWNEDctfe;\n     return ale;\n }\n@@ -577,7 +591,7 @@ ArrayLiteralExp *createBlockDuplicatedArrayLiteral(Loc loc, Type *type,\n  * Helper for NewExp\n  * Create a string literal consisting of 'value' duplicated 'dim' times.\n  */\n-StringExp *createBlockDuplicatedStringLiteral(Loc loc, Type *type,\n+StringExp *createBlockDuplicatedStringLiteral(UnionExp *pue, Loc loc, Type *type,\n         unsigned value, size_t dim, unsigned char sz)\n {\n     utf8_t *s = (utf8_t *)mem.xcalloc(dim + 1, sz);\n@@ -591,7 +605,8 @@ StringExp *createBlockDuplicatedStringLiteral(Loc loc, Type *type,\n             default:    assert(0);\n         }\n     }\n-    StringExp *se = new StringExp(loc, s, dim);\n+    new(pue) StringExp(loc, s, dim);\n+    StringExp *se = (StringExp *)pue->exp();\n     se->type = type;\n     se->sz = sz;\n     se->committed = true;\n@@ -984,13 +999,13 @@ bool isFloatIntPaint(Type *to, Type *from)\n }\n \n // Reinterpret float/int value 'fromVal' as a float/integer of type 'to'.\n-Expression *paintFloatInt(Expression *fromVal, Type *to)\n+Expression *paintFloatInt(UnionExp *pue, Expression *fromVal, Type *to)\n {\n     if (exceptionOrCantInterpret(fromVal))\n         return fromVal;\n \n     assert(to->size() == 4 || to->size() == 8);\n-    return Compiler::paintAsType(fromVal, to);\n+    return Compiler::paintAsType(pue, fromVal, to);\n }\n \n /******** Constant folding, with support for CTFE ***************************/\n@@ -1512,10 +1527,9 @@ UnionExp ctfeCat(Loc loc, Type *type, Expression *e1, Expression *e2)\n         ArrayLiteralExp *es1 = (ArrayLiteralExp *)e1;\n         ArrayLiteralExp *es2 = (ArrayLiteralExp *)e2;\n \n-        new(&ue) ArrayLiteralExp(es1->loc, copyLiteralArray(es1->elements));\n+        new(&ue) ArrayLiteralExp(es1->loc, type, copyLiteralArray(es1->elements));\n         es1 = (ArrayLiteralExp *)ue.exp();\n         es1->elements->insert(es1->elements->dim, copyLiteralArray(es2->elements));\n-        es1->type = type;\n         return ue;\n     }\n     if (e1->op == TOKarrayliteral && e2->op == TOKnull &&\n@@ -1587,52 +1601,62 @@ Expression *ctfeIndex(Loc loc, Type *type, Expression *e1, uinteger_t indx)\n     }\n }\n \n-Expression *ctfeCast(Loc loc, Type *type, Type *to, Expression *e)\n+Expression *ctfeCast(UnionExp *pue, Loc loc, Type *type, Type *to, Expression *e)\n {\n     if (e->op == TOKnull)\n-        return paintTypeOntoLiteral(to, e);\n+        return paintTypeOntoLiteral(pue, to, e);\n+\n     if (e->op == TOKclassreference)\n     {\n         // Disallow reinterpreting class casts. Do this by ensuring that\n         // the original class can implicitly convert to the target class\n         ClassDeclaration *originalClass = ((ClassReferenceExp *)e)->originalClass();\n         if (originalClass->type->implicitConvTo(to->mutableOf()))\n-            return paintTypeOntoLiteral(to, e);\n+            return paintTypeOntoLiteral(pue, to, e);\n         else\n-            return new NullExp(loc, to);\n+        {\n+            new(pue) NullExp(loc, to);\n+            return pue->exp();\n+        }\n     }\n+\n     // Allow TypeInfo type painting\n     if (isTypeInfo_Class(e->type) && e->type->implicitConvTo(to))\n-        return paintTypeOntoLiteral(to, e);\n+        return paintTypeOntoLiteral(pue, to, e);\n+\n     // Allow casting away const for struct literals\n     if (e->op == TOKstructliteral &&\n         e->type->toBasetype()->castMod(0) == to->toBasetype()->castMod(0))\n-    {\n-        return paintTypeOntoLiteral(to, e);\n-    }\n+        return paintTypeOntoLiteral(pue, to, e);\n \n     Expression *r;\n     if (e->type->equals(type) && type->equals(to))\n     {\n         // necessary not to change e's address for pointer comparisons\n         r = e;\n     }\n-    else if (to->toBasetype()->ty == Tarray &&     type->toBasetype()->ty == Tarray &&\n+    else if (to->toBasetype()->ty == Tarray &&\n+             type->toBasetype()->ty == Tarray &&\n              to->toBasetype()->nextOf()->size() == type->toBasetype()->nextOf()->size())\n     {\n         // Bugzilla 12495: Array reinterpret casts: eg. string to immutable(ubyte)[]\n-        return paintTypeOntoLiteral(to, e);\n+        return paintTypeOntoLiteral(pue, to, e);\n     }\n     else\n     {\n-        r = Cast(loc, type, to, e).copy();\n+        *pue = Cast(loc, type, to, e);\n+        r = pue->exp();\n     }\n+\n     if (CTFEExp::isCantExp(r))\n         error(loc, \"cannot cast %s to %s at compile time\", e->toChars(), to->toChars());\n+\n     if (e->op == TOKarrayliteral)\n         ((ArrayLiteralExp *)e)->ownedByCtfe = OWNEDctfe;\n+\n     if (e->op == TOKstring)\n         ((StringExp *)e)->ownedByCtfe = OWNEDctfe;\n+\n     return r;\n }\n \n@@ -1816,9 +1840,8 @@ UnionExp changeArrayLiteralLength(Loc loc, TypeArray *arrayType,\n             for (size_t i = copylen; i < newlen; i++)\n                 (*elements)[i] = defaultElem;\n         }\n-        new(&ue) ArrayLiteralExp(loc, elements);\n+        new(&ue) ArrayLiteralExp(loc, arrayType, elements);\n         ArrayLiteralExp *aae = (ArrayLiteralExp *)ue.exp();\n-        aae->type = arrayType;\n         aae->ownedByCtfe = OWNEDctfe;\n     }\n     return ue;\n@@ -2078,9 +2101,8 @@ UnionExp voidInitLiteral(Type *t, VarDeclaration *var)\n                 elem  = copyLiteral(elem).copy();\n             (*elements)[i] = elem;\n         }\n-        new(&ue) ArrayLiteralExp(var->loc, elements);\n+        new(&ue) ArrayLiteralExp(var->loc, tsa, elements);\n         ArrayLiteralExp *ae = (ArrayLiteralExp *)ue.exp();\n-        ae->type = tsa;\n         ae->ownedByCtfe = OWNEDctfe;\n     }\n     else if (t->ty == Tstruct)"}, {"sha": "140abfdd7e97fd2be1e546702ce238f312389360", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 368, "deletions": 230, "changes": 598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -264,14 +264,18 @@ void printCtfePerformanceStats()\n #endif\n }\n \n-VarDeclaration *findParentVar(Expression *e);\n-Expression *evaluateIfBuiltin(InterState *istate, Loc loc,\n+static Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n     FuncDeclaration *fd, Expressions *arguments, Expression *pthis);\n-Expression *evaluatePostblit(InterState *istate, Expression *e);\n-Expression *evaluateDtor(InterState *istate, Expression *e);\n-Expression *scrubReturnValue(Loc loc, Expression *e);\n+static Expression *evaluatePostblit(InterState *istate, Expression *e);\n+static Expression *evaluateDtor(InterState *istate, Expression *e);\n \n-Expression *scrubCacheValue(Loc loc, Expression *e);\n+static bool isEntirelyVoid(Expressions* elems);\n+static Expression *scrubArray(Loc loc, Expressions *elems, bool structlit = false);\n+static Expression *scrubStructLiteral(Loc loc, StructLiteralExp *sle);\n+static Expression *scrubReturnValue(Loc loc, Expression *e);\n+static Expression *scrubArrayCache(Expressions *elems);\n+static Expression *scrubStructLiteralCache(StructLiteralExp *sle);\n+static Expression *scrubCacheValue(Expression *e);\n \n \n /*************************************\n@@ -635,8 +639,24 @@ void ctfeCompile(FuncDeclaration *fd)\n  */\n Expression *ctfeInterpret(Expression *e)\n {\n-    if (e->op == TOKerror)\n+    switch (e->op)\n+    {\n+    case TOKint64:\n+    case TOKfloat64:\n+    case TOKcomplex80:\n+    case TOKnull:\n+    case TOKstring:\n+        if (e->type->ty == Terror)\n+            return new ErrorExp();\n+        /* fall through */\n+\n+    case TOKerror:\n         return e;\n+\n+    default:\n+        break;\n+    }\n+\n     assert(e->type);                    // Bugzilla 14642\n     //assert(e->type->ty != Terror);    // FIXME\n     if (e->type->ty == Terror)\n@@ -710,6 +730,8 @@ Expression *ctfeInterpretForPragmaMsg(Expression *e)\n /*************************************\n  * Attempt to interpret a function given the arguments.\n  * Input:\n+ *      pue        storage for result\n+ *      fd         function being called\n  *      istate     state for calling function (NULL if none)\n  *      arguments  function arguments\n  *      thisarg    'this', if a needThis() function, NULL if not.\n@@ -718,8 +740,9 @@ Expression *ctfeInterpretForPragmaMsg(Expression *e)\n  * or CTFEExp if function returned void.\n  */\n \n-static Expression *interpretFunction(FuncDeclaration *fd, InterState *istate, Expressions *arguments, Expression *thisarg)\n+static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterState *istate, Expressions *arguments, Expression *thisarg)\n {\n+    assert(pue);\n     if (fd->semanticRun == PASSsemantic3)\n     {\n         fd->error(\"circular dependency. Functions cannot be interpreted while being compiled\");\n@@ -898,7 +921,7 @@ static Expression *interpretFunction(FuncDeclaration *fd, InterState *istate, Ex\n             e = CTFEExp::cantexp;\n             break;\n         }\n-        e = interpret(fd->fbody, &istatex);\n+        e = interpret(pue, fd->fbody, &istatex);\n \n         if (istatex.start)\n         {\n@@ -938,6 +961,8 @@ static Expression *interpretFunction(FuncDeclaration *fd, InterState *istate, Ex\n     // If it generated an uncaught exception, report error.\n     if (!istate && e->op == TOKthrownexception)\n     {\n+        if (e == pue->exp())\n+            e = pue->copy();\n         ((ThrownExceptionExp *)e)->generateUncaughtError();\n         e = CTFEExp::cantexp;\n     }\n@@ -2004,7 +2029,8 @@ class Interpreter : public Visitor\n         {\n             // Normally this is already done by optimize()\n             // Do it here in case optimize(WANTvalue) wasn't run before CTFE\n-            result = new SymOffExp(e->loc, ((VarExp *)e->e1)->var, 0);\n+            new(pue) SymOffExp(e->loc, ((VarExp *)e->e1)->var, 0);\n+            result = pue->exp();\n             result->type = e->type;\n             return;\n         }\n@@ -2032,7 +2058,7 @@ class Interpreter : public Visitor\n             return;\n         }\n \n-        Expression *er = interpret(e->e1, istate);\n+        Expression *er = interpret(pue, e->e1, istate);\n         if (exceptionOrCant(er))\n             return;\n         if (er == e->e1)\n@@ -2042,6 +2068,7 @@ class Interpreter : public Visitor\n         }\n         else\n         {\n+            er = (er == pue->exp()) ? pue->copy() : er;\n             new(pue) DelegateExp(e->loc, er, e->func, false);\n             result = pue->exp();\n             result->type = e->type;\n@@ -2100,7 +2127,7 @@ class Interpreter : public Visitor\n                     /* Bugzilla 14304: e is a value that is not yet owned by CTFE.\n                      * Mark as \"cached\", and use it directly during interpretation.\n                      */\n-                    e = scrubCacheValue(v->loc, e);\n+                    e = scrubCacheValue(e);\n                     ctfeStack.saveGlobalConstant(v, e);\n                 }\n                 else\n@@ -2236,7 +2263,7 @@ class Interpreter : public Visitor\n              *  foo(s); // VarExp('s') will have const(S)\n              */\n             // A VarExp may include an implicit cast. It must be done explicitly.\n-            result = paintTypeOntoLiteral(e->type, result);\n+            result = paintTypeOntoLiteral(pue, e->type, result);\n         }\n     }\n \n@@ -2363,7 +2390,7 @@ class Interpreter : public Visitor\n         }\n         if (Expression *ex = isExpression(e->obj))\n         {\n-            result = interpret(ex, istate);\n+            result = interpret(pue, ex, istate);\n             if (exceptionOrCant(ex))\n                 return;\n \n@@ -2493,9 +2520,8 @@ class Interpreter : public Visitor\n                 result = CTFEExp::cantexp;\n                 return;\n             }\n-            new(pue) ArrayLiteralExp(e->loc, basis, expsx);\n+            new(pue) ArrayLiteralExp(e->loc, e->type, basis, expsx);\n             ArrayLiteralExp *ale = (ArrayLiteralExp *)pue->exp();\n-            ale->type = e->type;\n             ale->ownedByCtfe = OWNEDctfe;\n             result = ale;\n         }\n@@ -2505,7 +2531,10 @@ class Interpreter : public Visitor\n             result = e;\n         }\n         else\n-            result = copyLiteral(e).copy();\n+        {\n+            *pue = copyLiteral(e);\n+            result = pue->exp();\n+        }\n     }\n \n     void visit(AssocArrayLiteralExp *e)\n@@ -2585,7 +2614,10 @@ class Interpreter : public Visitor\n             result = ae;\n         }\n         else\n-            result = copyLiteral(e).copy();\n+        {\n+            *pue = copyLiteral(e);\n+            result = pue->exp();\n+        }\n     }\n \n     void visit(StructLiteralExp *e)\n@@ -2635,7 +2667,10 @@ class Interpreter : public Visitor\n                     // Block assignment from inside struct literals\n                     TypeSArray *tsa = (TypeSArray *)v->type;\n                     size_t len = (size_t)tsa->dim->toInteger();\n-                    ex = createBlockDuplicatedArrayLiteral(ex->loc, v->type, ex, len);\n+                    UnionExp ue;\n+                    ex = createBlockDuplicatedArrayLiteral(&ue, ex->loc, v->type, ex, len);\n+                    if (ex == ue.exp())\n+                        ex = ue.copy();\n                 }\n             }\n \n@@ -2665,22 +2700,25 @@ class Interpreter : public Visitor\n             result = sle;\n         }\n         else\n-            result = copyLiteral(e).copy();\n+        {\n+            *pue = copyLiteral(e);\n+            result = pue->exp();\n+        }\n     }\n \n     // Create an array literal of type 'newtype' with dimensions given by\n     // 'arguments'[argnum..$]\n-    static Expression *recursivelyCreateArrayLiteral(Loc loc, Type *newtype, InterState *istate,\n+    static Expression *recursivelyCreateArrayLiteral(UnionExp *pue, Loc loc, Type *newtype, InterState *istate,\n         Expressions *arguments, int argnum)\n     {\n-        Expression *lenExpr = interpret((*arguments)[argnum], istate);\n+        Expression *lenExpr = interpret(pue, (*arguments)[argnum], istate);\n         if (exceptionOrCantInterpret(lenExpr))\n             return lenExpr;\n         size_t len = (size_t)(lenExpr->toInteger());\n         Type *elemType = ((TypeArray *)newtype)->next;\n         if (elemType->ty == Tarray && argnum < (int)arguments->dim - 1)\n         {\n-            Expression *elem = recursivelyCreateArrayLiteral(loc, elemType, istate,\n+            Expression *elem = recursivelyCreateArrayLiteral(pue, loc, elemType, istate,\n                 arguments, argnum + 1);\n             if (exceptionOrCantInterpret(elem))\n                 return elem;\n@@ -2689,8 +2727,8 @@ class Interpreter : public Visitor\n             elements->setDim(len);\n             for (size_t i = 0; i < len; i++)\n                  (*elements)[i] = copyLiteral(elem).copy();\n-            ArrayLiteralExp *ae = new ArrayLiteralExp(loc, elements);\n-            ae->type = newtype;\n+            new(pue) ArrayLiteralExp(loc, newtype, elements);\n+            ArrayLiteralExp *ae = (ArrayLiteralExp *)pue->exp();\n             ae->ownedByCtfe = OWNEDctfe;\n             return ae;\n         }\n@@ -2699,12 +2737,12 @@ class Interpreter : public Visitor\n         {\n             const unsigned ch = (unsigned)elemType->defaultInitLiteral(loc)->toInteger();\n             const unsigned char sz = (unsigned char)elemType->size();\n-            return createBlockDuplicatedStringLiteral(loc, newtype, ch, len, sz);\n+            return createBlockDuplicatedStringLiteral(pue, loc, newtype, ch, len, sz);\n         }\n         else\n         {\n             Expression *el = interpret(elemType->defaultInitLiteral(loc), istate);\n-            return createBlockDuplicatedArrayLiteral(loc, newtype, el, len);\n+            return createBlockDuplicatedArrayLiteral(pue, loc, newtype, el, len);\n         }\n     }\n \n@@ -2717,13 +2755,13 @@ class Interpreter : public Visitor\n             return;\n         }\n \n-        result = interpret(e->argprefix, istate, ctfeNeedNothing);\n-        if (exceptionOrCant(result))\n+        Expression *epre = interpret(pue, e->argprefix, istate, ctfeNeedNothing);\n+        if (exceptionOrCant(epre))\n             return;\n \n         if (e->newtype->ty == Tarray && e->arguments)\n         {\n-            result = recursivelyCreateArrayLiteral(e->loc, e->newtype, istate, e->arguments, 0);\n+            result = recursivelyCreateArrayLiteral(pue, e->loc, e->newtype, istate, e->arguments, 0);\n             return;\n         }\n         if (e->newtype->toBasetype()->ty == Tstruct)\n@@ -2734,7 +2772,7 @@ class Interpreter : public Visitor\n                 se = interpret(se, istate);\n                 if (exceptionOrCant(se))\n                     return;\n-                result = interpretFunction(e->member, istate, e->arguments, se);\n+                result = interpretFunction(pue, e->member, istate, e->arguments, se);\n \n                 // Repaint as same as CallExp::interpret() does.\n                 result->loc = e->loc;\n@@ -2761,11 +2799,12 @@ class Interpreter : public Visitor\n                 StructLiteralExp *se = new StructLiteralExp(e->loc, sd, exps, e->newtype);\n                 se->type = e->newtype;\n                 se->ownedByCtfe = OWNEDctfe;\n-                result = interpret(se, istate);\n+                result = interpret(pue, se, istate);\n             }\n             if (exceptionOrCant(result))\n                 return;\n-            new(pue) AddrExp(e->loc, result, e->type);\n+            Expression *ev = (result == pue->exp()) ? pue->copy() : result;\n+            new(pue) AddrExp(e->loc, ev, e->type);\n             result = pue->exp();\n             return;\n         }\n@@ -2809,13 +2848,14 @@ class Interpreter : public Visitor\n             // We probably won't get away with this.\n             StructLiteralExp *se = new StructLiteralExp(e->loc, (StructDeclaration *)cd, elems, e->newtype);\n             se->ownedByCtfe = OWNEDctfe;\n-            Expression *eref = new ClassReferenceExp(e->loc, se, e->type);\n+            new(pue) ClassReferenceExp(e->loc, se, e->type);\n+            Expression *eref = pue->exp();\n             if (e->member)\n             {\n                 // Call constructor\n                 if (!e->member->fbody)\n                 {\n-                    Expression *ctorfail = evaluateIfBuiltin(istate, e->loc, e->member, e->arguments, eref);\n+                    Expression *ctorfail = evaluateIfBuiltin(pue, istate, e->loc, e->member, e->arguments, eref);\n                     if (ctorfail)\n                     {\n                         if (exceptionOrCant(ctorfail))\n@@ -2827,7 +2867,8 @@ class Interpreter : public Visitor\n                     result = CTFEExp::cantexp;\n                     return;\n                 }\n-                Expression *ctorfail = interpretFunction(e->member, istate, e->arguments, eref);\n+                UnionExp ue;\n+                Expression *ctorfail = interpretFunction(&ue, e->member, istate, e->arguments, eref);\n                 if (exceptionOrCant(ctorfail))\n                     return;\n \n@@ -2855,8 +2896,7 @@ class Interpreter : public Visitor\n             Expressions *elements = new Expressions();\n             elements->setDim(1);\n             (*elements)[0] = newval;\n-            ArrayLiteralExp *ae = new ArrayLiteralExp(e->loc, elements);\n-            ae->type = e->newtype->arrayOf();\n+            ArrayLiteralExp *ae = new ArrayLiteralExp(e->loc, e->newtype->arrayOf(), elements);\n             ae->ownedByCtfe = OWNEDctfe;\n \n             IndexExp *ei = new IndexExp(e->loc, ae, new IntegerExp(Loc(), 0, Type::tsize_t));\n@@ -3462,7 +3502,7 @@ class Interpreter : public Visitor\n             assignAssocArrayElement(e->loc, existingAA, lastIndex, newval);\n \n             // Determine the return value\n-            result = ctfeCast(e->loc, e->type, e->type, fp && post ? oldval : newval);\n+            result = ctfeCast(pue, e->loc, e->type, e->type, fp && post ? oldval : newval);\n             return;\n         }\n         if (e1->op == TOKarraylength)\n@@ -3474,10 +3514,13 @@ class Interpreter : public Visitor\n              */\n \n             // Determine the return value\n-            result = ctfeCast(e->loc, e->type, e->type, fp && post ? oldval : newval);\n+            result = ctfeCast(pue, e->loc, e->type, e->type, fp && post ? oldval : newval);\n             if (exceptionOrCant(result))\n                 return;\n \n+            if (result == pue->exp())\n+                result = pue->copy();\n+\n             size_t oldlen = (size_t)oldval->toInteger();\n             size_t newlen = (size_t)newval->toInteger();\n             if (oldlen == newlen) // no change required -- we're done!\n@@ -3511,15 +3554,21 @@ class Interpreter : public Visitor\n \n         if (!isBlockAssignment)\n         {\n-            newval = ctfeCast(e->loc, e->type, e->type, newval);\n+            newval = ctfeCast(pue, e->loc, e->type, e->type, newval);\n             if (exceptionOrCant(newval))\n                 return;\n+            if (newval == pue->exp())\n+                newval = pue->copy();\n \n             // Determine the return value\n             if (goal == ctfeNeedLvalue)     // Bugzilla 14371\n                 result = e1;\n             else\n-                result = ctfeCast(e->loc, e->type, e->type, fp && post ? oldval : newval);\n+            {\n+                result = ctfeCast(pue, e->loc, e->type, e->type, fp && post ? oldval : newval);\n+                if (result == pue->exp())\n+                    result = pue->copy();\n+            }\n             if (exceptionOrCant(result))\n                 return;\n         }\n@@ -3536,7 +3585,7 @@ class Interpreter : public Visitor\n         {\n             // Note that slice assignments don't support things like ++, so\n             // we don't need to remember 'returnValue'.\n-            result = interpretAssignToSlice(e, e1, newval, isBlockAssignment);\n+            result = interpretAssignToSlice(pue, e, e1, newval, isBlockAssignment);\n             if (exceptionOrCant(result))\n                 return;\n             if (e->e1->op == TOKslice)\n@@ -3781,7 +3830,7 @@ class Interpreter : public Visitor\n      * it returns aggregate[low..upp], except that as an optimisation,\n      * if goal == ctfeNeedNothing, it will return NULL\n      */\n-    Expression *interpretAssignToSlice(BinExp *e,\n+    Expression *interpretAssignToSlice(UnionExp *pue, BinExp *e,\n         Expression *e1, Expression *newval, bool isBlockAssignment)\n     {\n         dinteger_t lowerbound;\n@@ -3962,7 +4011,7 @@ class Interpreter : public Visitor\n                 new IntegerExp(e->loc, firstIndex, Type::tsize_t),\n                 new IntegerExp(e->loc, firstIndex + upperbound - lowerbound, Type::tsize_t));\n             retslice->type = e->type;\n-            return interpret(retslice, istate);\n+            return interpret(pue, retslice, istate);\n         }\n         if (aggregate->op == TOKarrayliteral)\n         {\n@@ -4178,7 +4227,7 @@ class Interpreter : public Visitor\n                 new IntegerExp(e->loc, firstIndex, Type::tsize_t),\n                 new IntegerExp(e->loc, firstIndex + upperbound - lowerbound, Type::tsize_t));\n             retslice->type = e->type;\n-            return interpret(retslice, istate);\n+            return interpret(pue, retslice, istate);\n         }\n \n         e->error(\"slice operation %s = %s cannot be evaluated at compile time\",\n@@ -4285,7 +4334,7 @@ class Interpreter : public Visitor\n      *  relational sub-expressions can be negated, eg\n      *  (!(q1 < p1) && p2 <= q2) is valid.\n      */\n-    void interpretFourPointerRelation(BinExp *e)\n+    void interpretFourPointerRelation(UnionExp *pue, BinExp *e)\n     {\n         assert(e->op == TOKandand || e->op == TOKoror);\n \n@@ -4311,12 +4360,16 @@ class Interpreter : public Visitor\n         }\n \n         //printf(\"FourPointerRelation %s\\n\", toChars());\n+        UnionExp ue1;\n+        UnionExp ue2;\n+        UnionExp ue3;\n+        UnionExp ue4;\n \n         // Evaluate the first two pointers\n-        p1 = interpret(p1, istate);\n+        p1 = interpret(&ue1, p1, istate);\n         if (exceptionOrCant(p1))\n             return;\n-        p2 = interpret(p2, istate);\n+        p2 = interpret(&ue2, p2, istate);\n         if (exceptionOrCant(p2))\n             return;\n         dinteger_t ofs1, ofs2;\n@@ -4329,7 +4382,7 @@ class Interpreter : public Visitor\n         {\n             // Here it is either CANT_INTERPRET,\n             // or an IsInside comparison returning false.\n-            p3 = interpret(p3, istate);\n+            p3 = interpret(&ue3, p3, istate);\n             if (CTFEExp::isCantExp(p3))\n                 return;\n             // Note that it is NOT legal for it to throw an exception!\n@@ -4338,7 +4391,7 @@ class Interpreter : public Visitor\n                 except = p3;\n             else\n             {\n-                p4 = interpret(p4, istate);\n+                p4 = interpret(&ue4, p4, istate);\n                 if (CTFEExp::isCantExp(p4))\n                 {\n                     result = p4;\n@@ -4367,7 +4420,8 @@ class Interpreter : public Visitor\n                 (dir1 != dir2 && pointToSameMemoryBlock(agg1, agg3) && pointToSameMemoryBlock(agg2, agg4)))\n             {\n                 // it's a legal two-sided comparison\n-                result = new IntegerExp(e->loc, (e->op == TOKandand) ?  0 : 1, e->type);\n+                new(pue) IntegerExp(e->loc, (e->op == TOKandand) ?  0 : 1, e->type);\n+                result = pue->exp();\n                 return;\n             }\n             // It's an invalid four-pointer comparison. Either the second\n@@ -4393,25 +4447,24 @@ class Interpreter : public Visitor\n             nott = !nott;\n             ex = ((NotExp *)ex)->e1;\n         }\n-        TOK cmpop = ex->op;\n-        if (nott)\n-            cmpop = reverseRelation(cmpop);\n-        int cmp = comparePointers(cmpop, agg1, ofs1, agg2, ofs2);\n+        const TOK cmpop = nott ? reverseRelation(ex->op) : ex->op;\n+        const int cmp = comparePointers(cmpop, agg1, ofs1, agg2, ofs2);\n         // We already know this is a valid comparison.\n         assert(cmp >= 0);\n         if ((e->op == TOKandand && cmp == 1) ||\n             (e->op == TOKoror   && cmp == 0))\n         {\n-            result = interpret(e->e2, istate);\n+            result = interpret(pue, e->e2, istate);\n             return;\n         }\n-        result = new IntegerExp(e->loc, (e->op == TOKandand) ? 0 : 1, e->type);\n+        new(pue) IntegerExp(e->loc, (e->op == TOKandand) ? 0 : 1, e->type);\n+        result = pue->exp();\n     }\n \n     void visit(AndAndExp *e)\n     {\n         // Check for an insidePointer expression, evaluate it if so\n-        interpretFourPointerRelation(e);\n+        interpretFourPointerRelation(pue, e);\n         if (result)\n             return;\n \n@@ -4461,7 +4514,7 @@ class Interpreter : public Visitor\n     void visit(OrOrExp *e)\n     {\n         // Check for an insidePointer expression, evaluate it if so\n-        interpretFourPointerRelation(e);\n+        interpretFourPointerRelation(pue, e);\n         if (result)\n             return;\n \n@@ -4695,7 +4748,7 @@ class Interpreter : public Visitor\n         }\n \n         // Check for built-in functions\n-        result = evaluateIfBuiltin(istate, e->loc, fd, e->arguments, pthis);\n+        result = evaluateIfBuiltin(pue, istate, e->loc, fd, e->arguments, pthis);\n         if (result)\n             return;\n \n@@ -4707,13 +4760,17 @@ class Interpreter : public Visitor\n             return;\n         }\n \n-        result = interpretFunction(fd, istate, e->arguments, pthis);\n+        result = interpretFunction(pue, fd, istate, e->arguments, pthis);\n         if (result->op == TOKvoidexp)\n             return;\n         if (!exceptionOrCantInterpret(result))\n         {\n-            if (goal != ctfeNeedLvalue) // Peel off CTFE reference if it's unnesessary\n-                result = interpret(result, istate);\n+            if (goal != ctfeNeedLvalue) // Peel off CTFE reference if it's unnecessary\n+            {\n+                if (result == pue->exp())\n+                    result = pue->copy();\n+                result = interpret(pue, result, istate);\n+            }\n         }\n         if (!exceptionOrCantInterpret(result))\n         {\n@@ -5306,17 +5363,37 @@ class Interpreter : public Visitor\n \n     void visit(CatExp *e)\n     {\n-        Expression *e1 = interpret(e->e1, istate);\n+        UnionExp ue1;\n+        Expression *e1 = interpret(&ue1, e->e1, istate);\n         if (exceptionOrCant(e1))\n             return;\n-        Expression *e2 = interpret(e->e2, istate);\n+\n+        UnionExp ue2;\n+        Expression *e2 = interpret(&ue2, e->e2, istate);\n         if (exceptionOrCant(e2))\n             return;\n+\n         UnionExp e1tmp;\n         e1 = resolveSlice(e1, &e1tmp);\n+\n         UnionExp e2tmp;\n         e2 = resolveSlice(e2, &e2tmp);\n-        result = ctfeCat(e->loc, e->type, e1, e2).copy();\n+\n+        /* e1 and e2 can't go on the stack because of x~[y] and [x]~y will\n+         * result in [x,y] and then x or y is on the stack.\n+         * But if they are both strings, we can, because it isn't the x~[y] case.\n+         */\n+        if (!(e1->op == TOKstring && e2->op == TOKstring))\n+        {\n+            if (e1 == ue1.exp())\n+                e1 = ue1.copy();\n+            if (e2 == ue2.exp())\n+                e2 = ue2.copy();\n+        }\n+\n+        *pue = ctfeCat(e->loc, e->type, e1, e2);\n+        result = pue->exp();\n+\n         if (CTFEExp::isCantExp(result))\n         {\n             e->error(\"%s cannot be interpreted at compile time\", e->toChars());\n@@ -5375,7 +5452,7 @@ class Interpreter : public Visitor\n \n             if (cd->dtor)\n             {\n-                result = interpretFunction(cd->dtor, istate, NULL, cre);\n+                result = interpretFunction(pue, cd->dtor, istate, NULL, cre);\n                 if (exceptionOrCant(result))\n                     return;\n             }\n@@ -5406,7 +5483,7 @@ class Interpreter : public Visitor\n \n                 if (sd->dtor)\n                 {\n-                    result = interpretFunction(sd->dtor, istate, NULL, sle);\n+                    result = interpretFunction(pue, sd->dtor, istate, NULL, sle);\n                     if (exceptionOrCant(result))\n                         return;\n                 }\n@@ -5440,7 +5517,7 @@ class Interpreter : public Visitor\n                     for (size_t i = 0; i < ale->elements->dim; i++)\n                     {\n                         Expression *el = (*ale->elements)[i];\n-                        result = interpretFunction(sd->dtor, istate, NULL, el);\n+                        result = interpretFunction(pue, sd->dtor, istate, NULL, el);\n                         if (exceptionOrCant(result))\n                             return;\n                     }\n@@ -5473,7 +5550,7 @@ class Interpreter : public Visitor\n             if (e1->op == TOKint64)\n             {\n                 // Happens with Windows HANDLEs, for example.\n-                result = paintTypeOntoLiteral(e->to, e1);\n+                result = paintTypeOntoLiteral(pue, e->to, e1);\n                 return;\n             }\n             bool castToSarrayPointer = false;\n@@ -5516,13 +5593,14 @@ class Interpreter : public Visitor\n \n             if (e1->op == TOKslice)\n             {\n-                if (((SliceExp *)e1)->e1->op == TOKnull)\n+                SliceExp *se = (SliceExp *)e1;\n+                if (se->e1->op == TOKnull)\n                 {\n-                    result = paintTypeOntoLiteral(e->type, ((SliceExp *)e1)->e1);\n+                    result = paintTypeOntoLiteral(pue, e->type, se->e1);\n                     return;\n                 }\n                 // Create a CTFE pointer &aggregate[1..2]\n-                IndexExp *ei = new IndexExp(e->loc, ((SliceExp *)e1)->e1, ((SliceExp *)e1)->lwr);\n+                IndexExp *ei = new IndexExp(e->loc, se->e1, se->lwr);\n                 ei->type = e->type->nextOf();\n                 new(pue) AddrExp(e->loc, ei, e->type);\n                 result = pue->exp();\n@@ -5541,7 +5619,6 @@ class Interpreter : public Visitor\n             {\n                 // type painting operation\n                 IndexExp *ie = (IndexExp *)e1;\n-                result = new IndexExp(e1->loc, ie->e1, ie->e2);\n                 if (castBackFromVoid)\n                 {\n                     // get the original type. For strings, it's just the type...\n@@ -5550,7 +5627,7 @@ class Interpreter : public Visitor\n                     if (ie->e1->op == TOKarrayliteral && ie->e2->op == TOKint64)\n                     {\n                         ArrayLiteralExp *ale = (ArrayLiteralExp *)ie->e1;\n-                        size_t indx = (size_t)ie->e2->toInteger();\n+                        const size_t indx = (size_t)ie->e2->toInteger();\n                         if (indx < ale->elements->dim)\n                         {\n                             Expression *xx = (*ale->elements)[indx];\n@@ -5572,23 +5649,26 @@ class Interpreter : public Visitor\n                         return;\n                     }\n                 }\n+                new(pue) IndexExp(e1->loc, ie->e1, ie->e2);\n+                result = pue->exp();\n                 result->type = e->type;\n                 return;\n             }\n             if (e1->op == TOKaddress)\n             {\n-                Type *origType = ((AddrExp *)e1)->e1->type;\n+                AddrExp *ae = (AddrExp *)e1;\n+                Type *origType = ae->e1->type;\n                 if (isSafePointerCast(origType, pointee))\n                 {\n-                    new(pue) AddrExp(e->loc, ((AddrExp *)e1)->e1, e->type);\n+                    new(pue) AddrExp(e->loc, ae->e1, e->type);\n                     result = pue->exp();\n                     return;\n                 }\n-                if (castToSarrayPointer && pointee->toBasetype()->ty == Tsarray && ((AddrExp *)e1)->e1->op == TOKindex)\n+                if (castToSarrayPointer && pointee->toBasetype()->ty == Tsarray && ae->e1->op == TOKindex)\n                 {\n                     // &val[idx]\n                     dinteger_t dim = ((TypeSArray *)pointee->toBasetype())->dim->toInteger();\n-                    IndexExp *ie = (IndexExp *)((AddrExp *)e1)->e1;\n+                    IndexExp *ie = (IndexExp *)ae->e1;\n                     Expression *lwr = ie->e2;\n                     Expression *upr = new IntegerExp(ie->e2->loc, ie->e2->toInteger() + dim, Type::tsize_t);\n \n@@ -5669,7 +5749,7 @@ class Interpreter : public Visitor\n             result = pue->exp();\n             return;\n         }\n-        result = ctfeCast(e->loc, e->type, e->to, e1);\n+        result = ctfeCast(pue, e->loc, e->type, e->to, e1);\n     }\n \n     void visit(AssertExp *e)\n@@ -5708,20 +5788,30 @@ class Interpreter : public Visitor\n     void visit(PtrExp *e)\n     {\n         // Check for int<->float and long<->double casts.\n-        if (e->e1->op == TOKsymoff && ((SymOffExp *)e->e1)->offset == 0 && ((SymOffExp *)e->e1)->var->isVarDeclaration() && isFloatIntPaint(e->type, ((SymOffExp *)e->e1)->var->type))\n+        if (e->e1->op == TOKsymoff)\n         {\n-            // *(cast(int*)&v), where v is a float variable\n-            result = paintFloatInt(getVarExp(e->loc, istate, ((SymOffExp *)e->e1)->var, ctfeNeedRvalue), e->type);\n-            return;\n+            SymOffExp *soe = (SymOffExp *)e->e1;\n+            if (soe->offset == 0 && soe->var->isVarDeclaration() && isFloatIntPaint(e->type, soe->var->type))\n+            {\n+                // *(cast(int*)&v), where v is a float variable\n+                result = paintFloatInt(pue, getVarExp(e->loc, istate, soe->var, ctfeNeedRvalue), e->type);\n+                return;\n+            }\n         }\n-        if (e->e1->op == TOKcast && ((CastExp *)e->e1)->e1->op == TOKaddress)\n+\n+        if (e->e1->op == TOKcast)\n         {\n-            // *(cast(int*)&x), where x is a float expression\n-            Expression *x = ((AddrExp *)(((CastExp *)e->e1)->e1))->e1;\n-            if (isFloatIntPaint(e->type, x->type))\n+            CastExp *ce1 = (CastExp *)e->e1;\n+            if (ce1->e1->op == TOKaddress)\n             {\n-                result = paintFloatInt(interpret(x, istate), e->type);\n-                return;\n+                AddrExp *ae11 = (AddrExp *)ce1->e1;\n+                // *(cast(int*)&x), where x is a float expression\n+                Expression *x = ae11->e1;\n+                if (isFloatIntPaint(e->type, x->type))\n+                {\n+                    result = paintFloatInt(pue, interpret(x, istate), e->type);\n+                    return;\n+                }\n             }\n         }\n \n@@ -5785,7 +5875,7 @@ class Interpreter : public Visitor\n              */\n             return;\n         }\n-        result = interpret(result, istate, goal);\n+        result = interpret(pue, result, istate, goal);\n         if (exceptionOrCant(result))\n             return;\n     }\n@@ -5898,7 +5988,10 @@ class Interpreter : public Visitor\n             // Block assignment from inside struct literals\n             TypeSArray *tsa = (TypeSArray *)v->type;\n             size_t len = (size_t)tsa->dim->toInteger();\n-            result = createBlockDuplicatedArrayLiteral(ex->loc, v->type, ex, len);\n+            UnionExp ue;\n+            result = createBlockDuplicatedArrayLiteral(&ue, ex->loc, v->type, ex, len);\n+            if (result == ue.exp())\n+                result = ue.copy();\n             (*se->elements)[i] = result;\n         }\n     }\n@@ -6022,57 +6115,47 @@ Expression *interpret(Statement *s, InterState *istate)\n     return result;\n }\n \n-Expression *scrubArray(Loc loc, Expressions *elems, bool structlit = false);\n-\n-/* All results destined for use outside of CTFE need to have their CTFE-specific\n+/**\n+ * All results destined for use outside of CTFE need to have their CTFE-specific\n  * features removed.\n- * In particular, all slices must be resolved.\n+ * In particular,\n+ * 1. all slices must be resolved.\n+ * 2. all .ownedByCtfe set to OWNEDcode\n  */\n Expression *scrubReturnValue(Loc loc, Expression *e)\n {\n     if (e->op == TOKclassreference)\n     {\n-        StructLiteralExp *se = ((ClassReferenceExp*)e)->value;\n-        se->ownedByCtfe = OWNEDcode;\n-        if (!(se->stageflags & stageScrub))\n-        {\n-            int old = se->stageflags;\n-            se->stageflags |= stageScrub;\n-            if (Expression *ex = scrubArray(loc, se->elements, true))\n-                return ex;\n-            se->stageflags = old;\n-        }\n+        StructLiteralExp *sle = ((ClassReferenceExp*)e)->value;\n+        if (Expression *ex = scrubStructLiteral(loc, sle))\n+            return ex;\n     }\n-    if (e->op == TOKvoid)\n+    else if (e->op == TOKvoid)\n     {\n         error(loc, \"uninitialized variable '%s' cannot be returned from CTFE\", ((VoidInitExp *)e)->var->toChars());\n         return new ErrorExp();\n     }\n+\n     e = resolveSlice(e);\n+\n     if (e->op == TOKstructliteral)\n     {\n-        StructLiteralExp *se = (StructLiteralExp *)e;\n-        se->ownedByCtfe = OWNEDcode;\n-        if (!(se->stageflags & stageScrub))\n-        {\n-            int old = se->stageflags;\n-            se->stageflags |= stageScrub;\n-            if (Expression *ex = scrubArray(loc, se->elements, true))\n-                return ex;\n-            se->stageflags = old;\n-        }\n+        StructLiteralExp *sle = (StructLiteralExp *)e;\n+        if (Expression *ex = scrubStructLiteral(loc, sle))\n+            return ex;\n     }\n-    if (e->op == TOKstring)\n+    else if (e->op == TOKstring)\n     {\n         ((StringExp *)e)->ownedByCtfe = OWNEDcode;\n     }\n-    if (e->op == TOKarrayliteral)\n+    else if (e->op == TOKarrayliteral)\n     {\n-        ((ArrayLiteralExp *)e)->ownedByCtfe = OWNEDcode;\n-        if (Expression *ex = scrubArray(loc, ((ArrayLiteralExp *)e)->elements))\n+        ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n+        ale->ownedByCtfe = OWNEDcode;\n+        if (Expression *ex = scrubArray(loc, ale->elements))\n             return ex;\n     }\n-    if (e->op == TOKassocarrayliteral)\n+    else if (e->op == TOKassocarrayliteral)\n     {\n         AssocArrayLiteralExp *aae = (AssocArrayLiteralExp *)e;\n         aae->ownedByCtfe = OWNEDcode;\n@@ -6085,24 +6168,34 @@ Expression *scrubReturnValue(Loc loc, Expression *e)\n     return e;\n }\n \n+/* Returns: true if e is void,\n+ * or is an array literal or struct literal of void elements.\n+ */\n+static bool isVoid(Expression *e)\n+{\n+    if (e->op == TOKvoid)\n+        return true;\n+\n+    if (e->op == TOKarrayliteral)\n+        return isEntirelyVoid(((ArrayLiteralExp *)e)->elements);\n+\n+    if (e->op == TOKstructliteral)\n+        return isEntirelyVoid(((StructLiteralExp *)e)->elements);\n+\n+    return false;\n+}\n+\n // Return true if every element is either void,\n // or is an array literal or struct literal of void elements.\n bool isEntirelyVoid(Expressions *elems)\n {\n     for (size_t i = 0; i < elems->dim; i++)\n     {\n-        Expression *m = (*elems)[i];\n+        Expression *e = (*elems)[i];\n         // It can be NULL for performance reasons,\n         // see StructLiteralExp::interpret().\n-        if (!m)\n-            continue;\n-\n-        if (!(m->op == TOKvoid) &&\n-            !(m->op == TOKarrayliteral && isEntirelyVoid(((ArrayLiteralExp *)m)->elements)) &&\n-            !(m->op == TOKstructliteral && isEntirelyVoid(((StructLiteralExp *)m)->elements)))\n-        {\n+        if (e && !isVoid(e))\n             return false;\n-        }\n     }\n     return true;\n }\n@@ -6112,155 +6205,178 @@ Expression *scrubArray(Loc loc, Expressions *elems, bool structlit)\n {\n     for (size_t i = 0; i < elems->dim; i++)\n     {\n-        Expression *m = (*elems)[i];\n+        Expression *e = (*elems)[i];\n         // It can be NULL for performance reasons,\n         // see StructLiteralExp::interpret().\n-        if (!m)\n+        if (!e)\n             continue;\n \n         // A struct .init may contain void members.\n         // Static array members are a weird special case (bug 10994).\n-        if (structlit &&\n-            ((m->op == TOKvoid) ||\n-             (m->op == TOKarrayliteral && m->type->ty == Tsarray && isEntirelyVoid(((ArrayLiteralExp *)m)->elements)) ||\n-             (m->op == TOKstructliteral && isEntirelyVoid(((StructLiteralExp *)m)->elements))))\n+        if (structlit && isVoid(e))\n         {\n-                m = NULL;\n+            e = NULL;\n         }\n         else\n         {\n-            m = scrubReturnValue(loc, m);\n-            if (CTFEExp::isCantExp(m) || m->op == TOKerror)\n-                return m;\n+            e = scrubReturnValue(loc, e);\n+            if (CTFEExp::isCantExp(e) || e->op == TOKerror)\n+                return e;\n         }\n-        (*elems)[i] = m;\n+        (*elems)[i] = e;\n     }\n     return NULL;\n }\n \n-Expression *scrubArrayCache(Loc loc, Expressions *elems);\n+Expression *scrubStructLiteral(Loc loc, StructLiteralExp *sle)\n+{\n+    sle->ownedByCtfe = OWNEDcode;\n+    if (!(sle->stageflags & stageScrub))\n+    {\n+        const int old = sle->stageflags;\n+        sle->stageflags |= stageScrub;       // prevent infinite recursion\n+        if (Expression *ex = scrubArray(loc, sle->elements, true))\n+            return ex;\n+        sle->stageflags = old;\n+    }\n+    return NULL;\n+}\n \n-Expression *scrubCacheValue(Loc loc, Expression *e)\n+/**************************************\n+ * Transitively set all .ownedByCtfe to OWNEDcache\n+ */\n+Expression *scrubCacheValue(Expression *e)\n {\n+    if (!e)\n+        return e;\n+\n     if (e->op == TOKclassreference)\n     {\n         StructLiteralExp *sle = ((ClassReferenceExp*)e)->value;\n-        sle->ownedByCtfe = OWNEDcache;\n-        if (!(sle->stageflags & stageScrub))\n-        {\n-            int old = sle->stageflags;\n-            sle->stageflags |= stageScrub;\n-            if (Expression *ex = scrubArrayCache(loc, sle->elements))\n-                return ex;\n-            sle->stageflags = old;\n-        }\n+        if (Expression *ex = scrubStructLiteralCache(sle))\n+            return ex;\n     }\n-    if (e->op == TOKstructliteral)\n+    else if (e->op == TOKstructliteral)\n     {\n         StructLiteralExp *sle = (StructLiteralExp *)e;\n-        sle->ownedByCtfe = OWNEDcache;\n-        if (!(sle->stageflags & stageScrub))\n-        {\n-            int old = sle->stageflags;\n-            sle->stageflags |= stageScrub;\n-            if (Expression *ex = scrubArrayCache(loc, sle->elements))\n-                return ex;\n-            sle->stageflags = old;\n-        }\n+        if (Expression *ex = scrubStructLiteralCache(sle))\n+            return ex;\n     }\n-    if (e->op == TOKstring)\n+    else if (e->op == TOKstring)\n     {\n         ((StringExp *)e)->ownedByCtfe = OWNEDcache;\n     }\n-    if (e->op == TOKarrayliteral)\n+    else if (e->op == TOKarrayliteral)\n     {\n-        ((ArrayLiteralExp *)e)->ownedByCtfe = OWNEDcache;\n-        if (Expression *ex = scrubArrayCache(loc, ((ArrayLiteralExp *)e)->elements))\n+        ArrayLiteralExp *ale = (ArrayLiteralExp *)e;\n+        ale->ownedByCtfe = OWNEDcache;\n+        if (Expression *ex = scrubArrayCache(ale->elements))\n             return ex;\n     }\n-    if (e->op == TOKassocarrayliteral)\n+    else if (e->op == TOKassocarrayliteral)\n     {\n         AssocArrayLiteralExp *aae = (AssocArrayLiteralExp *)e;\n         aae->ownedByCtfe = OWNEDcache;\n-        if (Expression *ex = scrubArrayCache(loc, aae->keys))\n+        if (Expression *ex = scrubArrayCache(aae->keys))\n             return ex;\n-        if (Expression *ex = scrubArrayCache(loc, aae->values))\n+        if (Expression *ex = scrubArrayCache(aae->values))\n             return ex;\n     }\n     return e;\n }\n \n-Expression *scrubArrayCache(Loc loc, Expressions *elems)\n+Expression *scrubArrayCache(Expressions *elems)\n {\n     for (size_t i = 0; i < elems->dim; i++)\n     {\n-        Expression *m = (*elems)[i];\n-        if (!m)\n-            continue;\n-        (*elems)[i] = scrubCacheValue(loc, m);\n+        Expression *e = (*elems)[i];\n+        (*elems)[i] = scrubCacheValue(e);\n+    }\n+    return NULL;\n+}\n+\n+Expression *scrubStructLiteralCache(StructLiteralExp *sle)\n+{\n+    sle->ownedByCtfe = OWNEDcache;\n+    if (!(sle->stageflags & stageScrub))\n+    {\n+        const int old = sle->stageflags;\n+        sle->stageflags |= stageScrub;       // prevent infinite recursion\n+        if (Expression *ex = scrubArrayCache(sle->elements))\n+            return ex;\n+        sle->stageflags = old;\n     }\n     return NULL;\n }\n \n /******************************* Special Functions ***************************/\n \n-Expression *interpret_length(InterState *istate, Expression *earg)\n+static Expression *interpret_length(UnionExp *pue, InterState *istate, Expression *earg)\n {\n     //printf(\"interpret_length()\\n\");\n-    earg = interpret(earg, istate);\n+    earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n     dinteger_t len = 0;\n     if (earg->op == TOKassocarrayliteral)\n         len = ((AssocArrayLiteralExp *)earg)->keys->dim;\n     else\n         assert(earg->op == TOKnull);\n-    Expression *e = new IntegerExp(earg->loc, len, Type::tsize_t);\n-    return e;\n+    new(pue) IntegerExp(earg->loc, len, Type::tsize_t);\n+    return pue->exp();\n }\n \n-Expression *interpret_keys(InterState *istate, Expression *earg, Type *returnType)\n+static Expression *interpret_keys(UnionExp *pue, InterState *istate, Expression *earg, Type *returnType)\n {\n-    earg = interpret(earg, istate);\n+    earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n     if (earg->op == TOKnull)\n-        return new NullExp(earg->loc, returnType);\n+    {\n+        new(pue) NullExp(earg->loc, earg->type);\n+        return pue->exp();\n+    }\n     if (earg->op != TOKassocarrayliteral && earg->type->toBasetype()->ty != Taarray)\n         return NULL;\n     assert(earg->op == TOKassocarrayliteral);\n     AssocArrayLiteralExp *aae = (AssocArrayLiteralExp *)earg;\n-    ArrayLiteralExp *ae = new ArrayLiteralExp(aae->loc, aae->keys);\n+    ArrayLiteralExp *ae = new ArrayLiteralExp(aae->loc, returnType, aae->keys);\n     ae->ownedByCtfe = aae->ownedByCtfe;\n-    ae->type = returnType;\n-    return copyLiteral(ae).copy();\n+    *pue = copyLiteral(ae);\n+    return pue->exp();\n }\n \n-Expression *interpret_values(InterState *istate, Expression *earg, Type *returnType)\n+static Expression *interpret_values(UnionExp *pue, InterState *istate, Expression *earg, Type *returnType)\n {\n-    earg = interpret(earg, istate);\n+    earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n     if (earg->op == TOKnull)\n-        return new NullExp(earg->loc, returnType);\n+    {\n+        new(pue) NullExp(earg->loc, earg->type);\n+        return pue->exp();\n+    }\n     if (earg->op != TOKassocarrayliteral && earg->type->toBasetype()->ty != Taarray)\n         return NULL;\n     assert(earg->op == TOKassocarrayliteral);\n     AssocArrayLiteralExp *aae = (AssocArrayLiteralExp *)earg;\n-    ArrayLiteralExp *ae = new ArrayLiteralExp(aae->loc, aae->values);\n+    ArrayLiteralExp *ae = new ArrayLiteralExp(aae->loc, returnType, aae->values);\n     ae->ownedByCtfe = aae->ownedByCtfe;\n-    ae->type = returnType;\n     //printf(\"result is %s\\n\", e->toChars());\n-    return copyLiteral(ae).copy();\n+    *pue = copyLiteral(ae);\n+    return pue->exp();\n }\n \n-Expression *interpret_dup(InterState *istate, Expression *earg)\n+Expression *interpret_dup(UnionExp *pue, InterState *istate, Expression *earg)\n {\n-    earg = interpret(earg, istate);\n+    earg = interpret(pue, earg, istate);\n     if (exceptionOrCantInterpret(earg))\n         return earg;\n     if (earg->op == TOKnull)\n-        return new NullExp(earg->loc, earg->type);\n+    {\n+        new(pue) NullExp(earg->loc, earg->type);\n+        return pue->exp();\n+    }\n     if (earg->op != TOKassocarrayliteral && earg->type->toBasetype()->ty != Taarray)\n         return NULL;\n     assert(earg->op == TOKassocarrayliteral);\n@@ -6278,13 +6394,16 @@ Expression *interpret_dup(InterState *istate, Expression *earg)\n }\n \n // signature is int delegate(ref Value) OR int delegate(ref Key, ref Value)\n-Expression *interpret_aaApply(InterState *istate, Expression *aa, Expression *deleg)\n+Expression *interpret_aaApply(UnionExp *pue, InterState *istate, Expression *aa, Expression *deleg)\n {\n     aa = interpret(aa, istate);\n     if (exceptionOrCantInterpret(aa))\n         return aa;\n     if (aa->op != TOKassocarrayliteral)\n-        return new IntegerExp(deleg->loc, 0, Type::tsize_t);\n+    {\n+        new(pue) IntegerExp(deleg->loc, 0, Type::tsize_t);\n+        return pue->exp();\n+    }\n \n     FuncDeclaration *fd = NULL;\n     Expression *pthis = NULL;\n@@ -6323,9 +6442,13 @@ Expression *interpret_aaApply(InterState *istate, Expression *aa, Expression *de\n             evalue->type = t;\n         }\n         args[numParams - 1] = evalue;\n-        if (numParams == 2) args[0] = ekey;\n+        if (numParams == 2)\n+            args[0] = ekey;\n \n-        eresult = interpretFunction(fd, istate, &args, pthis);\n+        UnionExp ue;\n+        eresult = interpretFunction(&ue, fd, istate, &args, pthis);\n+        if (eresult == ue.exp())\n+            eresult = ue.copy();\n         if (exceptionOrCantInterpret(eresult))\n             return eresult;\n \n@@ -6336,19 +6459,10 @@ Expression *interpret_aaApply(InterState *istate, Expression *aa, Expression *de\n     return eresult;\n }\n \n-// Helper function: given a function of type A[] f(...),\n-// return A[].\n-Type *returnedArrayType(FuncDeclaration *fd)\n-{\n-    assert(fd->type->ty == Tfunction);\n-    assert(fd->type->nextOf()->ty == Tarray);\n-    return ((TypeFunction *)fd->type)->nextOf();\n-}\n-\n /* Decoding UTF strings for foreach loops. Duplicates the functionality of\n  * the twelve _aApplyXXn functions in aApply.d in the runtime.\n  */\n-Expression *foreachApplyUtf(InterState *istate, Expression *str, Expression *deleg, bool rvs)\n+static Expression *foreachApplyUtf(UnionExp *pue, InterState *istate, Expression *str, Expression *deleg, bool rvs)\n {\n     FuncDeclaration *fd = NULL;\n     Expression *pthis = NULL;\n@@ -6369,7 +6483,10 @@ Expression *foreachApplyUtf(InterState *istate, Expression *str, Expression *del\n                                      : Type::tsize_t;\n     size_t len = (size_t)resolveArrayLength(str);\n     if (len == 0)\n-        return new IntegerExp(deleg->loc, 0, indexType);\n+    {\n+        new(pue) IntegerExp(deleg->loc, 0, indexType);\n+        return pue->exp();\n+    }\n \n     str = resolveSlice(str);\n \n@@ -6584,7 +6701,10 @@ Expression *foreachApplyUtf(InterState *istate, Expression *str, Expression *del\n \n             args[numParams - 1] = val;\n \n-            eresult = interpretFunction(fd, istate, &args, pthis);\n+            UnionExp ue;\n+            eresult = interpretFunction(&ue, fd, istate, &args, pthis);\n+            if (eresult == ue.exp())\n+                eresult = ue.copy();\n             if (exceptionOrCantInterpret(eresult))\n                 return eresult;\n             assert(eresult->op == TOKint64);\n@@ -6598,7 +6718,7 @@ Expression *foreachApplyUtf(InterState *istate, Expression *str, Expression *del\n /* If this is a built-in function, return the interpreted result,\n  * Otherwise, return NULL.\n  */\n-Expression *evaluateIfBuiltin(InterState *istate, Loc loc,\n+Expression *evaluateIfBuiltin(UnionExp *pue, InterState *istate, Loc loc,\n     FuncDeclaration *fd, Expressions *arguments, Expression *pthis)\n {\n     Expression *e = NULL;\n@@ -6631,21 +6751,31 @@ Expression *evaluateIfBuiltin(InterState *istate, Loc loc,\n         if (firstarg && firstarg->type->toBasetype()->ty == Taarray)\n         {\n             TypeAArray *firstAAtype = (TypeAArray *)firstarg->type;\n-            const char *id = fd->ident->toChars();\n-            if (nargs == 1 && fd->ident == Id::aaLen)\n-                return interpret_length(istate, firstarg);\n-            if (nargs == 3 && !strcmp(id, \"_aaApply\"))\n-                return interpret_aaApply(istate, firstarg, (Expression *)(arguments->data[2]));\n-            if (nargs == 3 && !strcmp(id, \"_aaApply2\"))\n-                return interpret_aaApply(istate, firstarg, (Expression *)(arguments->data[2]));\n-            if (nargs == 1 && !strcmp(id, \"keys\") && !strcmp(fd->toParent2()->ident->toChars(), \"object\"))\n-                return interpret_keys(istate, firstarg, firstAAtype->index->arrayOf());\n-            if (nargs == 1 && !strcmp(id, \"values\") && !strcmp(fd->toParent2()->ident->toChars(), \"object\"))\n-                return interpret_values(istate, firstarg, firstAAtype->nextOf()->arrayOf());\n-            if (nargs == 1 && !strcmp(id, \"rehash\") && !strcmp(fd->toParent2()->ident->toChars(), \"object\"))\n-                return interpret(firstarg, istate);\n-            if (nargs == 1 && !strcmp(id, \"dup\") && !strcmp(fd->toParent2()->ident->toChars(), \"object\"))\n-                return interpret_dup(istate, firstarg);\n+            const Identifier *id = fd->ident;\n+            if (nargs == 1)\n+            {\n+                if (fd->ident == Id::aaLen)\n+                    return interpret_length(pue, istate, firstarg);\n+\n+                if (fd->toParent2()->ident == Id::object)\n+                {\n+                    if (id == Id::keys)\n+                        return interpret_keys(pue, istate, firstarg, firstAAtype->index->arrayOf());\n+                    if (id == Id::values)\n+                        return interpret_values(pue, istate, firstarg, firstAAtype->nextOf()->arrayOf());\n+                    if (id == Id::rehash)\n+                        return interpret(pue, firstarg, istate);\n+                    if (id == Id::dup)\n+                        return interpret_dup(pue, istate, firstarg);\n+                }\n+            }\n+            else // (nargs == 3)\n+            {\n+                if (id == Id::_aaApply)\n+                    return interpret_aaApply(pue, istate, firstarg, (Expression *)(arguments->data[2]));\n+                if (id == Id::_aaApply2)\n+                    return interpret_aaApply(pue, istate, firstarg, (Expression *)(arguments->data[2]));\n+            }\n         }\n     }\n     if (pthis && !fd->fbody && fd->isCtorDeclaration() && fd->parent && fd->parent->parent && fd->parent->parent->ident == Id::object)\n@@ -6693,7 +6823,7 @@ Expression *evaluateIfBuiltin(InterState *istate, Loc loc,\n                 str = interpret(str, istate);\n                 if (exceptionOrCantInterpret(str))\n                     return str;\n-                return foreachApplyUtf(istate, str, (*arguments)[1], rvs);\n+                return foreachApplyUtf(pue, istate, str, (*arguments)[1], rvs);\n             }\n         }\n     }\n@@ -6723,7 +6853,10 @@ Expression *evaluatePostblit(InterState *istate, Expression *e)\n     if (e->op == TOKstructliteral)\n     {\n         // e.__postblit()\n-        e = interpretFunction(sd->postblit, istate, NULL, e);\n+        UnionExp ue;\n+        e = interpretFunction(&ue, sd->postblit, istate, NULL, e);\n+        if (e == ue.exp())\n+            e = ue.copy();\n         if (exceptionOrCantInterpret(e))\n             return e;\n         return NULL;\n@@ -6741,6 +6874,7 @@ Expression *evaluateDtor(InterState *istate, Expression *e)\n     if (!sd->dtor)\n         return NULL;\n \n+    UnionExp ue;\n     if (e->op == TOKarrayliteral)\n     {\n         ArrayLiteralExp *alex = (ArrayLiteralExp *)e;\n@@ -6750,12 +6884,16 @@ Expression *evaluateDtor(InterState *istate, Expression *e)\n     else if (e->op == TOKstructliteral)\n     {\n         // e.__dtor()\n-        e = interpretFunction(sd->dtor, istate, NULL, e);\n+        e = interpretFunction(&ue, sd->dtor, istate, NULL, e);\n     }\n     else\n         assert(0);\n     if (exceptionOrCantInterpret(e))\n+    {\n+        if (e == ue.exp())\n+            e = ue.copy();\n         return e;\n+    }\n     return NULL;\n }\n "}, {"sha": "4d82d7217e177c13fdf2b9a54509579098d8360d", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -1189,32 +1189,36 @@ void ScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n     }\n }\n \n+#define BITS_PER_INDEX (sizeof(size_t) * CHAR_BIT)\n+\n static void bitArraySet(BitArray *array, size_t idx)\n {\n-    array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] |= 1ULL << (idx & (sizeof(size_t) * CHAR_BIT - 1));\n+    array->ptr[idx / BITS_PER_INDEX] |= 1ULL << (idx % BITS_PER_INDEX);\n }\n \n static bool bitArrayGet(BitArray *array, size_t idx)\n {\n-    return (array->ptr[idx / (sizeof(size_t) * CHAR_BIT)] & (1ULL << (idx & (sizeof(size_t) * CHAR_BIT - 1)))) != 0;\n+    const size_t boffset = idx % BITS_PER_INDEX;\n+    return (array->ptr[idx / BITS_PER_INDEX] & (1ULL << boffset)) >> boffset;\n }\n \n static void bitArrayLength(BitArray *array, size_t len)\n {\n-    size_t obytes = (array->len + CHAR_BIT - 1) / CHAR_BIT;\n-    size_t nbytes = (len + CHAR_BIT - 1) / CHAR_BIT;\n-\n-    if (obytes < nbytes)\n+    if (array->len < len)\n     {\n+        const size_t obytes = (array->len + BITS_PER_INDEX - 1) / BITS_PER_INDEX;\n+        const size_t nbytes = (len + BITS_PER_INDEX - 1) / BITS_PER_INDEX;\n+\n         if (!array->ptr)\n             array->ptr = (size_t *)mem.xmalloc(nbytes * sizeof(size_t));\n         else\n             array->ptr = (size_t *)mem.xrealloc(array->ptr, nbytes * sizeof(size_t));\n \n         for (size_t i = obytes; i < nbytes; i++)\n             array->ptr[i] = 0;\n+\n+        array->len = nbytes * BITS_PER_INDEX;\n     }\n-    array->len = len;\n }\n \n void ScopeDsymbol::addAccessiblePackage(Package *p, Prot protection)"}, {"sha": "cbc38195ccad7c3c49a2cd75ebb270c742ff8dcc", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -1493,7 +1493,6 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                          * is now optimized. See Bugzilla 2356.\n                          */\n                         Type *tbn = ((TypeArray *)tb)->next;\n-                        Type *tsa = tbn->sarrayOf(nargs - i);\n \n                         Expressions *elements = new Expressions();\n                         elements->setDim(nargs - i);\n@@ -1511,8 +1510,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                             (*elements)[u] = a;\n                         }\n                         // Bugzilla 14395: Convert to a static array literal, or its slice.\n-                        arg = new ArrayLiteralExp(loc, elements);\n-                        arg->type = tsa;\n+                        arg = new ArrayLiteralExp(loc, tbn->sarrayOf(nargs - i), elements);\n                         if (tb->ty == Tarray)\n                         {\n                             arg = new SliceExp(loc, arg, NULL, NULL);\n@@ -3741,34 +3739,37 @@ unsigned StringExp::charAt(uinteger_t i) const\n \n // [ e1, e2, e3, ... ]\n \n-ArrayLiteralExp::ArrayLiteralExp(Loc loc, Expressions *elements)\n+ArrayLiteralExp::ArrayLiteralExp(Loc loc, Type *type, Expressions *elements)\n     : Expression(loc, TOKarrayliteral, sizeof(ArrayLiteralExp))\n {\n     this->basis = NULL;\n+    this->type = type;\n     this->elements = elements;\n     this->ownedByCtfe = OWNEDcode;\n }\n \n-ArrayLiteralExp::ArrayLiteralExp(Loc loc, Expression *e)\n+ArrayLiteralExp::ArrayLiteralExp(Loc loc, Type *type, Expression *e)\n     : Expression(loc, TOKarrayliteral, sizeof(ArrayLiteralExp))\n {\n     this->basis = NULL;\n+    this->type = type;\n     elements = new Expressions;\n     elements->push(e);\n     this->ownedByCtfe = OWNEDcode;\n }\n \n-ArrayLiteralExp::ArrayLiteralExp(Loc loc, Expression *basis, Expressions *elements)\n+ArrayLiteralExp::ArrayLiteralExp(Loc loc, Type *type, Expression *basis, Expressions *elements)\n     : Expression(loc, TOKarrayliteral, sizeof(ArrayLiteralExp))\n {\n     this->basis = basis;\n+    this->type = type;\n     this->elements = elements;\n     this->ownedByCtfe = OWNEDcode;\n }\n \n ArrayLiteralExp *ArrayLiteralExp::create(Loc loc, Expressions *elements)\n {\n-    return new ArrayLiteralExp(loc, elements);\n+    return new ArrayLiteralExp(loc, NULL, elements);\n }\n \n bool ArrayLiteralExp::equals(RootObject *o)\n@@ -3806,6 +3807,7 @@ bool ArrayLiteralExp::equals(RootObject *o)\n Expression *ArrayLiteralExp::syntaxCopy()\n {\n     return new ArrayLiteralExp(loc,\n+        NULL,\n         basis ? basis->syntaxCopy() : NULL,\n         arraySyntaxCopy(elements));\n }\n@@ -4082,8 +4084,7 @@ Expression *StructLiteralExp::getField(Type *type, unsigned offset)\n                 z->setDim(length);\n                 for (size_t q = 0; q < length; ++q)\n                     (*z)[q] = e->copy();\n-                e = new ArrayLiteralExp(loc, z);\n-                e->type = type;\n+                e = new ArrayLiteralExp(loc, type, z);\n             }\n             else\n             {"}, {"sha": "2dd0b249458e8d373f0b407da4916a951d03ba17", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -410,9 +410,9 @@ class ArrayLiteralExp : public Expression\n     Expressions *elements;\n     OwnedBy ownedByCtfe;\n \n-    ArrayLiteralExp(Loc loc, Expressions *elements);\n-    ArrayLiteralExp(Loc loc, Expression *e);\n-    ArrayLiteralExp(Loc loc, Expression *basis, Expressions *elements);\n+    ArrayLiteralExp(Loc loc, Type *type, Expressions *elements);\n+    ArrayLiteralExp(Loc loc, Type *type, Expression *e);\n+    ArrayLiteralExp(Loc loc, Type *type, Expression *basis, Expressions *elements);\n     static ArrayLiteralExp *create(Loc loc, Expressions *elements);\n     Expression *syntaxCopy();\n     bool equals(RootObject *o);"}, {"sha": "d5319e55a6e60edac21003627f22d0e06de899d3", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -6632,8 +6632,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 if (tb2->ty == Tarray || tb2->ty == Tsarray)\n                 {\n                     // Make e2 into [e2]\n-                    exp->e2 = new ArrayLiteralExp(exp->e2->loc, exp->e2);\n-                    exp->e2->type = exp->type;\n+                    exp->e2 = new ArrayLiteralExp(exp->e2->loc, exp->type, exp->e2);\n                 }\n                 result = exp->optimize(WANTvalue);\n                 return;\n@@ -6669,8 +6668,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 if (tb1->ty == Tarray || tb1->ty == Tsarray)\n                 {\n                     // Make e1 into [e1]\n-                    exp->e1 = new ArrayLiteralExp(exp->e1->loc, exp->e1);\n-                    exp->e1->type = exp->type;\n+                    exp->e1 = new ArrayLiteralExp(exp->e1->loc, exp->type, exp->e1);\n                 }\n                 result = exp->optimize(WANTvalue);\n                 return;"}, {"sha": "ec26b2c70088a7a415b18175ac9a8f27f042e5e7", "filename": "gcc/d/dmd/idgen.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -267,6 +267,9 @@ Msgtable msgtable[] =\n     { \"_ArrayEq\", NULL },\n     { \"_ArrayPostblit\", NULL },\n     { \"_ArrayDtor\", NULL },\n+    { \"dup\", NULL },\n+    { \"_aaApply\", NULL },\n+    { \"_aaApply2\", NULL },\n \n     // For pragma's\n     { \"Pinline\", \"inline\" },"}, {"sha": "52e26bccd858881cabd7b98590845c8ef093dabf", "filename": "gcc/d/dmd/initsem.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Finitsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Finitsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -612,7 +612,7 @@ class InferTypeVisitor : public Visitor\n                 assert((*elements)[i]->op != TOKerror);\n             }\n \n-            Expression *e = new ArrayLiteralExp(init->loc, elements);\n+            Expression *e = new ArrayLiteralExp(init->loc, NULL, elements);\n             ExpInitializer *ei = new ExpInitializer(init->loc, e);\n             result = inferType(ei, sc);\n             return;\n@@ -857,8 +857,7 @@ class InitToExpressionVisitor : public Visitor\n                             elements2->setDim(dim);\n                             for (size_t j = 0; j < dim; j++)\n                                 (*elements2)[j] = e;\n-                            e = new ArrayLiteralExp(e->loc, elements2);\n-                            e->type = tn;\n+                            e = new ArrayLiteralExp(e->loc, tn, elements2);\n                             (*elements)[i] = e;\n                         }\n                     }\n@@ -877,8 +876,7 @@ class InitToExpressionVisitor : public Visitor\n                 }\n             }\n \n-            Expression *e = new ArrayLiteralExp(init->loc, elements);\n-            e->type = init->type;\n+            Expression *e = new ArrayLiteralExp(init->loc, init->type, elements);\n             result = e;\n             return;\n         }\n@@ -902,8 +900,7 @@ class InitToExpressionVisitor : public Visitor\n                 elements->setDim(d);\n                 for (size_t i = 0; i < d; i++)\n                     (*elements)[i] = e;\n-                ArrayLiteralExp *ae = new ArrayLiteralExp(e->loc, elements);\n-                ae->type = itype;\n+                ArrayLiteralExp *ae = new ArrayLiteralExp(e->loc, itype, elements);\n                 result = ae;\n                 return;\n             }"}, {"sha": "09161a313eefed778b7d7d8ce74db5a8ec079f94", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -2324,16 +2324,11 @@ Identifier *Type::getTypeInfoIdent()\n     size_t namelen = 19 + sizeof(len) * 3 + len + 1;\n     char *name = namelen <= sizeof(namebuf) ? namebuf : (char *)mem.xmalloc(namelen);\n \n-    sprintf(name, \"_D%lluTypeInfo_%s6__initZ\", (unsigned long long) 9 + len, buf.data);\n+    int length = sprintf(name, \"_D%lluTypeInfo_%s6__initZ\", (unsigned long long) 9 + len, buf.data);\n     //printf(\"%p, deco = %s, name = %s\\n\", this, deco, name);\n-    assert(strlen(name) < namelen);     // don't overflow the buffer\n+    assert(0 < length && length < namelen);     // don't overflow the buffer\n \n-    size_t off = 0;\n-#ifndef IN_GCC\n-    if (global.params.isOSX || (global.params.isWindows && !global.params.is64bit))\n-        ++off;                 // C mangling will add '_' back in\n-#endif\n-    Identifier *id = Identifier::idPool(name + off);\n+    Identifier *id = Identifier::idPool(name, length);\n \n     if (name != namebuf)\n         free(name);\n@@ -4340,8 +4335,7 @@ Expression *TypeSArray::defaultInitLiteral(Loc loc)\n     elements->setDim(d);\n     for (size_t i = 0; i < d; i++)\n         (*elements)[i] = NULL;\n-    ArrayLiteralExp *ae = new ArrayLiteralExp(Loc(), elementinit, elements);\n-    ae->type = this;\n+    ArrayLiteralExp *ae = new ArrayLiteralExp(Loc(), this, elementinit, elements);\n     return ae;\n }\n "}, {"sha": "171ed14f132268213732755fbbbb24437a0f809f", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -7020,7 +7020,7 @@ Expression *Parser::parsePrimaryExp()\n             if (keys)\n                 e = new AssocArrayLiteralExp(loc, keys, values);\n             else\n-                e = new ArrayLiteralExp(loc, values);\n+                e = new ArrayLiteralExp(loc, NULL, values);\n             break;\n         }\n "}, {"sha": "1d5f3fc1064e63a1219e6c842202e635bba3dd35", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -479,8 +479,7 @@ Expression *pointerBitmap(TraitsExp *e)\n     for (d_uns64 i = 0; i < cntdata; i++)\n         exps->push(new IntegerExp(e->loc, data[(size_t)i], Type::tsize_t));\n \n-    ArrayLiteralExp* ale = new ArrayLiteralExp(e->loc, exps);\n-    ale->type = Type::tsize_t->sarrayOf(cntdata + 1);\n+    ArrayLiteralExp* ale = new ArrayLiteralExp(e->loc, Type::tsize_t->sarrayOf(cntdata + 1), exps);\n     return ale;\n }\n "}, {"sha": "7fcd41ab214fcbfda60e7069b083ecf553bf26fd", "filename": "gcc/testsuite/gdc.test/compilable/cppmangle.d", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/255b2d916ec794078cfd0c351d3e921f8701142a/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d?ref=255b2d916ec794078cfd0c351d3e921f8701142a", "patch": "@@ -351,3 +351,24 @@ void test15789()\n {\n     test15789a(0);\n }\n+\n+/**************************************/\n+// 7030\n+\n+extern(C++)\n+{\n+    struct T\n+    {\n+        void foo(int) const;\n+        void bar(int);\n+        static __gshared int boo;\n+    }\n+}\n+\n+version (Posix)\n+{\n+    static assert(T.foo.mangleof == \"_ZNK1T3fooEi\");\n+    static assert(T.bar.mangleof == \"_ZN1T3barEi\");\n+    static assert(T.boo.mangleof == \"_ZN1T3booE\");\n+}\n+"}]}