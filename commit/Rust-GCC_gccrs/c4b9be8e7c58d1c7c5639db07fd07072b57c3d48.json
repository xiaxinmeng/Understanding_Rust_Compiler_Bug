{"sha": "c4b9be8e7c58d1c7c5639db07fd07072b57c3d48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiOWJlOGU3YzU4ZDFjN2M1NjM5ZGIwN2ZkMDcwNzJiNTdjM2Q0OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-17T03:00:42Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-17T03:00:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r756", "tree": {"sha": "49676fab6c6ffa01813f882c616e0ae2a680bec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49676fab6c6ffa01813f882c616e0ae2a680bec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48/comments", "author": null, "committer": null, "parents": [{"sha": "b7d3fabeea7f7917c5a08e2f11d1cdc107393ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d3fabeea7f7917c5a08e2f11d1cdc107393ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d3fabeea7f7917c5a08e2f11d1cdc107393ba0"}], "stats": {"total": 166, "additions": 100, "deletions": 66}, "files": [{"sha": "2ff7677c9cc0549bb855f8c3d9f10af3067c8210", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 100, "deletions": 66, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4b9be8e7c58d1c7c5639db07fd07072b57c3d48/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c4b9be8e7c58d1c7c5639db07fd07072b57c3d48", "patch": "@@ -1937,13 +1937,20 @@ expand_block_move (operands)\n    operands[3] is the alignment.\n    operands[4] is a temp register.\n    operands[5] is a temp register.\n-   ... */\n+   ...\n+   operands[3+num_regs] is the last temp register.\n+\n+   The block move type can be one of the following:\n+\tBLOCK_MOVE_NORMAL\tDo all of the block move.\n+\tBLOCK_MOVE_NOT_LAST\tDo all but the last store.\n+\tBLOCK_MOVE_LAST\t\tDo just the last store. */\n \n char *\n-output_block_move (insn, operands, num_regs)\n+output_block_move (insn, operands, num_regs, move_type)\n      rtx insn;\n      rtx operands[];\n      int num_regs;\n+     enum block_move_type move_type;\n {\n   rtx dest_reg\t\t= XEXP (operands[0], 0);\n   rtx src_reg\t\t= XEXP (operands[1], 0);\n@@ -1961,22 +1968,21 @@ output_block_move (insn, operands, num_regs)\n     char *load;\t\t\t/* load insn without nop */\n     char *load_nop;\t\t/* load insn with trailing nop */\n     char *store;\t\t/* store insn */\n+    char *final;\t\t/* if last_store used: NULL or swr */\n+    char *last_store;\t\t/* last store instruction */\n     int offset;\t\t\t/* current offset */\n     enum machine_mode mode;\t/* mode to use on (MEM) */\n   } load_store[4];\n \n-  /* Work around a bug in GCC, where it can give us a register\n+  /* Detect a bug in GCC, where it can give us a register\n      the same as one of the addressing registers.  */\n   for (i = 4; i < last_operand; i++)\n     {\n       if (reg_mentioned_p (operands[i], operands[0])\n \t  || reg_mentioned_p (operands[i], operands[1]))\n \t{\n-\t  /* register passed as address and temp register to block move  */\n-\t  /* To have a correct compiler, either this function\n-\t     has to handle the case, or something else has to make\n-\t     sure the case won't arise.  */\n-\t  abort ();\n+\t  error (\"register $%d passed as address and temp register to block move\",\n+\t\t   REGNO (operands[i]));\n \n \t  for (j = i+1; j < last_operand; j++)\n \t    operands[j-1] = operands[j];\n@@ -1990,26 +1996,34 @@ output_block_move (insn, operands, num_regs)\n   /* If we are given global or static addresses, and we would be\n      emitting a few instructions, try to save time by using a\n      temporary register for the pointer.  */\n-  if (bytes > 2*align)\n+  if (bytes > 2*align || move_type != BLOCK_MOVE_NORMAL)\n     {\n       if (CONSTANT_P (src_reg))\n \t{\n \t  if (TARGET_STATS)\n \t    mips_count_memory_refs (operands[1], 1);\n \n-\t  xoperands[1] = operands[1];\n-\t  xoperands[0] = src_reg = operands[ 3 + num_regs-- ];\n-\t  output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t  src_reg = operands[ 3 + num_regs-- ];\n+\t  if (move_type != BLOCK_MOVE_LAST)\n+\t    {\n+\t      xoperands[1] = operands[1];\n+\t      xoperands[0] = src_reg;\n+\t      output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t    }\n \t}\n \n       if (CONSTANT_P (dest_reg))\n \t{\n \t  if (TARGET_STATS)\n \t    mips_count_memory_refs (operands[0], 1);\n \n-\t  xoperands[1] = operands[0];\n-\t  xoperands[0] = dest_reg = operands[ 3 + num_regs-- ];\n-\t  output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t  dest_reg = operands[ 3 + num_regs-- ];\n+\t  if (move_type != BLOCK_MOVE_LAST)\n+\t    {\n+\t      xoperands[1] = operands[0];\n+\t      xoperands[0] = dest_reg;\n+\t      output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t    }\n \t}\n     }\n \n@@ -2019,75 +2033,76 @@ output_block_move (insn, operands, num_regs)\n   else if (num_regs < 1)\n     abort ();\n \n-  if (TARGET_GAS && set_noreorder++ == 0)\n+  if (TARGET_GAS && move_type != BLOCK_MOVE_LAST && set_noreorder++ == 0)\n     output_asm_insn (\".set\\tnoreorder\", operands);\n \n   while (bytes > 0)\n     {\n       load_store[num].offset = offset;\n \n-      dslots_load_total++;\n-      dslots_load_filled++;\n       if (bytes >= UNITS_PER_WORD && align >= UNITS_PER_WORD)\n \t{\n-\t  load_store[num].load     = \"lw\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lw\\t%0,%1%#\";\n-\t  load_store[num].store    = \"sw\\t%0,%1\";\n-\t  load_store[num].mode     = SImode;\n+\t  load_store[num].load       = \"lw\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"lw\\t%0,%1%#\";\n+\t  load_store[num].store      = \"sw\\t%0,%1\";\n+\t  load_store[num].last_store = \"sw\\t%0,%1\";\n+\t  load_store[num].final      = (char *)0;\n+\t  load_store[num].mode       = SImode;\n \t  offset += UNITS_PER_WORD;\n \t  bytes -= UNITS_PER_WORD;\n \t}\n \n-      else if (bytes >= UNITS_PER_WORD && TARGET_GAS)\n+      else if (bytes >= UNITS_PER_WORD)\n \t{\n #if BYTES_BIG_ENDIAN\n-\t  load_store[num].load     = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2\";\n-\t  load_store[num].load_nop = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2%#\";\n-\t  load_store[num].store    = \"swl\\t%0,%1\\n\\tswr\\t%0,%2\";\n+\t  load_store[num].load       = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2\";\n+\t  load_store[num].load_nop   = \"lwl\\t%0,%1\\n\\tlwr\\t%0,%2%#\";\n+\t  load_store[num].store      = \"swl\\t%0,%1\\n\\tswr\\t%0,%2\";\n+\t  load_store[num].last_store = \"swr\\t%0,%2\";\n+\t  load_store[num].final      = \"swl\\t%0,%1\";\n #else\n-\t  load_store[num].load     = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1%#\";\n-\t  load_store[num].store    = \"swl\\t%0,%2\\n\\tswr\\t%0,%1\";\n+\t  load_store[num].load\t     = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"lwl\\t%0,%2\\n\\tlwr\\t%0,%1%#\";\n+\t  load_store[num].store\t     = \"swl\\t%0,%2\\n\\tswr\\t%0,%1\";\n+\t  load_store[num].last_store = \"swr\\t%0,%1\";\n+\t  load_store[num].final      = \"swl\\t%0,%2\";\n #endif\n \t  load_store[num].mode = SImode;\n \t  offset += UNITS_PER_WORD;\n \t  bytes -= UNITS_PER_WORD;\n \t  use_lwl_lwr = TRUE;\n \t}\n \n-      else if (bytes >= UNITS_PER_WORD)\n-\t{\n-\t  load_store[num].load     = \"ulw\\t%0,%1\";\n-\t  load_store[num].load_nop = \"ulw\\t%0,%1%#\";\n-\t  load_store[num].store    = \"usw\\t%0,%1\";\n-\t  load_store[num].mode     = SImode;\n-\t  offset += UNITS_PER_WORD;\n-\t  bytes -= UNITS_PER_WORD;\n-\t}\n-\n       else if (bytes >= UNITS_PER_SHORT && align >= UNITS_PER_SHORT)\n \t{\n-\t  load_store[num].load     = \"lh\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lh\\t%0,%1%#\";\n-\t  load_store[num].store    = \"sh\\t%0,%1\";\n-\t  load_store[num].offset   = offset;\n-\t  load_store[num].mode     = HImode;\n+\t  load_store[num].load\t     = \"lh\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"lh\\t%0,%1%#\";\n+\t  load_store[num].store\t     = \"sh\\t%0,%1\";\n+\t  load_store[num].last_store = \"sh\\t%0,%1\";\n+\t  load_store[num].final      = (char *)0;\n+\t  load_store[num].offset     = offset;\n+\t  load_store[num].mode\t     = HImode;\n \t  offset += UNITS_PER_SHORT;\n \t  bytes -= UNITS_PER_SHORT;\n \t}\n \n       else\n \t{\n-\t  load_store[num].load     = \"lb\\t%0,%1\";\n-\t  load_store[num].load_nop = \"lb\\t%0,%1%#\";\n-\t  load_store[num].store    = \"sb\\t%0,%1\";\n-\t  load_store[num].mode     = QImode;\n+\t  load_store[num].load\t     = \"lb\\t%0,%1\";\n+\t  load_store[num].load_nop   = \"lb\\t%0,%1%#\";\n+\t  load_store[num].store\t     = \"sb\\t%0,%1\";\n+\t  load_store[num].last_store = \"sb\\t%0,%1\";\n+\t  load_store[num].final      = (char *)0;\n+\t  load_store[num].mode\t     = QImode;\n \t  offset++;\n \t  bytes--;\n \t}\n \n-      if (TARGET_STATS)\n+      if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)\n \t{\n+\t  dslots_load_total++;\n+\t  dslots_load_filled++;\n+\n \t  if (CONSTANT_P (src_reg))\n \t    mips_count_memory_refs (src_reg, 1);\n \n@@ -2104,34 +2119,40 @@ output_block_move (insn, operands, num_regs)\n \t  if (num == 1)\n \t    {\n \t      load_store[0].load = load_store[0].load_nop;\n-\t      dslots_load_filled--;\n+\t      if (TARGET_STATS && move_type != BLOCK_MOVE_LAST)\n+\t\tdslots_load_filled--;\n \t    }\n \n-\t  for (i = 0; i < num; i++)\n+\t  if (move_type != BLOCK_MOVE_LAST)\n \t    {\n-\t      int offset;\n+\t      for (i = 0; i < num; i++)\n+\t\t{\n+\t\t  int offset;\n \n-\t      if (!operands[i+4])\n-\t\tabort ();\n+\t\t  if (!operands[i+4])\n+\t\t    abort ();\n \n-\t      if (GET_MODE (operands[i+4]) != load_store[i].mode)\n-\t\toperands[i+4] = gen_rtx (REG, load_store[i].mode, REGNO (operands[i+4]));\n+\t\t  if (GET_MODE (operands[i+4]) != load_store[i].mode)\n+\t\t    operands[i+4] = gen_rtx (REG, load_store[i].mode, REGNO (operands[i+4]));\n \n-\t      offset = load_store[i].offset;\n-\t      xoperands[0] = operands[i+4];\n-\t      xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t      plus_constant (src_reg, offset));\n+\t\t  offset = load_store[i].offset;\n+\t\t  xoperands[0] = operands[i+4];\n+\t\t  xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t\t  plus_constant (src_reg, offset));\n \n-\t      if (use_lwl_lwr)\n-\t\txoperands[2] = gen_rtx (MEM, load_store[i].mode,\n-\t\t\t\t\tplus_constant (src_reg, UNITS_PER_WORD-1+offset));\n+\t\t  if (use_lwl_lwr)\n+\t\t    xoperands[2] = gen_rtx (MEM, load_store[i].mode,\n+\t\t\t\t\t    plus_constant (src_reg, UNITS_PER_WORD-1+offset));\n \n-\t      output_asm_insn (load_store[i].load, xoperands);\n+\t\t  output_asm_insn (load_store[i].load, xoperands);\n+\t\t}\n \t    }\n \n \t  for (i = 0; i < num; i++)\n \t    {\n+\t      int last_p = (i == num-1 && bytes == 0);\n \t      int offset = load_store[i].offset;\n+\n \t      xoperands[0] = operands[i+4];\n \t      xoperands[1] = gen_rtx (MEM, load_store[i].mode,\n \t\t\t\t      plus_constant (dest_reg, offset));\n@@ -2141,15 +2162,28 @@ output_block_move (insn, operands, num_regs)\n \t\txoperands[2] = gen_rtx (MEM, load_store[i].mode,\n \t\t\t\t\tplus_constant (dest_reg, UNITS_PER_WORD-1+offset));\n \n-\t      output_asm_insn (load_store[i].store, xoperands);\n+\t      if (move_type == BLOCK_MOVE_NORMAL)\n+\t\toutput_asm_insn (load_store[i].store, xoperands);\n+\n+\t      else if (move_type == BLOCK_MOVE_NOT_LAST)\n+\t\t{\n+\t\t  if (!last_p)\n+\t\t    output_asm_insn (load_store[i].store, xoperands);\n+\n+\t\t  else if (load_store[i].final != (char *)0)\n+\t\t    output_asm_insn (load_store[i].final, xoperands);\n+\t\t}\n+\n+\t      else if (last_p)\n+\t\toutput_asm_insn (load_store[i].last_store, xoperands);\n \t    }\n \n \t  num = 0;\t\t/* reset load_store */\n \t  use_lwl_lwr = FALSE;\t/* reset whether or not we used lwl/lwr */\n \t}\n     }\n \n-  if (TARGET_GAS && --set_noreorder == 0)\n+  if (TARGET_GAS && move_type != BLOCK_MOVE_LAST && --set_noreorder == 0)\n     output_asm_insn (\".set\\treorder\", operands);\n \n   return \"\";"}]}