{"sha": "006601890b953c9177624f9f533b997f344802ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2NjAxODkwYjk1M2M5MTc3NjI0ZjlmNTMzYjk5N2YzNDQ4MDJhZA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-06T21:06:20Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2008-05-06T21:06:20Z"}, "message": "arith.c: (gfc_arith_concat...\n\n\t* arith.c: (gfc_arith_concat, gfc_compare_string,\n\tgfc_compare_with_Cstring, hollerith2representation,\n\tgfc_hollerith2int, gfc_hollerith2real, gfc_hollerith2complex,\n\tgfc_hollerith2character, gfc_hollerith2logical): Use wide\n\tcharacters for character constants.\n\t* data.c (create_character_intializer): Likewise.\n\t* decl.c (gfc_set_constant_character_len): Likewise.\n\t* dump-parse-tree.c (show_char_const): Correctly dump wide\n\tcharacter strings.\n\terror.c (print_wide_char): Rename into gfc_print_wide_char.\n\t(show_locus): Adapt to new prototype of gfc_print_wide_char.\n\texpr.c (free_expr0): Representation is now disjunct from\n\tcharacter string value, so we always free it.\n\t(gfc_copy_expr, find_substring_ref, gfc_simplify_expr): Adapt\n\tto wide character strings.\n\t* gfortran.h (gfc_expr): Make value.character.string a wide string.\n\t(gfc_wide_toupper, gfc_wide_strncasecmp, gfc_wide_memset,\n\tgfc_widechar_to_char, gfc_char_to_widechar): New prototypes.\n\t(gfc_get_wide_string): New macro.\n\t(gfc_print_wide_char): New prototype.\n\t* io.c (format_string): Make a wide string.\n\t(next_char, gfc_match_format, compare_to_allowed_values, \n\tgfc_match_open): Deal with wide strings.\n\t* module.c (mio_expr): Convert between wide strings and ASCII ones.\n\t* primary.c (match_hollerith_constant, match_charkind_name): \n\tHandle wide strings.\n\t* resolve.c (build_default_init_expr): Likewise.\n\t* scanner.c (gfc_wide_toupper, gfc_wide_memset,\n\tgfc_char_to_widechar): New functions.\n\t(wide_strchr, gfc_widechar_to_char, gfc_wide_strncasecmp):\n\tChanges in prototypes.\n\t(gfc_define_undef_line, load_line, preprocessor_line,\n\tinclude_line, load_file, gfc_read_orig_filename): Handle wide\n\tstrings.\n\t* simplify.c (gfc_simplify_achar, gfc_simplify_adjustl,\n\tgfc_simplify_adjustr, gfc_simplify_char, gfc_simplify_iachar,\n\tgfc_simplify_ichar, simplify_min_max, gfc_simplify_new_line,\n\tgfc_simplify_repeat): Handle wide strings.\n\t(wide_strspn, wide_strcspn): New helper functions.\n\t(gfc_simplify_scan, gfc_simplify_trim, gfc_simplify_verify):\n\tHandle wide strings.\n\t* symbol.c (generate_isocbinding_symbol): Likewise.\n\t* target-memory.c (size_character, gfc_target_expr_size,\n\tencode_character, gfc_target_encode_expr, gfc_interpret_character,\n\tgfc_target_interpret_expr): Handle wide strings.\n\t* trans-const.c (gfc_conv_string_init): Lower wide strings to\n\tnarrow ones.\n\t(gfc_conv_constant_to_tree): Likewise.\n\t* trans-expr.c (gfc_conv_substring_expr): Handle wide strings.\n\t* trans-io.c (gfc_new_nml_name_expr): Likewise.\n\t* trans-stmt.c (gfc_trans_label_assign): Likewise.\n\nFrom-SVN: r135006", "tree": {"sha": "afe9f21644dc49be8c1557eb5347bf2f587920d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afe9f21644dc49be8c1557eb5347bf2f587920d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/006601890b953c9177624f9f533b997f344802ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006601890b953c9177624f9f533b997f344802ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/006601890b953c9177624f9f533b997f344802ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006601890b953c9177624f9f533b997f344802ad/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b38192d61001d9cd1b15baf233a9e8847d06889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b38192d61001d9cd1b15baf233a9e8847d06889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b38192d61001d9cd1b15baf233a9e8847d06889"}], "stats": {"total": 690, "additions": 458, "deletions": 232}, "files": [{"sha": "66873c0723c144c1abf3d0050c9a67ac7f0fba54", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -1,3 +1,57 @@\n+2008-05-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\t* arith.c: (gfc_arith_concat, gfc_compare_string,\n+\tgfc_compare_with_Cstring, hollerith2representation,\n+\tgfc_hollerith2int, gfc_hollerith2real, gfc_hollerith2complex,\n+\tgfc_hollerith2character, gfc_hollerith2logical): Use wide\n+\tcharacters for character constants.\n+\t* data.c (create_character_intializer): Likewise.\n+\t* decl.c (gfc_set_constant_character_len): Likewise.\n+\t* dump-parse-tree.c (show_char_const): Correctly dump wide\n+\tcharacter strings.\n+\terror.c (print_wide_char): Rename into gfc_print_wide_char.\n+\t(show_locus): Adapt to new prototype of gfc_print_wide_char.\n+\texpr.c (free_expr0): Representation is now disjunct from\n+\tcharacter string value, so we always free it.\n+\t(gfc_copy_expr, find_substring_ref, gfc_simplify_expr): Adapt\n+\tto wide character strings.\n+\t* gfortran.h (gfc_expr): Make value.character.string a wide string.\n+\t(gfc_wide_toupper, gfc_wide_strncasecmp, gfc_wide_memset,\n+\tgfc_widechar_to_char, gfc_char_to_widechar): New prototypes.\n+\t(gfc_get_wide_string): New macro.\n+\t(gfc_print_wide_char): New prototype.\n+\t* io.c (format_string): Make a wide string.\n+\t(next_char, gfc_match_format, compare_to_allowed_values, \n+\tgfc_match_open): Deal with wide strings.\n+\t* module.c (mio_expr): Convert between wide strings and ASCII ones.\n+\t* primary.c (match_hollerith_constant, match_charkind_name): \n+\tHandle wide strings.\n+\t* resolve.c (build_default_init_expr): Likewise.\n+\t* scanner.c (gfc_wide_toupper, gfc_wide_memset,\n+\tgfc_char_to_widechar): New functions.\n+\t(wide_strchr, gfc_widechar_to_char, gfc_wide_strncasecmp):\n+\tChanges in prototypes.\n+\t(gfc_define_undef_line, load_line, preprocessor_line,\n+\tinclude_line, load_file, gfc_read_orig_filename): Handle wide\n+\tstrings.\n+\t* simplify.c (gfc_simplify_achar, gfc_simplify_adjustl,\n+\tgfc_simplify_adjustr, gfc_simplify_char, gfc_simplify_iachar,\n+\tgfc_simplify_ichar, simplify_min_max, gfc_simplify_new_line,\n+\tgfc_simplify_repeat): Handle wide strings.\n+\t(wide_strspn, wide_strcspn): New helper functions.\n+\t(gfc_simplify_scan, gfc_simplify_trim, gfc_simplify_verify):\n+\tHandle wide strings.\n+\t* symbol.c (generate_isocbinding_symbol): Likewise.\n+\t* target-memory.c (size_character, gfc_target_expr_size,\n+\tencode_character, gfc_target_encode_expr, gfc_interpret_character,\n+\tgfc_target_interpret_expr): Handle wide strings.\n+\t* trans-const.c (gfc_conv_string_init): Lower wide strings to\n+\tnarrow ones.\n+\t(gfc_conv_constant_to_tree): Likewise.\n+\t* trans-expr.c (gfc_conv_substring_expr): Handle wide strings.\n+\t* trans-io.c (gfc_new_nml_name_expr): Likewise.\n+\t* trans-stmt.c (gfc_trans_label_assign): Likewise.\n+\n 2008-05-06  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* simplify.c (gfc_simplify_bessel_j0,gfc_simplify_bessel_j1,"}, {"sha": "cbfcf291049579bb136846f8437bdeea64dab633", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -1102,14 +1102,15 @@ gfc_arith_concat (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n   len = op1->value.character.length + op2->value.character.length;\n \n-  result->value.character.string = gfc_getmem (len + 1);\n+  result->value.character.string = gfc_get_wide_string (len + 1);\n   result->value.character.length = len;\n \n   memcpy (result->value.character.string, op1->value.character.string,\n-\t  op1->value.character.length);\n+\t  op1->value.character.length * sizeof (gfc_char_t));\n \n-  memcpy (result->value.character.string + op1->value.character.length,\n-\t  op2->value.character.string, op2->value.character.length);\n+  memcpy (&result->value.character.string[op1->value.character.length],\n+\t  op2->value.character.string,\n+\t  op2->value.character.length * sizeof (gfc_char_t));\n \n   result->value.character.string[len] = '\\0';\n \n@@ -1203,7 +1204,8 @@ compare_complex (gfc_expr *op1, gfc_expr *op2)\n int\n gfc_compare_string (gfc_expr *a, gfc_expr *b)\n {\n-  int len, alen, blen, i, ac, bc;\n+  int len, alen, blen, i;\n+  gfc_char_t ac, bc;\n \n   alen = a->value.character.length;\n   blen = b->value.character.length;\n@@ -1212,10 +1214,8 @@ gfc_compare_string (gfc_expr *a, gfc_expr *b)\n \n   for (i = 0; i < len; i++)\n     {\n-      /* We cast to unsigned char because default char, if it is signed,\n-\t would lead to ac < 0 for string[i] > 127.  */\n-      ac = (unsigned char) ((i < alen) ? a->value.character.string[i] : ' ');\n-      bc = (unsigned char) ((i < blen) ? b->value.character.string[i] : ' ');\n+      ac = ((i < alen) ? a->value.character.string[i] : ' ');\n+      bc = ((i < blen) ? b->value.character.string[i] : ' ');\n \n       if (ac < bc)\n \treturn -1;\n@@ -1231,7 +1231,8 @@ gfc_compare_string (gfc_expr *a, gfc_expr *b)\n int\n gfc_compare_with_Cstring (gfc_expr *a, const char *b, bool case_sensitive)\n {\n-  int len, alen, blen, i, ac, bc;\n+  int len, alen, blen, i;\n+  gfc_char_t ac, bc;\n \n   alen = a->value.character.length;\n   blen = strlen (b);\n@@ -1240,10 +1241,8 @@ gfc_compare_with_Cstring (gfc_expr *a, const char *b, bool case_sensitive)\n \n   for (i = 0; i < len; i++)\n     {\n-      /* We cast to unsigned char because default char, if it is signed,\n-\t would lead to ac < 0 for string[i] > 127.  */\n-      ac = (unsigned char) ((i < alen) ? a->value.character.string[i] : ' ');\n-      bc = (unsigned char) ((i < blen) ? b[i] : ' ');\n+      ac = ((i < alen) ? a->value.character.string[i] : ' ');\n+      bc = ((i < blen) ? b[i] : ' ');\n \n       if (!case_sensitive)\n \t{\n@@ -2438,7 +2437,7 @@ hollerith2representation (gfc_expr *result, gfc_expr *src)\n \n   result->representation.string = gfc_getmem (result_len + 1);\n   memcpy (result->representation.string, src->representation.string,\n-\tMIN (result_len, src_len));\n+\t  MIN (result_len, src_len));\n \n   if (src_len < result_len)\n     memset (&result->representation.string[src_len], ' ', result_len - src_len);\n@@ -2462,8 +2461,8 @@ gfc_hollerith2int (gfc_expr *src, int kind)\n   result->where = src->where;\n \n   hollerith2representation (result, src);\n-  gfc_interpret_integer(kind, (unsigned char *) result->representation.string,\n-\t\t\tresult->representation.length, result->value.integer);\n+  gfc_interpret_integer (kind, (unsigned char *) result->representation.string,\n+\t\t\t result->representation.length, result->value.integer);\n \n   return result;\n }\n@@ -2486,8 +2485,8 @@ gfc_hollerith2real (gfc_expr *src, int kind)\n   result->where = src->where;\n \n   hollerith2representation (result, src);\n-  gfc_interpret_float(kind, (unsigned char *) result->representation.string,\n-\t\t      result->representation.length, result->value.real);\n+  gfc_interpret_float (kind, (unsigned char *) result->representation.string,\n+\t\t       result->representation.length, result->value.real);\n \n   return result;\n }\n@@ -2510,9 +2509,9 @@ gfc_hollerith2complex (gfc_expr *src, int kind)\n   result->where = src->where;\n \n   hollerith2representation (result, src);\n-  gfc_interpret_complex(kind, (unsigned char *) result->representation.string,\n-\t\t\tresult->representation.length, result->value.complex.r,\n-\t\t\tresult->value.complex.i);\n+  gfc_interpret_complex (kind, (unsigned char *) result->representation.string,\n+\t\t\t result->representation.length, result->value.complex.r,\n+\t\t\t result->value.complex.i);\n \n   return result;\n }\n@@ -2529,8 +2528,9 @@ gfc_hollerith2character (gfc_expr *src, int kind)\n   result->ts.type = BT_CHARACTER;\n   result->ts.kind = kind;\n \n-  result->value.character.string = result->representation.string;\n   result->value.character.length = result->representation.length;\n+  result->value.character.string\n+    = gfc_char_to_widechar (result->representation.string);\n \n   return result;\n }\n@@ -2553,8 +2553,8 @@ gfc_hollerith2logical (gfc_expr *src, int kind)\n   result->where = src->where;\n \n   hollerith2representation (result, src);\n-  gfc_interpret_logical(kind, (unsigned char *) result->representation.string,\n-\t\t\tresult->representation.length, &result->value.logical);\n+  gfc_interpret_logical (kind, (unsigned char *) result->representation.string,\n+\t\t\t result->representation.length, &result->value.logical);\n \n   return result;\n }"}, {"sha": "6cc7223af2f37422364aba1376c87c5b2df95613", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -151,10 +151,8 @@ static gfc_expr *\n create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n \t\t\t     gfc_ref *ref, gfc_expr *rvalue)\n {\n-  int len;\n-  int start;\n-  int end;\n-  char *dest, *rvalue_string;\n+  int len, start, end;\n+  gfc_char_t *dest;\n \t    \n   gfc_extract_int (ts->cl->length, &len);\n \n@@ -165,13 +163,13 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n       init->expr_type = EXPR_CONSTANT;\n       init->ts = *ts;\n       \n-      dest = gfc_getmem (len + 1);\n+      dest = gfc_get_wide_string (len + 1);\n       dest[len] = '\\0';\n       init->value.character.length = len;\n       init->value.character.string = dest;\n       /* Blank the string if we're only setting a substring.  */\n       if (ref != NULL)\n-\tmemset (dest, ' ', len);\n+\tgfc_wide_memset (dest, ' ', len);\n     }\n   else\n     dest = init->value.character.string;\n@@ -208,15 +206,9 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n \n   /* Copy the initial value.  */\n   if (rvalue->ts.type == BT_HOLLERITH)\n-    {\n-      len = rvalue->representation.length;\n-      rvalue_string = rvalue->representation.string;\n-    }\n+    len = rvalue->representation.length;\n   else\n-    {\n-      len = rvalue->value.character.length;\n-      rvalue_string = rvalue->value.character.string;\n-    }\n+    len = rvalue->value.character.length;\n \n   if (len > end - start)\n     {\n@@ -225,16 +217,26 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n \t\t       \"at %L\", &rvalue->where);\n     }\n \n-  memcpy (&dest[start], rvalue_string, len);\n+  if (rvalue->ts.type == BT_HOLLERITH)\n+    {\n+      int i;\n+      for (i = 0; i < len; i++)\n+\tdest[start+i] = rvalue->representation.string[i];\n+    }\n+  else\n+    memcpy (&dest[start], rvalue->value.character.string,\n+\t    len * sizeof (gfc_char_t));\n \n   /* Pad with spaces.  Substrings will already be blanked.  */\n   if (len < end - start && ref == NULL)\n-    memset (&dest[start + len], ' ', end - (start + len));\n+    gfc_wide_memset (&dest[start + len], ' ', end - (start + len));\n \n   if (rvalue->ts.type == BT_HOLLERITH)\n     {\n       init->representation.length = init->value.character.length;\n-      init->representation.string = init->value.character.string;\n+      init->representation.string\n+\t= gfc_widechar_to_char (init->value.character.string,\n+\t\t\t\tinit->value.character.length);\n     }\n \n   return init;"}, {"sha": "24606c448cf329df6986f7e6ae79ed1c9d09c1fd", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -1089,7 +1089,7 @@ build_sym (const char *name, gfc_charlen *cl,\n void\n gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n {\n-  char *s;\n+  gfc_char_t *s;\n   int slen;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n@@ -1098,10 +1098,11 @@ gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n   slen = expr->value.character.length;\n   if (len != slen)\n     {\n-      s = gfc_getmem (len + 1);\n-      memcpy (s, expr->value.character.string, MIN (len, slen));\n+      s = gfc_get_wide_string (len + 1);\n+      memcpy (s, expr->value.character.string,\n+\t      MIN (len, slen) * sizeof (gfc_char_t));\n       if (len > slen)\n-\tmemset (&s[slen], ' ', len - slen);\n+\tgfc_wide_memset (&s[slen], ' ', len - slen);\n \n       if (gfc_option.warn_character_truncation && slen > len)\n \tgfc_warning_now (\"CHARACTER expression at %L is being truncated \""}, {"sha": "44a4941e7b422f2bf49f1bf5e2f62dfb1ba23fbf", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -301,7 +301,7 @@ show_constructor (gfc_constructor *c)\n \n \n static void\n-show_char_const (const char *c, int length)\n+show_char_const (const gfc_char_t *c, int length)\n {\n   int i;\n \n@@ -310,10 +310,8 @@ show_char_const (const char *c, int length)\n     {\n       if (c[i] == '\\'')\n \tfputs (\"''\", dumpfile);\n-      else if (ISPRINT (c[i]))\n-\tfputc (c[i], dumpfile);\n       else\n-\tfprintf (dumpfile, \"' // ACHAR(%d) // '\", c[i]);\n+\tfputs (gfc_print_wide_char (c[i]), dumpfile);\n     }\n   fputc ('\\'', dumpfile);\n }"}, {"sha": "a9cbe9ef5f27f47cea7072ad1875416b4c4a77a3", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -152,48 +152,51 @@ error_integer (long int i)\n }\n \n \n-/* Show the file, where it was included, and the source line, give a\n-   locus.  Calls error_printf() recursively, but the recursion is at\n-   most one level deep.  */\n+static char wide_char_print_buffer[11];\n \n-static void\n-print_wide_char (gfc_char_t c)\n+const char *\n+gfc_print_wide_char (gfc_char_t c)\n {\n   static const char xdigit[16] = { '0', '1', '2', '3', '4', '5', '6',\n     '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-  char buf[9];\n+  char *buf = wide_char_print_buffer;\n \n   if (gfc_wide_is_printable (c))\n-    error_char (c);\n+    {\n+      buf[1] = '\\0';\n+      buf[0] = (unsigned char) c;\n+    }\n   else if (c < ((gfc_char_t) 1 << 8))\n     {\n-      buf[2] = '\\0';\n-      buf[1] = xdigit[c & 0x0F];\n+      buf[4] = '\\0';\n+      buf[3] = xdigit[c & 0x0F];\n       c = c >> 4;\n-      buf[0] = xdigit[c & 0x0F];\n+      buf[2] = xdigit[c & 0x0F];\n \n-      error_char ('\\\\');\n-      error_char ('x');\n-      error_string (buf);\n+      buf[1] = '\\\\';\n+      buf[0] = 'x';\n     }\n   else if (c < ((gfc_char_t) 1 << 16))\n     {\n-      buf[4] = '\\0';\n-      buf[3] = xdigit[c & 0x0F];\n+      buf[6] = '\\0';\n+      buf[5] = xdigit[c & 0x0F];\n       c = c >> 4;\n-      buf[2] = xdigit[c & 0x0F];\n+      buf[4] = xdigit[c & 0x0F];\n       c = c >> 4;\n-      buf[1] = xdigit[c & 0x0F];\n+      buf[3] = xdigit[c & 0x0F];\n       c = c >> 4;\n-      buf[0] = xdigit[c & 0x0F];\n+      buf[2] = xdigit[c & 0x0F];\n \n-      error_char ('\\\\');\n-      error_char ('u');\n-      error_string (buf);\n+      buf[1] = '\\\\';\n+      buf[0] = 'u';\n     }\n   else\n     {\n-      buf[8] = '\\0';\n+      buf[10] = '\\0';\n+      buf[9] = xdigit[c & 0x0F];\n+      c = c >> 4;\n+      buf[8] = xdigit[c & 0x0F];\n+      c = c >> 4;\n       buf[7] = xdigit[c & 0x0F];\n       c = c >> 4;\n       buf[6] = xdigit[c & 0x0F];\n@@ -205,17 +208,18 @@ print_wide_char (gfc_char_t c)\n       buf[3] = xdigit[c & 0x0F];\n       c = c >> 4;\n       buf[2] = xdigit[c & 0x0F];\n-      c = c >> 4;\n-      buf[1] = xdigit[c & 0x0F];\n-      c = c >> 4;\n-      buf[0] = xdigit[c & 0x0F];\n \n-      error_char ('\\\\');\n-      error_char ('U');\n-      error_string (buf);\n+      buf[1] = '\\\\';\n+      buf[0] = 'U';\n     }\n+\n+  return buf;\n }\n \n+/* Show the file, where it was included, and the source line, give a\n+   locus.  Calls error_printf() recursively, but the recursion is at\n+   most one level deep.  */\n+\n static void error_printf (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n \n static void\n@@ -317,7 +321,7 @@ show_locus (locus *loc, int c1, int c2)\n       if (c == '\\t')\n \tc = ' ';\n \n-      print_wide_char (c);\n+      error_string (gfc_print_wide_char (c));\n     }\n \n   error_char ('\\n');"}, {"sha": "87ea9e95090c0be9d846ce095d0a87ede41f02e0", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -164,9 +164,8 @@ free_expr0 (gfc_expr *e)\n \t  break;\n \t}\n \n-      /* Free the representation, except in character constants where it\n-\t is the same as value.character.string and thus already freed.  */\n-      if (e->representation.string && e->ts.type != BT_CHARACTER)\n+      /* Free the representation.  */\n+      if (e->representation.string)\n \tgfc_free (e->representation.string);\n \n       break;\n@@ -393,7 +392,8 @@ gfc_expr *\n gfc_copy_expr (gfc_expr *p)\n {\n   gfc_expr *q;\n-  char *s;\n+  gfc_char_t *s;\n+  char *c;\n \n   if (p == NULL)\n     return NULL;\n@@ -404,20 +404,19 @@ gfc_copy_expr (gfc_expr *p)\n   switch (q->expr_type)\n     {\n     case EXPR_SUBSTRING:\n-      s = gfc_getmem (p->value.character.length + 1);\n+      s = gfc_get_wide_string (p->value.character.length + 1);\n       q->value.character.string = s;\n-\n-      memcpy (s, p->value.character.string, p->value.character.length + 1);\n+      memcpy (s, p->value.character.string,\n+\t      (p->value.character.length + 1) * sizeof (gfc_char_t));\n       break;\n \n     case EXPR_CONSTANT:\n       /* Copy target representation, if it exists.  */\n       if (p->representation.string)\n \t{\n-\t  s = gfc_getmem (p->representation.length + 1);\n-\t  q->representation.string = s;\n-\n-\t  memcpy (s, p->representation.string, p->representation.length + 1);\n+\t  c = gfc_getmem (p->representation.length + 1);\n+\t  q->representation.string = c;\n+\t  memcpy (c, p->representation.string, (p->representation.length + 1));\n \t}\n \n       /* Copy the values of any pointer components of p->value.  */\n@@ -443,10 +442,11 @@ gfc_copy_expr (gfc_expr *p)\n \n \tcase BT_CHARACTER:\n \t  if (p->representation.string)\n-\t    q->value.character.string = q->representation.string;\n+\t    q->value.character.string\n+\t      = gfc_char_to_widechar (q->representation.string);\n \t  else\n \t    {\n-\t      s = gfc_getmem (p->value.character.length + 1);\n+\t      s = gfc_get_wide_string (p->value.character.length + 1);\n \t      q->value.character.string = s;\n \n \t      /* This is the case for the C_NULL_CHAR named constant.  */\n@@ -460,7 +460,7 @@ gfc_copy_expr (gfc_expr *p)\n \t\t}\n \t      else\n \t\tmemcpy (s, p->value.character.string,\n-\t\t\tp->value.character.length + 1);\n+\t\t\t(p->value.character.length + 1) * sizeof (gfc_char_t));\n \t    }\n \t  break;\n \n@@ -1379,7 +1379,7 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n   int end;\n   int start;\n   int length;\n-  char *chr;\n+  gfc_char_t *chr;\n \n   if (p->ref->u.ss.start->expr_type != EXPR_CONSTANT\n       || p->ref->u.ss.end->expr_type != EXPR_CONSTANT)\n@@ -1392,9 +1392,10 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n   start = (int) mpz_get_ui (p->ref->u.ss.start->value.integer);\n   length = end - start + 1;\n \n-  chr = (*newp)->value.character.string = gfc_getmem (length + 1);\n+  chr = (*newp)->value.character.string = gfc_get_wide_string (length + 1);\n   (*newp)->value.character.length = length;\n-  memcpy (chr, &p->value.character.string[start - 1], length);\n+  memcpy (chr, &p->value.character.string[start - 1],\n+\t  length * sizeof (gfc_char_t));\n   chr[length] = '\\0';\n   return SUCCESS;\n }\n@@ -1592,7 +1593,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \n       if (gfc_is_constant_expr (p))\n \t{\n-\t  char *s;\n+\t  gfc_char_t *s;\n \t  int start, end;\n \n \t  if (p->ref && p->ref->u.ss.start)\n@@ -1608,8 +1609,9 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  else\n \t    end = p->value.character.length;\n \n-\t  s = gfc_getmem (end - start + 2);\n-\t  memcpy (s, p->value.character.string + start, end - start);\n+\t  s = gfc_get_wide_string (end - start + 2);\n+\t  memcpy (s, p->value.character.string + start,\n+\t\t  (end - start) * sizeof (gfc_char_t));\n \t  s[end - start + 1] = '\\0';  /* TODO: C-style string.  */\n \t  gfc_free (p->value.character.string);\n \t  p->value.character.string = s;"}, {"sha": "b11cfa3c24d1531945e5c0d9424def476fdc2661", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -1497,7 +1497,7 @@ typedef struct gfc_expr\n     struct\n     {\n       int length;\n-      char *string;\n+      gfc_char_t *string;\n     }\n     character;\n \n@@ -1959,7 +1959,14 @@ int gfc_wide_is_printable (gfc_char_t);\n int gfc_wide_is_digit (gfc_char_t);\n int gfc_wide_fits_in_byte (gfc_char_t);\n gfc_char_t gfc_wide_tolower (gfc_char_t);\n+gfc_char_t gfc_wide_toupper (gfc_char_t);\n size_t gfc_wide_strlen (const gfc_char_t *);\n+int gfc_wide_strncasecmp (const gfc_char_t *, const char *, size_t);\n+gfc_char_t *gfc_wide_memset (gfc_char_t *, gfc_char_t, size_t);\n+char *gfc_widechar_to_char (const gfc_char_t *, int);\n+gfc_char_t *gfc_char_to_widechar (const char *);\n+\n+#define gfc_get_wide_string(n) gfc_getmem((n) * sizeof(gfc_char_t))\n \n void gfc_skip_comments (void);\n gfc_char_t gfc_next_char_literal (int);\n@@ -2019,6 +2026,8 @@ typedef struct gfc_error_buf\n void gfc_error_init_1 (void);\n void gfc_buffer_error (int);\n \n+const char *gfc_print_wide_char (gfc_char_t);\n+\n void gfc_warning (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_warning_now (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_clear_warning (void);"}, {"sha": "736253fe1599d76cda0752cb0f13b8d558af30d2", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -117,7 +117,7 @@ format_token;\n /* Local variables for checking format strings.  The saved_token is\n    used to back up by a single format token during the parsing\n    process.  */\n-static char *format_string;\n+static gfc_char_t *format_string;\n static int format_length, use_last_char;\n \n static format_token saved_token;\n@@ -165,7 +165,7 @@ next_char (int in_string)\n   if (mode == MODE_COPY)\n     *format_string++ = c;\n \n-  c = TOUPPER ((unsigned char) c);\n+  c = gfc_wide_toupper (c);\n   return c;\n }\n \n@@ -782,7 +782,7 @@ check_format (bool is_input)\n \tgfc_warning (\"The H format specifier at %C is\"\n \t\t     \" a Fortran 95 deleted feature\");\n \n-      if(mode == MODE_STRING)\n+      if (mode == MODE_STRING)\n \t{\n \t  format_string += value;\n \t  format_length -= value;\n@@ -1010,7 +1010,8 @@ gfc_match_format (void)\n   e->ts.type = BT_CHARACTER;\n   e->ts.kind = gfc_default_character_kind;\n   e->where = start;\n-  e->value.character.string = format_string = gfc_getmem (format_length + 1);\n+  e->value.character.string = format_string\n+\t\t\t    = gfc_get_wide_string (format_length + 1);\n   e->value.character.length = format_length;\n   gfc_statement_label->format = e;\n \n@@ -1412,13 +1413,13 @@ gfc_resolve_open (gfc_open *open)\n static int\n compare_to_allowed_values (const char *specifier, const char *allowed[],\n \t\t\t   const char *allowed_f2003[], \n-\t\t\t   const char *allowed_gnu[], char *value,\n+\t\t\t   const char *allowed_gnu[], gfc_char_t *value,\n \t\t\t   const char *statement, bool warn)\n {\n   int i;\n   unsigned int len;\n \n-  len = strlen (value);\n+  len = gfc_wide_strlen (value);\n   if (len > 0)\n   {\n     for (len--; len > 0; len--)\n@@ -1429,13 +1430,13 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \n   for (i = 0; allowed[i]; i++)\n     if (len == strlen (allowed[i])\n-\t&& strncasecmp (value, allowed[i], strlen (allowed[i])) == 0)\n+\t&& gfc_wide_strncasecmp (value, allowed[i], strlen (allowed[i])) == 0)\n       return 1;\n \n   for (i = 0; allowed_f2003 && allowed_f2003[i]; i++)\n     if (len == strlen (allowed_f2003[i])\n-\t&& strncasecmp (value, allowed_f2003[i], strlen (allowed_f2003[i]))\n-\t   == 0)\n+\t&& gfc_wide_strncasecmp (value, allowed_f2003[i],\n+\t\t\t\t strlen (allowed_f2003[i])) == 0)\n       {\n \tnotification n = gfc_notification_std (GFC_STD_F2003);\n \n@@ -1461,7 +1462,8 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \n   for (i = 0; allowed_gnu && allowed_gnu[i]; i++)\n     if (len == strlen (allowed_gnu[i])\n-\t&& strncasecmp (value, allowed_gnu[i], strlen (allowed_gnu[i])) == 0)\n+\t&& gfc_wide_strncasecmp (value, allowed_gnu[i],\n+\t\t\t\t strlen (allowed_gnu[i])) == 0)\n       {\n \tnotification n = gfc_notification_std (GFC_STD_GNU);\n \n@@ -1487,14 +1489,18 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \n   if (warn)\n     {\n+      char *s = gfc_widechar_to_char (value, -1);\n       gfc_warning (\"%s specifier in %s statement at %C has invalid value '%s'\",\n-\t\t   specifier, statement, value);\n+\t\t   specifier, statement, s);\n+      gfc_free (s);\n       return 1;\n     }\n   else\n     {\n+      char *s = gfc_widechar_to_char (value, -1);\n       gfc_error (\"%s specifier in %s statement at %C has invalid value '%s'\",\n-\t\t specifier, statement, value);\n+\t\t specifier, statement, s);\n+      gfc_free (s);\n       return 0;\n     }\n }\n@@ -1773,20 +1779,22 @@ gfc_match_open (void)\n       /* F2003, 9.4.5: If the STATUS= specifier has the value NEW or REPLACE,\n \t the FILE= specifier shall appear.  */\n       if (open->file == NULL\n-\t  && (strncasecmp (open->status->value.character.string, \"replace\", 7)\n-\t      == 0\n-\t     || strncasecmp (open->status->value.character.string, \"new\", 3)\n-\t\t== 0))\n+\t  && (gfc_wide_strncasecmp (open->status->value.character.string,\n+\t\t\t\t    \"replace\", 7) == 0\n+\t      || gfc_wide_strncasecmp (open->status->value.character.string,\n+\t\t\t\t       \"new\", 3) == 0))\n \t{\n+\t  char *s = gfc_widechar_to_char (open->status->value.character.string,\n+\t\t\t\t\t  -1);\n \t  warn_or_error (\"The STATUS specified in OPEN statement at %C is \"\n-\t\t\t \"'%s' and no FILE specifier is present\",\n-\t\t\t open->status->value.character.string);\n+\t\t\t \"'%s' and no FILE specifier is present\", s);\n+\t  gfc_free (s);\n \t}\n \n       /* F2003, 9.4.5: If the STATUS= specifier has the value SCRATCH,\n \t the FILE= specifier shall not appear.  */\n-      if (strncasecmp (open->status->value.character.string, \"scratch\", 7)\n-\t  == 0 && open->file)\n+      if (gfc_wide_strncasecmp (open->status->value.character.string,\n+\t\t\t\t\"scratch\", 7) == 0 && open->file)\n \t{\n \t  warn_or_error (\"The STATUS specified in OPEN statement at %C \"\n \t\t\t \"cannot have the value SCRATCH if a FILE specifier \"\n@@ -1798,8 +1806,8 @@ gfc_match_open (void)\n   if (open->form && open->form->expr_type == EXPR_CONSTANT\n       && (open->delim || open->decimal || open->encoding || open->round\n \t  || open->sign || open->pad || open->blank)\n-      && strncasecmp (open->form->value.character.string,\n-\t\t      \"unformatted\", 11) == 0)\n+      && gfc_wide_strncasecmp (open->form->value.character.string,\n+\t\t\t       \"unformatted\", 11) == 0)\n     {\n       const char *spec = (open->delim ? \"DELIM \"\n \t\t\t\t      : (open->pad ? \"PAD \" : open->blank\n@@ -1810,20 +1818,21 @@ gfc_match_open (void)\n     }\n \n   if (open->recl && open->access && open->access->expr_type == EXPR_CONSTANT\n-      && strncasecmp (open->access->value.character.string, \"stream\", 6) == 0)\n+      && gfc_wide_strncasecmp (open->access->value.character.string,\n+\t\t\t       \"stream\", 6) == 0)\n     {\n       warn_or_error (\"RECL specifier not allowed in OPEN statement at %C for \"\n \t\t     \"stream I/O\");\n     }\n \n   if (open->position\n       && open->access && open->access->expr_type == EXPR_CONSTANT\n-      && !(strncasecmp (open->access->value.character.string,\n-\t\t\t\"sequential\", 10) == 0\n-\t   || strncasecmp (open->access->value.character.string,\n-\t\t\t   \"stream\", 6) == 0\n-\t   || strncasecmp (open->access->value.character.string,\n-\t\t\t   \"append\", 6) == 0))\n+      && !(gfc_wide_strncasecmp (open->access->value.character.string,\n+\t\t\t\t \"sequential\", 10) == 0\n+\t   || gfc_wide_strncasecmp (open->access->value.character.string,\n+\t\t\t\t    \"stream\", 6) == 0\n+\t   || gfc_wide_strncasecmp (open->access->value.character.string,\n+\t\t\t\t    \"append\", 6) == 0))\n     {\n       warn_or_error (\"POSITION specifier in OPEN statement at %C only allowed \"\n \t\t     \"for stream or sequential ACCESS\");\n@@ -2939,9 +2948,12 @@ if (condition) \\\n \n   if (dt->id)\n     {\n-      io_constraint (!dt->asynchronous\n-\t\t     || strcmp (dt->asynchronous->value.character.string,\n-\t\t\t\t \"yes\"),\n+      bool not_yes\n+\t= !dt->asynchronous\n+\t  || gfc_wide_strlen (dt->asynchronous->value.character.string) != 3\n+\t  || gfc_wide_strncasecmp (dt->asynchronous->value.character.string,\n+\t\t\t\t   \"yes\", 3) != 0;\n+      io_constraint (not_yes,\n \t\t     \"ID= specifier at %L must be with ASYNCHRONOUS='yes' \"\n \t\t     \"specifier\", &dt->id->where);\n     }\n@@ -3137,9 +3149,11 @@ if (condition) \\\n \n       if (expr->expr_type == EXPR_CONSTANT && expr->ts.type == BT_CHARACTER)\n \t{\n-\t  const char * advance = expr->value.character.string;\n-\t  not_no = strcasecmp (advance, \"no\") != 0;\n-\t  not_yes = strcasecmp (advance, \"yes\") != 0;\n+\t  const gfc_char_t *advance = expr->value.character.string;\n+\t  not_no = gfc_wide_strlen (advance) != 2\n+\t\t   || gfc_wide_strncasecmp (advance, \"no\", 2) != 0;\n+\t  not_yes = gfc_wide_strlen (advance) != 3\n+\t\t    || gfc_wide_strncasecmp (advance, \"yes\", 3) != 0;\n \t}\n       else\n \t{"}, {"sha": "8d8b22a5704232bd34cacc74bc2abd5895aa8131", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -2708,6 +2708,7 @@ mio_expr (gfc_expr **ep)\n {\n   gfc_expr *e;\n   atom_type t;\n+  char *s;\n   int flag;\n \n   mio_lparen ();\n@@ -2832,8 +2833,10 @@ mio_expr (gfc_expr **ep)\n       break;\n \n     case EXPR_SUBSTRING:\n-      e->value.character.string\n-\t= CONST_CAST (char *, mio_allocated_string (e->value.character.string));\n+      s = gfc_widechar_to_char (e->value.character.string, -1);\n+      s = CONST_CAST (char *, mio_allocated_string (s));\n+      e->value.character.string = gfc_char_to_widechar (s);\n+      gfc_free (s);\n       mio_ref_list (&e->ref);\n       break;\n \n@@ -2867,8 +2870,10 @@ mio_expr (gfc_expr **ep)\n \n \tcase BT_CHARACTER:\n \t  mio_integer (&e->value.character.length);\n-\t  e->value.character.string\n-\t    = CONST_CAST (char *, mio_allocated_string (e->value.character.string));\n+\t  s = gfc_widechar_to_char (e->value.character.string, -1);\n+\t  s = CONST_CAST (char *, mio_allocated_string (s));\n+\t  e->value.character.string = gfc_char_to_widechar (s);\n+\t  gfc_free (s);\n \t  break;\n \n \tdefault:"}, {"sha": "fbc26af76e950d8f5ab237b185e2fc30a73288e3", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -278,11 +278,18 @@ match_hollerith_constant (gfc_expr **result)\n \n \t  e->representation.string = gfc_getmem (num + 1);\n \n-\t  /* FIXME -- determine what should be done for wide character\n-\t     strings, and do it!  */\n \t  for (i = 0; i < num; i++)\n-\t    e->representation.string[i]\n-\t      = (unsigned char) gfc_next_char_literal (1);\n+\t    {\n+\t      gfc_char_t c = gfc_next_char_literal (1);\n+\t      if (! gfc_wide_fits_in_byte (c))\n+\t\t{\n+\t\t  gfc_error (\"Invalid Hollerith constant at %L contains a \"\n+\t\t\t     \"wide character\", &old_loc);\n+\t\t  goto cleanup;\n+\t\t}\n+\n+\t      e->representation.string[i] = (unsigned char) c;\n+\t    }\n \n \t  e->representation.string[num] = '\\0';\n \t  e->representation.length = num;\n@@ -844,14 +851,14 @@ match_charkind_name (char *name)\n static match\n match_string_constant (gfc_expr **result)\n {\n-  char *p, name[GFC_MAX_SYMBOL_LEN + 1], peek;\n+  char name[GFC_MAX_SYMBOL_LEN + 1], peek;\n   int i, kind, length, warn_ampersand, ret;\n   locus old_locus, start_locus;\n   gfc_symbol *sym;\n   gfc_expr *e;\n   const char *q;\n   match m;\n-  gfc_char_t c, delimiter;\n+  gfc_char_t c, delimiter, *p;\n \n   old_locus = gfc_current_locus;\n \n@@ -970,7 +977,7 @@ match_string_constant (gfc_expr **result)\n   e->ts.is_iso_c = 0;\n   e->where = start_locus;\n \n-  e->value.character.string = p = gfc_getmem (length + 1);\n+  e->value.character.string = p = gfc_get_wide_string (length + 1);\n   e->value.character.length = length;\n \n   gfc_current_locus = start_locus;\n@@ -992,7 +999,7 @@ match_string_constant (gfc_expr **result)\n \t  return MATCH_ERROR;\n \t}\n \n-      *p++ = (unsigned char) c;\n+      *p++ = c;\n     }\n \n   *p = '\\0';\t/* TODO: C-style string is for development/debug purposes.  */"}, {"sha": "6338b068ecce3845f3e959dd118b574658999733", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -6804,7 +6804,6 @@ build_default_init_expr (gfc_symbol *sym)\n   int char_len;\n   gfc_expr *init_expr;\n   int i;\n-  char *ch;\n \n   /* These symbols should never have a default initialization.  */\n   if ((sym->attr.dimension && !gfc_is_compile_time_shape (sym->as))\n@@ -6922,10 +6921,10 @@ build_default_init_expr (gfc_symbol *sym)\n \t{\n \t  char_len = mpz_get_si (sym->ts.cl->length->value.integer);\n \t  init_expr->value.character.length = char_len;\n-\t  init_expr->value.character.string = gfc_getmem (char_len+1);\n-\t  ch = init_expr->value.character.string;\n+\t  init_expr->value.character.string = gfc_get_wide_string (char_len+1);\n \t  for (i = 0; i < char_len; i++)\n-\t    *(ch++) = gfc_option.flag_init_character_value;\n+\t    init_expr->value.character.string[i]\n+\t      = (unsigned char) gfc_option.flag_init_character_value;\n \t}\n       else\n \t{"}, {"sha": "21b9311d12aef9c1b9c83d2826cf7aba5fdb1deb", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -113,6 +113,12 @@ gfc_wide_tolower (gfc_char_t c)\n   return (wide_is_ascii (c) ? (gfc_char_t) TOLOWER((unsigned char) c) : c);\n }\n \n+gfc_char_t\n+gfc_wide_toupper (gfc_char_t c)\n+{\n+  return (wide_is_ascii (c) ? (gfc_char_t) TOUPPER((unsigned char) c) : c);\n+}\n+\n int\n gfc_wide_is_digit (gfc_char_t c)\n {\n@@ -143,6 +149,17 @@ gfc_wide_strlen (const gfc_char_t *str)\n   return i;\n }\n \n+gfc_char_t *\n+gfc_wide_memset (gfc_char_t *b, gfc_char_t c, size_t len)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < len; i++)\n+    b[i] = c;\n+\n+  return b;\n+}\n+\n static gfc_char_t *\n wide_strcpy (gfc_char_t *dest, const gfc_char_t *src)\n {\n@@ -155,25 +172,55 @@ wide_strcpy (gfc_char_t *dest, const gfc_char_t *src)\n }\n \n static gfc_char_t *\n-wide_strchr (gfc_char_t *s, gfc_char_t c)\n+wide_strchr (const gfc_char_t *s, gfc_char_t c)\n {\n   do {\n     if (*s == c)\n       {\n-        return (gfc_char_t *) s;\n+        return CONST_CAST(gfc_char_t *, s);\n       }\n   } while (*s++);\n   return 0;\n }\n \n-static char *\n-widechar_to_char (gfc_char_t *s)\n+char *\n+gfc_widechar_to_char (const gfc_char_t *s, int length)\n+{\n+  size_t len, i;\n+  char *res;\n+\n+  if (s == NULL)\n+    return NULL;\n+\n+  /* Passing a negative length is used to indicate that length should be\n+     calculated using gfc_wide_strlen().  */\n+  len = (length >= 0 ? (size_t) length : gfc_wide_strlen (s));\n+  res = gfc_getmem (len + 1);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      gcc_assert (gfc_wide_fits_in_byte (s[i]));\n+      res[i] = (unsigned char) s[i];\n+    }\n+\n+  res[len] = '\\0';\n+  return res;\n+}\n+\n+gfc_char_t *\n+gfc_char_to_widechar (const char *s)\n {\n-  size_t len = gfc_wide_strlen (s), i;\n-  char *res = gfc_getmem (len + 1);\n+  size_t len, i;\n+  gfc_char_t *res;\n+\n+  if (s == NULL)\n+    return NULL;\n+\n+  len = strlen (s);\n+  res = gfc_get_wide_string (len + 1);\n \n   for (i = 0; i < len; i++)\n-    res[i] = gfc_wide_fits_in_byte (s[i]) ? (unsigned char) s[i] : '?';\n+    res[i] = (unsigned char) s[i];\n \n   res[len] = '\\0';\n   return res;\n@@ -196,8 +243,8 @@ wide_strncmp (const gfc_char_t *s1, const char *s2, size_t n)\n   return 0;\n }\n \n-static int\n-wide_strncasecmp (const gfc_char_t *s1, const char *s2, size_t n)\n+int\n+gfc_wide_strncasecmp (const gfc_char_t *s1, const char *s2, size_t n)\n {\n   gfc_char_t c1, c2;\n \n@@ -585,15 +632,15 @@ gfc_define_undef_line (void)\n \n   if (wide_strncmp (gfc_current_locus.nextc, \"#define \", 8) == 0)\n     {\n-      tmp = widechar_to_char (&gfc_current_locus.nextc[8]);\n+      tmp = gfc_widechar_to_char (&gfc_current_locus.nextc[8], -1);\n       (*debug_hooks->define) (gfc_linebuf_linenum (gfc_current_locus.lb),\n \t\t\t      tmp);\n       gfc_free (tmp);\n     }\n \n   if (wide_strncmp (gfc_current_locus.nextc, \"#undef \", 7) == 0)\n     {\n-      tmp = widechar_to_char (&gfc_current_locus.nextc[7]);\n+      tmp = gfc_widechar_to_char (&gfc_current_locus.nextc[7], -1);\n       (*debug_hooks->undef) (gfc_linebuf_linenum (gfc_current_locus.lb),\n \t\t\t     tmp);\n       gfc_free (tmp);\n@@ -1294,7 +1341,7 @@ load_line (FILE *input, gfc_char_t **pbuf, int *pbuflen)\n       else\n \tbuflen = 132;\n \n-      *pbuf = gfc_getmem ((buflen + 1) * sizeof (gfc_char_t));\n+      *pbuf = gfc_get_wide_string (buflen + 1);\n     }\n \n   i = 0;\n@@ -1556,7 +1603,7 @@ preprocessor_line (gfc_char_t *c)\n \n   /* Convert the filename in wide characters into a filename in narrow\n      characters.  */\n-  filename = widechar_to_char (wide_filename);\n+  filename = gfc_widechar_to_char (wide_filename, -1);\n \n   /* Interpret flags.  */\n \n@@ -1647,7 +1694,7 @@ include_line (gfc_char_t *line)\n   while (*c == ' ' || *c == '\\t')\n     c++;\n \n-  if (wide_strncasecmp (c, \"include\", 7))\n+  if (gfc_wide_strncasecmp (c, \"include\", 7))\n     return false;\n \n   c += 7;\n@@ -1681,7 +1728,7 @@ include_line (gfc_char_t *line)\n   *stop = '\\0'; /* It's ok to trash the buffer, as this line won't be\n \t\t   read by anything else.  */\n \n-  filename = widechar_to_char (begin);\n+  filename = gfc_widechar_to_char (begin, -1);\n   load_file (filename, false);\n   gfc_free (filename);\n   return true;\n@@ -1779,7 +1826,7 @@ load_file (const char *filename, bool initial)\n \t\t\t\t&& line[2] == (unsigned char) '\\xBF')))\n \t{\n \t  int n = line[1] == (unsigned char) '\\xBB' ? 3 : 2;\n-\t  gfc_char_t *new = gfc_getmem (line_len * sizeof (gfc_char_t));\n+\t  gfc_char_t *new = gfc_get_wide_string (line_len);\n \n \t  wide_strcpy (new, &line[n]);\n \t  gfc_free (line);\n@@ -1944,7 +1991,7 @@ gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n   if (wide_strncmp (gfc_src_preprocessor_lines[0], \"# 1 \\\"\", 5) != 0)\n     return NULL;\n \n-  tmp = widechar_to_char (&gfc_src_preprocessor_lines[0][5]);\n+  tmp = gfc_widechar_to_char (&gfc_src_preprocessor_lines[0][5], -1);\n   filename = unescape_filename (tmp);\n   gfc_free (tmp);\n   if (filename == NULL)\n@@ -1962,7 +2009,7 @@ gfc_read_orig_filename (const char *filename, const char **canon_source_file)\n   if (wide_strncmp (gfc_src_preprocessor_lines[1], \"# 1 \\\"\", 5) != 0)\n     return filename;\n \n-  tmp = widechar_to_char (&gfc_src_preprocessor_lines[1][5]);\n+  tmp = gfc_widechar_to_char (&gfc_src_preprocessor_lines[1][5], -1);\n   dirname = unescape_filename (tmp);\n   gfc_free (tmp);\n   if (dirname == NULL)"}, {"sha": "e87804cef0cb9c92ecc0060692cd2a20854fdebb", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -284,7 +284,7 @@ gfc_simplify_achar (gfc_expr *e, gfc_expr *k)\n \n   result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n \n-  result->value.character.string = gfc_getmem (2);\n+  result->value.character.string = gfc_get_wide_string (2);\n \n   result->value.character.length = 1;\n   result->value.character.string[0] = c;\n@@ -343,7 +343,7 @@ gfc_simplify_adjustl (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, i, len;\n-  char ch;\n+  gfc_char_t ch;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -353,7 +353,7 @@ gfc_simplify_adjustl (gfc_expr *e)\n   result = gfc_constant_result (BT_CHARACTER, e->ts.kind, &e->where);\n \n   result->value.character.length = len;\n-  result->value.character.string = gfc_getmem (len + 1);\n+  result->value.character.string = gfc_get_wide_string (len + 1);\n \n   for (count = 0, i = 0; i < len; ++i)\n     {\n@@ -380,7 +380,7 @@ gfc_simplify_adjustr (gfc_expr *e)\n {\n   gfc_expr *result;\n   int count, i, len;\n-  char ch;\n+  gfc_char_t ch;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -390,7 +390,7 @@ gfc_simplify_adjustr (gfc_expr *e)\n   result = gfc_constant_result (BT_CHARACTER, e->ts.kind, &e->where);\n \n   result->value.character.length = len;\n-  result->value.character.string = gfc_getmem (len + 1);\n+  result->value.character.string = gfc_get_wide_string (len + 1);\n \n   for (count = 0, i = len - 1; i >= 0; --i)\n     {\n@@ -843,7 +843,7 @@ gfc_simplify_char (gfc_expr *e, gfc_expr *k)\n   result = gfc_constant_result (BT_CHARACTER, kind, &e->where);\n \n   result->value.character.length = 1;\n-  result->value.character.string = gfc_getmem (2);\n+  result->value.character.string = gfc_get_wide_string (2);\n \n   result->value.character.string[0] = c;\n   result->value.character.string[1] = '\\0';\t/* For debugger */\n@@ -1460,7 +1460,7 @@ gfc_expr *\n gfc_simplify_iachar (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n-  int index;\n+  gfc_char_t index;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -1471,7 +1471,7 @@ gfc_simplify_iachar (gfc_expr *e, gfc_expr *kind)\n       return &gfc_bad_expr;\n     }\n \n-  index = (unsigned char) e->value.character.string[0];\n+  index = e->value.character.string[0];\n \n   if (gfc_option.warn_surprising && index > 127)\n     gfc_warning (\"Argument of IACHAR function at %L outside of range 0..127\",\n@@ -1649,7 +1649,7 @@ gfc_expr *\n gfc_simplify_ichar (gfc_expr *e, gfc_expr *kind)\n {\n   gfc_expr *result;\n-  int index;\n+  gfc_char_t index;\n \n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -1660,9 +1660,8 @@ gfc_simplify_ichar (gfc_expr *e, gfc_expr *kind)\n       return &gfc_bad_expr;\n     }\n \n-  index = (unsigned char) e->value.character.string[0];\n-\n-  if (index < 0 || index > UCHAR_MAX)\n+  index = e->value.character.string[0];\n+  if (index > UCHAR_MAX)\n     gfc_internal_error(\"Argument of ICHAR at %L out of range\", &e->where);\n \n   if ((result = int_expr_with_kind (index, kind, \"ICHAR\")) == NULL)\n@@ -2687,12 +2686,13 @@ simplify_min_max (gfc_expr *expr, int sign)\n #define STRING(x) ((x)->expr->value.character.string)\n \t  if (LENGTH(extremum) < LENGTH(arg))\n \t    {\n-\t      char * tmp = STRING(extremum);\n+\t      gfc_char_t *tmp = STRING(extremum);\n \n-\t      STRING(extremum) = gfc_getmem (LENGTH(arg) + 1);\n-\t      memcpy (STRING(extremum), tmp, LENGTH(extremum));\n-\t      memset (&STRING(extremum)[LENGTH(extremum)], ' ',\n-\t\t      LENGTH(arg) - LENGTH(extremum));\n+\t      STRING(extremum) = gfc_get_wide_string (LENGTH(arg) + 1);\n+\t      memcpy (STRING(extremum), tmp,\n+\t\t      LENGTH(extremum) * sizeof (gfc_char_t));\n+\t      gfc_wide_memset (&STRING(extremum)[LENGTH(extremum)], ' ',\n+\t\t\t       LENGTH(arg) - LENGTH(extremum));\n \t      STRING(extremum)[LENGTH(arg)] = '\\0';  /* For debugger  */\n \t      LENGTH(extremum) = LENGTH(arg);\n \t      gfc_free (tmp);\n@@ -2701,10 +2701,11 @@ simplify_min_max (gfc_expr *expr, int sign)\n \t  if (gfc_compare_string (arg->expr, extremum->expr) * sign > 0)\n \t    {\n \t      gfc_free (STRING(extremum));\n-\t      STRING(extremum) = gfc_getmem (LENGTH(extremum) + 1);\n-\t      memcpy (STRING(extremum), STRING(arg), LENGTH(arg));\n-\t      memset (&STRING(extremum)[LENGTH(arg)], ' ',\n-\t\t      LENGTH(extremum) - LENGTH(arg));\n+\t      STRING(extremum) = gfc_get_wide_string (LENGTH(extremum) + 1);\n+\t      memcpy (STRING(extremum), STRING(arg),\n+\t\t      LENGTH(arg) * sizeof (gfc_char_t));\n+\t      gfc_wide_memset (&STRING(extremum)[LENGTH(arg)], ' ',\n+\t\t\t       LENGTH(extremum) - LENGTH(arg));\n \t      STRING(extremum)[LENGTH(extremum)] = '\\0';  /* For debugger  */\n \t    }\n #undef LENGTH\n@@ -3008,7 +3009,7 @@ gfc_simplify_new_line (gfc_expr *e)\n   gfc_expr *result;\n \n   result = gfc_constant_result (BT_CHARACTER, e->ts.kind, &e->where);\n-  result->value.character.string = gfc_getmem (2);\n+  result->value.character.string = gfc_get_wide_string (2);\n   result->value.character.length = 1;\n   result->value.character.string[0] = '\\n';\n   result->value.character.string[1] = '\\0';     /* For debugger */\n@@ -3329,19 +3330,18 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n \n   if (ncop == 0)\n     {\n-      result->value.character.string = gfc_getmem (1);\n+      result->value.character.string = gfc_get_wide_string (1);\n       result->value.character.length = 0;\n       result->value.character.string[0] = '\\0';\n       return result;\n     }\n \n   result->value.character.length = nlen;\n-  result->value.character.string = gfc_getmem (nlen + 1);\n+  result->value.character.string = gfc_get_wide_string (nlen + 1);\n \n   for (i = 0; i < ncop; i++)\n     for (j = 0; j < len; j++)\n-      result->value.character.string[j + i * len]\n-      = e->value.character.string[j];\n+      result->value.character.string[j+i*len]= e->value.character.string[j];\n \n   result->value.character.string[nlen] = '\\0';\t/* For debugger */\n   return result;\n@@ -3696,6 +3696,51 @@ gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n }\n \n \n+/* Variants of strspn and strcspn that operate on wide characters.  */\n+\n+static size_t\n+wide_strspn (const gfc_char_t *s1, const gfc_char_t *s2)\n+{\n+  size_t i = 0;\n+  const gfc_char_t *c;\n+\n+  while (s1[i])\n+    {\n+      for (c = s2; *c; c++)\n+\t{\n+\t  if (s1[i] == *c)\n+\t    break;\n+\t}\n+      if (*c == '\\0')\n+\tbreak;\n+      i++;\n+    }\n+\n+  return i;\n+}\n+\n+static size_t\n+wide_strcspn (const gfc_char_t *s1, const gfc_char_t *s2)\n+{\n+  size_t i = 0;\n+  const gfc_char_t *c;\n+\n+  while (s1[i])\n+    {\n+      for (c = s2; *c; c++)\n+\t{\n+\t  if (s1[i] == *c)\n+\t    break;\n+\t}\n+      if (*c)\n+\tbreak;\n+      i++;\n+    }\n+\n+  return i;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b, gfc_expr *kind)\n {\n@@ -3729,8 +3774,8 @@ gfc_simplify_scan (gfc_expr *e, gfc_expr *c, gfc_expr *b, gfc_expr *kind)\n     {\n       if (back == 0)\n \t{\n-\t  indx = strcspn (e->value.character.string, c->value.character.string)\n-\t       + 1;\n+\t  indx = wide_strcspn (e->value.character.string,\n+\t\t\t       c->value.character.string) + 1;\n \t  if (indx > len)\n \t    indx = 0;\n \t}\n@@ -4435,7 +4480,7 @@ gfc_simplify_trim (gfc_expr *e)\n   lentrim = len - count;\n \n   result->value.character.length = lentrim;\n-  result->value.character.string = gfc_getmem (lentrim + 1);\n+  result->value.character.string = gfc_get_wide_string (lentrim + 1);\n \n   for (i = 0; i < lentrim; i++)\n     result->value.character.string[i] = e->value.character.string[i];\n@@ -4492,8 +4537,8 @@ gfc_simplify_verify (gfc_expr *s, gfc_expr *set, gfc_expr *b, gfc_expr *kind)\n \t  return result;\n \t}\n \n-      index = strspn (s->value.character.string, set->value.character.string)\n-\t    + 1;\n+      index = wide_strspn (s->value.character.string,\n+\t\t\t   set->value.character.string) + 1;\n       if (index > len)\n \tindex = 0;\n "}, {"sha": "1d6867bd89cb311fa043291e647cd18a58d142ac", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -3833,9 +3833,9 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \ttmp_sym->value->ts.is_c_interop = 1;\n \ttmp_sym->value->ts.is_iso_c = 1;\n \ttmp_sym->value->value.character.length = 1;\n-\ttmp_sym->value->value.character.string = gfc_getmem (2);\n+\ttmp_sym->value->value.character.string = gfc_get_wide_string (2);\n \ttmp_sym->value->value.character.string[0]\n-\t  = (char) c_interop_kinds_table[s].value;\n+\t  = (gfc_char_t) c_interop_kinds_table[s].value;\n \ttmp_sym->value->value.character.string[1] = '\\0';\n \ttmp_sym->ts.cl = gfc_get_charlen ();\n \ttmp_sym->ts.cl->length = gfc_int_expr (1);"}, {"sha": "149afa1e8ca935b686dddec16645cf0ad6b74121", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -73,9 +73,9 @@ size_logical (int kind)\n \n \n static size_t\n-size_character (int length)\n+size_character (int length, int kind)\n {\n-  return length;\n+  return length * kind;\n }\n \n \n@@ -100,7 +100,7 @@ gfc_target_expr_size (gfc_expr *e)\n     case BT_LOGICAL:\n       return size_logical (e->ts.kind);\n     case BT_CHARACTER:\n-      return size_character (e->value.character.length);\n+      return size_character (e->value.character.length, e->ts.kind);\n     case BT_HOLLERITH:\n       return e->representation.length;\n     case BT_DERIVED:\n@@ -174,11 +174,20 @@ encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size\n \n \n static int\n-encode_character (int length, char *string, unsigned char *buffer,\n-\t\t  size_t buffer_size)\n+encode_character (int kind, int length, gfc_char_t *string,\n+\t\t  unsigned char *buffer, size_t buffer_size)\n {\n-  gcc_assert (buffer_size >= size_character (length));\n-  memcpy (buffer, string, length);\n+  char *s;\n+\n+  gcc_assert (buffer_size >= size_character (length, kind));\n+  /* FIXME -- when we support wide character types, we'll need to go\n+     via integers for them.  For now, we keep the simple memcpy().  */\n+  gcc_assert (kind == gfc_default_character_kind);\n+\n+  s = gfc_widechar_to_char (string, length);\n+  memcpy (buffer, s, length);\n+  gfc_free (s);\n+\n   return length;\n }\n \n@@ -248,7 +257,7 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n       return encode_logical (source->ts.kind, source->value.logical, buffer,\n \t\t\t     buffer_size);\n     case BT_CHARACTER:\n-      return encode_character (source->value.character.length, \n+      return encode_character (source->ts.kind, source->value.character.length,\n \t\t\t       source->value.character.string, buffer,\n \t\t\t       buffer_size);\n     case BT_DERIVED:\n@@ -351,18 +360,24 @@ gfc_interpret_logical (int kind, unsigned char *buffer, size_t buffer_size,\n \n \n int\n-gfc_interpret_character (unsigned char *buffer, size_t buffer_size, gfc_expr *result)\n+gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n+\t\t\t gfc_expr *result)\n {\n+  int i;\n+\n   if (result->ts.cl && result->ts.cl->length)\n     result->value.character.length =\n-      (int)mpz_get_ui (result->ts.cl->length->value.integer);\n+      (int) mpz_get_ui (result->ts.cl->length->value.integer);\n \n-  gcc_assert (buffer_size >= size_character (result->value.character.length));\n+  gcc_assert (buffer_size >= size_character (result->value.character.length,\n+\t\t\t\t\t     result->ts.kind));\n   result->value.character.string =\n-    gfc_getmem (result->value.character.length + 1);\n-  memcpy (result->value.character.string, buffer,\n-\t  result->value.character.length);\n-  result->value.character.string [result->value.character.length] = '\\0';\n+    gfc_get_wide_string (result->value.character.length + 1);\n+\n+  gcc_assert (result->ts.kind == gfc_default_character_kind);\n+  for (i = 0; i < result->value.character.length; i++)\n+    result->value.character.string[i] = (gfc_char_t) buffer[i];\n+  result->value.character.string[result->value.character.length] = '\\0';\n \n   return result->value.character.length;\n }\n@@ -481,7 +496,9 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n     }\n \n   if (result->ts.type == BT_CHARACTER)\n-    result->representation.string = result->value.character.string;\n+    result->representation.string\n+      = gfc_widechar_to_char (result->value.character.string,\n+\t\t\t      result->value.character.length);\n   else\n     {\n       result->representation.string ="}, {"sha": "6c9032f972a2eb79c7641620237298ba2aeb7711", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -105,7 +105,8 @@ gfc_build_localized_cstring_const (const char *msgid)\n tree\n gfc_conv_string_init (tree length, gfc_expr * expr)\n {\n-  char *s;\n+  gfc_char_t *s;\n+  char *c;\n   HOST_WIDE_INT len;\n   int slen;\n   tree str;\n@@ -120,14 +121,21 @@ gfc_conv_string_init (tree length, gfc_expr * expr)\n \n   if (len > slen)\n     {\n-      s = gfc_getmem (len);\n-      memcpy (s, expr->value.character.string, slen);\n-      memset (&s[slen], ' ', len - slen);\n-      str = gfc_build_string_const (len, s);\n+      s = gfc_get_wide_string (len);\n+      memcpy (s, expr->value.character.string, slen * sizeof (gfc_char_t));\n+      gfc_wide_memset (&s[slen], ' ', len - slen);\n+\n+      /* FIXME -- currently ignore wide character strings; see assert\n+\t above.  */\n+      c = gfc_widechar_to_char (s, len);\n       gfc_free (s);\n     }\n   else\n-    str = gfc_build_string_const (len, expr->value.character.string);\n+    c = gfc_widechar_to_char (expr->value.character.string,\n+\t\t\t      expr->value.character.length);\n+\n+  str = gfc_build_string_const (len, c);\n+  gfc_free (c);\n \n   return str;\n }\n@@ -214,6 +222,9 @@ gfc_conv_tree_to_mpfr (mpfr_ptr f, tree source)\n tree\n gfc_conv_constant_to_tree (gfc_expr * expr)\n {\n+  tree res;\n+  char *s;\n+\n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n \n   /* If it is has a prescribed memory representation, we build a string\n@@ -267,8 +278,12 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \t}\n \n     case BT_CHARACTER:\n-      return gfc_build_string_const (expr->value.character.length,\n-\t\t\t\t     expr->value.character.string);\n+      gcc_assert (expr->ts.kind == 1);\n+      s = gfc_widechar_to_char (expr->value.character.string,\n+\t\t\t\texpr->value.character.length);\n+      res = gfc_build_string_const (expr->value.character.length, s);\n+      gfc_free (s);\n+      return res;\n \n     case BT_HOLLERITH:\n       return gfc_build_string_const (expr->representation.length,"}, {"sha": "08c259173554b1d2a33994231d7a263833cba266", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -3488,13 +3488,18 @@ static void\n gfc_conv_substring_expr (gfc_se * se, gfc_expr * expr)\n {\n   gfc_ref *ref;\n+  char *s;\n \n   ref = expr->ref;\n \n   gcc_assert (ref == NULL || ref->type == REF_SUBSTRING);\n \n-  se->expr = gfc_build_string_const (expr->value.character.length,\n-\t\t\t\t     expr->value.character.string);\n+  gcc_assert (expr->ts.kind == gfc_default_character_kind);\n+  s = gfc_widechar_to_char (expr->value.character.string,\n+\t\t\t    expr->value.character.length);\n+  se->expr = gfc_build_string_const (expr->value.character.length, s);\n+  gfc_free (s);\n+\n   se->string_length = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (se->expr)));\n   TYPE_STRING_FLAG (TREE_TYPE (se->expr)) = 1;\n "}, {"sha": "2f35002a5ac06904bb6e20eed99219b0067f2825", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -1391,8 +1391,7 @@ gfc_new_nml_name_expr (const char * name)\n    nml_name->ts.kind = gfc_default_character_kind;\n    nml_name->ts.type = BT_CHARACTER;\n    nml_name->value.character.length = strlen(name);\n-   nml_name->value.character.string = gfc_getmem (strlen (name) + 1);\n-   strcpy (nml_name->value.character.string, name);\n+   nml_name->value.character.string = gfc_char_to_widechar (name);\n \n    return nml_name;\n }"}, {"sha": "9220315461ce0904a7ea370696bb77860455701a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006601890b953c9177624f9f533b997f344802ad/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=006601890b953c9177624f9f533b997f344802ad", "patch": "@@ -119,11 +119,14 @@ gfc_trans_label_assign (gfc_code * code)\n     }\n   else\n     {\n-      label_str = code->label->format->value.character.string;\n       label_len = code->label->format->value.character.length;\n+      label_str\n+\t= gfc_widechar_to_char (code->label->format->value.character.string,\n+\t\t\t\tlabel_len);\n       len_tree = build_int_cst (NULL_TREE, label_len);\n       label_tree = gfc_build_string_const (label_len + 1, label_str);\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n+      gfc_free (label_str);\n     }\n \n   gfc_add_modify_expr (&se.pre, len, len_tree);"}]}