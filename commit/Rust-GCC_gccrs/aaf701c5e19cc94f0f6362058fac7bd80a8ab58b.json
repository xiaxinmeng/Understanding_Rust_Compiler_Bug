{"sha": "aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFmNzAxYzVlMTljYzk0ZjBmNjM2MjA1OGZhYzdiZDgwYThhYjU4Yg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-06T12:25:03Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-06T12:25:03Z"}, "message": "sh-protos.h (fp_zero_operand, [...]): Use bool as return type.\n\n\t* config/sh/sh-protos.h (fp_zero_operand, fp_one_operand,\n\tnonpic_symbol_mentioned_p, expand_block_move, expand_ashiftrt,\n\tsh_dynamicalize_shift_p, gen_shl_and, gen_shl_sext, system_reg_operand,\n\treg_unused_after, sh_can_redirect_branch, sh_need_epilogue, fldi_ok,\n\tsh_hard_regno_rename_ok, sh_cfun_interrupt_handler_p,\n\tsh_cfun_resbank_handler_p, sh_attr_renesas_p, sh_cfun_attr_renesas_p,\n\tcheck_use_sfunc_addr, sh_contains_memref_p, sh_loads_bankedreg_p,\n\tsh2a_is_function_vector_call): Use bool as return type.\n\t(sh_pass_in_reg_p): Remove.\n\t* config/sh/sh.c (broken_move, mova_p, noncall_uses_reg, high_pressure,\n\tflow_dependent_p, sh2a_function_vector_p, expand_block_move,\n\texpand_ashiftrt, sh_dynamicalize_shift_p, gen_shl_and, gen_shl_sext,\n\tsh_need_epilogue, sh2a_is_function_vector_call, sh_attr_renesas_p,\n\tsh_cfun_attr_renesas_p, sh_cfun_interrupt_handler_p,\n\tsh_cfun_resbank_handler_p, system_reg_operand, fp_zero_operand,\n\tfp_one_operand, fldi_ok, reg_unused_after, sh_can_redirect_branch,\n\tsh_hard_regno_rename_ok, check_use_sfunc_addr, sh_contains_memref_p, \n\tsh_loads_bankedreg_p): Use bool as return type.\n\t(nonpic_symbol_mentioned_p): Use bool as return type.  Remove\n\t'register' modifier.\n\nFrom-SVN: r186183", "tree": {"sha": "494879271586bd07a33a330f2eb90f10cf1690f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/494879271586bd07a33a330f2eb90f10cf1690f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/comments", "author": null, "committer": null, "parents": [{"sha": "3805a93e4d7d52f8f4073957aa657c3b465b6a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3805a93e4d7d52f8f4073957aa657c3b465b6a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3805a93e4d7d52f8f4073957aa657c3b465b6a79"}], "stats": {"total": 303, "additions": 162, "deletions": 141}, "files": [{"sha": "78faf4674338d4caef17698e08599931bdee7c5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "patch": "@@ -1,3 +1,26 @@\n+2012-04-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh-protos.h (fp_zero_operand, fp_one_operand,\n+\tnonpic_symbol_mentioned_p, expand_block_move, expand_ashiftrt,\n+\tsh_dynamicalize_shift_p, gen_shl_and, gen_shl_sext, system_reg_operand,\n+\treg_unused_after, sh_can_redirect_branch, sh_need_epilogue, fldi_ok,\n+\tsh_hard_regno_rename_ok, sh_cfun_interrupt_handler_p,\n+\tsh_cfun_resbank_handler_p, sh_attr_renesas_p, sh_cfun_attr_renesas_p,\n+\tcheck_use_sfunc_addr, sh_contains_memref_p, sh_loads_bankedreg_p,\n+\tsh2a_is_function_vector_call): Use bool as return type.\n+\t(sh_pass_in_reg_p): Remove.\n+\t* config/sh/sh.c (broken_move, mova_p, noncall_uses_reg, high_pressure,\n+\tflow_dependent_p, sh2a_function_vector_p, expand_block_move,\n+\texpand_ashiftrt, sh_dynamicalize_shift_p, gen_shl_and, gen_shl_sext,\n+\tsh_need_epilogue, sh2a_is_function_vector_call, sh_attr_renesas_p,\n+\tsh_cfun_attr_renesas_p, sh_cfun_interrupt_handler_p,\n+\tsh_cfun_resbank_handler_p, system_reg_operand, fp_zero_operand,\n+\tfp_one_operand, fldi_ok, reg_unused_after, sh_can_redirect_branch,\n+\tsh_hard_regno_rename_ok, check_use_sfunc_addr, sh_contains_memref_p, \n+\tsh_loads_bankedreg_p): Use bool as return type.\n+\t(nonpic_symbol_mentioned_p): Use bool as return type.  Remove\n+\t'register' modifier.\n+\n 2012-04-06  Matt Turner  <mattst88@gmail.com>\n \n \t* doc/install.texi: Correct typo \"-mno-lsc\" -> \"-mno-llsc\"."}, {"sha": "337d80d82ce3a7daca490fce38c50900199de36b", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "patch": "@@ -53,18 +53,18 @@ extern const char *output_far_jump (rtx, rtx);\n extern rtx sfunc_uses_reg (rtx);\n extern int barrier_align (rtx);\n extern int sh_loop_align (rtx);\n-extern int fp_zero_operand (rtx);\n-extern int fp_one_operand (rtx);\n+extern bool fp_zero_operand (rtx);\n+extern bool fp_one_operand (rtx);\n extern int fp_int_operand (rtx);\n extern rtx get_fpscr_rtx (void);\n extern bool sh_legitimate_index_p (enum machine_mode, rtx);\n extern bool sh_legitimize_reload_address (rtx *, enum machine_mode, int, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n-extern int nonpic_symbol_mentioned_p (rtx);\n+extern bool nonpic_symbol_mentioned_p (rtx);\n extern void emit_sf_insn (rtx);\n extern void emit_df_insn (rtx);\n extern void output_pic_addr_const (FILE *, rtx);\n-extern int expand_block_move (rtx *);\n+extern bool expand_block_move (rtx *);\n extern int prepare_move_operands (rtx[], enum machine_mode mode);\n extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n@@ -79,23 +79,23 @@ extern void gen_ashift (int, int, rtx);\n extern void gen_ashift_hi (int, int, rtx);\n extern void gen_shifty_op (int, rtx *);\n extern void gen_shifty_hi_op (int, rtx *);\n-extern int expand_ashiftrt (rtx *);\n-extern int sh_dynamicalize_shift_p (rtx);\n+extern bool expand_ashiftrt (rtx *);\n+extern bool sh_dynamicalize_shift_p (rtx);\n extern int shl_and_kind (rtx, rtx, int *);\n extern int shl_and_length (rtx);\n extern int shl_and_scr_length (rtx);\n-extern int gen_shl_and (rtx, rtx, rtx, rtx);\n+extern bool gen_shl_and (rtx, rtx, rtx, rtx);\n extern int shl_sext_kind (rtx, rtx, int *);\n extern int shl_sext_length (rtx);\n-extern int gen_shl_sext (rtx, rtx, rtx, rtx);\n+extern bool gen_shl_sext (rtx, rtx, rtx, rtx);\n extern rtx gen_datalabel_ref (rtx);\n extern int regs_used (rtx, int);\n extern void fixup_addr_diff_vecs (rtx);\n extern int get_dest_uid (rtx, int);\n extern void final_prescan_insn (rtx, rtx *, int);\n extern int symbol_ref_operand (rtx, enum machine_mode);\n extern enum tls_model tls_symbolic_operand (rtx, enum machine_mode);\n-extern int system_reg_operand (rtx, enum machine_mode);\n+extern bool system_reg_operand (rtx, enum machine_mode);\n extern int general_movsrc_operand (rtx, enum machine_mode);\n extern int general_movdst_operand (rtx, enum machine_mode);\n extern int arith_reg_operand (rtx, enum machine_mode);\n@@ -107,14 +107,14 @@ extern int fpscr_operand (rtx, enum machine_mode);\n extern int fpul_operand (rtx, enum machine_mode);\n extern int commutative_float_operator (rtx, enum machine_mode);\n extern int noncommutative_float_operator (rtx, enum machine_mode);\n-extern int reg_unused_after (rtx, rtx);\n+extern bool reg_unused_after (rtx, rtx);\n extern void expand_sf_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n extern void expand_sf_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n extern void expand_df_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n extern void expand_df_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n extern void expand_fp_branch (rtx (*)(void), rtx (*)(void));\n extern int sh_insn_length_adjustment (rtx);\n-extern int sh_can_redirect_branch (rtx, rtx);\n+extern bool sh_can_redirect_branch (rtx, rtx);\n extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n extern int sh_expand_t_scc (rtx *);\n@@ -128,20 +128,20 @@ extern rtx get_fpscr_rtx (void);\n extern int sh_media_register_for_return (void);\n extern void sh_expand_prologue (void);\n extern void sh_expand_epilogue (bool);\n-extern int sh_need_epilogue (void);\n+extern bool sh_need_epilogue (void);\n extern void sh_set_return_address (rtx, rtx);\n extern int initial_elimination_offset (int, int);\n-extern int fldi_ok (void);\n-extern int sh_hard_regno_rename_ok (unsigned int, unsigned int);\n-extern int sh_cfun_interrupt_handler_p (void);\n-extern int sh_cfun_resbank_handler_p (void);\n-extern int sh_attr_renesas_p (const_tree);\n-extern int sh_cfun_attr_renesas_p (void);\n+extern bool fldi_ok (void);\n+extern bool sh_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern bool sh_cfun_interrupt_handler_p (void);\n+extern bool sh_cfun_resbank_handler_p (void);\n+extern bool sh_attr_renesas_p (const_tree);\n+extern bool sh_cfun_attr_renesas_p (void);\n extern bool sh_cannot_change_mode_class\n \t      (enum machine_mode, enum machine_mode, enum reg_class);\n extern bool sh_small_register_classes_for_mode_p (enum machine_mode);\n extern void sh_mark_label (rtx, int);\n-extern int check_use_sfunc_addr (rtx, rtx);\n+extern bool check_use_sfunc_addr (rtx, rtx);\n \n #ifdef HARD_CONST\n extern void fpscr_set_from_mem (int, HARD_REG_SET);\n@@ -153,18 +153,17 @@ extern void sh_pr_nosave_low_regs (struct cpp_reader *);\n extern rtx function_symbol (rtx, const char *, enum sh_function_kind);\n extern rtx sh_get_pr_initial_val (void);\n \n-extern int sh_pass_in_reg_p (CUMULATIVE_ARGS *, enum machine_mode, tree);\n extern void sh_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, signed int, enum machine_mode);\n extern rtx sh_dwarf_register_span (rtx);\n \n extern rtx replace_n_hard_rtx (rtx, rtx *, int , int);\n extern int shmedia_cleanup_truncate (rtx *, void *);\n \n-extern int sh_contains_memref_p (rtx);\n-extern int sh_loads_bankedreg_p (rtx);\n+extern bool sh_contains_memref_p (rtx);\n+extern bool sh_loads_bankedreg_p (rtx);\n extern rtx shmedia_prepare_call_address (rtx fnaddr, int is_sibcall);\n extern int sh2a_get_function_vector_number (rtx);\n-extern int sh2a_is_function_vector_call (rtx);\n+extern bool sh2a_is_function_vector_call (rtx);\n extern void sh_fix_range (const char *);\n extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);\n #endif /* ! GCC_SH_PROTOS_H */"}, {"sha": "d7c4c61699c1bd1dcc42f7698fe7174363626d5f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 117, "deletions": 118, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf701c5e19cc94f0f6362058fac7bd80a8ab58b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=aaf701c5e19cc94f0f6362058fac7bd80a8ab58b", "patch": "@@ -175,10 +175,10 @@ static void print_slot (rtx);\n static rtx add_constant (rtx, enum machine_mode, rtx);\n static void dump_table (rtx, rtx);\n static int hi_const (rtx);\n-static int broken_move (rtx);\n-static int mova_p (rtx);\n+static bool broken_move (rtx);\n+static bool mova_p (rtx);\n static rtx find_barrier (int, rtx, rtx);\n-static int noncall_uses_reg (rtx, rtx, rtx *);\n+static bool noncall_uses_reg (rtx, rtx, rtx *);\n static rtx gen_block_redirect (rtx, int, int);\n static void sh_reorg (void);\n static void sh_option_override (void);\n@@ -219,7 +219,7 @@ static void  sh_md_finish_global (FILE *, int);\n static int rank_for_reorder (const void *, const void *);\n static void swap_reorder (rtx *, int);\n static void ready_reorder (rtx *, int);\n-static short high_pressure (enum machine_mode);\n+static bool high_pressure (enum machine_mode);\n static int sh_reorder (FILE *, int, rtx *, int *, int);\n static int sh_reorder2 (FILE *, int, rtx *, int *, int);\n static void sh_md_init (FILE *, int, int);\n@@ -239,7 +239,7 @@ static tree sh_media_builtin_decl (unsigned, bool);\n static rtx sh_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void sh_file_start (void);\n-static int flow_dependent_p (rtx, rtx);\n+static bool flow_dependent_p (rtx, rtx);\n static void flow_dependent_p_1 (rtx, const_rtx, void *);\n static int shiftcosts (rtx);\n static int and_xor_ior_costs (rtx, int);\n@@ -297,7 +297,7 @@ static rtx sh_function_arg (cumulative_args_t, enum machine_mode,\n static bool sh_scalar_mode_supported_p (enum machine_mode);\n static int sh_dwarf_calling_convention (const_tree);\n static void sh_encode_section_info (tree, rtx, int);\n-static int sh2a_function_vector_p (tree);\n+static bool sh2a_function_vector_p (tree);\n static void sh_trampoline_init (rtx, tree, rtx);\n static rtx sh_trampoline_adjust_address (rtx);\n static void sh_conditional_register_usage (void);\n@@ -1463,15 +1463,15 @@ force_into (rtx value, rtx target)\n    OPERANDS[2] is the size.\n    OPERANDS[3] is the alignment safe to use.  */\n \n-int\n+bool\n expand_block_move (rtx *operands)\n {\n   int align = INTVAL (operands[3]);\n   int constp = (CONST_INT_P (operands[2]));\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n \n   if (! constp)\n-    return 0;\n+    return false;\n \n   /* If we could use mov.l to move words and dest is word-aligned, we\n      can use movua.l for loads and still generate a relatively short\n@@ -1508,18 +1508,18 @@ expand_block_move (rtx *operands)\n \t\t\t\t\t\t   src_addr, copied),\n \t\t\tbytes - copied, align, 0);\n \n-      return 1;\n+      return true;\n     }\n \n   /* If it isn't a constant number of bytes, or if it doesn't have 4 byte\n      alignment, or if it isn't a multiple of 4 bytes, then fail.  */\n   if (align < 4 || (bytes % 4 != 0))\n-    return 0;\n+    return false;\n \n   if (TARGET_HARD_SH4)\n     {\n       if (bytes < 12)\n-\treturn 0;\n+\treturn false;\n       else if (bytes == 12)\n \t{\n \t  rtx func_addr_rtx = gen_reg_rtx (Pmode);\n@@ -1530,7 +1530,7 @@ expand_block_move (rtx *operands)\n \t  force_into (XEXP (operands[0], 0), r4);\n \t  force_into (XEXP (operands[1], 0), r5);\n \t  emit_insn (gen_block_move_real_i4 (func_addr_rtx));\n-\t  return 1;\n+\t  return true;\n \t}\n       else if (! optimize_size)\n \t{\n@@ -1549,10 +1549,10 @@ expand_block_move (rtx *operands)\n \t  dwords = bytes >> 3;\n \t  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));\n \t  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));\n-\t  return 1;\n+\t  return true;\n \t}\n       else\n-\treturn 0;\n+\treturn false;\n     }\n   if (bytes < 64)\n     {\n@@ -1566,7 +1566,7 @@ expand_block_move (rtx *operands)\n       force_into (XEXP (operands[0], 0), r4);\n       force_into (XEXP (operands[1], 0), r5);\n       emit_insn (gen_block_move_real (func_addr_rtx));\n-      return 1;\n+      return true;\n     }\n \n   /* This is the same number of bytes as a memcpy call, but to a different\n@@ -1593,10 +1593,10 @@ expand_block_move (rtx *operands)\n       while_loop = ((bytes / 4) / 16 - 1) * 16;\n       emit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));\n       emit_insn (gen_block_lump_real (func_addr_rtx));\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Prepare operands for a move define_expand; specifically, one of the\n@@ -3386,7 +3386,7 @@ gen_shifty_hi_op (int code, rtx *operands)\n \n /* ??? Rewrite to use super-optimizer sequences.  */\n \n-int\n+bool\n expand_ashiftrt (rtx *operands)\n {\n   rtx wrk;\n@@ -3400,19 +3400,19 @@ expand_ashiftrt (rtx *operands)\n \t  rtx count = copy_to_mode_reg (SImode, operands[2]);\n \t  emit_insn (gen_negsi2 (count, count));\n \t  emit_insn (gen_ashrsi3_d (operands[0], operands[1], count));\n-\t  return 1;\n+\t  return true;\n \t}\n       else if (ashiftrt_insns[INTVAL (operands[2]) & 31]\n \t       > 1 + SH_DYNAMIC_SHIFT_COST)\n \t{\n \t  rtx count\n \t    = force_reg (SImode, GEN_INT (- (INTVAL (operands[2]) & 31)));\n \t  emit_insn (gen_ashrsi3_d (operands[0], operands[1], count));\n-\t  return 1;\n+\t  return true;\n \t}\n     }\n   if (!CONST_INT_P (operands[2]))\n-    return 0;\n+    return false;\n \n   value = INTVAL (operands[2]) & 31;\n \n@@ -3426,10 +3426,10 @@ expand_ashiftrt (rtx *operands)\n \t  emit_insn (gen_cmpgtsi_t (force_reg (SImode, CONST0_RTX (SImode)),\n \t\t\t\t    operands[1]));\n \t  emit_insn (gen_mov_neg_si_t (operands[0]));\n-\t  return 1;\n+\t  return true;\n \t}\n       emit_insn (gen_ashrsi2_31 (operands[0], operands[1]));\n-      return 1;\n+      return true;\n     }\n   else if (value >= 16 && value <= 19)\n     {\n@@ -3439,7 +3439,7 @@ expand_ashiftrt (rtx *operands)\n       while (value--)\n \tgen_ashift (ASHIFTRT, 1, wrk);\n       emit_move_insn (operands[0], wrk);\n-      return 1;\n+      return true;\n     }\n   /* Expand a short sequence inline, longer call a magic routine.  */\n   else if (value <= 5)\n@@ -3449,7 +3449,7 @@ expand_ashiftrt (rtx *operands)\n       while (value--)\n \tgen_ashift (ASHIFTRT, 1, wrk);\n       emit_move_insn (operands[0], wrk);\n-      return 1;\n+      return true;\n     }\n \n   wrk = gen_reg_rtx (Pmode);\n@@ -3460,10 +3460,10 @@ expand_ashiftrt (rtx *operands)\n   function_symbol (wrk, func, SFUNC_STATIC);\n   emit_insn (gen_ashrsi3_n (GEN_INT (value), wrk));\n   emit_move_insn (operands[0], gen_rtx_REG (SImode, 4));\n-  return 1;\n+  return true;\n }\n \n-int\n+bool\n sh_dynamicalize_shift_p (rtx count)\n {\n   return shift_insns[INTVAL (count) & 31] > 1 + SH_DYNAMIC_SHIFT_COST;\n@@ -3636,7 +3636,7 @@ shl_and_scr_length (rtx insn)\n /* Generate rtl for instructions for which shl_and_kind advised a particular\n    method of generating them, i.e. returned zero.  */\n \n-int\n+bool\n gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n {\n   int attributes[3];\n@@ -3651,7 +3651,7 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n   switch (kind)\n     {\n     default:\n-      return -1;\n+      return true;\n     case 1:\n       {\n \tint first = attributes[2];\n@@ -3746,7 +3746,7 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \t  break;\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Try to find a good way to implement the combiner pattern\n@@ -3875,7 +3875,7 @@ shl_sext_length (rtx insn)\n \n /* Generate rtl for this pattern */\n \n-int\n+bool\n gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n {\n   int kind;\n@@ -3989,9 +3989,9 @@ gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n \temit_insn (gen_ashrsi3_k (dest, dest, const1_rtx));\n       break;\n     default:\n-      return -1;\n+      return true;\n     }\n-  return 0;\n+  return false;\n }\n \n /* Prefix a symbol_ref name with \"datalabel\".  */\n@@ -4396,7 +4396,7 @@ hi_const (rtx src)\n    CONST_DOUBLE input value is CONST_OK_FOR_I08.  For a SFmode move, we don't\n    need to fix it if the input value is CONST_OK_FOR_I08.  */\n \n-static int\n+static bool\n broken_move (rtx insn)\n {\n   if (NONJUMP_INSN_P (insn))\n@@ -4433,13 +4433,13 @@ broken_move (rtx insn)\n \t\t&& (satisfies_constraint_I20 (SET_SRC (pat))\n \t\t   || satisfies_constraint_I28 (SET_SRC (pat))))\n \t  && ! satisfies_constraint_I08 (SET_SRC (pat)))\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n-static int\n+static bool\n mova_p (rtx insn)\n {\n   return (NONJUMP_INSN_P (insn)\n@@ -4921,7 +4921,7 @@ sfunc_uses_reg (rtx insn)\n    setting it while calling it.  Set *SET to a SET rtx if the register\n    is set by INSN.  */\n \n-static int\n+static bool\n noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n {\n   rtx pattern, reg2;\n@@ -4936,7 +4936,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n \t  && REG_P (SET_DEST (pattern))\n \t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n \t*set = pattern;\n-      return 0;\n+      return false;\n     }\n   if (!CALL_P (insn))\n     {\n@@ -4957,12 +4957,12 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n \t      {\n \t\tpart = XVECEXP (par, 0, i);\n \t\tif (GET_CODE (part) != SET && reg_mentioned_p (reg, part))\n-\t\t  return 1;\n+\t\t  return true;\n \t      }\n \t  return reg_mentioned_p (reg, SET_SRC (pattern));\n \t}\n \n-      return 1;\n+      return true;\n     }\n \n   pattern = PATTERN (insn);\n@@ -4973,7 +4973,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n \n       for (i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n \tif (reg_mentioned_p (reg, XVECEXP (pattern, 0, i)))\n-\t  return 1;\n+\t  return true;\n       pattern = XVECEXP (pattern, 0, 0);\n     }\n \n@@ -4985,7 +4985,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n              mode is different.  */\n \t  if (!REG_P (SET_DEST (pattern))\n \t      || REGNO (reg) != REGNO (SET_DEST (pattern)))\n-\t    return 1;\n+\t    return true;\n \n \t  *set = pattern;\n \t}\n@@ -4996,9 +4996,9 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n   if (GET_CODE (pattern) != CALL\n       || !MEM_P (XEXP (pattern, 0))\n       || ! rtx_equal_p (reg, XEXP (XEXP (pattern, 0), 0)))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n /* Given a X, a pattern of an insn or a part of it, return a mask of used\n@@ -7643,7 +7643,7 @@ sh_expand_epilogue (bool sibcall_p)\n \n static int sh_need_epilogue_known = 0;\n \n-int\n+bool\n sh_need_epilogue (void)\n {\n   if (! sh_need_epilogue_known)\n@@ -8291,9 +8291,9 @@ static bool\n sh_promote_prototypes (const_tree type)\n {\n   if (TARGET_HITACHI)\n-    return 0;\n+    return false;\n   if (! type)\n-    return 1;\n+    return true;\n   return ! sh_attr_renesas_p (type);\n }\n \n@@ -9088,9 +9088,9 @@ sh2a_handle_function_vector_handler_attribute (tree * node, tree name,\n   return NULL_TREE;\n }\n \n-/* Returns 1 if current function has been assigned the attribute\n+/* Returns true if current function has been assigned the attribute\n    'function_vector'.  */\n-int\n+bool\n sh2a_is_function_vector_call (rtx x)\n {\n   if (GET_CODE (x) == SYMBOL_REF\n@@ -9099,10 +9099,10 @@ sh2a_is_function_vector_call (rtx x)\n       tree tr = SYMBOL_REF_DECL (x);\n \n       if (sh2a_function_vector_p (tr))\n-        return 1;\n+        return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Returns the function vector number, if the attribute\n@@ -9198,60 +9198,60 @@ sh_handle_renesas_attribute (tree *node ATTRIBUTE_UNUSED,\n }\n \n /* True if __attribute__((renesas)) or -mrenesas.  */\n-int\n+bool\n sh_attr_renesas_p (const_tree td)\n {\n   if (TARGET_HITACHI)\n-    return 1;\n+    return true;\n   if (td == 0)\n-    return 0;\n+    return false;\n   if (DECL_P (td))\n     td = TREE_TYPE (td);\n   if (td == error_mark_node)\n-    return 0;\n+    return false;\n   return (lookup_attribute (\"renesas\", TYPE_ATTRIBUTES (td))\n \t  != NULL_TREE);\n }\n \n /* True if __attribute__((renesas)) or -mrenesas, for the current\n    function.  */\n-int\n+bool\n sh_cfun_attr_renesas_p (void)\n {\n   return sh_attr_renesas_p (current_function_decl);\n }\n \n-int\n+bool\n sh_cfun_interrupt_handler_p (void)\n {\n   return (lookup_attribute (\"interrupt_handler\",\n \t\t\t    DECL_ATTRIBUTES (current_function_decl))\n \t  != NULL_TREE);\n }\n \n-/* Returns 1 if FUNC has been assigned the attribute\n+/* Returns true if FUNC has been assigned the attribute\n    \"function_vector\".  */\n-int\n+bool\n sh2a_function_vector_p (tree func)\n {\n   tree list;\n   if (TREE_CODE (func) != FUNCTION_DECL)\n-    return 0;\n+    return false;\n \n   list = SH_ATTRIBUTES (func);\n   while (list)\n     {\n       if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n-        return 1;\n+        return true;\n \n       list = TREE_CHAIN (list);\n     }\n-  return 0;\n+  return false;\n }\n \n /* Returns TRUE if given tree has the \"resbank\" attribute.  */\n \n-int\n+bool\n sh_cfun_resbank_handler_p (void)\n {\n   return ((lookup_attribute (\"resbank\",\n@@ -9280,45 +9280,45 @@ sh_check_pch_target_flags (int old_flags)\n \f\n /* Predicates used by the templates.  */\n \n-/* Returns 1 if OP is MACL, MACH or PR.  The input must be a REG rtx.\n+/* Returns true if OP is MACL, MACH or PR.  The input must be a REG rtx.\n    Used only in general_movsrc_operand.  */\n \n-int\n+bool\n system_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (REGNO (op))\n     {\n     case PR_REG:\n     case MACL_REG:\n     case MACH_REG:\n-      return 1;\n+      return true;\n     }\n-  return 0;\n+  return false;\n }\n \n-/* Nonzero if OP is a floating point value with value 0.0.  */\n+/* Returns true if OP is a floating point value with value 0.0.  */\n \n-int\n+bool\n fp_zero_operand (rtx op)\n {\n   REAL_VALUE_TYPE r;\n \n   if (GET_MODE (op) != SFmode)\n-    return 0;\n+    return false;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n   return REAL_VALUES_EQUAL (r, dconst0) && ! REAL_VALUE_MINUS_ZERO (r);\n }\n \n-/* Nonzero if OP is a floating point value with value 1.0.  */\n+/* Returns true if OP is a floating point value with value 1.0.  */\n \n-int\n+bool\n fp_one_operand (rtx op)\n {\n   REAL_VALUE_TYPE r;\n \n   if (GET_MODE (op) != SFmode)\n-    return 0;\n+    return false;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n   return REAL_VALUES_EQUAL (r, dconst1);\n@@ -9331,10 +9331,10 @@ fp_one_operand (rtx op)\n    interface to find that out during reload, so we must avoid\n    choosing an fldi alternative during reload and thus failing to\n    allocate a scratch register for the constant loading.  */\n-int\n+bool\n fldi_ok (void)\n {\n-  return 1;\n+  return true;\n }\n \n /* Return the TLS type for TLS symbols, 0 for otherwise.  */\n@@ -9364,7 +9364,7 @@ branch_dest (rtx branch)\n /* Return nonzero if REG is not used after INSN.\n    We assume REG is a reload reg, and therefore does\n    not live past labels.  It may live past calls or jumps though.  */\n-int\n+bool\n reg_unused_after (rtx reg, rtx insn)\n {\n   enum rtx_code code;\n@@ -9376,7 +9376,7 @@ reg_unused_after (rtx reg, rtx insn)\n   set = single_set (insn);\n   if (set && !MEM_P (SET_DEST (set))\n       && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-    return 1;\n+    return true;\n \n   while ((insn = NEXT_INSN (insn)))\n     {\n@@ -9397,7 +9397,7 @@ reg_unused_after (rtx reg, rtx insn)\n #endif\n \n       if (code == JUMP_INSN)\n-\treturn 0;\n+\treturn false;\n \n       /* If this is a sequence, we must handle them all at once.\n \t We could have for instance a call that sets the target register,\n@@ -9418,41 +9418,41 @@ reg_unused_after (rtx reg, rtx insn)\n \t      else if (JUMP_P (this_insn))\n \t\t{\n \t\t  if (INSN_ANNULLED_BRANCH_P (this_insn))\n-\t\t    return 0;\n+\t\t    return false;\n \t\t  code = JUMP_INSN;\n \t\t}\n \n \t      if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n-\t\treturn 0;\n+\t\treturn false;\n \t      if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \t\t{\n \t\t  if (!MEM_P (SET_DEST (set)))\n-\t\t    retval = 1;\n+\t\t    retval = true;\n \t\t  else\n-\t\t    return 0;\n+\t\t    return false;\n \t\t}\n \t      if (set == 0\n \t\t  && reg_overlap_mentioned_p (reg, PATTERN (this_insn)))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n \t  if (retval == 1)\n-\t    return 1;\n+\t    return true;\n \t  else if (code == JUMP_INSN)\n-\t    return 0;\n+\t    return false;\n \t}\n \n       set = single_set (insn);\n       if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n-\treturn 0;\n+\treturn false;\n       if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \treturn !MEM_P (SET_DEST (set));\n       if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n-\treturn 0;\n+\treturn false;\n \n       if (code == CALL_INSN && call_really_used_regs[REGNO (reg)])\n-\treturn 1;\n+\treturn true;\n     }\n-  return 1;\n+  return true;\n }\n \f\n #include \"ggc.h\"\n@@ -9770,20 +9770,20 @@ sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \f\n /* Return TRUE if X references a SYMBOL_REF or LABEL_REF whose symbol\n    isn't protected by a PIC unspec.  */\n-int\n+bool\n nonpic_symbol_mentioned_p (rtx x)\n {\n-  register const char *fmt;\n-  register int i;\n+  const char *fmt;\n+  int i;\n \n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF\n       || GET_CODE (x) == PC)\n-    return 1;\n+    return true;\n \n   /* We don't want to look into the possible MEM location of a\n      CONST_DOUBLE, since we're not going to use it, in general.  */\n   if (GET_CODE (x) == CONST_DOUBLE)\n-    return 0;\n+    return false;\n \n   if (GET_CODE (x) == UNSPEC\n       && (XINT (x, 1) == UNSPEC_PIC\n@@ -9796,24 +9796,23 @@ nonpic_symbol_mentioned_p (rtx x)\n \t  || XINT (x, 1) == UNSPEC_PLT\n \t  || XINT (x, 1) == UNSPEC_SYMOFF\n \t  || XINT (x, 1) == UNSPEC_PCREL_SYMOFF))\n-    return 0;\n+    return false;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n-\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (nonpic_symbol_mentioned_p (XVECEXP (x, i, j)))\n-\t      return 1;\n+\t      return true;\n \t}\n       else if (fmt[i] == 'e' && nonpic_symbol_mentioned_p (XEXP (x, i)))\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n@@ -10143,7 +10142,7 @@ mark_constant_pool_use (rtx x)\n /* Return true if it's possible to redirect BRANCH1 to the destination\n    of an unconditional jump BRANCH2.  We only want to do this if the\n    resulting branch will have a short displacement.  */\n-int\n+bool\n sh_can_redirect_branch (rtx branch1, rtx branch2)\n {\n   if (flag_expensive_optimizations && simplejump_p (branch2))\n@@ -10157,7 +10156,7 @@ sh_can_redirect_branch (rtx branch1, rtx branch2)\n \t   insn = PREV_INSN (insn))\n \t{\n \t  if (insn == dest)\n-\t    return 1;\n+\t    return true;\n \t  else\n \t    distance += get_attr_length (insn);\n \t}\n@@ -10166,16 +10165,16 @@ sh_can_redirect_branch (rtx branch1, rtx branch2)\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  if (insn == dest)\n-\t    return 1;\n+\t    return true;\n \t  else\n \t    distance += get_attr_length (insn);\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Return nonzero if register old_reg can be renamed to register new_reg.  */\n-int\n+bool\n sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n \t\t\t unsigned int new_reg)\n {\n@@ -10184,9 +10183,9 @@ sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n      call-clobbered.  */\n \n   if (sh_cfun_interrupt_handler_p () && !df_regs_ever_live_p (new_reg))\n-    return 0;\n+    return false;\n \n-  return 1;\n+  return true;\n }\n \n /* Function to update the integer COST\n@@ -10397,7 +10396,7 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n \n /* Check if INSN is flow-dependent on DEP_INSN.  Can also be used to check\n    if DEP_INSN is anti-flow dependent on INSN.  */\n-static int\n+static bool\n flow_dependent_p (rtx insn, rtx dep_insn)\n {\n   rtx tmp = PATTERN (insn);\n@@ -10734,13 +10733,13 @@ sh_md_init (FILE *dump ATTRIBUTE_UNUSED,\n #define SFMODE_MAX_WEIGHT 10\n \n /* Return true if the pressure is high for MODE.  */\n-static short\n+static bool\n high_pressure (enum machine_mode mode)\n {\n   /* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n      functions that already have high pressure on r0. */\n    if (r0_life_regions >= R0_MAX_LIFE_REGIONS)\n-     return 1;\n+     return true;\n \n   if (mode == SFmode)\n     return (CURR_REGMODE_PRESSURE (SFmode) > SFMODE_MAX_WEIGHT);\n@@ -12053,7 +12052,7 @@ extract_sfunc_addr (rtx insn)\n    use_sfunc_addr.\n    INSN is the use_sfunc_addr instruction, and REG is the register it\n    guards.  */\n-int\n+bool\n check_use_sfunc_addr (rtx insn, rtx reg)\n {\n   /* Search for the sfunc.  It should really come right after INSN.  */\n@@ -12385,25 +12384,25 @@ sh_contains_memref_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n   return (MEM_P (*loc));\n }\n \n-/* Return nonzero iff INSN contains a MEM.  */\n-int\n+/* Return true iff INSN contains a MEM.  */\n+bool\n sh_contains_memref_p (rtx insn)\n {\n   return for_each_rtx (&PATTERN (insn), &sh_contains_memref_p_1, NULL);\n }\n \n-/* Return nonzero iff INSN loads a banked register.  */\n-int\n+/* Return true iff INSN loads a banked register.  */\n+bool\n sh_loads_bankedreg_p (rtx insn)\n {\n   if (GET_CODE (PATTERN (insn)) == SET)\n     {\n       rtx op = SET_DEST (PATTERN(insn));\n       if (REG_P (op) && BANKED_REGISTER_P (REGNO (op)))\n-\treturn 1;\n+\treturn true;\n     }\n \n-  return 0;  \n+  return false;\n }\n \n /* FNADDR is the MEM expression from a call expander.  Return an address"}]}