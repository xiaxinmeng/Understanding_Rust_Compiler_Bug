{"sha": "bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZiMjM4MDZiODNjM2JjMjRmOWVkNjIzMjk3NGQ3ODNjMDBhMmViZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@act-europe.fr", "date": "2004-05-07T11:40:42Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-05-07T11:40:42Z"}, "message": "sparc-protos.h (sparc_skip_caller_unimp): New declaration.\n\n\t* config/sparc/sparc-protos.h (sparc_skip_caller_unimp): New\n\tdeclaration.\n\t* config/sparc/sparc.c (SKIP_CALLERS_UNIMP_P): Delete.\n\t(sparc_skip_caller_unimp): New global variable.\n\t(sparc_function_epilogue): Set 'sparc_skip_caller_unimp'.\n\tUse it instead of SKIP_CALLERS_UNIMP_P.\n\t* config/sparc/sparc.md (call expander): Add sanity check.\n\t(call_address_struct_value_sp32): Re-sync with expander.\n\t(call_symbolic_struct_value_sp32): Likewise.\n\t(return peepholes): Use 'sparc_skip_caller_unimp' instead\n\tof custom predicate.\n\nFrom-SVN: r81617", "tree": {"sha": "4af06369785f575d5e325c746eceec41ce3febdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4af06369785f575d5e325c746eceec41ce3febdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/comments", "author": null, "committer": null, "parents": [{"sha": "92ff0c419aee64c757481517b44043dbe7c6b501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ff0c419aee64c757481517b44043dbe7c6b501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ff0c419aee64c757481517b44043dbe7c6b501"}], "stats": {"total": 74, "additions": 48, "deletions": 26}, "files": [{"sha": "a4e9863953889631e913fd9fca37bdbc3dbfc539", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "patch": "@@ -1,3 +1,17 @@\n+2004-05-07  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\t* config/sparc/sparc-protos.h (sparc_skip_caller_unimp): New\n+\tdeclaration.\n+\t* config/sparc/sparc.c (SKIP_CALLERS_UNIMP_P): Delete.\n+\t(sparc_skip_caller_unimp): New global variable.\n+\t(sparc_function_epilogue): Set 'sparc_skip_caller_unimp'.\n+\tUse it instead of SKIP_CALLERS_UNIMP_P.\n+\t* config/sparc/sparc.md (call expander): Add sanity check.\n+\t(call_address_struct_value_sp32): Re-sync with expander.\n+\t(call_symbolic_struct_value_sp32): Likewise.\n+\t(return peepholes): Use 'sparc_skip_caller_unimp' instead\n+\tof custom predicate.\n+\n 2004-05-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR c++/14962"}, {"sha": "4b1f9f0d3bebfeb7f1b0757735b9fd743b796550", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #define __SPARC_PROTOS_H__\n \n extern bool sparc_emitting_epilogue;\n+extern bool sparc_skip_caller_unimp;\n \n #ifdef TREE_CODE\n extern struct rtx_def *function_value (tree, enum machine_mode, int);"}, {"sha": "2192d96722447a35d05cae720a9d19880f0fbca7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "patch": "@@ -48,17 +48,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"cfglayout.h\"\n \n-/* 1 if the caller has placed an \"unimp\" insn immediately after the call.\n-   This is used in v8 code when calling a function that returns a structure.\n-   v9 doesn't have this.  Be careful to have this test be the same as that\n-   used on the call.  */\n-\n-#define SKIP_CALLERS_UNIMP_P  \\\n-(!TARGET_ARCH64 && current_function_returns_struct\t\t\t\\\n- && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)))\t\\\n- && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\t\\\n-     == INTEGER_CST))\n-\n /* Global variables for machine-dependent things.  */\n \n /* Size of frame.  Need to know this to emit return insns from leaf procedures.\n@@ -81,6 +70,7 @@ rtx sparc_compare_op0, sparc_compare_op1;\n /* Coordinate with the md file wrt special insns created by\n    sparc_function_epilogue.  */\n bool sparc_emitting_epilogue;\n+bool sparc_skip_caller_unimp;\n \n /* Vector to say how input registers are mapped to output registers.\n    HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to\n@@ -4498,6 +4488,17 @@ sparc_function_epilogue (FILE *file,\n {\n   const char *ret;\n \n+  /* True if the caller has placed an \"unimp\" insn immediately after the call.\n+     This insn is used in the 32-bit ABI when calling a function that returns\n+     a non zero-sized structure. The 64-bit ABI doesn't have it.  Be careful\n+     to have this test be the same as that used on the call.  */\n+  sparc_skip_caller_unimp =\n+    ! TARGET_ARCH64\n+    && current_function_returns_struct\n+    && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n+\t== INTEGER_CST)\n+    && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)));\n+\n   if (current_function_epilogue_delay_list == 0)\n     {\n       /* If code does not drop into the epilogue, we need\n@@ -4532,17 +4533,17 @@ sparc_function_epilogue (FILE *file,\n \n   /* Work out how to skip the caller's unimp instruction if required.  */\n   if (leaf_function)\n-    ret = (SKIP_CALLERS_UNIMP_P ? \"jmp\\t%o7+12\" : \"retl\");\n+    ret = (sparc_skip_caller_unimp ? \"jmp\\t%o7+12\" : \"retl\");\n   else\n-    ret = (SKIP_CALLERS_UNIMP_P ? \"jmp\\t%i7+12\" : \"ret\");\n+    ret = (sparc_skip_caller_unimp ? \"jmp\\t%i7+12\" : \"ret\");\n \n   if (! leaf_function)\n     {\n       if (current_function_calls_eh_return)\n \t{\n \t  if (current_function_epilogue_delay_list)\n \t    abort ();\n-\t  if (SKIP_CALLERS_UNIMP_P)\n+\t  if (sparc_skip_caller_unimp)\n \t    abort ();\n \n \t  fputs (\"\\trestore\\n\\tretl\\n\\tadd\\t%sp, %g1, %sp\\n\", file);\n@@ -4555,7 +4556,7 @@ sparc_function_epilogue (FILE *file,\n \t  if (TARGET_V9 && ! epilogue_renumber (&delay, 1))\n \t    {\n \t      epilogue_renumber (&delay, 0);\n-\t      fputs (SKIP_CALLERS_UNIMP_P\n+\t      fputs (sparc_skip_caller_unimp\n \t\t     ? \"\\treturn\\t%i7+12\\n\"\n \t\t     : \"\\treturn\\t%i7+8\\n\", file);\n \t      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n@@ -4588,7 +4589,7 @@ sparc_function_epilogue (FILE *file,\n \t      sparc_emitting_epilogue = false;\n \t    }\n \t}\n-      else if (TARGET_V9 && ! SKIP_CALLERS_UNIMP_P)\n+      else if (TARGET_V9 && ! sparc_skip_caller_unimp)\n \tfputs (\"\\treturn\\t%i7+8\\n\\tnop\\n\", file);\n       else\n \tfprintf (file, \"\\t%s\\n\\trestore\\n\", ret);"}, {"sha": "130d58c84f8e87c66e51110e6f9507b4101675ea", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfb23806b83c3bc24f9ed6232974d783c00a2ebd/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bfb23806b83c3bc24f9ed6232974d783c00a2ebd", "patch": "@@ -7321,9 +7321,12 @@\n {\n   rtx fn_rtx;\n \n-   if (GET_MODE (operands[0]) != FUNCTION_MODE)\n+  if (GET_MODE (operands[0]) != FUNCTION_MODE)\n     abort ();\n \n+  if (GET_CODE (operands[3]) != CONST_INT)\n+    abort();\n+\n   if (GET_CODE (XEXP (operands[0], 0)) == LABEL_REF)\n     {\n       /* This is really a PIC sequence.  We want to represent\n@@ -7333,6 +7336,7 @@\n \t call-clobbered registers?  We lose this if it is a JUMP_INSN.\n \t Why cannot we have delay slots filled if it were a CALL?  */\n \n+      /* We accept negative sizes for untyped calls.  */\n       if (! TARGET_ARCH64 && INTVAL (operands[3]) != 0)\n \temit_jump_insn\n \t  (gen_rtx_PARALLEL\n@@ -7353,6 +7357,7 @@\n \n   fn_rtx = operands[0];\n \n+  /* We accept negative sizes for untyped calls.  */\n   if (! TARGET_ARCH64 && INTVAL (operands[3]) != 0)\n     emit_call_insn\n       (gen_rtx_PARALLEL\n@@ -7419,7 +7424,7 @@\n    (match_operand 2 \"immediate_operand\" \"\")\n    (clobber (reg:SI 15))]\n   ;;- Do not use operand 1 for most machines.\n-  \"! TARGET_ARCH64 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0\"\n+  \"! TARGET_ARCH64 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 0\"\n   \"call\\t%a0, %1\\n\\tnop\\n\\tunimp\\t%2\"\n   [(set_attr \"type\" \"call_no_delay_slot\")\n    (set_attr \"length\" \"3\")])\n@@ -7432,7 +7437,7 @@\n    (match_operand 2 \"immediate_operand\" \"\")\n    (clobber (reg:SI 15))]\n   ;;- Do not use operand 1 for most machines.\n-  \"! TARGET_ARCH64 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0\"\n+  \"! TARGET_ARCH64 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 0\"\n   \"call\\t%a0, %1\\n\\tnop\\n\\tunimp\\t%2\"\n   [(set_attr \"type\" \"call_no_delay_slot\")\n    (set_attr \"length\" \"3\")])\n@@ -7450,7 +7455,8 @@\n   [(set_attr \"type\" \"call_no_delay_slot\")\n    (set_attr \"length\" \"3\")])\n \n-;; This is a call that wants a structure value.\n+;; This is a call that may want a structure value.  This is used for\n+;; untyped_calls.\n (define_insn \"*call_symbolic_untyped_struct_value_sp32\"\n   [(call (mem:SI (match_operand:SI 0 \"symbolic_operand\" \"s\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -8083,7 +8089,7 @@\n    (return)]\n   \"sparc_emitting_epilogue\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n   else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n \t\t\t || IN_OR_GLOBAL_P (operands[1])))\n@@ -8100,7 +8106,7 @@\n    (return)]\n   \"sparc_emitting_epilogue\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n   else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n \t\t\t || IN_OR_GLOBAL_P (operands[1])))\n@@ -8117,7 +8123,7 @@\n    (return)]\n   \"sparc_emitting_epilogue\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n   else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n \t\t\t || IN_OR_GLOBAL_P (operands[1])))\n@@ -8134,7 +8140,7 @@\n    (return)]\n   \"sparc_emitting_epilogue\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n   else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))\n     return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n@@ -8165,7 +8171,7 @@\n    (return)]\n   \"sparc_emitting_epilogue\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %r1, %2, %Y0\";\n   /* If operands are global or in registers, can use return */\n   else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1])\n@@ -8185,7 +8191,7 @@\n    (return)]\n   \"sparc_emitting_epilogue && ! TARGET_CM_MEDMID\"\n {\n-  if (! TARGET_ARCH64 && current_function_returns_struct)\n+  if (sparc_skip_caller_unimp)\n     return \"jmp\\t%%i7+12\\n\\trestore %r1, %%lo(%a2), %Y0\";\n   /* If operands are global or in registers, can use return */\n   else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))"}]}