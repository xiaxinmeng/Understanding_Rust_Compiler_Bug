{"sha": "38c28a2564a0f81eb26b2eec0908190c2094dd1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjMjhhMjU2NGEwZjgxZWIyNmIyZWVjMDkwODE5MGMyMDk0ZGQxZg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2005-07-28T02:03:45Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2005-07-28T02:03:45Z"}, "message": "frv.opt (moptimize-membar): New.\n\n\t* config/frv/frv.opt (moptimize-membar): New.\n\n\t* doc/invoke.texi: Document -moptimize-membar and its inverse.\n\n\t* config/frv/frv.h: Remove machine_function definition.\n\n        * config/frv/frv.c (struct frv_io): New.\n        (struct machine_function): Moved from frv.h.  Add has_membar_p.\n        (frv_same_doubleword_p, frv_io_fixed_order_p, frv_io_union)\n        (frv_extract_membar, frv_io_check_address, frv_io_handle_set)\n        (frv_io_handle_use_1, frv_io_handle_use, frv_optimize_membar_local)\n        (frv_optimize_membar_global, frv_optimize_membar): New functions.\n        (frv_reorg): Call frv_optimize_membar when appropriate.\n        (bdesc_loads, bdesc_stores): Use the membar code as the icode field.\n        (frv_expand_builtin): Adjust calls accordingly.\n        (frv_io_address_cookie): New function.\n        (frv_expand_load_builtin, frv_expand_store_builtin): Emit a normal\n        load or store rather than a special insn.  Add ccnstant address and\n        io-type operands to the membar.\n\t(frv_ifcvt_modify_tests): Unsign regno.\n\t(frv_ifcvt_modify_tests): Same.\n\n\t* config/frv/frv.md: Remove UNSPEC_BUILTIN_{LOAD,STORE}.  Change\n\tUNSPEC_OPTIONAL_MEMBAR constant.\n\t(builtin_read_<mode>): Delete.\n\t(builtin_write_<mode>): Delete.\n\t(\"optional_membar_<mode>\"): Add operand.\n\n\t* testsuite/gcc.target/frv/all-builtin-read8.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-read16.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-read32.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-read64.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-write8.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-write16.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-write32.c: Delete.\n\t* testsuite/gcc.target/frv/all-builtin-write64.c: Delete.\n\t* testsuite/gcc.target/frv/all-read-write-1.c: New.\n\nFrom-SVN: r102455", "tree": {"sha": "86d74a60faadcae82333a3bbc29a7771ade8a80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86d74a60faadcae82333a3bbc29a7771ade8a80b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c28a2564a0f81eb26b2eec0908190c2094dd1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c28a2564a0f81eb26b2eec0908190c2094dd1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c28a2564a0f81eb26b2eec0908190c2094dd1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c28a2564a0f81eb26b2eec0908190c2094dd1f/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47c504ea5ba6da768565dc25fd0455001cec7090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c504ea5ba6da768565dc25fd0455001cec7090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c504ea5ba6da768565dc25fd0455001cec7090"}], "stats": {"total": 693, "additions": 516, "deletions": 177}, "files": [{"sha": "299d20642a6550ad3508002ac7d31eab4986c3cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -1,3 +1,43 @@\n+2005-07-27  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* config/frv/frv.opt (moptimize-membar): New.\n+\n+\t* doc/invoke.texi: Document -moptimize-membar and its inverse.\n+\n+\t* config/frv/frv.h: Remove machine_function definition.\n+\n+        * config/frv/frv.c (struct frv_io): New.\n+        (struct machine_function): Moved from frv.h.  Add has_membar_p.\n+        (frv_same_doubleword_p, frv_io_fixed_order_p, frv_io_union)\n+        (frv_extract_membar, frv_io_check_address, frv_io_handle_set)\n+        (frv_io_handle_use_1, frv_io_handle_use, frv_optimize_membar_local)\n+        (frv_optimize_membar_global, frv_optimize_membar): New functions.\n+        (frv_reorg): Call frv_optimize_membar when appropriate.\n+        (bdesc_loads, bdesc_stores): Use the membar code as the icode field.\n+        (frv_expand_builtin): Adjust calls accordingly.\n+        (frv_io_address_cookie): New function.\n+        (frv_expand_load_builtin, frv_expand_store_builtin): Emit a normal\n+        load or store rather than a special insn.  Add ccnstant address and\n+        io-type operands to the membar.\n+\t(frv_ifcvt_modify_tests): Unsign regno.\n+\t(frv_ifcvt_modify_tests): Same.\n+\n+\t* config/frv/frv.md: Remove UNSPEC_BUILTIN_{LOAD,STORE}.  Change\n+\tUNSPEC_OPTIONAL_MEMBAR constant.\n+\t(builtin_read_<mode>): Delete.\n+\t(builtin_write_<mode>): Delete.\n+\t(\"optional_membar_<mode>\"): Add operand.\n+\n+\t* testsuite/gcc.target/frv/all-builtin-read8.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-read16.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-read32.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-read64.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-write8.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-write16.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-write32.c: Delete.\n+\t* testsuite/gcc.target/frv/all-builtin-write64.c: Delete.\n+\t* testsuite/gcc.target/frv/all-read-write-1.c: New.\n+\n 2005-07-28  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* df.c (df_uses_record): Handle SCRATCH."}, {"sha": "9213f9b901d374a6084f2a12a75ac99992e504b8", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 416, "deletions": 42, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -109,6 +109,21 @@ static GTY(()) rtx frv_nops[NUM_NOP_PATTERNS];\n /* The number of nop instructions in frv_nops[].  */\n static unsigned int frv_num_nops;\n \n+/* Information about one __builtin_read or __builtin_write access, or\n+   the combination of several such accesses.  The most general value\n+   is all-zeros (an unknown access to an unknown address).  */\n+struct frv_io {\n+  /* The type of access.  FRV_IO_UNKNOWN means the access can be either\n+     a read or a write.  */\n+  enum { FRV_IO_UNKNOWN, FRV_IO_READ, FRV_IO_WRITE } type;\n+\n+  /* The constant address being accessed, or zero if not known.  */\n+  HOST_WIDE_INT const_address;\n+\n+  /* The run-time address, as used in operand 0 of the membar pattern.  */\n+  rtx var_address;\n+};\n+\n /* Return true if instruction INSN should be packed with the following\n    instruction.  */\n #define PACKING_FLAG_P(INSN) (GET_MODE (INSN) == TImode)\n@@ -123,6 +138,16 @@ static unsigned int frv_num_nops;\n        REG < REGNO (X) + HARD_REGNO_NREGS (REGNO (X), GET_MODE (X));\t\\\n        REG++)\n \n+/* This structure contains machine specific function data.  */\n+struct machine_function GTY(())\n+{\n+  /* True if we have created an rtx that relies on the stack frame.  */\n+  int frame_needed;\n+\n+  /* True if this function contains at least one __builtin_{read,write}*.  */\n+  bool has_membar_p;\n+};\n+\n /* Temporary register allocation support structure.  */\n typedef struct frv_tmp_reg_struct\n   {\n@@ -756,6 +781,9 @@ frv_override_options (void)\n   if ((target_flags_explicit & MASK_LINKED_FP) == 0)\n     target_flags |= MASK_LINKED_FP;\n \n+  if ((target_flags_explicit & MASK_OPTIMIZE_MEMBAR) == 0)\n+    target_flags |= MASK_OPTIMIZE_MEMBAR;\n+\n   for (i = 0; i < ARRAY_SIZE (frv_unit_names); i++)\n     frv_unit_codes[i] = get_cpu_unit_code (frv_unit_names[i]);\n \n@@ -5291,7 +5319,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \n   if (join_bb)\n     {\n-      int regno;\n+      unsigned int regno;\n \n       /* Remove anything live at the beginning of the join block from being\n          available for allocation.  */\n@@ -5328,7 +5356,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n     {\n       rtx last_insn = BB_END (bb[j]);\n       rtx insn = BB_HEAD (bb[j]);\n-      int regno;\n+      unsigned int regno;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Scanning %s block %d, start %d, end %d\\n\",\n@@ -7661,6 +7689,334 @@ frv_fill_unused_units (enum frv_insn_group group)\n     frv_insert_nop_in_packet (packet_group->nop);\n }\n \n+/* Return true if accesses IO1 and IO2 refer to the same doubleword.  */\n+\n+static bool\n+frv_same_doubleword_p (const struct frv_io *io1, const struct frv_io *io2)\n+{\n+  if (io1->const_address != 0 && io2->const_address != 0)\n+    return io1->const_address == io2->const_address;\n+\n+  if (io1->var_address != 0 && io2->var_address != 0)\n+    return rtx_equal_p (io1->var_address, io2->var_address);\n+\n+  return false;\n+}\n+\n+/* Return true if operations IO1 and IO2 are guaranteed to complete\n+   in order.  */\n+\n+static bool\n+frv_io_fixed_order_p (const struct frv_io *io1, const struct frv_io *io2)\n+{\n+  /* The order of writes is always preserved.  */\n+  if (io1->type == FRV_IO_WRITE && io2->type == FRV_IO_WRITE)\n+    return true;\n+\n+  /* The order of reads isn't preserved.  */\n+  if (io1->type != FRV_IO_WRITE && io2->type != FRV_IO_WRITE)\n+    return false;\n+\n+  /* One operation is a write and the other is (or could be) a read.\n+     The order is only guaranteed if the accesses are to the same\n+     doubleword.  */\n+  return frv_same_doubleword_p (io1, io2);\n+}\n+\n+/* Generalize I/O operation X so that it covers both X and Y. */\n+\n+static void\n+frv_io_union (struct frv_io *x, const struct frv_io *y)\n+{\n+  if (x->type != y->type)\n+    x->type = FRV_IO_UNKNOWN;\n+  if (!frv_same_doubleword_p (x, y))\n+    {\n+      x->const_address = 0;\n+      x->var_address = 0;\n+    }\n+}\n+\n+/* Fill IO with information about the load or store associated with\n+   membar instruction INSN.  */\n+\n+static void\n+frv_extract_membar (struct frv_io *io, rtx insn)\n+{\n+  extract_insn (insn);\n+  io->type = INTVAL (recog_data.operand[2]);\n+  io->const_address = INTVAL (recog_data.operand[1]);\n+  io->var_address = XEXP (recog_data.operand[0], 0);\n+}\n+\n+/* A note_stores callback for which DATA points to an rtx.  Nullify *DATA\n+   if X is a register and *DATA depends on X.  */\n+\n+static void\n+frv_io_check_address (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx *other = data;\n+\n+  if (REG_P (x) && *other != 0 && reg_overlap_mentioned_p (x, *other))\n+    *other = 0;\n+}\n+\n+/* A note_stores callback for which DATA points to a HARD_REG_SET.\n+   Remove every modified register from the set.  */\n+\n+static void\n+frv_io_handle_set (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n+{\n+  HARD_REG_SET *set = data;\n+  unsigned int regno;\n+\n+  if (REG_P (x))\n+    FOR_EACH_REGNO (regno, x)\n+      CLEAR_HARD_REG_BIT (*set, regno);\n+}\n+\n+/* A for_each_rtx callback for which DATA points to a HARD_REG_SET.\n+   Add every register in *X to the set.  */\n+\n+static int\n+frv_io_handle_use_1 (rtx *x, void *data)\n+{\n+  HARD_REG_SET *set = data;\n+  unsigned int regno;\n+\n+  if (REG_P (*x))\n+    FOR_EACH_REGNO (regno, *x)\n+      SET_HARD_REG_BIT (*set, regno);\n+\n+  return 0;\n+}\n+\n+/* A note_stores callback that applies frv_io_handle_use_1 to an\n+   entire rhs value.  */\n+\n+static void\n+frv_io_handle_use (rtx *x, void *data)\n+{\n+  for_each_rtx (x, frv_io_handle_use_1, data);\n+}\n+\n+/* Go through block BB looking for membars to remove.  There are two\n+   cases where intra-block analysis is enough:\n+\n+   - a membar is redundant if it occurs between two consecutive I/O\n+   operations and if those operations are guaranteed to complete\n+   in order.\n+\n+   - a membar for a __builtin_read is redundant if the result is\n+   used before the next I/O operation is issued.\n+\n+   If the last membar in the block could not be removed, and there\n+   are guaranteed to be no I/O operations between that membar and\n+   the end of the block, store the membar in *LAST_MEMBAR, otherwise\n+   store null.\n+\n+   Describe the block's first I/O operation in *NEXT_IO.  Describe\n+   an unknown operation if the block doesn't do any I/O.  */\n+\n+static void\n+frv_optimize_membar_local (basic_block bb, struct frv_io *next_io,\n+\t\t\t   rtx *last_membar)\n+{\n+  HARD_REG_SET used_regs;\n+  rtx next_membar, set, insn;\n+  bool next_is_end_p;\n+\n+  /* NEXT_IO is the next I/O operation to be performed after the current\n+     instruction.  It starts off as being an unknown operation.  */\n+  memset (next_io, 0, sizeof (*next_io));\n+\n+  /* NEXT_IS_END_P is true if NEXT_IO describes the end of the block.  */\n+  next_is_end_p = true;\n+\n+  /* If the current instruction is a __builtin_read or __builtin_write,\n+     NEXT_MEMBAR is the membar instruction associated with it.  NEXT_MEMBAR\n+     is null if the membar has already been deleted.\n+\n+     Note that the initialization here should only be needed to\n+     supress warnings.  */\n+  next_membar = 0;\n+\n+  /* USED_REGS is the set of registers that are used before the\n+     next I/O instruction.  */\n+  CLEAR_HARD_REG_SET (used_regs);\n+\n+  for (insn = BB_END (bb); insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n+    if (GET_CODE (insn) == CALL_INSN)\n+      {\n+\t/* We can't predict what a call will do to volatile memory.  */\n+\tmemset (next_io, 0, sizeof (struct frv_io));\n+\tnext_is_end_p = false;\n+\tCLEAR_HARD_REG_SET (used_regs);\n+      }\n+    else if (INSN_P (insn))\n+      switch (recog_memoized (insn))\n+\t{\n+\tcase CODE_FOR_optional_membar_qi:\n+\tcase CODE_FOR_optional_membar_hi:\n+\tcase CODE_FOR_optional_membar_si:\n+\tcase CODE_FOR_optional_membar_di:\n+\t  next_membar = insn;\n+\t  if (next_is_end_p)\n+\t    {\n+\t      /* Local information isn't enough to decide whether this\n+\t\t membar is needed.  Stash it away for later.  */\n+\t      *last_membar = insn;\n+\t      frv_extract_membar (next_io, insn);\n+\t      next_is_end_p = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Check whether the I/O operation before INSN could be\n+\t\t reordered with one described by NEXT_IO.  If it can't,\n+\t\t INSN will not be needed.  */\n+\t      struct frv_io prev_io;\n+\n+\t      frv_extract_membar (&prev_io, insn);\n+\t      if (frv_io_fixed_order_p (&prev_io, next_io))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \";; [Local] Removing membar %d since order\"\n+\t\t\t     \" of accesses is guaranteed\\n\",\n+\t\t\t     INSN_UID (next_membar));\n+\n+\t\t  insn = NEXT_INSN (insn);\n+\t\t  delete_insn (next_membar);\n+\t\t  next_membar = 0;\n+\t\t}\n+\t      *next_io = prev_io;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  /* Invalidate NEXT_IO's address if it depends on something that\n+\t     is clobbered by INSN.  */\n+\t  if (next_io->var_address)\n+\t    note_stores (PATTERN (insn), frv_io_check_address,\n+\t\t\t &next_io->var_address);\n+\n+\t  /* If the next membar is associated with a __builtin_read,\n+\t     see if INSN reads from that address.  If it does, and if\n+\t     the destination register is used before the next I/O access,\n+\t     there is no need for the membar.  */\n+\t  set = PATTERN (insn);\n+\t  if (next_io->type == FRV_IO_READ\n+\t      && next_io->var_address != 0\n+\t      && next_membar != 0\n+\t      && GET_CODE (set) == SET\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && TEST_HARD_REG_BIT (used_regs, REGNO (SET_DEST (set))))\n+\t    {\n+\t      rtx src;\n+\n+\t      src = SET_SRC (set);\n+\t      if (GET_CODE (src) == ZERO_EXTEND)\n+\t\tsrc = XEXP (src, 0);\n+\n+\t      if (GET_CODE (src) == MEM\n+\t\t  && rtx_equal_p (XEXP (src, 0), next_io->var_address))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \";; [Local] Removing membar %d since the target\"\n+\t\t\t     \" of %d is used before the I/O operation\\n\",\n+\t\t\t     INSN_UID (next_membar), INSN_UID (insn));\n+\n+\t\t  if (next_membar == *last_membar)\n+\t\t    *last_membar = 0;\n+\n+\t\t  delete_insn (next_membar);\n+\t\t  next_membar = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* If INSN has volatile references, forget about any registers\n+\t     that are used after it.  Otherwise forget about uses that\n+\t     are (or might be) defined by INSN.  */\n+\t  if (volatile_refs_p (PATTERN (insn)))\n+\t    CLEAR_HARD_REG_SET (used_regs);\n+\t  else\n+\t    note_stores (PATTERN (insn), frv_io_handle_set, &used_regs);\n+\n+\t  note_uses (&PATTERN (insn), frv_io_handle_use, &used_regs);\n+\t  break;\n+\t}\n+}\n+\n+/* See if MEMBAR, the last membar instruction in BB, can be removed.\n+   FIRST_IO[X] describes the first operation performed by basic block X.  */\n+\n+static void\n+frv_optimize_membar_global (basic_block bb, struct frv_io *first_io,\n+\t\t\t    rtx membar)\n+{\n+  struct frv_io this_io, next_io;\n+  edge succ;\n+  edge_iterator ei;\n+\n+  /* We need to keep the membar if there is an edge to the exit block.  */\n+  FOR_EACH_EDGE (succ, ei, bb->succs)\n+  /* for (succ = bb->succ; succ != 0; succ = succ->succ_next) */\n+    if (succ->dest == EXIT_BLOCK_PTR)\n+      return;\n+\n+  /* Work out the union of all successor blocks.  */\n+  ei = ei_start (bb->succs);\n+  ei_cond (ei, &succ);\n+  /* next_io = first_io[bb->succ->dest->index]; */\n+  next_io = first_io[succ->dest->index];\n+  ei = ei_start (bb->succs);\n+  if (ei_cond (ei, &succ))\n+    {\n+      for (ei_next (&ei); ei_cond (ei, &succ); ei_next (&ei))\n+\t/*for (succ = bb->succ->succ_next; succ != 0; succ = succ->succ_next)*/\n+\tfrv_io_union (&next_io, &first_io[succ->dest->index]);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  frv_extract_membar (&this_io, membar);\n+  if (frv_io_fixed_order_p (&this_io, &next_io))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \";; [Global] Removing membar %d since order of accesses\"\n+\t\t \" is guaranteed\\n\", INSN_UID (membar));\n+\n+      delete_insn (membar);\n+    }\n+}\n+\n+/* Remove redundant membars from the current function.  */\n+\n+static void\n+frv_optimize_membar (void)\n+{\n+  basic_block bb;\n+  struct frv_io *first_io;\n+  rtx *last_membar;\n+\n+  compute_bb_for_insn ();\n+  first_io = xcalloc (last_basic_block, sizeof (struct frv_io));\n+  last_membar = xcalloc (last_basic_block, sizeof (rtx));\n+\n+  FOR_EACH_BB (bb)\n+    frv_optimize_membar_local (bb, &first_io[bb->index],\n+\t\t\t       &last_membar[bb->index]);\n+\n+  FOR_EACH_BB (bb)\n+    if (last_membar[bb->index] != 0)\n+      frv_optimize_membar_global (bb, first_io, last_membar[bb->index]);\n+\n+  free (first_io);\n+  free (last_membar);\n+}\n+\f\n /* Used by frv_reorg to keep track of the current packet's address.  */\n static unsigned int frv_packet_address;\n \n@@ -7773,6 +8129,9 @@ frv_register_nop (rtx nop)\n static void\n frv_reorg (void)\n {\n+  if (optimize > 0 && TARGET_OPTIMIZE_MEMBAR && cfun->machine->has_membar_p)\n+    frv_optimize_membar ();\n+\n   frv_num_nops = 0;\n   frv_register_nop (gen_nop ());\n   if (TARGET_MEDIA)\n@@ -7953,33 +8312,33 @@ static struct builtin_description bdesc_voidacc[] =\n   { CODE_FOR_mdasaccs, \"__MDASACCS\", FRV_BUILTIN_MDASACCS, 0, 0 }\n };\n \n-/* Intrinsics that load a value and then issue a MEMBAR.\n-   The FLAGS field is the icode for the membar.  */\n+/* Intrinsics that load a value and then issue a MEMBAR.  The load is\n+   a normal move and the ICODE is for the membar.  */\n \n static struct builtin_description bdesc_loads[] =\n {\n-  { CODE_FOR_builtin_read_qi, \"__builtin_read8\", FRV_BUILTIN_READ8, 0,\n-    CODE_FOR_optional_membar_qi },\n-  { CODE_FOR_builtin_read_hi, \"__builtin_read16\", FRV_BUILTIN_READ16, 0,\n-    CODE_FOR_optional_membar_hi },\n-  { CODE_FOR_builtin_read_si, \"__builtin_read32\", FRV_BUILTIN_READ32, 0,\n-    CODE_FOR_optional_membar_si },\n-  { CODE_FOR_builtin_read_di, \"__builtin_read64\", FRV_BUILTIN_READ64, 0,\n-    CODE_FOR_optional_membar_di }\n+  { CODE_FOR_optional_membar_qi, \"__builtin_read8\",\n+    FRV_BUILTIN_READ8, 0, 0 },\n+  { CODE_FOR_optional_membar_hi, \"__builtin_read16\",\n+    FRV_BUILTIN_READ16, 0, 0 },\n+  { CODE_FOR_optional_membar_si, \"__builtin_read32\",\n+    FRV_BUILTIN_READ32, 0, 0 },\n+  { CODE_FOR_optional_membar_di, \"__builtin_read64\",\n+    FRV_BUILTIN_READ64, 0, 0 }\n };\n \n /* Likewise stores.  */\n \n static struct builtin_description bdesc_stores[] =\n {\n-  { CODE_FOR_builtin_write_qi, \"__builtin_write8\", FRV_BUILTIN_WRITE8, 0,\n-    CODE_FOR_optional_membar_qi },\n-  { CODE_FOR_builtin_write_hi, \"__builtin_write16\", FRV_BUILTIN_WRITE16, 0,\n-    CODE_FOR_optional_membar_hi },\n-  { CODE_FOR_builtin_write_si, \"__builtin_write32\", FRV_BUILTIN_WRITE32, 0,\n-    CODE_FOR_optional_membar_si },\n-  { CODE_FOR_builtin_write64, \"__builtin_write64\", FRV_BUILTIN_WRITE64, 0,\n-    CODE_FOR_optional_membar_di }\n+  { CODE_FOR_optional_membar_qi, \"__builtin_write8\",\n+    FRV_BUILTIN_WRITE8, 0, 0 },\n+  { CODE_FOR_optional_membar_hi, \"__builtin_write16\",\n+    FRV_BUILTIN_WRITE16, 0, 0 },\n+  { CODE_FOR_optional_membar_si, \"__builtin_write32\",\n+    FRV_BUILTIN_WRITE32, 0, 0 },\n+  { CODE_FOR_optional_membar_di, \"__builtin_write64\",\n+    FRV_BUILTIN_WRITE64, 0, 0 },\n };\n \n /* Initialize media builtins.  */\n@@ -8305,6 +8664,18 @@ frv_matching_accg_mode (enum machine_mode mode)\n     }\n }\n \n+/* Given that a __builtin_read or __builtin_write function is accessing\n+   address ADDRESS, return the value that should be used as operand 1\n+   of the membar.  */\n+\n+static rtx\n+frv_io_address_cookie (rtx address)\n+{\n+  return (GET_CODE (address) == CONST_INT\n+\t  ? GEN_INT (INTVAL (address) / 8 * 8)\n+\t  : const0_rtx);\n+}\n+\n /* Return the accumulator guard that should be paired with accumulator\n    register ACC.  The mode of the returned register is in the same\n    class as ACC, but is four times smaller.  */\n@@ -8670,36 +9041,38 @@ frv_expand_voidaccop_builtin (enum insn_code icode, tree arglist)\n   return NULL_RTX;\n }\n \n-/* Expand a __builtin_read* function.  ICODE is the instruction code for\n-   the load and MEMBAR_ICODE is the instruction code of the \"membar\".  */\n+/* Expand a __builtin_read* function.  ICODE is the instruction code for the\n+   membar and TARGET_MODE is the mode that the loaded value should have.  */\n \n static rtx\n-frv_expand_load_builtin (enum insn_code icode, enum insn_code membar_icode,\n-\t\t\t tree arglist, rtx target)\n+frv_expand_load_builtin (enum insn_code icode, enum machine_mode target_mode,\n+                         tree arglist, rtx target)\n {\n-  rtx op0 = frv_read_argument (& arglist);\n-\n-  target = frv_legitimize_target (icode, target);\n-  op0 = frv_volatile_memref (insn_data[membar_icode].operand[0].mode, op0);\n-  emit_insn (GEN_FCN (icode) (target, op0));\n-  emit_insn (GEN_FCN (membar_icode) (copy_rtx (op0)));\n+  rtx op0 = frv_read_argument (&arglist);\n+  rtx cookie = frv_io_address_cookie (op0);\n+\n+  if (target == 0 || !REG_P (target))\n+    target = gen_reg_rtx (target_mode);\n+  op0 = frv_volatile_memref (insn_data[icode].operand[0].mode, op0);\n+  convert_move (target, op0, 1);\n+  emit_insn (GEN_FCN (icode) (copy_rtx (op0), cookie, GEN_INT (FRV_IO_READ)));\n+  cfun->machine->has_membar_p = 1;\n   return target;\n }\n \n-/* Likewise __builtin_write* functions, with ICODE being the instruction\n-   code of the store.  */\n+/* Likewise __builtin_write* functions.  */\n \n static rtx\n-frv_expand_store_builtin (enum insn_code icode, enum insn_code membar_icode,\n-\t\t\t  tree arglist)\n+frv_expand_store_builtin (enum insn_code icode, tree arglist)\n {\n-  rtx op0 = frv_read_argument (& arglist);\n-  rtx op1 = frv_read_argument (& arglist);\n+  rtx op0 = frv_read_argument (&arglist);\n+  rtx op1 = frv_read_argument (&arglist);\n+  rtx cookie = frv_io_address_cookie (op0);\n \n-  op0 = frv_volatile_memref (insn_data[membar_icode].operand[0].mode, op0);\n-  op1 = frv_legitimize_argument (icode, 1, op1);\n-  emit_insn (GEN_FCN (icode) (op0, op1));\n-  emit_insn (GEN_FCN (membar_icode) (copy_rtx (op0)));\n+  op0 = frv_volatile_memref (insn_data[icode].operand[0].mode, op0);\n+  convert_move (op0, force_reg (insn_data[icode].operand[0].mode, op1), 1);\n+  emit_insn (GEN_FCN (icode) (copy_rtx (op0), cookie, GEN_INT (FRV_IO_WRITE)));\n+  cfun->machine->has_membar_p = 1;\n   return NULL_RTX;\n }\n \n@@ -9049,11 +9422,12 @@ frv_expand_builtin (tree exp,\n \n   for (i = 0, d = bdesc_loads; i < ARRAY_SIZE (bdesc_loads); i++, d++)\n     if (d->code == fcode)\n-      return frv_expand_load_builtin (d->icode, d->flag, arglist, target);\n+      return frv_expand_load_builtin (d->icode, TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\t      arglist, target);\n \n   for (i = 0, d = bdesc_stores; i < ARRAY_SIZE (bdesc_stores); i++, d++)\n     if (d->code == fcode)\n-      return frv_expand_store_builtin (d->icode, d->flag, arglist);\n+      return frv_expand_store_builtin (d->icode, arglist);\n \n   return 0;\n }"}, {"sha": "73ecb2a6216673fc48d63413f97a9b506ed2261e", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -1492,13 +1492,6 @@ typedef struct frv_stack {\n    address of other frames.  */\n #define RETURN_ADDR_RTX(COUNT, FRAMEADDR) frv_return_addr_rtx (COUNT, FRAMEADDR)\n \n-/* This function contains machine specific function data.  */\n-struct machine_function GTY(())\n-{\n-  /* True if we have created an rtx that relies on the stack frame.  */\n-  int frame_needed;\n-};\n-\n #define RETURN_POINTER_REGNUM LR_REGNO\n \n /* A C expression whose value is RTL representing the location of the incoming"}, {"sha": "d0f359277592914feb1a1284a6adfe68067c1212", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -41,9 +41,7 @@\n    (UNSPEC_EH_RETURN_EPILOGUE\t6)\n    (UNSPEC_GOT\t\t\t7)\n    (UNSPEC_LDD\t\t\t8)\n-   (UNSPEC_BUILTIN_LOAD\t\t9)\n-   (UNSPEC_BUILTIN_STORE\t10)\n-   (UNSPEC_OPTIONAL_MEMBAR\t11)\n+   (UNSPEC_OPTIONAL_MEMBAR\t9)\n \n    (UNSPEC_GETTLSOFF\t\t\t200)\n    (UNSPEC_TLS_LOAD_GOTTLSOFF12\t\t201)\n@@ -2168,41 +2166,17 @@\n     FAIL;\n }\")\n \f\n-;; The load part of a __builtin_read* function.\n-;; Use UNSPECs to distinguish these patterns from normal moves.\n-(define_insn \"builtin_read_<mode>\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:SI (unspec:IMODE\n-\t\t\t [(match_operand:IMODE 1 \"memory_operand\" \"m\")]\n-\t\t\t UNSPEC_BUILTIN_LOAD)))]\n-  \"\"\n-  \"ld<BREADsuffix>%I1%U1 %M1,%0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"gload\")])\n-\n-;; The store part of a __builtin_write* function.\n-(define_insn \"builtin_write_<mode>\"\n-  [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n-\t(unspec:IMODE [(match_operand:IMODE 1 \"reg_or_0_operand\" \"dO\")]\n-\t\t      UNSPEC_BUILTIN_STORE))]\n-  \"\"\n-  \"st<IMODEsuffix>%I0%U0 %z1, %M0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"gstore\")])\n-\n-;; This one has a different predicate for operand 1.\n-(define_insn \"builtin_write64\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"d\")]\n-\t\t   UNSPEC_BUILTIN_STORE))]\n-  \"\"\n-  \"std%I0%U0 %z1, %M0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"gstore\")])\n \n+;; The \"membar\" part of a __builtin_read* or __builtin_write* function.\n+;; Operand 0 is a volatile reference to the memory that the function reads\n+;; or writes.  Operand 1 is the address being accessed, or zero if the\n+;; address isn't a known constant.  Operand 2 describes the __builtin\n+;; function (either FRV_IO_READ or FRV_IO_WRITE).\n (define_insn \"optional_membar_<mode>\"\n   [(set (match_operand:IMODE 0 \"memory_operand\" \"=m\")\n-\t(unspec:IMODE [(const_int 0)] UNSPEC_OPTIONAL_MEMBAR))]\n+\t(unspec:IMODE [(match_operand 1 \"const_int_operand\" \"\")\n+\t\t       (match_operand 2 \"const_int_operand\" \"\")]\n+\t\t      UNSPEC_OPTIONAL_MEMBAR))]\n   \"\"\n   \"membar\"\n   [(set_attr \"length\" \"4\")])"}, {"sha": "7416dfa82d651939e37788b381558aab17781db0", "filename": "gcc/config/frv/frv.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fconfig%2Ffrv%2Ffrv.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.opt?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -157,6 +157,10 @@ mno-eflags\n Target RejectNegative\n Do not mark ABI switches in e_flags\n \n+moptimize-membar\n+Target Report Mask(OPTIMIZE_MEMBAR)\n+Remove redundant membars\n+\n mpack\n Target Report Mask(PACK)\n Pack VLIW instructions"}, {"sha": "d24e75b76512aa8efb7afd8a9ac6ae7f01555f68", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -482,6 +482,7 @@ Objective-C and Objective-C++ Dialects}.\n -mlinked-fp  -mlong-calls  -malign-labels @gol\n -mlibrary-pic  -macc-4  -macc-8 @gol\n -mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move @gol\n+-moptimize-membar -mno-optimize-membar @gol\n -mscc  -mno-scc  -mcond-exec  -mno-cond-exec @gol\n -mvliw-branch  -mno-vliw-branch @gol\n -mmulti-cond-exec  -mno-multi-cond-exec  -mnested-cond-exec @gol\n@@ -8526,6 +8527,18 @@ Disable nested conditional execution optimizations.\n This switch is mainly for debugging the compiler and will likely be removed\n in a future version.\n \n+@item -moptimize-membar\n+@opindex moptimize-membar\n+\n+This switch removes redundant @code{membar} instructions from the\n+compiler generated code.  It is enabled by default.\n+\n+@item -mno-optimize-membar\n+@opindex mno-optimize-membar\n+\n+This switch disables the automatic removal of redundant @code{membar}\n+instructions from the generated code.\n+\n @item -mtomcat-stats\n @opindex mtomcat-stats\n "}, {"sha": "362cc8468e0067e08bd11ff201e6c16edf163f92", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-read16.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read16.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned short z;\n-\n-void foo (void *x)\n-{\n-  z = __builtin_read16 (x);\n-}\n-\n-/* { dg-final { scan-assembler \"lduh\" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "7e988a4378f91b904d4ce277413eee9439e56daf", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-read32.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read32.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O\" } */\n-\n-unsigned long z;\n-\n-void foo (void *x)\n-{\n-  z = __builtin_read32 (x);\n-}\n-\n-/* { dg-final { scan-assembler \"ld \" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "1d5b6562a4aced50bbacdaec66b0662ecabb438a", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-read64.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read64.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned long long z;\n-\n-void foo (void *x)\n-{\n-  z = __builtin_read64 (x);\n-}\n-\n-/* { dg-final { scan-assembler \"ldd\" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "b53fb61797dbbb39745dd05a2a4b6c53c180d648", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-read8.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-read8.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned char z;\n-\n-void foo (void *x)\n-{\n-  z = __builtin_read8 (x);\n-}\n-\n-/* { dg-final { scan-assembler \"ldub\" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "f9f1cb517eeea5022f09d2611bef8ef2b3c546a6", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-write16.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write16.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned short *addr;\n-unsigned short datum;\n-\n-void foo ()\n-{\n-  __builtin_write16 (addr, datum);\n-}\n-\n-/* { dg-final { scan-assembler \"sth\" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "b97715313c7c7d4f36da8bc1c01ec9ee3a2c3300", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-write32.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write32.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned long *addr;\n-unsigned long datum;\n-\n-void foo ()\n-{\n-  __builtin_write32 (addr, datum);\n-}\n-\n-/* { dg-final { scan-assembler \"st \" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "eac50a266c7fdc8adbf1b73011e95ce44452f40c", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-write64.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write64.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned long long *addr;\n-unsigned long long datum;\n-\n-void foo ()\n-{\n-  __builtin_write64 (addr, datum);\n-}\n-\n-/* { dg-final { scan-assembler \"std \" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "56e4f3e41b5c9dcb2d51eaa24b9b98a4f0eb735b", "filename": "gcc/testsuite/gcc.target/frv/all-builtin-write8.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c504ea5ba6da768565dc25fd0455001cec7090/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-builtin-write8.c?ref=47c504ea5ba6da768565dc25fd0455001cec7090", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-\n-unsigned char *addr;\n-unsigned char datum;\n-\n-void foo ()\n-{\n-  __builtin_write8 (addr, datum);\n-}\n-\n-/* { dg-final { scan-assembler \"stb\" } } */\n-/* { dg-final { scan-assembler \"membar\" } } */"}, {"sha": "8496a58ed390f989535eeb72ac1d779bb0422595", "filename": "gcc/testsuite/gcc.target/frv/all-read-write-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-read-write-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c28a2564a0f81eb26b2eec0908190c2094dd1f/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-read-write-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Ffrv%2Fall-read-write-1.c?ref=38c28a2564a0f81eb26b2eec0908190c2094dd1f", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+extern void abort (void);\n+extern void exit (int);\n+\n+volatile unsigned long long x[2];\n+\n+int main ()\n+{\n+  volatile char *addr = (volatile char *) &x[0];\n+\n+  x[0] = ~0ULL;\n+  x[1] = ~0ULL;\n+  __builtin_write64 (addr, 0x1122334455667788ULL);\n+  __builtin_write32 (addr + 8, 0x12345678);\n+  __builtin_write16 (addr + 12, 0xaabb);\n+  __builtin_write8 (addr + 14, 0xcc);\n+\n+  if (x[0] != 0x1122334455667788ULL\n+      || x[1] != 0x12345678aabbccffULL\n+      || __builtin_read8 (addr) != 0x11\n+      || __builtin_read16 (addr + 2) != 0x3344\n+      || __builtin_read32 (addr + 4) != 0x55667788\n+      || __builtin_read64 (addr + 8) != 0x12345678aabbccffULL)\n+    abort ();\n+\n+  __builtin_write64 (addr, 0);\n+  __builtin_write32 (addr + 8, 0);\n+  __builtin_write16 (addr + 12, 0);\n+  __builtin_write8 (addr + 14, 0);\n+  if (x[0] != 0 || x[1] != 0xff)\n+    abort ();\n+\n+  exit (0);\n+}"}]}