{"sha": "96285749d88e8bf954b7e977d43e5cb947357ce5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYyODU3NDlkODhlOGJmOTU0YjdlOTc3ZDQzZTVjYjk0NzM1N2NlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-26T09:18:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-26T09:18:30Z"}, "message": "Move cexp simplifications to match.pd\n\nThis required reinstating support for captures in the result\nof a simplification.  That part (genmatch.c) is by Richard B.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n2015-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (dt_simplify::gen): Skip captures that are\n\tpart of the result.\n\t(parser::parse_expr): Allow captures in results too.\n\t* builtins.c (fold_builtin_cexp): Delete.\n\t(fold_builtin_1): Handle constant cexp arguments here.\n\t* match.pd: Fold cexp(x+yi) to exp(x) * cexpi(y).\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r229308", "tree": {"sha": "e79ab049985d601289566c278b52580210cc2ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e79ab049985d601289566c278b52580210cc2ad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96285749d88e8bf954b7e977d43e5cb947357ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96285749d88e8bf954b7e977d43e5cb947357ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96285749d88e8bf954b7e977d43e5cb947357ce5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96285749d88e8bf954b7e977d43e5cb947357ce5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9df01367f2f481d91b4927669cec5dbf80f489a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9df01367f2f481d91b4927669cec5dbf80f489a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9df01367f2f481d91b4927669cec5dbf80f489a1"}], "stats": {"total": 112, "additions": 40, "deletions": 72}, "files": [{"sha": "23d1481678843492d77aceb6c1944c81c64a77fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96285749d88e8bf954b7e977d43e5cb947357ce5", "patch": "@@ -1,3 +1,15 @@\n+2015-10-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+2015-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (dt_simplify::gen): Skip captures that are\n+\tpart of the result.\n+\t(parser::parse_expr): Allow captures in results too.\n+\t* builtins.c (fold_builtin_cexp): Delete.\n+\t(fold_builtin_1): Handle constant cexp arguments here.\n+\t* match.pd: Fold cexp(x+yi) to exp(x) * cexpi(y).\n+\n 2015-10-26  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \t* alloc-pool.h (base_pool_allocator::initialize, ::allocate): Remove"}, {"sha": "c70bbfd8bf4f3247ab73345ce65c84f62ace6ce3", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 69, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=96285749d88e8bf954b7e977d43e5cb947357ce5", "patch": "@@ -7460,74 +7460,6 @@ fold_builtin_sincos (location_t loc,\n \t\t\t build1 (REALPART_EXPR, type, call)));\n }\n \n-/* Fold function call to builtin cexp, cexpf, or cexpl.  Return\n-   NULL_TREE if no simplification can be made.  */\n-\n-static tree\n-fold_builtin_cexp (location_t loc, tree arg0, tree type)\n-{\n-  tree rtype;\n-  tree realp, imagp, ifn;\n-  tree res;\n-\n-  if (!validate_arg (arg0, COMPLEX_TYPE)\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) != REAL_TYPE)\n-    return NULL_TREE;\n-\n-  /* Calculate the result when the argument is a constant.  */\n-  if ((res = do_mpc_arg1 (arg0, type, mpc_exp)))\n-    return res;\n-\n-  rtype = TREE_TYPE (TREE_TYPE (arg0));\n-\n-  /* In case we can figure out the real part of arg0 and it is constant zero\n-     fold to cexpi.  */\n-  if (!targetm.libc_has_function (function_c99_math_complex))\n-    return NULL_TREE;\n-  ifn = mathfn_built_in (rtype, BUILT_IN_CEXPI);\n-  if (!ifn)\n-    return NULL_TREE;\n-\n-  if ((realp = fold_unary_loc (loc, REALPART_EXPR, rtype, arg0))\n-      && real_zerop (realp))\n-    {\n-      tree narg = fold_build1_loc (loc, IMAGPART_EXPR, rtype, arg0);\n-      return build_call_expr_loc (loc, ifn, 1, narg);\n-    }\n-\n-  /* In case we can easily decompose real and imaginary parts split cexp\n-     to exp (r) * cexpi (i).  */\n-  if (flag_unsafe_math_optimizations\n-      && realp)\n-    {\n-      tree rfn, rcall, icall;\n-\n-      rfn = mathfn_built_in (rtype, BUILT_IN_EXP);\n-      if (!rfn)\n-\treturn NULL_TREE;\n-\n-      imagp = fold_unary_loc (loc, IMAGPART_EXPR, rtype, arg0);\n-      if (!imagp)\n-\treturn NULL_TREE;\n-\n-      icall = build_call_expr_loc (loc, ifn, 1, imagp);\n-      icall = builtin_save_expr (icall);\n-      rcall = build_call_expr_loc (loc, rfn, 1, realp);\n-      rcall = builtin_save_expr (rcall);\n-      return fold_build2_loc (loc, COMPLEX_EXPR, type,\n-\t\t\t  fold_build2_loc (loc, MULT_EXPR, rtype,\n-\t\t\t\t       rcall,\n-\t\t\t \t       fold_build1_loc (loc, REALPART_EXPR,\n-\t\t\t\t\t\t    rtype, icall)),\n-\t\t\t  fold_build2_loc (loc, MULT_EXPR, rtype,\n-\t\t\t\t       rcall,\n-\t\t\t\t       fold_build1_loc (loc, IMAGPART_EXPR,\n-\t\t\t\t\t\t    rtype, icall)));\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Fold function call to builtin lround, lroundf or lroundl (or the\n    corresponding long long versions) and other rounding functions.  ARG\n    is the argument to the call.  Return NULL_TREE if no simplification\n@@ -9357,7 +9289,10 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n       break;\n \n     CASE_FLT_FN (BUILT_IN_CEXP):\n-      return fold_builtin_cexp (loc, arg0, type);\n+      if (validate_arg (arg0, COMPLEX_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (arg0))) == REAL_TYPE)\n+\treturn do_mpc_arg1 (arg0, type, mpc_exp);\n+      break;\n \n     CASE_FLT_FN (BUILT_IN_CEXPI):\n       if (validate_arg (arg0, REAL_TYPE))"}, {"sha": "b5a0fffa714e1df19b2e12ebaf0d40360cc7f89a", "filename": "gcc/genmatch.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=96285749d88e8bf954b7e977d43e5cb947357ce5", "patch": "@@ -3163,7 +3163,11 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t\t      s->capture_max + 1, indexes[0]->get_name (opname));\n \n       for (int i = 1; i <= s->capture_max; ++i)\n-\tfprintf (f, \", %s\", indexes[i]->get_name (opname));\n+\t{\n+\t  if (!indexes[i])\n+\t    break;\n+\t  fprintf (f, \", %s\", indexes[i]->get_name (opname));\n+\t}\n       fprintf (f, \" };\\n\");\n     }\n \n@@ -3831,7 +3835,7 @@ parser::parse_expr ()\n \n   if (token->type == CPP_ATSIGN\n       && !(token->flags & PREV_WHITE))\n-    op = parse_capture (e, !parsing_match_operand);\n+    op = parse_capture (e, false);\n   else if (force_capture)\n     {\n       unsigned num = capture_ids->elements ();"}, {"sha": "acf0e40291b96e0d577ec296f3442469fa7789b8", "filename": "gcc/match.pd", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96285749d88e8bf954b7e977d43e5cb947357ce5/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=96285749d88e8bf954b7e977d43e5cb947357ce5", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n (define_operator_list TAN BUILT_IN_TANF BUILT_IN_TAN BUILT_IN_TANL)\n (define_operator_list ATAN BUILT_IN_ATANF BUILT_IN_ATAN BUILT_IN_ATANL)\n (define_operator_list COSH BUILT_IN_COSHF BUILT_IN_COSH BUILT_IN_COSHL)\n+(define_operator_list CEXP BUILT_IN_CEXPF BUILT_IN_CEXP BUILT_IN_CEXPL)\n (define_operator_list CEXPI BUILT_IN_CEXPIF BUILT_IN_CEXPI BUILT_IN_CEXPIL)\n (define_operator_list CPROJ BUILT_IN_CPROJF BUILT_IN_CPROJ BUILT_IN_CPROJL)\n (define_operator_list CCOS BUILT_IN_CCOSF BUILT_IN_CCOS BUILT_IN_CCOSL)\n@@ -1562,6 +1563,11 @@ along with GCC; see the file COPYING3.  If not see\n  (mult @0 integer_minus_onep)\n  (negate @0))\n \n+/* True if we can easily extract the real and imaginary parts of a complex\n+   number.  */\n+(match compositional_complex\n+ (convert? (complex @0 @1)))\n+\n /* COMPLEX_EXPR and REALPART/IMAGPART_EXPR cancellations.  */\n (simplify\n  (complex (realpart @0) (imagpart @0))\n@@ -2584,7 +2590,18 @@ along with GCC; see the file COPYING3.  If not see\n  /* cabs(x+xi) -> fabs(x)*sqrt(2).  */\n  (simplify\n   (CABS (complex @0 @0))\n-  (mult (abs @0) { build_real_truncate (type, dconst_sqrt2 ()); })))\n+  (mult (abs @0) { build_real_truncate (type, dconst_sqrt2 ()); }))\n+\n+ /* cexp(x+yi) -> exp(x)*cexpi(y).  */\n+ (for cexps (CEXP)\n+      exps (EXP)\n+      cexpis (CEXPI)\n+  (simplify\n+   (cexps compositional_complex@0)\n+   (if (targetm.libc_has_function (function_c99_math_complex))\n+    (complex\n+     (mult (exps@1 (realpart @0)) (realpart (cexpis:type@2 (imagpart @0))))\n+     (mult @1 (imagpart @2)))))))\n \n (if (canonicalize_math_p ())\n  /* floor(x) -> trunc(x) if x is nonnegative.  */"}]}