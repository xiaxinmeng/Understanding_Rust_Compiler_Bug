{"sha": "03702748005fcb46f8712e7c281982fefd98c85d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3MDI3NDgwMDVmY2I0NmY4NzEyZTdjMjgxOTgyZmVmZDk4Yzg1ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-01T03:04:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-01T03:04:27Z"}, "message": "cp-tree.h (VF_NORMAL_VALUE): Remove.\n\n\t* cp-tree.h (VF_NORMAL_VALUE): Remove.\n\t* class.c (struct base_info): Remove vfield, vfields, and rtti.\n\t(set_primary_base): New function, split out from ...\n\t(finish_base_struct): ... here.  Rename to ...\n\t(determine_primary_base): ... this.  Simplify.\n\t(create_vtable_ptr): Tweak accordingly.\n\t(finish_struct_1): Simplify.\n\nFrom-SVN: r31154", "tree": {"sha": "f6808adfbdd33738606f5103c9b3ec2d14b4b8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6808adfbdd33738606f5103c9b3ec2d14b4b8f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03702748005fcb46f8712e7c281982fefd98c85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03702748005fcb46f8712e7c281982fefd98c85d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03702748005fcb46f8712e7c281982fefd98c85d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03702748005fcb46f8712e7c281982fefd98c85d/comments", "author": null, "committer": null, "parents": [{"sha": "700f19f09fdeb75c173cd31b38acee11f6f88356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/700f19f09fdeb75c173cd31b38acee11f6f88356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/700f19f09fdeb75c173cd31b38acee11f6f88356"}], "stats": {"total": 182, "additions": 60, "deletions": 122}, "files": [{"sha": "3fb56b09bd61b7782a46ae0d25cac60c82f07a03", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03702748005fcb46f8712e7c281982fefd98c85d", "patch": "@@ -1,5 +1,13 @@\n 1999-12-31  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (VF_NORMAL_VALUE): Remove.\n+\t* class.c (struct base_info): Remove vfield, vfields, and rtti.\n+\t(set_primary_base): New function, split out from ...\n+\t(finish_base_struct): ... here.  Rename to ...\n+\t(determine_primary_base): ... this.  Simplify.\n+\t(create_vtable_ptr): Tweak accordingly.\n+\t(finish_struct_1): Simplify.\n+\t\n \t* cp-tree.h (CLASSTYPE_VBASECLASSES): Update documentation.\n \t(CLASSTYPE_N_BASECLASSES): Likewise.\n \t(BINFO_FOR_VBASE): New macro."}, {"sha": "2de8bc6ef1abffb3c165eeef3519fc1341772db1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 52, "deletions": 119, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=03702748005fcb46f8712e7c281982fefd98c85d", "patch": "@@ -107,7 +107,7 @@ static void modify_one_vtable PROTO((tree, tree, tree));\n static void modify_all_vtables PROTO((tree, tree));\n static void modify_all_direct_vtables PROTO((tree, int, tree, tree));\n static void modify_all_indirect_vtables PROTO((tree, int, int, tree, tree));\n-static int finish_base_struct PROTO((tree, struct base_info *));\n+static void determine_primary_base PROTO((tree, struct base_info *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n static int field_decl_cmp PROTO ((const tree *, const tree *));\n@@ -137,6 +137,7 @@ static void create_vtable_ptr PROTO((tree, int *, int *, int *, tree *, tree *))\n static void layout_class_type PROTO((tree, int *, int *, int *, tree *, tree *));\n static void fixup_pending_inline PROTO((struct pending_inline *));\n static void fixup_inline_methods PROTO((tree));\n+static void set_primary_base PROTO((tree, int, int *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1490,9 +1491,6 @@ struct base_info\n {\n   int has_virtual;\n   int max_has_virtual;\n-  tree vfield;\n-  tree vfields;\n-  tree rtti;\n };\n \n /* Run through the base clases of T, updating\n@@ -1619,136 +1617,87 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n     }\n }\n \n-/* Record information about type T derived from its base classes.\n-   Store most of that information in T itself, and place the\n-   remaining information in the struct BASE_INFO.\n+/* Make the Ith baseclass of T its primary base.  */\n \n-   Propagate basetype offsets throughout the lattice.  Note that the\n-   lattice topped by T is really a pair: it's a DAG that gives the\n-   structure of the derivation hierarchy, and it's a list of the\n-   virtual baseclasses that appear anywhere in the DAG.  When a vbase\n-   type appears in the DAG, it's offset is 0, and it's children start\n-   their offsets from that point.  When a vbase type appears in the list,\n-   its offset is the offset it has in the hierarchy, and its children's\n-   offsets include that offset in theirs.\n+static void\n+set_primary_base (t, i, has_virtual_p)\n+     tree t;\n+     int i;\n+     int *has_virtual_p;\n+{\n+  tree basetype;\n+\n+  CLASSTYPE_VFIELD_PARENT (t) = i;\n+  basetype = BINFO_TYPE (CLASSTYPE_PRIMARY_BINFO (t));\n+  TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n+  TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n+  TYPE_VFIELD (t) = TYPE_VFIELD (basetype);\n+  CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n+  *has_virtual_p = CLASSTYPE_VSIZE (basetype);\n+}\n \n-   Returns the index of the first base class to have virtual functions,\n-   or -1 if no such base class.  */\n+/* Determine the primary class for T.  */\n \n-static int\n-finish_base_struct (t, b)\n+static void\n+determine_primary_base (t, b)\n      tree t;\n      struct base_info *b;\n {\n-  tree binfos = TYPE_BINFO_BASETYPES (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n-  int first_vfn_base_index = -1;\n   bzero ((char *) b, sizeof (struct base_info));\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_POLYMORPHIC_P (basetype))\n \t{\n-\t  /* Ensure that this is set from at least a virtual base\n-             class.  */\n-\t  if (b->rtti == NULL_TREE)\n-\t    b->rtti = CLASSTYPE_RTTI (basetype);\n+\t  /* Even a virtual baseclass can contain our RTTI\n+\t     information.  But, we prefer a non-virtual polymorphic\n+\t     baseclass.  */\n+\t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+\t    CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n \n-\t  /* Don't borrow virtuals from virtual baseclasses.  */\n+\t  /* A virtual baseclass can't be the primary base.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n-\t  if (first_vfn_base_index < 0)\n+\t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    {\n-\t      tree vfields;\n-\t      first_vfn_base_index = i;\n-\n-\t      /* Update these two, now that we know what vtable we are\n-\t\t going to extend.  This is so that we can add virtual\n-\t\t functions, and override them properly.  */\n-\t      TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n-\t      TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n-\t      b->has_virtual = CLASSTYPE_VSIZE (basetype);\n-\t      b->vfield = TYPE_VFIELD (basetype);\n-\t      b->vfields = copy_list (CLASSTYPE_VFIELDS (basetype));\n-\t      vfields = b->vfields;\n-\t      while (vfields)\n-\t\t{\n-\t\t  if (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t      || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields)))\n-\t\t    {\n-\t\t      tree value = VF_BASETYPE_VALUE (vfields);\n-\t\t      if (DECL_NAME (TYPE_VFIELD (value))\n-\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n-\t\t\tVF_NORMAL_VALUE (b->vfields) = basetype;\n-\t\t      else\n-\t\t\tVF_NORMAL_VALUE (b->vfields) = VF_NORMAL_VALUE (vfields);\n-\t\t    }\n-\t\t  vfields = TREE_CHAIN (vfields);\n-\t\t}\n-\t      TYPE_VFIELD (t) = b->vfield;\n+\t      set_primary_base (t, i, &b->has_virtual);\n+\t      CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t    }\n \t  else\n \t    {\n+\t      tree vfields;\n+\n \t      /* Only add unique vfields, and flatten them out as we go.  */\n-\t      tree vfields = CLASSTYPE_VFIELDS (basetype);\n-\t      while (vfields)\n-\t\t{\n-\t\t  if (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t      || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields)))\n-\t\t    {\n-\t\t      tree value = VF_BASETYPE_VALUE (vfields);\n-\t\t      b->vfields = tree_cons (base_binfo, value, b->vfields);\n-\t\t      if (DECL_NAME (TYPE_VFIELD (value))\n-\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n-\t\t\tVF_NORMAL_VALUE (b->vfields) = basetype;\n-\t\t      else\n-\t\t\tVF_NORMAL_VALUE (b->vfields) = VF_NORMAL_VALUE (vfields);\n-\t\t    }\n-\t\t  vfields = TREE_CHAIN (vfields);\n-\t\t}\n+\t      for (vfields = CLASSTYPE_VFIELDS (basetype);\n+\t\t   vfields;\n+\t\t   vfields = TREE_CHAIN (vfields))\n+\t\tif (VF_BINFO_VALUE (vfields) == NULL_TREE\n+\t\t    || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields)))\n+\t\t  CLASSTYPE_VFIELDS (t) \n+\t\t    = tree_cons (base_binfo, \n+\t\t\t\t VF_BASETYPE_VALUE (vfields),\n+\t\t\t\t CLASSTYPE_VFIELDS (t));\n \n \t      if (b->has_virtual == 0)\n-\t\t{\n-\t\t  first_vfn_base_index = i;\n-\n-\t\t  /* Update these two, now that we know what vtable we are\n-\t\t     going to extend.  This is so that we can add virtual\n-\t\t     functions, and override them properly.  */\n-\t\t  TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n-\t\t  TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n-\t\t  b->has_virtual = CLASSTYPE_VSIZE (basetype);\n-\t\t  b->vfield = TYPE_VFIELD (basetype);\n-\t\t  TYPE_VFIELD (t) = b->vfield;\n-\t\t  /* When we install the first one, set the VF_NORMAL_VALUE\n-\t\t     to be the current class, as this it is the most derived\n-\t\t     class.  Hopefully, this is not set to something else\n-\t\t     later.  (mrs) */\n-\t\t  vfields = b->vfields;\n-\t\t  while (vfields)\n-\t\t    {\n-\t\t      if (DECL_NAME (TYPE_VFIELD (t))\n-\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n-\t\t\t{\n-\t\t\t  VF_NORMAL_VALUE (vfields) = t;\n-\t\t\t  /* There should only be one of them!  And it should\n-\t\t\t     always be found, if we get into here.  (mrs)  */\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      vfields = TREE_CHAIN (vfields);\n-\t\t    }\n-\t\t}\n+\t\tset_primary_base (t, i, &b->has_virtual);\n \t    }\n \t}\n     }\n \n+  if (!TYPE_VFIELD (t))\n+    CLASSTYPE_VFIELD_PARENT (t) = -1;\n+\n   {\n     tree vfields;\n     /* Find the base class with the largest number of virtual functions.  */\n-    for (vfields = b->vfields; vfields; vfields = TREE_CHAIN (vfields))\n+    for (vfields = CLASSTYPE_VFIELDS (t); \n+\t vfields; \n+\t vfields = TREE_CHAIN (vfields))\n       {\n \tif (CLASSTYPE_VSIZE (VF_BASETYPE_VALUE (vfields)) > b->max_has_virtual)\n \t  b->max_has_virtual = CLASSTYPE_VSIZE (VF_BASETYPE_VALUE (vfields));\n@@ -1757,16 +1706,6 @@ finish_base_struct (t, b)\n \t  b->max_has_virtual = CLASSTYPE_VSIZE (VF_DERIVED_VALUE (vfields));\n       }\n   }\n-\n-  if (b->vfield == 0)\n-    /* If all virtual functions come only from virtual baseclasses.  */\n-    return -1;\n-\n-  /* Update the rtti base if we have a non-virtual base class version\n-     of it.  */\n-  b->rtti = CLASSTYPE_RTTI (BINFO_TYPE (TREE_VEC_ELT (binfos, first_vfn_base_index)));\n-\n-  return first_vfn_base_index;\n }\n \f\n /* Set memoizing fields and bits of T (and its variants) for later use.\n@@ -4084,12 +4023,9 @@ create_vtable_ptr (t, empty_p, has_virtual_p, max_has_virtual_p,\n       struct base_info base_info;\n \n       /* Remember where we got our vfield from.  */\n-      CLASSTYPE_VFIELD_PARENT (t) = finish_base_struct (t, &base_info);\n+      determine_primary_base (t, &base_info);\n       *has_virtual_p = base_info.has_virtual;\n       *max_has_virtual_p = base_info.max_has_virtual;\n-      TYPE_VFIELD (t) = base_info.vfield;\n-      CLASSTYPE_VFIELDS (t) = base_info.vfields;\n-      CLASSTYPE_RTTI (t) = base_info.rtti;\n     }\n \n   /* Loop over the virtual functions, adding them to our various\n@@ -4330,7 +4266,6 @@ finish_struct_1 (t)\n   tree pending_hard_virtuals = NULL_TREE;\n   int n_fields = 0;\n   tree vfield;\n-  int n_baseclasses;\n   int empty = 1;\n \n   if (TYPE_SIZE (t))\n@@ -4350,15 +4285,13 @@ finish_struct_1 (t)\n \n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n-\n   CLASSTYPE_VFIELD_PARENT (t) = -1;\n   has_virtual = 0;\n   max_has_virtual = 0;\n   CLASSTYPE_RTTI (t) = NULL_TREE;\n-  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n   /* Do end-of-class semantic processing: checking the validity of the\n-     bases and members and adding implicitly generated methods.  */\n+     bases and members and add implicitly generated methods.  */\n   check_bases_and_members (t, &empty);\n \n   /* Layout the class itself.  */"}, {"sha": "9f7f68515babe807fa8466225f1f77d36ec07496", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03702748005fcb46f8712e7c281982fefd98c85d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=03702748005fcb46f8712e7c281982fefd98c85d", "patch": "@@ -1576,9 +1576,6 @@ struct lang_type\n \n /* Get the value of the top-most type dominating the non-`normal' vfields.  */\n #define VF_DERIVED_VALUE(NODE) (VF_BINFO_VALUE (NODE) ? BINFO_TYPE (VF_BINFO_VALUE (NODE)) : NULL_TREE)\n-\n-/* Get the value of the top-most type that's `normal' for the vfield.  */\n-#define VF_NORMAL_VALUE(NODE) TREE_TYPE (NODE)\n \f\n /* Nonzero for TREE_LIST node means that this list of things\n    is a list of parameters, as opposed to a list of expressions.  */"}]}