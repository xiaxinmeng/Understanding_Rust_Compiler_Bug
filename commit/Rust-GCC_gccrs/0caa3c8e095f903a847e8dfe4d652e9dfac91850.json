{"sha": "0caa3c8e095f903a847e8dfe4d652e9dfac91850", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNhYTNjOGUwOTVmOTAzYTg0N2U4ZGZlNGQ2NTJlOWRmYWM5MTg1MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-11-14T09:47:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-11-14T09:47:13Z"}, "message": "c-typeck.c (c_sizeof): Fold result to c_size_type_node.\n\n        * c-typeck.c (c_sizeof): Fold result to c_size_type_node.\n        (c_sizeof_nowarn, c_alignof, c_alignof_expr): Likewise.\n\nFrom-SVN: r37447", "tree": {"sha": "f759273c6d8e8f420c4cd169ddd35e54935ff5a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f759273c6d8e8f420c4cd169ddd35e54935ff5a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0caa3c8e095f903a847e8dfe4d652e9dfac91850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0caa3c8e095f903a847e8dfe4d652e9dfac91850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0caa3c8e095f903a847e8dfe4d652e9dfac91850", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0caa3c8e095f903a847e8dfe4d652e9dfac91850/comments", "author": null, "committer": null, "parents": [{"sha": "8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8422942cb6c2076b05d8a248f1f0c5b6ffe67321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8422942cb6c2076b05d8a248f1f0c5b6ffe67321"}], "stats": {"total": 97, "additions": 60, "deletions": 37}, "files": [{"sha": "f82e04a726b8c8b5fe3305b6cc3fffa03e26a688", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caa3c8e095f903a847e8dfe4d652e9dfac91850/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caa3c8e095f903a847e8dfe4d652e9dfac91850/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0caa3c8e095f903a847e8dfe4d652e9dfac91850", "patch": "@@ -1,3 +1,8 @@\n+2000-11-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-typeck.c (c_sizeof): Fold result to c_size_type_node.\n+\t(c_sizeof_nowarn, c_alignof, c_alignof_expr): Likewise.\n+\n 2000-11-13  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* loop.c (basic_induction_var): Revert accidental checkin."}, {"sha": "09f4089b5b361b4db99da6d0ed7e8a05430ee87f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0caa3c8e095f903a847e8dfe4d652e9dfac91850/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0caa3c8e095f903a847e8dfe4d652e9dfac91850/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=0caa3c8e095f903a847e8dfe4d652e9dfac91850", "patch": "@@ -697,51 +697,62 @@ c_sizeof (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n+  tree size;\n \n   if (code == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"sizeof applied to a function type\");\n-      return size_one_node;\n+      size = size_one_node;\n     }\n-  if (code == VOID_TYPE)\n+  else if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n \tpedwarn (\"sizeof applied to a void type\");\n-      return size_one_node;\n+      size = size_one_node;\n     }\n-\n-  if (code == ERROR_MARK)\n-    return size_one_node;\n-\n-  if (!COMPLETE_TYPE_P (type))\n+  else if (code == ERROR_MARK)\n+    size = size_one_node;\n+  else if (!COMPLETE_TYPE_P (type))\n     {\n       error (\"sizeof applied to an incomplete type\");\n-      return size_zero_node;\n+      size = size_zero_node;\n     }\n-\n-  /* Convert in case a char is more than one unit.  */\n-  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t     size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t       / BITS_PER_UNIT));\n+  else\n+    /* Convert in case a char is more than one unit.  */\n+    size = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t       size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t         / BITS_PER_UNIT));\n+\n+  /* SIZE will have an integer type with TYPE_IS_SIZETYPE set.\n+     TYPE_IS_SIZETYPE means that certain things (like overflow) will\n+     never happen.  However, this node should really have type\n+     `size_t', which is just a typedef for an ordinary integer type.  */\n+  return fold (build1 (NOP_EXPR, c_size_type_node, size));\n }\n \n tree\n c_sizeof_nowarn (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n+  tree size;\n \n   if (code == FUNCTION_TYPE || code == VOID_TYPE || code == ERROR_MARK)\n-    return size_one_node;\n-\n-  if (!COMPLETE_TYPE_P (type))\n-    return size_zero_node;\n-\n-  /* Convert in case a char is more than one unit.  */\n-  return size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n-\t\t     size_int (TYPE_PRECISION (char_type_node)\n-\t\t\t       / BITS_PER_UNIT));\n+    size = size_one_node;\n+  else if (!COMPLETE_TYPE_P (type))\n+    size = size_zero_node;\n+  else\n+    /* Convert in case a char is more than one unit.  */\n+    size = size_binop (CEIL_DIV_EXPR, TYPE_SIZE_UNIT (type),\n+\t\t       size_int (TYPE_PRECISION (char_type_node)\n+\t\t\t         / BITS_PER_UNIT));\n+\n+  /* SIZE will have an integer type with TYPE_IS_SIZETYPE set.\n+     TYPE_IS_SIZETYPE means that certain things (like overflow) will\n+     never happen.  However, this node should really have type\n+     `size_t', which is just a typedef for an ordinary integer type.  */\n+  return fold (build1 (NOP_EXPR, c_size_type_node, size));\n }\n \n /* Compute the size to increment a pointer by.  */\n@@ -775,20 +786,23 @@ c_alignof (type)\n      tree type;\n {\n   enum tree_code code = TREE_CODE (type);\n+  tree t;\n \n   if (code == FUNCTION_TYPE)\n-    return size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n-\n-  if (code == VOID_TYPE || code == ERROR_MARK)\n-    return size_one_node;\n-\n-  if (!COMPLETE_TYPE_P (type))\n+    t = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n+  else if (code == VOID_TYPE || code == ERROR_MARK)\n+    t = size_one_node;\n+  else if (code == ERROR_MARK)\n+    t = size_one_node;\n+  else if (!COMPLETE_TYPE_P (type))\n     {\n       error (\"__alignof__ applied to an incomplete type\");\n-      return size_zero_node;\n+      t = size_zero_node;\n     }\n+  else\n+    t = size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n \n-  return size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n+  return fold (build1 (NOP_EXPR, c_size_type_node, t));\n }\n \f\n /* Implement the __alignof keyword: Return the minimum required\n@@ -800,20 +814,22 @@ tree\n c_alignof_expr (expr)\n      tree expr;\n {\n+  tree t;\n+\n   if (TREE_CODE (expr) == VAR_DECL)\n-    return size_int (DECL_ALIGN (expr) / BITS_PER_UNIT);\n+    t = size_int (DECL_ALIGN (expr) / BITS_PER_UNIT);\n  \n-  if (TREE_CODE (expr) == COMPONENT_REF\n-      && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n+  else if (TREE_CODE (expr) == COMPONENT_REF\n+\t   && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n       error (\"`__alignof' applied to a bit-field\");\n-      return size_one_node;\n+      t = size_one_node;\n     }\n   else if (TREE_CODE (expr) == COMPONENT_REF\n       && TREE_CODE (TREE_OPERAND (expr, 1)) == FIELD_DECL)\n-    return size_int (DECL_ALIGN (TREE_OPERAND (expr, 1)) / BITS_PER_UNIT);\n+    t = size_int (DECL_ALIGN (TREE_OPERAND (expr, 1)) / BITS_PER_UNIT);\n  \n-  if (TREE_CODE (expr) == INDIRECT_REF)\n+  else if (TREE_CODE (expr) == INDIRECT_REF)\n     {\n       tree t = TREE_OPERAND (expr, 0);\n       tree best = t;\n@@ -833,6 +849,8 @@ c_alignof_expr (expr)\n     }\n   else\n     return c_alignof (TREE_TYPE (expr));\n+\n+  return fold (build1 (NOP_EXPR, c_size_type_node, t));\n }\n \n /* Return either DECL or its known constant value (if it has one).  */"}]}