{"sha": "1bf93c14836cacc2cc71aef99f8960b3ff99377a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmOTNjMTQ4MzZjYWNjMmNjNzFhZWY5OWY4OTYwYjNmZjk5Mzc3YQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-06-17T17:12:57Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-17T17:12:57Z"}, "message": "sh.h (ROUND_TYPE_ALIGN, [...]): Complex modes are aligned like integral modes.\n\n\t* sh.h (ROUND_TYPE_ALIGN, LOCAL_ALIGNMENT): Complex modes\n\tare aligned like integral modes.\n\t(SH5_WOULD_BE_PARTIAL_NREGS): Also test for CDImode and DCmode.\n\n\t* sh.h (EXTRA_CONSTRAINT_Csy): Allow PIC_DIRECT_ADDR_P.\n\t(LEGITIMATE_PIC_OPERAND_P): Allow LABEL_REF.\n\t* sh.md (*pt): Remove.\n\n\t* sh.h (REG_ALLOC_ORDER): Avoid squandering call-saved registers.\n\n\t* sh.md (return_media_rte): New pattern.\n\t(return_media): Use it.\n\nFrom-SVN: r68100", "tree": {"sha": "6c7cfcb33b09c1adb20ff78a96c04546c590c91d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c7cfcb33b09c1adb20ff78a96c04546c590c91d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bf93c14836cacc2cc71aef99f8960b3ff99377a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf93c14836cacc2cc71aef99f8960b3ff99377a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf93c14836cacc2cc71aef99f8960b3ff99377a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf93c14836cacc2cc71aef99f8960b3ff99377a/comments", "author": null, "committer": null, "parents": [{"sha": "71c6b99414f2fab2cb91b96444d0b2ae8bab45be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c6b99414f2fab2cb91b96444d0b2ae8bab45be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c6b99414f2fab2cb91b96444d0b2ae8bab45be"}], "stats": {"total": 112, "additions": 77, "deletions": 35}, "files": [{"sha": "fe1f9bd8faecc813dfe99c0a9ee992450e85e6e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bf93c14836cacc2cc71aef99f8960b3ff99377a", "patch": "@@ -1,3 +1,18 @@\n+2003-06-17  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.h (ROUND_TYPE_ALIGN, LOCAL_ALIGNMENT): Complex modes\n+\tare aligned like integral modes.\n+\t(SH5_WOULD_BE_PARTIAL_NREGS): Also test for CDImode and DCmode.\n+\n+\t* sh.h (EXTRA_CONSTRAINT_Csy): Allow PIC_DIRECT_ADDR_P.\n+\t(LEGITIMATE_PIC_OPERAND_P): Allow LABEL_REF.\n+\t* sh.md (*pt): Remove.\n+\n+\t* sh.h (REG_ALLOC_ORDER): Avoid squandering call-saved registers.\n+\n+\t* sh.md (return_media_rte): New pattern.\n+\t(return_media): Use it.\n+\n 2003-06-17  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/contrib.texi: Replace Hitachi with Renesas."}, {"sha": "d83996fad0be6063d41e45c14feeffe8b20ffb6e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=1bf93c14836cacc2cc71aef99f8960b3ff99377a", "patch": "@@ -619,6 +619,23 @@ do {\t\t\t\t\t\t\t\t\t\\\n     && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n     ? FASTEST_ALIGNMENT : (ALIGN))\n \n+/* get_mode_alignment assumes complex values are always held in multiple\n+   registers, but that is not the case on the SH; CQImode and CHImode are\n+   held in a single integer register.  SH5 also holds CSImode and SCmode\n+   values in integer regsters.  Thus the alignment needs to be bumped up\n+   to match the size of the mode.  */\n+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED) \\\n+  (MAX ((GET_MODE_CLASS (TYPE_MODE (STRUCT)) == MODE_COMPLEX_INT \\\n+\t || GET_MODE_CLASS (TYPE_MODE (STRUCT)) == MODE_COMPLEX_FLOAT) \\\n+\t? MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (STRUCT))) \\\n+\t: (COMPUTED), \\\n+\t(SPECIFIED)))\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n+  ((GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_INT \\\n+    || GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_FLOAT) \\\n+   ? MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (TYPE))) \\\n+   : ALIGN)\n+\n /* Make arrays of chars word-aligned for the same reasons.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n   (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n@@ -1264,26 +1281,35 @@ extern int regno_reg_class[FIRST_PSEUDO_REGISTER];\n    and GENERAL_FP_REGS the alternate class.  Since FP0 is likely to be\n    spilled or used otherwise, we better have the FP_REGS allocated first.  */\n #define REG_ALLOC_ORDER \\\n-  { 65, 66, 67, 68, 69, 70, 71, 64, \\\n-    72, 73, 74, 75, 76, 77, 78, 79, \\\n-   136,137,138,139,140,141,142,143, \\\n-    80, 81, 82, 83, 84, 85, 86, 87, \\\n-    88, 89, 90, 91, 92, 93, 94, 95, \\\n-    96, 97, 98, 99,100,101,102,103, \\\n+  {/* Caller-saved FPRs */ \\\n+    65, 66, 67, 68, 69, 70, 71, 64, \\\n+    72, 73, 74, 75, 80, 81, 82, 83, \\\n+    84, 85, 86, 87, 88, 89, 90, 91, \\\n+    92, 93, 94, 95, 96, 97, 98, 99, \\\n+   /* Callee-saved FPRs */ \\\n+    76, 77, 78, 79,100,101,102,103, \\\n    104,105,106,107,108,109,110,111, \\\n    112,113,114,115,116,117,118,119, \\\n    120,121,122,123,124,125,126,127, \\\n-   151,  1,  2,  3,  7,  6,  5,  4, \\\n-     0,  8,  9, 10, 11, 12, 13, 14, \\\n-    16, 17, 18, 19, 20, 21, 22, 23, \\\n-    24, 25, 26, 27, 28, 29, 30, 31, \\\n-    32, 33, 34, 35, 36, 37, 38, 39, \\\n-    40, 41, 42, 43, 44, 45, 46, 47, \\\n-    48, 49, 50, 51, 52, 53, 54, 55, \\\n-    56, 57, 58, 59, 60, 61, 62, 63, \\\n-   150, 15,145,146,147,144,148,149, \\\n+   136,137,138,139,140,141,142,143, \\\n+   /* FPSCR */ 151, \\\n+   /* Caller-saved GPRs (except 8/9 on SH1-4) */ \\\n+     1,  2,  3,  7,  6,  5,  4,  0, \\\n+     8,  9, 17, 19, 20, 21, 22, 23, \\\n+    36, 37, 38, 39, 40, 41, 42, 43, \\\n+    60, 61, 62, \\\n+   /* SH1-4 callee-saved saved GPRs / SH5 partially-saved GPRs */ \\\n+    10, 11, 12, 13, 14, 18, \\\n+    /* SH5 callee-saved GPRs */ \\\n+    28, 29, 30, 31, 32, 33, 34, 35, \\\n+    44, 45, 46, 47, 48, 49, 50, 51, \\\n+    52, 53, 54, 55, 56, 57, 58, 59, \\\n+   /* FPUL */ 150, \\\n+   /* SH5 branch target registers */ \\\n    128,129,130,131,132,133,134,135, \\\n-   152 }\n+   /* Fixed registers */ \\\n+    15, 16, 24, 25, 26, 27, 63,144, \\\n+   145,146,147,148,149,152 }\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  (TARGET_SHMEDIA ? GENERAL_REGS : R0_REGS)\n@@ -2158,7 +2184,9 @@ do {\t\t\t\t\t\t\t\\\n    : 0)\n \n #define SH5_WOULD_BE_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  (TARGET_SH5 && ((MODE) == BLKmode || (MODE) == TImode)\t\\\n+  (TARGET_SH5\t\t\t\t\t\t\t\\\n+   && ((MODE) == BLKmode || (MODE) == TImode || (MODE) == CDImode \\\n+       || (MODE) == DCmode) \\\n    && ((CUM).arg_count[(int) SH_ARG_INT]\t\t\t\\\n        + (int_size_in_bytes (TYPE) + 7) / 8) > NPARM_REGS (SImode))\n \n@@ -2462,7 +2490,7 @@ while (0)\n \n /* The `Csy' constraint is a label or a symbol.  */\n #define EXTRA_CONSTRAINT_Csy(OP) \\\n-  (NON_PIC_REFERENCE_P (OP))\n+  (NON_PIC_REFERENCE_P (OP) || PIC_DIRECT_ADDR_P (OP))\n \n /* A zero in any shape or form.  */\n #define EXTRA_CONSTRAINT_Z(OP) \\\n@@ -2889,10 +2917,11 @@ while (0)\n /* We can't directly access anything that contains a symbol,\n    nor can we indirect via the constant pool.  */\n #define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n-\t(! nonpic_symbol_mentioned_p (X)\t\t\t\\\n-\t && (GET_CODE (X) != SYMBOL_REF\t\t\t\t\\\n-\t     || ! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n-\t     || ! nonpic_symbol_mentioned_p (get_pool_constant (X))))\n+\t((! nonpic_symbol_mentioned_p (X)\t\t\t\\\n+\t  && (GET_CODE (X) != SYMBOL_REF\t\t\t\\\n+\t      || ! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n+\t      || ! nonpic_symbol_mentioned_p (get_pool_constant (X)))) \\\n+\t || (TARGET_SHMEDIA && GET_CODE (X) == LABEL_REF))\n \n #define SYMBOLIC_CONST_P(X)\t\\\n ((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF)\t\\"}, {"sha": "15be47060d7b926541dd6cbd23e3911e9ff06ce6", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf93c14836cacc2cc71aef99f8960b3ff99377a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=1bf93c14836cacc2cc71aef99f8960b3ff99377a", "patch": "@@ -6637,19 +6637,6 @@\n }\n \")\n \n-;; When generating PIC, we must match label_refs especially, because\n-;; they do not satisfy LEGITIMATE_PIC_OPERAND_P(), and we don't want\n-;; them to do, because they can't be loaded directly into\n-;; non-branch-target registers.\n-(define_insn \"*pt\"\n-  [(set (match_operand:DI 0 \"target_reg_operand\" \"=b\")\n-\t(match_operand:DI 1 \"\" \"Csy\"))]\n-  \"TARGET_SHMEDIA && flag_pic\n-   && EXTRA_CONSTRAINT_Csy (operands[1])\"\n-  \"pt\t%1, %0\"\n-  [(set_attr \"type\" \"pt_media\")\n-   (set_attr \"length\" \"*\")])\n-\n (define_insn \"*ptb\"\n   [(set (match_operand:DI 0 \"target_reg_operand\" \"=b\")\n \t(const:DI (unspec:DI [(match_operand:DI 1 \"\" \"Csy\")]\n@@ -7237,6 +7224,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"blink\t%0, r63\"\n   [(set_attr \"type\" \"jump_media\")])\n \n+(define_insn \"return_media_rte\"\n+  [(return)]\n+  \"TARGET_SHMEDIA && reload_completed && current_function_interrupt\"\n+  \"rte\"\n+  [(set_attr \"type\" \"jump_media\")])\n+\n (define_expand \"return_media\"\n   [(return)]\n   \"TARGET_SHMEDIA && reload_completed\"\n@@ -7245,6 +7238,11 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   int tr_regno = sh_media_register_for_return ();\n   rtx tr;\n \n+  if (current_function_interrupt)\n+    {\n+      emit_jump_insn (gen_return_media_rte ());\n+      DONE;\n+    }\n   if (tr_regno < 0)\n     {\n       rtx r18 = gen_rtx_REG (DImode, PR_MEDIA_REG);"}]}