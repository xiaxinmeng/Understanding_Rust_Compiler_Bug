{"sha": "cf16f980e5278c146f04587ea2a378fab950d7b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxNmY5ODBlNTI3OGMxNDZmMDQ1ODdlYTJhMzc4ZmFiOTUwZDdiMw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2019-11-07T10:39:39Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2019-11-07T10:39:39Z"}, "message": "[arm][1/X] Add initial support for saturation intrinsics\n\nThis patch adds the plumbing for and an implementation of the saturation\nintrinsics from ACLE, in particular the __ssat, __usat intrinsics.\nThese intrinsics set the Q sticky bit in APSR if an overflow occurred.\nACLE allows the user to read that bit (within the same function, it's not\ndefined across function boundaries) using the __saturation_occurred\nintrinsic\nand reset it using __set_saturation_occurred.\nThus, if the user cares about the Q bit they would be using a flow such as:\n\n__set_saturation_occurred (0); // reset the Q bit\n...\n__ssat (...) // Do some calculations involving __ssat\n...\nif (__saturation_occurred ()) // if Q bit set handle overflow\n   ...\n\nFor the implementation this has a few implications:\n* We must track the Q-setting side-effects of these instructions to make\nsure\nsaturation reading/writing intrinsics are ordered properly.\nThis is done by introducing a new \"apsrq\" register (and associated\nAPSRQ_REGNUM) in a similar way to the \"fake\"\" cc register.\n\n* The RTL patterns coming out of these intrinsics can have two forms:\none where they set the APSRQ_REGNUM and one where they don't.\nWhich one is used depends on whether the function cares about reading the Q\nflag. This is detected using the TARGET_CHECK_BUILTIN_CALL hook on the\n__saturation_occurred, __set_saturation_occurred occurrences.\nIf no Q-flag read is present in the function we'll use the simpler\nnon-Q-setting form to allow for more aggressive scheduling and such.\nIf a Q-bit read is present then the Q-setting form is emitted.\nTo avoid adding two patterns for each intrinsic to the MD file we make\nuse of define_subst to auto-generate the Q-setting forms\n\n* Some existing patterns already produce instructions that may clobber the\nQ bit, but they don't model it (as we didn't care about that bit up till\nnow).\nSince these patterns can be generated from straight-line C code they can\naffect\nthe Q-bit reads from intrinsics. Therefore they have to be disabled when\na Q-bit read is present.  These are mostly patterns in arm-fixed.md that are\nnot very common anyway, but there are also a couple of widening\nmultiply-accumulate patterns in arm.md that can set the Q-bit during\naccumulation.\n\nThere are more Q-setting intrinsics in ACLE, but these will be\nimplemented in\na more mechanical fashion once the infrastructure in this patch goes in.\n\n\t* config/arm/aout.h (REGISTER_NAMES): Add apsrq.\n\t* config/arm/arm.md (APSRQ_REGNUM): Define.\n\t(add_setq): New define_subst.\n\t(add_clobber_q_name): New define_subst_attr.\n\t(add_clobber_q_pred): Likewise.\n\t(maddhisi4): Change to define_expand.  Split into mult and add if\n\tARM_Q_BIT_READ.\n\t(arm_maddhisi4): New define_insn.\n\t(*maddhisi4tb): Disable for ARM_Q_BIT_READ.\n\t(*maddhisi4tt): Likewise.\n\t(arm_ssat): New define_expand.\n\t(arm_usat): Likewise.\n\t(arm_get_apsr): New define_insn.\n\t(arm_set_apsr): Likewise.\n\t(arm_saturation_occurred): New define_expand.\n\t(arm_set_saturation): Likewise.\n\t(*satsi_<SAT:code>): Rename to...\n\t(satsi_<SAT:code><add_clobber_q_name>): ... This.\n\t(*satsi_<SAT:code>_shift): Disable for ARM_Q_BIT_READ.\n\t* config/arm/arm.h (FIXED_REGISTERS): Mark apsrq as fixed.\n\t(CALL_USED_REGISTERS): Mark apsrq.\n\t(FIRST_PSEUDO_REGISTER): Update value.\n\t(REG_ALLOC_ORDER): Add APSRQ_REGNUM.\n\t(machine_function): Add q_bit_access.\n\t(ARM_Q_BIT_READ): Define.\n\t* config/arm/arm.c (TARGET_CHECK_BUILTIN_CALL): Define.\n\t(arm_conditional_register_usage): Clear APSRQ_REGNUM from\n\toperand_reg_set.\n\t(arm_q_bit_access): Define.\n\t* config/arm/arm-builtins.c: Include stringpool.h.\n\t(arm_sat_binop_imm_qualifiers,\n\tarm_unsigned_sat_binop_unsigned_imm_qualifiers,\n\tarm_sat_occurred_qualifiers, arm_set_sat_qualifiers): Define.\n\t(SAT_BINOP_UNSIGNED_IMM_QUALIFIERS,\n\tUNSIGNED_SAT_BINOP_UNSIGNED_IMM_QUALIFIERS, SAT_OCCURRED_QUALIFIERS,\n\tSET_SAT_QUALIFIERS): Likewise.\n\t(arm_builtins): Define ARM_BUILTIN_SAT_IMM_CHECK.\n\t(arm_init_acle_builtins): Initialize __builtin_sat_imm_check.\n\tHandle 0 argument expander.\n\t(arm_expand_acle_builtin): Handle ARM_BUILTIN_SAT_IMM_CHECK.\n\t(arm_check_builtin_call): Define.\n\t* config/arm/arm.md (ssmulsa3, usmulusa3, usmuluha3,\n\tarm_ssatsihi_shift, arm_usatsihi): Disable when ARM_Q_BIT_READ.\n\t* config/arm/arm-protos.h (arm_check_builtin_call): Declare prototype.\n\t(arm_q_bit_access): Likewise.\n\t* config/arm/arm_acle.h (__ssat, __usat, __ignore_saturation,\n\t__saturation_occurred, __set_saturation_occurred): Define.\n\t* config/arm/arm_acle_builtins.def: Define builtins for ssat, usat,\n\tsaturation_occurred, set_saturation_occurred.\n\t* config/arm/unspecs.md (UNSPEC_Q_SET): Define.\n\t(UNSPEC_APSR_READ): Likewise.\n\t(VUNSPEC_APSR_WRITE): Likewise.\n\t* config/arm/arm-fixed.md (ssadd<mode>3): Convert to define_expand.\n\t(*arm_ssadd<mode>3): New define_insn.\n\t(sssub<mode>3): Convert to define_expand.\n\t(*arm_sssub<mode>3): New define_insn.\n\t(ssmulsa3): Convert to define_expand.\n\t(*arm_ssmulsa3): New define_insn.\n\t(usmulusa3): Convert to define_expand.\n\t(*arm_usmulusa3): New define_insn.\n\t(ssmulha3): FAIL if ARM_Q_BIT_READ.\n\t(arm_ssatsihi_shift, arm_usatsihi): Disable for ARM_Q_BIT_READ.\n\t* config/arm/iterators.md (qaddsub_clob_q): New mode attribute.\n\n\t* gcc.target/arm/acle/saturation.c: New test.\n\t* gcc.target/arm/acle/sat_no_smlatb.c: Likewise.\n\t* lib/target-supports.exp (check_effective_target_arm_qbit_ok_nocache):\n\tDefine..\n\t(check_effective_target_arm_qbit_ok): Likewise.\n\t(add_options_for_arm_qbit): Likewise.\n\nFrom-SVN: r277914", "tree": {"sha": "7d0163547be22d04c3d43c5bc0d6c02b9f1c5773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d0163547be22d04c3d43c5bc0d6c02b9f1c5773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf16f980e5278c146f04587ea2a378fab950d7b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf16f980e5278c146f04587ea2a378fab950d7b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf16f980e5278c146f04587ea2a378fab950d7b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf16f980e5278c146f04587ea2a378fab950d7b3/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9d01715bd7e033eacfbadbfab5f1f206221305c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d01715bd7e033eacfbadbfab5f1f206221305c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d01715bd7e033eacfbadbfab5f1f206221305c"}], "stats": {"total": 586, "additions": 557, "deletions": 29}, "files": [{"sha": "51a301e2770d9174e8396973508757fe218d848b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -1,3 +1,69 @@\n+2019-11-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/arm/aout.h (REGISTER_NAMES): Add apsrq.\n+\t* config/arm/arm.md (APSRQ_REGNUM): Define.\n+\t(add_setq): New define_subst.\n+\t(add_clobber_q_name): New define_subst_attr.\n+\t(add_clobber_q_pred): Likewise.\n+\t(maddhisi4): Change to define_expand.  Split into mult and add if\n+\tARM_Q_BIT_READ.\n+\t(arm_maddhisi4): New define_insn.\n+\t(*maddhisi4tb): Disable for ARM_Q_BIT_READ.\n+\t(*maddhisi4tt): Likewise.\n+\t(arm_ssat): New define_expand.\n+\t(arm_usat): Likewise.\n+\t(arm_get_apsr): New define_insn.\n+\t(arm_set_apsr): Likewise.\n+\t(arm_saturation_occurred): New define_expand.\n+\t(arm_set_saturation): Likewise.\n+\t(*satsi_<SAT:code>): Rename to...\n+\t(satsi_<SAT:code><add_clobber_q_name>): ... This.\n+\t(*satsi_<SAT:code>_shift): Disable for ARM_Q_BIT_READ.\n+\t* config/arm/arm.h (FIXED_REGISTERS): Mark apsrq as fixed.\n+\t(CALL_USED_REGISTERS): Mark apsrq.\n+\t(FIRST_PSEUDO_REGISTER): Update value.\n+\t(REG_ALLOC_ORDER): Add APSRQ_REGNUM.\n+\t(machine_function): Add q_bit_access.\n+\t(ARM_Q_BIT_READ): Define.\n+\t* config/arm/arm.c (TARGET_CHECK_BUILTIN_CALL): Define.\n+\t(arm_conditional_register_usage): Clear APSRQ_REGNUM from\n+\toperand_reg_set.\n+\t(arm_q_bit_access): Define.\n+\t* config/arm/arm-builtins.c: Include stringpool.h.\n+\t(arm_sat_binop_imm_qualifiers,\n+\tarm_unsigned_sat_binop_unsigned_imm_qualifiers,\n+\tarm_sat_occurred_qualifiers, arm_set_sat_qualifiers): Define.\n+\t(SAT_BINOP_UNSIGNED_IMM_QUALIFIERS,\n+\tUNSIGNED_SAT_BINOP_UNSIGNED_IMM_QUALIFIERS, SAT_OCCURRED_QUALIFIERS,\n+\tSET_SAT_QUALIFIERS): Likewise.\n+\t(arm_builtins): Define ARM_BUILTIN_SAT_IMM_CHECK.\n+\t(arm_init_acle_builtins): Initialize __builtin_sat_imm_check.\n+\tHandle 0 argument expander.\n+\t(arm_expand_acle_builtin): Handle ARM_BUILTIN_SAT_IMM_CHECK.\n+\t(arm_check_builtin_call): Define.\n+\t* config/arm/arm.md (ssmulsa3, usmulusa3, usmuluha3,\n+\tarm_ssatsihi_shift, arm_usatsihi): Disable when ARM_Q_BIT_READ.\n+\t* config/arm/arm-protos.h (arm_check_builtin_call): Declare prototype.\n+\t(arm_q_bit_access): Likewise.\n+\t* config/arm/arm_acle.h (__ssat, __usat, __ignore_saturation,\n+\t__saturation_occurred, __set_saturation_occurred): Define.\n+\t* config/arm/arm_acle_builtins.def: Define builtins for ssat, usat,\n+\tsaturation_occurred, set_saturation_occurred.\n+\t* config/arm/unspecs.md (UNSPEC_Q_SET): Define.\n+\t(UNSPEC_APSR_READ): Likewise.\n+\t(VUNSPEC_APSR_WRITE): Likewise.\n+\t* config/arm/arm-fixed.md (ssadd<mode>3): Convert to define_expand.\n+\t(*arm_ssadd<mode>3): New define_insn.\n+\t(sssub<mode>3): Convert to define_expand.\n+\t(*arm_sssub<mode>3): New define_insn.\n+\t(ssmulsa3): Convert to define_expand.\n+\t(*arm_ssmulsa3): New define_insn.\n+\t(usmulusa3): Convert to define_expand.\n+\t(*arm_usmulusa3): New define_insn.\n+\t(ssmulha3): FAIL if ARM_Q_BIT_READ.\n+\t(arm_ssatsihi_shift, arm_usatsihi): Disable for ARM_Q_BIT_READ.\n+\t* config/arm/iterators.md (qaddsub_clob_q): New mode attribute.\n+\n 2019-11-07  Martin Liska  <mliska@suse.cz>\n \n \tPR c++/92354"}, {"sha": "a5f83cb503f61cc1cab0e61795edde33250610e7", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -72,7 +72,7 @@\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\t\t\\\n   \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\t\t\\\n   \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\t\t\\\n-  \"cc\", \"vfpcc\", \"sfp\", \"afp\"\t\t\t\t\t\\\n+  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\"\t\t\t\t\\\n }\n #endif\n "}, {"sha": "995f50785f6ebff7b3cd47185516f7bcb4fd5b81", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -41,6 +41,7 @@\n #include \"langhooks.h\"\n #include \"case-cfn-macros.h\"\n #include \"sbitmap.h\"\n+#include \"stringpool.h\"\n \n #define SIMD_MAX_BUILTIN_ARGS 7\n \n@@ -127,6 +128,20 @@ arm_binop_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n   = { qualifier_none, qualifier_none, qualifier_immediate };\n #define BINOP_IMM_QUALIFIERS (arm_binop_imm_qualifiers)\n \n+/* T (T, unsigned immediate).  */\n+static enum arm_type_qualifiers\n+arm_sat_binop_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_unsigned, qualifier_none, qualifier_unsigned_immediate };\n+#define SAT_BINOP_UNSIGNED_IMM_QUALIFIERS \\\n+  (arm_sat_binop_imm_qualifiers)\n+\n+/* unsigned T (T, unsigned immediate).  */\n+static enum arm_type_qualifiers\n+arm_unsigned_sat_binop_unsigned_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_unsigned, qualifier_none, qualifier_unsigned_immediate };\n+#define UNSIGNED_SAT_BINOP_UNSIGNED_IMM_QUALIFIERS \\\n+  (arm_unsigned_sat_binop_unsigned_imm_qualifiers)\n+\n /* T (T, lane index).  */\n static enum arm_type_qualifiers\n arm_getlane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n@@ -285,6 +300,18 @@ arm_storestruct_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n       qualifier_none, qualifier_struct_load_store_lane_index };\n #define STORE1LANE_QUALIFIERS (arm_storestruct_lane_qualifiers)\n \n+   /* int (void).  */\n+static enum arm_type_qualifiers\n+arm_sat_occurred_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_none, qualifier_void };\n+#define SAT_OCCURRED_QUALIFIERS (arm_sat_occurred_qualifiers)\n+\n+   /* void (int).  */\n+static enum arm_type_qualifiers\n+arm_set_sat_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n+  = { qualifier_void, qualifier_none };\n+#define SET_SAT_QUALIFIERS (arm_set_sat_qualifiers)\n+\n #define v8qi_UP  E_V8QImode\n #define v4hi_UP  E_V4HImode\n #define v4hf_UP  E_V4HFmode\n@@ -674,6 +701,7 @@ enum arm_builtins\n   ARM_BUILTIN_##N,\n \n   ARM_BUILTIN_ACLE_BASE,\n+  ARM_BUILTIN_SAT_IMM_CHECK = ARM_BUILTIN_ACLE_BASE,\n \n #include \"arm_acle_builtins.def\"\n \n@@ -1169,6 +1197,16 @@ arm_init_acle_builtins (void)\n {\n   unsigned int i, fcode = ARM_BUILTIN_ACLE_PATTERN_START;\n \n+  tree sat_check_fpr = build_function_type_list (void_type_node,\n+\t\t\t\t\t\t intSI_type_node,\n+\t\t\t\t\t\t intSI_type_node,\n+\t\t\t\t\t\t intSI_type_node,\n+\t\t\t\t\t\t NULL);\n+  arm_builtin_decls[ARM_BUILTIN_SAT_IMM_CHECK]\n+    = add_builtin_function (\"__builtin_sat_imm_check\", sat_check_fpr,\n+\t\t\t    ARM_BUILTIN_SAT_IMM_CHECK, BUILT_IN_MD,\n+\t\t\t    NULL, NULL_TREE);\n+\n   for (i = 0; i < ARRAY_SIZE (acle_builtin_data); i++, fcode++)\n     {\n       arm_builtin_datum *d = &acle_builtin_data[i];\n@@ -2307,6 +2345,9 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n   if (have_retval)\n     switch (argc)\n       {\n+      case 0:\n+\tpat = GEN_FCN (icode) (target);\n+\tbreak;\n       case 1:\n \tpat = GEN_FCN (icode) (target, op[0]);\n \tbreak;\n@@ -2465,7 +2506,26 @@ arm_expand_builtin_1 (int fcode, tree exp, rtx target,\n static rtx\n arm_expand_acle_builtin (int fcode, tree exp, rtx target)\n {\n-\n+  if (fcode == ARM_BUILTIN_SAT_IMM_CHECK)\n+    {\n+      /* Check the saturation immediate bounds.  */\n+\n+      rtx min_sat = expand_normal (CALL_EXPR_ARG (exp, 1));\n+      rtx max_sat = expand_normal (CALL_EXPR_ARG (exp, 2));\n+      gcc_assert (CONST_INT_P (min_sat));\n+      gcc_assert (CONST_INT_P (max_sat));\n+      rtx sat_imm = expand_normal (CALL_EXPR_ARG (exp, 0));\n+      if (CONST_INT_P (sat_imm))\n+\t{\n+\t  if (!IN_RANGE (sat_imm, min_sat, max_sat))\n+\t    error (\"%Ksaturation bit range must be in the range [%wd, %wd]\",\n+\t\t   exp, UINTVAL (min_sat), UINTVAL (max_sat));\n+\t}\n+      else\n+\terror (\"%Ksaturation bit range must be a constant immediate\", exp);\n+      /* Don't generate any RTL.  */\n+      return const0_rtx;\n+    }\n   arm_builtin_datum *d\n     = &acle_builtin_data[fcode - ARM_BUILTIN_ACLE_PATTERN_START];\n \n@@ -3295,4 +3355,22 @@ arm_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n \t\t\t    reload_fenv, restore_fnenv), update_call);\n }\n \n+/* Implement TARGET_CHECK_BUILTIN_CALL.  Record a read of the Q bit through\n+   intrinsics in the machine function.  */\n+bool\n+arm_check_builtin_call (location_t , vec<location_t> , tree fndecl,\n+\t\t\ttree, unsigned int, tree *)\n+{\n+  int fcode = DECL_MD_FUNCTION_CODE (fndecl);\n+  if (fcode == ARM_BUILTIN_saturation_occurred\n+      || fcode == ARM_BUILTIN_set_saturation)\n+    {\n+      if (cfun && cfun->decl)\n+\tDECL_ATTRIBUTES (cfun->decl)\n+\t  = tree_cons (get_identifier (\"acle qbit\"), NULL_TREE,\n+\t\t       DECL_ATTRIBUTES (cfun->decl));\n+    }\n+  return true;\n+}\n+\n #include \"gt-arm-builtins.h\""}, {"sha": "85dbc5d05c35921bc5115df68d30292a712729cf", "filename": "gcc/config/arm/arm-fixed.md", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-fixed.md?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -46,11 +46,22 @@\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"alu_dsp_reg\")])\n \n-(define_insn \"ssadd<mode>3\"\n+(define_expand \"ssadd<mode>3\"\n+  [(set (match_operand:QADDSUB 0 \"s_register_operand\")\n+\t(ss_plus:QADDSUB (match_operand:QADDSUB 1 \"s_register_operand\")\n+\t\t\t (match_operand:QADDSUB 2 \"s_register_operand\")))]\n+  \"TARGET_INT_SIMD\"\n+  {\n+    if (<qaddsub_clob_q>)\n+      FAIL;\n+  }\n+)\n+\n+(define_insn \"*arm_ssadd<mode>3\"\n   [(set (match_operand:QADDSUB 0 \"s_register_operand\" \"=r\")\n \t(ss_plus:QADDSUB (match_operand:QADDSUB 1 \"s_register_operand\" \"r\")\n \t\t\t (match_operand:QADDSUB 2 \"s_register_operand\" \"r\")))]\n-  \"TARGET_INT_SIMD\"\n+  \"TARGET_INT_SIMD && !<qaddsub_clob_q>\"\n   \"qadd<qaddsub_suf>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"alu_dsp_reg\")])\n@@ -84,11 +95,22 @@\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"alu_dsp_reg\")])\n \n-(define_insn \"sssub<mode>3\"\n+(define_expand \"sssub<mode>3\"\n+  [(set (match_operand:QADDSUB 0 \"s_register_operand\")\n+\t(ss_minus:QADDSUB (match_operand:QADDSUB 1 \"s_register_operand\")\n+\t\t\t  (match_operand:QADDSUB 2 \"s_register_operand\")))]\n+  \"TARGET_INT_SIMD\"\n+  {\n+    if (<qaddsub_clob_q>)\n+      FAIL;\n+  }\n+)\n+\n+(define_insn \"*arm_sssub<mode>3\"\n   [(set (match_operand:QADDSUB 0 \"s_register_operand\" \"=r\")\n \t(ss_minus:QADDSUB (match_operand:QADDSUB 1 \"s_register_operand\" \"r\")\n \t\t\t  (match_operand:QADDSUB 2 \"s_register_operand\" \"r\")))]\n-  \"TARGET_INT_SIMD\"\n+  \"TARGET_INT_SIMD && !<qaddsub_clob_q>\"\n   \"qsub<qaddsub_suf>%?\\\\t%0, %1, %2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"alu_dsp_reg\")])\n@@ -193,19 +215,31 @@\n   DONE;\n })\n \n-;; The code sequence emitted by this insn pattern uses the Q flag, which GCC\n-;; doesn't generally know about, so we don't bother expanding to individual\n-;; instructions.  It may be better to just use an out-of-line asm libcall for\n-;; this.\n+;; The code sequence emitted by this insn pattern uses the Q flag, so we need\n+;; to bail out when ARM_Q_BIT_READ and resort to a library sequence instead.\n+\n+(define_expand \"ssmulsa3\"\n+  [(parallel [(set (match_operand:SA 0 \"s_register_operand\")\n+\t(ss_mult:SA (match_operand:SA 1 \"s_register_operand\")\n+\t\t    (match_operand:SA 2 \"s_register_operand\")))\n+   (clobber (match_scratch:DI 3))\n+   (clobber (match_scratch:SI 4))\n+   (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_32BIT && arm_arch6\"\n+  {\n+    if (ARM_Q_BIT_READ)\n+      FAIL;\n+  }\n+)\n \n-(define_insn \"ssmulsa3\"\n+(define_insn \"*arm_ssmulsa3\"\n   [(set (match_operand:SA 0 \"s_register_operand\" \"=r\")\n \t(ss_mult:SA (match_operand:SA 1 \"s_register_operand\" \"r\")\n \t\t    (match_operand:SA 2 \"s_register_operand\" \"r\")))\n    (clobber (match_scratch:DI 3 \"=r\"))\n    (clobber (match_scratch:SI 4 \"=r\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT && arm_arch6\"\n+  \"TARGET_32BIT && arm_arch6 && !ARM_Q_BIT_READ\"\n {\n   /* s16.15 * s16.15 -> s32.30.  */\n   output_asm_insn (\"smull\\\\t%Q3, %R3, %1, %2\", operands);\n@@ -256,16 +290,28 @@\n \t\t                    (const_int 38))\n \t\t      (const_int 32)))])\n \n-;; Same goes for this.\n+(define_expand \"usmulusa3\"\n+  [(parallel [(set (match_operand:USA 0 \"s_register_operand\")\n+\t(us_mult:USA (match_operand:USA 1 \"s_register_operand\")\n+\t\t     (match_operand:USA 2 \"s_register_operand\")))\n+   (clobber (match_scratch:DI 3))\n+   (clobber (match_scratch:SI 4))\n+   (clobber (reg:CC CC_REGNUM))])]\n+  \"TARGET_32BIT && arm_arch6\"\n+  {\n+    if (ARM_Q_BIT_READ)\n+      FAIL;\n+  }\n+)\n \n-(define_insn \"usmulusa3\"\n+(define_insn \"*arm_usmulusa3\"\n   [(set (match_operand:USA 0 \"s_register_operand\" \"=r\")\n \t(us_mult:USA (match_operand:USA 1 \"s_register_operand\" \"r\")\n \t\t     (match_operand:USA 2 \"s_register_operand\" \"r\")))\n    (clobber (match_scratch:DI 3 \"=r\"))\n    (clobber (match_scratch:SI 4 \"=r\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT && arm_arch6\"\n+  \"TARGET_32BIT && arm_arch6 && !ARM_Q_BIT_READ\"\n {\n   /* 16.16 * 16.16 -> 32.32.  */\n   output_asm_insn (\"umull\\\\t%Q3, %R3, %1, %2\", operands);\n@@ -358,6 +404,8 @@\n \t\t    (match_operand:HA 2 \"s_register_operand\")))]\n   \"TARGET_32BIT && TARGET_DSP_MULTIPLY && arm_arch6\"\n {\n+  if (ARM_Q_BIT_READ)\n+    FAIL;\n   rtx tmp = gen_reg_rtx (SImode);\n   rtx rshift;\n \n@@ -378,6 +426,9 @@\n \t\t     (match_operand:UHA 2 \"s_register_operand\")))]\n   \"TARGET_INT_SIMD\"\n {\n+  if (ARM_Q_BIT_READ)\n+    FAIL;\n+\n   rtx tmp1 = gen_reg_rtx (SImode);\n   rtx tmp2 = gen_reg_rtx (SImode);\n   rtx tmp3 = gen_reg_rtx (SImode);\n@@ -405,7 +456,7 @@\n \t(ss_truncate:HI (match_operator:SI 1 \"sat_shift_operator\"\n \t\t\t  [(match_operand:SI 2 \"s_register_operand\" \"r\")\n \t\t\t   (match_operand:SI 3 \"immediate_operand\" \"I\")])))]\n-  \"TARGET_32BIT && arm_arch6\"\n+  \"TARGET_32BIT && arm_arch6 && !ARM_Q_BIT_READ\"\n   \"ssat%?\\\\t%0, #16, %2%S1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"1\")\n@@ -414,7 +465,7 @@\n (define_insn \"arm_usatsihi\"\n   [(set (match_operand:HI 0 \"s_register_operand\" \"=r\")\n \t(us_truncate:HI (match_operand:SI 1 \"s_register_operand\")))]\n-  \"TARGET_INT_SIMD\"\n+  \"TARGET_INT_SIMD && !ARM_Q_BIT_READ\"\n   \"usat%?\\\\t%0, #16, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"alu_imm\")]"}, {"sha": "963dc3e92f0119f424014a023edb51fbf32fc63f", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -28,6 +28,8 @@ extern enum unwind_info_type arm_except_unwind_info (struct gcc_options *);\n extern int use_return_insn (int, rtx);\n extern bool use_simple_return_p (void);\n extern enum reg_class arm_regno_class (int);\n+extern bool arm_check_builtin_call (location_t , vec<location_t> , tree,\n+\t\t\t\t    tree, unsigned int, tree *);\n extern void arm_load_pic_register (unsigned long, rtx);\n extern int arm_volatile_func (void);\n extern void arm_expand_prologue (void);\n@@ -58,6 +60,7 @@ extern bool arm_simd_check_vect_par_cnst_half_p (rtx op, machine_mode mode,\n \t\t\t\t\t\t bool high);\n extern void arm_emit_speculation_barrier_function (void);\n extern void arm_decompose_di_binop (rtx, rtx, rtx *, rtx *, rtx *, rtx *);\n+extern bool arm_q_bit_access (void);\n \n #ifdef RTX_CODE\n extern void arm_gen_unlikely_cbranch (enum rtx_code, machine_mode cc_mode,"}, {"sha": "04f02e664dd5001adc2f6c7b6fd6c61631e5deb8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -385,6 +385,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n+#undef TARGET_CHECK_BUILTIN_CALL\n+#define TARGET_CHECK_BUILTIN_CALL arm_check_builtin_call\n+\n #undef TARGET_LEGITIMIZE_ADDRESS\n #define TARGET_LEGITIMIZE_ADDRESS arm_legitimize_address\n \n@@ -29140,6 +29143,10 @@ arm_conditional_register_usage (void)\n       if (TARGET_CALLER_INTERWORKING)\n \tglobal_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\n     }\n+\n+  /* The Q bit is only accessed via special ACLE patterns.  */\n+  CLEAR_HARD_REG_BIT (operand_reg_set, APSRQ_REGNUM);\n+\n   SUBTARGET_CONDITIONAL_REGISTER_USAGE\n }\n \n@@ -32375,6 +32382,16 @@ arm_emit_speculation_barrier_function ()\n   emit_library_call (speculation_barrier_libfunc, LCT_NORMAL, VOIDmode);\n }\n \n+/* Have we recorded an explicit access to the Q bit of APSR?.  */\n+bool\n+arm_q_bit_access (void)\n+{\n+  if (cfun && cfun->decl)\n+    return lookup_attribute (\"acle qbit\",\n+\t\t\t     DECL_ATTRIBUTES (cfun->decl));\n+  return true;\n+}\n+\n #if CHECKING_P\n namespace selftest {\n "}, {"sha": "4cf49ff4ceb9256b6baac6b7a0cb62f79fb9088d", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -723,6 +723,8 @@ extern int arm_arch_cmse;\n \t                goto.  Without it fp appears to be used and the\n \t\t\telimination code won't get rid of sfp.  It tracks\n \t\t\tfp exactly at all times.\n+\tapsrq\t\tNor this, it is used to track operations on the Q bit\n+\t\t\tof APSR by ACLE saturating intrinsics.\n \n    *: See TARGET_CONDITIONAL_REGISTER_USAGE  */\n \n@@ -770,7 +772,7 @@ extern int arm_arch_cmse;\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1\t\t\t\\\n+  1,1,1,1,1\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -800,7 +802,7 @@ extern int arm_arch_cmse;\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1\t\t\t\\\n+  1,1,1,1,1\t\t\t\\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -975,10 +977,10 @@ extern int arm_arch_cmse;\n   ((((REGNUM) - FIRST_VFP_REGNUM) & 3) == 0 \\\n    && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n \n-/* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP.  */\n+/* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP + 1 APSRQ.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n /* VFP (VFP3) adds 32 (64) + 1 VFPCC.  */\n-#define FIRST_PSEUDO_REGISTER   104\n+#define FIRST_PSEUDO_REGISTER   105\n \n #define DBX_REGISTER_NUMBER(REGNO) arm_dbx_register_number (REGNO)\n \n@@ -1062,7 +1064,7 @@ extern int arm_regs_in_sequence[];\n   /* Registers not for general use.  */\t\t\\\n   CC_REGNUM, VFPCC_REGNUM,\t\t\t\\\n   FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM,\t\\\n-  SP_REGNUM, PC_REGNUM \t\t\t\t\\\n+  SP_REGNUM, PC_REGNUM, APSRQ_REGNUM\t\t\\\n }\n \n /* Use different register alloc ordering for Thumb.  */\n@@ -1402,6 +1404,8 @@ typedef struct GTY(()) machine_function\n machine_function;\n #endif\n \n+#define ARM_Q_BIT_READ (arm_q_bit_access ())\n+\n /* As in the machine_function, a global set of call-via labels, for code \n    that is in text_section.  */\n extern GTY(()) rtx thumb_call_via_label[14];"}, {"sha": "992d7b60bbc64570e0878d0acc569fda6bf92cc9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 145, "deletions": 7, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -39,6 +39,7 @@\n    (LAST_ARM_REGNUM  15)\t;\n    (CC_REGNUM       100)\t; Condition code pseudo register\n    (VFPCC_REGNUM    101)\t; VFP Condition code pseudo register\n+   (APSRQ_REGNUM    104)\t; Q bit pseudo register\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode\n@@ -423,6 +424,20 @@\n (include \"marvell-pj4.md\")\n (include \"xgene1.md\")\n \n+;; define_subst and associated attributes\n+\n+(define_subst \"add_setq\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+        (match_operand:SI 1 \"\" \"\"))]\n+  \"\"\n+  [(set (match_dup 0)\n+        (match_dup 1))\n+   (set (reg:CC APSRQ_REGNUM)\n+\t(unspec:CC [(reg:CC APSRQ_REGNUM)] UNSPEC_Q_SET))])\n+\n+(define_subst_attr \"add_clobber_q_name\" \"add_setq\" \"\" \"_setq\")\n+(define_subst_attr \"add_clobber_q_pred\" \"add_setq\" \"!ARM_Q_BIT_READ\"\n+\t\t   \"ARM_Q_BIT_READ\")\n \f\n ;;---------------------------------------------------------------------------\n ;; Insn patterns\n@@ -2515,14 +2530,36 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"maddhisi4\"\n+(define_expand \"maddhisi4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\")\n+\t(plus:SI (mult:SI (sign_extend:SI\n+\t\t\t   (match_operand:HI 1 \"s_register_operand\"))\n+\t\t\t  (sign_extend:SI\n+\t\t\t   (match_operand:HI 2 \"s_register_operand\")))\n+\t\t (match_operand:SI 3 \"s_register_operand\")))]\n+  \"TARGET_DSP_MULTIPLY\"\n+  {\n+    /* If this function reads the Q bit from ACLE intrinsics break up the\n+       multiplication and accumulation as an overflow during accumulation will\n+       clobber the Q flag.  */\n+    if (ARM_Q_BIT_READ)\n+      {\n+\trtx tmp = gen_reg_rtx (SImode);\n+\temit_insn (gen_mulhisi3 (tmp, operands[1], operands[2]));\n+\temit_insn (gen_addsi3 (operands[0], tmp, operands[3]));\n+\tDONE;\n+      }\n+  }\n+)\n+\n+(define_insn \"*arm_maddhisi4\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(plus:SI (mult:SI (sign_extend:SI\n \t\t\t   (match_operand:HI 1 \"s_register_operand\" \"r\"))\n \t\t\t  (sign_extend:SI\n \t\t\t   (match_operand:HI 2 \"s_register_operand\" \"r\")))\n \t\t (match_operand:SI 3 \"s_register_operand\" \"r\")))]\n-  \"TARGET_DSP_MULTIPLY\"\n+  \"TARGET_DSP_MULTIPLY && !ARM_Q_BIT_READ\"\n   \"smlabb%?\\\\t%0, %1, %2, %3\"\n   [(set_attr \"type\" \"smlaxy\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -2537,7 +2574,7 @@\n \t\t\t  (sign_extend:SI\n \t\t\t   (match_operand:HI 2 \"s_register_operand\" \"r\")))\n \t\t (match_operand:SI 3 \"s_register_operand\" \"r\")))]\n-  \"TARGET_DSP_MULTIPLY\"\n+  \"TARGET_DSP_MULTIPLY && !ARM_Q_BIT_READ\"\n   \"smlatb%?\\\\t%0, %1, %2, %3\"\n   [(set_attr \"type\" \"smlaxy\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -2552,7 +2589,7 @@\n \t\t\t   (match_operand:SI 2 \"s_register_operand\" \"r\")\n \t\t\t   (const_int 16)))\n \t\t (match_operand:SI 3 \"s_register_operand\" \"r\")))]\n-  \"TARGET_DSP_MULTIPLY\"\n+  \"TARGET_DSP_MULTIPLY && !ARM_Q_BIT_READ\"\n   \"smlatt%?\\\\t%0, %1, %2, %3\"\n   [(set_attr \"type\" \"smlaxy\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -4044,12 +4081,113 @@\n (define_code_attr SATlo [(smin \"1\") (smax \"2\")])\n (define_code_attr SAThi [(smin \"2\") (smax \"1\")])\n \n-(define_insn \"*satsi_<SAT:code>\"\n+(define_expand \"arm_ssat\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"s_register_operand\")\n+   (match_operand:SI 2 \"const_int_operand\")]\n+  \"TARGET_32BIT && arm_arch6\"\n+  {\n+    HOST_WIDE_INT val = INTVAL (operands[2]);\n+    /* The builtin checking code should have ensured the right\n+       range for the immediate.  */\n+    gcc_assert (IN_RANGE (val, 1, 32));\n+    HOST_WIDE_INT upper_bound = (HOST_WIDE_INT_1 << (val - 1)) - 1;\n+    HOST_WIDE_INT lower_bound = -upper_bound - 1;\n+    rtx up_rtx = gen_int_mode (upper_bound, SImode);\n+    rtx lo_rtx = gen_int_mode (lower_bound, SImode);\n+    if (ARM_Q_BIT_READ)\n+      emit_insn (gen_satsi_smin_setq (operands[0], lo_rtx,\n+\t\t\t\t      up_rtx, operands[1]));\n+    else\n+      emit_insn (gen_satsi_smin (operands[0], lo_rtx, up_rtx, operands[1]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"arm_usat\"\n+  [(match_operand:SI 0 \"s_register_operand\")\n+   (match_operand:SI 1 \"s_register_operand\")\n+   (match_operand:SI 2 \"const_int_operand\")]\n+  \"TARGET_32BIT && arm_arch6\"\n+  {\n+    HOST_WIDE_INT val = INTVAL (operands[2]);\n+    /* The builtin checking code should have ensured the right\n+       range for the immediate.  */\n+    gcc_assert (IN_RANGE (val, 0, 31));\n+    HOST_WIDE_INT upper_bound = (HOST_WIDE_INT_1 << val) - 1;\n+    rtx up_rtx = gen_int_mode (upper_bound, SImode);\n+    rtx lo_rtx = CONST0_RTX (SImode);\n+    if (ARM_Q_BIT_READ)\n+      emit_insn (gen_satsi_smin_setq (operands[0], lo_rtx, up_rtx,\n+\t\t\t\t      operands[1]));\n+    else\n+      emit_insn (gen_satsi_smin (operands[0], lo_rtx, up_rtx, operands[1]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"arm_get_apsr\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(unspec:SI [(reg:CC APSRQ_REGNUM)] UNSPEC_APSR_READ))]\n+  \"TARGET_ARM_QBIT\"\n+  \"mrs%?\\t%0, APSR\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"conds\" \"use\")]\n+)\n+\n+(define_insn \"arm_set_apsr\"\n+  [(set (reg:CC APSRQ_REGNUM)\n+\t(unspec_volatile:CC\n+\t  [(match_operand:SI 0 \"s_register_operand\" \"r\")] VUNSPEC_APSR_WRITE))]\n+  \"TARGET_ARM_QBIT\"\n+  \"msr%?\\tAPSR_nzcvq, %0\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"conds\" \"set\")]\n+)\n+\n+;; Read the APSR and extract the Q bit (bit 27)\n+(define_expand \"arm_saturation_occurred\"\n+  [(match_operand:SI 0 \"s_register_operand\")]\n+  \"TARGET_ARM_QBIT\"\n+  {\n+    rtx apsr = gen_reg_rtx (SImode);\n+    emit_insn (gen_arm_get_apsr (apsr));\n+    emit_insn (gen_extzv (operands[0], apsr, CONST1_RTX (SImode),\n+\t       gen_int_mode (27, SImode)));\n+    DONE;\n+  }\n+)\n+\n+;; Read the APSR and set the Q bit (bit position 27) according to operand 0\n+(define_expand \"arm_set_saturation\"\n+  [(match_operand:SI 0 \"reg_or_int_operand\")]\n+  \"TARGET_ARM_QBIT\"\n+  {\n+    rtx apsr = gen_reg_rtx (SImode);\n+    emit_insn (gen_arm_get_apsr (apsr));\n+    rtx to_insert = gen_reg_rtx (SImode);\n+    if (CONST_INT_P (operands[0]))\n+      emit_move_insn (to_insert, operands[0] == CONST0_RTX (SImode)\n+\t\t\t\t ? CONST0_RTX (SImode) : CONST1_RTX (SImode));\n+    else\n+      {\n+        rtx cmp = gen_rtx_NE (SImode, operands[0], CONST0_RTX (SImode));\n+        emit_insn (gen_cstoresi4 (to_insert, cmp, operands[0],\n+\t\t\t\t  CONST0_RTX (SImode)));\n+      }\n+    emit_insn (gen_insv (apsr, CONST1_RTX (SImode),\n+\t       gen_int_mode (27, SImode), to_insert));\n+    emit_insn (gen_arm_set_apsr (apsr));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"satsi_<SAT:code><add_clobber_q_name>\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n         (SAT:SI (<SATrev>:SI (match_operand:SI 3 \"s_register_operand\" \"r\")\n                            (match_operand:SI 1 \"const_int_operand\" \"i\"))\n                 (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n-  \"TARGET_32BIT && arm_arch6\n+  \"TARGET_32BIT && arm_arch6 && <add_clobber_q_pred>\n    && arm_sat_operator_match (operands[<SAT:SATlo>], operands[<SAT:SAThi>], NULL, NULL)\"\n {\n   int mask;\n@@ -4075,7 +4213,7 @@\n                               (match_operand:SI 5 \"const_int_operand\" \"i\")])\n                            (match_operand:SI 1 \"const_int_operand\" \"i\"))\n                 (match_operand:SI 2 \"const_int_operand\" \"i\")))]\n-  \"TARGET_32BIT && arm_arch6\n+  \"TARGET_32BIT && arm_arch6 && !ARM_Q_BIT_READ\n    && arm_sat_operator_match (operands[<SAT:SATlo>], operands[<SAT:SAThi>], NULL, NULL)\"\n {\n   int mask;"}, {"sha": "2564ad849856610f9415586e386f85eea6947bf7", "filename": "gcc/config/arm/arm_acle.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm_acle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm_acle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_acle.h?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -433,6 +433,50 @@ __smlsldx (int16x2_t __a, int16x2_t __b, int64_t __c)\n \n #endif\n \n+#ifdef __ARM_FEATURE_SAT\n+\n+#define __ssat(__a, __sat)\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\\\n+    int32_t __arg = (__a);\t\t\t\t\\\n+    __builtin_sat_imm_check (__sat, 1, 32);\t\t\\\n+    int32_t __res = __builtin_arm_ssat (__arg, __sat);\t\\\n+    __res;\t\t\t\t\t\t\\\n+  })\n+\n+#define __usat(__a, __sat)\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\\\n+    int32_t __arg = (__a);\t\t\t\t\\\n+    __builtin_sat_imm_check (__sat, 0, 31);\t\t\\\n+    uint32_t __res = __builtin_arm_usat (__arg, __sat);\t\\\n+    __res;\t\t\t\t\t\t\\\n+  })\n+\n+#endif\n+\n+#ifdef __ARM_FEATURE_QBIT\n+__extension__ extern __inline void\n+__attribute__  ((__always_inline__, __gnu_inline__, __artificial__))\n+__ignore_saturation (void)\n+{\n+  /* ACLE designates this intrinsic as a hint.\n+     Implement as a nop for now.  */\n+}\n+\n+/* These are defined as macros because the implementation of the builtins\n+   requires easy access to the current function so wrapping it in an\n+   always_inline function complicates things.  */\n+\n+#define __saturation_occurred __builtin_arm_saturation_occurred\n+\n+#define __set_saturation_occurred(__a)\t\t\t\\\n+  __extension__\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\\\n+    int __arg = (__a);\t\t\t\t\t\\\n+    __builtin_arm_set_saturation (__arg);\t\t\\\n+  })\n+#endif\n \n #pragma GCC push_options\n #ifdef __ARM_FEATURE_CRC32"}, {"sha": "c72480321faa952ac307418f9e4f7d5f5f9e3745", "filename": "gcc/config/arm/arm_acle_builtins.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm_acle_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Farm_acle_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_acle_builtins.def?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -79,3 +79,8 @@ VAR1 (TERNOP, smlald, di)\n VAR1 (TERNOP, smlaldx, di)\n VAR1 (TERNOP, smlsld, di)\n VAR1 (TERNOP, smlsldx, di)\n+\n+VAR1 (SAT_BINOP_UNSIGNED_IMM, ssat, si)\n+VAR1 (UNSIGNED_SAT_BINOP_UNSIGNED_IMM, usat, si)\n+VAR1 (SAT_OCCURRED, saturation_occurred, si)\n+VAR1 (SET_SAT, set_saturation, void)"}, {"sha": "e5cef6852a2dfcef4cd3597c163a53a6c247afab", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -763,6 +763,12 @@\n \t\t\t       (V4QQ \"8\") (V2HQ \"16\") (QQ \"8\") (HQ \"16\")\n \t\t\t       (V2HA \"16\") (HA \"16\") (SQ \"\") (SA \"\")])\n \n+(define_mode_attr qaddsub_clob_q [(V4UQQ \"0\") (V2UHQ \"0\") (UQQ \"0\") (UHQ \"0\")\n+\t\t\t       (V2UHA \"0\") (UHA \"0\")\n+\t\t\t       (V4QQ \"0\") (V2HQ \"0\") (QQ \"0\") (HQ \"0\")\n+\t\t\t       (V2HA \"0\") (HA \"0\") (SQ \"ARM_Q_BIT_READ\")\n+\t\t\t       (SA \"ARM_Q_BIT_READ\")])\n+\n ;; Mode attribute for vshll.\n (define_mode_attr V_innermode [(V8QI \"QI\") (V4HI \"HI\") (V2SI \"SI\")])\n "}, {"sha": "a4287949e525688ee5141e4975917537f84466ff", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -70,6 +70,9 @@\n \t\t\t; that.\n   UNSPEC_UNALIGNED_STORE ; Same for str/strh.\n   UNSPEC_PIC_UNIFIED    ; Create a common pic addressing form.\n+  UNSPEC_Q_SET          ; Represent setting the Q bit.\n+  UNSPEC_APSR_READ      ; Represent reading the APSR.\n+\n   UNSPEC_LL\t\t; Represent an unpaired load-register-exclusive.\n   UNSPEC_VRINTZ         ; Represent a float to integral float rounding\n                         ; towards zero.\n@@ -211,6 +214,7 @@\n   VUNSPEC_MRRC\t\t; Represent the coprocessor mrrc instruction.\n   VUNSPEC_MRRC2\t\t; Represent the coprocessor mrrc2 instruction.\n   VUNSPEC_SPECULATION_BARRIER ; Represents an unconditional speculation barrier.\n+  VUNSPEC_APSR_WRITE     ; Represent writing the APSR.\n ])\n \n ;; Enumerators for NEON unspecs."}, {"sha": "f3bf66c44ee82a3f28f1ad638a8cea1b6cc19bf6", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -1911,6 +1911,12 @@ ARM Target supports options suitable for accessing the SIMD32 intrinsics from\n @code{arm_acle.h}.\n Some multilibs may be incompatible with these options.\n \n+@item arm_qbit_ok\n+@anchor{arm_qbit_ok}\n+ARM Target supports options suitable for accessing the Q-bit manipulation\n+intrinsics from @code{arm_acle.h}.\n+Some multilibs may be incompatible with these options.\n+\n @end table\n \n @subsubsection AArch64-specific attributes"}, {"sha": "f7318b08b42d8817cc68270538068e82084d9a8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -1,3 +1,12 @@\n+2019-11-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.target/arm/acle/saturation.c: New test.\n+\t* gcc.target/arm/acle/sat_no_smlatb.c: Likewise.\n+\t* lib/target-supports.exp (check_effective_target_arm_qbit_ok_nocache):\n+\tDefine..\n+\t(check_effective_target_arm_qbit_ok): Likewise.\n+\t(add_options_for_arm_qbit): Likewise.\n+\n 2019-11-07  Martin Liska  <mliska@suse.cz>\n \n \tPR c++/92354"}, {"sha": "e0c53ed4dc9c9a2ff580d03a434ff34005db9ce6", "filename": "gcc/testsuite/gcc.target/arm/acle/sat_no_smlatb.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsat_no_smlatb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsat_no_smlatb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsat_no_smlatb.c?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_dsp } */\n+\n+/* Ensure the smlatb doesn't get generated when reading the Q flag\n+   from ACLE.  */\n+\n+#include <arm_acle.h>\n+\n+int\n+foo (int x, int in, int32_t c)\n+{\n+  short a = in & 0xffff;\n+  short b = (in & 0xffff0000) >> 16;\n+  \n+  int res =  x + b * a + __ssat (c, 24);\n+  return res + __saturation_occurred ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"smlatb\\\\t\" } } */"}, {"sha": "0b3fe519933d05a2d35106ec47b0f432365e430a", "filename": "gcc/testsuite/gcc.target/arm/acle/saturation.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsaturation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsaturation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Facle%2Fsaturation.c?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_qbit_ok } */\n+/* { dg-add-options arm_qbit } */\n+\n+#include <arm_acle.h>\n+\n+int32_t\n+test_ssat (int32_t a)\n+{\n+  return __ssat (a, 8);\n+}\n+\n+/* { dg-final { scan-assembler-times \"ssat\\t...?, #8, ...?\" 1 } } */\n+\n+uint32_t\n+test_usat (int32_t a)\n+{\n+  return __usat (a, 24);\n+}\n+\n+/* { dg-final { scan-assembler-times \"usat\\t...?, #24, ...?\" 1 } } */\n+\n+/* Test that USAT doesn't get removed as we need its Q-setting behavior.  */\n+int\n+test_sat_occur (int32_t a)\n+{\n+  uint32_t res = __usat (a, 3);\n+  return __saturation_occurred ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"usat\\t...?, #3, ...?\" 1 } } */\n+/* { dg-final { scan-assembler \"mrs\\t...?, APSR\" } } */\n+\n+void\n+test_set_sat (void)\n+{\n+  __set_saturation_occurred (0);\n+}\n+\n+/* { dg-final { scan-assembler-times \"msr\\tAPSR_nzcvq, ...?\" 1 } } */"}, {"sha": "751045d4744777991cda826c6a654ce2bcc73962", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf16f980e5278c146f04587ea2a378fab950d7b3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=cf16f980e5278c146f04587ea2a378fab950d7b3", "patch": "@@ -3845,6 +3845,44 @@ proc add_options_for_arm_simd32 { flags } {\n     return \"$flags $et_arm_simd32_flags\"\n }\n \n+# Return 1 if this is an ARM target supporting the saturation intrinsics\n+# from arm_acle.h.  Some multilibs may be incompatible with these options.\n+# Also set et_arm_qbit_flags to the best options to add.\n+# arm_acle.h includes stdint.h which can cause trouble with incompatible\n+# -mfloat-abi= options.\n+\n+proc check_effective_target_arm_qbit_ok_nocache { } {\n+    global et_arm_qbit_flags\n+    set et_arm_qbit_flags \"\"\n+    foreach flags {\"\" \"-march=armv5te\" \"-march=armv5te -mfloat-abi=softfp\" \"-march=armv5te -mfloat-abi=hard\"} {\n+      if { [check_no_compiler_messages_nocache et_arm_qbit_flags object {\n+\t#include <arm_acle.h>\n+\tint dummy;\n+\t#ifndef __ARM_FEATURE_QBIT\n+\t#error not QBIT\n+\t#endif\n+      } \"$flags\"] } {\n+\tset et_arm_qbit_flags $flags\n+\treturn 1\n+      }\n+    }\n+\n+  return 0\n+}\n+\n+proc check_effective_target_arm_qbit_ok { } {\n+    return [check_cached_effective_target et_arm_qbit_flags \\\n+\t\tcheck_effective_target_arm_qbit_ok_nocache]\n+}\n+\n+proc add_options_for_arm_qbit { flags } {\n+    if { ! [check_effective_target_arm_qbit_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_qbit_flags\n+    return \"$flags $et_arm_qbit_flags\"\n+}\n+\n # Return 1 if this is an ARM target supporting -mfpu=neon without any\n # -mfloat-abi= option.  Useful in tests where add_options is not\n # supported (such as lto tests)."}]}