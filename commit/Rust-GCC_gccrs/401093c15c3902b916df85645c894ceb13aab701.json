{"sha": "401093c15c3902b916df85645c894ceb13aab701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAxMDkzYzE1YzM5MDJiOTE2ZGY4NTY0NWM4OTRjZWIxM2FhYjcwMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:46:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:46:31Z"}, "message": "sem_ch4.adb (Try_Class_Wide_Operation): use base type of first parameter to determine whether operation applies to the...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Class_Wide_Operation): use base type of first\n\tparameter to determine whether operation applies to the prefix.\n\t(Complete_Object_Operation): If actual has an access type and\n\tcontrolling formal is not an in_parameter, reject the actual if it is\n\tan access_to_constant type.\n\t(Try_Primitive_Operation): If the type of the prefix is a formal tagged\n\ttype, the candidate operations are found in the scope of declaration of\n\tthe type, because the type has no primitive subprograms.\n\t(Analyze_Selected_Component): If prefix is class-wide, and root type is\n\ta private extension, only examine visible components before trying to\n\tanalyze as a prefixed call.\n\tChange Entity_List to Type_To_Use, for better readability.\n\t(Has_Fixed_Op): Use base type when checking whether the type of an\n\toperator has a user-defined multiplication/division\n\t(Check_Arithmetic_Pair): Use Ada 2005 rules to remove ambiguities when\n\tuser-defined operators are available for fixed-point types.\n\nFrom-SVN: r127444", "tree": {"sha": "845ccedfd3f2b59d738d79c1bf388b4d7df531e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/845ccedfd3f2b59d738d79c1bf388b4d7df531e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/401093c15c3902b916df85645c894ceb13aab701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401093c15c3902b916df85645c894ceb13aab701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401093c15c3902b916df85645c894ceb13aab701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401093c15c3902b916df85645c894ceb13aab701/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0ce9d83b5935bdba514340ef498c4bb73cfb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0ce9d83b5935bdba514340ef498c4bb73cfb78"}], "stats": {"total": 193, "additions": 151, "deletions": 42}, "files": [{"sha": "9a70be8219970f44152743e5feb53a9d0b8dc370", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 151, "deletions": 42, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/401093c15c3902b916df85645c894ceb13aab701/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/401093c15c3902b916df85645c894ceb13aab701/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=401093c15c3902b916df85645c894ceb13aab701", "patch": "@@ -200,7 +200,7 @@ package body Sem_Ch4 is\n    --  a valid pair for the given operator, and record the corresponding\n    --  interpretation of the operator node. The node N may be an operator\n    --  node (the usual case) or a function call whose prefix is an operator\n-   --  designator. In  both cases Op_Id is the operator name itself.\n+   --  designator. In both cases Op_Id is the operator name itself.\n \n    procedure Diagnose_Call (N : Node_Id; Nam : Node_Id);\n    --  Give detailed information on overloaded call where none of the\n@@ -1445,7 +1445,7 @@ package body Sem_Ch4 is\n          Set_Name (N, P);\n          Set_Parameter_Associations (N, Exprs);\n \n-         --  Analyze actuals prior to analyzing the call itself.\n+         --  Analyze actuals prior to analyzing the call itself\n \n          Actual := First (Parameter_Associations (N));\n          while Present (Actual) loop\n@@ -2073,7 +2073,7 @@ package body Sem_Ch4 is\n          --  access to subprogram. in which case this is an indirect call.\n \n          elsif Is_Access_Type (Subp_Type)\n-           and then Ekind (Designated_Type (Subp_Type))  = E_Subprogram_Type\n+           and then Ekind (Designated_Type (Subp_Type)) = E_Subprogram_Type\n          then\n             Is_Indexed := Try_Indirect_Call (N, Nam, Subp_Type);\n          end if;\n@@ -2252,7 +2252,8 @@ package body Sem_Ch4 is\n                           and then not Comes_From_Source (Nam)\n                         then\n                            Error_Msg_NE\n-                             (\"  =='> in call to &#(inherited)!\", Actual, Nam);\n+                             (\"\\\\  =='> in call to inherited operation & #!\",\n+                              Actual, Nam);\n \n                         elsif Ekind (Nam) = E_Subprogram_Type then\n                            declare\n@@ -2262,12 +2263,13 @@ package body Sem_Ch4 is\n                                     (Associated_Node_For_Itype (Nam));\n                            begin\n                               Error_Msg_NE (\n-                                \"  =='> in call to dereference of &#!\",\n+                                \"\\\\  =='> in call to dereference of &#!\",\n                                 Actual, Access_To_Subprogram_Typ);\n                            end;\n \n                         else\n-                           Error_Msg_NE (\"  =='> in call to &#!\", Actual, Nam);\n+                           Error_Msg_NE\n+                             (\"\\\\  =='> in call to &#!\", Actual, Nam);\n \n                         end if;\n                      end if;\n@@ -2619,8 +2621,13 @@ package body Sem_Ch4 is\n       Name        : constant Node_Id := Prefix (N);\n       Sel         : constant Node_Id := Selector_Name (N);\n       Comp        : Entity_Id;\n-      Entity_List : Entity_Id;\n       Prefix_Type : Entity_Id;\n+\n+      Type_To_Use : Entity_Id;\n+      --  In most cases this is the Prefix_Type, but if the Prefix_Type is\n+      --  a class-wide type, we use its root type, whose components are\n+      --  present in the class-wide type.\n+\n       Pent        : Entity_Id := Empty;\n       Act_Decl    : Node_Id;\n       In_Scope    : Boolean;\n@@ -2683,12 +2690,14 @@ package body Sem_Ch4 is\n       --  in what follows, either to retrieve a component of to find\n       --  a primitive operation. If the prefix is an explicit dereference,\n       --  set the type of the prefix to reflect this transformation.\n+      --  If the non-limited view is itself an incomplete type, get the\n+      --  full view if available.\n \n       if Is_Incomplete_Type (Prefix_Type)\n         and then From_With_Type (Prefix_Type)\n         and then Present (Non_Limited_View (Prefix_Type))\n       then\n-         Prefix_Type := Non_Limited_View (Prefix_Type);\n+         Prefix_Type := Get_Full_View (Non_Limited_View (Prefix_Type));\n \n          if Nkind (N) = N_Explicit_Dereference then\n             Set_Etype (Prefix (N), Prefix_Type);\n@@ -2710,17 +2719,17 @@ package body Sem_Ch4 is\n          Prefix_Type := Base_Type (Prefix_Type);\n       end if;\n \n-      Entity_List := Prefix_Type;\n+      Type_To_Use := Prefix_Type;\n \n       --  For class-wide types, use the entity list of the root type. This\n       --  indirection is specially important for private extensions because\n       --  only the root type get switched (not the class-wide type).\n \n       if Is_Class_Wide_Type (Prefix_Type) then\n-         Entity_List := Root_Type (Prefix_Type);\n+         Type_To_Use := Root_Type (Prefix_Type);\n       end if;\n \n-      Comp := First_Entity (Entity_List);\n+      Comp := First_Entity (Type_To_Use);\n \n       --  If the selector has an original discriminant, the node appears in\n       --  an instance. Replace the discriminant with the corresponding one\n@@ -2882,8 +2891,8 @@ package body Sem_Ch4 is\n             --  If the prefix is a private extension, check only the visible\n             --  components of the partial view.\n \n-            if Ekind (Prefix_Type) = E_Record_Type_With_Private then\n-               exit when Comp = Last_Entity (Prefix_Type);\n+            if Ekind (Type_To_Use) = E_Record_Type_With_Private then\n+               exit when Comp = Last_Entity (Type_To_Use);\n             end if;\n \n             Next_Entity (Comp);\n@@ -2909,8 +2918,8 @@ package body Sem_Ch4 is\n          --  do the same here.\n \n          if No (Full_View (Prefix_Type)) then\n-            Entity_List := Root_Type (Base_Type (Prefix_Type));\n-            Comp := First_Entity (Entity_List);\n+            Type_To_Use := Root_Type (Base_Type (Prefix_Type));\n+            Comp := First_Entity (Type_To_Use);\n          end if;\n \n          while Present (Comp) loop\n@@ -3058,7 +3067,7 @@ package body Sem_Ch4 is\n             Error_Msg_Node_2 := Entity (Name);\n             Error_Msg_NE (\"no selector& for&\", N, Sel);\n \n-            Check_Misspelled_Selector (Entity_List, Sel);\n+            Check_Misspelled_Selector (Type_To_Use, Sel);\n \n          elsif Is_Generic_Type (Prefix_Type)\n            and then Ekind (Prefix_Type) = E_Record_Type_With_Private\n@@ -3140,7 +3149,7 @@ package body Sem_Ch4 is\n             Error_Msg_Node_2 := First_Subtype (Prefix_Type);\n             Error_Msg_NE (\"no selector& for}\", N, Sel);\n \n-            Check_Misspelled_Selector (Entity_List, Sel);\n+            Check_Misspelled_Selector (Type_To_Use, Sel);\n \n          end if;\n \n@@ -3516,7 +3525,7 @@ package body Sem_Ch4 is\n       Op_Id  : Entity_Id;\n       N      : Node_Id)\n    is\n-      Op_Name : constant Name_Id   := Chars (Op_Id);\n+      Op_Name : constant Name_Id := Chars (Op_Id);\n \n       function Has_Fixed_Op (Typ : Entity_Id; Op : Entity_Id) return Boolean;\n       --  Check whether the fixed-point type Typ has a user-defined operator\n@@ -3532,6 +3541,7 @@ package body Sem_Ch4 is\n       ------------------\n \n       function Has_Fixed_Op (Typ : Entity_Id; Op : Entity_Id) return Boolean is\n+         Bas : constant Entity_Id := Base_Type (Typ);\n          Ent : Entity_Id;\n          F1  : Entity_Id;\n          F2  : Entity_Id;\n@@ -3547,18 +3557,18 @@ package body Sem_Ch4 is\n                F2 := Next_Formal (F1);\n \n                --  The operation counts as primitive if either operand or\n-               --  result are of the given type, and both operands are fixed\n-               --  point types.\n+               --  result are of the given base type, and both operands are\n+               --  fixed point types.\n \n-               if (Etype (F1) = Typ\n+               if (Base_Type (Etype (F1)) = Bas\n                     and then Is_Fixed_Point_Type (Etype (F2)))\n \n                  or else\n-                   (Etype (F2) = Typ\n+                   (Base_Type (Etype (F2)) = Bas\n                      and then Is_Fixed_Point_Type (Etype (F1)))\n \n                  or else\n-                   (Etype (Ent) = Typ\n+                   (Base_Type (Etype (Ent)) = Bas\n                      and then Is_Fixed_Point_Type (Etype (F1))\n                      and then Is_Fixed_Point_Type (Etype (F2)))\n                then\n@@ -3613,7 +3623,7 @@ package body Sem_Ch4 is\n             if (Nkind (N) not in N_Op\n                  or else not Treat_Fixed_As_Integer (N))\n               and then\n-                (not (Ada_Version >= Ada_05 and then Has_Fixed_Op (T1, Op_Id))\n+                (not Has_Fixed_Op (T1, Op_Id)\n                   or else Nkind (Parent (N)) = N_Type_Conversion)\n             then\n                Add_One_Interp (N, Op_Id, Universal_Fixed);\n@@ -3624,7 +3634,7 @@ package body Sem_Ch4 is\n                       or else not Treat_Fixed_As_Integer (N))\n            and then T1 = Universal_Real\n            and then\n-             (not (Ada_Version >= Ada_05 and then Has_Fixed_Op (T1, Op_Id))\n+             (not Has_Fixed_Op (T1, Op_Id)\n                or else Nkind (Parent (N)) = N_Type_Conversion)\n          then\n             Add_One_Interp (N, Op_Id, Universal_Fixed);\n@@ -4778,9 +4788,10 @@ package body Sem_Ch4 is\n    --------------------------------\n \n    procedure Remove_Abstract_Operations (N : Node_Id) is\n-      I            : Interp_Index;\n-      It           : Interp;\n-      Abstract_Op  : Entity_Id := Empty;\n+      Abstract_Op    : Entity_Id := Empty;\n+      Address_Kludge : Boolean := False;\n+      I              : Interp_Index;\n+      It             : Interp;\n \n       --  AI-310: If overloaded, remove abstract non-dispatching operations. We\n       --  activate this if either extensions are enabled, or if the abstract\n@@ -4816,6 +4827,7 @@ package body Sem_Ch4 is\n                end if;\n \n                if Is_Descendent_Of_Address (Etype (Formal)) then\n+                  Address_Kludge := True;\n                   Remove_Interp (I);\n                end if;\n \n@@ -4837,15 +4849,19 @@ package body Sem_Ch4 is\n             then\n                Abstract_Op := It.Nam;\n \n+               if Is_Descendent_Of_Address (It.Typ) then\n+                  Address_Kludge := True;\n+                  Remove_Interp (I);\n+                  exit;\n+\n                --  In Ada 2005, this operation does not participate in Overload\n                --  resolution. If the operation is defined in in a predefined\n                --  unit, it is one of the operations declared abstract in some\n                --  variants of System, and it must be removed as well.\n \n-               if Ada_Version >= Ada_05\n-                   or else Is_Predefined_File_Name\n-                             (Unit_File_Name (Get_Source_Unit (It.Nam)))\n-                   or else Is_Descendent_Of_Address (It.Typ)\n+               elsif Ada_Version >= Ada_05\n+                 or else Is_Predefined_File_Name\n+                           (Unit_File_Name (Get_Source_Unit (It.Nam)))\n                then\n                   Remove_Interp (I);\n                   exit;\n@@ -4863,7 +4879,7 @@ package body Sem_Ch4 is\n             --  on systems where Address is a visible integer type.\n \n             if Is_Overloaded (N)\n-              and then  Nkind (N) in N_Op\n+              and then Nkind (N) in N_Op\n               and then Is_Integer_Type (Etype (N))\n             then\n                if Nkind (N) in N_Binary_Op then\n@@ -4982,8 +4998,8 @@ package body Sem_Ch4 is\n             end;\n          end if;\n \n-         --  If the removal has left no valid interpretations, emit\n-         --  error message now and label node as illegal.\n+         --  If the removal has left no valid interpretations, emit an error\n+         --  message now and label node as illegal.\n \n          if Present (Abstract_Op) then\n             Get_First_Interp (N, I, It);\n@@ -4996,6 +5012,25 @@ package body Sem_Ch4 is\n                Error_Msg_Sloc := Sloc (Abstract_Op);\n                Error_Msg_NE\n                  (\"cannot call abstract operation& declared#\", N, Abstract_Op);\n+\n+            --  In Ada 2005, an abstract operation may disable predefined\n+            --  operators. Since the context is not yet known, we mark the\n+            --  predefined operators as potentially hidden. Do not include\n+            --  predefined operators when addresses are involved since this\n+            --  case is handled separately.\n+\n+            elsif Ada_Version >= Ada_05\n+              and then not Address_Kludge\n+            then\n+               while Present (It.Nam) loop\n+                  if Is_Numeric_Type (It.Typ)\n+                    and then Scope (It.Typ) = Standard_Standard\n+                  then\n+                     Set_Abstract_Op (I, Abstract_Op);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n             end if;\n          end if;\n       end if;\n@@ -5120,7 +5155,7 @@ package body Sem_Ch4 is\n       Subprog        : constant Node_Id    :=\n                          Make_Identifier (Sloc (Selector_Name (N)),\n                            Chars => Chars (Selector_Name (N)));\n-      --  Identifier on which possible interpretations will be collected.\n+      --  Identifier on which possible interpretations will be collected\n \n       Success        : Boolean := False;\n \n@@ -5284,6 +5319,16 @@ package body Sem_Ch4 is\n               Make_Explicit_Dereference (Sloc (Obj), Obj));\n             Analyze (First_Actual);\n \n+            --  If we need to introduce an explicit dereference, verify that\n+            --  the resulting actual is compatible with the mode of the formal.\n+\n+            if Ekind (First_Formal (Entity (Subprog))) /= E_In_Parameter\n+              and then Is_Access_Constant (Etype (Obj))\n+            then\n+               Error_Msg_NE\n+                 (\"expect variable in call to&\", Prefix (N), Entity (Subprog));\n+            end if;\n+\n          --  Conversely, if the formal is an access parameter and the\n          --  object is not, replace the actual with a 'Access reference.\n          --   Its analysis will check that the object is aliased.\n@@ -5299,7 +5344,7 @@ package body Sem_Ch4 is\n             if not Is_Aliased_View (Obj) then\n                Error_Msg_NE\n                  (\"object in prefixed call to& must be aliased\"\n-                      & \" ('R'M'-2005 4.3.1 (13))\",\n+                      & \" (RM-2005 4.3.1 (13))\",\n                  Prefix (First_Actual), Subprog);\n             end if;\n \n@@ -5507,21 +5552,26 @@ package body Sem_Ch4 is\n             Cls_Type := Class_Wide_Type (Anc_Type);\n \n             Hom := Current_Entity (Subprog);\n+\n+            --  Find operation whose first parameter is of the class-wide\n+            --  type, a subtype thereof, or an anonymous access to same.\n+\n             while Present (Hom) loop\n                if (Ekind (Hom) = E_Procedure\n                      or else\n                    Ekind (Hom) = E_Function)\n                  and then Scope (Hom) = Scope (Anc_Type)\n                  and then Present (First_Formal (Hom))\n                  and then\n-                   (Etype (First_Formal (Hom)) = Cls_Type\n+                   (Base_Type (Etype (First_Formal (Hom))) = Cls_Type\n                      or else\n                        (Is_Access_Type (Etype (First_Formal (Hom)))\n                           and then\n                             Ekind (Etype (First_Formal (Hom))) =\n                               E_Anonymous_Access_Type\n                           and then\n-                            Designated_Type (Etype (First_Formal (Hom))) =\n+                            Base_Type\n+                              (Designated_Type (Etype (First_Formal (Hom)))) =\n                                                                    Cls_Type))\n                then\n                   Set_Etype (Call_Node, Any_Type);\n@@ -5671,12 +5721,12 @@ package body Sem_Ch4 is\n \n          --  The type may have be obtained through a limited_with clause,\n          --  in which case the primitive operations are available on its\n-         --  non-limited view.\n+         --  non-limited view. If still incomplete, retrieve full view.\n \n          if Ekind (Obj_Type) = E_Incomplete_Type\n            and then From_With_Type (Obj_Type)\n          then\n-            Obj_Type := Non_Limited_View (Obj_Type);\n+            Obj_Type := Get_Full_View (Non_Limited_View (Obj_Type));\n          end if;\n \n          --  If the object is not tagged, or the type is still an incomplete\n@@ -5720,11 +5770,65 @@ package body Sem_Ch4 is\n \n          Success     : Boolean   := False;\n \n+         function Collect_Generic_Type_Ops (T : Entity_Id) return Elist_Id;\n+         --  For tagged types the candidate interpretations are found in\n+         --  the list of primitive operations of the type and its ancestors.\n+         --  For formal tagged types we have to find the operations declared\n+         --  in the same scope as the type (including in the generic formal\n+         --  part) because the type itself carries no primitive operations,\n+         --  except for formal derived types that inherit the operations of\n+         --  the parent and progenitors.\n+\n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n          --  controlling argument in a call to Op. The remaining actuals\n          --  are checked in the subsequent call to Analyze_One_Call.\n \n+         ------------------------------\n+         -- Collect_Generic_Type_Ops --\n+         ------------------------------\n+\n+         function Collect_Generic_Type_Ops (T : Entity_Id) return Elist_Id is\n+            Bas        : constant Entity_Id := Base_Type (T);\n+            Candidates : constant Elist_Id := New_Elmt_List;\n+            Subp       : Entity_Id;\n+            Formal     : Entity_Id;\n+\n+         begin\n+            if Is_Derived_Type (T) then\n+               return Primitive_Operations (T);\n+\n+            else\n+               --  Scan the list of entities declared in the same scope as\n+               --  the type. In general this will be an open scope, given that\n+               --  the call we are analyzing can only appear within a generic\n+               --  declaration or body (either the one that declares T, or a\n+               --  child unit).\n+\n+               Subp := First_Entity (Scope (T));\n+               while Present (Subp) loop\n+                  if Is_Overloadable (Subp) then\n+                     Formal := First_Formal (Subp);\n+\n+                     if Present (Formal)\n+                       and then Is_Controlling_Formal (Formal)\n+                       and then\n+                         (Base_Type (Etype (Formal)) = Bas\n+                           or else\n+                            (Is_Access_Type (Etype (Formal))\n+                              and then Designated_Type (Etype (Formal)) = Bas))\n+                     then\n+                        Append_Elmt (Subp, Candidates);\n+                     end if;\n+                  end if;\n+\n+                  Next_Entity (Subp);\n+               end loop;\n+\n+               return Candidates;\n+            end if;\n+         end Collect_Generic_Type_Ops;\n+\n          -----------------------------\n          -- Valid_First_Argument_Of --\n          -----------------------------\n@@ -5767,9 +5871,14 @@ package body Sem_Ch4 is\n          if Is_Concurrent_Type (Obj_Type) then\n             Corr_Type := Corresponding_Record_Type (Obj_Type);\n             Elmt := First_Elmt (Primitive_Operations (Corr_Type));\n-         else\n+\n+         elsif not Is_Generic_Type (Obj_Type) then\n             Corr_Type := Obj_Type;\n             Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n+\n+         else\n+            Corr_Type := Obj_Type;\n+            Elmt := First_Elmt (Collect_Generic_Type_Ops (Obj_Type));\n          end if;\n \n          while Present (Elmt) loop"}]}