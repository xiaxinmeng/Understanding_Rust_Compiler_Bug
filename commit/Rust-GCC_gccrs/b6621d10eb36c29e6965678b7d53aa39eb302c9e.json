{"sha": "b6621d10eb36c29e6965678b7d53aa39eb302c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2MjFkMTBlYjM2YzI5ZTY5NjU2NzhiN2Q1M2FhMzllYjMwMmM5ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:56:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:56:02Z"}, "message": "[multiple changes]\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch8.adb (Build_Class_Wide_Wrapper): Handle various special\n\tcases related to equality.  Remove the special processing\n\tfor dispatching abstract subprograms as it is not needed.\n\t(Interpretation_Error): Add a specialized error message for\n\tpredefined operators.\n\t(Is_Intrinsic_Equality): New routine.\n\t(Is_Suitable_Candidate): New routine.\n\n2014-08-04  Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.adb: Minor comment reformatting.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* restrict.adb (Check_Restriction): For checked max_parameter\n\trestrictions reset Violated flag, so that subsequent violations\n\tare properly detected.\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb (Check_Initialization): Fix bad test of GNATprove\n\tmode.\n\t(Process_Discriminants): Fix bad test of GNATprove mode\n\n2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch12.adb (Instantiate_Formal_Subprogram):\n\tMove variable to their own section. Propagate the source\n\tlocation of a formal parameter to the corresponding formal of\n\tthe subprogram renaming declaration. Code reformatting.\n\nFrom-SVN: r213533", "tree": {"sha": "efe344255a63d56e3dba5fcc3694838761f249e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe344255a63d56e3dba5fcc3694838761f249e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6621d10eb36c29e6965678b7d53aa39eb302c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6621d10eb36c29e6965678b7d53aa39eb302c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6621d10eb36c29e6965678b7d53aa39eb302c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6621d10eb36c29e6965678b7d53aa39eb302c9e/comments", "author": null, "committer": null, "parents": [{"sha": "f5655e4a9433c8a865b36eb098fb2315d7621855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5655e4a9433c8a865b36eb098fb2315d7621855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5655e4a9433c8a865b36eb098fb2315d7621855"}], "stats": {"total": 262, "additions": 173, "deletions": 89}, "files": [{"sha": "a979ec7424e8deb5af81e770775ae9f74c7256eb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -1,3 +1,36 @@\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch8.adb (Build_Class_Wide_Wrapper): Handle various special\n+\tcases related to equality.  Remove the special processing\n+\tfor dispatching abstract subprograms as it is not needed.\n+\t(Interpretation_Error): Add a specialized error message for\n+\tpredefined operators.\n+\t(Is_Intrinsic_Equality): New routine.\n+\t(Is_Suitable_Candidate): New routine.\n+\n+2014-08-04  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* checks.adb: Minor comment reformatting.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* restrict.adb (Check_Restriction): For checked max_parameter\n+\trestrictions reset Violated flag, so that subsequent violations\n+\tare properly detected.\n+\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Initialization): Fix bad test of GNATprove\n+\tmode.\n+\t(Process_Discriminants): Fix bad test of GNATprove mode\n+\n+2014-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch12.adb (Instantiate_Formal_Subprogram):\n+\tMove variable to their own section. Propagate the source\n+\tlocation of a formal parameter to the corresponding formal of\n+\tthe subprogram renaming declaration. Code reformatting.\n+\n 2014-08-04  Arnaud Charlet  <charlet@adacore.com>\n \n \t* g-trasym-vms-ia64.adb, g-trasym-vms-alpha.adb: Removed."}, {"sha": "f41df5466b746176fbc198990caf77e6e244bfc0", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -6407,25 +6407,24 @@ package body Checks is\n       --  a temporary. Then check the converted value against the range of the\n       --  target subtype.\n \n-      procedure Convert_And_Check_Range is\n-         --  To what does the following comment belong???\n-         --  We make a temporary to hold the value of the converted value\n-         --  (converted to the base type), and then we will do the test against\n-         --  this temporary.\n-         --\n-         --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n-         --     [constraint_error when Tnn not in Target_Type]\n-         --\n-         --  The conversion itself is replaced by an occurrence of Tnn\n+      -----------------------------\n+      -- Convert_And_Check_Range --\n+      -----------------------------\n \n+      procedure Convert_And_Check_Range is\n          Tnn : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n \n-         --  To what does the following comment belong???\n-         --  Follow the conversion with the explicit range check. Note that we\n-         --  suppress checks for this code, since we don't want a recursive\n+      begin\n+         --  We make a temporary to hold the value of the converted value\n+         --  (converted to the base type), and then do the test against this\n+         --  temporary. The conversion itself is replaced by an occurrence of\n+         --  Tnn and followed by the explicit range check. Note that checks\n+         --  are suppressed for this code, since we don't want a recursive\n          --  range check popping up.\n \n-      begin\n+         --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n+         --     [constraint_error when Tnn not in Target_Type]\n+\n          Insert_Actions (N, New_List (\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Tnn,"}, {"sha": "9b8e2c62e34d40afcd57122fa2461fcba5ce2734", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -562,6 +562,7 @@ package body Restrict is\n \n       if R in Checked_Max_Parameter_Restrictions then\n          Restrictions.Count (R) := 0;\n+         Restrictions.Violated (R) := False;\n       end if;\n    end Check_Restriction;\n "}, {"sha": "ee40fc84dc748f458b99bca4b72450ee4ecc02e9", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -9454,14 +9454,10 @@ package body Sem_Ch12 is\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id) return Node_Id\n    is\n-      Loc        : Source_Ptr;\n-      Formal_Sub : constant Entity_Id :=\n-                     Defining_Unit_Name (Specification (Formal));\n       Analyzed_S : constant Entity_Id :=\n                      Defining_Unit_Name (Specification (Analyzed_Formal));\n-      Decl_Node  : Node_Id;\n-      Nam        : Node_Id;\n-      New_Spec   : Node_Id;\n+      Formal_Sub : constant Entity_Id :=\n+                     Defining_Unit_Name (Specification (Formal));\n \n       function From_Parent_Scope (Subp : Entity_Id) return Boolean;\n       --  If the generic is a child unit, the parent has been installed on the\n@@ -9528,9 +9524,15 @@ package body Sem_Ch12 is\n            (\"expect subprogram or entry name in instantiation of&\",\n             Instantiation_Node, Formal_Sub);\n          Abandon_Instantiation (Instantiation_Node);\n-\n       end Valid_Actual_Subprogram;\n \n+      --  Local variables\n+\n+      Decl_Node  : Node_Id;\n+      Loc        : Source_Ptr;\n+      Nam        : Node_Id;\n+      New_Spec   : Node_Id;\n+\n    --  Start of processing for Instantiate_Formal_Subprogram\n \n    begin\n@@ -9547,18 +9549,21 @@ package body Sem_Ch12 is\n       Set_Defining_Unit_Name\n         (New_Spec, Make_Defining_Identifier (Loc, Chars (Formal_Sub)));\n \n-      --  Create new entities for the each of the formals in the\n-      --  specification of the renaming declaration built for the actual.\n+      --  Create new entities for the each of the formals in the specification\n+      --  of the renaming declaration built for the actual.\n \n       if Present (Parameter_Specifications (New_Spec)) then\n          declare\n-            F : Node_Id;\n+            F    : Node_Id;\n+            F_Id : Entity_Id;\n+\n          begin\n             F := First (Parameter_Specifications (New_Spec));\n             while Present (F) loop\n+               F_Id := Defining_Identifier (F);\n+\n                Set_Defining_Identifier (F,\n-                  Make_Defining_Identifier (Sloc (F),\n-                    Chars => Chars (Defining_Identifier (F))));\n+                  Make_Defining_Identifier (Sloc (F_Id), Chars (F_Id)));\n                Next (F);\n             end loop;\n          end;\n@@ -9607,9 +9612,10 @@ package body Sem_Ch12 is\n          --  identifier or operator with the same name as the formal.\n \n          if Nkind (Formal_Sub) = N_Defining_Operator_Symbol then\n-            Nam := Make_Operator_Symbol (Loc,\n-              Chars =>  Chars (Formal_Sub),\n-              Strval => No_String);\n+            Nam :=\n+              Make_Operator_Symbol (Loc,\n+                Chars  => Chars (Formal_Sub),\n+                Strval => No_String);\n          else\n             Nam := Make_Identifier (Loc, Chars (Formal_Sub));\n          end if;\n@@ -9656,9 +9662,7 @@ package body Sem_Ch12 is\n       --  instance. If overloaded, it will be resolved when analyzing the\n       --  renaming declaration.\n \n-      if Box_Present (Formal)\n-        and then No (Actual)\n-      then\n+      if Box_Present (Formal) and then No (Actual) then\n          Analyze (Nam);\n \n          if Is_Child_Unit (Scope (Analyzed_S))"}, {"sha": "f4983035fd109ae97999387942c6b716b2a7239a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -10377,7 +10377,7 @@ package body Sem_Ch3 is\n       --  In gnatc or gnatprove mode, make sure set Do_Range_Check flag gets\n       --  set unless we can be sure that no range check is required.\n \n-      if (not Expander_Active and not GNATprove_Mode)\n+      if (GNATprove_Mode or not Expander_Active)\n         and then Is_Scalar_Type (T)\n         and then not Is_In_Range (Exp, T, Assume_Valid => True)\n       then\n@@ -18092,7 +18092,7 @@ package body Sem_Ch3 is\n             --  In gnatc or gnatprove mode, make sure set Do_Range_Check flag\n             --  gets set unless we can be sure that no range check is required.\n \n-            if (not Expander_Active and not GNATprove_Mode)\n+            if (GNATprove_Mode or not Expander_Active)\n               and then not\n                 Is_In_Range\n                   (Expression (Discr), Discr_Type, Assume_Valid => True)"}, {"sha": "97518b3148243972d5f96a70c0ba1fc9933b5221", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6621d10eb36c29e6965678b7d53aa39eb302c9e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=b6621d10eb36c29e6965678b7d53aa39eb302c9e", "patch": "@@ -1918,6 +1918,14 @@ package body Sem_Ch8 is\n          --  Emit a continuation error message suggesting subprogram Subp_Id as\n          --  a possible interpretation.\n \n+         function Is_Intrinsic_Equality (Subp_Id : Entity_Id) return Boolean;\n+         --  Determine whether subprogram Subp_Id denotes the intrinsic \"=\"\n+         --  operator.\n+\n+         function Is_Suitable_Candidate (Subp_Id : Entity_Id) return Boolean;\n+         --  Determine whether subprogram Subp_Id is a suitable candidate for\n+         --  the role of a wrapped subprogram.\n+\n          ----------------\n          -- Build_Call --\n          ----------------\n@@ -2087,25 +2095,70 @@ package body Sem_Ch8 is\n          procedure Interpretation_Error (Subp_Id : Entity_Id) is\n          begin\n             Error_Msg_Sloc := Sloc (Subp_Id);\n-            Error_Msg_NE\n-              (\"\\\\possible interpretation: & defined #\", Spec, Formal_Spec);\n+\n+            if Is_Internal (Subp_Id) then\n+               Error_Msg_NE\n+                 (\"\\\\possible interpretation: predefined & #\",\n+                  Spec, Formal_Spec);\n+            else\n+               Error_Msg_NE\n+                 (\"\\\\possible interpretation: & defined #\", Spec, Formal_Spec);\n+            end if;\n          end Interpretation_Error;\n \n+         ---------------------------\n+         -- Is_Intrinsic_Equality --\n+         ---------------------------\n+\n+         function Is_Intrinsic_Equality (Subp_Id : Entity_Id) return Boolean is\n+         begin\n+            return\n+              Ekind (Subp_Id) = E_Operator\n+                and then Chars (Subp_Id) = Name_Op_Eq\n+                and then Is_Intrinsic_Subprogram (Subp_Id);\n+         end Is_Intrinsic_Equality;\n+\n+         ---------------------------\n+         -- Is_Suitable_Candidate --\n+         ---------------------------\n+\n+         function Is_Suitable_Candidate (Subp_Id : Entity_Id) return Boolean is\n+         begin\n+            if No (Subp_Id) then\n+               return False;\n+\n+            --  An intrinsic subprogram is never a good candidate. This is an\n+            --  indication of a missing primitive, either defined directly or\n+            --  inherited from a parent tagged type.\n+\n+            elsif Is_Intrinsic_Subprogram (Subp_Id) then\n+               return False;\n+\n+            else\n+               return True;\n+            end if;\n+         end Is_Suitable_Candidate;\n+\n          --  Local variables\n \n          Actual_Typ : Entity_Id := Empty;\n          --  The actual class-wide type for Formal_Typ\n \n+         CW_Prim_OK : Boolean;\n          CW_Prim_Op : Entity_Id;\n-         --  The class-wide primitive (if any) which corresponds to the renamed\n-         --  generic formal subprogram.\n+         --  The class-wide subprogram (if available) which corresponds to the\n+         --  renamed generic formal subprogram.\n \n          Formal_Typ : Entity_Id := Empty;\n-         --  The generic formal type (if any) with unknown discriminants\n+         --  The generic formal type with unknown discriminants\n \n+         Root_Prim_OK : Boolean;\n          Root_Prim_Op : Entity_Id;\n-         --  The root type primitive (if any) which corresponds to the renamed\n-         --  generic formal subprogram.\n+         --  The root type primitive (if available) which corresponds to the\n+         --  renamed generic formal subprogram.\n+\n+         Root_Typ : Entity_Id := Empty;\n+         --  The root type of Actual_Typ\n \n          Body_Decl : Node_Id;\n          Formal    : Node_Id;\n@@ -2128,10 +2181,19 @@ package body Sem_Ch8 is\n          end if;\n \n          --  Analyze the renamed name, but do not resolve it. The resolution is\n-         --  completed once a suitable primitive is found.\n+         --  completed once a suitable subprogram is found.\n \n          Analyze (Nam);\n \n+         --  When the renamed name denotes the intrinsic operator equals, the\n+         --  name must be treated as overloaded. This allows for a potential\n+         --  match against the root type's predefined equality function.\n+\n+         if Is_Intrinsic_Equality (Entity (Nam)) then\n+            Set_Is_Overloaded (Nam);\n+            Collect_Interps   (Nam);\n+         end if;\n+\n          --  Step 1: Find the generic formal type with unknown discriminants\n          --  and its corresponding class-wide actual type from the renamed\n          --  generic formal subprogram.\n@@ -2144,6 +2206,7 @@ package body Sem_Ch8 is\n             then\n                Formal_Typ := Etype (Formal);\n                Actual_Typ := Get_Instance_Of (Formal_Typ);\n+               Root_Typ   := Etype (Actual_Typ);\n                exit;\n             end if;\n \n@@ -2157,86 +2220,70 @@ package body Sem_Ch8 is\n \n          pragma Assert (Present (Formal_Typ));\n \n-         --  Step 2: Find the proper primitive which corresponds to the renamed\n-         --  generic formal subprogram.\n+         --  Step 2: Find the proper class-wide subprogram or primitive which\n+         --  corresponds to the renamed generic formal subprogram.\n \n          CW_Prim_Op   := Find_Primitive (Actual_Typ);\n-         Root_Prim_Op := Find_Primitive (Etype (Actual_Typ));\n+         CW_Prim_OK   := Is_Suitable_Candidate (CW_Prim_Op);\n+         Root_Prim_Op := Find_Primitive (Root_Typ);\n+         Root_Prim_OK := Is_Suitable_Candidate (Root_Prim_Op);\n \n-         --  The class-wide actual type has two primitives which correspond to\n+         --  The class-wide actual type has two subprograms which correspond to\n          --  the renamed generic formal subprogram:\n \n          --    with procedure Prim_Op (Param : Formal_Typ);\n \n          --    procedure Prim_Op (Param : Actual_Typ);  --  may be inherited\n          --    procedure Prim_Op (Param : Actual_Typ'Class);\n \n-         --  Even though the declaration of the two primitives is legal, a call\n-         --  to either one is ambiguous and therefore illegal.\n+         --  Even though the declaration of the two subprograms is legal, a\n+         --  call to either one is ambiguous and therefore illegal.\n \n-         if Present (CW_Prim_Op) and then Present (Root_Prim_Op) then\n+         if CW_Prim_OK and Root_Prim_OK then\n \n-            --  Deal with abstract primitives\n+            --  A user-defined primitive has precedence over a predefined one\n \n-            if Is_Abstract_Subprogram (CW_Prim_Op)\n-              or else Is_Abstract_Subprogram (Root_Prim_Op)\n+            if Is_Internal (CW_Prim_Op)\n+              and then not Is_Internal (Root_Prim_Op)\n             then\n-               --  An abstract subprogram cannot act as a generic actual, but\n-               --  the partial parameterization of the instance may hide the\n-               --  true nature of the actual. Emit an error when both options\n-               --  are abstract.\n-\n-               if Is_Abstract_Subprogram (CW_Prim_Op)\n-                 and then Is_Abstract_Subprogram (Root_Prim_Op)\n-               then\n-                  Error_Msg_NE\n-                    (\"abstract subprogram not allowed as generic actual\",\n-                     Spec, Formal_Spec);\n-                  Interpretation_Error (CW_Prim_Op);\n-                  Interpretation_Error (Root_Prim_Op);\n-                  return;\n-\n-               --  Otherwise choose the non-abstract version\n-\n-               elsif Is_Abstract_Subprogram (Root_Prim_Op) then\n-                  Prim_Op := CW_Prim_Op;\n-\n-               else pragma Assert (Is_Abstract_Subprogram (CW_Prim_Op));\n-                  Prim_Op := Root_Prim_Op;\n-               end if;\n-\n-            --  If one of the candidate primitives is intrinsic, choose the\n-            --  other (which may also be intrinsic). Preference is given to\n-            --  the primitive of the root type.\n-\n-            elsif Is_Intrinsic_Subprogram (CW_Prim_Op) then\n                Prim_Op := Root_Prim_Op;\n \n-            elsif Is_Intrinsic_Subprogram (Root_Prim_Op) then\n+            elsif Is_Internal (Root_Prim_Op)\n+              and then not Is_Internal (CW_Prim_Op)\n+            then\n                Prim_Op := CW_Prim_Op;\n \n             elsif CW_Prim_Op = Root_Prim_Op then\n                Prim_Op := Root_Prim_Op;\n \n-            --  Otherwise there are two perfectly good candidates which satisfy\n-            --  the profile of the renamed generic formal subprogram.\n+            --  Otherwise both candidate subprograms are user-defined and\n+            --  ambiguous.\n \n             else\n                Error_Msg_NE\n                  (\"ambiguous actual for generic subprogram &\",\n-                   Spec, Formal_Spec);\n-               Interpretation_Error (CW_Prim_Op);\n+                  Spec, Formal_Spec);\n                Interpretation_Error (Root_Prim_Op);\n+               Interpretation_Error (CW_Prim_Op);\n                return;\n             end if;\n \n-         elsif Present (CW_Prim_Op) then\n+         elsif CW_Prim_OK and not Root_Prim_OK then\n             Prim_Op := CW_Prim_Op;\n \n-         elsif Present (Root_Prim_Op) then\n+         elsif not CW_Prim_OK and Root_Prim_OK then\n+            Prim_Op := Root_Prim_Op;\n+\n+         --  An intrinsic equality may act as a suitable candidate in the case\n+         --  of a null type extension where the parent's equality is hidden. A\n+         --  call to an intrinsic equality is expanded as dispatching.\n+\n+         elsif Present (Root_Prim_Op)\n+           and then Is_Intrinsic_Equality (Root_Prim_Op)\n+         then\n             Prim_Op := Root_Prim_Op;\n \n-         --  Otherwise there are no candidate primitives. Let the caller\n+         --  Otherwise there are no candidate subprograms. Let the caller\n          --  diagnose the error.\n \n          else"}]}