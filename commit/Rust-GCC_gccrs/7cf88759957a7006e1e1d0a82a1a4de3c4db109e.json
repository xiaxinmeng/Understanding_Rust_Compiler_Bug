{"sha": "7cf88759957a7006e1e1d0a82a1a4de3c4db109e", "node_id": "C_kwDOANBUbNoAKDdjZjg4NzU5OTU3YTcwMDZlMWUxZDBhODJhMWE0ZGUzYzRkYjEwOWU", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-12T15:48:31Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-04-12T21:38:31Z"}, "message": "libstdc++: Use allocator to construct std::stacktrace_entry objects\n\nBecause std::basic_stacktrace<A> is an allocator-aware container its\nelements should be initialized using allocator_traits<A>::construct and\ndestroyed using allocator_traits<A>::destroy.\n\nThis adds new _M_clone and _M_assign helper functions to construct\nelements correctly and uses those functions instead of calling\nstd::uninitialized_copy_n.\n\nThe _Impl::_M_destroy function needs to be passed an allocator to\ndestroy the elements correctly, so is replaced by _M_resize which can\nalso be used to trim the container to a smaller size.\n\nBecause destroying and creating std::stacktrace_entry objects is cheap,\nthe copy/move assignment operators can just destroy all existing\nelements and use _Impl._M_clone or _Impl._M_assign to create new ones.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/stacktrace (basic_stacktrace): Use _Impl::_M_clone\n\tor _Impl::_M_assign to initialize elements in allocated storage.\n\t(basic_stacktrace::_M_clear()): Use _Impl::_M_resize instead of\n\t_Impl::_M_destroy.\n\t(basic_stacktrace::_Impl::_M_destroy()): Replace with ...\n\t(basic_stacktrace::_Impl::_M_resize(size_type, allocator&)): New\n\tfunction.\n\t(basic_stacktrace::_Impl::_M_push_back): Use _M_xclone. Construct\n\tnew element using allocator.\n\t(basic_stacktrace::_Impl::_M_clone): New function.\n\t(basic_stacktrace::_Impl::_M_xclone): New function.\n\t(basic_stacktrace::_Impl::_M_assign): New function.", "tree": {"sha": "b29b455818f1ac45dfd8f354e3f53d49e64db0b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b29b455818f1ac45dfd8f354e3f53d49e64db0b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cf88759957a7006e1e1d0a82a1a4de3c4db109e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cf88759957a7006e1e1d0a82a1a4de3c4db109e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cf88759957a7006e1e1d0a82a1a4de3c4db109e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cf88759957a7006e1e1d0a82a1a4de3c4db109e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e48933f00d676658ad065d9691a1b61446745386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48933f00d676658ad065d9691a1b61446745386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48933f00d676658ad065d9691a1b61446745386"}], "stats": {"total": 92, "additions": 47, "deletions": 45}, "files": [{"sha": "382d900a822fe09f1c52c1a59d5b5364e9b686d3", "filename": "libstdc++-v3/include/std/stacktrace", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cf88759957a7006e1e1d0a82a1a4de3c4db109e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cf88759957a7006e1e1d0a82a1a4de3c4db109e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstacktrace?ref=7cf88759957a7006e1e1d0a82a1a4de3c4db109e", "patch": "@@ -289,7 +289,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__err < 0)\n \t      __ret._M_clear();\n \t    else if (__ret.size() > __max_depth)\n-\t      __ret._M_impl._M_size = __max_depth;\n+\t      __ret._M_impl._M_resize(__max_depth, __ret._M_alloc);\n \t  }\n \treturn __ret;\n       }\n@@ -318,11 +318,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_alloc(__alloc)\n       {\n \tif (const auto __s = __other._M_impl._M_size)\n-\t  if (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n-\t    {\n-\t      std::uninitialized_copy_n(__other.begin(), __s, __f);\n-\t      _M_impl._M_size = __s;\n-\t    }\n+\t  _M_impl = __other._M_impl._M_clone(_M_alloc);\n       }\n \n       basic_stacktrace(basic_stacktrace&& __other,\n@@ -334,11 +330,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \telse if (_M_alloc == __other._M_alloc)\n \t  _M_impl = std::__exchange(__other._M_impl, {});\n \telse if (const auto __s = __other._M_impl._M_size)\n-\t  if (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n-\t    {\n-\t      std::uninitialized_copy_n(__other.begin(), __s, __f);\n-\t      _M_impl._M_size = __s;\n-\t    }\n+\t  _M_impl = __other._M_impl._M_clone(_M_alloc);\n       }\n \n       basic_stacktrace&\n@@ -370,19 +362,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if constexpr (__pocca)\n \t      _M_alloc = __other._M_alloc;\n \n-\t    if (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n-\t      {\n-\t\tstd::uninitialized_copy_n(__other.begin(), __s, __f);\n-\t\t_M_impl._M_size = __s;\n-\t      }\n+\t    _M_impl = __other._M_impl._M_clone(_M_alloc);\n \t  }\n \telse\n \t  {\n-\t    // Current storage is large enough and can be freed by whichever\n-\t    // allocator we will have after this function returns.\n-\t    auto __to = std::copy_n(__other.begin(), __s, begin());\n-\t    std::destroy(__to, end());\n-\t    _M_impl._M_size = __s;\n+\t    // Current storage is large enough.\n+\t    _M_impl._M_resize(0, _M_alloc);\n+\t    _M_impl._M_assign(__other._M_impl, _M_alloc);\n \n \t    if constexpr (__pocca)\n \t      _M_alloc = __other._M_alloc;\n@@ -418,23 +404,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      {\n \t\t// Need to allocate new storage.\n \t\t_M_clear();\n-\n-\t\tif (auto __f = _M_impl._M_allocate(_M_alloc, __s))\n-\t\t  {\n-\t\t    std::uninitialized_copy_n(__other.begin(), __s, __f);\n-\t\t    _M_impl._M_size = __s;\n-\t\t  }\n+\t\t_M_impl = __other._M_impl._M_clone(_M_alloc);\n \t      }\n \t    else\n \t      {\n \t\t// Current storage is large enough.\n-\t\tauto __first = __other.begin();\n-\t\tauto __mid = __first + std::min(__s, _M_impl._M_size);\n-\t\tauto __last = __other.end();\n-\t\tauto __to = std::copy(__first, __mid, begin());\n-\t\t__to = std::uninitialized_copy(__mid, __last, __to);\n-\t\tstd::destroy(__to, end());\n-\t\t_M_impl._M_size = __s;\n+\t\t_M_impl._M_resize(0, _M_alloc);\n+\t\t_M_impl._M_assign(__other._M_impl, _M_alloc);\n \t      }\n \t  }\n \n@@ -527,7 +503,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n     private:\n-      // Precondition: _M_capacity != 0\n       bool\n       _M_push_back(const value_type& __x) noexcept\n       {\n@@ -537,7 +512,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_clear() noexcept\n       {\n-\t_M_impl._M_destroy();\n+\t_M_impl._M_resize(0, _M_alloc);\n \t_M_impl._M_deallocate(_M_alloc);\n       }\n \n@@ -647,32 +622,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #undef _GLIBCXX_OPERATOR_DELETE\n #undef _GLIBCXX_OPERATOR_NEW\n \n+\t// Precondition: __n <= _M_size\n \tvoid\n-\t_M_destroy() noexcept\n+\t_M_resize(size_type __n, allocator_type& __alloc) noexcept\n \t{\n-\t  std::destroy_n(_M_frames, _M_size);\n-\t  _M_size = 0;\n+\t  for (size_type __i = __n; __i < _M_size; ++__i)\n+\t    _AllocTraits::destroy(__alloc, &_M_frames[__i]);\n+\t  _M_size = __n;\n \t}\n \n-\t// Precondition: _M_capacity != 0\n \tbool\n \t_M_push_back(allocator_type& __alloc,\n \t\t     const stacktrace_entry& __f) noexcept\n \t{\n \t  if (_M_size == _M_capacity) [[unlikely]]\n \t    {\n-\t      _Impl __tmp;\n-\t      if (auto __f = __tmp._M_allocate(__alloc, _M_capacity * 2))\n-\t\tstd::uninitialized_copy_n(_M_frames, _M_size, __f);\n-\t      else\n+\t      _Impl __tmp = _M_xclone(_M_capacity ? _M_capacity : 8, __alloc);\n+\t      if (!__tmp._M_capacity) [[unlikely]]\n \t\treturn false;\n+\t      _M_resize(0, __alloc);\n \t      _M_deallocate(__alloc);\n \t      *this = __tmp;\n \t    }\n \t  stacktrace_entry* __addr = std::to_address(_M_frames + _M_size++);\n-\t  std::construct_at(__addr, __f);\n+\t  _AllocTraits::construct(__alloc, __addr, __f);\n \t  return true;\n \t}\n+\n+\t// Precondition: _M_size != 0\n+\t_Impl\n+\t_M_clone(allocator_type& __alloc) const noexcept\n+\t{\n+\t  return _M_xclone(_M_size, __alloc);\n+\t}\n+\n+\t// Precondition: _M_size != 0 || __extra != 0\n+\t_Impl\n+\t_M_xclone(size_type __extra, allocator_type& __alloc) const noexcept\n+\t{\n+\t  _Impl __i;\n+\t  if (__i._M_allocate(__alloc, _M_size + __extra)) [[likely]]\n+\t    __i._M_assign(*this, __alloc);\n+\t  return __i;\n+\t}\n+\n+\t// Precondition: _M_capacity >= __other._M_size\n+\tvoid\n+\t_M_assign(const _Impl& __other, allocator_type& __alloc) noexcept\n+\t{\n+\t  std::__uninitialized_copy_a(__other._M_frames,\n+\t\t\t\t      __other._M_frames + __other._M_size,\n+\t\t\t\t      _M_frames, __alloc);\n+\t  _M_size = __other._M_size;\n+\t}\n       };\n \n       [[no_unique_address]] allocator_type  _M_alloc{};"}]}