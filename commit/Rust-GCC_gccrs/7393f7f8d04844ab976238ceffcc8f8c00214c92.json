{"sha": "7393f7f8d04844ab976238ceffcc8f8c00214c92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM5M2Y3ZjhkMDQ4NDRhYjk3NjIzOGNlZmZjYzhmOGMwMDIxNGM5Mg==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2007-03-02T15:57:08Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2007-03-02T15:57:08Z"}, "message": "dfp.md: New file.\n\n\t* config/rs6000/dfp.md: New file.\n\t* config/rs6000/rs6000.md: Include dfp.md.\n\t(add<mode>3_internal1): Disable for DECIMAL_FLOAT_MODE_P operands.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Handle DDmode\n\tand TDmode decimal float modes in FP registers.\n\t(num_insns_constant): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_legitimate_address): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(function_arg_boundary): Likewise.\n\t(function_arg_advance): Likewise.\n\t(rs6000_darwin64_record_arg_recurse): Likewise.\n\t(function_arg): Likewise.\n\t(rs6000_gimplify_va_arg): Likewise.\n\t(rs6000_split_multireg_move): Likewise.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(rs6000_output_function_epilogue): Likewise.\n\t(rs6000_register_move_cost): Likewise.\n\t(rs6000_function_value): Likewise.\n\t(rs6000_libcall_value): Likewise.\n\nCo-Authored-By: Janis Johnson <janis187@us.ibm.com>\nCo-Authored-By: Peter Bergner <bergner@vnet.ibm.com>\n\nFrom-SVN: r122477", "tree": {"sha": "5e2ec5ca1190c689a7fd6cc8b35ad025ff4c9a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e2ec5ca1190c689a7fd6cc8b35ad025ff4c9a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7393f7f8d04844ab976238ceffcc8f8c00214c92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7393f7f8d04844ab976238ceffcc8f8c00214c92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7393f7f8d04844ab976238ceffcc8f8c00214c92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7393f7f8d04844ab976238ceffcc8f8c00214c92/comments", "author": null, "committer": null, "parents": [{"sha": "0fa4c370260d5edba1ea59a11c0ccf905eff510c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa4c370260d5edba1ea59a11c0ccf905eff510c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa4c370260d5edba1ea59a11c0ccf905eff510c"}], "stats": {"total": 487, "additions": 457, "deletions": 30}, "files": [{"sha": "29df5e2f5f4551d667206f85e8a13003d087d6d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7393f7f8d04844ab976238ceffcc8f8c00214c92", "patch": "@@ -1,3 +1,30 @@\n+2007-03-02  Ben Elliston  <bje@au.ibm.com>\n+\t    Peter Bergner  <bergner@vnet.ibm.com>\n+\t    Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* config/rs6000/dfp.md: New file.\n+\t* config/rs6000/rs6000.md: Include dfp.md.\n+\t(add<mode>3_internal1): Disable for DECIMAL_FLOAT_MODE_P operands.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Handle DDmode\n+\tand TDmode decimal float modes in FP registers.\n+\t(num_insns_constant): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_legitimize_reload_address): Likewise.\n+\t(rs6000_legitimate_address): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(function_arg_boundary): Likewise.\n+\t(function_arg_advance): Likewise.\n+\t(rs6000_darwin64_record_arg_recurse): Likewise.\n+\t(function_arg): Likewise.\n+\t(rs6000_gimplify_va_arg): Likewise.\n+\t(rs6000_split_multireg_move): Likewise.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(rs6000_output_function_epilogue): Likewise.\n+\t(rs6000_register_move_cost): Likewise.\n+\t(rs6000_function_value): Likewise.\n+\t(rs6000_libcall_value): Likewise.\n+\n 2007-03-02  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/t-vxworks (LIMITS_H_TEST): Define to true for VxWorks."}, {"sha": "28f7b93eef15a8aaa76ca9ce103e2ee5b32980d3", "filename": "gcc/config/rs6000/dfp.md", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Fdfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Fdfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdfp.md?ref=7393f7f8d04844ab976238ceffcc8f8c00214c92", "patch": "@@ -0,0 +1,316 @@\n+;; Decimal Floating Point (DFP) patterns.\n+;; Copyright (C) 2007\n+;; Free Software Foundation, Inc.\n+;; Contributed by Ben Elliston (bje@au.ibm.com) and Peter Bergner\n+;; (bergner@vnet.ibm.com).\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the\n+;; Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+;; MA 02110-1301, USA.\n+\n+(define_expand \"movdd\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DD 1 \"any_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], DDmode); DONE; }\")\n+\n+(define_split\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DD 1 \"const_int_operand\" \"\"))]\n+  \"! TARGET_POWERPC64 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 1))]\n+  \"\n+{\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  HOST_WIDE_INT value = INTVAL (operands[1]);\n+\n+  operands[2] = operand_subword (operands[0], endian, 0, DDmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DDmode);\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n+#else\n+  operands[4] = GEN_INT (value >> 32);\n+  operands[1] = GEN_INT (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);\n+#endif\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DD 1 \"const_double_operand\" \"\"))]\n+  \"! TARGET_POWERPC64 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"\n+{\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  long l[2];\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n+\n+  operands[2] = operand_subword (operands[0], endian, 0, DDmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DDmode);\n+  operands[4] = gen_int_mode (l[endian], SImode);\n+  operands[5] = gen_int_mode (l[1 - endian], SImode);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DD 0 \"gpc_reg_operand\" \"\")\n+\t(match_operand:DD 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  long l[2];\n+  REAL_VALUE_TYPE rv;\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  HOST_WIDE_INT val;\n+#endif\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n+\n+  operands[2] = gen_lowpart (DImode, operands[0]);\n+  /* HIGHPART is lower memory address when WORDS_BIG_ENDIAN.  */\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  val = ((HOST_WIDE_INT)(unsigned long)l[endian] << 32\n+\t | ((HOST_WIDE_INT)(unsigned long)l[1 - endian]));\n+\n+  operands[3] = gen_int_mode (val, DImode);\n+#else\n+  operands[3] = immed_double_const (l[1 - endian], l[endian], DImode);\n+#endif\n+}\")\n+\n+;; Don't have reload use general registers to load a constant.  First,\n+;; it might not work if the output operand is the equivalent of\n+;; a non-offsettable memref, but also it is less efficient than loading\n+;; the constant into an FP register, since it will probably be used there.\n+;; The \"??\" is a kludge until we can figure out a more reasonable way\n+;; of handling these non-offsettable values.\n+(define_insn \"*movdd_hardfloat32\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=!r,??r,m,f,f,m,!r,!r,!r\")\n+\t(match_operand:DD 1 \"input_operand\" \"r,m,r,f,m,f,G,H,F\"))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS\n+   && (gpc_reg_operand (operands[0], DDmode)\n+       || gpc_reg_operand (operands[1], DDmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case 0:\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register\n+\t of operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n+      else\n+\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n+    case 1:\n+      if (rs6000_offsettable_memref_p (operands[1])\n+\t  || (GET_CODE (operands[1]) == MEM\n+\t      && (GET_CODE (XEXP (operands[1], 0)) == LO_SUM\n+\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n+\t\t  || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)))\n+\t{\n+\t  /* If the low-address word is used in the address, we must load\n+\t     it last.  Otherwise, load it first.  Note that we cannot have\n+\t     auto-increment in that case since the address register is\n+\t     known to be dead.  */\n+\t  if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t\t operands[1], 0))\n+\t    return \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n+\t  else\n+\t    return \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n+\t}\n+      else\n+\t{\n+\t  rtx addreg;\n+\n+\t  addreg = find_addr_reg (XEXP (operands[1], 0));\n+\t  if (refers_to_regno_p (REGNO (operands[0]),\n+\t\t\t\t REGNO (operands[0]) + 1,\n+\t\t\t\t operands[1], 0))\n+\t    {\n+\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n+\t      output_asm_insn (\\\"{lx|lwzx} %L0,%1\\\", operands);\n+\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n+\t      return \\\"{lx|lwzx} %0,%1\\\";\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\\\"{lx|lwzx} %0,%1\\\", operands);\n+\t      output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n+\t      output_asm_insn (\\\"{lx|lwzx} %L0,%1\\\", operands);\n+\t      output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n+\t      return \\\"\\\";\n+\t    }\n+\t}\n+    case 2:\n+      if (rs6000_offsettable_memref_p (operands[0])\n+\t  || (GET_CODE (operands[0]) == MEM\n+\t      && (GET_CODE (XEXP (operands[0], 0)) == LO_SUM\n+\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n+\t\t  || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)))\n+\treturn \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+      else\n+\t{\n+\t  rtx addreg;\n+\n+\t  addreg = find_addr_reg (XEXP (operands[0], 0));\n+\t  output_asm_insn (\\\"{stx|stwx} %1,%0\\\", operands);\n+\t  output_asm_insn (\\\"{cal|la} %0,4(%0)\\\", &addreg);\n+\t  output_asm_insn (\\\"{stx|stwx} %L1,%0\\\", operands);\n+\t  output_asm_insn (\\\"{cal|la} %0,-4(%0)\\\", &addreg);\n+\t  return \\\"\\\";\n+\t}\n+    case 3:\n+      return \\\"fmr %0,%1\\\";\n+    case 4:\n+      return \\\"lfd%U1%X1 %0,%1\\\";\n+    case 5:\n+      return \\\"stfd%U0%X0 %1,%0\\\";\n+    case 6:\n+    case 7:\n+    case 8:\n+      return \\\"#\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"two,load,store,fp,fpload,fpstore,*,*,*\")\n+   (set_attr \"length\" \"8,16,16,4,4,4,8,12,16\")])\n+\n+(define_insn \"*movdd_softfloat32\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n+\t(match_operand:DD 1 \"input_operand\" \"r,m,r,G,H,F\"))]\n+  \"! TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n+   && (gpc_reg_operand (operands[0], DDmode)\n+       || gpc_reg_operand (operands[1], DDmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case 0:\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n+      else\n+\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n+    case 1:\n+      /* If the low-address word is used in the address, we must load\n+\t it last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is\n+\t known to be dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], 0))\n+\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n+      else\n+\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n+    case 2:\n+      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+    case 3:\n+    case 4:\n+    case 5:\n+      return \\\"#\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"two,load,store,*,*,*\")\n+   (set_attr \"length\" \"8,8,8,8,12,16\")])\n+\n+; ld/std require word-aligned displacements -> 'Y' constraint.\n+; List Y->r and r->Y before r->r for reload.\n+(define_insn \"*movdd_hardfloat64\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=Y,r,!r,f,f,m,*c*l,!r,*h,!r,!r,!r\")\n+\t(match_operand:DD 1 \"input_operand\" \"r,Y,r,f,m,f,r,h,0,G,H,F\"))]\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS\n+   && (gpc_reg_operand (operands[0], DDmode)\n+       || gpc_reg_operand (operands[1], DDmode))\"\n+  \"@\n+   std%U0%X0 %1,%0\n+   ld%U1%X1 %0,%1\n+   mr %0,%1\n+   fmr %0,%1\n+   lfd%U1%X1 %0,%1\n+   stfd%U0%X0 %1,%0\n+   mt%0 %1\n+   mf%1 %0\n+   {cror 0,0,0|nop}\n+   #\n+   #\n+   #\"\n+  [(set_attr \"type\" \"store,load,*,fp,fpload,fpstore,mtjmpr,mfjmpr,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,12,16\")])\n+\n+(define_insn \"*movdd_softfloat64\"\n+  [(set (match_operand:DD 0 \"nonimmediate_operand\" \"=r,Y,r,cl,r,r,r,r,*h\")\n+\t(match_operand:DD 1 \"input_operand\" \"Y,r,r,r,h,G,H,F,0\"))]\n+  \"TARGET_POWERPC64 && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+   && (gpc_reg_operand (operands[0], DDmode)\n+       || gpc_reg_operand (operands[1], DDmode))\"\n+  \"@\n+   ld%U1%X1 %0,%1\n+   std%U0%X0 %1,%0\n+   mr %0,%1\n+   mt%0 %1\n+   mf%1 %0\n+   #\n+   #\n+   #\n+   {cror 0,0,0|nop}\"\n+  [(set_attr \"type\" \"load,store,*,mtjmpr,mfjmpr,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,8,12,16,4\")])\n+\n+(define_expand \"movtd\"\n+  [(set (match_operand:TD 0 \"general_operand\" \"\")\n+\t(match_operand:TD 1 \"any_operand\" \"\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"{ rs6000_emit_move (operands[0], operands[1], TDmode); DONE; }\")\n+\n+; It's important to list the o->f and f->o moves before f->f because\n+; otherwise reload, given m->f, will try to pick f->f and reload it,\n+; which doesn't make progress.  Likewise r->Y must be before r->r.\n+(define_insn_and_split \"*movtd_internal\"\n+  [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=o,f,f,r,Y,r\")\n+\t(match_operand:TD 1 \"input_operand\"         \"f,o,f,YGHF,r,r\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_FPRS\n+   && (gpc_reg_operand (operands[0], TDmode)\n+       || gpc_reg_operand (operands[1], TDmode))\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+{ rs6000_split_multireg_move (operands[0], operands[1]); DONE; }\n+  [(set_attr \"length\" \"8,8,8,20,20,16\")])\n+"}, {"sha": "f21d5f1d7c3741f4ba36ad72a35f8398ea3e4e89", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 112, "deletions": 29, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7393f7f8d04844ab976238ceffcc8f8c00214c92", "patch": "@@ -1131,11 +1131,11 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     return INT_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1);\n \n   /* The float registers can only hold floating modes and DImode.\n-     This also excludes decimal float modes.  */\n+     This excludes the 32-bit decimal float mode for now.  */\n   if (FP_REGNO_P (regno))\n     return\n       (SCALAR_FLOAT_MODE_P (mode)\n-       && !DECIMAL_FLOAT_MODE_P (mode)\n+       && mode != SDmode\n        && FP_REGNO_P (regno + HARD_REGNO_NREGS (regno, mode) - 1))\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_SIZE (mode) == UNITS_PER_FP_WORD);\n@@ -2314,7 +2314,10 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t    REAL_VALUE_TYPE rv;\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-\t    REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n+\t    if (DECIMAL_FLOAT_MODE_P (mode))\n+\t      REAL_VALUE_TO_TARGET_DECIMAL64 (rv, l);\n+\t    else\n+\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, l);\n \t    high = l[WORDS_BIG_ENDIAN == 0];\n \t    low  = l[WORDS_BIG_ENDIAN != 0];\n \t  }\n@@ -3054,6 +3057,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       return SPE_CONST_OFFSET_OK (offset);\n \n     case DFmode:\n+    case DDmode:\n       if (TARGET_E500_DOUBLE)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n@@ -3066,7 +3070,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       if (TARGET_E500_DOUBLE)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n-      if (mode == DFmode || !TARGET_POWERPC64)\n+      if (mode == DFmode || mode == DDmode || !TARGET_POWERPC64)\n \textra = 4;\n       else if (offset & 3)\n \treturn false;\n@@ -3078,7 +3082,8 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n \t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n \n     case TImode:\n-      if (mode == TFmode || !TARGET_POWERPC64)\n+    case TDmode:\n+      if (mode == TFmode || mode == TDmode || !TARGET_POWERPC64)\n \textra = 12;\n       else if (offset & 3)\n \treturn false;\n@@ -3233,8 +3238,9 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t       || TARGET_POWERPC64\n-\t       || (((mode != DImode && mode != DFmode) || TARGET_E500_DOUBLE)\n-\t\t   && mode != TFmode))\n+\t       || (((mode != DImode && mode != DFmode && mode != DDmode)\n+\t\t    || TARGET_E500_DOUBLE)\n+\t\t   && mode != TFmode && mode != TDmode))\n \t   && (TARGET_POWERPC64 || mode != DImode)\n \t   && mode != TImode)\n     {\n@@ -3255,6 +3261,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     }\n   else if (SPE_VECTOR_MODE (mode)\n \t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t\t      || mode == DDmode || mode == TDmode\n \t\t\t\t      || mode == DImode)))\n     {\n       if (mode == DImode)\n@@ -3700,10 +3707,11 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && DEFAULT_ABI == ABI_V4\n       && !flag_pic\n #endif\n-      /* Don't do this for TFmode, since the result isn't offsettable.\n+      /* Don't do this for TFmode or TDmode, since the result isn't offsettable.\n \t The same goes for DImode without 64-bit gprs and DFmode\n \t without fprs.  */\n       && mode != TFmode\n+      && mode != TDmode\n       && (mode != DImode || TARGET_POWERPC64)\n       && (mode != DFmode || TARGET_POWERPC64\n \t  || (TARGET_FPRS && TARGET_HARD_FLOAT)))\n@@ -3773,8 +3781,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n    word aligned.\n \n    For modes spanning multiple registers (DFmode in 32-bit GPRs,\n-   32-bit DImode, TImode, TFmode), indexed addressing cannot be used because\n-   adjacent memory cells are accessed by adding word-sized offsets\n+   32-bit DImode, TImode, TFmode, TDmode), indexed addressing cannot be used\n+   because adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */\n int\n rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n@@ -3795,6 +3803,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && !ALTIVEC_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n       && mode != TFmode\n+      && mode != TDmode\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n       && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t  || mode == DImode))\n@@ -3817,6 +3826,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n     return 1;\n   if (mode != TImode\n       && mode != TFmode\n+      && mode != TDmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n \t  || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n@@ -4173,7 +4183,7 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n }\n \n /* Helper for the following.  Get rid of [r+r] memory refs\n-   in cases where it won't work (TImode, TFmode).  */\n+   in cases where it won't work (TImode, TFmode, TDmode).  */\n \n static void\n rs6000_eliminate_indexed_memrefs (rtx operands[2])\n@@ -4337,10 +4347,12 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       break;\n \n     case TFmode:\n+    case TDmode:\n       rs6000_eliminate_indexed_memrefs (operands);\n       /* fall through */\n \n     case DFmode:\n+    case DDmode:\n     case SFmode:\n       if (CONSTANT_P (operands[1])\n \t  && ! easy_fp_constant (operands[1], mode))\n@@ -4552,7 +4564,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE,TYPE)\t\t\\\n   (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n-   && !DECIMAL_FLOAT_MODE_P (MODE)\t\t\\\n+   && (MODE) != SDmode\t\t\t\t\\\n    && (CUM)->fregno <= FP_ARG_MAX_REG\t\t\\\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n@@ -4794,7 +4806,7 @@ function_arg_boundary (enum machine_mode mode, tree type)\n       && (GET_MODE_SIZE (mode) == 8\n \t  || (TARGET_HARD_FLOAT\n \t      && TARGET_FPRS\n-\t      && mode == TFmode)))\n+\t      && (mode == TFmode || mode == TDmode))))\n     return 64;\n   else if (SPE_VECTOR_MODE (mode)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n@@ -5032,14 +5044,20 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && (mode == SFmode || mode == DFmode\n+\t      || mode == DDmode || mode == TDmode\n \t      || (mode == TFmode && !TARGET_IEEEQUAD)))\n \t{\n-\t  if (cum->fregno + (mode == TFmode ? 1 : 0) <= FP_ARG_V4_MAX_REG)\n+\t  /* _Decimal128 must use an even/odd register pair.  */\n+\t  if (mode == TDmode && cum->fregno % 2)\n+\t    cum->fregno++;\n+\n+\t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n+\t      <= FP_ARG_V4_MAX_REG)\n \t    cum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \t  else\n \t    {\n \t      cum->fregno = FP_ARG_V4_MAX_REG + 1;\n-\t      if (mode == DFmode || mode == TFmode)\n+\t      if (mode == DFmode || mode == TFmode || mode == DDmode || mode == TDmode)\n \t\tcum->words += cum->words & 1;\n \t      cum->words += rs6000_arg_size (mode, type);\n \t    }\n@@ -5091,7 +5109,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       cum->words = align_words + n_words;\n \n       if (SCALAR_FLOAT_MODE_P (mode)\n-\t  && !DECIMAL_FLOAT_MODE_P (mode)\n+\t  && mode != SDmode\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n \tcum->fregno += (GET_MODE_SIZE (mode) + 7) >> 3;\n \n@@ -5310,7 +5328,7 @@ rs6000_darwin64_record_arg_recurse (CUMULATIVE_ARGS *cum, tree type,\n \t      = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t   gen_rtx_REG (mode, cum->fregno++),\n \t\t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n-\t    if (mode == TFmode)\n+\t    if (mode == TFmode || mode == TDmode)\n \t      cum->fregno++;\n \t  }\n \telse if (cum->named && USE_ALTIVEC_FOR_ARG_P (cum, mode, ftype, 1))\n@@ -5571,18 +5589,26 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   else if (TARGET_SPE_ABI && TARGET_SPE\n \t   && (SPE_VECTOR_MODE (mode)\n \t       || (TARGET_E500_DOUBLE && (mode == DFmode\n+\t\t\t\t\t  || mode == DDmode\n \t\t\t\t\t  || mode == DCmode\n \t\t\t\t\t  || mode == TFmode\n+\t\t\t\t\t  || mode == TDmode\n \t\t\t\t\t  || mode == TCmode))))\n     return rs6000_spe_function_arg (cum, mode, type);\n \n   else if (abi == ABI_V4)\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n \t  && (mode == SFmode || mode == DFmode\n-\t      || (mode == TFmode && !TARGET_IEEEQUAD)))\n+\t      || (mode == TFmode && !TARGET_IEEEQUAD)\n+\t      || mode == DDmode || mode == TDmode))\n \t{\n-\t  if (cum->fregno + (mode == TFmode ? 1 : 0) <= FP_ARG_V4_MAX_REG)\n+\t  /* _Decimal128 must use an even/odd register pair.  */\n+\t  if (mode == TDmode && cum->fregno % 2)\n+\t    cum->fregno++;\n+\n+\t  if (cum->fregno + (mode == TFmode || mode == TDmode ? 1 : 0)\n+\t      <= FP_ARG_V4_MAX_REG)\n \t    return gen_rtx_REG (mode, cum->fregno);\n \t  else\n \t    return NULL_RTX;\n@@ -5625,10 +5651,11 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    {\n \t      /* Currently, we only ever need one reg here because complex\n \t\t doubles are split.  */\n-\t      gcc_assert (cum->fregno == FP_ARG_MAX_REG && fmode == TFmode);\n+\t      gcc_assert (cum->fregno == FP_ARG_MAX_REG\n+\t\t\t  && (fmode == TFmode || fmode == TDmode));\n \n-\t      /* Long double split over regs and memory.  */\n-\t      fmode = DFmode;\n+\t      /* Long double or _Decimal128 split over regs and memory.  */\n+\t      fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n \t    }\n \n \t  /* Do we also need to pass this arg in the parameter save\n@@ -6183,6 +6210,7 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   tree lab_false, lab_over, addr;\n   int align;\n   tree ptrtype = build_pointer_type (type);\n+  int regalign = 0;\n \n   if (pass_by_reference (NULL, TYPE_MODE (type), type, false))\n     {\n@@ -6239,7 +6267,9 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   if (TARGET_HARD_FLOAT && TARGET_FPRS\n       && (TYPE_MODE (type) == SFmode\n \t  || TYPE_MODE (type) == DFmode\n-\t  || TYPE_MODE (type) == TFmode))\n+\t  || TYPE_MODE (type) == TFmode\n+\t  || TYPE_MODE (type) == DDmode\n+\t  || TYPE_MODE (type) == TDmode))\n     {\n       /* FP args go in FP registers, if present.  */\n       reg = fpr;\n@@ -6280,10 +6310,19 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       u = reg;\n       if (n_reg == 2 && reg == gpr)\n \t{\n+\t  regalign = 1;\n \t  u = build2 (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n \t\t     size_int (n_reg - 1));\n \t  u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, u);\n \t}\n+      /* _Decimal128 is passed in even/odd fpr pairs; the stored\n+\t reg number is 0 for f1, so we want to make it odd.  */\n+      else if (reg == fpr && TYPE_MODE (type) == TDmode)\n+\t{\n+\t  regalign = 1;\n+\t  t = build2 (BIT_IOR_EXPR, TREE_TYPE (reg), reg, size_int (1));\n+\t  u = build2 (MODIFY_EXPR, void_type_node, reg, t);\n+\t}\n \n       t = fold_convert (TREE_TYPE (reg), size_int (8 - n_reg + 1));\n       t = build2 (GE_EXPR, boolean_type_node, u, t);\n@@ -6309,10 +6348,10 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = build1 (LABEL_EXPR, void_type_node, lab_false);\n       append_to_statement_list (t, pre_p);\n \n-      if ((n_reg == 2 && reg != gpr) || n_reg > 2)\n+      if ((n_reg == 2 && !regalign) || n_reg > 2)\n \t{\n \t  /* Ensure that we don't find any more args in regs.\n-\t     Alignment has taken care of the n_reg == 2 gpr case.  */\n+\t     Alignment has taken care of for special cases.  */\n \t  t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (reg), reg, size_int (8));\n \t  gimplify_and_add (t, pre_p);\n \t}\n@@ -12923,7 +12962,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n   mode = GET_MODE (dst);\n   nregs = hard_regno_nregs[reg][mode];\n   if (FP_REGNO_P (reg))\n-    reg_mode = DFmode;\n+    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : DFmode;\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n   else if (TARGET_E500_DOUBLE && mode == TFmode)\n@@ -15857,7 +15896,9 @@ rs6000_output_function_epilogue (FILE *file,\n \t\t\t  break;\n \n \t\t\tcase DFmode:\n+\t\t\tcase DDmode:\n \t\t\tcase TFmode:\n+\t\t\tcase TDmode:\n \t\t\t  bits = 0x3;\n \t\t\t  break;\n \n@@ -20196,7 +20237,7 @@ rs6000_register_move_cost (enum machine_mode mode,\n \n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n-    return mode == TFmode ? 4 : 2;\n+    return (mode == TFmode || mode == TDmode) ? 4 : 2;\n \n   /* Everything else has to go through GENERAL_REGS.  */\n   else\n@@ -20529,7 +20570,28 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n     mode = TYPE_MODE (valtype);\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n-    regno = GP_ARG_RETURN;\n+    {\n+      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t{\n+\t  switch (mode)\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    case SDmode:\n+\t      regno = GP_ARG_RETURN;\n+\t      break;\n+\t    case DDmode:\n+\t      regno = FP_ARG_RETURN;\n+\t      break;\n+\t    case TDmode:\n+\t      /* Use f2:f3 specified by the ABI.  */\n+\t      regno = FP_ARG_RETURN + 1;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\tregno = GP_ARG_RETURN;\n+    }\n   else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n@@ -20571,7 +20633,28 @@ rs6000_libcall_value (enum machine_mode mode)\n     }\n \n   if (DECIMAL_FLOAT_MODE_P (mode))\n-    regno = GP_ARG_RETURN;\n+    {\n+      if (TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t{\n+\t  switch (mode)\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    case SDmode:\n+\t      regno = GP_ARG_RETURN;\n+\t      break;\n+\t    case DDmode:\n+\t      regno = FP_ARG_RETURN;\n+\t      break;\n+\t    case TDmode:\n+\t      /* Use f2:f3 specified by the ABI.  */\n+\t      regno = FP_ARG_RETURN + 1;\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\tregno = GP_ARG_RETURN;\n+    }\n   else if (SCALAR_FLOAT_MODE_P (mode)\n \t   && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;"}, {"sha": "75f064a7780bea3a646d4d5ee5413224b1078665", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7393f7f8d04844ab976238ceffcc8f8c00214c92/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=7393f7f8d04844ab976238ceffcc8f8c00214c92", "patch": "@@ -1493,7 +1493,7 @@\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r,?r,r\")\n \t(plus:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"%r,b,r,b\")\n \t\t  (match_operand:GPR 2 \"add_operand\" \"r,I,I,L\")))]\n-  \"\"\n+  \"!DECIMAL_FLOAT_MODE_P (GET_MODE (operands[0])) && !DECIMAL_FLOAT_MODE_P (GET_MODE (operands[1]))\"\n   \"@\n    {cax|add} %0,%1,%2\n    {cal %0,%2(%1)|addi %0,%1,%2}\n@@ -14531,3 +14531,4 @@\n (include \"sync.md\")\n (include \"altivec.md\")\n (include \"spe.md\")\n+(include \"dfp.md\")"}]}