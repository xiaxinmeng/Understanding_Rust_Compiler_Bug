{"sha": "dbed1c8693c6b5cb02c903cea91db574200bd513", "node_id": "C_kwDOANBUbNoAKGRiZWQxYzg2OTNjNmI1Y2IwMmM5MDNjZWE5MWRiNTc0MjAwYmQ1MTM", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-06-23T23:30:47Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2021-09-28T12:10:59Z"}, "message": "reassoc: Propagate PHI_LOOP_BIAS along single uses\n\nPR tree-optimization/49749 introduced code that shortens dependency\nchains containing loop accumulators by placing them last on operand\nlists of associative operations.\n\n456.hmmer benchmark on s390 could benefit from this, however, the code\nthat needs it modifies loop accumulator before using it, and since only\nso-called loop-carried phis are are treated as loop accumulators, the\ncode in the present form doesn't really help.   According to Bill\nSchmidt - the original author - such a conservative approach was chosen\nso as to avoid unnecessarily swapping operands, which might cause\nunpredictable effects.  However, giving special treatment to forms of\nloop accumulators is acceptable.\n\nThe definition of loop-carried phi is: it's a single-use phi, which is\nused in the same innermost loop it's defined in, at least one argument\nof which is defined in the same innermost loop as the phi itself.\nGiven this, it seems natural to treat single uses of such phis as phis\nthemselves.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-reassoc.c (biased_names): New global.\n\t(propagate_bias_p): New function.\n\t(loop_carried_phi): Remove.\n\t(propagate_rank): Propagate bias along single uses.\n\t(get_rank): Update biased_names when needed.", "tree": {"sha": "1351e1465d3e9cd4d27b1f8d79f1245d83cac6b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1351e1465d3e9cd4d27b1f8d79f1245d83cac6b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbed1c8693c6b5cb02c903cea91db574200bd513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbed1c8693c6b5cb02c903cea91db574200bd513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbed1c8693c6b5cb02c903cea91db574200bd513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbed1c8693c6b5cb02c903cea91db574200bd513/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c106e695bd8f1de580c4ff0b1d3fe59c9a4f1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c106e695bd8f1de580c4ff0b1d3fe59c9a4f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c106e695bd8f1de580c4ff0b1d3fe59c9a4f1e"}], "stats": {"total": 109, "additions": 74, "deletions": 35}, "files": [{"sha": "db9fb4e1cac8e7428cf6f2e6dcdf3044d9c3f07c", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 74, "deletions": 35, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbed1c8693c6b5cb02c903cea91db574200bd513/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbed1c8693c6b5cb02c903cea91db574200bd513/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=dbed1c8693c6b5cb02c903cea91db574200bd513", "patch": "@@ -211,6 +211,10 @@ static int64_t *bb_rank;\n /* Operand->rank hashtable.  */\n static hash_map<tree, int64_t> *operand_rank;\n \n+/* SSA_NAMEs that are forms of loop accumulators and whose ranks need to be\n+   biased.  */\n+static auto_bitmap biased_names;\n+\n /* Vector of SSA_NAMEs on which after reassociate_bb is done with\n    all basic blocks the CFG should be adjusted - basic blocks\n    split right after that SSA_NAME's definition statement and before\n@@ -256,6 +260,53 @@ reassoc_remove_stmt (gimple_stmt_iterator *gsi)\n    the rank difference between two blocks.  */\n #define PHI_LOOP_BIAS (1 << 15)\n \n+/* Return TRUE iff PHI_LOOP_BIAS should be propagated from one of the STMT's\n+   operands to the STMT's left-hand side.  The goal is to preserve bias in code\n+   like this:\n+\n+     x_1 = phi(x_0, x_2)\n+     a = x_1 | 1\n+     b = a ^ 2\n+     .MEM = b\n+     c = b + d\n+     x_2 = c + e\n+\n+   That is, we need to preserve bias along single-use chains originating from\n+   loop-carried phis.  Only GIMPLE_ASSIGNs to SSA_NAMEs are considered to be\n+   uses, because only they participate in rank propagation.  */\n+static bool\n+propagate_bias_p (gimple *stmt)\n+{\n+  use_operand_p use;\n+  imm_use_iterator use_iter;\n+  gimple *single_use_stmt = NULL;\n+\n+  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_reference)\n+    return false;\n+\n+  FOR_EACH_IMM_USE_FAST (use, use_iter, gimple_assign_lhs (stmt))\n+    {\n+      gimple *current_use_stmt = USE_STMT (use);\n+\n+      if (is_gimple_assign (current_use_stmt)\n+\t  && TREE_CODE (gimple_assign_lhs (current_use_stmt)) == SSA_NAME)\n+\t{\n+\t  if (single_use_stmt != NULL && single_use_stmt != current_use_stmt)\n+\t    return false;\n+\t  single_use_stmt = current_use_stmt;\n+\t}\n+    }\n+\n+  if (single_use_stmt == NULL)\n+    return false;\n+\n+  if (gimple_bb (stmt)->loop_father\n+      != gimple_bb (single_use_stmt)->loop_father)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Rank assigned to a phi statement.  If STMT is a loop-carried phi of\n    an innermost loop, and the phi has only a single use which is inside\n    the loop, then the rank is the block rank of the loop latch plus an\n@@ -313,49 +364,27 @@ phi_rank (gimple *stmt)\n   return bb_rank[bb->index];\n }\n \n-/* If EXP is an SSA_NAME defined by a PHI statement that represents a\n-   loop-carried dependence of an innermost loop, return TRUE; else\n-   return FALSE.  */\n-static bool\n-loop_carried_phi (tree exp)\n-{\n-  gimple *phi_stmt;\n-  int64_t block_rank;\n-\n-  if (TREE_CODE (exp) != SSA_NAME\n-      || SSA_NAME_IS_DEFAULT_DEF (exp))\n-    return false;\n-\n-  phi_stmt = SSA_NAME_DEF_STMT (exp);\n-\n-  if (gimple_code (SSA_NAME_DEF_STMT (exp)) != GIMPLE_PHI)\n-    return false;\n-\n-  /* Non-loop-carried phis have block rank.  Loop-carried phis have\n-     an additional bias added in.  If this phi doesn't have block rank,\n-     it's biased and should not be propagated.  */\n-  block_rank = bb_rank[gimple_bb (phi_stmt)->index];\n-\n-  if (phi_rank (phi_stmt) != block_rank)\n-    return true;\n-\n-  return false;\n-}\n-\n /* Return the maximum of RANK and the rank that should be propagated\n    from expression OP.  For most operands, this is just the rank of OP.\n    For loop-carried phis, the value is zero to avoid undoing the bias\n    in favor of the phi.  */\n static int64_t\n-propagate_rank (int64_t rank, tree op)\n+propagate_rank (int64_t rank, tree op, bool *maybe_biased_p)\n {\n   int64_t op_rank;\n \n-  if (loop_carried_phi (op))\n-    return rank;\n-\n   op_rank = get_rank (op);\n \n+  /* Check whether op is biased after the get_rank () call, since it might have\n+     updated biased_names.  */\n+  if (TREE_CODE (op) == SSA_NAME\n+      && bitmap_bit_p (biased_names, SSA_NAME_VERSION (op)))\n+    {\n+      if (maybe_biased_p == NULL)\n+\treturn rank;\n+      *maybe_biased_p = true;\n+    }\n+\n   return MAX (rank, op_rank);\n }\n \n@@ -433,13 +462,20 @@ get_rank (tree e)\n \n       stmt = SSA_NAME_DEF_STMT (e);\n       if (gimple_code (stmt) == GIMPLE_PHI)\n-\trank = phi_rank (stmt);\n+\t{\n+\t  rank = phi_rank (stmt);\n+\t  if (rank != bb_rank[gimple_bb (stmt)->index])\n+\t    bitmap_set_bit (biased_names, SSA_NAME_VERSION (e));\n+\t}\n \n       else if (!is_gimple_assign (stmt))\n \trank = bb_rank[gimple_bb (stmt)->index];\n \n       else\n \t{\n+\t  bool biased_p = false;\n+\t  bool *maybe_biased_p = propagate_bias_p (stmt) ? &biased_p : NULL;\n+\n \t  /* Otherwise, find the maximum rank for the operands.  As an\n \t     exception, remove the bias from loop-carried phis when propagating\n \t     the rank so that dependent operations are not also biased.  */\n@@ -448,9 +484,11 @@ get_rank (tree e)\n \t     thus have rank 0.  */\n \t  rank = 0;\n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t    rank = propagate_rank (rank, op);\n+\t    rank = propagate_rank (rank, op, maybe_biased_p);\n \n \t  rank += 1;\n+\t  if (biased_p)\n+\t    bitmap_set_bit (biased_names, SSA_NAME_VERSION (e));\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -6933,6 +6971,7 @@ fini_reassoc (void)\n \t\t\t    reassociate_stats.pows_created);\n \n   delete operand_rank;\n+  bitmap_clear (biased_names);\n   operand_entry_pool.release ();\n   free (bb_rank);\n   plus_negates.release ();"}]}