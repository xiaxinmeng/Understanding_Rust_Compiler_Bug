{"sha": "906c4e36c6f418550a1040e1e61d989aa72f3b3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA2YzRlMzZjNmY0MTg1NTBhMTA0MGUxZTYxZDk4OWFhNzJmM2IzYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T20:04:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T20:04:13Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1473", "tree": {"sha": "13b15ad4d758f873683cb6c6f99e16cb34f53a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13b15ad4d758f873683cb6c6f99e16cb34f53a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/906c4e36c6f418550a1040e1e61d989aa72f3b3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906c4e36c6f418550a1040e1e61d989aa72f3b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906c4e36c6f418550a1040e1e61d989aa72f3b3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906c4e36c6f418550a1040e1e61d989aa72f3b3c/comments", "author": null, "committer": null, "parents": [{"sha": "b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1ec3c92629621146e4c7e1e1b2341c5326e1b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1ec3c92629621146e4c7e1e1b2341c5326e1b73"}], "stats": {"total": 1510, "additions": 820, "deletions": 690}, "files": [{"sha": "dbb2f2209fdeb7fe6051a1732043c42294af13c3", "filename": "gcc/cse.c", "status": "modified", "additions": 224, "deletions": 185, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -326,7 +326,7 @@ static int cse_basic_block_end;\n    The cuids are like uids but increase monotonically always.\n    We use them to see whether a reg is used outside a given basic block.  */\n \n-static short *uid_cuid;\n+static int *uid_cuid;\n \n /* Get the cuid of an insn.  */\n \n@@ -863,15 +863,15 @@ mention_regs (x)\n     {\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n-\tif (insert_regs (XEXP (x, 0), 0, 0))\n+\tif (insert_regs (XEXP (x, 0), NULL_PTR, 0))\n \t  {\n \t    rehash_using_reg (XEXP (x, 0));\n \t    changed = 1;\n \t  }\n \n       if (GET_CODE (XEXP (x, 1)) == REG\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n-\tif (insert_regs (XEXP (x, 1), 0, 0))\n+\tif (insert_regs (XEXP (x, 1), NULL_PTR, 0))\n \t  {\n \t    rehash_using_reg (XEXP (x, 1));\n \t    changed = 1;\n@@ -939,7 +939,7 @@ insert_regs (x, classp, modified)\n   else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n \t   && ! REGNO_QTY_VALID_P (REGNO (SUBREG_REG (x))))\n     {\n-      insert_regs (SUBREG_REG (x), 0, 0);\n+      insert_regs (SUBREG_REG (x), NULL_PTR, 0);\n       mention_regs (SUBREG_REG (x));\n       return 1;\n     }\n@@ -1297,7 +1297,7 @@ insert (x, classp, hash, mode)\n \t  subhash = safe_hash (subexp, mode) % NBUCKETS;\n \t  subelt = lookup (subexp, subhash, mode);\n \t  if (subelt == 0)\n-\t    subelt = insert (subexp, 0, subhash, mode);\n+\t    subelt = insert (subexp, NULL_PTR, subhash, mode);\n \t  /* Initialize SUBELT's circular chain if it has none.  */\n \t  if (subelt->related_value == 0)\n \t    subelt->related_value = subelt;\n@@ -1387,7 +1387,7 @@ invalidate (x)\n   register int i;\n   register struct table_elt *p;\n   register rtx base;\n-  register int start, end;\n+  register HOST_WIDE_INT start, end;\n \n   /* If X is a register, dependencies on its contents\n      are recorded through the qty number mechanism.\n@@ -1527,7 +1527,7 @@ remove_invalid_refs (regno)\n       {\n \tnext = p->next_same_hash;\n \tif (GET_CODE (p->exp) != REG\n-\t    && refers_to_regno_p (regno, regno + 1, p->exp, 0))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n \t  remove_from_table (p, i);\n       }\n }\n@@ -1675,7 +1675,7 @@ use_related_value (x, elt)\n {\n   register struct table_elt *relt = 0;\n   register struct table_elt *p, *q;\n-  int offset;\n+  HOST_WIDE_INT offset;\n \n   /* First, is there anything related known?\n      If we have a table element, we can tell from that.\n@@ -1952,7 +1952,7 @@ exp_equiv_p (x, y, validate, equal_values)\n      int validate;\n      int equal_values;\n {\n-  register int i;\n+  register int i, j;\n   register enum rtx_code code;\n   register char *fmt;\n \n@@ -2052,34 +2052,45 @@ exp_equiv_p (x, y, validate, equal_values)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      if (fmt[i] == 'e')\n+      switch (fmt[i])\n \t{\n+\tcase 'e':\n \t  if (! exp_equiv_p (XEXP (x, i), XEXP (y, i), validate, equal_values))\n \t    return 0;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n+\t  break;\n+\n+\tcase 'E':\n \t  if (XVECLEN (x, i) != XVECLEN (y, i))\n \t    return 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    if (! exp_equiv_p (XVECEXP (x, i, j), XVECEXP (y, i, j),\n \t\t\t       validate, equal_values))\n \t      return 0;\n-\t}\n-      else if (fmt[i] == 's')\n-\t{\n+\t  break;\n+\n+\tcase 's':\n \t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n \t    return 0;\n-\t}\n-      else if (fmt[i] == 'i')\n-\t{\n+\t  break;\n+\n+\tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n \t    return 0;\n+\t  break;\n+\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\tbreak;\n+\n+\tcase '0':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n-      else if (fmt[i] != '0')\n- \tabort ();\n-    }\n+      }\n+\n   return 1;\n }\n \f\n@@ -2152,9 +2163,9 @@ refers_to_p (x, y)\n int\n refers_to_mem_p (x, base, start, end)\n      rtx x, base;\n-     int start, end;\n+     HOST_WIDE_INT start, end;\n {\n-  register int i;\n+  register HOST_WIDE_INT i;\n   register enum rtx_code code;\n   register char *fmt;\n \n@@ -2221,7 +2232,7 @@ refers_to_mem_p (x, base, start, end)\n \t  if (GET_CODE (base) == PLUS\n \t      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n \t    {\n-\t      int tem = INTVAL (XEXP (base, 1));\n+\t      HOST_WIDE_INT tem = INTVAL (XEXP (base, 1));\n \t      start += tem;\n \t      end += tem;\n \t      base = XEXP (base, 0);\n@@ -2236,7 +2247,7 @@ refers_to_mem_p (x, base, start, end)\n \t  if (GET_CODE (base) == PLUS\n \t      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n \t    {\n-\t      int tem = INTVAL (XEXP (base, 1));\n+\t      HOST_WIDE_INT tem = INTVAL (XEXP (base, 1));\n \t      start += tem;\n \t      end += tem;\n \t      base = XEXP (base, 0);\n@@ -2477,7 +2488,7 @@ find_best_addr (insn, loc)\n \t    && (GET_CODE (elt->exp) == REG\n \t\t|| exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t    && validate_change (insn, loc,\n-\t\t\t\tcanon_reg (copy_rtx (elt->exp), 0), 0))\n+\t\t\t\tcanon_reg (copy_rtx (elt->exp), NULL_RTX), 0))\n \t  return;\n     }\n #else\n@@ -2516,7 +2527,8 @@ find_best_addr (insn, loc)\n \t  if (found_better)\n \t    {\n \t      if (validate_change (insn, loc,\n-\t\t\t\t   canon_reg (copy_rtx (best_elt->exp), 0), 0))\n+\t\t\t\t   canon_reg (copy_rtx (best_elt->exp),\n+\t\t\t\t\t      NULL_RTX), 0))\n \t\treturn;\n \t      else\n \t\tbest_elt->flag = 1;\n@@ -2593,7 +2605,8 @@ find_best_addr (insn, loc)\n \t  if (found_better)\n \t    {\n \t      if (validate_change (insn, loc,\n-\t\t\t\t   canon_reg (copy_rtx (best_rtx), 0), 0))\n+\t\t\t\t   canon_reg (copy_rtx (best_rtx),\n+\t\t\t\t\t      NULL_RTX), 0))\n \t\treturn;\n \t      else\n \t\tbest_elt->flag = 1;\n@@ -2698,9 +2711,11 @@ find_comparison_args (code, parg1, parg2)\n \t      || ((code == NE\n \t\t   || (code == LT\n \t\t       && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t       && GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n+\t\t       && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t   <= HOST_BITS_PER_WIDE_INT)\n \t\t       && (STORE_FLAG_VALUE\n-\t\t\t   & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t   & ((HOST_WIDE_INT) 1\n+\t\t\t      << (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t   || (code == LT\n \t\t       && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n@@ -2715,9 +2730,11 @@ find_comparison_args (code, parg1, parg2)\n \t  else if ((code == EQ\n \t\t    || (code == GE\n \t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t&& GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n+\t\t\t&& (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t    <= HOST_BITS_PER_WIDE_INT)\n \t\t\t&& (STORE_FLAG_VALUE\n-\t\t\t    & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t    & ((HOST_WIDE_INT) 1\n+\t\t\t       << (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t    || (code == GE\n \t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n@@ -2811,17 +2828,17 @@ simplify_unary_operation (code, mode, op, op_mode)\n       if (CONST_DOUBLE_HIGH (op) < 0)\n \t{\n \t  d = (double) (~ CONST_DOUBLE_HIGH (op));\n-\t  d *= ((double) (1 << (HOST_BITS_PER_INT / 2))\n-\t\t* (double) (1 << (HOST_BITS_PER_INT / 2)));\n-\t  d += (double) (unsigned) (~ CONST_DOUBLE_LOW (op));\n+\t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n+\t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+\t  d += (double) (unsigned HOST_WIDE_INT) (~ CONST_DOUBLE_LOW (op));\n \t  d = (- d - 1.0);\n \t}\n       else\n \t{\n \t  d = (double) CONST_DOUBLE_HIGH (op);\n-\t  d *= ((double) (1 << (HOST_BITS_PER_INT / 2))\n-\t\t* (double) (1 << (HOST_BITS_PER_INT / 2)));\n-\t  d += (double) (unsigned) CONST_DOUBLE_LOW (op);\n+\t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n+\t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+\t  d += (double) (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n \t}\n #endif  /* REAL_ARITHMETIC */\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n@@ -2836,19 +2853,19 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t\t\t\t    CONST_DOUBLE_HIGH (op));\n #else\n       d = (double) CONST_DOUBLE_HIGH (op);\n-      d *= ((double) (1 << (HOST_BITS_PER_INT / 2))\n-\t    * (double) (1 << (HOST_BITS_PER_INT / 2)));\n-      d += (double) (unsigned) CONST_DOUBLE_LOW (op);\n+      d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n+\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+      d += (double) (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (op);\n #endif  /* REAL_ARITHMETIC */\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n #endif\n \n   else if (GET_CODE (op) == CONST_INT\n-\t   && width <= HOST_BITS_PER_INT && width > 0)\n+\t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      register int arg0 = INTVAL (op);\n-      register int val;\n+      register HOST_WIDE_INT arg0 = INTVAL (op);\n+      register HOST_WIDE_INT val;\n \n       switch (code)\n \t{\n@@ -2926,19 +2943,20 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t unless they and our sign bit are all one.\n \t So we get either a reasonable negative value or a reasonable\n \t unsigned value for this mode.  */\n-      if (width < HOST_BITS_PER_INT\n-\t  && ((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n+      if (width < HOST_BITS_PER_WIDE_INT\n+\t  && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n \tval &= (1 << width) - 1;\n \n-      return gen_rtx (CONST_INT, VOIDmode, val);\n+      return GEN_INT (val);\n     }\n \n   /* We can do some operations on integer CONST_DOUBLEs.  Also allow\n      for a DImode operation on a CONST_INT. */\n   else if (GET_MODE (op) == VOIDmode\n \t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     {\n-      int l1, h1, lv, hv;\n+      HOST_WIDE_INT l1, h1, lv, hv;\n \n       if (GET_CODE (op) == CONST_DOUBLE)\n \tl1 = CONST_DOUBLE_LOW (op), h1 = CONST_DOUBLE_HIGH (op);\n@@ -2966,21 +2984,21 @@ simplify_unary_operation (code, mode, op, op_mode)\n \tcase FFS:\n \t  hv = 0;\n \t  if (l1 == 0)\n-\t    lv = HOST_BITS_PER_INT + exact_log2 (h1 & (-h1)) + 1;\n+\t    lv = HOST_BITS_PER_WIDE_INT + exact_log2 (h1 & (-h1)) + 1;\n \t  else\n \t    lv = exact_log2 (l1 & (-l1)) + 1;\n \t  break;\n \n \tcase TRUNCATE:\n-\t  if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT)\n-\t    return gen_rtx (CONST_INT, VOIDmode, l1 & GET_MODE_MASK (mode));\n+\t  if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t    return GEN_INT (l1 & GET_MODE_MASK (mode));\n \t  else\n \t    return 0;\n \t  break;\n \n \tcase ZERO_EXTEND:\n \t  if (op_mode == VOIDmode\n-\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_INT)\n+\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT)\n \t    return 0;\n \n \t  hv = 0;\n@@ -2989,16 +3007,17 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n \tcase SIGN_EXTEND:\n \t  if (op_mode == VOIDmode\n-\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_INT)\n+\t      || GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT)\n \t    return 0;\n \t  else\n \t    {\n \t      lv = l1 & GET_MODE_MASK (op_mode);\n-\t      if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_INT\n-\t\t  && (lv & (1 << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n-\t\tlv -= 1 << GET_MODE_BITSIZE (op_mode);\n+\t      if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT\n+\t\t  && (lv & ((HOST_WIDE_INT) 1\n+\t\t\t    << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n+\t\tlv -= (HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n \n-\t      hv = (lv < 0) ? ~0 : 0;\n+\t      hv = (lv < 0) ? ~ (HOST_WIDE_INT) 0 : 0;\n \t    }\n \t  break;\n \n@@ -3065,16 +3084,16 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t}\n \n       x = immed_real_const_1 (d, mode);\n-      set_float_handler (0);\n+      set_float_handler (NULL_PTR);\n       return x;\n     }\n   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE_CLASS (mode) == MODE_INT\n-\t   && width <= HOST_BITS_PER_INT && width > 0)\n+\t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n       REAL_VALUE_TYPE d;\n       jmp_buf handler;\n       rtx x;\n-      int val;\n+      HOST_WIDE_INT val;\n \n       if (setjmp (handler))\n \treturn 0;\n@@ -3097,17 +3116,18 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  abort ();\n \t}\n \n-      set_float_handler (0);\n+      set_float_handler (NULL_PTR);\n \n       /* Clear the bits that don't belong in our mode,\n \t unless they and our sign bit are all one.\n \t So we get either a reasonable negative value or a reasonable\n \t unsigned value for this mode.  */\n-      if (width < HOST_BITS_PER_INT\n-\t  && ((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-\tval &= (1 << width) - 1;\n+      if (width < HOST_BITS_PER_WIDE_INT\n+\t  && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+\tval &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n-      return gen_rtx (CONST_INT, VOIDmode, val);\n+      return GEN_INT (val);\n     }\n #endif\n   /* This was formerly used only for non-IEEE float.\n@@ -3155,8 +3175,8 @@ simplify_binary_operation (code, mode, op0, op1)\n      enum machine_mode mode;\n      rtx op0, op1;\n {\n-  register int arg0, arg1, arg0s, arg1s;\n-  int val;\n+  register HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n+  HOST_WIDE_INT val;\n   int width = GET_MODE_BITSIZE (mode);\n \n   /* Relational operations don't work here.  We must know the mode\n@@ -3217,7 +3237,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t}\n #endif\n \n-      set_float_handler (0);\n+      set_float_handler (NULL_PTR);\n       value = real_value_truncate (mode, value);\n       return immed_real_const_1 (value, mode);\n     }\n@@ -3227,7 +3247,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t   && GET_CODE (op0) == CONST_DOUBLE\n \t   && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n     {\n-      int l1, l2, h1, h2, lv, hv;\n+      HOST_WIDE_INT l1, l2, h1, h2, lv, hv;\n \n       l1 = CONST_DOUBLE_LOW (op0), h1 = CONST_DOUBLE_HIGH (op0);\n \n@@ -3271,30 +3291,40 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase SMIN:\n-\t  if (h1 < h2 || (h1 == h2 && (unsigned) l1 < (unsigned) l2))\n+\t  if (h1 < h2\n+\t      || (h1 == h2\n+\t\t  && ((unsigned HOST_WIDE_INT) l1\n+\t\t      < (unsigned HOST_WIDE_INT) l2)))\n \t    lv = l1, hv = h1;\n \t  else\n \t    lv = l2, hv = h2;\n \t  break;\n \n \tcase SMAX:\n-\t  if (h1 > h2 || (h1 == h2 && (unsigned) l1 > (unsigned) l2))\n+\t  if (h1 > h2\n+\t      || (h1 == h2\n+\t\t  && ((unsigned HOST_WIDE_INT) l1\n+\t\t      > (unsigned HOST_WIDE_INT) l2)))\n \t    lv = l1, hv = h1;\n \t  else\n \t    lv = l2, hv = h2;\n \t  break;\n \n \tcase UMIN:\n-\t  if ((unsigned) h1 < (unsigned) h2\n-\t      || (h1 == h2 && (unsigned) l1 < (unsigned) l2))\n+\t  if ((unsigned HOST_WIDE_INT) h1 < (unsigned HOST_WIDE_INT) h2\n+\t      || (h1 == h2\n+\t\t  && ((unsigned HOST_WIDE_INT) l1\n+\t\t      < (unsigned HOST_WIDE_INT) l2)))\n \t    lv = l1, hv = h1;\n \t  else\n \t    lv = l2, hv = h2;\n \t  break;\n \n \tcase UMAX:\n-\t  if ((unsigned) h1 > (unsigned) h2\n-\t      || (h1 == h2 && (unsigned) l1 > (unsigned) l2))\n+\t  if ((unsigned HOST_WIDE_INT) h1 > (unsigned HOST_WIDE_INT) h2\n+\t      || (h1 == h2\n+\t\t  && ((unsigned HOST_WIDE_INT) l1\n+\t\t      > (unsigned HOST_WIDE_INT) l2)))\n \t    lv = l1, hv = h1;\n \t  else\n \t    lv = l2, hv = h2;\n@@ -3331,7 +3361,7 @@ simplify_binary_operation (code, mode, op0, op1)\n #endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n   if (GET_CODE (op0) != CONST_INT || GET_CODE (op1) != CONST_INT\n-      || width > HOST_BITS_PER_INT || width == 0)\n+      || width > HOST_BITS_PER_WIDE_INT || width == 0)\n     {\n       /* Even if we can't compute a constant result,\n \t there are some cases worth simplifying.  */\n@@ -3633,8 +3663,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* Convert multiply by constant power of two into shift.  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && (val = exact_log2 (INTVAL (op1))) >= 0)\n-\t    return gen_rtx (ASHIFT, mode, op0,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, val));\n+\t    return gen_rtx (ASHIFT, mode, op0, GEN_INT (val));\n \n \t  if (GET_CODE (op1) == CONST_DOUBLE\n \t      && GET_MODE_CLASS (GET_MODE (op1)) == MODE_FLOAT)\n@@ -3698,8 +3727,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     below).  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && (arg1 = exact_log2 (INTVAL (op1))) > 0)\n-\t    return gen_rtx (LSHIFTRT, mode, op0,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, arg1));\n+\t    return gen_rtx (LSHIFTRT, mode, op0, GEN_INT (arg1));\n \n \t  /* ... fall through ... */\n \n@@ -3737,8 +3765,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* Handle modulus by power of two (mod with 1 handled below).  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && exact_log2 (INTVAL (op1)) > 0)\n-\t    return gen_rtx (AND, mode, op0, \n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, INTVAL (op1) - 1));\n+\t    return gen_rtx (AND, mode, op0, GEN_INT (INTVAL (op1) - 1));\n \n \t  /* ... fall through ... */\n \n@@ -3751,7 +3778,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \tcase ROTATERT:\n \tcase ROTATE:\n \t  /* Rotating ~0 always results in ~0.  */\n-\t  if (GET_CODE (op0) == CONST_INT && width <= HOST_BITS_PER_INT\n+\t  if (GET_CODE (op0) == CONST_INT && width <= HOST_BITS_PER_WIDE_INT\n \t      && INTVAL (op0) == GET_MODE_MASK (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n@@ -3769,16 +3796,16 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase SMIN:\n-\t  if (width <= HOST_BITS_PER_INT && GET_CODE (op1) == CONST_INT \n-\t      && INTVAL (op1) == 1 << (width -1)\n+\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (op1) == CONST_INT \n+\t      && INTVAL (op1) == (HOST_WIDE_INT) 1 << (width -1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n \t  else if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n \t   \n \tcase SMAX:\n-\t  if (width <= HOST_BITS_PER_INT && GET_CODE (op1) == CONST_INT\n+\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (op1) == CONST_INT\n \t      && INTVAL (op1) == GET_MODE_MASK (mode) >> 1\n \t      && ! side_effects_p (op0))\n \t    return op1;\n@@ -3813,18 +3840,18 @@ simplify_binary_operation (code, mode, op0, op1)\n   arg0 = INTVAL (op0);\n   arg1 = INTVAL (op1);\n \n-  if (width < HOST_BITS_PER_INT)\n+  if (width < HOST_BITS_PER_WIDE_INT)\n     {\n-      arg0 &= (1 << width) - 1;\n-      arg1 &= (1 << width) - 1;\n+      arg0 &= ((HOST_WIDE_INT) 1 << width) - 1;\n+      arg1 &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n       arg0s = arg0;\n-      if (arg0s & (1 << (width - 1)))\n-\targ0s |= ((-1) << width);\n+      if (arg0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\targ0s |= ((HOST_WIDE_INT) (-1) << width);\n \n       arg1s = arg1;\n-      if (arg1s & (1 << (width - 1)))\n-\targ1s |= ((-1) << width);\n+      if (arg1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\targ1s |= ((HOST_WIDE_INT) (-1) << width);\n     }\n   else\n     {\n@@ -3863,13 +3890,13 @@ simplify_binary_operation (code, mode, op0, op1)\n     case UDIV:\n       if (arg1 == 0)\n \treturn 0;\n-      val = (unsigned) arg0 / arg1;\n+      val = (unsigned HOST_WIDE_INT) arg0 / arg1;\n       break;\n \n     case UMOD:\n       if (arg1 == 0)\n \treturn 0;\n-      val = (unsigned) arg0 % arg1;\n+      val = (unsigned HOST_WIDE_INT) arg0 % arg1;\n       break;\n \n     case AND:\n@@ -3897,7 +3924,7 @@ simplify_binary_operation (code, mode, op0, op1)\n       if (arg1 >= width)\n \treturn 0;\n \n-      val = ((unsigned) arg0) >> arg1;\n+      val = ((unsigned HOST_WIDE_INT) arg0) >> arg1;\n       break;\n \n     case ASHIFT:\n@@ -3912,7 +3939,7 @@ simplify_binary_operation (code, mode, op0, op1)\n       if (arg1 >= width)\n \treturn 0;\n \n-      val = ((unsigned) arg0) << arg1;\n+      val = ((unsigned HOST_WIDE_INT) arg0) << arg1;\n       break;\n \n     case ASHIFTRT:\n@@ -3934,17 +3961,17 @@ simplify_binary_operation (code, mode, op0, op1)\n \treturn 0;\n \n       arg1 %= width;\n-      val = ((((unsigned) arg0) << (width - arg1))\n-\t     | (((unsigned) arg0) >> arg1));\n+      val = ((((unsigned HOST_WIDE_INT) arg0) << (width - arg1))\n+\t     | (((unsigned HOST_WIDE_INT) arg0) >> arg1));\n       break;\n \n     case ROTATE:\n       if (arg1 < 0)\n \treturn 0;\n \n       arg1 %= width;\n-      val = ((((unsigned) arg0) << arg1)\n-\t     | (((unsigned) arg0) >> (width - arg1)));\n+      val = ((((unsigned HOST_WIDE_INT) arg0) << arg1)\n+\t     | (((unsigned HOST_WIDE_INT) arg0) >> (width - arg1)));\n       break;\n \n     case COMPARE:\n@@ -3956,15 +3983,17 @@ simplify_binary_operation (code, mode, op0, op1)\n       break;\n \n     case UMIN:\n-      val = (unsigned int)arg0 <= (unsigned int)arg1 ? arg0 : arg1;\n+      val = ((unsigned HOST_WIDE_INT) arg0\n+\t     <= (unsigned HOST_WIDE_INT) arg1 ? arg0 : arg1);\n       break;\n \n     case SMAX:\n       val = arg0s > arg1s ? arg0s : arg1s;\n       break;\n \n     case UMAX:\n-      val = (unsigned int)arg0 > (unsigned int)arg1 ? arg0 : arg1;\n+      val = ((unsigned HOST_WIDE_INT) arg0\n+\t     > (unsigned HOST_WIDE_INT) arg1 ? arg0 : arg1);\n       break;\n \n     default:\n@@ -3974,11 +4003,12 @@ simplify_binary_operation (code, mode, op0, op1)\n   /* Clear the bits that don't belong in our mode, unless they and our sign\n      bit are all one.  So we get either a reasonable negative value or a\n      reasonable unsigned value for this mode.  */\n-  if (width < HOST_BITS_PER_INT\n-      && ((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-    val &= (1 << width) - 1;\n-  \n-  return gen_rtx (CONST_INT, VOIDmode, val);\n+  if (width < HOST_BITS_PER_WIDE_INT\n+      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\n+  return GEN_INT (val);\n }\n \f\n /* Like simplify_binary_operation except used for relational operators.\n@@ -3990,16 +4020,16 @@ simplify_relational_operation (code, mode, op0, op1)\n      enum machine_mode mode;\n      rtx op0, op1;\n {\n-  register int arg0, arg1, arg0s, arg1s;\n-  int val;\n+  register HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n+  HOST_WIDE_INT val;\n   int width = GET_MODE_BITSIZE (mode);\n \n   /* If op0 is a compare, extract the comparison arguments from it.  */\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n     op1 = XEXP (op0, 1), op0 = XEXP (op0, 0);\n \n   if (GET_CODE (op0) != CONST_INT || GET_CODE (op1) != CONST_INT\n-      || width > HOST_BITS_PER_INT || width == 0)\n+      || width > HOST_BITS_PER_WIDE_INT || width == 0)\n     {\n       /* Even if we can't compute a constant result,\n \t there are some cases worth simplifying.  */\n@@ -4016,7 +4046,6 @@ simplify_relational_operation (code, mode, op0, op1)\n \t       && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n \t{\n \t  REAL_VALUE_TYPE d0, d1;\n-\t  int value;\n \t  jmp_buf handler;\n \t  int op0lt, op1lt, equal;\n \n@@ -4029,7 +4058,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \t  equal = REAL_VALUES_EQUAL (d0, d1);\n \t  op0lt = REAL_VALUES_LESS (d0, d1);\n \t  op1lt = REAL_VALUES_LESS (d1, d0);\n-\t  set_float_handler (0);\n+\t  set_float_handler (NULL_PTR);\n \n \t  switch (code)\n \t    {\n@@ -4116,18 +4145,18 @@ simplify_relational_operation (code, mode, op0, op1)\n   arg0 = INTVAL (op0);\n   arg1 = INTVAL (op1);\n \n-  if (width < HOST_BITS_PER_INT)\n+  if (width < HOST_BITS_PER_WIDE_INT)\n     {\n-      arg0 &= (1 << width) - 1;\n-      arg1 &= (1 << width) - 1;\n+      arg0 &= ((HOST_WIDE_INT) 1 << width) - 1;\n+      arg1 &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n       arg0s = arg0;\n-      if (arg0s & (1 << (width - 1)))\n-\targ0s |= ((-1) << width);\n+      if (arg0s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\targ0s |= ((HOST_WIDE_INT) (-1) << width);\n \n       arg1s = arg1;\n-      if (arg1s & (1 << (width - 1)))\n-\targ1s |= ((-1) << width);\n+      if (arg1s & ((HOST_WIDE_INT) 1 << (width - 1)))\n+\targ1s |= ((HOST_WIDE_INT) (-1) << width);\n     }\n   else\n     {\n@@ -4164,19 +4193,23 @@ simplify_relational_operation (code, mode, op0, op1)\n       break;\n \n     case LEU:\n-      val = ((unsigned) arg0) <= ((unsigned) arg1) ? STORE_FLAG_VALUE : 0;\n+      val = (((unsigned HOST_WIDE_INT) arg0)\n+\t     <= ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n       break;\n \n     case LTU:\n-      val = ((unsigned) arg0) < ((unsigned) arg1) ? STORE_FLAG_VALUE : 0;\n+      val = (((unsigned HOST_WIDE_INT) arg0)\n+\t     < ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n       break;\n \n     case GEU:\n-      val = ((unsigned) arg0) >= ((unsigned) arg1) ? STORE_FLAG_VALUE : 0;\n+      val = (((unsigned HOST_WIDE_INT) arg0)\n+\t     >= ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n       break;\n \n     case GTU:\n-      val = ((unsigned) arg0) > ((unsigned) arg1) ? STORE_FLAG_VALUE : 0;\n+      val = (((unsigned HOST_WIDE_INT) arg0)\n+\t     > ((unsigned HOST_WIDE_INT) arg1) ? STORE_FLAG_VALUE : 0);\n       break;\n \n     default:\n@@ -4186,11 +4219,12 @@ simplify_relational_operation (code, mode, op0, op1)\n   /* Clear the bits that don't belong in our mode, unless they and our sign\n      bit are all one.  So we get either a reasonable negative value or a\n      reasonable unsigned value for this mode.  */\n-  if (width < HOST_BITS_PER_INT\n-      && ((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-    val &= (1 << width) - 1;\n+  if (width < HOST_BITS_PER_WIDE_INT\n+      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n   \n-  return gen_rtx (CONST_INT, VOIDmode, val);\n+  return GEN_INT (val);\n }\n \f\n /* Simplify CODE, an operation with result mode MODE and three operands,\n@@ -4207,7 +4241,7 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \n   /* VOIDmode means \"infinite\" precision.  */\n   if (width == 0)\n-    width = HOST_BITS_PER_INT;\n+    width = HOST_BITS_PER_WIDE_INT;\n \n   switch (code)\n     {\n@@ -4217,34 +4251,36 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t  && GET_CODE (op1) == CONST_INT\n \t  && GET_CODE (op2) == CONST_INT\n \t  && INTVAL (op1) + INTVAL (op2) <= GET_MODE_BITSIZE (op0_mode)\n-\t  && width <= HOST_BITS_PER_INT)\n+\t  && width <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  /* Extracting a bit-field from a constant */\n-\t  int val = INTVAL (op0);\n+\t  HOST_WIDE_INT val = INTVAL (op0);\n \n #if BITS_BIG_ENDIAN\n \t  val >>= (GET_MODE_BITSIZE (op0_mode) - INTVAL (op2) - INTVAL (op1));\n #else\n \t  val >>= INTVAL (op2);\n #endif\n-\t  if (HOST_BITS_PER_INT != INTVAL (op1))\n+\t  if (HOST_BITS_PER_WIDE_INT != INTVAL (op1))\n \t    {\n \t      /* First zero-extend.  */\n-\t      val &= (1 << INTVAL (op1)) - 1;\n+\t      val &= ((HOST_WIDE_INT) 1 << INTVAL (op1)) - 1;\n \t      /* If desired, propagate sign bit.  */\n-\t      if (code == SIGN_EXTRACT && (val & (1 << (INTVAL (op1) - 1))))\n-\t\tval |= ~ ((1 << INTVAL (op1)) - 1);\n+\t      if (code == SIGN_EXTRACT\n+\t\t  && (val & ((HOST_WIDE_INT) 1 << (INTVAL (op1) - 1))))\n+\t\tval |= ~ (((HOST_WIDE_INT) 1 << INTVAL (op1)) - 1);\n \t    }\n \n \t  /* Clear the bits that don't belong in our mode,\n \t     unless they and our sign bit are all one.\n \t     So we get either a reasonable negative value or a reasonable\n \t     unsigned value for this mode.  */\n-\t  if (width < HOST_BITS_PER_INT\n-\t      && ((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-\t    val &= (1 << width) - 1;\n+\t  if (width < HOST_BITS_PER_WIDE_INT\n+\t      && ((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t\t  != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+\t    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n-\t  return gen_rtx (CONST_INT, VOIDmode, val);\n+\t  return GEN_INT (val);\n \t}\n       break;\n \n@@ -4281,7 +4317,7 @@ fold_rtx (x, insn)\n   register enum rtx_code code;\n   register enum machine_mode mode;\n   register char *fmt;\n-  register int i, val;\n+  register int i;\n   rtx new = 0;\n   int copied = 0;\n   int must_swap = 0;\n@@ -4367,7 +4403,7 @@ fold_rtx (x, insn)\n \t\t   elt; elt = elt->next_same_value)\n \t\tif (GET_CODE (elt->exp) == SUBREG\n \t\t    && GET_MODE (SUBREG_REG (elt->exp)) == mode\n-\t\t    && exp_equiv_p (elt->exp, elt->exp, 1))\n+\t\t    && exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t\t  return copy_rtx (SUBREG_REG (elt->exp));\n \t    }\n \n@@ -4439,7 +4475,7 @@ fold_rtx (x, insn)\n \t\t  rtx op0 = SUBREG_REG (XEXP (elt->exp, 0));\n \n \t\t  if (GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n-\t\t    op0 = fold_rtx (op0, 0);\n+\t\t    op0 = fold_rtx (op0, NULL_RTX);\n \n \t\t  op0 = equiv_constant (op0);\n \t\t  if (op0)\n@@ -4461,13 +4497,13 @@ fold_rtx (x, insn)\n \t\t  rtx op1 = gen_lowpart_common (mode, XEXP (elt->exp, 1));\n \n \t\t  if (op0 && GET_CODE (op0) != REG && ! CONSTANT_P (op0))\n-\t\t    op0 = fold_rtx (op0, 0);\n+\t\t    op0 = fold_rtx (op0, NULL_RTX);\n \n \t\t  if (op0)\n \t\t    op0 = equiv_constant (op0);\n \n \t\t  if (op1 && GET_CODE (op1) != REG && ! CONSTANT_P (op1))\n-\t\t    op1 = fold_rtx (op1, 0);\n+\t\t    op1 = fold_rtx (op1, NULL_RTX);\n \n \t\t  if (op1)\n \t\t    op1 = equiv_constant (op1);\n@@ -4481,7 +4517,7 @@ fold_rtx (x, insn)\n \t\t       && GET_MODE (SUBREG_REG (elt->exp)) == mode\n \t\t       && (GET_MODE_SIZE (GET_MODE (folded_arg0))\n \t\t\t   <= UNITS_PER_WORD)\n-\t\t       && exp_equiv_p (elt->exp, elt->exp, 1))\n+\t\t       && exp_equiv_p (elt->exp, elt->exp, 1, 0))\n \t\tnew = copy_rtx (SUBREG_REG (elt->exp));\n \n \t      if (new)\n@@ -4510,9 +4546,9 @@ fold_rtx (x, insn)\n       {\n \t/* Even if we don't fold in the insn itself,\n \t   we can safely do so here, in hopes of getting a constant.  */\n-\trtx addr = fold_rtx (XEXP (x, 0), 0);\n+\trtx addr = fold_rtx (XEXP (x, 0), NULL_RTX);\n \trtx base = 0;\n-\tint offset = 0;\n+\tHOST_WIDE_INT offset = 0;\n \n \tif (GET_CODE (addr) == REG\n \t    && REGNO_QTY_VALID_P (REGNO (addr))\n@@ -4912,8 +4948,9 @@ fold_rtx (x, insn)\n \t      && INTVAL (inner_const) != 0)\n \t    {\n \t      int sign_bitnum = GET_MODE_BITSIZE (mode_arg0) - 1;\n-\t      int has_sign = (HOST_BITS_PER_INT >= sign_bitnum\n-\t\t\t      && (INTVAL (inner_const) & (1 << sign_bitnum)));\n+\t      int has_sign = (HOST_BITS_PER_WIDE_INT >= sign_bitnum\n+\t\t\t      && (INTVAL (inner_const)\n+\t\t\t\t  & ((HOST_WIDE_INT) 1 << sign_bitnum)));\n \t      rtx true = const_true_rtx, false = const0_rtx;\n \n #ifdef FLOAT_STORE_FLAG_VALUE\n@@ -5110,7 +5147,7 @@ equiv_constant (x)\n     {\n       struct table_elt *elt;\n \n-      x = fold_rtx (x, 0);\n+      x = fold_rtx (x, NULL_RTX);\n       if (CONSTANT_P (x))\n \treturn x;\n \n@@ -5340,13 +5377,13 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t new quantity number.  */\n       if (op0_elt == 0)\n \t{\n-\t  if (insert_regs (op0, 0, 0))\n+\t  if (insert_regs (op0, NULL_PTR, 0))\n \t    {\n \t      rehash_using_reg (op0);\n \t      op0_hash_code = HASH (op0, mode);\n \t    }\n \n-\t  op0_elt = insert (op0, 0, op0_hash_code, mode);\n+\t  op0_elt = insert (op0, NULL_PTR, op0_hash_code, mode);\n \t  op0_elt->in_memory = op0_in_memory;\n \t  op0_elt->in_struct = op0_in_struct;\n \t}\n@@ -5357,13 +5394,13 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t  /* Put OP1 in the hash table so it gets a new quantity number.  */\n \t  if (op1_elt == 0)\n \t    {\n-\t      if (insert_regs (op1, 0, 0))\n+\t      if (insert_regs (op1, NULL_PTR, 0))\n \t\t{\n \t\t  rehash_using_reg (op1);\n \t\t  op1_hash_code = HASH (op1, mode);\n \t\t}\n \n-\t      op1_elt = insert (op1, 0, op1_hash_code, mode);\n+\t      op1_elt = insert (op1, NULL_PTR, op1_hash_code, mode);\n \t      op1_elt->in_memory = op1_in_memory;\n \t      op1_elt->in_struct = op1_in_struct;\n \t    }\n@@ -5580,14 +5617,14 @@ cse_insn (insn, in_libcall_block)\n \t\t because we have already invalidated the reg.  */\n \t      if (GET_CODE (XEXP (y, 0)) == MEM)\n \t\t{\n-\t\t  canon_reg (XEXP (y, 0), 0);\n+\t\t  canon_reg (XEXP (y, 0), NULL_RTX);\n \t\t  note_mem_written (XEXP (y, 0), &writes_memory);\n \t\t}\n \t    }\n \t  else if (GET_CODE (y) == USE\n \t\t   && ! (GET_CODE (XEXP (y, 0)) == REG\n \t\t\t && REGNO (XEXP (y, 0)) < FIRST_PSEUDO_REGISTER))\n-\t    canon_reg (y, 0);\n+\t    canon_reg (y, NULL_RTX);\n \t  else if (GET_CODE (y) == CALL)\n \t    {\n \t      canon_reg (y, insn);\n@@ -5600,7 +5637,7 @@ cse_insn (insn, in_libcall_block)\n     {\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n \t{\n-\t  canon_reg (XEXP (x, 0), 0);\n+\t  canon_reg (XEXP (x, 0), NULL_RTX);\n \t  note_mem_written (XEXP (x, 0), &writes_memory);\n \t}\n     }\n@@ -5609,7 +5646,7 @@ cse_insn (insn, in_libcall_block)\n   else if (GET_CODE (x) == USE\n \t   && ! (GET_CODE (XEXP (x, 0)) == REG\n \t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER))\n-    canon_reg (XEXP (x, 0), 0);\n+    canon_reg (XEXP (x, 0), NULL_RTX);\n   else if (GET_CODE (x) == CALL)\n     {\n       canon_reg (x, insn);\n@@ -5620,10 +5657,10 @@ cse_insn (insn, in_libcall_block)\n   if (n_sets == 1 && REG_NOTES (insn) != 0)\n     {\n       /* Store the equivalent value in SRC_EQV, if different.  */\n-      rtx tem = find_reg_note (insn, REG_EQUAL, 0);\n+      rtx tem = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n       if (tem && ! rtx_equal_p (XEXP (tem, 0), SET_SRC (sets[0].rtl)))\n-        src_eqv = canon_reg (XEXP (tem, 0), 0);\n+        src_eqv = canon_reg (XEXP (tem, 0), NULL_RTX);\n     }\n \n   /* Canonicalize sources and addresses of destinations.\n@@ -5750,10 +5787,11 @@ cse_insn (insn, in_libcall_block)\n \n \t  if (GET_CODE (src) == CONST_INT\n \t      && GET_CODE (width) == CONST_INT\n-\t      && INTVAL (width) < HOST_BITS_PER_INT\n-\t      && (INTVAL (src) & ((-1) << INTVAL (width))))\n-\t    src_folded = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t  INTVAL (src) & ((1 << INTVAL (width)) - 1));\n+\t      && INTVAL (width) < HOST_BITS_PER_WIDE_INT\n+\t      && (INTVAL (src) & ((HOST_WIDE_INT) (-1) << INTVAL (width))))\n+\t    src_folded\n+\t      = GEN_INT (INTVAL (src) & (((HOST_WIDE_INT) 1\n+\t\t\t\t\t  << INTVAL (width)) - 1));\n \t}\n \n       /* Compute SRC's hash code, and also notice if it\n@@ -5932,7 +5970,7 @@ cse_insn (insn, in_libcall_block)\n \t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n \t  enum machine_mode tmode;\n-\t  rtx new_and = gen_rtx (AND, VOIDmode, 0, XEXP (src, 1));\n+\t  rtx new_and = gen_rtx (AND, VOIDmode, NULL_RTX, XEXP (src, 1));\n \n \t  for (tmode = GET_MODE_WIDER_MODE (mode);\n \t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n@@ -6202,7 +6240,7 @@ cse_insn (insn, in_libcall_block)\n       if (n_sets == 1 && src_const && GET_CODE (dest) == REG\n \t  && GET_CODE (src_const) != REG)\n \t{\n-\t  rtx tem = find_reg_note (insn, REG_EQUAL, 0);\n+\t  rtx tem = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \t  \n \t  /* Record the actual constant value in a REG_EQUAL note, making\n \t     a new one if one does not already exist.  */\n@@ -6227,7 +6265,7 @@ cse_insn (insn, in_libcall_block)\n \t      && qty_const[reg_qty[REGNO (dest)]] == const0_rtx)\n \t    {\n \t      /* See if we previously had a REG_WAS_0 note.  */\n-\t      rtx note = find_reg_note (insn, REG_WAS_0, 0);\n+\t      rtx note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n \t      rtx const_insn = qty_const_insn[reg_qty[REGNO (dest)]];\n \n \t      if ((tem = single_set (const_insn)) != 0\n@@ -6287,8 +6325,9 @@ cse_insn (insn, in_libcall_block)\n \n \t  if (src_const != 0 && GET_CODE (src_const) == CONST_INT\n \t      && GET_CODE (width) == CONST_INT\n-\t      && INTVAL (width) < HOST_BITS_PER_INT\n-\t      && ! (INTVAL (src_const) & ((-1) << INTVAL (width))))\n+\t      && INTVAL (width) < HOST_BITS_PER_WIDE_INT\n+\t      && ! (INTVAL (src_const)\n+\t\t    & ((HOST_WIDE_INT) (-1) << INTVAL (width))))\n \t    /* Exception: if the value is constant,\n \t       and it won't be truncated, record it.  */\n \t    ;\n@@ -6696,7 +6735,7 @@ cse_insn (insn, in_libcall_block)\n \t  && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl))\n \t{\n \t  rtx dest = SET_DEST (sets[0].rtl);\n-\t  rtx note = find_reg_note (prev, REG_EQUIV, 0);\n+\t  rtx note = find_reg_note (prev, REG_EQUIV, NULL_RTX);\n \n \t  validate_change (prev, & SET_DEST (PATTERN (prev)), dest, 1);\n \t  validate_change (insn, & SET_DEST (sets[0].rtl),\n@@ -6710,11 +6749,11 @@ cse_insn (insn, in_libcall_block)\n \n \t  /* If there was a REG_WAS_0 note on PREV, remove it.  Move\n \t     any REG_WAS_0 note on INSN to PREV.  */\n-\t  note = find_reg_note (prev, REG_WAS_0, 0);\n+\t  note = find_reg_note (prev, REG_WAS_0, NULL_RTX);\n \t  if (note)\n \t    remove_note (prev, note);\n \n-\t  note = find_reg_note (insn, REG_WAS_0, 0);\n+\t  note = find_reg_note (insn, REG_WAS_0, NULL_RTX);\n \t  if (note)\n \t    {\n \t      remove_note (insn, note);\n@@ -6889,9 +6928,9 @@ cse_process_notes (x, object)\n     case EXPR_LIST:\n     case INSN_LIST:\n       if (REG_NOTE_KIND (x) == REG_EQUAL)\n-\tXEXP (x, 0) = cse_process_notes (XEXP (x, 0), 0);\n+\tXEXP (x, 0) = cse_process_notes (XEXP (x, 0), NULL_RTX);\n       if (XEXP (x, 1))\n-\tXEXP (x, 1) = cse_process_notes (XEXP (x, 1), 0);\n+\tXEXP (x, 1) = cse_process_notes (XEXP (x, 1), NULL_RTX);\n       return x;\n \n     case SIGN_EXTEND:\n@@ -6920,13 +6959,13 @@ cse_process_notes (x, object)\n \t}\n \n       /* Otherwise, canonicalize this register.  */\n-      return canon_reg (x, 0);\n+      return canon_reg (x, NULL_RTX);\n     }\n \n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     if (fmt[i] == 'e')\n       validate_change (object, &XEXP (x, i),\n-\t\t       cse_process_notes (XEXP (x, i), object), 0);\n+\t\t       cse_process_notes (XEXP (x, i), object), NULL_RTX);\n \n   return x;\n }\n@@ -7478,8 +7517,8 @@ cse_main (f, nregs, after_loop, file)\n   /* Find the largest uid.  */\n \n   i = get_max_uid ();\n-  uid_cuid = (short *) alloca ((i + 1) * sizeof (short));\n-  bzero (uid_cuid, (i + 1) * sizeof (short));\n+  uid_cuid = (int *) alloca ((i + 1) * sizeof (int));\n+  bzero (uid_cuid, (i + 1) * sizeof (int));\n \n   /* Compute the mapping from uids to cuids.\n      CUIDs are numbers assigned to insns, like uids,\n@@ -7678,17 +7717,17 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t     looking for duplicate operations.  */\n \n \t  if (REG_NOTES (insn))\n-\t    REG_NOTES (insn) = cse_process_notes (REG_NOTES (insn), 0);\n+\t    REG_NOTES (insn) = cse_process_notes (REG_NOTES (insn), NULL_RTX);\n \n \t  /* Track when we are inside in LIBCALL block.  Inside such a block,\n \t     we do not want to record destinations.  The last insn of a\n \t     LIBCALL block is not considered to be part of the block, since\n \t     its destination is the result of the block and hence should be\n \t     recorded.  */\n \n-\t  if (find_reg_note (insn, REG_LIBCALL, 0))\n+\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \t    in_libcall_block = 1;\n-\t  else if (find_reg_note (insn, REG_RETVAL, 0))\n+\t  else if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t    in_libcall_block = 0;\n \n \t  cse_insn (insn, in_libcall_block);\n@@ -7893,7 +7932,7 @@ delete_dead_from_cse (insns, nreg)\n       /* Don't delete any insns that are part of a libcall block.\n \t Flow or loop might get confused if we did that.  Remember\n \t that we are scanning backwards.  */\n-      if (find_reg_note (insn, REG_RETVAL, 0))\n+      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \tin_libcall = 1;\n \n       if (in_libcall)\n@@ -7958,7 +7997,7 @@ delete_dead_from_cse (insns, nreg)\n \t  delete_insn (insn);\n \t}\n \n-      if (find_reg_note (insn, REG_LIBCALL, 0))\n+      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \tin_libcall = 0;\n     }\n }"}, {"sha": "75080a9b5e65d2f7717f8fd548025a9c2ae57a5f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -1498,7 +1498,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \n \t  if (! optimize)\n \t    output_loc_descriptor\n-\t      (eliminate_regs (SAVE_EXPR_RTL (bound), 0, 0));\n+\t      (eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n \n \t  ASM_OUTPUT_LABEL (asm_out_file, end_label);\n \t}\n@@ -1573,7 +1573,7 @@ location_attribute (rtl)\n      declaration, but not a definition.  So sayeth the PLSIG.  */\n \n   if (! is_pseudo_reg (rtl))\n-    output_loc_descriptor (eliminate_regs (rtl, 0, 0));\n+    output_loc_descriptor (eliminate_regs (rtl, 0, NULL_RTX));\n \n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n@@ -1783,8 +1783,8 @@ const_value_attribute (rtl)\n \t   simplicity we always just output CONST_DOUBLEs using 8 bytes.  */\n \n \tASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n-\t\t\t\t(unsigned) CONST_DOUBLE_HIGH (rtl),\n-\t\t\t\t(unsigned) CONST_DOUBLE_LOW (rtl));\n+\t\t\t\t(unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (rtl),\n+\t\t\t\t(unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (rtl));\n \tbreak;\n \n       case CONST_STRING:\n@@ -4320,7 +4320,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_SECTION);\n   finalizing = set_finalizing;\n-  output_decl (decl, NULL);\n+  output_decl (decl, NULL_TREE);\n \n   /* NOTE:  The call above to `output_decl' may have caused one or more\n      file-scope named types (i.e. tagged types) to be placed onto the\n@@ -4333,7 +4333,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n      `output_pending_types_for_scope' takes them off of the list and un-sets\n      their TREE_ASM_WRITTEN flags.  */\n \n-  output_pending_types_for_scope (NULL);\n+  output_pending_types_for_scope (NULL_TREE);\n \n   /* The above call should have totally emptied the pending_types_list.  */\n "}, {"sha": "8af05c5c9d774cde8bc76d2ca7eadfb94d2800d7", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -247,7 +247,7 @@ gen_rtx (va_alist)\n \n   if (code == CONST_INT)\n     {\n-      int arg = va_arg (p, int);\n+      HOST_WIDE_INT arg = va_arg (p, HOST_WIDE_INT);\n \n       if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n \treturn const_int_rtx[arg + MAX_SAVED_CONST_INT];\n@@ -306,6 +306,10 @@ gen_rtx (va_alist)\n \t      XINT (rt_val, i) = va_arg (p, int);\n \t      break;\n \n+\t    case 'w':\t\t/* A wide integer? */\n+\t      XWINT (rt_val, i) = va_arg (p, HOST_WIDE_INT);\n+\t      break;\n+\n \t    case 's':\t\t/* A string?  */\n \t      XSTR (rt_val, i) = va_arg (p, char *);\n \t      break;\n@@ -538,25 +542,26 @@ gen_lowpart_common (mode, x)\n \t either a reasonable negative value or a reasonable unsigned value\n \t for this mode.  */\n \n-      if (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_INT)\n+      if (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT)\n \treturn x;\n-      else if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_INT)\n+      else if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n \treturn 0;\n-      else if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_INT)\n+      else if (GET_MODE_BITSIZE (mode) == HOST_BITS_PER_WIDE_INT)\n \treturn (GET_CODE (x) == CONST_INT ? x\n-\t\t: gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (x)));\n+\t\t: GEN_INT (CONST_DOUBLE_LOW (x)));\n       else\n \t{\n \t  /* MODE must be narrower than HOST_BITS_PER_INT.  */\n \t  int width = GET_MODE_BITSIZE (mode);\n-\t  int val = (GET_CODE (x) == CONST_INT ? INTVAL (x)\n-\t\t     : CONST_DOUBLE_LOW (x));\n+\t  HOST_WIDE_INT val = (GET_CODE (x) == CONST_INT ? INTVAL (x)\n+\t\t\t       : CONST_DOUBLE_LOW (x));\n \n-\t  if (((val & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-\t    val &= (1 << width) - 1;\n+\t  if (((val & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t       != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+\t    val &= ((HOST_WIDE_INT) 1 << width) - 1;\n \n \t  return (GET_CODE (x) == CONST_INT && INTVAL (x) == val ? x\n-\t\t  : gen_rtx (CONST_INT, VOIDmode, val));\n+\t\t  : GEN_INT (val));\n \t}\n     }\n \n@@ -567,33 +572,34 @@ gen_lowpart_common (mode, x)\n      different.  */\n \n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n \t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n \t   && GET_CODE (x) == CONST_INT\n-\t   && sizeof (float) * HOST_BITS_PER_CHAR == HOST_BITS_PER_INT)\n+\t   && sizeof (float) * HOST_BITS_PER_CHAR == HOST_BITS_PER_WIDE_INT)\n     {\n-      union {int i; float d; } u;\n+      union {HOST_WIDE_INT i; float d; } u;\n \n       u.i = INTVAL (x);\n       return immed_real_const_1 (u.d, mode);\n     }\n \n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n \t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n \t   && GET_MODE (x) == VOIDmode\n-\t   && sizeof (double) * HOST_BITS_PER_CHAR == 2 * HOST_BITS_PER_INT)\n+\t   && (sizeof (double) * HOST_BITS_PER_CHAR\n+\t       == 2 * HOST_BITS_PER_WIDE_INT))\n     {\n-      union {int i[2]; double d; } u;\n-      int low, high;\n+      union {HOST_WIDE_INT i[2]; double d; } u;\n+      HOST_WIDE_INT low, high;\n \n       if (GET_CODE (x) == CONST_INT)\n-\tlow = INTVAL (x), high = low >> (HOST_BITS_PER_INT -1);\n+\tlow = INTVAL (x), high = low >> (HOST_BITS_PER_WIDE_INT -1);\n       else\n \tlow = CONST_DOUBLE_LOW (x), high = CONST_DOUBLE_HIGH (x);\n \n@@ -611,7 +617,7 @@ gen_lowpart_common (mode, x)\n      compatible.  */\n \n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n \t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && GET_CODE (x) == CONST_DOUBLE\n@@ -625,7 +631,7 @@ gen_lowpart_common (mode, x)\n      compatible.  */\n \n   else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n \t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && GET_CODE (x) == CONST_DOUBLE\n@@ -725,8 +731,8 @@ operand_subword (op, i, validate_address, mode)\n      int validate_address;\n      enum machine_mode mode;\n {\n-  int val;\n-  int size_ratio = HOST_BITS_PER_INT / BITS_PER_WORD;\n+  HOST_WIDE_INT val;\n+  int size_ratio = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -793,13 +799,12 @@ operand_subword (op, i, validate_address, mode)\n      target floating formats are the same, handling two-word floating\n      constants are easy.  */\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t&& HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n        || flag_pretend_float)\n       && GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && GET_CODE (op) == CONST_DOUBLE)\n-    return gen_rtx (CONST_INT, VOIDmode,\n-\t\t    i ^ (WORDS_BIG_ENDIAN !=\n+    return GEN_INT (i ^ (WORDS_BIG_ENDIAN !=\n /* The constant is stored in the host's word-ordering,\n    but we want to access it in the target's word-ordering.  */\n #ifdef HOST_WORDS_BIG_ENDIAN\n@@ -813,19 +818,19 @@ operand_subword (op, i, validate_address, mode)\n      values often do not have the same high-order bits.  We have already\n      verified that we want the only defined word of the single-word value.  */\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t&& HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n        || flag_pretend_float)\n       && GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n       && GET_CODE (op) == CONST_DOUBLE)\n     {\n       double d;\n-      union {float f; int i; } u;\n+      union {float f; HOST_WIDE_INT i; } u;\n \n       REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n \n       u.f = d;\n-      return gen_rtx (CONST_INT, VOIDmode, u.i);\n+      return GEN_INT (u.i);\n     }\n       \n   /* The only remaining cases that we can handle are integers.\n@@ -854,11 +859,12 @@ operand_subword (op, i, validate_address, mode)\n \t    ? (INTVAL (op) < 0 ? ~0 : 0) : CONST_DOUBLE_HIGH (op)));\n \n   /* If BITS_PER_WORD is smaller than an int, get the appropriate bits.  */\n-  if (BITS_PER_WORD < HOST_BITS_PER_INT)\n+  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT)\n     val = ((val >> ((i % size_ratio) * BITS_PER_WORD))\n-\t   & ((1 << (BITS_PER_WORD % HOST_BITS_PER_INT)) - 1));\n+\t   & (((HOST_WIDE_INT) 1\n+\t       << (BITS_PER_WORD % HOST_BITS_PER_WIDE_INT)) - 1));\n \n-  return gen_rtx (CONST_INT, VOIDmode, val);\n+  return GEN_INT (val);\n }\n \n /* Similar to `operand_subword', but never return 0.  If we can't extract\n@@ -965,7 +971,8 @@ change_address (memref, mode, addr)\n rtx\n gen_label_rtx ()\n {\n-  register rtx label = gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0, label_num++, 0);\n+  register rtx label = gen_rtx (CODE_LABEL, VOIDmode, 0, 0, 0,\n+\t\t\t\tlabel_num++, NULL_PTR);\n   LABEL_NUSES (label) = 0;\n   return label;\n }\n@@ -991,7 +998,7 @@ gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n      rtx original_decl_initial;\n {\n   rtx header = gen_rtx (INLINE_HEADER, VOIDmode,\n-\t\t\tcur_insn_uid++, NULL,\n+\t\t\tcur_insn_uid++, NULL_RTX,\n \t\t\tfirst_insn, first_parm_insn,\n \t\t\tfirst_labelno, last_labelno,\n \t\t\tmax_parm_regnum, max_regnum, args_size, pops_args,\n@@ -1577,7 +1584,7 @@ rtx\n next_cc0_user (insn)\n      rtx insn;\n {\n-  rtx note = find_reg_note (insn, REG_CC_USER, 0);\n+  rtx note = find_reg_note (insn, REG_CC_USER, NULL_RTX);\n \n   if (note)\n     return XEXP (note, 0);\n@@ -1600,7 +1607,7 @@ rtx\n prev_cc0_setter (insn)\n      rtx insn;\n {\n-  rtx note = find_reg_note (insn, REG_CC_SETTER, 0);\n+  rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n   rtx link;\n \n   if (note)\n@@ -1903,7 +1910,7 @@ emit_insn_before (pattern, before)\n     }\n   else\n     {\n-      insn = make_insn_raw (pattern, 0);\n+      insn = make_insn_raw (pattern, NULL_RTVEC);\n       add_insn_after (insn, PREV_INSN (before));\n     }\n \n@@ -1923,7 +1930,7 @@ emit_jump_insn_before (pattern, before)\n     insn = emit_insn_before (pattern, before);\n   else\n     {\n-      insn = make_jump_insn_raw (pattern, 0);\n+      insn = make_jump_insn_raw (pattern, NULL_RTVEC);\n       add_insn_after (insn, PREV_INSN (before));\n     }\n \n@@ -1997,7 +2004,7 @@ emit_insn_after (pattern, after)\n     }\n   else\n     {\n-      insn = make_insn_raw (pattern, 0);\n+      insn = make_insn_raw (pattern, NULL_RTVEC);\n       add_insn_after (insn, after);\n     }\n \n@@ -2017,7 +2024,7 @@ emit_jump_insn_after (pattern, after)\n     insn = emit_insn_after (pattern, after);\n   else\n     {\n-      insn = make_jump_insn_raw (pattern, 0);\n+      insn = make_jump_insn_raw (pattern, NULL_RTVEC);\n       add_insn_after (insn, after);\n     }\n \n@@ -2123,7 +2130,7 @@ emit_insn (pattern)\n     }\n   else\n     {\n-      insn = make_insn_raw (pattern, NULL);\n+      insn = make_insn_raw (pattern, NULL_RTVEC);\n       add_insn (insn);\n     }\n \n@@ -2182,7 +2189,7 @@ emit_jump_insn (pattern)\n     return emit_insn (pattern);\n   else\n     {\n-      register rtx insn = make_jump_insn_raw (pattern, NULL);\n+      register rtx insn = make_jump_insn_raw (pattern, NULL_RTVEC);\n       add_insn (insn);\n       return insn;\n     }\n@@ -2199,7 +2206,7 @@ emit_call_insn (pattern)\n     return emit_insn (pattern);\n   else\n     {\n-      register rtx insn = make_insn_raw (pattern, NULL);\n+      register rtx insn = make_insn_raw (pattern, NULL_RTVEC);\n       add_insn (insn);\n       PUT_CODE (insn, CALL_INSN);\n       return insn;\n@@ -2712,13 +2719,13 @@ init_emit_once (line_numbers)\n     }\n \n   /* These four calls obtain some of the rtx expressions made above.  */\n-  const0_rtx = gen_rtx (CONST_INT, VOIDmode, 0);\n-  const1_rtx = gen_rtx (CONST_INT, VOIDmode, 1);\n-  const2_rtx = gen_rtx (CONST_INT, VOIDmode, 2);\n-  constm1_rtx = gen_rtx (CONST_INT, VOIDmode, -1);\n+  const0_rtx = GEN_INT (0);\n+  const1_rtx = GEN_INT (1);\n+  const2_rtx = GEN_INT (2);\n+  constm1_rtx = GEN_INT (-1);\n \n   /* This will usually be one of the above constants, but may be a new rtx.  */\n-  const_true_rtx = gen_rtx (CONST_INT, VOIDmode, STORE_FLAG_VALUE);\n+  const_true_rtx = GEN_INT (STORE_FLAG_VALUE);\n \n   dconst0 = REAL_VALUE_ATOF (\"0\");\n   dconst1 = REAL_VALUE_ATOF (\"1\");\n@@ -2743,11 +2750,11 @@ init_emit_once (line_numbers)\n \t  const_tiny_rtx[i][(int) mode] = tem;\n \t}\n \n-      const_tiny_rtx[i][(int) VOIDmode] = gen_rtx (CONST_INT, VOIDmode, i);\n+      const_tiny_rtx[i][(int) VOIDmode] = GEN_INT (i);\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n-\tconst_tiny_rtx[i][(int) mode] = gen_rtx (CONST_INT, VOIDmode, i);\n+\tconst_tiny_rtx[i][(int) mode] = GEN_INT (i);\n     }\n \n   stack_pointer_rtx = gen_rtx (REG, Pmode, STACK_POINTER_REGNUM);"}, {"sha": "e1a94e7e359d476edea9728a47b91453e20660c4", "filename": "gcc/expr.c", "status": "modified", "additions": 217, "deletions": 224, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -242,7 +242,7 @@ enqueue_insn (var, body)\n      rtx var, body;\n {\n   pending_chain = gen_rtx (QUEUED, GET_MODE (var),\n-\t\t\t   var, 0, 0, body, pending_chain);\n+\t\t\t   var, NULL_RTX, NULL_RTX, body, pending_chain);\n   return pending_chain;\n }\n \n@@ -601,7 +601,8 @@ convert_move (to, from, unsignedp)\n \t      && insn_operand_mode[(int) CODE_FOR_slt][0] == word_mode\n \t      && STORE_FLAG_VALUE == -1)\n \t    {\n-\t      emit_cmp_insn (lowfrom, const0_rtx, NE, 0, lowpart_mode, 0, 0);\n+\t      emit_cmp_insn (lowfrom, const0_rtx, NE, NULL_RTX,\n+\t\t\t     lowpart_mode, 0, 0);\n \t      fill_value = gen_reg_rtx (word_mode);\n \t      emit_insn (gen_slt (fill_value));\n \t    }\n@@ -611,7 +612,7 @@ convert_move (to, from, unsignedp)\n \t      fill_value\n \t\t= expand_shift (RSHIFT_EXPR, lowpart_mode, lowfrom,\n \t\t\t\tsize_int (GET_MODE_BITSIZE (lowpart_mode) - 1),\n-\t\t\t\t0, 0);\n+\t\t\t\tNULL_RTX, 0);\n \t      fill_value = convert_to_mode (word_mode, fill_value, 1);\n \t    }\n \t}\n@@ -632,7 +633,7 @@ convert_move (to, from, unsignedp)\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, to, from, 0,\n+      emit_no_conflict_block (insns, to, from, NULL_RTX,\n \t\t\t      gen_rtx (equiv_code, to_mode, from));\n       return;\n     }\n@@ -844,15 +845,15 @@ convert_to_mode (mode, x, unsignedp)\n     return x;\n \n   /* There is one case that we must handle specially: If we are converting\n-     a CONST_INT into a mode whose size is twice HOST_BITS_PER_INT and\n+     a CONST_INT into a mode whose size is twice HOST_BITS_PER_WIDE_INT and\n      we are to interpret the constant as unsigned, gen_lowpart will do\n      the wrong if the constant appears negative.  What we want to do is\n      make the high-order word of the constant zero, not all ones.  */\n \n   if (unsignedp && GET_MODE_CLASS (mode) == MODE_INT\n-      && GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_INT\n+      && GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT\n       && GET_CODE (x) == CONST_INT && INTVAL (x) < 0)\n-    return immed_double_const (INTVAL (x), 0, mode);\n+    return immed_double_const (INTVAL (x), (HOST_WIDE_INT) 0, mode);\n \n   /* We can do this with a gen_lowpart if both desired and current modes\n      are integer, and this is either a constant integer, a register, or a\n@@ -1074,21 +1075,17 @@ move_by_pieces_1 (genfun, mode, data)\n \n #ifdef HAVE_PRE_DECREMENT\n       if (data->explicit_inc_to < 0)\n-\temit_insn (gen_add2_insn (data->to_addr,\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, -size)));\n+\temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n       if (data->explicit_inc_from < 0)\n-\temit_insn (gen_add2_insn (data->from_addr,\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, -size)));\n+\temit_insn (gen_add2_insn (data->from_addr, GEN_INT (-size)));\n #endif\n \n       emit_insn ((*genfun) (to1, from1));\n #ifdef HAVE_POST_INCREMENT\n       if (data->explicit_inc_to > 0)\n-\temit_insn (gen_add2_insn (data->to_addr,\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, size)));\n+\temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));\n       if (data->explicit_inc_from > 0)\n-\temit_insn (gen_add2_insn (data->from_addr,\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, size)));\n+\temit_insn (gen_add2_insn (data->from_addr, GEN_INT (size)));\n #endif\n \n       if (! data->reverse) data->offset += size;\n@@ -1130,8 +1127,7 @@ emit_block_move (x, y, size, align)\n     abort ();\n \n   if (GET_CODE (size) == CONST_INT\n-      && (move_by_pieces_ninsns ((unsigned) INTVAL (size), align)\n-\t  < MOVE_RATIO))\n+      && (move_by_pieces_ninsns (INTVAL (size), align) < MOVE_RATIO))\n     move_by_pieces (x, y, INTVAL (size), align);\n   else\n     {\n@@ -1144,8 +1140,7 @@ emit_block_move (x, y, size, align)\n \t  && ((unsigned) INTVAL (size)\n \t      < (1 << (GET_MODE_BITSIZE (QImode) - 1))))\n \t{\n-\t  rtx insn = gen_movstrqi (x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align));\n+\t  rtx insn = gen_movstrqi (x, y, size, GEN_INT (align));\n \t  if (insn)\n \t    {\n \t      emit_insn (insn);\n@@ -1159,8 +1154,7 @@ emit_block_move (x, y, size, align)\n \t  && ((unsigned) INTVAL (size)\n \t      < (1 << (GET_MODE_BITSIZE (HImode) - 1))))\n \t{\n-\t  rtx insn = gen_movstrhi (x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align));\n+\t  rtx insn = gen_movstrhi (x, y, size, GEN_INT (align));\n \t  if (insn)\n \t    {\n \t      emit_insn (insn);\n@@ -1171,8 +1165,7 @@ emit_block_move (x, y, size, align)\n #ifdef HAVE_movstrsi\n       if (HAVE_movstrsi)\n \t{\n-\t  rtx insn = gen_movstrsi (x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align));\n+\t  rtx insn = gen_movstrsi (x, y, size, GEN_INT (align));\n \t  if (insn)\n \t    {\n \t      emit_insn (insn);\n@@ -1183,8 +1176,7 @@ emit_block_move (x, y, size, align)\n #ifdef HAVE_movstrdi\n       if (HAVE_movstrdi)\n \t{\n-\t  rtx insn = gen_movstrdi (x, y, size,\n-\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, align));\n+\t  rtx insn = gen_movstrdi (x, y, size, GEN_INT (align));\n \t  if (insn)\n \t    {\n \t      emit_insn (insn);\n@@ -1227,7 +1219,7 @@ move_block_to_reg (regno, x, nregs, mode)\n #ifdef HAVE_load_multiple\n   last = get_last_insn ();\n   pat = gen_load_multiple (gen_rtx (REG, word_mode, regno), x,\n-\t\t\t   gen_rtx (CONST_INT, VOIDmode, nregs));\n+\t\t\t   GEN_INT (nregs));\n   if (pat)\n     {\n       emit_insn (pat);\n@@ -1258,7 +1250,7 @@ move_block_from_reg (regno, x, nregs)\n #ifdef HAVE_store_multiple\n   last = get_last_insn ();\n   pat = gen_store_multiple (x, gen_rtx (REG, word_mode, regno),\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, nregs));\n+\t\t\t    GEN_INT (nregs));\n   if (pat)\n     {\n       emit_insn (pat);\n@@ -1306,12 +1298,12 @@ clear_storage (object, size)\n       emit_library_call (memset_libfunc, 1,\n \t\t\t VOIDmode, 3,\n \t\t\t XEXP (object, 0), Pmode, const0_rtx, Pmode,\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, size), Pmode);\n+\t\t\t GEN_INT (size), Pmode);\n #else\n       emit_library_call (bzero_libfunc, 1,\n \t\t\t VOIDmode, 2,\n \t\t\t XEXP (object, 0), Pmode,\n-\t\t\t gen_rtx (CONST_INT, VOIDmode, size), Pmode);\n+\t\t\t GEN_INT (size), Pmode);\n #endif\n     }\n   else\n@@ -1424,9 +1416,7 @@ push_block (size, extra, below)\n     {\n       rtx temp = copy_to_mode_reg (Pmode, size);\n       if (extra != 0)\n-\ttemp = expand_binop (Pmode, add_optab,\n-\t\t\t     temp,\n-\t\t\t     gen_rtx (CONST_INT, VOIDmode, extra),\n+\ttemp = expand_binop (Pmode, add_optab, temp, GEN_INT (extra),\n \t\t\t     temp, 0, OPTAB_LIB_WIDEN);\n       anti_adjust_stack (temp);\n     }\n@@ -1568,7 +1558,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t     But if space already allocated, this has already been done.  */\n \t  if (extra && args_addr == 0\n \t      && where_pad != none && where_pad != stack_direction)\n-\t    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode, extra));\n+\t    anti_adjust_stack (GEN_INT (extra));\n \n \t  move_by_pieces (gen_rtx (MEM, BLKmode, gen_push_operand ()), xinner,\n \t\t\t  INTVAL (size) - used, align);\n@@ -1583,11 +1573,11 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  if (partial != 0)\n \t    {\n \t      if (GET_CODE (size) == CONST_INT)\n-\t\tsize = gen_rtx (CONST_INT, VOIDmode, INTVAL (size) - used);\n+\t\tsize = GEN_INT (INTVAL (size) - used);\n \t      else\n \t\tsize = expand_binop (GET_MODE (size), sub_optab, size,\n-\t\t\t\t     gen_rtx (CONST_INT, VOIDmode, used),\n-\t\t\t\t     0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t     GEN_INT (used), NULL_RTX, 0,\n+\t\t\t\t     OPTAB_LIB_WIDEN);\n \t    }\n \n \t  /* Get the address of the stack space.\n@@ -1627,8 +1617,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t  < (1 << (GET_MODE_BITSIZE (QImode) - 1))))\n \t    {\n \t      emit_insn (gen_movstrqi (gen_rtx (MEM, BLKmode, temp),\n-\t\t\t\t       xinner, size,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t       xinner, size, GEN_INT (align)));\n \t      goto ret;\n \t    }\n #endif\n@@ -1639,26 +1628,23 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t  < (1 << (GET_MODE_BITSIZE (HImode) - 1))))\n \t    {\n \t      emit_insn (gen_movstrhi (gen_rtx (MEM, BLKmode, temp),\n-\t\t\t\t       xinner, size,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t       xinner, size, GEN_INT (align)));\n \t      goto ret;\n \t    }\n #endif\n #ifdef HAVE_movstrsi\n \t  if (HAVE_movstrsi)\n \t    {\n \t      emit_insn (gen_movstrsi (gen_rtx (MEM, BLKmode, temp),\n-\t\t\t\t       xinner, size,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t       xinner, size, GEN_INT (align)));\n \t      goto ret;\n \t    }\n #endif\n #ifdef HAVE_movstrdi\n \t  if (HAVE_movstrdi)\n \t    {\n \t      emit_insn (gen_movstrdi (gen_rtx (MEM, BLKmode, temp),\n-\t\t\t\t       xinner, size,\n-\t\t\t\t       gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t       xinner, size, GEN_INT (align)));\n \t      goto ret;\n \t    }\n #endif\n@@ -1706,7 +1692,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t But if space already allocated, this has already been done.  */\n       if (extra && args_addr == 0\n \t  && where_pad != none && where_pad != stack_direction)\n-\tanti_adjust_stack (gen_rtx (CONST_INT, VOIDmode, extra));\n+\tanti_adjust_stack (GEN_INT (extra));\n \n       /* If we make space by pushing it, we might as well push\n \t the real data.  Otherwise, we can leave OFFSET nonzero\n@@ -1747,9 +1733,9 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n #endif\n \tif (i >= not_stack + offset)\n \t  emit_push_insn (operand_subword_force (x, i, mode),\n-\t\t\t  word_mode, 0, 0, align, 0, 0, 0, args_addr,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   args_offset + ((i - not_stack + skip)\n+\t\t\t  word_mode, NULL_TREE, NULL_RTX, align, 0, NULL_RTX,\n+\t\t\t  0, args_addr,\n+\t\t\t  GEN_INT (args_offset + ((i - not_stack + skip)\n \t\t\t\t\t\t  * UNITS_PER_WORD)));\n     }\n   else\n@@ -1761,7 +1747,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t But if space already allocated, this has already been done.  */\n       if (extra && args_addr == 0\n \t  && where_pad != none && where_pad != stack_direction)\n-\tanti_adjust_stack (gen_rtx (CONST_INT, VOIDmode, extra));\n+\tanti_adjust_stack (GEN_INT (extra));\n \n #ifdef PUSH_ROUNDING\n       if (args_addr == 0)\n@@ -1787,7 +1773,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n     move_block_to_reg (REGNO (reg), x, partial, mode);\n \n   if (extra && args_addr == 0 && where_pad == stack_direction)\n-    anti_adjust_stack (gen_rtx (CONST_INT, VOIDmode, extra));\n+    anti_adjust_stack (GEN_INT (extra));\n }\n \f\n /* Output a library call to function FUN (a SYMBOL_REF rtx)\n@@ -1864,29 +1850,29 @@ emit_library_call (va_alist)\n       /* Make sure it is a reasonable operand for a move or push insn.  */\n       if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n \t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n-\tval = force_operand (val, 0);\n+\tval = force_operand (val, NULL_RTX);\n \n       argvec[count].value = val;\n       argvec[count].mode = mode;\n \n #ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, (tree)0, 1))\n+      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n \tabort ();\n #endif\n \n-      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, (tree)0, 1);\n+      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n       if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n \tabort ();\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n-\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, (tree)0, 1);\n+\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n #else\n       argvec[count].partial = 0;\n #endif\n \n-      locate_and_pad_parm (mode, 0,\n+      locate_and_pad_parm (mode, NULL_TREE,\n \t\t\t   argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t   0, &args_size, &argvec[count].offset,\n+\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n \t\t\t   &argvec[count].size);\n \n       if (argvec[count].size.var)\n@@ -1942,8 +1928,7 @@ emit_library_call (va_alist)\n #endif\n \n #ifndef PUSH_ROUNDING\n-  argblock = push_block (gen_rtx (CONST_INT, VOIDmode, args_size.constant),\n-\t\t\t 0, 0);\n+  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n #endif\n \n #ifdef PUSH_ARGS_REVERSED\n@@ -1964,9 +1949,8 @@ emit_library_call (va_alist)\n       int partial = argvec[argnum].partial;\n \n       if (! (reg != 0 && partial == 0))\n-\temit_push_insn (val, mode, 0, 0, 0, partial, reg, 0, argblock,\n-\t\t\tgen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t argvec[count].offset.constant));\n+\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n+\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n       NO_DEFER_POP;\n     }\n \n@@ -2003,7 +1987,7 @@ emit_library_call (va_alist)\n   use_insns = get_insns ();\n   end_sequence ();\n \n-  fun = prepare_call_address (fun, 0, &use_insns);\n+  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n \n   /* Don't allow popping to be deferred, since then\n      cse'ing of library calls could delete a call and leave the pop.  */\n@@ -2014,7 +1998,7 @@ emit_library_call (va_alist)\n \n   emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       outmode != VOIDmode ? hard_libcall_value (outmode) : 0,\n+\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n \t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n@@ -2045,7 +2029,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n   /* Don't crash if the lhs of the assignment was erroneous.  */\n \n   if (TREE_CODE (to) == ERROR_MARK)\n-    return expand_expr (from, 0, VOIDmode, 0);\n+    return expand_expr (from, NULL_RTX, VOIDmode, 0);\n \n   /* Assignment of a structure component needs special treatment\n      if the structure component's rtx is not simply a MEM.\n@@ -2073,10 +2057,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      to_rtx = expand_expr (tem, 0, VOIDmode, 0);\n+      to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n       if (offset != 0)\n \t{\n-\t  rtx offset_rtx = expand_expr (offset, 0, VOIDmode, 0);\n+\t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \n \t  if (GET_CODE (to_rtx) != MEM)\n \t    abort ();\n@@ -2115,7 +2099,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      Don't re-expand if it was expanded already (in COMPONENT_REF case).  */\n \n   if (to_rtx == 0)\n-    to_rtx = expand_expr (to, 0, VOIDmode, 0);\n+    to_rtx = expand_expr (to, NULL_RTX, VOIDmode, 0);\n \n   /* In case we are returning the contents of an object which overlaps\n      the place the value is being stored, use a safe function when copying\n@@ -2124,7 +2108,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       && current_function_returns_struct\n       && !current_function_returns_pcc_struct)\n     {\n-      rtx from_rtx = expand_expr (from, 0, VOIDmode, 0);\n+      rtx from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n       rtx size = expr_size (from);\n \n #ifdef TARGET_MEM_FUNCTIONS\n@@ -2211,7 +2195,7 @@ store_expr (exp, target, suggest_reg)\n        if EXP is another assignment, SUGGEST_REG will be nonzero for it.\n        We know expand_expr will not use the target in that case.  */\n     {\n-      temp = expand_expr (exp, cse_not_expected ? 0 : target,\n+      temp = expand_expr (exp, cse_not_expected ? NULL_RTX : target,\n \t\t\t  GET_MODE (target), 0);\n       if (GET_MODE (temp) != BLKmode && GET_MODE (temp) != VOIDmode)\n \ttemp = copy_to_reg (temp);\n@@ -2231,7 +2215,7 @@ store_expr (exp, target, suggest_reg)\n \t  temp = expand_expr (exp, temp, GET_MODE (target), 0);\n \t}\n       else\n-\ttemp = expand_expr (exp, 0, GET_MODE (target), 0);\n+\ttemp = expand_expr (exp, NULL_RTX, GET_MODE (target), 0);\n       dont_return_target = 1;\n     }\n   else\n@@ -2291,7 +2275,8 @@ store_expr (exp, target, suggest_reg)\n \t\t\t\t\t   size_int (BITS_PER_UNIT)),\n \t\t\t       convert (sizetype,\n \t\t\t\t\tbuild_int_2 (TREE_STRING_LENGTH (exp), 0))));\n-\t      rtx copy_size_rtx = expand_expr (copy_size, 0, VOIDmode, 0);\n+\t      rtx copy_size_rtx = expand_expr (copy_size, NULL_RTX,\n+\t\t\t\t\t       VOIDmode, 0);\n \t      rtx label = 0;\n \n \t      /* Copy that much.  */\n@@ -2313,12 +2298,14 @@ store_expr (exp, target, suggest_reg)\n \n \t\t  temp = force_reg (Pmode, XEXP (target, 0));\n \t\t  temp = expand_binop (size_mode, add_optab, temp,\n-\t\t\t\t       copy_size_rtx, 0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n+\t\t\t\t       OPTAB_LIB_WIDEN);\n \n \t\t  size = expand_binop (size_mode, sub_optab, size,\n-\t\t\t\t       copy_size_rtx, 0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n+\t\t\t\t       OPTAB_LIB_WIDEN);\n \n-\t\t  emit_cmp_insn (size, const0_rtx, LT, 0,\n+\t\t  emit_cmp_insn (size, const0_rtx, LT, NULL_RTX,\n \t\t\t\t GET_MODE (size), 0, 0);\n \t\t  label = gen_label_rtx ();\n \t\t  emit_jump_insn (gen_blt (label));\n@@ -2438,8 +2425,8 @@ store_constructor (exp, target)\n       register tree elt;\n       register int i;\n       tree domain = TYPE_DOMAIN (type);\n-      int minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n-      int maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n+      HOST_WIDE_INT minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n+      HOST_WIDE_INT maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n       tree elttype = TREE_TYPE (type);\n \n       /* If the constructor has fewer fields than the structure,\n@@ -2511,10 +2498,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n      int align;\n      int total_size;\n {\n-  int width_mask = 0;\n+  HOST_WIDE_INT width_mask = 0;\n \n-  if (bitsize < HOST_BITS_PER_INT)\n-    width_mask = (1 << bitsize) - 1;\n+  if (bitsize < HOST_BITS_PER_WIDE_INT)\n+    width_mask = ((HOST_WIDE_INT) 1 << bitsize) - 1;\n \n   /* If we are storing into an unaligned field of an aligned union that is\n      in a register, we may have the mode of TARGET being an integer mode but\n@@ -2556,7 +2543,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       || GET_CODE (target) == REG\n       || GET_CODE (target) == SUBREG)\n     {\n-      rtx temp = expand_expr (exp, 0, VOIDmode, 0);\n+      rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n       /* Store the value in the bitfield.  */\n       store_bit_field (target, bitsize, bitpos, mode, temp, align, total_size);\n       if (value_mode != VOIDmode)\n@@ -2565,10 +2552,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t  /* If possible, avoid refetching from the bitfield itself.  */\n \t  if (width_mask != 0\n \t      && ! (GET_CODE (target) == MEM && MEM_VOLATILE_P (target)))\n-\t    return expand_and (temp,\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode, width_mask), 0);\n+\t    return expand_and (temp, GEN_INT (width_mask), NULL_RTX);\n \t  return extract_bit_field (target, bitsize, bitpos, unsignedp,\n-\t\t\t\t    0, value_mode, 0, align, total_size);\n+\t\t\t\t    NULL_RTX, value_mode, 0, align,\n+\t\t\t\t    total_size);\n \t}\n       return const0_rtx;\n     }\n@@ -2785,7 +2772,7 @@ force_operand (value, target)\n \tsubtarget = 0;\n       tmp = force_operand (XEXP (value, 0), subtarget);\n       return expand_mult (GET_MODE (value), tmp,\n-\t\t\t  force_operand (op2, 0),\n+\t\t\t  force_operand (op2, NULL_RTX),\n \t\t\t  target, 0);\n     }\n \n@@ -2823,7 +2810,7 @@ force_operand (value, target)\n \t\t\t\t   \n       tmp = force_operand (XEXP (value, 0), subtarget);\n       return expand_binop (GET_MODE (value), binoptab, tmp,\n-\t\t\t   force_operand (op2, 0),\n+\t\t\t   force_operand (op2, NULL_RTX),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n       /* We give UNSIGNEP = 0 to expand_binop\n \t because the only operations we are expanding here are signed ones.  */\n@@ -2851,13 +2838,14 @@ save_noncopied_parts (lhs, list)\n       {\n \ttree part = TREE_VALUE (tail);\n \ttree part_type = TREE_TYPE (part);\n-\ttree to_be_saved = build (COMPONENT_REF, part_type, lhs, part, 0);\n+\ttree to_be_saved = build (COMPONENT_REF, part_type, lhs, part);\n \trtx target = assign_stack_temp (TYPE_MODE (part_type),\n \t\t\t\t\tint_size_in_bytes (part_type), 0);\n \tif (! memory_address_p (TYPE_MODE (part_type), XEXP (target, 0)))\n-\t  target = change_address (target, TYPE_MODE (part_type), 0);\n+\t  target = change_address (target, TYPE_MODE (part_type), NULL_RTX);\n \tparts = tree_cons (to_be_saved,\n-\t\t\t   build (RTL_EXPR, part_type, 0, (tree) target),\n+\t\t\t   build (RTL_EXPR, part_type, NULL_TREE,\n+\t\t\t\t  (tree) target),\n \t\t\t   parts);\n \tstore_expr (TREE_PURPOSE (parts), RTL_EXPR_RTL (TREE_VALUE (parts)), 0);\n       }\n@@ -2883,7 +2871,7 @@ init_noncopied_parts (lhs, list)\n       {\n \ttree part = TREE_VALUE (tail);\n \ttree part_type = TREE_TYPE (part);\n-\ttree to_be_initialized = build (COMPONENT_REF, part_type, lhs, part, 0);\n+\ttree to_be_initialized = build (COMPONENT_REF, part_type, lhs, part);\n \tparts = tree_cons (TREE_PURPOSE (tail), to_be_initialized, parts);\n       }\n   return parts;\n@@ -3304,8 +3292,8 @@ expand_expr (exp, target, tmode, modifier)\n       /* Exit the current loop if the body-expression is true.  */\n       {\n \trtx label = gen_label_rtx ();\n-\tdo_jump (TREE_OPERAND (exp, 0), label, 0);\n-\texpand_exit_loop (0);\n+\tdo_jump (TREE_OPERAND (exp, 0), label, NULL_RTX);\n+\texpand_exit_loop (NULL_PTR);\n \temit_label (label);\n       }\n       return const0_rtx;\n@@ -3416,14 +3404,15 @@ expand_expr (exp, target, tmode, modifier)\n \t    && TYPE_MODE (TREE_TYPE (exp1)) == Pmode\n \t    && TYPE_MODE (TREE_TYPE (exp2)) == Pmode)\n \t  {\n-\t    temp = expand_expr (TREE_OPERAND (exp1, 0), 0, VOIDmode, EXPAND_SUM);\n+\t    temp = expand_expr (TREE_OPERAND (exp1, 0), NULL_RTX,\n+\t\t\t\tVOIDmode, EXPAND_SUM);\n \t    op0 = memory_address (mode, temp);\n \t    op0 = copy_all_regs (op0);\n \t    SAVE_EXPR_RTL (exp1) = op0;\n \t  }\n \telse\n \t  {\n-\t    op0 = expand_expr (exp1, 0, VOIDmode, EXPAND_SUM);\n+\t    op0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \t    op0 = memory_address (mode, op0);\n \t  }\n \n@@ -3577,8 +3566,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      else if (TREE_CODE (init) == STRING_CST\n \t\t       && i < TREE_STRING_LENGTH (init))\n \t\t{\n-\t\t  temp = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t  TREE_STRING_POINTER (init)[i]);\n+\t\t  temp = GEN_INT (TREE_STRING_POINTER (init)[i]);\n \t\t  return convert_to_mode (mode, temp, 0);\n \t\t}\n \t    }\n@@ -3612,7 +3600,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* In some cases, we will be offsetting OP0's address by a constant.\n \t   So get it as a sum, if possible.  If we will be using it\n \t   directly in an insn, we validate it.  */\n-\top0 = expand_expr (tem, 0, VOIDmode, EXPAND_SUM);\n+\top0 = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_SUM);\n \n \t/* If this is a constant, put it into a register if it is a\n \t   legimate constant and memory if it isn't.  */\n@@ -3627,7 +3615,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (offset != 0)\n \t  {\n-\t    rtx offset_rtx = expand_expr (offset, 0, VOIDmode, 0);\n+\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n \n \t    if (GET_CODE (op0) != MEM)\n \t      abort ();\n@@ -3701,7 +3689,7 @@ expand_expr (exp, target, tmode, modifier)\n       {\n \ttree base = build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 0), 0);\n \ttree addr = build (PLUS_EXPR, type, base, TREE_OPERAND (exp, 1));\n-\top0 = expand_expr (addr, 0, VOIDmode, EXPAND_SUM);\n+\top0 = expand_expr (addr, NULL_RTX, VOIDmode, EXPAND_SUM);\n \ttemp = gen_rtx (MEM, mode, memory_address (mode, op0));\n \tMEM_IN_STRUCT_P (temp) = 1;\n \tMEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) || flag_volatile;\n@@ -3724,7 +3712,8 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  RTL_EXPR_RTL (exp)\n \t    = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-\t  cleanups_this_call = tree_cons (0, TREE_OPERAND (exp, 2), cleanups_this_call);\n+\t  cleanups_this_call\n+\t    = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2), cleanups_this_call);\n \t  /* That's it for this cleanup.  */\n \t  TREE_OPERAND (exp, 2) = 0;\n \t}\n@@ -3774,7 +3763,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n-\t\t\tchange_address (target, TYPE_MODE (valtype), 0), 0);\n+\t\t\tchange_address (target, TYPE_MODE (valtype), 0),\n+\t\t\tNULL_RTX);\n \t  else if (GET_CODE (target) == REG)\n \t    /* Store this field into a union of the proper type.  */\n \t    store_field (target, GET_MODE_BITSIZE (TYPE_MODE (valtype)), 0,\n@@ -3787,7 +3777,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Return the entire union.  */\n \t  return target;\n \t}\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), 0, mode, 0);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, 0);\n       if (GET_MODE (op0) == mode || GET_MODE (op0) == VOIDmode)\n \treturn op0;\n       if (flag_force_mem && GET_CODE (op0) == MEM)\n@@ -3837,7 +3827,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t If this is an EXPAND_SUM call, always return the sum.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n+\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n \t      || mode == Pmode))\n \t{\n@@ -3874,7 +3864,7 @@ expand_expr (exp, target, tmode, modifier)\n \tsubtarget = 0;\n \n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, modifier);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, modifier);\n \n       /* Make sure any term that's a sum with a constant comes last.  */\n       if (GET_CODE (op0) == PLUS\n@@ -3929,8 +3919,10 @@ expand_expr (exp, target, tmode, modifier)\n \t  && really_constant_p (TREE_OPERAND (exp, 0))\n \t  && really_constant_p (TREE_OPERAND (exp, 1)))\n \t{\n-\t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, modifier);\n-\t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, modifier);\n+\t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX,\n+\t\t\t\t VOIDmode, modifier);\n+\t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n+\t\t\t\t VOIDmode, modifier);\n \t  return gen_rtx (MINUS, mode, op0, op1);\n \t}\n       /* Convert A - const to A + (-const).  */\n@@ -3961,7 +3953,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       if (modifier == EXPAND_SUM && mode == Pmode\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT)\n+\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, EXPAND_SUM);\n \n@@ -3970,20 +3962,17 @@ expand_expr (exp, target, tmode, modifier)\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n \t    return gen_rtx (PLUS, mode,\n \t\t\t    gen_rtx (MULT, mode, XEXP (op0, 0),\n-\t\t\t\t     gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t      TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t     (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n-\t\t\t\t      * INTVAL (XEXP (op0, 1)))));\n+\t\t\t\t     GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n+\t\t\t    GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n+\t\t\t\t     * INTVAL (XEXP (op0, 1))));\n \n \t  if (GET_CODE (op0) != REG)\n-\t    op0 = force_operand (op0, 0);\n+\t    op0 = force_operand (op0, NULL_RTX);\n \t  if (GET_CODE (op0) != REG)\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n \t  return gen_rtx (MULT, mode, op0,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n+\t\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n \t}\n \n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n@@ -4002,7 +3991,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t   TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n \t       /* Don't use a widening multiply if a shift will do.  */\n \t       && ((GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n-\t\t    > HOST_BITS_PER_INT)\n+\t\t    > HOST_BITS_PER_WIDE_INT)\n \t\t   || exact_log2 (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))) < 0))\n \t      ||\n \t      (TREE_CODE (TREE_OPERAND (exp, 1)) == NOP_EXPR\n@@ -4023,17 +4012,18 @@ expand_expr (exp, target, tmode, modifier)\n \t      && this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t    {\n \t      op0 = expand_expr (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t 0, VOIDmode, 0);\n+\t\t\t\t NULL_RTX, VOIDmode, 0);\n \t      if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n-\t\top1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+\t\top1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n+\t\t\t\t   VOIDmode, 0);\n \t      else\n \t\top1 = expand_expr (TREE_OPERAND (TREE_OPERAND (exp, 1), 0),\n-\t\t\t\t   0, VOIDmode, 0);\n+\t\t\t\t   NULL_RTX, VOIDmode, 0);\n \t      goto binop2;\n \t    }\n \t}\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n       return expand_mult (mode, op0, op1, target, unsignedp);\n \n     case TRUNC_DIV_EXPR:\n@@ -4048,7 +4038,7 @@ expand_expr (exp, target, tmode, modifier)\n \t then if the divisor is constant can optimize the case\n \t where some terms of the dividend have coeffs divisible by it.  */\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n     case RDIV_EXPR:\n@@ -4063,7 +4053,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n \tsubtarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n \n     case FIX_ROUND_EXPR:\n@@ -4072,14 +4062,14 @@ expand_expr (exp, target, tmode, modifier)\n       abort ();\t\t\t/* Not used for C.  */\n \n     case FIX_TRUNC_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       if (target == 0)\n \ttarget = gen_reg_rtx (mode);\n       expand_fix (target, op0, unsignedp);\n       return target;\n \n     case FLOAT_EXPR:\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n       if (target == 0)\n \ttarget = gen_reg_rtx (mode);\n       /* expand_float can't figure out what to do if FROM has VOIDmode.\n@@ -4119,7 +4109,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n \t\t\t\t       size_int (GET_MODE_BITSIZE (mode) - 1),\n-\t\t\t\t       0, 0);\n+\t\t\t\t       NULL_RTX, 0);\n \n \t  temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n \t\t\t       OPTAB_LIB_WIDEN);\n@@ -4141,8 +4131,8 @@ expand_expr (exp, target, tmode, modifier)\n       emit_move_insn (target, op0);\n       emit_cmp_insn (target,\n \t\t     expand_expr (convert (type, integer_zero_node),\n-\t\t\t\t  0, VOIDmode, 0),\n-\t\t     GE, 0, mode, 0, 0);\n+\t\t\t\t  NULL_RTX, VOIDmode, 0),\n+\t\t     GE, NULL_RTX, mode, 0, 0);\n       NO_DEFER_POP;\n       emit_jump_insn (gen_bge (temp));\n       op0 = expand_unop (mode, neg_optab, target, target, 0);\n@@ -4159,7 +4149,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  || (GET_CODE (target) == REG\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n       op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, 0);\n \n       /* First try to do it with a special MIN or MAX instruction.\n@@ -4179,12 +4169,12 @@ expand_expr (exp, target, tmode, modifier)\n       op0 = gen_label_rtx ();\n       if (code == MAX_EXPR)\n \ttemp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t? compare_from_rtx (target, op1, GEU, 1, mode, 0, 0)\n-\t\t: compare_from_rtx (target, op1, GE, 0, mode, 0, 0));\n+\t\t? compare_from_rtx (target, op1, GEU, 1, mode, NULL_RTX, 0)\n+\t\t: compare_from_rtx (target, op1, GE, 0, mode, NULL_RTX, 0));\n       else\n \ttemp = (TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)))\n-\t\t? compare_from_rtx (target, op1, LEU, 1, mode, 0, 0)\n-\t\t: compare_from_rtx (target, op1, LE, 0, mode, 0, 0));\n+\t\t? compare_from_rtx (target, op1, LEU, 1, mode, NULL_RTX, 0)\n+\t\t: compare_from_rtx (target, op1, LE, 0, mode, NULL_RTX, 0));\n       if (temp == const0_rtx)\n \temit_move_insn (target, op1);\n       else if (temp != const_true_rtx)\n@@ -4278,7 +4268,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (temp != original_target)\n \t    temp = copy_to_reg (temp);\n \t  op1 = gen_label_rtx ();\n-\t  emit_cmp_insn (temp, const0_rtx, EQ, 0,\n+\t  emit_cmp_insn (temp, const0_rtx, EQ, NULL_RTX,\n \t\t\t GET_MODE (temp), unsignedp, 0);\n \t  emit_jump_insn (gen_beq (op1));\n \t  emit_move_insn (temp, const1_rtx);\n@@ -4308,8 +4298,7 @@ expand_expr (exp, target, tmode, modifier)\n       op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, 0);\n       /* The parser is careful to generate TRUTH_NOT_EXPR\n \t only with operands that are always zero or one.  */\n-      temp = expand_binop (mode, xor_optab, op0,\n-\t\t\t   gen_rtx (CONST_INT, mode, 1),\n+      temp = expand_binop (mode, xor_optab, op0, const1_rtx,\n \t\t\t   target, 1, OPTAB_LIB_WIDEN);\n       if (temp == 0)\n \tabort ();\n@@ -4430,12 +4419,13 @@ expand_expr (exp, target, tmode, modifier)\n \t\t= invert_truthvalue (TREE_OPERAND (exp, 0));\n \n \t    result = do_store_flag (TREE_OPERAND (exp, 0),\n-\t\t\t\t    safe_from_p (temp, singleton) ? temp : 0,\n+\t\t\t\t    (safe_from_p (temp, singleton)\n+\t\t\t\t     ? temp : NULL_RTX),\n \t\t\t\t    mode, BRANCH_COST <= 1);\n \n \t    if (result)\n \t      {\n-\t\top1 = expand_expr (singleton, 0, VOIDmode, 0);\n+\t\top1 = expand_expr (singleton, NULL_RTX, VOIDmode, 0);\n \t\treturn expand_binop (mode, boptab, op1, result, temp,\n \t\t\t\t     unsignedp, OPTAB_LIB_WIDEN);\n \t      }\n@@ -4463,7 +4453,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\tstore_expr (singleton, temp, 0);\n \t      }\n \t    else\n-\t      expand_expr (singleton, ignore ? const1_rtx : 0, VOIDmode, 0);\n+\t      expand_expr (singleton,\n+\t\t\t   ignore ? const1_rtx : NULL_RTX, VOIDmode, 0);\n \t    if (cleanups_this_call)\n \t      {\n \t\tsorry (\"aggregate value in COND_EXPR\");\n@@ -4477,7 +4468,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (binary_op && temp == 0)\n \t      /* Just touch the other operand.  */\n \t      expand_expr (TREE_OPERAND (binary_op, 1),\n-\t\t\t   ignore ? const0_rtx : 0, VOIDmode, 0);\n+\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t    else if (binary_op)\n \t      store_expr (build (TREE_CODE (binary_op), type,\n \t\t\t\t make_tree (type, temp),\n@@ -4560,8 +4551,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    else\n-\t      expand_expr (TREE_OPERAND (exp, 1), ignore ? const0_rtx : 0,\n-\t\t\t   VOIDmode, 0);\n+\t      expand_expr (TREE_OPERAND (exp, 1),\n+\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t    if (cleanups_this_call)\n \t      {\n \t\tsorry (\"aggregate value in COND_EXPR\");\n@@ -4575,8 +4566,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    else\n-\t      expand_expr (TREE_OPERAND (exp, 2), ignore ? const0_rtx : 0,\n-\t\t\t   VOIDmode, 0);\n+\t      expand_expr (TREE_OPERAND (exp, 2),\n+\t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t  }\n \n \tif (cleanups_this_call)\n@@ -4631,8 +4622,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (TREE_OPERAND (exp, 2) == 0)\n \t      TREE_OPERAND (exp, 2) = maybe_build_cleanup (slot);\n \t    if (TREE_OPERAND (exp, 2))\n-\t      cleanups_this_call = tree_cons (0, TREE_OPERAND (exp, 2),\n-\t\t\t\t\t\t cleanups_this_call);\n+\t      cleanups_this_call = tree_cons (NULL_TREE, TREE_OPERAND (exp, 2),\n+\t\t\t\t\t      cleanups_this_call);\n #endif\n \t  }\n \telse\n@@ -4755,7 +4746,7 @@ expand_expr (exp, target, tmode, modifier)\n \t}\n       else\n \t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode,\n+\t  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n \t\t\t     (modifier == EXPAND_INITIALIZER\n \t\t\t      ? modifier : EXPAND_CONST_ADDRESS));\n \t  if (GET_CODE (op0) != MEM)\n@@ -4786,7 +4777,7 @@ expand_expr (exp, target, tmode, modifier)\n   if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n     subtarget = 0;\n   op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n  binop2:\n   temp = expand_binop (mode, this_optab, op0, op1, target,\n \t\t       unsignedp, OPTAB_LIB_WIDEN);\n@@ -5041,7 +5032,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t{\n \t  /* By checking op > 0 we are able to catch all of the\n              IEEE special cases with a single if conditional.  */\n-          emit_cmp_insn (op0, CONST0_RTX (GET_MODE (op0)), GT, 0,\n+          emit_cmp_insn (op0, CONST0_RTX (GET_MODE (op0)), GT, NULL_RTX,\n \t\t\t GET_MODE (op0), 0, 0);\n           emit_jump_insn (gen_bgt (lab1));\n \n@@ -5162,7 +5153,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\tif (wordnum < 0 || wordnum >= nwords)\n \t\t  error (\"argument of __builtin_args_info out of range\");\n \t\telse\n-\t\t  return gen_rtx (CONST_INT, VOIDmode, word_ptr[wordnum]);\n+\t\t  return GEN_INT (word_ptr[wordnum]);\n \t      }\n \t  }\n \telse\n@@ -5181,7 +5172,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \tTREE_STATIC (result) = 1;\n \tresult = build (INDIRECT_REF, build_pointer_type (type), result);\n \tTREE_CONSTANT (result) = 1;\n-\treturn expand_expr (result, 0, VOIDmode, 0);\n+\treturn expand_expr (result, NULL_RTX, VOIDmode, 0);\n #endif\n       }\n \n@@ -5201,53 +5192,53 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_binop (Pmode, add_optab,\n \t\t\t   current_function_internal_arg_pointer,\n \t\t\t   current_function_arg_offset_rtx,\n-\t\t\t   0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n     case BUILT_IN_CLASSIFY_TYPE:\n       if (arglist != 0)\n \t{\n \t  tree type = TREE_TYPE (TREE_VALUE (arglist));\n \t  enum tree_code code = TREE_CODE (type);\n \t  if (code == VOID_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, void_type_class);\n+\t    return GEN_INT (void_type_class);\n \t  if (code == INTEGER_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, integer_type_class);\n+\t    return GEN_INT (integer_type_class);\n \t  if (code == CHAR_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, char_type_class);\n+\t    return GEN_INT (char_type_class);\n \t  if (code == ENUMERAL_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, enumeral_type_class);\n+\t    return GEN_INT (enumeral_type_class);\n \t  if (code == BOOLEAN_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, boolean_type_class);\n+\t    return GEN_INT (boolean_type_class);\n \t  if (code == POINTER_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, pointer_type_class);\n+\t    return GEN_INT (pointer_type_class);\n \t  if (code == REFERENCE_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, reference_type_class);\n+\t    return GEN_INT (reference_type_class);\n \t  if (code == OFFSET_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, offset_type_class);\n+\t    return GEN_INT (offset_type_class);\n \t  if (code == REAL_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, real_type_class);\n+\t    return GEN_INT (real_type_class);\n \t  if (code == COMPLEX_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, complex_type_class);\n+\t    return GEN_INT (complex_type_class);\n \t  if (code == FUNCTION_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, function_type_class);\n+\t    return GEN_INT (function_type_class);\n \t  if (code == METHOD_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, method_type_class);\n+\t    return GEN_INT (method_type_class);\n \t  if (code == RECORD_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, record_type_class);\n+\t    return GEN_INT (record_type_class);\n \t  if (code == UNION_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, union_type_class);\n+\t    return GEN_INT (union_type_class);\n \t  if (code == ARRAY_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, array_type_class);\n+\t    return GEN_INT (array_type_class);\n \t  if (code == STRING_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, string_type_class);\n+\t    return GEN_INT (string_type_class);\n \t  if (code == SET_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, set_type_class);\n+\t    return GEN_INT (set_type_class);\n \t  if (code == FILE_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, file_type_class);\n+\t    return GEN_INT (file_type_class);\n \t  if (code == LANG_TYPE)\n-\t    return gen_rtx (CONST_INT, VOIDmode, lang_type_class);\n+\t    return GEN_INT (lang_type_class);\n \t}\n-      return gen_rtx (CONST_INT, VOIDmode, no_type_class);\n+      return GEN_INT (no_type_class);\n \n     case BUILT_IN_CONSTANT_P:\n       if (arglist == 0)\n@@ -5317,14 +5308,14 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn const0_rtx;\n       current_function_calls_alloca = 1;\n       /* Compute the argument.  */\n-      op0 = expand_expr (TREE_VALUE (arglist), 0, VOIDmode, 0);\n+      op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n \n       /* Allocate the desired space.  */\n       target = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n \n       /* Record the new stack level for nonlocal gotos.  */\n       if (nonlocal_goto_handler_slot != 0)\n-\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n+\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n       return target;\n \n     case BUILT_IN_FFS:\n@@ -5403,7 +5394,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    result = gen_reg_rtx (insn_mode);\n \n \t  src_rtx = memory_address (BLKmode,\n-\t\t\t\t    expand_expr (src, 0, Pmode,\n+\t\t\t\t    expand_expr (src, NULL_RTX, Pmode,\n \t\t\t\t\t\t EXPAND_NORMAL));\n \t  if (! (*insn_operand_predicate[(int)icode][1]) (src_rtx, Pmode))\n \t    src_rtx = copy_to_mode_reg (Pmode, src_rtx);\n@@ -5415,8 +5406,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \t  emit_insn (GEN_FCN (icode) (result,\n \t\t\t\t      gen_rtx (MEM, BLKmode, src_rtx),\n-\t\t\t\t      char_rtx,\n-\t\t\t\t      gen_rtx (CONST_INT, VOIDmode, align)));\n+\t\t\t\t      char_rtx, GEN_INT (align)));\n \n \t  /* Return the value in the proper mode for this function.  */\n \t  if (GET_MODE (result) == value_mode)\n@@ -5450,7 +5440,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \t  len = size_binop (PLUS_EXPR, len, integer_one_node);\n \n-\t  chainon (arglist, build_tree_list (0, len));\n+\t  chainon (arglist, build_tree_list (NULL_TREE, len));\n \t}\n \n       /* Drops in.  */\n@@ -5488,16 +5478,17 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t      break;\n \t    }\n \n-\t  dest_rtx = expand_expr (dest, 0, Pmode, EXPAND_NORMAL);\n+\t  dest_rtx = expand_expr (dest, NULL_RTX, Pmode, EXPAND_NORMAL);\n \n \t  /* Copy word part most expediently.  */\n \t  emit_block_move (gen_rtx (MEM, BLKmode,\n \t\t\t\t    memory_address (BLKmode, dest_rtx)),\n \t\t\t   gen_rtx (MEM, BLKmode,\n \t\t\t\t    memory_address (BLKmode,\n-\t\t\t\t\t\t    expand_expr (src, 0, Pmode,\n+\t\t\t\t\t\t    expand_expr (src, NULL_RTX,\n+\t\t\t\t\t\t\t\t Pmode,\n \t\t\t\t\t\t\t\t EXPAND_NORMAL))),\n-\t\t\t   expand_expr (len, 0, VOIDmode, 0),\n+\t\t\t   expand_expr (len, NULL_RTX, VOIDmode, 0),\n \t\t\t   MIN (src_align, dest_align));\n \t  return dest_rtx;\n \t}\n@@ -5555,7 +5546,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t      len = len2;\n \t  }\n \n-\tchainon (arglist, build_tree_list (0, len));\n+\tchainon (arglist, build_tree_list (NULL_TREE, len));\n       }\n \n       /* Drops in.  */\n@@ -5604,12 +5595,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \temit_insn (gen_cmpstrsi (result,\n \t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg1, 0, Pmode, EXPAND_NORMAL)),\n+\t\t\t\t\t  expand_expr (arg1, NULL_RTX, Pmode,\n+\t\t\t\t\t\t       EXPAND_NORMAL)),\n \t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg2, 0, Pmode, EXPAND_NORMAL)),\n-\t\t\t\t expand_expr (len, 0, VOIDmode, 0),\n-\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t  MIN (arg1_align, arg2_align))));\n+\t\t\t\t\t  expand_expr (arg2, NULL_RTX, Pmode,\n+\t\t\t\t\t\t       EXPAND_NORMAL)),\n+\t\t\t\t expand_expr (len, NULL_RTX, VOIDmode, 0),\n+\t\t\t\t GEN_INT (MIN (arg1_align, arg2_align))));\n \n \t/* Return the value in the proper mode for this function.  */\n \tmode = TYPE_MODE (TREE_TYPE (exp));\n@@ -5670,10 +5662,10 @@ expand_increment (exp, post)\n      I believe it is a copy iff it is a register or subreg\n      and insns were generated in computing it.  */\n   temp = get_last_insn ();\n-  op0 = expand_expr (incremented, 0, VOIDmode, 0);\n+  op0 = expand_expr (incremented, NULL_RTX, VOIDmode, 0);\n   op0_is_copy = ((GET_CODE (op0) == SUBREG || GET_CODE (op0) == REG)\n \t\t && temp != get_last_insn ());\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n \n   /* Decide whether incrementing or decrementing.  */\n   if (TREE_CODE (exp) == POSTDECREMENT_EXPR\n@@ -5705,7 +5697,7 @@ expand_increment (exp, post)\n   if (this_optab == sub_optab\n       && GET_CODE (op1) == CONST_INT)\n     {\n-      op1 = gen_rtx (CONST_INT, VOIDmode, - INTVAL (op1));\n+      op1 = GEN_INT (- INTVAL (op1));\n       this_optab = add_optab;\n     }\n \n@@ -5784,7 +5776,7 @@ preexpand_calls (exp)\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) != ADDR_EXPR\n \t  || TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) != FUNCTION_DECL\n \t  || ! DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n-\tCALL_EXPR_RTL (exp) = expand_call (exp, 0, 0);\n+\tCALL_EXPR_RTL (exp) = expand_call (exp, NULL_RTX, 0);\n       return;\n \n     case COMPOUND_EXPR:\n@@ -5851,7 +5843,7 @@ do_pending_stack_adjust ()\n   if (inhibit_defer_pop == 0)\n     {\n       if (pending_stack_adjust != 0)\n-\tadjust_stack (gen_rtx (CONST_INT, VOIDmode, pending_stack_adjust));\n+\tadjust_stack (GEN_INT (pending_stack_adjust));\n       pending_stack_adjust = 0;\n     }\n }\n@@ -5865,7 +5857,7 @@ expand_cleanups_to (old_cleanups)\n {\n   while (cleanups_this_call != old_cleanups)\n     {\n-      expand_expr (TREE_VALUE (cleanups_this_call), 0, VOIDmode, 0);\n+      expand_expr (TREE_VALUE (cleanups_this_call), NULL_RTX, VOIDmode, 0);\n       cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n     }\n }\n@@ -5881,7 +5873,7 @@ jumpifnot (exp, label)\n      tree exp;\n      rtx label;\n {\n-  do_jump (exp, label, 0);\n+  do_jump (exp, label, NULL_RTX);\n }\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n@@ -5891,7 +5883,7 @@ jumpif (exp, label)\n      tree exp;\n      rtx label;\n {\n-  do_jump (exp, 0, label);\n+  do_jump (exp, NULL_RTX, label);\n }\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n@@ -5994,7 +5986,7 @@ do_jump (exp, if_false_label, if_true_label)\n \n       if (! SLOW_BYTE_ACCESS\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t  && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_INT\n+\t  && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n \t  && (i = floor_log2 (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))) >= 0\n \t  && (type = type_for_size (i + 1, 1)) != 0\n \t  && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n@@ -6013,14 +6005,14 @@ do_jump (exp, if_false_label, if_true_label)\n     case TRUTH_ANDIF_EXPR:\n       if (if_false_label == 0)\n \tif_false_label = drop_through_label = gen_label_rtx ();\n-      do_jump (TREE_OPERAND (exp, 0), if_false_label, 0);\n+      do_jump (TREE_OPERAND (exp, 0), if_false_label, NULL_RTX);\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n       break;\n \n     case TRUTH_ORIF_EXPR:\n       if (if_true_label == 0)\n \tif_true_label = drop_through_label = gen_label_rtx ();\n-      do_jump (TREE_OPERAND (exp, 0), 0, if_true_label);\n+      do_jump (TREE_OPERAND (exp, 0), NULL_RTX, if_true_label);\n       do_jump (TREE_OPERAND (exp, 1), if_false_label, if_true_label);\n       break;\n \n@@ -6074,7 +6066,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t{\n \t  register rtx label1 = gen_label_rtx ();\n \t  drop_through_label = gen_label_rtx ();\n-\t  do_jump (TREE_OPERAND (exp, 0), label1, 0);\n+\t  do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n \t  /* Now the THEN-expression.  */\n \t  do_jump (TREE_OPERAND (exp, 1),\n \t\t   if_false_label ? if_false_label : drop_through_label,\n@@ -6151,7 +6143,7 @@ do_jump (exp, if_false_label, if_true_label)\n \n     default:\n     normal:\n-      temp = expand_expr (exp, 0, VOIDmode, 0);\n+      temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n #if 0\n       /* This is not needed any more and causes poor code since it causes\n \t comparisons and tests from non-SI objects to have different code\n@@ -6172,7 +6164,7 @@ do_jump (exp, if_false_label, if_true_label)\n \tdo_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n       else if (GET_MODE (temp) != VOIDmode)\n \tcomparison = compare_from_rtx (temp, CONST0_RTX (GET_MODE (temp)),\n-\t\t\t\t       NE, 1, GET_MODE (temp), 0, 0);\n+\t\t\t\t       NE, 1, GET_MODE (temp), NULL_RTX, 0);\n       else\n \tabort ();\n     }\n@@ -6220,8 +6212,8 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n      int swap;\n      rtx if_false_label, if_true_label;\n {\n-  rtx op0 = expand_expr (TREE_OPERAND (exp, swap), 0, VOIDmode, 0);\n-  rtx op1 = expand_expr (TREE_OPERAND (exp, !swap), 0, VOIDmode, 0);\n+  rtx op0 = expand_expr (TREE_OPERAND (exp, swap), NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (TREE_OPERAND (exp, !swap), NULL_RTX, VOIDmode, 0);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx drop_through_label = 0;\n@@ -6255,19 +6247,19 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n       /* All but high-order word must be compared as unsigned.  */\n       comp = compare_from_rtx (op0_word, op1_word,\n \t\t\t       (unsignedp || i > 0) ? GTU : GT,\n-\t\t\t       unsignedp, word_mode, 0, 0);\n+\t\t\t       unsignedp, word_mode, NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_true_label);\n       else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, 0, if_true_label);\n+\tdo_jump_for_compare (comp, NULL_RTX, if_true_label);\n \n       /* Consider lower words only if these are equal.  */\n       comp = compare_from_rtx (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       0, 0);\n+\t\t\t       NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_false_label);\n       else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, 0, if_false_label);\n+\tdo_jump_for_compare (comp, NULL_RTX, if_false_label);\n     }\n \n   if (if_false_label)\n@@ -6284,8 +6276,8 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n      tree exp;\n      rtx if_false_label, if_true_label;\n {\n-  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   int i;\n@@ -6298,11 +6290,11 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n     {\n       rtx comp = compare_from_rtx (operand_subword_force (op0, i, mode),\n \t\t\t\t   operand_subword_force (op1, i, mode),\n-\t\t\t\t   EQ, 0, word_mode, 0, 0);\n+\t\t\t\t   EQ, 0, word_mode, NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_false_label);\n       else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, if_false_label, 0);\n+\tdo_jump_for_compare (comp, if_false_label, NULL_RTX);\n     }\n \n   if (if_true_label)\n@@ -6331,11 +6323,11 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n     {\n       rtx comp = compare_from_rtx (operand_subword_force (op0, i,\n \t\t\t\t\t\t\t  GET_MODE (op0)),\n-\t\t\t\t   const0_rtx, EQ, 0, word_mode, 0, 0);\n+\t\t\t\t   const0_rtx, EQ, 0, word_mode, NULL_RTX, 0);\n       if (comp == const_true_rtx)\n \temit_jump (if_false_label);\n       else if (comp != const0_rtx)\n-\tdo_jump_for_compare (comp, if_false_label, 0);\n+\tdo_jump_for_compare (comp, if_false_label, NULL_RTX);\n     }\n \n   if (if_true_label)\n@@ -6422,16 +6414,18 @@ compare (exp, signed_code, unsigned_code)\n      register tree exp;\n      enum rtx_code signed_code, unsigned_code;\n {\n-  register rtx op0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n-  register rtx op1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+  register rtx op0\n+    = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+  register rtx op1\n+    = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n   register tree type = TREE_TYPE (TREE_OPERAND (exp, 0));\n   register enum machine_mode mode = TYPE_MODE (type);\n   int unsignedp = TREE_UNSIGNED (type);\n   enum rtx_code code = unsignedp ? unsigned_code : signed_code;\n \n   return compare_from_rtx (op0, op1, code, unsignedp, mode,\n \t\t\t   ((mode == BLKmode)\n-\t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : 0),\n+\t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n \t\t\t   TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);\n }\n \n@@ -6482,12 +6476,11 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n      sign-extension is.  If we are comparing against a constant, we must\n      convert it to what it would look like unsigned.  */\n   if ((code == EQ || code == NE) && ! unsignedp\n-      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_INT)\n+      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (GET_CODE (op1) == CONST_INT\n \t  && (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0))) != INTVAL (op1))\n-\top1 = gen_rtx (CONST_INT, VOIDmode, \n-\t\t       INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n+\top1 = GEN_INT (INTVAL (op1) & GET_MODE_MASK (GET_MODE (op0)));\n       unsignedp = 1;\n     }\n \t\n@@ -6618,10 +6611,10 @@ do_store_flag (exp, target, mode, only_cheap)\n   if ((code == NE || code == EQ)\n       && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)\n       && integer_pow2p (TREE_OPERAND (arg0, 1))\n-      && TYPE_PRECISION (type) <= HOST_BITS_PER_INT)\n+      && TYPE_PRECISION (type) <= HOST_BITS_PER_WIDE_INT)\n     {\n       int bitnum = exact_log2 (INTVAL (expand_expr (TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t\t    0, VOIDmode, 0)));\n+\t\t\t\t\t\t    NULL_RTX, VOIDmode, 0)));\n \n       if (subtarget == 0 || GET_CODE (subtarget) != REG\n \t  || GET_MODE (subtarget) != operand_mode\n@@ -6678,7 +6671,7 @@ do_store_flag (exp, target, mode, only_cheap)\n     subtarget = 0;\n \n   op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n-  op1 = expand_expr (arg1, 0, VOIDmode, 0);\n+  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n \n   if (target == 0)\n     target = gen_reg_rtx (mode);\n@@ -6700,7 +6693,8 @@ do_store_flag (exp, target, mode, only_cheap)\n     target = gen_reg_rtx (GET_MODE (target));\n \n   emit_move_insn (target, invert ? const0_rtx : const1_rtx);\n-  result = compare_from_rtx (op0, op1, code, unsignedp, operand_mode, 0, 0);\n+  result = compare_from_rtx (op0, op1, code, unsignedp,\n+\t\t\t     operand_mode, NULL_RTX, 0);\n   if (GET_CODE (result) == CONST_INT)\n     return (((result == const0_rtx && ! invert)\n \t     || (result != const0_rtx && invert))\n@@ -6745,7 +6739,7 @@ do_tablejump (index, mode, range, table_label, default_label)\n      or equal to the minimum value of the range and less than or equal to\n      the maximum value of the range.  */\n \n-  emit_cmp_insn (range, index, LTU, 0, mode, 0, 0);\n+  emit_cmp_insn (range, index, LTU, NULL_RTX, mode, 0, 0);\n   emit_jump_insn (gen_bltu (default_label));\n \n   /* If index is in range, it must fit in Pmode.\n@@ -6765,8 +6759,7 @@ do_tablejump (index, mode, range, table_label, default_label)\n     (CASE_VECTOR_MODE,\n      gen_rtx (PLUS, Pmode,\n \t      gen_rtx (MULT, Pmode, index,\n-\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\tGET_MODE_SIZE (CASE_VECTOR_MODE))),\n+\t\t       GEN_INT (GET_MODE_SIZE (CASE_VECTOR_MODE))),\n \t      gen_rtx (LABEL_REF, Pmode, table_label)));\n   temp = gen_reg_rtx (CASE_VECTOR_MODE);\n   vector = gen_rtx (MEM, CASE_VECTOR_MODE, index);"}, {"sha": "d05aa70d24b12c510dd0f0f73e4c7030cf0d8632", "filename": "gcc/final.c", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -283,8 +283,7 @@ end_final (filename)\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n-      assemble_integer (gen_rtx (CONST_INT, VOIDmode, count_basic_blocks),\n-\t\t\tUNITS_PER_WORD, 1);\n+      assemble_integer (GEN_INT (count_basic_blocks), UNITS_PER_WORD, 1);\n       assemble_integer (const0_rtx, UNITS_PER_WORD, 1);\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n       assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), UNITS_PER_WORD, 1);\n@@ -600,7 +599,8 @@ asm_insn_count (body)\n   char *template;\n   int count = 1;\n \n-  for (template = decode_asm_operands (body, 0, 0, 0, 0);\n+  for (template = decode_asm_operands (body, NULL_PTR, NULL_PTR,\n+\t\t\t\t       NULL_PTR, NULL_PTR);\n        *template; template++)\n     if (*template == ';' || *template == '\\n')\n       count++;\n@@ -1174,7 +1174,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t   of the insn that branched here.  So recover the cc status\n \t   from the insn that set it.  */\n \n-\tnote = find_reg_note (insn, REG_CC_SETTER, 0);\n+\tnote = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \tif (note)\n \t  {\n \t    NOTICE_UPDATE_CC (PATTERN (XEXP (note, 0)), XEXP (note, 0));\n@@ -1277,7 +1277,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      }\n \n \t    /* Get out the operand values.  */\n-\t    string = decode_asm_operands (body, ops, 0, 0, 0);\n+\t    string = decode_asm_operands (body, ops, NULL_PTR,\n+\t\t\t\t\t  NULL_PTR, NULL_PTR);\n \t    /* Inhibit aborts on what would otherwise be compiler bugs.  */\n \t    insn_noperands = noperands;\n \t    this_is_asm_operands = insn;\n@@ -1982,7 +1983,13 @@ output_asm_insn (template, operands)\n \t      else if (letter == 'n')\n \t\t{\n \t\t  if (GET_CODE (operands[c]) == CONST_INT)\n-\t\t    fprintf (asm_out_file, \"%d\", - INTVAL (operands[c]));\n+\t\t    fprintf (asm_out_file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t\t     \"%d\",\n+#else\n+\t\t\t     \"%ld\",\n+#endif\n+\t\t\t     - INTVAL (operands[c]));\n \t\t  else\n \t\t    {\n \t\t      putc ('-', asm_out_file);\n@@ -2009,7 +2016,7 @@ output_asm_insn (template, operands)\n \t     The PRINT_OPERAND macro decides what is actually done.  */\n #ifdef PRINT_OPERAND_PUNCT_VALID_P\n \t  else if (PRINT_OPERAND_PUNCT_VALID_P (*p))\n-\t    output_operand (0, *p++);\n+\t    output_operand (NULL_RTX, *p++);\n #endif\n \t  else\n \t    output_operand_lossage (\"invalid %%-code\");\n@@ -2123,7 +2130,13 @@ output_addr_const (file, x)\n       break;\n \n     case CONST_INT:\n-      fprintf (file, \"%d\", INTVAL (x));\n+      fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t       \"%d\",\n+#else\n+\t       \"%ld\",\n+#endif\n+\t       INTVAL (x));\n       break;\n \n     case CONST:\n@@ -2135,12 +2148,31 @@ output_addr_const (file, x)\n     case CONST_DOUBLE:\n       if (GET_MODE (x) == VOIDmode)\n \t{\n-\t  /* We can use %d if the number is <32 bits and positive.  */\n+\t  /* We can use %d if the number is one word and positive.  */\n \t  if (CONST_DOUBLE_HIGH (x) || CONST_DOUBLE_LOW (x) < 0)\n-\t    fprintf (file, \"0x%x%08x\",\n+\t    fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%016lx\",\n+#else\n+\t\t \" 0x%x%016x\",\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%08lx\",\n+#else\n+\t\t \" 0x%x%08x\",\n+#endif\n+#endif\n \t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n \t  else\n-\t    fprintf (file, \"%d\", CONST_DOUBLE_LOW (x));\n+\t    fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t     \"%d\",\n+#else\n+\t\t     \"%ld\",\n+#endif\n+\t\t     CONST_DOUBLE_LOW (x));\n \t}\n       else\n \t/* We can't handle floating point constants;\n@@ -2320,27 +2352,27 @@ split_double (value, first, second)\n       /* In an integer, the words are defined as most and least significant.\n \t So order them by the target's convention.  */\n #if WORDS_BIG_ENDIAN\n-      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n-      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n+      *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n+      *second = GEN_INT (CONST_DOUBLE_LOW (value));\n #else\n-      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n-      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+      *first = GEN_INT (CONST_DOUBLE_LOW (value));\n+      *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n #endif\n     }\n   else\n     {\n       if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t   || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t   || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t  && ! flag_pretend_float)\n       abort ();\n \n #if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n       /* Host and target agree => no need to swap.  */\n-      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n-      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+      *first = GEN_INT (CONST_DOUBLE_LOW (value));\n+      *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n #else\n-      *second = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (value));\n-      *first = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (value));\n+      *second = GEN_INT (CONST_DOUBLE_LOW (value));\n+      *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n #endif\n     }\n }"}, {"sha": "035c22923371402ed04f15522408c279215dfb14", "filename": "gcc/fold-const.c", "status": "modified", "additions": 160, "deletions": 139, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -58,44 +58,47 @@ static tree const_binop ();\n #define BRANCH_COST 1\n #endif\n \f\n-/* To do constant folding on INTEGER_CST nodes requires 64-bit arithmetic.\n-   We do that by representing the 64-bit integer as 8 shorts,\n+/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n+   We do that by representing the two-word integer as MAX_SHORTS shorts,\n    with only 8 bits stored in each short, as a positive number.  */\n \n-/* Unpack a 64-bit integer into 8 shorts.\n-   LOW and HI are the integer, as two `int' pieces.\n+/* Unpack a two-word integer into MAX_SHORTS shorts.\n+   LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n    SHORTS points to the array of shorts.  */\n \n static void\n encode (shorts, low, hi)\n      short *shorts;\n-     int low, hi;\n+     HOST_WIDE_INT low, hi;\n {\n-  shorts[0] = low & 0xff;\n-  shorts[1] = (low >> 8) & 0xff;\n-  shorts[2] = (low >> 16) & 0xff;\n-  shorts[3] = (low >> 24) & 0xff;\n-  shorts[4] = hi & 0xff;\n-  shorts[5] = (hi >> 8) & 0xff;\n-  shorts[6] = (hi >> 16) & 0xff;\n-  shorts[7] = (hi >> 24) & 0xff;\n+  register int i;\n+\n+  for (i = 0; i < MAX_SHORTS / 2; i++)\n+    {\n+      shorts[i] = (low >> (i * 8)) & 0xff;\n+      shorts[i + MAX_SHORTS / 2] = (hi >> (i * 8) & 0xff);\n+    }\n }\n \n-/* Pack an array of 8 shorts into a 64-bit integer.\n+/* Pack an array of MAX_SHORTS shorts into a two-word integer.\n    SHORTS points to the array of shorts.\n-   The integer is stored into *LOW and *HI as two `int' pieces.  */\n+   The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n \n static void\n decode (shorts, low, hi)\n      short *shorts;\n-     int *low, *hi;\n+     HOST_WIDE_INT *low, *hi;\n {\n-  /* The casts in the following statement should not be\n-     needed, but they get around bugs in some C compilers.  */\n-  *low = (((long)shorts[3] << 24) | ((long)shorts[2] << 16)\n-\t  | ((long)shorts[1] << 8) | (long)shorts[0]);\n-  *hi = (((long)shorts[7] << 24) | ((long)shorts[6] << 16)\n-\t | ((long)shorts[5] << 8) | (long)shorts[4]);\n+  register int i;\n+  HOST_WIDE_INT lv = 0, hv = 0;\n+\n+  for (i = 0; i < MAX_SHORTS / 2; i++)\n+    {\n+      lv |= (HOST_WIDE_INT) shorts[i] << (i * 8);\n+      hv |= (HOST_WIDE_INT) shorts[i + MAX_SHORTS / 2] << (i * 8);\n+    }\n+\n+  *low = lv, *hi = hv;\n }\n \f\n /* Make the integer constant T valid for its type\n@@ -113,66 +116,65 @@ force_fit_type (t)\n \n   /* First clear all bits that are beyond the type's precision.  */\n \n-  if (prec == 2 * HOST_BITS_PER_INT)\n+  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n     ;\n-  else if (prec > HOST_BITS_PER_INT)\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n     {\n       TREE_INT_CST_HIGH (t)\n-\t&= ~((-1) << (prec - HOST_BITS_PER_INT));\n+\t&= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n     }\n   else\n     {\n       TREE_INT_CST_HIGH (t) = 0;\n-      if (prec < HOST_BITS_PER_INT)\n-\tTREE_INT_CST_LOW (t)\n-\t  &= ~((-1) << prec);\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tTREE_INT_CST_LOW (t) &= ~((HOST_WIDE_INT) (-1) << prec);\n     }\n \n   /* If it's a signed type and value's sign bit is set, extend the sign.  */\n \n   if (! TREE_UNSIGNED (TREE_TYPE (t))\n-      && prec != 2 * HOST_BITS_PER_INT\n-      && (prec > HOST_BITS_PER_INT\n-\t  ? TREE_INT_CST_HIGH (t) & (1 << (prec - HOST_BITS_PER_INT - 1))\n-\t  : TREE_INT_CST_LOW (t) & (1 << (prec - 1))))\n+      && prec != 2 * HOST_BITS_PER_WIDE_INT\n+      && (prec > HOST_BITS_PER_WIDE_INT\n+\t  ? (TREE_INT_CST_HIGH (t)\n+\t     & ((HOST_WIDE_INT) 1 << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n+\t  : TREE_INT_CST_LOW (t) & ((HOST_WIDE_INT) 1 << (prec - 1))))\n     {\n       /* Value is negative:\n \t set to 1 all the bits that are outside this type's precision.  */\n-      if (prec > HOST_BITS_PER_INT)\n+      if (prec > HOST_BITS_PER_WIDE_INT)\n \t{\n \t  TREE_INT_CST_HIGH (t)\n-\t    |= ((-1) << (prec - HOST_BITS_PER_INT));\n+\t    |= ((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n \t}\n       else\n \t{\n \t  TREE_INT_CST_HIGH (t) = -1;\n-\t  if (prec < HOST_BITS_PER_INT)\n-\t    TREE_INT_CST_LOW (t)\n-\t      |= ((-1) << prec);\n+\t  if (prec < HOST_BITS_PER_WIDE_INT)\n+\t    TREE_INT_CST_LOW (t) |= ((HOST_WIDE_INT) (-1) << prec);\n \t}\n     }\n }\n \f\n-/* Add two 64-bit integers with 64-bit result.\n-   Each argument is given as two `int' pieces.\n+/* Add two doubleword integers with doubleword result.\n+   Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `int' pieces in *LV and *HV.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n void\n add_double (l1, h1, l2, h2, lv, hv)\n-     int l1, h1, l2, h2;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1, l2, h2;\n+     HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[8];\n-  short arg2[8];\n+  short arg1[MAX_SHORTS];\n+  short arg2[MAX_SHORTS];\n   register int carry = 0;\n   register int i;\n \n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n \n-  for (i = 0; i < 8; i++)\n+  for (i = 0; i < MAX_SHORTS; i++)\n     {\n       carry += arg1[i] + arg2[i];\n       arg1[i] = carry & 0xff;\n@@ -182,15 +184,15 @@ add_double (l1, h1, l2, h2, lv, hv)\n   decode (arg1, lv, hv);\n }\n \n-/* Negate a 64-bit integers with 64-bit result.\n-   The argument is given as two `int' pieces in L1 and H1.\n-   The value is stored as two `int' pieces in *LV and *HV.\n+/* Negate a doubleword integer with doubleword result.\n+   The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n void\n neg_double (l1, h1, lv, hv)\n-     int l1, h1;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1;\n+     HOST_WIDE_INT *lv, *hv;\n {\n   if (l1 == 0)\n     {\n@@ -204,20 +206,20 @@ neg_double (l1, h1, lv, hv)\n     }\n }\n \f\n-/* Multiply two 64-bit integers with 64-bit result.\n-   Each argument is given as two `int' pieces.\n+/* Multiply two doubleword integers with doubleword result.\n+   Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `int' pieces in *LV and *HV.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n    We use the 8-shorts representation internally.  */\n \n void\n mul_double (l1, h1, l2, h2, lv, hv)\n-     int l1, h1, l2, h2;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1, l2, h2;\n+     HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[8];\n-  short arg2[8];\n-  short prod[16];\n+  short arg1[MAX_SHORTS];\n+  short arg2[MAX_SHORTS];\n+  short prod[MAX_SHORTS * 2];\n   register int carry = 0;\n   register int i, j, k;\n \n@@ -227,14 +229,14 @@ mul_double (l1, h1, l2, h2, lv, hv)\n     {\n       if (l2 == 2)\n \t{\n-\t  unsigned temp = l1 + l1;\n+\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n \t  *hv = h1 * 2 + (temp < l1);\n \t  *lv = temp;\n \t  return;\n \t}\n       if (l2 == 4)\n \t{\n-\t  unsigned temp = l1 + l1;\n+\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n \t  h1 = h1 * 4 + ((temp < l1) << 1);\n \t  l1 = temp;\n \t  temp += temp;\n@@ -245,7 +247,7 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \t}\n       if (l2 == 8)\n \t{\n-\t  unsigned temp = l1 + l1;\n+\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n \t  h1 = h1 * 8 + ((temp < l1) << 2);\n \t  l1 = temp;\n \t  temp += temp;\n@@ -264,8 +266,8 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \n   bzero (prod, sizeof prod);\n \n-  for (i = 0; i < 8; i++)\n-    for (j = 0; j < 8; j++)\n+  for (i = 0; i < MAX_SHORTS; i++)\n+    for (j = 0; j < MAX_SHORTS; j++)\n       {\n \tk = i + j;\n \tcarry = arg1[i] * arg2[j];\n@@ -278,22 +280,24 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \t  }\n       }\n \n-  decode (prod, lv, hv);\t/* @@decode ignores prod[8] -> prod[15] */\n+  decode (prod, lv, hv);\t/* ?? decode ignores\n+\t\t\t\t   prod[MAX_SHORTS] -> prod[MAX_SHORTS*2-1] */\n }\n \f\n-/* Shift the 64-bit integer in L1, H1 left by COUNT places\n+/* Shift the doubleword integer in L1, H1 left by COUNT places\n    keeping only PREC bits of result.\n    Shift right if COUNT is negative.\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n-   Store the value as two `int' pieces in *LV and *HV.  */\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n lshift_double (l1, h1, count, prec, lv, hv, arith)\n-     int l1, h1, count, prec;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1;\n+     int count, prec;\n+     HOST_WIDE_INT *lv, *hv;\n      int arith;\n {\n-  short arg1[8];\n+  short arg1[MAX_SHORTS];\n   register int i;\n   register int carry;\n \n@@ -311,7 +315,7 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n   while (count > 0)\n     {\n       carry = 0;\n-      for (i = 0; i < 8; i++)\n+      for (i = 0; i < MAX_SHORTS; i++)\n \t{\n \t  carry += arg1[i] << 1;\n \t  arg1[i] = carry & 0xff;\n@@ -323,18 +327,18 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n   decode (arg1, lv, hv);\n }\n \n-/* Shift the 64-bit integer in L1, H1 right by COUNT places\n+/* Shift the doubleword integer in L1, H1 right by COUNT places\n    keeping only PREC bits of result.  COUNT must be positive.\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n-   Store the value as two `int' pieces in *LV and *HV.  */\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n rshift_double (l1, h1, count, prec, lv, hv, arith)\n-     int l1, h1, count, prec;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1, count, prec;\n+     HOST_WIDE_INT *lv, *hv;\n      int arith;\n {\n-  short arg1[8];\n+  short arg1[MAX_SHORTS];\n   register int i;\n   register int carry;\n \n@@ -346,7 +350,7 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n   while (count > 0)\n     {\n       carry = arith && arg1[7] >> 7; \n-     for (i = 7; i >= 0; i--)\n+      for (i = MAX_SHORTS - 1; i >= 0; i--)\n \t{\n \t  carry <<= 8;\n \t  carry += arg1[i];\n@@ -358,17 +362,17 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n   decode (arg1, lv, hv);\n }\n \f\n-/* Rotate the 64-bit integer in L1, H1 left by COUNT places\n+/* Rotate the doubldword integer in L1, H1 left by COUNT places\n    keeping only PREC bits of result.\n    Rotate right if COUNT is negative.\n-   Store the value as two `int' pieces in *LV and *HV.  */\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n lrotate_double (l1, h1, count, prec, lv, hv)\n-     int l1, h1, count, prec;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1, count, prec;\n+     HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[8];\n+  short arg1[MAX_SHORTS];\n   register int i;\n   register int carry;\n \n@@ -383,10 +387,10 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n   if (count > prec)\n     count = prec;\n \n-  carry = arg1[7] >> 7;\n+  carry = arg1[MAX_SHORTS - 1] >> 7;\n   while (count > 0)\n     {\n-      for (i = 0; i < 8; i++)\n+      for (i = 0; i < MAX_SHORTS; i++)\n \t{\n \t  carry += arg1[i] << 1;\n \t  arg1[i] = carry & 0xff;\n@@ -398,16 +402,16 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n   decode (arg1, lv, hv);\n }\n \n-/* Rotate the 64-bit integer in L1, H1 left by COUNT places\n+/* Rotate the doubleword integer in L1, H1 left by COUNT places\n    keeping only PREC bits of result.  COUNT must be positive.\n-   Store the value as two `int' pieces in *LV and *HV.  */\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n rrotate_double (l1, h1, count, prec, lv, hv)\n-     int l1, h1, count, prec;\n-     int *lv, *hv;\n+     HOST_WIDE_INT l1, h1, count, prec;\n+     HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[8];\n+  short arg1[MAX_SHORTS];\n   register int i;\n   register int carry;\n \n@@ -419,7 +423,7 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n   carry = arg1[0] & 1;\n   while (count > 0)\n     {\n-      for (i = 7; i >= 0; i--)\n+      for (i = MAX_SHORTS - 1; i >= 0; i--)\n \t{\n \t  carry <<= 8;\n \t  carry += arg1[i];\n@@ -431,7 +435,7 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n   decode (arg1, lv, hv);\n }\n \f\n-/* Divide 64 bit integer LNUM, HNUM by 64 bit integer LDEN, HDEN\n+/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN\n    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).\n    CODE is a tree code for a kind of division, one of\n    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR\n@@ -445,12 +449,13 @@ div_and_round_double (code, uns,\n \t\t      lquo, hquo, lrem, hrem)\n      enum tree_code code;\n      int uns;\n-     int lnum_orig, hnum_orig;\t\t/* num == numerator == dividend */\n-     int lden_orig, hden_orig;\t\t/* den == denominator == divisor */\n-     int *lquo, *hquo, *lrem, *hrem;\n+     HOST_WIDE_INT lnum_orig, hnum_orig; /* num == numerator == dividend */\n+     HOST_WIDE_INT lden_orig, hden_orig; /* den == denominator == divisor */\n+     HOST_WIDE_INT *lquo, *hquo, *lrem, *hrem;\n {\n   int quo_neg = 0;\n-  short num[9], den[8], quo[8];\t/* extra element for scaling.  */\n+  short num[MAX_SHORTS + 1];\t/* extra element for scaling.  */\n+  short den[MAX_SHORTS], quo[MAX_SHORTS];\n   register int i, j, work;\n   register int carry = 0;\n   unsigned int lnum = lnum_orig;\n@@ -507,7 +512,7 @@ div_and_round_double (code, uns,\n   if (hden == 0 && ((lden << 8) >> 8) == lden)\n     {\t\t\t\t/* simpler algorithm */\n       /* hnum != 0 already checked.  */\n-      for (i = 7; i >= 0; i--)\n+      for (i = MAX_SHORTS - 1; i >= 0; i--)\n \t{\n \t  work = num[i] + (carry << 8);\n \t  quo[i] = work / lden;\n@@ -521,12 +526,12 @@ div_and_round_double (code, uns,\n     int quo_est, scale, num_hi_sig, den_hi_sig, quo_hi_sig;\n \n     /* Find the highest non-zero divisor digit.  */\n-    for (i = 7; ; i--)\n+    for (i = MAX_SHORTS - 1; ; i--)\n       if (den[i] != 0) {\n \tden_hi_sig = i;\n \tbreak;\n       }\n-    for (i = 7; ; i--)\n+    for (i = MAX_SHORTS - 1; ; i--)\n       if (num[i] != 0) {\n \tnum_hi_sig = i;\n \tbreak;\n@@ -539,14 +544,14 @@ div_and_round_double (code, uns,\n     scale = BASE / (den[den_hi_sig] + 1);\n     if (scale > 1) {\t\t/* scale divisor and dividend */\n       carry = 0;\n-      for (i = 0; i <= 8; i++) {\n+      for (i = 0; i <= MAX_SHORTS - 1; i++) {\n \twork = (num[i] * scale) + carry;\n \tnum[i] = work & 0xff;\n \tcarry = work >> 8;\n \tif (num[i] != 0) num_hi_sig = i;\n       }\n       carry = 0;\n-      for (i = 0; i <= 7; i++) {\n+      for (i = 0; i <= MAX_SHORTS - 1; i++) {\n \twork = (den[i] * scale) + carry;\n \tden[i] = work & 0xff;\n \tcarry = work >> 8;\n@@ -652,7 +657,8 @@ div_and_round_double (code, uns,\n       if (quo_neg && (*lrem != 0 || *hrem != 0))   /* ratio < 0 && rem != 0 */\n \t{\n \t  /* quo = quo - 1;  */\n-\t  add_double (*lquo, *hquo, -1, -1, lquo, hquo);\n+\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n+\t\t      lquo, hquo);\n \t}\n       else return;\n       break;\n@@ -661,33 +667,40 @@ div_and_round_double (code, uns,\n     case CEIL_MOD_EXPR:\t\t/* round toward positive infinity */\n       if (!quo_neg && (*lrem != 0 || *hrem != 0))  /* ratio > 0 && rem != 0 */\n \t{\n-\t  add_double (*lquo, *hquo, 1, 0, lquo, hquo);\n+\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t\t      lquo, hquo);\n \t}\n       else return;\n       break;\n     \n     case ROUND_DIV_EXPR:\n     case ROUND_MOD_EXPR:\t/* round to closest integer */\n       {\n-\tint labs_rem = *lrem, habs_rem = *hrem;\n-\tint labs_den = lden, habs_den = hden, ltwice, htwice;\n+\tHOST_WIDE_INT labs_rem = *lrem, habs_rem = *hrem;\n+\tHOST_WIDE_INT labs_den = lden, habs_den = hden, ltwice, htwice;\n \n \t/* get absolute values */\n \tif (*hrem < 0) neg_double (*lrem, *hrem, &labs_rem, &habs_rem);\n \tif (hden < 0) neg_double (lden, hden, &labs_den, &habs_den);\n \n \t/* if (2 * abs (lrem) >= abs (lden)) */\n-\tmul_double (2, 0, labs_rem, habs_rem, &ltwice, &htwice);\n-\tif (((unsigned) habs_den < (unsigned) htwice)\n-\t    || (((unsigned) habs_den == (unsigned) htwice)\n-\t\t&& ((unsigned) labs_den < (unsigned) ltwice)))\n+\tmul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,\n+\t\t    labs_rem, habs_rem, &ltwice, &htwice);\n+\tif (((unsigned HOST_WIDE_INT) habs_den\n+\t     < (unsigned HOST_WIDE_INT) htwice)\n+\t    || (((unsigned HOST_WIDE_INT) habs_den\n+\t\t == (unsigned HOST_WIDE_INT) htwice)\n+\t\t&& ((HOST_WIDE_INT unsigned) labs_den\n+\t\t    < (unsigned HOST_WIDE_INT) ltwice)))\n \t  {\n \t    if (*hquo < 0)\n \t      /* quo = quo - 1;  */\n-\t      add_double (*lquo, *hquo, -1, -1, lquo, hquo);\n+\t      add_double (*lquo, *hquo,\n+\t\t\t  (HOST_WIDE_INT) -1, (HOST_WIDE_INT) -1, lquo, hquo);\n \t    else\n \t      /* quo = quo + 1; */\n-\t      add_double (*lquo, *hquo, 1, 0, lquo, hquo);\n+\t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t\t\t  lquo, hquo);\n \t  }\n \telse return;\n       }\n@@ -728,7 +741,7 @@ real_value_truncate (mode, arg)\n     }\n   set_float_handler (handler);\n   value = REAL_VALUE_TRUNCATE (mode, arg);\n-  set_float_handler (0);\n+  set_float_handler (NULL_PTR);\n   return value;\n }\n \n@@ -981,12 +994,12 @@ const_binop (code, arg1, arg2)\n {\n   if (TREE_CODE (arg1) == INTEGER_CST)\n     {\n-      register int int1l = TREE_INT_CST_LOW (arg1);\n-      register int int1h = TREE_INT_CST_HIGH (arg1);\n-      int int2l = TREE_INT_CST_LOW (arg2);\n-      int int2h = TREE_INT_CST_HIGH (arg2);\n-      int low, hi;\n-      int garbagel, garbageh;\n+      register HOST_WIDE_INT int1l = TREE_INT_CST_LOW (arg1);\n+      register HOST_WIDE_INT int1h = TREE_INT_CST_HIGH (arg1);\n+      HOST_WIDE_INT int2l = TREE_INT_CST_LOW (arg2);\n+      HOST_WIDE_INT int2h = TREE_INT_CST_HIGH (arg2);\n+      HOST_WIDE_INT low, hi;\n+      HOST_WIDE_INT garbagel, garbageh;\n       register tree t;\n       int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n \n@@ -1031,15 +1044,15 @@ const_binop (code, arg1, arg2)\n \t  if (int1h == 0)\n \t    {\n \t      int2l += int1l;\n-\t      if ((unsigned) int2l < int1l)\n+\t      if ((unsigned HOST_WIDE_INT) int2l < int1l)\n \t\tint2h += 1;\n \t      t = build_int_2 (int2l, int2h);\n \t      break;\n \t    }\n \t  if (int2h == 0)\n \t    {\n \t      int1l += int2l;\n-\t      if ((unsigned) int1l < int2l)\n+\t      if ((unsigned HOST_WIDE_INT) int1l < int2l)\n \t\tint1h += 1;\n \t      t = build_int_2 (int1l, int1h);\n \t      break;\n@@ -1063,7 +1076,7 @@ const_binop (code, arg1, arg2)\n   /* Optimize simple cases.  */\n \t  if (int1h == 0)\n \t    {\n-\t      unsigned temp;\n+\t      unsigned HOST_WIDE_INT temp;\n \n \t      switch (int1l)\n \t\t{\n@@ -1168,15 +1181,19 @@ const_binop (code, arg1, arg2)\n \tcase MAX_EXPR:\n \t  if (uns)\n \t    {\n-\t      low = (((unsigned) int1h < (unsigned) int2h)\n-\t\t     || (((unsigned) int1h == (unsigned) int2h)\n-\t\t\t && ((unsigned) int1l < (unsigned) int2l)));\n+\t      low = (((unsigned HOST_WIDE_INT) int1h\n+\t\t      < (unsigned HOST_WIDE_INT) int2h)\n+\t\t     || (((unsigned HOST_WIDE_INT) int1h\n+\t\t\t  == (unsigned HOST_WIDE_INT) int2h)\n+\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n \t    }\n \t  else\n \t    {\n \t      low = ((int1h < int2h)\n \t\t     || ((int1h == int2h)\n-\t\t\t && ((unsigned) int1l < (unsigned) int2l)));\n+\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n \t    }\n \t  if (low == (code == MIN_EXPR))\n \t    t = build_int_2 (int1l, int1h);\n@@ -1249,7 +1266,7 @@ const_binop (code, arg1, arg2)\n #endif /* no REAL_ARITHMETIC */\n       t = build_real (TREE_TYPE (arg1),\n \t\t      real_value_truncate (TYPE_MODE (TREE_TYPE (arg1)), value));\n-      set_float_handler (0);\n+      set_float_handler (NULL_PTR);\n       return t;\n     }\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n@@ -1318,11 +1335,12 @@ size_int (number)\n {\n   register tree t;\n   /* Type-size nodes already made for small sizes.  */\n-  static tree size_table[2*HOST_BITS_PER_INT+1];\n+  static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1];\n \n-  if (number >= 0 && number < 2*HOST_BITS_PER_INT+1 && size_table[number] != 0)\n+  if (number >= 0 && number < 2*HOST_BITS_PER_WIDE_INT + 1\n+      && size_table[number] != 0)\n     return size_table[number];\n-  if (number >= 0 && number < 2*HOST_BITS_PER_INT+1)\n+  if (number >= 0 && number < 2*HOST_BITS_PER_WIDE_INT + 1)\n     {\n       push_obstacks_nochange ();\n       /* Make this a permanent node.  */\n@@ -1423,23 +1441,24 @@ fold_convert (t, arg1)\n #ifndef REAL_ARITHMETIC\n \t  {\n \t    REAL_VALUE_TYPE d;\n-\t    int low, high;\n-\t    int half_word = 1 << (HOST_BITS_PER_INT / 2);\n+\t    HOST_WIDE_INT low, high;\n+\t    HOST_WIDE_INT half_word\n+\t      = (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2);\n \n \t    d = TREE_REAL_CST (arg1);\n \t    if (d < 0)\n \t      d = -d;\n \n-\t    high = (int) (d / half_word / half_word);\n+\t    high = (HOST_WIDE_INT) (d / half_word / half_word);\n \t    d -= (REAL_VALUE_TYPE) high * half_word * half_word;\n-\t    low = (unsigned) d;\n+\t    low = (unsigned HOST_WIDE_INT) d;\n \t    if (TREE_REAL_CST (arg1) < 0)\n \t      neg_double (low, high, &low, &high);\n \t    t = build_int_2 (low, high);\n \t  }\n #else\n \t  {\n-\t    int low, high;\n+\t    HOST_WIDE_INT low, high;\n \t    REAL_VALUE_TO_INT (low, high, TREE_REAL_CST (arg1));\n \t    t = build_int_2 (low, high);\n \t  }\n@@ -1467,7 +1486,7 @@ fold_convert (t, arg1)\n \n \t  t = build_real (type, real_value_truncate (TYPE_MODE (type),\n \t\t\t\t\t\t     TREE_REAL_CST (arg1)));\n-\t  set_float_handler (0);\n+\t  set_float_handler (NULL_PTR);\n \t  return t;\n \t}\n     }\n@@ -3377,16 +3396,18 @@ fold (expr)\n \t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg1, 0))))\n \t{\n \t  int prec = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg1, 0)));\n-\t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_INT\n-\t      && (~TREE_INT_CST_LOW (arg0) & ((1 << prec) - 1)) == 0)\n+\t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_WIDE_INT\n+\t      && (~TREE_INT_CST_LOW (arg0)\n+\t\t  & (((HOST_WIDE_INT) 1 << prec) - 1)) == 0)\n \t    return build1 (NOP_EXPR, type, TREE_OPERAND (arg1, 0));\n \t}\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n \t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n \t  int prec = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n-\t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_INT\n-\t      && (~TREE_INT_CST_LOW (arg1) & ((1 << prec) - 1)) == 0)\n+\t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_WIDE_INT\n+\t      && (~TREE_INT_CST_LOW (arg1)\n+\t\t  & (((HOST_WIDE_INT) 1 << prec) - 1)) == 0)\n \t    return build1 (NOP_EXPR, type, TREE_OPERAND (arg0, 0));\n \t}\n       goto associate;\n@@ -3429,7 +3450,7 @@ fold (expr)\n \t{\n \t  tree new_op\n \t    = build_int_2 (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1))\n-\t\t\t   / TREE_INT_CST_LOW (arg1));\n+\t\t\t   / TREE_INT_CST_LOW (arg1), 0);\n \n \t  TREE_TYPE (new_op) = type;\n \t  return build (MULT_EXPR, type, TREE_OPERAND (arg0, 0), new_op);\n@@ -3450,7 +3471,7 @@ fold (expr)\n \t{\n \t  tree new_op\n \t    = build_int_2 (TREE_INT_CST_LOW (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t\t   / TREE_INT_CST_LOW (arg1));\n+\t\t\t   / TREE_INT_CST_LOW (arg1), 0);\n \t  \n \t  TREE_TYPE (new_op) = type;\n \t  return build (MULT_EXPR, type,"}, {"sha": "a2fc595dd01033353056604d42d524d958b2a5d4", "filename": "gcc/gcc.c", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -47,6 +47,14 @@ compilation is specified by a string called a \"spec\".  */\n #define X_OK 1\n #endif\n \n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR (char *) NULL\n+#endif\n+\n #ifdef USG\n #define vfork fork\n #endif /* USG */\n@@ -1716,8 +1724,8 @@ process_command (argc, argv)\n \n   if (gcc_exec_prefix)\n     {\n-      add_prefix (&exec_prefix, gcc_exec_prefix, 0, 0, 0);\n-      add_prefix (&startfile_prefix, gcc_exec_prefix, 0, 0, 0);\n+      add_prefix (&exec_prefix, gcc_exec_prefix, 0, 0, NULL_PTR);\n+      add_prefix (&startfile_prefix, gcc_exec_prefix, 0, 0, NULL_PTR);\n     }\n \n   /* COMPILER_PATH and LIBRARY_PATH have values\n@@ -1746,7 +1754,7 @@ process_command (argc, argv)\n \t\t}\n \t      else\n \t\tnstore[endp-startp] = 0;\n-\t      add_prefix (&exec_prefix, nstore, 0, 0, 0);\n+\t      add_prefix (&exec_prefix, nstore, 0, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n \t      endp = startp = endp + 1;\n@@ -1779,9 +1787,9 @@ process_command (argc, argv)\n \t\t}\n \t      else\n \t\tnstore[endp-startp] = 0;\n-\t      add_prefix (&startfile_prefix, nstore, 0, 0, 0);\n+\t      add_prefix (&startfile_prefix, nstore, 0, 0, NULL_PTR);\n \t      /* Make separate list of dirs that came from LIBRARY_PATH.  */\n-\t      add_prefix (&library_prefix, nstore, 0, 0, 0);\n+\t      add_prefix (&library_prefix, nstore, 0, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n \t      endp = startp = endp + 1;\n@@ -1815,9 +1823,9 @@ process_command (argc, argv)\n \t\t}\n \t      else\n \t\tnstore[endp-startp] = 0;\n-\t      add_prefix (&startfile_prefix, nstore, 0, 0, 0);\n+\t      add_prefix (&startfile_prefix, nstore, 0, 0, NULL_PTR);\n \t      /* Make separate list of dirs that came from LIBRARY_PATH.  */\n-\t      add_prefix (&library_prefix, nstore, 0, 0, 0);\n+\t      add_prefix (&library_prefix, nstore, 0, 0, NULL_PTR);\n \t      if (*endp == 0)\n \t\tbreak;\n \t      endp = startp = endp + 1;\n@@ -1947,11 +1955,11 @@ process_command (argc, argv)\n \n   /* These come before the md prefixes so that we will find gcc's subcommands\n      (such as cpp) rather than those of the host system.  */\n-  add_prefix (&exec_prefix, standard_exec_prefix, 0, 1, 0);\n-  add_prefix (&exec_prefix, standard_exec_prefix_1, 0, 1, 0);\n+  add_prefix (&exec_prefix, standard_exec_prefix, 0, 1, NULL_PTR);\n+  add_prefix (&exec_prefix, standard_exec_prefix_1, 0, 1, NULL_PTR);\n \n-  add_prefix (&startfile_prefix, standard_exec_prefix, 0, 1, 0);\n-  add_prefix (&startfile_prefix, standard_exec_prefix_1, 0, 1, 0);\n+  add_prefix (&startfile_prefix, standard_exec_prefix, 0, 1, NULL_PTR);\n+  add_prefix (&startfile_prefix, standard_exec_prefix_1, 0, 1, NULL_PTR);\n \n   /* More prefixes are enabled in main, after we read the specs file\n      and determine whether this is cross-compilation or not.  */\n@@ -2115,7 +2123,7 @@ do_spec (spec)\n   this_is_output_file = 0;\n   this_is_library_file = 0;\n \n-  value = do_spec_1 (spec, 0, NULL);\n+  value = do_spec_1 (spec, 0, NULL_PTR);\n \n   /* Force out any unfinished command.\n      If -pipe, this forces out the last command if it ended in `|'.  */\n@@ -2287,11 +2295,11 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t      {\n \t\t\tif (is_linker_dir (pl->prefix, machine_suffix))\n \t\t\t  {\n-\t\t\t    do_spec_1 (\"-L\", 0, 0);\n+\t\t\t    do_spec_1 (\"-L\", 0, NULL_PTR);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t    do_spec_1 (\" \", 0, 0);\n+\t\t\t    do_spec_1 (\" \", 0, NULL_PTR);\n #endif\n-\t\t\t    do_spec_1 (pl->prefix, 1, 0);\n+\t\t\t    do_spec_1 (pl->prefix, 1, NULL_PTR);\n \t\t\t    /* Remove slash from machine_suffix.  */\n \t\t\t    if (strlen (machine_suffix) >= bufsize)\n \t\t\t      bufsize = strlen (machine_suffix) * 2 + 1;\n@@ -2300,18 +2308,18 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t    idx = strlen (buffer);\n \t\t\t    if (buffer[idx - 1] == '/')\n \t\t\t      buffer[idx - 1] = 0;\n-\t\t\t    do_spec_1 (buffer, 1, 0);\n+\t\t\t    do_spec_1 (buffer, 1, NULL_PTR);\n \t\t\t    /* Make this a separate argument.  */\n-\t\t\t    do_spec_1 (\" \", 0, 0);\n+\t\t\t    do_spec_1 (\" \", 0, NULL_PTR);\n \t\t\t  }\n \t\t      }\n \t\t    if (!pl->require_machine_suffix)\n \t\t      {\n \t\t\tif (is_linker_dir (pl->prefix, \"\"))\n \t\t\t  {\n-\t\t\t    do_spec_1 (\"-L\", 0, 0);\n+\t\t\t    do_spec_1 (\"-L\", 0, NULL_PTR);\n #ifdef SPACE_AFTER_L_OPTION\n-\t\t\t    do_spec_1 (\" \", 0, 0);\n+\t\t\t    do_spec_1 (\" \", 0, NULL_PTR);\n #endif\n \t\t\t    /* Remove slash from pl->prefix.  */\n \t\t\t    if (strlen (pl->prefix) >= bufsize)\n@@ -2321,9 +2329,9 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t    idx = strlen (buffer);\n \t\t\t    if (buffer[idx - 1] == '/')\n \t\t\t      buffer[idx - 1] = 0;\n-\t\t\t    do_spec_1 (buffer, 1, 0);\n+\t\t\t    do_spec_1 (buffer, 1, NULL_PTR);\n \t\t\t    /* Make this a separate argument.  */\n-\t\t\t    do_spec_1 (\" \", 0, 0);\n+\t\t\t    do_spec_1 (\" \", 0, NULL_PTR);\n \t\t\t  }\n \t\t      }\n \t\t  }\n@@ -2444,49 +2452,49 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t  case 'X':\n \t    for (i = 0; i < n_linker_options; i++)\n \t      {\n-\t\tdo_spec_1 (linker_options[i], 1, NULL);\n+\t\tdo_spec_1 (linker_options[i], 1, NULL_PTR);\n \t\t/* Make each accumulated option a separate argument.  */\n-\t\tdo_spec_1 (\" \", 0, NULL);\n+\t\tdo_spec_1 (\" \", 0, NULL_PTR);\n \t      }\n \t    break;\n \n \t    /* Here are digits and numbers that just process\n \t       a certain constant string as a spec.  */\n \n \t  case '1':\n-\t    do_spec_1 (cc1_spec, 0, NULL);\n+\t    do_spec_1 (cc1_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case '2':\n-\t    do_spec_1 (cc1plus_spec, 0, NULL);\n+\t    do_spec_1 (cc1plus_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'a':\n-\t    do_spec_1 (asm_spec, 0, NULL);\n+\t    do_spec_1 (asm_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'A':\n-\t    do_spec_1 (asm_final_spec, 0, NULL);\n+\t    do_spec_1 (asm_final_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'c':\n-\t    do_spec_1 (signed_char_spec, 0, NULL);\n+\t    do_spec_1 (signed_char_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'C':\n-\t    do_spec_1 (cpp_spec, 0, NULL);\n+\t    do_spec_1 (cpp_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'E':\n-\t    do_spec_1 (endfile_spec, 0, NULL);\n+\t    do_spec_1 (endfile_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'l':\n-\t    do_spec_1 (link_spec, 0, NULL);\n+\t    do_spec_1 (link_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'L':\n-\t    do_spec_1 (lib_spec, 0, NULL);\n+\t    do_spec_1 (lib_spec, 0, NULL_PTR);\n \t    break;\n \n \t  case 'p':\n@@ -2513,7 +2521,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      *x = 0;\n \n-\t      do_spec_1 (buf, 0, NULL);\n+\t      do_spec_1 (buf, 0, NULL_PTR);\n \t    }\n \t    break;\n \n@@ -2619,12 +2627,12 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n \t      *x = 0;\n \n-\t      do_spec_1 (buf, 0, NULL);\n+\t      do_spec_1 (buf, 0, NULL_PTR);\n \t    }\n \t    break;\n \n \t  case 'S':\n-\t    do_spec_1 (startfile_spec, 0, NULL);\n+\t    do_spec_1 (startfile_spec, 0, NULL_PTR);\n \t    break;\n \n \t    /* Here we define characters other than letters and digits.  */\n@@ -2640,8 +2648,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    break;\n \n \t  case '*':\n-\t    do_spec_1 (soft_matched_part, 1, NULL);\n-\t    do_spec_1 (\" \", 0, NULL);\n+\t    do_spec_1 (soft_matched_part, 1, NULL_PTR);\n+\t    do_spec_1 (\" \", 0, NULL_PTR);\n \t    break;\n \n \t    /* Process a string found as the value of a spec given by name.\n@@ -2672,7 +2680,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      if (sl)\n \t\t{\n \t\t  if (c == '(')\n-\t\t    do_spec_1 (name, 0, NULL);\n+\t\t    do_spec_1 (name, 0, NULL_PTR);\n \t\t  else\n \t\t    {\n \t\t      char *x = (char *) alloca (strlen (name) * 2 + 1);\n@@ -2705,7 +2713,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t\t}\n \t\t      *x = 0;\n \n-\t\t      do_spec_1 (buf, 0, NULL);\n+\t\t      do_spec_1 (buf, 0, NULL_PTR);\n \t\t    }\n \t\t}\n \n@@ -2797,7 +2805,7 @@ handle_braces (p)\n \tabort ();\n \n       if (negate != found\n-\t  && do_spec_1 (save_string (p + 1, q - p - 2), 0, NULL) < 0)\n+\t  && do_spec_1 (save_string (p + 1, q - p - 2), 0, NULL_PTR) < 0)\n \treturn 0;\n \n       return q;\n@@ -2895,15 +2903,15 @@ handle_braces (p)\n \t    }\n \t  else\n \t    {\n-\t      if (do_spec_1 (save_string (p + 1, q - p - 2), 0, NULL) < 0)\n+\t      if (do_spec_1 (save_string (p + 1, q - p - 2), 0, NULL_PTR) < 0)\n \t\treturn 0;\n \t    }\n \t}\n       else if (pipe)\n \t{\n \t  /* Here if a %{|...} conditional fails: output a minus sign,\n \t     which means \"standard output\" or \"standard input\".  */\n-\t  do_spec_1 (\"-\", 0, NULL);\n+\t  do_spec_1 (\"-\", 0, NULL_PTR);\n \t}\n     }\n \n@@ -2925,17 +2933,17 @@ give_switch (switchnum, omit_first_word)\n {\n   if (!omit_first_word)\n     {\n-      do_spec_1 (\"-\", 0, NULL);\n-      do_spec_1 (switches[switchnum].part1, 1, NULL);\n+      do_spec_1 (\"-\", 0, NULL_PTR);\n+      do_spec_1 (switches[switchnum].part1, 1, NULL_PTR);\n     }\n-  do_spec_1 (\" \", 0, NULL);\n+  do_spec_1 (\" \", 0, NULL_PTR);\n   if (switches[switchnum].args != 0)\n     {\n       char **p;\n       for (p = switches[switchnum].args; *p; p++)\n \t{\n-\t  do_spec_1 (*p, 1, NULL);\n-\t  do_spec_1 (\" \", 0, NULL);\n+\t  do_spec_1 (*p, 1, NULL_PTR);\n+\t  do_spec_1 (\" \", 0, NULL_PTR);\n \t}\n     }\n   switches[switchnum].valid = 1;\n@@ -3072,23 +3080,26 @@ main (argc, argv)\n   if (!cross_compile)\n     {\n #ifdef MD_EXEC_PREFIX\n-      add_prefix (&exec_prefix, md_exec_prefix, 0, 0, 0);\n-      add_prefix (&startfile_prefix, md_exec_prefix, 0, 0, 0);\n+      add_prefix (&exec_prefix, md_exec_prefix, 0, 0, NULL_PTR);\n+      add_prefix (&startfile_prefix, md_exec_prefix, 0, 0, NULL_PTR);\n #endif\n \n #ifdef MD_STARTFILE_PREFIX\n-      add_prefix (&startfile_prefix, md_startfile_prefix, 0, 0, 0);\n+      add_prefix (&startfile_prefix, md_startfile_prefix, 0, 0, NULL_PTR);\n #endif\n \n #ifdef MD_STARTFILE_PREFIX_1\n-      add_prefix (&startfile_prefix, md_startfile_prefix_1, 0, 0, 0);\n+      add_prefix (&startfile_prefix, md_startfile_prefix_1, 0, 0, NULL_PTR);\n #endif\n \n-      add_prefix (&startfile_prefix, standard_startfile_prefix, 0, 0, 0);\n-      add_prefix (&startfile_prefix, standard_startfile_prefix_1, 0, 0, 0);\n-      add_prefix (&startfile_prefix, standard_startfile_prefix_2, 0, 0, 0);\n+      add_prefix (&startfile_prefix, standard_startfile_prefix, 0, 0,\n+\t\t  NULL_PTR);\n+      add_prefix (&startfile_prefix, standard_startfile_prefix_1, 0, 0,\n+\t\t  NULL_PTR);\n+      add_prefix (&startfile_prefix, standard_startfile_prefix_2, 0, 0,\n+\t\t  NULL_PTR);\n #if 0 /* Can cause surprises, and one can use -B./ instead.  */\n-      add_prefix (&startfile_prefix, \"./\", 0, 1, 0);\n+      add_prefix (&startfile_prefix, \"./\", 0, 1, NULL_PTR);\n #endif\n     }\n \n@@ -3315,7 +3326,7 @@ lookup_compiler (name, length, language)\n \t      language = cp->spec + 1;\n \t      new = (struct compiler *) xmalloc (sizeof (struct compiler));\n \t      new->suffix = cp->suffix;\n-\t      new->spec = lookup_compiler (0, 0, language)->spec;\n+\t      new->spec = lookup_compiler (NULL_PTR, 0, language)->spec;\n \t      return new;\n \t    }\n \t  /* A non-alias entry: return it.  */"}, {"sha": "b7aaddef7b2482d58ee1cd2e13aaea266bcb235b", "filename": "gcc/print-tree.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/906c4e36c6f418550a1040e1e61d989aa72f3b3c/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=906c4e36c6f418550a1040e1e61d989aa72f3b3c", "patch": "@@ -79,8 +79,8 @@ print_node_brief (file, prefix, node, indent)\n      name if any.  */\n   if (indent > 0)\n     fprintf (file, \" \");\n-  fprintf (file, \"%s <%s %x\", prefix,\n-\t   tree_code_name[(int) TREE_CODE (node)], (int) node);\n+  fprintf (file, \"%s <%s \", prefix, tree_code_name[(int) TREE_CODE (node)]);\n+  fprintf (file, HOST_PTR_PRINTF, node);\n \n   if (class == 'd')\n     {\n@@ -110,9 +110,21 @@ print_node_brief (file, prefix, node, indent)\n \t       && TREE_INT_CST_LOW (node) != 0)\n \tfprintf (file, \" -%1u\", -TREE_INT_CST_LOW (node));\n       else\n-\tfprintf (file, \" 0x%x%08x\",\n-\t\t TREE_INT_CST_HIGH (node),\n-\t\t TREE_INT_CST_LOW (node));\n+\tfprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%016lx\",\n+#else\n+\t\t \" 0x%x%016x\",\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%08lx\",\n+#else\n+\t\t \" 0x%x%08x\",\n+#endif\n+#endif\n+\t\t TREE_INT_CST_HIGH (node), TREE_INT_CST_LOW (node));\n     }\n   if (TREE_CODE (node) == REAL_CST)\n     {\n@@ -213,8 +225,8 @@ print_node (file, prefix, node, indent)\n   indent_to (file, indent);\n \n   /* Print the slot this node is in, and its code, and address.  */\n-  fprintf (file, \"%s <%s %x\", prefix,\n-\t   tree_code_name[(int) TREE_CODE (node)], (int) node);\n+  fprintf (file, \"%s <%s \", prefix, tree_code_name[(int) TREE_CODE (node)]);\n+  fprintf (file, HOST_PTR_PRINTF, node);\n \n   /* Print the name, if any.  */\n   if (class == 'd')\n@@ -374,7 +386,10 @@ print_node (file, prefix, node, indent)\n \t      print_rtl (file, DECL_INCOMING_RTL (node));\n \t    }\n \t  else if (TREE_CODE (node) == FUNCTION_DECL)\n-\t    fprintf (file, \"saved-insns 0x%x\", DECL_SAVED_INSNS (node));\n+\t    {\n+\t      fprintf (file, \"saved-insns \");\n+\t      fprintf (file, HOST_PTR_PRINTF, DECL_SAVED_INSNS (node));\n+\t    }\n \t}\n \n       /* Print the decl chain only if decl is at second level.  */\n@@ -525,9 +540,21 @@ print_node (file, prefix, node, indent)\n \t\t   && TREE_INT_CST_LOW (node) != 0)\n \t    fprintf (file, \" -%1u\", -TREE_INT_CST_LOW (node));\n \t  else\n-\t    fprintf (file, \" 0x%x%08x\",\n-\t\t     TREE_INT_CST_HIGH (node),\n-\t\t     TREE_INT_CST_LOW (node));\n+\t    fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t     \" 0x%lx%016lx\",\n+#else\n+\t\t     \" 0x%x%016x\",\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t     \" 0x%lx%08lx\",\n+#else\n+\t\t     \" 0x%x%08x\",\n+#endif\n+#endif\n+\t\t     TREE_INT_CST_HIGH (node), TREE_INT_CST_LOW (node));\n \t  break;\n \n \tcase REAL_CST:"}]}