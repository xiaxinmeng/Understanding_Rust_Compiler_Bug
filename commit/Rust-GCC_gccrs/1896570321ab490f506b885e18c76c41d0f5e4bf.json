{"sha": "1896570321ab490f506b885e18c76c41d0f5e4bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg5NjU3MDMyMWFiNDkwZjUwNmI4ODVlMThjNzZjNDFkMGY1ZTRiZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-05-30T13:29:51Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-05-30T13:29:51Z"}, "message": "tree-scalar-evolution.c (scev_const_prop): Do not create labels.\n\n\t* tree-scalar-evolution.c (scev_const_prop): Do not create labels.\n\t* tree-ssa-sink.c (statement_sink_location): Return basic block and\n\tbsi of the location where statements should be inserted.\n\t(sink_code_in_bb): Take bsi from statement_sink_location.\n\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use bsi_after_labels\n\tinstead of bsi_start.\n\t* tree-profile.c (tree_gen_ic_func_profiler): Pass BSI_NEW_STMT to\n\tbsi_insert_after.\n\t* tree-cfg.c (bsi_move_after): Pass BSI_NEW_STMT to bsi_insert_after.\n\t(bsi_move_before): Document inconsistency with bsi_move_after.\n\t(tree_redirect_edge_and_branch): Do not create labels if not necessary.\n\nFrom-SVN: r125181", "tree": {"sha": "c2daa0843ce51836927c876cdf0efada31c93249", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2daa0843ce51836927c876cdf0efada31c93249"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1896570321ab490f506b885e18c76c41d0f5e4bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1896570321ab490f506b885e18c76c41d0f5e4bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1896570321ab490f506b885e18c76c41d0f5e4bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1896570321ab490f506b885e18c76c41d0f5e4bf/comments", "author": null, "committer": null, "parents": [{"sha": "0a1c5e5520b74cb2f2450dce1ef9fa468ba3da39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1c5e5520b74cb2f2450dce1ef9fa468ba3da39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1c5e5520b74cb2f2450dce1ef9fa468ba3da39"}], "stats": {"total": 99, "additions": 59, "deletions": 40}, "files": [{"sha": "3030d3ccd00c70a2a59e9d9b6ece05221b0a6be8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -1,3 +1,17 @@\n+2007-05-30  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-scalar-evolution.c (scev_const_prop): Do not create labels.\n+\t* tree-ssa-sink.c (statement_sink_location): Return basic block and\n+\tbsi of the location where statements should be inserted.\n+\t(sink_code_in_bb): Take bsi from statement_sink_location.\n+\t* lambda-code.c (lambda_loopnest_to_gcc_loopnest): Use bsi_after_labels\n+\tinstead of bsi_start.\n+\t* tree-profile.c (tree_gen_ic_func_profiler): Pass BSI_NEW_STMT to\n+\tbsi_insert_after.\n+\t* tree-cfg.c (bsi_move_after): Pass BSI_NEW_STMT to bsi_insert_after.\n+\t(bsi_move_before): Document inconsistency with bsi_move_after.\n+\t(tree_redirect_edge_and_branch): Do not create labels if not necessary.\n+\n 2007-05-30 Uros Bizjak <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (TARGET_ABM): New define."}, {"sha": "62fd245b2358ab635b0ec4854eb57f6d9a7d10b5", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -1881,8 +1881,8 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       exit = single_exit (temp);\n       exitcond = get_loop_exit_condition (temp);\n       bb = bb_for_stmt (exitcond);\n-      bsi = bsi_start (bb);\n-      bsi_insert_after (&bsi, stmts, BSI_NEW_STMT);\n+      bsi = bsi_after_labels (bb);\n+      bsi_insert_before (&bsi, stmts, BSI_NEW_STMT);\n \n       /* Create the new iv.  */\n "}, {"sha": "7bd4496cf836e350202334b116cc8332af309379", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -2776,7 +2776,9 @@ bsi_move_after (block_stmt_iterator *from, block_stmt_iterator *to)\n {\n   tree stmt = bsi_stmt (*from);\n   bsi_remove (from, false);\n-  bsi_insert_after (to, stmt, BSI_SAME_STMT);\n+  /* We must have BSI_NEW_STMT here, as bsi_move_after is sometimes used to\n+     move statements to an empty block.  */\n+  bsi_insert_after (to, stmt, BSI_NEW_STMT);\n }\n \n \n@@ -2787,6 +2789,9 @@ bsi_move_before (block_stmt_iterator *from, block_stmt_iterator *to)\n {\n   tree stmt = bsi_stmt (*from);\n   bsi_remove (from, false);\n+  /* For consistency with bsi_move_after, it might be better to have\n+     BSI_NEW_STMT here; however, that breaks several places that expect\n+     that TO does not change.  */\n   bsi_insert_before (to, stmt, BSI_SAME_STMT);\n }\n \n@@ -3993,7 +3998,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   basic_block bb = e->src;\n   block_stmt_iterator bsi;\n   edge ret;\n-  tree label, stmt;\n+  tree stmt;\n \n   if (e->flags & EDGE_ABNORMAL)\n     return NULL;\n@@ -4005,8 +4010,6 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->dest == dest)\n     return NULL;\n \n-  label = tree_block_label (dest);\n-\n   bsi = bsi_last (bb);\n   stmt = bsi_end_p (bsi) ? NULL : bsi_stmt (bsi);\n \n@@ -4024,6 +4027,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n     case SWITCH_EXPR:\n       {\n         tree cases = get_cases_for_edge (e, stmt);\n+\ttree label = tree_block_label (dest);\n \n \t/* If we have a list of cases associated with E, then use it\n \t   as it's a lot faster than walking the entire case vector.  */"}, {"sha": "2dace9c6a8f6d9a7931d4e5db365c4081a927610", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -332,7 +332,7 @@ tree_gen_ic_func_profiler (void)\n \t\t\t       tree_uid,\n \t\t\t       cur_func,\n \t\t\t       ic_void_ptr_var);\n-      bsi_insert_after (&bsi, stmt1, BSI_SAME_STMT);\n+      bsi_insert_after (&bsi, stmt1, BSI_NEW_STMT);\n     }\n }\n "}, {"sha": "059836154a6559a2e73099b49ef4474e0e693c52", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -2968,7 +2968,6 @@ scev_const_prop (void)\n       /* Ensure that it is possible to insert new statements somewhere.  */\n       if (!single_pred_p (exit->dest))\n \tsplit_loop_exit_edge (exit);\n-      tree_block_label (exit->dest);\n       bsi = bsi_after_labels (exit->dest);\n \n       ex_loop = superloop_at_depth (loop,"}, {"sha": "6dff7ff943fb91b6f583af77651b6187bb32e1fa", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1896570321ab490f506b885e18c76c41d0f5e4bf/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=1896570321ab490f506b885e18c76c41d0f5e4bf", "patch": "@@ -263,11 +263,13 @@ nearest_common_dominator_of_uses (tree stmt)\n \n /* Given a statement (STMT) and the basic block it is currently in (FROMBB), \n    determine the location to sink the statement to, if any.\n-   Return the basic block to sink it to, or NULL if we should not sink\n-   it.  */\n+   Returns true if there is such location; in that case, TOBB is set to the\n+   basic block of the location, and TOBSI points to the statement before\n+   that STMT should be moved.  */\n \n-static tree\n-statement_sink_location (tree stmt, basic_block frombb)\n+static bool\n+statement_sink_location (tree stmt, basic_block frombb, basic_block *tobb,\n+\t\t\t block_stmt_iterator *tobsi)\n {\n   tree use, def;\n   use_operand_p one_use = NULL_USE_OPERAND_P;\n@@ -291,10 +293,10 @@ statement_sink_location (tree stmt, basic_block frombb)\n \n   /* Return if there are no immediate uses of this stmt.  */\n   if (one_use == NULL_USE_OPERAND_P)\n-    return NULL;\n+    return false;\n \n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n-    return NULL;\n+    return false;\n   rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n   /* There are a few classes of things we can't or don't move, some because we\n@@ -325,21 +327,21 @@ statement_sink_location (tree stmt, basic_block frombb)\n       || is_hidden_global_store (stmt)\n       || ann->has_volatile_ops\n       || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE))\n-    return NULL;\n+    return false;\n   \n   FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n       tree def = DEF_FROM_PTR (def_p);\n       if (is_global_var (SSA_NAME_VAR (def))\n \t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def))\n-\treturn NULL;\n+\treturn false;\n     }\n     \n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n     {\n       tree use = USE_FROM_PTR (use_p);\n       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use))\n-\treturn NULL;\n+\treturn false;\n     }\n   \n   /* If all the immediate uses are not in the same place, find the nearest\n@@ -351,13 +353,13 @@ statement_sink_location (tree stmt, basic_block frombb)\n       basic_block commondom = nearest_common_dominator_of_uses (stmt);\n      \n       if (commondom == frombb)\n-\treturn NULL;\n+\treturn false;\n \n       /* Our common dominator has to be dominated by frombb in order to be a\n \t trivially safe place to put this statement, since it has multiple\n \t uses.  */     \n       if (!dominated_by_p (CDI_DOMINATORS, commondom, frombb))\n-\treturn NULL;\n+\treturn false;\n       \n       /* It doesn't make sense to move to a dominator that post-dominates\n \t frombb, because it means we've just moved it into a path that always\n@@ -367,17 +369,19 @@ statement_sink_location (tree stmt, basic_block frombb)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Not moving store, common dominator post-dominates from block.\\n\");\n-\t  return NULL;\n+\t  return false;\n \t}\n \n       if (commondom == frombb || commondom->loop_depth > frombb->loop_depth)\n-\treturn NULL;\n+\treturn false;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Common dominator of all uses is %d\\n\",\n \t\t   commondom->index);\n \t}\n-      return first_stmt (commondom);\n+      *tobb = commondom;\n+      *tobsi = bsi_after_labels (commondom);\n+      return true;\n     }\n \n   use = USE_STMT (one_use);\n@@ -386,19 +390,20 @@ statement_sink_location (tree stmt, basic_block frombb)\n       sinkbb = bb_for_stmt (use);\n       if (sinkbb == frombb || sinkbb->loop_depth > frombb->loop_depth\n \t  || sinkbb->loop_father != frombb->loop_father)\n-\treturn NULL;      \n-      return use;\n+\treturn false;\n+      *tobb = sinkbb;\n+      *tobsi = bsi_for_stmt (use);\n+      return true;\n     }\n \n   /* Note that at this point, all uses must be in the same statement, so it\n      doesn't matter which def op we choose, pick the first one.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     break;\n \n-  \n   sinkbb = find_bb_for_arg (use, def);\n   if (!sinkbb)\n-    return NULL;\n+    return false;\n \n   /* This will happen when you have\n      a_3 = PHI <a_13, a_26>\n@@ -409,12 +414,15 @@ statement_sink_location (tree stmt, basic_block frombb)\n      we can't sink it.  */\n \n   if (bb_for_stmt (use) == frombb)\n-    return NULL;\n+    return false;\n   if (sinkbb == frombb || sinkbb->loop_depth > frombb->loop_depth\n       || sinkbb->loop_father != frombb->loop_father)\n-    return NULL;\n+    return false;\n+\n+  *tobb = sinkbb;\n+  *tobsi = bsi_after_labels (sinkbb);\n \n-  return first_stmt (sinkbb);\n+  return true;\n }\n \n /* Perform code sinking on BB */\n@@ -441,10 +449,9 @@ sink_code_in_bb (basic_block bb)\n     {\n       tree stmt = bsi_stmt (bsi);\t\n       block_stmt_iterator tobsi;\n-      tree sinkstmt;\n-      \n-      sinkstmt = statement_sink_location (stmt, bb);\n-      if (!sinkstmt)\n+      basic_block tobb;\n+\n+      if (!statement_sink_location (stmt, bb, &tobb, &tobsi))\n \t{\n \t  if (!bsi_end_p (bsi))\n \t    bsi_prev (&bsi);\n@@ -455,18 +462,13 @@ sink_code_in_bb (basic_block bb)\n \t  fprintf (dump_file, \"Sinking \");\n \t  print_generic_expr (dump_file, stmt, TDF_VOPS);\n \t  fprintf (dump_file, \" from bb %d to bb %d\\n\",\n-\t\t   bb->index, bb_for_stmt (sinkstmt)->index);\n+\t\t   bb->index, tobb->index);\n \t}\n-      tobsi = bsi_for_stmt (sinkstmt);\n-      /* Find the first non-label.  */\n-      while (!bsi_end_p (tobsi)\n-             && TREE_CODE (bsi_stmt (tobsi)) == LABEL_EXPR)\n-        bsi_next (&tobsi);\n       \n       /* If this is the end of the basic block, we need to insert at the end\n          of the basic block.  */\n       if (bsi_end_p (tobsi))\n-\tbsi_move_to_bb_end (&bsi, bb_for_stmt (sinkstmt));\n+\tbsi_move_to_bb_end (&bsi, tobb);\n       else\n \tbsi_move_before (&bsi, &tobsi);\n "}]}