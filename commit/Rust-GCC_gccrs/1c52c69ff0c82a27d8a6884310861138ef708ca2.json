{"sha": "1c52c69ff0c82a27d8a6884310861138ef708ca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM1MmM2OWZmMGM4MmEyN2Q4YTY4ODQzMTA4NjExMzhlZjcwOGNhMg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-02T16:12:41Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-02T16:12:41Z"}, "message": "tree-ssa-loop-ivopts.c (struct walk_tree_data): New.\n\n\t* tree-ssa-loop-ivopts.c (struct walk_tree_data): New.\n\t(find_inv_vars_cb): New.\n\t(find_depends): Renamed to ...\n\t(find_inv_vars): ... this.\n\t(add_candidate_1, force_var_cost): Call find_inv_vars.\n\t(split_address_cost, determine_group_iv_cost_cond): Ditto.\n\nFrom-SVN: r247514", "tree": {"sha": "8ffe37c0ecd3b206b9cd79921c35acd976d5a5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ffe37c0ecd3b206b9cd79921c35acd976d5a5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c52c69ff0c82a27d8a6884310861138ef708ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c52c69ff0c82a27d8a6884310861138ef708ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c52c69ff0c82a27d8a6884310861138ef708ca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c52c69ff0c82a27d8a6884310861138ef708ca2/comments", "author": null, "committer": null, "parents": [{"sha": "0ca91c77f47be118b5b2a0b97e986863c80beafc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca91c77f47be118b5b2a0b97e986863c80beafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca91c77f47be118b5b2a0b97e986863c80beafc"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "28cde9e929fe16618a7665cde8fa6aee510ee54b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c52c69ff0c82a27d8a6884310861138ef708ca2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c52c69ff0c82a27d8a6884310861138ef708ca2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c52c69ff0c82a27d8a6884310861138ef708ca2", "patch": "@@ -1,3 +1,12 @@\n+2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (struct walk_tree_data): New.\n+\t(find_inv_vars_cb): New.\n+\t(find_depends): Renamed to ...\n+\t(find_inv_vars): ... this.\n+\t(add_candidate_1, force_var_cost): Call find_inv_vars.\n+\t(split_address_cost, determine_group_iv_cost_cond): Ditto.\n+\n 2017-05-02  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (struct cost_pair): Rename depends_on to"}, {"sha": "3a5b1b9f7c89621b66839bcc6ae26ff15ffd53bf", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c52c69ff0c82a27d8a6884310861138ef708ca2/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c52c69ff0c82a27d8a6884310861138ef708ca2/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1c52c69ff0c82a27d8a6884310861138ef708ca2", "patch": "@@ -2896,30 +2896,53 @@ generic_type_for (tree type)\n   return unsigned_type_for (type);\n }\n \n-/* Records invariants in *EXPR_P.  Callback for walk_tree.  DATA contains\n-   the bitmap to that we should store it.  */\n+/* Private data for walk_tree.  */\n+\n+struct walk_tree_data\n+{\n+  bitmap *inv_vars;\n+  struct ivopts_data *idata;\n+};\n+\n+/* Callback function for walk_tree, it records invariants and symbol\n+   reference in *EXPR_P.  DATA is the structure storing result info.  */\n \n-static struct ivopts_data *fd_ivopts_data;\n static tree\n-find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n+find_inv_vars_cb (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n {\n-  bitmap *inv_vars = (bitmap *) data;\n+  struct walk_tree_data *wdata = (struct walk_tree_data*) data;\n   struct version_info *info;\n \n   if (TREE_CODE (*expr_p) != SSA_NAME)\n     return NULL_TREE;\n-  info = name_info (fd_ivopts_data, *expr_p);\n \n+  info = name_info (wdata->idata, *expr_p);\n   if (!info->inv_id || info->has_nonlin_use)\n     return NULL_TREE;\n \n-  if (!*inv_vars)\n-    *inv_vars = BITMAP_ALLOC (NULL);\n-  bitmap_set_bit (*inv_vars, info->inv_id);\n+  if (!*wdata->inv_vars)\n+    *wdata->inv_vars = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (*wdata->inv_vars, info->inv_id);\n \n   return NULL_TREE;\n }\n \n+/* Records invariants in *EXPR_P.  INV_VARS is the bitmap to that we should\n+   store it.  */\n+\n+static inline void\n+find_inv_vars (struct ivopts_data *data, tree *expr_p, bitmap *inv_vars)\n+{\n+  struct walk_tree_data wdata;\n+\n+  if (!inv_vars)\n+    return;\n+\n+  wdata.idata = data;\n+  wdata.inv_vars = inv_vars;\n+  walk_tree (expr_p, find_inv_vars_cb, &wdata, NULL);\n+}\n+\n /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and\n    position to POS.  If USE is not NULL, the candidate is set as related to\n    it.  If both BASE and STEP are NULL, we add a pseudocandidate for the\n@@ -2996,10 +3019,7 @@ add_candidate_1 (struct ivopts_data *data,\n       data->vcands.safe_push (cand);\n \n       if (TREE_CODE (step) != INTEGER_CST)\n-\t{\n-\t  fd_ivopts_data = data;\n-\t  walk_tree (&step, find_depends, &cand->inv_vars, NULL);\n-\t}\n+\tfind_inv_vars (data, &step, &cand->inv_vars);\n \n       if (pos == IP_AFTER_USE || pos == IP_BEFORE_USE)\n \tcand->ainc_use = use;\n@@ -4486,15 +4506,12 @@ force_expr_to_var_cost (tree expr, bool speed)\n    invariants the computation depends on.  */\n \n static comp_cost\n-force_var_cost (struct ivopts_data *data,\n-\t\ttree expr, bitmap *inv_vars)\n+force_var_cost (struct ivopts_data *data, tree expr, bitmap *inv_vars)\n {\n-  if (inv_vars)\n-    {\n-      fd_ivopts_data = data;\n-      walk_tree (&expr, find_depends, inv_vars, NULL);\n-    }\n+  if (!expr)\n+    return no_cost;\n \n+  find_inv_vars (data, &expr, inv_vars);\n   return force_expr_to_var_cost (expr, data->speed);\n }\n \n@@ -4525,10 +4542,7 @@ split_address_cost (struct ivopts_data *data,\n     {\n       *symbol_present = false;\n       *var_present = true;\n-      fd_ivopts_data = data;\n-      if (inv_vars)\n-\twalk_tree (&addr, find_depends, inv_vars, NULL);\n-\n+      find_inv_vars (data, &addr, inv_vars);\n       return comp_cost (target_spill_cost[data->speed], 0);\n     }\n \n@@ -5624,8 +5638,8 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n   express_cost = get_computation_cost (data, use, cand, false,\n \t\t\t\t       &inv_vars_express, NULL,\n \t\t\t\t       &inv_expr_express);\n-  fd_ivopts_data = data;\n-  walk_tree (&cmp_iv->base, find_depends, &inv_vars_express, NULL);\n+  if (cmp_iv != NULL)\n+    find_inv_vars (data, &cmp_iv->base, &inv_vars_express);\n \n   /* Count the cost of the original bound as well.  */\n   bound_cost = force_var_cost (data, *bound_cst, NULL);"}]}