{"sha": "0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjYjRhN2M1ZTBmYTVmY2VmM2FiNWJiZDBhNDdmZTlhMjBiMDAyZA==", "commit": {"author": {"name": "Ralf Wildenhues", "email": "Ralf.Wildenhues@gmx.de", "date": "2011-01-10T18:59:56Z"}, "committer": {"name": "Ralf Wildenhues", "email": "rwild@gcc.gnu.org", "date": "2011-01-10T18:59:56Z"}, "message": "doc: avoid extra indentation in gimple.texi\n\ngcc/:\n\t* doc/gimple.texi (Temporaries, Operands, Compound Lvalues)\n\t(Conditional Expressions, Logical Operators)\n\t(Statement and operand traversals): Do not indent smallexample\n\tcode.  Fix duplicate function argument in example.\n\nFrom-SVN: r168636", "tree": {"sha": "ff30189a2b9693e27b318eef2c7405d4db5e089e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff30189a2b9693e27b318eef2c7405d4db5e089e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d/comments", "author": null, "committer": null, "parents": [{"sha": "3c2e63dea12ef60142780dd9d9c8fc20cd07200f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2e63dea12ef60142780dd9d9c8fc20cd07200f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2e63dea12ef60142780dd9d9c8fc20cd07200f"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "346a4c70fdb312232d8a3e67953e2a9e8811413d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "patch": "@@ -1,3 +1,10 @@\n+2011-01-10  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n+\n+\t* doc/gimple.texi (Temporaries, Operands, Compound Lvalues)\n+\t(Conditional Expressions, Logical Operators)\n+\t(Statement and operand traversals): Do not indent smallexample\n+\tcode.  Fix duplicate function argument in example.\n+\n 2011-01-10  Jeff Law  <law@redhat.com>\n \n \t* PR tree-optimization/47141"}, {"sha": "d20358ab1e6a7ffdb828552d1c554416289d6716", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=0ecb4a7c5e0fa5fcef3ab5bbd0a47fe9a20b002d", "patch": "@@ -424,8 +424,8 @@ using @code{get_initialized_tmp_var} or @code{create_tmp_var}.\n Currently, an expression like @code{a = b + 5} is not reduced any\n further.  We tried converting it to something like\n @smallexample\n-  T1 = b + 5;\n-  a = T1;\n+T1 = b + 5;\n+a = T1;\n @end smallexample\n but this bloated the representation for minimal benefit.  However, a\n variable which must live in memory cannot appear in an expression; its\n@@ -443,12 +443,12 @@ GIMPLE rvalue (@code{is_gimple_val}), i.e.@: a constant or a register\n variable.  More complex operands are factored out into temporaries, so\n that\n @smallexample\n-  a = b + c + d\n+a = b + c + d\n @end smallexample\n becomes\n @smallexample\n-  T1 = b + c;\n-  a = T1 + d;\n+T1 = b + c;\n+a = T1 + d;\n @end smallexample\n \n The same rule holds for arguments to a @code{GIMPLE_CALL}.\n@@ -481,8 +481,8 @@ workaround for limitations in later optimizers; if we were to convert this\n to\n \n @smallexample\n-  T1 = &a.b;\n-  T1[2] = 42;\n+T1 = &a.b;\n+T1[2] = 42;\n @end smallexample\n \n alias analysis would not remember that the reference to @code{T1[2]} came\n@@ -498,15 +498,15 @@ A C @code{?:} expression is converted into an @code{if} statement with\n each branch assigning to the same temporary.  So,\n \n @smallexample\n-  a = b ? c : d;\n+a = b ? c : d;\n @end smallexample\n becomes\n @smallexample\n-  if (b == 1)\n-    T1 = c;\n-  else\n-    T1 = d;\n-  a = T1;\n+if (b == 1)\n+  T1 = c;\n+else\n+  T1 = d;\n+a = T1;\n @end smallexample\n \n The GIMPLE level if-conversion pass re-introduces @code{?:}\n@@ -525,10 +525,10 @@ Except when they appear in the condition operand of a\n as follows: @code{a = b && c} becomes\n \n @smallexample\n-  T1 = (bool)b;\n-  if (T1 == true)\n-    T1 = (bool)c;\n-  a = T1;\n+T1 = (bool)b;\n+if (T1 == true)\n+  T1 = (bool)c;\n+a = T1;\n @end smallexample\n \n Note that @code{T1} in this example cannot be an expression temporary,\n@@ -2545,7 +2545,7 @@ Additional parameters to @code{walk_tree} must be stored in @code{WI}.  For\n each operand @code{OP}, @code{walk_tree} is called as:\n \n @smallexample\n-    walk_tree (&@code{OP}, @code{CALLBACK_OP}, @code{WI}, @code{WI}- @code{PSET})\n+walk_tree (&@code{OP}, @code{CALLBACK_OP}, @code{WI}, @code{PSET})\n @end smallexample\n \n If @code{CALLBACK_OP} returns non-@code{NULL} for an operand, the remaining"}]}