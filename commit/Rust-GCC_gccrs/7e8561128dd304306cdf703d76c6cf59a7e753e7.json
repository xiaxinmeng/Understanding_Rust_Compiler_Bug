{"sha": "7e8561128dd304306cdf703d76c6cf59a7e753e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4NTYxMTI4ZGQzMDQzMDZjZGY3MDNkNzZjNmNmNTlhN2U3NTNlNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:33:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:33:47Z"}, "message": "[multiple changes]\n\n2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Preserve loop\n\tidentifier only if it comes from source.\n\t(Expand_N_Loop_Statement): If the domain of iteration is an\n\tenumeration type with a representation clause, remove from\n\tvisibility the loop identifier before rewriting the loop as a\n\tblock with a declaration for said identifier.\n\t* sem_util.adb (Remove_Homonym): Handle properly the default case.\n\n2013-01-29  Vincent Celier  <celier@adacore.com>\n\n\t* prj-proc.adb: Minor comment spelling fix.\n\nFrom-SVN: r195546", "tree": {"sha": "decd418f191225b68d8e6f42529425183bc85eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/decd418f191225b68d8e6f42529425183bc85eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e8561128dd304306cdf703d76c6cf59a7e753e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8561128dd304306cdf703d76c6cf59a7e753e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8561128dd304306cdf703d76c6cf59a7e753e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8561128dd304306cdf703d76c6cf59a7e753e7/comments", "author": null, "committer": null, "parents": [{"sha": "4e3da85af1403ed3599404bd154c1afc0d3e4b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3da85af1403ed3599404bd154c1afc0d3e4b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3da85af1403ed3599404bd154c1afc0d3e4b13"}], "stats": {"total": 74, "additions": 55, "deletions": 19}, "files": [{"sha": "73ddbfb571134fb4e1ca1823abaa0873dec16cfd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7e8561128dd304306cdf703d76c6cf59a7e753e7", "patch": "@@ -1,3 +1,17 @@\n+2013-01-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Preserve loop\n+\tidentifier only if it comes from source.\n+\t(Expand_N_Loop_Statement): If the domain of iteration is an\n+\tenumeration type with a representation clause, remove from\n+\tvisibility the loop identifier before rewriting the loop as a\n+\tblock with a declaration for said identifier.\n+\t* sem_util.adb (Remove_Homonym): Handle properly the default case.\n+\n+2013-01-29  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-proc.adb: Minor comment spelling fix.\n+\n 2013-01-29  Pascal Obry  <obry@adacore.com>\n \n \t* prj-proc.adb (Process_Expression_Variable_Decl): Prepend"}, {"sha": "2bdb82797ab6318b258b0831738318731a71860a", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=7e8561128dd304306cdf703d76c6cf59a7e753e7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3743,10 +3743,14 @@ package body Exp_Ch5 is\n          end loop;\n       end if;\n \n-      --  If original loop has a name, preserve it so it can be recognized by\n-      --  an exit statement in the body of the rewritten loop.\n+      --  If original loop has a source name, preserve it so it can be\n+      --  recognized by an exit statement in the body of the rewritten loop.\n+      --  This only concerns source names: the generated name of an anonymous\n+      --  loop will be create again during the subsequent analysis below.\n \n-      if Present (Identifier (N)) then\n+      if Present (Identifier (N))\n+        and then Comes_From_Source (Identifier (N))\n+      then\n          Set_Identifier (Core_Loop, Relocate_Node (Identifier (N)));\n       end if;\n \n@@ -3810,6 +3814,7 @@ package body Exp_Ch5 is\n             Ltype   : constant Entity_Id := Etype (Loop_Id);\n             Btype   : constant Entity_Id := Base_Type (Ltype);\n             Expr    : Node_Id;\n+            Decls   : List_Id;\n             New_Id  : Entity_Id;\n \n          begin\n@@ -3869,6 +3874,16 @@ package body Exp_Ch5 is\n                         New_List (New_Reference_To (New_Id, Loc)));\n                end if;\n \n+               --  Build declaration for loop identifier\n+\n+               Decls :=\n+                 New_List (\n+                   Make_Object_Declaration (Loc,\n+                     Defining_Identifier => Loop_Id,\n+                     Constant_Present    => True,\n+                     Object_Definition   => New_Reference_To (Ltype, Loc),\n+                     Expression          => Expr));\n+\n                Rewrite (N,\n                  Make_Loop_Statement (Loc,\n                    Identifier => Identifier (N),\n@@ -3916,28 +3931,30 @@ package body Exp_Ch5 is\n \n                    Statements => New_List (\n                      Make_Block_Statement (Loc,\n-                       Declarations => New_List (\n-                         Make_Object_Declaration (Loc,\n-                           Defining_Identifier => Loop_Id,\n-                           Constant_Present    => True,\n-                           Object_Definition   =>\n-                             New_Reference_To (Ltype, Loc),\n-                           Expression          => Expr)),\n-\n+                       Declarations => Decls,\n                        Handled_Statement_Sequence =>\n                          Make_Handled_Sequence_Of_Statements (Loc,\n                            Statements => Statements (N)))),\n \n                    End_Label => End_Label (N)));\n \n                --  The loop parameter's entity must be removed from the loop\n-               --  scope's entity list, since it will now be located in the\n-               --  new block scope. Any other entities already associated with\n-               --  the loop scope, such as the loop parameter's subtype, will\n-               --  remain there.\n+               --  scope's entity list and rendered invisible, since it will\n+               --  now be located in the new block scope. Any other entities\n+               --  already associated with the loop scope, such as the loop\n+               --  parameter's subtype, will remain there.\n+\n+               --  In an element loop, the loop will contain a declaration for\n+               --  a cursor variable; otherwise the loop id is the first entity\n+               --  in the scope constructed for the loop.\n+\n+               if Comes_From_Source (Loop_Id) then\n+                  pragma Assert (First_Entity (Scope (Loop_Id)) = Loop_Id);\n+                  null;\n+               end if;\n \n-               pragma Assert (First_Entity (Scope (Loop_Id)) = Loop_Id);\n                Set_First_Entity (Scope (Loop_Id), Next_Entity (Loop_Id));\n+               Remove_Homonym (Loop_Id);\n \n                if Last_Entity (Scope (Loop_Id)) = Loop_Id then\n                   Set_Last_Entity (Scope (Loop_Id), Empty);"}, {"sha": "39ebe70b4ad988595379d73e502e38de295f15bd", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=7e8561128dd304306cdf703d76c6cf59a7e753e7", "patch": "@@ -2076,7 +2076,7 @@ package body Prj.Proc is\n                      Val := Shared.String_Elements.Table (Val).Next;\n                   end loop;\n \n-                  --  Prepend them in the oder found in the attribute\n+                  --  Prepend them in the order found in the attribute\n \n                   for K in Positive range 1 .. Positive (List.Length) loop\n                      Prj.Env.Add_Directories"}, {"sha": "336ce67c49a7840de9f032c552dc568d50af35a0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e8561128dd304306cdf703d76c6cf59a7e753e7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7e8561128dd304306cdf703d76c6cf59a7e753e7", "patch": "@@ -12638,14 +12638,19 @@ package body Sem_Util is\n          else\n             Set_Name_Entity_Id (Chars (E), Empty);\n          end if;\n+\n       else\n          H := Current_Entity (E);\n          while Present (H) and then H /= E loop\n             Prev := H;\n             H    := Homonym (H);\n          end loop;\n \n-         Set_Homonym (Prev, Homonym (E));\n+         --  If E is not on the homonym chain, nothing to do\n+\n+         if Present (H) then\n+            Set_Homonym (Prev, Homonym (E));\n+         end if;\n       end if;\n    end Remove_Homonym;\n "}]}