{"sha": "ed789fe9b07451de3170648409c7242083e21449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ3ODlmZTliMDc0NTFkZTMxNzA2NDg0MDljNzI0MjA4M2UyMTQ0OQ==", "commit": {"author": {"name": "Cyrille Comar", "email": "comar@adacore.com", "date": "2005-11-15T13:57:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:57:37Z"}, "message": "exp_ch5.adb (Expand_N_Assignment_Statement, [...]): For an assignment of a value of a tagged type that has been rewritten to a...\n\n2005-11-14  Cyrille Comar  <comar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement, Tagged_Case): For an\n\tassignment of a value of a tagged type that has been rewritten to a\n\tblock statement, it is known by construction that no checks are\n\tnecessary for the statements within the block: analyze it with checks\n\tsuppressed.\n\t(Expand_N_If_Statement): When killing a dead then-branch in an\n\tif-statement that has elsif_parts, recompute the Current_Value node\n\tfor any entity whose value is known from the condition of the first\n\telsif_part.\n\t(Expand_N_Return_Statement): When returning a mutable record, convert\n\tthe return value into its actual subtype in order to help the backend\n\tto return the actual size instead of the maximum. This is another\n\taftermath of not returning mutable records on the sec-stack anymore.\n\n\t* sem_ch5.ads, sem_ch5.adb (Analyze_Iteration_Scheme): Minor change to\n\thandling of error msg for suspicious reverse range iteration.\n\t(Check_Possible_Current_Value_Condition): Move declaration from body to\n\tspec, to allow this subprogram to be called from exp_ch5.\n\nFrom-SVN: r106972", "tree": {"sha": "62a5e233d912a22ae19f2e94781992b0c7814089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62a5e233d912a22ae19f2e94781992b0c7814089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed789fe9b07451de3170648409c7242083e21449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed789fe9b07451de3170648409c7242083e21449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed789fe9b07451de3170648409c7242083e21449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed789fe9b07451de3170648409c7242083e21449/comments", "author": {"login": "CyrilleComar", "id": 18616717, "node_id": "MDQ6VXNlcjE4NjE2NzE3", "avatar_url": "https://avatars.githubusercontent.com/u/18616717?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CyrilleComar", "html_url": "https://github.com/CyrilleComar", "followers_url": "https://api.github.com/users/CyrilleComar/followers", "following_url": "https://api.github.com/users/CyrilleComar/following{/other_user}", "gists_url": "https://api.github.com/users/CyrilleComar/gists{/gist_id}", "starred_url": "https://api.github.com/users/CyrilleComar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CyrilleComar/subscriptions", "organizations_url": "https://api.github.com/users/CyrilleComar/orgs", "repos_url": "https://api.github.com/users/CyrilleComar/repos", "events_url": "https://api.github.com/users/CyrilleComar/events{/privacy}", "received_events_url": "https://api.github.com/users/CyrilleComar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dcc05e6bcbe1976ddfa17c82eb5b5e0f8654752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dcc05e6bcbe1976ddfa17c82eb5b5e0f8654752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dcc05e6bcbe1976ddfa17c82eb5b5e0f8654752"}], "stats": {"total": 287, "additions": 164, "deletions": 123}, "files": [{"sha": "af7cd2426f7cbb8d7a779289a93cd0154e0d83ba", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 150, "deletions": 111, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=ed789fe9b07451de3170648409c7242083e21449", "patch": "@@ -45,6 +45,7 @@ with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n@@ -1808,7 +1809,11 @@ package body Exp_Ch5 is\n                end;\n             end if;\n \n-            Analyze (N);\n+            --  N has been rewritten to a block statement for which it is\n+            --  known by construction that no checks are necessary: analyze\n+            --  it with all checks suppressed.\n+\n+            Analyze (N, Suppress => All_Checks);\n             return;\n          end Tagged_Case;\n \n@@ -2259,6 +2264,13 @@ package body Exp_Ch5 is\n                Set_Condition       (N, Condition (Hed));\n                Set_Then_Statements (N, Then_Statements (Hed));\n \n+               --  Hed might have been captured as the condition determining\n+               --  the current value for an entity. Now it is detached from\n+               --  the tree, so a Current_Value pointer in the condition might\n+               --  need to be updated.\n+\n+               Check_Possible_Current_Value_Condition (N);\n+\n                if Is_Empty_List (Elsif_Parts (N)) then\n                   Set_Elsif_Parts (N, No_List);\n                end if;\n@@ -2762,123 +2774,38 @@ package body Exp_Ch5 is\n          Analyze (Exp);\n       end if;\n \n-      --  Implement the rules of 6.5(8-10), which require a tag check in\n-      --  the case of a limited tagged return type, and tag reassignment\n-      --  for nonlimited tagged results. These actions are needed when\n-      --  the return type is a specific tagged type and the result\n-      --  expression is a conversion or a formal parameter, because in\n-      --  that case the tag of the expression might differ from the tag\n-      --  of the specific result type.\n-\n-      if Is_Tagged_Type (Utyp)\n-        and then not Is_Class_Wide_Type (Utyp)\n-        and then (Nkind (Exp) = N_Type_Conversion\n-                    or else Nkind (Exp) = N_Unchecked_Type_Conversion\n-                    or else (Is_Entity_Name (Exp)\n-                               and then Ekind (Entity (Exp)) in Formal_Kind))\n-      then\n-         --  When the return type is limited, perform a check that the\n-         --  tag of the result is the same as the tag of the return type.\n-\n-         if Is_Limited_Type (Return_Type) then\n-            Insert_Action (Exp,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd =>\n-                      Make_Selected_Component (Loc,\n-                        Prefix => Duplicate_Subexpr (Exp),\n-                        Selector_Name =>\n-                          New_Reference_To (First_Tag_Component (Utyp), Loc)),\n-                    Right_Opnd =>\n-                      Unchecked_Convert_To (RTE (RE_Tag),\n-                        New_Reference_To\n-                          (Node (First_Elmt\n-                                  (Access_Disp_Table (Base_Type (Utyp)))),\n-                           Loc))),\n-                Reason => CE_Tag_Check_Failed));\n-\n-         --  If the result type is a specific nonlimited tagged type,\n-         --  then we have to ensure that the tag of the result is that\n-         --  of the result type. This is handled by making a copy of the\n-         --  expression in the case where it might have a different tag,\n-         --  namely when the expression is a conversion or a formal\n-         --  parameter. We create a new object of the result type and\n-         --  initialize it from the expression, which will implicitly\n-         --  force the tag to be set appropriately.\n-\n-         else\n-            Result_Id :=\n-              Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-            Result_Exp := New_Reference_To (Result_Id, Loc);\n-\n-            Result_Obj :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Result_Id,\n-                Object_Definition   => New_Reference_To (Return_Type, Loc),\n-                Constant_Present    => True,\n-                Expression          => Relocate_Node (Exp));\n-\n-            Set_Assignment_OK (Result_Obj);\n-            Insert_Action (Exp, Result_Obj);\n-\n-            Rewrite (Exp, Result_Exp);\n-            Analyze_And_Resolve (Exp, Return_Type);\n-         end if;\n-\n-      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n-      --  a check that the level of the return expression's underlying type\n-      --  is not deeper than the level of the master enclosing the function.\n-      --  Always generate the check when the type of the return expression\n-      --  is class-wide, when it's a type conversion, or when it's a formal\n-      --  parameter. Otherwise, suppress the check in the case where the\n-      --  return expression has a specific type whose level is known not to\n-      --  be statically deeper than the function's result type.\n-\n-      elsif Ada_Version >= Ada_05\n-        and then Is_Class_Wide_Type (Return_Type)\n-        and then not Scope_Suppress (Accessibility_Check)\n-        and then\n-          (Is_Class_Wide_Type (Etype (Exp))\n-            or else Nkind (Exp) = N_Type_Conversion\n-            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n-            or else (Is_Entity_Name (Exp)\n-                       and then Ekind (Entity (Exp)) in Formal_Kind)\n-            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n-                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n-      then\n-         Insert_Action (Exp,\n-           Make_Raise_Program_Error (Loc,\n-             Condition =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd =>\n-                   Make_Function_Call (Loc,\n-                     Name =>\n-                       New_Reference_To\n-                         (RTE (RE_Get_Access_Level), Loc),\n-                     Parameter_Associations =>\n-                       New_List (Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                      Duplicate_Subexpr (Exp),\n-                                   Attribute_Name =>\n-                                      Name_Tag))),\n-                 Right_Opnd =>\n-                   Make_Integer_Literal (Loc,\n-                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n-             Reason => PE_Accessibility_Check_Failed));\n-      end if;\n-\n       --  Deal with returning variable length objects and controlled types\n \n       --  Nothing to do if we are returning by reference, or this is not\n       --  a type that requires special processing (indicated by the fact\n       --  that it requires a cleanup scope for the secondary stack case)\n \n-      if Is_Return_By_Reference_Type (T)\n-        or else not Requires_Transient_Scope (Return_Type)\n-      then\n+      if Is_Return_By_Reference_Type (T) then\n          null;\n \n+      elsif not Requires_Transient_Scope (Return_Type) then\n+\n+         --  mutable records with no variable length components are not\n+         --  returned on the sec-stack so we need to make sure that the\n+         --  backend will only copy back the size of the actual value  and not\n+         --  the maximum size. We create an actual subtype for this purpose\n+\n+         declare\n+            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (T));\n+            Decl : Node_Id;\n+            Ent  : Entity_Id;\n+         begin\n+            if Has_Discriminants (Ubt)\n+              and then not Is_Constrained (Ubt)\n+              and then not Has_Unchecked_Union (Ubt)\n+            then\n+               Decl := Build_Actual_Subtype (Ubt, Exp);\n+               Ent := Defining_Identifier (Decl);\n+               Insert_Action (Exp, Decl);\n+               Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n+            end if;\n+         end;\n+\n       --  Case of secondary stack not used\n \n       elsif Function_Returns_With_DSP (Scope_Id) then\n@@ -3063,6 +2990,12 @@ package body Exp_Ch5 is\n          then\n             Set_By_Ref (N);\n \n+            --  Remove side effects from the expression now so that\n+            --  other part of the expander do not have to reanalyze\n+            --  this node without this optimization\n+\n+            Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n+\n          --  For controlled types, do the allocation on the sec-stack\n          --  manually in order to call adjust at the right time\n          --    type Anon1 is access Return_Type;\n@@ -3128,6 +3061,112 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n+      --  Implement the rules of 6.5(8-10), which require a tag check in\n+      --  the case of a limited tagged return type, and tag reassignment\n+      --  for nonlimited tagged results. These actions are needed when\n+      --  the return type is a specific tagged type and the result\n+      --  expression is a conversion or a formal parameter, because in\n+      --  that case the tag of the expression might differ from the tag\n+      --  of the specific result type.\n+\n+      if Is_Tagged_Type (Utyp)\n+        and then not Is_Class_Wide_Type (Utyp)\n+        and then (Nkind (Exp) = N_Type_Conversion\n+                    or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+                    or else (Is_Entity_Name (Exp)\n+                               and then Ekind (Entity (Exp)) in Formal_Kind))\n+      then\n+         --  When the return type is limited, perform a check that the\n+         --  tag of the result is the same as the tag of the return type.\n+\n+         if Is_Limited_Type (Return_Type) then\n+            Insert_Action (Exp,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => Duplicate_Subexpr (Exp),\n+                        Selector_Name =>\n+                          New_Reference_To (First_Tag_Component (Utyp), Loc)),\n+                    Right_Opnd =>\n+                      Unchecked_Convert_To (RTE (RE_Tag),\n+                        New_Reference_To\n+                          (Node (First_Elmt\n+                                  (Access_Disp_Table (Base_Type (Utyp)))),\n+                           Loc))),\n+                Reason => CE_Tag_Check_Failed));\n+\n+         --  If the result type is a specific nonlimited tagged type,\n+         --  then we have to ensure that the tag of the result is that\n+         --  of the result type. This is handled by making a copy of the\n+         --  expression in the case where it might have a different tag,\n+         --  namely when the expression is a conversion or a formal\n+         --  parameter. We create a new object of the result type and\n+         --  initialize it from the expression, which will implicitly\n+         --  force the tag to be set appropriately.\n+\n+         else\n+            Result_Id :=\n+              Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+            Result_Exp := New_Reference_To (Result_Id, Loc);\n+\n+            Result_Obj :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Result_Id,\n+                Object_Definition   => New_Reference_To (Return_Type, Loc),\n+                Constant_Present    => True,\n+                Expression          => Relocate_Node (Exp));\n+\n+            Set_Assignment_OK (Result_Obj);\n+            Insert_Action (Exp, Result_Obj);\n+\n+            Rewrite (Exp, Result_Exp);\n+            Analyze_And_Resolve (Exp, Return_Type);\n+         end if;\n+\n+      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n+      --  a check that the level of the return expression's underlying type\n+      --  is not deeper than the level of the master enclosing the function.\n+      --  Always generate the check when the type of the return expression\n+      --  is class-wide, when it's a type conversion, or when it's a formal\n+      --  parameter. Otherwise, suppress the check in the case where the\n+      --  return expression has a specific type whose level is known not to\n+      --  be statically deeper than the function's result type.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Class_Wide_Type (Return_Type)\n+        and then not Scope_Suppress (Accessibility_Check)\n+        and then\n+          (Is_Class_Wide_Type (Etype (Exp))\n+            or else Nkind (Exp) = N_Type_Conversion\n+            or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+            or else (Is_Entity_Name (Exp)\n+                       and then Ekind (Entity (Exp)) in Formal_Kind)\n+            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n+                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n+      then\n+         Insert_Action (Exp,\n+           Make_Raise_Program_Error (Loc,\n+             Condition =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd =>\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Reference_To\n+                         (RTE (RE_Get_Access_Level), Loc),\n+                     Parameter_Associations =>\n+                       New_List (Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                      Duplicate_Subexpr (Exp),\n+                                   Attribute_Name =>\n+                                      Name_Tag))),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc,\n+                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n+             Reason => PE_Accessibility_Check_Failed));\n+      end if;\n+\n    exception\n       when RE_Not_Available =>\n          return;\n@@ -3175,7 +3214,7 @@ package body Exp_Ch5 is\n       if not Ctrl_Act then\n          null;\n \n-      --  The left hand side is an uninitialized  temporary\n+      --  The left hand side is an uninitialized temporary\n \n       elsif Nkind (L) = N_Type_Conversion\n         and then Is_Entity_Name (Expression (L))"}, {"sha": "896a8fb7a9ee7e4b5e872bc1d2c51c6127af4feb", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ed789fe9b07451de3170648409c7242083e21449", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,15 +71,6 @@ package body Sem_Ch5 is\n \n    procedure Analyze_Iteration_Scheme (N : Node_Id);\n \n-   procedure Check_Possible_Current_Value_Condition (Cnode : Node_Id);\n-   --  Cnode is N_If_Statement, N_Elsif_Part, or N_Iteration_Scheme\n-   --  (the latter when a WHILE condition is present). This call checks\n-   --  if Condition (Cnode) is of the form ([NOT] var op val), where var\n-   --  is a simple object, val is known at compile time, and op is one\n-   --  of the six relational operators. If this is the case, and the\n-   --  Current_Value field of \"var\" is not set, then it is set to Cnode.\n-   --  See Exp_Util.Set_Current_Value_Condition for further details.\n-\n    ------------------------\n    -- Analyze_Assignment --\n    ------------------------\n@@ -1526,13 +1517,15 @@ package body Sem_Ch5 is\n                         --  of reversing the bounds incorrectly in the range.\n \n                         elsif Reverse_Present (LP)\n-                          and then Nkind (H) = N_Integer_Literal\n+                          and then Nkind (Original_Node (H)) =\n+                                                          N_Integer_Literal\n                           and then (Intval (H) = Uint_0\n                                       or else\n                                     Intval (H) = Uint_1)\n                           and then Lhi > Hhi\n                         then\n                            Error_Msg_N (\"?loop range may be null\", DS);\n+                           Error_Msg_N (\"\\?bounds may be wrong way round\", DS);\n                         end if;\n                      end;\n                   end if;"}, {"sha": "0ea538eb11886730ba937dd17613b245d94d33a8", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed789fe9b07451de3170648409c7242083e21449/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=ed789fe9b07451de3170648409c7242083e21449", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,15 @@ package Sem_Ch5 is\n    --  care of setting Reachable, since labels defined by the expander can\n    --  be assumed to be reachable.\n \n+   procedure Check_Possible_Current_Value_Condition (Cnode : Node_Id);\n+   --  Cnode is N_If_Statement, N_Elsif_Part, or N_Iteration_Scheme\n+   --  (the latter when a WHILE condition is present). This call checks\n+   --  if Condition (Cnode) is of the form ([NOT] var op val), where var\n+   --  is a simple object, val is known at compile time, and op is one\n+   --  of the six relational operators. If this is the case, and the\n+   --  Current_Value field of \"var\" is not set, then it is set to Cnode.\n+   --  See Exp_Util.Set_Current_Value_Condition for further details.\n+\n    procedure Check_Unreachable_Code (N : Node_Id);\n    --  This procedure is called with N being the node for a statement that\n    --  is an unconditional transfer of control. It checks to see if the"}]}