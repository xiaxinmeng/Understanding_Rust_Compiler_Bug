{"sha": "f002c046e37d0027513af5297d9259e1fad29c27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwMmMwNDZlMzdkMDAyNzUxM2FmNTI5N2Q5MjU5ZTFmYWQyOWMyNw==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2020-06-21T03:00:15Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2020-06-21T05:26:12Z"}, "message": "rs6000: Add base support and types for defining MMA built-ins.\n\nAdd the new -mmma option as well as the initial MMA support, which includes\nthe target specific __vector_pair and __vector_quad types, the POImode and\nPXImode partial integer modes they are mapped to, and their associated\nmove patterns.  Support for the restrictions on the registers these modes\ncan be assigned to as also been added.\n\n2020-06-20  Peter Bergner  <bergner@linux.ibm.com>\n\t    Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/mma.md: New file.\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Define\n\t__MMA__ for mma.\n\t* config/rs6000/rs6000-call.c (rs6000_init_builtins): Add support\n\tfor __vector_pair and __vector_quad types.\n\t* config/rs6000/rs6000-cpus.def (OTHER_FUTURE_MASKS): Add\n\tOPTION_MASK_MMA.\n\t(POWERPC_MASKS): Likewise.\n\t* config/rs6000/rs6000-modes.def (OI, XI): New integer modes.\n\t(POI, PXI): New partial integer modes.\n\t* config/rs6000/rs6000.c (TARGET_INVALID_CONVERSION): Define.\n\t(rs6000_hard_regno_nregs_internal): Use VECTOR_ALIGNMENT_P.\n\t(rs6000_hard_regno_mode_ok_uncached): Likewise.\n\tAdd support for POImode being allowed in VSX registers and PXImode\n\tbeing allowed in FP registers.\n\t(rs6000_modes_tieable_p): Adjust comment.\n\tAdd support for POImode and PXImode.\n\t(rs6000_debug_reg_global) <print_tieable_modes>: Add OImode, POImode\n\tXImode, PXImode, V2SImode, V2SFmode and CCFPmode..\n\t(rs6000_setup_reg_addr_masks): Use VECTOR_ALIGNMENT_P.\n\tSet up appropriate addr_masks for vector pair and vector quad addresses.\n\t(rs6000_init_hard_regno_mode_ok): Add support for vector pair and\n\tvector quad registers.  Setup reload handlers for POImode and PXImode.\n\t(rs6000_builtin_mask_calculate): Add support for RS6000_BTM_MMA.\n\t(rs6000_option_override_internal): Error if -mmma is specified\n\twithout -mcpu=future.\n\t(rs6000_slow_unaligned_access): Use VECTOR_ALIGNMENT_P.\n\t(quad_address_p): Change size test to less than 16 bytes.\n\t(reg_offset_addressing_ok_p): Add support for ISA 3.1 vector pair\n\tand vector quad instructions.\n\t(avoiding_indexed_address_p): Likewise.\n\t(rs6000_emit_move): Disallow POImode and PXImode moves involving\n\tconstants.\n\t(rs6000_preferred_reload_class): Prefer VSX registers for POImode\n\tand FP registers for PXImode.\n\t(rs6000_split_multireg_move): Support splitting POImode and PXImode\n\tmove instructions.\n\t(rs6000_mangle_type): Adjust comment.  Add support for mangling\n\t__vector_pair and __vector_quad types.\n\t(rs6000_opt_masks): Add entry for mma.\n\t(rs6000_builtin_mask_names): Add RS6000_BTM_MMA and RS6000_BTM_FUTURE.\n\t(rs6000_function_value): Use VECTOR_ALIGNMENT_P.\n\t(address_to_insn_form): Likewise.\n\t(reg_to_non_prefixed): Likewise.\n\t(rs6000_invalid_conversion): New function.\n\t* config/rs6000/rs6000.h (MASK_MMA): Define.\n\t(BIGGEST_ALIGNMENT): Set to 512 if MMA support is enabled.\n\t(VECTOR_ALIGNMENT_P): New helper macro.\n\t(ALTIVEC_VECTOR_MODE): Use VECTOR_ALIGNMENT_P.\n\t(RS6000_BTM_MMA): Define.\n\t(RS6000_BTM_COMMON): Add RS6000_BTM_MMA and RS6000_BTM_FUTURE.\n\t(rs6000_builtin_type_index): Add RS6000_BTI_vector_pair and\n\tRS6000_BTI_vector_quad.\n\t(vector_pair_type_node): New.\n\t(vector_quad_type_node): New.\n\t* config/rs6000/rs6000.md: Include mma.md.\n\t(define_mode_iterator RELOAD): Add POI and PXI.\n\t* config/rs6000/t-rs6000 (MD_INCLUDES): Add mma.md.\n\t* config/rs6000/rs6000.opt (-mmma): New.\n\t* doc/invoke.texi: Document -mmma.", "tree": {"sha": "6bdb751981b906104687aed220b2dbda30f28eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bdb751981b906104687aed220b2dbda30f28eec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f002c046e37d0027513af5297d9259e1fad29c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f002c046e37d0027513af5297d9259e1fad29c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f002c046e37d0027513af5297d9259e1fad29c27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f002c046e37d0027513af5297d9259e1fad29c27/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbac3886a2e05cf28425696a8a183950fefae9af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbac3886a2e05cf28425696a8a183950fefae9af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbac3886a2e05cf28425696a8a183950fefae9af"}], "stats": {"total": 440, "additions": 408, "deletions": 32}, "files": [{"sha": "6e4cfcaeebc3a43be609ddffa67daaf8f54a9063", "filename": "gcc/config/rs6000/mma.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Fmma.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Fmma.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmma.md?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -0,0 +1,108 @@\n+;; Matrix-Multiply Assist (MMA) patterns.\n+;; Copyright (C) 2020 Free Software Foundation, Inc.\n+;; Contributed by Peter Bergner <bergner@linux.ibm.com> and\n+;;\t\t  Michael Meissner <meissner@linux.ibm.com>\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; The MMA patterns use the multi-register PXImode and POImode partial\n+;; integer modes to implement the target specific __vector_quad and\n+;; __vector_pair types that the MMA built-in functions reference.\n+;; To use these modes, we must define XImode and OImode move patterns\n+;; so the independent parts of the compiler can use our large partial\n+;; integer modes.  However, if we enable the XImode and OImode move\n+;; patterns, then the compiler will attempt to use them and this can\n+;; cause byte swapping issues on litte-endian systems.  We don't need\n+;; the XImode and OImode move patterns for actual code generation,\n+;; therefore, we define the XImode and OImode move patterns, but we\n+;; disable their use with a \"false\" condition flag.\n+\n+;; Define a disabled OImode move pattern, so we can use POImode.\n+(define_expand \"movoi\"\n+  [(set (match_operand:OI 0 \"nonimmediate_operand\")\n+\t(match_operand:OI 1 \"input_operand\"))]\n+  \"0\"\n+{\n+  gcc_unreachable ();\n+})\n+\n+;; Vector pair support.  POImode can only live in VSRs.\n+(define_expand \"movpoi\"\n+  [(set (match_operand:POI 0 \"nonimmediate_operand\")\n+\t(match_operand:POI 1 \"input_operand\"))]\n+  \"TARGET_MMA\"\n+{\n+  rs6000_emit_move (operands[0], operands[1], POImode);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*movpoi\"\n+  [(set (match_operand:POI 0 \"nonimmediate_operand\" \"=wa,m,wa\")\n+\t(match_operand:POI 1 \"input_operand\" \"m,wa,wa\"))]\n+  \"TARGET_MMA\n+   && (gpc_reg_operand (operands[0], POImode)\n+       || gpc_reg_operand (operands[1], POImode))\"\n+  \"@\n+   lxvp%X1 %x0,%1\n+   stxvp%X0 %x1,%0\n+   #\"\n+  \"&& reload_completed\n+   && (!MEM_P (operands[0]) && !MEM_P (operands[1]))\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecload,vecstore,veclogical\")\n+   (set_attr \"length\" \"*,*,8\")])\n+\n+\f\n+;; Define a disabled XImode move pattern, so we can use PXImode.\n+(define_expand \"movxi\"\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\")\n+\t(match_operand:XI 1 \"input_operand\"))]\n+  \"0\"\n+{\n+  gcc_unreachable ();\n+})\n+\n+;; Vector quad support.  PXImode can only live in FPRs.\n+(define_expand \"movpxi\"\n+  [(set (match_operand:PXI 0 \"nonimmediate_operand\")\n+\t(match_operand:PXI 1 \"input_operand\"))]\n+  \"TARGET_MMA\"\n+{\n+  rs6000_emit_move (operands[0], operands[1], PXImode);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*movpxi\"\n+  [(set (match_operand:PXI 0 \"nonimmediate_operand\" \"=d,m,d\")\n+\t(match_operand:PXI 1 \"input_operand\" \"m,d,d\"))]\n+  \"TARGET_MMA\n+   && (gpc_reg_operand (operands[0], PXImode)\n+       || gpc_reg_operand (operands[1], PXImode))\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rs6000_split_multireg_move (operands[0], operands[1]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecload,vecstore,veclogical\")\n+   (set_attr \"length\" \"8,8,16\")\n+   (set_attr \"max_prefixed_insns\" \"2,2,*\")])"}, {"sha": "47514552449681685d58f08c0a6a61d804ad7159", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -593,6 +593,10 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n      PROCESSOR_CELL) (e.g. -mcpu=cell).  */\n   if ((bu_mask & RS6000_BTM_CELL) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__PPU__\");\n+\n+  /* Tell the user if we support the MMA instructions.  */\n+  if ((flags & OPTION_MASK_MMA) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__MMA__\");\n }\n \n void"}, {"sha": "088264bab90b0dcd97de847cf888454ed4ec3ddf", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -12208,6 +12208,24 @@ rs6000_init_builtins (void)\n   else\n     ieee128_float_type_node = ibm128_float_type_node = long_double_type_node;\n \n+  /* Vector paired and vector quad support.  */\n+  if (TARGET_MMA)\n+    {\n+      tree oi_uns_type = make_unsigned_type (256);\n+      vector_pair_type_node = build_distinct_type_copy (oi_uns_type);\n+      SET_TYPE_MODE (vector_pair_type_node, POImode);\n+      layout_type (vector_pair_type_node);\n+      lang_hooks.types.register_builtin_type (vector_pair_type_node,\n+\t\t\t\t\t      \"__vector_pair\");\n+\n+      tree xi_uns_type = make_unsigned_type (512);\n+      vector_quad_type_node = build_distinct_type_copy (xi_uns_type);\n+      SET_TYPE_MODE (vector_quad_type_node, PXImode);\n+      layout_type (vector_quad_type_node);\n+      lang_hooks.types.register_builtin_type (vector_quad_type_node,\n+\t\t\t\t\t      \"__vector_quad\");\n+    }\n+\n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n      tree type node.  */\n   builtin_mode_to_type[QImode][0] = integer_type_node;\n@@ -12239,6 +12257,8 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[V8HImode][1] = unsigned_V8HI_type_node;\n   builtin_mode_to_type[V16QImode][0] = V16QI_type_node;\n   builtin_mode_to_type[V16QImode][1] = unsigned_V16QI_type_node;\n+  builtin_mode_to_type[POImode][1] = vector_pair_type_node;\n+  builtin_mode_to_type[PXImode][1] = vector_quad_type_node;\n \n   tdecl = add_builtin_type (\"__bool char\", bool_char_type_node);\n   TYPE_NAME (bool_char_type_node) = tdecl;"}, {"sha": "667c7ecefb84fcea40eec80926d4896b245c8d93", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -76,7 +76,8 @@\n \t\t\t\t | OPTION_MASK_P9_VECTOR)\n \n /* Flags that need to be turned off if -mno-future.  */\n-#define OTHER_FUTURE_MASKS\t(OPTION_MASK_PCREL\t\t\t\\\n+#define OTHER_FUTURE_MASKS\t(OPTION_MASK_MMA\t\t\t\\\n+\t\t\t\t | OPTION_MASK_PCREL\t\t\t\\\n \t\t\t\t | OPTION_MASK_PREFIXED)\n \n /* Support for a future processor's features.  */\n@@ -132,6 +133,7 @@\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFCRF\t\t\t\\\n+\t\t\t\t | OPTION_MASK_MMA\t\t\t\\\n \t\t\t\t | OPTION_MASK_MODULO\t\t\t\\\n \t\t\t\t | OPTION_MASK_MULHW\t\t\t\\\n \t\t\t\t | OPTION_MASK_NO_UPDATE\t\t\\"}, {"sha": "ddb218b3fbaf0f900884f6b77573ea03d6125460", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -82,3 +82,13 @@ VECTOR_MODE (INT, SI, 2);     /*                 V2SI  */\n    for quad memory atomic operations to force getting an even/odd register\n    combination.  */\n PARTIAL_INT_MODE (TI, 128, PTI);\n+\n+/* Define, but don't use the larger integer modes.  We need an integer mode\n+   defined that is the same size as the vector pair and vector quad modes.  */\n+\n+INT_MODE (OI, 32);\n+INT_MODE (XI, 64);\n+\n+/* Modes used by __vector_pair and __vector_quad.  */\n+PARTIAL_INT_MODE (OI, 256, POI);\t/* __vector_pair.  */\n+PARTIAL_INT_MODE (XI, 512, PXI);\t/* __vector_quad.  */"}, {"sha": "8f06080821afe091b227fbd2ae981069d6a06d04", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 230, "deletions": 22, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -1745,6 +1745,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P\n #define TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P \\\n   rs6000_cannot_substitute_mem_equiv_p\n+\n+#undef TARGET_INVALID_CONVERSION\n+#define TARGET_INVALID_CONVERSION rs6000_invalid_conversion\n \f\n \n /* Processor table.  */\n@@ -1798,7 +1801,7 @@ rs6000_hard_regno_nregs_internal (int regno, machine_mode mode)\n      128-bit floating point that can go in vector registers, which has VSX\n      memory addressing.  */\n   if (FP_REGNO_P (regno))\n-    reg_size = (VECTOR_MEM_VSX_P (mode) || FLOAT128_VECTOR_P (mode)\n+    reg_size = (VECTOR_MEM_VSX_P (mode) || VECTOR_ALIGNMENT_P (mode)\n \t\t? UNITS_PER_VSX_WORD\n \t\t: UNITS_PER_FP_WORD);\n \n@@ -1821,6 +1824,18 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n   if (COMPLEX_MODE_P (mode))\n     mode = GET_MODE_INNER (mode);\n \n+  /* Vector pair modes need even/odd VSX register pairs.  Only allow vector\n+     registers.  We need to allow OImode to have the same registers as POImode,\n+     even though we do not enable the move pattern for OImode.  */\n+  if (mode == POImode || mode == OImode)\n+    return (TARGET_MMA && VSX_REGNO_P (regno) && (regno & 1) == 0);\n+\n+  /* MMA accumulator modes need FPR registers divisible by 4.  We need to allow\n+     XImode to have the same registers as PXImode, even though we do not enable\n+     the move pattern for XImode.  */\n+  if (mode == PXImode || mode == XImode)\n+    return (TARGET_MMA && FP_REGNO_P (regno) && (regno & 3) == 0);\n+\n   /* PTImode can only go in GPRs.  Quad word memory operations require even/odd\n      register combinations, and use PTImode where we need to deal with quad\n      word memory operations.  Don't allow quad words in the argument or frame\n@@ -1836,7 +1851,7 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n      asked for it.  */\n   if (TARGET_VSX && VSX_REGNO_P (regno)\n       && (VECTOR_MEM_VSX_P (mode)\n-\t  || FLOAT128_VECTOR_P (mode)\n+\t  || VECTOR_ALIGNMENT_P (mode)\n \t  || reg_addr[mode].scalar_in_vmx_p\n \t  || mode == TImode\n \t  || (TARGET_VADDUQM && mode == V1TImode)))\n@@ -1846,7 +1861,7 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n \n       if (ALTIVEC_REGNO_P (regno))\n \t{\n-\t  if (GET_MODE_SIZE (mode) != 16 && !reg_addr[mode].scalar_in_vmx_p)\n+\t  if (GET_MODE_SIZE (mode) < 16 && !reg_addr[mode].scalar_in_vmx_p)\n \t    return 0;\n \n \t  return ALTIVEC_REGNO_P (last_regno);\n@@ -1862,7 +1877,7 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n      modes and DImode.  */\n   if (FP_REGNO_P (regno))\n     {\n-      if (FLOAT128_VECTOR_P (mode))\n+      if (VECTOR_ALIGNMENT_P (mode))\n \treturn false;\n \n       if (SCALAR_FLOAT_MODE_P (mode)\n@@ -1925,16 +1940,19 @@ rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n    GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n    57744).\n \n+   Similarly, don't allow POImode (vector pair, restricted to even VSX\n+   registers) or PXImode (vector quad, restricted to FPR registers divisible\n+   by 4) to tie with other modes.\n+\n    Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n    128-bit floating point on VSX systems ties with other vectors.  */\n \n static bool\n rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n-  if (mode1 == PTImode)\n-    return mode2 == PTImode;\n-  if (mode2 == PTImode)\n-    return false;\n+  if (mode1 == PTImode || mode1 == POImode || mode1 == PXImode\n+      || mode2 == PTImode || mode2 == POImode || mode2 == PXImode)\n+    return mode1 == mode2;\n \n   if (ALTIVEC_OR_VSX_VECTOR_MODE (mode1))\n     return ALTIVEC_OR_VSX_VECTOR_MODE (mode2);\n@@ -2206,6 +2224,8 @@ rs6000_debug_reg_global (void)\n     SDmode,\n     DDmode,\n     TDmode,\n+    V2SImode,\n+    V2SFmode,\n     V16QImode,\n     V8HImode,\n     V4SImode,\n@@ -2220,9 +2240,14 @@ rs6000_debug_reg_global (void)\n     V2DFmode,\n     V8SFmode,\n     V4DFmode,\n+    OImode,\n+    XImode,\n+    POImode,\n+    PXImode,\n     CCmode,\n     CCUNSmode,\n     CCEQmode,\n+    CCFPmode,\n   };\n \n   /* Virtual regs we are interested in.  */\n@@ -2619,7 +2644,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR)\n \t\t  && msize <= 8\n \t\t  && !VECTOR_MODE_P (m2)\n-\t\t  && !FLOAT128_VECTOR_P (m2)\n+\t\t  && !VECTOR_ALIGNMENT_P (m2)\n \t\t  && !complex_p\n \t\t  && (m != E_DFmode || !TARGET_VSX)\n \t\t  && (m != E_SFmode || !TARGET_P8_VECTOR)\n@@ -2675,6 +2700,22 @@ rs6000_setup_reg_addr_masks (void)\n \t\taddr_mask |= RELOAD_REG_QUAD_OFFSET;\n \t    }\n \n+\t  /* Vector pairs can do both indexed and offset loads if the\n+\t     instructions are enabled, otherwise they can only do offset loads\n+\t     since it will be broken into two vector moves.  Vector quads can\n+\t     only do offset loads.  */\n+\t  else if ((addr_mask != 0) && TARGET_MMA\n+\t\t   && (m2 == POImode || m2 == PXImode))\n+\t    {\n+\t      addr_mask |= RELOAD_REG_OFFSET;\n+\t      if (rc == RELOAD_REG_FPR || rc == RELOAD_REG_VMX)\n+\t\t{\n+\t\t  addr_mask |= RELOAD_REG_QUAD_OFFSET;\n+\t\t  if (m2 == POImode)\n+\t\t    addr_mask |= RELOAD_REG_INDEXED;\n+\t\t}\n+\t    }\n+\n \t  /* VMX registers can do (REG & -16) and ((REG+REG) & -16)\n \t     addressing on 128-bit types.  */\n \t  if (rc == RELOAD_REG_VMX && msize == 16\n@@ -2876,6 +2917,18 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_vector_align[TImode] = align64;\n     }\n \n+  /* Add support for vector pairs and vector quad registers.  */\n+  if (TARGET_MMA)\n+    {\n+      rs6000_vector_unit[POImode] = VECTOR_NONE;\n+      rs6000_vector_mem[POImode] = VECTOR_VSX;\n+      rs6000_vector_align[POImode] = 256;\n+\n+      rs6000_vector_unit[PXImode] = VECTOR_NONE;\n+      rs6000_vector_mem[PXImode] = VECTOR_VSX;\n+      rs6000_vector_align[PXImode] = 512;\n+    }\n+\n   /* Register class constraints for the constraints that depend on compile\n      switches. When the VSX code was added, different constraints were added\n      based on the type (DFmode, V2DFmode, V4SFmode).  For the vector types, all\n@@ -3007,6 +3060,14 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t\t  reg_addr[TFmode].reload_gpr_vsx = CODE_FOR_reload_gpr_from_vsxtf;\n \t\t  reg_addr[TFmode].reload_vsx_gpr = CODE_FOR_reload_vsx_from_gprtf;\n \t\t}\n+\n+\t      if (TARGET_MMA)\n+\t\t{\n+\t\t  reg_addr[POImode].reload_store = CODE_FOR_reload_poi_di_store;\n+\t\t  reg_addr[POImode].reload_load = CODE_FOR_reload_poi_di_load;\n+\t\t  reg_addr[PXImode].reload_store = CODE_FOR_reload_pxi_di_store;\n+\t\t  reg_addr[PXImode].reload_load = CODE_FOR_reload_pxi_di_load;\n+\t\t}\n \t    }\n \t}\n       else\n@@ -3339,7 +3400,8 @@ rs6000_builtin_mask_calculate (void)\n \t      && !TARGET_IEEEQUAD)\t    ? RS6000_BTM_LDBL128   : 0)\n \t  | ((TARGET_FLOAT128_TYPE)\t    ? RS6000_BTM_FLOAT128  : 0)\n \t  | ((TARGET_FLOAT128_HW)\t    ? RS6000_BTM_FLOAT128_HW : 0)\n-\t  | ((TARGET_FUTURE)                ? RS6000_BTM_FUTURE    : 0));\n+\t  | ((TARGET_MMA)\t\t    ? RS6000_BTM_MMA\t   : 0)\n+\t  | ((TARGET_FUTURE)\t\t    ? RS6000_BTM_FUTURE    : 0));\n }\n \n /* Implement TARGET_MD_ASM_ADJUST.  All asm statements are considered\n@@ -4202,6 +4264,15 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_PCREL;\n     }\n \n+  /* Turn off vector pair/mma options on non-future systems.  */\n+  if (!TARGET_FUTURE && TARGET_MMA)\n+    {\n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_MMA) != 0)\n+\terror (\"%qs requires %qs\", \"-mmma\", \"-mcpu=future\");\n+\n+      rs6000_isa_flags &= ~OPTION_MASK_MMA;\n+    }\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after subtarget\", rs6000_isa_flags);\n \n@@ -7175,7 +7246,7 @@ rs6000_slow_unaligned_access (machine_mode mode, unsigned int align)\n   return (STRICT_ALIGNMENT\n \t  || (!TARGET_EFFICIENT_UNALIGNED_VSX\n \t      && ((SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode) && align < 32)\n-\t\t  || ((VECTOR_MODE_P (mode) || FLOAT128_VECTOR_P (mode))\n+\t\t  || ((VECTOR_MODE_P (mode) || VECTOR_ALIGNMENT_P (mode))\n \t\t      && (int) align < VECTOR_ALIGN (mode)))));\n }\n \n@@ -7360,7 +7431,7 @@ quad_address_p (rtx addr, machine_mode mode, bool strict)\n {\n   rtx op0, op1;\n \n-  if (GET_MODE_SIZE (mode) != 16)\n+  if (GET_MODE_SIZE (mode) < 16)\n     return false;\n \n   if (legitimate_indirect_address_p (addr, strict))\n@@ -7678,6 +7749,12 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \treturn mode_supports_dq_form (mode);\n       break;\n \n+      /* The vector pair/quad types support offset addressing if the\n+\t underlying vectors support offset addressing.  */\n+    case E_POImode:\n+    case E_PXImode:\n+      return TARGET_MMA;\n+\n     case E_SDmode:\n       /* If we can do direct load/stores of SDmode, restrict it to reg+reg\n \t addressing for the LFIWZX and STFIWX instructions.  */\n@@ -8024,8 +8101,14 @@ legitimate_indexed_address_p (rtx x, int strict)\n bool\n avoiding_indexed_address_p (machine_mode mode)\n {\n-  /* Avoid indexed addressing for modes that have non-indexed\n-     load/store instruction forms.  */\n+  unsigned int msize = GET_MODE_SIZE (mode);\n+\n+  /* Avoid indexed addressing for modes that have non-indexed load/store\n+     instruction forms.  On the future system, vector pairs have an indexed\n+     form, but vector quads don't.  */\n+  if (msize > 16)\n+    return msize != 32;\n+\n   return (TARGET_AVOID_XFORM && VECTOR_MEM_NONE_P (mode));\n }\n \n@@ -9856,6 +9939,13 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n+    case E_POImode:\n+    case E_PXImode:\n+      if (CONSTANT_P (operands[1]))\n+\terror (\"%qs is an opaque type, and you can't set it to other values.\",\n+\t       (mode == POImode) ? \"__vector_pair\" : \"__vector_quad\");\n+      break;\n+\n     case E_SImode:\n     case E_DImode:\n       /* Use default pattern for address of ELF small data */\n@@ -12117,8 +12207,20 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n       return NO_REGS;\n     }\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT && rclass == GEN_OR_FLOAT_REGS)\n-    return GENERAL_REGS;\n+  /* For the vector pair and vector quad modes, prefer their natural register\n+     (VSX or FPR) rather than GPR registers.  For other integer types, prefer\n+     the GPR registers.  */\n+  if (rclass == GEN_OR_FLOAT_REGS)\n+    {\n+      if (mode == POImode)\n+\treturn VSX_REGS;\n+\n+      if (mode == PXImode)\n+\treturn FLOAT_REGS;\n+\n+      if (GET_MODE_CLASS (mode) == MODE_INT)\n+\treturn GENERAL_REGS;\n+    }\n \n   return rclass;\n }\n@@ -15793,7 +15895,20 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n   reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n   mode = GET_MODE (dst);\n   nregs = hard_regno_nregs (reg, mode);\n-  if (FP_REGNO_P (reg))\n+\n+  /* If we have a vector quad register for MMA, and this is a load or store,\n+     see if we can use vector paired load/stores.  */\n+  if (mode == PXImode && TARGET_MMA\n+      && (MEM_P (dst) || MEM_P (src)))\n+    {\n+      reg_mode = POImode;\n+      nregs /= 2;\n+    }\n+  /* If we have a vector pair/quad mode, split it into two/four separate\n+     vectors.  */\n+  else if (mode == POImode || mode == PXImode)\n+    reg_mode = V1TImode;\n+  else if (FP_REGNO_P (reg))\n     reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode :\n \t(TARGET_HARD_FLOAT ? DFmode : SFmode);\n   else if (ALTIVEC_REGNO_P (reg))\n@@ -15837,6 +15952,51 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       return;\n     }\n \n+  /* The __vector_pair and __vector_quad modes are multi-register modes,\n+     so if have to load or store the registers, we have to be careful to\n+     properly swap them if we're in little endian mode below.  This means\n+     the last register gets the first memory location.  */\n+  if (mode == POImode || mode == PXImode)\n+    {\n+      if (MEM_P (dst))\n+\t{\n+\t  unsigned offset = 0;\n+\t  unsigned size = GET_MODE_SIZE (reg_mode);\n+\n+\t  for (int i = 0; i < nregs; i++)\n+\t    {\n+\t      unsigned subreg = (WORDS_BIG_ENDIAN)\n+\t\t\t\t  ? i * size : (nregs - 1 - i) * size;\n+\t      rtx dst2 = adjust_address (dst, reg_mode, offset);\n+\t      rtx src2 = simplify_gen_subreg (reg_mode, src, mode, subreg);\n+\t      offset += size;\n+\t      emit_insn (gen_rtx_SET (dst2, src2));\n+\t    }\n+\n+\t  return;\n+\t}\n+\n+      if (MEM_P (src))\n+\t{\n+\t  unsigned offset = 0;\n+\t  unsigned size = GET_MODE_SIZE (reg_mode);\n+\n+\t  for (int i = 0; i < nregs; i++)\n+\t    {\n+\t      unsigned subreg = (WORDS_BIG_ENDIAN)\n+\t\t\t\t  ? i * size : (nregs - 1 - i) * size;\n+\t      rtx dst2 = simplify_gen_subreg (reg_mode, dst, mode, subreg);\n+\t      rtx src2 = adjust_address (src, reg_mode, offset);\n+\t      offset += size;\n+\t      emit_insn (gen_rtx_SET (dst2, src2));\n+\t    }\n+\n+\t  return;\n+\t}\n+\n+      /* Register -> register moves can use common code.  */\n+    }\n+\n   if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n     {\n       /* Move register range backwards, if we might have destructive\n@@ -19227,7 +19387,8 @@ rs6000_handle_altivec_attribute (tree *node,\n \n /* AltiVec defines five built-in scalar types that serve as vector\n    elements; we must teach the compiler how to mangle them.  The 128-bit\n-   floating point mangling is target-specific as well.  */\n+   floating point mangling is target-specific as well.  MMA defines\n+   two built-in types to be used as opaque vector types.  */\n \n static const char *\n rs6000_mangle_type (const_tree type)\n@@ -19249,6 +19410,11 @@ rs6000_mangle_type (const_tree type)\n   if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IEEE_P (TYPE_MODE (type)))\n     return ieee128_mangling_gcc_8_1 ? \"U10__float128\" : \"u9__ieee128\";\n \n+  if (type == vector_pair_type_node)\n+    return \"u13__vector_pair\";\n+  if (type == vector_quad_type_node)\n+    return \"u13__vector_quad\";\n+\n   /* For all other types, use the default mangling.  */\n   return NULL;\n }\n@@ -22506,7 +22672,7 @@ rs6000_function_value (const_tree valtype,\n   /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n      return register is used in both cases, and we won't see V2DImode/V2DFmode\n      for pure altivec, combine the two cases.  */\n-  else if ((TREE_CODE (valtype) == VECTOR_TYPE || FLOAT128_VECTOR_P (mode))\n+  else if ((TREE_CODE (valtype) == VECTOR_TYPE || VECTOR_ALIGNMENT_P (mode))\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI\n \t   && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n@@ -22922,6 +23088,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"isel\",\t\t\tOPTION_MASK_ISEL,\t\tfalse, true  },\n   { \"mfcrf\",\t\t\tOPTION_MASK_MFCRF,\t\tfalse, true  },\n   { \"mfpgpr\",\t\t\t0,\t\t\t\tfalse, true  },\n+  { \"mma\",\t\t\tOPTION_MASK_MMA,\t\tfalse, true  },\n   { \"modulo\",\t\t\tOPTION_MASK_MODULO,\t\tfalse, true  },\n   { \"mulhw\",\t\t\tOPTION_MASK_MULHW,\t\tfalse, true  },\n   { \"multiple\",\t\t\tOPTION_MASK_MULTIPLE,\t\tfalse, true  },\n@@ -22992,6 +23159,8 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n   { \"powerpc64\",\t RS6000_BTM_POWERPC64,  false, false },\n   { \"float128\",\t\t RS6000_BTM_FLOAT128,   false, false },\n   { \"float128-hw\",\t RS6000_BTM_FLOAT128_HW,false, false },\n+  { \"mma\",\t\t RS6000_BTM_MMA,\tfalse, false },\n+  { \"future\",\t\t RS6000_BTM_FUTURE,\tfalse, false },\n };\n \n /* Option variables that we want to support inside attribute((target)) and\n@@ -24947,7 +25116,7 @@ address_to_insn_form (rtx addr,\n \tnon_prefixed_format = NON_PREFIXED_DS;\n \n       else if (TARGET_VSX && size >= 16\n-\t       && (VECTOR_MODE_P (mode) || FLOAT128_VECTOR_P (mode)))\n+\t       && (VECTOR_MODE_P (mode) || VECTOR_ALIGNMENT_P (mode)))\n \tnon_prefixed_format = NON_PREFIXED_DQ;\n \n       else\n@@ -25076,7 +25245,7 @@ reg_to_non_prefixed (rtx reg, machine_mode mode)\n \n       else if (TARGET_VSX && size >= 16\n \t       && (VECTOR_MODE_P (mode)\n-\t\t   || FLOAT128_VECTOR_P (mode)\n+\t\t   || VECTOR_ALIGNMENT_P (mode)\n \t\t   || mode == TImode || mode == CTImode))\n \treturn (TARGET_P9_VECTOR) ? NON_PREFIXED_DQ : NON_PREFIXED_X;\n \n@@ -25100,7 +25269,7 @@ reg_to_non_prefixed (rtx reg, machine_mode mode)\n \n       else if (TARGET_VSX && size >= 16\n \t       && (VECTOR_MODE_P (mode)\n-\t\t   || FLOAT128_VECTOR_P (mode)\n+\t\t   || VECTOR_ALIGNMENT_P (mode)\n \t\t   || mode == TImode || mode == CTImode))\n \treturn NON_PREFIXED_DQ;\n \n@@ -26494,6 +26663,45 @@ rs6000_cannot_substitute_mem_equiv_p (rtx mem)\n   return false;\n }\n \n+/* Implement TARGET_INVALID_CONVERSION.  */\n+\n+static const char *\n+rs6000_invalid_conversion (const_tree fromtype, const_tree totype)\n+{\n+  if (element_mode (fromtype) != element_mode (totype))\n+    {\n+      /* Do not allow conversions to/from PXImode and POImode types.  */\n+      if (TYPE_MODE (fromtype) == PXImode)\n+\treturn N_(\"invalid conversion from type %<__vector_quad%>\");\n+      if (TYPE_MODE (totype) == PXImode)\n+\treturn N_(\"invalid conversion to type %<__vector_quad%>\");\n+      if (TYPE_MODE (fromtype) == POImode)\n+\treturn N_(\"invalid conversion from type %<__vector_pair%>\");\n+      if (TYPE_MODE (totype) == POImode)\n+\treturn N_(\"invalid conversion to type %<__vector_pair%>\");\n+    }\n+  else if (POINTER_TYPE_P (fromtype) && POINTER_TYPE_P (totype))\n+    {\n+      /* Do not allow conversions to/from PXImode and POImode pointer\n+\t types, except to/from void pointers.  */\n+      if (TYPE_MODE (TREE_TYPE (fromtype)) == PXImode\n+\t  && TYPE_MODE (TREE_TYPE (totype)) != VOIDmode)\n+\treturn N_(\"invalid conversion from type %<* __vector_quad%>\");\n+      if (TYPE_MODE (TREE_TYPE (totype)) == PXImode\n+\t  && TYPE_MODE (TREE_TYPE (fromtype)) != VOIDmode)\n+\treturn N_(\"invalid conversion to type %<* __vector_quad%>\");\n+      if (TYPE_MODE (TREE_TYPE (fromtype)) == POImode\n+\t  && TYPE_MODE (TREE_TYPE (totype)) != VOIDmode)\n+\treturn N_(\"invalid conversion from type %<* __vector_pair%>\");\n+      if (TYPE_MODE (TREE_TYPE (totype)) == POImode\n+\t  && TYPE_MODE (TREE_TYPE (fromtype)) != VOIDmode)\n+\treturn N_(\"invalid conversion to type %<* __vector_pair%>\");\n+    }\n+\n+  /* Conversion allowed.  */\n+  return NULL;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rs6000.h\""}, {"sha": "188f49ca1f3e5382e6cdcd7e20d833db7370fe5b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -522,6 +522,7 @@ extern int rs6000_vector_align[];\n #define MASK_HTM\t\t\tOPTION_MASK_HTM\n #define MASK_ISEL\t\t\tOPTION_MASK_ISEL\n #define MASK_MFCRF\t\t\tOPTION_MASK_MFCRF\n+#define MASK_MMA\t\t\tOPTION_MASK_MMA\n #define MASK_MULHW\t\t\tOPTION_MASK_MULHW\n #define MASK_MULTIPLE\t\t\tOPTION_MASK_MULTIPLE\n #define MASK_NO_UPDATE\t\t\tOPTION_MASK_NO_UPDATE\n@@ -776,7 +777,7 @@ extern unsigned rs6000_pointer_size;\n #define FUNCTION_BOUNDARY 32\n \n /* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 128\n+#define BIGGEST_ALIGNMENT (TARGET_MMA ? 512 : 128)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 32\n@@ -1035,16 +1036,17 @@ enum data_align { align_abi, align_opt, align_both };\n \t ((MODE) == V4SFmode\t\t\\\n \t  || (MODE) == V2DFmode)\t\\\n \n-/* Note KFmode and possibly TFmode (i.e. IEEE 128-bit floating point) are not\n-   really a vector, but we want to treat it as a vector for moves, and\n-   such.  */\n+/* Modes that are not vectors, but require vector alignment.  Treat these like\n+   vectors in terms of loads and stores.  */\n+#define VECTOR_ALIGNMENT_P(MODE)\t\t\t\t\t\\\n+  (FLOAT128_VECTOR_P (MODE) || (MODE) == POImode || (MODE) == PXImode)\n \n #define ALTIVEC_VECTOR_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode\t\t\t\t\t\t\t\\\n    || (MODE) == V8HImode\t\t\t\t\t\t\\\n    || (MODE) == V4SFmode\t\t\t\t\t\t\\\n    || (MODE) == V4SImode\t\t\t\t\t\t\\\n-   || FLOAT128_VECTOR_P (MODE))\n+   || VECTOR_ALIGNMENT_P (MODE))\n \n #define ALTIVEC_OR_VSX_VECTOR_MODE(MODE)\t\t\t\t\\\n   (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)\t\t\t\\\n@@ -2309,6 +2311,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_POWERPC64\tMASK_POWERPC64\t/* 64-bit registers.  */\n #define RS6000_BTM_FLOAT128\tMASK_FLOAT128_KEYWORD /* IEEE 128-bit float.  */\n #define RS6000_BTM_FLOAT128_HW\tMASK_FLOAT128_HW /* IEEE 128-bit float h/w.  */\n+#define RS6000_BTM_MMA\t\tMASK_MMA\t/* ISA 3.1 MMA.  */\n #define RS6000_BTM_FUTURE\tMASK_FUTURE\n \n \n@@ -2331,7 +2334,9 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_LDBL128\t\t\t\\\n \t\t\t\t | RS6000_BTM_POWERPC64\t\t\t\\\n \t\t\t\t | RS6000_BTM_FLOAT128\t\t\t\\\n-\t\t\t\t | RS6000_BTM_FLOAT128_HW)\n+\t\t\t\t | RS6000_BTM_FLOAT128_HW\t\t\\\n+\t\t\t\t | RS6000_BTM_MMA\t\t\t\\\n+\t\t\t\t | RS6000_BTM_FUTURE)\n \n /* Define builtin enum index.  */\n \n@@ -2443,6 +2448,8 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_ieee128_float,\t /* ieee 128-bit floating point */\n   RS6000_BTI_ibm128_float,\t /* IBM 128-bit floating point */\n   RS6000_BTI_const_str,\t\t /* pointer to const char * */\n+  RS6000_BTI_vector_pair,\t /* unsigned 256-bit types (vector pair).  */\n+  RS6000_BTI_vector_quad,\t /* unsigned 512-bit types (vector quad).  */\n   RS6000_BTI_MAX\n };\n \n@@ -2495,6 +2502,8 @@ enum rs6000_builtin_type_index\n #define ieee128_float_type_node\t\t (rs6000_builtin_types[RS6000_BTI_ieee128_float])\n #define ibm128_float_type_node\t\t (rs6000_builtin_types[RS6000_BTI_ibm128_float])\n #define const_str_type_node\t\t (rs6000_builtin_types[RS6000_BTI_const_str])\n+#define vector_pair_type_node\t\t (rs6000_builtin_types[RS6000_BTI_vector_pair])\n+#define vector_quad_type_node\t\t (rs6000_builtin_types[RS6000_BTI_vector_quad])\n \n extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];\n extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];"}, {"sha": "f577bb0e823999f6c33c9e923df0b7a1e0bded1e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -772,7 +772,8 @@\n ;; Reload iterator for creating the function to allocate a base register to\n ;; supplement addressing modes.\n (define_mode_iterator RELOAD [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n-\t\t\t      SF SD SI DF DD DI TI PTI KF IF TF])\n+\t\t\t      SF SD SI DF DD DI TI PTI KF IF TF\n+\t\t\t      POI PXI])\n \n ;; Iterate over smin, smax\n (define_code_iterator fp_minmax\t[smin smax])\n@@ -14866,6 +14867,7 @@\n (include \"vector.md\")\n (include \"vsx.md\")\n (include \"altivec.md\")\n+(include \"mma.md\")\n (include \"dfp.md\")\n (include \"crypto.md\")\n (include \"htm.md\")"}, {"sha": "92951483e4ec1ea9b975b1dcf209f99ba5c90348", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -578,3 +578,7 @@ Generate (do not generate) prefixed memory instructions.\n mpcrel\n Target Report Mask(PCREL) Var(rs6000_isa_flags)\n Generate (do not generate) pc-relative memory addressing.\n+\n+mmma\n+Target Report Mask(MMA) Var(rs6000_isa_flags)\n+Generate (do not generate) MMA instructions."}, {"sha": "81d550ce236807f8e6bddb83db2f09fdd27976d4", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -83,6 +83,7 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/vector.md \\\n \t$(srcdir)/config/rs6000/vsx.md \\\n \t$(srcdir)/config/rs6000/altivec.md \\\n+\t$(srcdir)/config/rs6000/mma.md \\\n \t$(srcdir)/config/rs6000/crypto.md \\\n \t$(srcdir)/config/rs6000/htm.md \\\n \t$(srcdir)/config/rs6000/dfp.md"}, {"sha": "98cc0f2f0de1d89928d98edcb2f2fa99f040f195", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f002c046e37d0027513af5297d9259e1fad29c27/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f002c046e37d0027513af5297d9259e1fad29c27", "patch": "@@ -1201,7 +1201,7 @@ See RS/6000 and PowerPC Options.\n -mgnu-attribute  -mno-gnu-attribute @gol\n -mstack-protector-guard=@var{guard} -mstack-protector-guard-reg=@var{reg} @gol\n -mstack-protector-guard-offset=@var{offset} -mprefixed -mno-prefixed @gol\n--mpcrel -mno-pcrel}\n+-mpcrel -mno-pcrel -mmma -mno-mmma}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -25941,7 +25941,8 @@ following options:\n -mpowerpc-gpopt  -mpowerpc-gfxopt @gol\n -mmulhw  -mdlmzb  -mmfpgpr  -mvsx @gol\n -mcrypto  -mhtm  -mpower8-fusion  -mpower8-vector @gol\n--mquad-memory  -mquad-memory-atomic  -mfloat128  -mfloat128-hardware}\n+-mquad-memory  -mquad-memory-atomic  -mfloat128 @gol\n+-mfloat128-hardware -mprefixed -mpcrel -mmma}\n \n The particular options set for any particular CPU varies between\n compiler versions, depending on what setting seems to produce optimal\n@@ -26937,6 +26938,13 @@ addressing (@option{-mprefixed}) options are enabled.\n @opindex mno-prefixed\n Generate (do not generate) addressing modes using prefixed load and\n store instructions when the option @option{-mcpu=future} is used.\n+\n+@item -mmma\n+@itemx -mno-mma\n+@opindex mmma\n+@opindex mno-mma\n+Generate (do not generate) the MMA instructions when the option\n+@option{-mcpu=future} is used.\n @end table\n \n @node RX Options"}]}