{"sha": "2d70f6d43551f5e6344909b8f2020a92ae7e4839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ3MGY2ZDQzNTUxZjVlNjM0NDkwOWI4ZjIwMjBhOTJhZTdlNDgzOQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2014-01-30T16:01:43Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2014-01-30T16:01:43Z"}, "message": "rl78.c (register_sizes): Make the \"upper half\" of %fp 2 to keep registers after it properly word-aligned.\n\n\t* config/rl78/rl78.c (register_sizes): Make the \"upper half\" of\n\t%fp 2 to keep registers after it properly word-aligned.\n\t(rl78_alloc_physical_registers_umul): Handle the case where both\n\tinput operands are the same.\n\nCo-Authored-By: DJ Delorie <dj@redhat.com>\n\nFrom-SVN: r207308", "tree": {"sha": "a4d943903a5c8757ad627ce4b35372fb1795de05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4d943903a5c8757ad627ce4b35372fb1795de05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d70f6d43551f5e6344909b8f2020a92ae7e4839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d70f6d43551f5e6344909b8f2020a92ae7e4839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d70f6d43551f5e6344909b8f2020a92ae7e4839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d70f6d43551f5e6344909b8f2020a92ae7e4839/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c972624e481f320326200ef6cfbaaf4daa66a45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c972624e481f320326200ef6cfbaaf4daa66a45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c972624e481f320326200ef6cfbaaf4daa66a45a"}], "stats": {"total": 82, "additions": 51, "deletions": 31}, "files": [{"sha": "b659fb59eeeed55f2c3e98a732cdbbe9c7e5e7d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d70f6d43551f5e6344909b8f2020a92ae7e4839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d70f6d43551f5e6344909b8f2020a92ae7e4839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d70f6d43551f5e6344909b8f2020a92ae7e4839", "patch": "@@ -1,3 +1,11 @@\n+2014-01-30  Nick Clifton  <nickc@redhat.com>\n+\t    DJ Delorie  <dj@redhat.com>\n+\n+\t* config/rl78/rl78.c (register_sizes): Make the \"upper half\" of\n+\t%fp 2 to keep registers after it properly word-aligned.\n+\t(rl78_alloc_physical_registers_umul): Handle the case where both\n+\tinput operands are the same.\n+\n 2014-01-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59903"}, {"sha": "b5cd2ad7516cbdac651a253b57a235722f7ccd9a", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d70f6d43551f5e6344909b8f2020a92ae7e4839/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d70f6d43551f5e6344909b8f2020a92ae7e4839/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=2d70f6d43551f5e6344909b8f2020a92ae7e4839", "patch": "@@ -327,13 +327,15 @@ rl78_option_override (void)\n }\n \n /* Most registers are 8 bits.  Some are 16 bits because, for example,\n-   gcc doesn't like dealing with $FP as a register pair.  This table\n-   maps register numbers to size in bytes.  */\n+   gcc doesn't like dealing with $FP as a register pair (the second\n+   half of $fp is also 2 to keep reload happy wrt register pairs, but\n+   no register class includes it).  This table maps register numbers\n+   to size in bytes.  */\n static const int register_sizes[] =\n {\n   1, 1, 1, 1, 1, 1, 1, 1,\n   1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 2, 1,\n+  1, 1, 1, 1, 1, 1, 2, 2,\n   1, 1, 1, 1, 1, 1, 1, 1,\n   2, 2, 1, 1, 1\n };\n@@ -381,7 +383,7 @@ rl78_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   /* These are not to be used by gcc.  */\n   if (regno == 23 || regno == ES_REG || regno == CS_REG)\n     return 0;\n-  /* $fp can alway sbe accessed as a 16-bit value.  */\n+  /* $fp can always be accessed as a 16-bit value.  */\n   if (regno == FP_REG && s == 2)\n     return 1;\n   if (regno < SP_REG)\n@@ -659,10 +661,10 @@ is_brk_interrupt_func (const_tree decl)\n /* Check \"interrupt\" attributes.  */\n static tree\n rl78_handle_func_attribute (tree * node,\n-\t\t\t  tree   name,\n-\t\t\t  tree   args,\n-\t\t\t  int    flags ATTRIBUTE_UNUSED,\n-\t\t\t  bool * no_add_attrs)\n+\t\t\t    tree   name,\n+\t\t\t    tree   args,\n+\t\t\t    int    flags ATTRIBUTE_UNUSED,\n+\t\t\t    bool * no_add_attrs)\n {\n   gcc_assert (DECL_P (* node));\n   gcc_assert (args == NULL_TREE);\n@@ -820,14 +822,14 @@ rl78_far_p (rtx x)\n   if (! MEM_P (x))\n     return 0;\n #if DEBUG0\n-  fprintf (stderr, \"\\033[35mrl78_far_p: \"); debug_rtx(x);\n+  fprintf (stderr, \"\\033[35mrl78_far_p: \"); debug_rtx (x);\n   fprintf (stderr, \" = %d\\033[0m\\n\", MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR);\n #endif\n   return MEM_ADDR_SPACE (x) == ADDR_SPACE_FAR;\n }\n \n /* Return the appropriate mode for a named address pointer.  */\n-#undef TARGET_ADDR_SPACE_POINTER_MODE\n+#undef  TARGET_ADDR_SPACE_POINTER_MODE\n #define TARGET_ADDR_SPACE_POINTER_MODE rl78_addr_space_pointer_mode\n static enum machine_mode\n rl78_addr_space_pointer_mode (addr_space_t addrspace)\n@@ -844,7 +846,7 @@ rl78_addr_space_pointer_mode (addr_space_t addrspace)\n }\n \n /* Returns TRUE for valid addresses.  */\n-#undef TARGET_VALID_POINTER_MODE\n+#undef  TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE rl78_valid_pointer_mode\n static bool\n rl78_valid_pointer_mode (enum machine_mode m)\n@@ -853,7 +855,7 @@ rl78_valid_pointer_mode (enum machine_mode m)\n }\n \n /* Return the appropriate mode for a named address address.  */\n-#undef TARGET_ADDR_SPACE_ADDRESS_MODE\n+#undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n #define TARGET_ADDR_SPACE_ADDRESS_MODE rl78_addr_space_address_mode\n static enum machine_mode\n rl78_addr_space_address_mode (addr_space_t addrspace)\n@@ -1796,7 +1798,7 @@ rl78_peep_movhi_p (rtx *operands)\n \t    {\n #if DEBUG_PEEP\n \t      fprintf (stderr, \"no peep: wrong mem %d\\n\", i);\n-\t      debug_rtx(m);\n+\t      debug_rtx (m);\n \t      debug_rtx (operands[i+2]);\n #endif\n \t      return false;\n@@ -1832,7 +1834,7 @@ rl78_setup_peep_movhi (rtx *operands)\n \t  break;\n \n \tcase CONST_INT:\n-\t  operands[i+4] = GEN_INT ((INTVAL (operands[i]) & 0xff) + ((char)INTVAL (operands[i+2])) * 256);\n+\t  operands[i+4] = GEN_INT ((INTVAL (operands[i]) & 0xff) + ((char) INTVAL (operands[i+2])) * 256);\n \t  break;\n \n \tcase MEM:\n@@ -2031,7 +2033,7 @@ update_content (unsigned char index, unsigned char val, enum machine_mode mode)\n       else\n \tfprintf (dump_file, \"%s and vice versa\\n\", get_content_name (val, mode));\n     }\n-  \n+\n   if (mode == HImode)\n     {\n       val = val == NOT_KNOWN ? val : val + 1;\n@@ -2054,7 +2056,7 @@ update_content (unsigned char index, unsigned char val, enum machine_mode mode)\n \t    ++ i;\n \t  continue;\n \t}\n-\t\n+\n       if (content_memory[i] == index\n \t  || (val != NOT_KNOWN && content_memory[i] == val))\n \t{\n@@ -2269,7 +2271,7 @@ EM2 (int line ATTRIBUTE_UNUSED, rtx r)\n {\n #if DEBUG_ALLOC\n   fprintf (stderr, \"\\033[36m%d: \", line);\n-  debug_rtx(r);\n+  debug_rtx (r);\n   fprintf (stderr, \"\\033[0m\");\n #endif\n   /*SCHED_GROUP_P (r) = 1;*/\n@@ -2363,7 +2365,7 @@ gen_and_emit_move (rtx to, rtx from, rtx where, bool before)\n   else\n     {\n       rtx move = mode == QImode ? gen_movqi (to, from) : gen_movhi (to, from);\n-      \n+\n       EM (move);\n \n       if (where == NULL_RTX)\n@@ -2521,7 +2523,7 @@ force_into_acc (rtx src, rtx before)\n     return;\n \n   move = mode == QImode ? gen_movqi (A, src) : gen_movhi (AX, src);\n-      \n+\n   EM (move);\n \n   emit_insn_before (move, before);\n@@ -2683,7 +2685,7 @@ has_constraint (unsigned int opnum, enum constraint_num constraint)\n   /* No constraints means anything is accepted.  */\n   if (p == NULL || *p == 0 || *p == ',')\n     return true;\n- \n+\n   do\n     {\n       char c;\n@@ -2750,7 +2752,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n     }\n \n   /* Make a note of whether (H)L is being used.  It matters\n-     because if OP (2) alsoneeds reloading, then we must take\n+     because if OP (2) also needs reloading, then we must take\n      care not to corrupt HL.  */\n   hl_used = reg_mentioned_p (L, OP (0)) || reg_mentioned_p (L, OP (1));\n \n@@ -2764,7 +2766,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n       /* If op0 is a Ws1 type memory address then switching the base\n \t address register to HL might allow us to perform an in-memory\n \t operation.  (eg for the INCW instruction).\n-\t \n+\n \t FIXME: Adding the move into HL is costly if this optimization is not\n \t going to work, so for now, make sure that we know that the new insn will\n \t match the requirements of the addhi3_real pattern.  Really we ought to\n@@ -2786,7 +2788,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n \t      newbase = gen_and_emit_move (HL, base, insn, true);\n \t      record_content (newbase, NULL_RTX);\n \t      newbase = gen_rtx_PLUS (HImode, newbase, addend);\n-      \n+\n \t      OP (0) = OP (1) = change_address (OP (0), VOIDmode, newbase);\n \n \t      /* We do not want to fail here as this means that\n@@ -2817,7 +2819,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n \n \t      record_content (HL, NULL_RTX);\n \t      newbase = gen_rtx_PLUS (HImode, HL, addend);\n-      \n+\n \t      OP (2) = change_address (OP (2), VOIDmode, newbase);\n \n \t      /* We do not want to fail here as this means that\n@@ -2857,7 +2859,7 @@ rl78_alloc_physical_registers_op2 (rtx insn)\n       ;\n \n   OP (2) = hl_used ? move_to_de (2, first) : move_to_hl (2, first);\n-  \n+\n   MUST_BE_OK (insn);\n }\n \n@@ -2923,7 +2925,7 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n       if (GET_CODE (cmp) == EQ || GET_CODE (cmp) == NE)\n \tPATTERN (insn) = gen_cbranchhi4_real (cmp, OP (2), OP (1), OP (3));\n       else\n@@ -2939,7 +2941,7 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n       OP (1) = OP (2) = BC;\n       MUST_BE_OK (insn);\n     }\n-  \n+\n   tmp_id = get_max_insn_count ();\n   saved_op1 = OP (1);\n \n@@ -2967,7 +2969,7 @@ rl78_alloc_physical_registers_cmp (rtx insn)\n   MUST_BE_OK (insn);\n }\n \n-/* Like op2, but AX = A op X.  */\n+/* Like op2, but AX = A * X.  */\n static void\n rl78_alloc_physical_registers_umul (rtx insn)\n {\n@@ -2996,8 +2998,18 @@ rl78_alloc_physical_registers_umul (rtx insn)\n \n   tmp_id = get_max_insn_count ();\n   saved_op1 = OP (1);\n-  \n-  OP (1) = move_to_acc (1, insn);\n+\n+  if (rtx_equal_p (OP (1), OP (2)))\n+    {\n+      gcc_assert (GET_MODE (OP (2)) == QImode);\n+      /* The MULU instruction does not support duplicate arguments\n+\t but we know that if we copy OP (2) to X it will do so via\n+\t A and thus OP (1) will already be loaded into A.  */\n+      OP (2) = move_to_x (2, insn);\n+      OP (1) = A;\n+    }\n+  else\n+    OP (1) = move_to_acc (1, insn);\n \n   MAYBE_OK (insn);\n \n@@ -3129,7 +3141,7 @@ rl78_alloc_physical_registers (void)\n \t{\n \t  if (LABEL_P (insn))\n \t    clear_content_memory ();\n-\t    \n+\n  \t  continue;\n \t}\n "}]}