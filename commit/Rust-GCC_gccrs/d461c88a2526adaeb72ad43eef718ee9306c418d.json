{"sha": "d461c88a2526adaeb72ad43eef718ee9306c418d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ2MWM4OGEyNTI2YWRhZWI3MmFkNDNlZWY3MThlZTkzMDZjNDE4ZA==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-06-18T17:47:40Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-06-18T17:47:40Z"}, "message": "The main function for epilogue RTL generation, used by expand epilogue\npatterns.\n\ngcc/\n\n2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n            Sameera Deshpande  <sameera.deshpande@arm.com>\n            Greta Yorsh  <greta.yorsh@arm.com>\n\n        * config/arm/arm-protos.h (arm_expand_epilogue): New declaration.\n        * config/arm/arm.c (arm_expand_epilogue): New function.\n        * config/arm/arm.md (epilogue): Update condition and code.\n        (sibcall_epilogue): Likewise.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r188742", "tree": {"sha": "0c0b9d07169e0af7d66e1f6d09d931f60d55f0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c0b9d07169e0af7d66e1f6d09d931f60d55f0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d461c88a2526adaeb72ad43eef718ee9306c418d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d461c88a2526adaeb72ad43eef718ee9306c418d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d461c88a2526adaeb72ad43eef718ee9306c418d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d461c88a2526adaeb72ad43eef718ee9306c418d/comments", "author": null, "committer": null, "parents": [{"sha": "0f9926f36760320180ae46f7e2c332750ebfbd9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9926f36760320180ae46f7e2c332750ebfbd9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9926f36760320180ae46f7e2c332750ebfbd9d"}], "stats": {"total": 292, "additions": 268, "deletions": 24}, "files": [{"sha": "ec83ad6a95daa03715a30c9c7d1aa1292af4a758", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d461c88a2526adaeb72ad43eef718ee9306c418d", "patch": "@@ -1,3 +1,12 @@\n+2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n+            Sameera Deshpande  <sameera.deshpande@arm.com>\n+            Greta Yorsh  <greta.yorsh@arm.com>\n+\n+        * config/arm/arm-protos.h (arm_expand_epilogue): New declaration.\n+        * config/arm/arm.c (arm_expand_epilogue): New function.\n+        * config/arm/arm.md (epilogue): Update condition and code.\n+        (sibcall_epilogue): Likewise.\n+\n 2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n             Sameera Deshpande  <sameera.deshpande@arm.com>\n             Greta Yorsh  <greta.yorsh@arm.com>"}, {"sha": "5c25e997c7fb5f81787b0b4d2bb00a648a55cf31", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d461c88a2526adaeb72ad43eef718ee9306c418d", "patch": "@@ -30,6 +30,7 @@ extern void arm_load_pic_register (unsigned long);\n extern int arm_volatile_func (void);\n extern const char *arm_output_epilogue (rtx);\n extern void arm_expand_prologue (void);\n+extern void arm_expand_epilogue (bool);\n extern const char *arm_strip_name_encoding (const char *);\n extern void arm_asm_output_labelref (FILE *, const char *);\n extern void thumb2_asm_output_opcode (FILE *);"}, {"sha": "8bc8fd0b357ba46643bfca3f722ab02991736705", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d461c88a2526adaeb72ad43eef718ee9306c418d", "patch": "@@ -23473,6 +23473,241 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n   emit_jump_insn (simple_return_rtx);\n }\n \n+/* Generate RTL to represent ARM epilogue.  Really_return is true if the\n+   function is not a sibcall.  */\n+void\n+arm_expand_epilogue (bool really_return)\n+{\n+  unsigned long func_type;\n+  unsigned long saved_regs_mask;\n+  int num_regs = 0;\n+  int i;\n+  int amount;\n+  int floats_from_frame = 0;\n+  arm_stack_offsets *offsets;\n+\n+  func_type = arm_current_func_type ();\n+\n+  /* Naked functions don't have epilogue.  Hence, generate return pattern, and\n+     let output_return_instruction take care of instruction emition if any.  */\n+  if (IS_NAKED (func_type)\n+      || (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN))\n+    {\n+      emit_jump_insn (simple_return_rtx);\n+      return;\n+    }\n+\n+  /* If we are throwing an exception, then we really must be doing a\n+     return, so we can't tail-call.  */\n+  gcc_assert (!crtl->calls_eh_return || really_return);\n+\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+    {\n+      arm_expand_epilogue_apcs_frame (really_return);\n+      return;\n+    }\n+\n+  /* Get frame offsets for ARM.  */\n+  offsets = arm_get_frame_offsets ();\n+  saved_regs_mask = offsets->saved_regs_mask;\n+\n+  /* Find offset of floating point register from frame pointer.\n+     The initialization is done in this way to take care of frame pointer\n+     and static-chain register, if stored.  */\n+  floats_from_frame = offsets->saved_args - offsets->frame;\n+  /* Compute how many registers saved and how far away the floats will be.  */\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      {\n+        num_regs++;\n+        floats_from_frame += 4;\n+      }\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Restore stack pointer if necessary.  */\n+      if (TARGET_ARM)\n+        {\n+          /* In ARM mode, frame pointer points to first saved register.\n+             Restore stack pointer to last saved register.  */\n+          amount = offsets->frame - offsets->saved_regs;\n+\n+          /* Force out any pending memory operations that reference stacked data\n+             before stack de-allocation occurs.  */\n+          emit_insn (gen_blockage ());\n+          emit_insn (gen_addsi3 (stack_pointer_rtx,\n+                                 hard_frame_pointer_rtx,\n+                                 GEN_INT (amount)));\n+\n+          /* Emit USE(stack_pointer_rtx) to ensure that stack adjustment is not\n+             deleted.  */\n+          emit_insn (gen_prologue_use (stack_pointer_rtx));\n+        }\n+      else\n+        {\n+          /* In Thumb-2 mode, the frame pointer points to the last saved\n+             register.  */\n+          amount = offsets->locals_base - offsets->saved_regs;\n+          if (amount)\n+            emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n+                                   hard_frame_pointer_rtx,\n+                                   GEN_INT (amount)));\n+\n+          /* Force out any pending memory operations that reference stacked data\n+             before stack de-allocation occurs.  */\n+          emit_insn (gen_blockage ());\n+          emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));\n+          /* Emit USE(stack_pointer_rtx) to ensure that stack adjustment is not\n+             deleted.  */\n+          emit_insn (gen_prologue_use (stack_pointer_rtx));\n+        }\n+    }\n+  else\n+    {\n+      /* Pop off outgoing args and local frame to adjust stack pointer to\n+         last saved register.  */\n+      amount = offsets->outgoing_args - offsets->saved_regs;\n+      if (amount)\n+        {\n+          /* Force out any pending memory operations that reference stacked data\n+             before stack de-allocation occurs.  */\n+          emit_insn (gen_blockage ());\n+          emit_insn (gen_addsi3 (stack_pointer_rtx,\n+                                 stack_pointer_rtx,\n+                                 GEN_INT (amount)));\n+          /* Emit USE(stack_pointer_rtx) to ensure that stack adjustment is\n+             not deleted.  */\n+          emit_insn (gen_prologue_use (stack_pointer_rtx));\n+        }\n+    }\n+\n+  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+    {\n+      /* Generate VFP register multi-pop.  */\n+      int end_reg = LAST_VFP_REGNUM + 1;\n+\n+      /* Scan the registers in reverse order.  We need to match\n+         any groupings made in the prologue and generate matching\n+         vldm operations.  The need to match groups is because,\n+         unlike pop, vldm can only do consecutive regs.  */\n+      for (i = LAST_VFP_REGNUM - 1; i >= FIRST_VFP_REGNUM; i -= 2)\n+        /* Look for a case where a reg does not need restoring.  */\n+        if ((!df_regs_ever_live_p (i) || call_used_regs[i])\n+            && (!df_regs_ever_live_p (i + 1)\n+                || call_used_regs[i + 1]))\n+          {\n+            /* Restore the regs discovered so far (from reg+2 to\n+               end_reg).  */\n+            if (end_reg > i + 2)\n+              arm_emit_vfp_multi_reg_pop (i + 2,\n+                                          (end_reg - (i + 2)) / 2,\n+                                          stack_pointer_rtx);\n+            end_reg = i;\n+          }\n+\n+      /* Restore the remaining regs that we have discovered (or possibly\n+         even all of them, if the conditional in the for loop never\n+         fired).  */\n+      if (end_reg > i + 2)\n+        arm_emit_vfp_multi_reg_pop (i + 2,\n+                                    (end_reg - (i + 2)) / 2,\n+                                    stack_pointer_rtx);\n+    }\n+\n+  if (TARGET_IWMMXT)\n+    for (i = FIRST_IWMMXT_REGNUM; i <= LAST_IWMMXT_REGNUM; i++)\n+      if (df_regs_ever_live_p (i) && !call_used_regs[i])\n+        {\n+          rtx insn;\n+          rtx addr = gen_rtx_MEM (V2SImode,\n+                                  gen_rtx_POST_INC (SImode,\n+                                                    stack_pointer_rtx));\n+          set_mem_alias_set (addr, get_frame_alias_set ());\n+          insn = emit_insn (gen_movsi (gen_rtx_REG (V2SImode, i), addr));\n+          REG_NOTES (insn) = alloc_reg_note (REG_CFA_RESTORE,\n+                                             gen_rtx_REG (V2SImode, i),\n+                                             NULL_RTX);\n+        }\n+\n+  if (saved_regs_mask)\n+    {\n+      rtx insn;\n+      bool return_in_pc = false;\n+\n+      if (ARM_FUNC_TYPE (func_type) != ARM_FT_INTERWORKED\n+          && (TARGET_ARM || ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n+          && !IS_STACKALIGN (func_type)\n+          && really_return\n+          && crtl->args.pretend_args_size == 0\n+          && saved_regs_mask & (1 << LR_REGNUM)\n+          && !crtl->calls_eh_return)\n+        {\n+          saved_regs_mask &= ~(1 << LR_REGNUM);\n+          saved_regs_mask |= (1 << PC_REGNUM);\n+          return_in_pc = true;\n+        }\n+\n+      if (num_regs == 1 && (!IS_INTERRUPT (func_type) || !return_in_pc))\n+        {\n+          for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+            if (saved_regs_mask & (1 << i))\n+              {\n+                rtx addr = gen_rtx_MEM (SImode,\n+                                        gen_rtx_POST_INC (SImode,\n+                                                          stack_pointer_rtx));\n+                set_mem_alias_set (addr, get_frame_alias_set ());\n+\n+                if (i == PC_REGNUM)\n+                  {\n+                    insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+                    XVECEXP (insn, 0, 0) = ret_rtx;\n+                    XVECEXP (insn, 0, 1) = gen_rtx_SET (SImode,\n+                                                        gen_rtx_REG (SImode, i),\n+                                                        addr);\n+                    RTX_FRAME_RELATED_P (XVECEXP (insn, 0, 1)) = 1;\n+                    insn = emit_jump_insn (insn);\n+                  }\n+                else\n+                  {\n+                    insn = emit_insn (gen_movsi (gen_rtx_REG (SImode, i),\n+                                                 addr));\n+                    REG_NOTES (insn) = alloc_reg_note (REG_CFA_RESTORE,\n+                                                       gen_rtx_REG (SImode, i),\n+                                                       NULL_RTX);\n+                  }\n+              }\n+        }\n+      else\n+        {\n+          arm_emit_multi_reg_pop (saved_regs_mask);\n+        }\n+\n+      if (return_in_pc == true)\n+        return;\n+    }\n+\n+  if (crtl->args.pretend_args_size)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+                           stack_pointer_rtx,\n+                           GEN_INT (crtl->args.pretend_args_size)));\n+\n+  if (!really_return)\n+    return;\n+\n+  if (crtl->calls_eh_return)\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+                           stack_pointer_rtx,\n+                           gen_rtx_REG (SImode, ARM_EH_STACKADJ_REGNUM)));\n+\n+  if (IS_STACKALIGN (func_type))\n+    /* Restore the original stack pointer.  Before prologue, the stack was\n+       realigned and the original stack pointer saved in r0.  For details,\n+       see comment in arm_expand_prologue.  */\n+    emit_insn (gen_movsi (stack_pointer_rtx, gen_rtx_REG (SImode, 0)));\n+\n+  emit_jump_insn (simple_return_rtx);\n+}\n+\n /* Implementation of insn prologue_thumb1_interwork.  This is the first\n    \"instruction\" of a function called in ARM mode.  Swap to thumb mode.  */\n "}, {"sha": "c2793f1bf174f28d2fc39e874e584fff8602c8e0", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d461c88a2526adaeb72ad43eef718ee9306c418d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d461c88a2526adaeb72ad43eef718ee9306c418d", "patch": "@@ -10547,14 +10547,21 @@\n   if (crtl->calls_eh_return)\n     emit_insn (gen_prologue_use (gen_rtx_REG (Pmode, 2)));\n   if (TARGET_THUMB1)\n-    thumb1_expand_epilogue ();\n-  else if (USE_RETURN_INSN (FALSE))\n-    {\n-      emit_jump_insn (gen_return ());\n-      DONE;\n-    }\n-  emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,\n-\tgen_rtvec (1, ret_rtx), VUNSPEC_EPILOGUE));\n+   {\n+     thumb1_expand_epilogue ();\n+     emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,\n+                     gen_rtvec (1, ret_rtx), VUNSPEC_EPILOGUE));\n+   }\n+  else if (HAVE_return)\n+   {\n+     /* HAVE_return is testing for USE_RETURN_INSN (FALSE).  Hence,\n+        no need for explicit testing again.  */\n+     emit_jump_insn (gen_return ());\n+   }\n+  else if (TARGET_32BIT)\n+   {\n+    arm_expand_epilogue (true);\n+   }\n   DONE;\n   \"\n )\n@@ -10571,22 +10578,14 @@\n ;; to add an unspec of the link register to ensure that flow\n ;; does not think that it is unused by the sibcall branch that\n ;; will replace the standard function epilogue.\n-(define_insn \"sibcall_epilogue\"\n-  [(parallel [(unspec:SI [(reg:SI LR_REGNUM)] UNSPEC_PROLOGUE_USE)\n-              (unspec_volatile [(return)] VUNSPEC_EPILOGUE)])]\n-  \"TARGET_32BIT\"\n-  \"*\n-  if (use_return_insn (FALSE, next_nonnote_insn (insn)))\n-    return output_return_instruction (const_true_rtx, FALSE, FALSE);\n-  return arm_output_epilogue (next_nonnote_insn (insn));\n-  \"\n-;; Length is absolute worst case\n-  [(set_attr \"length\" \"44\")\n-   (set_attr \"type\" \"block\")\n-   ;; We don't clobber the conditions, but the potential length of this\n-   ;; operation is sufficient to make conditionalizing the sequence \n-   ;; unlikely to be profitable.\n-   (set_attr \"conds\" \"clob\")]\n+(define_expand \"sibcall_epilogue\"\n+   [(parallel [(unspec:SI [(reg:SI LR_REGNUM)] UNSPEC_PROLOGUE_USE)\n+               (unspec_volatile [(return)] VUNSPEC_EPILOGUE)])]\n+   \"TARGET_32BIT\"\n+   \"\n+   arm_expand_epilogue (false);\n+   DONE;\n+   \"\n )\n \n (define_insn \"*epilogue_insns\""}]}