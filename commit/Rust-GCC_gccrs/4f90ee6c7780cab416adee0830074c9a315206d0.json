{"sha": "4f90ee6c7780cab416adee0830074c9a315206d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY5MGVlNmM3NzgwY2FiNDE2YWRlZTA4MzAwNzRjOWEzMTUyMDZkMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-01-10T12:56:28Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-01-10T12:56:28Z"}, "message": "re PR fortran/67779 (Strange ordering with strings in extended object)\n\n2016-01-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67779\n\t* trans_array.c (gfc_conv_scalarized_array_ref): Add missing\n\tse->use_offset from condition for calculation of 'base'.\n\n2016-01-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67779\n\t* gfortran.dg/actual_array_offset_1: New test.\n\nFrom-SVN: r232200", "tree": {"sha": "8db8d7d0db37f77d9cc1bcaaff023ba63e0748a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8db8d7d0db37f77d9cc1bcaaff023ba63e0748a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f90ee6c7780cab416adee0830074c9a315206d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f90ee6c7780cab416adee0830074c9a315206d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f90ee6c7780cab416adee0830074c9a315206d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f90ee6c7780cab416adee0830074c9a315206d0/comments", "author": null, "committer": null, "parents": [{"sha": "3907c6cf931af4e874cb217addd29b24063b6367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3907c6cf931af4e874cb217addd29b24063b6367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3907c6cf931af4e874cb217addd29b24063b6367"}], "stats": {"total": 180, "additions": 179, "deletions": 1}, "files": [{"sha": "c38c28038d3aae1cac4e90274c79bac51fd45630", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4f90ee6c7780cab416adee0830074c9a315206d0", "patch": "@@ -1,3 +1,9 @@\n+2016-01-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67779\n+\t* trans_array.c (gfc_conv_scalarized_array_ref): Add missing\n+\tse->use_offset from condition for calculation of 'base'.\n+\n 2016-01-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/69128"}, {"sha": "a46f1034777975002d39edd35989f5515b0db122", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4f90ee6c7780cab416adee0830074c9a315206d0", "patch": "@@ -7114,7 +7114,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t    gfc_array_index_type,\n \t\t\t\t    stride, info->stride[n]);\n \n-\t  if (se->direct_byref\n+\t  if ((se->direct_byref || se->use_offset)\n \t      && ((info->ref && info->ref->u.ar.type != AR_FULL)\n \t\t  || (expr->expr_type == EXPR_ARRAY && se->use_offset)))\n \t    {"}, {"sha": "6ab64f74cc354f58085d8a5e6a906b71f5957998", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f90ee6c7780cab416adee0830074c9a315206d0", "patch": "@@ -1,3 +1,8 @@\n+2016-01-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67779\n+\t* gfortran.dg/actual_array_offset_1: New test.\n+\n 2016-01-10  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/69062"}, {"sha": "f67bcfd9651536c2d3c43d615c87722c79ccbd23", "filename": "gcc/testsuite/gfortran.dg/actual_array_offset_1.f90", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_offset_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f90ee6c7780cab416adee0830074c9a315206d0/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_offset_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_offset_1.f90?ref=4f90ee6c7780cab416adee0830074c9a315206d0", "patch": "@@ -0,0 +1,167 @@\n+! { dg-do run }\n+!\n+! Check the fix for PR67779, in which array sections passed in the\n+! recursive calls to 'quicksort' had an incorrect offset.\n+!\n+! Contributed by Arjen Markus  <arjen.markus895@gmail.com>\n+!\n+! NOTE: This is the version of the testcase in comment #16 (from Thomas Koenig)\n+!\n+module myclass_def\n+    implicit none\n+\n+    type, abstract :: myclass\n+    contains\n+        procedure(assign_object), deferred        :: copy\n+        procedure(one_lower_than_two), deferred   :: lower\n+        procedure(print_object), deferred         :: print\n+        procedure, nopass                         :: quicksort  ! without nopass, it does not work\n+    end type myclass\n+\n+    abstract interface\n+        subroutine assign_object( left, right )\n+            import                        :: myclass\n+            class(myclass), intent(inout) :: left\n+            class(myclass), intent(in)    :: right\n+        end subroutine assign_object\n+    end interface\n+\n+    abstract interface\n+        logical function one_lower_than_two( op1, op2 )\n+            import                     :: myclass\n+            class(myclass), intent(in) :: op1, op2\n+        end function one_lower_than_two\n+    end interface\n+\n+    abstract interface\n+        subroutine print_object( obj )\n+            import                     :: myclass\n+            class(myclass), intent(in) :: obj\n+        end subroutine print_object\n+    end interface\n+\n+    !\n+    ! Type containing a real\n+    !\n+\n+    type, extends(myclass) :: mysortable\n+        integer :: value\n+    contains\n+        procedure :: copy    => copy_sortable\n+        procedure :: lower   => lower_sortable\n+        procedure :: print   => print_sortable\n+    end type mysortable\n+\n+contains\n+!\n+! Generic part\n+!\n+recursive subroutine quicksort( array )\n+    class(myclass), dimension(:) :: array\n+\n+    class(myclass), allocatable :: v, tmp\n+    integer                     :: i, j\n+\n+    integer :: k\n+\n+    i = 1\n+    j = size(array)\n+\n+    allocate( v,   source = array(1) )\n+    allocate( tmp, source = array(1) )\n+\n+    call v%copy( array((j+i)/2) ) ! Use the middle element\n+\n+    do\n+        do while ( array(i)%lower(v) )\n+            i = i + 1\n+        enddo\n+        do while ( v%lower(array(j)) )\n+            j = j - 1\n+        enddo\n+\n+        if ( i <= j ) then\n+            call tmp%copy( array(i) )\n+            call array(i)%copy( array(j) )\n+            call array(j)%copy( tmp )\n+            i        = i + 1\n+            j        = j - 1\n+        endif\n+\n+        if ( i > j ) then\n+            exit\n+        endif\n+    enddo\n+\n+    if ( 1 < j ) then\n+        call quicksort( array(1:j) ) ! Problem here\n+    endif\n+\n+    if ( i < size(array) ) then\n+        call quicksort( array(i:) )  ! ....and here\n+    endif\n+end subroutine quicksort\n+\n+!\n+! Specific part\n+!\n+subroutine copy_sortable( left, right )\n+    class(mysortable), intent(inout) :: left\n+    class(myclass), intent(in)       :: right\n+\n+    select type (right)\n+        type is (mysortable)\n+            select type (left)\n+                type is (mysortable)\n+                    left = right\n+            end select\n+    end select\n+end subroutine copy_sortable\n+\n+logical function lower_sortable( op1, op2 )\n+    class(mysortable), intent(in) :: op1\n+    class(myclass),    intent(in) :: op2\n+\n+    select type (op2)\n+        type is (mysortable)\n+            lower_sortable = op1%value < op2%value\n+    end select\n+end function lower_sortable\n+\n+subroutine print_sortable( obj )\n+    class(mysortable), intent(in) :: obj\n+\n+    write(*,'(G0,\" \")', advance=\"no\") obj%value\n+end subroutine print_sortable\n+\n+end module myclass_def\n+\n+\n+! test program\n+program test_quicksort\n+    use myclass_def\n+\n+    implicit none\n+\n+    type(mysortable), dimension(20) :: array\n+    real, dimension(20) :: values\n+\n+    call random_number(values)\n+\n+    array%value = int (1000000 * values)\n+\n+! It would be pretty perverse if this failed!\n+    if (check (array)) call abort\n+\n+    call quicksort( array )\n+\n+! Check the the array is correctly ordered\n+    if (.not.check (array)) call abort\n+contains\n+     logical function check (arg)\n+         type(mysortable), dimension(:) :: arg\n+         integer                        :: s\n+         s = size (arg, 1)\n+         check = all (arg(2 : s)%value .ge. arg(1 : s - 1)%value)\n+     end function check\n+end program test_quicksort"}]}