{"sha": "6ec73c7cc8bba8fa653d12bccf399623231059b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVjNzNjN2NjOGJiYThmYTY1M2QxMmJjY2YzOTk2MjMyMzEwNTliOA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-01T00:21:14Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-01T00:21:14Z"}, "message": "loop.c (loop_bivs_find): Break out from strength_reduce.\n\n\t* loop.c (loop_bivs_find): Break out from strength_reduce.\n\t(loop_bivs_init_find, loop_bivs_check, loop_givs_find): Likewise.\n\t(loop_givs_check, loop_biv_eliminable_p): Likewise.\n\nFrom-SVN: r38577", "tree": {"sha": "cec27c0d221a1eb8c5791dfecbd56fa2ec23f120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cec27c0d221a1eb8c5791dfecbd56fa2ec23f120"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ec73c7cc8bba8fa653d12bccf399623231059b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec73c7cc8bba8fa653d12bccf399623231059b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec73c7cc8bba8fa653d12bccf399623231059b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec73c7cc8bba8fa653d12bccf399623231059b8/comments", "author": null, "committer": null, "parents": [{"sha": "b8056b46cd76fc0ad5b493b3f9e71d8d0e8236c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8056b46cd76fc0ad5b493b3f9e71d8d0e8236c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8056b46cd76fc0ad5b493b3f9e71d8d0e8236c3"}], "stats": {"total": 310, "additions": 208, "deletions": 102}, "files": [{"sha": "cd7a9f3981f26b4dd3e2adeca6d168431c7c966f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec73c7cc8bba8fa653d12bccf399623231059b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec73c7cc8bba8fa653d12bccf399623231059b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ec73c7cc8bba8fa653d12bccf399623231059b8", "patch": "@@ -1,5 +1,11 @@\n 2001-01-01  Michael Hayes  <mhayes@redhat.com>\n \n+\t* loop.c (loop_bivs_find): Break out from strength_reduce.\n+\t(loop_bivs_init_find, loop_bivs_check, loop_givs_find): Likewise.\n+\t(loop_givs_check, loop_biv_eliminable_p): Likewise.\n+\t\n+2001-01-01  Michael Hayes  <mhayes@redhat.com>\t\n+\n \t* loop.c (LOOP_REG_LIFETIME, LOOP_REG_GLOBAL_P): Define.\n \t(scan_loop, record_giv): Use LOOP_REG_LIFETIME and LOOP_REG_GLOBAL_P.\n \t"}, {"sha": "0a11c54d9e675dd2a40b6fc8e0e0c96446841749", "filename": "gcc/loop.c", "status": "modified", "additions": 202, "deletions": 102, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec73c7cc8bba8fa653d12bccf399623231059b8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec73c7cc8bba8fa653d12bccf399623231059b8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6ec73c7cc8bba8fa653d12bccf399623231059b8", "patch": "@@ -181,6 +181,13 @@ static void loop_movables_add PARAMS((struct loop_movables *,\n \t\t\t\t      struct movable *));\n static void loop_movables_free PARAMS((struct loop_movables *));\n static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n+static void loop_bivs_find PARAMS((struct loop *));\n+static void loop_bivs_init_find PARAMS((struct loop *));\n+static void loop_bivs_check PARAMS((struct loop *));\n+static void loop_givs_find PARAMS((struct loop *));\n+static void loop_givs_check PARAMS((struct loop *));\n+static void loop_biv_eliminable_p PARAMS((struct loop *, struct iv_class *,\n+\t\t\t\t\t  int, int));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n static int valid_initial_value_p PARAMS ((rtx, rtx, int, rtx));\n@@ -3621,66 +3628,30 @@ for_each_insn_in_loop (loop, fncall)\n     }\n }\n \f\n-/* Perform strength reduction and induction variable elimination.\n-\n-   Pseudo registers created during this function will be beyond the\n-   last valid index in several tables including regs->n_times_set and\n-   regno_last_uid.  This does not cause a problem here, because the\n-   added registers cannot be givs outside of their loop, and hence\n-   will never be reconsidered.  But scan_loop must check regnos to\n-   make sure they are in bounds.  */\n-\n static void\n-strength_reduce (loop, insn_count, flags)\n+loop_bivs_find (loop)\n      struct loop *loop;\n-     int insn_count;\n-     int flags;\n {\n-  struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n-  rtx p;\n   /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n      and more registers are available.  */\n   /* ??? could set this to last value of threshold in move_movables */\n-  int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n-  /* Map of pseudo-register replacements.  */\n-  rtx *reg_map = NULL;\n-  int reg_map_size;\n-  int call_seen;\n-  rtx test;\n-  rtx end_insert_before;\n-  int unrolled_insn_copies = 0;\n-  rtx loop_start = loop->start;\n-  rtx loop_end = loop->end;\n-  rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n+\n+  ivs->loop_iv_list = 0;\n \n   VARRAY_INT_INIT (ivs->reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n-  VARRAY_GENERIC_PTR_INIT (ivs->reg_iv_info, max_reg_before_loop, \"reg_iv_info\");\n+  VARRAY_GENERIC_PTR_INIT (ivs->reg_iv_info, max_reg_before_loop,\n+\t\t\t   \"reg_iv_info\");\n   ivs->reg_biv_class = (struct iv_class **)\n     xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n \n-  ivs->loop_iv_list = 0;\n-  addr_placeholder = gen_reg_rtx (Pmode);\n-\n-  /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n-     must be put before this insn, so that they will appear in the right\n-     order (i.e. loop order).\n-\n-     If loop_end is the end of the current function, then emit a\n-     NOTE_INSN_DELETED after loop_end and set end_insert_before to the\n-     dummy note insn.  */\n-  if (NEXT_INSN (loop_end) != 0)\n-    end_insert_before = NEXT_INSN (loop_end);\n-  else\n-    end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop_end);\n-\n   for_each_insn_in_loop (loop, check_insn_for_bivs);\n-\n+  \n   /* Scan ivs->loop_iv_list to remove all regs that proved not to be bivs.\n      Make a sanity check against regs->n_times_set.  */\n   for (backbl = &ivs->loop_iv_list, bl = *backbl; bl; bl = bl->next)\n@@ -3712,17 +3683,20 @@ strength_reduce (loop, insn_count, flags)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv verified\\n\", bl->regno);\n \t}\n     }\n+}\n \n-  /* Exit if there are no bivs.  */\n-  if (! ivs->loop_iv_list)\n-    {\n-      /* Can still unroll the loop anyways, but indicate that there is no\n-\t strength reduction info available.  */\n-      if (flags & LOOP_UNROLL)\n-\tunroll_loop (loop, insn_count, end_insert_before, 0);\n \n-      goto egress;\n-    }\n+/* Determine how BIVS are initialised by looking through pre-header\n+   extended basic block.  */\n+static void\n+loop_bivs_init_find (loop)\n+     struct loop *loop;\n+{\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  struct iv_class *bl;\n+  basic_block ebb;\n \n   /* Find initial value for each biv by searching backwards from loop_start,\n      halting at first label.  Also record any test condition.  */\n@@ -3762,10 +3736,21 @@ strength_reduce (loop, insn_count, flags)\n \t    bl->initial_test = test;\n \t}\n     }\n+}\n+\n+\n+/* Look at the each biv and see if we can say anything better about its\n+   initial value from any initializing insns set up above.  (This is done\n+   in two passes to avoid missing SETs in a PARALLEL.)  */\n+static void\n+loop_bivs_check (loop)\n+     struct loop *loop;\n+{\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  struct iv_class *bl;\n+  struct iv_class **backbl;\n \n-  /* Look at the each biv and see if we can say anything better about its\n-     initial value from any initializing insns set up above.  (This is done\n-     in two passes to avoid missing SETs in a PARALLEL.)  */\n   for (backbl = &ivs->loop_iv_list; (bl = *backbl); backbl = &bl->next)\n     {\n       rtx src;\n@@ -3791,15 +3776,16 @@ strength_reduce (loop, insn_count, flags)\n \n       if ((GET_MODE (src) == GET_MODE (regno_reg_rtx[bl->regno])\n \t   || GET_MODE (src) == VOIDmode)\n-\t  && valid_initial_value_p (src, bl->init_insn, call_seen, loop_start))\n+\t  && valid_initial_value_p (loop, src, bl->init_insn))\n \t{\n \t  bl->initial_value = src;\n \n \t  if (loop_dump_stream)\n \t    {\n \t      if (GET_CODE (src) == CONST_INT)\n \t\t{\n-\t\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (src));\n+\t\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, \n+\t\t\t   INTVAL (src));\n \t\t  fputc ('\\n', loop_dump_stream);\n \t\t}\n \t      else\n@@ -3810,26 +3796,33 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t}\n       /* If we can't make it a giv,\n-       let biv keep initial value of \"itself\".  */\n+\t let biv keep initial value of \"itself\".  */\n       else if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"is complex\\n\");\n     }\n+}\n \n-  /* Search the loop for general induction variables.  */\n \n+/* Search the loop for general induction variables.  */\n+\n+static void\n+loop_givs_find (loop)\n+     struct loop* loop;\n+{\n   for_each_insn_in_loop (loop, check_insn_for_givs);\n+}\n \n-  /* Try to calculate and save the number of loop iterations.  This is\n-     set to zero if the actual number can not be calculated.  This must\n-     be called after all giv's have been identified, since otherwise it may\n-     fail if the iteration variable is a giv.  */\n \n-  loop_iterations (loop);\n+/* For each giv for which we still don't know whether or not it is\n+   replaceable, check to see if it is replaceable because its final value\n+   can be calculated.   */\n \n-  /* Now for each giv for which we still don't know whether or not it is\n-     replaceable, check to see if it is replaceable because its final value\n-     can be calculated.  This must be done after loop_iterations is called,\n-     so that final_giv_value will work correctly.  */\n+static void\n+loop_givs_check (loop)\n+     struct loop *loop;\n+{\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  struct iv_class *bl;\n \n   for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n     {\n@@ -3839,6 +3832,140 @@ strength_reduce (loop, insn_count, flags)\n \tif (! v->replaceable && ! v->not_replaceable)\n \t  check_final_value (loop, v);\n     }\n+}\n+\n+\n+static void\n+loop_biv_eliminable_p (loop, bl, threshold, insn_count)\n+     struct loop *loop;\n+     struct iv_class *bl;\n+     int threshold;\n+     int insn_count;\n+{\n+  /* Test whether it will be possible to eliminate this biv\n+     provided all givs are reduced.  This is possible if either\n+     the reg is not used outside the loop, or we can compute\n+     what its final value will be.\n+     \n+     For architectures with a decrement_and_branch_until_zero insn,\n+     don't do this if we put a REG_NONNEG note on the endtest for\n+     this biv.  */\n+  \n+  /* Compare against bl->init_insn rather than loop_start.\n+     We aren't concerned with any uses of the biv between\n+     init_insn and loop_start since these won't be affected\n+     by the value of the biv elsewhere in the function, so\n+     long as init_insn doesn't use the biv itself.\n+     March 14, 1989 -- self@bayes.arc.nasa.gov */\n+  \n+  if ((REGNO_LAST_LUID (bl->regno) < INSN_LUID (loop->end)\n+       && bl->init_insn\n+       && INSN_UID (bl->init_insn) < max_uid_for_loop\n+       && REGNO_FIRST_LUID (bl->regno) >= INSN_LUID (bl->init_insn)\n+#ifdef HAVE_decrement_and_branch_until_zero\n+       && ! bl->nonneg\n+#endif\n+       && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n+      || ((final_value = final_biv_value (loop, bl))\n+#ifdef HAVE_decrement_and_branch_until_zero\n+\t  && ! bl->nonneg\n+#endif\n+\t  ))\n+    return maybe_eliminate_biv (loop, bl, 0, threshold,\tinsn_count);\n+  else\n+    return 0;\n+}\n+\n+\n+/* Perform strength reduction and induction variable elimination.\n+\n+   Pseudo registers created during this function will be beyond the\n+   last valid index in several tables including regs->n_times_set and\n+   regno_last_uid.  This does not cause a problem here, because the\n+   added registers cannot be givs outside of their loop, and hence\n+   will never be reconsidered.  But scan_loop must check regnos to\n+   make sure they are in bounds.  */\n+\n+static void\n+strength_reduce (loop, insn_count, flags)\n+     struct loop *loop;\n+     int insn_count;\n+     int flags;\n+{\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_regs *regs = LOOP_REGS (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  rtx p;\n+  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  struct iv_class *bl, **backbl;\n+  /* Ratio of extra register life span we can justify\n+     for saving an instruction.  More if loop doesn't call subroutines\n+     since in that case saving an insn makes more difference\n+     and more registers are available.  */\n+  /* ??? could set this to last value of threshold in move_movables */\n+  int threshold = (loop_info->has_call ? 1 : 2) * (3 + n_non_fixed_regs);\n+  /* Map of pseudo-register replacements.  */\n+  rtx *reg_map = NULL;\n+  int reg_map_size;\n+  int call_seen;\n+  rtx test;\n+  rtx end_insert_before;\n+  int unrolled_insn_copies = 0;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n+\n+  addr_placeholder = gen_reg_rtx (Pmode);\n+\n+  /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n+     must be put before this insn, so that they will appear in the right\n+     order (i.e. loop order).\n+\n+     If loop_end is the end of the current function, then emit a\n+     NOTE_INSN_DELETED after loop_end and set end_insert_before to the\n+     dummy note insn.  */\n+  if (NEXT_INSN (loop_end) != 0)\n+    end_insert_before = NEXT_INSN (loop_end);\n+  else\n+    end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop_end);\n+\n+\n+  /* Find all BIVs in loop.  */\n+  loop_bivs_find (loop);\n+\n+  /* Exit if there are no bivs.  */\n+  if (! ivs->loop_iv_list)\n+    {\n+      /* Can still unroll the loop anyways, but indicate that there is no\n+\t strength reduction info available.  */\n+      if (flags & LOOP_UNROLL)\n+\tunroll_loop (loop, insn_count, end_insert_before, 0);\n+\n+      goto egress;\n+    }\n+\n+  /* Determine how BIVS are initialised by looking through pre-header\n+     extended basic block.  */\n+  loop_bivs_init_find (loop);\n+\n+  /* Look at the each biv and see if we can say anything better about its\n+     initial value from any initializing insns set up above.  */\n+  loop_bivs_check (loop);\n+\n+  /* Search the loop for general induction variables.  */\n+  loop_givs_find (loop);\n+\n+  /* Try to calculate and save the number of loop iterations.  This is\n+     set to zero if the actual number can not be calculated.  This must\n+     be called after all giv's have been identified, since otherwise it may\n+     fail if the iteration variable is a giv.  */\n+  loop_iterations (loop);\n+\n+  /* Now for each giv for which we still don't know whether or not it is\n+     replaceable, check to see if it is replaceable because its final value\n+     can be calculated.  This must be done after loop_iterations is called,\n+     so that final_giv_value will work correctly.  */\n+  loop_givs_check (loop);\n \n   /* Try to prove that the loop counter variable (if any) is always\n      nonnegative; if so, record that fact with a REG_NONNEG note\n@@ -3860,39 +3987,11 @@ strength_reduce (loop, insn_count, flags)\n       int benefit;\n       int all_reduced;\n       rtx final_value = 0;\n-\n+      \n       /* Test whether it will be possible to eliminate this biv\n-\t provided all givs are reduced.  This is possible if either\n-\t the reg is not used outside the loop, or we can compute\n-\t what its final value will be.\n-\n-\t For architectures with a decrement_and_branch_until_zero insn,\n-\t don't do this if we put a REG_NONNEG note on the endtest for\n-\t this biv.  */\n-\n-      /* Compare against bl->init_insn rather than loop_start.\n-\t We aren't concerned with any uses of the biv between\n-\t init_insn and loop_start since these won't be affected\n-\t by the value of the biv elsewhere in the function, so\n-\t long as init_insn doesn't use the biv itself.\n-\t March 14, 1989 -- self@bayes.arc.nasa.gov */\n-\n-      if ((REGNO_LAST_LUID (bl->regno) < INSN_LUID (loop_end)\n-\t   && bl->init_insn\n-\t   && INSN_UID (bl->init_insn) < max_uid_for_loop\n-\t   && REGNO_FIRST_LUID (bl->regno) >= INSN_LUID (bl->init_insn)\n-#ifdef HAVE_decrement_and_branch_until_zero\n-\t   && ! bl->nonneg\n-#endif\n-\t   && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n-\t  || ((final_value = final_biv_value (loop, bl))\n-#ifdef HAVE_decrement_and_branch_until_zero\n-\t      && ! bl->nonneg\n-#endif\n-\t      ))\n-\tbl->eliminable = maybe_eliminate_biv (loop, bl, 0, threshold,\n-\t\t\t\t\t      insn_count);\n-      else\n+\t provided all givs are reduced.  */\n+      if (!(bl->eliminable = loop_biv_eliminable_p (loop, bl, \n+\t\t\t\t\t\t    threshold, insn_count)))\n \t{\n \t  if (loop_dump_stream)\n \t    {\n@@ -3906,7 +4005,7 @@ strength_reduce (loop, insn_count, flags)\n \t    }\n \t}\n \n-      /* Check each extension dependant giv in this class to see if its\n+      /* Check each extension dependent giv in this class to see if its\n \t root biv is safe from wrapping in the interior mode.  */\n       check_ext_dependant_givs (bl, loop_info);\n \n@@ -3997,8 +4096,9 @@ strength_reduce (loop, insn_count, flags)\n \t     of such giv's whether or not we know they are used after the loop\n \t     exit.  */\n \n-\t  if ( ! flag_reduce_all_givs && v->lifetime * threshold * benefit < insn_count\n-\t      && ! bl->reversed )\n+\t  if (! flag_reduce_all_givs\n+\t      && v->lifetime * threshold * benefit < insn_count\n+\t      && ! bl->reversed)\n \t    {\n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream,"}]}