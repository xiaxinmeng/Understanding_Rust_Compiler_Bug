{"sha": "5add6d1a6d7221a24424c78a6eff9981e281043c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkZDZkMWE2ZDcyMjFhMjQ0MjRjNzhhNmVmZjk5ODFlMjgxMDQzYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2002-04-03T03:21:29Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-04-03T03:21:29Z"}, "message": "combine.c (simplify_comparison): Avoid narrowing a comparison with a paradoxical subreg when...\n\n\t* combine.c (simplify_comparison): Avoid narrowing a comparison\n\twith a paradoxical subreg when doing so would drop signficant bits.\n\nCo-Authored-By: Hans-Peter Nilsson <hp@bitrange.com>\n\nFrom-SVN: r51785", "tree": {"sha": "81d13ae636c1c2ef3fc57e33050a792f8398c3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81d13ae636c1c2ef3fc57e33050a792f8398c3e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5add6d1a6d7221a24424c78a6eff9981e281043c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5add6d1a6d7221a24424c78a6eff9981e281043c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5add6d1a6d7221a24424c78a6eff9981e281043c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5add6d1a6d7221a24424c78a6eff9981e281043c/comments", "author": null, "committer": null, "parents": [{"sha": "2e839a04cf14dadf85f376c4e2c6ba13945ff73b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e839a04cf14dadf85f376c4e2c6ba13945ff73b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e839a04cf14dadf85f376c4e2c6ba13945ff73b"}], "stats": {"total": 70, "additions": 47, "deletions": 23}, "files": [{"sha": "ed2f08343946f24ea6ae702f9065ddff6b805209", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5add6d1a6d7221a24424c78a6eff9981e281043c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5add6d1a6d7221a24424c78a6eff9981e281043c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5add6d1a6d7221a24424c78a6eff9981e281043c", "patch": "@@ -1,3 +1,9 @@\n+2002-04-03  Jeffrey A Law  (law@redhat.com)\n+            Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* combine.c (simplify_comparison): Avoid narrowing a comparison\n+\twith a paradoxical subreg when doing so would drop signficant bits.\n+\n 2002-04-02  Steve Ellcey  <sje@cup.hp.com>\n \n \t* builtins.c (expand_builtin_prefetch): Force op0 pointer to Pmode"}, {"sha": "9a9d6484f565af85ce284c0210174070d3967807", "filename": "gcc/combine.c", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5add6d1a6d7221a24424c78a6eff9981e281043c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5add6d1a6d7221a24424c78a6eff9981e281043c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5add6d1a6d7221a24424c78a6eff9981e281043c", "patch": "@@ -10955,38 +10955,56 @@ simplify_comparison (code, pop0, pop1)\n \n   /* Now make any compound operations involved in this comparison.  Then,\n      check for an outmost SUBREG on OP0 that is not doing anything or is\n-     paradoxical.  The latter case can only occur when it is known that the\n-     \"extra\" bits will be zero.  Therefore, it is safe to remove the SUBREG.\n-     We can never remove a SUBREG for a non-equality comparison because the\n-     sign bit is in a different place in the underlying object.  */\n+     paradoxical.  The latter transformation must only be performed when\n+     it is known that the \"extra\" bits will be the same in op0 and op1 or\n+     that they don't matter.  There are three cases to consider:\n+\n+     1. SUBREG_REG (op0) is a register.  In this case the bits are don't\n+     care bits and we can assume they have any convenient value.  So\n+     making the transformation is safe.\n+\n+     2. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is not defined.\n+     In this case the upper bits of op0 are undefined.  We should not make\n+     the simplification in that case as we do not know the contents of\n+     those bits.\n+\n+     3. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is defined and not\n+     NIL.  In that case we know those bits are zeros or ones.  We must\n+     also be sure that they are the same as the upper bits of op1.\n+\n+     We can never remove a SUBREG for a non-equality comparison because\n+     the sign bit is in a different place in the underlying object.  */\n \n   op0 = make_compound_operation (op0, op1 == const0_rtx ? COMPARE : SET);\n   op1 = make_compound_operation (op1, SET);\n \n   if (GET_CODE (op0) == SUBREG && subreg_lowpart_p (op0)\n+      /* Case 3 above, to sometimes allow (subreg (mem x)), isn't\n+\t implemented.  */\n+      && GET_CODE (SUBREG_REG (op0)) == REG\n       && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n       && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op0))) == MODE_INT\n-      && (code == NE || code == EQ)\n-      && ((GET_MODE_SIZE (GET_MODE (op0))\n-\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))))))\n+      && (code == NE || code == EQ))\n     {\n-      op0 = SUBREG_REG (op0);\n-      op1 = gen_lowpart_for_combine (GET_MODE (op0), op1);\n-    }\n+      if (GET_MODE_SIZE (GET_MODE (op0))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))))\n+\t{\n+\t  op0 = SUBREG_REG (op0);\n+\t  op1 = gen_lowpart_for_combine (GET_MODE (op0), op1);\n+\t}\n+      else if ((GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n+\t\t<= HOST_BITS_PER_WIDE_INT)\n+\t       && (nonzero_bits (SUBREG_REG (op0),\n+\t\t\t\t GET_MODE (SUBREG_REG (op0)))\n+\t\t   & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+\t{\n+\t  tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)), op1);\n \n-  else if (GET_CODE (op0) == SUBREG && subreg_lowpart_p (op0)\n-\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op0))) == MODE_INT\n-\t   && (code == NE || code == EQ)\n-\t   && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n-\t       <= HOST_BITS_PER_WIDE_INT)\n-\t   && (nonzero_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n-\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0\n-\t   && (tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)),\n-\t\t\t\t\t      op1),\n-\t       (nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n-\t\t& ~GET_MODE_MASK (GET_MODE (op0))) == 0))\n-    op0 = SUBREG_REG (op0), op1 = tem;\n+\t  if ((nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n+\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0)\n+\t    op0 = SUBREG_REG (op0), op1 = tem;\n+\t}\n+    }\n \n   /* We now do the opposite procedure: Some machines don't have compare\n      insns in all modes.  If OP0's mode is an integer mode smaller than a"}]}