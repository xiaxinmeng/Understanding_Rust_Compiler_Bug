{"sha": "d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlY2RhMjc4NWI3M2RhNmE0YmUyMmViY2E1ZDAzYTdjYzFhYWU5MA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-10T22:03:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-10T22:03:36Z"}, "message": "lcm.c: New file.\n\n        * lcm.c: New file.\n        * Makefile.in (OBJS): Add lcm.o\n        (lcm.o): Add dependencies.\n\nFrom-SVN: r25679", "tree": {"sha": "f7c6e412c7450d01e77ee4b7ba7b207d0d2b713a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c6e412c7450d01e77ee4b7ba7b207d0d2b713a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/comments", "author": null, "committer": null, "parents": [{"sha": "3524fe03395ca14f1ab9d86addef627c275c1be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3524fe03395ca14f1ab9d86addef627c275c1be6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3524fe03395ca14f1ab9d86addef627c275c1be6"}], "stats": {"total": 807, "additions": 806, "deletions": 1}, "files": [{"sha": "215fe7ac61fbfb958aaa9a9caa9726feb06a47f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "patch": "@@ -22,6 +22,10 @@ Wed Mar 10 23:11:19 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Wed Mar 10 20:28:29 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* lcm.c: New file.\n+\t* Makefile.in (OBJS): Add lcm.o\n+\t(lcm.o): Add dependencies.\n+\n \t* gcse.c (compute_pre_local_properties): Delete.\n \t(compute_pre_data): Use compute_local_properties instead of\n \tcompute_pre_local_properties."}, {"sha": "49322d5f79126a2579b3403ea3902cebf4c9b0a6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "patch": "@@ -676,7 +676,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o varray.o \\\n  regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n- insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n+ insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o\n \n@@ -1505,6 +1505,8 @@ gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h\n+lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n+   real.h insn-config.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h insn-config.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h loop.h insn-config.h \\"}, {"sha": "01367e36d5c24e9e33db3587d16540b77b5b0988", "filename": "gcc/lcm.c", "status": "added", "additions": 799, "deletions": 0, "changes": 799, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ecda2785b73da6a4be22ebca5d03a7cc1aae90/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=d2ecda2785b73da6a4be22ebca5d03a7cc1aae90", "patch": "@@ -0,0 +1,799 @@\n+/* Generic partial redundancy elimination with lazy code motion\n+   support.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* These routines are meant to be used by various optimization\n+   passes which can be modeled as lazy code motion problems. \n+   Including, but not limited to:\n+\n+\t* Traditional partial redundancy elimination.\n+\n+\t* Placement of caller/caller register save/restores.\n+\n+\t* Load/store motion.\n+\n+\t* Copy motion.\n+\n+\t* Conversion of flat register files to a stacked register\n+\tmodel.\n+\n+\t* Dead load/store elimination.\n+\n+  These routines accept as input:\n+\n+\t* Basic block information (number of blocks, lists of\n+\tpredecessors and successors).  Note the granularity\n+\tdoes not need to be basic block, they could be statements\n+\tor functions.\n+\n+\t* Bitmaps of local properties (computed, transparent and\n+\tanticipatable expressions).\n+\n+  The output of these routines is bitmap of redundant computations\n+  and a bitmap of optimal placement points.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"basic-block.h\"\n+\n+static void compute_antinout \tPROTO ((int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n+static void compute_earlyinout\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n+static void compute_delayinout  PROTO ((int, int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *));\n+static void compute_latein\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *));\n+static void compute_isoinout\tPROTO ((int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n+static void compute_optimal\tPROTO ((int, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *));\n+static void compute_redundant\tPROTO ((int, int, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n+\n+/* Similarly, but for the reversed flowgraph.  */\n+static void compute_avinout \tPROTO ((int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *, sbitmap *));\n+static void compute_fartherinout\tPROTO ((int, int, int_list_ptr *,\n+\t\t\t\t\t\tsbitmap *, sbitmap *,\n+\t\t\t\t\t\tsbitmap *, sbitmap *));\n+static void compute_earlierinout  PROTO ((int, int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\t  sbitmap *, sbitmap *,\n+\t\t\t\t\t  sbitmap *, sbitmap *));\n+static void compute_firstout\tPROTO ((int, int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\tsbitmap *, sbitmap *));\n+static void compute_rev_isoinout PROTO ((int, int_list_ptr *, sbitmap *,\n+\t\t\t\t\t sbitmap *, sbitmap *, sbitmap *));\n+\n+/* Given local properties TRANSP, ANTLOC, return the redundant and optimal\n+   computation points for expressions.\n+\n+   To reduce overall memory consumption, we allocate memory immediately\n+   before its needed and deallocate it as soon as possible.  */\n+void\n+pre_lcm (n_blocks, n_exprs, s_preds, s_succs, transp,\n+\t antloc, redundant, optimal)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     sbitmap *transp;\n+     sbitmap *antloc;\n+     sbitmap *redundant;\n+     sbitmap *optimal;\n+{\n+  sbitmap *antin, *antout, *earlyin, *earlyout, *delayin, *delayout;\n+  sbitmap *latein, *isoin, *isoout;\n+\n+  /* Compute global anticipatability.  ANTOUT is not needed except to\n+     compute ANTIN, so free its memory as soon as we return from\n+     compute_antinout.  */\n+  antin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  antout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_antinout (n_blocks, s_succs, antloc,\n+\t\t    transp, antin, antout);\n+  free (antout);\n+  antout = NULL;\n+\n+  /* Compute earliestness.  EARLYOUT is not needed except to compute\n+     EARLYIN, so free its memory as soon as we return from\n+     compute_earlyinout.  */\n+  earlyin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  earlyout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_earlyinout (n_blocks, n_exprs, s_preds, transp, antin,\n+\t\t      earlyin, earlyout);\n+  free (earlyout);\n+  earlyout = NULL;\n+\n+  /* Compute delayedness.  DELAYOUT is not needed except to compute\n+     DELAYIN, so free its memory as soon as we return from\n+     compute_delayinout.  We also no longer need ANTIN and EARLYIN.  */\n+  delayin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  delayout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_delayinout (n_blocks, n_exprs, s_preds, antloc,\n+\t\t      antin, earlyin, delayin, delayout);\n+  free (delayout);\n+  delayout = NULL;\n+  free (antin);\n+  antin = NULL;\n+  free (earlyin);\n+  earlyin = NULL;\n+\n+  /* Compute latestness.  We no longer need DELAYIN after we compute\n+     LATEIN.  */\n+  latein = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_latein (n_blocks, n_exprs, s_succs, antloc, delayin, latein);\n+  free (delayin);\n+  delayin = NULL;\n+\n+  /* Compute isolatedness.  ISOIN is not needed except to compute\n+     ISOOUT, so free its memory as soon as we return from\n+     compute_isoinout.  */\n+  isoin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  isoout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_isoinout (n_blocks, s_succs, antloc, latein, isoin, isoout);\n+  free (isoin);\n+  isoin = NULL;\n+\n+  /* Now compute optimal placement points and the redundant expressions.  */\n+  compute_optimal (n_blocks, latein, isoout, optimal);\n+  compute_redundant (n_blocks, n_exprs, antloc, latein, isoout, redundant);\n+  free (latein);\n+  latein = NULL;\n+  free (isoout);\n+  isoout = NULL;\n+}\n+\n+/* Given local properties TRANSP, AVLOC, return the redundant and optimal\n+   computation points for expressions on the reverse flowgraph.\n+\n+   To reduce overall memory consumption, we allocate memory immediately\n+   before its needed and deallocate it as soon as possible.  */\n+\n+void\n+pre_rev_lcm (n_blocks, n_exprs, s_preds, s_succs, transp,\n+\t     avloc, redundant, optimal)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     sbitmap *transp;\n+     sbitmap *avloc;\n+     sbitmap *redundant;\n+     sbitmap *optimal;\n+{\n+  sbitmap *avin, *avout, *fartherin, *fartherout, *earlierin, *earlierout;\n+  sbitmap *firstout, *rev_isoin, *rev_isoout;\n+\n+  /* Compute global availability.  AVIN is not needed except to\n+     compute AVOUT, so free its memory as soon as we return from\n+     compute_avinout.  */\n+  avin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  avout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_avinout (n_blocks, s_preds, avloc, transp, avin, avout);\n+  free (avin);\n+  avin = NULL;\n+\n+  /* Compute fartherness.  FARTHERIN is not needed except to compute\n+     FARTHEROUT, so free its memory as soon as we return from\n+     compute_earlyinout.  */\n+  fartherin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  fartherout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_fartherinout (n_blocks, n_exprs, s_succs, transp,\n+\t\t\tavout, fartherin, fartherout);\n+  free (fartherin);\n+  fartherin = NULL;\n+\n+  /* Compute earlierness.  EARLIERIN is not needed except to compute\n+     EARLIEROUT, so free its memory as soon as we return from\n+     compute_delayinout.  We also no longer need AVOUT and FARTHEROUT.  */\n+  earlierin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  earlierout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_earlierinout (n_blocks, n_exprs, s_succs, avloc,\n+\t\t        avout, fartherout, earlierin, earlierout);\n+  free (earlierin);\n+  earlierin = NULL;\n+  free (avout);\n+  avout = NULL;\n+  free (fartherout);\n+  fartherout = NULL;\n+\n+  /* Compute firstness.  We no longer need EARLIEROUT after we compute\n+     FIRSTOUT.  */\n+  firstout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_firstout (n_blocks, n_exprs, s_preds, avloc, earlierout, firstout);\n+  free (earlierout);\n+  earlierout = NULL;\n+\n+  /* Compute rev_isolatedness.  ISOIN is not needed except to compute\n+     ISOOUT, so free its memory as soon as we return from\n+     compute_isoinout.  */\n+  rev_isoin = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  rev_isoout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  compute_rev_isoinout (n_blocks, s_preds, avloc, firstout,\n+\t\t\trev_isoin, rev_isoout);\n+  free (rev_isoout);\n+  rev_isoout = NULL;\n+\n+  /* Now compute optimal placement points and the redundant expressions.  */\n+  compute_optimal (n_blocks, firstout, rev_isoin, optimal);\n+  compute_redundant (n_blocks, n_exprs, avloc, firstout, rev_isoin, redundant);\n+  free (firstout);\n+  firstout = NULL;\n+  free (rev_isoin);\n+  rev_isoin = NULL;\n+}\n+\n+/* Compute expression anticipatability at entrance and exit of each block.  */\n+\n+static void\n+compute_antinout (n_blocks, s_succs, antloc, transp, antin, antout)\n+     int n_blocks;\n+     int_list_ptr *s_succs;\n+     sbitmap *antloc;\n+     sbitmap *transp;\n+     sbitmap *antin;\n+     sbitmap *antout;\n+{\n+  int bb, changed, passes;\n+  sbitmap old_changed, new_changed;\n+\n+  sbitmap_zero (antout[n_blocks - 1]);\n+  sbitmap_vector_ones (antin, n_blocks);\n+\n+  old_changed = sbitmap_alloc (n_blocks);\n+  new_changed = sbitmap_alloc (n_blocks);\n+  sbitmap_ones (old_changed);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      sbitmap_zero (new_changed);\n+      /* We scan the blocks in the reverse order to speed up\n+\t the convergence.  */\n+      for (bb = n_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  int_list_ptr ps;\n+\n+\t  /* If none of the successors of this block have changed,\n+\t     then this block is not going to change.  */\n+\t  for (ps = s_succs[bb] ; ps; ps = ps->next)\n+\t    {\n+\t      if (INT_LIST_VAL (ps) == EXIT_BLOCK\n+\t\t  || INT_LIST_VAL (ps) == ENTRY_BLOCK)\n+\t\tbreak;\n+\n+\t      if (TEST_BIT (old_changed, INT_LIST_VAL (ps))\n+\t\t  || TEST_BIT (new_changed, INT_LIST_VAL (ps)))\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!ps)\n+\t    continue;\n+\n+\t  if (bb != n_blocks - 1)\n+\t    sbitmap_intersect_of_successors (antout[bb], antin,\n+\t\t\t\t\t     bb, s_succs);\n+ \t  if (sbitmap_a_or_b_and_c (antin[bb], antloc[bb],\n+\t\t\t\t    transp[bb], antout[bb]))\n+\t    {\n+\t      changed = 1;\n+\t      SET_BIT (new_changed, bb);\n+\t    }\n+\t}\n+      sbitmap_copy (old_changed, new_changed);\n+      passes++;\n+    }\n+  free (old_changed);\n+  free (new_changed);\n+}\n+\n+/* Compute expression earliestness at entrance and exit of each block.\n+\n+   From Advanced Compiler Design and Implementation pp411.\n+\n+   An expression is earliest at the entrance to basic block BB if no\n+   block from entry to block BB both evaluates the expression and\n+   produces the same value as evaluating it at the entry to block BB\n+   does.  Similarly for earlistness at basic block BB exit.  */\n+\n+static void\n+compute_earlyinout (n_blocks, n_exprs, s_preds, transp, antin,\n+\t\t    earlyin, earlyout)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_preds;\n+     sbitmap *transp;\n+     sbitmap *antin;\n+     sbitmap *earlyin;\n+     sbitmap *earlyout;\n+{\n+  int bb, changed, passes;\n+  sbitmap temp_bitmap;\n+  sbitmap old_changed, new_changed;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  sbitmap_vector_zero (earlyout, n_blocks);\n+  sbitmap_ones (earlyin[0]);\n+\n+  old_changed = sbitmap_alloc (n_blocks);\n+  new_changed = sbitmap_alloc (n_blocks);\n+  sbitmap_ones (old_changed);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      sbitmap_zero (new_changed);\n+      for (bb = 0; bb < n_blocks; bb++)\n+\t{\n+\t  int_list_ptr ps;\n+\n+\t  /* If none of the predecessors of this block have changed,\n+\t     then this block is not going to change.  */\n+\t  for (ps = s_preds[bb] ; ps; ps = ps->next)\n+\t    {\n+\t      if (INT_LIST_VAL (ps) == EXIT_BLOCK\n+\t\t  || INT_LIST_VAL (ps) == ENTRY_BLOCK)\n+\t\tbreak;\n+\n+\t      if (TEST_BIT (old_changed, INT_LIST_VAL (ps))\n+\t\t  || TEST_BIT (new_changed, INT_LIST_VAL (ps)))\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!ps)\n+\t    continue;\n+\n+\t  if (bb != 0)\n+\t    sbitmap_union_of_predecessors (earlyin[bb], earlyout,\n+\t\t\t\t\t   bb, s_preds);\n+\t  sbitmap_not (temp_bitmap, transp[bb]);\n+\t  if (sbitmap_union_of_diff (earlyout[bb], temp_bitmap,\n+\t\t\t\t     earlyin[bb], antin[bb]))\n+\t    {\n+\t      changed = 1;\n+\t      SET_BIT (new_changed, bb);\n+\t    }\n+\t}\n+      sbitmap_copy (old_changed, new_changed);\n+      passes++;\n+    }\n+  free (old_changed);\n+  free (new_changed);\n+  free (temp_bitmap);\n+}\n+\n+/* Compute expression delayedness at entrance and exit of each block.\n+\n+   From Advanced Compiler Design and Implementation pp411.\n+\n+   An expression is delayed at the entrance to BB if it is anticipatable\n+   and earliest at that point and if all subsequent computations of\n+   the expression are in block BB.   */\n+\n+static void\n+compute_delayinout (n_blocks, n_exprs, s_preds, antloc,\n+\t\t    antin, earlyin, delayin, delayout)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_preds;\n+     sbitmap *antloc;\n+     sbitmap *antin;\n+     sbitmap *earlyin;\n+     sbitmap *delayin;\n+     sbitmap *delayout;\n+{\n+  int bb, changed, passes;\n+  sbitmap *anti_and_early;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  /* This is constant throughout the flow equations below, so compute\n+     it once to save time.  */\n+  anti_and_early = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  for (bb = 0; bb < n_blocks; bb++)\n+    sbitmap_a_and_b (anti_and_early[bb], antin[bb], earlyin[bb]);\n+  \n+  sbitmap_vector_zero (delayout, n_blocks);\n+  sbitmap_copy (delayin[0], anti_and_early[0]);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = 0; bb < n_blocks; bb++)\n+\t{\n+\t  if (bb != 0)\n+\t    {\n+\t      sbitmap_intersect_of_predecessors (temp_bitmap, delayout,\n+\t\t\t\t\t\t bb, s_preds);\n+\t      changed |= sbitmap_a_or_b (delayin[bb],\n+\t\t\t\t\t anti_and_early[bb],\n+\t\t\t\t\t temp_bitmap);\n+\t    }\n+\t  sbitmap_not (temp_bitmap, antloc[bb]);\n+\t  changed |= sbitmap_a_and_b (delayout[bb],\n+\t\t\t\t      temp_bitmap,\n+\t\t\t\t      delayin[bb]);\n+\t}\n+      passes++;\n+    }\n+\n+  /* We're done with this, so go ahead and free it's memory now instead\n+     of waiting until the end of pre.  */\n+  free (anti_and_early);\n+  free (temp_bitmap);\n+}\n+\n+/* Compute latestness.\n+\n+   From Advanced Compiler Design and Implementation pp412.\n+\n+   An expression is latest at the entrance to block BB if that is an optimal\n+   point for computing the expression and if on every path from block BB's\n+   entrance to the exit block, any optimal computation point for the \n+   expression occurs after one of the points at which the expression was\n+   computed in the original flowgraph.  */\n+\n+static void\n+compute_latein (n_blocks, n_exprs, s_succs, antloc, delayin, latein)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_succs;\n+     sbitmap *antloc;\n+     sbitmap *delayin;\n+     sbitmap *latein;\n+{\n+  int bb;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  for (bb = 0; bb < n_blocks; bb++)\n+    {\n+      /* The last block is succeeded only by the exit block; therefore,\n+\t temp_bitmap will not be set by the following call!  */\n+      if (bb == n_blocks - 1)\n+\t{\n+          sbitmap_intersect_of_successors (temp_bitmap, delayin,\n+\t\t\t\t           bb, s_succs);\n+\t  sbitmap_not (temp_bitmap, temp_bitmap);\n+\t}\n+      else\n+\tsbitmap_ones (temp_bitmap);\n+      sbitmap_a_and_b_or_c (latein[bb], delayin[bb],\n+\t\t\t    antloc[bb], temp_bitmap);\n+    }\n+  free (temp_bitmap);\n+}\n+\n+/* Compute isolated.\n+\n+   From Advanced Compiler Design and Implementation pp413.\n+\n+   A computationally optimal placement for the evaluation of an expression\n+   is defined to be isolated if and only if on every path from a successor\n+   of the block in which it is computed to the exit block, every original\n+   computation of the expression is preceded by the optimal placement point.  */\n+\n+static void\n+compute_isoinout (n_blocks, s_succs, antloc, latein, isoin, isoout)\n+     int n_blocks;\n+     int_list_ptr *s_succs;\n+     sbitmap *antloc;\n+     sbitmap *latein;\n+     sbitmap *isoin;\n+     sbitmap *isoout;\n+{\n+  int bb, changed, passes;\n+\n+  sbitmap_vector_zero (isoin, n_blocks);\n+  sbitmap_zero (isoout[n_blocks - 1]);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = n_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  if (bb != n_blocks - 1)\n+\t    sbitmap_intersect_of_successors (isoout[bb], isoin,\n+\t\t\t\t\t     bb, s_succs);\n+\t  changed |= sbitmap_union_of_diff (isoin[bb], latein[bb],\n+\t\t\t\t\t    isoout[bb], antloc[bb]);\n+\t}\n+      passes++;\n+    }\n+}\n+\n+/* Compute the set of expressions which have optimal computational points\n+   in each basic block.  This is the set of expressions that are latest, but\n+   that are not isolated in the block.  */\n+\n+static void\n+compute_optimal (n_blocks, latein, isoout, optimal)\n+     int n_blocks;\n+     sbitmap *latein;\n+     sbitmap *isoout;\n+     sbitmap *optimal;\n+{\n+  int bb;\n+\n+  for (bb = 0; bb < n_blocks; bb++)\n+    sbitmap_difference (optimal[bb], latein[bb], isoout[bb]);\n+}\n+\n+/* Compute the set of expressions that are redundant in a block.  They are\n+   the expressions that are used in the block and that are neither isolated\n+   or latest.  */\n+\n+static void\n+compute_redundant (n_blocks, n_exprs, antloc, latein, isoout, redundant)\n+     int n_blocks;\n+     int n_exprs;\n+     sbitmap *antloc;\n+     sbitmap *latein;\n+     sbitmap *isoout;\n+     sbitmap *redundant;\n+{\n+  int bb;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  for (bb = 0; bb < n_blocks; bb++)\n+    {\n+      sbitmap_a_or_b (temp_bitmap, latein[bb], isoout[bb]);\n+      sbitmap_difference (redundant[bb], antloc[bb], temp_bitmap);\n+    }\n+  free (temp_bitmap);\n+}\n+\n+/* Compute expression availability at entrance and exit of each block.  */\n+\n+static void\n+compute_avinout (n_blocks, s_preds, avloc, transp, avin, avout)\n+     int n_blocks;\n+     int_list_ptr *s_preds;\n+     sbitmap *avloc;\n+     sbitmap *transp;\n+     sbitmap *avin;\n+     sbitmap *avout;\n+{\n+  int bb, changed, passes;\n+\n+  sbitmap_zero (avin[0]);\n+  sbitmap_vector_ones (avout, n_blocks);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = 0; bb < n_blocks; bb++)\n+\t{\n+\t  if (bb != 0)\n+\t    sbitmap_intersect_of_predecessors (avin[bb], avout,\n+\t\t\t\t\t       bb, s_preds);\n+\t  changed |= sbitmap_a_or_b_and_c (avout[bb], avloc[bb],\n+\t\t\t\t\t   transp[bb], avin[bb]);\n+\t}\n+      passes++;\n+    }\n+}\n+\n+/* Compute expression latestness.\n+\n+   This is effectively the same as earliestness computed on the reverse\n+   flow graph.  */\n+\n+static void\n+compute_fartherinout (n_blocks, n_exprs, s_succs,\n+\t\t      transp, avout, fartherin, fartherout)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_succs;\n+     sbitmap *transp;\n+     sbitmap *avout;\n+     sbitmap *fartherin;\n+     sbitmap *fartherout;\n+{\n+  int bb, changed, passes;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  sbitmap_vector_zero (fartherin, n_blocks);\n+  sbitmap_ones (fartherout[n_blocks - 1]);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = n_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  if (bb != n_blocks - 1)\n+\t    sbitmap_union_of_successors (fartherout[bb], fartherin,\n+\t\t\t\t\t bb, s_succs);\n+\t  sbitmap_not (temp_bitmap, transp[bb]);\n+\t  changed |= sbitmap_union_of_diff (fartherin[bb], temp_bitmap,\n+\t\t\t\t\t    fartherout[bb], avout[bb]);\n+\t}\n+      passes++;\n+    }\n+\n+  free (temp_bitmap);\n+}\n+\n+/* Compute expression earlierness at entrance and exit of each block.\n+\n+   This is effectively the same as delayedness computed on the reverse\n+   flow graph.  */\n+\n+static void\n+compute_earlierinout (n_blocks, n_exprs, s_succs, avloc,\n+\t\t      avout, fartherout, earlierin, earlierout)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_succs;\n+     sbitmap *avloc;\n+     sbitmap *avout;\n+     sbitmap *fartherout;\n+     sbitmap *earlierin;\n+     sbitmap *earlierout;\n+{\n+  int bb, changed, passes;\n+  sbitmap *av_and_farther;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  /* This is constant throughout the flow equations below, so compute\n+     it once to save time.  */\n+  av_and_farther = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  for (bb = 0; bb < n_blocks; bb++)\n+    sbitmap_a_and_b (av_and_farther[bb], avout[bb], fartherout[bb]);\n+  \n+  sbitmap_vector_zero (earlierin, n_blocks);\n+  sbitmap_copy (earlierout[n_blocks - 1], av_and_farther[n_blocks - 1]);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = n_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  if (bb != n_blocks - 1)\n+\t    {\n+\t      sbitmap_intersect_of_successors (temp_bitmap, earlierin,\n+\t\t\t\t\t       bb, s_succs);\n+\t      changed |= sbitmap_a_or_b (earlierout[bb],\n+\t\t\t\t\t av_and_farther[bb],\n+\t\t\t\t\t temp_bitmap);\n+\t    }\n+\t  sbitmap_not (temp_bitmap, avloc[bb]);\n+\t  changed |= sbitmap_a_and_b (earlierin[bb],\n+\t\t\t\t      temp_bitmap,\n+\t\t\t\t      earlierout[bb]);\n+\t}\n+      passes++;\n+    }\n+\n+  /* We're done with this, so go ahead and free it's memory now instead\n+     of waiting until the end of pre.  */\n+  free (av_and_farther);\n+  free (temp_bitmap);\n+}\n+\n+/* Compute firstness. \n+\n+   This is effectively the same as latestness computed on the reverse\n+   flow graph.  */\n+\n+static void\n+compute_firstout (n_blocks, n_exprs, s_preds, avloc, earlierout, firstout)\n+     int n_blocks;\n+     int n_exprs;\n+     int_list_ptr *s_preds;\n+     sbitmap *avloc;\n+     sbitmap *earlierout;\n+     sbitmap *firstout;\n+{\n+  int bb;\n+  sbitmap temp_bitmap;\n+\n+  temp_bitmap = sbitmap_alloc (n_exprs);\n+\n+  for (bb = 0; bb < n_blocks; bb++)\n+    {\n+      /* The first block is preceded only by the entry block; therefore,\n+\t temp_bitmap will not be set by the following call!  */\n+      if (bb != 0)\n+\t{\n+\t  sbitmap_intersect_of_predecessors (temp_bitmap, earlierout,\n+\t\t\t\t\t     bb, s_preds);\n+\t  sbitmap_not (temp_bitmap, temp_bitmap);\n+\t}\n+      else\n+\t{\n+\t  sbitmap_ones (temp_bitmap);\n+\t}\n+      sbitmap_a_and_b_or_c (firstout[bb], earlierout[bb],\n+\t\t\t    avloc[bb], temp_bitmap);\n+    }\n+  free (temp_bitmap);\n+}\n+\n+/* Compute reverse isolated.\n+\n+   This is effectively the same as isolatedness computed on the reverse\n+   flow graph.  */\n+\n+static void\n+compute_rev_isoinout (n_blocks, s_preds, avloc, firstout,\n+\t\t      rev_isoin, rev_isoout)\n+     int n_blocks;\n+     int_list_ptr *s_preds;\n+     sbitmap *avloc;\n+     sbitmap *firstout;\n+     sbitmap *rev_isoin;\n+     sbitmap *rev_isoout;\n+{\n+  int bb, changed, passes;\n+\n+  sbitmap_vector_zero (rev_isoout, n_blocks);\n+  sbitmap_zero (rev_isoin[0]);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (bb = 0; bb < n_blocks; bb++)\n+\t{\n+\t  if (bb != 0)\n+\t    sbitmap_intersect_of_predecessors (rev_isoin[bb], rev_isoout,\n+\t\t\t\t\t       bb, s_preds);\n+\t  changed |= sbitmap_union_of_diff (rev_isoout[bb], firstout[bb],\n+\t\t\t\t\t    rev_isoin[bb], avloc[bb]);\n+\t}\n+      passes++;\n+    }\n+}"}]}