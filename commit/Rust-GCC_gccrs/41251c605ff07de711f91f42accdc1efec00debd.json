{"sha": "41251c605ff07de711f91f42accdc1efec00debd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyNTFjNjA1ZmYwN2RlNzExZjkxZjQyYWNjZGMxZWZlYzAwZGViZA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-09-05T08:02:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:02:21Z"}, "message": "sem_ch6.ads, [...] (Check_Conformance): In case of anonymous access types the null-exclusion and access-to-constant...\n\n2005-09-01  Javier Miranda  <miranda@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch6.ads, sem_ch6.adb (Check_Conformance): In case of anonymous\n\taccess types the null-exclusion and access-to-constant attributes must\n\talso match.\n\t(Analyze_Return_Statement): When the result type is an anonymous access\n\ttype, apply a conversion of the return expression to the access type\n\tto ensure that appropriate accessibility checks are performed.\n\t(Analyze_Return_Type): For the case of an anonymous access result type,\n\tgenerate the Itype and set Is_Local_Anonymous_Access on the type.\n\tAdd ??? placeholder for check to disallow returning a limited object\n\tin Ada 2005 unless it's an aggregate or a result of a function call.\n\tChange calls from Subtype_Mark to Result_Definition.\n\t(Analyze_Subprogram_Body): Change formal Subtype_Mark to\n\tResult_Definition in call to Make_Function_Specification.\n\t(Build_Body_To_Inline): Change Set_Subtype_Mark to\n\tSet_Result_Definition.\n\t(Make_Inequality_Operator): Change formal Subtype_Mark to\n\tResult_Definition in call to Make_Function_Specification.\n\t(Process_Formals): Create the new null-excluding itype if required.\n\t(New_Overloaded_Entity): For an entity overriding an interface primitive\n\tcheck if the entity also covers other abstract subprograms in the same\n\tscope. This is required to handle the general case, that is, overriding\n\tother interface primitives and overriding abstract subprograms inherited\n\tfrom some abstract ancestor type.\n\t(New_Overloaded_Entity): For an overriding entity that comes from\n\tsource, note the operation that it overrides.\n\t(Check_Conformance, Type_Conformant): Addition of one new formal\n\tto skip controlling formals in the analysis. This is used to\n\thandle overloading of abstract interfaces.\n\t(Base_Types_Match): Add missing case for types imported from\n\tlimited-with clauses\n\t(New_Overloaded_Entity): Add barrier to protect the use of\n\tthe \"alias\" attribute.\n\nFrom-SVN: r103883", "tree": {"sha": "f7894364bc3233e2c1bcbc372a1c697c25c3c786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7894364bc3233e2c1bcbc372a1c697c25c3c786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41251c605ff07de711f91f42accdc1efec00debd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41251c605ff07de711f91f42accdc1efec00debd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41251c605ff07de711f91f42accdc1efec00debd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41251c605ff07de711f91f42accdc1efec00debd/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec6078e39bea99dc01b635d24db203caf7d26de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6078e39bea99dc01b635d24db203caf7d26de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6078e39bea99dc01b635d24db203caf7d26de5"}], "stats": {"total": 330, "additions": 211, "deletions": 119}, "files": [{"sha": "47056d5e46bb15179128758c559264a9851071cd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 200, "deletions": 110, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41251c605ff07de711f91f42accdc1efec00debd/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41251c605ff07de711f91f42accdc1efec00debd/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=41251c605ff07de711f91f42accdc1efec00debd", "patch": "@@ -34,6 +34,7 @@ with Expander; use Expander;\n with Exp_Ch7;  use Exp_Ch7;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Lib;      use Lib;\n@@ -103,13 +104,14 @@ package body Sem_Ch6 is\n    --  RM definitions of the corresponding terms.\n \n    procedure Check_Conformance\n-     (New_Id   : Entity_Id;\n-      Old_Id   : Entity_Id;\n-      Ctype    : Conformance_Type;\n-      Errmsg   : Boolean;\n-      Conforms : out Boolean;\n-      Err_Loc  : Node_Id := Empty;\n-      Get_Inst : Boolean := False);\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Ctype                    : Conformance_Type;\n+      Errmsg                   : Boolean;\n+      Conforms                 : out Boolean;\n+      Err_Loc                  : Node_Id := Empty;\n+      Get_Inst                 : Boolean := False;\n+      Skip_Controlling_Formals : Boolean := False);\n    --  Given two entities, this procedure checks that the profiles associated\n    --  with these entities meet the conformance criterion given by the third\n    --  parameter. If they conform, Conforms is set True and control returns\n@@ -733,6 +735,18 @@ package body Sem_Ch6 is\n             Set_Return_Type (N, R_Type);\n             Analyze_And_Resolve (Expr, R_Type);\n \n+            --  Ada 2005 (AI-318-02): When the result type is an anonymous\n+            --  access type, apply an implicit conversion of the expression\n+            --  to that type to force appropriate static and run-time\n+            --  accessibility checks.\n+\n+            if Ada_Version >= Ada_05\n+              and then Ekind (R_Type) = E_Anonymous_Access_Type\n+            then\n+               Rewrite (Expr, Convert_To (R_Type, Relocate_Node (Expr)));\n+               Analyze_And_Resolve (Expr, R_Type);\n+            end if;\n+\n             if (Is_Class_Wide_Type (Etype (Expr))\n                  or else Is_Dynamically_Tagged (Expr))\n               and then not Is_Class_Wide_Type (R_Type)\n@@ -743,6 +757,22 @@ package body Sem_Ch6 is\n \n             Apply_Constraint_Check (Expr, R_Type);\n \n+            --  Ada 2005 (AI-318-02): Return-by-reference types have been\n+            --  removed and replaced by anonymous access results. This is\n+            --  an incompatibility with Ada 95. Not clear whether this\n+            --  should be enforced yet or perhaps controllable with a\n+            --  special switch. ???\n+\n+            --  if Ada_Version >= Ada_05\n+            --    and then Is_Limited_Type (R_Type)\n+            --    and then Nkind (Expr) /= N_Aggregate\n+            --    and then Nkind (Expr) /= N_Extension_Aggregate\n+            --    and then Nkind (Expr) /= N_Function_Call\n+            --  then\n+            --     Error_Msg_N\n+            --       (\"(Ada 2005) illegal operand for limited return\", N);\n+            --  end if;\n+\n             --  ??? A real run-time accessibility check is needed in cases\n             --  involving dereferences of access parameters. For now we just\n             --  check the static cases.\n@@ -798,18 +828,37 @@ package body Sem_Ch6 is\n       Typ        : Entity_Id := Empty;\n \n    begin\n-      if Subtype_Mark (N) /= Error then\n-         Find_Type (Subtype_Mark (N));\n-         Typ := Entity (Subtype_Mark (N));\n-         Set_Etype (Designator, Typ);\n-\n-         if Ekind (Typ) = E_Incomplete_Type\n-           or else (Is_Class_Wide_Type (Typ)\n-                      and then\n-                        Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n-         then\n-            Error_Msg_N\n-              (\"invalid use of incomplete type\", Subtype_Mark (N));\n+      if Result_Definition (N) /= Error then\n+         if Nkind (Result_Definition (N)) = N_Access_Definition then\n+            Typ := Access_Definition (N, Result_Definition (N));\n+            Set_Parent (Typ, Result_Definition (N));\n+            Set_Is_Local_Anonymous_Access (Typ);\n+            Set_Etype (Designator, Typ);\n+\n+            --  Ada 2005 (AI-231): Static checks\n+\n+            --  Null_Exclusion_Static_Checks needs to be extended to handle\n+            --  null exclusion checks for function specifications. ???\n+\n+            --  if Null_Exclusion_Present (N) then\n+            --     Null_Exclusion_Static_Checks (Param_Spec);\n+            --  end if;\n+\n+         --  Subtype_Mark case\n+\n+         else\n+            Find_Type (Result_Definition (N));\n+            Typ := Entity (Result_Definition (N));\n+            Set_Etype (Designator, Typ);\n+\n+            if Ekind (Typ) = E_Incomplete_Type\n+              or else (Is_Class_Wide_Type (Typ)\n+                         and then\n+                           Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n+            then\n+               Error_Msg_N\n+                 (\"invalid use of incomplete type\", Result_Definition (N));\n+            end if;\n          end if;\n \n       else\n@@ -1083,7 +1132,8 @@ package body Sem_Ch6 is\n                       Make_Defining_Identifier (Sloc (Body_Id),\n                         Chars => Chars (Body_Id)),\n                     Parameter_Specifications => Plist,\n-                    Subtype_Mark => New_Occurrence_Of (Etype (Body_Id), Loc));\n+                    Result_Definition =>\n+                      New_Occurrence_Of (Etype (Body_Id), Loc));\n             end if;\n \n             Decl :=\n@@ -2097,7 +2147,7 @@ package body Sem_Ch6 is\n       --  to be resolved.\n \n       if Ekind (Subp) = E_Function then\n-         Set_Subtype_Mark (Specification (Body_To_Analyze),\n+         Set_Result_Definition (Specification (Body_To_Analyze),\n            New_Occurrence_Of (Etype (Subp), Sloc (N)));\n       end if;\n \n@@ -2167,13 +2217,14 @@ package body Sem_Ch6 is\n    -----------------------\n \n    procedure Check_Conformance\n-     (New_Id   : Entity_Id;\n-      Old_Id   : Entity_Id;\n-      Ctype    : Conformance_Type;\n-      Errmsg   : Boolean;\n-      Conforms : out Boolean;\n-      Err_Loc  : Node_Id := Empty;\n-      Get_Inst : Boolean := False)\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Ctype                    : Conformance_Type;\n+      Errmsg                   : Boolean;\n+      Conforms                 : out Boolean;\n+      Err_Loc                  : Node_Id := Empty;\n+      Get_Inst                 : Boolean := False;\n+      Skip_Controlling_Formals : Boolean := False)\n    is\n       Old_Type   : constant Entity_Id := Etype (Old_Id);\n       New_Type   : constant Entity_Id := Etype (New_Id);\n@@ -2255,6 +2306,21 @@ package body Sem_Ch6 is\n             return;\n          end if;\n \n+         --  Ada 2005 (AI-231): In case of anonymous access types check the\n+         --  null-exclusion and access-to-constant attributes must match.\n+\n+         if Ada_Version >= Ada_05\n+           and then Ekind (Etype (Old_Type)) = E_Anonymous_Access_Type\n+           and then\n+             (Can_Never_Be_Null (Old_Type)\n+                /= Can_Never_Be_Null (New_Type)\n+              or else Is_Access_Constant (Etype (Old_Type))\n+                        /= Is_Access_Constant (Etype (New_Type)))\n+         then\n+            Conformance_Error (\"return type does not match!\", New_Id);\n+            return;\n+         end if;\n+\n       --  If either is a function/operator and the other isn't, error\n \n       elsif Old_Type /= Standard_Void_Type\n@@ -2311,6 +2377,13 @@ package body Sem_Ch6 is\n       New_Formal := First_Formal (New_Id);\n \n       while Present (Old_Formal) and then Present (New_Formal) loop\n+         if Is_Controlling_Formal (Old_Formal)\n+           and then Is_Controlling_Formal (New_Formal)\n+           and then Skip_Controlling_Formals\n+         then\n+            goto Skip_Controlling_Formal;\n+         end if;\n+\n          if Ctype = Fully_Conformant then\n \n             --  Names must match. Error message is more accurate if we do\n@@ -2362,10 +2435,29 @@ package body Sem_Ch6 is\n \n          if Ctype = Fully_Conformant then\n \n-            --  We have checked already that names match. Check default\n-            --  expressions for in parameters\n+            --  We have checked already that names match\n \n             if Parameter_Mode (Old_Formal) = E_In_Parameter then\n+\n+               --  Ada 2005 (AI-231): In case of anonymous access types check\n+               --  the null-exclusion and access-to-constant attributes must\n+               --  match.\n+\n+               if Ada_Version >= Ada_05\n+                 and then Ekind (Etype (Old_Formal)) = E_Anonymous_Access_Type\n+                 and then\n+                   (Can_Never_Be_Null (Old_Formal)\n+                      /= Can_Never_Be_Null (New_Formal)\n+                    or else Is_Access_Constant (Etype (Old_Formal))\n+                              /= Is_Access_Constant (Etype (New_Formal)))\n+               then\n+                  Conformance_Error\n+                    (\"type of & does not match!\", New_Formal);\n+                  return;\n+               end if;\n+\n+               --  Check default expressions for in parameters\n+\n                declare\n                   NewD : constant Boolean :=\n                            Present (Default_Value (New_Formal));\n@@ -2448,6 +2540,10 @@ package body Sem_Ch6 is\n             end;\n          end if;\n \n+         --  This label is required when skipping controlling formals\n+\n+         <<Skip_Controlling_Formal>>\n+\n          Next_Formal (Old_Formal);\n          Next_Formal (New_Formal);\n       end loop;\n@@ -3237,6 +3333,12 @@ package body Sem_Ch6 is\n          then\n             return True;\n \n+         elsif From_With_Type (T2)\n+           and then Ekind (T2) = E_Incomplete_Type\n+           and then T1 = Non_Limited_View (T2)\n+         then\n+            return True;\n+\n          else\n             return False;\n          end if;\n@@ -4489,7 +4591,7 @@ package body Sem_Ch6 is\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name => Op_Name,\n               Parameter_Specifications => Formals,\n-              Subtype_Mark => New_Reference_To (Standard_Boolean, Loc)));\n+              Result_Definition => New_Reference_To (Standard_Boolean, Loc)));\n \n       --  Insert inequality right after equality if it is explicit or after\n       --  the derived type when implicit. These entities are created only for\n@@ -4925,6 +5027,15 @@ package body Sem_Ch6 is\n \n                   if Comes_From_Source (E) then\n                      Check_Overriding_Indicator (E, True);\n+\n+                     --  Indicate that E overrides the operation from which\n+                     --  S is inherited.\n+\n+                     if  Present (Alias (S)) then\n+                        Set_Overridden_Operation (E, Alias (S));\n+                     else\n+                        Set_Overridden_Operation (E, S);\n+                     end if;\n                   end if;\n \n                   return;\n@@ -5081,6 +5192,17 @@ package body Sem_Ch6 is\n                      Set_Is_Overriding_Operation (S);\n                      Check_Overriding_Indicator (S, True);\n \n+                     --  Indicate that S overrides the operation from which\n+                     --  E is inherited.\n+\n+                     if Comes_From_Source (S) then\n+                        if  Present (Alias (E)) then\n+                           Set_Overridden_Operation (S, Alias (E));\n+                        else\n+                           Set_Overridden_Operation (S, E);\n+                        end if;\n+                     end if;\n+\n                      if Is_Dispatching_Operation (E) then\n \n                         --  An overriding dispatching subprogram inherits the\n@@ -5089,28 +5211,33 @@ package body Sem_Ch6 is\n \n                         Set_Convention (S, Convention (E));\n \n-                        --  AI-251: If the subprogram implements an interface,\n-                        --  check if this subprogram covers other interface\n-                        --  subprograms available in the same scope.\n+                        --  AI-251: For an entity overriding an interface\n+                        --  primitive check if the entity also covers other\n+                        --  abstract subprograms in the same scope. This is\n+                        --  required to handle the general case, that is,\n+                        --  1) overriding other interface primitives, and\n+                        --  2) overriding abstract subprograms inherited from\n+                        --  some abstract ancestor type.\n \n-                        if Present (Alias (E))\n+                        if Has_Homonym (E)\n+                          and then Present (Alias (E))\n                           and then Ekind (Alias (E)) /= E_Operator\n                           and then Present (DTC_Entity (Alias (E)))\n                           and then Is_Interface (Scope (DTC_Entity\n                                                         (Alias (E))))\n                         then\n-                           Check_Dispatching_Operation (S, E);\n-\n                            declare\n                               E1 : Entity_Id;\n \n                            begin\n                               E1 := Homonym (E);\n                               while Present (E1) loop\n-                                 if Present (Alias (E1))\n+                                 if (Is_Overloadable (E1)\n+                                       or else Ekind (E1) = E_Subprogram_Type)\n+                                   and then Present (Alias (E1))\n                                    and then Ekind (Alias (E1)) /= E_Operator\n                                    and then Present (DTC_Entity (Alias (E1)))\n-                                   and then Is_Interface\n+                                   and then Is_Abstract\n                                               (Scope (DTC_Entity (Alias (E1))))\n                                    and then Type_Conformant (E1, S)\n                                  then\n@@ -5120,10 +5247,10 @@ package body Sem_Ch6 is\n                                  E1 := Homonym (E1);\n                               end loop;\n                            end;\n-                        else\n-                           Check_Dispatching_Operation (S, E);\n                         end if;\n \n+                        Check_Dispatching_Operation (S, E);\n+\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;\n@@ -5292,69 +5419,20 @@ package body Sem_Ch6 is\n             --  formal in the enclosing scope. Finally, replace the parameter\n             --  type of the formal with the internal subtype.\n \n-            if Null_Exclusion_Present (Param_Spec) then\n-               declare\n-                  Loc   : constant Source_Ptr := Sloc (Param_Spec);\n-\n-                  Anon  : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc,\n-                              Chars => New_Internal_Name ('S'));\n-\n-                  Curr_Scope : constant Scope_Stack_Entry :=\n-                                 Scope_Stack.Table (Scope_Stack.Last);\n-\n-                  Ptype : constant Node_Id := Parameter_Type (Param_Spec);\n-                  Decl  : Node_Id;\n-                  P     : Node_Id := Parent (Related_Nod);\n-\n-               begin\n-                  Set_Is_Internal (Anon);\n-\n-                  Decl :=\n-                    Make_Subtype_Declaration (Loc,\n-                      Defining_Identifier      => Anon,\n-                        Null_Exclusion_Present => True,\n-                        Subtype_Indication     =>\n-                          New_Occurrence_Of (Etype (Ptype), Loc));\n-\n-                  --  Propagate the null-excluding attribute to the new entity\n-\n-                  if Null_Exclusion_Present (Param_Spec) then\n-                     Set_Null_Exclusion_Present (Param_Spec, False);\n-                     Set_Can_Never_Be_Null (Anon);\n-                  end if;\n-\n-                  Mark_Rewrite_Insertion (Decl);\n-\n-                  --  Insert the new declaration in the nearest enclosing scope\n-                  --  in front of the subprogram or entry declaration.\n-\n-                  while not Is_List_Member (P) loop\n-                     P := Parent (P);\n-                  end loop;\n-\n-                  Insert_Before (P, Decl);\n-\n-                  Rewrite (Ptype, New_Occurrence_Of (Anon, Loc));\n-                  Mark_Rewrite_Insertion (Ptype);\n-\n-                  --  Analyze the new declaration in the context of the\n-                  --  enclosing scope\n-\n-                  Scope_Stack.Decrement_Last;\n-                  Analyze (Decl);\n-                  Scope_Stack.Append (Curr_Scope);\n-\n-                  Formal_Type := Anon;\n-               end;\n-            end if;\n-\n-            --  Ada 2005 (AI-231): Static checks\n-\n-            if Null_Exclusion_Present (Param_Spec)\n-              or else Can_Never_Be_Null (Entity (Ptype))\n+            if Ada_Version >= Ada_05\n+              and then Is_Access_Type (Formal_Type)\n+              and then Null_Exclusion_Present (Param_Spec)\n             then\n-               Null_Exclusion_Static_Checks (Param_Spec);\n+               if Can_Never_Be_Null (Formal_Type) then\n+                  Error_Msg_N\n+                    (\"(Ada 2005) already a null-excluding type\", Related_Nod);\n+               end if;\n+\n+               Formal_Type :=\n+                 Create_Null_Excluding_Itype\n+                   (T           => Formal_Type,\n+                    Related_Nod => Related_Nod,\n+                    Scope_Id    => Scope (Current_Scope));\n             end if;\n \n          --  An access formal type\n@@ -5407,6 +5485,15 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n+         --  Ada 2005 (AI-231): Static checks\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Access_Type (Etype (Formal))\n+           and then Can_Never_Be_Null (Etype (Formal))\n+         then\n+            Null_Exclusion_Static_Checks (Param_Spec);\n+         end if;\n+\n       <<Continue>>\n          Next (Param_Spec);\n       end loop;\n@@ -5663,20 +5750,18 @@ package body Sem_Ch6 is\n          --  null; In Ada 2005, only if then null_exclusion is explicit.\n \n          if Ada_Version < Ada_05\n-           or else Null_Exclusion_Present (Spec)\n            or else Can_Never_Be_Null (Etype (Formal_Id))\n          then\n             Set_Is_Known_Non_Null (Formal_Id);\n             Set_Can_Never_Be_Null (Formal_Id);\n          end if;\n \n+      --  Ada 2005 (AI-231): Null-exclusion access subtype\n+\n       elsif Is_Access_Type (Etype (Formal_Id))\n         and then Can_Never_Be_Null (Etype (Formal_Id))\n       then\n-         --  Ada 2005: The access subtype may be declared with null-exclusion\n-\n          Set_Is_Known_Non_Null (Formal_Id);\n-         Set_Can_Never_Be_Null (Formal_Id);\n       end if;\n \n       Set_Mechanism (Formal_Id, Default_Mechanism);\n@@ -5734,10 +5819,16 @@ package body Sem_Ch6 is\n    -- Type_Conformant --\n    ---------------------\n \n-   function Type_Conformant (New_Id, Old_Id : Entity_Id) return Boolean is\n+   function Type_Conformant\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Skip_Controlling_Formals : Boolean := False) return Boolean\n+   is\n       Result : Boolean;\n    begin\n-      Check_Conformance (New_Id, Old_Id, Type_Conformant, False, Result);\n+      Check_Conformance\n+        (New_Id, Old_Id, Type_Conformant, False, Result,\n+         Skip_Controlling_Formals => Skip_Controlling_Formals);\n       return Result;\n    end Type_Conformant;\n \n@@ -5753,7 +5844,6 @@ package body Sem_Ch6 is\n \n    begin\n       F := First_Formal (Designator);\n-\n       while Present (F) loop\n          N := N + 1;\n "}, {"sha": "79d785e10c5d7ec58ed357e39b83b126acfdb9de", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41251c605ff07de711f91f42accdc1efec00debd/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41251c605ff07de711f91f42accdc1efec00debd/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=41251c605ff07de711f91f42accdc1efec00debd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -143,11 +143,10 @@ package Sem_Ch6 is\n    procedure New_Overloaded_Entity\n      (S            : Entity_Id;\n       Derived_Type : Entity_Id := Empty);\n-   --  Process new overloaded entity. Overloaded entities are created\n-   --  by enumeration type declarations, subprogram specifications,\n-   --  entry declarations, and (implicitly) by type derivations.\n-   --  If Derived_Type is not Empty, then it indicates that this\n-   --  is subprogram derived for that type.\n+   --  Process new overloaded entity. Overloaded entities are created by\n+   --  enumeration type declarations, subprogram specifications, entry\n+   --  declarations, and (implicitly) by type derivations. Derived_Type non-\n+   --  Empty indicates that this is subprogram derived for that type.\n \n    procedure Process_Formals (T : List_Id; Related_Nod : Node_Id);\n    --  Enter the formals in the scope of the subprogram or entry, and\n@@ -168,11 +167,14 @@ package Sem_Ch6 is\n \n    function Subtype_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n-   --  literals) are subtype conformant (RM6.3.1(16))\n+   --  literals) are subtype conformant (RM6.3.1(16)).\n \n-   function Type_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n+   function Type_Conformant\n+     (New_Id                   : Entity_Id;\n+      Old_Id                   : Entity_Id;\n+      Skip_Controlling_Formals : Boolean := False) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n-   --  literals) are type conformant (RM6.3.1(14))\n+   --  literals) are type conformant (RM6.3.1(14)).\n \n    procedure Valid_Operator_Definition (Designator : Entity_Id);\n    --  Verify that an operator definition has the proper number of formals"}]}