{"sha": "2f3cdcf50295a3888012b66a52b709a7f21d2f25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzY2RjZjUwMjk1YTM4ODgwMTJiNjZhNTJiNzA5YTdmMjFkMmYyNQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-01-14T18:00:34Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-01-14T18:00:34Z"}, "message": "re PR tree-optimization/42706 (ICE in gimple_op, at gimple.h:1634, (IPA SRA))\n\n2010-01-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/42706\n\t* tree-sra.c (encountered_recursive_call): New variable.\n\t(encountered_unchangable_recursive_call): Likewise.\n\t(sra_initialize): Initialize both new variables.\n\t(callsite_has_enough_arguments_p): New function.\n\t(scan_function): Call decl and flags check only for IPA-SRA, check\n\twhether there is a recursive call and whether it has enough arguments.\n\t(all_callers_have_enough_arguments_p): New function.\n\t(convert_callers): Look for recursive calls only when\n\tencountered_recursive_call is set.\n\t(ipa_early_sra): Bail out either if\n\t!all_callers_have_enough_arguments_p or\n\tencountered_unchangable_recursive_call.\n\n\t* testsuite/gcc.dg/ipa/pr42706.c: New testcase.\n\nFrom-SVN: r155911", "tree": {"sha": "e67d8e3c3b5b8bd2f68e5f4e63f4b36f8e354636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e67d8e3c3b5b8bd2f68e5f4e63f4b36f8e354636"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f3cdcf50295a3888012b66a52b709a7f21d2f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3cdcf50295a3888012b66a52b709a7f21d2f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3cdcf50295a3888012b66a52b709a7f21d2f25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3cdcf50295a3888012b66a52b709a7f21d2f25/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7767706d58eecfccd3805fd9e59fdb5e3b557611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7767706d58eecfccd3805fd9e59fdb5e3b557611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7767706d58eecfccd3805fd9e59fdb5e3b557611"}], "stats": {"total": 121, "additions": 115, "deletions": 6}, "files": [{"sha": "9c2e7ef4dc1140f7ff20898a7082a5ef1ccb33fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f3cdcf50295a3888012b66a52b709a7f21d2f25", "patch": "@@ -1,3 +1,19 @@\n+2010-01-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/42706\n+\t* tree-sra.c (encountered_recursive_call): New variable.\n+\t(encountered_unchangable_recursive_call): Likewise.\n+\t(sra_initialize): Initialize both new variables.\n+\t(callsite_has_enough_arguments_p): New function.\n+\t(scan_function): Call decl and flags check only for IPA-SRA, check\n+\twhether there is a recursive call and whether it has enough arguments.\n+\t(all_callers_have_enough_arguments_p): New function.\n+\t(convert_callers): Look for recursive calls only when\n+\tencountered_recursive_call is set.\n+\t(ipa_early_sra): Bail out either if\n+\t!all_callers_have_enough_arguments_p or\n+\tencountered_unchangable_recursive_call.\n+\n 2010-01-14  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* sel-sched.c: Add 2010 to copyright years."}, {"sha": "cfebc861535cb101e44d271d9a5c40a4d5985d6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f3cdcf50295a3888012b66a52b709a7f21d2f25", "patch": "@@ -1,11 +1,16 @@\n+2010-01-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/42706\n+\t* gcc.dg/ipa/pr42706.c: New testcase.\t\n+\n 2010-01-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* g++.dg/graphite/pr42681.C (size_t): Use __SIZE_TYPE__.\n \n 2010-01-14  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/42714\n-\t* gcc/testsuite/g++.dg/torture/pr42714.C: New test.\n+\t* g++.dg/torture/pr42714.C: New test.\n \n 2010-01-14  Alexander Monakov  <amonakov@ispras.ru>\n "}, {"sha": "9c5f43af36fbba3720c081fcc7dd933833c55951", "filename": "gcc/testsuite/gcc.dg/ipa/pr42706.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr42706.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr42706.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr42706.c?ref=2f3cdcf50295a3888012b66a52b709a7f21d2f25", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fipa-sra\"  } */\n+\n+struct S\n+{\n+  float red;\n+  int green;\n+  void *blue;\n+};\n+\n+extern int gi;\n+static int foo ();\n+\n+int\n+bar (void)\n+{\n+  foo ();\n+  return 0;\n+}\n+\n+static int\n+foo (struct S s)\n+{\n+  gi = s.green;\n+  return 0;\n+}\n+"}, {"sha": "dd62cc53798653c9ccd8eee8d46aa48e7eb2eecd", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3cdcf50295a3888012b66a52b709a7f21d2f25/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2f3cdcf50295a3888012b66a52b709a7f21d2f25", "patch": "@@ -258,6 +258,13 @@ static int func_param_count;\n    __builtin_apply_args.  */\n static bool encountered_apply_args;\n \n+/* Set by scan_function when it finds a recursive call.  */\n+static bool encountered_recursive_call;\n+\n+/* Set by scan_function when it finds a recursive call with less actual\n+   arguments than formal parameters..  */\n+static bool encountered_unchangable_recursive_call;\n+\n /* This is a table in which for each basic block and parameter there is a\n    distance (offset + size) in that parameter which is dereferenced and\n    accessed in that BB.  */\n@@ -545,6 +552,8 @@ sra_initialize (void)\n   base_access_vec = pointer_map_create ();\n   memset (&sra_stats, 0, sizeof (sra_stats));\n   encountered_apply_args = false;\n+  encountered_recursive_call = false;\n+  encountered_unchangable_recursive_call = false;\n }\n \n /* Hook fed to pointer_map_traverse, deallocate stored vectors.  */\n@@ -944,6 +953,14 @@ asm_visit_addr (gimple stmt ATTRIBUTE_UNUSED, tree op,\n   return false;\n }\n \n+/* Return true iff callsite CALL has at least as many actual arguments as there\n+   are formal parameters of the function currently processed by IPA-SRA.  */\n+\n+static inline bool\n+callsite_has_enough_arguments_p (gimple call)\n+{\n+  return gimple_call_num_args (call) >= (unsigned) func_param_count;\n+}\n \n /* Scan function and look for interesting statements. Return true if any has\n    been found or processed, as indicated by callbacks.  SCAN_EXPR is a callback\n@@ -1014,15 +1031,24 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t\t  any |= scan_expr (argp, &gsi, false, data);\n \t\t}\n \n-\t      if (analysis_stage)\n+\t      if (analysis_stage && sra_mode == SRA_MODE_EARLY_IPA)\n \t\t{\n \t\t  tree dest = gimple_call_fndecl (stmt);\n \t\t  int flags = gimple_call_flags (stmt);\n \n-\t\t  if (dest\n-\t\t      && DECL_BUILT_IN_CLASS (dest) == BUILT_IN_NORMAL\n-\t\t      && DECL_FUNCTION_CODE (dest) == BUILT_IN_APPLY_ARGS)\n-\t\t    encountered_apply_args = true;\n+\t\t  if (dest)\n+\t\t    {\n+\t\t      if (DECL_BUILT_IN_CLASS (dest) == BUILT_IN_NORMAL\n+\t\t\t  && DECL_FUNCTION_CODE (dest) == BUILT_IN_APPLY_ARGS)\n+\t\t\tencountered_apply_args = true;\n+\t\t      if (cgraph_get_node (dest)\n+\t\t\t  == cgraph_get_node (current_function_decl))\n+\t\t\t{\n+\t\t\t  encountered_recursive_call = true;\n+\t\t\t  if (!callsite_has_enough_arguments_p (stmt))\n+\t\t\t    encountered_unchangable_recursive_call = true;\n+\t\t\t}\n+\t\t    }\n \n \t\t  if (final_bbs\n \t\t      && (flags & (ECF_CONST | ECF_PURE)) == 0)\n@@ -3780,6 +3806,21 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n     }\n }\n \n+/* Return true iff all callers have at least as many actual arguments as there\n+   are formal parameters in the current function.  */\n+\n+static bool\n+all_callers_have_enough_arguments_p (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *cs;\n+  for (cs = node->callers; cs; cs = cs->next_caller)\n+    if (!callsite_has_enough_arguments_p (cs->call_stmt))\n+      return false;\n+\n+  return true;\n+}\n+\n+\n /* Convert all callers of NODE to pass parameters as given in ADJUSTMENTS.  */\n \n static void\n@@ -3815,6 +3856,10 @@ convert_callers (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n   BITMAP_FREE (recomputed_callers);\n \n   current_function_decl = old_cur_fndecl;\n+\n+  if (!encountered_recursive_call)\n+    return;\n+\n   FOR_EACH_BB (this_block)\n     {\n       gimple_stmt_iterator gsi;\n@@ -3927,6 +3972,14 @@ ipa_early_sra (void)\n       goto simple_out;\n     }\n \n+  if (!all_callers_have_enough_arguments_p (node))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"There are callers with insufficient number of \"\n+\t\t \"arguments.\\n\");\n+      goto simple_out;\n+    }\n+\n   bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n \t\t\t\t func_param_count\n \t\t\t\t * last_basic_block_for_function (cfun));\n@@ -3941,6 +3994,14 @@ ipa_early_sra (void)\n       goto out;\n     }\n \n+  if (encountered_unchangable_recursive_call)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function calls itself with insufficient \"\n+\t\t \"number of arguments.\\n\");\n+      goto out;\n+    }\n+\n   adjustments = analyze_all_param_acesses ();\n   if (!adjustments)\n     goto out;"}]}