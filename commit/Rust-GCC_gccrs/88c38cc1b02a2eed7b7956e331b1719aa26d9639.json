{"sha": "88c38cc1b02a2eed7b7956e331b1719aa26d9639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjMzhjYzFiMDJhMmVlZDdiNzk1NmUzMzFiMTcxOWFhMjZkOTYzOQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2002-02-12T04:14:52Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-02-12T04:14:52Z"}, "message": "boehm.cc (initialized, [...]): Removed unused declarations.\n\n\t* boehm.cc (initialized, obj_kind_x, obj_free_list): Removed unused\n\tdeclarations.\n\t(_Jv_InitGC): Don't bother locking, as this is always called from a\n\tsingle-thread. Turn off GC_all_interior_pointers. Remove dead code.\n\nFrom-SVN: r49695", "tree": {"sha": "c6805b4b7494b53d254170105c7c18f0d8971088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6805b4b7494b53d254170105c7c18f0d8971088"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88c38cc1b02a2eed7b7956e331b1719aa26d9639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c38cc1b02a2eed7b7956e331b1719aa26d9639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88c38cc1b02a2eed7b7956e331b1719aa26d9639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88c38cc1b02a2eed7b7956e331b1719aa26d9639/comments", "author": null, "committer": null, "parents": [{"sha": "036d01d034da4bdde2e83a21dc65d2b984bcbd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036d01d034da4bdde2e83a21dc65d2b984bcbd50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036d01d034da4bdde2e83a21dc65d2b984bcbd50"}], "stats": {"total": 99, "additions": 9, "deletions": 90}, "files": [{"sha": "e4d312e827cba013fd411c65b0d90b533de4e891", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c38cc1b02a2eed7b7956e331b1719aa26d9639/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c38cc1b02a2eed7b7956e331b1719aa26d9639/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=88c38cc1b02a2eed7b7956e331b1719aa26d9639", "patch": "@@ -1,3 +1,10 @@\n+2002-02-12  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\t* boehm.cc (initialized, obj_kind_x, obj_free_list): Removed unused\n+\tdeclarations.\n+\t(_Jv_InitGC): Don't bother locking, as this is always called from a \n+\tsingle-thread. Turn off GC_all_interior_pointers. Remove dead code.\n+\n 2002-02-11  Adam Megacz <adam@xwt.org>\n \n \t* include/win32.h: Added _Jv_platform_gettimeofday."}, {"sha": "be2855aef72b9b410054bb608c6d1a76682fedcc", "filename": "libjava/boehm.cc", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88c38cc1b02a2eed7b7956e331b1719aa26d9639/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88c38cc1b02a2eed7b7956e331b1719aa26d9639/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=88c38cc1b02a2eed7b7956e331b1719aa26d9639", "patch": "@@ -26,7 +26,6 @@ details.  */\n \n extern \"C\"\n {\n-#include <private/gc_priv.h>\n #include <private/gc_pmark.h>\n #include <gc_gcj.h>\n \n@@ -44,19 +43,6 @@ extern \"C\"\n #define MAYBE_MARK(Obj, Top, Limit, Source, Exit)  \\\n \tTop=GC_MARK_AND_PUSH((GC_PTR)Obj, Top, Limit, (GC_PTR *)Source)\n \n-\f\n-\n-// Nonzero if this module has been initialized.\n-static int initialized = 0;\n-\n-#if 0\n-// `kind' index used when allocating Java objects.\n-static int obj_kind_x;\n-\n-// Freelist used for Java objects.\n-static ptr_t *obj_free_list;\n-#endif /* 0 */\n-\n // `kind' index used when allocating Java arrays.\n static int array_kind_x;\n \n@@ -470,19 +456,9 @@ void\n _Jv_InitGC (void)\n {\n   int proc;\n-  DCL_LOCK_STATE;\n \n-  DISABLE_SIGNALS ();\n-  LOCK ();\n-\n-  if (initialized)\n-    {\n-      UNLOCK ();\n-      ENABLE_SIGNALS ();\n-      return;\n-    }\n-  initialized = 1;\n-  UNLOCK ();\n+  // Ignore pointers that do not point to the start of an object.\n+  GC_all_interior_pointers = 0;\n \n   // Configure the collector to use the bitmap marking descriptors that we\n   // stash in the class vtable.\n@@ -492,7 +468,6 @@ _Jv_InitGC (void)\n   // instead of returning 0.  This is cheaper than checking on allocation.\n   GC_oom_fn = handle_out_of_memory;\n \n-  LOCK ();\n   GC_java_finalization = 1;\n \n   // We use a different mark procedure for object arrays. This code \n@@ -514,9 +489,6 @@ _Jv_InitGC (void)\n   GC_obj_kinds[array_kind_x].ok_init = TRUE;\n \n   _Jv_MutexInit (&disable_gc_mutex);\n-\n-  UNLOCK ();\n-  ENABLE_SIGNALS ();\n }\n \n #ifdef JV_HASH_SYNCHRONIZATION\n@@ -578,63 +550,3 @@ _Jv_GCCanReclaimSoftReference (jobject)\n   // For now, always reclaim soft references.  FIXME.\n   return true;\n }\n-\n-#if 0\n-void\n-_Jv_InitGC (void)\n-{\n-  int proc;\n-  DCL_LOCK_STATE;\n-\n-  DISABLE_SIGNALS ();\n-  LOCK ();\n-\n-  if (initialized)\n-   {\n-     UNLOCK ();\n-     ENABLE_SIGNALS ();\n-     return;\n-   }\n-  initialized = 1;\n-\n-  GC_java_finalization = 1;\n-\n-  // Set up state for marking and allocation of Java objects.\n-  obj_free_list = (ptr_t *) GC_generic_malloc_inner ((MAXOBJSZ + 1)\n-\t\t\t\t\t\t     * sizeof (ptr_t),\n-\t\t\t\t\t\t     PTRFREE);\n-  memset (obj_free_list, 0, (MAXOBJSZ + 1) * sizeof (ptr_t));\n-\n-  proc = GC_n_mark_procs++;\n-  GC_mark_procs[proc] = (GC_mark_proc) _Jv_MarkObj;\n-\n-  obj_kind_x = GC_n_kinds++;\n-  GC_obj_kinds[obj_kind_x].ok_freelist = obj_free_list;\n-  GC_obj_kinds[obj_kind_x].ok_reclaim_list = 0;\n-  GC_obj_kinds[obj_kind_x].ok_descriptor = GC_MAKE_PROC (proc, 0);\n-  GC_obj_kinds[obj_kind_x].ok_relocate_descr = FALSE;\n-  GC_obj_kinds[obj_kind_x].ok_init = TRUE;\n-\n-  // Set up state for marking and allocation of arrays of Java\n-  // objects.\n-  array_free_list = (ptr_t *) GC_generic_malloc_inner ((MAXOBJSZ + 1)\n-\t\t\t\t\t\t       * sizeof (ptr_t),\n-\t\t\t\t\t\t       PTRFREE);\n-  memset (array_free_list, 0, (MAXOBJSZ + 1) * sizeof (ptr_t));\n-\n-  proc = GC_n_mark_procs++;\n-  GC_mark_procs[proc] = (GC_mark_proc) _Jv_MarkArray;\n-\n-  array_kind_x = GC_n_kinds++;\n-  GC_obj_kinds[array_kind_x].ok_freelist = array_free_list;\n-  GC_obj_kinds[array_kind_x].ok_reclaim_list = 0;\n-  GC_obj_kinds[array_kind_x].ok_descriptor = GC_MAKE_PROC (proc, 0);\n-  GC_obj_kinds[array_kind_x].ok_relocate_descr = FALSE;\n-  GC_obj_kinds[array_kind_x].ok_init = TRUE;\n-\n-  _Jv_MutexInit (&disable_gc_mutex);\n-\n-  UNLOCK ();\n-  ENABLE_SIGNALS ();\n-}\n-#endif /* 0 */"}]}