{"sha": "38c37a0ef08365d63cad46f0c345dffdb138f5ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhjMzdhMGVmMDgzNjVkNjNjYWQ0NmYwYzM0NWRmZmRiMTM4ZjVlYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-03-14T17:32:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-03-14T17:32:36Z"}, "message": "mn10300.c (const_costs): Remove unused function.\n\n        * mn10300/mn10300.c (const_costs): Remove unused function.\n        * mn10300/mn10300.h (CONST_COSTS): Rework to generate better code.\n\n        * mn10300/mn10300.c (print_operand): Handle 'H' and 'L' output\n        modifers for high/low part of a 64bit value.\n        * mn10300/mn10300.h (CONST_DOUBLE_OK_FOR_LETTER_P): Handle 'G'\n        (LEGITIMATE_CONSTANT_P): Allow any constant.\n        * mn10300/mn10300.md (movdi, movdf): Implement.\n        (adddi3, subdi3): New expanders and patterns.\n\n        * mn10300/mn10300.c (print_operand): Handle 'A' modifier for an\n        address which can't be simple register indirect.\n        * mn10300/mn10300.h (EXTRA_CONSTRAINT): Handle 'R' for bit ops.\n        * mn10300/mn10300.md: Add several patterns to test, set and clear\n        bitfields.\n\n        * mn10300/mn10300.c (can_use_return_insn): New function.\n        (expand_epilogue): Emit a RETURN insn if possible.\n        * mn10300/mn10300.md (return): New pattern.\n\n        * mn10300/mn10300.h (CONST_OK_FOR_LETTER_P): Handle 'N'.\n        * mn10300/mn10300.md (andsi3): Catch \"and 255,dn\" and \"and 65535,dn\"\n        which were not turned into zero_extend patterns.\n\n        * mn10300/mn10300.h (GO_IF_LEGITIMATE_ADDRESS): Handle symbolic\n        constant as an index/base too.\n\n        * mn10300/mn10300.md (movsi): Allow SP to be loaded/saved with\n        reg+d8 addresses.\n\n        * mn10300/mn10300.md (cmpsi): Allow second operand to be a constant.\n        (subsi3): Likewise.\n\n        * mn10300/mn10300.md (sign extension patterns): Fix thinko when\n        extending from memory.\n\n        * mn10300/mn10300.md (tst peepholes): Add peepholes for test/branch\n        based on N bit being set/clear and the data value being tested dies.\n\nFrom-SVN: r13701", "tree": {"sha": "8d2300725b82f4dc227fd730ecbc3897558b61cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d2300725b82f4dc227fd730ecbc3897558b61cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38c37a0ef08365d63cad46f0c345dffdb138f5ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c37a0ef08365d63cad46f0c345dffdb138f5ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c37a0ef08365d63cad46f0c345dffdb138f5ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c37a0ef08365d63cad46f0c345dffdb138f5ec/comments", "author": null, "committer": null, "parents": [{"sha": "777fbf098d29a455da9b16b904d6c57a8612d598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777fbf098d29a455da9b16b904d6c57a8612d598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777fbf098d29a455da9b16b904d6c57a8612d598"}], "stats": {"total": 572, "additions": 518, "deletions": 54}, "files": [{"sha": "027a8e7a02ff0185f904ba036b51df9c7be3b6d1", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 157, "deletions": 25, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=38c37a0ef08365d63cad46f0c345dffdb138f5ec", "patch": "@@ -49,27 +49,6 @@ asm_file_start (file)\n }\n \f\n \n-int\n-const_costs (r, c)\n-     rtx r;\n-     enum rtx_code c;\n-{\n-  switch (c)\n-    {\n-    case CONST_INT:\n-      if (INT_8_BITS (INTVAL (r)))\n-\treturn 0;\n-      else if (INT_16_BITS (INTVAL (r)))\n-\treturn 1;\n-      else\n-\treturn 2;\n-    case CONST_DOUBLE:\n-      return 8;\n-    default:\n-      return 4;\n-    }\n-}\n-\f\n /* Print operand X using operand code CODE to assembly language output file\n    FILE.  */\n \n@@ -134,6 +113,123 @@ print_operand (file, x, code)\n \t  print_operand (file, x, 0);\n \tbreak;\n      \n+      /* These are the least significant word in a 64bit value.  */\n+      case 'L':\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    break;\n+\n+\t  case CONST_DOUBLE:\n+\t      {\n+\t\tlong val[2];\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tswitch (GET_MODE (x))\n+\t\t  {\n+\t\t    case DFmode:\n+\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t\t      print_operand_address (file, GEN_INT (val[0]));\n+\t\t      break;;\n+\t\t    case SFmode:\n+\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\t      REAL_VALUE_TO_TARGET_SINGLE (rv, val[0]);\n+\t\t      print_operand_address (file, GEN_INT (val[0]));\n+\t\t      break;;\n+\t\t    case VOIDmode:\n+\t\t    case DImode:\n+\t\t      print_operand_address (file,\n+\t\t\t\t\t     GEN_INT (CONST_DOUBLE_LOW (x)));\n+\t\t      break;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\n+\t  case CONST_INT:\n+\t    print_operand_address (file, x);\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      /* Similarly, but for the most significant word.  */\n+      case 'H':\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    x = adj_offsettable_operand (x, 4);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)] + 1);\n+\t    break;\n+\n+\t  case CONST_DOUBLE:\n+\t      {\n+\t\tlong val[2];\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tswitch (GET_MODE (x))\n+\t\t  {\n+\t\t    case DFmode:\n+\t\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\t      REAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t\t      print_operand_address (file, GEN_INT (val[1]));\n+\t\t      break;;\n+\t\t    case SFmode:\n+\t\t      abort ();\n+\t\t    case VOIDmode:\n+\t\t    case DImode:\n+\t\t      print_operand_address (file, \n+\t\t\t\t\t     GEN_INT (CONST_DOUBLE_HIGH (x)));\n+\t\t      break;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\n+\t  case CONST_INT:\n+\t    if (INTVAL (x) < 0)\n+\t      print_operand_address (file, GEN_INT (-1));\n+ \t    else\n+\t      print_operand_address (file, GEN_INT (0));\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      case 'A':\n+\tfputc ('(', file);\n+\tif (GET_CODE (XEXP (x, 0)) == REG)\n+\t  output_address (gen_rtx (PLUS, SImode, XEXP (x, 0), GEN_INT (0)));\n+\telse\n+\t  output_address (XEXP (x, 0));\n+\tfputc (')', file);\n+\tbreak;\n+\n       default:\n \tswitch (GET_CODE (x))\n \t  {\n@@ -143,6 +239,10 @@ print_operand (file, x, code)\n \t    fputc (')', file);\n \t    break;\n \n+\t  case PLUS:\n+\t    output_address (x);\n+\t    break;\n+\n \t  case REG:\n \t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n \t    break;\n@@ -152,6 +252,18 @@ print_operand (file, x, code)\n \t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n \t    break;\n \n+\t  /* This will only be single precision....  */\n+\t  case CONST_DOUBLE:\n+\t    {\n+\t      unsigned long val;\n+\t      REAL_VALUE_TYPE rv;\n+\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t      REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\t      print_operand_address (file, GEN_INT (val));\n+\t      break;\n+\t    }\n+\n \t  case CONST_INT:\n \t  case SYMBOL_REF:\n \t  case CONST:\n@@ -208,6 +320,20 @@ print_operand_address (file, addr)\n     }\n }\n \n+int\n+can_use_return_insn ()\n+{\n+  int size = get_frame_size ();\n+\n+  return (reload_completed\n+\t  && size == 0\n+\t  && !regs_ever_live[2]\n+\t  && !regs_ever_live[3]\n+\t  && !regs_ever_live[6]\n+\t  && !regs_ever_live[7]\n+\t  && !frame_pointer_needed);\n+}\n+\n void\n expand_prologue ()\n {\n@@ -262,10 +388,16 @@ expand_epilogue ()\n   else\n     {\n       if (size)\n-\temit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT (size)));\n-      emit_jump_insn (gen_return_internal ());\n+\t{\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t GEN_INT (size)));\n+\t  emit_jump_insn (gen_return_internal ());\n+\t}\n+      else\n+\t{\n+\t  emit_jump_insn (gen_return ());\n+\t}\n     }\n }\n "}, {"sha": "1cac33a125854792451ed3bbaed58fce4c604833", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=38c37a0ef08365d63cad46f0c345dffdb138f5ec", "patch": "@@ -305,21 +305,25 @@ enum reg_class {\n #define CONST_OK_FOR_K(VALUE) ((VALUE) == 2)\n #define CONST_OK_FOR_L(VALUE) ((VALUE) == 4)\n #define CONST_OK_FOR_M(VALUE) ((VALUE) == 3)\n+#define CONST_OK_FOR_N(VALUE) ((VALUE) == 255 || (VALUE) == 65535)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n   ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n    (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n    (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n    (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : 0)\n+   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : \\\n+   (C) == 'N' ? CONST_OK_FOR_N (VALUE) : 0)\n \n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself. \n      \n   `G' is a floating-point zero.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n+\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE))) : 0)\n \n \f\n /* Stack layout; function entry, exit and calling.  */\n@@ -565,8 +569,22 @@ enum reg_class {\n \n /* Extra constraints.  */\n  \n+#define OK_FOR_R(OP) \\\n+   (GET_CODE (OP) == MEM\t\t\t\t\t\\\n+    && GET_MODE (OP) == QImode\t\t\t\t\t\\\n+    && (CONSTANT_ADDRESS_P (XEXP (OP, 0))\t\t\t\\\n+\t|| (GET_CODE (XEXP (OP, 0)) == REG\t\t\t\\\n+\t    && REG_OK_FOR_BASE_P (XEXP (OP, 0))\t\t\t\\\n+\t    && XEXP (OP, 0) != stack_pointer_rtx)\t\t\\\n+\t|| (GET_CODE (XEXP (OP, 0)) == PLUS\t\t\t\\\n+\t    && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\t\\\n+\t    && REG_OK_FOR_BASE_P (XEXP (XEXP (OP, 0), 0))\t\\\n+\t    && XEXP (XEXP (OP, 0), 0) != stack_pointer_rtx\t\\\n+\t    && GET_CODE (XEXP (XEXP (OP, 0), 1)) == CONST_INT\t\\\n+\t    && INT_8_BITS (INTVAL (XEXP (XEXP (OP, 0), 1))))))\n+\t \n #define EXTRA_CONSTRAINT(OP, C) \\\n- ((C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : 0)\n+ ((C) == 'R' ? OK_FOR_R (OP) : (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : 0)\n \n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -635,10 +653,11 @@ enum reg_class {\n \tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n       if (base != 0 && index != 0)\t\t\t\\\n \t{\t\t\t\t\t\t\\\n-\t  if (GET_CODE (index) == CONST_INT)\t\t\\\n+\t  if (CONSTANT_ADDRESS_P (index))\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t  if (REG_P (index)\t\t\t\t\\\n-\t      && REG_OK_FOR_INDEX_P (index))\t\t\\\n+\t      && REG_OK_FOR_INDEX_P (index)\t\t\\\n+\t      && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode)) \\\n \t    goto ADDR;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n@@ -668,8 +687,7 @@ enum reg_class {\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT) \\\n+#define LEGITIMATE_CONSTANT_P(X) 1\n \n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n@@ -691,8 +709,31 @@ enum reg_class {\n    return it with a return statement.  Otherwise, break from the switch.  */\n \n #define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  default: { int _zxy= const_costs(RTX, CODE);\t\\\n-\t     if(_zxy) return _zxy; break;}\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    /* Zeros are extremely cheap.  */\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0 && OUTER_CODE == SET)\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    /* If it fits in 8 bits, then it's still relatively cheap.  */\t\\\n+    if (INT_8_BITS (INTVAL (RTX)))\t\t\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    /* This is the \"base\" cost, includes constants where either the\t\\\n+       upper or lower 16bits are all zeros.  */\t\t\t\t\\\n+    if (INT_16_BITS (INTVAL (RTX))\t\t\t\t\t\\\n+\t|| (INTVAL (RTX) & 0xffff) == 0\t\t\t\t\t\\\n+\t|| (INTVAL (RTX) & 0xffff0000) == 0)\t\t\t\t\\\n+      return 2;\t\t\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\t\\\n+  /* These are more costly than a CONST_INT, but we can relax them,\t\\\n+     so they're less costly than a CONST_DOUBLE.  */\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\t\\\n+  /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\t\\\n+     so their cost is very high.  */\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    return 8;\n+\n \n #define REGISTER_MOVE_COST(CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 0)\n "}, {"sha": "bdc65c82a4d82d596c32e2099e042634dd65f572", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 311, "deletions": 20, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38c37a0ef08365d63cad46f0c345dffdb138f5ec/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=38c37a0ef08365d63cad46f0c345dffdb138f5ec", "patch": "@@ -119,10 +119,9 @@\n     operands[1] = copy_to_mode_reg (SImode, operand1);\n }\")\n \n-;; We could improve loading of some constants with a little work.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a,a,x\")\n-\t(match_operand:SI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim,x,a\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a,aR,x\")\n+\t(match_operand:SI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim,x,aR\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"@\n@@ -153,7 +152,6 @@\n     operands[1] = copy_to_mode_reg (SFmode, operand1);\n }\")\n \n-;; We could improve loading of some constants with a little work.\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=d,a,d,dam,da\")\n \t(match_operand:SF 1 \"general_operand\" \"0,0,G,da,daim\"))]\n@@ -167,6 +165,69 @@\n   mov %1,%0\"\n   [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit\")])\n \n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, DImode)\n+      && !register_operand (operand0, DImode))\n+    operands[1] = copy_to_mode_reg (DImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a\")\n+\t(match_operand:DI 1 \"general_operand\" \"0,0,I,d,a,d,a,dim,aim,dim,aim\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %L0\\;clr %H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, DFmode)\n+      && !register_operand (operand0, DFmode))\n+    operands[1] = copy_to_mode_reg (DFmode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=d,a,d,dm,dm,am,am,d,d,a,a\")\n+\t(match_operand:DF 1 \"general_operand\" \"0,0,G,d,a,d,a,dim,aim,dim,aim\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"@\n+  nop\n+  nop\n+  clr %L0\\;clr %H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\n+  mov %L1,%L0\\;mov %H1,%H0\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+  \n+\n \f\n ;; ----------------------------------------------------------------------\n ;; TEST INSTRUCTIONS\n@@ -182,8 +243,8 @@\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare:SI (match_operand:SI 0 \"register_operand\" \"da\")\n-\t\t    (match_operand:SI 1 \"register_operand\" \"dai\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"da\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"dai\")))]\n   \"\"\n   \"cmp %1,%0\"\n   [(set_attr \"cc\" \"compare\")])\n@@ -193,9 +254,9 @@\n ;; ----------------------------------------------------------------------\n \n (define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=da,a,da,x\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,L,dai,i\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -225,14 +286,56 @@\n   add %2,%0\"\n   [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit\")])\n \n+(define_expand \"adddi3\"\n+  [(set (reg:DI 0) (match_operand:DI 1 \"register_operand\" \"\"))\n+   (set (reg:DI 2) (match_operand:DI 2 \"nonmemory_operand\" \"\"))\n+   (set (reg:DI 0) (plus:DI (reg:DI 0) (reg:DI 2)))\n+   (set (match_operand:DI 0 \"register_operand\" \"\") (reg:DI 0))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx reg0 = gen_rtx (REG, DImode, 0);\n+\n+      emit_move_insn (reg0, operands[1]);\n+      emit_insn (gen_adddi3_const (operands[2]));\n+      emit_move_insn (operands[0], reg0);\n+      DONE;\n+    }\n+}\")\n+\n+;; The general adddi3 pattern.\n+(define_insn \"\"\n+  [(set (reg:DI 0) (plus:DI (reg:DI 0) (reg:DI 2)))]\n+  \"\"\n+  \"add d2,d0\\;addc d3,d1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; adddi3 with on operand being a constant.\n+(define_insn \"adddi3_const\"\n+  [(set (reg:DI 0)\n+        (plus:DI (reg:DI 0) (match_operand:DI 0 \"const_int_operand\" \"i\")))\n+   (clobber (reg:DI 2))]\n+  \"\"\n+  \"*\n+{\n+  long value = INTVAL (operands[0]);\n+\n+  if (value < 0)\n+    return \\\"mov -1,d2\\;add %0,d0\\;addc d2,d1\\\";\n+  else\n+    return \\\"clr d2\\;add %0,d0\\;addc d2,d1\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=da\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"dai\")))]\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"dai\")))]\n   \"\"\n   \"sub %2,%0\"\n   [(set_attr \"cc\" \"set_zn_c0\")])\n@@ -251,6 +354,19 @@\n   DONE;\n }\")\n \n+(define_expand \"subdi3\"\n+  [(set (reg:DI 0) (match_operand:DI 1 \"register_operand\" \"\"))\n+   (set (reg:DI 2) (match_operand:DI 2 \"nonmemory_operand\" \"\"))\n+   (set (reg:DI 0) (minus:DI (reg:DI 0) (reg:DI 2)))\n+   (set (match_operand:DI 0 \"register_operand\" \"\") (reg:DI 0))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:DI 0) (minus:DI (reg:DI 0) (reg:DI 2)))]\n+  \"\"\n+  \"sub d2,d0\\;subc d3,d1\"\n+  [(set_attr \"cc\" \"clobber\")])\n \n ;; ----------------------------------------------------------------------\n ;; MULTIPLY INSTRUCTIONS\n@@ -304,12 +420,19 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,di\")))]\n   \"\"\n-  \"and %2,%0\"\n-  [(set_attr \"cc\" \"set_zn_c0\")])\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n+    return \\\"extbu %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xffff)\n+    return \\\"exthu %0\\\";\n+  return \\\"and %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit,set_zn_c0\")])\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n@@ -349,9 +472,127 @@\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------\n-;; Is it worth defining insv and extv for the MN10300 series?!?\n-;; probably so.\n \n+\n+;; These set/clear memory in byte sized chunks.\n+;;\n+;; They are no smaller/faster than loading the value into a register\n+;; and storing the register, but they don't need a scratch register\n+;; which may allow for better code generation.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=R,d\") (const_int 0))]\n+  \"\"\n+  \"@\n+  bclr 255,%A0\n+  clr %0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=R,d\") (const_int -1))]\n+  \"\"\n+  \"@\n+  bset 255,%A0\n+  mov -1,%0\"\n+  [(set_attr \"cc\" \"clobber,none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=R,d\")\n+\t(subreg:QI\n+\t  (and:SI (subreg:SI (match_dup 0) 0)\n+\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))]\n+  \"\"\n+  \"@\n+  bclr %N1,%A0\n+  and %1,%0\"\n+  [(set_attr \"cc\" \"clobber,set_zn_c0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=R,d\")\n+\t(subreg:QI\n+\t  (ior:SI (subreg:SI (match_dup 0) 0)\n+\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))]\n+  \"\"\n+  \"@\n+  bset %1,%A0\n+  or %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+     (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t      (match_operand 1 \"const_int_operand\" \"\")\n+\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int len = INTVAL (operands[1]);\n+  int bit = INTVAL (operands[2]);\n+  int mask = 0;\n+  rtx xoperands[2];\n+\n+  while (len > 0)\n+    {\n+      mask |= (1 << bit);\n+      bit++;\n+      len--;\n+    }\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = GEN_INT (mask);\n+  output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+     (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,d\")\n+\t\t      (match_operand 1 \"const_int_operand\" \"\")\n+\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[1]) <= 8 && INTVAL (operands[2]) <= 7\"\n+  \"*\n+{\n+  int len = INTVAL (operands[1]);\n+  int bit = INTVAL (operands[2]);\n+  int mask = 0;\n+  rtx xoperands[2];\n+\n+  while (len > 0)\n+    {\n+      mask |= (1 << bit);\n+      bit++;\n+      len--;\n+    }\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = GEN_INT (mask);\n+  if (GET_CODE (operands[0]) == REG)\n+    output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n+  else\n+    output_asm_insn (\\\"btst %1,%A0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (and:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 1 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"btst %1,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+     (and:SI\n+       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,d\") 0)\n+       (match_operand:SI 1 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"@\n+  btst %1,%A0\n+  btst %1,%0\"\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n+\n+;; -----------------------------------------------------------------\n ;; -----------------------------------------------------------------\n ;; Scc INSTRUCTIONS\n ;; -----------------------------------------------------------------\n@@ -602,7 +843,7 @@\n   \"\"\n   \"@\n   extb %0\n-  mov %1,%0\"\n+  mov %1,%0\\;extb %0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n (define_insn \"extendhisi2\"\n@@ -612,9 +853,8 @@\n   \"\"\n   \"@\n   exth %0\n-  mov %1,%0\"\n+  mov %1,%0\\;exth %0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n-\n \f\n ;; ----------------------------------------------------------------------\n ;; SHIFTS\n@@ -694,6 +934,12 @@\n   \"movm [d2,d3,a2,a3],(sp)\"\n   [(set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"return\"\n+  [(return)]\n+  \"can_use_return_insn ()\"\n+  \"rets\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n ;; Try to combine consecutive updates of the stack pointer (or any\n ;; other register for that matter).\n (define_peephole\n@@ -710,3 +956,48 @@\n   return \\\"add %1,%0\\\";\n }\"\n   [(set_attr \"cc\" \"clobber\")])\n+\n+;;\n+;; We had patterns to check eq/ne, but the they don't work because\n+;; 0x80000000 + 0x80000000 = 0x0 with a carry out.\n+;;\n+;; The Z flag and C flag would be set, and we have no way to\n+;; check for the Z flag set and C flag clear.\n+;;\n+;; This will work on the mn10200 because we can check the ZX flag\n+;; if the comparison is in HImode.\n+(define_peephole\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcc %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcs %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcs %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcc %1\"\n+  [(set_attr \"cc\" \"clobber\")])"}]}