{"sha": "3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxZjhkOGMwNDI3ODZhYTc5NDc3NGQxYjUyOWE4ZjgzZDE1YzRjMA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-18T23:27:55Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-18T23:27:55Z"}, "message": "Pass QI/HI structures like the MIPS compiler; define SIZE_TYPE to be int by default.\n\nFrom-SVN: r2893", "tree": {"sha": "0c743b19e91882f96d6d0f1e1d13f23191ca939a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c743b19e91882f96d6d0f1e1d13f23191ca939a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/comments", "author": null, "committer": null, "parents": [{"sha": "d45820250acad85ac8ab3503823587079a45ccab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d45820250acad85ac8ab3503823587079a45ccab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d45820250acad85ac8ab3503823587079a45ccab"}], "stats": {"total": 266, "additions": 188, "deletions": 78}, "files": [{"sha": "8e925b4ac864cfccd9636bf4c309d5779c52d004", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 106, "deletions": 56, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "patch": "@@ -2413,6 +2413,7 @@ init_cumulative_args (cum, fntype, libname)\n      tree fntype;\t\t/* tree ptr for function decl */\n      rtx libname;\t\t/* SYMBOL_REF of library name or 0 */\n {\n+  static CUMULATIVE_ARGS zero_cum;\n   tree param, next_param;\n \n   if (TARGET_DEBUG_E_MODE)\n@@ -2430,9 +2431,7 @@ init_cumulative_args (cum, fntype, libname)\n \t}\n     }\n \n-  cum->gp_reg_found = 0;\n-  cum->arg_number = 0;\n-  cum->arg_words = 0;\n+  *cum = zero_cum;\n \n   /* Determine if this function has variable arguments.  This is\n      indicated by the last argument being 'void_type_mode' if there\n@@ -2461,7 +2460,7 @@ function_arg_advance (cum, mode, type, named)\n {\n   if (TARGET_DEBUG_E_MODE)\n     fprintf (stderr,\n-\t     \"function_adv( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d )\\n\",\n+\t     \"function_adv( {gp reg found = %d, arg # = %2d, words = %2d}, %4s, 0x%.8x, %d )\\n\\n\",\n \t     cum->gp_reg_found, cum->arg_number, cum->arg_words, GET_MODE_NAME (mode),\n \t     type, named);\n \n@@ -2512,8 +2511,12 @@ function_arg (cum, mode, type, named)\n      tree type;\t\t\t/* type of the argument or 0 if lib support */\n      int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n {\n+  rtx ret;\n   int regbase = -1;\n   int bias = 0;\n+  int struct_p = ((type != (tree)0)\n+\t\t  && (TREE_CODE (type) == RECORD_TYPE\n+\t\t      || TREE_CODE (type) == UNION_TYPE));\n \n   if (TARGET_DEBUG_E_MODE)\n     fprintf (stderr,\n@@ -2567,18 +2570,42 @@ function_arg (cum, mode, type, named)\n   if (cum->arg_words >= MAX_ARGS_IN_REGISTERS)\n     {\n       if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"<stack>\\n\");\n+\tfprintf (stderr, \"<stack>%s\\n\", struct_p ? \", [struct]\" : \"\");\n \n-      return 0;\n+      ret = (rtx)0;\n     }\n+  else\n+    {\n+      if (regbase == -1)\n+\tabort ();\n \n-  if (regbase == -1)\n-    abort ();\n+      ret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n \n-  if (TARGET_DEBUG_E_MODE)\n-    fprintf (stderr, \"%s\\n\", reg_names[regbase + cum->arg_words + bias]);\n+      if (TARGET_DEBUG_E_MODE)\n+\tfprintf (stderr, \"%s%s\\n\", reg_names[regbase + cum->arg_words + bias],\n+\t\t struct_p ? \", [struct]\" : \"\");\n+\n+      /* The following is a hack in order to pass 1 byte structures\n+\t the same way that the MIPS compiler does (namely by passing\n+\t the structure in the high byte or half word of the register).\n+\t This also makes varargs work.  If we have such a structure,\n+\t we save the adjustment RTL, and the call define expands will\n+\t emit them.  For the VOIDmode argument (argument after the\n+\t last real argument, pass back a parallel vector holding each\n+\t of the adjustments.  */\n+\n+      if (struct_p && (mode == QImode || mode == HImode))\n+\t{\n+\t  rtx amount = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (mode));\n+\t  rtx reg = gen_rtx (REG, SImode, regbase + cum->arg_words + bias);\n+\t  cum->adjust[ cum->num_adjusts++ ] = gen_ashlsi3 (reg, reg, amount);\n+\t}\n+    }\n+\n+  if (mode == VOIDmode && cum->num_adjusts > 0)\n+    ret = gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (cum->num_adjusts, cum->adjust));\n \n-  return gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+  return ret;\n }\n \n \n@@ -4237,20 +4264,56 @@ mips_expand_prologue ()\n {\n   int regno;\n   long tsize;\n-  tree fndecl = current_function_decl; /* current... is tooo long */\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree fnargs = (TREE_CODE (fntype) != METHOD_TYPE)\n+  rtx tmp_rtx\t = (rtx)0;\n+  char *arg_name = (char *)0;\n+  tree fndecl\t = current_function_decl;\n+  tree fntype\t = TREE_TYPE (fndecl);\n+  tree fnargs\t = (TREE_CODE (fntype) != METHOD_TYPE)\n \t\t\t? DECL_ARGUMENTS (fndecl)\n \t\t\t: 0;\n+  rtx next_arg_reg;\n+  int i;\n   tree next_arg;\n   tree cur_arg;\n-  rtx tmp_rtx\t = (rtx)0;\n-  char *arg_name = (char *)0;\n   CUMULATIVE_ARGS args_so_far;\n \n   /* Determine the last argument, and get its name.  */\n+\n+  INIT_CUMULATIVE_ARGS (args_so_far, fntype, (rtx)0);\n+  regno = GP_ARG_FIRST;\n+\n   for (cur_arg = fnargs; cur_arg != (tree)0; cur_arg = next_arg)\n     {\n+      tree type = DECL_ARG_TYPE (cur_arg);\n+      enum machine_mode passed_mode = TYPE_MODE (type);\n+      rtx entry_parm = FUNCTION_ARG (args_so_far,\n+\t\t\t\t     passed_mode,\n+\t\t\t\t     DECL_ARG_TYPE (cur_arg),\n+\t\t\t\t     1);\n+\n+      if (entry_parm)\n+\t{\n+\t  int words;\n+\n+\t  /* passed in a register, so will get homed automatically */\n+\t  if (GET_MODE (entry_parm) == BLKmode)\n+\t    words = (int_size_in_bytes (type) + 3) / 4;\n+\t  else\n+\t    words = (GET_MODE_SIZE (GET_MODE (entry_parm)) + 3) / 4;\n+\n+\t  regno = REGNO (entry_parm) + words - 1;\n+\t}\n+      else\n+\t{\n+\t  regno = GP_ARG_LAST+1;\n+\t  break;\n+\t}\n+\n+      FUNCTION_ARG_ADVANCE (args_so_far,\n+\t\t\t    passed_mode,\n+\t\t\t    DECL_ARG_TYPE (cur_arg),\n+\t\t\t    1);\n+\n       next_arg = TREE_CHAIN (cur_arg);\n       if (next_arg == (tree)0)\n \t{\n@@ -4261,52 +4324,39 @@ mips_expand_prologue ()\n \t}\n     }\n \n-  /* If this function is a varargs function, store any registers that\n-     would normally hold arguments ($4 - $7) on the stack.  */\n-  if ((TYPE_ARG_TYPES (fntype) != 0\n-       && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype))) != void_type_node))\n-      || (arg_name\n-\t  && (strcmp (arg_name, \"__builtin_va_alist\") == 0\n-\t      || strcmp (arg_name, \"va_alist\") == 0)))\n-    {\n-      tree parm;\n+  /* In order to pass small structures by value in registers\n+     compatibly with the MIPS compiler, we need to shift the value\n+     into the high part of the register.  Function_arg has encoded a\n+     PARALLEL rtx, holding a vector of adjustments to be made as the\n+     next_arg_reg variable, so we split up the insns, and emit them\n+     separately.  */\n \n-      regno = GP_ARG_FIRST;\n-      INIT_CUMULATIVE_ARGS (args_so_far, fntype, (rtx)0);\n+  next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n+  if (next_arg_reg != (rtx)0 && GET_CODE (next_arg_reg) == PARALLEL)\n+    {\n+      rtvec adjust = XVEC (next_arg_reg, 0);\n+      int num = GET_NUM_ELEM (adjust);\n \n-      for (parm = fnargs; (parm && (regno <= GP_ARG_LAST)); parm = TREE_CHAIN (parm))\n+      for (i = 0; i < num; i++)\n \t{\n-\t  rtx entry_parm;\n-\t  enum machine_mode passed_mode;\n-\t  tree type;\n-\n-\t  type = DECL_ARG_TYPE (parm);\n-\t  passed_mode = TYPE_MODE (type);\n-\t  entry_parm = FUNCTION_ARG (args_so_far, passed_mode,\n-\t\t\t\t     DECL_ARG_TYPE (parm), 1);\n-\n-\t  if (entry_parm)\n-\t    {\n-\t      int words;\n-\n-\t      /* passed in a register, so will get homed automatically */\n-\t      if (GET_MODE (entry_parm) == BLKmode)\n-\t\twords = (int_size_in_bytes (type) + 3) / 4;\n-\t      else\n-\t\twords = (GET_MODE_SIZE (GET_MODE (entry_parm)) + 3) / 4;\n-\n-\t      regno = REGNO (entry_parm) + words - 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      regno = GP_ARG_LAST+1;\n-\t      break;\n-\t    }\n+\t  rtx pattern = RTVEC_ELT (adjust, i);\n+\t  if (GET_CODE (pattern) != SET\n+\t      || GET_CODE (SET_SRC (pattern)) != ASHIFT)\n+\t    abort_with_insn (pattern, \"Insn is not a shift\");\n \n-\t  FUNCTION_ARG_ADVANCE (args_so_far, passed_mode,\n-\t\t\t\tDECL_ARG_TYPE (parm), 1);\n+\t  PUT_CODE (SET_SRC (pattern), ASHIFTRT);\n+\t  emit_insn (pattern);\n \t}\n+    }\n \n+  /* If this function is a varargs function, store any registers that\n+     would normally hold arguments ($4 - $7) on the stack.  */\n+  if ((TYPE_ARG_TYPES (fntype) != 0\n+       && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype))) != void_type_node))\n+      || (arg_name != (char *)0\n+\t  && ((arg_name[0] == '_' && strcmp (arg_name, \"__builtin_va_alist\") == 0)\n+\t      || (arg_name[0] == 'v' && strcmp (arg_name, \"va_alist\") == 0))))\n+    {\n       for (; regno <= GP_ARG_LAST; regno++)\n \t{\n \t  rtx ptr = stack_pointer_rtx;"}, {"sha": "53636b1e74a8966bedb4b2a7ecb1c6679ea797c7", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "patch": "@@ -483,7 +483,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 32]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 33]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -1809,9 +1809,12 @@ extern struct mips_frame_info current_frame_info;\n */\n \n typedef struct mips_args {\n-  int gp_reg_found;\n-  int arg_number;\n-  int arg_words;\n+  int gp_reg_found;\t\t/* whether a gp register was found yet */\n+  int arg_number;\t\t/* argument number */\n+  int arg_words;\t\t/* # total words the arguments take */\n+  int num_adjusts;\t\t/* number of adjustments made */\n+\t\t\t\t/* Adjustments made to args pass in regs.  */\n+  struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS];\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -3525,3 +3528,15 @@ while (0)\n #define MIPS_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)\n #define MIPS_MARK_STAB(code) ((code)+CODE_MASK)\n #define MIPS_UNMARK_STAB(code) ((code)-CODE_MASK)\n+\n+\f\n+/* Default definitions for size_t and ptrdiff_t.  */\n+\n+#ifndef SIZE_TYPE\n+#define SIZE_TYPE\t\"unsigned int\"\n+#endif\n+\n+#ifndef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE\t\"int\"\n+#endif\n+"}, {"sha": "42f3c7c50e5035bebf89f148fc3e97db354fd53b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1f8d8c042786aa794774d1b529a8f83d15c4c0/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=3f1f8d8c042786aa794774d1b529a8f83d15c4c0", "patch": "@@ -4043,17 +4043,41 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"m\")\n \t\t    (match_operand 1 \"\" \"i\"))\n-\t      (clobber (match_operand 2 \"\" \"\"))])]\t;; overwrite op2 with $31\n+\t      (clobber (reg:SI 31))\n+\t      (use (match_operand 2 \"\" \"\"))\t\t;; next_arg_reg\n+\t      (use (match_operand 3 \"\" \"\"))])]\t\t;; struct_value_size_rtx\n   \"\"\n   \"\n {\n   rtx addr;\n \n-  operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n+  if (operands[0])\t\t/* eliminate unused code warnings */\n+    {\n+      addr = XEXP (operands[0], 0);\n+      if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n+\tXEXP (operands[0], 0) = force_reg (FUNCTION_MODE, addr);\n+\n+      /* In order to pass small structures by value in registers\n+\t compatibly with the MIPS compiler, we need to shift the value\n+\t into the high part of the register.  Function_arg has encoded\n+\t a PARALLEL rtx, holding a vector of adjustments to be made\n+\t as the next_arg_reg variable, so we split up the insns,\n+\t and emit them separately.  */\n+\n+      if (operands[2] != (rtx)0 && GET_CODE (operands[2]) == PARALLEL)\n+\t{\n+\t  rtvec adjust = XVEC (operands[2], 0);\n+\t  int num = GET_NUM_ELEM (adjust);\n+\t  int i;\n+\n+\t  for (i = 0; i < num; i++)\n+\t    emit_insn (RTVEC_ELT (adjust, i));\n+\t}\n \n-  addr = XEXP (operands[0], 0);\n-  if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[0], 0) = force_reg (FUNCTION_MODE, addr);\n+      emit_call_insn (gen_call_internal (operands[0], operands[1],\n+\t\t\t\t\t gen_rtx (REG, Pmode, GP_REG_FIRST + 31)));\n+      DONE;\n+    }\n }\")\n \n (define_insn \"call_internal\"\n@@ -4071,15 +4095,13 @@ move\\\\t%0,%z4\\\\n\\\\\n   else if (GET_CODE (target) == CONST_INT)\n     {\n       operands[0] = target;\n-      operands[1] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n-      return \\\"%*%[li\\\\t%@,%0\\\\n\\\\tjal\\\\t%1,%@%]\\\";\n+      return \\\"%*%[li\\\\t%@,%0\\\\n\\\\tjal\\\\t%2,%@%]\\\";\n     }\n \n   else\n     {\n       operands[0] = target;\n-      operands[1] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n-      return \\\"%*jal\\\\t%1,%0\\\";\n+      return \\\"%*jal\\\\t%2,%0\\\";\n     }\n }\"\n   [(set_attr \"type\"\t\"call\")\n@@ -4092,17 +4114,42 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(parallel [(set (match_operand 0 \"register_operand\" \"=df\")\n \t\t   (call (match_operand 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand 2 \"\" \"i\")))\n-\t      (clobber (match_operand 3 \"\" \"\"))])]\t;; overwrite op3 with $31\n+\t      (clobber (reg:SI 31))\n+\t      (use (match_operand 3 \"\" \"\"))])]\t\t;; next_arg_reg\n   \"\"\n   \"\n {\n   rtx addr;\n \n-  operands[3] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n+  if (operands[0])\t\t/* eliminate unused code warning */\n+    {\n+      addr = XEXP (operands[1], 0);\n+      if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n+\tXEXP (operands[1], 0) = force_reg (FUNCTION_MODE, addr);\n+\n+      /* In order to pass small structures by value in registers\n+\t compatibly with the MIPS compiler, we need to shift the value\n+\t into the high part of the register.  Function_arg has encoded\n+\t a PARALLEL rtx, holding a vector of adjustments to be made\n+\t as the next_arg_reg variable, so we split up the insns,\n+\t and emit them separately.  */\n+\n+      if (operands[3] != (rtx)0 && GET_CODE (operands[3]) == PARALLEL)\n+\t{\n+\t  rtvec adjust = XVEC (operands[3], 0);\n+\t  int num = GET_NUM_ELEM (adjust);\n+\t  int i;\n+\n+\t  for (i = 0; i < num; i++)\n+\t    emit_insn (RTVEC_ELT (adjust, i));\n+\t}\n+\n+      emit_call_insn (gen_call_value_internal (operands[0], operands[1], operands[2],\n+\t\t\t\t\t       gen_rtx (REG, Pmode, GP_REG_FIRST + 31)));\n+\n+      DONE;\n+    }\n \n-  addr = XEXP (operands[1], 0);\n-  if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[1], 0) = force_reg (FUNCTION_MODE, addr);\n }\")\n \n (define_insn \"call_value_internal\"\n@@ -4121,15 +4168,13 @@ move\\\\t%0,%z4\\\\n\\\\\n   else if (GET_CODE (target) == CONST_INT)\n     {\n       operands[1] = target;\n-      operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n-      return \\\"%*%[li\\\\t%@,%1\\\\n\\\\tjal\\\\t%2,%@%]\\\";\n+      return \\\"%*%[li\\\\t%@,%1\\\\n\\\\tjal\\\\t%3,%@%]\\\";\n     }\n \n   else\n     {\n       operands[1] = target;\n-      operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n-      return \\\"%*jal\\\\t%2,%1\\\";\n+      return \\\"%*jal\\\\t%3,%1\\\";\n     }\n }\"\n   [(set_attr \"type\"\t\"call\")"}]}