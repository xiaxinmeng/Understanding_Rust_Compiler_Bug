{"sha": "7916a546ed8115dbe61806a919ece4de400efaf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkxNmE1NDZlZDgxMTVkYmU2MTgwNmE5MTllY2U0ZGU0MDBlZmFmMQ==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2010-06-21T07:29:55Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2010-06-21T07:29:55Z"}, "message": "i386.c (ix86_compute_frame_layout): Avoid stack-alignment for simple leaf-functions.\n\n2010-06-21  Kai Tietz  <kai.tietz@onevision.com>\n\n        * config/i386/i386.c (ix86_compute_frame_layout): Avoid\n        stack-alignment for simple leaf-functions.\n\nFrom-SVN: r161064", "tree": {"sha": "04e4ae79dd1fe7d860676dd2335e207e07441bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04e4ae79dd1fe7d860676dd2335e207e07441bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7916a546ed8115dbe61806a919ece4de400efaf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7916a546ed8115dbe61806a919ece4de400efaf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7916a546ed8115dbe61806a919ece4de400efaf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7916a546ed8115dbe61806a919ece4de400efaf1/comments", "author": null, "committer": null, "parents": [{"sha": "64bf6102aa03c1feda71400d6391a9396139fac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64bf6102aa03c1feda71400d6391a9396139fac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64bf6102aa03c1feda71400d6391a9396139fac0"}], "stats": {"total": 129, "additions": 68, "deletions": 61}, "files": [{"sha": "652cd379c869143550dca4b02699e920f0958de8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7916a546ed8115dbe61806a919ece4de400efaf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7916a546ed8115dbe61806a919ece4de400efaf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7916a546ed8115dbe61806a919ece4de400efaf1", "patch": "@@ -1,3 +1,8 @@\n+2010-06-21  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Avoid\n+\tstack-alignment for simple leaf-functions.\n+\n 2010-06-20  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* doc/install.texi: Document bootstrap-lto."}, {"sha": "f9c0718e391a0f5eabdf8755a13bd213f3f67da4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7916a546ed8115dbe61806a919ece4de400efaf1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7916a546ed8115dbe61806a919ece4de400efaf1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7916a546ed8115dbe61806a919ece4de400efaf1", "patch": "@@ -2725,7 +2725,7 @@ override_options (bool main_args_p)\n {\n   int i;\n   unsigned int ix86_arch_mask, ix86_tune_mask;\n-  const bool ix86_tune_specified = (ix86_tune_string != NULL); \n+  const bool ix86_tune_specified = (ix86_tune_string != NULL);\n   const char *prefix;\n   const char *suffix;\n   const char *sw;\n@@ -2850,7 +2850,7 @@ override_options (bool main_args_p)\n       {\"bdver1\", PROCESSOR_BDVER1, CPU_BDVER1,\n \tPTA_64BIT | PTA_MMX | PTA_3DNOW | PTA_3DNOW_A | PTA_SSE\n \t| PTA_SSE2 | PTA_SSE3 | PTA_SSE4A | PTA_CX16 | PTA_ABM\n-\t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AES \n+\t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AES\n \t| PTA_PCLMUL | PTA_AVX | PTA_FMA4 | PTA_XOP | PTA_LWP},\n       {\"generic32\", PROCESSOR_GENERIC32, CPU_PENTIUMPRO,\n \t0 /* flags are only used for -march switch.  */ },\n@@ -4324,13 +4324,13 @@ x86_64_elf_unique_section (tree decl, int reloc)\n \n \t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \t  name = targetm.strip_name_encoding (name);\n-\t  \n+\n \t  /* If we're using one_only, then there needs to be a .gnu.linkonce\n      \t     prefix to the section name.  */\n \t  linkonce = one_only ? \".gnu.linkonce\" : \"\";\n-  \n+\n \t  string = ACONCAT ((linkonce, prefix, \".\", name, NULL));\n-\t  \n+\n \t  DECL_SECTION_NAME (decl) = build_string (strlen (string), string);\n \t  return;\n \t}\n@@ -5181,7 +5181,7 @@ type_natural_mode (const_tree type, CUMULATIVE_ARGS *cum)\n \t\t    static bool warnedavx;\n \n \t\t    if (cum\n-\t\t\t&& !warnedavx \n+\t\t\t&& !warnedavx\n \t\t\t&& cum->warn_avx)\n \t\t      {\n \t\t\twarnedavx = true;\n@@ -5362,7 +5362,7 @@ classify_argument (enum machine_mode mode, const_tree type,\n \t\t\t      == NULL_TREE))\n \t\t\t{\n \t\t\t  static bool warned;\n-\t\t\t  \n+\n \t\t\t  if (!warned && warn_psabi)\n \t\t\t    {\n \t\t\t      warned = true;\n@@ -5784,7 +5784,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n \tif (mode != BLKmode)\n-\t  return gen_reg_or_parallel (mode, orig_mode, \n+\t  return gen_reg_or_parallel (mode, orig_mode,\n \t\t\t\t      SSE_REGNO (sse_regno));\n \tbreak;\n       case X86_64_X87_CLASS:\n@@ -6694,7 +6694,7 @@ ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   return SUBTARGET_RETURN_IN_MEMORY (type, fntype);\n #else\n   const enum machine_mode mode = type_natural_mode (type, NULL);\n- \n+\n   if (TARGET_64BIT)\n     {\n       if (ix86_function_type_abi (fntype) == MS_ABI)\n@@ -7567,7 +7567,7 @@ standard_sse_constant_opcode (rtx insn, rtx x)\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t    return TARGET_AVX ? \"vxorps\\t%0, %0, %0\" : \"xorps\\t%0, %0\";\n \t  else\n-\t    return TARGET_AVX ? \"vxorpd\\t%0, %0, %0\" : \"xorpd\\t%0, %0\";\t    \n+\t    return TARGET_AVX ? \"vxorpd\\t%0, %0, %0\" : \"xorpd\\t%0, %0\";\n \tcase MODE_TI:\n \t  if (TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t    return TARGET_AVX ? \"vxorps\\t%0, %0, %0\" : \"xorps\\t%0, %0\";\n@@ -8101,8 +8101,10 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n \n   /* MS ABI seem to require stack alignment to be always 16 except for function\n-     prologues.  */\n-  if (ix86_cfun_abi () == MS_ABI && preferred_alignment < 16)\n+     prologues and leaf.  */\n+  if ((ix86_cfun_abi () == MS_ABI && preferred_alignment < 16)\n+      && (!current_function_is_leaf || cfun->calls_alloca != 0\n+          || ix86_current_function_calls_tls_descriptor))\n     {\n       preferred_alignment = 16;\n       stack_alignment_needed = 16;\n@@ -8177,7 +8179,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     frame->padding0 = ((offset + 16 - 1) & -16) - offset;\n   else\n     frame->padding0 = 0;\n-  \n+\n   /* SSE register save area.  */\n   offset += frame->padding0 + frame->nsseregs * 16;\n \n@@ -8395,7 +8397,7 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n       gcc_assert (ix86_cfa_state->reg == src);\n       ix86_cfa_state->offset += INTVAL (offset);\n       ix86_cfa_state->reg = dest;\n-    \n+\n       r = gen_rtx_PLUS (Pmode, src, offset);\n       r = gen_rtx_SET (VOIDmode, dest, r);\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, r);\n@@ -8416,7 +8418,7 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n \n    Return: the regno of chosen register.  */\n \n-static unsigned int \n+static unsigned int\n find_drap_reg (void)\n {\n   tree decl = cfun->decl;\n@@ -8440,7 +8442,7 @@ find_drap_reg (void)\n \t register in such case.  */\n       if (DECL_STATIC_CHAIN (decl) || crtl->tail_call_emit)\n \treturn DI_REG;\n-    \n+\n       /* Reuse static chain register if it isn't used for parameter\n          passing.  */\n       if (ix86_function_regparm (TREE_TYPE (decl), decl) <= 2\n@@ -8465,7 +8467,7 @@ ix86_minimum_incoming_stack_boundary (bool sibcall)\n   if (ix86_user_incoming_stack_boundary)\n     incoming_stack_boundary = ix86_user_incoming_stack_boundary;\n   /* In 32bit, use MIN_STACK_BOUNDARY for incoming stack boundary\n-     if -mstackrealign is used, it isn't used for sibcall check and \n+     if -mstackrealign is used, it isn't used for sibcall check and\n      estimated stack alignment is 128bit.  */\n   else if (!sibcall\n \t   && !TARGET_64BIT\n@@ -8539,7 +8541,7 @@ ix86_get_drap_rtx (void)\n       drap_vreg = copy_to_reg (arg_ptr);\n       seq = get_insns ();\n       end_sequence ();\n-      \n+\n       insn = emit_insn_before (seq, NEXT_INSN (entry_of_function ()));\n       if (!optimize)\n \t{\n@@ -8562,10 +8564,10 @@ ix86_internal_arg_pointer (void)\n \n /* Finalize stack_realign_needed flag, which will guide prologue/epilogue\n    to be generated in correct form.  */\n-static void \n+static void\n ix86_finalize_stack_realign_flags (void)\n {\n-  /* Check if stack realign is really needed after reload, and \n+  /* Check if stack realign is really needed after reload, and\n      stores result in cfun */\n   unsigned int incoming_stack_boundary\n     = (crtl->parm_stack_boundary > ix86_incoming_stack_boundary\n@@ -8698,7 +8700,7 @@ ix86_expand_prologue (void)\n \t}\n \n       insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n-      RTX_FRAME_RELATED_P (insn) = 1; \n+      RTX_FRAME_RELATED_P (insn) = 1;\n       ix86_cfa_state->reg = crtl->drap_reg;\n \n       /* Align the stack.  */\n@@ -8760,7 +8762,7 @@ ix86_expand_prologue (void)\n   if (!TARGET_64BIT_MS_ABI && TARGET_RED_ZONE && frame.save_regs_using_mov\n       && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT))\n     ix86_emit_save_regs_using_mov ((frame_pointer_needed\n-\t\t\t\t     && !crtl->stack_realign_needed) \n+\t\t\t\t     && !crtl->stack_realign_needed)\n                                    ? hard_frame_pointer_rtx\n \t\t\t\t   : stack_pointer_rtx,\n \t\t\t\t   -frame.nregs * UNITS_PER_WORD);\n@@ -8992,7 +8994,7 @@ ix86_emit_leave (HOST_WIDE_INT red_offset)\n       ix86_cfa_state->reg = stack_pointer_rtx;\n       ix86_cfa_state->offset -= UNITS_PER_WORD;\n \n-      add_reg_note (insn, REG_CFA_ADJUST_CFA, \n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 0)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       ix86_add_cfa_restore_note (insn, hard_frame_pointer_rtx, red_offset);\n@@ -9111,7 +9113,7 @@ ix86_expand_epilogue (int style)\n   /* See the comment about red zone and frame\n      pointer usage in ix86_expand_prologue.  */\n   if (frame_pointer_needed && frame.red_zone_size)\n-    emit_insn (gen_memory_blockage ()); \n+    emit_insn (gen_memory_blockage ());\n \n   using_drap = crtl->drap_reg && crtl->stack_realign_needed;\n   gcc_assert (!using_drap || ix86_cfa_state->reg == crtl->drap_reg);\n@@ -9167,13 +9169,13 @@ ix86_expand_epilogue (int style)\n \t locations.  If both are available, default to ebp, since offsets\n \t are known to be small.  Only exception is esp pointing directly\n \t to the end of block of saved registers, where we may simplify\n-\t addressing mode.  \n+\t addressing mode.\n \n \t If we are realigning stack with bp and sp, regs restore can't\n \t be addressed by bp. sp must be used instead.  */\n \n       if (!frame_pointer_needed\n-\t  || (sp_valid && !(frame.to_allocate + frame.padding0)) \n+\t  || (sp_valid && !(frame.to_allocate + frame.padding0))\n \t  || stack_realign_fp)\n \t{\n \t  ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n@@ -9289,7 +9291,7 @@ ix86_expand_epilogue (int style)\n \n \t If we realign stack with frame pointer, then stack pointer\n          won't be able to recover via lea $offset(%bp), %sp, because\n-         there is a padding area between bp and sp for realign. \n+         there is a padding area between bp and sp for realign.\n          \"add $to_allocate, %sp\" must be used instead.  */\n       if (!sp_valid)\n \t{\n@@ -9330,8 +9332,8 @@ ix86_expand_epilogue (int style)\n \t    ix86_emit_leave (red_offset);\n \t  else\n             {\n-              /* For stack realigned really happens, recover stack \n-                 pointer to hard frame pointer is a must, if not using \n+              /* For stack realigned really happens, recover stack\n+                 pointer to hard frame pointer is a must, if not using\n                  leave.  */\n               if (stack_realign_fp)\n \t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n@@ -9380,7 +9382,7 @@ ix86_expand_epilogue (int style)\n \n       gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n       ix86_cfa_state->offset += UNITS_PER_WORD;\n-    \n+\n       r = gen_rtx_REG (Pmode, CX_REG);\n       insn = emit_insn (ix86_gen_pop1 (r));\n \n@@ -11768,7 +11770,7 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t  output_operand_lossage\n \t    (\"invalid operand size for operand code '%c'\", code);\n \t  return;\n-\t    \n+\n \tcase 'd':\n \tcase 'b':\n \tcase 'w':\n@@ -13375,7 +13377,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  op1 = gen_lowpart (mode, op1);\n \n \t  switch (mode)\n-\t    { \n+\t    {\n \t    case V4SFmode:\n \t      emit_insn (gen_avx_movups (op0, op1));\n \t      break;\n@@ -13410,7 +13412,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n   if (MEM_P (op1))\n     {\n       /* If we're optimizing for size, movups is the smallest.  */\n-      if (optimize_insn_for_size_p () \n+      if (optimize_insn_for_size_p ()\n \t  || TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL)\n \t{\n \t  op0 = gen_lowpart (V4SFmode, op0);\n@@ -13519,7 +13521,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t    {\n \t      op0 = gen_lowpart (V2DFmode, op0);\n \t      op1 = gen_lowpart (V2DFmode, op1);\n-\t      emit_insn (gen_sse2_movupd (op0, op1));\t      \n+\t      emit_insn (gen_sse2_movupd (op0, op1));\n \t    }\n \t  else\n \t    {\n@@ -13537,7 +13539,7 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  if (TARGET_SSE_UNALIGNED_STORE_OPTIMAL)\n \t    {\n \t      op0 = gen_lowpart (V4SFmode, op0);\n-\t      emit_insn (gen_sse_movups (op0, op1));\t      \n+\t      emit_insn (gen_sse_movups (op0, op1));\n \t    }\n \t  else\n \t    {\n@@ -13806,7 +13808,7 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n #define LEA_SEARCH_THRESHOLD 12\n \n /* Search backward for non-agu definition of register number REGNO1\n-   or register number REGNO2 in INSN's basic block until \n+   or register number REGNO2 in INSN's basic block until\n    1. Pass LEA_SEARCH_THRESHOLD instructions, or\n    2. Reach BB boundary, or\n    3. Reach agu definition.\n@@ -13846,20 +13848,20 @@ distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n \t  prev = PREV_INSN (prev);\n \t}\n     }\n-  \n+\n   if (distance < LEA_SEARCH_THRESHOLD)\n     {\n       edge e;\n       edge_iterator ei;\n       bool simple_loop = false;\n-  \n+\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \tif (e->src == bb)\n \t  {\n \t    simple_loop = true;\n \t    break;\n \t  }\n-  \n+\n       if (simple_loop)\n \t{\n \t  rtx prev = BB_END (bb);\n@@ -13896,7 +13898,7 @@ distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n   return distance;\n }\n \n-/* Return the distance between INSN and the next insn that uses \n+/* Return the distance between INSN and the next insn that uses\n    register number REGNO0 in memory address.  Return -1 if no such\n    a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */\n \n@@ -13947,14 +13949,14 @@ distance_agu_use (unsigned int regno0, rtx insn)\n       edge e;\n       edge_iterator ei;\n       bool simple_loop = false;\n-  \n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n         if (e->dest == bb)\n \t  {\n \t    simple_loop = true;\n \t    break;\n \t  }\n-  \n+\n       if (simple_loop)\n \t{\n \t  rtx next = BB_HEAD (bb);\n@@ -13989,7 +13991,7 @@ distance_agu_use (unsigned int regno0, rtx insn)\n \t      next = NEXT_INSN (next);\n \t    }\n \t}\n-    }  \n+    }\n \n   return -1;\n }\n@@ -14023,7 +14025,7 @@ ix86_lea_for_add_ok (enum rtx_code code ATTRIBUTE_UNUSED,\n   /* If a = b + c, (a!=b && a!=c), must use lea form. */\n   if (regno0 != regno1 && regno0 != regno2)\n     return true;\n-  else    \n+  else\n     {\n       int dist_define, dist_use;\n       dist_define = distance_non_agu_define (regno1, regno2, insn);\n@@ -14085,7 +14087,7 @@ ix86_dep_by_shift_count_body (const_rtx set_body, const_rtx use_body)\n       break;\n     }\n \n-  if (shift_rtx \n+  if (shift_rtx\n       && (GET_CODE (shift_rtx) == ASHIFT\n \t  || GET_CODE (shift_rtx) == LSHIFTRT\n \t  || GET_CODE (shift_rtx) == ASHIFTRT\n@@ -14915,7 +14917,7 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n }\n \n \n-/* Return a comparison we can do and that it is equivalent to \n+/* Return a comparison we can do and that it is equivalent to\n    swap_condition (code) apart possibly from orderedness.\n    But, never change orderedness if TARGET_IEEE_FP, returning\n    UNKNOWN in that case if necessary.  */\n@@ -18261,7 +18263,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t\t\t       && alg != rep_prefix_4_byte      \\\n \t\t\t       && alg != rep_prefix_8_byte))\n   const struct processor_costs *cost;\n-  \n+\n   /* Even if the string operation call is cold, we still might spend a lot\n      of time processing large blocks.  */\n   if (optimize_function_for_size_p (cfun)\n@@ -19435,7 +19437,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     }\n \n   if (ix86_cmodel == CM_LARGE_PIC\n-      && MEM_P (fnaddr) \n+      && MEM_P (fnaddr)\n       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n       && !local_symbolic_operand (XEXP (fnaddr, 0), VOIDmode))\n     fnaddr = gen_rtx_MEM (QImode, construct_plt_address (XEXP (fnaddr, 0)));\n@@ -20408,7 +20410,7 @@ ix86_static_chain (const_tree fndecl, bool incoming_p)\n }\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNDECL is the decl of the target address; M_TRAMP is a MEM for \n+   FNDECL is the decl of the target address; M_TRAMP is a MEM for\n    the trampoline, and CHAIN_VALUE is an RTX for the static chain\n    to be passed to the target function.  */\n \n@@ -22517,7 +22519,7 @@ static const struct builtin_description bdesc_multi_arg[] =\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfmsubv2df4,     \"__builtin_ia32_vfmsubsd\",    IX86_BUILTIN_VFMSUBSD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv4sf4,       \"__builtin_ia32_vfmsubps\",    IX86_BUILTIN_VFMSUBPS,    UNKNOWN,      (int)MULTI_ARG_3_SF },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv2df4,       \"__builtin_ia32_vfmsubpd\",    IX86_BUILTIN_VFMSUBPD,    UNKNOWN,      (int)MULTI_ARG_3_DF },\n-    \n+\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmaddv4sf4,    \"__builtin_ia32_vfnmaddss\",   IX86_BUILTIN_VFNMADDSS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_vmfnmaddv2df4,    \"__builtin_ia32_vfnmaddsd\",   IX86_BUILTIN_VFNMADDSD,   UNKNOWN,      (int)MULTI_ARG_3_DF },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv4sf4,      \"__builtin_ia32_vfnmaddps\",   IX86_BUILTIN_VFNMADDPS,   UNKNOWN,      (int)MULTI_ARG_3_SF },\n@@ -22536,7 +22538,7 @@ static const struct builtin_description bdesc_multi_arg[] =\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmaddv4df4256,       \"__builtin_ia32_vfmaddpd256\",    IX86_BUILTIN_VFMADDPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv8sf4256,       \"__builtin_ia32_vfmsubps256\",    IX86_BUILTIN_VFMSUBPS256,    UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fmsubv4df4256,       \"__builtin_ia32_vfmsubpd256\",    IX86_BUILTIN_VFMSUBPD256,    UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n-  \n+\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv8sf4256,      \"__builtin_ia32_vfnmaddps256\",   IX86_BUILTIN_VFNMADDPS256,   UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmaddv4df4256,      \"__builtin_ia32_vfnmaddpd256\",   IX86_BUILTIN_VFNMADDPD256,   UNKNOWN,      (int)MULTI_ARG_3_DF2 },\n   { OPTION_MASK_ISA_FMA4, CODE_FOR_fma4i_fnmsubv8sf4256,      \"__builtin_ia32_vfnmsubps256\",   IX86_BUILTIN_VFNMSUBPS256,   UNKNOWN,      (int)MULTI_ARG_3_SF2 },\n@@ -23833,8 +23835,8 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n     case V8HI_FTYPE_V8HI_V8HI_INT:\n     case V8SI_FTYPE_V8SI_V8SI_INT:\n     case V8SI_FTYPE_V8SI_V4SI_INT:\n-    case V8SF_FTYPE_V8SF_V8SF_INT: \n-    case V8SF_FTYPE_V8SF_V4SF_INT: \n+    case V8SF_FTYPE_V8SF_V8SF_INT:\n+    case V8SF_FTYPE_V8SF_V4SF_INT:\n     case V4SI_FTYPE_V4SI_V4SI_INT:\n     case V4DF_FTYPE_V4DF_V4DF_INT:\n     case V4DF_FTYPE_V4DF_V2DF_INT:\n@@ -27247,7 +27249,7 @@ ix86_expand_vector_init_one_nonzero (bool mmx_ok, enum machine_mode mode,\n       emit_insn (gen_rtx_SET (VOIDmode, target, CONST0_RTX (mode)));\n       var = force_reg (GET_MODE_INNER (mode), var);\n       ix86_expand_vector_set (mmx_ok, target, var, one_var);\n-      return true; \n+      return true;\n     }\n \n   switch (mode)\n@@ -27581,7 +27583,7 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n   rtx (*gen_load_even) (rtx, rtx, rtx);\n   rtx (*gen_interleave_first_low) (rtx, rtx, rtx);\n   rtx (*gen_interleave_second_low) (rtx, rtx, rtx);\n-  \n+\n   switch (mode)\n     {\n     case V8HImode:\n@@ -27605,7 +27607,7 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n     default:\n       gcc_unreachable ();\n     }\n-     \n+\n   for (i = 0; i < n; i++)\n     {\n       /* Extend the odd elment to SImode using a paradoxical SUBREG.  */\n@@ -27624,7 +27626,7 @@ ix86_expand_vector_init_interleave (enum machine_mode mode,\n       /* Cast the V4SImode vector back to a vector in orignal mode.  */\n       op0 = gen_reg_rtx (mode);\n       emit_move_insn (op0, gen_lowpart (mode, op1));\n-      \n+\n       /* Load even elements into the second positon.  */\n       emit_insn ((*gen_load_even) (op0,\n \t\t\t\t   force_reg (inner_mode,\n@@ -27747,7 +27749,7 @@ ix86_expand_vector_init_general (bool mmx_ok, enum machine_mode mode,\n \tbreak;\n \n       /* Don't use ix86_expand_vector_init_interleave if we can't\n-\t move from GPR to SSE register directly.  */ \n+\t move from GPR to SSE register directly.  */\n       if (!TARGET_INTER_UNIT_MOVES)\n \tbreak;\n \n@@ -30006,7 +30008,7 @@ expand_vec_perm_pshufb2 (struct expand_vec_perm_d *d)\n \n   nelt = d->nelt;\n   eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n-  \n+\n   /* Generate two permutation masks.  If the required element is within\n      the given vector it is shuffled into the proper lane.  If the required\n      element is in the other vector, force a zero into the lane by setting\n@@ -30404,7 +30406,7 @@ ix86_expand_vec_perm_builtin (tree exp)\n       d.op1 = d.op0;\n       break;\n     }\n- \n+\n   d.target = gen_reg_rtx (d.vmode);\n   if (ix86_expand_vec_perm_builtin_1 (&d))\n     return d.target;\n@@ -30476,7 +30478,7 @@ ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n      an error generated from the extract.  */\n   gcc_assert (vec_mask > 0 && vec_mask <= 3);\n   one_vec = (vec_mask != 3);\n-  \n+\n   /* Implementable with shufps or pshufd.  */\n   if (one_vec && (d.vmode == V4SFmode || d.vmode == V4SImode))\n     return true;"}]}