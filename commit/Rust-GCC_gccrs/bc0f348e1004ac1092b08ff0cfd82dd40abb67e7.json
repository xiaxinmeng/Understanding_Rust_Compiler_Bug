{"sha": "bc0f348e1004ac1092b08ff0cfd82dd40abb67e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwZjM0OGUxMDA0YWMxMDkyYjA4ZmYwY2ZkODJkZDQwYWJiNjdlNw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-02T21:45:57Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-02T21:45:57Z"}, "message": "Index: ChangeLog\n2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n\n\t* config/rs6000/rs6000.md (sync_boolcshort_internal): New.\n\t* config/rs6000/rs6000.c (rs6000_emit_sync): Shift count must\n\tbe complemented for big-endian.  Mask for AND must be rotated,\n\tnot shifted.  Handle short operands with NOT on the memory\n\toperation.\n\nIndex: testsuite/ChangeLog\n2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_sync_char_short): New.\n\t* gcc.dg/sync-2.c: New.\n\nFrom-SVN: r100515", "tree": {"sha": "99ae9ea1708821e17b29de920210967f403c9914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99ae9ea1708821e17b29de920210967f403c9914"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7/comments", "author": null, "committer": null, "parents": [{"sha": "e2089d725e78e1a3b34fc3051ad6c804659bc362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2089d725e78e1a3b34fc3051ad6c804659bc362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2089d725e78e1a3b34fc3051ad6c804659bc362"}], "stats": {"total": 23, "additions": 23, "deletions": 0}, "files": [{"sha": "b2bec156da36d4f936990672ea714c352b24f44c", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0f348e1004ac1092b08ff0cfd82dd40abb67e7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=bc0f348e1004ac1092b08ff0cfd82dd40abb67e7", "patch": "@@ -990,6 +990,29 @@ proc check_effective_target_sync_int_long { } {\n     return $et_sync_int_long_saved\n }\n \n+# Return 1 if the target supports atomic operations on \"char\" and \"short\".\n+\n+proc check_effective_target_sync_char_short { } {\n+    global et_sync_char_short_saved\n+\n+    if [info exists et_sync_char_short_saved] {\n+        verbose \"check_effective_target_sync_char_short: using cached result\" 2\n+    } else {\n+        set et_sync_char_short_saved 0\n+# This is intentionally powerpc but not rs6000, rs6000 doesn't have the\n+# load-reserved/store-conditional instructions.\n+        if { [istarget ia64-*-*]\n+\t     || [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*]\n+\t     || [istarget powerpc*-*-*] } {\n+           set et_sync_char_short_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_sync_char_short: returning $et_sync_char_short_saved\" 2\n+    return $et_sync_char_short_saved\n+}\n+\n # Return 1 if the target matches the effective target 'arg', 0 otherwise.\n # This can be used with any check_* proc that takes no argument and\n # returns only 1 or 0.  It could be used with check_* procs that take"}]}