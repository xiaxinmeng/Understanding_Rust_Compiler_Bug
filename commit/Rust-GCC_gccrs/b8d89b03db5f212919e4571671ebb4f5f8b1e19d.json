{"sha": "b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhkODliMDNkYjVmMjEyOTE5ZTQ1NzE2NzFlYmI0ZjVmOGIxZTE5ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-11-23T12:27:13Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2016-11-23T12:27:13Z"}, "message": "Remove build dependence on HSA run-time\n\n2016-11-23  Martin Liska  <mliska@suse.cz>\n            Martin Jambor  <mjambor@suse.cz>\n\ngcc/\n\t* doc/install.texi: Remove entry about --with-hsa-kmt-lib.\n\nlibgomp/\n\t* plugin/hsa.h: New file.\n\t* plugin/hsa_ext_finalize.h: New file.\n\t* plugin/configfrag.ac: Remove hsa-kmt-lib test.  Added checks for\n\theader file unistd.h, and functions secure_getenv, __secure_getenv,\n\tgetuid, geteuid, getgid and getegid.\n\t* plugin/Makefrag.am (libgomp_plugin_hsa_la_CPPFLAGS): Added\n\t-D_GNU_SOURCE.\n\t* plugin/plugin-hsa.c: Include config.h, inttypes.h and stdbool.h.\n\tHandle various cases of secure_getenv presence, add an implementation\n\twhen we can test effective UID and GID.\n\t(struct hsa_runtime_fn_info): New structure.\n\t(hsa_runtime_fn_info hsa_fns): New variable.\n\t(hsa_runtime_lib): Likewise.\n\t(support_cpu_devices): Likewise.\n\t(init_enviroment_variables): Load newly introduced ENV\n\tvariables.\n\t(hsa_warn): Call hsa run-time functions via hsa_fns structure.\n\t(hsa_fatal): Likewise.\n\t(DLSYM_FN): New macro.\n\t(init_hsa_runtime_functions): New function.\n\t(suitable_hsa_agent_p): Call hsa run-time functions via hsa_fns\n\tstructure.  Depending on environment, also allow CPU devices.\n\t(init_hsa_context): Call hsa run-time functions via hsa_fns structure.\n\t(get_kernarg_memory_region): Likewise.\n\t(GOMP_OFFLOAD_init_device): Likewise.\n\t(destroy_hsa_program): Likewise.\n\t(init_basic_kernel_info): New function.\n\t(GOMP_OFFLOAD_load_image): Use it.\n\t(create_and_finalize_hsa_program): Call hsa run-time functions via\n\thsa_fns structure.\n\t(create_single_kernel_dispatch): Likewise.\n\t(release_kernel_dispatch): Likewise.\n\t(init_single_kernel): Likewise.\n\t(parse_target_attributes): Allow up multiple HSA grid dimensions.\n\t(get_group_size): New function.\n\t(run_kernel): Likewise.\n\t(GOMP_OFFLOAD_run): Outline most functionality to run_kernel.\n\t(GOMP_OFFLOAD_fini_device): Call hsa run-time functions via hsa_fns\n\tstructure.\n\t* testsuite/lib/libgomp.exp: Remove hsa_kmt_lib support.\n\t* testsuite/libgomp-test-support.exp.in: Likewise.\n\t* Makefile.in: Regenerated.\n\t* aclocal.m4: Likewise.\n\t* config.h.in: Likewise.\n\t* configure: Likewise.\n\t* testsuite/Makefile.in: Likewise.\n\n\n\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\n\nFrom-SVN: r242749", "tree": {"sha": "ca8d3a25bea7a0869227ad33aafc39ca9eff7e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca8d3a25bea7a0869227ad33aafc39ca9eff7e0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3615816da830d41f67a5d8955ae588eba7f0b6fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3615816da830d41f67a5d8955ae588eba7f0b6fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3615816da830d41f67a5d8955ae588eba7f0b6fb"}], "stats": {"total": 1927, "additions": 1539, "deletions": 388}, "files": [{"sha": "0bafde2dba60071a0136c69df2c7f8425deafe42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,3 +1,8 @@\n+2016-11-23  Martin Liska  <mliska@suse.cz>\n+            Martin Jambor  <mjambor@suse.cz>\n+\n+\t* doc/install.texi: Remove entry about --with-hsa-kmt-lib.\n+\n 2016-11-23  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR target/78213"}, {"sha": "0cf2f8a71cd5adce2a267a3094e4e8f89349507a", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -2035,12 +2035,6 @@ explicitly specify the directory where they are installed.  The\n shorthand for\n @option{--with-hsa-runtime-lib=@/@var{hsainstalldir}/lib} and\n @option{--with-hsa-runtime-include=@/@var{hsainstalldir}/include}.\n-\n-@item --with-hsa-kmt-lib=@var{pathname}\n-\n-If you configure GCC with HSA offloading but do not have the HSA\n-KMT library installed in a standard location then you can\n-explicitly specify the directory where it resides.\n @end table\n \n @subheading Cross-Compiler-Specific Options"}, {"sha": "19d80394f4b8e984676b36860dc00c1f26db2be8", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,3 +1,53 @@\n+2016-11-23  Martin Liska  <mliska@suse.cz>\n+            Martin Jambor  <mjambor@suse.cz>\n+\n+\t* plugin/hsa.h: New file.\n+\t* plugin/hsa_ext_finalize.h: New file.\n+\t* plugin/configfrag.ac: Remove hsa-kmt-lib test.  Added checks for\n+\theader file unistd.h, and functions secure_getenv, __secure_getenv,\n+\tgetuid, geteuid, getgid and getegid.\n+\t* plugin/Makefrag.am (libgomp_plugin_hsa_la_CPPFLAGS): Added\n+\t-D_GNU_SOURCE.\n+\t* plugin/plugin-hsa.c: Include config.h, inttypes.h and stdbool.h.\n+\tHandle various cases of secure_getenv presence, add an implementation\n+\twhen we can test effective UID and GID.\n+\t(struct hsa_runtime_fn_info): New structure.\n+\t(hsa_runtime_fn_info hsa_fns): New variable.\n+\t(hsa_runtime_lib): Likewise.\n+\t(support_cpu_devices): Likewise.\n+\t(init_enviroment_variables): Load newly introduced ENV\n+\tvariables.\n+\t(hsa_warn): Call hsa run-time functions via hsa_fns structure.\n+\t(hsa_fatal): Likewise.\n+\t(DLSYM_FN): New macro.\n+\t(init_hsa_runtime_functions): New function.\n+\t(suitable_hsa_agent_p): Call hsa run-time functions via hsa_fns\n+\tstructure.  Depending on environment, also allow CPU devices.\n+\t(init_hsa_context): Call hsa run-time functions via hsa_fns structure.\n+\t(get_kernarg_memory_region): Likewise.\n+\t(GOMP_OFFLOAD_init_device): Likewise.\n+\t(destroy_hsa_program): Likewise.\n+\t(init_basic_kernel_info): New function.\n+\t(GOMP_OFFLOAD_load_image): Use it.\n+\t(create_and_finalize_hsa_program): Call hsa run-time functions via\n+\thsa_fns structure.\n+\t(create_single_kernel_dispatch): Likewise.\n+\t(release_kernel_dispatch): Likewise.\n+\t(init_single_kernel): Likewise.\n+\t(parse_target_attributes): Allow up multiple HSA grid dimensions.\n+\t(get_group_size): New function.\n+\t(run_kernel): Likewise.\n+\t(GOMP_OFFLOAD_run): Outline most functionality to run_kernel.\n+\t(GOMP_OFFLOAD_fini_device): Call hsa run-time functions via hsa_fns\n+\tstructure.\n+\t* testsuite/lib/libgomp.exp: Remove hsa_kmt_lib support.\n+\t* testsuite/libgomp-test-support.exp.in: Likewise.\n+\t* Makefile.in: Regenerated.\n+\t* aclocal.m4: Likewise.\n+\t* config.h.in: Likewise.\n+\t* configure: Likewise.\n+\t* testsuite/Makefile.in: Likewise.\n+\n 2016-11-15  Martin Jambor  <mjambor@suse.cz>\n             Alexander Monakov  <amonakov@ispras.ru>\n "}, {"sha": "e7cf3112e5e7c7df36f881c92361383c923aabd4", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 45, "deletions": 93, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,9 +1,9 @@\n-# Makefile.in generated by automake 1.11.6 from Makefile.am.\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n-# Foundation, Inc.\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -45,23 +45,6 @@\n \n \n VPATH = @srcdir@\n-am__make_dryrun = \\\n-  { \\\n-    am__dry=no; \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n-      *) \\\n-        for am__flg in $$MAKEFLAGS; do \\\n-          case $$am__flg in \\\n-            *=*|--*) ;; \\\n-            *n*) am__dry=yes; break;; \\\n-          esac; \\\n-        done;; \\\n-    esac; \\\n-    test $$am__dry = yes; \\\n-  }\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n pkglibdir = $(libdir)/@PACKAGE@\n@@ -137,12 +120,6 @@ am__nobase_list = $(am__nobase_strip_setup); \\\n am__base_list = \\\n   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n   sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n \t\"$(DESTDIR)$(fincludedir)\" \"$(DESTDIR)$(libsubincludedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibdir)\"\n@@ -226,11 +203,6 @@ RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \tinstall-pdf-recursive install-ps-recursive install-recursive \\\n \tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n \tps-recursive uninstall-recursive\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n HEADERS = $(nodist_finclude_HEADERS) $(nodist_libsubinclude_HEADERS) \\\n \t$(nodist_noinst_HEADERS) $(nodist_toolexeclib_HEADERS)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n@@ -268,7 +240,6 @@ FC = @FC@\n FCFLAGS = @FCFLAGS@\n FGREP = @FGREP@\n GREP = @GREP@\n-HSA_KMT_LIB = @HSA_KMT_LIB@\n HSA_RUNTIME_INCLUDE = @HSA_RUNTIME_INCLUDE@\n HSA_RUNTIME_LIB = @HSA_RUNTIME_LIB@\n INSTALL = @INSTALL@\n@@ -450,7 +421,9 @@ libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n # Heterogenous Systems Architecture plugin\n @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_version_info = -version-info $(libtool_VERSION)\n @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_SOURCES = plugin/plugin-hsa.c\n-@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS)\n+@PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS) \\\n+@PLUGIN_HSA_TRUE@\t-D_GNU_SOURCE\n+\n @PLUGIN_HSA_TRUE@libgomp_plugin_hsa_la_LDFLAGS =  \\\n @PLUGIN_HSA_TRUE@\t$(libgomp_plugin_hsa_version_info) \\\n @PLUGIN_HSA_TRUE@\t$(lt_host_flags) $(PLUGIN_HSA_LDFLAGS)\n@@ -491,7 +464,7 @@ all: config.h\n \n .SUFFIXES:\n .SUFFIXES: .c .dvi .f90 .lo .o .obj .ps\n-am--refresh: Makefile\n+am--refresh:\n \t@:\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/plugin/Makefrag.am $(am__configure_deps)\n \t@for dep in $?; do \\\n@@ -516,7 +489,6 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n \t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n \tesac;\n-$(top_srcdir)/plugin/Makefrag.am:\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n \t$(SHELL) ./config.status --recheck\n@@ -528,8 +500,10 @@ $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n $(am__aclocal_m4_deps):\n \n config.h: stamp-h1\n-\t@if test ! -f $@; then rm -f stamp-h1; else :; fi\n-\t@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n \n stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n \t@rm -f stamp-h1\n@@ -553,15 +527,14 @@ libgomp.spec: $(top_builddir)/config.status $(srcdir)/libgomp.spec.in\n \tcd $(top_builddir) && $(SHELL) ./config.status $@\n install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n \t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n \tlist2=; for p in $$list; do \\\n \t  if test -f $$p; then \\\n \t    list2=\"$$list2 $$p\"; \\\n \t  else :; fi; \\\n \tdone; \\\n \ttest -z \"$$list2\" || { \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n \t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n \t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n \t}\n@@ -583,11 +556,11 @@ clean-toolexeclibLTLIBRARIES:\n \t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n-libgomp-plugin-hsa.la: $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_hsa_la_DEPENDENCIES) \n+libgomp-plugin-hsa.la: $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_DEPENDENCIES) \n \t$(libgomp_plugin_hsa_la_LINK) $(am_libgomp_plugin_hsa_la_rpath) $(libgomp_plugin_hsa_la_OBJECTS) $(libgomp_plugin_hsa_la_LIBADD) $(LIBS)\n-libgomp-plugin-nvptx.la: $(libgomp_plugin_nvptx_la_OBJECTS) $(libgomp_plugin_nvptx_la_DEPENDENCIES) $(EXTRA_libgomp_plugin_nvptx_la_DEPENDENCIES) \n+libgomp-plugin-nvptx.la: $(libgomp_plugin_nvptx_la_OBJECTS) $(libgomp_plugin_nvptx_la_DEPENDENCIES) \n \t$(libgomp_plugin_nvptx_la_LINK) $(am_libgomp_plugin_nvptx_la_rpath) $(libgomp_plugin_nvptx_la_OBJECTS) $(libgomp_plugin_nvptx_la_LIBADD) $(LIBS)\n-libgomp.la: $(libgomp_la_OBJECTS) $(libgomp_la_DEPENDENCIES) $(EXTRA_libgomp_la_DEPENDENCIES) \n+libgomp.la: $(libgomp_la_OBJECTS) $(libgomp_la_DEPENDENCIES) \n \t$(libgomp_la_LINK) -rpath $(toolexeclibdir) $(libgomp_la_OBJECTS) $(libgomp_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n@@ -752,7 +725,9 @@ uninstall-html-am:\n \n uninstall-info-am:\n \t@$(PRE_UNINSTALL)\n-\t@if test -d '$(DESTDIR)$(infodir)' && $(am__can_run_installinfo); then \\\n+\t@if test -d '$(DESTDIR)$(infodir)' && \\\n+\t    (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n \t  list='$(INFO_DEPS)'; \\\n \t  for file in $$list; do \\\n \t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n@@ -826,11 +801,8 @@ maintainer-clean-aminfo:\n \tdone\n install-nodist_fincludeHEADERS: $(nodist_finclude_HEADERS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(fincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(fincludedir)\"\n \t@list='$(nodist_finclude_HEADERS)'; test -n \"$(fincludedir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(fincludedir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(fincludedir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n@@ -844,14 +816,13 @@ uninstall-nodist_fincludeHEADERS:\n \t@$(NORMAL_UNINSTALL)\n \t@list='$(nodist_finclude_HEADERS)'; test -n \"$(fincludedir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(fincludedir)'; $(am__uninstall_files_from_dir)\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(fincludedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(fincludedir)\" && rm -f $$files\n install-nodist_libsubincludeHEADERS: $(nodist_libsubinclude_HEADERS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(libsubincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)\"\n \t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(libsubincludedir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n@@ -865,14 +836,13 @@ uninstall-nodist_libsubincludeHEADERS:\n \t@$(NORMAL_UNINSTALL)\n \t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(libsubincludedir)'; $(am__uninstall_files_from_dir)\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(libsubincludedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(libsubincludedir)\" && rm -f $$files\n install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n \t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n@@ -886,7 +856,9 @@ uninstall-nodist_toolexeclibHEADERS:\n \t@$(NORMAL_UNINSTALL)\n \t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibdir)\" && rm -f $$files\n \n # This directory's subdirectories are mostly independent; you can cd\n # into them and run `make' without going through this Makefile.\n@@ -1041,15 +1013,10 @@ install-am: all-am\n \n installcheck: installcheck-recursive\n install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n mostlyclean-generic:\n \n clean-generic:\n@@ -1094,11 +1061,8 @@ install-dvi: install-dvi-recursive\n \n install-dvi-am: $(DVIS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(dvidir)\" || $(MKDIR_P) \"$(DESTDIR)$(dvidir)\"\n \t@list='$(DVIS)'; test -n \"$(dvidir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(dvidir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(dvidir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n@@ -1114,22 +1078,18 @@ install-html: install-html-recursive\n \n install-html-am: $(HTMLS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(MKDIR_P) \"$(DESTDIR)$(htmldir)\"\n \t@list='$(HTMLS)'; list2=; test -n \"$(htmldir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(htmldir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(htmldir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\" || test -d \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  $(am__strip_dir) \\\n-\t  d2=$$d$$p; \\\n-\t  if test -d \"$$d2\"; then \\\n+\t  if test -d \"$$d$$p\"; then \\\n \t    echo \" $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n \t    $(MKDIR_P) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-\t    echo \" $(INSTALL_DATA) '$$d2'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d2\"/* \"$(DESTDIR)$(htmldir)/$$f\" || exit $$?; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\" || exit $$?; \\\n \t  else \\\n-\t    list2=\"$$list2 $$d2\"; \\\n+\t    list2=\"$$list2 $$d$$p\"; \\\n \t  fi; \\\n \tdone; \\\n \ttest -z \"$$list2\" || { echo \"$$list2\" | $(am__base_list) | \\\n@@ -1141,12 +1101,9 @@ install-info: install-info-recursive\n \n install-info-am: $(INFO_DEPS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(infodir)\" || $(MKDIR_P) \"$(DESTDIR)$(infodir)\"\n \t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n \tlist='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(infodir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(infodir)\" || exit 1; \\\n-\tfi; \\\n \tfor file in $$list; do \\\n \t  case $$file in \\\n \t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n@@ -1164,7 +1121,8 @@ install-info-am: $(INFO_DEPS)\n \t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'\"; \\\n \t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(infodir)\" || exit $$?; done\n \t@$(POST_INSTALL)\n-\t@if $(am__can_run_installinfo); then \\\n+\t@if (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n \t  list='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n \t  for file in $$list; do \\\n \t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n@@ -1178,11 +1136,8 @@ install-pdf: install-pdf-recursive\n \n install-pdf-am: $(PDFS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(MKDIR_P) \"$(DESTDIR)$(pdfdir)\"\n \t@list='$(PDFS)'; test -n \"$(pdfdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(pdfdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(pdfdir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n@@ -1194,11 +1149,8 @@ install-ps: install-ps-recursive\n \n install-ps-am: $(PSS)\n \t@$(NORMAL_INSTALL)\n+\ttest -z \"$(psdir)\" || $(MKDIR_P) \"$(DESTDIR)$(psdir)\"\n \t@list='$(PSS)'; test -n \"$(psdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(psdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(psdir)\" || exit 1; \\\n-\tfi; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\"}, {"sha": "6aff9fd3a823f5dba9cf056002601ac20c053f4a", "filename": "libgomp/aclocal.m4", "status": "modified", "additions": 27, "deletions": 47, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Faclocal.m4?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,8 +1,7 @@\n-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n \n # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n-# Inc.\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -20,15 +19,12 @@ You have another version of autoconf.  It may work, but is not guaranteed to.\n If you have problems, you may need to regenerate the build system entirely.\n To do so, use the procedure documented by the package, typically `autoreconf'.])])\n \n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n-# Foundation, Inc.\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 1\n-\n # AM_AUTOMAKE_VERSION(VERSION)\n # ----------------------------\n # Automake X.Y traces this macro to ensure aclocal.m4 has been\n@@ -38,7 +34,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],\n [am__api_version='1.11'\n dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.6], [],\n+m4_if([$1], [1.11.1], [],\n       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n ])\n \n@@ -54,21 +50,19 @@ m4_define([_AM_AUTOCONF_VERSION], [])\n # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.6])dnl\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n m4_ifndef([AC_AUTOCONF_VERSION],\n   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n \n # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n \n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 1\n-\n # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n # `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n@@ -150,14 +144,14 @@ AC_CONFIG_COMMANDS_PRE(\n Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,\n-# 2010, 2011 Free Software Foundation, Inc.\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 12\n+# serial 10\n \n # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n # written in clear, in which case automake, when reading aclocal.m4,\n@@ -197,7 +191,6 @@ AC_CACHE_CHECK([dependency style of $depcc],\n   # instance it was reported that on HP-UX the gcc test will end up\n   # making a dummy file named `D' -- because `-MD' means `put the output\n   # in D'.\n-  rm -rf conftest.dir\n   mkdir conftest.dir\n   # Copy depcomp to subdir because otherwise we won't find it if we're\n   # using a relative directory.\n@@ -262,7 +255,7 @@ AC_CACHE_CHECK([dependency style of $depcc],\n \tbreak\n       fi\n       ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n+    msvisualcpp | msvcmsys)\n       # This compiler won't grok `-c -o', but also, the minuso test has\n       # not run yet.  These depmodes are late enough in the game, and\n       # so weak that their functioning should not be impacted.\n@@ -327,13 +320,10 @@ AC_DEFUN([AM_DEP_TRACK],\n if test \"x$enable_dependency_tracking\" != xno; then\n   am_depcomp=\"$ac_aux_dir/depcomp\"\n   AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n fi\n AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n AC_SUBST([AMDEPBACKSLASH])dnl\n _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-AC_SUBST([am__nodep])dnl\n-_AM_SUBST_NOTMAKE([am__nodep])dnl\n ])\n \n # Generate code to set up dependency tracking.              -*- Autoconf -*-\n@@ -555,15 +545,12 @@ for _am_header in $config_headers :; do\n done\n echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n \n-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n-# Inc.\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 1\n-\n # AM_PROG_INSTALL_SH\n # ------------------\n # Define $install_sh.\n@@ -582,8 +569,8 @@ AC_SUBST(install_sh)])\n # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n # From Jim Meyering\n \n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,\n-# 2011 Free Software Foundation, Inc.\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -603,7 +590,7 @@ AC_DEFUN([AM_MAINTAINER_MODE],\n        [disable], [m4_define([am_maintainer_other], [enable])],\n        [m4_define([am_maintainer_other], [enable])\n         m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n   dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n   AC_ARG_ENABLE([maintainer-mode],\n [  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n@@ -714,15 +701,12 @@ else\n fi\n ])\n \n-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n-# Inc.\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 1\n-\n # AM_PROG_MKDIR_P\n # ---------------\n # Check for `mkdir -p'.\n@@ -745,28 +729,27 @@ esac\n \n # Helper functions for option handling.                     -*- Autoconf -*-\n \n-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n-# Foundation, Inc.\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 5\n+# serial 4\n \n # _AM_MANGLE_OPTION(NAME)\n # -----------------------\n AC_DEFUN([_AM_MANGLE_OPTION],\n [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n \n # _AM_SET_OPTION(NAME)\n-# --------------------\n+# ------------------------------\n # Set option NAME.  Presently that only means defining a flag for this option.\n AC_DEFUN([_AM_SET_OPTION],\n [m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n \n # _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n+# ----------------------------------\n # OPTIONS is a space-separated list of Automake options.\n AC_DEFUN([_AM_SET_OPTIONS],\n [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n@@ -842,14 +825,12 @@ Check your system clock])\n fi\n AC_MSG_RESULT(yes)])\n \n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 1\n-\n # AM_PROG_INSTALL_STRIP\n # ---------------------\n # One issue with vendor `install' (even GNU) is that you can't\n@@ -872,13 +853,13 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 3\n+# serial 2\n \n # _AM_SUBST_NOTMAKE(VARIABLE)\n # ---------------------------\n@@ -887,13 +868,13 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])\n AC_DEFUN([_AM_SUBST_NOTMAKE])\n \n # AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n+# ---------------------------\n # Public sister of _AM_SUBST_NOTMAKE.\n AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n \n # Check how to create a tarball.                            -*- Autoconf -*-\n \n-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -915,11 +896,10 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n # a tarball read from stdin.\n #     $(am__untar) < result.tar\n AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n m4_if([$1], [v7],\n-     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n      [m4_case([$1], [ustar],, [pax],,\n               [m4_fatal([Unknown tar format])])\n AC_MSG_CHECKING([how to create a $1 tar archive])"}, {"sha": "cdcda494096e8bd42bf745fcfc8faa161c251bd4", "filename": "libgomp/config.h.in", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -24,9 +24,21 @@\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n+/* Define to 1 if you have the `getegid' function. */\n+#undef HAVE_GETEGID\n+\n+/* Define to 1 if you have the `geteuid' function. */\n+#undef HAVE_GETEUID\n+\n+/* Define to 1 if you have the `getgid' function. */\n+#undef HAVE_GETGID\n+\n /* Define to 1 if you have the `getloadavg' function. */\n #undef HAVE_GETLOADAVG\n \n+/* Define to 1 if you have the `getuid' function. */\n+#undef HAVE_GETUID\n+\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n@@ -42,6 +54,9 @@\n /* Define to 1 if you have the <pthread.h> header file. */\n #undef HAVE_PTHREAD_H\n \n+/* Define to 1 if you have the `secure_getenv' function. */\n+#undef HAVE_SECURE_GETENV\n+\n /* Define to 1 if you have the <semaphore.h> header file. */\n #undef HAVE_SEMAPHORE_H\n \n@@ -91,6 +106,12 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to 1 if you have the `__secure_getenv' function. */\n+#undef HAVE___SECURE_GETENV\n+\n+/* Define path to HSA runtime. */\n+#undef HSA_RUNTIME_LIB\n+\n /* Define to 1 if GNU symbol versioning is used for libgomp. */\n #undef LIBGOMP_GNU_SYMBOL_VERSIONING\n "}, {"sha": "d369320bb3cdd86e6a1fff3f27234392f58a4099", "filename": "libgomp/configure", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -597,6 +597,8 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n+ac_header_list=\n+ac_func_list=\n ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n@@ -637,7 +639,6 @@ PLUGIN_HSA_LIBS\n PLUGIN_HSA_LDFLAGS\n PLUGIN_HSA_CPPFLAGS\n PLUGIN_HSA\n-HSA_KMT_LIB\n HSA_RUNTIME_LIB\n HSA_RUNTIME_INCLUDE\n PLUGIN_NVPTX_LIBS\n@@ -682,7 +683,6 @@ AR\n am__fastdepCC_FALSE\n am__fastdepCC_TRUE\n CCDEPMODE\n-am__nodep\n AMDEPBACKSLASH\n AMDEP_FALSE\n AMDEP_TRUE\n@@ -794,7 +794,6 @@ with_cuda_driver_lib\n with_hsa_runtime\n with_hsa_runtime_include\n with_hsa_runtime_lib\n-with_hsa_kmt_lib\n enable_linux_futex\n enable_tls\n enable_symvers\n@@ -1476,7 +1475,6 @@ Optional Packages:\n   --with-hsa-runtime-lib=PATH\n                           specify directory for the installed HSA run-time\n                           library\n-  --with-hsa-kmt-lib=PATH specify directory for installed HSA KMT library.\n \n Some influential environment variables:\n   CC          C compiler command\n@@ -2518,6 +2516,13 @@ $as_echo \"$as_me: creating cache $cache_file\" >&6;}\n   >$cache_file\n fi\n \n+as_fn_append ac_header_list \" unistd.h\"\n+as_fn_append ac_func_list \" secure_getenv\"\n+as_fn_append ac_func_list \" __secure_getenv\"\n+as_fn_append ac_func_list \" getuid\"\n+as_fn_append ac_func_list \" geteuid\"\n+as_fn_append ac_func_list \" getgid\"\n+as_fn_append ac_func_list \" getegid\"\n # Check that the precious variables saved in the cache have kept the same\n # value.\n ac_cache_corrupted=false\n@@ -3280,11 +3285,11 @@ MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n # We need awk for the \"check\" target.  The system \"awk\" is bad on\n # some platforms.\n-# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AMTAR='$${TAR-tar}'\n+# Always define AMTAR for backward compatibility.\n \n-am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'\n+AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n+\n+am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'\n \n \n \n@@ -4182,7 +4187,6 @@ fi\n if test \"x$enable_dependency_tracking\" != xno; then\n   am_depcomp=\"$ac_aux_dir/depcomp\"\n   AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n fi\n  if test \"x$enable_dependency_tracking\" != xno; then\n   AMDEP_TRUE=\n@@ -4207,7 +4211,6 @@ else\n   # instance it was reported that on HP-UX the gcc test will end up\n   # making a dummy file named `D' -- because `-MD' means `put the output\n   # in D'.\n-  rm -rf conftest.dir\n   mkdir conftest.dir\n   # Copy depcomp to subdir because otherwise we won't find it if we're\n   # using a relative directory.\n@@ -4267,7 +4270,7 @@ else\n \tbreak\n       fi\n       ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n+    msvisualcpp | msvcmsys)\n       # This compiler won't grok `-c -o', but also, the minuso test has\n       # not run yet.  These depmodes are late enough in the game, and\n       # so weak that their functioning should not be impacted.\n@@ -11145,7 +11148,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11148 \"configure\"\n+#line 11151 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11251,7 +11254,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11254 \"configure\"\n+#line 11257 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15198,6 +15201,57 @@ elif test \"x${enable_offload_targets-no}\" != xno; then\n   as_fn_error \"Can't support offloading without support for plugins\" \"$LINENO\" 5\n fi\n \n+\n+\n+  for ac_header in $ac_header_list\n+do :\n+  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n+ac_fn_c_check_header_compile \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\n+\"\n+eval as_val=\\$$as_ac_Header\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n+\n+\n+\n+\n+\n+  for ac_func in $ac_func_list\n+do :\n+  as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n+ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n+eval as_val=\\$$as_ac_var\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n+_ACEOF\n+\n+fi\n+done\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n # Look for the CUDA driver package.\n CUDA_DRIVER_INCLUDE=\n CUDA_DRIVER_LIB=\n@@ -15293,22 +15347,6 @@ if test \"x$HSA_RUNTIME_LIB\" != x; then\n   HSA_RUNTIME_LDFLAGS=-L$HSA_RUNTIME_LIB\n fi\n \n-HSA_KMT_LIB=\n-\n-HSA_KMT_LDFLAGS=\n-\n-# Check whether --with-hsa-kmt-lib was given.\n-if test \"${with_hsa_kmt_lib+set}\" = set; then :\n-  withval=$with_hsa_kmt_lib;\n-fi\n-\n-if test \"x$with_hsa_kmt_lib\" != x; then\n-  HSA_KMT_LIB=$with_hsa_kmt_lib\n-fi\n-if test \"x$HSA_KMT_LIB\" != x; then\n-  HSA_KMT_LDFLAGS=-L$HSA_KMT_LIB\n-fi\n-\n PLUGIN_HSA=0\n PLUGIN_HSA_CPPFLAGS=\n PLUGIN_HSA_LDFLAGS=\n@@ -15318,8 +15356,6 @@ PLUGIN_HSA_LIBS=\n \n \n \n-\n-\n # Get offload targets and path to install tree of offloading compiler.\n offload_additional_options=\n offload_additional_lib_paths=\n@@ -15384,8 +15420,8 @@ rm -f core conftest.err conftest.$ac_objext \\\n \t        tgt_name=hsa\n \t        PLUGIN_HSA=$tgt\n \t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n-\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS $HSA_KMT_LDFLAGS\"\n-\t        PLUGIN_HSA_LIBS=\"-lhsa-runtime64 -lhsakmt\"\n+\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n+\t        PLUGIN_HSA_LIBS=\"-ldl\"\n \n \t        PLUGIN_HSA_save_CPPFLAGS=$CPPFLAGS\n \t        CPPFLAGS=\"$PLUGIN_HSA_CPPFLAGS $CPPFLAGS\"\n@@ -15394,22 +15430,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n \t        PLUGIN_HSA_save_LIBS=$LIBS\n \t        LIBS=\"$PLUGIN_HSA_LIBS $LIBS\"\n \n-\t        cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include \"hsa.h\"\n-int\n-main ()\n-{\n-hsa_status_t status = hsa_init ()\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  PLUGIN_HSA=1\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n+\t        PLUGIN_HSA=1\n \t        CPPFLAGS=$PLUGIN_HSA_save_CPPFLAGS\n \t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n \t        LIBS=$PLUGIN_HSA_save_LIBS\n@@ -15484,6 +15505,16 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n+if test \"$HSA_RUNTIME_LIB\" != \"\"; then\n+  HSA_RUNTIME_LIB=\"$HSA_RUNTIME_LIB/\"\n+fi\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HSA_RUNTIME_LIB \"$HSA_RUNTIME_LIB\"\n+_ACEOF\n+\n+\n \n # Check for functions needed.\n for ac_func in getloadavg clock_gettime strtoull"}, {"sha": "39d1de1e9d7159cf0ea5e47b0a0deaf4660e1c9d", "filename": "libgomp/plugin/Makefrag.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2FMakefrag.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2FMakefrag.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2FMakefrag.am?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -44,7 +44,8 @@ if PLUGIN_HSA\n libgomp_plugin_hsa_version_info = -version-info $(libtool_VERSION)\n toolexeclib_LTLIBRARIES += libgomp-plugin-hsa.la\n libgomp_plugin_hsa_la_SOURCES = plugin/plugin-hsa.c\n-libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS)\n+libgomp_plugin_hsa_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_HSA_CPPFLAGS) \\\n+\t-D_GNU_SOURCE\n libgomp_plugin_hsa_la_LDFLAGS = $(libgomp_plugin_hsa_version_info) \\\n \t$(lt_host_flags)\n libgomp_plugin_hsa_la_LDFLAGS += $(PLUGIN_HSA_LDFLAGS)"}, {"sha": "29416d565accd38a17576cec84ed4cabdf4ea41d", "filename": "libgomp/plugin/configfrag.ac", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fconfigfrag.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fconfigfrag.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fconfigfrag.ac?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -36,6 +36,9 @@ if test x\"$plugin_support\" = xyes; then\n elif test \"x${enable_offload_targets-no}\" != xno; then\n   AC_MSG_ERROR([Can't support offloading without support for plugins])\n fi\n+AC_CHECK_HEADERS_ONCE(unistd.h)\n+AC_CHECK_FUNCS_ONCE(secure_getenv __secure_getenv getuid geteuid getgid getegid)\n+\n \n # Look for the CUDA driver package.\n CUDA_DRIVER_INCLUDE=\n@@ -118,19 +121,6 @@ if test \"x$HSA_RUNTIME_LIB\" != x; then\n   HSA_RUNTIME_LDFLAGS=-L$HSA_RUNTIME_LIB\n fi\n \n-HSA_KMT_LIB=\n-AC_SUBST(HSA_KMT_LIB)\n-HSA_KMT_LDFLAGS=\n-AC_ARG_WITH(hsa-kmt-lib,\n-\t[AS_HELP_STRING([--with-hsa-kmt-lib=PATH],\n-\t\t[specify directory for installed HSA KMT library.])])\n-if test \"x$with_hsa_kmt_lib\" != x; then\n-  HSA_KMT_LIB=$with_hsa_kmt_lib\n-fi\n-if test \"x$HSA_KMT_LIB\" != x; then\n-  HSA_KMT_LDFLAGS=-L$HSA_KMT_LIB\n-fi\n-\n PLUGIN_HSA=0\n PLUGIN_HSA_CPPFLAGS=\n PLUGIN_HSA_LDFLAGS=\n@@ -140,8 +130,6 @@ AC_SUBST(PLUGIN_HSA_CPPFLAGS)\n AC_SUBST(PLUGIN_HSA_LDFLAGS)\n AC_SUBST(PLUGIN_HSA_LIBS)\n \n-\n-\n # Get offload targets and path to install tree of offloading compiler.\n offload_additional_options=\n offload_additional_lib_paths=\n@@ -195,8 +183,8 @@ if test x\"$enable_offload_targets\" != x; then\n \t        tgt_name=hsa\n \t        PLUGIN_HSA=$tgt\n \t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n-\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS $HSA_KMT_LDFLAGS\"\n-\t        PLUGIN_HSA_LIBS=\"-lhsa-runtime64 -lhsakmt\"\n+\t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n+\t        PLUGIN_HSA_LIBS=\"-ldl\"\n \n \t        PLUGIN_HSA_save_CPPFLAGS=$CPPFLAGS\n \t        CPPFLAGS=\"$PLUGIN_HSA_CPPFLAGS $CPPFLAGS\"\n@@ -205,11 +193,7 @@ if test x\"$enable_offload_targets\" != x; then\n \t        PLUGIN_HSA_save_LIBS=$LIBS\n \t        LIBS=\"$PLUGIN_HSA_LIBS $LIBS\"\n \n-\t        AC_LINK_IFELSE(\n-\t          [AC_LANG_PROGRAM(\n-\t            [#include \"hsa.h\"],\n-\t              [hsa_status_t status = hsa_init ()])],\n-\t          [PLUGIN_HSA=1])\n+\t        PLUGIN_HSA=1\n \t        CPPFLAGS=$PLUGIN_HSA_save_CPPFLAGS\n \t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n \t        LIBS=$PLUGIN_HSA_save_LIBS\n@@ -260,3 +244,10 @@ AC_DEFINE_UNQUOTED([PLUGIN_NVPTX], [$PLUGIN_NVPTX],\n AM_CONDITIONAL([PLUGIN_HSA], [test $PLUGIN_HSA = 1])\n AC_DEFINE_UNQUOTED([PLUGIN_HSA], [$PLUGIN_HSA],\n   [Define to 1 if the HSA plugin is built, 0 if not.])\n+\n+if test \"$HSA_RUNTIME_LIB\" != \"\"; then\n+  HSA_RUNTIME_LIB=\"$HSA_RUNTIME_LIB/\"\n+fi\n+\n+AC_DEFINE_UNQUOTED([HSA_RUNTIME_LIB], [\"$HSA_RUNTIME_LIB\"],\n+  [Define path to HSA runtime.])"}, {"sha": "6765751e32312e6591487b7f7f6cdd95bd65578d", "filename": "libgomp/plugin/hsa.h", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fhsa.h?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -0,0 +1,630 @@\n+/* HSA runtime API 1.0.1 representation description.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.\n+\n+The contents of the file was created by extracting data structures, enum,\n+typedef and other definitions from HSA Runtime Programmer\u2019s Reference Manual\n+Version 1.0 (http://www.hsafoundation.com/standards/).\n+\n+HTML version is provided on the following link:\n+http://www.hsafoundation.com/html/Content/Runtime/Topics/Runtime_title_page.htm\n+*/\n+\n+#ifndef _HSA_H\n+#define _HSA_H 1\n+\n+#define HSA_LARGE_MODEL 1\n+\n+typedef struct hsa_signal_s { uint64_t handle; } hsa_signal_t;\n+typedef enum {\n+  HSA_QUEUE_TYPE_MULTI = 0,\n+  HSA_QUEUE_TYPE_SINGLE = 1\n+} hsa_queue_type_t;\n+\n+typedef enum { HSA_PROFILE_BASE = 0, HSA_PROFILE_FULL = 1 } hsa_profile_t;\n+typedef struct hsa_region_s { uint64_t handle; } hsa_region_t;\n+typedef enum {\n+  HSA_EXECUTABLE_SYMBOL_INFO_TYPE = 0,\n+  HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH = 1,\n+  HSA_EXECUTABLE_SYMBOL_INFO_NAME = 2,\n+  HSA_EXECUTABLE_SYMBOL_INFO_MODULE_NAME_LENGTH = 3,\n+  HSA_EXECUTABLE_SYMBOL_INFO_MODULE_NAME = 4,\n+  HSA_EXECUTABLE_SYMBOL_INFO_AGENT = 20,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS = 21,\n+  HSA_EXECUTABLE_SYMBOL_INFO_LINKAGE = 5,\n+  HSA_EXECUTABLE_SYMBOL_INFO_IS_DEFINITION = 17,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ALLOCATION = 6,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SEGMENT = 7,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ALIGNMENT = 8,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE = 9,\n+  HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_IS_CONST = 10,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT = 22,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE = 11,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_ALIGNMENT = 12,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE = 13,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE = 14,\n+  HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK = 15,\n+  HSA_EXECUTABLE_SYMBOL_INFO_INDIRECT_FUNCTION_OBJECT = 23,\n+  HSA_EXECUTABLE_SYMBOL_INFO_INDIRECT_FUNCTION_CALL_CONVENTION = 16\n+} hsa_executable_symbol_info_t;\n+typedef enum {\n+  HSA_REGION_GLOBAL_FLAG_KERNARG = 1,\n+  HSA_REGION_GLOBAL_FLAG_FINE_GRAINED = 2,\n+  HSA_REGION_GLOBAL_FLAG_COARSE_GRAINED = 4\n+} hsa_region_global_flag_t;\n+typedef struct hsa_code_object_s { uint64_t handle; } hsa_code_object_t;\n+typedef enum {\n+  HSA_KERNEL_DISPATCH_PACKET_SETUP_WIDTH_DIMENSIONS = 2\n+} hsa_kernel_dispatch_packet_setup_width_t;\n+typedef enum {\n+  HSA_DEVICE_TYPE_CPU = 0,\n+  HSA_DEVICE_TYPE_GPU = 1,\n+  HSA_DEVICE_TYPE_DSP = 2\n+} hsa_device_type_t;\n+typedef enum {\n+  HSA_STATUS_SUCCESS = 0x0,\n+  HSA_STATUS_INFO_BREAK = 0x1,\n+  HSA_STATUS_ERROR = 0x1000,\n+  HSA_STATUS_ERROR_INVALID_ARGUMENT = 0x1001,\n+  HSA_STATUS_ERROR_INVALID_QUEUE_CREATION = 0x1002,\n+  HSA_STATUS_ERROR_INVALID_ALLOCATION = 0x1003,\n+  HSA_STATUS_ERROR_INVALID_AGENT = 0x1004,\n+  HSA_STATUS_ERROR_INVALID_REGION = 0x1005,\n+  HSA_STATUS_ERROR_INVALID_SIGNAL = 0x1006,\n+  HSA_STATUS_ERROR_INVALID_QUEUE = 0x1007,\n+  HSA_STATUS_ERROR_OUT_OF_RESOURCES = 0x1008,\n+  HSA_STATUS_ERROR_INVALID_PACKET_FORMAT = 0x1009,\n+  HSA_STATUS_ERROR_RESOURCE_FREE = 0x100A,\n+  HSA_STATUS_ERROR_NOT_INITIALIZED = 0x100B,\n+  HSA_STATUS_ERROR_REFCOUNT_OVERFLOW = 0x100C,\n+  HSA_STATUS_ERROR_INCOMPATIBLE_ARGUMENTS = 0x100D,\n+  HSA_STATUS_ERROR_INVALID_INDEX = 0x100E,\n+  HSA_STATUS_ERROR_INVALID_ISA = 0x100F,\n+  HSA_STATUS_ERROR_INVALID_ISA_NAME = 0x1017,\n+  HSA_STATUS_ERROR_INVALID_CODE_OBJECT = 0x1010,\n+  HSA_STATUS_ERROR_INVALID_EXECUTABLE = 0x1011,\n+  HSA_STATUS_ERROR_FROZEN_EXECUTABLE = 0x1012,\n+  HSA_STATUS_ERROR_INVALID_SYMBOL_NAME = 0x1013,\n+  HSA_STATUS_ERROR_VARIABLE_ALREADY_DEFINED = 0x1014,\n+  HSA_STATUS_ERROR_VARIABLE_UNDEFINED = 0x1015,\n+  HSA_STATUS_ERROR_EXCEPTION = 0x1016\n+} hsa_status_t;\n+typedef enum {\n+  HSA_EXTENSION_FINALIZER = 0,\n+  HSA_EXTENSION_IMAGES = 1\n+} hsa_extension_t;\n+typedef struct hsa_queue_s {\n+  hsa_queue_type_t type;\n+  uint32_t features;\n+\n+#ifdef HSA_LARGE_MODEL\n+  void *base_address;\n+#elif defined HSA_LITTLE_ENDIAN\n+  void *base_address;\n+  uint32_t reserved0;\n+#else\n+  uint32_t reserved0;\n+  void *base_address;\n+#endif\n+\n+  hsa_signal_t doorbell_signal;\n+  uint32_t size;\n+  uint32_t reserved1;\n+  uint64_t id;\n+} hsa_queue_t;\n+typedef struct hsa_agent_dispatch_packet_s {\n+  uint16_t header;\n+  uint16_t type;\n+  uint32_t reserved0;\n+\n+#ifdef HSA_LARGE_MODEL\n+  void *return_address;\n+#elif defined HSA_LITTLE_ENDIAN\n+  void *return_address;\n+  uint32_t reserved1;\n+#else\n+  uint32_t reserved1;\n+  void *return_address;\n+#endif\n+  uint64_t arg[4];\n+  uint64_t reserved2;\n+  hsa_signal_t completion_signal;\n+} hsa_agent_dispatch_packet_t;\n+typedef enum {\n+  HSA_CODE_SYMBOL_INFO_TYPE = 0,\n+  HSA_CODE_SYMBOL_INFO_NAME_LENGTH = 1,\n+  HSA_CODE_SYMBOL_INFO_NAME = 2,\n+  HSA_CODE_SYMBOL_INFO_MODULE_NAME_LENGTH = 3,\n+  HSA_CODE_SYMBOL_INFO_MODULE_NAME = 4,\n+  HSA_CODE_SYMBOL_INFO_LINKAGE = 5,\n+  HSA_CODE_SYMBOL_INFO_IS_DEFINITION = 17,\n+  HSA_CODE_SYMBOL_INFO_VARIABLE_ALLOCATION = 6,\n+  HSA_CODE_SYMBOL_INFO_VARIABLE_SEGMENT = 7,\n+  HSA_CODE_SYMBOL_INFO_VARIABLE_ALIGNMENT = 8,\n+  HSA_CODE_SYMBOL_INFO_VARIABLE_SIZE = 9,\n+  HSA_CODE_SYMBOL_INFO_VARIABLE_IS_CONST = 10,\n+  HSA_CODE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE = 11,\n+  HSA_CODE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_ALIGNMENT = 12,\n+  HSA_CODE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE = 13,\n+  HSA_CODE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE = 14,\n+  HSA_CODE_SYMBOL_INFO_KERNEL_DYNAMIC_CALLSTACK = 15,\n+  HSA_CODE_SYMBOL_INFO_INDIRECT_FUNCTION_CALL_CONVENTION = 16\n+} hsa_code_symbol_info_t;\n+typedef enum {\n+  HSA_QUEUE_FEATURE_KERNEL_DISPATCH = 1,\n+  HSA_QUEUE_FEATURE_AGENT_DISPATCH = 2\n+} hsa_queue_feature_t;\n+typedef enum {\n+  HSA_VARIABLE_ALLOCATION_AGENT = 0,\n+  HSA_VARIABLE_ALLOCATION_PROGRAM = 1\n+} hsa_variable_allocation_t;\n+typedef enum {\n+  HSA_FENCE_SCOPE_NONE = 0,\n+  HSA_FENCE_SCOPE_AGENT = 1,\n+  HSA_FENCE_SCOPE_SYSTEM = 2\n+} hsa_fence_scope_t;\n+typedef struct hsa_agent_s { uint64_t handle; } hsa_agent_t;\n+typedef enum { HSA_CODE_OBJECT_TYPE_PROGRAM = 0 } hsa_code_object_type_t;\n+typedef enum {\n+  HSA_SIGNAL_CONDITION_EQ = 0,\n+  HSA_SIGNAL_CONDITION_NE = 1,\n+  HSA_SIGNAL_CONDITION_LT = 2,\n+  HSA_SIGNAL_CONDITION_GTE = 3\n+} hsa_signal_condition_t;\n+typedef enum {\n+  HSA_EXECUTABLE_STATE_UNFROZEN = 0,\n+  HSA_EXECUTABLE_STATE_FROZEN = 1\n+} hsa_executable_state_t;\n+typedef enum {\n+  HSA_ENDIANNESS_LITTLE = 0,\n+  HSA_ENDIANNESS_BIG = 1\n+} hsa_endianness_t;\n+typedef enum {\n+  HSA_MACHINE_MODEL_SMALL = 0,\n+  HSA_MACHINE_MODEL_LARGE = 1\n+} hsa_machine_model_t;\n+typedef enum {\n+  HSA_AGENT_INFO_NAME = 0,\n+  HSA_AGENT_INFO_VENDOR_NAME = 1,\n+  HSA_AGENT_INFO_FEATURE = 2,\n+  HSA_AGENT_INFO_MACHINE_MODEL = 3,\n+  HSA_AGENT_INFO_PROFILE = 4,\n+  HSA_AGENT_INFO_DEFAULT_FLOAT_ROUNDING_MODE = 5,\n+  HSA_AGENT_INFO_BASE_PROFILE_DEFAULT_FLOAT_ROUNDING_MODES = 23,\n+  HSA_AGENT_INFO_FAST_F16_OPERATION = 24,\n+  HSA_AGENT_INFO_WAVEFRONT_SIZE = 6,\n+  HSA_AGENT_INFO_WORKGROUP_MAX_DIM = 7,\n+  HSA_AGENT_INFO_WORKGROUP_MAX_SIZE = 8,\n+  HSA_AGENT_INFO_GRID_MAX_DIM = 9,\n+  HSA_AGENT_INFO_GRID_MAX_SIZE = 10,\n+  HSA_AGENT_INFO_FBARRIER_MAX_SIZE = 11,\n+  HSA_AGENT_INFO_QUEUES_MAX = 12,\n+  HSA_AGENT_INFO_QUEUE_MIN_SIZE = 13,\n+  HSA_AGENT_INFO_QUEUE_MAX_SIZE = 14,\n+  HSA_AGENT_INFO_QUEUE_TYPE = 15,\n+  HSA_AGENT_INFO_NODE = 16,\n+  HSA_AGENT_INFO_DEVICE = 17,\n+  HSA_AGENT_INFO_CACHE_SIZE = 18,\n+  HSA_AGENT_INFO_ISA = 19,\n+  HSA_AGENT_INFO_EXTENSIONS = 20,\n+  HSA_AGENT_INFO_VERSION_MAJOR = 21,\n+  HSA_AGENT_INFO_VERSION_MINOR = 22\n+} hsa_agent_info_t;\n+typedef struct hsa_barrier_and_packet_s {\n+  uint16_t header;\n+  uint16_t reserved0;\n+  uint32_t reserved1;\n+  hsa_signal_t dep_signal[5];\n+  uint64_t reserved2;\n+  hsa_signal_t completion_signal;\n+} hsa_barrier_and_packet_t;\n+typedef struct hsa_dim3_s {\n+  uint32_t x;\n+  uint32_t y;\n+  uint32_t z;\n+} hsa_dim3_t;\n+typedef enum {\n+  HSA_ACCESS_PERMISSION_RO = 1,\n+  HSA_ACCESS_PERMISSION_WO = 2,\n+  HSA_ACCESS_PERMISSION_RW = 3\n+} hsa_access_permission_t;\n+typedef enum {\n+  HSA_AGENT_FEATURE_KERNEL_DISPATCH = 1,\n+  HSA_AGENT_FEATURE_AGENT_DISPATCH = 2\n+} hsa_agent_feature_t;\n+typedef enum {\n+  HSA_WAIT_STATE_BLOCKED = 0,\n+  HSA_WAIT_STATE_ACTIVE = 1\n+} hsa_wait_state_t;\n+typedef struct hsa_executable_s { uint64_t handle; } hsa_executable_t;\n+typedef enum {\n+  HSA_REGION_SEGMENT_GLOBAL = 0,\n+  HSA_REGION_SEGMENT_READONLY = 1,\n+  HSA_REGION_SEGMENT_PRIVATE = 2,\n+  HSA_REGION_SEGMENT_GROUP = 3\n+} hsa_region_segment_t;\n+typedef enum {\n+  HSA_REGION_INFO_SEGMENT = 0,\n+  HSA_REGION_INFO_GLOBAL_FLAGS = 1,\n+  HSA_REGION_INFO_SIZE = 2,\n+  HSA_REGION_INFO_ALLOC_MAX_SIZE = 4,\n+  HSA_REGION_INFO_RUNTIME_ALLOC_ALLOWED = 5,\n+  HSA_REGION_INFO_RUNTIME_ALLOC_GRANULE = 6,\n+  HSA_REGION_INFO_RUNTIME_ALLOC_ALIGNMENT = 7\n+} hsa_region_info_t;\n+typedef enum {\n+  HSA_ISA_INFO_NAME_LENGTH = 0,\n+  HSA_ISA_INFO_NAME = 1,\n+  HSA_ISA_INFO_CALL_CONVENTION_COUNT = 2,\n+  HSA_ISA_INFO_CALL_CONVENTION_INFO_WAVEFRONT_SIZE = 3,\n+  HSA_ISA_INFO_CALL_CONVENTION_INFO_WAVEFRONTS_PER_COMPUTE_UNIT = 4\n+} hsa_isa_info_t;\n+typedef enum {\n+  HSA_VARIABLE_SEGMENT_GLOBAL = 0,\n+  HSA_VARIABLE_SEGMENT_READONLY = 1\n+} hsa_variable_segment_t;\n+typedef struct hsa_callback_data_s { uint64_t handle; } hsa_callback_data_t;\n+typedef enum {\n+  HSA_SYMBOL_KIND_VARIABLE = 0,\n+  HSA_SYMBOL_KIND_KERNEL = 1,\n+  HSA_SYMBOL_KIND_INDIRECT_FUNCTION = 2\n+} hsa_symbol_kind_t;\n+typedef struct hsa_kernel_dispatch_packet_s {\n+  uint16_t header;\n+  uint16_t setup;\n+  uint16_t workgroup_size_x;\n+  uint16_t workgroup_size_y;\n+  uint16_t workgroup_size_z;\n+  uint16_t reserved0;\n+  uint32_t grid_size_x;\n+  uint32_t grid_size_y;\n+  uint32_t grid_size_z;\n+  uint32_t private_segment_size;\n+  uint32_t group_segment_size;\n+  uint64_t kernel_object;\n+\n+#ifdef HSA_LARGE_MODEL\n+  void *kernarg_address;\n+#elif defined HSA_LITTLE_ENDIAN\n+  void *kernarg_address;\n+  uint32_t reserved1;\n+#else\n+  uint32_t reserved1;\n+  void *kernarg_address;\n+#endif\n+  uint64_t reserved2;\n+  hsa_signal_t completion_signal;\n+} hsa_kernel_dispatch_packet_t;\n+typedef enum {\n+  HSA_PACKET_TYPE_VENDOR_SPECIFIC = 0,\n+  HSA_PACKET_TYPE_INVALID = 1,\n+  HSA_PACKET_TYPE_KERNEL_DISPATCH = 2,\n+  HSA_PACKET_TYPE_BARRIER_AND = 3,\n+  HSA_PACKET_TYPE_AGENT_DISPATCH = 4,\n+  HSA_PACKET_TYPE_BARRIER_OR = 5\n+} hsa_packet_type_t;\n+typedef enum {\n+  HSA_PACKET_HEADER_TYPE = 0,\n+  HSA_PACKET_HEADER_BARRIER = 8,\n+  HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE = 9,\n+  HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE = 11\n+} hsa_packet_header_t;\n+typedef struct hsa_isa_s { uint64_t handle; } hsa_isa_t;\n+typedef enum {\n+  HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT = 0,\n+  HSA_DEFAULT_FLOAT_ROUNDING_MODE_ZERO = 1,\n+  HSA_DEFAULT_FLOAT_ROUNDING_MODE_NEAR = 2\n+} hsa_default_float_rounding_mode_t;\n+typedef struct hsa_code_symbol_s { uint64_t handle; } hsa_code_symbol_t;\n+typedef struct hsa_executable_symbol_s {\n+  uint64_t handle;\n+} hsa_executable_symbol_t;\n+#ifdef HSA_LARGE_MODEL\n+typedef int64_t hsa_signal_value_t;\n+#else\n+typedef int32_t hsa_signal_value_t;\n+#endif\n+typedef enum {\n+  HSA_EXCEPTION_POLICY_BREAK = 1,\n+  HSA_EXCEPTION_POLICY_DETECT = 2\n+} hsa_exception_policy_t;\n+typedef enum {\n+  HSA_SYSTEM_INFO_VERSION_MAJOR = 0,\n+  HSA_SYSTEM_INFO_VERSION_MINOR = 1,\n+  HSA_SYSTEM_INFO_TIMESTAMP = 2,\n+  HSA_SYSTEM_INFO_TIMESTAMP_FREQUENCY = 3,\n+  HSA_SYSTEM_INFO_SIGNAL_MAX_WAIT = 4,\n+  HSA_SYSTEM_INFO_ENDIANNESS = 5,\n+  HSA_SYSTEM_INFO_MACHINE_MODEL = 6,\n+  HSA_SYSTEM_INFO_EXTENSIONS = 7\n+} hsa_system_info_t;\n+typedef enum {\n+  HSA_EXECUTABLE_INFO_PROFILE = 1,\n+  HSA_EXECUTABLE_INFO_STATE = 2\n+} hsa_executable_info_t;\n+typedef enum {\n+  HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS = 0\n+} hsa_kernel_dispatch_packet_setup_t;\n+typedef enum {\n+  HSA_PACKET_HEADER_WIDTH_TYPE = 8,\n+  HSA_PACKET_HEADER_WIDTH_BARRIER = 1,\n+  HSA_PACKET_HEADER_WIDTH_ACQUIRE_FENCE_SCOPE = 2,\n+  HSA_PACKET_HEADER_WIDTH_RELEASE_FENCE_SCOPE = 2\n+} hsa_packet_header_width_t;\n+typedef enum {\n+  HSA_CODE_OBJECT_INFO_VERSION = 0,\n+  HSA_CODE_OBJECT_INFO_TYPE = 1,\n+  HSA_CODE_OBJECT_INFO_ISA = 2,\n+  HSA_CODE_OBJECT_INFO_MACHINE_MODEL = 3,\n+  HSA_CODE_OBJECT_INFO_PROFILE = 4,\n+  HSA_CODE_OBJECT_INFO_DEFAULT_FLOAT_ROUNDING_MODE = 5\n+} hsa_code_object_info_t;\n+typedef struct hsa_barrier_or_packet_s {\n+  uint16_t header;\n+  uint16_t reserved0;\n+  uint32_t reserved1;\n+  hsa_signal_t dep_signal[5];\n+  uint64_t reserved2;\n+  hsa_signal_t completion_signal;\n+} hsa_barrier_or_packet_t;\n+typedef enum {\n+  HSA_SYMBOL_KIND_LINKAGE_MODULE = 0,\n+  HSA_SYMBOL_KIND_LINKAGE_PROGRAM = 1,\n+} hsa_symbol_kind_linkage_t;\n+hsa_status_t hsa_executable_validate(hsa_executable_t executable,\n+                                     uint32_t *result);\n+uint64_t hsa_queue_add_write_index_acq_rel(const hsa_queue_t *queue,\n+                                           uint64_t value);\n+\n+uint64_t hsa_queue_add_write_index_acquire(const hsa_queue_t *queue,\n+                                           uint64_t value);\n+\n+uint64_t hsa_queue_add_write_index_relaxed(const hsa_queue_t *queue,\n+                                           uint64_t value);\n+\n+uint64_t hsa_queue_add_write_index_release(const hsa_queue_t *queue,\n+                                           uint64_t value);\n+hsa_status_t hsa_shut_down();\n+void hsa_signal_add_acq_rel(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_add_acquire(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_add_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_add_release(hsa_signal_t signal, hsa_signal_value_t value);\n+hsa_status_t hsa_executable_readonly_variable_define(\n+    hsa_executable_t executable, hsa_agent_t agent, const char *variable_name,\n+    void *address);\n+hsa_status_t hsa_agent_extension_supported(uint16_t extension,\n+                                           hsa_agent_t agent,\n+                                           uint16_t version_major,\n+                                           uint16_t version_minor,\n+                                           bool *result);\n+hsa_signal_value_t hsa_signal_load_acquire(hsa_signal_t signal);\n+\n+hsa_signal_value_t hsa_signal_load_relaxed(hsa_signal_t signal);\n+hsa_status_t hsa_executable_get_info(hsa_executable_t executable,\n+                                     hsa_executable_info_t attribute,\n+                                     void *value);\n+hsa_status_t hsa_iterate_agents(hsa_status_t (*callback)(hsa_agent_t agent,\n+                                                         void *data),\n+                                void *data);\n+void hsa_signal_subtract_acq_rel(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_subtract_acquire(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_subtract_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_subtract_release(hsa_signal_t signal, hsa_signal_value_t value);\n+hsa_status_t\n+hsa_executable_symbol_get_info(hsa_executable_symbol_t executable_symbol,\n+                               hsa_executable_symbol_info_t attribute,\n+                               void *value);\n+void hsa_signal_xor_acq_rel(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_xor_acquire(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_xor_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_xor_release(hsa_signal_t signal, hsa_signal_value_t value);\n+hsa_status_t hsa_code_object_get_info(hsa_code_object_t code_object,\n+                                      hsa_code_object_info_t attribute,\n+                                      void *value);\n+hsa_status_t hsa_code_object_deserialize(void *serialized_code_object,\n+                                         size_t serialized_code_object_size,\n+                                         const char *options,\n+                                         hsa_code_object_t *code_object);\n+hsa_status_t hsa_status_string(hsa_status_t status, const char **status_string);\n+hsa_status_t hsa_code_object_get_symbol(hsa_code_object_t code_object,\n+                                        const char *symbol_name,\n+                                        hsa_code_symbol_t *symbol);\n+void hsa_signal_store_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_store_release(hsa_signal_t signal, hsa_signal_value_t value);\n+hsa_status_t hsa_signal_destroy(hsa_signal_t signal);\n+hsa_status_t hsa_system_get_extension_table(uint16_t extension,\n+                                            uint16_t version_major,\n+                                            uint16_t version_minor,\n+                                            void *table);\n+hsa_status_t hsa_agent_iterate_regions(\n+    hsa_agent_t agent,\n+    hsa_status_t (*callback)(hsa_region_t region, void *data), void *data);\n+hsa_status_t hsa_executable_agent_global_variable_define(\n+    hsa_executable_t executable, hsa_agent_t agent, const char *variable_name,\n+    void *address);\n+hsa_status_t hsa_queue_create(hsa_agent_t agent, uint32_t size,\n+                              hsa_queue_type_t type,\n+                              void (*callback)(hsa_status_t status,\n+                                               hsa_queue_t *source, void *data),\n+                              void *data, uint32_t private_segment_size,\n+                              uint32_t group_segment_size, hsa_queue_t **queue);\n+hsa_status_t hsa_isa_compatible(hsa_isa_t code_object_isa, hsa_isa_t agent_isa,\n+                                bool *result);\n+hsa_status_t hsa_code_object_serialize(\n+    hsa_code_object_t code_object,\n+    hsa_status_t (*alloc_callback)(size_t size, hsa_callback_data_t data,\n+                                   void **address),\n+    hsa_callback_data_t callback_data, const char *options,\n+    void **serialized_code_object, size_t *serialized_code_object_size);\n+hsa_status_t hsa_region_get_info(hsa_region_t region,\n+                                 hsa_region_info_t attribute, void *value);\n+hsa_status_t hsa_executable_freeze(hsa_extension_t executable,\n+                                   const char *options);\n+hsa_status_t hsa_system_extension_supported(uint16_t extension,\n+                                            uint16_t version_major,\n+                                            uint16_t version_minor,\n+                                            bool *result);\n+hsa_signal_value_t hsa_signal_wait_acquire(hsa_signal_t signal,\n+                                           hsa_signal_condition_t condition,\n+                                           hsa_signal_value_t compare_value,\n+                                           uint64_t timeout_hint,\n+                                           hsa_wait_state_t wait_state_hint);\n+\n+hsa_signal_value_t hsa_signal_wait_relaxed(hsa_signal_t signal,\n+                                           hsa_signal_condition_t condition,\n+                                           hsa_signal_value_t compare_value,\n+                                           uint64_t timeout_hint,\n+                                           hsa_wait_state_t wait_state_hint);\n+hsa_status_t hsa_memory_copy(void *dst, const void *src, size_t size);\n+hsa_status_t hsa_memory_free(void *ptr);\n+hsa_status_t hsa_queue_destroy(hsa_queue_t *queue);\n+hsa_status_t hsa_isa_from_name(const char *name, hsa_isa_t *isa);\n+hsa_status_t hsa_isa_get_info(hsa_isa_t isa, hsa_isa_info_t attribute,\n+                              uint32_t index, void *value);\n+hsa_status_t hsa_signal_create(hsa_signal_value_t initial_value,\n+                               uint32_t num_consumers,\n+                               const hsa_agent_t *consumers,\n+                               hsa_signal_t *signal);\n+hsa_status_t hsa_code_symbol_get_info(hsa_code_symbol_t code_symbol,\n+                                      hsa_code_symbol_info_t attribute,\n+                                      void *value);\n+hsa_signal_value_t hsa_signal_cas_acq_rel(hsa_signal_t signal,\n+                                          hsa_signal_value_t expected,\n+                                          hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_cas_acquire(hsa_signal_t signal,\n+                                          hsa_signal_value_t expected,\n+                                          hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_cas_relaxed(hsa_signal_t signal,\n+                                          hsa_signal_value_t expected,\n+                                          hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_cas_release(hsa_signal_t signal,\n+                                          hsa_signal_value_t expected,\n+                                          hsa_signal_value_t value);\n+hsa_status_t hsa_code_object_iterate_symbols(\n+    hsa_code_object_t code_object,\n+    hsa_status_t (*callback)(hsa_code_object_t code_object,\n+                             hsa_code_symbol_t symbol, void *data),\n+    void *data);\n+void hsa_queue_store_read_index_relaxed(const hsa_queue_t *queue,\n+                                        uint64_t value);\n+\n+void hsa_queue_store_read_index_release(const hsa_queue_t *queue,\n+                                        uint64_t value);\n+hsa_status_t hsa_memory_assign_agent(void *ptr, hsa_agent_t agent,\n+                                     hsa_access_permission_t access);\n+hsa_status_t hsa_queue_inactivate(hsa_queue_t *queue);\n+hsa_status_t hsa_executable_get_symbol(hsa_executable_t executable,\n+                                       const char *module_name,\n+                                       const char *symbol_name,\n+                                       hsa_agent_t agent,\n+                                       int32_t call_convention,\n+                                       hsa_executable_symbol_t *symbol);\n+uint64_t hsa_queue_cas_write_index_acq_rel(const hsa_queue_t *queue,\n+                                           uint64_t expected, uint64_t value);\n+\n+uint64_t hsa_queue_cas_write_index_acquire(const hsa_queue_t *queue,\n+                                           uint64_t expected, uint64_t value);\n+\n+uint64_t hsa_queue_cas_write_index_relaxed(const hsa_queue_t *queue,\n+                                           uint64_t expected, uint64_t value);\n+\n+uint64_t hsa_queue_cas_write_index_release(const hsa_queue_t *queue,\n+                                           uint64_t expected, uint64_t value);\n+void hsa_signal_and_acq_rel(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_and_acquire(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_and_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_and_release(hsa_signal_t signal, hsa_signal_value_t value);\n+uint64_t hsa_queue_load_read_index_acquire(const hsa_queue_t *queue);\n+\n+uint64_t hsa_queue_load_read_index_relaxed(const hsa_queue_t *queue);\n+hsa_status_t hsa_executable_load_code_object(hsa_executable_t executable,\n+                                             hsa_agent_t agent,\n+                                             hsa_code_object_t code_object,\n+                                             const char *options);\n+uint64_t hsa_queue_load_write_index_acquire(const hsa_queue_t *queue);\n+\n+uint64_t hsa_queue_load_write_index_relaxed(const hsa_queue_t *queue);\n+hsa_status_t hsa_agent_get_exception_policies(hsa_agent_t agent,\n+                                              hsa_profile_t profile,\n+                                              uint16_t *mask);\n+hsa_status_t hsa_memory_deregister(void *ptr, size_t size);\n+void hsa_signal_or_acq_rel(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_or_acquire(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_or_relaxed(hsa_signal_t signal, hsa_signal_value_t value);\n+\n+void hsa_signal_or_release(hsa_signal_t signal, hsa_signal_value_t value);\n+hsa_status_t hsa_soft_queue_create(hsa_region_t region, uint32_t size,\n+                                   hsa_queue_type_t type, uint32_t features,\n+                                   hsa_signal_t doorbell_signal,\n+                                   hsa_queue_t **queue);\n+hsa_status_t hsa_executable_iterate_symbols(\n+    hsa_executable_t executable,\n+    hsa_status_t (*callback)(hsa_executable_t executable,\n+                             hsa_executable_symbol_t symbol, void *data),\n+    void *data);\n+hsa_status_t hsa_memory_register(void *ptr, size_t size);\n+void hsa_queue_store_write_index_relaxed(const hsa_queue_t *queue,\n+                                         uint64_t value);\n+\n+void hsa_queue_store_write_index_release(const hsa_queue_t *queue,\n+                                         uint64_t value);\n+hsa_status_t hsa_executable_global_variable_define(hsa_executable_t executable,\n+                                                   const char *variable_name,\n+                                                   void *address);\n+hsa_status_t hsa_executable_destroy(hsa_executable_t executable);\n+hsa_status_t hsa_code_object_destroy(hsa_code_object_t code_object);\n+hsa_status_t hsa_memory_allocate(hsa_region_t region, size_t size, void **ptr);\n+hsa_signal_value_t hsa_signal_exchange_acq_rel(hsa_signal_t signal,\n+                                               hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_exchange_acquire(hsa_signal_t signal,\n+                                               hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_exchange_relaxed(hsa_signal_t signal,\n+                                               hsa_signal_value_t value);\n+\n+hsa_signal_value_t hsa_signal_exchange_release(hsa_signal_t signal,\n+                                               hsa_signal_value_t value);\n+hsa_status_t hsa_agent_get_info(hsa_agent_t agent, hsa_agent_info_t attribute,\n+                                void *value);\n+hsa_status_t hsa_init();\n+hsa_status_t hsa_system_get_info(hsa_system_info_t attribute, void *value);\n+hsa_status_t hsa_executable_create(hsa_profile_t profile,\n+                                   hsa_executable_state_t executable_state,\n+                                   const char *options,\n+                                   hsa_executable_t *executable);\n+\n+#endif /* _HSA_H */"}, {"sha": "f159addd2270c3ab42b7b7a5bbe9a028995ca717", "filename": "libgomp/plugin/hsa_ext_finalize.h", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fhsa_ext_finalize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fhsa_ext_finalize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fhsa_ext_finalize.h?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -0,0 +1,265 @@\n+/* HSA Extensions API 1.0.1 representation description.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.\n+\n+The contents of the file was created by extracting data structures, enum,\n+typedef and other definitions from HSA Runtime Programmer\u2019s Reference Manual\n+Version 1.0 (http://www.hsafoundation.com/standards/).\n+\n+HTML version is provided on the following link:\n+http://www.hsafoundation.com/html/Content/Runtime/Topics/Runtime_title_page.htm\n+*/\n+\n+\n+#ifndef _HSA_EXT_FINALIZE_H\n+#define _HSA_EXT_FINALIZE_H 1\n+\n+struct BrigModuleHeader;\n+typedef struct BrigModuleHeader *BrigModule_t;\n+\n+typedef enum {\n+  HSA_EXT_IMAGE_GEOMETRY_1D = 0,\n+  HSA_EXT_IMAGE_GEOMETRY_2D = 1,\n+  HSA_EXT_IMAGE_GEOMETRY_3D = 2,\n+  HSA_EXT_IMAGE_GEOMETRY_1DA = 3,\n+  HSA_EXT_IMAGE_GEOMETRY_2DA = 4,\n+  HSA_EXT_IMAGE_GEOMETRY_1DB = 5,\n+  HSA_EXT_IMAGE_GEOMETRY_2DDEPTH = 6,\n+  HSA_EXT_IMAGE_GEOMETRY_2DADEPTH = 7\n+} hsa_ext_image_geometry_t;\n+\n+typedef enum {\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT8 = 0,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT16 = 1,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT8 = 2,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT16 = 3,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT24 = 4,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_555 = 5,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_565 = 6,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_101010 = 7,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT8 = 8,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT16 = 9,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT32 = 10,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT8 = 11,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT16 = 12,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT32 = 13,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_HALF_FLOAT = 14,\n+  HSA_EXT_IMAGE_CHANNEL_TYPE_FLOAT = 15\n+} hsa_ext_image_channel_type_t;\n+\n+typedef enum {\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_A = 0,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_R = 1,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RX = 2,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RG = 3,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RGX = 4,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RA = 5,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RGB = 6,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RGBX = 7,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_RGBA = 8,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_BGRA = 9,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_ARGB = 10,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_ABGR = 11,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB = 12,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBX = 13,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBA = 14,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_SBGRA = 15,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_INTENSITY = 16,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_LUMINANCE = 17,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH = 18,\n+  HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH_STENCIL = 19\n+} hsa_ext_image_channel_order_t;\n+\n+typedef struct hsa_ext_image_format_s\n+{\n+  hsa_ext_image_channel_type_t channel_type;\n+  hsa_ext_image_channel_order_t channel_order;\n+} hsa_ext_image_format_t;\n+\n+typedef struct hsa_ext_sampler_s\n+{\n+  uint64_t handle;\n+} hsa_ext_sampler_t;\n+typedef struct hsa_ext_image_data_info_s\n+{\n+  size_t size;\n+  size_t alignment;\n+} hsa_ext_image_data_info_t;\n+typedef enum {\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_UNDEFINED = 0,\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_EDGE = 1,\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_BORDER = 2,\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_REPEAT = 3,\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_MIRRORED_REPEAT = 4\n+} hsa_ext_sampler_addressing_mode_t;\n+typedef struct hsa_ext_image_s\n+{\n+  uint64_t handle;\n+} hsa_ext_image_t;\n+typedef enum {\n+  HSA_EXT_IMAGE_CAPABILITY_NOT_SUPPORTED = 0x0,\n+  HSA_EXT_IMAGE_CAPABILITY_READ_ONLY = 0x1,\n+  HSA_EXT_IMAGE_CAPABILITY_WRITE_ONLY = 0x2,\n+  HSA_EXT_IMAGE_CAPABILITY_READ_WRITE = 0x4,\n+  HSA_EXT_IMAGE_CAPABILITY_READ_MODIFY_WRITE = 0x8,\n+  HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT = 0x10\n+} hsa_ext_image_capability_t;\n+typedef struct hsa_ext_control_directives_s\n+{\n+  uint64_t control_directives_mask;\n+  uint16_t break_exceptions_mask;\n+  uint16_t detect_exceptions_mask;\n+  uint32_t max_dynamic_group_size;\n+  uint64_t max_flat_grid_size;\n+  uint32_t max_flat_workgroup_size;\n+  uint32_t reserved1;\n+  uint64_t required_grid_size[3];\n+  hsa_dim3_t required_workgroup_size;\n+  uint8_t required_dim;\n+  uint8_t reserved2[75];\n+} hsa_ext_control_directives_t;\n+typedef enum {\n+  HSA_EXT_SAMPLER_FILTER_MODE_NEAREST = 0,\n+  HSA_EXT_SAMPLER_FILTER_MODE_LINEAR = 1\n+} hsa_ext_sampler_filter_mode_t;\n+\n+typedef enum {\n+  HSA_EXT_SAMPLER_COORDINATE_MODE_UNNORMALIZED = 0,\n+  HSA_EXT_SAMPLER_COORDINATE_MODE_NORMALIZED = 1\n+} hsa_ext_sampler_coordinate_mode_t;\n+typedef enum {\n+  HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO = -1\n+} hsa_ext_finalizer_call_convention_t;\n+typedef struct hsa_ext_program_s\n+{\n+  uint64_t handle;\n+} hsa_ext_program_t;\n+typedef struct hsa_ext_image_descriptor_s\n+{\n+  hsa_ext_image_geometry_t geometry;\n+  size_t width;\n+  size_t height;\n+  size_t depth;\n+  size_t array_size;\n+  hsa_ext_image_format_t format;\n+} hsa_ext_image_descriptor_t;\n+typedef enum {\n+  HSA_EXT_PROGRAM_INFO_MACHINE_MODEL = 0,\n+  HSA_EXT_PROGRAM_INFO_PROFILE = 1,\n+  HSA_EXT_PROGRAM_INFO_DEFAULT_FLOAT_ROUNDING_MODE = 2\n+} hsa_ext_program_info_t;\n+typedef BrigModule_t hsa_ext_module_t;\n+typedef struct hsa_ext_sampler_descriptor_s\n+{\n+  hsa_ext_sampler_coordinate_mode_t coordinate_mode;\n+  hsa_ext_sampler_filter_mode_t filter_mode;\n+  hsa_ext_sampler_addressing_mode_t address_mode;\n+} hsa_ext_sampler_descriptor_t;\n+\n+typedef struct hsa_ext_image_region_s\n+{\n+  hsa_dim3_t offset;\n+  hsa_dim3_t range;\n+} hsa_ext_image_region_t;\n+hsa_status_t hsa_ext_image_export (hsa_agent_t agent, hsa_ext_image_t src_image,\n+\t\t\t\t   void *dst_memory, size_t dst_row_pitch,\n+\t\t\t\t   size_t dst_slice_pitch,\n+\t\t\t\t   const hsa_ext_image_region_t *image_region);\n+hsa_status_t hsa_ext_program_add_module (hsa_ext_program_t program,\n+\t\t\t\t\t hsa_ext_module_t module);\n+hsa_status_t hsa_ext_program_iterate_modules (\n+  hsa_ext_program_t program,\n+  hsa_status_t (*callback) (hsa_ext_program_t program, hsa_ext_module_t module,\n+\t\t\t    void *data),\n+  void *data);\n+hsa_status_t hsa_ext_program_create (\n+  hsa_machine_model_t machine_model, hsa_profile_t profile,\n+  hsa_default_float_rounding_mode_t default_float_rounding_mode,\n+  const char *options, hsa_ext_program_t *program);\n+hsa_status_t\n+hsa_ext_image_data_get_info (hsa_agent_t agent,\n+\t\t\t     const hsa_ext_image_descriptor_t *image_descriptor,\n+\t\t\t     hsa_access_permission_t access_permission,\n+\t\t\t     hsa_ext_image_data_info_t *image_data_info);\n+\n+hsa_status_t hsa_ext_image_import (hsa_agent_t agent, const void *src_memory,\n+\t\t\t\t   size_t src_row_pitch, size_t src_slice_pitch,\n+\t\t\t\t   hsa_ext_image_t dst_image,\n+\t\t\t\t   const hsa_ext_image_region_t *image_region);\n+hsa_status_t hsa_ext_program_get_info (hsa_ext_program_t program,\n+\t\t\t\t       hsa_ext_program_info_t attribute,\n+\t\t\t\t       void *value);\n+enum\n+{\n+  HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED = 0x3000,\n+  HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED = 0x3001\n+};\n+hsa_status_t hsa_ext_image_destroy (hsa_agent_t agent, hsa_ext_image_t image);\n+hsa_status_t hsa_ext_image_get_capability (\n+  hsa_agent_t agent, hsa_ext_image_geometry_t geometry,\n+  const hsa_ext_image_format_t *image_format, uint32_t *capability_mask);\n+enum\n+{\n+  HSA_EXT_STATUS_ERROR_INVALID_PROGRAM = 0x2000,\n+  HSA_EXT_STATUS_ERROR_INVALID_MODULE = 0x2001,\n+  HSA_EXT_STATUS_ERROR_INCOMPATIBLE_MODULE = 0x2002,\n+  HSA_EXT_STATUS_ERROR_MODULE_ALREADY_INCLUDED = 0x2003,\n+  HSA_EXT_STATUS_ERROR_SYMBOL_MISMATCH = 0x2004,\n+  HSA_EXT_STATUS_ERROR_FINALIZATION_FAILED = 0x2005,\n+  HSA_EXT_STATUS_ERROR_DIRECTIVE_MISMATCH = 0x2006\n+};\n+hsa_status_t hsa_ext_sampler_destroy (hsa_agent_t agent,\n+\t\t\t\t      hsa_ext_sampler_t sampler);\n+hsa_status_t hsa_ext_program_finalize (\n+  hsa_ext_program_t program, hsa_isa_t isa, int32_t call_convention,\n+  hsa_ext_control_directives_t control_directives, const char *options,\n+  hsa_code_object_type_t code_object_type, hsa_code_object_t *code_object);\n+hsa_status_t hsa_ext_image_create (\n+  hsa_agent_t agent, const hsa_ext_image_descriptor_t *image_descriptor,\n+  const void *image_data, hsa_access_permission_t access_permission,\n+  hsa_ext_image_t *image);\n+hsa_status_t hsa_ext_program_destroy (hsa_ext_program_t program);\n+hsa_status_t hsa_ext_image_copy (hsa_agent_t agent, hsa_ext_image_t src_image,\n+\t\t\t\t const hsa_dim3_t *src_offset,\n+\t\t\t\t hsa_ext_image_t dst_image,\n+\t\t\t\t const hsa_dim3_t *dst_offset,\n+\t\t\t\t const hsa_dim3_t *range);\n+hsa_status_t hsa_ext_image_clear (hsa_agent_t agent, hsa_ext_image_t image,\n+\t\t\t\t  const void *data,\n+\t\t\t\t  const hsa_ext_image_region_t *image_region);\n+enum\n+{\n+  HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS = 0x3000,\n+  HSA_EXT_AGENT_INFO_IMAGE_1DA_MAX_ELEMENTS = 0x3001,\n+  HSA_EXT_AGENT_INFO_IMAGE_1DB_MAX_ELEMENTS = 0x3002,\n+  HSA_EXT_AGENT_INFO_IMAGE_2D_MAX_ELEMENTS = 0x3003,\n+  HSA_EXT_AGENT_INFO_IMAGE_2DA_MAX_ELEMENTS = 0x3004,\n+  HSA_EXT_AGENT_INFO_IMAGE_2DDEPTH_MAX_ELEMENTS = 0x3005,\n+  HSA_EXT_AGENT_INFO_IMAGE_2DADEPTH_MAX_ELEMENTS = 0x3006,\n+  HSA_EXT_AGENT_INFO_IMAGE_3D_MAX_ELEMENTS = 0x3007,\n+  HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS = 0x3008,\n+  HSA_EXT_AGENT_INFO_MAX_IMAGE_RD_HANDLES = 0x3009,\n+  HSA_EXT_AGENT_INFO_MAX_IMAGE_RORW_HANDLES = 0x300A,\n+  HSA_EXT_AGENT_INFO_MAX_SAMPLER_HANDLERS = 0x300B\n+};\n+hsa_status_t\n+hsa_ext_sampler_create (hsa_agent_t agent,\n+\t\t\tconst hsa_ext_sampler_descriptor_t *sampler_descriptor,\n+\t\t\thsa_ext_sampler_t *sampler);\n+\n+#endif /* _HSA_EXT_FINALIZE_H */"}, {"sha": "b829c8ca81f7b488e285a98a49b8a901dafaf9d5", "filename": "libgomp/plugin/plugin-hsa.c", "status": "modified", "additions": 388, "deletions": 117, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fplugin-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Fplugin%2Fplugin-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-hsa.c?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -27,16 +27,129 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+#include \"config.h\"\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <pthread.h>\n-#include <hsa.h>\n-#include <hsa_ext_finalize.h>\n+#include <inttypes.h>\n+#include <stdbool.h>\n+#include <plugin/hsa.h>\n+#include <plugin/hsa_ext_finalize.h>\n #include <dlfcn.h>\n #include \"libgomp-plugin.h\"\n #include \"gomp-constants.h\"\n \n+/* Secure getenv() which returns NULL if running as SUID/SGID.  */\n+#ifndef HAVE_SECURE_GETENV\n+#ifdef HAVE___SECURE_GETENV\n+#define secure_getenv __secure_getenv\n+#elif defined (HAVE_UNISTD_H) && defined(HAVE_GETUID) && defined(HAVE_GETEUID) \\\n+  && defined(HAVE_GETGID) && defined(HAVE_GETEGID)\n+\n+#include <unistd.h>\n+\n+/* Implementation of secure_getenv() for targets where it is not provided but\n+   we have at least means to test real and effective IDs. */\n+\n+static char *\n+secure_getenv (const char *name)\n+{\n+  if ((getuid () == geteuid ()) && (getgid () == getegid ()))\n+    return getenv (name);\n+  else\n+    return NULL;\n+}\n+\n+#else\n+#define secure_getenv getenv\n+#endif\n+#endif\n+\n+/* As an HSA runtime is dlopened, following structure defines function\n+   pointers utilized by the HSA plug-in.  */\n+\n+struct hsa_runtime_fn_info\n+{\n+  /* HSA runtime.  */\n+  hsa_status_t (*hsa_status_string_fn) (hsa_status_t status,\n+\t\t\t\t\tconst char **status_string);\n+  hsa_status_t (*hsa_agent_get_info_fn) (hsa_agent_t agent,\n+\t\t\t\t\t hsa_agent_info_t attribute,\n+\t\t\t\t\t void *value);\n+  hsa_status_t (*hsa_init_fn) (void);\n+  hsa_status_t (*hsa_iterate_agents_fn)\n+    (hsa_status_t (*callback)(hsa_agent_t agent, void *data), void *data);\n+  hsa_status_t (*hsa_region_get_info_fn) (hsa_region_t region,\n+\t\t\t\t\t  hsa_region_info_t attribute,\n+\t\t\t\t\t  void *value);\n+  hsa_status_t (*hsa_queue_create_fn)\n+    (hsa_agent_t agent, uint32_t size, hsa_queue_type_t type,\n+     void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),\n+     void *data, uint32_t private_segment_size,\n+     uint32_t group_segment_size, hsa_queue_t **queue);\n+  hsa_status_t (*hsa_agent_iterate_regions_fn)\n+    (hsa_agent_t agent,\n+     hsa_status_t (*callback)(hsa_region_t region, void *data), void *data);\n+  hsa_status_t (*hsa_executable_destroy_fn) (hsa_executable_t executable);\n+  hsa_status_t (*hsa_executable_create_fn)\n+    (hsa_profile_t profile, hsa_executable_state_t executable_state,\n+     const char *options, hsa_executable_t *executable);\n+  hsa_status_t (*hsa_executable_global_variable_define_fn)\n+    (hsa_executable_t executable, const char *variable_name, void *address);\n+  hsa_status_t (*hsa_executable_load_code_object_fn)\n+    (hsa_executable_t executable, hsa_agent_t agent,\n+     hsa_code_object_t code_object, const char *options);\n+  hsa_status_t (*hsa_executable_freeze_fn)(hsa_executable_t executable,\n+\t\t\t\t\t   const char *options);\n+  hsa_status_t (*hsa_signal_create_fn) (hsa_signal_value_t initial_value,\n+\t\t\t\t\tuint32_t num_consumers,\n+\t\t\t\t\tconst hsa_agent_t *consumers,\n+\t\t\t\t\thsa_signal_t *signal);\n+  hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,\n+\t\t\t\t\t  void **ptr);\n+  hsa_status_t (*hsa_memory_free_fn) (void *ptr);\n+  hsa_status_t (*hsa_signal_destroy_fn) (hsa_signal_t signal);\n+  hsa_status_t (*hsa_executable_get_symbol_fn)\n+    (hsa_executable_t executable, const char *module_name,\n+     const char *symbol_name, hsa_agent_t agent, int32_t call_convention,\n+     hsa_executable_symbol_t *symbol);\n+  hsa_status_t (*hsa_executable_symbol_get_info_fn)\n+    (hsa_executable_symbol_t executable_symbol,\n+     hsa_executable_symbol_info_t attribute, void *value);\n+  uint64_t (*hsa_queue_add_write_index_release_fn) (const hsa_queue_t *queue,\n+\t\t\t\t\t\t    uint64_t value);\n+  uint64_t (*hsa_queue_load_read_index_acquire_fn) (const hsa_queue_t *queue);\n+  void (*hsa_signal_store_relaxed_fn) (hsa_signal_t signal,\n+\t\t\t\t       hsa_signal_value_t value);\n+  void (*hsa_signal_store_release_fn) (hsa_signal_t signal,\n+\t\t\t\t       hsa_signal_value_t value);\n+  hsa_signal_value_t (*hsa_signal_wait_acquire_fn)\n+    (hsa_signal_t signal, hsa_signal_condition_t condition,\n+     hsa_signal_value_t compare_value, uint64_t timeout_hint,\n+     hsa_wait_state_t wait_state_hint);\n+  hsa_signal_value_t (*hsa_signal_load_acquire_fn) (hsa_signal_t signal);\n+  hsa_status_t (*hsa_queue_destroy_fn) (hsa_queue_t *queue);\n+\n+  /* HSA finalizer.  */\n+  hsa_status_t (*hsa_ext_program_add_module_fn) (hsa_ext_program_t program,\n+\t\t\t\t\t\t hsa_ext_module_t module);\n+  hsa_status_t (*hsa_ext_program_create_fn)\n+    (hsa_machine_model_t machine_model, hsa_profile_t profile,\n+     hsa_default_float_rounding_mode_t default_float_rounding_mode,\n+     const char *options, hsa_ext_program_t *program);\n+  hsa_status_t (*hsa_ext_program_destroy_fn) (hsa_ext_program_t program);\n+  hsa_status_t (*hsa_ext_program_finalize_fn)\n+    (hsa_ext_program_t program,hsa_isa_t isa,\n+     int32_t call_convention, hsa_ext_control_directives_t control_directives,\n+     const char *options, hsa_code_object_type_t code_object_type,\n+     hsa_code_object_t *code_object);\n+};\n+\n+/* HSA runtime functions that are initialized in init_hsa_context.  */\n+\n+static struct hsa_runtime_fn_info hsa_fns;\n+\n /* Keep the following GOMP prefixed structures in sync with respective parts of\n    the compiler.  */\n \n@@ -129,20 +242,36 @@ static bool debug;\n \n static bool suppress_host_fallback;\n \n+/* Flag to locate HSA runtime shared library that is dlopened\n+   by this plug-in.  */\n+\n+static const char *hsa_runtime_lib;\n+\n+/* Flag to decide if the runtime should support also CPU devices (can be\n+   a simulator).  */\n+\n+static bool support_cpu_devices;\n+\n /* Initialize debug and suppress_host_fallback according to the environment.  */\n \n static void\n init_enviroment_variables (void)\n {\n-  if (getenv (\"HSA_DEBUG\"))\n+  if (secure_getenv (\"HSA_DEBUG\"))\n     debug = true;\n   else\n     debug = false;\n \n-  if (getenv (\"HSA_SUPPRESS_HOST_FALLBACK\"))\n+  if (secure_getenv (\"HSA_SUPPRESS_HOST_FALLBACK\"))\n     suppress_host_fallback = true;\n   else\n     suppress_host_fallback = false;\n+\n+  hsa_runtime_lib = secure_getenv (\"HSA_RUNTIME_LIB\");\n+  if (hsa_runtime_lib == NULL)\n+    hsa_runtime_lib = HSA_RUNTIME_LIB \"libhsa-runtime64.so\";\n+\n+  support_cpu_devices = secure_getenv (\"HSA_SUPPORT_CPU_DEVICES\");\n }\n \n /* Print a logging message with PREFIX to stderr if HSA_DEBUG value\n@@ -176,7 +305,7 @@ hsa_warn (const char *str, hsa_status_t status)\n     return;\n \n   const char *hsa_error_msg;\n-  hsa_status_string (status, &hsa_error_msg);\n+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n \n   fprintf (stderr, \"HSA warning: %s\\nRuntime message: %s\", str, hsa_error_msg);\n }\n@@ -188,7 +317,7 @@ static void\n hsa_fatal (const char *str, hsa_status_t status)\n {\n   const char *hsa_error_msg;\n-  hsa_status_string (status, &hsa_error_msg);\n+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n   GOMP_PLUGIN_fatal (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n \t\t     hsa_error_msg);\n }\n@@ -200,7 +329,7 @@ static bool\n hsa_error (const char *str, hsa_status_t status)\n {\n   const char *hsa_error_msg;\n-  hsa_status_string (status, &hsa_error_msg);\n+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n   GOMP_PLUGIN_error (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n \t\t     hsa_error_msg);\n   return false;\n@@ -359,6 +488,50 @@ struct hsa_context_info\n \n static struct hsa_context_info hsa_context;\n \n+#define DLSYM_FN(function) \\\n+  hsa_fns.function##_fn = dlsym (handle, #function); \\\n+  if (hsa_fns.function##_fn == NULL) \\\n+    return false;\n+\n+static bool\n+init_hsa_runtime_functions (void)\n+{\n+  void *handle = dlopen (hsa_runtime_lib, RTLD_LAZY);\n+  if (handle == NULL)\n+    return false;\n+\n+  DLSYM_FN (hsa_status_string)\n+  DLSYM_FN (hsa_agent_get_info)\n+  DLSYM_FN (hsa_init)\n+  DLSYM_FN (hsa_iterate_agents)\n+  DLSYM_FN (hsa_region_get_info)\n+  DLSYM_FN (hsa_queue_create)\n+  DLSYM_FN (hsa_agent_iterate_regions)\n+  DLSYM_FN (hsa_executable_destroy)\n+  DLSYM_FN (hsa_executable_create)\n+  DLSYM_FN (hsa_executable_global_variable_define)\n+  DLSYM_FN (hsa_executable_load_code_object)\n+  DLSYM_FN (hsa_executable_freeze)\n+  DLSYM_FN (hsa_signal_create)\n+  DLSYM_FN (hsa_memory_allocate)\n+  DLSYM_FN (hsa_memory_free)\n+  DLSYM_FN (hsa_signal_destroy)\n+  DLSYM_FN (hsa_executable_get_symbol)\n+  DLSYM_FN (hsa_executable_symbol_get_info)\n+  DLSYM_FN (hsa_queue_add_write_index_release)\n+  DLSYM_FN (hsa_queue_load_read_index_acquire)\n+  DLSYM_FN (hsa_signal_wait_acquire)\n+  DLSYM_FN (hsa_signal_store_relaxed)\n+  DLSYM_FN (hsa_signal_store_release)\n+  DLSYM_FN (hsa_signal_load_acquire)\n+  DLSYM_FN (hsa_queue_destroy)\n+  DLSYM_FN (hsa_ext_program_add_module)\n+  DLSYM_FN (hsa_ext_program_create)\n+  DLSYM_FN (hsa_ext_program_destroy)\n+  DLSYM_FN (hsa_ext_program_finalize)\n+  return true;\n+}\n+\n /* Find kernel for an AGENT by name provided in KERNEL_NAME.  */\n \n static struct kernel_info *\n@@ -386,17 +559,32 @@ suitable_hsa_agent_p (hsa_agent_t agent)\n {\n   hsa_device_type_t device_type;\n   hsa_status_t status\n-    = hsa_agent_get_info (agent, HSA_AGENT_INFO_DEVICE, &device_type);\n-  if (status != HSA_STATUS_SUCCESS || device_type != HSA_DEVICE_TYPE_GPU)\n+    = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,\n+\t\t\t\t     &device_type);\n+  if (status != HSA_STATUS_SUCCESS)\n     return false;\n \n+  switch (device_type)\n+    {\n+    case HSA_DEVICE_TYPE_GPU:\n+      break;\n+    case HSA_DEVICE_TYPE_CPU:\n+      if (!support_cpu_devices)\n+\treturn false;\n+      break;\n+    default:\n+      return false;\n+    }\n+\n   uint32_t features = 0;\n-  status = hsa_agent_get_info (agent, HSA_AGENT_INFO_FEATURE, &features);\n+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_FEATURE,\n+\t\t\t\t\t  &features);\n   if (status != HSA_STATUS_SUCCESS\n       || !(features & HSA_AGENT_FEATURE_KERNEL_DISPATCH))\n     return false;\n   hsa_queue_type_t queue_type;\n-  status = hsa_agent_get_info (agent, HSA_AGENT_INFO_QUEUE_TYPE, &queue_type);\n+  status = hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_QUEUE_TYPE,\n+\t\t\t\t\t  &queue_type);\n   if (status != HSA_STATUS_SUCCESS\n       || (queue_type != HSA_QUEUE_TYPE_MULTI))\n     return false;\n@@ -443,19 +631,24 @@ init_hsa_context (void)\n   if (hsa_context.initialized)\n     return true;\n   init_enviroment_variables ();\n-  status = hsa_init ();\n+  if (!init_hsa_runtime_functions ())\n+    {\n+      HSA_DEBUG (\"Run-time could not be dynamically opened\\n\");\n+      return false;\n+    }\n+  status = hsa_fns.hsa_init_fn ();\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Run-time could not be initialized\", status);\n   HSA_DEBUG (\"HSA run-time initialized\\n\");\n-  status = hsa_iterate_agents (count_gpu_agents, NULL);\n+  status = hsa_fns.hsa_iterate_agents_fn (count_gpu_agents, NULL);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"HSA GPU devices could not be enumerated\", status);\n   HSA_DEBUG (\"There are %i HSA GPU devices.\\n\", hsa_context.agent_count);\n \n   hsa_context.agents\n     = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count\n \t\t\t\t  * sizeof (struct agent_info));\n-  status = hsa_iterate_agents (assign_agent_ids, &agent_index);\n+  status = hsa_fns.hsa_iterate_agents_fn (assign_agent_ids, &agent_index);\n   if (agent_index != hsa_context.agent_count)\n     {\n       GOMP_PLUGIN_error (\"Failed to assign IDs to all HSA agents\");\n@@ -485,14 +678,16 @@ get_kernarg_memory_region (hsa_region_t region, void *data)\n   hsa_status_t status;\n   hsa_region_segment_t segment;\n \n-  status = hsa_region_get_info (region, HSA_REGION_INFO_SEGMENT, &segment);\n+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT,\n+\t\t\t\t\t   &segment);\n   if (status != HSA_STATUS_SUCCESS)\n     return status;\n   if (segment != HSA_REGION_SEGMENT_GLOBAL)\n     return HSA_STATUS_SUCCESS;\n \n   uint32_t flags;\n-  status = hsa_region_get_info (region, HSA_REGION_INFO_GLOBAL_FLAGS, &flags);\n+  status = hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,\n+\t\t\t\t\t   &flags);\n   if (status != HSA_STATUS_SUCCESS)\n     return status;\n   if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)\n@@ -546,29 +741,36 @@ GOMP_OFFLOAD_init_device (int n)\n \n   uint32_t queue_size;\n   hsa_status_t status;\n-  status = hsa_agent_get_info (agent->id, HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n-\t\t\t       &queue_size);\n+  status = hsa_fns.hsa_agent_get_info_fn (agent->id,\n+\t\t\t\t\t  HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n+\t\t\t\t\t  &queue_size);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error requesting maximum queue size of the HSA agent\",\n-\t\t      status);\n-  status = hsa_agent_get_info (agent->id, HSA_AGENT_INFO_ISA, &agent->isa);\n+    \t   \t      status);\n+  status = hsa_fns.hsa_agent_get_info_fn (agent->id, HSA_AGENT_INFO_ISA,\n+\t\t\t\t\t  &agent->isa);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error querying the ISA of the agent\", status);\n-  status = hsa_queue_create (agent->id, queue_size, HSA_QUEUE_TYPE_MULTI,\n-\t\t\t     queue_callback, NULL, UINT32_MAX, UINT32_MAX,\n-\t\t\t     &agent->command_q);\n+  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n+\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n+\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n+\t\t\t\t\tUINT32_MAX,\n+\t\t\t\t\t&agent->command_q);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error creating command queue\", status);\n \n-  status = hsa_queue_create (agent->id, queue_size, HSA_QUEUE_TYPE_MULTI,\n-\t\t\t     queue_callback, NULL, UINT32_MAX, UINT32_MAX,\n-\t\t\t     &agent->kernel_dispatch_command_q);\n+  status = hsa_fns.hsa_queue_create_fn (agent->id, queue_size,\n+\t\t\t\t\tHSA_QUEUE_TYPE_MULTI,\n+\t\t\t\t\tqueue_callback, NULL, UINT32_MAX,\n+\t\t\t\t\tUINT32_MAX,\n+\t\t\t\t\t&agent->kernel_dispatch_command_q);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error creating kernel dispatch command queue\", status);\n \n   agent->kernarg_region.handle = (uint64_t) -1;\n-  status = hsa_agent_iterate_regions (agent->id, get_kernarg_memory_region,\n-\t\t\t\t      &agent->kernarg_region);\n+  status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,\n+\t\t\t\t\t\t get_kernarg_memory_region,\n+\t\t\t\t\t\t &agent->kernarg_region);\n   if (agent->kernarg_region.handle == (uint64_t) -1)\n     {\n       GOMP_PLUGIN_error (\"Could not find suitable memory region for kernel \"\n@@ -646,7 +848,7 @@ destroy_hsa_program (struct agent_info *agent)\n \n   HSA_DEBUG (\"Destroying the current HSA program.\\n\");\n \n-  status = hsa_executable_destroy (agent->executable);\n+  status = hsa_fns.hsa_executable_destroy_fn (agent->executable);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Could not destroy HSA executable\", status);\n \n@@ -661,6 +863,29 @@ destroy_hsa_program (struct agent_info *agent)\n   return true;\n }\n \n+/* Initialize KERNEL from D and other parameters.  Return true on success. */\n+\n+static bool\n+init_basic_kernel_info (struct kernel_info *kernel,\n+\t\t\tstruct hsa_kernel_description *d,\n+\t\t\tstruct agent_info *agent,\n+\t\t\tstruct module_info *module)\n+{\n+  kernel->agent = agent;\n+  kernel->module = module;\n+  kernel->name = d->name;\n+  kernel->omp_data_size = d->omp_data_size;\n+  kernel->gridified_kernel_p = d->gridified_kernel_p;\n+  kernel->dependencies_count = d->kernel_dependencies_count;\n+  kernel->dependencies = d->kernel_dependencies;\n+  if (pthread_mutex_init (&kernel->init_mutex, NULL))\n+    {\n+      GOMP_PLUGIN_error (\"Failed to initialize an HSA kernel mutex\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Part of the libgomp plugin interface.  Load BRIG module described by struct\n    brig_image_desc in TARGET_DATA and return references to kernel descriptors\n    in TARGET_TABLE.  */\n@@ -715,19 +940,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, void *target_data,\n       pair->end = (uintptr_t) (kernel + 1);\n \n       struct hsa_kernel_description *d = &image_desc->kernel_infos[i];\n-      kernel->agent = agent;\n-      kernel->module = module;\n-      kernel->name = d->name;\n-      kernel->omp_data_size = d->omp_data_size;\n-      kernel->gridified_kernel_p = d->gridified_kernel_p;\n-      kernel->dependencies_count = d->kernel_dependencies_count;\n-      kernel->dependencies = d->kernel_dependencies;\n-      if (pthread_mutex_init (&kernel->init_mutex, NULL))\n-\t{\n-\t  GOMP_PLUGIN_error (\"Failed to initialize an HSA kernel mutex\");\n-\t  return -1;\n-\t}\n-\n+      if (!init_basic_kernel_info (kernel, d, agent, module))\n+\treturn -1;\n       kernel++;\n       pair++;\n     }\n@@ -799,9 +1013,10 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n   if (agent->prog_finalized)\n     goto final;\n \n-  status = hsa_ext_program_create (HSA_MACHINE_MODEL_LARGE, HSA_PROFILE_FULL,\n-\t\t\t\t   HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n-\t\t\t\t   NULL, &prog_handle);\n+  status = hsa_fns.hsa_ext_program_create_fn\n+    (HSA_MACHINE_MODEL_LARGE, HSA_PROFILE_FULL,\n+     HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n+     NULL, &prog_handle);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not create an HSA program\", status);\n \n@@ -810,8 +1025,8 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n   struct module_info *module = agent->first_module;\n   while (module)\n     {\n-      status = hsa_ext_program_add_module (prog_handle,\n-\t\t\t\t\t   module->image_desc->brig_module);\n+      status = hsa_fns.hsa_ext_program_add_module_fn\n+\t(prog_handle, module->image_desc->brig_module);\n       if (status != HSA_STATUS_SUCCESS)\n \thsa_fatal (\"Could not add a module to the HSA program\", status);\n       module = module->next;\n@@ -837,7 +1052,8 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n \t  continue;\n \t}\n \n-      status = hsa_ext_program_add_module (prog_handle, library->image);\n+      status = hsa_fns.hsa_ext_program_add_module_fn (prog_handle,\n+\t\t\t\t\t\t      library->image);\n       if (status != HSA_STATUS_SUCCESS)\n \thsa_warn (\"Could not add a shared BRIG library the HSA program\",\n \t\t  status);\n@@ -849,23 +1065,22 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n   hsa_ext_control_directives_t control_directives;\n   memset (&control_directives, 0, sizeof (control_directives));\n   hsa_code_object_t code_object;\n-  status = hsa_ext_program_finalize (prog_handle, agent->isa,\n-\t\t\t\t     HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO,\n-\t\t\t\t     control_directives, \"\",\n-\t\t\t\t     HSA_CODE_OBJECT_TYPE_PROGRAM,\n-\t\t\t\t     &code_object);\n+  status = hsa_fns.hsa_ext_program_finalize_fn\n+    (prog_handle, agent->isa,HSA_EXT_FINALIZER_CALL_CONVENTION_AUTO,\n+     control_directives, \"\", HSA_CODE_OBJECT_TYPE_PROGRAM, &code_object);\n   if (status != HSA_STATUS_SUCCESS)\n     {\n       hsa_warn (\"Finalization of the HSA program failed\", status);\n       goto failure;\n     }\n \n   HSA_DEBUG (\"Finalization done\\n\");\n-  hsa_ext_program_destroy (prog_handle);\n+  hsa_fns.hsa_ext_program_destroy_fn (prog_handle);\n \n   status\n-    = hsa_executable_create (HSA_PROFILE_FULL, HSA_EXECUTABLE_STATE_UNFROZEN,\n-\t\t\t     \"\", &agent->executable);\n+    = hsa_fns.hsa_executable_create_fn (HSA_PROFILE_FULL,\n+\t\t\t\t\tHSA_EXECUTABLE_STATE_UNFROZEN,\n+\t\t\t\t\t\"\", &agent->executable);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not create HSA executable\", status);\n \n@@ -877,9 +1092,8 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n \t{\n \t  struct global_var_info *var;\n \t  var = &module->image_desc->global_variables[i];\n-\t  status\n-\t    = hsa_executable_global_variable_define (agent->executable,\n-\t\t\t\t\t\t     var->name, var->address);\n+\t  status = hsa_fns.hsa_executable_global_variable_define_fn\n+\t    (agent->executable, var->name, var->address);\n \n \t  HSA_DEBUG (\"Defining global variable: %s, address: %p\\n\", var->name,\n \t\t     var->address);\n@@ -892,11 +1106,12 @@ create_and_finalize_hsa_program (struct agent_info *agent)\n       module = module->next;\n     }\n \n-  status = hsa_executable_load_code_object (agent->executable, agent->id,\n-\t\t\t\t\t    code_object, \"\");\n+  status = hsa_fns.hsa_executable_load_code_object_fn (agent->executable,\n+\t\t\t\t\t\t       agent->id,\n+\t\t\t\t\t\t       code_object, \"\");\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not add a code object to the HSA executable\", status);\n-  status = hsa_executable_freeze (agent->executable, \"\");\n+  status = hsa_fns.hsa_executable_freeze_fn (agent->executable, \"\");\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not freeze the HSA executable\", status);\n \n@@ -937,7 +1152,7 @@ create_single_kernel_dispatch (struct kernel_info *kernel,\n   shadow->object = kernel->object;\n \n   hsa_signal_t sync_signal;\n-  hsa_status_t status = hsa_signal_create (1, 0, NULL, &sync_signal);\n+  hsa_status_t status = hsa_fns.hsa_signal_create_fn (1, 0, NULL, &sync_signal);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Error creating the HSA sync signal\", status);\n \n@@ -946,8 +1161,9 @@ create_single_kernel_dispatch (struct kernel_info *kernel,\n   shadow->group_segment_size = kernel->group_segment_size;\n \n   status\n-    = hsa_memory_allocate (agent->kernarg_region, kernel->kernarg_segment_size,\n-\t\t\t   &shadow->kernarg_address);\n+    = hsa_fns.hsa_memory_allocate_fn (agent->kernarg_region,\n+\t\t\t\t      kernel->kernarg_segment_size,\n+\t\t\t\t      &shadow->kernarg_address);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not allocate memory for HSA kernel arguments\", status);\n \n@@ -962,11 +1178,11 @@ release_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)\n   HSA_DEBUG (\"Released kernel dispatch: %p has value: %lu (%p)\\n\", shadow,\n \t     shadow->debug, (void *) shadow->debug);\n \n-  hsa_memory_free (shadow->kernarg_address);\n+  hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);\n \n   hsa_signal_t s;\n   s.handle = shadow->signal;\n-  hsa_signal_destroy (s);\n+  hsa_fns.hsa_signal_destroy_fn (s);\n \n   free (shadow->omp_data_memory);\n \n@@ -986,31 +1202,30 @@ init_single_kernel (struct kernel_info *kernel, unsigned *max_omp_data_size)\n   hsa_status_t status;\n   struct agent_info *agent = kernel->agent;\n   hsa_executable_symbol_t kernel_symbol;\n-  status = hsa_executable_get_symbol (agent->executable, NULL, kernel->name,\n-\t\t\t\t      agent->id, 0, &kernel_symbol);\n+  status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n+\t\t\t\t\t\t kernel->name, agent->id,\n+\t\t\t\t\t\t 0, &kernel_symbol);\n   if (status != HSA_STATUS_SUCCESS)\n     {\n       hsa_warn (\"Could not find symbol for kernel in the code object\", status);\n       goto failure;\n     }\n   HSA_DEBUG (\"Located kernel %s\\n\", kernel->name);\n-  status\n-    = hsa_executable_symbol_get_info (kernel_symbol,\n-\t\t\t\t      HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT,\n-\t\t\t\t      &kernel->object);\n+  status = hsa_fns.hsa_executable_symbol_get_info_fn\n+    (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernel->object);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not extract a kernel object from its symbol\", status);\n-  status = hsa_executable_symbol_get_info\n+  status = hsa_fns.hsa_executable_symbol_get_info_fn\n     (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE,\n      &kernel->kernarg_segment_size);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not get info about kernel argument size\", status);\n-  status = hsa_executable_symbol_get_info\n+  status = hsa_fns.hsa_executable_symbol_get_info_fn\n     (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE,\n      &kernel->group_segment_size);\n   if (status != HSA_STATUS_SUCCESS)\n     hsa_fatal (\"Could not get info about kernel group segment size\", status);\n-  status = hsa_executable_symbol_get_info\n+  status = hsa_fns.hsa_executable_symbol_get_info_fn\n     (kernel_symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,\n      &kernel->private_segment_size);\n   if (status != HSA_STATUS_SUCCESS)\n@@ -1209,18 +1424,43 @@ parse_target_attributes (void **input,\n   struct GOMP_kernel_launch_attributes *kla;\n   kla = (struct GOMP_kernel_launch_attributes *) *input;\n   *result = kla;\n-  if (kla->ndim != 1)\n-    GOMP_PLUGIN_fatal (\"HSA does not yet support number of dimensions \"\n-\t\t       \"different from one.\");\n-  if (kla->gdims[0] == 0)\n-    return false;\n-\n-  HSA_DEBUG (\"GOMP_OFFLOAD_run called with grid size %u and group size %u\\n\",\n-\t     kla->gdims[0], kla->wdims[0]);\n+  if (kla->ndim == 0 || kla->ndim > 3)\n+    GOMP_PLUGIN_fatal (\"Invalid number of dimensions (%u)\", kla->ndim);\n \n+  HSA_DEBUG (\"GOMP_OFFLOAD_run called with %u dimensions:\\n\", kla->ndim);\n+  unsigned i;\n+  for (i = 0; i < kla->ndim; i++)\n+    {\n+      HSA_DEBUG (\"  Dimension %u: grid size %u and group size %u\\n\", i,\n+\t\t kla->gdims[i], kla->wdims[i]);\n+      if (kla->gdims[i] == 0)\n+\treturn false;\n+    }\n   return true;\n }\n \n+/* Return the group size given the requested GROUP size, GRID size and number\n+   of grid dimensions NDIM.  */\n+\n+static uint32_t\n+get_group_size (uint32_t ndim, uint32_t grid, uint32_t group)\n+{\n+  if (group == 0)\n+    {\n+      /* TODO: Provide a default via environment or device characteristics.  */\n+      if (ndim == 1)\n+\tgroup = 64;\n+      else if (ndim == 2)\n+\tgroup = 8;\n+      else\n+\tgroup = 4;\n+    }\n+\n+  if (group > grid)\n+    group = grid;\n+  return group;\n+}\n+\n /* Return true if the HSA runtime can run function FN_PTR.  */\n \n bool\n@@ -1254,22 +1494,14 @@ packet_store_release (uint32_t* packet, uint16_t header, uint16_t rest)\n   __atomic_store_n (packet, header | (rest << 16), __ATOMIC_RELEASE);\n }\n \n-/* Part of the libgomp plugin interface.  Run a kernel on device N and pass it\n-   an array of pointers in VARS as a parameter.  The kernel is identified by\n-   FN_PTR which must point to a kernel_info structure.  */\n+/* Run KERNEL on its agent, pass VARS to it as arguments and take\n+   launchattributes from KLA.  */\n \n void\n-GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n+run_kernel (struct kernel_info *kernel, void *vars,\n+\t    struct GOMP_kernel_launch_attributes *kla)\n {\n-  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n   struct agent_info *agent = kernel->agent;\n-  struct GOMP_kernel_launch_attributes def;\n-  struct GOMP_kernel_launch_attributes *kla;\n-  if (!parse_target_attributes (args, &def, &kla))\n-    {\n-      HSA_DEBUG (\"Will not run HSA kernel because the grid size is zero\\n\");\n-      return;\n-    }\n   if (pthread_rwlock_rdlock (&agent->modules_rwlock))\n     GOMP_PLUGIN_fatal (\"Unable to read-lock an HSA agent rwlock\");\n \n@@ -1288,11 +1520,12 @@ GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n       print_kernel_dispatch (shadow, 2);\n     }\n \n-  uint64_t index = hsa_queue_add_write_index_release (agent->command_q, 1);\n+  uint64_t index\n+    = hsa_fns.hsa_queue_add_write_index_release_fn (agent->command_q, 1);\n   HSA_DEBUG (\"Got AQL index %llu\\n\", (long long int) index);\n \n   /* Wait until the queue is not full before writing the packet.   */\n-  while (index - hsa_queue_load_read_index_acquire (agent->command_q)\n+  while (index - hsa_fns.hsa_queue_load_read_index_acquire_fn (agent->command_q)\n \t >= agent->command_q->size)\n     ;\n \n@@ -1302,25 +1535,41 @@ GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n \n   memset (((uint8_t *) packet) + 4, 0, sizeof (*packet) - 4);\n   packet->grid_size_x = kla->gdims[0];\n-  uint32_t wgs = kla->wdims[0];\n-  if (wgs == 0)\n-    /* TODO: Provide a default via environment.  */\n-    wgs = 64;\n-  else if (wgs > kla->gdims[0])\n-    wgs = kla->gdims[0];\n-  packet->workgroup_size_x = wgs;\n-  packet->grid_size_y = 1;\n-  packet->workgroup_size_y = 1;\n-  packet->grid_size_z = 1;\n-  packet->workgroup_size_z = 1;\n+  packet->workgroup_size_x = get_group_size (kla->ndim, kla->gdims[0],\n+\t\t\t\t\t     kla->wdims[0]);\n+\n+  if (kla->ndim >= 2)\n+    {\n+      packet->grid_size_y = kla->gdims[1];\n+      packet->workgroup_size_y = get_group_size (kla->ndim, kla->gdims[1],\n+\t\t\t\t\t\t kla->wdims[1]);\n+    }\n+  else\n+    {\n+      packet->grid_size_y = 1;\n+      packet->workgroup_size_y = 1;\n+    }\n+\n+  if (kla->ndim == 3)\n+    {\n+      packet->grid_size_z = kla->gdims[2];\n+      packet->workgroup_size_z = get_group_size (kla->ndim, kla->gdims[2],\n+\t\t\t\t\t     kla->wdims[2]);\n+    }\n+  else\n+    {\n+      packet->grid_size_z = 1;\n+      packet->workgroup_size_z = 1;\n+    }\n+\n   packet->private_segment_size = kernel->private_segment_size;\n   packet->group_segment_size = kernel->group_segment_size;\n   packet->kernel_object = kernel->object;\n   packet->kernarg_address = shadow->kernarg_address;\n   hsa_signal_t s;\n   s.handle = shadow->signal;\n   packet->completion_signal = s;\n-  hsa_signal_store_relaxed (s, 1);\n+  hsa_fns.hsa_signal_store_relaxed_fn (s, 1);\n   memcpy (shadow->kernarg_address, &vars, sizeof (vars));\n \n   /* PR hsa/70337.  */\n@@ -1344,9 +1593,10 @@ GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n   HSA_DEBUG (\"Going to dispatch kernel %s\\n\", kernel->name);\n \n   packet_store_release ((uint32_t *) packet, header,\n-\t\t\t1 << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS);\n+\t\t\t(uint16_t) kla->ndim << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS);\n \n-  hsa_signal_store_release (agent->command_q->doorbell_signal, index);\n+  hsa_fns.hsa_signal_store_release_fn (agent->command_q->doorbell_signal,\n+\t\t\t\t       index);\n \n   /* TODO: GPU agents in Carrizo APUs cannot properly update L2 cache for\n      signal wait and signal load operations on their own and we need to\n@@ -1357,16 +1607,17 @@ GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n   HSA_DEBUG (\"Kernel dispatched, waiting for completion\\n\");\n \n   /* Root signal waits with 1ms timeout.  */\n-  while (hsa_signal_wait_acquire (s, HSA_SIGNAL_CONDITION_LT, 1, 1000 * 1000,\n-\t\t\t\t  HSA_WAIT_STATE_BLOCKED) != 0)\n+  while (hsa_fns.hsa_signal_wait_acquire_fn (s, HSA_SIGNAL_CONDITION_LT, 1,\n+\t\t\t\t\t     1000 * 1000,\n+\t\t\t\t\t     HSA_WAIT_STATE_BLOCKED) != 0)\n     for (unsigned i = 0; i < shadow->kernel_dispatch_count; i++)\n       {\n \thsa_signal_t child_s;\n \tchild_s.handle = shadow->children_dispatches[i]->signal;\n \n \tHSA_DEBUG (\"Waiting for children completion signal: %lu\\n\",\n \t\t   shadow->children_dispatches[i]->signal);\n-\thsa_signal_load_acquire (child_s);\n+\thsa_fns.hsa_signal_load_acquire_fn (child_s);\n       }\n \n   release_kernel_dispatch (shadow);\n@@ -1375,6 +1626,26 @@ GOMP_OFFLOAD_run (int n, void *fn_ptr, void *vars, void **args)\n     GOMP_PLUGIN_fatal (\"Unable to unlock an HSA agent rwlock\");\n }\n \n+/* Part of the libgomp plugin interface.  Run a kernel on device N (the number\n+   is actually ignored, we assume the FN_PTR has been mapped using the correct\n+   device) and pass it an array of pointers in VARS as a parameter.  The kernel\n+   is identified by FN_PTR which must point to a kernel_info structure.  */\n+\n+void\n+GOMP_OFFLOAD_run (int n __attribute__((unused)),\n+\t\t  void *fn_ptr, void *vars, void **args)\n+{\n+  struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n+  struct GOMP_kernel_launch_attributes def;\n+  struct GOMP_kernel_launch_attributes *kla;\n+  if (!parse_target_attributes (args, &def, &kla))\n+    {\n+      HSA_DEBUG (\"Will not run HSA kernel because the grid size is zero\\n\");\n+      return;\n+    }\n+  run_kernel (kernel, vars, kla);\n+}\n+\n /* Information to be passed to a thread running a kernel asycnronously.  */\n \n struct async_run_info\n@@ -1534,10 +1805,10 @@ GOMP_OFFLOAD_fini_device (int n)\n \n   release_agent_shared_libraries (agent);\n \n-  hsa_status_t status = hsa_queue_destroy (agent->command_q);\n+  hsa_status_t status = hsa_fns.hsa_queue_destroy_fn (agent->command_q);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error destroying command queue\", status);\n-  status = hsa_queue_destroy (agent->kernel_dispatch_command_q);\n+  status = hsa_fns.hsa_queue_destroy_fn (agent->kernel_dispatch_command_q);\n   if (status != HSA_STATUS_SUCCESS)\n     return hsa_error (\"Error destroying kernel dispatch command queue\", status);\n   if (pthread_mutex_destroy (&agent->prog_mutex))"}, {"sha": "5a73d30c6e5ff678e680f395143cde2f3f54825c", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,9 +1,9 @@\n-# Makefile.in generated by automake 1.11.6 from Makefile.am.\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n-# Foundation, Inc.\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -15,23 +15,6 @@\n \n @SET_MAKE@\n VPATH = @srcdir@\n-am__make_dryrun = \\\n-  { \\\n-    am__dry=no; \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n-      *) \\\n-        for am__flg in $$MAKEFLAGS; do \\\n-          case $$am__flg in \\\n-            *=*|--*) ;; \\\n-            *n*) am__dry=yes; break;; \\\n-          esac; \\\n-        done;; \\\n-    esac; \\\n-    test $$am__dry = yes; \\\n-  }\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n pkglibdir = $(libdir)/@PACKAGE@\n@@ -76,11 +59,6 @@ CONFIG_HEADER = $(top_builddir)/config.h\n CONFIG_CLEAN_FILES = libgomp-test-support.pt.exp\n CONFIG_CLEAN_VPATH_FILES =\n SOURCES =\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n DEJATOOL = $(PACKAGE)\n RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir\n ACLOCAL = @ACLOCAL@\n@@ -111,7 +89,6 @@ FC = @FC@\n FCFLAGS = @FCFLAGS@\n FGREP = @FGREP@\n GREP = @GREP@\n-HSA_KMT_LIB = @HSA_KMT_LIB@\n HSA_RUNTIME_INCLUDE = @HSA_RUNTIME_INCLUDE@\n HSA_RUNTIME_LIB = @HSA_RUNTIME_LIB@\n INSTALL = @INSTALL@\n@@ -303,7 +280,7 @@ CTAGS:\n \n \n check-DEJAGNU: site.exp\n-\tsrcdir='$(srcdir)'; export srcdir; \\\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n \tEXPECT=$(EXPECT); export EXPECT; \\\n \truntest=$(RUNTEST); \\\n \tif $(SHELL) -c \"$$runtest --version\" > /dev/null 2>&1; then \\\n@@ -314,29 +291,22 @@ check-DEJAGNU: site.exp\n \telse echo \"WARNING: could not find \\`runtest'\" 1>&2; :;\\\n \tfi; \\\n \texit $$exit_status\n-site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)\n+site.exp: Makefile\n \t@echo 'Making a new site.exp file...'\n \t@echo '## these variables are automatically generated by make ##' >site.tmp\n \t@echo '# Do not edit here.  If you wish to override these values' >>site.tmp\n \t@echo '# edit the last section' >>site.tmp\n-\t@echo 'set srcdir \"$(srcdir)\"' >>site.tmp\n+\t@echo 'set srcdir $(srcdir)' >>site.tmp\n \t@echo \"set objdir `pwd`\" >>site.tmp\n \t@echo 'set build_alias \"$(build_alias)\"' >>site.tmp\n \t@echo 'set build_triplet $(build_triplet)' >>site.tmp\n \t@echo 'set host_alias \"$(host_alias)\"' >>site.tmp\n \t@echo 'set host_triplet $(host_triplet)' >>site.tmp\n \t@echo 'set target_alias \"$(target_alias)\"' >>site.tmp\n \t@echo 'set target_triplet $(target_triplet)' >>site.tmp\n-\t@list='$(EXTRA_DEJAGNU_SITE_CONFIG)'; for f in $$list; do \\\n-\t  echo \"## Begin content included from file $$f.  Do not modify. ##\" \\\n-\t   && cat `test -f \"$$f\" || echo '$(srcdir)/'`$$f \\\n-\t   && echo \"## End content included from file $$f. ##\" \\\n-\t   || exit 1; \\\n-\t done >> site.tmp\n-\t@echo \"## End of auto-generated content; you can edit from here. ##\" >> site.tmp\n-\t@if test -f site.exp; then \\\n-\t   sed -e '1,/^## End of auto-generated content.*##/d' site.exp >> site.tmp; \\\n-\t fi\n+\t@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp\n+\t@test ! -f site.exp || \\\n+\t  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp\n \t@-rm -f site.bak\n \t@test ! -f site.exp || mv site.exp site.bak\n \t@mv site.tmp site.exp\n@@ -361,15 +331,10 @@ install-am: all-am\n \n installcheck: installcheck-am\n install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n mostlyclean-generic:\n \n clean-generic:"}, {"sha": "50ec8a7fa95cb23c29e7007222edad98d8b7949b", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -205,13 +205,9 @@ proc libgomp_init { args } {\n \t    append always_ld_library_path \":$cuda_driver_lib\"\n \t}\n \tglobal hsa_runtime_lib\n-\tglobal hsa_kmt_lib\n \tif { $hsa_runtime_lib != \"\" } {\n \t    append always_ld_library_path \":$hsa_runtime_lib\"\n \t}\n-\tif { $hsa_kmt_lib != \"\" } {\n-\t    append always_ld_library_path \":$hsa_kmt_lib\"\n-\t}\n     }\n \n     # We use atomic operations in the testcases to validate results."}, {"sha": "a5250a802c48edab56525a85a1996e48117ec952", "filename": "libgomp/testsuite/libgomp-test-support.exp.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d89b03db5f212919e4571671ebb4f5f8b1e19d/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in?ref=b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "patch": "@@ -1,6 +1,5 @@\n set cuda_driver_include \"@CUDA_DRIVER_INCLUDE@\"\n set cuda_driver_lib \"@CUDA_DRIVER_LIB@\"\n set hsa_runtime_lib \"@HSA_RUNTIME_LIB@\"\n-set hsa_kmt_lib \"@HSA_KMT_LIB@\"\n \n set offload_targets \"@offload_targets@\""}]}