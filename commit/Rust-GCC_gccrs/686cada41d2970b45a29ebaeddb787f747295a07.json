{"sha": "686cada41d2970b45a29ebaeddb787f747295a07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2Y2FkYTQxZDI5NzBiNDVhMjllYmFlZGRiNzg3Zjc0NzI5NWEwNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-07-19T20:02:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-07-19T20:02:44Z"}, "message": "Add MCF5200 support\n\nFrom-SVN: r12534", "tree": {"sha": "1d5d287532007500aaa0c54753fca3919c2ce593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5d287532007500aaa0c54753fca3919c2ce593"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/686cada41d2970b45a29ebaeddb787f747295a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686cada41d2970b45a29ebaeddb787f747295a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686cada41d2970b45a29ebaeddb787f747295a07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686cada41d2970b45a29ebaeddb787f747295a07/comments", "author": null, "committer": null, "parents": [{"sha": "a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9"}], "stats": {"total": 923, "additions": 895, "deletions": 28}, "files": [{"sha": "c290b56bce0c9e96bf9c0ac2bb638e7fa09132da", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 895, "deletions": 28, "changes": 923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686cada41d2970b45a29ebaeddb787f747295a07/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686cada41d2970b45a29ebaeddb787f747295a07/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=686cada41d2970b45a29ebaeddb787f747295a07", "patch": "@@ -244,12 +244,22 @@ FPTRAP = 15\n $_exception_handler:\n \tlea\tSYM (_fpCCR),a0\n \tmovew\td7,a0@(EBITS)\t| set __exception_bits\n+#ifndef __mcf5200__\n \torw\td7,a0@(STICK)\t| and __sticky_bits\n+#else\n+\tmovew\ta0@(STICK),d4\n+\torl\td7,d4\n+\tmovew\td4,a0@(STICK)\n+#endif\n \tmovew\td6,a0@(FORMT)\t| and __format\n \tmovew\td5,a0@(LASTO)\t| and __last_operation\n \n | Now put the operands in place:\n+#ifndef __mcf5200__\n \tcmpw\tIMM (SINGLE_FLOAT),d6\n+#else\n+\tcmpl\tIMM (SINGLE_FLOAT),d6\n+#endif\n \tbeq\t1f\n \tmovel\ta6@(8),a0@(OPER1)\n \tmovel\ta6@(12),a0@(OPER1+4)\n@@ -260,7 +270,13 @@ $_exception_handler:\n \tmovel\ta6@(12),a0@(OPER2)\n 2:\n | And check whether the exception is trap-enabled:\n+#ifndef __mcf5200__\n \tandw\ta0@(TRAPE),d7\t| is exception trap-enabled?\n+#else\n+\tclrl\td6\n+\tmovew\ta0@(TRAPE),d6\n+\tandl\td6,d7\n+#endif\n \tbeq\t1f\t\t| no, exit\n \tpea\tSYM (_fpCCR)\t| yes, push address of _fpCCR\n \ttrap\tIMM (FPTRAP)\t| and trap\n@@ -278,7 +294,11 @@ SYM (__mulsi3):\n \tmuluw\tsp@(10), d0\t/* x0*y1 */\n \tmovew\tsp@(6), d1\t/* x1 -> d1 */\n \tmuluw\tsp@(8), d1\t/* x1*y0 */\n+#ifndef __mcf5200__\n \taddw\td1, d0\n+#else\n+\taddl\td1, d0\n+#endif\n \tswap\td0\n \tclrw\td0\n \tmovew\tsp@(6), d1\t/* x1 -> d1 */\n@@ -293,6 +313,7 @@ SYM (__mulsi3):\n \t.proc\n \t.globl\tSYM (__udivsi3)\n SYM (__udivsi3):\n+#ifndef __mcf5200__\n \tmovel\td2, sp@-\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tmovel\tsp@(8), d0\t/* d0 = dividend */\n@@ -336,6 +357,31 @@ L5:\tsubql\tIMM (1), d0\t/* adjust quotient */\n \n L6:\tmovel\tsp@+, d2\n \trts\n+\n+#else /* __mcf5200__ */\n+\n+/* Coldfire implementation of non-restoring division algorithm from\n+   Hennessy & Patterson, Appendix A. */\n+\tlink\ta6,IMM (0)\n+\tmoveml\td2-d4,sp@-\n+\tmovel\ta6@(8),d0\n+\tmovel\ta6@(12),d1\n+\tclrl\td2\t\t| clear p\n+\tmoveq\tIMM (31),d4\n+L1:\taddl\td0,d0\t\t| shift reg pair (p,a) one bit left\n+\taddxl\td2,d2\n+\tmovl\td2,d3\t\t| subtract b from p, store in tmp.\n+\tsubl\td1,d3\n+\tjmi\tL2\t\t| if the result is not is negative, set the\n+\tbset\t#0,d0\t\t| low order bit of a to 1 and store tmp in p.\n+\tmovl\td3,d2\n+L2:\tsubql\tIMM (1),d4\n+\tjcc\tL1\n+\tmoveml\tsp@+,d2-d4\t| restore data registers\n+\tunlk\ta6\t\t| and return\n+\trts\n+#endif /* __mcf5200__ */\n+\n #endif /* L_udivsi3 */\n \n #ifdef  L_divsi3\n@@ -345,15 +391,23 @@ L6:\tmovel\tsp@+, d2\n SYM (__divsi3):\n \tmovel\td2, sp@-\n \n-\tmoveb\tIMM (1), d2\t/* sign of result stored in d2 (=1 or =-1) */\n+\tmoveq\tIMM (1), d2\t/* sign of result stored in d2 (=1 or =-1) */\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tjpl\tL1\n \tnegl\td1\n+#ifndef __mcf5200__\n \tnegb\td2\t\t/* change sign because divisor <0  */\n+#else\n+\tnegl\td2\t\t/* change sign because divisor <0  */\n+#endif\n L1:\tmovel\tsp@(8), d0\t/* d0 = dividend */\n \tjpl\tL2\n \tnegl\td0\n+#ifndef __mcf5200__\n \tnegb\td2\n+#else\n+\tnegl\td2\n+#endif\n \n L2:\tmovel\td1, sp@-\n \tmovel\td0, sp@-\n@@ -467,7 +521,7 @@ Ld$den:\n | Return and signal a denormalized number\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n-\tmovew\tIMM (DOUBLE_FLOAT),d6\n+\tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$infty:\n@@ -477,23 +531,23 @@ Ld$overflow:\n \tmovel\tIMM (0),d1\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+OVERFLOW),d7\n-\tmovew\tIMM (DOUBLE_FLOAT),d6\n+\tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$underflow:\n | Return 0 and set the exception flags \n \tmovel\tIMM (0),d0\n \tmovel\td0,d1\n \tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n-\tmovew\tIMM (DOUBLE_FLOAT),d6\n+\tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$inop:\n | Return a quiet NaN and set the exception flags\n \tmovel\tIMM (QUIET_NaN),d0\n \tmovel\td0,d1\n \tmovew\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n-\tmovew\tIMM (DOUBLE_FLOAT),d6\n+\tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$div$0:\n@@ -502,7 +556,7 @@ Ld$div$0:\n \tmovel\tIMM (0),d1\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7\n-\tmovew\tIMM (DOUBLE_FLOAT),d6\n+\tmoveq\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n |=============================================================================\n@@ -558,10 +612,15 @@ SYM (__adddf3):\n \n \tandl\tIMM (0x80000000),d7 | isolate a's sign bit '\n         swap\td6\t\t| and also b's sign bit '\n+#ifndef __mcf5200__\n \tandw\tIMM (0x8000),d6\t|\n \torw\td6,d7\t\t| and combine them into d7, so that a's sign '\n \t\t\t\t| bit is in the high word and b's is in the '\n \t\t\t\t| low word, so d6 is free to be used\n+#else\n+\tandl\tIMM (0x8000),d6\n+\torl\td6,d7\n+#endif\n \tmovel\td7,a0\t\t| now save d7 into a0, so d7 is free to\n                 \t\t| be used also\n \n@@ -580,7 +639,11 @@ SYM (__adddf3):\n \torl\td7,d0\t\t| and put hidden bit back\n Ladddf$1:\n \tswap\td4\t\t| shift right exponent so that it starts\n+#ifndef __mcf5200__\n \tlsrw\tIMM (5),d4\t| in bit 0 and not bit 20\n+#else\n+\tlsrl\tIMM (5),d4\t| in bit 0 and not bit 20\n+#endif\n | Now we have a's exponent in d4 and fraction in d0-d1 '\n \tmovel\td2,d5\t\t| save b to get exponent\n \tandl\td6,d5\t\t| get exponent in d5\n@@ -592,7 +655,11 @@ Ladddf$1:\n \torl\td7,d2\t\t| and put hidden bit back\n Ladddf$2:\n \tswap\td5\t\t| shift right exponent so that it starts\n+#ifndef __mcf5200__\n \tlsrw\tIMM (5),d5\t| in bit 0 and not bit 20\n+#else\n+\tlsrl\tIMM (5),d5\t| in bit 0 and not bit 20\n+#endif\n \n | Now we have b's exponent in d5 and fraction in d2-d3. '\n \n@@ -603,7 +670,11 @@ Ladddf$2:\n | and d4-d5-d6-d7 for the second. To do this we store (temporarily) the\n | exponents in a2-a3.\n \n+#ifndef __mcf5200__\n \tmoveml\ta2-a3,sp@-\t| save the address registers\n+#else\n+\tmoveml\ta2-a4,sp@-\t| save the address registers\n+#endif\n \n \tmovel\td4,a2\t\t| save the exponents\n \tmovel\td5,a3\t\t| \n@@ -617,32 +688,88 @@ Ladddf$2:\n \n | Here we shift the numbers until the exponents are the same, and put \n | the largest exponent in a2.\n+#ifndef __mcf5200__\n \texg\td4,a2\t\t| get exponents back\n \texg\td5,a3\t\t|\n \tcmpw\td4,d5\t\t| compare the exponents\n+#else\n+\tmovel\td4,a4\t\t| get exponents back\n+\tmovel\ta2,d4\n+\tmovel\ta4,a2\n+\tmovel\td5,a4\n+\tmovel\ta3,d5\n+\tmovel\ta4,a3\n+\tcmpl\td4,d5\t\t| compare the exponents\n+#endif\n \tbeq\tLadddf$3\t| if equal don't shift '\n \tbhi\t9f\t\t| branch if second exponent is higher\n \n | Here we have a's exponent larger than b's, so we have to shift b. We do \n | this by using as counter d2:\n 1:\tmovew\td4,d2\t\t| move largest exponent to d2\n+#ifndef __mcf5200__\n \tsubw\td5,d2\t\t| and subtract second exponent\n \texg\td4,a2\t\t| get back the longs we saved\n \texg\td5,a3\t\t|\n+#else\n+\tsubl\td5,d2\t\t| and subtract second exponent\n+\tmovel\td4,a4\t\t| get back the longs we saved\n+\tmovel\ta2,d4\n+\tmovel\ta4,a2\n+\tmovel\td5,a4\n+\tmovel\ta3,d5\n+\tmovel\ta4,a3\n+#endif\n | if difference is too large we don't shift (actually, we can just exit) '\n+#ifndef __mcf5200__\n \tcmpw\tIMM (DBL_MANT_DIG+2),d2\n+#else\n+\tcmpl\tIMM (DBL_MANT_DIG+2),d2\n+#endif\n \tbge\tLadddf$b$small\n+#ifndef __mcf5200__\n \tcmpw\tIMM (32),d2\t| if difference >= 32, shift by longs\n+#else\n+\tcmpl\tIMM (32),d2\t| if difference >= 32, shift by longs\n+#endif\n \tbge\t5f\n-2:\tcmpw\tIMM (16),d2\t| if difference >= 16, shift by words\t\n+2:\n+#ifndef __mcf5200__\n+\tcmpw\tIMM (16),d2\t| if difference >= 16, shift by words\t\n+#else\n+\tcmpl\tIMM (16),d2\t| if difference >= 16, shift by words\t\n+#endif\n \tbge\t6f\n \tbra\t3f\t\t| enter dbra loop\n \n-4:\tlsrl\tIMM (1),d4\n+4:\n+#ifndef __mcf5200__\n+\tlsrl\tIMM (1),d4\n \troxrl\tIMM (1),d5\n \troxrl\tIMM (1),d6\n \troxrl\tIMM (1),d7\n-3:\tdbra\td2,4b\n+#else\n+\tlsrl\tIMM (1),d7\n+\tbtst\tIMM (0),d6\n+\tbeq\t10f\n+\tbset\tIMM (31),d7\n+10:\tlsrl\tIMM (1),d6\n+\tbtst\tIMM (0),d5\n+\tbeq\t11f\n+\tbset\tIMM (31),d6\n+11:\tlsrl\tIMM (1),d5\n+\tbtst\tIMM (0),d4\n+\tbeq\t12f\n+\tbset\tIMM (31),d5\n+12:\tlsrl\tIMM (1),d4\n+#endif\n+3:\n+#ifndef __mcf5200__\n+\tdbra\td2,4b\n+#else\n+\tsubql\tIMM (1),d2\n+\tbpl\t4b\t\n+#endif\n \tmovel\tIMM (0),d2\n \tmovel\td2,d3\t\n \tbra\tLadddf$4\n@@ -651,7 +778,11 @@ Ladddf$2:\n \tmovel\td5,d6\n \tmovel\td4,d5\n \tmovel\tIMM (0),d4\n+#ifndef __mcf5200__\n \tsubw\tIMM (32),d2\n+#else\n+\tsubl\tIMM (32),d2\n+#endif\n \tbra\t2b\n 6:\n \tmovew\td6,d7\n@@ -662,28 +793,82 @@ Ladddf$2:\n \tswap\td5\n \tmovew\tIMM (0),d4\n \tswap\td4\n+#ifndef __mcf5200__\n \tsubw\tIMM (16),d2\n+#else\n+\tsubl\tIMM (16),d2\n+#endif\n \tbra\t3b\n \t\n-9:\texg\td4,d5\n+9:\n+#ifndef __mcf5200__\n+\texg\td4,d5\n \tmovew\td4,d6\n \tsubw\td5,d6\t\t| keep d5 (largest exponent) in d4\n \texg\td4,a2\n \texg\td5,a3\n+#else\n+\tmovel\td5,d6\n+\tmovel\td4,d5\n+\tmovel\td6,d4\n+\tsubl\td5,d6\n+\tmovel\td4,a4\n+\tmovel\ta2,d4\n+\tmovel\ta4,a2\n+\tmovel\td5,a4\n+\tmovel\ta3,d5\n+\tmovel\ta4,a3\n+#endif\n | if difference is too large we don't shift (actually, we can just exit) '\n+#ifndef __mcf5200__\n \tcmpw\tIMM (DBL_MANT_DIG+2),d6\n+#else\n+\tcmpl\tIMM (DBL_MANT_DIG+2),d6\n+#endif\n \tbge\tLadddf$a$small\n+#ifndef __mcf5200__\n \tcmpw\tIMM (32),d6\t| if difference >= 32, shift by longs\n+#else\n+\tcmpl\tIMM (32),d6\t| if difference >= 32, shift by longs\n+#endif\n \tbge\t5f\n-2:\tcmpw\tIMM (16),d6\t| if difference >= 16, shift by words\t\n+2:\n+#ifndef __mcf5200__\n+\tcmpw\tIMM (16),d6\t| if difference >= 16, shift by words\t\n+#else\n+\tcmpl\tIMM (16),d6\t| if difference >= 16, shift by words\t\n+#endif\n \tbge\t6f\n \tbra\t3f\t\t| enter dbra loop\n \n-4:\tlsrl\tIMM (1),d0\n+4:\n+#ifndef __mcf5200__\n+\tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n \troxrl\tIMM (1),d3\n-3:\tdbra\td6,4b\n+#else\n+\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d2\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t12f\n+\tbset\tIMM (31),d1\n+12:\tlsrl\tIMM (1),d0\n+#endif\n+3:\n+#ifndef __mcf5200__\n+\tdbra\td6,4b\n+#else\n+\tsubql\tIMM (1),d6\n+\tbpl\t4b\n+#endif\n \tmovel\tIMM (0),d7\n \tmovel\td7,d6\n \tbra\tLadddf$4\n@@ -692,7 +877,11 @@ Ladddf$2:\n \tmovel\td1,d2\n \tmovel\td0,d1\n \tmovel\tIMM (0),d0\n+#ifndef __mcf5200__\n \tsubw\tIMM (32),d6\n+#else\n+\tsubl\tIMM (32),d6\n+#endif\n \tbra\t2b\n 6:\n \tmovew\td2,d3\n@@ -703,27 +892,58 @@ Ladddf$2:\n \tswap\td1\n \tmovew\tIMM (0),d0\n \tswap\td0\n+#ifndef __mcf5200__\n \tsubw\tIMM (16),d6\n+#else\n+\tsubl\tIMM (16),d6\n+#endif\n \tbra\t3b\n Ladddf$3:\n+#ifndef __mcf5200__\n \texg\td4,a2\t\n \texg\td5,a3\n+#else\n+\tmovel\td4,a4\n+\tmovel\ta2,d4\n+\tmovel\ta4,a2\n+\tmovel\td5,a4\n+\tmovel\ta3,d5\n+\tmovel\ta4,a3\n+#endif\n Ladddf$4:\t\n | Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and\n | the signs in a4.\n \n | Here we have to decide whether to add or subtract the numbers:\n+#ifndef __mcf5200__\n \texg\td7,a0\t\t| get the signs \n \texg\td6,a3\t\t| a3 is free to be used\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta0,d7\n+\tmovel\ta4,a0\n+\tmovel\td6,a4\n+\tmovel\ta3,d6\n+\tmovel\ta4,a3\n+#endif\n \tmovel\td7,d6\t\t|\n \tmovew\tIMM (0),d7\t| get a's sign in d7 '\n \tswap\td6              |\n \tmovew\tIMM (0),d6\t| and b's sign in d6 '\n \teorl\td7,d6\t\t| compare the signs\n \tbmi\tLsubdf$0\t| if the signs are different we have \n \t\t\t\t| to subtract\n+#ifndef __mcf5200__\n \texg\td7,a0\t\t| else we add the numbers\n \texg\td6,a3\t\t|\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta0,d7\n+\tmovel\ta4,a0\n+\tmovel\td6,a4\n+\tmovel\ta3,d6\n+\tmovel\ta4,a3\n+#endif\n \taddl\td7,d3\t\t|\n \taddxl\td6,d2\t\t|\n \taddxl\td5,d1\t\t| \n@@ -733,36 +953,76 @@ Ladddf$4:\n \tmovel\ta0,d7\t\t| \n \tandl\tIMM (0x80000000),d7 | d7 now has the sign\n \n+#ifndef __mcf5200__\n \tmoveml\tsp@+,a2-a3\t\n+#else\n+\tmoveml\tsp@+,a2-a4\t\n+#endif\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n \troxrl\tIMM (1),d3\n \taddw\tIMM (1),d4\n+#else\n+\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d2\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t12f\n+\tbset\tIMM (31),d1\n+12:\tlsrl\tIMM (1),d0\n+\taddl\tIMM (1),d4\n+#endif\n 1:\n \tlea\tLadddf$5,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Ladddf$5:\n | Put back the exponent and check for overflow\n+#ifndef __mcf5200__\n \tcmpw\tIMM (0x7ff),d4\t| is the exponent big?\n+#else\n+\tcmpl\tIMM (0x7ff),d4\t| is the exponent big?\n+#endif\n \tbge\t1f\n \tbclr\tIMM (DBL_MANT_DIG-1),d0\n+#ifndef __mcf5200__\n \tlslw\tIMM (4),d4\t| put exponent back into position\n+#else\n+\tlsll\tIMM (4),d4\t| put exponent back into position\n+#endif\n \tswap\td0\t\t| \n+#ifndef __mcf5200__\n \torw\td4,d0\t\t|\n+#else\n+\torl\td4,d0\t\t|\n+#endif\n \tswap\td0\t\t|\n \tbra\tLadddf$ret\n 1:\n@@ -771,17 +1031,26 @@ Ladddf$5:\n \n Lsubdf$0:\n | Here we do the subtraction.\n+#ifndef __mcf5200__\n \texg\td7,a0\t\t| put sign back in a0\n \texg\td6,a3\t\t|\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta0,d7\n+\tmovel\ta4,a0\n+\tmovel\td6,a4\n+\tmovel\ta3,d6\n+\tmovel\ta4,a3\n+#endif\n \tsubl\td7,d3\t\t|\n \tsubxl\td6,d2\t\t|\n \tsubxl\td5,d1\t\t|\n \tsubxl\td4,d0\t\t|\n \tbeq\tLadddf$ret$1\t| if zero just exit\n \tbpl\t1f\t\t| if positive skip the following\n-\texg\td7,a0\t\t|\n+\tmovel\ta0,d7\t\t|\n \tbchg\tIMM (31),d7\t| change sign bit in d7\n-\texg\td7,a0\t\t|\n+\tmovel\td7,a0\t\t|\n \tnegl\td3\t\t|\n \tnegxl\td2\t\t|\n \tnegxl\td1              | and negate result\n@@ -790,42 +1059,82 @@ Lsubdf$0:\n \tmovel\ta2,d4\t\t| return exponent to d4\n \tmovel\ta0,d7\n \tandl\tIMM (0x80000000),d7 | isolate sign bit\n+#ifndef __mcf5200__\n \tmoveml\tsp@+,a2-a3\t|\n+#else\n+\tmoveml\tsp@+,a2-a4\t|\n+#endif\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n \troxrl\tIMM (1),d3\n \taddw\tIMM (1),d4\n+#else\n+\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d2\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t12f\n+\tbset\tIMM (31),d1\n+12:\tlsrl\tIMM (1),d0\n+\taddl\tIMM (1),d4\n+#endif\n 1:\n \tlea\tLsubdf$1,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Lsubdf$1:\n | Put back the exponent and sign (we don't have overflow). '\n \tbclr\tIMM (DBL_MANT_DIG-1),d0\t\n+#ifndef __mcf5200__\n \tlslw\tIMM (4),d4\t| put exponent back into position\n+#else\n+\tlsll\tIMM (4),d4\t| put exponent back into position\n+#endif\n \tswap\td0\t\t| \n+#ifndef __mcf5200__\n \torw\td4,d0\t\t|\n+#else\n+\torl\td4,d0\t\t|\n+#endif\n \tswap\td0\t\t|\n \tbra\tLadddf$ret\n \n | If one of the numbers was too small (difference of exponents >= \n | DBL_MANT_DIG+1) we return the other (and now we don't have to '\n | check for finiteness or zero).\n Ladddf$a$small:\n+#ifndef __mcf5200__\n \tmoveml\tsp@+,a2-a3\t\n+#else\n+\tmoveml\tsp@+,a2-a4\t\n+#endif\n \tmovel\ta6@(16),d0\n \tmovel\ta6@(20),d1\n \tlea\tSYM (_fpCCR),a0\n@@ -835,7 +1144,11 @@ Ladddf$a$small:\n \trts\n \n Ladddf$b$small:\n+#ifndef __mcf5200__\n \tmoveml\tsp@+,a2-a3\t\n+#else\n+\tmoveml\tsp@+,a2-a4\t\n+#endif\n \tmovel\ta6@(8),d0\n \tmovel\ta6@(12),d1\n \tlea\tSYM (_fpCCR),a0\n@@ -893,8 +1206,16 @@ Ladddf$ret:\n \n Ladddf$ret$den:\n | Return a denormalized number.\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\t| shift right once more\n \troxrl\tIMM (1),d1\t|\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+#endif\n \tbra\tLadddf$ret\n \n Ladddf$nf:\n@@ -987,17 +1308,30 @@ SYM (__muldf3):\n \tandl\td6,d0\t\t\t| isolate fraction\n \torl\tIMM (0x00100000),d0\t| and put hidden bit back\n \tswap\td4\t\t\t| I like exponents in the first byte\n+#ifndef __mcf5200__\n \tlsrw\tIMM (4),d4\t\t| \n+#else\n+\tlsrl\tIMM (4),d4\t\t| \n+#endif\n Lmuldf$1:\t\t\t\n \tandl\td7,d5\t\t\t|\n \tbeq\tLmuldf$b$den\t\t|\n \tandl\td6,d2\t\t\t|\n \torl\tIMM (0x00100000),d2\t| and put hidden bit back\n \tswap\td5\t\t\t|\n+#ifndef __mcf5200__\n \tlsrw\tIMM (4),d5\t\t|\n+#else\n+\tlsrl\tIMM (4),d5\t\t|\n+#endif\n Lmuldf$2:\t\t\t\t|\n+#ifndef __mcf5200__\n \taddw\td5,d4\t\t\t| add exponents\n \tsubw\tIMM (D_BIAS+1),d4\t| and subtract bias (plus one)\n+#else\n+\taddl\td5,d4\t\t\t| add exponents\n+\tsubl\tIMM (D_BIAS+1),d4\t| and subtract bias (plus one)\n+#endif\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were \n@@ -1009,11 +1343,16 @@ Lmuldf$2:\t\t\t\t|\n | enough to keep everything in them. So we use the address registers to keep\n | some intermediate data.\n \n+#ifndef __mcf5200__\n \tmoveml\ta2-a3,sp@-\t| save a2 and a3 for temporary use\n+#else\n+\tmoveml\ta2-a4,sp@-\n+#endif\n \tmovel\tIMM (0),a2\t| a2 is a null register\n \tmovel\td4,a3\t\t| and a3 will preserve the exponent\n \n | First, shift d2-d3 so bit 20 becomes bit 31:\n+#ifndef __mcf5200__\n \trorl\tIMM (5),d2\t| rotate d2 5 places right\n \tswap\td2\t\t| and swap it\n \trorl\tIMM (5),d3\t| do the same thing with d3\n@@ -1022,6 +1361,16 @@ Lmuldf$2:\t\t\t\t|\n \tandw\tIMM (0x07ff),d6\t|\n \torw\td6,d2\t\t| and put them into d2\n \tandw\tIMM (0xf800),d3\t| clear those bits in d3\n+#else\n+\tmoveq\tIMM (11),d7\t| left shift d2 11 bits\n+\tlsll\td7,d2\n+\tmovel\td3,d6\t\t| get a copy of d3\n+\tlsll\td7,d3\t\t| left shift d3 11 bits\n+\tandl\tIMM (0xffe00000),d6 | get the top 11 bits of d3\n+\tmoveq\tIMM (21),d7\t| right shift them 21 bits\n+\tlsrl\td7,d6\n+\torl\td6,d2\t\t| stick them at the end of d2\n+#endif\n \n \tmovel\td2,d6\t\t| move b into d6-d7\n \tmovel\td3,d7           | move a into d4-d5\n@@ -1034,27 +1383,65 @@ Lmuldf$2:\t\t\t\t|\n \n | We use a1 as counter:\t\n \tmovel\tIMM (DBL_MANT_DIG-1),a1\t\t\n+#ifndef __mcf5200__\n \texg\td7,a1\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta1,d7\n+\tmovel\ta4,a1\n+#endif\n \n-1:\texg\td7,a1\t\t| put counter back in a1\n+1:\n+#ifndef __mcf5200__\n+\texg\td7,a1\t\t| put counter back in a1\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta1,d7\n+\tmovel\ta4,a1\n+#endif\n \taddl\td3,d3\t\t| shift sum once left\n \taddxl\td2,d2           |\n \taddxl\td1,d1           |\n \taddxl\td0,d0           |\n \taddl\td7,d7\t\t|\n \taddxl\td6,d6\t\t|\n \tbcc\t2f\t\t| if bit clear skip the following\n+#ifndef __mcf5200__\n \texg\td7,a2\t\t|\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta2,d7\n+\tmovel\ta4,a2\n+#endif\n \taddl\td5,d3\t\t| else add a to the sum\n \taddxl\td4,d2\t\t|\n \taddxl\td7,d1\t\t|\n \taddxl\td7,d0\t\t|\n+#ifndef __mcf5200__\n \texg\td7,a2\t\t| \n-2:\texg\td7,a1\t\t| put counter in d7\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta2,d7\n+\tmovel\ta4,a2\n+#endif\n+2:\n+#ifndef __mcf5200__\n+\texg\td7,a1\t\t| put counter in d7\n \tdbf\td7,1b\t\t| decrement and branch\n+#else\n+\tmovel\td7,a4\n+\tmovel\ta1,d7\n+\tmovel\ta4,a1\n+\tsubql\tIMM (1),d7\n+\tbpl\t1b\n+#endif\n \n \tmovel\ta3,d4\t\t| restore exponent\n+#ifndef __mcf5200__\n \tmoveml\tsp@+,a2-a3\n+#else\n+\tmoveml\tsp@+,a2-a4\n+#endif\n \n | Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The \n | first thing to do now is to normalize it so bit 8 becomes bit \n@@ -1067,6 +1454,7 @@ Lmuldf$2:\t\t\t\t|\n \tswap\td3\n \tmovew\td3,d2\n \tmovew\tIMM (0),d3\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -1079,16 +1467,41 @@ Lmuldf$2:\t\t\t\t|\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n \troxrl\tIMM (1),d3\n+#else\n+\tmoveq\tIMM (29),d6\n+\tlsrl\tIMM (3),d3\n+\tmovel\td2,d7\n+\tlsll\td6,d7\n+\torl\td7,d3\n+\tlsrl\tIMM (3),d2\n+\tmovel\td1,d7\n+\tlsll\td6,d7\n+\torl\td7,d2\n+\tlsrl\tIMM (3),d1\n+\tmovel\td0,d7\n+\tlsll\td6,d7\n+\torl\td7,d1\n+\tlsrl\tIMM (3),d0\n+#endif\n \t\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n \tmovew\tIMM (MULTIPLY),d5\n \n \tbtst\tIMM (DBL_MANT_DIG+1-32),d0\n \tbeq\tLround$exit\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d4\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+\taddl\tIMM (1),d4\n+#endif\n \tbra\tLround$exit\n \n Lmuldf$inop:\n@@ -1113,8 +1526,17 @@ Lmuldf$a$nf:\n | NaN, in which case we return NaN.\n Lmuldf$b$0:\n \tmovew\tIMM (MULTIPLY),d5\n+#ifndef __mcf5200__\n \texg\td2,d0\t\t| put b (==0) into d0-d1\n \texg\td3,d1\t\t| and a (with sign bit cleared) into d2-d3\n+#else\n+\tmovel\td2,d7\n+\tmovel\td0,d2\n+\tmovel\td7,d0\n+\tmovel\td3,d7\n+\tmovel\td1,d3\n+\tmovel\td7,d1\n+#endif\n \tbra\t1f\n Lmuldf$a$0:\n \tmovel\ta6@(16),d2\t| put b into d2-d3 again\n@@ -1137,7 +1559,11 @@ Lmuldf$a$den:\n \tandl\td6,d0\n 1:\taddl\td1,d1           | shift a left until bit 20 is set\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d4\t| and adjust exponent\n+#else\n+\tsubl\tIMM (1),d4\t| and adjust exponent\n+#endif\n \tbtst\tIMM (20),d0\t|\n \tbne\tLmuldf$1        |\n \tbra\t1b\n@@ -1147,7 +1573,11 @@ Lmuldf$b$den:\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\t\t|\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d5\t| and adjust exponent\n+#else\n+\tsubql\tIMM (1),d5\t| and adjust exponent\n+#endif\n \tbtst\tIMM (20),d2\t|\n \tbne\tLmuldf$2\t|\n \tbra\t1b\n@@ -1199,17 +1629,30 @@ SYM (__divdf3):\n \tandl\td6,d0\t\t| and isolate fraction\n \torl\tIMM (0x00100000),d0 | and put hidden bit back\n \tswap\td4\t\t| I like exponents in the first byte\n+#ifndef __mcf5200__\n \tlsrw\tIMM (4),d4\t| \n+#else\n+\tlsrl\tIMM (4),d4\t| \n+#endif\n Ldivdf$1:\t\t\t| \n \tandl\td7,d5\t\t|\n \tbeq\tLdivdf$b$den\t|\n \tandl\td6,d2\t\t|\n \torl\tIMM (0x00100000),d2\n \tswap\td5\t\t|\n+#ifndef __mcf5200__\n \tlsrw\tIMM (4),d5\t|\n+#else\n+\tlsrl\tIMM (4),d5\t|\n+#endif\n Ldivdf$2:\t\t\t|\n+#ifndef __mcf5200__\n \tsubw\td5,d4\t\t| subtract exponents\n \taddw\tIMM (D_BIAS),d4\t| and add bias\n+#else\n+\tsubl\td5,d4\t\t| subtract exponents\n+\taddl\tIMM (D_BIAS),d4\t| and add bias\n+#endif\n \n | We are now ready to do the division. We have prepared things in such a way\n | that the ratio of the fractions will be less than 2 but greater than 1/2.\n@@ -1240,7 +1683,12 @@ Ldivdf$2:\t\t\t|\n \tbset\td5,d6\t\t| set the corresponding bit in d6\n 3:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tdbra\td5,1b\t\t| and branch back\n+#else\n+\tsubql\tIMM (1), d5\n+\tbpl\t1b\n+#endif\n \tbra\t5f\t\t\t\n 4:\tcmpl\td1,d3\t\t| here d0==d2, so check d1 and d3\n \tbhi\t3b\t\t| if d1 > d2 skip the subtraction\n@@ -1257,7 +1705,12 @@ Ldivdf$2:\t\t\t|\n \tbset\td5,d7\t\t| set the corresponding bit in d7\n 3:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tdbra\td5,1b\t\t| and branch back\n+#else\n+\tsubql\tIMM (1), d5\n+\tbpl\t1b\n+#endif\n \tbra\t5f\t\t\t\n 4:\tcmpl\td1,d3\t\t| here d0==d2, so check d1 and d3\n \tbhi\t3b\t\t| if d1 > d2 skip the subtraction\n@@ -1270,7 +1723,12 @@ Ldivdf$2:\t\t\t|\n \tbeq\t3f\t\t| if d0==d2 check d1 and d3\n 2:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tdbra\td5,1b\t\t| and branch back\n+#else\n+\tsubql\tIMM (1), d5\n+\tbpl\t1b\n+#endif\n \tmovel\tIMM (0),d2\t| here no sticky bit was found\n \tmovel\td2,d3\n \tbra\t5f\t\t\t\n@@ -1281,13 +1739,23 @@ Ldivdf$2:\t\t\t|\n | to it; if you don't do this the algorithm loses in some cases). '\n \tmovel\tIMM (0),d2\n \tmovel\td2,d3\n+#ifndef __mcf5200__\n \tsubw\tIMM (DBL_MANT_DIG),d5\n \taddw\tIMM (63),d5\n \tcmpw\tIMM (31),d5\n+#else\n+\tsubl\tIMM (DBL_MANT_DIG),d5\n+\taddl\tIMM (63),d5\n+\tcmpl\tIMM (31),d5\n+#endif\n \tbhi\t2f\n 1:\tbset\td5,d3\n \tbra\t5f\n+#ifndef __mcf5200__\n \tsubw\tIMM (32),d5\n+#else\n+\tsubl\tIMM (32),d5\n+#endif\n 2:\tbset\td5,d2\n 5:\n | Finally we are finished! Move the longs in the address registers to\n@@ -1302,11 +1770,28 @@ Ldivdf$2:\t\t\t|\n | not set:\n \tbtst\tIMM (DBL_MANT_DIG-32+1),d0\n \tbeq\t1f\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n \troxrl\tIMM (1),d3\n \taddw\tIMM (1),d4\n+#else\n+\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d2\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t12f\n+\tbset\tIMM (31),d1\n+12:\tlsrl\tIMM (1),d0\n+\taddl\tIMM (1),d4\n+#endif\n 1:\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| restore sign bit to d7\n@@ -1377,7 +1862,11 @@ Ldivdf$a$den:\n \tandl\td6,d0\n 1:\taddl\td1,d1\t\t| shift a left until bit 20 is set\n \taddxl\td0,d0\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d4\t| and adjust exponent\n+#else\n+\tsubl\tIMM (1),d4\t| and adjust exponent\n+#endif\n \tbtst\tIMM (DBL_MANT_DIG-32-1),d0\n \tbne\tLdivdf$1\n \tbra\t1b\n@@ -1387,7 +1876,11 @@ Ldivdf$b$den:\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d5\t| and adjust exponent\n+#else\n+\tsubql\tIMM (1),d5\t| and adjust exponent\n+#endif\n \tbtst\tIMM (DBL_MANT_DIG-32-1),d2\n \tbne\tLdivdf$2\n \tbra\t1b\n@@ -1398,7 +1891,11 @@ Lround$exit:\n | so that 2^21 <= d0 < 2^22, and the exponent is in the lower byte of d4.\n \n | First check for underlow in the exponent:\n+#ifndef __mcf5200__\n \tcmpw\tIMM (-DBL_MANT_DIG-1),d4\t\t\n+#else\n+\tcmpl\tIMM (-DBL_MANT_DIG-1),d4\t\t\n+#endif\n \tblt\tLd$underflow\t\n | It could happen that the exponent is less than 1, in which case the \n | number is denormalized. In this case we shift right and adjust the \n@@ -1407,16 +1904,47 @@ Lround$exit:\n \tmovel\td7,a0\t\t|\n \tmovel\tIMM (0),d6\t| use d6-d7 to collect bits flushed right\n \tmovel\td6,d7\t\t| use d6-d7 to collect bits flushed right\n+#ifndef __mcf5200__\n \tcmpw\tIMM (1),d4\t| if the exponent is less than 1 we \n+#else\n+\tcmpl\tIMM (1),d4\t| if the exponent is less than 1 we \n+#endif\n \tbge\t2f\t\t| have to shift right (denormalize)\n-1:\taddw\tIMM (1),d4\t| adjust the exponent\n+1:\n+#ifndef __mcf5200__\n+\taddw\tIMM (1),d4\t| adjust the exponent\n \tlsrl\tIMM (1),d0\t| shift right once \n \troxrl\tIMM (1),d1\t|\n \troxrl\tIMM (1),d2\t|\n \troxrl\tIMM (1),d3\t|\n \troxrl\tIMM (1),d6\t| \n \troxrl\tIMM (1),d7\t|\n \tcmpw\tIMM (1),d4\t| is the exponent 1 already?\n+#else\n+\taddl\tIMM (1),d4\t| adjust the exponent\n+\tlsrl\tIMM (1),d7\n+\tbtst\tIMM (0),d6\n+\tbeq\t13f\n+\tbset\tIMM (31),d7\n+13:\tlsrl\tIMM (1),d6\n+\tbtst\tIMM (0),d3\n+\tbeq\t14f\n+\tbset\tIMM (31),d6\n+14:\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d2\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t12f\n+\tbset\tIMM (31),d1\n+12:\tlsrl\tIMM (1),d0\n+\tcmpl\tIMM (1),d4\t| is the exponent 1 already?\n+#endif\n \tbeq\t2f\t\t| if not loop back\n \tbra\t1b              |\n \tbra\tLd$underflow\t| safety check, shouldn't execute '\n@@ -1426,9 +1954,16 @@ Lround$exit:\n | Now call the rounding routine (which takes care of denormalized numbers):\n \tlea\tLround$0,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n@@ -1440,17 +1975,29 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 0x7ff).\n+#ifndef __mcf5200__\n \tcmpw\tIMM (0x07ff),d4\n+#else\n+\tcmpl\tIMM (0x07ff),d4\n+#endif\n \tbge\tLd$overflow\n | Now check for a denormalized number (exponent==0):\n \tmovew\td4,d4\n \tbeq\tLd$den\n 1:\n | Put back the exponents and sign and return.\n+#ifndef __mcf5200__\n \tlslw\tIMM (4),d4\t| exponent back to fourth byte\n+#else\n+\tlsll\tIMM (4),d4\t| exponent back to fourth byte\n+#endif\n \tbclr\tIMM (DBL_MANT_DIG-32-1),d0\n \tswap\td0\t\t| and put back exponent\n+#ifndef __mcf5200__\n \torw\td4,d0\t\t| \n+#else\n+\torl\td4,d0\t\t| \n+#endif\n \tswap\td0\t\t|\n \torl\td7,d0\t\t| and sign also\n \n@@ -1542,8 +2089,17 @@ Lcmpdf$1:\n \ttstl\td6\n \tbpl\t1f\n | If both are negative exchange them\n+#ifndef __mcf5200__\n \texg\td0,d2\n \texg\td1,d3\n+#else\n+\tmovel\td0,d7\n+\tmovel\td2,d0\n+\tmovel\td7,d2\n+\tmovel\td1,d7\n+\tmovel\td3,d1\n+\tmovel\td7,d3\n+#endif\n 1:\n | Now that they are positive we just compare them as longs (does this also\n | work for denormalized numbers?).\n@@ -1608,13 +2164,22 @@ Lround$to$nearest:\n | Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -D_BIAS+1).\n+#ifndef __mcf5200__\n \tcmpw\tIMM (1),d4\t| remember that the exponent is at least one\n+#else\n+\tcmpl\tIMM (1),d4\t| remember that the exponent is at least one\n+#endif\n  \tbeq\t2f\t\t| an exponent of one means denormalized\n \taddl\td3,d3\t\t| else shift and adjust the exponent\n \taddxl\td2,d2\t\t|\n \taddxl\td1,d1\t\t|\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tdbra\td4,1b\t\t|\n+#else\n+\tsubql\tIMM (1), d4\n+\tbpl\t1b\n+#endif\n 2:\n | Now round: we do it as follows: after the shifting we can write the\n | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.\n@@ -1636,16 +2201,34 @@ Lround$to$nearest:\n \taddl\td3,d1\t\t|\n \taddxl\td2,d0\n | Shift right once (because we used bit #DBL_MANT_DIG-32!).\n-2:\tlsrl\tIMM (1),d0\n+2:\n+#ifndef __mcf5200__\n+\tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\t\t\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+#endif\n \n | Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a\n | 'fraction overflow' ...).\n \tbtst\tIMM (DBL_MANT_DIG-32),d0\t\n \tbeq\t1f\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d4\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+\taddl\tIMM (1),d4\n+#endif\n 1:\n | If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we \n | have to put the exponent to zero and return a denormalized number.\n@@ -1717,7 +2300,7 @@ Lf$den:\n | Return and signal a denormalized number\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n-\tmovew\tIMM (SINGLE_FLOAT),d6\n+\tmoveq\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$infty:\n@@ -1726,29 +2309,29 @@ Lf$overflow:\n \tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+OVERFLOW),d7\n-\tmovew\tIMM (SINGLE_FLOAT),d6\n+\tmoveq\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$underflow:\n | Return 0 and set the exception flags \n \tmovel\tIMM (0),d0\n \tmovew\tIMM (INEXACT_RESULT+UNDERFLOW),d7\n-\tmovew\tIMM (SINGLE_FLOAT),d6\n+\tmoveq\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$inop:\n | Return a quiet NaN and set the exception flags\n \tmovel\tIMM (QUIET_NaN),d0\n \tmovew\tIMM (INEXACT_RESULT+INVALID_OPERATION),d7\n-\tmovew\tIMM (SINGLE_FLOAT),d6\n+\tmoveq\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$div$0:\n | Return a properly signed INFINITY and set the exception flags\n \tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n \tmovew\tIMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7\n-\tmovew\tIMM (SINGLE_FLOAT),d6\n+\tmoveq\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n |=============================================================================\n@@ -1840,54 +2423,126 @@ Laddsf$2:\n | same, and put the largest exponent in d6. Note that we are using two\n | registers for each number (see the discussion by D. Knuth in \"Seminumerical \n | Algorithms\").\n+#ifndef __mcf5200__\n \tcmpw\td6,d7\t\t| compare exponents\n+#else\n+\tcmpl\td6,d7\t\t| compare exponents\n+#endif\n \tbeq\tLaddsf$3\t| if equal don't shift '\n \tbhi\t5f\t\t| branch if second exponent largest\n 1:\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\n+#ifndef __mcf5200__\n \tlsrw\tIMM (8),d7\t| put difference in lower byte\n+#else\n+\tlsrl\tIMM (8),d7\t| put difference in lower byte\n+#endif\n | if difference is too large we don't shift (actually, we can just exit) '\n+#ifndef __mcf5200__\n \tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n+#else\n+\tcmpl\tIMM (FLT_MANT_DIG+2),d7\t\t\n+#endif\n \tbge\tLaddsf$b$small\n+#ifndef __mcf5200__\n \tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n+#else\n+\tcmpl\tIMM (16),d7\t| if difference >= 16 swap\n+#endif\n \tbge\t4f\n 2:\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d7\n-3:\tlsrl\tIMM (1),d2\t| shift right second operand\n+#else\n+\tsubql\tIMM (1), d7\n+#endif\n+3:\n+#ifndef __mcf5200__\n+\tlsrl\tIMM (1),d2\t| shift right second operand\n \troxrl\tIMM (1),d3\n \tdbra\td7,3b\n+#else\n+\tlsrl\tIMM (1),d3\n+\tbtst\tIMM (0),d2\n+\tbeq\t10f\n+\tbset\tIMM (31),d3\n+10:\tlsrl\tIMM (1),d2\n+\tsubql\tIMM (1), d7\n+\tbpl\t3b\n+#endif\n \tbra\tLaddsf$3\n 4:\n \tmovew\td2,d3\n \tswap\td3\n \tmovew\td3,d2\n \tswap\td2\n+#ifndef __mcf5200__\n \tsubw\tIMM (16),d7\n+#else\n+\tsubl\tIMM (16),d7\n+#endif\n \tbne\t2b\t\t| if still more bits, go back to normal case\n \tbra\tLaddsf$3\n 5:\n+#ifndef __mcf5200__\n \texg\td6,d7\t\t| exchange the exponents\n+#else\n+\teorl\td6,d7\n+\teorl\td7,d6\n+\teorl\td6,d7\n+#endif\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\t\t|\n+#ifndef __mcf5200__\n \tlsrw\tIMM (8),d7\t| put difference in lower byte\n+#else\n+\tlsrl\tIMM (8),d7\t| put difference in lower byte\n+#endif\n | if difference is too large we don't shift (and exit!) '\n+#ifndef __mcf5200__\n \tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n+#else\n+\tcmpl\tIMM (FLT_MANT_DIG+2),d7\t\t\n+#endif\n \tbge\tLaddsf$a$small\n+#ifndef __mcf5200__\n \tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n+#else\n+\tcmpl\tIMM (16),d7\t| if difference >= 16 swap\n+#endif\n \tbge\t8f\n 6:\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d7\n-7:\tlsrl\tIMM (1),d0\t| shift right first operand\n+#else\n+\tsubl\tIMM (1),d7\n+#endif\n+7:\n+#ifndef __mcf5200__\n+\tlsrl\tIMM (1),d0\t| shift right first operand\n \troxrl\tIMM (1),d1\n \tdbra\td7,7b\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+\tsubql\tIMM (1),d7\n+\tbpl\t7b\n+#endif\n \tbra\tLaddsf$3\n 8:\n \tmovew\td0,d1\n \tswap\td1\n \tmovew\td1,d0\n \tswap\td0\n+#ifndef __mcf5200__\n \tsubw\tIMM (16),d7\n+#else\n+\tsubl\tIMM (16),d7\n+#endif\n \tbne\t6b\t\t| if still more bits, go back to normal case\n \t\t\t\t| otherwise we fall through\n \n@@ -1896,15 +2551,30 @@ Laddsf$2:\n \n Laddsf$3:\n | Here we have to decide whether to add or subtract the numbers\n+#ifndef __mcf5200__\n \texg\td6,a0\t\t| get signs back\n \texg\td7,a1\t\t| and save the exponents\n+#else\n+\tmovel\td6,d4\n+\tmovel\ta0,d6\n+\tmovel\td4,d6\n+\tmovel\td7,d4\n+\tmovel\ta1,d4\n+\tmovel\td4,a1\n+#endif\n \teorl\td6,d7\t\t| combine sign bits\n \tbmi\tLsubsf$0\t| if negative a and b have opposite \n \t\t\t\t| sign so we actually subtract the\n \t\t\t\t| numbers\n \n | Here we have both positive or both negative\n+#ifndef __mcf5200__\n \texg\td6,a0\t\t| now we have the exponent in d6\n+#else\n+\tmovel\td6,d4\n+\tmovel\ta0,d6\n+\tmovel\td4,a0\n+#endif\n \tmovel\ta0,d7\t\t| and sign in d7\n \tandl\tIMM (0x80000000),d7\n | Here we do the addition.\n@@ -1915,32 +2585,59 @@ Laddsf$3:\n | Put the exponent, in the first byte, in d2, to use the \"standard\" rounding\n | routines:\n \tmovel\td6,d2\n+#ifndef __mcf5200__\n \tlsrw\tIMM (8),d2\n+#else\n+\tlsrl\tIMM (8),d2\n+#endif\n \n | Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\t\n \tbeq\t1f\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+#endif\n \taddl\tIMM (1),d2\n 1:\n \tlea\tLaddsf$4,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Laddsf$4:\n | Put back the exponent, but check for overflow.\n+#ifndef __mcf5200__\n \tcmpw\tIMM (0xff),d2\n+#else\n+\tcmpl\tIMM (0xff),d2\n+#endif\n \tbhi\t1f\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n+#ifndef __mcf5200__\n \tlslw\tIMM (7),d2\n+#else\n+\tlsll\tIMM (7),d2\n+#endif\n \tswap\td2\n \torl\td2,d0\n \tbra\tLaddsf$ret\n@@ -1962,8 +2659,15 @@ Lsubsf$0:\n \tnegl\td1\n \tnegxl\td0\n 1:\n+#ifndef __mcf5200__\n \texg\td2,a0\t\t| now we have the exponent in d2\n \tlsrw\tIMM (8),d2\t| put it in the first byte\n+#else\n+\tmovel\td2,d4\n+\tmovel\ta0,d2\n+\tmovel\td4,a0\n+\tlsrl\tIMM (8),d2\t| put it in the first byte\n+#endif\n \n | Now d0-d1 is positive and the sign bit is in d7.\n \n@@ -1972,16 +2676,27 @@ Lsubsf$0:\n | the rounding routines themselves.\n \tlea\tLsubsf$1,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Lsubsf$1:\n | Put back the exponent (we can't have overflow!). '\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n+#ifndef __mcf5200__\n \tlslw\tIMM (7),d2\n+#else\n+\tlsll\tIMM (7),d2\n+#endif\n \tswap\td2\n \torl\td2,d0\n \tbra\tLaddsf$ret\n@@ -2144,17 +2859,30 @@ SYM (__mulsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n+#ifndef __mcf5200__\n \tlsrw\tIMM (7),d2\t| \n+#else\n+\tlsrl\tIMM (7),d2\t| \n+#endif\n Lmulsf$1:\t\t\t| number\n \tandl\td6,d3\t\t|\n \tbeq\tLmulsf$b$den\t|\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n+#ifndef __mcf5200__\n \tlsrw\tIMM (7),d3\t|\n+#else\n+\tlsrl\tIMM (7),d3\t|\n+#endif\n Lmulsf$2:\t\t\t|\n+#ifndef __mcf5200__\n \taddw\td3,d2\t\t| add exponents\n \tsubw\tIMM (F_BIAS+1),d2 | and subtract bias (plus one)\n+#else\n+\taddl\td3,d2\t\t| add exponents\n+\tsubl\tIMM (F_BIAS+1),d2 | and subtract bias (plus one)\n+#endif\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit FLT_MANT_DIG-1 set (even if they were \n@@ -2180,28 +2908,58 @@ Lmulsf$2:\t\t\t|\n \tbcc\t2f\t\t| if not set skip sum\n \taddl\td5,d1\t\t| add a\n \taddxl\td4,d0\n-2:\tdbf\td3,1b\t\t| loop back\n+2:\n+#ifndef __mcf5200__\n+\tdbf\td3,1b\t\t| loop back\n+#else\n+\tsubql\tIMM (1),d3\n+\tbpl\t1b\n+#endif\n \n | Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG\n | (mod 32) of d0 set. The first thing to do now is to normalize it so bit \n | FLT_MANT_DIG is set (to do the rounding).\n+#ifndef __mcf5200__\n \trorl\tIMM (6),d1\n \tswap\td1\n \tmovew\td1,d3\n \tandw\tIMM (0x03ff),d3\n \tandw\tIMM (0xfd00),d1\n+#else\n+\tmovel\td1,d3\n+\tlsll\tIMM (8),d1\n+\taddl\td1,d1\n+\taddl\td1,d1\n+\tmoveq\tIMM (22),d5\n+\tlsrl\td5,d3\n+\torl\td3,d1\n+\tandl\tIMM (0xfffffd00),d1\n+#endif\n \tlsll\tIMM (8),d0\n \taddl\td0,d0\n \taddl\td0,d0\n+#ifndef __mcf5200__\n \torw\td3,d0\n+#else\n+\torl\td3,d0\n+#endif\n \n \tmovew\tIMM (MULTIPLY),d5\n \t\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\n \tbeq\tLround$exit\n+#ifndef __mcf5200__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d2\n+#else\n+\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+\taddql\tIMM (1),d2\n+#endif\n \tbra\tLround$exit\n \n Lmulsf$inop:\n@@ -2246,7 +3004,11 @@ Lmulsf$a$den:\n \tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left (until bit 23 is set)\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d2\t| and adjust exponent\n+#else\n+\tsubql\tIMM (1),d2\t| and adjust exponent\n+#endif\n \tbtst\tIMM (FLT_MANT_DIG-1),d0\n \tbne\tLmulsf$1\t|\n \tbra\t1b\t\t| else loop back\n@@ -2255,7 +3017,11 @@ Lmulsf$b$den:\n \tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit 23 is set\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d3\t| and adjust exponent\n+#else\n+\tsubl\tIMM (1),d3\t| and adjust exponent\n+#endif\n \tbtst\tIMM (FLT_MANT_DIG-1),d1\n \tbne\tLmulsf$2\t|\n \tbra\t1b\t\t| else loop back\n@@ -2298,17 +3064,30 @@ SYM (__divsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n+#ifndef __mcf5200__\n \tlsrw\tIMM (7),d2\t| \n+#else\n+\tlsrl\tIMM (7),d2\t| \n+#endif\n Ldivsf$1:\t\t\t| \n \tandl\td6,d3\t\t|\n \tbeq\tLdivsf$b$den\t|\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n+#ifndef __mcf5200__\n \tlsrw\tIMM (7),d3\t|\n+#else\n+\tlsrl\tIMM (7),d3\t|\n+#endif\n Ldivsf$2:\t\t\t|\n+#ifndef __mcf5200__\n \tsubw\td3,d2\t\t| subtract exponents\n  \taddw\tIMM (F_BIAS),d2\t| and add bias\n+#else\n+\tsubl\td3,d2\t\t| subtract exponents\n+ \taddl\tIMM (F_BIAS),d2\t| and add bias\n+#endif\n  \n | We are now ready to do the division. We have prepared things in such a way\n | that the ratio of the fractions will be less than 2 but greater than 1/2.\n@@ -2329,19 +3108,34 @@ Ldivsf$2:\t\t\t|\n \tsubl\td1,d0\t\t| if a >= b  a <-- a-b\n \tbeq\t3f\t\t| if a is zero, exit\n 2:\taddl\td0,d0\t\t| multiply a by 2\n+#ifndef __mcf5200__\n \tdbra\td3,1b\n+#else\n+\tsubql\tIMM (1),d3\n+\tbpl\t1b\n+#endif\n \n | Now we keep going to set the sticky bit ...\n \tmovew\tIMM (FLT_MANT_DIG),d3\n 1:\tcmpl\td0,d1\n \tble\t2f\n \taddl\td0,d0\n+#ifndef __mcf5200__\n \tdbra\td3,1b\n+#else\n+\tsubql\tIMM(1),d3\n+\tbpl\t1b\n+#endif\n \tmovel\tIMM (0),d1\n \tbra\t3f\n 2:\tmovel\tIMM (0),d1\n+#ifndef __mcf5200__\n \tsubw\tIMM (FLT_MANT_DIG),d3\n \taddw\tIMM (31),d3\n+#else\n+\tsubl\tIMM (FLT_MANT_DIG),d3\n+\taddl\tIMM (31),d3\n+#endif\n \tbset\td3,d1\n 3:\n \tmovel\td6,d0\t\t| put the ratio in d0-d1\n@@ -2353,7 +3147,11 @@ Ldivsf$2:\t\t\t|\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\t\t\n \tbeq\t1f              | if it is not set, then bit 24 is set\n \tlsrl\tIMM (1),d0\t|\n+#ifndef __mcf5200__\n \taddw\tIMM (1),d2\t|\n+#else\n+\taddl\tIMM (1),d2\t|\n+#endif\n 1:\n | Now round, check for over- and underflow, and exit.\n \tmovew\tIMM (DIVIDE),d5\n@@ -2409,7 +3207,11 @@ Ldivsf$a$den:\n \tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left until bit FLT_MANT_DIG-1 is set\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d2\t| and adjust exponent\n+#else\n+\tsubl\tIMM (1),d2\t| and adjust exponent\n+#endif\n \tbtst\tIMM (FLT_MANT_DIG-1),d0\n \tbne\tLdivsf$1\n \tbra\t1b\n@@ -2418,7 +3220,11 @@ Ldivsf$b$den:\n \tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit FLT_MANT_DIG is set\n+#ifndef __mcf5200__\n \tsubw\tIMM (1),d3\t| and adjust exponent\n+#else\n+\tsubl\tIMM (1),d3\t| and adjust exponent\n+#endif\n \tbtst\tIMM (FLT_MANT_DIG-1),d1\n \tbne\tLdivsf$2\n \tbra\t1b\n@@ -2427,20 +3233,43 @@ Lround$exit:\n | This is a common exit point for __mulsf3 and __divsf3. \n \n | First check for underlow in the exponent:\n+#ifndef __mcf5200__\n \tcmpw\tIMM (-FLT_MANT_DIG-1),d2\t\t\n+#else\n+\tcmpl\tIMM (-FLT_MANT_DIG-1),d2\t\t\n+#endif\n \tblt\tLf$underflow\t\n | It could happen that the exponent is less than 1, in which case the \n | number is denormalized. In this case we shift right and adjust the \n | exponent until it becomes 1 or the fraction is zero (in the latter case \n | we signal underflow and return zero).\n \tmovel\tIMM (0),d6\t| d6 is used temporarily\n+#ifndef __mcf5200__\n \tcmpw\tIMM (1),d2\t| if the exponent is less than 1 we \n+#else\n+\tcmpl\tIMM (1),d2\t| if the exponent is less than 1 we \n+#endif\n \tbge\t2f\t\t| have to shift right (denormalize)\n-1:\taddw\tIMM (1),d2\t| adjust the exponent\n+1:\n+#ifndef __mcf5200__\n+\taddw\tIMM (1),d2\t| adjust the exponent\n \tlsrl\tIMM (1),d0\t| shift right once \n \troxrl\tIMM (1),d1\t|\n \troxrl\tIMM (1),d6\t| d6 collect bits we would lose otherwise\n \tcmpw\tIMM (1),d2\t| is the exponent 1 already?\n+#else\n+\taddql\tIMM (1),d2\t| adjust the exponent\n+\tlsrl\tIMM (1),d6\n+\tbtst\tIMM (0),d1\n+\tbeq\t11f\n+\tbset\tIMM (31),d6\n+11:\tlsrl\tIMM (1),d1\n+\tbtst\tIMM (0),d0\n+\tbeq\t10f\n+\tbset\tIMM (31),d1\n+10:\tlsrl\tIMM (1),d0\n+\tcmpl\tIMM (1),d2\t| is the exponent 1 already?\n+#endif\n \tbeq\t2f\t\t| if not loop back\n \tbra\t1b              |\n \tbra\tLf$underflow\t| safety check, shouldn't execute '\n@@ -2449,9 +3278,16 @@ Lround$exit:\n | Now call the rounding routine (which takes care of denormalized numbers):\n \tlea\tLround$0,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n+#ifdef __mcf5200__\n+\tclrl\td6\n+#endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n+#ifndef __mcf5200__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n+#else\n+\tcmpl\tIMM (ROUND_TO_PLUS),d6\n+#endif\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n@@ -2463,17 +3299,29 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 255).\n+#ifndef __mcf5200__\n \tcmpw\tIMM (0x00ff),d2\n+#else\n+\tcmpl\tIMM (0x00ff),d2\n+#endif\n \tbge\tLf$overflow\n | Now check for a denormalized number (exponent==0).\n \tmovew\td2,d2\n \tbeq\tLf$den\n 1:\n | Put back the exponents and sign and return.\n+#ifndef __mcf5200__\n \tlslw\tIMM (7),d2\t| exponent back to fourth byte\n+#else\n+\tlsll\tIMM (7),d2\t| exponent back to fourth byte\n+#endif\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n \tswap\td0\t\t| and put back exponent\n+#ifndef __mcf5200__\n \torw\td2,d0\t\t| \n+#else\n+\torl\td2,d0\n+#endif\n \tswap\td0\t\t|\n \torl\td7,d0\t\t| and sign also\n \n@@ -2557,7 +3405,13 @@ Lcmpsf$2:\n \ttstl\td6\n \tbpl\t1f\n | If both are negative exchange them\n+#ifndef __mcf5200__\n \texg\td0,d1\n+#else\n+\tmovel\td0,d7\n+\tmovel\td1,d0\n+\tmovel\td7,d1\n+#endif\n 1:\n | Now that they are positive we just compare them as longs (does this also\n | work for denormalized numbers?).\n@@ -2608,11 +3462,20 @@ Lround$to$nearest:\n | Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -F_BIAS+1).\n+#ifndef __mcf5200__\n \tcmpw\tIMM (1),d2\t| remember that the exponent is at least one\n+#else\n+\tcmpl\tIMM (1),d2\t| remember that the exponent is at least one\n+#endif\n  \tbeq\t2f\t\t| an exponent of one means denormalized\n \taddl\td1,d1\t\t| else shift and adjust the exponent\n \taddxl\td0,d0\t\t|\n+#ifndef __mcf5200__\n \tdbra\td2,1b\t\t|\n+#else\n+\tsubql\tIMM (1),d2\n+\tbpl\t1b\n+#endif\n 2:\n | Now round: we do it as follows: after the shifting we can write the\n | fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.\n@@ -2636,7 +3499,11 @@ Lround$to$nearest:\n \tbtst\tIMM (FLT_MANT_DIG),d0\t\n \tbeq\t1f\n \tlsrl\tIMM (1),d0\n+#ifndef __mcf5200__\n \taddw\tIMM (1),d2\n+#else\n+\taddql\tIMM (1),d2\n+#endif\n 1:\n | If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we \n | have to put the exponent to zero and return a denormalized number."}]}