{"sha": "85d53c1d08fbc4b95ac0f21207b87bffe0349841", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVkNTNjMWQwOGZiYzRiOTVhYzBmMjEyMDdiODdiZmZlMDM0OTg0MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-09T10:13:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-09T10:13:16Z"}, "message": "xtensa-protos.h (xtensa_va_arg): Remove.\n\n        * config/xtensa/xtensa-protos.h (xtensa_va_arg): Remove.\n        * config/xtensa/xtensa.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n        (xtensa_gimplify_va_arg_expr): Rewrite from xtensa_va_arg.\n        * config/xtensa/xtensa.h (EXPAND_BUILTIN_VA_ARG): Remove.\n\nFrom-SVN: r84360", "tree": {"sha": "e7a6748e645d8bae00a0349b0fd7af3d3dbab55c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7a6748e645d8bae00a0349b0fd7af3d3dbab55c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85d53c1d08fbc4b95ac0f21207b87bffe0349841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d53c1d08fbc4b95ac0f21207b87bffe0349841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85d53c1d08fbc4b95ac0f21207b87bffe0349841", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85d53c1d08fbc4b95ac0f21207b87bffe0349841/comments", "author": null, "committer": null, "parents": [{"sha": "a900345fb54ed9f1cca996c238c50c385de959dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a900345fb54ed9f1cca996c238c50c385de959dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a900345fb54ed9f1cca996c238c50c385de959dd"}], "stats": {"total": 206, "additions": 97, "deletions": 109}, "files": [{"sha": "120df2955e248bc8ec6d6b71f050ff910c861970", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85d53c1d08fbc4b95ac0f21207b87bffe0349841", "patch": "@@ -1,5 +1,10 @@\n 2004-07-09  Richard Henderson  <rth@redhat.com>\n \n+\t* config/xtensa/xtensa-protos.h (xtensa_va_arg): Remove.\n+\t* config/xtensa/xtensa.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n+\t(xtensa_gimplify_va_arg_expr): Rewrite from xtensa_va_arg.\n+\t* config/xtensa/xtensa.h (EXPAND_BUILTIN_VA_ARG): Remove.\n+\n \t* config/v850/v850-protos.h (v850_va_arg): Remove.\n \t* config/v850/v850.c (TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n \t(v850_gimplify_va_arg_expr): Rewrite from v850_va_arg."}, {"sha": "a300204e8ecf488cff46098cce4a5133c7bfcba6", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=85d53c1d08fbc4b95ac0f21207b87bffe0349841", "patch": "@@ -77,7 +77,6 @@ extern char *xtensa_emit_call (int, rtx *);\n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, int);\n extern void xtensa_va_start (tree, rtx);\n-extern rtx xtensa_va_arg (tree, tree);\n #endif /* TREE_CODE */\n \n extern void print_operand (FILE *, rtx, int);"}, {"sha": "f21930d96678515ca0a70957ce8238fbcb75e709", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 92, "deletions": 104, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=85d53c1d08fbc4b95ac0f21207b87bffe0349841", "patch": "@@ -48,6 +48,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\"\n+#include \"tree-gimple.h\"\n+\n \n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n@@ -211,6 +213,7 @@ static void xtensa_select_rtx_section (enum machine_mode, rtx,\n static bool xtensa_rtx_costs (rtx, int, int, int *);\n static tree xtensa_build_builtin_va_list (void);\n static bool xtensa_return_in_memory (tree, tree);\n+static tree xtensa_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n \n static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n   REG_ALLOC_ORDER;\n@@ -255,6 +258,8 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n \n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS xtensa_builtin_saveregs\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR xtensa_gimplify_va_arg_expr\n \n #undef TARGET_RETURN_IN_MSB\n #define TARGET_RETURN_IN_MSB xtensa_return_in_msb\n@@ -2461,33 +2466,30 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n /* Implement `va_arg'.  */\n \n-rtx\n-xtensa_va_arg (tree valist, tree type)\n+static tree\n+xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n+\t\t\t     tree *post_p ATTRIBUTE_UNUSED)\n {\n   tree f_stk, stk;\n   tree f_reg, reg;\n   tree f_ndx, ndx;\n-  tree tmp, addr_tree, type_size;\n-  rtx array, orig_ndx, r, addr, size, va_size;\n-  rtx lab_false, lab_over, lab_false2;\n+  tree type_size, array, orig_ndx, addr, size, va_size, t;\n+  tree lab_false, lab_over, lab_false2;\n \n   /* Handle complex values as separate real and imaginary parts.  */\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n-      rtx real_part, imag_part, concat_val, local_copy;\n+      tree real_part, imag_part;\n \n-      real_part = xtensa_va_arg (valist, TREE_TYPE (type));\n-      imag_part = xtensa_va_arg (valist, TREE_TYPE (type));\n+      real_part = xtensa_gimplify_va_arg_expr (valist, TREE_TYPE (type),\n+\t\t\t\t\t       pre_p, NULL);\n+      real_part = get_initialized_tmp_var (real_part, pre_p, NULL);\n \n-      /* Make a copy of the value in case the parts are not contiguous.  */\n-      real_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), real_part);\n-      imag_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), imag_part);\n-      concat_val = gen_rtx_CONCAT (TYPE_MODE (type), real_part, imag_part);\n+      imag_part = xtensa_gimplify_va_arg_expr (valist, TREE_TYPE (type),\n+\t\t\t\t\t       pre_p, NULL);\n+      imag_part = get_initialized_tmp_var (imag_part, pre_p, NULL);\n \n-      local_copy = assign_temp (type, 0, 1, 0);\n-      emit_move_insn (local_copy, concat_val);\n-\n-      return XEXP (local_copy, 0);\n+      return build (COMPLEX_EXPR, type, real_part, imag_part);\n     }\n \n   f_stk = TYPE_FIELDS (va_list_type_node);\n@@ -2498,55 +2500,41 @@ xtensa_va_arg (tree valist, tree type)\n   reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg, NULL_TREE);\n   ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx, NULL_TREE);\n \n-  type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type));\n-\n-  va_size = gen_reg_rtx (SImode);\n-  tmp = fold (build (MULT_EXPR, sizetype,\n-\t\t     fold (build (TRUNC_DIV_EXPR, sizetype,\n-\t\t\t\t  fold (build (PLUS_EXPR, sizetype,\n-\t\t\t\t\t       type_size,\n-\t\t\t\t\t       size_int (UNITS_PER_WORD - 1))),\n-\t\t\t\t  size_int (UNITS_PER_WORD))),\n-\t\t     size_int (UNITS_PER_WORD)));\n-  r = expand_expr (tmp, va_size, SImode, EXPAND_NORMAL);\n-  if (r != va_size)\n-    emit_move_insn (va_size, r);\n+  type_size = size_in_bytes (type);\n+  va_size = round_up (type_size, UNITS_PER_WORD);\n+  gimplify_expr (&va_size, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n \n   /* First align __va_ndx if necessary for this arg:\n \n+     orig_ndx = (AP).__va_ndx;\n      if (__alignof__ (TYPE) > 4 )\n-       (AP).__va_ndx = (((AP).__va_ndx + __alignof__ (TYPE) - 1)\n+       orig_ndx = ((orig_ndx + __alignof__ (TYPE) - 1)\n \t\t\t& -__alignof__ (TYPE)); */\n \n+  orig_ndx = get_initialized_tmp_var (ndx, pre_p, NULL);\n+\n   if (TYPE_ALIGN (type) > BITS_PER_WORD)\n     {\n       int align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n-      tmp = build (PLUS_EXPR, integer_type_node, ndx,\n-\t\t   build_int_2 (align - 1, 0));\n-      tmp = build (BIT_AND_EXPR, integer_type_node, tmp,\n-\t\t   build_int_2 (-align, -1));\n-      tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n-      TREE_SIDE_EFFECTS (tmp) = 1;\n-      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      t = build (PLUS_EXPR, integer_type_node, orig_ndx,\n+\t\t build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, integer_type_node, t,\n+\t\t build_int_2 (-align, -1));\n+      t = build (MODIFY_EXPR, integer_type_node, orig_ndx, t);\n+      gimplify_and_add (t, pre_p);\n     }\n \n \n   /* Increment __va_ndx to point past the argument:\n \n-     orig_ndx = (AP).__va_ndx;\n-     (AP).__va_ndx += __va_size (TYPE); */\n-\n-  orig_ndx = gen_reg_rtx (SImode);\n-  r = expand_expr (ndx, orig_ndx, SImode, EXPAND_NORMAL);\n-  if (r != orig_ndx)\n-    emit_move_insn (orig_ndx, r);\n+     (AP).__va_ndx = orig_ndx + __va_size (TYPE); */\n \n-  tmp = build (PLUS_EXPR, integer_type_node, ndx,\n-\t       make_tree (intSI_type_node, va_size));\n-  tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n-  TREE_SIDE_EFFECTS (tmp) = 1;\n-  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  t = fold_convert (integer_type_node, va_size);\n+  t = build (PLUS_EXPR, integer_type_node, orig_ndx, t);\n+  t = build (MODIFY_EXPR, integer_type_node, ndx, t);\n+  gimplify_and_add (t, pre_p);\n \n \n   /* Check if the argument is in registers:\n@@ -2555,29 +2543,32 @@ xtensa_va_arg (tree valist, tree type)\n          && !MUST_PASS_IN_STACK (type))\n         __array = (AP).__va_reg; */\n \n-  array = gen_reg_rtx (Pmode);\n+  array = create_tmp_var (ptr_type_node, NULL);\n \n-  lab_over = NULL_RTX;\n+  lab_over = NULL;\n   if (!MUST_PASS_IN_STACK (VOIDmode, type))\n     {\n-      lab_false = gen_label_rtx ();\n-      lab_over = gen_label_rtx ();\n-\n-      emit_cmp_and_jump_insns (expand_expr (ndx, NULL_RTX, SImode,\n-\t\t\t\t\t    EXPAND_NORMAL),\n-\t\t\t       GEN_INT (MAX_ARGS_IN_REGISTERS\n-\t\t\t\t\t* UNITS_PER_WORD),\n-\t\t\t       GT, const1_rtx, SImode, 0, lab_false);\n-\n-      r = expand_expr (reg, array, Pmode, EXPAND_NORMAL);\n-      if (r != array)\n-\temit_move_insn (array, r);\n-\n-      emit_jump_insn (gen_jump (lab_over));\n-      emit_barrier ();\n-      emit_label (lab_false);\n+      lab_false = create_artificial_label ();\n+      lab_over = create_artificial_label ();\n+\n+      t = build_int_2 (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n+      t = build (GT_EXPR, boolean_type_node, ndx, t);\n+      t = build (COND_EXPR, void_type_node, t,\n+\t\t build (GOTO_EXPR, void_type_node, lab_false),\n+\t\t NULL);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build (MODIFY_EXPR, void_type_node, array, reg);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build (GOTO_EXPR, void_type_node, lab_over);\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build (LABEL_EXPR, void_type_node, lab_false);\n+      gimplify_and_add (t, pre_p);\n     }\n \n+\n   /* ...otherwise, the argument is on the stack (never split between\n      registers and the stack -- change __va_ndx if necessary):\n \n@@ -2588,25 +2579,31 @@ xtensa_va_arg (tree valist, tree type)\n \t __array = (AP).__va_stk;\n        } */\n \n-  lab_false2 = gen_label_rtx ();\n-  emit_cmp_and_jump_insns (orig_ndx,\n-\t\t\t   GEN_INT (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD),\n-\t\t\t   GT, const1_rtx, SImode, 0, lab_false2);\n+  lab_false2 = create_artificial_label ();\n \n-  tmp = build (PLUS_EXPR, sizetype, make_tree (intSI_type_node, va_size),\n-\t       build_int_2 (32, 0));\n-  tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n-  TREE_SIDE_EFFECTS (tmp) = 1;\n-  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  t = build_int_2 (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n+  t = build (GT_EXPR, boolean_type_node, orig_ndx, t);\n+  t = build (COND_EXPR, void_type_node, t,\n+\t     build (GOTO_EXPR, void_type_node, lab_false2),\n+\t     NULL);\n+  gimplify_and_add (t, pre_p);\n \n-  emit_label (lab_false2);\n+  t = size_binop (PLUS_EXPR, va_size, size_int (32));\n+  t = fold_convert (integer_type_node, t);\n+  t = build (MODIFY_EXPR, integer_type_node, ndx, t);\n+  gimplify_and_add (t, pre_p);\n \n-  r = expand_expr (stk, array, Pmode, EXPAND_NORMAL);\n-  if (r != array)\n-    emit_move_insn (array, r);\n+  t = build (LABEL_EXPR, void_type_node, lab_false2);\n+  gimplify_and_add (t, pre_p);\n \n-  if (lab_over != NULL_RTX)\n-    emit_label (lab_over);\n+  t = build (MODIFY_EXPR, void_type_node, array, stk);\n+  gimplify_and_add (t, pre_p);\n+\n+  if (lab_over)\n+    {\n+      t = build (LABEL_EXPR, void_type_node, lab_over);\n+      gimplify_and_add (t, pre_p);\n+    }\n \n \n   /* Given the base array pointer (__array) and index to the subsequent\n@@ -2619,33 +2616,24 @@ xtensa_va_arg (tree valist, tree type)\n      The results are endian-dependent because values smaller than one word\n      are aligned differently.  */\n \n-  size = gen_reg_rtx (SImode);\n-  emit_move_insn (size, va_size);\n \n   if (BYTES_BIG_ENDIAN)\n     {\n-      rtx lab_use_va_size = gen_label_rtx ();\n-\n-      emit_cmp_and_jump_insns (expand_expr (type_size, NULL_RTX, SImode,\n-\t\t\t\t\t    EXPAND_NORMAL),\n-\t\t\t       GEN_INT (PARM_BOUNDARY / BITS_PER_UNIT),\n-\t\t\t       GE, const1_rtx, SImode, 0, lab_use_va_size);\n-\n-      r = expand_expr (type_size, size, SImode, EXPAND_NORMAL);\n-      if (r != size)\n-\temit_move_insn (size, r);\n-\n-      emit_label (lab_use_va_size);\n+      t = size_int (PARM_BOUNDARY / BITS_PER_UNIT);\n+      t = fold (build (GE_EXPR, boolean_type_node, type_size, t));\n+      t = fold (build (COND_EXPR, sizetype, t, type_size, va_size));\n+      size = t;\n     }\n+  else\n+    size = va_size;\n+\n+  t = fold_convert (ptr_type_node, ndx);\n+  addr = build (PLUS_EXPR, ptr_type_node, array, t);\n+  t = fold_convert (ptr_type_node, size);\n+  addr = build (MINUS_EXPR, ptr_type_node, addr, t);\n \n-  addr_tree = build (PLUS_EXPR, ptr_type_node,\n-\t\t     make_tree (ptr_type_node, array),\n-\t\t     ndx);\n-  addr_tree = build (MINUS_EXPR, ptr_type_node, addr_tree,\n-\t\t     make_tree (intSI_type_node, size));\n-  addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n-  addr = copy_to_reg (addr);\n-  return addr;\n+  addr = fold_convert (build_pointer_type (type), addr);\n+  return build_fold_indirect_ref (addr);\n }\n \n "}, {"sha": "41e64c6278be90a1b571bc5fce96f4b5a59a06eb", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85d53c1d08fbc4b95ac0f21207b87bffe0349841/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=85d53c1d08fbc4b95ac0f21207b87bffe0349841", "patch": "@@ -901,10 +901,6 @@ typedef struct xtensa_args\n #define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n   xtensa_va_start (valist, nextarg)\n \n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  xtensa_va_arg (valist, type)\n-\n /* If defined, a C expression that produces the machine-specific code\n    to setup the stack so that arbitrary frames can be accessed.\n "}]}