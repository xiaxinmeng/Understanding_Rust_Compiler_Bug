{"sha": "8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE2NDIzN2NmYzBmMWY1ZjdhZDliNTdlN2QxNDRjMjViNmI4OWIyYg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@merlin.codesourcery.com", "date": "2001-06-21T12:01:09Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-06-21T12:01:09Z"}, "message": "indirect_array.h (indirect_array<>::operator=): Make copy and assignment operator public.\n\n\t* include/bits/indirect_array.h (indirect_array<>::operator=):\n\tMake copy and assignment operator public.  Implement.  Format.\n\n\t* include/bits/valarray_array.h (__valarray_copy): Add overloads\n\tfor copy between index arrays.  Format.\n\nFrom-SVN: r43483", "tree": {"sha": "5e9d39039e45899c5e731183b2b596a557d1bd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e9d39039e45899c5e731183b2b596a557d1bd09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/comments", "author": null, "committer": null, "parents": [{"sha": "c0eadc6bfeb28d60298ba454ac43446b700820e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0eadc6bfeb28d60298ba454ac43446b700820e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0eadc6bfeb28d60298ba454ac43446b700820e4"}], "stats": {"total": 784, "additions": 415, "deletions": 369}, "files": [{"sha": "8f94275ba29a3abf25c2a837657d1eb5ec4a1709", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "patch": "@@ -1,3 +1,11 @@\n+2001-06-21  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n+\n+\t* include/bits/indirect_array.h (indirect_array<>::operator=):\n+\tMake copy and assignment operator public.  Implement.  Format.\n+\n+\t* include/bits/valarray_array.h (__valarray_copy): Add overloads\n+\tfor copy between index arrays.  Format.\n+\n 2001-06-19  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* mknumeric_limits: Add static definitions, format."}, {"sha": "5eb3fb04edd2b4676a7d266194008b7d486c0190", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "modified", "additions": 98, "deletions": 89, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "patch": "@@ -34,95 +34,104 @@\n \n #pragma GCC system_header\n \n-namespace std {\n-\n-    template <class _Tp> class indirect_array\n-    {\n-    public:\n-        typedef _Tp value_type;\n-    \n-        void operator=  (const valarray<_Tp>&) const;\n-        void operator*= (const valarray<_Tp>&) const;\n-        void operator/= (const valarray<_Tp>&) const;\n-        void operator%= (const valarray<_Tp>&) const; \n-        void operator+= (const valarray<_Tp>&) const;\n-        void operator-= (const valarray<_Tp>&) const;  \n-        void operator^= (const valarray<_Tp>&) const;\n-        void operator&= (const valarray<_Tp>&) const;\n-        void operator|= (const valarray<_Tp>&) const;\n-        void operator<<= (const valarray<_Tp>&) const;\n-        void operator>>= (const valarray<_Tp>&) const; \n-        void operator= (const _Tp&);\n-        //    ~indirect_array();\n-\n-        template<class _Dom>\n-        void operator=  (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator*= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator/= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator%= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator+= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator-= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator^= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator&= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator|= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator<<= (const _Expr<_Dom, _Tp>&) const;\n-        template<class _Dom>\n-        void operator>>= (const _Expr<_Dom, _Tp>&) const; \n-\n-    private:\n-    indirect_array (const indirect_array&);\n-    indirect_array (_Array<_Tp>, size_t, _Array<size_t>);\n-\n-    friend class valarray<_Tp>;\n-    friend class gslice_array<_Tp>;\n-\n-    const size_t \t _M_sz;\n-    const _Array<size_t> _M_index;\n-    const _Array<_Tp> \t _M_array;\n-\n-        // not implemented\n-        indirect_array ();\n-        indirect_array& operator= (const indirect_array&);\n-    };\n-\n-    template<typename _Tp>\n-    inline indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n-            : _M_sz (__a._M_sz), _M_index (__a._M_index),\n-              _M_array (__a._M_array) {}\n-    \n-    template<typename _Tp>\n-    inline\n-    indirect_array<_Tp>::indirect_array (_Array<_Tp> __a, size_t __s, \n-                                         _Array<size_t> __i)\n-            : _M_sz (__s), _M_index (__i), _M_array (__a) {}\n-    \n-    // template<typename _Tp>\n-    // inline indirect_array<_Tp>::~indirect_array() {}\n-\n-    template<typename _Tp>\n-    inline void\n-    indirect_array<_Tp>::operator= (const _Tp& __t)\n-    { __valarray_fill(_M_array, _M_index, _M_sz, __t); }\n-\n-    template<typename _Tp>\n-    inline void\n-    indirect_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n-    { __valarray_copy (_Array<_Tp> (__v), _M_sz, _M_array, _M_index); }\n-\n-    template<typename _Tp>\n-    template<class _Dom>\n-    inline void\n-    indirect_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n-    { __valarray_copy (__e, _M_sz, _M_array, _M_index); }\n+namespace std\n+{\n+  template <class _Tp>\n+     class indirect_array\n+     {\n+     public:\n+       typedef _Tp value_type;\n+\n+       // XXX: This is a proposed resolution for DR-253.\n+       indirect_array& operator= (const indirect_array&);\n+\n+       void operator=  (const valarray<_Tp>&) const;\n+       void operator*= (const valarray<_Tp>&) const;\n+       void operator/= (const valarray<_Tp>&) const;\n+       void operator%= (const valarray<_Tp>&) const; \n+       void operator+= (const valarray<_Tp>&) const;\n+       void operator-= (const valarray<_Tp>&) const;  \n+       void operator^= (const valarray<_Tp>&) const;\n+       void operator&= (const valarray<_Tp>&) const;\n+       void operator|= (const valarray<_Tp>&) const;\n+       void operator<<= (const valarray<_Tp>&) const;\n+       void operator>>= (const valarray<_Tp>&) const; \n+       void operator= (const _Tp&);\n+       //    ~indirect_array();\n+\n+       template<class _Dom>\n+       void operator=  (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator*= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator/= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator%= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator+= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator-= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator^= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator&= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator|= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator<<= (const _Expr<_Dom, _Tp>&) const;\n+       template<class _Dom>\n+       void operator>>= (const _Expr<_Dom, _Tp>&) const; \n+\n+     private:\n+       indirect_array (const indirect_array&);\n+       indirect_array (_Array<_Tp>, size_t, _Array<size_t>);\n+\n+       friend class valarray<_Tp>;\n+       friend class gslice_array<_Tp>;\n+\n+       const size_t \t _M_sz;\n+       const _Array<size_t> _M_index;\n+       const _Array<_Tp> \t _M_array;\n+\n+       // not implemented\n+       indirect_array ();\n+     };\n+\n+  template<typename _Tp>\n+  inline indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n+          : _M_sz (__a._M_sz), _M_index (__a._M_index),\n+            _M_array (__a._M_array) {}\n+\n+  template<typename _Tp>\n+     inline\n+     indirect_array<_Tp>::indirect_array (_Array<_Tp> __a, size_t __s, \n+                                          _Array<size_t> __i)\n+             : _M_sz (__s), _M_index (__i), _M_array (__a) {}\n+\n+  template<typename _Tp>\n+     inline indirect_array<_Tp>&\n+     indirect_array<_Tp>::operator=(const indirect_array<_Tp>& __a)\n+     {\n+       __valarray_copy(__a._M_array, _M_sz, __a._M_index, _M_array, _M_index);\n+       return *this;\n+     }\n+\n+\n+  template<typename _Tp>\n+     inline void\n+     indirect_array<_Tp>::operator= (const _Tp& __t)\n+     { __valarray_fill(_M_array, _M_index, _M_sz, __t); }\n+\n+  template<typename _Tp>\n+     inline void\n+     indirect_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+     { __valarray_copy (_Array<_Tp> (__v), _M_sz, _M_array, _M_index); }\n+\n+  template<typename _Tp>\n+     template<class _Dom>\n+     inline void\n+     indirect_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+     { __valarray_copy (__e, _M_sz, _M_array, _M_index); }\n \n #undef _DEFINE_VALARRAY_OPERATOR\n #define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\"}, {"sha": "d163d0530ff9ede1219f7efe77809ce3943305a5", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 309, "deletions": 280, "changes": 589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=8164237cfc0f1f5f7ad9b57e7d144c25b6b89b2b", "patch": "@@ -42,7 +42,6 @@\n \n namespace std\n {\n-  \n   //\n   // Helper functions on raw pointers\n   //\n@@ -53,12 +52,12 @@ namespace std\n   { return operator new(__n); }\n   \n   template<typename _Tp>\n-  inline _Tp*__restrict__\n-  __valarray_get_storage(size_t __n)\n-  {\n-    return static_cast<_Tp*__restrict__>\n-      (__valarray_get_memory(__n * sizeof(_Tp)));\n-  }\n+     inline _Tp*__restrict__\n+     __valarray_get_storage(size_t __n)\n+     {\n+       return static_cast<_Tp*__restrict__>\n+         (__valarray_get_memory(__n * sizeof(_Tp)));\n+     }\n \n   // Return memory to the system\n   inline void\n@@ -68,218 +67,230 @@ namespace std\n   // Turn a raw-memory into an array of _Tp filled with _Tp()\n   // This is required in 'valarray<T> v(n);'\n   template<typename _Tp, bool>\n-  struct _Array_default_ctor\n-  {\n-    // Please note that this isn't exception safe.  But\n-    // valarrays aren't required to be exception safe.\n-    inline static void\n-    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-    { while (__b != __e) new(__b++) _Tp(); }\n-  };\n-\n-  template<typename _Tp>\n-  struct _Array_default_ctor<_Tp, true>\n-  {\n-    // For fundamental types, it suffices to say 'memset()'\n-    inline static void\n-    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-    { memset(__b, 0, (__e - __b)*sizeof(_Tp)); }\n-  };\n-\n-  template<typename _Tp>\n-  inline void\n-  __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-  {\n-    _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-      _S_do_it(__b, __e);\n-  }\n+     struct _Array_default_ctor\n+     {\n+       // Please note that this isn't exception safe.  But\n+       // valarrays aren't required to be exception safe.\n+       inline static void\n+       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+       { while (__b != __e) new(__b++) _Tp(); }\n+     };\n+\n+  template<typename _Tp>\n+     struct _Array_default_ctor<_Tp, true>\n+     {\n+       // For fundamental types, it suffices to say 'memset()'\n+       inline static void\n+       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+       { memset(__b, 0, (__e - __b)*sizeof(_Tp)); }\n+     };\n+\n+  template<typename _Tp>\n+     inline void\n+     __valarray_default_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+     {\n+       _Array_default_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+         _S_do_it(__b, __e);\n+     }\n     \n   // Turn a raw-memory into an array of _Tp filled with __t\n   // This is the required in valarray<T> v(n, t).  Also\n   // used in valarray<>::resize().\n   template<typename _Tp, bool>\n-  struct _Array_init_ctor\n-  {\n-    // Please note that this isn't exception safe.  But\n-    // valarrays aren't required to be exception safe.\n-    inline static void\n-    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n-    { while (__b != __e) new(__b++) _Tp(__t); }\n-  };\n-\n-  template<typename _Tp>\n-  struct _Array_init_ctor<_Tp, true>\n-  {\n-    inline static void\n-    _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n-    { while (__b != __e) *__b++ = __t; }\n-  };\n-\n-  template<typename _Tp>\n-  inline void\n-  __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n-                            const _Tp __t)\n-  {\n-    _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-      _S_do_it(__b, __e, __t);\n-  }\n+     struct _Array_init_ctor\n+     {\n+       // Please note that this isn't exception safe.  But\n+       // valarrays aren't required to be exception safe.\n+       inline static void\n+       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n+       { while (__b != __e) new(__b++) _Tp(__t); }\n+     };\n+\n+  template<typename _Tp>\n+     struct _Array_init_ctor<_Tp, true>\n+     {\n+       inline static void\n+       _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n+       { while (__b != __e) *__b++ = __t; }\n+     };\n+\n+  template<typename _Tp>\n+     inline void\n+     __valarray_fill_construct(_Tp* __restrict__ __b, _Tp* __restrict__ __e,\n+                               const _Tp __t)\n+     {\n+       _Array_init_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+         _S_do_it(__b, __e, __t);\n+     }\n \n   //\n   // copy-construct raw array [__o, *) from plain array [__b, __e)\n   // We can't just say 'memcpy()'\n   //\n   template<typename _Tp, bool>\n-  struct _Array_copy_ctor\n-  {\n-    // Please note that this isn't exception safe.  But\n-    // valarrays aren't required to be exception safe.\n-    inline static void\n-    _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n-             _Tp* __restrict__ __o)\n-    { while (__b != __e) new(__o++) _Tp(*__b++); }\n-  };\n-\n-  template<typename _Tp>\n-  struct _Array_copy_ctor<_Tp, true>\n-  {\n-    inline static void\n-    _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n-             _Tp* __restrict__ __o)\n-    { memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }\n-  };\n-\n-  template<typename _Tp>\n-  inline void\n-  __valarray_copy_construct(const _Tp* __restrict__ __b,\n-                            const _Tp* __restrict__ __e,\n-                            _Tp* __restrict__ __o)\n-  {\n-    _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n-      _S_do_it(__b, __e, __o);\n-  }\n+     struct _Array_copy_ctor\n+     {\n+       // Please note that this isn't exception safe.  But\n+       // valarrays aren't required to be exception safe.\n+       inline static void\n+       _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+                _Tp* __restrict__ __o)\n+       { while (__b != __e) new(__o++) _Tp(*__b++); }\n+     };\n+\n+  template<typename _Tp>\n+     struct _Array_copy_ctor<_Tp, true>\n+     {\n+       inline static void\n+       _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n+                _Tp* __restrict__ __o)\n+       { memcpy(__o, __b, (__e - __b)*sizeof(_Tp)); }\n+     };\n+\n+  template<typename _Tp>\n+     inline void\n+     __valarray_copy_construct(const _Tp* __restrict__ __b,\n+                               const _Tp* __restrict__ __e,\n+                               _Tp* __restrict__ __o)\n+     {\n+       _Array_copy_ctor<_Tp, __is_fundamental<_Tp>::_M_type>::\n+         _S_do_it(__b, __e, __o);\n+     }\n \n   // copy-construct raw array [__o, *) from strided array __a[<__n : __s>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n-                             size_t __s, _Tp* __restrict__ __o)\n-  {\n-    if (__is_fundamental<_Tp>::_M_type)\n-      while (__n--) { *__o++ = *__a; __a += __s; }\n-    else\n-      while (__n--) { new(__o++) _Tp(*__a);  __a += __s; }\n-  }\n+     inline void\n+     __valarray_copy_construct (const _Tp* __restrict__ __a, size_t __n,\n+                                size_t __s, _Tp* __restrict__ __o)\n+     {\n+       if (__is_fundamental<_Tp>::_M_type)\n+         while (__n--) { *__o++ = *__a; __a += __s; }\n+       else\n+         while (__n--) { new(__o++) _Tp(*__a);  __a += __s; }\n+     }\n \n   // copy-construct raw array [__o, *) from indexed array __a[__i[<__n>]]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy_construct (const _Tp* __restrict__ __a,\n-                             const size_t* __restrict__ __i,\n-                             _Tp* __restrict__ __o, size_t __n)\n-  {\n-    if (__is_fundamental<_Tp>::_M_type)\n-      while (__n--) *__o++ = __a[*__i++];\n-    else\n-      while (__n--) new (__o++) _Tp(__a[*__i++]);\n-  }\n+     inline void\n+     __valarray_copy_construct (const _Tp* __restrict__ __a,\n+                                const size_t* __restrict__ __i,\n+                                _Tp* __restrict__ __o, size_t __n)\n+     {\n+       if (__is_fundamental<_Tp>::_M_type)\n+         while (__n--) *__o++ = __a[*__i++];\n+       else\n+         while (__n--) new (__o++) _Tp(__a[*__i++]);\n+     }\n \n   // Do the necessary cleanup when we're done with arrays.\n   template<typename _Tp>\n-  inline void\n-  __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-  {\n-    if (!__is_fundamental<_Tp>::_M_type)\n-      while (__b != __e) { __b->~_Tp(); ++__b; }\n-  }\n+     inline void\n+     __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n+     {\n+       if (!__is_fundamental<_Tp>::_M_type)\n+         while (__b != __e) { __b->~_Tp(); ++__b; }\n+     }\n     \n-  // fill plain array __a[<__n>] with __t\n+  // Fill a plain array __a[<__n>] with __t\n   template<typename _Tp>\n-  void\n-  __valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n-  { while (__n--) *__a++ = __t; }\n+     inline void\n+     __valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n+     { while (__n--) *__a++ = __t; }\n   \n   // fill strided array __a[<__n-1 : __s>] with __t\n   template<typename _Tp>\n-  inline void\n-  __valarray_fill (_Tp* __restrict__ __a, size_t __n,\n-                   size_t __s, const _Tp& __t)\n-  { for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n+     inline void\n+     __valarray_fill (_Tp* __restrict__ __a, size_t __n,\n+                      size_t __s, const _Tp& __t)\n+     { for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n \n   // fill indir   ect array __a[__i[<__n>]] with __i\n   template<typename _Tp>\n-  inline void\n-  __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n-                  size_t __n, const _Tp& __t)\n-  { for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n+     inline void\n+     __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n+                     size_t __n, const _Tp& __t)\n+     { for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n     \n   // copy plain array __a[<__n>] in __b[<__n>]\n   // For non-fundamental types, it is wrong to say 'memcpy()'\n   template<typename _Tp, bool>\n-  struct _Array_copier\n-  {\n-    inline static void\n-    _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n-    { while (__n--) *__b++ = *__a++; }      \n-  };\n+     struct _Array_copier\n+     {\n+       inline static void\n+       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+       { while (__n--) *__b++ = *__a++; }      \n+     };\n \n   template<typename _Tp>\n-  struct _Array_copier<_Tp, true>\n-  {\n-    inline static void\n-    _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n-    { memcpy (__b, __a, __n * sizeof (_Tp)); }\n-  };\n+     struct _Array_copier<_Tp, true>\n+     {\n+       inline static void\n+       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n+       { memcpy (__b, __a, __n * sizeof (_Tp)); }\n+     };\n \n+  // Copy a plain array __a[<__n>] into a play array __b[<>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n-                   _Tp* __restrict__ __b)\n-  {\n-    _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n-      _S_do_it(__a, __n, __b);\n-  }\n+     inline void\n+     __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n+                      _Tp* __restrict__ __b)\n+     {\n+       _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n+         _S_do_it(__a, __n, __b);\n+     }\n \n-  // copy strided array __a[<__n : __s>] in plain __b[<__n>]\n+  // Copy strided array __a[<__n : __s>] in plain __b[<__n>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (const _Tp* __restrict__ __a, size_t __n, size_t __s,\n-                   _Tp* __restrict__ __b)\n-  { for (size_t __i=0; __i<__n; ++__i, ++__b, __a += __s) *__b = *__a; }\n+     inline void\n+     __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,\n+                      _Tp* __restrict__ __b)\n+     { for (size_t __i=0; __i<__n; ++__i, ++__b, __a += __s) *__b = *__a; }\n \n-  // copy plain __a[<__n>] in strided __b[<__n : __s>]\n+  // Copy a plain array  __a[<__n>] into a strided array __b[<__n : __s>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n-                   size_t __n, size_t __s)\n-  { for (size_t __i=0; __i<__n; ++__i, ++__a, __b+=__s) *__b = *__a; }\n+     inline void\n+     __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n+                      size_t __n, size_t __s)\n+     { for (size_t __i=0; __i<__n; ++__i, ++__a, __b+=__s) *__b = *__a; }\n \n   // Copy strided array __src[<__n : __s1>] into another\n   // strided array __dst[< : __s2>].  Their sizes must match.\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,\n-                  _Tp* __restrict__ __dst, size_t __s2)\n-  {\n-    for (size_t __i = 0; __i < __n; ++__i)\n-      __dst[__i * __s2] = __src [ __i * __s1];\n-  }\n+     inline void\n+     __valarray_copy(const _Tp* __restrict__ __src, size_t __n, size_t __s1,\n+                     _Tp* __restrict__ __dst, size_t __s2)\n+     {\n+       for (size_t __i = 0; __i < __n; ++__i)\n+         __dst[__i * __s2] = __src [ __i * __s1];\n+     }\n \n   \n-  // copy indexed __a[__i[<__n>]] in plain __b[<__n>]\n+  // Copy an indexed array __a[__i[<__n>]] in plain array __b[<__n>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (const _Tp* __restrict__ __a,\n-                   const size_t* __restrict__ __i,\n-                   _Tp* __restrict__ __b, size_t __n)\n-  { for (size_t __j=0; __j<__n; ++__j, ++__b, ++__i) *__b = __a[*__i]; }\n+     inline void\n+     __valarray_copy (const _Tp* __restrict__ __a,\n+                      const size_t* __restrict__ __i,\n+                      _Tp* __restrict__ __b, size_t __n)\n+     { for (size_t __j=0; __j<__n; ++__j, ++__b, ++__i) *__b = __a[*__i]; }\n \n-  // copy plain __a[<__n>] in indexed __b[__i[<__n>]]\n+  // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n-                   _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n-  { for (size_t __j=0; __j<__n; ++__j, ++__a, ++__i) __b[*__i] = *__a; }\n+     inline void\n+     __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n+                      _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n+     { for (size_t __j=0; __j<__n; ++__j, ++__a, ++__i) __b[*__i] = *__a; }\n \n+  // Copy the __n first elements of an indexed array __src[<__i>] into\n+  // another indexed array __dst[<__j>].\n+  template<typename _Tp>\n+     inline void\n+     __valarray_copy(const _Tp* __restrict__ __src, size_t __n,\n+                     const size_t* __restrict__ __i,\n+                     _Tp* __restrict__ __dst, const size_t* __restrict__ __j)\n+     {\n+       for (size_t __k = 0; __k < __n; ++__k)\n+         __dst[*__j++] = __src[*__i++];\n+     }\n \n   //\n   // Compute the sum of elements in range [__f, __l)\n@@ -289,57 +300,57 @@ namespace std\n   // algorithm.\n   //\n   template<typename _Tp>\n-  inline _Tp\n-  __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n-  {\n-    _Tp __r = _Tp();\n-    while (__f != __l) __r += *__f++;\n-    return __r;\n-  }\n+     inline _Tp\n+     __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n+     {\n+       _Tp __r = _Tp();\n+       while (__f != __l) __r += *__f++;\n+       return __r;\n+     }\n \n   // Compute the product of all elements in range [__f, __l)\n   template<typename _Tp>\n-  inline _Tp\n-  __valarray_product(const _Tp* __restrict__ __f,\n-                     const _Tp* __restrict__ __l)\n-  {\n-    _Tp __r = _Tp(1);\n-    while (__f != __l) __r = __r * *__f++;\n-    return __r;\n-  }\n+     inline _Tp\n+     __valarray_product(const _Tp* __restrict__ __f,\n+                        const _Tp* __restrict__ __l)\n+     {\n+       _Tp __r = _Tp(1);\n+       while (__f != __l) __r = __r * *__f++;\n+       return __r;\n+     }\n \n   // Compute the min/max of an array-expression\n   template<typename _Ta>\n-  inline typename _Ta::value_type\n-  __valarray_min(const _Ta& __a)\n-  {\n-    size_t __s = __a.size();\n-    typedef typename _Ta::value_type _Value_type;\n-    _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n-    for (size_t __i = 1; __i < __s; ++__i)\n-      {\n-        _Value_type __t = __a[__i];\n-        if (__t < __r)\n-          __r = __t;\n-      }\n-    return __r;\n-  }\n+     inline typename _Ta::value_type\n+     __valarray_min(const _Ta& __a)\n+     {\n+       size_t __s = __a.size();\n+       typedef typename _Ta::value_type _Value_type;\n+       _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n+       for (size_t __i = 1; __i < __s; ++__i)\n+         {\n+           _Value_type __t = __a[__i];\n+           if (__t < __r)\n+             __r = __t;\n+         }\n+       return __r;\n+     }\n   \n   template<typename _Ta>\n-  inline typename _Ta::value_type\n-  __valarray_max(const _Ta& __a)\n-  {\n-    size_t __s = __a.size();\n-    typedef typename _Ta::value_type _Value_type;\n-    _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n-    for (size_t __i = 1; __i < __s; ++__i)\n-      {\n-        _Value_type __t = __a[__i];\n-        if (__t > __r)\n-          __r = __t;\n-      }\n-    return __r;\n-  }\n+     inline typename _Ta::value_type\n+     __valarray_max(const _Ta& __a)\n+     {\n+       size_t __s = __a.size();\n+       typedef typename _Ta::value_type _Value_type;\n+       _Value_type __r = __s == 0 ? _Value_type() : __a[0];\n+       for (size_t __i = 1; __i < __s; ++__i)\n+         {\n+           _Value_type __t = __a[__i];\n+           if (__t > __r)\n+             __r = __t;\n+         }\n+       return __r;\n+     }\n   \n   //\n   // Helper class _Array, first layer of valarray abstraction.\n@@ -348,92 +359,110 @@ namespace std\n   //\n     \n   template<typename _Tp>\n-  struct _Array\n-  {\n-    explicit _Array (size_t);\n-    explicit _Array (_Tp* const __restrict__);\n-    explicit _Array (const valarray<_Tp>&);\n-    _Array (const _Tp* __restrict__, size_t);\n-    \n-    _Tp* begin () const;\n-    \n-    _Tp* const __restrict__ _M_data;\n-  };\n+     struct _Array\n+     {\n+       explicit _Array (size_t);\n+       explicit _Array (_Tp* const __restrict__);\n+       explicit _Array (const valarray<_Tp>&);\n+       _Array (const _Tp* __restrict__, size_t);\n+\n+       _Tp* begin () const;\n+\n+       _Tp* const __restrict__ _M_data;\n+     };\n   \n   template<typename _Tp>\n-  inline void\n-  __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n-  { __valarray_fill (__a._M_data, __n, __t); }\n+     inline void\n+     __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n+     { __valarray_fill (__a._M_data, __n, __t); }\n   \n   template<typename _Tp>\n-  inline void\n-  __valarray_fill (_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n-  { __valarray_fill (__a._M_data, __n, __s, __t); }\n+     inline void\n+     __valarray_fill (_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n+     { __valarray_fill (__a._M_data, __n, __s, __t); }\n   \n   template<typename _Tp>\n-  inline void\n-  __valarray_fill (_Array<_Tp> __a, _Array<size_t> __i, \n-                   size_t __n, const _Tp& __t)\n-  { __valarray_fill (__a._M_data, __i._M_data, __n, __t); }\n+     inline void\n+     __valarray_fill (_Array<_Tp> __a, _Array<size_t> __i, \n+                      size_t __n, const _Tp& __t)\n+     { __valarray_fill (__a._M_data, __i._M_data, __n, __t); }\n \n+  // Copy a plain array __a[<__n>] into a play array __b[<>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\n-  { __valarray_copy (__a._M_data, __n, __b._M_data); }\n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\n+     { __valarray_copy(__a._M_data, __n, __b._M_data); }\n   \n+  // Copy strided array __a[<__n : __s>] in plain __b[<__n>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)\n-  { __valarray_copy(__a._M_data, __n, __s, __b._M_data); }\n-  \n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s, _Array<_Tp> __b)\n+     { __valarray_copy(__a._M_data, __n, __s, __b._M_data); }\n+\n+  // Copy a plain array  __a[<__n>] into a strided array __b[<__n : __s>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)\n-  { __valarray_copy (__a._M_data, __b._M_data, __n, __s); }\n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, _Array<_Tp> __b, size_t __n, size_t __s)\n+     { __valarray_copy(__a._M_data, __b._M_data, __n, __s); }\n \n+  // Copy strided array __src[<__n : __s1>] into another\n+  // strided array __dst[< : __s2>].  Their sizes must match.\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,\n-                  _Array<_Tp> __b, size_t __s2)\n-  { __valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }\n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, size_t __n, size_t __s1,\n+                     _Array<_Tp> __b, size_t __s2)\n+     { __valarray_copy(__a._M_data, __n, __s1, __b._M_data, __s2); }\n \n   \n+  // Copy an indexed array __a[__i[<__n>]] in plain array __b[<__n>]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (_Array<_Tp> __a, _Array<size_t> __i, \n-                   _Array<_Tp> __b, size_t __n)\n-  { __valarray_copy (__a._M_data, __i._M_data, __b._M_data, __n); }\n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i, \n+                      _Array<_Tp> __b, size_t __n)\n+     { __valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }\n   \n+  // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n-  inline void\n-  __valarray_copy (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, \n-                   _Array<size_t> __i)\n-  { __valarray_copy (__a._M_data, __n, __b._M_data, __i._M_data); }\n+     inline void\n+     __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b, \n+                      _Array<size_t> __i)\n+     { __valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }\n+\n+  // Copy the __n first elements of an indexed array __src[<__i>] into\n+  // another indexed array __dst[<__j>].\n+  template<typename _Tp>\n+     inline void\n+     __valarray_copy(_Array<_Tp> __src, size_t __n, _Array<size_t> __i,\n+                     _Array<_Tp> __dst, _Array<size_t> __j)\n+     {\n+       __valarray_copy(__src._M_data, __n, __i._M_data,\n+                       __dst._M_data, __j._M_data);\n+     }\n \n   template<typename _Tp>\n-  inline\n-  _Array<_Tp>::_Array (size_t __n)\n-    : _M_data(__valarray_get_storage<_Tp>(__n))\n-  { __valarray_default_construct(_M_data, _M_data + __n); }\n+     inline\n+     _Array<_Tp>::_Array (size_t __n)\n+       : _M_data(__valarray_get_storage<_Tp>(__n))\n+     { __valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n-  inline\n-  _Array<_Tp>::_Array (_Tp* const __restrict__ __p) : _M_data (__p) {}\n+     inline\n+     _Array<_Tp>::_Array (_Tp* const __restrict__ __p) : _M_data (__p) {}\n   \n   template<typename _Tp>\n-  inline _Array<_Tp>::_Array (const valarray<_Tp>& __v) \n-      : _M_data (__v._M_data) {}\n+     inline _Array<_Tp>::_Array (const valarray<_Tp>& __v) \n+         : _M_data (__v._M_data) {}\n   \n   template<typename _Tp>\n-  inline\n-  _Array<_Tp>::_Array (const _Tp* __restrict__ __b, size_t __s) \n-    : _M_data(__valarray_get_storage<_Tp>(__s))\n-  { __valarray_copy_construct(__b, __s, _M_data); }\n+     inline\n+     _Array<_Tp>::_Array (const _Tp* __restrict__ __b, size_t __s) \n+       : _M_data(__valarray_get_storage<_Tp>(__s))\n+     { __valarray_copy_construct(__b, __s, _M_data); }\n \n   template<typename _Tp>\n-  inline _Tp*\n-  _Array<_Tp>::begin () const\n-  { return _M_data; }\n+     inline _Tp*\n+     _Array<_Tp>::begin () const\n+     { return _M_data; }\n \n #define _DEFINE_ARRAY_FUNCTION(_Op, _Name)\t\t\t\t\\\n template<typename _Tp>\t\t\t\t\t\t\t\\\n@@ -569,16 +598,16 @@ _Array_augmented_##_Name (_Array<_Tp> __a, _Array<bool> __m,\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-_DEFINE_ARRAY_FUNCTION(+, plus)\n-_DEFINE_ARRAY_FUNCTION(-, minus)\n-_DEFINE_ARRAY_FUNCTION(*, multiplies)\n-_DEFINE_ARRAY_FUNCTION(/, divides)\n-_DEFINE_ARRAY_FUNCTION(%, modulus)\n-_DEFINE_ARRAY_FUNCTION(^, xor)\n-_DEFINE_ARRAY_FUNCTION(|, or)\n-_DEFINE_ARRAY_FUNCTION(&, and)    \n-_DEFINE_ARRAY_FUNCTION(<<, shift_left)\n-_DEFINE_ARRAY_FUNCTION(>>, shift_right)\n+   _DEFINE_ARRAY_FUNCTION(+, plus)\n+   _DEFINE_ARRAY_FUNCTION(-, minus)\n+   _DEFINE_ARRAY_FUNCTION(*, multiplies)\n+   _DEFINE_ARRAY_FUNCTION(/, divides)\n+   _DEFINE_ARRAY_FUNCTION(%, modulus)\n+   _DEFINE_ARRAY_FUNCTION(^, xor)\n+   _DEFINE_ARRAY_FUNCTION(|, or)\n+   _DEFINE_ARRAY_FUNCTION(&, and)    \n+   _DEFINE_ARRAY_FUNCTION(<<, shift_left)\n+   _DEFINE_ARRAY_FUNCTION(>>, shift_right)\n \n #undef _DEFINE_VALARRAY_FUNCTION    \n "}]}