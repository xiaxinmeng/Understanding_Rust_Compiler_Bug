{"sha": "fc7d0afb9c70f466189c433962bab41a84765b0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM3ZDBhZmI5YzcwZjQ2NjE4OWM0MzM5NjJiYWI0MWE4NDc2NWIwZg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-04-27T17:34:11Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-04-27T17:34:11Z"}, "message": "re PR fortran/59678 ([F03] Segfault on equalizing variables of a complex derived type)\n\ngcc/fortran\n2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n\n        PR fortran/59678\n        PR fortran/65841\n        * trans-array.c (duplicate_allocatable): Fixed deep copy of\n        allocatable components, which are liable for copy only, when\n        they are allocated.\n        (gfc_duplicate_allocatable): Add deep-copy code into if\n        component allocated block. Needed interface change for that.\n        (gfc_copy_allocatable_data): Supplying NULL_TREE for code to\n        add into if-block for checking whether a component was\n        allocated.\n        (gfc_duplicate_allocatable_nocopy): Likewise.\n        (structure_alloc_comps): Likewise.\n        * trans-array.h: Likewise.\n        * trans-expr.c (gfc_trans_alloc_subarray_assign): Likewise.\n        * trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n\ngcc/testsuite\n2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n\n        PR fortran/59678\n        PR fortran/65841\n        * gfortran.dg/alloc_comp_deep_copy_1.f03: New test.\n        * gfortran.dg/alloc_comp_deep_copy_2.f03: New test.\n\nFrom-SVN: r222477", "tree": {"sha": "8a4260da5d8939c246372d739e6e13568877622d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4260da5d8939c246372d739e6e13568877622d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc7d0afb9c70f466189c433962bab41a84765b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7d0afb9c70f466189c433962bab41a84765b0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7d0afb9c70f466189c433962bab41a84765b0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7d0afb9c70f466189c433962bab41a84765b0f/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16d710b164529c81929bcb8bb55eea1b758b070e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d710b164529c81929bcb8bb55eea1b758b070e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d710b164529c81929bcb8bb55eea1b758b070e"}], "stats": {"total": 426, "additions": 383, "deletions": 43}, "files": [{"sha": "f6dbc36b2b7f21add230be1128bb409d270f7434", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -1,3 +1,21 @@\n+2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/59678\n+\tPR fortran/65841\n+\t* trans-array.c (duplicate_allocatable): Fixed deep copy of\n+\tallocatable components, which are liable for copy only, when\n+\tthey are allocated.\n+\t(gfc_duplicate_allocatable): Add deep-copy code into if\n+\tcomponent allocated block. Needed interface change for that.\n+\t(gfc_copy_allocatable_data): Supplying NULL_TREE for code to\n+\tadd into if-block for checking whether a component was\n+\tallocated.\n+\t(gfc_duplicate_allocatable_nocopy): Likewise.\n+\t(structure_alloc_comps): Likewise.\n+\t* trans-array.h: Likewise.\n+\t* trans-expr.c (gfc_trans_alloc_subarray_assign): Likewise.\n+\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n+\n 2015-04-23  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/60322"}, {"sha": "a17f4314d47c0119fc59b674063edb753848e78b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -7523,7 +7523,8 @@ gfc_full_array_size (stmtblock_t *block, tree decl, int rank)\n \n static tree\n duplicate_allocatable (tree dest, tree src, tree type, int rank,\n-\t\t       bool no_malloc, bool no_memcpy, tree str_sz)\n+\t\t       bool no_malloc, bool no_memcpy, tree str_sz,\n+\t\t       tree add_when_allocated)\n {\n   tree tmp;\n   tree size;\n@@ -7603,6 +7604,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \t}\n     }\n \n+  gfc_add_expr_to_block (&block, add_when_allocated);\n   tmp = gfc_finish_block (&block);\n \n   /* Null the destination if the source is null; otherwise do\n@@ -7622,10 +7624,11 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n /* Allocate dest to the same size as src, and copy data src -> dest.  */\n \n tree\n-gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n+gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank,\n+\t\t\t   tree add_when_allocated)\n {\n   return duplicate_allocatable (dest, src, type, rank, false, false,\n-\t\t\t\tNULL_TREE);\n+\t\t\t\tNULL_TREE, add_when_allocated);\n }\n \n \n@@ -7635,15 +7638,16 @@ tree\n gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)\n {\n   return duplicate_allocatable (dest, src, type, rank, true, false,\n-\t\t\t\tNULL_TREE);\n+\t\t\t\tNULL_TREE, NULL_TREE);\n }\n \n /* Allocate dest to the same size as src, but don't copy anything.  */\n \n tree\n gfc_duplicate_allocatable_nocopy (tree dest, tree src, tree type, int rank)\n {\n-  return duplicate_allocatable (dest, src, type, rank, false, true, NULL_TREE);\n+  return duplicate_allocatable (dest, src, type, rank, false, true,\n+\t\t\t\tNULL_TREE, NULL_TREE);\n }\n \n \n@@ -7675,27 +7679,32 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   tree ctype;\n   tree vref, dref;\n   tree null_cond = NULL_TREE;\n+  tree add_when_allocated;\n   bool called_dealloc_with_status;\n \n   gfc_init_block (&fnblock);\n \n   decl_type = TREE_TYPE (decl);\n \n-  if ((POINTER_TYPE_P (decl_type) && rank != 0)\n+  if ((POINTER_TYPE_P (decl_type))\n \t|| (TREE_CODE (decl_type) == REFERENCE_TYPE && rank == 0))\n-    decl = build_fold_indirect_ref_loc (input_location, decl);\n+    {\n+      decl = build_fold_indirect_ref_loc (input_location, decl);\n+      /* Deref dest in sync with decl, but only when it is not NULL.  */\n+      if (dest)\n+\tdest = build_fold_indirect_ref_loc (input_location, dest);\n+    }\n \n-  /* Just in case in gets dereferenced.  */\n+  /* Just in case it gets dereferenced.  */\n   decl_type = TREE_TYPE (decl);\n \n-  /* If this an array of derived types with allocatable components\n+  /* If this is an array of derived types with allocatable components\n      build a loop and recursively call this function.  */\n   if (TREE_CODE (decl_type) == ARRAY_TYPE\n       || (GFC_DESCRIPTOR_TYPE_P (decl_type) && rank != 0))\n     {\n       tmp = gfc_conv_array_data (decl);\n-      var = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t     tmp);\n+      var = build_fold_indirect_ref_loc (input_location, tmp);\n \n       /* Get the number of elements - 1 and set the counter.  */\n       if (GFC_DESCRIPTOR_TYPE_P (decl_type))\n@@ -7716,7 +7725,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       else\n \t{\n \t  /*  Otherwise use the TYPE_DOMAIN information.  */\n-\t  tmp =  array_type_nelts (decl_type);\n+\t  tmp = array_type_nelts (decl_type);\n \t  tmp = fold_convert (gfc_array_index_type, tmp);\n \t}\n \n@@ -7729,19 +7738,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n       vref = gfc_build_array_ref (var, index, NULL);\n \n-      if (purpose == COPY_ALLOC_COMP)\n-        {\n-\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))\n-\t    {\n-\t      tmp = gfc_duplicate_allocatable (dest, decl, decl_type, rank);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t    }\n-\t  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t gfc_conv_array_data (dest));\n-\t  dref = gfc_build_array_ref (tmp, index, NULL);\n-\t  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);\n-\t}\n-      else if (purpose == COPY_ONLY_ALLOC_COMP)\n+      if (purpose == COPY_ALLOC_COMP || purpose == COPY_ONLY_ALLOC_COMP)\n         {\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t gfc_conv_array_data (dest));\n@@ -7764,7 +7761,17 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       gfc_add_block_to_block (&fnblock, &loop.pre);\n \n       tmp = gfc_finish_block (&fnblock);\n-      if (null_cond != NULL_TREE)\n+      /* When copying allocateable components, the above implements the\n+\t deep copy.  Nevertheless is a deep copy only allowed, when the current\n+\t component is allocated, for which code will be generated in\n+\t gfc_duplicate_allocatable (), where the deep copy code is just added\n+\t into the if's body, by adding tmp (the deep copy code) as last\n+\t argument to gfc_duplicate_allocatable ().  */\n+      if (purpose == COPY_ALLOC_COMP\n+\t  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))\n+\ttmp = gfc_duplicate_allocatable (dest, decl, decl_type, rank,\n+\t\t\t\t\t tmp);\n+      else if (null_cond != NULL_TREE)\n \ttmp = build3_v (COND_EXPR, null_cond, tmp,\n \t\t\tbuild_empty_stmt (input_location));\n \n@@ -8049,6 +8056,22 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      continue;\n \t    }\n \n+\t  /* To implement guarded deep copy, i.e., deep copy only allocatable\n+\t     components that are really allocated, the deep copy code has to\n+\t     be generated first and then added to the if-block in\n+\t     gfc_duplicate_allocatable ().  */\n+\t  if (cmp_has_alloc_comps)\n+\t    {\n+\t      rank = c->as ? c->as->rank : 0;\n+\t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n+\t      gfc_add_modify (&fnblock, dcmp, tmp);\n+\t      add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n+\t\t\t\t\t\t\t  comp, dcmp,\n+\t\t\t\t\t\t\t  rank, purpose);\n+\t    }\n+\t  else\n+\t    add_when_allocated = NULL_TREE;\n+\n \t  if (gfc_deferred_strlen (c, &tmp))\n \t    {\n \t      tree len, size;\n@@ -8063,30 +8086,29 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t     TREE_TYPE (len), len, tmp);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t      size = size_of_string_in_bytes (c->ts.kind, len);\n+\t      /* This component can not have allocatable components,\n+\t\t therefore add_when_allocated of duplicate_allocatable ()\n+\t\t is always NULL.  */\n \t      tmp = duplicate_allocatable (dcmp, comp, ctype, rank,\n-\t\t\t\t\t   false, false, size);\n+\t\t\t\t\t   false, false, size, NULL_TREE);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable && !c->attr.proc_pointer\n-\t\t   && !cmp_has_alloc_comps)\n+\t\t   && (!(cmp_has_alloc_comps && c->as)\n+\t\t       || c->attr.codimension))\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      if (c->attr.codimension)\n \t\ttmp = gfc_copy_allocatable_data (dcmp, comp, ctype, rank);\n \t      else\n-\t\ttmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank);\n+\t\ttmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank,\n+\t\t\t\t\t\t add_when_allocated);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n+\t  else\n+\t    if (cmp_has_alloc_comps)\n+\t      gfc_add_expr_to_block (&fnblock, add_when_allocated);\n \n-          if (cmp_has_alloc_comps)\n-\t    {\n-\t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n-\t      gfc_add_modify (&fnblock, dcmp, tmp);\n-\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n-\t\t\t\t\t   rank, purpose);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t    }\n \t  break;\n \n \tdefault:"}, {"sha": "76bad2a199a854f6a655fa7c7e666f9c880758da", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -46,7 +46,7 @@ tree gfc_trans_dealloc_allocated (tree, bool, gfc_expr *);\n \n tree gfc_full_array_size (stmtblock_t *, tree, int);\n \n-tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);\n+tree gfc_duplicate_allocatable (tree, tree, tree, int, tree);\n \n tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);\n "}, {"sha": "9c5ce7d9df0fd19ab6752431f143d3352a9c0c69", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -6713,13 +6713,13 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \t{\n \t  tmp = TREE_TYPE (dest);\n \t  tmp = gfc_duplicate_allocatable (dest, se.expr,\n-\t\t\t\t\t   tmp, expr->rank);\n+\t\t\t\t\t   tmp, expr->rank, NULL_TREE);\n \t}\n     }\n   else\n     tmp = gfc_duplicate_allocatable (dest, se.expr,\n \t\t\t\t     TREE_TYPE(cm->backend_decl),\n-\t\t\t\t     cm->as->rank);\n+\t\t\t\t     cm->as->rank, NULL_TREE);\n \n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &se.post);"}, {"sha": "dd19a9cec213ab9b758757c91a54ef51b070d7c4", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -391,9 +391,11 @@ gfc_walk_alloc_comps (tree decl, tree dest, tree var,\n \t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n \t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n \t    tem = gfc_duplicate_allocatable (destf, declf, ftype,\n-\t\t\t\t\t     GFC_TYPE_ARRAY_RANK (ftype));\n+\t\t\t\t\t     GFC_TYPE_ARRAY_RANK (ftype),\n+\t\t\t\t\t     NULL_TREE);\n \t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n-\t    tem = gfc_duplicate_allocatable (destf, declf, ftype, 0);\n+\t    tem = gfc_duplicate_allocatable (destf, declf, ftype, 0,\n+\t\t\t\t\t     NULL_TREE);\n \t  break;\n \t}\n       if (tem)"}, {"sha": "fb5618116d0ae1eb32b2832f5a09eb19ae745df7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -1,3 +1,10 @@\n+2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/59678\n+\tPR fortran/65841\n+\t* gfortran.dg/alloc_comp_deep_copy_1.f03: New test.\n+\t* gfortran.dg/alloc_comp_deep_copy_2.f03: New test.\n+\n 2015-04-27  Caroline Tice  <cmtice@google.com>\n \n \t* gcc.dg/tree-prof/cold_partition_label.c (main): Check for cold"}, {"sha": "df42b342b6736909e49d07304c1bbf1d05c1c343", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_1.f03", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_1.f03?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -0,0 +1,270 @@\n+! { dg-do run }\n+!\n+! Check fix for correctly deep copying allocatable components.\n+! PR fortran/59678\n+! Contributed by Andre Vehreschild  <vehre@gmx.de>\n+!\n+program alloc_comp_copy_test\n+\n+  type InnerT\n+    integer :: ii\n+    integer, allocatable :: ai\n+    integer, allocatable :: v(:)\n+  end type InnerT\n+\n+  type T\n+    integer :: i\n+    integer, allocatable :: a_i\n+    type(InnerT), allocatable :: it\n+    type(InnerT), allocatable :: vec(:)\n+  end type T\n+\n+  type(T) :: o1, o2\n+  class(T), allocatable :: o3, o4\n+  o1%i = 42\n+\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (allocated(o2%a_i)) call abort()\n+  if (allocated(o2%it)) call abort()\n+  if (allocated(o2%vec)) call abort()\n+\n+  allocate (o1%a_i, source=2)\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (allocated(o2%it)) call abort()\n+  if (allocated(o2%vec)) call abort()\n+\n+  allocate (o1%it)\n+  o1%it%ii = 3\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (allocated(o2%it%ai)) call abort()\n+  if (allocated(o2%it%v)) call abort()\n+  if (allocated(o2%vec)) call abort()\n+\n+  allocate (o1%it%ai)\n+  o1%it%ai = 4\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (.not. allocated(o2%it%ai)) call abort()\n+  if (o2%it%ai /= 4) call abort()\n+  if (allocated(o2%it%v)) call abort()\n+  if (allocated(o2%vec)) call abort()\n+\n+  allocate (o1%it%v(3), source= 5)\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (.not. allocated(o2%it%ai)) call abort()\n+  if (o2%it%ai /= 4) call abort()\n+  if (.not. allocated(o2%it%v)) call abort()\n+  if (any (o2%it%v /= 5) .or. size (o2%it%v) /= 3) call abort()\n+  if (allocated(o2%vec)) call abort()\n+\n+  allocate (o1%vec(2))\n+  o1%vec(:)%ii = 6\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (.not. allocated(o2%it%ai)) call abort()\n+  if (o2%it%ai /= 4) call abort()\n+  if (.not. allocated(o2%it%v)) call abort()\n+  if (size (o2%it%v) /= 3) call abort()\n+  if (any (o2%it%v /= 5)) call abort()\n+  if (.not. allocated(o2%vec)) call abort()\n+  if (size(o2%vec) /= 2) call abort()\n+  if (any(o2%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o2%vec(1)%ai) .or. allocated(o2%vec(2)%ai)) call abort()\n+  if (allocated(o2%vec(1)%v) .or. allocated(o2%vec(2)%v)) call abort()\n+\n+  allocate (o1%vec(2)%ai)\n+  o1%vec(2)%ai = 7\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (.not. allocated(o2%it%ai)) call abort()\n+  if (o2%it%ai /= 4) call abort()\n+  if (.not. allocated(o2%it%v)) call abort()\n+  if (size (o2%it%v) /= 3) call abort()\n+  if (any (o2%it%v /= 5)) call abort()\n+  if (.not. allocated(o2%vec)) call abort()\n+  if (size(o2%vec) /= 2) call abort()\n+  if (any(o2%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o2%vec(1)%ai)) call abort()\n+  if (.not. allocated(o2%vec(2)%ai)) call abort()\n+  if (o2%vec(2)%ai /= 7) call abort()\n+  if (allocated(o2%vec(1)%v) .or. allocated(o2%vec(2)%v)) call abort()\n+\n+  allocate (o1%vec(1)%v(3))\n+  o1%vec(1)%v = [8, 9, 10]\n+  call copyO(o1, o2)\n+  if (o2%i /= 42) call abort ()\n+  if (.not. allocated(o2%a_i)) call abort()\n+  if (o2%a_i /= 2) call abort()\n+  if (.not. allocated(o2%it)) call abort()\n+  if (o2%it%ii /= 3) call abort()\n+  if (.not. allocated(o2%it%ai)) call abort()\n+  if (o2%it%ai /= 4) call abort()\n+  if (.not. allocated(o2%it%v)) call abort()\n+  if (size (o2%it%v) /= 3) call abort()\n+  if (any (o2%it%v /= 5)) call abort()\n+  if (.not. allocated(o2%vec)) call abort()\n+  if (size(o2%vec) /= 2) call abort()\n+  if (any(o2%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o2%vec(1)%ai)) call abort()\n+  if (.not. allocated(o2%vec(2)%ai)) call abort()\n+  if (o2%vec(2)%ai /= 7) call abort()\n+  if (.not. allocated(o2%vec(1)%v)) call abort()\n+  if (any (o2%vec(1)%v /= [8,9,10])) call abort()\n+  if (allocated(o2%vec(2)%v)) call abort()\n+\n+  ! Now all the above for class objects.\n+  allocate (o3, o4)\n+  o3%i = 42\n+\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (allocated(o4%a_i)) call abort()\n+  if (allocated(o4%it)) call abort()\n+  if (allocated(o4%vec)) call abort()\n+\n+  allocate (o3%a_i, source=2)\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (allocated(o4%it)) call abort()\n+  if (allocated(o4%vec)) call abort()\n+\n+  allocate (o3%it)\n+  o3%it%ii = 3\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (allocated(o4%it%ai)) call abort()\n+  if (allocated(o4%it%v)) call abort()\n+  if (allocated(o4%vec)) call abort()\n+\n+  allocate (o3%it%ai)\n+  o3%it%ai = 4\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (.not. allocated(o4%it%ai)) call abort()\n+  if (o4%it%ai /= 4) call abort()\n+  if (allocated(o4%it%v)) call abort()\n+  if (allocated(o4%vec)) call abort()\n+\n+  allocate (o3%it%v(3), source= 5)\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (.not. allocated(o4%it%ai)) call abort()\n+  if (o4%it%ai /= 4) call abort()\n+  if (.not. allocated(o4%it%v)) call abort()\n+  if (any (o4%it%v /= 5) .or. size (o4%it%v) /= 3) call abort()\n+  if (allocated(o4%vec)) call abort()\n+\n+  allocate (o3%vec(2))\n+  o3%vec(:)%ii = 6\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (.not. allocated(o4%it%ai)) call abort()\n+  if (o4%it%ai /= 4) call abort()\n+  if (.not. allocated(o4%it%v)) call abort()\n+  if (size (o4%it%v) /= 3) call abort()\n+  if (any (o4%it%v /= 5)) call abort()\n+  if (.not. allocated(o4%vec)) call abort()\n+  if (size(o4%vec) /= 2) call abort()\n+  if (any(o4%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o4%vec(1)%ai) .or. allocated(o4%vec(2)%ai)) call abort()\n+  if (allocated(o4%vec(1)%v) .or. allocated(o4%vec(2)%v)) call abort()\n+\n+  allocate (o3%vec(2)%ai)\n+  o3%vec(2)%ai = 7\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (.not. allocated(o4%it%ai)) call abort()\n+  if (o4%it%ai /= 4) call abort()\n+  if (.not. allocated(o4%it%v)) call abort()\n+  if (size (o4%it%v) /= 3) call abort()\n+  if (any (o4%it%v /= 5)) call abort()\n+  if (.not. allocated(o4%vec)) call abort()\n+  if (size(o4%vec) /= 2) call abort()\n+  if (any(o4%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o4%vec(1)%ai)) call abort()\n+  if (.not. allocated(o4%vec(2)%ai)) call abort()\n+  if (o4%vec(2)%ai /= 7) call abort()\n+  if (allocated(o4%vec(1)%v) .or. allocated(o4%vec(2)%v)) call abort()\n+\n+  allocate (o3%vec(1)%v(3))\n+  o3%vec(1)%v = [8, 9, 10]\n+  call copyO(o3, o4)\n+  if (o4%i /= 42) call abort ()\n+  if (.not. allocated(o4%a_i)) call abort()\n+  if (o4%a_i /= 2) call abort()\n+  if (.not. allocated(o4%it)) call abort()\n+  if (o4%it%ii /= 3) call abort()\n+  if (.not. allocated(o4%it%ai)) call abort()\n+  if (o4%it%ai /= 4) call abort()\n+  if (.not. allocated(o4%it%v)) call abort()\n+  if (size (o4%it%v) /= 3) call abort()\n+  if (any (o4%it%v /= 5)) call abort()\n+  if (.not. allocated(o4%vec)) call abort()\n+  if (size(o4%vec) /= 2) call abort()\n+  if (any(o4%vec(:)%ii /= 6)) call abort()\n+  if (allocated(o4%vec(1)%ai)) call abort()\n+  if (.not. allocated(o4%vec(2)%ai)) call abort()\n+  if (o4%vec(2)%ai /= 7) call abort()\n+  if (.not. allocated(o4%vec(1)%v)) call abort()\n+  if (any (o4%vec(1)%v /= [8,9,10])) call abort()\n+  if (allocated(o4%vec(2)%v)) call abort()\n+\n+contains\n+\n+  subroutine copyO(src, dst)\n+    type(T), intent(in) :: src\n+    type(T), intent(out) :: dst\n+\n+    dst = src\n+  end subroutine copyO\n+\n+end program alloc_comp_copy_test\n+"}, {"sha": "582a2b8e3e1089d9e7bd47ebdcba8008a0efa225", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_deep_copy_2.f03", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7d0afb9c70f466189c433962bab41a84765b0f/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_deep_copy_2.f03?ref=fc7d0afb9c70f466189c433962bab41a84765b0f", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+!\n+! Testcase for PR fortran/65841\n+! Contributed by Damian Rousson\n+!\n+program alloc_comp_deep_copy_2\n+  type a\n+    real, allocatable :: f\n+  end type\n+  type b\n+    type(a), allocatable :: g\n+  end type\n+\n+  type(b) c,d\n+\n+  c%g=a(1.) \n+  d=c\n+  if (d%g%f /= 1.0) call abort()\n+  d%g%f = 2.0\n+  if (d%g%f /= 2.0) call abort()\n+end program"}]}