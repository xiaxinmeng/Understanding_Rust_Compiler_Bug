{"sha": "7f251deef07f33de59e7e934ffb66c715ae95231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YyNTFkZWVmMDdmMzNkZTU5ZTdlOTM0ZmZiNjZjNzE1YWU5NTIzMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@cygnus.com", "date": "2000-05-20T23:01:00Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2000-05-20T23:01:00Z"}, "message": "final.c (split_double): Right shift of negative values is not portable.\n\n* final.c (split_double): Right shift of negative values is not\nportable.\n\nFrom-SVN: r34061", "tree": {"sha": "ec72c53866a5ded4a8faae1b4bbf1939590ae8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec72c53866a5ded4a8faae1b4bbf1939590ae8c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f251deef07f33de59e7e934ffb66c715ae95231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f251deef07f33de59e7e934ffb66c715ae95231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f251deef07f33de59e7e934ffb66c715ae95231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f251deef07f33de59e7e934ffb66c715ae95231/comments", "author": null, "committer": null, "parents": [{"sha": "6b48deee6ece109f4f4e4e2659f038472b9220c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b48deee6ece109f4f4e4e2659f038472b9220c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b48deee6ece109f4f4e4e2659f038472b9220c8"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "a1a00b16193a101ded336e4a7f78a07d9adb8481", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f251deef07f33de59e7e934ffb66c715ae95231/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f251deef07f33de59e7e934ffb66c715ae95231/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f251deef07f33de59e7e934ffb66c715ae95231", "patch": "@@ -1,5 +1,8 @@\n 2000-05-20  Alexandre Oliva  <aoliva@cygnus.com>\n \n+\t* final.c (split_double): Right shift of negative values is not\n+\tportable.\n+\n \t* ifcvt.c (if_convert): Scan and kill dead code.\n \n \t* emit-rtl.c (unshare_all_rtl): Store the copied rtx."}, {"sha": "2ab018b85986821e1caa9e3acff1e0882ef8afe5", "filename": "gcc/final.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f251deef07f33de59e7e934ffb66c715ae95231/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f251deef07f33de59e7e934ffb66c715ae95231/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=7f251deef07f33de59e7e934ffb66c715ae95231", "patch": "@@ -3923,25 +3923,50 @@ split_double (value, first, second)\n \t  /* In this case the CONST_INT holds both target words.\n \t     Extract the bits from it into two word-sized pieces.\n \t     Sign extend each half to HOST_WIDE_INT.  */\n-\t  rtx low, high;\n-\t  /* On machines where HOST_BITS_PER_WIDE_INT == BITS_PER_WORD\n-\t     the shift below will cause a compiler warning, even though\n-\t     this code won't be executed.  So put the shift amounts in\n-\t     variables to avoid the warning.  */\n-\t  int rshift = HOST_BITS_PER_WIDE_INT - BITS_PER_WORD;\n-\t  int lshift = HOST_BITS_PER_WIDE_INT - 2 * BITS_PER_WORD;\n-\n-\t  low = GEN_INT ((INTVAL (value) << rshift) >> rshift);\n-\t  high = GEN_INT ((INTVAL (value) << lshift) >> rshift);\n+\t  unsigned HOST_WIDE_INT low, high;\n+\t  unsigned HOST_WIDE_INT mask, sign_bit, sign_extend;\n+\n+\t  /* Set sign_bit to the most significant bit of a word.  */\n+\t  sign_bit = 1;\n+\t  sign_bit <<= BITS_PER_WORD - 1;\n+\n+\t  /* Set mask so that all bits of the word are set.  We could\n+\t     have used 1 << BITS_PER_WORD instead of basing the\n+\t     calculation on sign_bit.  However, on machines where\n+\t     HOST_BITS_PER_WIDE_INT == BITS_PER_WORD, it could cause a\n+\t     compiler warning, even though the code would never be\n+\t     executed.  */\n+\t  mask = sign_bit << 1;\n+\t  mask--;\n+\n+\t  /* Set sign_extend as any remaining bits.  */\n+\t  sign_extend = ~mask;\n+\t  \n+\t  /* Pick the lower word and sign-extend it.  */\n+\t  low = INTVAL (value);\n+\t  low &= mask;\n+\t  if (low & sign_bit)\n+\t    low |= sign_extend;\n+\n+\t  /* Pick the higher word, shifted to the least significant\n+\t     bits, and sign-extend it.  */\n+\t  high = INTVAL (value);\n+\t  high >>= BITS_PER_WORD - 1;\n+\t  high >>= 1;\n+\t  high &= mask;\n+\t  if (high & sign_bit)\n+\t    high |= sign_extend;\n+\n+\t  /* Store the words in the target machine order.  */\n \t  if (WORDS_BIG_ENDIAN)\n \t    {\n-\t      *first = high;\n-\t      *second = low;\n+\t      *first = GEN_INT (high);\n+\t      *second = GEN_INT (low);\n \t    }\n \t  else\n \t    {\n-\t      *first = low;\n-\t      *second = high;\n+\t      *first = GEN_INT (low);\n+\t      *second = GEN_INT (high);\n \t    }\n \t}\n       else\n@@ -4026,7 +4051,7 @@ split_double (value, first, second)\n       if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n \t   || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t  && ! flag_pretend_float)\n-      abort ();\n+\tabort ();\n \n       if (\n #ifdef HOST_WORDS_BIG_ENDIAN"}]}