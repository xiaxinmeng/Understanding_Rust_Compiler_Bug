{"sha": "c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4Y2Q1YmZmNjBmYTJhMGJkMzFmY2RiZDJmMDc1OGEzMjYzOWMwOQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-11-24T00:51:48Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-11-24T00:51:48Z"}, "message": "flag-types.h (struct visibility_flags): Don't declare here.\n\n\t* flag-types.h (struct visibility_flags): Don't declare here.\n\t* flags.h (strip_off_ending, fast_math_flags_set_p,\n\tfast_math_flags_struct_set_p): Declare here.\n\t(visibility_options): Don't declare here.\n\t* opts-common.c (option_enabled, get_option_state): Move from\n\topts.c.\n\t* opts-global.c: Include diagnostic.h instead of\n\tdiagnostic-core.h.  Include tree.h, langhooks.h, lto-streamer.h\n\tand toplev.h.\n\t(const_char_p, ignored_options, in_fnames, num_in_fnames,\n\twrite_langs, complain_wrong_lang, postpone_unknown_option_warning,\n\tprint_ignored_options, unknown_option_callback,\n\tpost_handling_callback, lang_handle_option, add_input_filename,\n\tread_cmdline_options, initial_lang_mask, init_options_once,\n\tdecode_cmdline_options_to_array_default_mask,\n\tset_default_handlers, decode_options): Move from opts.c.\n\t(print_ignored_options): Use warning_at instead of saving and\n\trestoring input_location.\n\t* opts.c: Include <signal.h> and <sys/resource.h>.  Include rtl.h\n\tinstead of expr.h.  Don't include langhooks.h, except.h or\n\tlto-streamer.h.  Add more comments on includes.\n\t(strip_off_ending, setup_core_dumping, decode_d_option): Move from\n\ttoplev.c.\n\t(visibility_options): Move to c-family/c-common.c.\n\t(const_char_p, ignored_options, in_fnames, num_in_fnames,\n\twrite_langs, complain_wrong_lang, postpone_unknown_option_warning,\n\tprint_ignored_options, unknown_option_callback,\n\tpost_handling_callback, lang_handle_option, add_input_filename,\n\tread_cmdline_options, initial_lang_mask, init_options_once,\n\tdecode_cmdline_options_to_array_default_mask,\n\tset_default_handlers, decode_options): Move to opts-global.c.\n\t(target_handle_option, default_options_optimization,\n\tfinish_options, common_handle_option): Remove static.\n\t(option_enabled, get_option_state): Move to opts-common.c.\n\t* opts.h (common_handle_option, target_handle_option,\n\tfinish_options, default_options_optimization): Declare.\n\t* toplev.c: Don't include <signal.h> or <sys/resource.h>.\n\t(setup_core_dumping, strip_off_ending, decode_d_option): Move to\n\topts.c.\n\t* toplev.h (strip_off_ending, decode_d_option,\n\tfast_math_flags_set_p, fast_math_flags_struct_set_p): Don't\n\tdeclare here.\n\t* Makefile.in (opts.o, opts-global.o): Update dependencies.\n\nc-family:\n\t* c-common.c (visibility_options): Move from ../opts.c.\n\t* c-common.h (struct visibility_flags, visibility_options):\n\tDeclare here.\n\t* c-opts.c (finish_options): Rename to c_finish_options.\n\t(c_common_init): Update call to finish_options.\n\nFrom-SVN: r167105", "tree": {"sha": "e78bd9fc9f3b4e8df779c5d10ba572a064b6c4cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e78bd9fc9f3b4e8df779c5d10ba572a064b6c4cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3862bc3a55766907dbd1518e9f153abb34eb6785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3862bc3a55766907dbd1518e9f153abb34eb6785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3862bc3a55766907dbd1518e9f153abb34eb6785"}], "stats": {"total": 1072, "additions": 572, "deletions": 500}, "files": [{"sha": "9b2206b11f9b0da2584b1189ac899517ab596cbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -1,3 +1,49 @@\n+2010-11-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* flag-types.h (struct visibility_flags): Don't declare here.\n+\t* flags.h (strip_off_ending, fast_math_flags_set_p,\n+\tfast_math_flags_struct_set_p): Declare here.\n+\t(visibility_options): Don't declare here.\n+\t* opts-common.c (option_enabled, get_option_state): Move from\n+\topts.c.\n+\t* opts-global.c: Include diagnostic.h instead of\n+\tdiagnostic-core.h.  Include tree.h, langhooks.h, lto-streamer.h\n+\tand toplev.h.\n+\t(const_char_p, ignored_options, in_fnames, num_in_fnames,\n+\twrite_langs, complain_wrong_lang, postpone_unknown_option_warning,\n+\tprint_ignored_options, unknown_option_callback,\n+\tpost_handling_callback, lang_handle_option, add_input_filename,\n+\tread_cmdline_options, initial_lang_mask, init_options_once,\n+\tdecode_cmdline_options_to_array_default_mask,\n+\tset_default_handlers, decode_options): Move from opts.c.\n+\t(print_ignored_options): Use warning_at instead of saving and\n+\trestoring input_location.\n+\t* opts.c: Include <signal.h> and <sys/resource.h>.  Include rtl.h\n+\tinstead of expr.h.  Don't include langhooks.h, except.h or\n+\tlto-streamer.h.  Add more comments on includes.\n+\t(strip_off_ending, setup_core_dumping, decode_d_option): Move from\n+\ttoplev.c.\n+\t(visibility_options): Move to c-family/c-common.c.\n+\t(const_char_p, ignored_options, in_fnames, num_in_fnames,\n+\twrite_langs, complain_wrong_lang, postpone_unknown_option_warning,\n+\tprint_ignored_options, unknown_option_callback,\n+\tpost_handling_callback, lang_handle_option, add_input_filename,\n+\tread_cmdline_options, initial_lang_mask, init_options_once,\n+\tdecode_cmdline_options_to_array_default_mask,\n+\tset_default_handlers, decode_options): Move to opts-global.c.\n+\t(target_handle_option, default_options_optimization,\n+\tfinish_options, common_handle_option): Remove static.\n+\t(option_enabled, get_option_state): Move to opts-common.c.\n+\t* opts.h (common_handle_option, target_handle_option,\n+\tfinish_options, default_options_optimization): Declare.\n+\t* toplev.c: Don't include <signal.h> or <sys/resource.h>.\n+\t(setup_core_dumping, strip_off_ending, decode_d_option): Move to\n+\topts.c.\n+\t* toplev.h (strip_off_ending, decode_d_option,\n+\tfast_math_flags_set_p, fast_math_flags_struct_set_p): Don't\n+\tdeclare here.\n+\t* Makefile.in (opts.o, opts-global.o): Update dependencies.\n+\n 2010-11-23  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \tPR driver/42690"}, {"sha": "fb914333c1769277f9ecfca7e543958c0caf90b6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -2824,13 +2824,14 @@ fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    version.h $(INPUT_H) intl.h $(DIAGNOSTIC_H) diagnostic.def\n opts.o : opts.c $(OPTS_H) $(OPTIONS_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TREE_H) $(TM_H) langhooks.h $(EXPR_H) \\\n-   $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n+   coretypes.h $(TREE_H) $(TM_H) $(RTL_H) \\\n+   $(DIAGNOSTIC_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n    $(FLAGS_H) $(PARAMS_H) $(DBGCNT_H) debug.h \\\n-   $(EXCEPT_H) $(LTO_STREAMER_H) opts-diagnostic.h\n+   opts-diagnostic.h\n opts-global.o : opts-global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(DIAGNOSTIC_CORE_H) $(OPTS_H) $(FLAGS_H) $(GGC_H) $(TM_H) $(RTL_H) \\\n-   output.h $(PLUGIN_H) $(TREE_PASS_H)\n+   $(DIAGNOSTIC_H) $(OPTS_H) $(FLAGS_H) $(GGC_H) $(TREE_H) langhooks.h \\\n+   $(TM_H) $(RTL_H) $(LTO_STREAMER_H) output.h $(PLUGIN_H) $(TOPLEV_H) \\\n+   $(TREE_PASS_H)\n opts-common.o : opts-common.c $(OPTS_H) $(FLAGS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h intl.h $(DIAGNOSTIC_H) $(TM_H)\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\"}, {"sha": "8ca7ba881979e8faf00e6d9a17a6dc72bbfdbb25", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -1,3 +1,11 @@\n+2010-11-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.c (visibility_options): Move from ../opts.c.\n+\t* c-common.h (struct visibility_flags, visibility_options):\n+\tDeclare here.\n+\t* c-opts.c (finish_options): Rename to c_finish_options.\n+\t(c_common_init): Update call to finish_options.\n+\n 2010-11-22  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/34033"}, {"sha": "21a6ad4366410c0f738deef8aa2f9c683832f392", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -304,6 +304,9 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n+/* Global visibility options.  */\n+struct visibility_flags visibility_options;\n+\n static tree c_fully_fold_internal (tree expr, bool, bool *, bool *);\n static tree check_case_value (tree);\n static bool check_case_bounds (tree, tree, tree *, tree *);"}, {"sha": "11b92fbfe875f14cfba62184ae0b9e2c99964036", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -660,6 +660,15 @@ extern bool done_lexing;\n #define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n   (!C_TYPE_FUNCTION_P (type))\n \n+struct visibility_flags\n+{\n+  unsigned inpragma : 1;\t/* True when in #pragma GCC visibility.  */\n+  unsigned inlines_hidden : 1;\t/* True when -finlineshidden in effect.  */\n+};\n+\n+/* Global visibility options.  */\n+extern struct visibility_flags visibility_options;\n+\n /* Attribute table common to the C front ends.  */\n extern const struct attribute_spec c_common_attribute_table[];\n extern const struct attribute_spec c_common_format_attribute_table[];"}, {"sha": "c5373060c6b6e29fdc04ac6273245279e6deb6bd", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -116,7 +116,7 @@ static void add_prefixed_path (const char *, size_t);\n static void push_command_line_include (void);\n static void cb_file_change (cpp_reader *, const struct line_map *);\n static void cb_dir_change (cpp_reader *, const char *);\n-static void finish_options (void);\n+static void c_finish_options (void);\n \n #ifndef STDC_0_IN_SYSTEM_HEADERS\n #define STDC_0_IN_SYSTEM_HEADERS 0\n@@ -1047,7 +1047,7 @@ c_common_init (void)\n \n   if (flag_preprocess_only)\n     {\n-      finish_options ();\n+      c_finish_options ();\n       preprocess_file (parse_in);\n       return false;\n     }\n@@ -1065,7 +1065,7 @@ c_common_parse_file (void)\n   i = 0;\n   for (;;)\n     {\n-      finish_options ();\n+      c_finish_options ();\n       pch_init ();\n       push_file_scope ();\n       c_parse_file ();\n@@ -1277,7 +1277,7 @@ add_prefixed_path (const char *suffix, size_t chain)\n \n /* Handle -D, -U, -A, -imacros, and the first -include.  */\n static void\n-finish_options (void)\n+c_finish_options (void)\n {\n   if (!cpp_opts->preprocessed)\n     {"}, {"sha": "307755a28548816920c8d5da22ffdc84c9a06262", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -106,12 +106,6 @@ enum symbol_visibility\n };\n #endif\n \n-struct visibility_flags\n-{\n-  unsigned inpragma : 1;\t/* True when in #pragma GCC visibility.  */\n-  unsigned inlines_hidden : 1;\t/* True when -finlineshidden in effect.  */\n-};\n-\n /* The algorithm used for the integrated register allocator (IRA).  */\n enum ira_algorithm\n {"}, {"sha": "47a93a9f8bdadef0d3ce7909feec653ab8b9eeda", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Names of debug_info_type, for error messages.  */\n extern const char *const debug_type_names[];\n \n+extern void strip_off_ending (char *, int);\n extern int base_of_path (const char *path, const char **base_out);\n extern void set_struct_debug_option (struct gcc_options *opts,\n \t\t\t\t     const char *value);\n@@ -40,16 +41,17 @@ extern void set_struct_debug_option (struct gcc_options *opts,\n    an actual variable not a macro.  */\n extern int flag_compare_debug;\n \n-/* Global visibility options.  */\n-extern struct visibility_flags visibility_options;\n-\n /* True if this is the LTO front end (lto1).  This is used to disable\n    gimple generation and lowering passes that are normally run on the\n    output of a front end.  These passes must be bypassed for lto since\n    they have already been done before the gimple was written.  */\n \n extern bool in_lto_p;\n \n+/* Return true iff flags are set as if -ffast-math.  */\n+extern bool fast_math_flags_set_p (const struct gcc_options *);\n+extern bool fast_math_flags_struct_set_p (struct cl_optimization *);\n+\n /* Used to set the level of -Wstrict-aliasing in OPTS, when no level\n    is specified.  The external way to set the default level is to use\n    -Wstrict-aliasing=level."}, {"sha": "9a574024d3720d36d776d0f0834839af4c574caa", "filename": "gcc/opts-common.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -994,6 +994,78 @@ option_flag_var (int opt_index, struct gcc_options *opts)\n   return (void *)(((char *) opts) + option->flag_var_offset);\n }\n \n+/* Return 1 if option OPT_IDX is enabled in OPTS, 0 if it is disabled,\n+   or -1 if it isn't a simple on-off switch.  */\n+\n+int\n+option_enabled (int opt_idx, void *opts)\n+{\n+  const struct cl_option *option = &(cl_options[opt_idx]);\n+  struct gcc_options *optsg = (struct gcc_options *) opts;\n+  void *flag_var = option_flag_var (opt_idx, optsg);\n+\n+  if (flag_var)\n+    switch (option->var_type)\n+      {\n+      case CLVC_BOOLEAN:\n+\treturn *(int *) flag_var != 0;\n+\n+      case CLVC_EQUAL:\n+\treturn *(int *) flag_var == option->var_value;\n+\n+      case CLVC_BIT_CLEAR:\n+\treturn (*(int *) flag_var & option->var_value) == 0;\n+\n+      case CLVC_BIT_SET:\n+\treturn (*(int *) flag_var & option->var_value) != 0;\n+\n+      case CLVC_STRING:\n+      case CLVC_DEFER:\n+\tbreak;\n+      }\n+  return -1;\n+}\n+\n+/* Fill STATE with the current state of option OPTION in OPTS.  Return\n+   true if there is some state to store.  */\n+\n+bool\n+get_option_state (struct gcc_options *opts, int option,\n+\t\t  struct cl_option_state *state)\n+{\n+  void *flag_var = option_flag_var (option, opts);\n+\n+  if (flag_var == 0)\n+    return false;\n+\n+  switch (cl_options[option].var_type)\n+    {\n+    case CLVC_BOOLEAN:\n+    case CLVC_EQUAL:\n+      state->data = flag_var;\n+      state->size = sizeof (int);\n+      break;\n+\n+    case CLVC_BIT_CLEAR:\n+    case CLVC_BIT_SET:\n+      state->ch = option_enabled (option, opts);\n+      state->data = &state->ch;\n+      state->size = 1;\n+      break;\n+\n+    case CLVC_STRING:\n+      state->data = *(const char **) flag_var;\n+      if (state->data == 0)\n+\tstate->data = \"\";\n+      state->size = strlen ((const char *) state->data) + 1;\n+      break;\n+\n+    case CLVC_DEFER:\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Set a warning option OPT_INDEX (language mask LANG_MASK, option\n    handlers HANDLERS) to have diagnostic kind KIND for option\n    structures OPTS and OPTS_SET and diagnostic context DC (possibly"}, {"sha": "3ed562d465f49d02dd2f898cc7a0dc1298433d73", "filename": "gcc/opts-global.c", "status": "modified", "additions": 301, "deletions": 1, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -22,16 +22,316 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n+#include \"diagnostic.h\"\n #include \"opts.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"tree.h\" /* Required by langhooks.h.  */\n+#include \"langhooks.h\"\n #include \"tm.h\" /* Required by rtl.h.  */\n #include \"rtl.h\"\n+#include \"lto-streamer.h\"\n #include \"output.h\"\n #include \"plugin.h\"\n+#include \"toplev.h\"\n #include \"tree-pass.h\"\n \n+typedef const char *const_char_p; /* For DEF_VEC_P.  */\n+DEF_VEC_P(const_char_p);\n+DEF_VEC_ALLOC_P(const_char_p,heap);\n+\n+static VEC(const_char_p,heap) *ignored_options;\n+\n+/* Input file names.  */\n+const char **in_fnames;\n+unsigned num_in_fnames;\n+\n+/* Return a malloced slash-separated list of languages in MASK.  */\n+\n+static char *\n+write_langs (unsigned int mask)\n+{\n+  unsigned int n = 0, len = 0;\n+  const char *lang_name;\n+  char *result;\n+\n+  for (n = 0; (lang_name = lang_names[n]) != 0; n++)\n+    if (mask & (1U << n))\n+      len += strlen (lang_name) + 1;\n+\n+  result = XNEWVEC (char, len);\n+  len = 0;\n+  for (n = 0; (lang_name = lang_names[n]) != 0; n++)\n+    if (mask & (1U << n))\n+      {\n+\tif (len)\n+\t  result[len++] = '/';\n+\tstrcpy (result + len, lang_name);\n+\tlen += strlen (lang_name);\n+      }\n+\n+  result[len] = 0;\n+\n+  return result;\n+}\n+\n+/* Complain that switch DECODED does not apply to this front end (mask\n+   LANG_MASK).  */\n+\n+static void\n+complain_wrong_lang (const struct cl_decoded_option *decoded,\n+\t\t     unsigned int lang_mask)\n+{\n+  const struct cl_option *option = &cl_options[decoded->opt_index];\n+  const char *text = decoded->orig_option_with_args_text;\n+  char *ok_langs = NULL, *bad_lang = NULL;\n+  unsigned int opt_flags = option->flags;\n+\n+  if (!lang_hooks.complain_wrong_lang_p (option))\n+    return;\n+\n+  opt_flags &= ((1U << cl_lang_count) - 1) | CL_DRIVER;\n+  if (opt_flags != CL_DRIVER)\n+    ok_langs = write_langs (opt_flags);\n+  if (lang_mask != CL_DRIVER)\n+    bad_lang = write_langs (lang_mask);\n+\n+  if (opt_flags == CL_DRIVER)\n+    error (\"command line option %qs is valid for the driver but not for %s\",\n+\t   text, bad_lang);\n+  else if (lang_mask == CL_DRIVER)\n+    gcc_unreachable ();\n+  else\n+    /* Eventually this should become a hard error IMO.  */\n+    warning (0, \"command line option %qs is valid for %s but not for %s\",\n+\t     text, ok_langs, bad_lang);\n+\n+  free (ok_langs);\n+  free (bad_lang);\n+}\n+\n+/* Buffer the unknown option described by the string OPT.  Currently,\n+   we only complain about unknown -Wno-* options if they may have\n+   prevented a diagnostic. Otherwise, we just ignore them.  Note that\n+   if we do complain, it is only as a warning, not an error; passing\n+   the compiler an unrecognised -Wno-* option should never change\n+   whether the compilation succeeds or fails.  */\n+\n+static void\n+postpone_unknown_option_warning (const char *opt)\n+{\n+  VEC_safe_push (const_char_p, heap, ignored_options, opt);\n+}\n+\n+/* Produce a warning for each option previously buffered.  */\n+\n+void\n+print_ignored_options (void)\n+{\n+  while (!VEC_empty (const_char_p, ignored_options))\n+    {\n+      const char *opt;\n+\n+      opt = VEC_pop (const_char_p, ignored_options);\n+      warning_at (UNKNOWN_LOCATION, 0,\n+\t\t  \"unrecognized command line option \\\"%s\\\"\", opt);\n+    }\n+}\n+\n+/* Handle an unknown option DECODED, returning true if an error should\n+   be given.  */\n+\n+static bool\n+unknown_option_callback (const struct cl_decoded_option *decoded)\n+{\n+  const char *opt = decoded->arg;\n+\n+  if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-'\n+      && !(decoded->errors & CL_ERR_NEGATIVE))\n+    {\n+      /* We don't generate warnings for unknown -Wno-* options unless\n+\t we issue diagnostics.  */\n+      postpone_unknown_option_warning (opt);\n+      return false;\n+    }\n+  else\n+    return true;\n+}\n+\n+/* Note that an option DECODED has been successfully handled with a\n+   handler for mask MASK.  */\n+\n+static void\n+post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n+\t\t\tunsigned int mask ATTRIBUTE_UNUSED)\n+{\n+#ifdef ENABLE_LTO\n+  lto_register_user_option (decoded->opt_index, decoded->arg,\n+\t\t\t    decoded->value, mask);\n+#endif\n+}\n+\n+/* Handle a front-end option; arguments and return value as for\n+   handle_option.  */\n+\n+static bool\n+lang_handle_option (struct gcc_options *opts,\n+\t\t    struct gcc_options *opts_set,\n+\t\t    const struct cl_decoded_option *decoded,\n+\t\t    unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\n+\t\t    location_t loc,\n+\t\t    const struct cl_option_handlers *handlers,\n+\t\t    diagnostic_context *dc)\n+{\n+  gcc_assert (opts == &global_options);\n+  gcc_assert (opts_set == &global_options_set);\n+  gcc_assert (dc == global_dc);\n+  gcc_assert (decoded->canonical_option_num_elements <= 2);\n+  return lang_hooks.handle_option (decoded->opt_index, decoded->arg,\n+\t\t\t\t   decoded->value, kind, loc, handlers);\n+}\n+\n+/* Handle FILENAME from the command line.  */\n+\n+static void\n+add_input_filename (const char *filename)\n+{\n+  num_in_fnames++;\n+  in_fnames = XRESIZEVEC (const char *, in_fnames, num_in_fnames);\n+  in_fnames[num_in_fnames - 1] = filename;\n+}\n+\n+/* Handle the vector of command line options (located at LOC), storing\n+   the results of processing DECODED_OPTIONS and DECODED_OPTIONS_COUNT\n+   in OPTS and OPTS_SET and using DC for diagnostic state.  LANG_MASK\n+   contains has a single bit set representing the current language.\n+   HANDLERS describes what functions to call for the options.  */\n+\n+static void\n+read_cmdline_options (struct gcc_options *opts, struct gcc_options *opts_set,\n+\t\t      struct cl_decoded_option *decoded_options,\n+\t\t      unsigned int decoded_options_count,\n+\t\t      location_t loc,\n+\t\t      unsigned int lang_mask,\n+\t\t      const struct cl_option_handlers *handlers,\n+\t\t      diagnostic_context *dc)\n+{\n+  unsigned int i;\n+\n+  for (i = 1; i < decoded_options_count; i++)\n+    {\n+      if (decoded_options[i].opt_index == OPT_SPECIAL_input_file)\n+\t{\n+\t  /* Input files should only ever appear on the main command\n+\t     line.  */\n+\t  gcc_assert (opts == &global_options);\n+\t  gcc_assert (opts_set == &global_options_set);\n+\n+\t  if (main_input_filename == NULL)\n+\t    {\n+\t      main_input_filename = decoded_options[i].arg;\n+\t      main_input_baselength\n+\t\t= base_of_path (main_input_filename, &main_input_basename);\n+\t    }\n+\t  add_input_filename (decoded_options[i].arg);\n+\t  continue;\n+\t}\n+\n+      read_cmdline_option (opts, opts_set,\n+\t\t\t   decoded_options + i, loc, lang_mask, handlers,\n+\t\t\t   dc);\n+    }\n+}\n+\n+/* Language mask determined at initialization.  */\n+static unsigned int initial_lang_mask;\n+\n+/* Initialize global options-related settings at start-up.  */\n+\n+void\n+init_options_once (void)\n+{\n+  /* Perform language-specific options initialization.  */\n+  initial_lang_mask = lang_hooks.option_lang_mask ();\n+\n+  lang_hooks.initialize_diagnostics (global_dc);\n+}\n+\n+/* Decode command-line options to an array, like\n+   decode_cmdline_options_to_array and with the same arguments but\n+   using the default lang_mask.  */\n+\n+void\n+decode_cmdline_options_to_array_default_mask (unsigned int argc,\n+\t\t\t\t\t      const char **argv, \n+\t\t\t\t\t      struct cl_decoded_option **decoded_options,\n+\t\t\t\t\t      unsigned int *decoded_options_count)\n+{\n+  decode_cmdline_options_to_array (argc, argv,\n+\t\t\t\t   initial_lang_mask | CL_COMMON | CL_TARGET,\n+\t\t\t\t   decoded_options, decoded_options_count);\n+}\n+\n+/* Set *HANDLERS to the default set of option handlers for use in the\n+   compilers proper (not the driver).  */\n+void\n+set_default_handlers (struct cl_option_handlers *handlers)\n+{\n+  handlers->unknown_option_callback = unknown_option_callback;\n+  handlers->wrong_lang_callback = complain_wrong_lang;\n+  handlers->post_handling_callback = post_handling_callback;\n+  handlers->num_handlers = 3;\n+  handlers->handlers[0].handler = lang_handle_option;\n+  handlers->handlers[0].mask = initial_lang_mask;\n+  handlers->handlers[1].handler = common_handle_option;\n+  handlers->handlers[1].mask = CL_COMMON;\n+  handlers->handlers[2].handler = target_handle_option;\n+  handlers->handlers[2].mask = CL_TARGET;\n+}\n+\n+/* Parse command line options and set default flag values.  Do minimal\n+   options processing.  The decoded options are in *DECODED_OPTIONS\n+   and *DECODED_OPTIONS_COUNT; settings go in OPTS, OPTS_SET and DC;\n+   the options are located at LOC.  */\n+void\n+decode_options (struct gcc_options *opts, struct gcc_options *opts_set,\n+\t\tstruct cl_decoded_option *decoded_options,\n+\t\tunsigned int decoded_options_count,\n+\t\tlocation_t loc, diagnostic_context *dc)\n+{\n+  struct cl_option_handlers handlers;\n+\n+  unsigned int lang_mask;\n+\n+  lang_mask = initial_lang_mask;\n+\n+  set_default_handlers (&handlers);\n+\n+  /* Enable -Werror=coverage-mismatch by default.  */\n+  control_warning_option (OPT_Wcoverage_mismatch, (int) DK_ERROR, true,\n+\t\t\t  loc, lang_mask,\n+\t\t\t  &handlers, opts, opts_set, dc);\n+\n+  default_options_optimization (opts, opts_set,\n+\t\t\t\tdecoded_options, decoded_options_count,\n+\t\t\t\tloc, lang_mask, &handlers, dc);\n+\n+#ifdef ENABLE_LTO\n+  /* Clear any options currently held for LTO.  */\n+  lto_clear_user_options ();\n+#endif\n+\n+  read_cmdline_options (opts, opts_set,\n+\t\t\tdecoded_options, decoded_options_count,\n+\t\t\tloc, lang_mask,\n+\t\t\t&handlers, dc);\n+\n+  finish_options (opts, opts_set);\n+}\n+\n+/* Process common options that have been deferred until after the\n+   handlers have been called for all options.  */\n+\n void\n handle_common_deferred_options (void)\n {"}, {"sha": "a088bc548407a3a101a8e040d81767793aa20c23", "filename": "gcc/opts.c", "status": "modified", "additions": 94, "deletions": 380, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -21,25 +21,30 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+\n+#include <signal.h>\n+\n+#ifdef HAVE_SYS_RESOURCE_H\n+# include <sys/resource.h>\n+#endif\n+\n #include \"intl.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"langhooks.h\"\n+#include \"tm.h\" /* Needed by rtl.h and used for DWARF2_DEBUGGING_INFO\n+\t\t   and DBX_DEBUGGING_INFO.  */\n+#include \"tree.h\" /* For vect_set_verbosity_level.  */\n+#include \"rtl.h\" /* Needed by insn-attr.h.  */\n #include \"opts.h\"\n #include \"options.h\"\n #include \"flags.h\"\n-#include \"toplev.h\"\n+#include \"toplev.h\" /* For set_random_seed and enable_rtl_dump_file.  */\n #include \"params.h\"\n #include \"diagnostic.h\"\n #include \"opts-diagnostic.h\"\n-#include \"insn-attr.h\"\t\t/* For INSN_SCHEDULING.  */\n+#include \"insn-attr.h\"\t\t/* For INSN_SCHEDULING and DELAY_SLOTS.  */\n #include \"target.h\"\n #include \"dbgcnt.h\"\n #include \"debug.h\"\n-#include \"except.h\"\n-#include \"lto-streamer.h\"\n \n /* Run the second compilation of -fcompare-debug.  Not defined using\n    Var in common.opt because this is used in Ada code and so must be\n@@ -136,6 +141,25 @@ set_struct_debug_option (struct gcc_options *opts, const char *spec)\n     }\n }\n \n+/* Strip off a legitimate source ending from the input string NAME of\n+   length LEN.  Rather than having to know the names used by all of\n+   our front ends, we strip off an ending of a period followed by\n+   up to five characters.  (Java uses \".class\".)  */\n+\n+void\n+strip_off_ending (char *name, int len)\n+{\n+  int i;\n+  for (i = 2; i < 6 && len > i; i++)\n+    {\n+      if (name[len - i] == '.')\n+\t{\n+\t  name[len - i] = '\\0';\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Find the base name of a path, stripping off both directories and\n    a single final extension. */\n int\n@@ -162,42 +186,20 @@ base_of_path (const char *path, const char **base_out)\n   return dot - base;\n }\n \n-/* Global visibility options.  */\n-struct visibility_flags visibility_options;\n-\n /* What to print when a switch has no documentation.  */\n static const char undocumented_msg[] = N_(\"This switch lacks documentation\");\n \n typedef char *char_p; /* For DEF_VEC_P.  */\n DEF_VEC_P(char_p);\n DEF_VEC_ALLOC_P(char_p,heap);\n \n-typedef const char *const_char_p; /* For DEF_VEC_P.  */\n-DEF_VEC_P(const_char_p);\n-DEF_VEC_ALLOC_P(const_char_p,heap);\n-\n-static VEC(const_char_p,heap) *ignored_options;\n-\n-/* Input file names.  */\n-const char **in_fnames;\n-unsigned num_in_fnames;\n-\n-static bool common_handle_option (struct gcc_options *opts,\n-\t\t\t\t  struct gcc_options *opts_set,\n-\t\t\t\t  const struct cl_decoded_option *decoded,\n-\t\t\t\t  unsigned int lang_mask, int kind,\n-\t\t\t\t  location_t loc,\n-\t\t\t\t  const struct cl_option_handlers *handlers,\n-\t\t\t\t  diagnostic_context *dc);\n static void handle_param (struct gcc_options *opts,\n \t\t\t  struct gcc_options *opts_set, const char *carg);\n-static char *write_langs (unsigned int lang_mask);\n-static void complain_wrong_lang (const struct cl_decoded_option *,\n-\t\t\t\t unsigned int lang_mask);\n static void set_debug_level (enum debug_info_type type, int extended,\n \t\t\t     const char *arg, struct gcc_options *opts,\n \t\t\t     struct gcc_options *opts_set);\n static void set_fast_math_flags (struct gcc_options *opts, int set);\n+static void decode_d_option (const char *arg);\n static void set_unsafe_math_optimizations_flags (struct gcc_options *opts,\n \t\t\t\t\t\t int set);\n static void enable_warning_as_error (const char *arg, int value,\n@@ -208,155 +210,10 @@ static void enable_warning_as_error (const char *arg, int value,\n \t\t\t\t     location_t loc,\n \t\t\t\t     diagnostic_context *dc);\n \n-/* Return a malloced slash-separated list of languages in MASK.  */\n-static char *\n-write_langs (unsigned int mask)\n-{\n-  unsigned int n = 0, len = 0;\n-  const char *lang_name;\n-  char *result;\n-\n-  for (n = 0; (lang_name = lang_names[n]) != 0; n++)\n-    if (mask & (1U << n))\n-      len += strlen (lang_name) + 1;\n-\n-  result = XNEWVEC (char, len);\n-  len = 0;\n-  for (n = 0; (lang_name = lang_names[n]) != 0; n++)\n-    if (mask & (1U << n))\n-      {\n-\tif (len)\n-\t  result[len++] = '/';\n-\tstrcpy (result + len, lang_name);\n-\tlen += strlen (lang_name);\n-      }\n-\n-  result[len] = 0;\n-\n-  return result;\n-}\n-\n-/* Complain that switch DECODED does not apply to this front end (mask\n-   LANG_MASK).  */\n-static void\n-complain_wrong_lang (const struct cl_decoded_option *decoded,\n-\t\t     unsigned int lang_mask)\n-{\n-  const struct cl_option *option = &cl_options[decoded->opt_index];\n-  const char *text = decoded->orig_option_with_args_text;\n-  char *ok_langs = NULL, *bad_lang = NULL;\n-  unsigned int opt_flags = option->flags;\n-\n-  if (!lang_hooks.complain_wrong_lang_p (option))\n-    return;\n-\n-  opt_flags &= ((1U << cl_lang_count) - 1) | CL_DRIVER;\n-  if (opt_flags != CL_DRIVER)\n-    ok_langs = write_langs (opt_flags);\n-  if (lang_mask != CL_DRIVER)\n-    bad_lang = write_langs (lang_mask);\n-\n-  if (opt_flags == CL_DRIVER)\n-    error (\"command line option %qs is valid for the driver but not for %s\",\n-\t   text, bad_lang);\n-  else if (lang_mask == CL_DRIVER)\n-    gcc_unreachable ();\n-  else\n-    /* Eventually this should become a hard error IMO.  */\n-    warning (0, \"command line option %qs is valid for %s but not for %s\",\n-\t     text, ok_langs, bad_lang);\n-\n-  free (ok_langs);\n-  free (bad_lang);\n-}\n-\n-/* Buffer the unknown option described by the string OPT.  Currently,\n-   we only complain about unknown -Wno-* options if they may have\n-   prevented a diagnostic. Otherwise, we just ignore them.\n-   Note that if we do complain, it is only as a warning, not an error;\n-   passing the compiler an unrecognised -Wno-* option should never\n-   change whether the compilation succeeds or fails.  */\n-\n-static void postpone_unknown_option_warning(const char *opt)\n-{\n-  VEC_safe_push (const_char_p, heap, ignored_options, opt);\n-}\n-\n-/* Produce a warning for each option previously buffered.  */\n-\n-void print_ignored_options (void)\n-{\n-  location_t saved_loc = input_location;\n-\n-  input_location = 0;\n-\n-  while (!VEC_empty (const_char_p, ignored_options))\n-    {\n-      const char *opt;\n-      opt = VEC_pop (const_char_p, ignored_options);\n-      warning (0, \"unrecognized command line option \\\"%s\\\"\", opt);\n-    }\n-\n-  input_location = saved_loc;\n-}\n-\n-/* Handle an unknown option DECODED, returning true if an error should be\n-   given.  */\n-\n-static bool\n-unknown_option_callback (const struct cl_decoded_option *decoded)\n-{\n-  const char *opt = decoded->arg;\n-\n-  if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-'\n-      && !(decoded->errors & CL_ERR_NEGATIVE))\n-    {\n-      /* We don't generate warnings for unknown -Wno-* options unless\n-\t we issue diagnostics.  */\n-      postpone_unknown_option_warning (opt);\n-      return false;\n-    }\n-  else\n-    return true;\n-}\n-\n-/* Note that an option DECODED has been successfully handled with a\n-   handler for mask MASK.  */\n-\n-static void\n-post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n-\t\t\tunsigned int mask ATTRIBUTE_UNUSED)\n-{\n-#ifdef ENABLE_LTO\n-  lto_register_user_option (decoded->opt_index, decoded->arg,\n-\t\t\t    decoded->value, mask);\n-#endif\n-}\n-\n-/* Handle a front-end option; arguments and return value as for\n-   handle_option.  */\n-\n-static bool\n-lang_handle_option (struct gcc_options *opts,\n-\t\t    struct gcc_options *opts_set,\n-\t\t    const struct cl_decoded_option *decoded,\n-\t\t    unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\n-\t\t    location_t loc,\n-\t\t    const struct cl_option_handlers *handlers,\n-\t\t    diagnostic_context *dc)\n-{\n-  gcc_assert (opts == &global_options);\n-  gcc_assert (opts_set == &global_options_set);\n-  gcc_assert (dc == global_dc);\n-  gcc_assert (decoded->canonical_option_num_elements <= 2);\n-  return lang_hooks.handle_option (decoded->opt_index, decoded->arg,\n-\t\t\t\t   decoded->value, kind, loc, handlers);\n-}\n-\n /* Handle a back-end option; arguments and return value as for\n    handle_option.  */\n \n-static bool\n+bool\n target_handle_option (struct gcc_options *opts,\n \t\t      struct gcc_options *opts_set,\n \t\t      const struct cl_decoded_option *decoded,\n@@ -378,15 +235,6 @@ target_handle_option (struct gcc_options *opts,\n \t\t\t\tdecoded->value);\n }\n \n-/* Handle FILENAME from the command line.  */\n-static void\n-add_input_filename (const char *filename)\n-{\n-  num_in_fnames++;\n-  in_fnames = XRESIZEVEC (const char *, in_fnames, num_in_fnames);\n-  in_fnames[num_in_fnames - 1] = filename;\n-}\n-\n /* Add comma-separated strings to a char_p vector.  */\n \n static void\n@@ -428,61 +276,6 @@ add_comma_separated_to_vector (void **pvec, const char *arg)\n   *pvec = vec;\n }\n \n-/* Handle the vector of command line options (located at LOC), storing\n-   the results of processing DECODED_OPTIONS and DECODED_OPTIONS_COUNT\n-   in OPTS and OPTS_SET and using DC for diagnostic state.  LANG_MASK\n-   contains has a single bit set representing the current language.\n-   HANDLERS describes what functions to call for the options.  */\n-static void\n-read_cmdline_options (struct gcc_options *opts, struct gcc_options *opts_set,\n-\t\t      struct cl_decoded_option *decoded_options,\n-\t\t      unsigned int decoded_options_count,\n-\t\t      location_t loc,\n-\t\t      unsigned int lang_mask,\n-\t\t      const struct cl_option_handlers *handlers,\n-\t\t      diagnostic_context *dc)\n-{\n-  unsigned int i;\n-\n-  for (i = 1; i < decoded_options_count; i++)\n-    {\n-      if (decoded_options[i].opt_index == OPT_SPECIAL_input_file)\n-\t{\n-\t  /* Input files should only ever appear on the main command\n-\t     line.  */\n-\t  gcc_assert (opts == &global_options);\n-\t  gcc_assert (opts_set == &global_options_set);\n-\n-\t  if (main_input_filename == NULL)\n-\t    {\n-\t      main_input_filename = decoded_options[i].arg;\n-\t      main_input_baselength\n-\t\t= base_of_path (main_input_filename, &main_input_basename);\n-\t    }\n-\t  add_input_filename (decoded_options[i].arg);\n-\t  continue;\n-\t}\n-\n-      read_cmdline_option (opts, opts_set,\n-\t\t\t   decoded_options + i, loc, lang_mask, handlers,\n-\t\t\t   dc);\n-    }\n-}\n-\n-/* Language mask determined at initialization.  */\n-static unsigned int initial_lang_mask;\n-\n-/* Initialize global options-related settings at start-up.  */\n-\n-void\n-init_options_once (void)\n-{\n-  /* Perform language-specific options initialization.  */\n-  initial_lang_mask = lang_hooks.option_lang_mask ();\n-\n-  lang_hooks.initialize_diagnostics (global_dc);\n-}\n-\n /* Initialize OPTS and OPTS_SET before using them in parsing options.  */\n \n void\n@@ -519,21 +312,6 @@ init_options_struct (struct gcc_options *opts, struct gcc_options *opts_set)\n   targetm.target_option.init_struct (opts);\n }\n \n-/* Decode command-line options to an array, like\n-   decode_cmdline_options_to_array and with the same arguments but\n-   using the default lang_mask.  */\n-\n-void\n-decode_cmdline_options_to_array_default_mask (unsigned int argc,\n-\t\t\t\t\t      const char **argv, \n-\t\t\t\t\t      struct cl_decoded_option **decoded_options,\n-\t\t\t\t\t      unsigned int *decoded_options_count)\n-{\n-  decode_cmdline_options_to_array (argc, argv,\n-\t\t\t\t   initial_lang_mask | CL_COMMON | CL_TARGET,\n-\t\t\t\t   decoded_options, decoded_options_count);\n-}\n-\n /* If indicated by the optimization level LEVEL (-Os if SIZE is set,\n    -Ofast if FAST is set), apply the option DEFAULT_OPT to OPTS and\n    OPTS_SET, diagnostic context DC, location LOC, with language mask\n@@ -725,7 +503,7 @@ static const struct default_options default_options_table[] =\n \n /* Default the options in OPTS and OPTS_SET based on the optimization\n    settings in DECODED_OPTIONS and DECODED_OPTIONS_COUNT.  */\n-static void\n+void\n default_options_optimization (struct gcc_options *opts,\n \t\t\t      struct gcc_options *opts_set,\n \t\t\t      struct cl_decoded_option *decoded_options,\n@@ -826,69 +604,10 @@ default_options_optimization (struct gcc_options *opts,\n \t\t\t ofast, lang_mask, handlers, loc, dc);\n }\n \n-static void finish_options (struct gcc_options *, struct gcc_options *);\n-\n-/* Set *HANDLERS to the default set of option handlers for use in the\n-   compilers proper (not the driver).  */\n-void\n-set_default_handlers (struct cl_option_handlers *handlers)\n-{\n-  handlers->unknown_option_callback = unknown_option_callback;\n-  handlers->wrong_lang_callback = complain_wrong_lang;\n-  handlers->post_handling_callback = post_handling_callback;\n-  handlers->num_handlers = 3;\n-  handlers->handlers[0].handler = lang_handle_option;\n-  handlers->handlers[0].mask = initial_lang_mask;\n-  handlers->handlers[1].handler = common_handle_option;\n-  handlers->handlers[1].mask = CL_COMMON;\n-  handlers->handlers[2].handler = target_handle_option;\n-  handlers->handlers[2].mask = CL_TARGET;\n-}\n-\n-/* Parse command line options and set default flag values.  Do minimal\n-   options processing.  The decoded options are in *DECODED_OPTIONS\n-   and *DECODED_OPTIONS_COUNT; settings go in OPTS, OPTS_SET and DC;\n-   the options are located at LOC.  */\n-void\n-decode_options (struct gcc_options *opts, struct gcc_options *opts_set,\n-\t\tstruct cl_decoded_option *decoded_options,\n-\t\tunsigned int decoded_options_count,\n-\t\tlocation_t loc, diagnostic_context *dc)\n-{\n-  struct cl_option_handlers handlers;\n-\n-  unsigned int lang_mask;\n-\n-  lang_mask = initial_lang_mask;\n-\n-  set_default_handlers (&handlers);\n-\n-  /* Enable -Werror=coverage-mismatch by default.  */\n-  control_warning_option (OPT_Wcoverage_mismatch, (int) DK_ERROR, true,\n-\t\t\t  loc, lang_mask,\n-\t\t\t  &handlers, opts, opts_set, dc);\n-\n-  default_options_optimization (opts, opts_set,\n-\t\t\t\tdecoded_options, decoded_options_count,\n-\t\t\t\tloc, lang_mask, &handlers, dc);\n-\n-#ifdef ENABLE_LTO\n-  /* Clear any options currently held for LTO.  */\n-  lto_clear_user_options ();\n-#endif\n-\n-  read_cmdline_options (opts, opts_set,\n-\t\t\tdecoded_options, decoded_options_count,\n-\t\t\tloc, lang_mask,\n-\t\t\t&handlers, dc);\n-\n-  finish_options (opts, opts_set);\n-}\n-\n /* After all options have been read into OPTS and OPTS_SET, finalize\n    settings of those options and diagnose incompatible\n    combinations.  */\n-static void\n+void\n finish_options (struct gcc_options *opts, struct gcc_options *opts_set)\n {\n   static bool first_time_p = true;\n@@ -1419,7 +1138,7 @@ print_specific_help (unsigned int include_flags,\n    extra handling need to be listed here; if you simply want\n    DECODED->value assigned to a variable, it happens automatically.  */\n \n-static bool\n+bool\n common_handle_option (struct gcc_options *opts,\n \t\t      struct gcc_options *opts_set,\n \t\t      const struct cl_decoded_option *decoded,\n@@ -2145,76 +1864,71 @@ set_debug_level (enum debug_info_type type, int extended, const char *arg,\n     }\n }\n \n-/* Return 1 if option OPT_IDX is enabled in OPTS, 0 if it is disabled,\n-   or -1 if it isn't a simple on-off switch.  */\n+/* Arrange to dump core on error.  (The regular error message is still\n+   printed first, except in the case of abort ().)  */\n \n-int\n-option_enabled (int opt_idx, void *opts)\n+static void\n+setup_core_dumping (void)\n {\n-  const struct cl_option *option = &(cl_options[opt_idx]);\n-  struct gcc_options *optsg = (struct gcc_options *) opts;\n-  void *flag_var = option_flag_var (opt_idx, optsg);\n-\n-  if (flag_var)\n-    switch (option->var_type)\n-      {\n-      case CLVC_BOOLEAN:\n-\treturn *(int *) flag_var != 0;\n-\n-      case CLVC_EQUAL:\n-\treturn *(int *) flag_var == option->var_value;\n-\n-      case CLVC_BIT_CLEAR:\n-\treturn (*(int *) flag_var & option->var_value) == 0;\n-\n-      case CLVC_BIT_SET:\n-\treturn (*(int *) flag_var & option->var_value) != 0;\n-\n-      case CLVC_STRING:\n-      case CLVC_DEFER:\n-\tbreak;\n-      }\n-  return -1;\n+#ifdef SIGABRT\n+  signal (SIGABRT, SIG_DFL);\n+#endif\n+#if defined(HAVE_SETRLIMIT)\n+  {\n+    struct rlimit rlim;\n+    if (getrlimit (RLIMIT_CORE, &rlim) != 0)\n+      fatal_error (\"getting core file size maximum limit: %m\");\n+    rlim.rlim_cur = rlim.rlim_max;\n+    if (setrlimit (RLIMIT_CORE, &rlim) != 0)\n+      fatal_error (\"setting core file size limit to maximum: %m\");\n+  }\n+#endif\n+  diagnostic_abort_on_error (global_dc);\n }\n \n-/* Fill STATE with the current state of option OPTION in OPTS.  Return\n-   true if there is some state to store.  */\n+/* Parse a -d<ARG> command line switch.  */\n \n-bool\n-get_option_state (struct gcc_options *opts, int option,\n-\t\t  struct cl_option_state *state)\n+static void\n+decode_d_option (const char *arg)\n {\n-  void *flag_var = option_flag_var (option, opts);\n-\n-  if (flag_var == 0)\n-    return false;\n+  int c;\n \n-  switch (cl_options[option].var_type)\n-    {\n-    case CLVC_BOOLEAN:\n-    case CLVC_EQUAL:\n-      state->data = flag_var;\n-      state->size = sizeof (int);\n-      break;\n-\n-    case CLVC_BIT_CLEAR:\n-    case CLVC_BIT_SET:\n-      state->ch = option_enabled (option, opts);\n-      state->data = &state->ch;\n-      state->size = 1;\n-      break;\n-\n-    case CLVC_STRING:\n-      state->data = *(const char **) flag_var;\n-      if (state->data == 0)\n-\tstate->data = \"\";\n-      state->size = strlen ((const char *) state->data) + 1;\n-      break;\n+  while (*arg)\n+    switch (c = *arg++)\n+      {\n+      case 'A':\n+\tflag_debug_asm = 1;\n+\tbreak;\n+      case 'p':\n+\tflag_print_asm_name = 1;\n+\tbreak;\n+      case 'P':\n+\tflag_dump_rtl_in_asm = 1;\n+\tflag_print_asm_name = 1;\n+\tbreak;\n+      case 'v':\n+\tgraph_dump_format = vcg;\n+\tbreak;\n+      case 'x':\n+\trtl_dump_and_exit = 1;\n+\tbreak;\n+      case 'D':\t/* These are handled by the preprocessor.  */\n+      case 'I':\n+      case 'M':\n+      case 'N':\n+      case 'U':\n+\tbreak;\n+      case 'H':\n+\tsetup_core_dumping ();\n+\tbreak;\n+      case 'a':\n+\tenable_rtl_dump_file ();\n+\tbreak;\n \n-    case CLVC_DEFER:\n-      return false;\n-    }\n-  return true;\n+      default:\n+\t  warning (0, \"unrecognized gcc debugging option: %c\", c);\n+\tbreak;\n+      }\n }\n \n /* Enable (or disable if VALUE is 0) a warning option ARG (language"}, {"sha": "e819bf38d2786e144a6594f859bd5cda2c31bd65", "filename": "gcc/opts.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -284,4 +284,28 @@ extern void control_warning_option (unsigned int opt_index, int kind,\n \t\t\t\t    diagnostic_context *dc);\n extern void print_ignored_options (void);\n extern void handle_common_deferred_options (void);\n+extern bool common_handle_option (struct gcc_options *opts,\n+\t\t\t\t  struct gcc_options *opts_set,\n+\t\t\t\t  const struct cl_decoded_option *decoded,\n+\t\t\t\t  unsigned int lang_mask, int kind,\n+\t\t\t\t  location_t loc,\n+\t\t\t\t  const struct cl_option_handlers *handlers,\n+\t\t\t\t  diagnostic_context *dc);\n+extern bool target_handle_option (struct gcc_options *opts,\n+\t\t\t\t  struct gcc_options *opts_set,\n+\t\t\t\t  const struct cl_decoded_option *decoded,\n+\t\t\t\t  unsigned int lang_mask, int kind,\n+\t\t\t\t  location_t loc,\n+\t\t\t\t  const struct cl_option_handlers *handlers,\n+\t\t\t\t  diagnostic_context *dc);\n+extern void finish_options (struct gcc_options *opts,\n+\t\t\t    struct gcc_options *opts_set);\n+extern void default_options_optimization (struct gcc_options *opts,\n+\t\t\t\t\t  struct gcc_options *opts_set,\n+\t\t\t\t\t  struct cl_decoded_option *decoded_options,\n+\t\t\t\t\t  unsigned int decoded_options_count,\n+\t\t\t\t\t  location_t loc,\n+\t\t\t\t\t  unsigned int lang_mask,\n+\t\t\t\t\t  const struct cl_option_handlers *handlers,\n+\t\t\t\t\t  diagnostic_context *dc);\n #endif"}, {"sha": "edbb076f1ea5225a79b8e3e8a54745c288ddc7be", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -28,11 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include <signal.h>\n-\n-#ifdef HAVE_SYS_RESOURCE_H\n-# include <sys/resource.h>\n-#endif\n \n #ifdef HAVE_SYS_TIMES_H\n # include <sys/times.h>\n@@ -114,7 +109,6 @@ static void init_asm_output (const char *);\n static void finalize (void);\n \n static void crash_signal (int) ATTRIBUTE_NORETURN;\n-static void setup_core_dumping (void);\n static void compile_file (void);\n \n /* True if we don't need a backend (e.g. preprocessing only).  */\n@@ -480,48 +474,6 @@ crash_signal (int signo)\n   internal_error (\"%s\", strsignal (signo));\n }\n \n-/* Arrange to dump core on error.  (The regular error message is still\n-   printed first, except in the case of abort().)  */\n-\n-static void\n-setup_core_dumping (void)\n-{\n-#ifdef SIGABRT\n-  signal (SIGABRT, SIG_DFL);\n-#endif\n-#if defined(HAVE_SETRLIMIT)\n-  {\n-    struct rlimit rlim;\n-    if (getrlimit (RLIMIT_CORE, &rlim) != 0)\n-      fatal_error (\"getting core file size maximum limit: %m\");\n-    rlim.rlim_cur = rlim.rlim_max;\n-    if (setrlimit (RLIMIT_CORE, &rlim) != 0)\n-      fatal_error (\"setting core file size limit to maximum: %m\");\n-  }\n-#endif\n-  diagnostic_abort_on_error (global_dc);\n-}\n-\n-\n-/* Strip off a legitimate source ending from the input string NAME of\n-   length LEN.  Rather than having to know the names used by all of\n-   our front ends, we strip off an ending of a period followed by\n-   up to five characters.  (Java uses \".class\".)  */\n-\n-void\n-strip_off_ending (char *name, int len)\n-{\n-  int i;\n-  for (i = 2; i < 6 && len > i; i++)\n-    {\n-      if (name[len - i] == '.')\n-\t{\n-\t  name[len - i] = '\\0';\n-\t  break;\n-\t}\n-    }\n-}\n-\n /* Output a quoted string.  */\n \n void\n@@ -967,51 +919,6 @@ compile_file (void)\n   targetm.asm_out.file_end ();\n }\n \n-/* Parse a -d... command line switch.  */\n-\n-void\n-decode_d_option (const char *arg)\n-{\n-  int c;\n-\n-  while (*arg)\n-    switch (c = *arg++)\n-      {\n-      case 'A':\n-\tflag_debug_asm = 1;\n-\tbreak;\n-      case 'p':\n-\tflag_print_asm_name = 1;\n-\tbreak;\n-      case 'P':\n-\tflag_dump_rtl_in_asm = 1;\n-\tflag_print_asm_name = 1;\n-\tbreak;\n-      case 'v':\n-\tgraph_dump_format = vcg;\n-\tbreak;\n-      case 'x':\n-\trtl_dump_and_exit = 1;\n-\tbreak;\n-      case 'D':\t/* These are handled by the preprocessor.  */\n-      case 'I':\n-      case 'M':\n-      case 'N':\n-      case 'U':\n-\tbreak;\n-      case 'H':\n-\tsetup_core_dumping();\n-\tbreak;\n-      case 'a':\n-\tenable_rtl_dump_file ();\n-\tbreak;\n-\n-      default:\n-\t  warning (0, \"unrecognized gcc debugging option: %c\", c);\n-\tbreak;\n-      }\n-}\n-\n /* Indexed by enum debug_info_type.  */\n const char *const debug_type_names[] =\n {"}, {"sha": "46d953735daf654db292eecb469c587b4b197ac1", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=c98cd5bff60fa2a0bd31fcdbd2f0758a32639c09", "patch": "@@ -34,7 +34,6 @@ extern struct cl_decoded_option *save_decoded_options;\n extern unsigned int save_decoded_options_count;\n \n extern int toplev_main (int, char **);\n-extern void strip_off_ending (char *, int);\n extern void rest_of_decl_compilation (tree, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void tree_rest_of_compilation (tree);\n@@ -92,13 +91,6 @@ extern const char * default_pch_valid_p (const void *, size_t);\n /* The hashtable, so that the C front ends can pass it to cpplib.  */\n extern struct ht *ident_hash;\n \n-/* Handle -d switch.  */\n-extern void decode_d_option\t\t(const char *);\n-\n-/* Return true iff flags are set as if -ffast-math.  */\n-extern bool fast_math_flags_set_p\t(const struct gcc_options *);\n-extern bool fast_math_flags_struct_set_p (struct cl_optimization *);\n-\n /* Inline versions of the above for speed.  */\n #if GCC_VERSION < 3004\n "}]}