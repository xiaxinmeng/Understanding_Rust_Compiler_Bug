{"sha": "2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY3NWQ2ZWJmODE4MzNjYWM5NjU5NjEwOGMyZDU2ZDBjNmNkYjJhMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-12-13T15:35:14Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-12-13T15:35:14Z"}, "message": "Add sanopt for ASAN_MARK poison and unpoison.\n\n\t* sanopt.c (sanopt_optimize_walker): Set contains_asan_mark.\n\t(sanopt_optimize): Add new argument.\n\t(sanitize_asan_mark_unpoison): New function.\n\t(maybe_contains_asan_check): Likewise.\n\t(sanitize_asan_mark_poison): Likewise.\n\t(pass_sanopt::execute): Call the new functions.\n\nFrom-SVN: r243611", "tree": {"sha": "604db308344ff532343de8ca9aad04b245db93de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/604db308344ff532343de8ca9aad04b245db93de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "437df9f9d154c9328e52d967fbecdf72148566e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437df9f9d154c9328e52d967fbecdf72148566e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437df9f9d154c9328e52d967fbecdf72148566e1"}], "stats": {"total": 215, "additions": 211, "deletions": 4}, "files": [{"sha": "d3c9a9fd2b98bed57c436536240f035136e39a84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "patch": "@@ -1,3 +1,12 @@\n+2016-12-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* sanopt.c (sanopt_optimize_walker): Set contains_asan_mark.\n+\t(sanopt_optimize): Add new argument.\n+\t(sanitize_asan_mark_unpoison): New function.\n+\t(maybe_contains_asan_check): Likewise.\n+\t(sanitize_asan_mark_poison): Likewise.\n+\t(pass_sanopt::execute): Call the new functions.\n+\n 2016-12-13  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/78428"}, {"sha": "7fe8d32e39acf8694cc2de9047cd43d2156872e9", "filename": "gcc/sanopt.c", "status": "modified", "additions": 202, "deletions": 4, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f75d6ebf81833cac96596108c2d56d0c6cdb2a0/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=2f75d6ebf81833cac96596108c2d56d0c6cdb2a0", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"ssa.h\"\n #include \"tree-pass.h\"\n #include \"tree-ssa-operands.h\"\n #include \"gimple-pretty-print.h\"\n@@ -37,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n \n-\n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n \n@@ -160,8 +160,10 @@ struct sanopt_ctx\n \n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n-};\n \n+  /* True when the current functions constains an ASAN_MARK.  */\n+  bool contains_asan_mark;\n+};\n \n /* Return true if there might be any call to free/munmap operation\n    on any path in between DOM (which should be imm(BB)) and BB.  */\n@@ -582,6 +584,9 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \t    if (!remove)\n \t      ctx->asan_num_accesses++;\n \t    break;\n+\t  case IFN_ASAN_MARK:\n+\t    ctx->contains_asan_mark = true;\n+\t    break;\n \t  default:\n \t    break;\n \t  }\n@@ -620,10 +625,11 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n /* Try to remove redundant sanitizer checks in function FUN.  */\n \n static int\n-sanopt_optimize (function *fun)\n+sanopt_optimize (function *fun, bool *contains_asan_mark)\n {\n   struct sanopt_ctx ctx;\n   ctx.asan_num_accesses = 0;\n+  ctx.contains_asan_mark = false;\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (sanopt_info));\n@@ -638,6 +644,7 @@ sanopt_optimize (function *fun)\n \n   free_aux_for_blocks ();\n \n+  *contains_asan_mark = ctx.contains_asan_mark;\n   return ctx.asan_num_accesses;\n }\n \n@@ -671,18 +678,201 @@ class pass_sanopt : public gimple_opt_pass\n \n }; // class pass_sanopt\n \n+/* Sanitize all ASAN_MARK unpoison calls that are not reachable by a BB\n+   that contains an ASAN_MARK poison.  All these ASAN_MARK unpoison call\n+   can be removed as all variables are unpoisoned in a function prologue.  */\n+\n+static void\n+sanitize_asan_mark_unpoison (void)\n+{\n+  /* 1) Find all BBs that contain an ASAN_MARK poison call.  */\n+  auto_sbitmap with_poison (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_clear (with_poison);\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (bitmap_bit_p (with_poison, bb->index))\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (asan_mark_p (stmt, ASAN_MARK_POISON))\n+\t    {\n+\t      bitmap_set_bit (with_poison, bb->index);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  auto_sbitmap poisoned (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_clear (poisoned);\n+  auto_sbitmap worklist (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_copy (worklist, with_poison);\n+\n+  /* 2) Propagate the information to all reachable blocks.  */\n+  while (!bitmap_empty_p (worklist))\n+    {\n+      unsigned i = bitmap_first_set_bit (worklist);\n+      bitmap_clear_bit (worklist, i);\n+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+      gcc_assert (bb);\n+\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (!bitmap_bit_p (poisoned, e->dest->index))\n+\t  {\n+\t    bitmap_set_bit (poisoned, e->dest->index);\n+\t    bitmap_set_bit (worklist, e->dest->index);\n+\t  }\n+    }\n+\n+  /* 3) Iterate all BBs not included in POISONED BBs and remove unpoison\n+\tASAN_MARK preceding an ASAN_MARK poison (which can still happen).  */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (bitmap_bit_p (poisoned, bb->index))\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  bool next = true;\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n+\t    {\n+\t      if (asan_mark_p (stmt, ASAN_MARK_POISON))\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Removing ASAN_MARK unpoison\\n\");\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  release_defs (stmt);\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  next = false;\n+\t\t}\n+\t    }\n+\n+\t  if (next)\n+\t    gsi_next (&gsi);\n+\t}\n+    }\n+}\n+\n+/* Return true when STMT is either ASAN_CHECK call or a call of a function\n+   that can contain an ASAN_CHECK.  */\n+\n+static bool\n+maybe_contains_asan_check (gimple *stmt)\n+{\n+  if (is_gimple_call (stmt))\n+    {\n+      if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n+\treturn false;\n+      else\n+\treturn !(gimple_call_flags (stmt) & ECF_CONST);\n+    }\n+  else if (is_a<gasm *> (stmt))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Sanitize all ASAN_MARK poison calls that are not followed by an ASAN_CHECK\n+   call.  These calls can be removed.  */\n+\n+static void\n+sanitize_asan_mark_poison (void)\n+{\n+  /* 1) Find all BBs that possibly contain an ASAN_CHECK.  */\n+  auto_sbitmap with_check (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_clear (with_check);\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (maybe_contains_asan_check (stmt))\n+\t    {\n+\t      bitmap_set_bit (with_check, bb->index);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  auto_sbitmap can_reach_check (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_clear (can_reach_check);\n+  auto_sbitmap worklist (last_basic_block_for_fn (cfun) + 1);\n+  bitmap_copy (worklist, with_check);\n+\n+  /* 2) Propagate the information to all definitions blocks.  */\n+  while (!bitmap_empty_p (worklist))\n+    {\n+      unsigned i = bitmap_first_set_bit (worklist);\n+      bitmap_clear_bit (worklist, i);\n+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+      gcc_assert (bb);\n+\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!bitmap_bit_p (can_reach_check, e->src->index))\n+\t  {\n+\t    bitmap_set_bit (can_reach_check, e->src->index);\n+\t    bitmap_set_bit (worklist, e->src->index);\n+\t  }\n+    }\n+\n+  /* 3) Iterate all BBs not included in CAN_REACH_CHECK BBs and remove poison\n+\tASAN_MARK not followed by a call to function having an ASAN_CHECK.  */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (bitmap_bit_p (can_reach_check, bb->index))\n+\tcontinue;\n+\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  bool prev = true;\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (maybe_contains_asan_check (stmt))\n+\t    break;\n+\t  else if (asan_mark_p (stmt, ASAN_MARK_POISON))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Removing ASAN_MARK poison\\n\");\n+\t      unlink_stmt_vdef (stmt);\n+\t      release_defs (stmt);\n+\t      gsi_remove (&gsi, true);\n+\t      prev = false;\n+\t    }\n+\n+\t  if (prev)\n+\t    gsi_prev (&gsi);\n+\t}\n+    }\n+}\n+\n unsigned int\n pass_sanopt::execute (function *fun)\n {\n   basic_block bb;\n   int asan_num_accesses = 0;\n+  bool contains_asan_mark = false;\n \n   /* Try to remove redundant checks.  */\n   if (optimize\n       && (flag_sanitize\n \t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT\n \t     | SANITIZE_ADDRESS | SANITIZE_VPTR)))\n-    asan_num_accesses = sanopt_optimize (fun);\n+    asan_num_accesses = sanopt_optimize (fun, &contains_asan_mark);\n   else if (flag_sanitize & SANITIZE_ADDRESS)\n     {\n       gimple_stmt_iterator gsi;\n@@ -692,9 +882,17 @@ pass_sanopt::execute (function *fun)\n \t    gimple *stmt = gsi_stmt (gsi);\n \t    if (gimple_call_internal_p (stmt, IFN_ASAN_CHECK))\n \t      ++asan_num_accesses;\n+\t    else if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n+\t      contains_asan_mark = true;\n \t  }\n     }\n \n+  if (contains_asan_mark)\n+    {\n+      sanitize_asan_mark_unpoison ();\n+      sanitize_asan_mark_poison ();\n+    }\n+\n   bool use_calls = ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n     && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n "}]}