{"sha": "e80c2726d26a882c2ef35108b46aa5981a7a4513", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwYzI3MjZkMjZhODgyYzJlZjM1MTA4YjQ2YWE1OTgxYTdhNDUxMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-10T09:16:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-10T09:16:22Z"}, "message": "tree.h (get_object_alignment): Adjust prototype.\n\n2010-08-10  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (get_object_alignment): Adjust prototype.\n\t* builtins.c (get_object_alignment): Return unsigned int,\n\tdrop the align parameter.  Handle MEM_REF, MISALIGNED_INDIRECT_REF\n\tand TARGET_MEM_REF properly.\n\t(get_pointer_alignment): Adjust.\n\t* emit-rtl.c (get_mem_align_offset): Adjust comment.\n\t(set_mem_attributes_minus_bitpos): Adjust.\n\t* tree-ssa-ccp.c (get_value_from_alignment): Adjust.\n\nFrom-SVN: r163051", "tree": {"sha": "69f85b0d583ceda0fdc88c84ebf0b408827b5505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69f85b0d583ceda0fdc88c84ebf0b408827b5505"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e80c2726d26a882c2ef35108b46aa5981a7a4513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80c2726d26a882c2ef35108b46aa5981a7a4513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80c2726d26a882c2ef35108b46aa5981a7a4513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80c2726d26a882c2ef35108b46aa5981a7a4513/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a024390f71187444954cc0001bdea390fb31551f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a024390f71187444954cc0001bdea390fb31551f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a024390f71187444954cc0001bdea390fb31551f"}], "stats": {"total": 206, "additions": 135, "deletions": 71}, "files": [{"sha": "49a95d0cd736be8bba419af119dbbd436e025354", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e80c2726d26a882c2ef35108b46aa5981a7a4513", "patch": "@@ -1,3 +1,14 @@\n+2010-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (get_object_alignment): Adjust prototype.\n+\t* builtins.c (get_object_alignment): Return unsigned int,\n+\tdrop the align parameter.  Handle MEM_REF, MISALIGNED_INDIRECT_REF\n+\tand TARGET_MEM_REF properly.\n+\t(get_pointer_alignment): Adjust.\n+\t* emit-rtl.c (get_mem_align_offset): Adjust comment.\n+\t(set_mem_attributes_minus_bitpos): Adjust.\n+\t* tree-ssa-ccp.c (get_value_from_alignment): Adjust.\n+\n 2010-08-10  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-copy.c (set_copy_of_val): Use operand_equal_p."}, {"sha": "3d5ca33989cd1868ce42b7def2fe7762842293cb", "filename": "gcc/builtins.c", "status": "modified", "additions": 119, "deletions": 65, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e80c2726d26a882c2ef35108b46aa5981a7a4513", "patch": "@@ -267,81 +267,135 @@ called_as_built_in (tree node)\n }\n \n /* Return the alignment in bits of EXP, an object.\n-   Don't return more than MAX_ALIGN no matter what, ALIGN is the inital\n-   guessed alignment e.g. from type alignment.  */\n+   Don't return more than MAX_ALIGN no matter what.  */\n \n-int\n-get_object_alignment (tree exp, unsigned int align, unsigned int max_align)\n+unsigned int\n+get_object_alignment (tree exp, unsigned int max_align)\n {\n-  unsigned int inner;\n-\n-  inner = max_align;\n-  if (handled_component_p (exp))\n-   {\n-      HOST_WIDE_INT bitsize, bitpos;\n-      tree offset;\n-      enum machine_mode mode;\n-      int unsignedp, volatilep;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int unsignedp, volatilep;\n+  unsigned int align, inner;\n \n-      exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t &mode, &unsignedp, &volatilep, true);\n-      if (bitpos)\n-\tinner = MIN (inner, (unsigned) (bitpos & -bitpos));\n-      while (offset)\n-\t{\n-\t  tree next_offset;\n+  /* Get the innermost object and the constant (bitpos) and possibly\n+     variable (offset) offset of the access.  */\n+  exp = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t     &mode, &unsignedp, &volatilep, true);\n \n-\t  if (TREE_CODE (offset) == PLUS_EXPR)\n-\t    {\n-\t      next_offset = TREE_OPERAND (offset, 0);\n-\t      offset = TREE_OPERAND (offset, 1);\n-\t    }\n-\t  else\n-\t    next_offset = NULL;\n-\t  if (host_integerp (offset, 1))\n-\t    {\n-\t      /* Any overflow in calculating offset_bits won't change\n-\t\t the alignment.  */\n-\t      unsigned offset_bits\n-\t\t= ((unsigned) tree_low_cst (offset, 1) * BITS_PER_UNIT);\n-\n-\t      if (offset_bits)\n-\t\tinner = MIN (inner, (offset_bits & -offset_bits));\n-\t    }\n-\t  else if (TREE_CODE (offset) == MULT_EXPR\n-\t\t   && host_integerp (TREE_OPERAND (offset, 1), 1))\n-\t    {\n-\t      /* Any overflow in calculating offset_factor won't change\n-\t\t the alignment.  */\n-\t      unsigned offset_factor\n-\t\t= ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n-\t\t   * BITS_PER_UNIT);\n-\n-\t      if (offset_factor)\n-\t\tinner = MIN (inner, (offset_factor & -offset_factor));\n-\t    }\n-\t  else\n-\t    {\n-\t      inner = MIN (inner, BITS_PER_UNIT);\n-\t      break;\n-\t    }\n-\t  offset = next_offset;\n-\t}\n-    }\n+  /* Extract alignment information from the innermost object and\n+     possibly adjust bitpos and offset.  */\n   if (TREE_CODE (exp) == CONST_DECL)\n     exp = DECL_INITIAL (exp);\n   if (DECL_P (exp)\n       && TREE_CODE (exp) != LABEL_DECL)\n-    align = MIN (inner, DECL_ALIGN (exp));\n-#ifdef CONSTANT_ALIGNMENT\n+    align = DECL_ALIGN (exp);\n   else if (CONSTANT_CLASS_P (exp))\n-    align = MIN (inner, (unsigned)CONSTANT_ALIGNMENT (exp, align));\n+    {\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+#ifdef CONSTANT_ALIGNMENT\n+      align = (unsigned)CONSTANT_ALIGNMENT (exp, align);\n #endif\n-  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR\n-\t   || TREE_CODE (exp) == INDIRECT_REF)\n-    align = MIN (TYPE_ALIGN (TREE_TYPE (exp)), inner);\n+    }\n+  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n+    align = TYPE_ALIGN (TREE_TYPE (exp));\n+  else if (TREE_CODE (exp) == INDIRECT_REF)\n+    align = TYPE_ALIGN (TREE_TYPE (exp));\n+  else if (TREE_CODE (exp) == MISALIGNED_INDIRECT_REF)\n+    {\n+      tree op1 = TREE_OPERAND (exp, 1);\n+      align = integer_zerop (op1) ? BITS_PER_UNIT : TREE_INT_CST_LOW (op1);\n+    }\n+  else if (TREE_CODE (exp) == MEM_REF)\n+    {\n+      tree addr = TREE_OPERAND (exp, 0);\n+      if (TREE_CODE (addr) == BIT_AND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n+\t{\n+\t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n+\t\t    & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n+\t  align *= BITS_PER_UNIT;\n+\t  addr = TREE_OPERAND (addr, 0);\n+\t}\n+      else\n+\talign = BITS_PER_UNIT;\n+      if (TREE_CODE (addr) == ADDR_EXPR)\n+\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0),\n+\t\t\t\t\t\t  max_align));\n+      bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n+    }\n+  else if (TREE_CODE (exp) == TARGET_MEM_REF\n+\t   && TMR_SYMBOL (exp))\n+    {\n+      align = get_object_alignment (TMR_SYMBOL (exp), max_align);\n+      if (TMR_OFFSET (exp))\n+        bitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n+      if (TMR_INDEX (exp) && TMR_STEP (exp))\n+\t{\n+\t  unsigned HOST_WIDE_INT step = TREE_INT_CST_LOW (TMR_STEP (exp));\n+\t  align = MIN (align, (step & -step) * BITS_PER_UNIT);\n+\t}\n+      else if (TMR_INDEX (exp))\n+\talign = BITS_PER_UNIT;\n+    }\n   else\n-    align = MIN (align, inner);\n+    align = BITS_PER_UNIT;\n+\n+  /* If there is a non-constant offset part extract the maximum\n+     alignment that can prevail.  */\n+  inner = max_align;\n+  while (offset)\n+    {\n+      tree next_offset;\n+\n+      if (TREE_CODE (offset) == PLUS_EXPR)\n+\t{\n+\t  next_offset = TREE_OPERAND (offset, 0);\n+\t  offset = TREE_OPERAND (offset, 1);\n+\t}\n+      else\n+\tnext_offset = NULL;\n+      if (host_integerp (offset, 1))\n+\t{\n+\t  /* Any overflow in calculating offset_bits won't change\n+\t     the alignment.  */\n+\t  unsigned offset_bits\n+\t    = ((unsigned) tree_low_cst (offset, 1) * BITS_PER_UNIT);\n+\n+\t  if (offset_bits)\n+\t    inner = MIN (inner, (offset_bits & -offset_bits));\n+\t}\n+      else if (TREE_CODE (offset) == MULT_EXPR\n+\t       && host_integerp (TREE_OPERAND (offset, 1), 1))\n+\t{\n+\t  /* Any overflow in calculating offset_factor won't change\n+\t     the alignment.  */\n+\t  unsigned offset_factor\n+\t    = ((unsigned) tree_low_cst (TREE_OPERAND (offset, 1), 1)\n+\t       * BITS_PER_UNIT);\n+\n+\t  if (offset_factor)\n+\t    inner = MIN (inner, (offset_factor & -offset_factor));\n+\t}\n+      else\n+\t{\n+\t  inner = MIN (inner, BITS_PER_UNIT);\n+\t  break;\n+\t}\n+      offset = next_offset;\n+    }\n+\n+  /* Alignment is innermost object alignment adjusted by the constant\n+     and non-constant offset parts.  */\n+  align = MIN (align, inner);\n+  bitpos = bitpos & (align - 1);\n+\n+  /* align and bitpos now specify known low bits of the pointer.\n+     ptr & (align - 1) == bitpos.  */\n+\n+  if (bitpos != 0)\n+    align = (bitpos & -bitpos);\n+\n   return MIN (align, max_align);\n }\n \n@@ -407,7 +461,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \n \tcase ADDR_EXPR:\n \t  /* See what we are pointing at and look at its alignment.  */\n-\t  return get_object_alignment (TREE_OPERAND (exp, 0), align, max_align);\n+\t  return get_object_alignment (TREE_OPERAND (exp, 0), max_align);\n \n \tdefault:\n \t  return align;"}, {"sha": "267d63462f0a112a9f38e443f88fd5f8d88348fc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e80c2726d26a882c2ef35108b46aa5981a7a4513", "patch": "@@ -1459,7 +1459,8 @@ get_mem_align_offset (rtx mem, unsigned int align)\n   /* This function can't use\n      if (!MEM_EXPR (mem) || !MEM_OFFSET (mem)\n \t || !CONST_INT_P (MEM_OFFSET (mem))\n-\t || (get_object_alignment (MEM_EXPR (mem), MEM_ALIGN (mem), align)\n+\t || (MAX (MEM_ALIGN (mem),\n+\t          get_object_alignment (MEM_EXPR (mem), align))\n \t     < align))\n        return -1;\n      else\n@@ -1796,8 +1797,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \n       if (!align_computed && !INDIRECT_REF_P (t))\n \t{\n-\t  unsigned int obj_align\n-\t    = get_object_alignment (t, align, BIGGEST_ALIGNMENT);\n+\t  unsigned int obj_align = get_object_alignment (t, BIGGEST_ALIGNMENT);\n \t  align = MAX (align, obj_align);\n \t}\n     }"}, {"sha": "622fe146315daf6e5021d68fce3fbada6171aacf", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e80c2726d26a882c2ef35108b46aa5981a7a4513", "patch": "@@ -515,8 +515,7 @@ get_value_from_alignment (tree expr)\n     val = bit_value_binop (PLUS_EXPR, TREE_TYPE (expr),\n \t\t\t   TREE_OPERAND (base, 0), TREE_OPERAND (base, 1));\n   else if (base\n-\t   && ((align = get_object_alignment (base, BITS_PER_UNIT,\n-\t\t\t\t\t      BIGGEST_ALIGNMENT))\n+\t   && ((align = get_object_alignment (base, BIGGEST_ALIGNMENT))\n \t\t> BITS_PER_UNIT))\n     {\n       val.lattice_val = CONSTANT;"}, {"sha": "bdf4f727c45ac51c09bf73639c633650a61c0138", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80c2726d26a882c2ef35108b46aa5981a7a4513/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e80c2726d26a882c2ef35108b46aa5981a7a4513", "patch": "@@ -5036,7 +5036,7 @@ extern bool can_trust_pointer_alignment (void);\n extern int get_pointer_alignment (tree, unsigned int);\n extern bool is_builtin_name (const char *);\n extern bool is_builtin_fn (tree);\n-extern int get_object_alignment (tree, unsigned int, unsigned int);\n+extern unsigned int get_object_alignment (tree, unsigned int);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);\n extern tree make_range (tree, int *, tree *, tree *, bool *);"}]}