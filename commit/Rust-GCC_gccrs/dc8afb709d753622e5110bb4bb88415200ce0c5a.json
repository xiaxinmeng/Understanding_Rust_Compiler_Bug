{"sha": "dc8afb709d753622e5110bb4bb88415200ce0c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM4YWZiNzA5ZDc1MzYyMmU1MTEwYmI0YmI4ODQxNTIwMGNlMGM1YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-05-19T07:09:06Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-05-19T07:09:06Z"}, "message": "rtl.h (REG_NREGS): New macro\n\ngcc/\n\t* rtl.h (REG_NREGS): New macro\n\t* alias.c (record_set): Use it.\n\t* cfgcleanup.c (mark_effect): Likewise.\n\t* combine.c (likely_spilled_retval_1): Likewise.\n\t(likely_spilled_retval_p, can_change_dest_mode): Likewise.\n\t(move_deaths, distribute_notes): Likewise.\n\t* cselib.c (cselib_record_set): Likewise.\n\t* df-problems.c (df_simulate_one_insn_forwards): Likewise.\n\t* df-scan.c (df_mark_reg): Likewise.\n\t* dse.c (look_for_hardregs): Likewise.\n\t* dwarf2out.c (reg_loc_descriptor): Likewise.\n\t(multiple_reg_loc_descriptor): Likewise.\n\t* expr.c (write_complex_part, read_complex_part): Likewise.\n\t(emit_move_complex): Likewise.\n\t* haifa-sched.c (setup_ref_regs): Likewise.\n\t* ira-lives.c (mark_hard_reg_live): Likewise.\n\t* lra.c (lra_set_insn_recog_data): Likewise.\n\t* mode-switching.c (create_pre_exit): Likewise.\n\t* postreload.c (reload_combine_recognize_const_pattern): Likewise.\n\t(reload_combine_recognize_pattern): Likewise.\n\t(reload_combine_note_use, move2add_record_mode): Likewise.\n\t(reload_cse_move2add): Likewise.\n\t* reg-stack.c (subst_stack_regs_pat): Likewise.\n\t* regcprop.c (kill_value, copy_value): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\t* regrename.c (verify_reg_in_set, scan_rtx_reg): Likewise.\n\t(build_def_use): Likewise.\n\t* sched-deps.c (mark_insn_reg_birth, mark_reg_death): Likewise.\n\t(deps_analyze_insn): Likewise.\n\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n\t* sel-sched.c (count_occurrences_equiv): Likewise.\n\t* valtrack.c (dead_debug_insert_temp): Likewise.\n\nFrom-SVN: r223337", "tree": {"sha": "25c6e2369912ec1fc912f445b0108ef913286eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25c6e2369912ec1fc912f445b0108ef913286eef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc8afb709d753622e5110bb4bb88415200ce0c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc8afb709d753622e5110bb4bb88415200ce0c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc8afb709d753622e5110bb4bb88415200ce0c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc8afb709d753622e5110bb4bb88415200ce0c5a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53d1bae90176e1e1a605149d6bdfb9c455888289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d1bae90176e1e1a605149d6bdfb9c455888289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d1bae90176e1e1a605149d6bdfb9c455888289"}], "stats": {"total": 177, "additions": 89, "deletions": 88}, "files": [{"sha": "f9f790027aa8c6adcf6c2857863121e14276b3f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1,3 +1,38 @@\n+2015-05-19  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtl.h (REG_NREGS): New macro\n+\t* alias.c (record_set): Use it.\n+\t* cfgcleanup.c (mark_effect): Likewise.\n+\t* combine.c (likely_spilled_retval_1): Likewise.\n+\t(likely_spilled_retval_p, can_change_dest_mode): Likewise.\n+\t(move_deaths, distribute_notes): Likewise.\n+\t* cselib.c (cselib_record_set): Likewise.\n+\t* df-problems.c (df_simulate_one_insn_forwards): Likewise.\n+\t* df-scan.c (df_mark_reg): Likewise.\n+\t* dse.c (look_for_hardregs): Likewise.\n+\t* dwarf2out.c (reg_loc_descriptor): Likewise.\n+\t(multiple_reg_loc_descriptor): Likewise.\n+\t* expr.c (write_complex_part, read_complex_part): Likewise.\n+\t(emit_move_complex): Likewise.\n+\t* haifa-sched.c (setup_ref_regs): Likewise.\n+\t* ira-lives.c (mark_hard_reg_live): Likewise.\n+\t* lra.c (lra_set_insn_recog_data): Likewise.\n+\t* mode-switching.c (create_pre_exit): Likewise.\n+\t* postreload.c (reload_combine_recognize_const_pattern): Likewise.\n+\t(reload_combine_recognize_pattern): Likewise.\n+\t(reload_combine_note_use, move2add_record_mode): Likewise.\n+\t(reload_cse_move2add): Likewise.\n+\t* reg-stack.c (subst_stack_regs_pat): Likewise.\n+\t* regcprop.c (kill_value, copy_value): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t* regrename.c (verify_reg_in_set, scan_rtx_reg): Likewise.\n+\t(build_def_use): Likewise.\n+\t* sched-deps.c (mark_insn_reg_birth, mark_reg_death): Likewise.\n+\t(deps_analyze_insn): Likewise.\n+\t* sched-rgn.c (check_live_1, update_live_1): Likewise.\n+\t* sel-sched.c (count_occurrences_equiv): Likewise.\n+\t* valtrack.c (dead_debug_insert_temp): Likewise.\n+\n 2015-05-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* cfgcleanup.c (mentions_nonequal_regs): Use END_REGNO."}, {"sha": "215ad63f6960ca5688121843049f67a85bf93a84", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1298,12 +1298,7 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \n   gcc_checking_assert (regno < reg_base_value->length ());\n \n-  /* If this spans multiple hard registers, then we must indicate that every\n-     register has an unusable value.  */\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    n = hard_regno_nregs[regno][GET_MODE (dest)];\n-  else\n-    n = 1;\n+  n = REG_NREGS (dest);\n   if (n != 1)\n     {\n       while (--n >= 0)"}, {"sha": "0a6766ba41c880450e85203c0f72594febc85b8d", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -234,8 +234,7 @@ mark_effect (rtx exp, regset nonequal)\n \t  dest = XEXP (exp, 0);\n \t  regno = REGNO (dest);\n \t  if (HARD_REGISTER_NUM_P (regno))\n-\t    bitmap_clear_range (nonequal, regno,\n-\t\t\t\thard_regno_nregs[regno][GET_MODE (dest)]);\n+\t    bitmap_clear_range (nonequal, regno, REG_NREGS (dest));\n \t  else\n \t    bitmap_clear_bit (nonequal, regno);\n \t}\n@@ -251,8 +250,7 @@ mark_effect (rtx exp, regset nonequal)\n \treturn true;\n       regno = REGNO (dest);\n       if (HARD_REGISTER_NUM_P (regno))\n-\tbitmap_set_range (nonequal, regno,\n-\t\t\t  hard_regno_nregs[regno][GET_MODE (dest)]);\n+\tbitmap_set_range (nonequal, regno, REG_NREGS (dest));\n       else\n \tbitmap_set_bit (nonequal, regno);\n       return false;"}, {"sha": "4ea450a66bbf6bbae2209c11661e0c5d44c98424", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -2364,7 +2364,7 @@ likely_spilled_retval_1 (rtx x, const_rtx set, void *data)\n   regno = REGNO (x);\n   if (regno >= info->regno + info->nregs)\n     return;\n-  nregs = hard_regno_nregs[regno][GET_MODE (x)];\n+  nregs = REG_NREGS (x);\n   if (regno + nregs <= info->regno)\n     return;\n   new_mask = (2U << (nregs - 1)) - 1;\n@@ -2399,7 +2399,7 @@ likely_spilled_retval_p (rtx_insn *insn)\n   if (!REG_P (reg) || !targetm.calls.function_value_regno_p (REGNO (reg)))\n     return 0;\n   regno = REGNO (reg);\n-  nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n+  nregs = REG_NREGS (reg);\n   if (nregs == 1)\n     return 0;\n   mask = (2U << (nregs - 1)) - 1;\n@@ -2471,8 +2471,7 @@ can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n      registers than the old mode.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return (HARD_REGNO_MODE_OK (regno, mode)\n-\t    && (hard_regno_nregs[regno][GET_MODE (x)]\n-\t\t>= hard_regno_nregs[regno][mode]));\n+\t    && REG_NREGS (x) >= hard_regno_nregs[regno][mode]);\n \n   /* Or a pseudo that is only used once.  */\n   return (regno < reg_n_sets_max\n@@ -13474,7 +13473,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n \t\t\t&& (GET_MODE_SIZE (GET_MODE (XEXP (note, 0)))\n \t\t\t    < GET_MODE_SIZE (GET_MODE (x)))))\n \t\t   && regno < FIRST_PSEUDO_REGISTER\n-\t\t   && hard_regno_nregs[regno][GET_MODE (x)] > 1)\n+\t\t   && REG_NREGS (x) > 1)\n \t    {\n \t      unsigned int ourend = END_HARD_REGNO (x);\n \t      unsigned int i, offset;\n@@ -14069,8 +14068,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t\t be dead; so we recourse, and the recursive call then finds\n \t\t the previous insn that used this register.  */\n \n-\t      if (place && regno < FIRST_PSEUDO_REGISTER\n-\t\t  && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] > 1)\n+\t      if (place && REG_NREGS (XEXP (note, 0)) > 1)\n \t\t{\n \t\t  unsigned int endregno = END_HARD_REGNO (XEXP (note, 0));\n \t\t  bool all_used = true;"}, {"sha": "29705cc07dc1bd6ebc0758fe821d5520f50c5bc3", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -2371,16 +2371,15 @@ cselib_invalidate_rtx_note_stores (rtx dest, const_rtx ignore ATTRIBUTE_UNUSED,\n static void\n cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n {\n-  int dreg = REG_P (dest) ? (int) REGNO (dest) : -1;\n-\n   if (src_elt == 0 || side_effects_p (dest))\n     return;\n \n-  if (dreg >= 0)\n+  if (REG_P (dest))\n     {\n+      unsigned int dreg = REGNO (dest);\n       if (dreg < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int n = hard_regno_nregs[dreg][GET_MODE (dest)];\n+\t  unsigned int n = REG_NREGS (dest);\n \n \t  if (n > max_value_regs)\n \t    max_value_regs = n;"}, {"sha": "aca8c749a6e91fef962b35b393178e378e250603", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -3576,8 +3576,7 @@ df_simulate_one_insn_forwards (basic_block bb, rtx_insn *insn, bitmap live)\n \t    rtx reg = XEXP (link, 0);\n \t    int regno = REGNO (reg);\n \t    if (HARD_REGISTER_NUM_P (regno))\n-\t      bitmap_clear_range (live, regno,\n-\t\t\t\t  hard_regno_nregs[regno][GET_MODE (reg)]);\n+\t      bitmap_clear_range (live, regno, REG_NREGS (reg));\n \t    else\n \t      bitmap_clear_bit (live, regno);\n \t  }"}, {"sha": "db5aa40e255ac3905f894404385de2b5c313d062", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -3516,10 +3516,7 @@ df_mark_reg (rtx reg, void *vset)\n   gcc_assert (GET_MODE (reg) != BLKmode);\n \n   if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int n = hard_regno_nregs[regno][GET_MODE (reg)];\n-      bitmap_set_range (set, regno, n);\n-    }\n+    bitmap_set_range (set, regno, REG_NREGS (reg));\n   else\n     bitmap_set_bit (set, regno);\n }"}, {"sha": "291c0ab19925534e8b3e542dc5b97912e3586161", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1876,11 +1876,7 @@ look_for_hardregs (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n \n   if (REG_P (x)\n       && HARD_REGISTER_P (x))\n-    {\n-      unsigned int regno = REGNO (x);\n-      bitmap_set_range (regs_set, regno,\n-\t\t\thard_regno_nregs[regno][GET_MODE (x)]);\n-    }\n+    bitmap_set_range (regs_set, REGNO (x), REG_NREGS (x));\n }\n \n /* Helper function for replace_read and record_store."}, {"sha": "cc7ac84e48ac4ac8969f90920373a08eba3bbfeb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -11147,7 +11147,7 @@ reg_loc_descriptor (rtx rtl, enum var_init_status initialized)\n \n   regs = targetm.dwarf_register_span (rtl);\n \n-  if (hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)] > 1 || regs)\n+  if (REG_NREGS (rtl) > 1 || regs)\n     return multiple_reg_loc_descriptor (rtl, regs, initialized);\n   else\n     {\n@@ -11204,7 +11204,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs,\n #endif\n \n       gcc_assert ((unsigned) DBX_REGISTER_NUMBER (reg) == dbx_reg_number (rtl));\n-      nregs = hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)];\n+      nregs = REG_NREGS (rtl);\n \n       size = GET_MODE_SIZE (GET_MODE (rtl)) / nregs;\n "}, {"sha": "3259bd1f1266f04db1836519675e5a350988d336", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -3051,7 +3051,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n \t where the natural size of floating-point regs is 32-bit.  */\n       || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n-\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0))\n+\t  && REG_NREGS (cplx) % 2 == 0))\n     {\n       rtx part = simplify_gen_subreg (imode, cplx, cmode,\n \t\t\t\t      imag_p ? GET_MODE_SIZE (imode) : 0);\n@@ -3116,7 +3116,7 @@ read_complex_part (rtx cplx, bool imag_p)\n \t where the natural size of floating-point regs is 32-bit.  */\n       || (REG_P (cplx)\n \t  && REGNO (cplx) < FIRST_PSEUDO_REGISTER\n-\t  && hard_regno_nregs[REGNO (cplx)][cmode] % 2 == 0))\n+\t  && REG_NREGS (cplx) % 2 == 0))\n     {\n       rtx ret = simplify_gen_subreg (imode, cplx, cmode,\n \t\t\t\t     imag_p ? GET_MODE_SIZE (imode) : 0);\n@@ -3346,10 +3346,10 @@ emit_move_complex (machine_mode mode, rtx x, rtx y)\n       && optab_handler (mov_optab, GET_MODE_INNER (mode)) != CODE_FOR_nothing\n       && !(REG_P (x)\n \t   && HARD_REGISTER_P (x)\n-\t   && hard_regno_nregs[REGNO (x)][mode] == 1)\n+\t   && REG_NREGS (x) == 1)\n       && !(REG_P (y)\n \t   && HARD_REGISTER_P (y)\n-\t   && hard_regno_nregs[REGNO (y)][mode] == 1))\n+\t   && REG_NREGS (y) == 1))\n     try_int = false;\n   /* Not possible if the values are inherently not adjacent.  */\n   else if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)"}, {"sha": "af9b364052ed2e1286b0bc0c50eaf482d0df0f2d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1040,8 +1040,7 @@ setup_ref_regs (rtx x)\n     {\n       regno = REGNO (x);\n       if (HARD_REGISTER_NUM_P (regno))\n-\tbitmap_set_range (region_ref_regs, regno,\n-\t\t\t  hard_regno_nregs[regno][GET_MODE (x)]);\n+\tbitmap_set_range (region_ref_regs, regno, REG_NREGS (x));\n       else\n \tbitmap_set_bit (region_ref_regs, REGNO (x));\n       return;"}, {"sha": "307696a7730bc7115a58e639180ae1b3d5442a9b", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -352,7 +352,7 @@ mark_hard_reg_live (rtx reg)\n \n   if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n-      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n+      int last = END_REGNO (reg);\n       enum reg_class aclass, pclass;\n \n       while (regno < last)"}, {"sha": "7c336366d8d5ab1ea1adcab4cafed1a8b6be7535", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1104,10 +1104,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t    regno = REGNO (XEXP (XEXP (link, 0), 0));\n \t    lra_assert (regno < FIRST_PSEUDO_REGISTER);\n \t    /* It is an argument register.  */\n-\t    for (i = (hard_regno_nregs\n-\t\t      [regno][GET_MODE (XEXP (XEXP (link, 0), 0))]) - 1;\n-\t\t i >= 0;\n-\t\t i--)\n+\t    for (i = REG_NREGS (XEXP (XEXP (link, 0), 0)) - 1; i >= 0; i--)\n \t      arg_hard_regs[n_hard_regs++] = regno + i;\n \t  }\n       if (n_hard_regs != 0)"}, {"sha": "40d5b19c33c4d31f98493d95874a8079f2ebb0fa", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -267,7 +267,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t    && GET_CODE ((ret_reg = XEXP (PATTERN (last_insn), 0))) == REG)\n \t  {\n \t    int ret_start = REGNO (ret_reg);\n-\t    int nregs = hard_regno_nregs[ret_start][GET_MODE (ret_reg)];\n+\t    int nregs = REG_NREGS (ret_reg);\n \t    int ret_end = ret_start + nregs;\n \t    bool short_block = false;\n \t    bool multi_reg_return = false;"}, {"sha": "e2790ee9ed7131962d959aac9d8a97f931f65c08", "filename": "gcc/postreload.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -971,7 +971,7 @@ reload_combine_recognize_const_pattern (rtx_insn *insn)\n   reg = SET_DEST (set);\n   src = SET_SRC (set);\n   if (!REG_P (reg)\n-      || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1\n+      || REG_NREGS (reg) != 1\n       || GET_MODE (reg) != Pmode\n       || reg == stack_pointer_rtx)\n     return false;\n@@ -1106,8 +1106,7 @@ reload_combine_recognize_pattern (rtx_insn *insn)\n \n   reg = SET_DEST (set);\n   src = SET_SRC (set);\n-  if (!REG_P (reg)\n-      || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1)\n+  if (!REG_P (reg) || REG_NREGS (reg) != 1)\n     return false;\n \n   regno = REGNO (reg);\n@@ -1563,7 +1562,7 @@ reload_combine_note_use (rtx *xp, rtx_insn *insn, int ruid, rtx containing_mem)\n \t/* No spurious USEs of pseudo registers may remain.  */\n \tgcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n-\tnregs = hard_regno_nregs[regno][GET_MODE (x)];\n+\tnregs = REG_NREGS (x);\n \n \t/* We can't substitute into multi-hard-reg uses.  */\n \tif (nregs > 1)\n@@ -1695,7 +1694,7 @@ move2add_record_mode (rtx reg)\n   else if (REG_P (reg))\n     {\n       regno = REGNO (reg);\n-      nregs = hard_regno_nregs[regno][mode];\n+      nregs = REG_NREGS (reg);\n     }\n   else\n     gcc_unreachable ();\n@@ -2135,7 +2134,7 @@ reload_cse_move2add (rtx_insn *first)\n \t\t number of calls to gen_rtx_SET to avoid memory\n \t\t allocation if possible.  */\n \t      && SCALAR_INT_MODE_P (GET_MODE (XEXP (cnd, 0)))\n-\t      && hard_regno_nregs[REGNO (XEXP (cnd, 0))][GET_MODE (XEXP (cnd, 0))] == 1\n+\t      && REG_NREGS (XEXP (cnd, 0)) == 1\n \t      && CONST_INT_P (XEXP (cnd, 1)))\n \t    {\n \t      rtx implicit_set ="}, {"sha": "b6ed778aa3cc4ef915de7b0216ce88d96af6de97", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1470,8 +1470,7 @@ subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n \t  case CALL:\n \t    {\n \t      int count;\n-\t      for (count = hard_regno_nregs[REGNO (*dest)][GET_MODE (*dest)];\n-\t\t   --count >= 0;)\n+\t      for (count = REG_NREGS (*dest); --count >= 0;)\n \t\t{\n \t\t  regstack->reg[++regstack->top] = REGNO (*dest) + count;\n \t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest) + count);"}, {"sha": "19bcec507b3c7862201a15339a671643e326e451", "filename": "gcc/regcprop.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -207,12 +207,7 @@ kill_value (const_rtx x, struct value_data *vd)\n       x = tmp ? tmp : SUBREG_REG (x);\n     }\n   if (REG_P (x))\n-    {\n-      unsigned int regno = REGNO (x);\n-      unsigned int n = hard_regno_nregs[regno][GET_MODE (x)];\n-\n-      kill_value_regno (regno, n, vd);\n-    }\n+    kill_value_regno (REGNO (x), REG_NREGS (x), vd);\n }\n \n /* Remember that REGNO is valid in MODE.  */\n@@ -333,8 +328,8 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n     return;\n \n   /* If SRC and DEST overlap, don't record anything.  */\n-  dn = hard_regno_nregs[dr][GET_MODE (dest)];\n-  sn = hard_regno_nregs[sr][GET_MODE (dest)];\n+  dn = REG_NREGS (dest);\n+  sn = REG_NREGS (src);\n   if ((dr > sr && dr < sr + sn)\n       || (sr > dr && sr < dr + dn))\n     return;\n@@ -1035,8 +1030,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\t  copy_value (dest, SET_SRC (x), vd);\n \t\t  ksvd.ignore_set_reg = dest;\n \t\t  set_regno = REGNO (dest);\n-\t\t  set_nregs\n-\t\t    = hard_regno_nregs[set_regno][GET_MODE (dest)];\n+\t\t  set_nregs = REG_NREGS (dest);\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "3bcb9f08b24c3ac620f77a233cda9cfa3884fdc7", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -983,7 +983,7 @@ verify_reg_in_set (rtx op, HARD_REG_SET *pset)\n     return false;\n \n   regno = REGNO (op);\n-  nregs = hard_regno_nregs[regno][GET_MODE (op)];\n+  nregs = REG_NREGS (op);\n   all_live = all_dead = true;\n   while (nregs-- > 0)\n     if (TEST_HARD_REG_BIT (*pset, regno + nregs))\n@@ -1036,9 +1036,8 @@ scan_rtx_reg (rtx_insn *insn, rtx *loc, enum reg_class cl, enum scan_actions act\n {\n   struct du_head **p;\n   rtx x = *loc;\n-  machine_mode mode = GET_MODE (x);\n   unsigned this_regno = REGNO (x);\n-  int this_nregs = hard_regno_nregs[this_regno][mode];\n+  int this_nregs = REG_NREGS (x);\n \n   if (action == mark_write)\n     {\n@@ -1624,13 +1623,8 @@ build_def_use (basic_block bb)\n \t\t  && !(untracked_operands & (1 << i))\n \t\t  && REG_P (op)\n \t\t  && !verify_reg_tracked (op))\n-\t\t{\n-\t\t  machine_mode mode = GET_MODE (op);\n-\t\t  unsigned this_regno = REGNO (op);\n-\t\t  unsigned this_nregs = hard_regno_nregs[this_regno][mode];\n-\t\t  create_new_chain (this_regno, this_nregs, NULL, NULL,\n-\t\t\t\t    NO_REGS);\n-\t\t}\n+\t\tcreate_new_chain (REGNO (op), REG_NREGS (op), NULL, NULL,\n+\t\t\t\t  NO_REGS);\n \t    }\n \n \t  if (fail_current_block)"}, {"sha": "4049d192909364fa7fe7b5d8d09676ae26d75efc", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1697,6 +1697,14 @@ inline rtx_insn *JUMP_LABEL_AS_INSN (const rtx_insn *insn)\n   (df_ref_change_reg_with_loc (REGNO (RTX), N, RTX), XCUINT (RTX, 0, REG) = N)\n #define SET_REGNO_RAW(RTX,N) (XCUINT (RTX, 0, REG) = N)\n \n+/* Return the number of consecutive registers in a REG.  This is always\n+   1 for pseudo registers and is determined by HARD_REGNO_NREGS for\n+   hard registers.  */\n+#define REG_NREGS(RTX) \\\n+  (REGNO (RTX) < FIRST_PSEUDO_REGISTER \\\n+   ? (unsigned int) hard_regno_nregs[REGNO (RTX)][GET_MODE (RTX)] \\\n+   : 1)\n+\n /* ORIGINAL_REGNO holds the number the register originally had; for a\n    pseudo register turned into a hard reg this will hold the old pseudo\n    register number.  */"}, {"sha": "3563095c62edbb8308c7b3ba842dd7b8612c3927", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -2125,8 +2125,7 @@ mark_insn_reg_birth (rtx insn, rtx reg, bool clobber_p, bool unused_p)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    mark_insn_hard_regno_birth (insn, regno,\n-\t\t\t\thard_regno_nregs[regno][GET_MODE (reg)],\n+    mark_insn_hard_regno_birth (insn, regno, REG_NREGS (reg),\n \t\t\t\tclobber_p, unused_p);\n   else\n     mark_insn_pseudo_birth (insn, regno, clobber_p, unused_p);\n@@ -2185,7 +2184,7 @@ mark_reg_death (rtx reg)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    mark_hard_regno_death (regno, hard_regno_nregs[regno][GET_MODE (reg)]);\n+    mark_hard_regno_death (regno, REG_NREGS (reg));\n   else\n     mark_pseudo_death (regno);\n }\n@@ -3645,7 +3644,7 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n \t  rtx_insn_list *cond_deps = NULL;\n \t  t = XEXP (t, 0);\n \t  regno = REGNO (t);\n-\t  nregs = hard_regno_nregs[regno][GET_MODE (t)];\n+\t  nregs = REG_NREGS (t);\n \t  while (nregs-- > 0)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[regno + nregs];"}, {"sha": "4dac7e284e63585bd25fdf9327070ba57eace915", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -1720,7 +1720,7 @@ check_live_1 (int src, rtx x)\n       if (regno < FIRST_PSEUDO_REGISTER)\n \t{\n \t  /* Check for hard registers.  */\n-\t  int j = hard_regno_nregs[regno][GET_MODE (reg)];\n+\t  int j = REG_NREGS (reg);\n \t  while (--j >= 0)\n \t    {\n \t      for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n@@ -1803,8 +1803,7 @@ update_live_1 (int src, rtx x)\n \t  basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n \t  if (HARD_REGISTER_NUM_P (regno))\n-\t    bitmap_set_range (df_get_live_in (b), regno,\n-\t\t\t      hard_regno_nregs[regno][GET_MODE (reg)]);\n+\t    bitmap_set_range (df_get_live_in (b), regno, REG_NREGS (reg));\n \t  else\n \t    bitmap_set_bit (df_get_live_in (b), regno);\n \t}"}, {"sha": "668c433dab0c4efd98eb1204903e44b9b79b4f40", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -825,9 +825,7 @@ count_occurrences_equiv (const_rtx what, const_rtx where)\n \t{\n \t  /* Bail out if mode is different or more than one register is\n \t     used.  */\n-\t  if (GET_MODE (x) != GET_MODE (what)\n-\t      || (HARD_REGISTER_P (x)\n-\t\t  && hard_regno_nregs[REGNO (x)][GET_MODE (x)] > 1))\n+\t  if (GET_MODE (x) != GET_MODE (what) || REG_NREGS (x) > 1)\n \t    return 0;\n \t  count += 1;\n \t}"}, {"sha": "d5d4578ee5bd9089669541d2acf620d3315f90ee", "filename": "gcc/valtrack.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc8afb709d753622e5110bb4bb88415200ce0c5a/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=dc8afb709d753622e5110bb4bb88415200ce0c5a", "patch": "@@ -671,9 +671,7 @@ dead_debug_insert_temp (struct dead_debug_local *debug, unsigned int uregno,\n \t     the debug temp to.  ??? We could bind the debug_expr to a\n \t     CONCAT or PARALLEL with the split multi-registers, and\n \t     replace them as we found the corresponding sets.  */\n-\t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n-\t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n+\t  else if (REG_NREGS (reg) != REG_NREGS (dest))\n \t    breg = NULL;\n \t  /* Ok, it's the same (hardware) REG, but with a different\n \t     mode, so SUBREG it.  */\n@@ -695,7 +693,7 @@ dead_debug_insert_temp (struct dead_debug_local *debug, unsigned int uregno,\n \t     setting REG in its mode would, we won't know what to bind\n \t     the debug temp to.  */\n \t  else if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && (hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]\n+\t\t   && (REG_NREGS (reg)\n \t\t       != hard_regno_nregs[REGNO (reg)][GET_MODE (dest)]))\n \t    breg = NULL;\n \t  /* Yay, we can use SRC, just adjust its mode.  */"}]}