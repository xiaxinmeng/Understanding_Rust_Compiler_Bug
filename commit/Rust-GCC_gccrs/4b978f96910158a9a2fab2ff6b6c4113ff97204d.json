{"sha": "4b978f96910158a9a2fab2ff6b6c4113ff97204d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5NzhmOTY5MTAxNThhOWEyZmFiMmZmNmI2YzQxMTNmZjk3MjA0ZA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-06-06T23:01:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-06-06T23:01:45Z"}, "message": "re PR c++/53567 (\"ICE: Error reporting routines re-entered\" on missing enum entry)\n\n/cp\n2012-06-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53567\n\t* typeck.c (cp_perform_integral_promotions): New, like\n\tperform_integral_promotions but also takes a tsubst_flags_t parameter.\n\t(pointer_diff): Add tsubst_flags_t parameter.\n\t(decay_conversion, cp_default_conversion, cp_build_array_ref,\n\tcp_build_binary_op, cp_build_unary_op, build_static_cast_1,\n\tbuild_reinterpret_cast_1, cp_build_modify_expr,\n\tconvert_for_assignment): Adjust.\n\t* optimize.c (build_delete_destructor_body): Adjust.\n\t* init.c (expand_virtual_init, expand_default_init, build_new_1,\n\tbuild_new, build_vec_delete_1, build_vec_init, build_delete): Adjust.\n\t(construct_virtual_base): Adjust LOOKUP_COMPLAIN -> 0.\n\t* class.c (build_base_path): Adjust.\n\t* decl.c (compute_array_index_type, finish_destructor_body): Likewise.\n\t* method.c (synthesized_method_walk): Adjust flag and complain.\n\t* rtti.c (ifnonnull): Add tsubst_flags_t parameter.\n\t(build_typeid, build_dynamic_cast_1): Adjust.\n\t* except.c (initialize_handler_parm): Likewise.\n\t* typeck2.c (process_init_constructor_record): Likewise.\n\t* pt.c (tsubst_friend_class): Don't change flags.\n\t* semantics.c (finish_goto_stmt, handle_omp_for_class_iterator,\n\tfinish_static_assert): Likewise.\n\t* parser.c (cp_parser_lookup_name): Just pass 0 as flags to\n\tlookup_name_real.\n\t* call.c (build_op_delete_call): Add tsubst_flags_t parameter.\n\t(convert_like_real, convert_arg_to_ellipsis, convert_for_arg_passing):\n\tAdjust.\n\t(standard_conversion): Adjust LOOKUP_COMPLAIN -> 0.\n\t(implicit_conversion): Mask out tf_error with a FIXME.\n\t(build_user_type_conversion_1, build_new_op_1, build_over_call): Use\n\tcomplain & tf_error instead of flags & LOOKUP_COMPLAIN.\n\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n\tbuild_up_reference, convert_to_reference, cp_convert,\n\tcp_convert_and_check, ocp_convert, convert_force): Add tsubst_flags_t\n\tparameter.\n\t(convert_to_reference, ocp_convert): Use complain & tf_error instead\n\tof flags & LOOKUP_COMPLAIN.\n\t(convert_force): Adjust LOOKUP_COMPLAIN -> 0.\n\t* name-lookup.c (identifier_type_value_1, lookup_qualified_name,\n\tlookup_name_real, lookup_function_nonclass, lookup_name,\n\tlookup_name_prefer_type): Adjust LOOKUP_COMPLAIN -> 0.\n\t* cp-tree.h: Adjust prototypes; remove LOOKUP_COMPLAIN.\n\n/testsuite\n2012-06-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53567\n\t* g++.dg/cpp0x/alias-decl-19.C: New.\n\nFrom-SVN: r188283", "tree": {"sha": "f33c10cac813a9df3728ad7933a633ef664460ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f33c10cac813a9df3728ad7933a633ef664460ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b978f96910158a9a2fab2ff6b6c4113ff97204d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b978f96910158a9a2fab2ff6b6c4113ff97204d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b978f96910158a9a2fab2ff6b6c4113ff97204d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b978f96910158a9a2fab2ff6b6c4113ff97204d/comments", "author": null, "committer": null, "parents": [{"sha": "6f07a821c41399a6b87094816a7d0f7beefa5faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f07a821c41399a6b87094816a7d0f7beefa5faa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f07a821c41399a6b87094816a7d0f7beefa5faa"}], "stats": {"total": 631, "additions": 389, "deletions": 242}, "files": [{"sha": "e8a11f31321843fbc91b9daf193298de65e1f580", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1,3 +1,48 @@\n+2012-06-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53567\n+\t* typeck.c (cp_perform_integral_promotions): New, like\n+\tperform_integral_promotions but also takes a tsubst_flags_t parameter.\n+\t(pointer_diff): Add tsubst_flags_t parameter.\n+\t(decay_conversion, cp_default_conversion, cp_build_array_ref,\n+\tcp_build_binary_op, cp_build_unary_op, build_static_cast_1,\n+\tbuild_reinterpret_cast_1, cp_build_modify_expr,\n+\tconvert_for_assignment): Adjust.\n+\t* optimize.c (build_delete_destructor_body): Adjust.\n+\t* init.c (expand_virtual_init, expand_default_init, build_new_1,\n+\tbuild_new, build_vec_delete_1, build_vec_init, build_delete): Adjust.\n+\t(construct_virtual_base): Adjust LOOKUP_COMPLAIN -> 0.\n+\t* class.c (build_base_path): Adjust.\n+\t* decl.c (compute_array_index_type, finish_destructor_body): Likewise.\n+\t* method.c (synthesized_method_walk): Adjust flag and complain.\n+\t* rtti.c (ifnonnull): Add tsubst_flags_t parameter.\n+\t(build_typeid, build_dynamic_cast_1): Adjust.\n+\t* except.c (initialize_handler_parm): Likewise.\n+\t* typeck2.c (process_init_constructor_record): Likewise.\n+\t* pt.c (tsubst_friend_class): Don't change flags.\n+\t* semantics.c (finish_goto_stmt, handle_omp_for_class_iterator,\n+\tfinish_static_assert): Likewise.\n+\t* parser.c (cp_parser_lookup_name): Just pass 0 as flags to\n+\tlookup_name_real.\n+\t* call.c (build_op_delete_call): Add tsubst_flags_t parameter.\n+\t(convert_like_real, convert_arg_to_ellipsis, convert_for_arg_passing):\n+\tAdjust.\n+\t(standard_conversion): Adjust LOOKUP_COMPLAIN -> 0.\n+\t(implicit_conversion): Mask out tf_error with a FIXME.\n+\t(build_user_type_conversion_1, build_new_op_1, build_over_call): Use\n+\tcomplain & tf_error instead of flags & LOOKUP_COMPLAIN.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n+\tbuild_up_reference, convert_to_reference, cp_convert,\n+\tcp_convert_and_check, ocp_convert, convert_force): Add tsubst_flags_t\n+\tparameter.\n+\t(convert_to_reference, ocp_convert): Use complain & tf_error instead\n+\tof flags & LOOKUP_COMPLAIN.\n+\t(convert_force): Adjust LOOKUP_COMPLAIN -> 0.\n+\t* name-lookup.c (identifier_type_value_1, lookup_qualified_name,\n+\tlookup_name_real, lookup_function_nonclass, lookup_name,\n+\tlookup_name_prefer_type): Adjust LOOKUP_COMPLAIN -> 0.\n+\t* cp-tree.h: Adjust prototypes; remove LOOKUP_COMPLAIN.\n+\n 2012-06-06  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* decl.c: Do not include output.h."}, {"sha": "09965b321cc1e46f0aa2eea9daaffc396b6b763f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1695,6 +1695,13 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t    |LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND|LOOKUP_PREFER_RVALUE\n \t    |LOOKUP_NO_NARROWING|LOOKUP_PROTECT);\n \n+  /* FIXME: actually we don't want warnings either, but we can't just\n+     have 'complain &= ~(tf_warning|tf_error)' because it would cause\n+     the regression of, eg, g++.old-deja/g++.benjamin/16077.C.\n+     We really ought not to issue that warning until we've committed\n+     to that conversion.  */\n+  complain &= ~tf_error;\n+\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, c_cast_p, flags, complain);\n   else\n@@ -3607,8 +3614,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   cand = tourney (candidates, complain);\n   if (cand == 0)\n     {\n-      if ((flags & LOOKUP_COMPLAIN)\n-\t  && (complain & tf_error))\n+      if (complain & tf_error)\n \t{\n \t  error (\"conversion from %qT to %qT is ambiguous\",\n \t\t fromtype, totype);\n@@ -5098,7 +5104,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t     distinguish between prefix and postfix ++ and\n \t     operator++() was used for both, so we allow this with\n \t     -fpermissive.  */\n-\t  if (flags & LOOKUP_COMPLAIN)\n+\t  else\n \t    {\n \t      const char *msg = (flag_permissive) \n \t\t? G_(\"no %<%D(int)%> declared for postfix %qs,\"\n@@ -5127,7 +5133,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t  break;\n \n \tdefault:\n-\t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n+\t  if (complain & tf_error)\n \t    {\n \t\t/* If one of the arguments of the operator represents\n \t\t   an invalid use of member function pointer, try to report\n@@ -5153,7 +5159,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n       cand = tourney (candidates, complain);\n       if (cand == 0)\n \t{\n-\t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n+\t  if (complain & tf_error)\n \t    {\n \t      op_error (loc, code, code2, arg1, arg2, arg3, TRUE);\n \t      print_z_candidates (loc, candidates);\n@@ -5379,7 +5385,7 @@ non_placement_deallocation_fn_p (tree t)\n tree\n build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t      bool global_p, tree placement,\n-\t\t      tree alloc_fn)\n+\t\t      tree alloc_fn, tsubst_flags_t complain)\n {\n   tree fn = NULL_TREE;\n   tree fns, fnname, type, t;\n@@ -5413,7 +5419,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n     fns = lookup_name_nonclass (fnname);\n \n   /* Strip const and volatile from addr.  */\n-  addr = cp_convert (ptr_type_node, addr);\n+  addr = cp_convert (ptr_type_node, addr, complain);\n \n   if (placement)\n     {\n@@ -5452,8 +5458,13 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t  && FUNCTION_ARG_CHAIN (elt) == void_list_node)\n \t\tgoto ok;\n \t    }\n-\t  permerror (0, \"non-placement deallocation function %q+D\", fn);\n-\t  permerror (input_location, \"selected for placement delete\");\n+\t  if (complain & tf_error)\n+\t    {\n+\t      permerror (0, \"non-placement deallocation function %q+D\", fn);\n+\t      permerror (input_location, \"selected for placement delete\");\n+\t    }\n+\t  else\n+\t    return error_mark_node;\n \tok:;\n \t}\n     }\n@@ -5518,7 +5529,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t  VEC_quick_push (tree, args, addr);\n \t  if (FUNCTION_ARG_CHAIN (fn) != void_list_node)\n \t    VEC_quick_push (tree, args, size);\n-\t  ret = cp_build_function_call_vec (fn, &args, tf_warning_or_error);\n+\t  ret = cp_build_function_call_vec (fn, &args, complain);\n \t  VEC_free (tree, gc, args);\n \t  return ret;\n \t}\n@@ -5531,14 +5542,16 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n      be freed.  */\n   if (alloc_fn)\n     {\n-      if (!placement)\n+      if ((complain & tf_warning)\n+\t  && !placement)\n \twarning (0, \"no corresponding deallocation function for %qD\",\n \t\t alloc_fn);\n       return NULL_TREE;\n     }\n \n-  error (\"no suitable %<operator %s%> for %qT\",\n-\t operator_name_info[(int)code].name, type);\n+  if (complain & tf_error)\n+    error (\"no suitable %<operator %s%> for %qT\",\n+\t   operator_name_info[(int)code].name, type);\n   return error_mark_node;\n }\n \n@@ -5685,9 +5698,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t\t\t\tcomplain);\n \t      if (convs->kind == ck_ref_bind)\n \t\treturn convert_to_reference (totype, expr, CONV_IMPLICIT,\n-\t\t\t\t\t     LOOKUP_NORMAL, NULL_TREE);\n+\t\t\t\t\t     LOOKUP_NORMAL, NULL_TREE,\n+\t\t\t\t\t     complain);\n \t      else\n-\t\treturn cp_convert (totype, expr);\n+\t\treturn cp_convert (totype, expr, complain);\n \t    }\n \t  else if (t->kind == ck_user || !t->bad_p)\n \t    {\n@@ -5712,7 +5726,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tpermerror (DECL_SOURCE_LOCATION (fn),\n \t\t   \"  initializing argument %P of %qD\", argnum, fn);\n \n-      return cp_convert (totype, expr);\n+      return cp_convert (totype, expr, complain);\n     }\n \n   if (issue_conversion_warnings && (complain & tf_warning))\n@@ -5851,7 +5865,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t/* Take the address explicitly rather than via decay_conversion\n \t   to avoid the error about taking the address of a temporary.  */\n \tarray = cp_build_addr_expr (array, complain);\n-\tarray = cp_convert (build_pointer_type (elttype), array);\n+\tarray = cp_convert (build_pointer_type (elttype), array, complain);\n \n \t/* Build up the initializer_list object.  */\n \ttotype = complete_type (totype);\n@@ -6017,7 +6031,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t   reference.  This will adjust the pointer if a derived to\n \t   base conversion is being performed.  */\n \texpr = cp_convert (build_pointer_type (TREE_TYPE (ref_type)),\n-\t\t\t   expr);\n+\t\t\t   expr, complain);\n \t/* Convert the pointer to the desired reference type.  */\n \treturn build_nop (ref_type, expr);\n       }\n@@ -6099,9 +6113,9 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n \t  if (complain & tf_warning)\n \t    warning_at (loc, OPT_Wabi, \"scoped enum %qT will not promote to an \"\n \t\t\t\"integral type in a future version of GCC\", arg_type);\n-\t  arg = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg);\n+\t  arg = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg, complain);\n \t}\n-      arg = perform_integral_promotions (arg);\n+      arg = cp_perform_integral_promotions (arg, complain);\n     }\n \n   arg = require_complete_type (arg);\n@@ -6336,7 +6350,7 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n \t   && COMPLETE_TYPE_P (type)\n \t   && INT_CST_LT_UNSIGNED (TYPE_SIZE (type),\n \t\t\t\t   TYPE_SIZE (integer_type_node)))\n-    val = perform_integral_promotions (val);\n+    val = cp_perform_integral_promotions (val, complain);\n   if ((complain & tf_warning)\n       && warn_suggest_attribute_format)\n     {\n@@ -6487,7 +6501,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (flags & LOOKUP_SPECULATIVE)\n \t{\n \t  if (!speculative_access_check (cand->access_path, access_fn, fn,\n-\t\t\t\t\t !!(flags & LOOKUP_COMPLAIN)))\n+\t\t\t\t\t complain & tf_error))\n \t    return error_mark_node;\n \t}\n       else\n@@ -6500,13 +6514,13 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     {\n       if (DECL_DELETED_FN (fn))\n \t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n+\t  if (complain & tf_error)\n \t    mark_used (fn);\n \t  return error_mark_node;\n \t}\n       if (cand->viable == 1)\n \treturn fn;\n-      else if (!(flags & LOOKUP_COMPLAIN))\n+      else if (!(complain & tf_error))\n \t/* Reject bad conversions now.  */\n \treturn error_mark_node;\n       /* else continue to get conversion error.  */"}, {"sha": "e85aac96c39ed60a015f4667050777eb0bc664d9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -366,7 +366,7 @@ build_base_path (enum tree_code code,\n   /* Now that we've saved expr, build the real null test.  */\n   if (null_test)\n     {\n-      tree zero = cp_convert (TREE_TYPE (expr), nullptr_node);\n+      tree zero = cp_convert (TREE_TYPE (expr), nullptr_node, complain);\n       null_test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t       expr, zero);\n     }"}, {"sha": "22012e25d952ec19be4478bb37c4247451c7fd31", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -4371,37 +4371,34 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n    behaviors relevant to them.  */\n /* Check for access violations.  */\n #define LOOKUP_PROTECT (1 << 0)\n-/* Complain if no suitable member function matching the arguments is\n-   found.  */\n-#define LOOKUP_COMPLAIN (1 << 1)\n-#define LOOKUP_NORMAL (LOOKUP_PROTECT | LOOKUP_COMPLAIN)\n+#define LOOKUP_NORMAL (LOOKUP_PROTECT)\n /* Even if the function found by lookup is a virtual function, it\n    should be called directly.  */\n-#define LOOKUP_NONVIRTUAL (1 << 2)\n+#define LOOKUP_NONVIRTUAL (1 << 1)\n /* Non-converting (i.e., \"explicit\") constructors are not tried.  This flag\n    indicates that we are not performing direct-initialization.  */\n-#define LOOKUP_ONLYCONVERTING (1 << 3)\n+#define LOOKUP_ONLYCONVERTING (1 << 2)\n #define LOOKUP_IMPLICIT (LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING)\n /* If a temporary is created, it should be created so that it lives\n    as long as the current variable bindings; otherwise it only lives\n    until the end of the complete-expression.  It also forces\n    direct-initialization in cases where other parts of the compiler\n    have already generated a temporary, such as reference\n    initialization and the catch parameter.  */\n-#define DIRECT_BIND (1 << 4)\n+#define DIRECT_BIND (1 << 3)\n /* We're performing a user-defined conversion, so more user-defined\n    conversions are not permitted (only built-in conversions).  */\n-#define LOOKUP_NO_CONVERSION (1 << 5)\n+#define LOOKUP_NO_CONVERSION (1 << 4)\n /* The user has explicitly called a destructor.  (Therefore, we do\n    not need to check that the object is non-NULL before calling the\n    destructor.)  */\n-#define LOOKUP_DESTRUCTOR (1 << 6)\n+#define LOOKUP_DESTRUCTOR (1 << 5)\n /* Do not permit references to bind to temporaries.  */\n-#define LOOKUP_NO_TEMP_BIND (1 << 7)\n+#define LOOKUP_NO_TEMP_BIND (1 << 6)\n /* Do not accept objects, and possibly namespaces.  */\n-#define LOOKUP_PREFER_TYPES (1 << 8)\n+#define LOOKUP_PREFER_TYPES (1 << 7)\n /* Do not accept objects, and possibly types.   */\n-#define LOOKUP_PREFER_NAMESPACES (1 << 9)\n+#define LOOKUP_PREFER_NAMESPACES (1 << 8)\n /* Accept types or namespaces.  */\n #define LOOKUP_PREFER_BOTH (LOOKUP_PREFER_TYPES | LOOKUP_PREFER_NAMESPACES)\n /* Return friend declarations and un-declared builtin functions.\n@@ -4894,7 +4891,9 @@ extern tree build_new_op\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_call\t\t\t(tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree, tree);\n+extern tree build_op_delete_call\t\t(enum tree_code, tree, tree,\n+\t\t\t\t\t\t bool, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern bool can_convert\t\t\t\t(tree, tree, tsubst_flags_t);\n extern bool can_convert_arg\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -5001,16 +5000,19 @@ extern void adjust_clone_args\t\t\t(tree);\n extern void deduce_noexcept_on_destructor       (tree);\n \n /* in cvt.c */\n-extern tree convert_to_reference\t\t(tree, tree, int, int, tree);\n+extern tree convert_to_reference\t\t(tree, tree, int, int, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_from_reference\t\t(tree);\n extern tree force_rvalue\t\t\t(tree, tsubst_flags_t);\n-extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n-extern tree cp_convert\t\t\t\t(tree, tree);\n-extern tree cp_convert_and_check                (tree, tree);\n+extern tree ocp_convert\t\t\t\t(tree, tree, int, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree cp_convert\t\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree cp_convert_and_check                (tree, tree, tsubst_flags_t);\n extern tree cp_fold_convert\t\t\t(tree, tree);\n extern tree convert_to_void\t\t\t(tree, impl_conv_void,\n                                  \t\t tsubst_flags_t);\n-extern tree convert_force\t\t\t(tree, tree, int);\n+extern tree convert_force\t\t\t(tree, tree, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_expr_type_conversion\t\t(int, tree, bool);\n extern tree type_promotes_to\t\t\t(tree);\n extern tree perform_qualification_conversions\t(tree, tree);\n@@ -5901,6 +5903,7 @@ extern void check_template_keyword\t\t(tree);\n extern bool check_raw_literal_operator\t\t(const_tree decl);\n extern bool check_literal_operator_args\t\t(const_tree, bool *, bool *);\n extern void maybe_warn_about_useless_cast       (tree, tree, tsubst_flags_t);\n+extern tree cp_perform_integral_promotions      (tree, tsubst_flags_t);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "998d4eb345e719ee414157e8504843bbd3255cd6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 107, "deletions": 90, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -38,10 +38,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"decl.h\"\n #include \"target.h\"\n \n-static tree cp_convert_to_pointer (tree, tree);\n-static tree convert_to_pointer_force (tree, tree);\n+static tree cp_convert_to_pointer (tree, tree, tsubst_flags_t);\n+static tree convert_to_pointer_force (tree, tree, tsubst_flags_t);\n static tree build_type_conversion (tree, tree);\n-static tree build_up_reference (tree, tree, int, tree);\n+static tree build_up_reference (tree, tree, int, tree, tsubst_flags_t);\n static void warn_ref_binding (location_t, tree, tree, tree);\n \n /* Change of width--truncation and extension of integers or reals--\n@@ -74,7 +74,7 @@ static void warn_ref_binding (location_t, tree, tree, tree);\n    else try C-style pointer conversion.  */\n \n static tree\n-cp_convert_to_pointer (tree type, tree expr)\n+cp_convert_to_pointer (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form;\n@@ -89,15 +89,17 @@ cp_convert_to_pointer (tree type, tree expr)\n       intype = complete_type (intype);\n       if (!COMPLETE_TYPE_P (intype))\n \t{\n-\t  error_at (loc, \"can%'t convert from incomplete type %qT to %qT\",\n-\t\t    intype, type);\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"can%'t convert from incomplete type %qT to %qT\",\n+\t\t      intype, type);\n \t  return error_mark_node;\n \t}\n \n       rval = build_type_conversion (type, expr);\n       if (rval)\n \t{\n-\t  if (rval == error_mark_node)\n+\t  if ((complain & tf_error)\n+\t      && rval == error_mark_node)\n \t    error_at (loc, \"conversion of %qE from %qT to %qT is ambiguous\",\n \t\t      expr, intype, type);\n \t  return rval;\n@@ -111,7 +113,7 @@ cp_convert_to_pointer (tree type, tree expr)\n     {\n       if (TYPE_PTRMEMFUNC_P (intype)\n \t  || TREE_CODE (intype) == METHOD_TYPE)\n-\treturn convert_member_func_to_ptr (type, expr, tf_warning_or_error);\n+\treturn convert_member_func_to_ptr (type, expr, complain);\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \treturn build_nop (type, expr);\n       intype = TREE_TYPE (expr);\n@@ -159,17 +161,17 @@ cp_convert_to_pointer (tree type, tree expr)\n \t  if (binfo || same_p)\n \t    {\n \t      if (binfo)\n-\t\texpr = build_base_path (code, expr, binfo, 0,\n-\t\t\t\t\ttf_warning_or_error);\n+\t\texpr = build_base_path (code, expr, binfo, 0, complain);\n \t      /* Add any qualifier conversions.  */\n \t      return build_nop (type, expr);\n \t    }\n \t}\n \n       if (TYPE_PTRMEMFUNC_P (type))\n \t{\n-\t  error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n-\t\t    expr, intype, type);\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t\t      expr, intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -178,20 +180,20 @@ cp_convert_to_pointer (tree type, tree expr)\n   else if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     return convert_ptrmem (type, expr, /*allow_inverse_p=*/false,\n-\t\t\t   /*c_cast_p=*/false, tf_warning_or_error);\n+\t\t\t   /*c_cast_p=*/false, complain);\n   else if (TYPE_PTRMEMFUNC_P (intype))\n     {\n       if (!warn_pmf2ptr)\n \t{\n \t  if (TREE_CODE (expr) == PTRMEM_CST)\n-\t    return cp_convert_to_pointer (type,\n-\t\t\t\t\t  PTRMEM_CST_MEMBER (expr));\n+\t    return cp_convert_to_pointer (type, PTRMEM_CST_MEMBER (expr),\n+\t\t\t\t\t  complain);\n \t  else if (TREE_CODE (expr) == OFFSET_REF)\n \t    {\n \t      tree object = TREE_OPERAND (expr, 0);\n \t      return get_member_function_from_ptrfunc (&object,\n \t\t\t\t\t\t       TREE_OPERAND (expr, 1),\n-\t\t\t\t\t\t       tf_warning_or_error);\n+\t\t\t\t\t\t       complain);\n \t    }\n \t}\n       error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n@@ -201,14 +203,15 @@ cp_convert_to_pointer (tree type, tree expr)\n \n   if (null_ptr_cst_p (expr))\n     {\n-      if (c_inhibit_evaluation_warnings == 0\n+      if ((complain & tf_warning)\n+\t  && c_inhibit_evaluation_warnings == 0\n \t  && !NULLPTR_TYPE_P (TREE_TYPE (expr)))\n \twarning_at (loc, OPT_Wzero_as_null_pointer_constant,\n \t\t    \"zero as null pointer constant\");\n \n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n-\t\t\t\t /*c_cast_p=*/false, tf_warning_or_error);\n+\t\t\t\t /*c_cast_p=*/false, complain);\n \n       if (TYPE_PTRDATAMEM_P (type))\n \t{\n@@ -223,15 +226,17 @@ cp_convert_to_pointer (tree type, tree expr)\n     }\n   else if (TYPE_PTRMEM_P (type) && INTEGRAL_CODE_P (form))\n     {\n-      error_at (loc, \"invalid conversion from %qT to %qT\", intype, type);\n+      if (complain & tf_error)\n+\terror_at (loc, \"invalid conversion from %qT to %qT\", intype, type);\n       return error_mark_node;\n     }\n \n   if (INTEGRAL_CODE_P (form))\n     {\n       if (TYPE_PRECISION (intype) == POINTER_SIZE)\n \treturn build1 (CONVERT_EXPR, type, expr);\n-      expr = cp_convert (c_common_type_for_size (POINTER_SIZE, 0), expr);\n+      expr = cp_convert (c_common_type_for_size (POINTER_SIZE, 0), expr,\n+\t\t\t complain);\n       /* Modes may be different but sizes should be the same.  There\n \t is supposed to be some integral type that is the same width\n \t as a pointer.  */\n@@ -242,10 +247,11 @@ cp_convert_to_pointer (tree type, tree expr)\n     }\n \n   if (type_unknown_p (expr))\n-    return instantiate_type (type, expr, tf_warning_or_error);\n+    return instantiate_type (type, expr, complain);\n \n-  error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n-\t    expr, intype, type);\n+  if (complain & tf_error)\n+    error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t      expr, intype, type);\n   return error_mark_node;\n }\n \n@@ -254,7 +260,7 @@ cp_convert_to_pointer (tree type, tree expr)\n    (such as conversion from sub-type to private super-type).  */\n \n static tree\n-convert_to_pointer_force (tree type, tree expr)\n+convert_to_pointer_force (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree intype = TREE_TYPE (expr);\n   enum tree_code form = TREE_CODE (intype);\n@@ -284,8 +290,7 @@ convert_to_pointer_force (tree type, tree expr)\n \t    return error_mark_node;\n \t  if (binfo)\n \t    {\n-\t      expr = build_base_path (code, expr, binfo, 0,\n-\t\t\t\t      tf_warning_or_error);\n+\t      expr = build_base_path (code, expr, binfo, 0, complain);\n \t      if (expr == error_mark_node)\n \t\t return error_mark_node;\n \t      /* Add any qualifier conversions.  */\n@@ -297,7 +302,7 @@ convert_to_pointer_force (tree type, tree expr)\n \t}\n     }\n \n-  return cp_convert_to_pointer (type, expr);\n+  return cp_convert_to_pointer (type, expr, complain);\n }\n \n /* We are passing something to a function which requires a reference.\n@@ -309,7 +314,8 @@ convert_to_pointer_force (tree type, tree expr)\n      If DIRECT_BIND is set, DECL is the reference we're binding to.  */\n \n static tree\n-build_up_reference (tree type, tree arg, int flags, tree decl)\n+build_up_reference (tree type, tree arg, int flags, tree decl,\n+\t\t    tsubst_flags_t complain)\n {\n   tree rval;\n   tree argtype = TREE_TYPE (arg);\n@@ -351,12 +357,12 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n \treturn error_mark_node;\n       if (binfo == NULL_TREE)\n \treturn error_not_base_type (target_type, argtype);\n-      rval = build_base_path (PLUS_EXPR, rval, binfo, 1,\n-\t\t\t      tf_warning_or_error);\n+      rval = build_base_path (PLUS_EXPR, rval, binfo, 1, complain);\n     }\n   else\n     rval\n-      = convert_to_pointer_force (build_pointer_type (target_type), rval);\n+      = convert_to_pointer_force (build_pointer_type (target_type),\n+\t\t\t\t  rval, complain);\n   return build_nop (type, rval);\n }\n \n@@ -403,15 +409,13 @@ warn_ref_binding (location_t loc, tree reftype, tree intype, tree decl)\n \n tree\n convert_to_reference (tree reftype, tree expr, int convtype,\n-\t\t      int flags, tree decl)\n+\t\t      int flags, tree decl, tsubst_flags_t complain)\n {\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n   tree intype;\n   tree rval = NULL_TREE;\n   tree rval_as_conversion = NULL_TREE;\n   bool can_convert_intype_to_type;\n-  tsubst_flags_t complain = ((flags & LOOKUP_COMPLAIN)\n-\t\t\t     ? tf_warning_or_error : tf_none);\n   location_t loc = EXPR_LOC_OR_HERE (expr);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n@@ -452,21 +456,26 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   if (((convtype & CONV_STATIC) && can_convert (intype, type, complain))\n       || ((convtype & CONV_IMPLICIT) && can_convert_intype_to_type))\n     {\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  tree ttl = TREE_TYPE (reftype);\n-\t  tree ttr = lvalue_type (expr);\n+      {\n+\ttree ttl = TREE_TYPE (reftype);\n+\ttree ttr = lvalue_type (expr);\n \n-\t  if (! real_lvalue_p (expr))\n-\t    warn_ref_binding (loc, reftype, intype, decl);\n+\tif ((complain & tf_warning)\n+\t    && ! real_lvalue_p (expr))\n+\t  warn_ref_binding (loc, reftype, intype, decl);\n \n-\t  if (! (convtype & CONV_CONST)\n-\t\t   && !at_least_as_qualified_p (ttl, ttr))\n-\t    permerror (loc, \"conversion from %qT to %qT discards qualifiers\",\n-\t\t       ttr, reftype);\n-\t}\n+\tif (! (convtype & CONV_CONST)\n+\t    && !at_least_as_qualified_p (ttl, ttr))\n+\t  {\n+\t    if (complain & tf_error)\n+\t      permerror (loc, \"conversion from %qT to %qT discards qualifiers\",\n+\t\t\t ttr, reftype);\n+\t    else\n+\t      return error_mark_node;\n+\t  }\n+      }\n \n-      return build_up_reference (reftype, expr, flags, decl);\n+      return build_up_reference (reftype, expr, flags, decl, complain);\n     }\n   else if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n     {\n@@ -477,28 +486,29 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n \t meant.  */\n-      if (TREE_CODE (intype) == POINTER_TYPE\n+      if ((complain & tf_warning)\n+\t  && TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type,\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n \twarning_at (loc, 0, \"casting %qT to %qT does not dereference pointer\",\n \t\t    intype, reftype);\n \n-      rval = cp_build_addr_expr (expr, tf_warning_or_error);\n+      rval = cp_build_addr_expr (expr, complain);\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)),\n-\t\t\t      rval, 0);\n+\t\t\t      rval, 0, complain);\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n   else\n     {\n       rval = convert_for_initialization (NULL_TREE, type, expr, flags,\n-\t\t\t\t\t ICR_CONVERTING, 0, 0,\n-                                         tf_warning_or_error);\n+\t\t\t\t\t ICR_CONVERTING, 0, 0, complain);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n-      warn_ref_binding (loc, reftype, intype, decl);\n-      rval = build_up_reference (reftype, rval, flags, decl);\n+      if (complain & tf_warning)\n+\twarn_ref_binding (loc, reftype, intype, decl);\n+      rval = build_up_reference (reftype, rval, flags, decl, complain);\n     }\n \n   if (rval)\n@@ -507,7 +517,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       return rval;\n     }\n \n-  if (flags & LOOKUP_COMPLAIN)\n+  if (complain & tf_error)\n     error_at (loc, \"cannot convert type %qT to type %qT\", intype, reftype);\n \n   return error_mark_node;\n@@ -595,9 +605,9 @@ cp_fold_convert (tree type, tree expr)\n /* C++ conversions, preference to static cast conversions.  */\n \n tree\n-cp_convert (tree type, tree expr)\n+cp_convert (tree type, tree expr, tsubst_flags_t complain)\n {\n-  return ocp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL);\n+  return ocp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL, complain);\n }\n \n /* C++ equivalent of convert_and_check but using cp_convert as the\n@@ -608,16 +618,17 @@ cp_convert (tree type, tree expr)\n    i.e. because of language rules and not because of an explicit cast.  */\n \n tree\n-cp_convert_and_check (tree type, tree expr)\n+cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree result;\n \n   if (TREE_TYPE (expr) == type)\n     return expr;\n   \n-  result = cp_convert (type, expr);\n+  result = cp_convert (type, expr, complain);\n \n-  if (c_inhibit_evaluation_warnings == 0\n+  if ((complain & tf_warning)\n+      && c_inhibit_evaluation_warnings == 0\n       && !TREE_OVERFLOW_P (expr)\n       && result != error_mark_node)\n     warnings_for_convert_and_check (type, expr, result);\n@@ -630,7 +641,8 @@ cp_convert_and_check (tree type, tree expr)\n    FLAGS indicates how we should behave.  */\n \n tree\n-ocp_convert (tree type, tree expr, int convtype, int flags)\n+ocp_convert (tree type, tree expr, int convtype, int flags,\n+\t     tsubst_flags_t complain)\n {\n   tree e = expr;\n   enum tree_code code = TREE_CODE (type);\n@@ -647,7 +659,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   if ((invalid_conv_diag\n        = targetm.invalid_conversion (TREE_TYPE (expr), type)))\n     {\n-      error (invalid_conv_diag);\n+      if (complain & tf_error)\n+\terror (invalid_conv_diag);\n       return error_mark_node;\n     }\n \n@@ -696,7 +709,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     {\n-      e = convert_to_void (e, ICV_CAST, tf_warning_or_error);\n+      e = convert_to_void (e, ICV_CAST, complain);\n       return e;\n     }\n \n@@ -714,9 +727,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t       && ! (convtype & CONV_STATIC))\n \t      || TREE_CODE (intype) == POINTER_TYPE)\n \t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n+\t      if (complain & tf_error)\n \t\tpermerror (loc, \"conversion from %q#T to %q#T\", intype, type);\n-\t      if (!flag_permissive)\n+\t      else\n \t\treturn error_mark_node;\n \t    }\n \n@@ -727,7 +740,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t     the original value is within the range of the enumeration\n \t     values. Otherwise, the resulting enumeration value is\n \t     unspecified.  */\n-\t  if (TREE_CODE (expr) == INTEGER_CST\n+\t  if ((complain & tf_warning)\n+\t      && TREE_CODE (expr) == INTEGER_CST\n \t      && !int_fits_type_p (expr, ENUM_UNDERLYING_TYPE (type)))\n \t    warning_at (loc, OPT_Wconversion, \n \t\t\t\"the result of the conversion is unspecified because \"\n@@ -740,16 +754,18 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  rval = build_type_conversion (type, e);\n \t  if (rval)\n \t    return rval;\n-\t  if (flags & LOOKUP_COMPLAIN)\n+\t  if (complain & tf_error)\n \t    error_at (loc, \"%q#T used where a %qT was expected\", intype, type);\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n \t{\n \t  if (TREE_CODE (intype) == VOID_TYPE)\n \t    {\n-\t      error_at (loc, \"could not convert %qE from %<void%> to %<bool%>\",\n-\t\t\texpr);\n+\t      if (complain & tf_error)\n+\t\terror_at (loc,\n+\t\t\t  \"could not convert %qE from %<void%> to %<bool%>\",\n+\t\t\t  expr);\n \t      return error_mark_node;\n \t    }\n \n@@ -768,7 +784,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n   if (NULLPTR_TYPE_P (type) && e && null_ptr_cst_p (e))\n     return nullptr_node;\n   if (POINTER_TYPE_P (type) || TYPE_PTRMEM_P (type))\n-    return fold_if_not_in_template (cp_convert_to_pointer (type, e));\n+    return fold_if_not_in_template (cp_convert_to_pointer (type, e, complain));\n   if (code == VECTOR_TYPE)\n     {\n       tree in_vtype = TREE_TYPE (e);\n@@ -778,8 +794,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  ret_val = build_type_conversion (type, e);\n \t  if (ret_val)\n \t    return ret_val;\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    error_at (loc, \"%q#T used where a %qT was expected\", in_vtype, type);\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"%q#T used where a %qT was expected\",\n+\t\t      in_vtype, type);\n \t  return error_mark_node;\n \t}\n       return fold_if_not_in_template (convert_to_vector (type, e));\n@@ -792,10 +809,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  rval = build_type_conversion (type, e);\n \t  if (rval)\n \t    return rval;\n-\t  else\n-\t    if (flags & LOOKUP_COMPLAIN)\n-\t      error_at (loc, \"%q#T used where a floating point value was expected\",\n-\t\t\tTREE_TYPE (e));\n+\t  else if (complain & tf_error)\n+\t    error_at (loc,\n+\t\t      \"%q#T used where a floating point value was expected\",\n+\t\t      TREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n \treturn fold_if_not_in_template (convert_to_real (type, e));\n@@ -826,33 +843,31 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \treturn error_mark_node;\n \n       if (BRACE_ENCLOSED_INITIALIZER_P (ctor))\n-\tctor = perform_implicit_conversion (type, ctor, tf_warning_or_error);\n+\tctor = perform_implicit_conversion (type, ctor, complain);\n       else if ((flags & LOOKUP_ONLYCONVERTING)\n \t       && ! (CLASS_TYPE_P (dtype) && DERIVED_FROM_P (type, dtype)))\n \t/* For copy-initialization, first we create a temp of the proper type\n \t   with a user-defined conversion sequence, then we direct-initialize\n \t   the target with the temp (see [dcl.init]).  */\n-\tctor = build_user_type_conversion (type, ctor, flags,\n-\t\t\t\t\t   tf_warning_or_error);\n+\tctor = build_user_type_conversion (type, ctor, flags, complain);\n       else\n \t{\n \t  VEC(tree,gc) *ctor_vec = make_tree_vector_single (ctor);\n \t  ctor = build_special_member_call (NULL_TREE,\n \t\t\t\t\t    complete_ctor_identifier,\n \t\t\t\t\t    &ctor_vec,\n-\t\t\t\t\t    type, flags,\n-\t\t\t\t\t    tf_warning_or_error);\n+\t\t\t\t\t    type, flags, complain);\n \t  release_tree_vector (ctor_vec);\n \t}\n       if (ctor)\n-\treturn build_cplus_new (type, ctor, tf_warning_or_error);\n+\treturn build_cplus_new (type, ctor, complain);\n     }\n \n-  if (flags & LOOKUP_COMPLAIN)\n+  if (complain & tf_error)\n     {\n       /* If the conversion failed and expr was an invalid use of pointer to\n \t member function, try to report a meaningful error.  */\n-      if (invalid_nonstatic_memfn_p (expr, tf_warning_or_error))\n+      if (invalid_nonstatic_memfn_p (expr, complain))\n \t/* We displayed the error message.  */;\n       else\n \terror_at (loc, \"conversion from %qT to non-scalar type %qT requested\",\n@@ -1416,26 +1431,28 @@ convert (tree type, tree expr)\n     return fold_if_not_in_template (build_nop (type, expr));\n \n   return ocp_convert (type, expr, CONV_OLD_CONVERT,\n-\t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION,\n+\t\t      tf_warning_or_error);\n }\n \n /* Like cp_convert, except permit conversions to take place which\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n \n tree\n-convert_force (tree type, tree expr, int convtype)\n+convert_force (tree type, tree expr, int convtype, tsubst_flags_t complain)\n {\n   tree e = expr;\n   enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n     return (fold_if_not_in_template\n-\t    (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n-\t\t\t\t   NULL_TREE)));\n+\t    (convert_to_reference (type, e, CONV_C_CAST, 0,\n+\t\t\t\t   NULL_TREE, complain)));\n \n   if (code == POINTER_TYPE)\n-    return fold_if_not_in_template (convert_to_pointer_force (type, e));\n+    return fold_if_not_in_template (convert_to_pointer_force (type, e,\n+\t\t\t\t\t\t\t      complain));\n \n   /* From typeck.c convert_for_assignment */\n   if (((TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE && TREE_CODE (e) == ADDR_EXPR\n@@ -1446,9 +1463,9 @@ convert_force (tree type, tree expr, int convtype)\n       && TYPE_PTRMEMFUNC_P (type))\n     /* compatible pointer to member functions.  */\n     return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1,\n-\t\t\t     /*c_cast_p=*/1, tf_warning_or_error);\n+\t\t\t     /*c_cast_p=*/1, complain);\n \n-  return ocp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n+  return ocp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL, complain);\n }\n \n /* Convert an aggregate EXPR to type XTYPE.  If a conversion"}, {"sha": "b0f62a3350c62dd71bc3a9ba6c044e66eac503fa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -8091,9 +8091,10 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n       processing_template_decl = 0;\n       itype = cp_build_binary_op (input_location,\n \t\t\t\t  MINUS_EXPR,\n-\t\t\t\t  cp_convert (ssizetype, size),\n-\t\t\t\t  cp_convert (ssizetype, integer_one_node),\n-\t\t\t\t  tf_warning_or_error);\n+\t\t\t\t  cp_convert (ssizetype, size, complain),\n+\t\t\t\t  cp_convert (ssizetype, integer_one_node,\n+\t\t\t\t\t      complain),\n+\t\t\t\t  complain);\n       itype = fold (itype);\n       processing_template_decl = saved_processing_template_decl;\n \n@@ -13277,11 +13278,12 @@ finish_destructor_body (void)\n       an implicit definition), non-placement operator delete shall\n       be looked up in the scope of the destructor's class and if\n       found shall be accessible and unambiguous.  */\n-      exprstmt = build_op_delete_call(DELETE_EXPR, current_class_ptr,\n-\t\t\t\t      virtual_size,\n-\t\t\t\t      /*global_p=*/false,\n-\t\t\t\t      /*placement=*/NULL_TREE,\n-\t\t\t\t      /*alloc_fn=*/NULL_TREE);\n+      exprstmt = build_op_delete_call (DELETE_EXPR, current_class_ptr,\n+\t\t\t\t       virtual_size,\n+\t\t\t\t       /*global_p=*/false,\n+\t\t\t\t       /*placement=*/NULL_TREE,\n+\t\t\t\t       /*alloc_fn=*/NULL_TREE,\n+\t\t\t\t       tf_warning_or_error);\n \n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (build2 (BIT_AND_EXPR, integer_type_node,"}, {"sha": "2339b9ceb38c6b25c232d7c32ef9ad4ddeb7ada6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -424,7 +424,8 @@ initialize_handler_parm (tree decl, tree exp)\n       && TYPE_PTR_P (TREE_TYPE (init_type)))\n     exp = cp_build_addr_expr (exp, tf_warning_or_error);\n \n-  exp = ocp_convert (init_type, exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+  exp = ocp_convert (init_type, exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0,\n+\t\t     tf_warning_or_error);\n \n   init = convert_from_reference (exp);\n \n@@ -435,7 +436,8 @@ initialize_handler_parm (tree decl, tree exp)\n       /* Generate the copy constructor call directly so we can wrap it.\n \t See also expand_default_init.  */\n       init = ocp_convert (TREE_TYPE (decl), init,\n-\t\t\t  CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+\t\t\t  CONV_IMPLICIT|CONV_FORCE_TEMP, 0,\n+\t\t\t  tf_warning_or_error);\n       /* Force cleanups now to avoid nesting problems with the\n \t MUST_NOT_THROW_EXPR.  */\n       init = fold_build_cleanup_point_expr (TREE_TYPE (init), init);"}, {"sha": "419c13f3e61002b2312dbfada6ca5d53d1ce0198", "filename": "gcc/cp/init.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1180,7 +1180,7 @@ expand_virtual_init (tree binfo, tree decl)\n   gcc_assert (vtbl_ptr != error_mark_node);\n \n   /* Assign the vtable to the vptr.  */\n-  vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n+  vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0, tf_warning_or_error);\n   finish_expr_stmt (cp_build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl,\n \t\t\t\t\t  tf_warning_or_error));\n }\n@@ -1250,7 +1250,7 @@ construct_virtual_base (tree vbase, tree arguments)\n   exp = convert_to_base_statically (current_class_ref, vbase);\n \n   expand_aggr_init_1 (vbase, current_class_ref, exp, arguments,\n-\t\t      LOOKUP_COMPLAIN, tf_warning_or_error);\n+\t\t      0, tf_warning_or_error);\n   finish_then_clause (inner_if_stmt);\n   finish_if_stmt (inner_if_stmt);\n \n@@ -1598,7 +1598,8 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t   have already built up the constructor call so we could wrap it\n \t   in an exception region.  */;\n       else\n-\tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n+\tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP,\n+\t\t\t    flags, complain);\n \n       if (TREE_CODE (init) == MUST_NOT_THROW_EXPR)\n \t/* We need to protect the initialization of a catch parm with a\n@@ -2656,7 +2657,8 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t\t      size,\n \t\t      globally_qualified_p,\n \t\t      placement_allocation_fn_p ? alloc_call : NULL_TREE,\n-\t\t      alloc_fn));\n+\t\t      alloc_fn,\n+\t\t      complain));\n \n \t  if (!cleanup)\n \t    /* We're done.  */;\n@@ -2815,7 +2817,7 @@ build_new (VEC(tree,gc) **placement, tree type, tree nelts,\n             return error_mark_node;\n         }\n       nelts = mark_rvalue_use (nelts);\n-      nelts = cp_save_expr (cp_convert (sizetype, nelts));\n+      nelts = cp_save_expr (cp_convert (sizetype, nelts, complain));\n     }\n \n   /* ``A reference cannot be created by the new operator.  A reference\n@@ -3012,12 +3014,12 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t  base_tbd = cp_build_binary_op (input_location,\n \t\t\t\t\t MINUS_EXPR,\n \t\t\t\t\t cp_convert (string_type_node,\n-\t\t\t\t\t\t     base),\n+\t\t\t\t\t\t     base, complain),\n \t\t\t\t\t cookie_size,\n \t\t\t\t\t complain);\n \t  if (base_tbd == error_mark_node)\n \t    return error_mark_node;\n-\t  base_tbd = cp_convert (ptype, base_tbd);\n+\t  base_tbd = cp_convert (ptype, base_tbd, complain);\n \t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, cookie_size);\n \t}\n@@ -3026,7 +3028,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t\t\t      base_tbd, virtual_size,\n \t\t\t\t\t      use_global_delete & 1,\n \t\t\t\t\t      /*placement=*/NULL_TREE,\n-\t\t\t\t\t      /*alloc_fn=*/NULL_TREE);\n+\t\t\t\t\t      /*alloc_fn=*/NULL_TREE,\n+\t\t\t\t\t      complain);\n     }\n \n   body = loop;\n@@ -3189,14 +3192,14 @@ build_vec_init (tree base, tree maxindex, tree init,\n       return stmt_expr;\n     }\n \n-  maxindex = cp_convert (ptrdiff_type_node, maxindex);\n+  maxindex = cp_convert (ptrdiff_type_node, maxindex, complain);\n   if (TREE_CODE (atype) == ARRAY_TYPE)\n     {\n       ptype = build_pointer_type (type);\n       base = decay_conversion (base, complain);\n       if (base == error_mark_node)\n \treturn error_mark_node;\n-      base = cp_convert (ptype, base);\n+      base = cp_convert (ptype, base, complain);\n     }\n   else\n     ptype = atype;\n@@ -3665,7 +3668,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \taddr = save_expr (addr);\n \n       /* Throw away const and volatile on target type of addr.  */\n-      addr = convert_force (build_pointer_type (type), addr, 0);\n+      addr = convert_force (build_pointer_type (type), addr, 0, complain);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -3691,7 +3694,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n \n-      addr = convert_force (build_pointer_type (type), addr, 0);\n+      addr = convert_force (build_pointer_type (type), addr, 0, complain);\n     }\n \n   gcc_assert (MAYBE_CLASS_TYPE_P (type));\n@@ -3705,7 +3708,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t\t\t\t   cxx_sizeof_nowarn (type),\n \t\t\t\t   use_global_delete,\n \t\t\t\t   /*placement=*/NULL_TREE,\n-\t\t\t\t   /*alloc_fn=*/NULL_TREE);\n+\t\t\t\t   /*alloc_fn=*/NULL_TREE,\n+\t\t\t\t   complain);\n     }\n   else\n     {\n@@ -3744,7 +3748,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t\t\t\t\t    cxx_sizeof_nowarn (type),\n \t\t\t\t\t    /*global_p=*/false,\n \t\t\t\t\t    /*placement=*/NULL_TREE,\n-\t\t\t\t\t    /*alloc_fn=*/NULL_TREE);\n+\t\t\t\t\t    /*alloc_fn=*/NULL_TREE,\n+\t\t\t\t\t    complain);\n \t  /* Call the complete object destructor.  */\n \t  auto_delete = sfk_complete_destructor;\n \t}\n@@ -3756,7 +3761,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n \t\t\t\t/*global_p=*/false,\n \t\t\t\t/*placement=*/NULL_TREE,\n-\t\t\t\t/*alloc_fn=*/NULL_TREE);\n+\t\t\t\t/*alloc_fn=*/NULL_TREE,\n+\t\t\t\tcomplain);\n \t}\n \n       expr = build_dtor_call (cp_build_indirect_ref (addr, RO_NULL, complain),"}, {"sha": "0237456dcca4117f37320fb9fa9ac8378a87b9d0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1228,16 +1228,9 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n   scope = push_scope (ctype);\n \n-  if (diag)\n-    {\n-      flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE|LOOKUP_DEFAULTED;\n-      complain = tf_warning_or_error;\n-    }\n-  else\n-    {\n-      flags = LOOKUP_PROTECT|LOOKUP_SPECULATIVE|LOOKUP_DEFAULTED;\n-      complain = tf_none;\n-    }\n+  flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE|LOOKUP_DEFAULTED;\n+\n+  complain = diag ? tf_warning_or_error : tf_none;\n \n   if (const_p)\n     quals = TYPE_QUAL_CONST;"}, {"sha": "9cc6d39fffa1a99920b635cf9e10e1213f4f9933", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1854,7 +1854,7 @@ identifier_type_value_1 (tree id)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, 2, 1, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n+  id = lookup_name_real (id, 2, 1, /*block_p=*/true, 0, 0);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -4345,7 +4345,6 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n     {\n       struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n-      flags |= LOOKUP_COMPLAIN;\n       if (is_type_p)\n \tflags |= LOOKUP_PREFER_TYPES;\n       if (qualified_lookup_using_namespace (name, scope, &binding, flags))\n@@ -4772,30 +4771,28 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n tree\n lookup_name_nonclass (tree name)\n {\n-  return lookup_name_real (name, 0, 1, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n+  return lookup_name_real (name, 0, 1, /*block_p=*/true, 0, 0);\n }\n \n tree\n lookup_function_nonclass (tree name, VEC(tree,gc) *args, bool block_p)\n {\n   return\n     lookup_arg_dependent (name,\n-\t\t\t  lookup_name_real (name, 0, 1, block_p, 0,\n-\t\t\t\t\t    LOOKUP_COMPLAIN),\n+\t\t\t  lookup_name_real (name, 0, 1, block_p, 0, 0),\n \t\t\t  args, false);\n }\n \n tree\n lookup_name (tree name)\n {\n-  return lookup_name_real (name, 0, 0, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n+  return lookup_name_real (name, 0, 0, /*block_p=*/true, 0, 0);\n }\n \n tree\n lookup_name_prefer_type (tree name, int prefer_type)\n {\n-  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true,\n-\t\t\t   0, LOOKUP_COMPLAIN);\n+  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true, 0, 0);\n }\n \n /* Look up NAME for type used in elaborated name specifier in"}, {"sha": "8f0b3c0450244119056bc640e260c8d6a9fa7264", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -138,7 +138,8 @@ build_delete_destructor_body (tree delete_dtor, tree complete_dtor)\n                                       virtual_size,\n                                       /*global_p=*/false,\n                                       /*placement=*/NULL_TREE,\n-                                      /*alloc_fn=*/NULL_TREE);\n+                                      /*alloc_fn=*/NULL_TREE,\n+\t\t\t\t      tf_warning_or_error);\n   add_stmt (call_delete);\n \n   /* Return the address of the object.  */"}, {"sha": "85e0322e43f2671b67d0d269afbde8b87623b685", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -20320,13 +20320,9 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       tree *ambiguous_decls,\n \t\t       location_t name_location)\n {\n-  int flags = 0;\n   tree decl;\n   tree object_type = parser->context->object_type;\n \n-  if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-    flags |= LOOKUP_COMPLAIN;\n-\n   /* Assume that the lookup will be unambiguous.  */\n   if (ambiguous_decls)\n     *ambiguous_decls = NULL_TREE;\n@@ -20498,7 +20494,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       /* Look it up in the enclosing context, too.  */\n       decl = lookup_name_real (name, tag_type != none_type,\n \t\t\t       /*nonclass=*/0,\n-\t\t\t       /*block_p=*/true, is_namespace, flags);\n+\t\t\t       /*block_p=*/true, is_namespace, 0);\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n       if (object_decl)\n@@ -20508,7 +20504,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     {\n       decl = lookup_name_real (name, tag_type != none_type,\n \t\t\t       /*nonclass=*/0,\n-\t\t\t       /*block_p=*/true, is_namespace, flags);\n+\t\t\t       /*block_p=*/true, is_namespace, 0);\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;\n     }"}, {"sha": "df80159cf7594b3ee11b79c30ea10ae783205a25", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -8474,8 +8474,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \n      both F templates are the same.  */\n   tmpl = lookup_name_real (DECL_NAME (friend_tmpl), 0, 0,\n-\t\t\t   /*block_p=*/true, 0, \n-\t\t\t   LOOKUP_COMPLAIN | LOOKUP_HIDDEN);\n+\t\t\t   /*block_p=*/true, 0, LOOKUP_HIDDEN);\n \n   /* But, if we don't find one, it might be because we're in a\n      situation like this:"}, {"sha": "a19a893c6647f0ff5dd70dc6389f3277249c79f0", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -99,7 +99,7 @@ VEC(tree,gc) *unemitted_tinfo_decls;\n    and are generated as needed. */\n static GTY (()) VEC(tinfo_s,gc) *tinfo_descs;\n \n-static tree ifnonnull (tree, tree);\n+static tree ifnonnull (tree, tree, tsubst_flags_t);\n static tree tinfo_name (tree, bool);\n static tree build_dynamic_cast_1 (tree, tree, tsubst_flags_t);\n static tree throw_bad_cast (void);\n@@ -336,7 +336,8 @@ build_typeid (tree exp)\n          This is an lvalue use of expr then.  */\n       exp = mark_lvalue_use (exp);\n       exp = stabilize_reference (exp);\n-      cond = cp_convert (boolean_type_node, TREE_OPERAND (exp, 0));\n+      cond = cp_convert (boolean_type_node, TREE_OPERAND (exp, 0),\n+\t\t\t tf_warning_or_error);\n     }\n \n   exp = get_tinfo_decl_dynamic (exp);\n@@ -498,12 +499,13 @@ get_typeid (tree type)\n    RESULT, it must have previously had a save_expr applied to it.  */\n \n static tree\n-ifnonnull (tree test, tree result)\n+ifnonnull (tree test, tree result, tsubst_flags_t complain)\n {\n   return build3 (COND_EXPR, TREE_TYPE (result),\n \t\t build2 (EQ_EXPR, boolean_type_node, test,\n-\t\t\t cp_convert (TREE_TYPE (test), nullptr_node)),\n-\t\t cp_convert (TREE_TYPE (result), nullptr_node),\n+\t\t\t cp_convert (TREE_TYPE (test), nullptr_node,\n+\t\t\t\t     complain)),\n+\t\t cp_convert (TREE_TYPE (result), nullptr_node, complain),\n \t\t result);\n }\n \n@@ -596,7 +598,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n       /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n       expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n-\t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n+\t\t\t\t   LOOKUP_NORMAL, NULL_TREE, complain);\n     }\n \n   /* The dynamic_cast operator shall not cast away constness.  */\n@@ -644,7 +646,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t  expr1 = build_headof (expr);\n \t  if (TREE_TYPE (expr1) != type)\n \t    expr1 = build1 (NOP_EXPR, type, expr1);\n-\t  return ifnonnull (expr, expr1);\n+\t  return ifnonnull (expr, expr1, complain);\n \t}\n       else\n \t{\n@@ -752,12 +754,12 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \t      neq = cp_truthvalue_conversion (result);\n \t      return cp_convert (type,\n \t\t\t\t build3 (COND_EXPR, TREE_TYPE (result),\n-\t\t\t\t\t neq, result, bad));\n+\t\t\t\t\t neq, result, bad), complain);\n \t    }\n \n \t  /* Now back to the type we want from a void*.  */\n-\t  result = cp_convert (type, result);\n-\t  return ifnonnull (expr, result);\n+\t  result = cp_convert (type, result, complain);\n+\t  return ifnonnull (expr, result, complain);\n \t}\n     }\n   else"}, {"sha": "7769bbaa36fba4babb417379d6926637e4c9e225", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -564,7 +564,8 @@ finish_goto_stmt (tree destination)\n       destination = mark_rvalue_use (destination);\n       if (!processing_template_decl)\n \t{\n-\t  destination = cp_convert (ptr_type_node, destination);\n+\t  destination = cp_convert (ptr_type_node, destination,\n+\t\t\t\t    tf_warning_or_error);\n \t  if (error_operand_p (destination))\n \t    return NULL_TREE;\n \t}\n@@ -4526,7 +4527,8 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\t  if (error_operand_p (iter_incr))\n \t\t    return true;\n \t\t  incr = TREE_OPERAND (rhs, 1);\n-\t\t  incr = cp_convert (TREE_TYPE (diff), incr);\n+\t\t  incr = cp_convert (TREE_TYPE (diff), incr,\n+\t\t\t\t     tf_warning_or_error);\n \t\t  if (TREE_CODE (rhs) == MINUS_EXPR)\n \t\t    {\n \t\t      incr = build1 (NEGATE_EXPR, TREE_TYPE (diff), incr);\n@@ -4581,7 +4583,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n       return true;\n     }\n \n-  incr = cp_convert (TREE_TYPE (diff), incr);\n+  incr = cp_convert (TREE_TYPE (diff), incr, tf_warning_or_error);\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t&& OMP_CLAUSE_DECL (c) == iter)\n@@ -5130,7 +5132,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n \n   /* Fold the expression and convert it to a boolean value. */\n   condition = fold_non_dependent_expr (condition);\n-  condition = cp_convert (boolean_type_node, condition);\n+  condition = cp_convert (boolean_type_node, condition, tf_warning_or_error);\n   condition = maybe_constant_value (condition);\n \n   if (TREE_CODE (condition) == INTEGER_CST && !integer_zerop (condition))"}, {"sha": "945266b854e9f42349f4c27bb8e1c31030e781f8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -52,7 +52,7 @@ static tree rationalize_conditional_expr (enum tree_code, tree,\n static int comp_ptr_ttypes_real (tree, tree, int);\n static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (const_tree, const_tree, bool);\n-static tree pointer_diff (tree, tree, tree);\n+static tree pointer_diff (tree, tree, tree, tsubst_flags_t);\n static tree get_delta_difference (tree, tree, bool, bool, tsubst_flags_t);\n static void casts_away_constness_r (tree *, tree *, tsubst_flags_t);\n static bool casts_away_constness (tree, tree, tsubst_flags_t);\n@@ -1906,7 +1906,7 @@ decay_conversion (tree exp, tsubst_flags_t complain)\n       /* This way is better for a COMPONENT_REF since it can\n \t simplify the offset for a component.  */\n       adr = cp_build_addr_expr (exp, complain);\n-      return cp_convert (ptrtype, adr);\n+      return cp_convert (ptrtype, adr, complain);\n     }\n \n   /* If a bitfield is used in a context where integral promotion\n@@ -1950,12 +1950,12 @@ cp_default_conversion (tree exp, tsubst_flags_t complain)\n   /* Check for target-specific promotions.  */\n   tree promoted_type = targetm.promoted_type (TREE_TYPE (exp));\n   if (promoted_type)\n-    exp = cp_convert (promoted_type, exp);\n+    exp = cp_convert (promoted_type, exp, complain);\n   /* Perform the integral promotions first so that bitfield\n      expressions (which may promote to \"int\", even if the bitfield is\n      declared \"unsigned\") are promoted correctly.  */\n   else if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n-    exp = perform_integral_promotions (exp);\n+    exp = cp_perform_integral_promotions (exp, complain);\n   /* Perform the other conversions.  */\n   exp = decay_conversion (exp, complain);\n \n@@ -1975,7 +1975,7 @@ default_conversion (tree exp)\n    converted value.  */\n \n tree\n-perform_integral_promotions (tree expr)\n+cp_perform_integral_promotions (tree expr, tsubst_flags_t complain)\n {\n   tree type;\n   tree promoted_type;\n@@ -1995,10 +1995,18 @@ perform_integral_promotions (tree expr)\n     return expr;\n   promoted_type = type_promotes_to (type);\n   if (type != promoted_type)\n-    expr = cp_convert (promoted_type, expr);\n+    expr = cp_convert (promoted_type, expr, complain);\n   return expr;\n }\n \n+/* C version.  */\n+\n+tree\n+perform_integral_promotions (tree expr)\n+{\n+  return cp_perform_integral_promotions (expr, tf_warning_or_error);\n+}\n+\n /* Returns nonzero iff exp is a STRING_CST or the result of applying\n    decay_conversion to one.  */\n \n@@ -2945,7 +2953,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t does not say that we should.  In fact, the natural thing would\n \t seem to be to convert IDX to ptrdiff_t; we're performing\n \t pointer arithmetic.)  */\n-      idx = perform_integral_promotions (idx);\n+      idx = cp_perform_integral_promotions (idx, complain);\n \n       /* An array that is indexed by a non-constant\n \t cannot be stored in a register; we must be able to do\n@@ -3867,7 +3875,8 @@ cp_build_binary_op (location_t location,\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n \t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (type0),\n \t\t\t\t\t\t\tTREE_TYPE (type1)))\n-\treturn pointer_diff (op0, op1, common_pointer_type (type0, type1));\n+\treturn pointer_diff (op0, op1, common_pointer_type (type0, type1),\n+\t\t\t     complain);\n       /* In all other cases except pointer - int, the usual arithmetic\n \t rules apply.  */\n       else if (!(code0 == POINTER_TYPE && code1 == INTEGER_TYPE))\n@@ -4003,7 +4012,7 @@ cp_build_binary_op (location_t location,\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = cp_convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1, complain);\n \t  /* Avoid converting op1 to result_type later.  */\n \t  converted = 1;\n \t}\n@@ -4031,7 +4040,7 @@ cp_build_binary_op (location_t location,\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = cp_convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1, complain);\n \t  /* Avoid converting op1 to result_type later.  */\n \t  converted = 1;\n \t}\n@@ -4062,7 +4071,7 @@ cp_build_binary_op (location_t location,\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n-\t    op1 = cp_convert (integer_type_node, op1);\n+\t    op1 = cp_convert (integer_type_node, op1, complain);\n \t}\n       break;\n \n@@ -4162,12 +4171,12 @@ cp_build_binary_op (location_t location,\n \t      op0 = cp_build_binary_op (location,\n \t\t\t\t\tTRUTH_ANDIF_EXPR, e1, e2,\n \t\t\t\t\tcomplain);\n-\t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node); \n+\t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node, complain); \n \t    }\n      \t  else \n \t    {\n \t      op0 = build_ptrmemfunc_access_expr (op0, pfn_identifier);\n-\t      op1 = cp_convert (TREE_TYPE (op0), op1);\n+\t      op1 = cp_convert (TREE_TYPE (op0), op1, complain);\n \t    }\n \t  result_type = TREE_TYPE (op0);\n \t}\n@@ -4190,9 +4199,9 @@ cp_build_binary_op (location_t location,\n \t\t\t\t\t CPO_COMPARISON, complain);\n \n \t  if (!same_type_p (TREE_TYPE (op0), type))\n-\t    op0 = cp_convert_and_check (type, op0);\n+\t    op0 = cp_convert_and_check (type, op0, complain);\n \t  if (!same_type_p (TREE_TYPE (op1), type))\n-\t    op1 = cp_convert_and_check (type, op1);\n+\t    op1 = cp_convert_and_check (type, op1, complain);\n \n \t  if (op0 == error_mark_node || op1 == error_mark_node)\n \t    return error_mark_node;\n@@ -4456,16 +4465,16 @@ cp_build_binary_op (location_t location,\n \t  if (first_complex)\n \t    {\n \t      if (TREE_TYPE (op0) != result_type)\n-\t\top0 = cp_convert_and_check (result_type, op0);\n+\t\top0 = cp_convert_and_check (result_type, op0, complain);\n \t      if (TREE_TYPE (op1) != real_type)\n-\t\top1 = cp_convert_and_check (real_type, op1);\n+\t\top1 = cp_convert_and_check (real_type, op1, complain);\n \t    }\n \t  else\n \t    {\n \t      if (TREE_TYPE (op0) != real_type)\n-\t\top0 = cp_convert_and_check (real_type, op0);\n+\t\top0 = cp_convert_and_check (real_type, op0, complain);\n \t      if (TREE_TYPE (op1) != result_type)\n-\t\top1 = cp_convert_and_check (result_type, op1);\n+\t\top1 = cp_convert_and_check (result_type, op1, complain);\n \t    }\n \t  if (TREE_CODE (op0) == ERROR_MARK || TREE_CODE (op1) == ERROR_MARK)\n \t    return error_mark_node;\n@@ -4550,7 +4559,7 @@ cp_build_binary_op (location_t location,\n \t  tree val\n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \t  if (val != 0)\n-\t    return cp_convert (boolean_type_node, val);\n+\t    return cp_convert (boolean_type_node, val, complain);\n \t  op0 = xop0, op1 = xop1;\n \t  converted = 1;\n \t  resultcode = xresultcode;\n@@ -4580,9 +4589,9 @@ cp_build_binary_op (location_t location,\n   if (! converted)\n     {\n       if (TREE_TYPE (op0) != result_type)\n-\top0 = cp_convert_and_check (result_type, op0);\n+\top0 = cp_convert_and_check (result_type, op0, complain);\n       if (TREE_TYPE (op1) != result_type)\n-\top1 = cp_convert_and_check (result_type, op1);\n+\top1 = cp_convert_and_check (result_type, op1, complain);\n \n       if (op0 == error_mark_node || op1 == error_mark_node)\n \treturn error_mark_node;\n@@ -4594,7 +4603,7 @@ cp_build_binary_op (location_t location,\n   result = build2 (resultcode, build_type, op0, op1);\n   result = fold_if_not_in_template (result);\n   if (final_type != 0)\n-    result = cp_convert (final_type, result);\n+    result = cp_convert (final_type, result, complain);\n \n   if (TREE_OVERFLOW_P (result) \n       && !TREE_OVERFLOW_P (op0) \n@@ -4627,7 +4636,7 @@ cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (tree op0, tree op1, tree ptrtype)\n+pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n {\n   tree result;\n   tree restype = ptrdiff_type_node;\n@@ -4637,32 +4646,57 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n     return error_mark_node;\n \n   if (TREE_CODE (target_type) == VOID_TYPE)\n-    permerror (input_location, \"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n+    {\n+      if (complain & tf_error)\n+\tpermerror (input_location, \"ISO C++ forbids using pointer of \"\n+\t\t   \"type %<void *%> in subtraction\");\n+      else\n+\treturn error_mark_node;\n+    }\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-    permerror (input_location, \"ISO C++ forbids using pointer to a function in subtraction\");\n+    {\n+      if (complain & tf_error)\n+\tpermerror (input_location, \"ISO C++ forbids using pointer to \"\n+\t\t   \"a function in subtraction\");\n+      else\n+\treturn error_mark_node;\n+    }\n   if (TREE_CODE (target_type) == METHOD_TYPE)\n-    permerror (input_location, \"ISO C++ forbids using pointer to a method in subtraction\");\n+    {\n+      if (complain & tf_error)\n+\tpermerror (input_location, \"ISO C++ forbids using pointer to \"\n+\t\t   \"a method in subtraction\");\n+      else\n+\treturn error_mark_node;\n+    }\n \n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n   op0 = cp_build_binary_op (input_location,\n \t\t\t    MINUS_EXPR,\n-\t\t\t    cp_convert (restype, op0),\n-\t\t\t    cp_convert (restype, op1),\n-\t\t\t    tf_warning_or_error);\n+\t\t\t    cp_convert (restype, op0, complain),\n+\t\t\t    cp_convert (restype, op1, complain),\n+\t\t\t    complain);\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n-    error (\"invalid use of a pointer to an incomplete type in pointer arithmetic\");\n+    {\n+      if (complain & tf_error)\n+\terror (\"invalid use of a pointer to an incomplete type in \"\n+\t       \"pointer arithmetic\");\n+      else\n+\treturn error_mark_node;\n+    }\n \n   op1 = (TYPE_PTROB_P (ptrtype)\n \t ? size_in_bytes (target_type)\n \t : integer_one_node);\n \n   /* Do the division.  */\n \n-  result = build2 (EXACT_DIV_EXPR, restype, op0, cp_convert (restype, op1));\n+  result = build2 (EXACT_DIV_EXPR, restype, op0,\n+\t\t   cp_convert (restype, op1, complain));\n   return fold_if_not_in_template (result);\n }\n \f\n@@ -5175,7 +5209,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \telse\n \t  {\n \t    if (!noconvert && CP_INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n-\t      arg = perform_integral_promotions (arg);\n+\t      arg = cp_perform_integral_promotions (arg, complain);\n \n \t    /* Make sure the result is not an lvalue: a unary plus or minus\n \t       expression is always a rvalue.  */\n@@ -5200,7 +5234,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t\t\t\t\t\t   arg, true)))\n \terrstring = _(\"wrong type argument to bit-complement\");\n       else if (!noconvert && CP_INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n-\targ = perform_integral_promotions (arg);\n+\targ = cp_perform_integral_promotions (arg, complain);\n       break;\n \n     case ABS_EXPR:\n@@ -5358,7 +5392,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \telse\n \t  inc = integer_one_node;\n \n-\tinc = cp_convert (argtype, inc);\n+\tinc = cp_convert (argtype, inc, complain);\n \n \t/* If 'arg' is an Objective-C PROPERTY_REF expression, then we\n \t   need to ask Objective-C to build the increment or decrement\n@@ -6074,7 +6108,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n        || SCALAR_FLOAT_TYPE_P (type))\n       && (INTEGRAL_OR_ENUMERATION_TYPE_P (intype)\n \t  || SCALAR_FLOAT_TYPE_P (intype)))\n-    return ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n+    return ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL, complain);\n \n   if (TYPE_PTR_P (type) && TYPE_PTR_P (intype)\n       && CLASS_TYPE_P (TREE_TYPE (type))\n@@ -6417,7 +6451,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       return error_mark_node;\n     }\n \n-  return cp_convert (type, expr);\n+  return cp_convert (type, expr, complain);\n }\n \n tree\n@@ -7078,7 +7112,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t\t\t\t     NULL_TREE, 0, complain, LOOKUP_IMPLICIT);\n \n   if (!same_type_p (lhstype, olhstype))\n-    newrhs = cp_convert_and_check (lhstype, newrhs);\n+    newrhs = cp_convert_and_check (lhstype, newrhs, complain);\n \n   if (modifycode != INIT_EXPR)\n     {\n@@ -7599,7 +7633,7 @@ convert_for_assignment (tree type, tree rhs,\n       if (!warn_pmf2ptr\n \t  && TYPE_PTR_P (type)\n \t  && TYPE_PTRMEMFUNC_P (rhstype))\n-\trhs = cp_convert (strip_top_quals (type), rhs);\n+\trhs = cp_convert (strip_top_quals (type), rhs, complain);\n       else\n \t{\n \t  if (complain & tf_error)\n@@ -7723,9 +7757,7 @@ convert_for_assignment (tree type, tree rhs,\n    latter (X(X&)).\n \n    If using constructor make sure no conversion operator exists, if one does\n-   exist, an ambiguity exists.\n-\n-   If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */\n+   exist, an ambiguity exists.  */\n \n tree\n convert_for_initialization (tree exp, tree type, tree rhs, int flags,"}, {"sha": "326f602b0fdfeff0db7999d51cc16681a3aed79b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1264,7 +1264,7 @@ process_init_constructor_record (tree type, tree init,\n \n       /* If this is a bitfield, now convert to the lowered type.  */\n       if (type != TREE_TYPE (field))\n-\tnext = cp_convert_and_check (TREE_TYPE (field), next);\n+\tnext = cp_convert_and_check (TREE_TYPE (field), next, complain);\n       flags |= picflag_from_initializer (next);\n       CONSTRUCTOR_APPEND_ELT (v, field, next);\n     }"}, {"sha": "2711820f14f424a9646bb24101f2d40a5355f166", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -1,3 +1,8 @@\n+2012-06-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53567\n+\t* g++.dg/cpp0x/alias-decl-19.C: New.\n+\n 2012-06-06  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* g++.old-deja/g++.brendan/array1.C: Remove dg-options."}, {"sha": "b101cb3b7fbfdc6e21134b35196bc86011b08d50", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-19.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b978f96910158a9a2fab2ff6b6c4113ff97204d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-19.C?ref=4b978f96910158a9a2fab2ff6b6c4113ff97204d", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/53567\n+// { dg-do compile { target c++11 } }\n+\n+template <unsigned int, bool> struct IntegerType { typedef unsigned type; };\n+\n+template <class EnumT>\n+using UnderlyingEnumType = typename IntegerType<sizeof(EnumT), (EnumT(-1) > EnumT(0))>::type;\n+\n+template <class EnumT, class UnderlyingT = UnderlyingEnumType<EnumT>>\n+struct EnumMask\n+{\n+  constexpr EnumMask(EnumT val) : m_val(val) {}\n+  operator EnumT() { return m_val; }\n+\n+  EnumT m_val;\n+};\n+\n+enum class A : unsigned { x };\n+\n+template <class EnumT>\n+EnumMask<EnumT> operator ~(EnumT lhs)\n+{\n+  return EnumT(~unsigned(lhs) & unsigned(EnumT::maskAll)); // { dg-error \"not a member\" }\n+\n+}\n+\n+int main()\n+{\n+  ~A::x;\n+  return 0;\n+}"}]}