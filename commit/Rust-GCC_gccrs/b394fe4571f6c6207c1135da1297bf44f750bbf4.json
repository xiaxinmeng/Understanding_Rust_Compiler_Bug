{"sha": "b394fe4571f6c6207c1135da1297bf44f750bbf4", "node_id": "C_kwDOANBUbNoAKGIzOTRmZTQ1NzFmNmM2MjA3YzExMzVkYTEyOTdiZjQ0Zjc1MGJiZjQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-10T11:38:12Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - get_fileinfo\n - cxx_make_type\n - build_min_array_type\n - identifier_p\n\nFollowing structs are ported in this changeset:\n - c_fileinfo\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "2a89d61ab839546319f052fe9e37e73c9e9b267d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a89d61ab839546319f052fe9e37e73c9e9b267d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b394fe4571f6c6207c1135da1297bf44f750bbf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b394fe4571f6c6207c1135da1297bf44f750bbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b394fe4571f6c6207c1135da1297bf44f750bbf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b394fe4571f6c6207c1135da1297bf44f750bbf4/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c08d705e6174bbbd0670b196d24e00b6f84d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c08d705e6174bbbd0670b196d24e00b6f84d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c08d705e6174bbbd0670b196d24e00b6f84d33"}], "stats": {"total": 151, "additions": 150, "deletions": 1}, "files": [{"sha": "73c50a4cc2c50b55255a1763d6744f546b7d442c", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b394fe4571f6c6207c1135da1297bf44f750bbf4/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b394fe4571f6c6207c1135da1297bf44f750bbf4/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=b394fe4571f6c6207c1135da1297bf44f750bbf4", "patch": "@@ -21,6 +21,7 @@\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"escaped_string.h\"\n+#include \"libiberty.h\"\n \n namespace Rust {\n \n@@ -1463,4 +1464,65 @@ maybe_add_lang_type_raw (tree t)\n   return true;\n }\n \n+// forked from gcc/c-family/c-lex.cc get_fileinfo\n+\n+static splay_tree file_info_tree;\n+\n+struct c_fileinfo *\n+get_fileinfo (const char *name)\n+{\n+  splay_tree_node n;\n+  struct c_fileinfo *fi;\n+\n+  if (!file_info_tree)\n+    file_info_tree = splay_tree_new (splay_tree_compare_strings, 0,\n+\t\t\t\t     splay_tree_delete_pointers);\n+\n+  n = splay_tree_lookup (file_info_tree, (splay_tree_key) name);\n+  if (n)\n+    return (struct c_fileinfo *) n->value;\n+\n+  fi = XNEW (struct c_fileinfo);\n+  fi->time = 0;\n+  fi->interface_only = 0;\n+  fi->interface_unknown = 1;\n+  splay_tree_insert (file_info_tree, (splay_tree_key) name,\n+\t\t     (splay_tree_value) fi);\n+  return fi;\n+}\n+\n+// forked from gcc/cp/lex.cc cxx_make_type\n+\n+tree\n+cxx_make_type (enum tree_code code MEM_STAT_DECL)\n+{\n+  tree t = make_node (code PASS_MEM_STAT);\n+\n+  if (maybe_add_lang_type_raw (t))\n+    {\n+      /* Set up some flags that give proper default behavior.  */\n+      struct c_fileinfo *finfo = get_fileinfo (LOCATION_FILE (input_location));\n+      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, finfo->interface_unknown);\n+      CLASSTYPE_INTERFACE_ONLY (t) = finfo->interface_only;\n+    }\n+\n+  if (code == RECORD_TYPE || code == UNION_TYPE)\n+    TYPE_CXX_ODR_P (t) = 1;\n+\n+  return t;\n+}\n+\n+// forked from gcc/cp/tree.cc build_min_array_type\n+\n+/* Build an ARRAY_TYPE without laying it out.  */\n+\n+static tree\n+build_min_array_type (tree elt_type, tree index_type)\n+{\n+  tree t = cxx_make_type (ARRAY_TYPE);\n+  TREE_TYPE (t) = elt_type;\n+  TYPE_DOMAIN (t) = index_type;\n+  return t;\n+}\n+\n } // namespace Rust"}, {"sha": "e35226833727a0fbce0aedf5c1520b572581323d", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b394fe4571f6c6207c1135da1297bf44f750bbf4/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b394fe4571f6c6207c1135da1297bf44f750bbf4/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=b394fe4571f6c6207c1135da1297bf44f750bbf4", "patch": "@@ -23,6 +23,7 @@\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"cpplib.h\"\n+#include \"splay-tree.h\"\n \n /* Returns true if NODE is a pointer.  */\n #define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n@@ -677,7 +678,7 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n #define TYPE_PTRMEMFUNC_FN_TYPE(NODE)                                          \\\n-  (cp_build_qualified_type (TREE_TYPE (TYPE_FIELDS (NODE)),                    \\\n+  (rs_build_qualified_type (TREE_TYPE (TYPE_FIELDS (NODE)),                    \\\n \t\t\t    rs_type_quals (NODE)))\n \n /* As above, but can be used in places that want an lvalue at the expense\n@@ -733,6 +734,17 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n /* The expression in question for a DECLTYPE_TYPE.  */\n #define DECLTYPE_TYPE_EXPR(NODE) (TYPE_VALUES_RAW (DECLTYPE_TYPE_CHECK (NODE)))\n \n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE, X)                             \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_unknown = !!(X))\n+\n+/* Nonzero if this class is included from a header file which employs\n+   `#pragma interface', and it is not included in its implementation file.  */\n+#define CLASSTYPE_INTERFACE_ONLY(NODE)                                         \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->interface_only)\n+\n+#define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n+#define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -798,6 +810,24 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+// forked from gcc/c-family/c-common.h c_fileinfo\n+\n+/* Information recorded about each file examined during compilation.  */\n+\n+struct c_fileinfo\n+{\n+  int time; /* Time spent in the file.  */\n+\n+  /* Flags used only by C++.\n+     INTERFACE_ONLY nonzero means that we are in an \"interface\" section\n+     of the compiler.  INTERFACE_UNKNOWN nonzero means we cannot trust\n+     the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN is zero and\n+     INTERFACE_ONLY is zero, it means that we are responsible for\n+     exporting definitions that others might need.  */\n+  short interface_only;\n+  short interface_unknown;\n+};\n+\n // forked from gcc/cp/name-lookup.h\n \n /* Datatype that represents binding established by a declaration between\n@@ -1286,6 +1316,50 @@ inline tree ovl_first (tree) ATTRIBUTE_PURE;\n \n inline bool type_unknown_p (const_tree);\n \n+extern tree\n+lookup_add (tree fns, tree lookup);\n+\n+extern tree\n+ovl_make (tree fn, tree next = NULL_TREE);\n+\n+extern int is_overloaded_fn (tree) ATTRIBUTE_PURE;\n+\n+extern bool maybe_add_lang_type_raw (tree);\n+\n+extern rs_ref_qualifier type_memfn_rqual (const_tree);\n+\n+extern bool builtin_pack_fn_p (tree);\n+\n+extern tree make_conv_op_name (tree);\n+\n+extern int type_memfn_quals (const_tree);\n+\n+struct c_fileinfo *\n+get_fileinfo (const char *);\n+\n+extern tree\n+cxx_make_type (enum tree_code CXX_MEM_STAT_INFO);\n+\n+extern tree\n+build_cplus_array_type (tree, tree, int is_dep = -1);\n+\n+extern bool is_byte_access_type (tree);\n+\n+// forked from gcc/cp/cp-tree.h\n+\n+enum\n+{\n+  ce_derived,\n+  ce_type,\n+  ce_normal,\n+  ce_exact\n+};\n+\n+extern tree\n+rs_build_qualified_type_real (tree, int, tsubst_flags_t);\n+#define rs_build_qualified_type(TYPE, QUALS)                                   \\\n+  rs_build_qualified_type_real ((TYPE), (QUALS), tf_warning_or_error)\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\\n@@ -1354,6 +1428,19 @@ class_of_this_parm (const_tree fntype)\n {\n   return TREE_TYPE (type_of_this_parm (fntype));\n }\n+\n+// forked from gcc/cp/cp-tree.h identifier_p\n+\n+/* Return a typed pointer version of T if it designates a\n+   C++ front-end identifier.  */\n+inline lang_identifier *\n+identifier_p (tree t)\n+{\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    return (lang_identifier *) t;\n+  return NULL;\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}