{"sha": "f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlkMjk4NjZiNWJkZjdkNDJkOTc0ZGMzZjkxZmIyYmQ4MzQzNTRkYg==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2014-10-09T08:58:44Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2014-10-09T08:58:44Z"}, "message": "avr.opt (mmcu=): Change to have a string value.\n\n\t* config/avr/avr.opt (mmcu=): Change to have a string value.\n\t(mn-flash=, mskip-bug, march=, mrmw): New options.\n\t(HeaderInclude): New.\n\t(mmcu=): Remove Var / Init clauses.\n\t* config/avr/avr.h (DRIVER_SELF_SPECS): Translate -mmcu into a\n\t-specs option.\n\t(SYMBOL_FLAG_IO, SYMBOL_FLAG_ADDRESS): Define.\n\t(ASM_OUTPUT_ALIGNED_BSS): Use avr_asm_asm_output_aligned_bss.\n\t(SYMBOL_FLAG_IO_LOW): Define.\n\t(avr_device_to_as, avr_device_to_ld): Don't declare.\n\t(avr_device_to_data_start, avr_device_to_startfiles): Likewise.\n\t(avr_device_to_devicelib, avr_device_to_sp8): Likewise.\n\t(EXTRA_SPEC_FUNCTIONS): Don't define.\n\t(ASM_SPEC): Translate -arch= option to -mmcu= option.\n\t(LINK_SPEC): Translate -arch= option to -m= option.\n\tDon't use device_to_ld / device_to_data_start.\n\t(STARTFILE_SPEC): Now empty.\n\t(ASM_SPEC): Add -%{mrelax: --mlink-relax}.\n\t* config/avr/gen-avr-mmcu-specs.c: New file.\n\t* config/avr/t-avr (gen-avr-mmcu-specs$(build_exeext)): New rule.\n\t(s-device-specs): Likewise.\n\t(GCC_PASSES): Add s-device-specs.\n\t(install-driver): Depend on install-device-specs.\n\t(install-device-specs): New rule.\n\t* config/avr/avr.c (avr_option_override): Look up mcu arch by\n\tavr_arch_index and provide fallback initialization for avr_n_flash.\n\t(varasm.h): #include.\n\t(avr_print_operand) <i>: Allow SYMBOL_REF with SYMBOL_FLAG_IO;\n\t(avr_handle_addr_attribute, avr_eval_addr_attrib): New functions.\n\t(avr_attribute_table): Add \"io\", \"address\" and \"io_low\".\n\t(avr_asm_output_aligned_decl_common): Change type of decl to tree.\n\tAdd special handling for symbols with \"io\" and/or \"address\" attributes.\n\t(avr_asm_asm_output_aligned_bss): New function.\n\t(avr_encode_section_info): Set SYMBOL_FLAG_IO and SYMBOL_FLAG_ADDRESS\n\tas appropriate.  Handle io_low attribute.\n\t(avr_out_sbxx_branch): Handle symbolic io addresses.\n\t(avr_xload_libgcc_p, avr_nonconst_pointer_addrspace): Use\n\tavr_n_flash instead of avr_current_device->n_flash.\n\t(avr_pgm_check_var_decl, avr_insert_attributes): Likewise.\n\t(avr_emit_movmemhi): Likewise.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Likewise.\n\tUse TARGET_RMW instead of avr_current_device->dev_attributes.\n\tDon't define avr_current_device->macro (that's the specfile's job).\n\tUse TARGET_SKIP_BUG instead of avr_current_device->errata_skip.\n\t* config/avr/avr.c (avr_2word_insn_p): Likewise.\n\t* config/avr/avr.md (*cpse.ne): Likewise.\n\t(mov<mode>): Use avr_eval_addr_attrib.\n\t(cbi): Change constraint for low_io_address_operand operand to \"i\".\n\t(sbi, sbix_branch, sbix_branch_bit7, insv.io, insv.not.io): Likewise.\n\t* config/avr/predicates.md (io_address_operand):\n\tAllow SYMBOL_REF with SYMBOL_FLAG_IO.\n\t(low_io_address_operand): Allow SYMBOL_REF with SYMBOL_FLAG_IO_LOW.\n\t* config/avr/avr-protos.h (avr_asm_output_aligned_decl_common):\n\tUpdate prototype.\n\t(avr_eval_addr_attrib, avr_asm_asm_output_aligned_bss): Prototype.\n\t* config/avr/genmultilib.awk: Use -march=.\n\tRemove Multilib matches processing.\n\t* config/avr/t-multilib, config/avr/avr-tables.opt: Regenerate.\n\t* config/avr/avr-arch.h: Add double include guard.\n\t(avr_mcu_t) <library_name>: Update comment.\n\t* config/avr/driver-avr.c (avr_device_to_as): Delete.\n\t(avr_device_to_ld, avr_device_to_data_start): Likewise.\n\t(avr_device_to_startfiles, avr_device_to_devicelib): Likewise.\n\t(avr_device_to_sp8): Likewise.\n\t* config/avr/genopt.sh:  Instead avr_mcu, emit an Enum for avr_arch.\n\n\t* doc/extend.texi (io, address): Document new AVR variable attributes.\n\t(io_low): Likewise.\n\nFrom-SVN: r216034", "tree": {"sha": "ae70bb7447947a051bce2dfbf5a47ec34e396dd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae70bb7447947a051bce2dfbf5a47ec34e396dd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95784c5ab0159b527bcaa9b1116ad10d8d36ea5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95784c5ab0159b527bcaa9b1116ad10d8d36ea5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95784c5ab0159b527bcaa9b1116ad10d8d36ea5a"}], "stats": {"total": 1772, "additions": 565, "deletions": 1207}, "files": [{"sha": "5300c01190483d2079179241fdbffad296fe685e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -1,3 +1,74 @@\n+2014-10-09  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* config/avr/avr.opt (mmcu=): Change to have a string value.\n+\t(mn-flash=, mskip-bug, march=, mrmw): New options.\n+\t(HeaderInclude): New.\n+\t(mmcu=): Remove Var / Init clauses.\n+\t* config/avr/avr.h (DRIVER_SELF_SPECS): Translate -mmcu into a\n+\t-specs option.\n+\t(SYMBOL_FLAG_IO, SYMBOL_FLAG_ADDRESS): Define.\n+\t(ASM_OUTPUT_ALIGNED_BSS): Use avr_asm_asm_output_aligned_bss.\n+\t(SYMBOL_FLAG_IO_LOW): Define.\n+\t(avr_device_to_as, avr_device_to_ld): Don't declare.\n+\t(avr_device_to_data_start, avr_device_to_startfiles): Likewise.\n+\t(avr_device_to_devicelib, avr_device_to_sp8): Likewise.\n+\t(EXTRA_SPEC_FUNCTIONS): Don't define.\n+\t(ASM_SPEC): Translate -arch= option to -mmcu= option.\n+\t(LINK_SPEC): Translate -arch= option to -m= option.\n+\tDon't use device_to_ld / device_to_data_start.\n+\t(STARTFILE_SPEC): Now empty.\n+\t(ASM_SPEC): Add -%{mrelax: --mlink-relax}.\n+\t* config/avr/gen-avr-mmcu-specs.c: New file.\n+\t* config/avr/t-avr (gen-avr-mmcu-specs$(build_exeext)): New rule.\n+\t(s-device-specs): Likewise.\n+\t(GCC_PASSES): Add s-device-specs.\n+\t(install-driver): Depend on install-device-specs.\n+\t(install-device-specs): New rule.\n+\t* config/avr/avr.c (avr_option_override): Look up mcu arch by\n+\tavr_arch_index and provide fallback initialization for avr_n_flash.\n+\t(varasm.h): #include.\n+\t(avr_print_operand) <i>: Allow SYMBOL_REF with SYMBOL_FLAG_IO;\n+\t(avr_handle_addr_attribute, avr_eval_addr_attrib): New functions.\n+\t(avr_attribute_table): Add \"io\", \"address\" and \"io_low\".\n+\t(avr_asm_output_aligned_decl_common): Change type of decl to tree.\n+\tAdd special handling for symbols with \"io\" and/or \"address\" attributes.\n+\t(avr_asm_asm_output_aligned_bss): New function.\n+\t(avr_encode_section_info): Set SYMBOL_FLAG_IO and SYMBOL_FLAG_ADDRESS\n+\tas appropriate.  Handle io_low attribute.\n+\t(avr_out_sbxx_branch): Handle symbolic io addresses.\n+\t(avr_xload_libgcc_p, avr_nonconst_pointer_addrspace): Use\n+\tavr_n_flash instead of avr_current_device->n_flash.\n+\t(avr_pgm_check_var_decl, avr_insert_attributes): Likewise.\n+\t(avr_emit_movmemhi): Likewise.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): Likewise.\n+\tUse TARGET_RMW instead of avr_current_device->dev_attributes.\n+\tDon't define avr_current_device->macro (that's the specfile's job).\n+\tUse TARGET_SKIP_BUG instead of avr_current_device->errata_skip.\n+\t* config/avr/avr.c (avr_2word_insn_p): Likewise.\n+\t* config/avr/avr.md (*cpse.ne): Likewise.\n+\t(mov<mode>): Use avr_eval_addr_attrib.\n+\t(cbi): Change constraint for low_io_address_operand operand to \"i\".\n+\t(sbi, sbix_branch, sbix_branch_bit7, insv.io, insv.not.io): Likewise.\n+\t* config/avr/predicates.md (io_address_operand):\n+\tAllow SYMBOL_REF with SYMBOL_FLAG_IO.\n+\t(low_io_address_operand): Allow SYMBOL_REF with SYMBOL_FLAG_IO_LOW.\n+\t* config/avr/avr-protos.h (avr_asm_output_aligned_decl_common):\n+\tUpdate prototype.\n+\t(avr_eval_addr_attrib, avr_asm_asm_output_aligned_bss): Prototype.\n+\t* config/avr/genmultilib.awk: Use -march=.\n+\tRemove Multilib matches processing.\n+\t* config/avr/t-multilib, config/avr/avr-tables.opt: Regenerate.\n+\t* config/avr/avr-arch.h: Add double include guard.\n+\t(avr_mcu_t) <library_name>: Update comment.\n+\t* config/avr/driver-avr.c (avr_device_to_as): Delete.\n+\t(avr_device_to_ld, avr_device_to_data_start): Likewise.\n+\t(avr_device_to_startfiles, avr_device_to_devicelib): Likewise.\n+\t(avr_device_to_sp8): Likewise.\n+\t* config/avr/genopt.sh:  Instead avr_mcu, emit an Enum for avr_arch.\n+\n+\t* doc/extend.texi (io, address): Document new AVR variable attributes.\n+\t(io_low): Likewise.\n+\n 2014-10-09  Marek Polacek  <polacek@redhat.com>\n \n \t* doc/invoke.texi: Document -fsanitize=bool and -fsanitize=enum."}, {"sha": "4e368affc16757e2d25bcdd104edb8aff6fd8cd6", "filename": "gcc/config/avr/avr-arch.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-arch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-arch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-arch.h?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -19,6 +19,8 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#ifndef AVR_ARCH_H\n+#define AVR_ARCH_H\n \n /* This enum supplies indices into the avr_arch_types[] table below. */\n \n@@ -115,7 +117,7 @@ typedef struct\n   /* Number of 64k segments in the flash.  */\n   int n_flash;\n \n-  /* Name of device library.  */\n+  /* Old name of device library.  */\n   const char *const library_name;\n } avr_mcu_t;\n \n@@ -173,3 +175,5 @@ extern const avr_arch_t *avr_current_arch;\n \n extern const avr_mcu_t avr_mcu_types[];\n extern const avr_mcu_t *avr_current_device;\n+\n+#endif /* AVR_ARCH_H */"}, {"sha": "d5c40e6b34ab450c76b75a6c0ceec57d4b7e953f", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -298,12 +298,6 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n \n   if (avr_current_arch->macro)\n     cpp_define_formatted (pfile, \"__AVR_ARCH__=%s\", avr_current_arch->macro);\n-  if (avr_current_device->macro)\n-    {\n-      cpp_define (pfile, avr_current_device->macro);\n-      cpp_define_formatted (pfile, \"__AVR_DEVICE_NAME__=%s\",\n-\t\t\t    avr_current_device->name);\n-    }\n   if (AVR_HAVE_RAMPD)    cpp_define (pfile, \"__AVR_HAVE_RAMPD__\");\n   if (AVR_HAVE_RAMPX)    cpp_define (pfile, \"__AVR_HAVE_RAMPX__\");\n   if (AVR_HAVE_RAMPY)    cpp_define (pfile, \"__AVR_HAVE_RAMPY__\");\n@@ -351,15 +345,15 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   if (TARGET_NO_INTERRUPTS)\n     cpp_define (pfile, \"__NO_INTERRUPTS__\");\n \n-  if (avr_current_device->dev_attribute & AVR_ERRATA_SKIP)\n+  if (TARGET_SKIP_BUG)\n     {\n       cpp_define (pfile, \"__AVR_ERRATA_SKIP__\");\n \n       if (avr_current_arch->have_jmp_call)\n         cpp_define (pfile, \"__AVR_ERRATA_SKIP_JMP_CALL__\");\n     }\n \n-  if (avr_current_device->dev_attribute & AVR_ISA_RMW)\n+  if (TARGET_RMW)\n     cpp_define (pfile, \"__AVR_ISA_RMW__\");\n \n   cpp_define_formatted (pfile, \"__AVR_SFR_OFFSET__=0x%x\",\n@@ -382,7 +376,7 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n             /* Only supply __FLASH<n> macro if the address space is reasonable\n                for this target.  The address space qualifier itself is still\n                supported, but using it will throw an error.  */\n-            && avr_addrspace[i].segment < avr_current_device->n_flash)\n+            && avr_addrspace[i].segment < avr_n_flash)\n           {\n             const char *name = avr_addrspace[i].name;\n             char *Name = (char*) alloca (1 + strlen (name));"}, {"sha": "d0784042ef465fdea8f716060bae70e3469b4472", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -33,7 +33,8 @@ extern void avr_register_target_pragmas (void);\n extern void avr_init_expanders (void);\n \n #ifdef TREE_CODE\n-extern void avr_asm_output_aligned_decl_common (FILE*, const_tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);\n+extern void avr_asm_output_aligned_decl_common (FILE*, tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);\n+extern void avr_asm_asm_output_aligned_bss (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int, void (*) (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int));\n extern void asm_output_external (FILE *file, tree decl, char *name);\n extern int avr_progmem_p (tree decl, tree attributes);\n \n@@ -124,6 +125,7 @@ extern bool avr_mem_flash_p (rtx);\n extern bool avr_mem_memx_p (rtx);\n extern bool avr_load_libgcc_p (rtx);\n extern bool avr_xload_libgcc_p (enum machine_mode);\n+extern rtx avr_eval_addr_attrib (rtx x);\n \n extern rtx lpm_reg_rtx;\n extern rtx lpm_addr_reg_rtx;"}, {"sha": "4de0dbd750e008b855b189b20aa35c3ff7348462", "filename": "gcc/config/avr/avr-tables.opt", "status": "modified", "additions": 17, "deletions": 752, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-tables.opt?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -20,786 +20,51 @@\n ; <http://www.gnu.org/licenses/>.\n \n Enum\n-Name(avr_mcu) Type(int)\n-Known MCU names:\n+Name(avr_arch) Type(enum avr_arch)\n+Known MCU architectures:\n \n EnumValue\n-Enum(avr_mcu) String(avr2) Value(0)\n+Enum(avr_arch) String(avr2) Value(ARCH_AVR2)\n \n EnumValue\n-Enum(avr_mcu) String(at90s2313) Value(1)\n+Enum(avr_arch) String(avr25) Value(ARCH_AVR25)\n \n EnumValue\n-Enum(avr_mcu) String(at90s2323) Value(2)\n+Enum(avr_arch) String(avr3) Value(ARCH_AVR3)\n \n EnumValue\n-Enum(avr_mcu) String(at90s2333) Value(3)\n+Enum(avr_arch) String(avr31) Value(ARCH_AVR31)\n \n EnumValue\n-Enum(avr_mcu) String(at90s2343) Value(4)\n+Enum(avr_arch) String(avr35) Value(ARCH_AVR35)\n \n EnumValue\n-Enum(avr_mcu) String(attiny22) Value(5)\n+Enum(avr_arch) String(avr4) Value(ARCH_AVR4)\n \n EnumValue\n-Enum(avr_mcu) String(attiny26) Value(6)\n+Enum(avr_arch) String(avr5) Value(ARCH_AVR5)\n \n EnumValue\n-Enum(avr_mcu) String(at90s4414) Value(7)\n+Enum(avr_arch) String(avr51) Value(ARCH_AVR51)\n \n EnumValue\n-Enum(avr_mcu) String(at90s4433) Value(8)\n+Enum(avr_arch) String(avr6) Value(ARCH_AVR6)\n \n EnumValue\n-Enum(avr_mcu) String(at90s4434) Value(9)\n+Enum(avr_arch) String(avrxmega2) Value(ARCH_AVRXMEGA2)\n \n EnumValue\n-Enum(avr_mcu) String(at90s8515) Value(10)\n+Enum(avr_arch) String(avrxmega4) Value(ARCH_AVRXMEGA4)\n \n EnumValue\n-Enum(avr_mcu) String(at90c8534) Value(11)\n+Enum(avr_arch) String(avrxmega5) Value(ARCH_AVRXMEGA5)\n \n EnumValue\n-Enum(avr_mcu) String(at90s8535) Value(12)\n+Enum(avr_arch) String(avrxmega6) Value(ARCH_AVRXMEGA6)\n \n EnumValue\n-Enum(avr_mcu) String(avr25) Value(13)\n+Enum(avr_arch) String(avrxmega7) Value(ARCH_AVRXMEGA7)\n \n EnumValue\n-Enum(avr_mcu) String(ata5272) Value(14)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6616c) Value(15)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny13) Value(16)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny13a) Value(17)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny2313) Value(18)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny2313a) Value(19)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny24) Value(20)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny24a) Value(21)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny4313) Value(22)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny44) Value(23)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny44a) Value(24)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny441) Value(25)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny84) Value(26)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny84a) Value(27)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny25) Value(28)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny45) Value(29)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny85) Value(30)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny261) Value(31)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny261a) Value(32)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny461) Value(33)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny461a) Value(34)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny861) Value(35)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny861a) Value(36)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny43u) Value(37)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny87) Value(38)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny48) Value(39)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny88) Value(40)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny828) Value(41)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny841) Value(42)\n-\n-EnumValue\n-Enum(avr_mcu) String(at86rf401) Value(43)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr3) Value(44)\n-\n-EnumValue\n-Enum(avr_mcu) String(at43usb355) Value(45)\n-\n-EnumValue\n-Enum(avr_mcu) String(at76c711) Value(46)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr31) Value(47)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega103) Value(48)\n-\n-EnumValue\n-Enum(avr_mcu) String(at43usb320) Value(49)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr35) Value(50)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5505) Value(51)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6617c) Value(52)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata664251) Value(53)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb82) Value(54)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb162) Value(55)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8u2) Value(56)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16u2) Value(57)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32u2) Value(58)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny167) Value(59)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny1634) Value(60)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr4) Value(61)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6285) Value(62)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6286) Value(63)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6289) Value(64)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6612c) Value(65)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8) Value(66)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8a) Value(67)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega48) Value(68)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega48a) Value(69)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega48p) Value(70)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega48pa) Value(71)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega88) Value(72)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega88a) Value(73)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega88p) Value(74)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega88pa) Value(75)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8515) Value(76)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8535) Value(77)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega8hva) Value(78)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm1) Value(79)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm2) Value(80)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm2b) Value(81)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm3) Value(82)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm3b) Value(83)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm81) Value(84)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr5) Value(85)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5702m322) Value(86)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5782) Value(87)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5790) Value(88)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5790n) Value(89)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5795) Value(90)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata5831) Value(91)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6613c) Value(92)\n-\n-EnumValue\n-Enum(avr_mcu) String(ata6614q) Value(93)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16) Value(94)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16a) Value(95)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega161) Value(96)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega162) Value(97)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega163) Value(98)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega164a) Value(99)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega164p) Value(100)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega164pa) Value(101)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega165) Value(102)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega165a) Value(103)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega165p) Value(104)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega165pa) Value(105)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega168) Value(106)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega168a) Value(107)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega168p) Value(108)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega168pa) Value(109)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega169) Value(110)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega169a) Value(111)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega169p) Value(112)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega169pa) Value(113)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16hvb) Value(114)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16hvbrevb) Value(115)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16m1) Value(116)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16u4) Value(117)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32a) Value(118)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32) Value(119)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega323) Value(120)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega324a) Value(121)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega324p) Value(122)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega324pa) Value(123)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega325) Value(124)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega325a) Value(125)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega325p) Value(126)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega325pa) Value(127)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3250) Value(128)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3250a) Value(129)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3250p) Value(130)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3250pa) Value(131)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega328) Value(132)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega328p) Value(133)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega329) Value(134)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega329a) Value(135)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega329p) Value(136)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega329pa) Value(137)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3290) Value(138)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3290a) Value(139)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3290p) Value(140)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega3290pa) Value(141)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32c1) Value(142)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32m1) Value(143)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32u4) Value(144)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32u6) Value(145)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega406) Value(146)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64) Value(147)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64a) Value(148)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega640) Value(149)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega644) Value(150)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega644a) Value(151)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega644p) Value(152)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega644pa) Value(153)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega645) Value(154)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega645a) Value(155)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega645p) Value(156)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6450) Value(157)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6450a) Value(158)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6450p) Value(159)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega649) Value(160)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega649a) Value(161)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega649p) Value(162)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6490) Value(163)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16hva) Value(164)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega16hva2) Value(165)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32hvb) Value(166)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6490a) Value(167)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega6490p) Value(168)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64c1) Value(169)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64m1) Value(170)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64hve) Value(171)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64hve2) Value(172)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega64rfr2) Value(173)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega644rfr2) Value(174)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega32hvbrevb) Value(175)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90can32) Value(176)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90can64) Value(177)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm161) Value(178)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm216) Value(179)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90pwm316) Value(180)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90scr100) Value(181)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb646) Value(182)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb647) Value(183)\n-\n-EnumValue\n-Enum(avr_mcu) String(at94k) Value(184)\n-\n-EnumValue\n-Enum(avr_mcu) String(m3000) Value(185)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr51) Value(186)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega128) Value(187)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega128a) Value(188)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega1280) Value(189)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega1281) Value(190)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega1284) Value(191)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega1284p) Value(192)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega128rfa1) Value(193)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega128rfr2) Value(194)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega1284rfr2) Value(195)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90can128) Value(196)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb1286) Value(197)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90usb1287) Value(198)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr6) Value(199)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega2560) Value(200)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega2561) Value(201)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega256rfr2) Value(202)\n-\n-EnumValue\n-Enum(avr_mcu) String(atmega2564rfr2) Value(203)\n-\n-EnumValue\n-Enum(avr_mcu) String(avrxmega2) Value(204)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega8e5) Value(205)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega16a4) Value(206)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega16d4) Value(207)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega16e5) Value(208)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32a4) Value(209)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32c3) Value(210)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32d3) Value(211)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32d4) Value(212)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega16a4u) Value(213)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega16c4) Value(214)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32a4u) Value(215)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32c4) Value(216)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega32e5) Value(217)\n-\n-EnumValue\n-Enum(avr_mcu) String(avrxmega4) Value(218)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64a3) Value(219)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64d3) Value(220)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64a3u) Value(221)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64a4u) Value(222)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64b1) Value(223)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64b3) Value(224)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64c3) Value(225)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64d4) Value(226)\n-\n-EnumValue\n-Enum(avr_mcu) String(avrxmega5) Value(227)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64a1) Value(228)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega64a1u) Value(229)\n-\n-EnumValue\n-Enum(avr_mcu) String(avrxmega6) Value(230)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128a3) Value(231)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128d3) Value(232)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega192a3) Value(233)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega192d3) Value(234)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256a3) Value(235)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256a3b) Value(236)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256a3bu) Value(237)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256d3) Value(238)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128a3u) Value(239)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128b1) Value(240)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128b3) Value(241)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128c3) Value(242)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128d4) Value(243)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega192a3u) Value(244)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega192c3) Value(245)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256a3u) Value(246)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega256c3) Value(247)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega384c3) Value(248)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega384d3) Value(249)\n-\n-EnumValue\n-Enum(avr_mcu) String(avrxmega7) Value(250)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128a1) Value(251)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128a1u) Value(252)\n-\n-EnumValue\n-Enum(avr_mcu) String(atxmega128a4u) Value(253)\n-\n-EnumValue\n-Enum(avr_mcu) String(avr1) Value(254)\n-\n-EnumValue\n-Enum(avr_mcu) String(at90s1200) Value(255)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny11) Value(256)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny12) Value(257)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny15) Value(258)\n-\n-EnumValue\n-Enum(avr_mcu) String(attiny28) Value(259)\n+Enum(avr_arch) String(avr1) Value(ARCH_AVR1)\n "}, {"sha": "4e25fcf459cc0a98628fc22cb4260100585d3e47", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 195, "deletions": 11, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -32,6 +32,7 @@\n #include \"flags.h\"\n #include \"reload.h\"\n #include \"tree.h\"\n+#include \"varasm.h\"\n #include \"print-tree.h\"\n #include \"calls.h\"\n #include \"stor-layout.h\"\n@@ -330,8 +331,23 @@ avr_option_override (void)\n   if (flag_pie == 2)\n     warning (OPT_fPIE, \"-fPIE is not supported\");\n \n-  avr_current_device = &avr_mcu_types[avr_mcu_index];\n-  avr_current_arch = &avr_arch_types[avr_current_device->arch];\n+  /* Search for mcu arch.\n+     ??? We should probably just put the architecture-default device\n+     settings in the architecture struct and remove any notion of a current\n+     device from gcc.  */\n+\n+  for (avr_current_device = avr_mcu_types; ; avr_current_device++)\n+    {\n+      if (!avr_current_device->name)\n+\tfatal_error (\"mcu not found\");\n+      if (!avr_current_device->macro\n+\t  && avr_current_device->arch == avr_arch_index)\n+\tbreak;\n+    }\n+\n+  avr_current_arch = &avr_arch_types[avr_arch_index];\n+  if (avr_n_flash < 0)\n+    avr_n_flash = avr_current_device->n_flash;\n \n   /* RAM addresses of some SFRs common to all devices in respective arch. */\n \n@@ -2242,7 +2258,11 @@ avr_print_operand (FILE *file, rtx x, int code)\n     }\n   else if (code == 'i')\n     {\n-      fatal_insn (\"bad address, not an I/O address:\", x);\n+      if (GET_CODE (x) == SYMBOL_REF && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO))\n+\tavr_print_operand_address\n+\t  (file, plus_constant (HImode, x, -avr_current_arch->sfr_offset));\n+      else\n+\tfatal_insn (\"bad address, not an I/O address:\", x);\n     }\n   else if (code == 'x')\n     {\n@@ -2767,7 +2787,7 @@ avr_xload_libgcc_p (enum machine_mode mode)\n   int n_bytes = GET_MODE_SIZE (mode);\n \n   return (n_bytes > 1\n-          || avr_current_device->n_flash > 1);\n+          || avr_n_flash > 1);\n }\n \n \n@@ -8132,6 +8152,86 @@ avr_handle_fntype_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+static tree\n+avr_handle_addr_attribute (tree *node, tree name, tree args,\n+\t\t\t   int flags ATTRIBUTE_UNUSED, bool *no_add)\n+{\n+  bool io_p = (strncmp (IDENTIFIER_POINTER (name), \"io\", 2) == 0);\n+  location_t loc = DECL_SOURCE_LOCATION (*node);\n+\n+  if (TREE_CODE (*node) != VAR_DECL)\n+    {\n+      warning_at (loc, 0, \"%qE attribute only applies to variables\", name);\n+      *no_add = true;\n+    }\n+\n+  if (args != NULL_TREE)\n+    {\n+      if (TREE_CODE (TREE_VALUE (args)) == NON_LVALUE_EXPR)\n+\tTREE_VALUE (args) = TREE_OPERAND (TREE_VALUE (args), 0);\n+      tree arg = TREE_VALUE (args);\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\t{\n+\t  warning (0, \"%qE attribute allows only an integer constant argument\",\n+\t\t   name);\n+\t  *no_add = true;\n+\t}\n+      else if (io_p\n+\t       && (!tree_fits_shwi_p (arg)\n+\t\t   || !(strcmp (IDENTIFIER_POINTER (name), \"io_low\") == 0\n+\t\t\t? low_io_address_operand : io_address_operand)\n+\t\t\t (GEN_INT (TREE_INT_CST_LOW (arg)), QImode)))\n+\t{\n+\t  warning_at (loc, 0, \"%qE attribute address out of range\", name);\n+\t  *no_add = true;\n+\t}\n+      else\n+\t{\n+\t  tree attribs = DECL_ATTRIBUTES (*node);\n+\t  const char *names[] = { \"io\", \"io_low\", \"address\", NULL } ;\n+\t  for (const char **p = names; *p; p++)\n+\t    {\n+\t      tree other = lookup_attribute (*p, attribs);\n+\t      if (other && TREE_VALUE (other))\n+\t\t{\n+\t\t  warning_at (loc, 0,\n+\t\t\t      \"both %s and %qE attribute provide address\",\n+\t\t\t      *p, name);\n+\t\t  *no_add = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (*no_add == false && io_p && !TREE_THIS_VOLATILE (*node))\n+    warning_at (loc, 0, \"%qE attribute on non-volatile variable\", name);\n+\n+  return NULL_TREE;\n+}\n+\n+rtx\n+avr_eval_addr_attrib (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_ADDRESS))\n+    {\n+      tree decl = SYMBOL_REF_DECL (x);\n+      tree attr = NULL_TREE;\n+\n+      if (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_IO)\n+\t{\n+\t  attr = lookup_attribute (\"io\", DECL_ATTRIBUTES (decl));\n+\t  gcc_assert (attr);\n+\t}\n+      if (!attr || !TREE_VALUE (attr))\n+\tattr = lookup_attribute (\"address\", DECL_ATTRIBUTES (decl));\n+      gcc_assert (attr && TREE_VALUE (attr) && TREE_VALUE (TREE_VALUE (attr)));\n+      return GEN_INT (TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr))));\n+    }\n+  return x;\n+}\n+\n \n /* AVR attributes.  */\n static const struct attribute_spec\n@@ -8151,6 +8251,12 @@ avr_attribute_table[] =\n     false },\n   { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n     false },\n+  { \"io\",        0, 1, false, false, false,  avr_handle_addr_attribute,\n+    false },\n+  { \"io_low\",    0, 1, false, false, false,  avr_handle_addr_attribute,\n+    false },\n+  { \"address\",   1, 1, false, false, false,  avr_handle_addr_attribute,\n+    false },\n   { NULL,        0, 0, false, false, false, NULL, false }\n };\n \n@@ -8232,7 +8338,7 @@ avr_nonconst_pointer_addrspace (tree typ)\n \n       if (!ADDR_SPACE_GENERIC_P (as)\n           && (!TYPE_READONLY (target)\n-              || avr_addrspace[as].segment >= avr_current_device->n_flash))\n+              || avr_addrspace[as].segment >= avr_n_flash))\n         {\n           return as;\n         }\n@@ -8296,7 +8402,7 @@ avr_pgm_check_var_decl (tree node)\n \n   if (reason)\n     {\n-      if (avr_addrspace[as].segment >= avr_current_device->n_flash)\n+      if (avr_addrspace[as].segment >= avr_n_flash)\n         {\n           if (TYPE_P (node))\n             error (\"%qT uses address space %qs beyond flash of %qs\",\n@@ -8348,7 +8454,7 @@ avr_insert_attributes (tree node, tree *attributes)\n \n       as = TYPE_ADDR_SPACE (TREE_TYPE (node));\n \n-      if (avr_addrspace[as].segment >= avr_current_device->n_flash)\n+      if (avr_addrspace[as].segment >= avr_n_flash)\n         {\n           error (\"variable %q+D located in address space %qs\"\n                  \" beyond flash of %qs\",\n@@ -8379,11 +8485,37 @@ avr_insert_attributes (tree node, tree *attributes)\n \n void\n avr_asm_output_aligned_decl_common (FILE * stream,\n-                                    const_tree decl ATTRIBUTE_UNUSED,\n+                                    tree decl,\n                                     const char *name,\n                                     unsigned HOST_WIDE_INT size,\n                                     unsigned int align, bool local_p)\n {\n+  rtx mem = decl == NULL_TREE ? NULL_RTX : DECL_RTL (decl);\n+  rtx symbol;\n+\n+  if (mem != NULL_RTX && MEM_P (mem)\n+      && GET_CODE ((symbol = XEXP (mem, 0))) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (symbol) & (SYMBOL_FLAG_IO | SYMBOL_FLAG_ADDRESS)))\n+    {\n+\n+      if (!local_p)\n+\t{\n+\t  fprintf (stream, \"\\t.globl\\t\");\n+\t  assemble_name (stream, name);\n+\t  fprintf (stream, \"\\n\");\n+\t}\n+      if (SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_ADDRESS)\n+\t{\n+\t  assemble_name (stream, name);\n+\t  fprintf (stream, \" = %ld\\n\",\n+\t\t   (long) INTVAL (avr_eval_addr_attrib (symbol)));\n+\t}\n+      else if (local_p)\n+\terror_at (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"static IO declaration for %q+D needs an address\", decl);\n+      return;\n+    }\n+\n   /* __gnu_lto_v1 etc. are just markers for the linker injected by toplev.c.\n      There is no need to trigger __do_clear_bss code for them.  */\n \n@@ -8396,6 +8528,29 @@ avr_asm_output_aligned_decl_common (FILE * stream,\n     ASM_OUTPUT_ALIGNED_COMMON (stream, name, size, align);\n }\n \n+void\n+avr_asm_asm_output_aligned_bss (FILE *file, tree decl, const char *name,\n+\t\t\t\tunsigned HOST_WIDE_INT size, int align,\n+\t\t\t\tvoid (*default_func)\n+\t\t\t\t  (FILE *, tree, const char *,\n+\t\t\t\t   unsigned HOST_WIDE_INT, int))\n+{\n+  rtx mem = decl == NULL_TREE ? NULL_RTX : DECL_RTL (decl);\n+  rtx symbol;\n+\n+  if (mem != NULL_RTX && MEM_P (mem)\n+      && GET_CODE ((symbol = XEXP (mem, 0))) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (symbol) & (SYMBOL_FLAG_IO | SYMBOL_FLAG_ADDRESS)))\n+    {\n+      if (!(SYMBOL_REF_FLAGS (symbol) & SYMBOL_FLAG_ADDRESS))\n+\terror_at (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"IO definition for %q+D needs an address\", decl);\n+      avr_asm_output_aligned_decl_common (file, decl, name, size, align, false);\n+    }\n+  else\n+    default_func (file, decl, name, size, align);\n+}\n+\n \n /* Unnamed section callback for data_section\n    to track need of __do_copy_data.  */\n@@ -8627,17 +8782,43 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n    {\n       rtx sym = XEXP (rtl, 0);\n       tree type = TREE_TYPE (decl);\n+      tree attr = DECL_ATTRIBUTES (decl);\n       if (type == error_mark_node)\n \treturn;\n+\n       addr_space_t as = TYPE_ADDR_SPACE (type);\n \n       /* PSTR strings are in generic space but located in flash:\n          patch address space.  */\n \n-      if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n+      if (-1 == avr_progmem_p (decl, attr))\n         as = ADDR_SPACE_FLASH;\n \n       AVR_SYMBOL_SET_ADDR_SPACE (sym, as);\n+\n+      tree io_low_attr = lookup_attribute (\"io_low\", attr);\n+      tree io_attr = lookup_attribute (\"io\", attr);\n+      tree addr_attr;\n+      if (io_low_attr\n+\t  && TREE_VALUE (io_low_attr) && TREE_VALUE (TREE_VALUE (io_low_attr)))\n+\taddr_attr = io_attr;\n+      else if (io_attr\n+\t       && TREE_VALUE (io_attr) && TREE_VALUE (TREE_VALUE (io_attr)))\n+\taddr_attr = io_attr;\n+      else\n+\taddr_attr = lookup_attribute (\"address\", attr);\n+      if (io_low_attr\n+\t  || (io_attr && addr_attr && \n+\t      low_io_address_operand (GEN_INT (TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (addr_attr)))), QImode)))\n+\tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO_LOW;\n+      if (io_attr || io_low_attr)\n+\tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO;\n+      /* If we have an (io) address attribute specification, but the variable\n+\t is external, treat the address as only a tentative definition\n+\t to be used to determine if an io port is in the lower range, but\n+\t don't use the exact value for constant propagation.  */\n+      if (addr_attr && !DECL_EXTERNAL (decl))\n+\tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_ADDRESS;\n     }\n }\n \n@@ -10142,7 +10323,7 @@ test_hard_reg_class (enum reg_class rclass, rtx x)\n static bool\n avr_2word_insn_p (rtx_insn *insn)\n {\n-  if ((avr_current_device->dev_attribute & AVR_ERRATA_SKIP)\n+  if (TARGET_SKIP_BUG\n       || !insn\n       || 2 != get_attr_length (insn))\n     {\n@@ -10760,6 +10941,8 @@ avr_out_sbxx_branch (rtx_insn *insn, rtx operands[])\n       gcc_unreachable();\n \n     case CONST_INT:\n+    case CONST:\n+    case SYMBOL_REF:\n \n       if (low_io_address_operand (operands[1], QImode))\n         {\n@@ -10770,6 +10953,7 @@ avr_out_sbxx_branch (rtx_insn *insn, rtx operands[])\n         }\n       else\n         {\n+\t  gcc_assert (io_address_operand (operands[1], QImode));\n           output_asm_insn (\"in __tmp_reg__,%i1\", operands);\n           if (comp == EQ)\n             output_asm_insn (\"sbrs __tmp_reg__,%2\", operands);\n@@ -11179,7 +11363,7 @@ avr_emit_movmemhi (rtx *xop)\n       int segment = avr_addrspace[as].segment;\n \n       if (segment\n-          && avr_current_device->n_flash > 1)\n+          && avr_n_flash > 1)\n         {\n           a_hi8 = GEN_INT (segment);\n           emit_move_insn (rampz_rtx, a_hi8 = copy_to_mode_reg (QImode, a_hi8));"}, {"sha": "de2bcd171c89899e0cb5b687905f4be870b0655f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -75,6 +75,7 @@ enum\n \n /* Handling of 8-bit SP versus 16-bit SP is as follows:\n \n+FIXME: DRIVER_SELF_SPECS has changed.\n    -msp8 is used internally to select the right multilib for targets with\n    8-bit SP.  -msp8 is set automatically by DRIVER_SELF_SPECS for devices\n    with 8-bit SP or by multilib generation machinery.  If a frame pointer is\n@@ -403,7 +404,8 @@ typedef struct avr_args\n   avr_asm_output_aligned_decl_common (STREAM, DECL, NAME, SIZE, ALIGN, false)\n \n #define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+  avr_asm_asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN, \\\n+\t\t\t\t  asm_output_aligned_bss)\n \n #define ASM_OUTPUT_ALIGNED_DECL_LOCAL(STREAM, DECL, NAME, SIZE, ALIGN)  \\\n   avr_asm_output_aligned_decl_common (STREAM, DECL, NAME, SIZE, ALIGN, true)\n@@ -488,24 +490,7 @@ typedef struct avr_args\n #define ADJUST_INSN_LENGTH(INSN, LENGTH)                \\\n     (LENGTH = avr_adjust_insn_length (INSN, LENGTH))\n \n-extern const char *avr_device_to_as (int argc, const char **argv);\n-extern const char *avr_device_to_ld (int argc, const char **argv);\n-extern const char *avr_device_to_data_start (int argc, const char **argv);\n-extern const char *avr_device_to_text_start (int argc, const char **argv);\n-extern const char *avr_device_to_startfiles (int argc, const char **argv);\n-extern const char *avr_device_to_devicelib (int argc, const char **argv);\n-extern const char *avr_device_to_sp8 (int argc, const char **argv);\n-\n-#define EXTRA_SPEC_FUNCTIONS                            \\\n-  { \"device_to_as\", avr_device_to_as },                 \\\n-  { \"device_to_ld\", avr_device_to_ld },                 \\\n-  { \"device_to_data_start\", avr_device_to_data_start }, \\\n-  { \"device_to_text_start\", avr_device_to_text_start }, \\\n-  { \"device_to_startfile\", avr_device_to_startfiles },  \\\n-  { \"device_to_devicelib\", avr_device_to_devicelib },   \\\n-  { \"device_to_sp8\", avr_device_to_sp8 },\n-\n-#define DRIVER_SELF_SPECS \" %:device_to_sp8(%{mmcu=*:%*}) \"\n+#define DRIVER_SELF_SPECS \" %{mmcu=*:-specs=device-specs/specs-%*%s %<mmcu=*} \"\n #define CPP_SPEC \"\"\n \n #define CC1_SPEC \"\"\n@@ -514,7 +499,7 @@ extern const char *avr_device_to_sp8 (int argc, const char **argv);\n     %{!fenforce-eh-specs:-fno-enforce-eh-specs} \\\n     %{!fexceptions:-fno-exceptions}\"\n \n-#define ASM_SPEC \"%:device_to_as(%{mmcu=*:%*}) \"\n+#define ASM_SPEC \"%{march=*:-mmcu=%*}%{mrelax: --mlink-relax}\"\n   \n #define LINK_SPEC \"\\\n %{mrelax:--relax\\\n@@ -525,9 +510,7 @@ extern const char *avr_device_to_sp8 (int argc, const char **argv);\n                              %{mmcu=atmega64*|\\\n                                mmcu=at90can64*|\\\n                                mmcu=at90usb64*:--pmem-wrap-around=64k}}}\\\n-%:device_to_ld(%{mmcu=*:%*})\\\n-%:device_to_data_start(%{mmcu=*:%*})\\\n-%:device_to_text_start(%{mmcu=*:%*}) \\\n+%{march=*:-m%*}\\\n %{shared:%eshared is not supported}\"\n \n #define LIB_SPEC \\\n@@ -539,7 +522,8 @@ extern const char *avr_device_to_sp8 (int argc, const char **argv);\n #define LIBGCC_SPEC \\\n   \"%{!mmcu=at90s1*:%{!mmcu=attiny11:%{!mmcu=attiny12:%{!mmcu=attiny15:%{!mmcu=attiny28: -lgcc }}}}}\"\n \n-#define STARTFILE_SPEC \"%:device_to_startfile(%{mmcu=*:%*})\"\n+/* The actual definition will come from the device-specific spec file.  */\n+#define STARTFILE_SPEC \"\"\n \n #define ENDFILE_SPEC \"\"\n \n@@ -608,3 +592,8 @@ extern int avr_accumulate_outgoing_args (void);\n #define ACCUMULATE_OUTGOING_ARGS avr_accumulate_outgoing_args()\n \n #define INIT_EXPANDERS avr_init_expanders()\n+\n+/* Flags used for io and address attributes.  */\n+#define SYMBOL_FLAG_IO_LOW\t(SYMBOL_FLAG_MACH_DEP << 4)\n+#define SYMBOL_FLAG_IO\t\t(SYMBOL_FLAG_MACH_DEP << 5)\n+#define SYMBOL_FLAG_ADDRESS\t(SYMBOL_FLAG_MACH_DEP << 6)"}, {"sha": "3f3d6eb195c88f7d5712035f795e1019032c22c5", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -585,7 +585,7 @@\n   \"\"\n   {\n     rtx dest = operands[0];\n-    rtx src  = operands[1];\n+    rtx src  = avr_eval_addr_attrib (operands[1]);\n \n     if (avr_mem_flash_p (dest))\n       DONE;\n@@ -5014,7 +5014,7 @@\n ;; Clear/set/test a single bit in I/O address space.\n \n (define_insn \"*cbi\"\n-  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n+  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"i\"))\n         (and:QI (mem:QI (match_dup 0))\n                 (match_operand:QI 1 \"single_zero_operand\" \"n\")))]\n   \"\"\n@@ -5026,7 +5026,7 @@\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*sbi\"\n-  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n+  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"i\"))\n         (ior:QI (mem:QI (match_dup 0))\n                 (match_operand:QI 1 \"single_one_operand\" \"n\")))]\n   \"\"\n@@ -5043,7 +5043,7 @@\n         (if_then_else\n          (match_operator 0 \"eqne_operator\"\n                          [(zero_extract:QIHI\n-                           (mem:QI (match_operand 1 \"low_io_address_operand\" \"n\"))\n+                           (mem:QI (match_operand 1 \"low_io_address_operand\" \"i\"))\n                            (const_int 1)\n                            (match_operand 2 \"const_int_operand\" \"n\"))\n                           (const_int 0)])\n@@ -5067,7 +5067,7 @@\n   [(set (pc)\n         (if_then_else\n          (match_operator 0 \"gelt_operator\"\n-                         [(mem:QI (match_operand 1 \"low_io_address_operand\" \"n\"))\n+                         [(mem:QI (match_operand 1 \"low_io_address_operand\" \"i\"))\n                           (const_int 0)])\n          (label_ref (match_operand 2 \"\" \"\"))\n          (pc)))]\n@@ -5382,7 +5382,7 @@\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n   \"!AVR_HAVE_JMP_CALL\n-   || !(avr_current_device->dev_attribute & AVR_ERRATA_SKIP)\"\n+   || !TARGET_SKIP_BUG\"\n   {\n     if (operands[2] == CONST0_RTX (<MODE>mode))\n       operands[2] = zero_reg_rtx;\n@@ -6240,7 +6240,7 @@\n ;; in contrast to a IN/BST/BLD/OUT sequence we need less registers and the\n ;; operation on I/O is atomic.\n (define_insn \"*insv.io\"\n-  [(set (zero_extract:QI (mem:QI (match_operand 0 \"low_io_address_operand\" \"n,n,n\"))\n+  [(set (zero_extract:QI (mem:QI (match_operand 0 \"low_io_address_operand\" \"i,i,i\"))\n                          (const_int 1)\n                          (match_operand:QI 1 \"const_0_to_7_operand\"        \"n,n,n\"))\n         (match_operand:QI 2 \"nonmemory_operand\"                            \"L,P,r\"))]\n@@ -6253,7 +6253,7 @@\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*insv.not.io\"\n-  [(set (zero_extract:QI (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n+  [(set (zero_extract:QI (mem:QI (match_operand 0 \"low_io_address_operand\" \"i\"))\n                          (const_int 1)\n                          (match_operand:QI 1 \"const_0_to_7_operand\"        \"n\"))\n         (not:QI (match_operand:QI 2 \"register_operand\"                     \"r\")))]"}, {"sha": "cfe4b1441700b62bef0e68b1d9ab92d7b25ddd04", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -18,14 +18,33 @@\n ; along with GCC; see the file COPYING3.  If not see\n ; <http://www.gnu.org/licenses/>.\n \n+HeaderInclude\n+config/avr/avr-arch.h\n+\n mcall-prologues\n Target Report Mask(CALL_PROLOGUES)\n Use subroutines for function prologues and epilogues\n \n mmcu=\n-Target RejectNegative Joined Var(avr_mcu_index) Init(0) Enum(avr_mcu)\n+Target RejectNegative Joined\n -mmcu=MCU\tSelect the target MCU\n \n+march=\n+Target RejectNegative Joined Var(avr_arch_index) Init(ARCH_AVR2) Enum(avr_arch)\n+-march=ARCH Select target architecture\n+\n+mn-flash=\n+Target RejectNegative Joined Var(avr_n_flash) UInteger Init(-1)\n+Set the number of 64 KiB flash segments\n+\n+mskip-bug\n+Target Report Mask(SKIP_BUG)\n+Indicate presence of a processor erratum\n+\n+mrmw\n+Target Report Mask(RMW)\n+Enable Read-Modify-Write (RMW) instructions support/use\n+\n mdeb\n Target Report Undocumented Mask(ALL_DEBUG)\n "}, {"sha": "24a26d46bed00d6ec72ef3413b9f0cfb999aa4ab", "filename": "gcc/config/avr/driver-avr.c", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fdriver-avr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fdriver-avr.c?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -47,128 +47,3 @@ avr_set_current_device (const char *name)\n \n   avr_current_arch = &avr_arch_types[avr_current_device->arch];\n }\n-\n-/* Returns command line parameters to pass to as.  */\n-\n-const char*\n-avr_device_to_as (int argc, const char **argv)\n-{\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  return concat (\"-mmcu=\", avr_current_arch->arch_name,\n-    avr_current_device->dev_attribute & AVR_ERRATA_SKIP ? \"\" : \" -mno-skip-bug\",\n-    avr_current_device->dev_attribute & AVR_ISA_RMW ? \" -mrmw\" : \"\", NULL);\n-}\n-\n-/* Returns command line parameters to pass to ld.  */\n-\n-const char*\n-avr_device_to_ld (int argc, const char **argv)\n-{\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  return concat (\"-m \", avr_current_arch->arch_name, NULL);\n-}\n-\n-/* Returns command line parameters that describe start of date section.  */\n-\n-const char *\n-avr_device_to_data_start (int argc, const char **argv)\n-{\n-  unsigned long data_section_start;\n-  char data_section_start_str[16];\n-\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-  \n-  if (avr_current_device->data_section_start \n-      == avr_current_arch->default_data_section_start)\n-    return NULL;\n-    \n-  data_section_start = 0x800000 + avr_current_device->data_section_start;\n-  \n-  snprintf (data_section_start_str, sizeof(data_section_start_str) - 1,\n-            \"0x%lX\", data_section_start);\n-  \n-  return concat (\"-Tdata \", data_section_start_str, NULL);    \n-}\n-\n-/* Returns command line parameters that describe start of text section.  */\n-\n-const char *\n-avr_device_to_text_start (int argc, const char **argv)\n-{\n-  unsigned long text_section_start;\n-  char text_section_start_str[16];\n-\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  if (avr_current_device->text_section_start == 0x0)\n-    return NULL;\n-\n-  text_section_start = avr_current_device->text_section_start;\n-\n-  snprintf (text_section_start_str, sizeof(text_section_start_str) - 1,\n-            \"0x%lX\", text_section_start);\n-\n-  return concat (\"-Ttext \", text_section_start_str, NULL);\n-}\n-\n-/* Returns command line parameters that describe the device startfile.  */\n-\n-const char *\n-avr_device_to_startfiles (int argc, const char **argv)\n-{\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  return concat (\"crt\", avr_current_device->library_name, \".o%s\", NULL);\n-}\n-\n-/* Returns command line parameters that describe the device library.  */\n-\n-const char *\n-avr_device_to_devicelib (int argc, const char **argv)\n-{\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  return concat (\"-l\", avr_current_device->library_name, NULL);\n-}\n-\n-const char*\n-avr_device_to_sp8 (int argc, const char **argv)\n-{\n-  if (0 == argc)\n-    return NULL;\n-\n-  avr_set_current_device (argv[0]);\n-\n-  /* Leave \"avr2\" and \"avr25\" alone.  These two architectures are\n-     the only ones that mix devices with 8-bit SP and 16-bit SP.\n-     -msp8 is set by mmultilib machinery.  */\n-\n-  if (avr_current_device->macro == NULL\n-      && (avr_current_device->arch == ARCH_AVR2\n-          || avr_current_device->arch == ARCH_AVR25))\n-    return \"\";\n-\n-  return (avr_current_device->dev_attribute & AVR_SHORT_SP)\n-    ? \"-msp8\"\n-    : \"%<msp8\";\n-}"}, {"sha": "73bacf4fa2f52e690bcbf2f25b3f587ffefc260a", "filename": "gcc/config/avr/gen-avr-mmcu-specs.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgen-avr-mmcu-specs.c?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -0,0 +1,137 @@\n+/* Copyright (C) 1998-2014 Free Software Foundation, Inc.\n+   Contributed by Joern Rennecke\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+   \n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#define IN_GEN_AVR_MMCU_TEXI\n+\n+#include \"avr-arch.h\"\n+#include \"avr-devices.c\"\n+\n+static void\n+print_mcu (const avr_mcu_t *mcu)\n+{\n+  const avr_mcu_t *arch_mcu;\n+\n+  for (arch_mcu = mcu; arch_mcu->macro; )\n+    arch_mcu--;\n+  if (arch_mcu->arch != mcu->arch)\n+    exit (EXIT_FAILURE);\n+\n+  char name[100];\n+  if (snprintf (name, sizeof name, \"specs-%s\", mcu->name) >= sizeof name)\n+   exit (EXIT_FAILURE);\n+\n+  FILE *f = fopen (name ,\"w\");\n+\n+  const char *sp8, *errata_skip, *rmw;\n+  /* Leave \"avr2\" and \"avr25\" alone.  These two architectures are\n+     the only ones that mix devices with 8-bit SP and 16-bit SP.  */\n+  if (mcu->macro == NULL\n+      && (mcu->arch == ARCH_AVR2 || mcu->arch == ARCH_AVR25))\n+    sp8 = \"\";\n+\n+  sp8 = ((mcu->dev_attribute & AVR_SHORT_SP)\n+\t ? \" -msp8\" : \" %<msp8\");\n+\n+  errata_skip = (mcu->dev_attribute & AVR_ERRATA_SKIP) ? \" -mskip-bug\" : \"\";\n+  rmw = (mcu->dev_attribute & AVR_ISA_RMW) ? \"%%{!mno-rmw: -mrmw}\" : \"\";\n+\n+  const char *arch_name = avr_arch_types[mcu->arch].arch_name;\n+\n+  fprintf (f, \"*self_spec:\\n%%{!march=*:-march=%s}%s\\n\\n\", arch_name, sp8);\n+\n+  if (mcu->macro)\n+    fprintf (f, \"*cpp:\\n-D__AVR_DEV_LIB_NAME__=%s -D%s \"\n+\t     \"-D__AVR_DEVICE_NAME__=%s\\n\\n\",\n+\t     mcu->library_name, mcu->macro, mcu->name);\n+\n+  fprintf (f, \"*cc1:\\n%s%s\", errata_skip, rmw);\n+  if (mcu->n_flash != arch_mcu->n_flash)\n+    fprintf (f, \" %%{!mn-flash:-mn-flash=%d}\", mcu->n_flash);\n+  fprintf (f, \"\\n\\n\");\n+  fprintf (f, \"*cc1plus:\\n%s%s \", errata_skip, rmw);\n+  if (mcu->n_flash != arch_mcu->n_flash)\n+    fprintf (f, \"%%{!mn-flash:-mn-flash=%d}\", mcu->n_flash);\n+  fprintf (f, \"%%{!frtti: -fno-rtti}\"\n+\t   \"%%{!fenforce-eh-specs: -fno-enforce-eh-specs}\"\n+\t   \"%%{!fexceptions: -fno-exceptions}\\n\\n\");\n+\n+  fprintf (f, \"*asm:\\n%%{march=*:-mmcu=%%*}%{mrelax: --mlink-relax}%s\\n\\n\",\n+\t   *errata_skip ? \"\" : \" -mno-skip-bug\");\n+\n+  fprintf (f, \"*link:\\n%%{mrelax:--relax\");\n+  if (strncmp (mcu->name, \"at90usb8\", strlen (\"at90usb8\")) == 0)\n+    fprintf (f, \"%%{mpmem-wrap-around: --pmem-wrap-around=8k}\");\n+  if (strncmp (mcu->name, \"atmega16\", strlen (\"atmega16\")) == 0)\n+    fprintf (f, \"%%{mpmem-wrap-around: --pmem-wrap-around=16k}\");\n+  if (strncmp (mcu->name, \"atmega32\", strlen (\"atmega32\")) == 0\n+      || strncmp (mcu->name, \"at90can32\", strlen (\"at90can32\")) == 0)\n+    fprintf (f, \"%%{mpmem-wrap-around: --pmem-wrap-around=32k}\");\n+  if (strncmp (mcu->name, \"atmega64\", strlen (\"atmega64\")) == 0\n+      || strncmp (mcu->name, \"at90can64\", strlen (\"at90can64\")) == 0\n+      || strncmp (mcu->name, \"at90usb64\", strlen (\"at90usb64\")) == 0)\n+    fprintf (f, \"%%{mpmem-wrap-around: --pmem-wrap-around=64k}\");\n+  fprintf (f, \"} %%{march=*:-m%%*}\");\n+  if (mcu->data_section_start\n+      != avr_arch_types[mcu->arch].default_data_section_start)\n+    fprintf (f, \" -Tdata 0x%lX\", 0x800000UL + mcu->data_section_start);\n+  if (mcu->text_section_start != 0x0)\n+    fprintf (f, \" -Ttext 0x%lX\", mcu->text_section_start);\n+\n+  fprintf (f, \" %%{shared:%%eshared is not supported}\\n\\n\");\n+\n+  fprintf (f, \"*lib:\\n\");\n+  if (strncmp (mcu->name, \"mmcu=at90s1\", strlen (\"mmcu=at90s1\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny11\", strlen (\"mmcu=attiny11\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny12\", strlen (\"mmcu=attiny12\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny15\", strlen (\"mmcu=attiny15\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny28\", strlen (\"mmcu=attiny28\")) != 0)\n+    {\n+      fprintf (f, \"-lc\");\n+      if (mcu->macro)\n+\tfprintf (f, \" dev/%s/libdev.a%%s\", mcu->name);\n+    }\n+  fprintf (f, \"\\n\\n\");\n+\n+  fprintf (f, \"*libgcc:\\n\");\n+  if (strncmp (mcu->name, \"mmcu=at90s1\", strlen (\"mmcu=at90s1\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny11\", strlen (\"mmcu=attiny11\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny12\", strlen (\"mmcu=attiny12\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny15\", strlen (\"mmcu=attiny15\")) != 0\n+      && strncmp (mcu->name, \"mmcu=attiny28\", strlen (\"mmcu=attiny28\")) != 0)\n+    fprintf (f, \"-lgcc\");\n+  fprintf (f, \"\\n\\n\");\n+\n+  fprintf (f, \"*startfile:\\ndev/%s/crt1.o%%s\\n\\n\", mcu->name);\n+}\n+\n+int main (void)\n+{\n+  enum avr_arch arch = ARCH_UNKNOWN;\n+  size_t i, n_mcus = 0;\n+  const avr_mcu_t *mcu;\n+\n+  for (mcu = avr_mcu_types; mcu->name; mcu++)\n+    print_mcu (mcu);\n+\n+  return EXIT_SUCCESS;\n+}"}, {"sha": "b09ef6cc647e23b22d0743f0c0702c71ea62cde0", "filename": "gcc/config/avr/genmultilib.awk", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgenmultilib.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgenmultilib.awk?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -97,7 +97,7 @@ BEGIN {\n \tcores[n_cores] = core\n \tn_cores++\n \ttiny_stack[core] = 0\n-\toption[core] = \"mmcu=\" core\n+\toption[core] = \"march=\" core\n \n \tnext\n     }\n@@ -135,15 +135,13 @@ BEGIN {\n #    m_options     <->    MULTILIB_OPTIONS         Makefile\n #    m_dirnames    <->    MULTILIB_DIRNAMES           \"\n #    m_exceptions  <->    MULTILIB_EXCEPTIONS         \"\n-#    m_matches     <->    MULTILIB_MATCHES            \"\n #\n ##################################################################\n \n END {\n     m_options    = \"\\nMULTILIB_OPTIONS = \"\n     m_dirnames   = \"\\nMULTILIB_DIRNAMES =\"\n     m_exceptions = \"\\nMULTILIB_EXCEPTIONS =\"\n-    m_matches    = \"\\nMULTILIB_MATCHES =\"\n \n     ##############################################################\n     # Compose MULTILIB_OPTIONS.  This represents the Cross-Product\n@@ -169,8 +167,6 @@ END {\n \tline = option[core] \":\" option[mcu[t]]\n \tgsub (\"=\", \"?\", line)\n \tgsub (\":\", \"=\", line)\n-\n-\tm_matches = m_matches \" \\\\\\n\\t\" line\n     }\n \n     ####################################################################\n@@ -221,6 +217,5 @@ END {\n \tprint m_options\n \tprint m_dirnames\n \tprint m_exceptions\n-\tprint m_matches\n     }\n }"}, {"sha": "d55c6571ffda3a0c3352cb8bb896874c7f589d0a", "filename": "gcc/config/avr/genopt.sh", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgenopt.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fgenopt.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fgenopt.sh?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -41,19 +41,18 @@ cat <<EOF\n ; <http://www.gnu.org/licenses/>.\n \n Enum\n-Name(avr_mcu) Type(int)\n-Known MCU names:\n+Name(avr_arch) Type(enum avr_arch)\n+Known MCU architectures:\n \n EOF\n \n awk -F'[(, \t]+' 'BEGIN {\n-    value = 0\n }\n-/^AVR_MCU/ {\n+/^AVR_MCU.*NULL/ {\n     name = $2\n+    value = $3\n     gsub(\"\\\"\", \"\", name)\n     print \"EnumValue\"\n-    print \"Enum(avr_mcu) String(\" name \") Value(\" value \")\"\n+    print \"Enum(avr_arch) String(\" name \") Value(\" value \")\"\n     print \"\"\n-    value++\n }' $1"}, {"sha": "4b456a5706d420141a729c1b47b1c54133e3f467", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -43,10 +43,12 @@\n        (match_test \"REGNO (op) == REG_SP\")))\n \n ;; Return true if OP is a valid address for lower half of I/O space.\n-(define_predicate \"low_io_address_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n-                              0, 0x1f)\")))\n+(define_special_predicate \"low_io_address_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+\t\t\t\t   0, 020 - GET_MODE_SIZE (mode))\"))\n+       (and (match_code \"symbol_ref\")\n+\t    (match_test \"SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO_LOW\"))))\n \n ;; Return true if OP is a valid address for high half of I/O space.\n (define_predicate \"high_io_address_operand\"\n@@ -55,10 +57,12 @@\n                               0x20, 0x3F)\")))\n \n ;; Return true if OP is a valid address of I/O space.\n-(define_predicate \"io_address_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n-                              0, 0x40 - GET_MODE_SIZE (mode))\")))\n+(define_special_predicate \"io_address_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"IN_RANGE (INTVAL (op) - avr_current_arch->sfr_offset,\n+\t\t\t\t   0, 0x40 - GET_MODE_SIZE (mode))\"))\n+       (and (match_code \"symbol_ref\")\n+\t    (match_test \"SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_IO\"))))\n \n ;; Return 1 if OP is a general operand not in flash memory\n (define_predicate \"nop_general_operand\""}, {"sha": "2b445bb66ede2074b9df52a643c6b0d26093a5e0", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -67,9 +67,30 @@ gen-avr-mmcu-texi$(build_exeext): $(srcdir)/config/avr/gen-avr-mmcu-texi.c \\\n   $(srcdir)/config/avr/avr-arch.h\n \t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $< -o $@\n \n+gen-avr-mmcu-specs$(build_exeext): $(srcdir)/config/avr/gen-avr-mmcu-specs.c \\\n+  $(AVR_MCUS) $(srcdir)/config/avr/avr-devices.c \\\n+  $(srcdir)/config/avr/avr-arch.h\n+\t$(CC_FOR_BUILD) $(CFLAGS_FOR_BUILD) $< -o $@\n+\n $(srcdir)/doc/avr-mmcu.texi: gen-avr-mmcu-texi$(build_exeext)\n \t$(RUN_GEN) ./$< > $@\n \n+s-device-specs: gen-avr-mmcu-specs$(build_exeext)\n+\trm -rf device-specs\n+\tmkdir device-specs && cd device-specs && $(RUN_GEN) ../$<\n+\t$(STAMP) s-device-specs\n+\n+GCC_PASSES+=s-device-specs\n+\n+install-driver: install-device-specs\n+\n+install-device-specs: s-device-specs installdirs\n+\t-rm -rf $(DESTDIR)$(libsubdir)/device-specs\n+\tmkdir $(DESTDIR)$(libsubdir)/device-specs\n+\t-for file in device-specs/*; do \\\n+\t$(INSTALL_PROGRAM) $${file} $(DESTDIR)$(libsubdir)/$${file}; \\\n+\tdone\n+\n # Map -mmcu= to the right multilib variant\n # MULTILIB_OPTIONS\n # MULTILIB_DIRNAMES"}, {"sha": "9aee17bfda83b4b60814be40b4982d272f1a3a6c", "filename": "gcc/config/avr/t-multilib", "status": "modified", "additions": 13, "deletions": 255, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Ft-multilib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fconfig%2Favr%2Ft-multilib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-multilib?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -21,262 +21,20 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr25/mmcu=avr3/mmcu=avr31/mmcu=avr35/mmcu=avr4/mmcu=avr5/mmcu=avr51/mmcu=avr6/mmcu=avrxmega2/mmcu=avrxmega4/mmcu=avrxmega5/mmcu=avrxmega6/mmcu=avrxmega7 msp8\n+MULTILIB_OPTIONS = march=avr2/march=avr25/march=avr3/march=avr31/march=avr35/march=avr4/march=avr5/march=avr51/march=avr6/march=avrxmega2/march=avrxmega4/march=avrxmega5/march=avrxmega6/march=avrxmega7 msp8\n \n MULTILIB_DIRNAMES =  avr2 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega2 avrxmega4 avrxmega5 avrxmega6 avrxmega7 tiny-stack avr25/tiny-stack\n \n MULTILIB_EXCEPTIONS = \\\n-\tmmcu=avr3/msp8 \\\n-\tmmcu=avr31/msp8 \\\n-\tmmcu=avr35/msp8 \\\n-\tmmcu=avr4/msp8 \\\n-\tmmcu=avr5/msp8 \\\n-\tmmcu=avr51/msp8 \\\n-\tmmcu=avr6/msp8 \\\n-\tmmcu=avrxmega2/msp8 \\\n-\tmmcu=avrxmega4/msp8 \\\n-\tmmcu=avrxmega5/msp8 \\\n-\tmmcu=avrxmega6/msp8 \\\n-\tmmcu=avrxmega7/msp8\n-\n-MULTILIB_MATCHES = \\\n-\tmmcu?avr2=mmcu?at90s2313 \\\n-\tmmcu?avr2=mmcu?at90s2323 \\\n-\tmmcu?avr2=mmcu?at90s2333 \\\n-\tmmcu?avr2=mmcu?at90s2343 \\\n-\tmmcu?avr2=mmcu?attiny22 \\\n-\tmmcu?avr2=mmcu?attiny26 \\\n-\tmmcu?avr2=mmcu?at90s4414 \\\n-\tmmcu?avr2=mmcu?at90s4433 \\\n-\tmmcu?avr2=mmcu?at90s4434 \\\n-\tmmcu?avr2=mmcu?at90s8515 \\\n-\tmmcu?avr2=mmcu?at90c8534 \\\n-\tmmcu?avr2=mmcu?at90s8535 \\\n-\tmmcu?avr25=mmcu?ata5272 \\\n-\tmmcu?avr25=mmcu?ata6616c \\\n-\tmmcu?avr25=mmcu?attiny13 \\\n-\tmmcu?avr25=mmcu?attiny13a \\\n-\tmmcu?avr25=mmcu?attiny2313 \\\n-\tmmcu?avr25=mmcu?attiny2313a \\\n-\tmmcu?avr25=mmcu?attiny24 \\\n-\tmmcu?avr25=mmcu?attiny24a \\\n-\tmmcu?avr25=mmcu?attiny4313 \\\n-\tmmcu?avr25=mmcu?attiny44 \\\n-\tmmcu?avr25=mmcu?attiny44a \\\n-\tmmcu?avr25=mmcu?attiny441 \\\n-\tmmcu?avr25=mmcu?attiny84 \\\n-\tmmcu?avr25=mmcu?attiny84a \\\n-\tmmcu?avr25=mmcu?attiny25 \\\n-\tmmcu?avr25=mmcu?attiny45 \\\n-\tmmcu?avr25=mmcu?attiny85 \\\n-\tmmcu?avr25=mmcu?attiny261 \\\n-\tmmcu?avr25=mmcu?attiny261a \\\n-\tmmcu?avr25=mmcu?attiny461 \\\n-\tmmcu?avr25=mmcu?attiny461a \\\n-\tmmcu?avr25=mmcu?attiny861 \\\n-\tmmcu?avr25=mmcu?attiny861a \\\n-\tmmcu?avr25=mmcu?attiny43u \\\n-\tmmcu?avr25=mmcu?attiny87 \\\n-\tmmcu?avr25=mmcu?attiny48 \\\n-\tmmcu?avr25=mmcu?attiny88 \\\n-\tmmcu?avr25=mmcu?attiny828 \\\n-\tmmcu?avr25=mmcu?attiny841 \\\n-\tmmcu?avr25=mmcu?at86rf401 \\\n-\tmmcu?avr3=mmcu?at43usb355 \\\n-\tmmcu?avr3=mmcu?at76c711 \\\n-\tmmcu?avr31=mmcu?atmega103 \\\n-\tmmcu?avr31=mmcu?at43usb320 \\\n-\tmmcu?avr35=mmcu?ata5505 \\\n-\tmmcu?avr35=mmcu?ata6617c \\\n-\tmmcu?avr35=mmcu?ata664251 \\\n-\tmmcu?avr35=mmcu?at90usb82 \\\n-\tmmcu?avr35=mmcu?at90usb162 \\\n-\tmmcu?avr35=mmcu?atmega8u2 \\\n-\tmmcu?avr35=mmcu?atmega16u2 \\\n-\tmmcu?avr35=mmcu?atmega32u2 \\\n-\tmmcu?avr35=mmcu?attiny167 \\\n-\tmmcu?avr35=mmcu?attiny1634 \\\n-\tmmcu?avr4=mmcu?ata6285 \\\n-\tmmcu?avr4=mmcu?ata6286 \\\n-\tmmcu?avr4=mmcu?ata6289 \\\n-\tmmcu?avr4=mmcu?ata6612c \\\n-\tmmcu?avr4=mmcu?atmega8 \\\n-\tmmcu?avr4=mmcu?atmega8a \\\n-\tmmcu?avr4=mmcu?atmega48 \\\n-\tmmcu?avr4=mmcu?atmega48a \\\n-\tmmcu?avr4=mmcu?atmega48p \\\n-\tmmcu?avr4=mmcu?atmega48pa \\\n-\tmmcu?avr4=mmcu?atmega88 \\\n-\tmmcu?avr4=mmcu?atmega88a \\\n-\tmmcu?avr4=mmcu?atmega88p \\\n-\tmmcu?avr4=mmcu?atmega88pa \\\n-\tmmcu?avr4=mmcu?atmega8515 \\\n-\tmmcu?avr4=mmcu?atmega8535 \\\n-\tmmcu?avr4=mmcu?atmega8hva \\\n-\tmmcu?avr4=mmcu?at90pwm1 \\\n-\tmmcu?avr4=mmcu?at90pwm2 \\\n-\tmmcu?avr4=mmcu?at90pwm2b \\\n-\tmmcu?avr4=mmcu?at90pwm3 \\\n-\tmmcu?avr4=mmcu?at90pwm3b \\\n-\tmmcu?avr4=mmcu?at90pwm81 \\\n-\tmmcu?avr5=mmcu?ata5702m322 \\\n-\tmmcu?avr5=mmcu?ata5782 \\\n-\tmmcu?avr5=mmcu?ata5790 \\\n-\tmmcu?avr5=mmcu?ata5790n \\\n-\tmmcu?avr5=mmcu?ata5795 \\\n-\tmmcu?avr5=mmcu?ata5831 \\\n-\tmmcu?avr5=mmcu?ata6613c \\\n-\tmmcu?avr5=mmcu?ata6614q \\\n-\tmmcu?avr5=mmcu?atmega16 \\\n-\tmmcu?avr5=mmcu?atmega16a \\\n-\tmmcu?avr5=mmcu?atmega161 \\\n-\tmmcu?avr5=mmcu?atmega162 \\\n-\tmmcu?avr5=mmcu?atmega163 \\\n-\tmmcu?avr5=mmcu?atmega164a \\\n-\tmmcu?avr5=mmcu?atmega164p \\\n-\tmmcu?avr5=mmcu?atmega164pa \\\n-\tmmcu?avr5=mmcu?atmega165 \\\n-\tmmcu?avr5=mmcu?atmega165a \\\n-\tmmcu?avr5=mmcu?atmega165p \\\n-\tmmcu?avr5=mmcu?atmega165pa \\\n-\tmmcu?avr5=mmcu?atmega168 \\\n-\tmmcu?avr5=mmcu?atmega168a \\\n-\tmmcu?avr5=mmcu?atmega168p \\\n-\tmmcu?avr5=mmcu?atmega168pa \\\n-\tmmcu?avr5=mmcu?atmega169 \\\n-\tmmcu?avr5=mmcu?atmega169a \\\n-\tmmcu?avr5=mmcu?atmega169p \\\n-\tmmcu?avr5=mmcu?atmega169pa \\\n-\tmmcu?avr5=mmcu?atmega16hvb \\\n-\tmmcu?avr5=mmcu?atmega16hvbrevb \\\n-\tmmcu?avr5=mmcu?atmega16m1 \\\n-\tmmcu?avr5=mmcu?atmega16u4 \\\n-\tmmcu?avr5=mmcu?atmega32a \\\n-\tmmcu?avr5=mmcu?atmega32 \\\n-\tmmcu?avr5=mmcu?atmega323 \\\n-\tmmcu?avr5=mmcu?atmega324a \\\n-\tmmcu?avr5=mmcu?atmega324p \\\n-\tmmcu?avr5=mmcu?atmega324pa \\\n-\tmmcu?avr5=mmcu?atmega325 \\\n-\tmmcu?avr5=mmcu?atmega325a \\\n-\tmmcu?avr5=mmcu?atmega325p \\\n-\tmmcu?avr5=mmcu?atmega325pa \\\n-\tmmcu?avr5=mmcu?atmega3250 \\\n-\tmmcu?avr5=mmcu?atmega3250a \\\n-\tmmcu?avr5=mmcu?atmega3250p \\\n-\tmmcu?avr5=mmcu?atmega3250pa \\\n-\tmmcu?avr5=mmcu?atmega328 \\\n-\tmmcu?avr5=mmcu?atmega328p \\\n-\tmmcu?avr5=mmcu?atmega329 \\\n-\tmmcu?avr5=mmcu?atmega329a \\\n-\tmmcu?avr5=mmcu?atmega329p \\\n-\tmmcu?avr5=mmcu?atmega329pa \\\n-\tmmcu?avr5=mmcu?atmega3290 \\\n-\tmmcu?avr5=mmcu?atmega3290a \\\n-\tmmcu?avr5=mmcu?atmega3290p \\\n-\tmmcu?avr5=mmcu?atmega3290pa \\\n-\tmmcu?avr5=mmcu?atmega32c1 \\\n-\tmmcu?avr5=mmcu?atmega32m1 \\\n-\tmmcu?avr5=mmcu?atmega32u4 \\\n-\tmmcu?avr5=mmcu?atmega32u6 \\\n-\tmmcu?avr5=mmcu?atmega406 \\\n-\tmmcu?avr5=mmcu?atmega64 \\\n-\tmmcu?avr5=mmcu?atmega64a \\\n-\tmmcu?avr5=mmcu?atmega640 \\\n-\tmmcu?avr5=mmcu?atmega644 \\\n-\tmmcu?avr5=mmcu?atmega644a \\\n-\tmmcu?avr5=mmcu?atmega644p \\\n-\tmmcu?avr5=mmcu?atmega644pa \\\n-\tmmcu?avr5=mmcu?atmega645 \\\n-\tmmcu?avr5=mmcu?atmega645a \\\n-\tmmcu?avr5=mmcu?atmega645p \\\n-\tmmcu?avr5=mmcu?atmega6450 \\\n-\tmmcu?avr5=mmcu?atmega6450a \\\n-\tmmcu?avr5=mmcu?atmega6450p \\\n-\tmmcu?avr5=mmcu?atmega649 \\\n-\tmmcu?avr5=mmcu?atmega649a \\\n-\tmmcu?avr5=mmcu?atmega649p \\\n-\tmmcu?avr5=mmcu?atmega6490 \\\n-\tmmcu?avr5=mmcu?atmega16hva \\\n-\tmmcu?avr5=mmcu?atmega16hva2 \\\n-\tmmcu?avr5=mmcu?atmega32hvb \\\n-\tmmcu?avr5=mmcu?atmega6490a \\\n-\tmmcu?avr5=mmcu?atmega6490p \\\n-\tmmcu?avr5=mmcu?atmega64c1 \\\n-\tmmcu?avr5=mmcu?atmega64m1 \\\n-\tmmcu?avr5=mmcu?atmega64hve \\\n-\tmmcu?avr5=mmcu?atmega64hve2 \\\n-\tmmcu?avr5=mmcu?atmega64rfr2 \\\n-\tmmcu?avr5=mmcu?atmega644rfr2 \\\n-\tmmcu?avr5=mmcu?atmega32hvbrevb \\\n-\tmmcu?avr5=mmcu?at90can32 \\\n-\tmmcu?avr5=mmcu?at90can64 \\\n-\tmmcu?avr5=mmcu?at90pwm161 \\\n-\tmmcu?avr5=mmcu?at90pwm216 \\\n-\tmmcu?avr5=mmcu?at90pwm316 \\\n-\tmmcu?avr5=mmcu?at90scr100 \\\n-\tmmcu?avr5=mmcu?at90usb646 \\\n-\tmmcu?avr5=mmcu?at90usb647 \\\n-\tmmcu?avr5=mmcu?at94k \\\n-\tmmcu?avr5=mmcu?m3000 \\\n-\tmmcu?avr51=mmcu?atmega128 \\\n-\tmmcu?avr51=mmcu?atmega128a \\\n-\tmmcu?avr51=mmcu?atmega1280 \\\n-\tmmcu?avr51=mmcu?atmega1281 \\\n-\tmmcu?avr51=mmcu?atmega1284 \\\n-\tmmcu?avr51=mmcu?atmega1284p \\\n-\tmmcu?avr51=mmcu?atmega128rfa1 \\\n-\tmmcu?avr51=mmcu?atmega128rfr2 \\\n-\tmmcu?avr51=mmcu?atmega1284rfr2 \\\n-\tmmcu?avr51=mmcu?at90can128 \\\n-\tmmcu?avr51=mmcu?at90usb1286 \\\n-\tmmcu?avr51=mmcu?at90usb1287 \\\n-\tmmcu?avr6=mmcu?atmega2560 \\\n-\tmmcu?avr6=mmcu?atmega2561 \\\n-\tmmcu?avr6=mmcu?atmega256rfr2 \\\n-\tmmcu?avr6=mmcu?atmega2564rfr2 \\\n-\tmmcu?avrxmega2=mmcu?atxmega8e5 \\\n-\tmmcu?avrxmega2=mmcu?atxmega16a4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega16d4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega16e5 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32a4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32c3 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32d3 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32d4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega16a4u \\\n-\tmmcu?avrxmega2=mmcu?atxmega16c4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32a4u \\\n-\tmmcu?avrxmega2=mmcu?atxmega32c4 \\\n-\tmmcu?avrxmega2=mmcu?atxmega32e5 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64a3 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64d3 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64a3u \\\n-\tmmcu?avrxmega4=mmcu?atxmega64a4u \\\n-\tmmcu?avrxmega4=mmcu?atxmega64b1 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64b3 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64c3 \\\n-\tmmcu?avrxmega4=mmcu?atxmega64d4 \\\n-\tmmcu?avrxmega5=mmcu?atxmega64a1 \\\n-\tmmcu?avrxmega5=mmcu?atxmega64a1u \\\n-\tmmcu?avrxmega6=mmcu?atxmega128a3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega128d3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega192a3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega192d3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega256a3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega256a3b \\\n-\tmmcu?avrxmega6=mmcu?atxmega256a3bu \\\n-\tmmcu?avrxmega6=mmcu?atxmega256d3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega128a3u \\\n-\tmmcu?avrxmega6=mmcu?atxmega128b1 \\\n-\tmmcu?avrxmega6=mmcu?atxmega128b3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega128c3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega128d4 \\\n-\tmmcu?avrxmega6=mmcu?atxmega192a3u \\\n-\tmmcu?avrxmega6=mmcu?atxmega192c3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega256a3u \\\n-\tmmcu?avrxmega6=mmcu?atxmega256c3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega384c3 \\\n-\tmmcu?avrxmega6=mmcu?atxmega384d3 \\\n-\tmmcu?avrxmega7=mmcu?atxmega128a1 \\\n-\tmmcu?avrxmega7=mmcu?atxmega128a1u \\\n-\tmmcu?avrxmega7=mmcu?atxmega128a4u\n+\tmarch=avr3/msp8 \\\n+\tmarch=avr31/msp8 \\\n+\tmarch=avr35/msp8 \\\n+\tmarch=avr4/msp8 \\\n+\tmarch=avr5/msp8 \\\n+\tmarch=avr51/msp8 \\\n+\tmarch=avr6/msp8 \\\n+\tmarch=avrxmega2/msp8 \\\n+\tmarch=avrxmega4/msp8 \\\n+\tmarch=avrxmega5/msp8 \\\n+\tmarch=avrxmega6/msp8 \\\n+\tmarch=avrxmega7/msp8"}, {"sha": "6db142e4d6c3fa2ad0643d7523972cd5e63b95ac", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d29866b5bdf7d42d974dc3f91fb2bd834354db/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f9d29866b5bdf7d42d974dc3f91fb2bd834354db", "patch": "@@ -5318,6 +5318,47 @@ normally resides in the data memory (RAM).\n \n See also the @ref{AVR Named Address Spaces} section for\n an alternate way to locate and access data in flash memory.\n+\n+@item io\n+@itemx io (@var{addr})\n+Variables with the @code{io} attribute are used to address\n+memory-mapped peripherals in the io address range.\n+If an address is specified, the variable\n+is assigned that address, and the value is interpreted as an\n+address in the data address space.\n+Example:\n+\n+@smallexample\n+volatile int porta __attribute__((io (0x22)));\n+@end smallexample\n+\n+The address specified in the address in the data address range.\n+\n+Otherwise, the variable it is not assigned an address, but the\n+compiler will still use in/out instructions where applicable,\n+assuming some other module assigns an address in the io address range.\n+Example:\n+\n+@smallexample\n+extern volatile int porta __attribute__((io));\n+@end smallexample\n+\n+@item io_low\n+@itemx io_low (@var{addr})\n+This is like the @code{io} attribute, but additionally it informs the\n+compiler that the object lies in the lower half of the I/O area,\n+allowing the use of @code{cbi}, @code{sbi}, @code{sbic} and @code{sbis}\n+instructions.\n+\n+@item address\n+@itemx address (@var{addr})\n+Variables with the @code{address} attribute are used to address\n+memory-mapped peripherals that may lie outside the io address range.\n+\n+@smallexample\n+volatile int porta __attribute__((address (0x600)));\n+@end smallexample\n+\n @end table\n \n @subsection Blackfin Variable Attributes"}]}