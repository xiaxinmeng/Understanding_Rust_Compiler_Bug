{"sha": "93fe8e9229a808d836553dcbe49104f97bdecb96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmZThlOTIyOWE4MDhkODM2NTUzZGNiZTQ5MTA0Zjk3YmRlY2I5Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2002-03-09T12:53:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-03-09T12:53:21Z"}, "message": "emit-rtl.c (copy_most_rtx): Accept EXPR_LIST for may_share.\n\n\t* emit-rtl.c (copy_most_rtx): Accept EXPR_LIST for may_share.\n\t* function.c (fixup_var_refs): Add MAY_SHARE parameter.\n\t(fixup_var_refs_insns, fixup_var_refs_insns_with_has): Likewise.\n\t(fixup_var_refs_insn, fixup_var_refs_1): Likewise.\n\t(pop_function_context): Compute MAY_SHARE parameter for\n\tfixup_var_refs.\n\t(fixup_var_refs_1, case MEM): Pass MAY_SHARE to copy_most_rtx, not VAR.\n\t(gen_mem_addressof): Call fixup_var_refs with new parm.\n\nFrom-SVN: r50493", "tree": {"sha": "1f599de47e1e5ba4b01146509946d8ab73e913f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f599de47e1e5ba4b01146509946d8ab73e913f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93fe8e9229a808d836553dcbe49104f97bdecb96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fe8e9229a808d836553dcbe49104f97bdecb96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93fe8e9229a808d836553dcbe49104f97bdecb96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fe8e9229a808d836553dcbe49104f97bdecb96/comments", "author": null, "committer": null, "parents": [{"sha": "0a7ec76355b0e53a3f48727f7ae8e3c5f812458b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7ec76355b0e53a3f48727f7ae8e3c5f812458b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7ec76355b0e53a3f48727f7ae8e3c5f812458b"}], "stats": {"total": 156, "additions": 106, "deletions": 50}, "files": [{"sha": "559ab4f4fb1b1177c845399b3d6f1df7164f4d5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93fe8e9229a808d836553dcbe49104f97bdecb96", "patch": "@@ -1,5 +1,14 @@\n Sat Mar  9 07:20:01 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* emit-rtl.c (copy_most_rtx): Accept EXPR_LIST for may_share.\n+\t* function.c (fixup_var_refs): Add MAY_SHARE parameter.\n+\t(fixup_var_refs_insns, fixup_var_refs_insns_with_has): Likewise.\n+\t(fixup_var_refs_insn, fixup_var_refs_1): Likewise.\n+\t(pop_function_context): Compute MAY_SHARE parameter for\n+\tfixup_var_refs.\n+\t(fixup_var_refs_1, case MEM): Pass MAY_SHARE to copy_most_rtx, not VAR.\n+\t(gen_mem_addressof): Call fixup_var_refs with new parm.\n+\n \t* combine.c (make_extraction): Don't make extension of CONST_INT.\n \n 2002-03-09  Alexandre Oliva  <aoliva@redhat.com>"}, {"sha": "4d82afb68851b06adb101c3e625dbc2ee3f239e8", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=93fe8e9229a808d836553dcbe49104f97bdecb96", "patch": "@@ -2239,7 +2239,8 @@ reset_used_decls (blk)\n }\n \n /* Similar to `copy_rtx' except that if MAY_SHARE is present, it is\n-   placed in the result directly, rather than being copied.  */\n+   placed in the result directly, rather than being copied.  MAY_SHARE is\n+   either a MEM of an EXPR_LIST of MEMs.  */\n \n rtx\n copy_most_rtx (orig, may_share)\n@@ -2251,7 +2252,9 @@ copy_most_rtx (orig, may_share)\n   RTX_CODE code;\n   const char *format_ptr;\n \n-  if (orig == may_share)\n+  if (orig == may_share\n+      || (GET_CODE (may_share) == EXPR_LIST\n+\t  && in_expr_list_p (may_share, orig)))\n     return orig;\n \n   code = GET_CODE (orig);"}, {"sha": "f245a063a51a9d3bb9524ca5bc8bd791be03a54a", "filename": "gcc/function.c", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=93fe8e9229a808d836553dcbe49104f97bdecb96", "patch": "@@ -239,19 +239,19 @@ static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n static void schedule_fixup_var_refs PARAMS ((struct function *, rtx, tree,\n \t\t\t\t\t     enum machine_mode,\n \t\t\t\t\t     struct hash_table *));\n-static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int,\n+static void fixup_var_refs\tPARAMS ((rtx, enum machine_mode, int, rtx,\n \t\t\t\t\t struct hash_table *));\n static struct fixup_replacement\n   *find_fixup_replacement\tPARAMS ((struct fixup_replacement **, rtx));\n static void fixup_var_refs_insns PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t  int, int));\n+\t\t\t\t\t  int, int, rtx));\n static void fixup_var_refs_insns_with_hash\n \t\t\t\tPARAMS ((struct hash_table *, rtx,\n-\t\t\t\t\t enum machine_mode, int));\n+\t\t\t\t\t enum machine_mode, int, rtx));\n static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t int, int));\n+\t\t\t\t\t int, int, rtx));\n static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n-\t\t\t\t\t struct fixup_replacement **));\n+\t\t\t\t\t struct fixup_replacement **, rtx));\n static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, int));\n static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, int));\n static rtx fixup_stack_1\tPARAMS ((rtx, rtx));\n@@ -389,11 +389,29 @@ pop_function_context_from (context)\n   if (restore_lang_status)\n     (*restore_lang_status) (p);\n \n-  /* Finish doing put_var_into_stack for any of our variables\n-     which became addressable during the nested function.  */\n-  for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n-    fixup_var_refs (queue->modified, queue->promoted_mode,\n-\t\t    queue->unsignedp, 0);\n+  /* Finish doing put_var_into_stack for any of our variables which became\n+     addressable during the nested function.  If only one entry has to be\n+     fixed up, just do that one.  Otherwise, first make a list of MEMs that\n+     are not to be unshared.  */\n+  if (p->fixup_var_refs_queue == 0)\n+    ;\n+  else if (p->fixup_var_refs_queue->next == 0)\n+    fixup_var_refs (p->fixup_var_refs_queue->modified,\n+\t\t    p->fixup_var_refs_queue->promoted_mode,\n+\t\t    p->fixup_var_refs_queue->unsignedp,\n+\t\t    p->fixup_var_refs_queue->modified, 0);\n+  else\n+    {\n+      rtx list = 0;\n+\n+      for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n+\tlist = gen_rtx_EXPR_LIST (VOIDmode, queue->modified, list);\n+\n+      for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n+\tfixup_var_refs (queue->modified, queue->promoted_mode,\n+\t\t\tqueue->unsignedp, list, 0);\n+\n+    }\n \n   p->fixup_var_refs_queue = 0;\n \n@@ -1525,15 +1543,16 @@ schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n     }\n   else\n     /* Variable is local; fix it up now.  */\n-    fixup_var_refs (reg, promoted_mode, unsigned_p, ht);\n+    fixup_var_refs (reg, promoted_mode, unsigned_p, reg, ht);\n }\n \f\n static void\n-fixup_var_refs (var, promoted_mode, unsignedp, ht)\n+fixup_var_refs (var, promoted_mode, unsignedp, may_share, ht)\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n      struct hash_table *ht;\n+     rtx may_share;\n {\n   tree pending;\n   rtx first_insn = get_insns ();\n@@ -1545,19 +1564,20 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n     {\n       if (stack != 0)\n \tabort ();\n-      fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp);\n+      fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp,\n+\t\t\t\t      may_share);\n       return;\n     }\n \n   fixup_var_refs_insns (first_insn, var, promoted_mode, unsignedp,\n-\t\t\tstack == 0);\n+\t\t\tstack == 0, may_share);\n \n   /* Scan all pending sequences too.  */\n   for (; stack; stack = stack->next)\n     {\n       push_to_full_sequence (stack->first, stack->last);\n       fixup_var_refs_insns (stack->first, var, promoted_mode, unsignedp,\n-\t\t\t    stack->next != 0);\n+\t\t\t    stack->next != 0, may_share);\n       /* Update remembered end of sequence\n \t in case we added an insn at the end.  */\n       stack->last = get_last_insn ();\n@@ -1571,7 +1591,8 @@ fixup_var_refs (var, promoted_mode, unsignedp, ht)\n       if (seq != const0_rtx && seq != 0)\n \t{\n \t  push_to_sequence (seq);\n-\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0);\n+\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0,\n+\t\t\t\tmay_share);\n \t  end_sequence ();\n \t}\n     }\n@@ -1604,17 +1625,19 @@ find_fixup_replacement (replacements, x)\n   return p;\n }\n \n-/* Scan the insn-chain starting with INSN for refs to VAR\n-   and fix them up.  TOPLEVEL is nonzero if this chain is the\n-   main chain of insns for the current function.  */\n+/* Scan the insn-chain starting with INSN for refs to VAR and fix them\n+   up.  TOPLEVEL is nonzero if this chain is the main chain of insns\n+   for the current function.  MAY_SHARE is either a MEM that is not\n+   to be unshared or a list of them.  */\n \n static void\n-fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel)\n+fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel, may_share)\n      rtx insn;\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n      int toplevel;\n+     rtx may_share;\n {\n   while (insn)\n     {\n@@ -1639,15 +1662,17 @@ fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel)\n \t      if (seq)\n \t\t{\n \t\t  push_to_sequence (seq);\n-\t\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0);\n+\t\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0,\n+\t\t\t\t\tmay_share);\n \t\t  XEXP (PATTERN (insn), i) = get_insns ();\n \t\t  end_sequence ();\n \t\t}\n \t    }\n \t}\n \n       else if (INSN_P (insn))\n-\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel);\n+\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel,\n+\t\t\t     may_share);\n \n       insn = next;\n     }\n@@ -1661,25 +1686,22 @@ fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel)\n    (inside the CALL_PLACEHOLDER).  */\n \n static void\n-fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n+fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp, may_share)\n      struct hash_table *ht;\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n+     rtx may_share;\n {\n-  struct insns_for_mem_entry *ime = (struct insns_for_mem_entry *)\n-    hash_lookup (ht, var, /*create=*/0, /*copy=*/0);\n-  rtx insn_list = ime->insns;\n-\n-  while (insn_list)\n-    {\n-      rtx insn = XEXP (insn_list, 0);\n-\t\n-      if (INSN_P (insn))\n-\tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, 1);\n-\n-      insn_list = XEXP (insn_list, 1);\n-    }\n+  struct insns_for_mem_entry *ime\n+    = (struct insns_for_mem_entry *) hash_lookup (ht, var,\n+\t\t\t\t\t\t  /*create=*/0, /*copy=*/0);\n+  rtx insn_list;\n+\n+  for (insn_list = ime->insns; insn_list != 0; insn_list = XEXP (insn_list, 1))\n+    if (INSN_P (XEXP (insn_list, 0)))\n+      fixup_var_refs_insn (XEXP (insn_list, 0), var, promoted_mode,\n+\t\t\t   unsignedp, 1, may_share);\n }\n \n \n@@ -1690,12 +1712,13 @@ fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n    function.  */\n \n static void\n-fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n+fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n      rtx insn;\n      rtx var;\n      enum machine_mode promoted_mode;\n      int unsignedp;\n      int toplevel;\n+     rtx no_share;\n {\n   rtx call_dest = 0;\n   rtx set, prev, prev_set;\n@@ -1800,7 +1823,7 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n \t it here.  */\n \n       fixup_var_refs_1 (var, promoted_mode, &PATTERN (insn), insn,\n-\t\t\t&replacements);\n+\t\t\t&replacements, no_share);\n \n       /* If this is last_parm_insn, and any instructions were output\n \t after it to fix it up, then we must set last_parm_insn to\n@@ -1877,12 +1900,13 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n    or the SUBREG, as appropriate, to the pseudo.  */\n \n static void\n-fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n+fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n      rtx var;\n      enum machine_mode promoted_mode;\n      rtx *loc;\n      rtx insn;\n      struct fixup_replacement **replacements;\n+     rtx no_share;\n {\n   int i;\n   rtx x = *loc;\n@@ -1979,7 +2003,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t{\n \t  replacement = find_fixup_replacement (replacements, x);\n \t  if (replacement->new == 0)\n-\t    replacement->new = copy_most_rtx (x, var);\n+\t    replacement->new = copy_most_rtx (x, no_share);\n \n \t  *loc = x = replacement->new;\n \t  code = GET_CODE (x);\n@@ -2116,7 +2140,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t  if (SUBREG_PROMOTED_VAR_P (x))\n \t    {\n \t      *loc = var;\n-\t      fixup_var_refs_1 (var, GET_MODE (var), loc, insn, replacements);\n+\t      fixup_var_refs_1 (var, GET_MODE (var), loc, insn, replacements,\n+\t\t\t\tno_share);\n \t      return;\n \t    }\n \n@@ -2222,11 +2247,11 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t    /* Since this case will return, ensure we fixup all the\n \t       operands here.  */\n \t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 1),\n-\t\t\t      insn, replacements);\n+\t\t\t      insn, replacements, no_share);\n \t    fixup_var_refs_1 (var, promoted_mode, &XEXP (outerdest, 2),\n-\t\t\t      insn, replacements);\n+\t\t\t      insn, replacements, no_share);\n \t    fixup_var_refs_1 (var, promoted_mode, &SET_SRC (x),\n-\t\t\t      insn, replacements);\n+\t\t\t      insn, replacements, no_share);\n \n \t    tem = XEXP (outerdest, 0);\n \n@@ -2455,13 +2480,14 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tfixup_var_refs_1 (var, promoted_mode, &XEXP (x, i), insn, replacements);\n+\tfixup_var_refs_1 (var, promoted_mode, &XEXP (x, i), insn, replacements,\n+\t\t\t  no_share);\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    fixup_var_refs_1 (var, promoted_mode, &XVECEXP (x, i, j),\n-\t\t\t      insn, replacements);\n+\t\t\t      insn, replacements, no_share);\n \t}\n     }\n }\n@@ -2869,10 +2895,10 @@ gen_mem_addressof (reg, decl)\n \tSET_DECL_RTL (decl, reg);\n \n       if (TREE_USED (decl) || (DECL_P (decl) && DECL_INITIAL (decl) != 0))\n-\tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), 0);\n+\tfixup_var_refs (reg, GET_MODE (reg), TREE_UNSIGNED (type), reg, 0);\n     }\n   else\n-    fixup_var_refs (reg, GET_MODE (reg), 0, 0);\n+    fixup_var_refs (reg, GET_MODE (reg), 0, reg, 0);\n \n   return reg;\n }"}, {"sha": "2e1c449b0cc9fba164c26e5934e96c655420bcbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93fe8e9229a808d836553dcbe49104f97bdecb96", "patch": "@@ -1,3 +1,7 @@\n+Sat Mar  9 07:47:50 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* gcc.c-torture/compile/20020309-1.c: New test.\n+\n 2002-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20020307-2.c: New test."}, {"sha": "b74061764de595ce26dd703a0210dbd194c0bafb", "filename": "gcc/testsuite/gcc.c-torture/compile/20020309-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020309-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fe8e9229a808d836553dcbe49104f97bdecb96/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020309-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020309-1.c?ref=93fe8e9229a808d836553dcbe49104f97bdecb96", "patch": "@@ -0,0 +1,14 @@\n+int\n+sub1 (char *p, int i)\n+{\n+  char j = p[i];\n+\n+  {\n+    void\n+    sub2 ()\n+      {\n+\ti = 2;\n+\tp = p + 2;\n+      }\n+  }\n+}"}]}