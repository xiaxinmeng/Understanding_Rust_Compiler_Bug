{"sha": "c70eaeafa005e95e565806c8c9b30e54c8e8642f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcwZWFlYWZhMDA1ZTk1ZTU2NTgwNmM4YzliMzBlNTRjOGU4NjQyZg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-10-06T14:59:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-10-06T14:59:56Z"}, "message": "builtins.c (is_valid_printf_arglist, [...]): Move functions from here ...\n\n\t* builtins.c (is_valid_printf_arglist, expand_builtin_printf):\n\tMove functions from here ...\n\n\t* c-common.c (is_valid_printf_arglist, c_expand_builtin_printf):\n\t... to here.\n\t(c_expand_builtin): New function.\n\t(init_function_format_info): Don't set `check_function_format_ptr'.\n\t(c_common_nodes_and_builtins): Set built_in_class type for\n\tprintf/__builtin_printf to BUILT_IN_FRONTEND.\n\t(c_expand_expr): Handle CALL_EXPRs that are front-end builtins.\n\n\t* c-common.h (build_function_call): Declare.\n\n\t* expr.c (expand_expr): Pass builtins with class BUILT_IN_FRONTEND\n\tto `lang_expand_expr' rather than `expand_builtin'.\n\n\t* tree.c (check_function_format_ptr): Delete.\n\n\t* tree.h (check_function_format_ptr): Likewise.\n\nFrom-SVN: r36758", "tree": {"sha": "44773ff39d77f5a3d3e0a42bcc8277bd1b19a1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44773ff39d77f5a3d3e0a42bcc8277bd1b19a1bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c70eaeafa005e95e565806c8c9b30e54c8e8642f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70eaeafa005e95e565806c8c9b30e54c8e8642f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c70eaeafa005e95e565806c8c9b30e54c8e8642f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70eaeafa005e95e565806c8c9b30e54c8e8642f/comments", "author": null, "committer": null, "parents": [{"sha": "f299afab9b5479f9eaf8628dde4db4e5403aa9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f299afab9b5479f9eaf8628dde4db4e5403aa9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f299afab9b5479f9eaf8628dde4db4e5403aa9a6"}], "stats": {"total": 358, "additions": 224, "deletions": 134}, "files": [{"sha": "c98f4d9a5ec3c6e784e0103f8eb906fc7254f267", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -1,3 +1,25 @@\n+2000-10-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (is_valid_printf_arglist, expand_builtin_printf):\n+\tMove functions from here ...\n+\n+\t* c-common.c (is_valid_printf_arglist, c_expand_builtin_printf):\n+\t... to here.\n+\t(c_expand_builtin): New function.\n+\t(init_function_format_info): Don't set `check_function_format_ptr'.\n+\t(c_common_nodes_and_builtins): Set built_in_class type for\n+\tprintf/__builtin_printf to BUILT_IN_FRONTEND.\n+\t(c_expand_expr): Handle CALL_EXPRs that are front-end builtins.\n+\n+\t* c-common.h (build_function_call): Declare.\n+\n+\t* expr.c (expand_expr): Pass builtins with class BUILT_IN_FRONTEND\n+\tto `lang_expand_expr' rather than `expand_builtin'.\n+\n+\t* tree.c (check_function_format_ptr): Delete.\n+\n+\t* tree.h (check_function_format_ptr): Likewise.\n+\n 2000-10-06  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* dwarf2out.c (build_cfa_loc): Correct to use DW_OP_regx or"}, {"sha": "e2acada22c7e0efa0ee8210bcd557a13bab72556", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -111,8 +111,6 @@ static rtx expand_builtin_strlen\tPARAMS ((tree, rtx,\n static rtx expand_builtin_alloca\tPARAMS ((tree, rtx));\n static rtx expand_builtin_ffs\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_frame_address\tPARAMS ((tree));\n-static int is_valid_printf_arglist\tPARAMS ((tree));\n-static rtx expand_builtin_printf\tPARAMS ((tree, int));\n static rtx expand_builtin_fputs\t\tPARAMS ((tree, int));\n static tree stabilize_va_list\t\tPARAMS ((tree, int));\n static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n@@ -2398,120 +2396,6 @@ expand_builtin_fputs (arglist, ignore)\n \t\t      VOIDmode, EXPAND_NORMAL);\n }\n \n-/* Check an arglist to *printf for problems.  The arglist should start\n-   at the format specifier, with the remaining arguments immediately\n-   following it. */\n-static int\n-is_valid_printf_arglist (arglist)\n-  tree arglist;\n-{\n-  /* Save this value so we can restore it later. */\n-  const int SAVE_pedantic = pedantic;\n-  int diagnostic_occurred = 0;\n-\n-  /* If we can't check the format, be safe and return false. */\n-  if (!check_function_format_ptr)\n-    return 0;\n-  \n-  /* Set this to a known value so the user setting won't affect code\n-     generation.  */\n-  pedantic = 1;\n-  /* Check to make sure there are no format specifier errors. */\n-  check_function_format_ptr (&diagnostic_occurred,\n-\t\t\t     maybe_get_identifier(\"printf\"),\n-\t\t\t     NULL_TREE, arglist);\n-\n-  /* Restore the value of `pedantic'. */\n-  pedantic = SAVE_pedantic;\n-\n-  /* If calling `check_function_format_ptr' produces a warning, we\n-     return false, otherwise we return true. */\n-  return ! diagnostic_occurred;\n-}\n-\n-/* If the arguments passed to printf are suitable for optimizations,\n-   we attempt to transform the call. */\n-static rtx\n-expand_builtin_printf (arglist, ignore)\n-     tree arglist;\n-     int ignore;\n-{\n-  tree fn_putchar = built_in_decls[BUILT_IN_PUTCHAR],\n-    fn_puts = built_in_decls[BUILT_IN_PUTS];\n-  tree call_expr, fn;\n-  tree format_arg, stripped_string;\n-\n-  /* If the return value is used, or the replacement _DECL isn't\n-     initialized, don't do the transformation. */\n-  if (!ignore || !fn_putchar || !fn_puts)\n-    return 0;\n-\n-  /* Verify the required arguments in the original call. */\n-  if (arglist == 0\n-      || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE))\n-    return 0;\n-  \n-  /* Check the specifier vs. the parameters. */\n-  if (!is_valid_printf_arglist (arglist))\n-    return 0;\n-  \n-  format_arg = TREE_VALUE (arglist);\n-  stripped_string = format_arg;\n-  STRIP_NOPS (stripped_string);\n-  if (stripped_string && TREE_CODE (stripped_string) == ADDR_EXPR)\n-    stripped_string = TREE_OPERAND (stripped_string, 0);\n-\n-  /* If the format specifier isn't a STRING_CST, punt.  */\n-  if (TREE_CODE (stripped_string) != STRING_CST)\n-    return 0;\n-  \n-  /* OK!  We can attempt optimization.  */\n-\n-  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2). */\n-  if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\\n\") == 0)\n-    {\n-      arglist = TREE_CHAIN (arglist);\n-      fn = fn_puts;\n-    }\n-  /* If the format specifier was \"%c\", call __builtin_putchar (arg2). */\n-  else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n-    {\n-      arglist = TREE_CHAIN (arglist);\n-      fn = fn_putchar;\n-    }\n-  else\n-    {\n-     /* We can't handle anything else with % args or %% ... yet. */\n-      if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n-\treturn 0;\n-      \n-      /* If the resulting constant string has a length of 1, call\n-         putchar.  Note, TREE_STRING_LENGTH includes the terminating\n-         NULL in its count.  */\n-      if (TREE_STRING_LENGTH (stripped_string) == 2)\n-        {\n-\t  /* Given printf(\"c\"), (where c is any one character,)\n-             convert \"c\"[0] to an int and pass that to the replacement\n-             function. */\n-\t  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);\n-\t  arglist = build_tree_list (NULL_TREE, arglist);\n-\t  \n-\t  fn = fn_putchar;\n-        }\n-      else\n-\t/* We'd like to arrange to call fputs(string) here, but we\n-           need stdout and don't have a way to get it ... yet.  */\n-\treturn 0;\n-    }\n-  \n-  call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     call_expr, arglist, NULL_TREE);\n-  TREE_SIDE_EFFECTS (call_expr) = 1;\n-  return expand_expr (call_expr, (ignore ? const0_rtx : NULL_RTX),\n-\t\t      VOIDmode, EXPAND_NORMAL);\n-}\n-\n /* Expand a call to __builtin_expect.  We return our argument and\n    emit a NOTE_INSN_EXPECTED_VALUE note.  */\n \n@@ -2814,12 +2698,6 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n       \n-    case BUILT_IN_PRINTF:\n-      target = expand_builtin_printf (arglist, ignore);\n-      if (target)\n-\treturn target;\n-      break;\n-      \n       /* Various hooks for the DWARF 2 __throw routine.  */\n     case BUILT_IN_UNWIND_INIT:\n       expand_builtin_unwind_init ();"}, {"sha": "2d2ab4718cb140f2e75585a55faa701ff6298d66", "filename": "gcc/c-common.c", "status": "modified", "additions": 193, "deletions": 4, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -1550,6 +1550,10 @@ static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n static void finish_dollar_format_checking\tPARAMS ((int *));\n \n static void check_format_types\tPARAMS ((int *, format_wanted_type *));\n+static int is_valid_printf_arglist PARAMS ((tree));\n+static rtx c_expand_builtin (tree, rtx, enum machine_mode, enum expand_modifier);\n+static rtx c_expand_builtin_printf PARAMS ((tree, rtx, enum machine_mode,\n+\t\t\t\t\t    enum expand_modifier, int));\n \n /* Initialize the table of functions to perform format checking on.\n    The ISO C functions are always checked (whether <stdio.h> is\n@@ -1615,8 +1619,6 @@ init_function_format_info ()\n       record_international_format (get_identifier (\"dgettext\"), NULL_TREE, 2);\n       record_international_format (get_identifier (\"dcgettext\"), NULL_TREE, 2);\n     }\n-\n-  check_function_format_ptr = check_function_format;\n }\n \n /* Record information for argument format checking.  FUNCTION_IDENT is\n@@ -4388,7 +4390,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n     builtin_function (\"__builtin_puts\", puts_ftype,\n \t\t      BUILT_IN_PUTS, BUILT_IN_NORMAL, \"puts\");\n   builtin_function (\"__builtin_printf\", printf_ftype,\n-\t\t    BUILT_IN_PRINTF, BUILT_IN_NORMAL, \"printf\");\n+\t\t    BUILT_IN_PRINTF, BUILT_IN_FRONTEND, \"printf\");\n   /* We declare these without argument so that the initial declaration\n      for these identifiers is a builtin.  That allows us to redeclare\n      them later with argument without worrying about the explicit\n@@ -4450,7 +4452,7 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n       builtin_function (\"cosl\", ldouble_ftype_ldouble, BUILT_IN_COS,\n \t\t\tBUILT_IN_NORMAL, NULL_PTR);\n       builtin_function (\"printf\", printf_ftype, BUILT_IN_PRINTF,\n-\t\t\tBUILT_IN_NORMAL, NULL_PTR);\n+\t\t\tBUILT_IN_FRONTEND, NULL_PTR);\n       /* We declare these without argument so that the initial\n          declaration for these identifiers is a builtin.  That allows\n          us to redeclare them later with argument without worrying\n@@ -5028,6 +5030,20 @@ c_expand_expr (exp, target, tmode, modifier)\n       }\n       break;\n       \n+    case CALL_EXPR:\n+      {\n+\tif (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t    && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t\t== FUNCTION_DECL)\n+\t    && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t    && (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t\t== BUILT_IN_FRONTEND))\n+\t  return c_expand_builtin (exp, target, tmode, modifier);\n+\telse\n+\t  abort();\n+      }\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -5112,3 +5128,176 @@ add_c_tree_codes ()\n \t  c_tree_code_name,\n \t  (LAST_C_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n }\n+\n+#define CALLED_AS_BUILT_IN(NODE) \\\n+   (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n+\n+static rtx\n+c_expand_builtin (exp, target, tmode, modifier)\n+     tree exp;\n+     rtx target;\n+     enum machine_mode tmode;\n+     enum expand_modifier modifier;\n+{\n+  tree type = TREE_TYPE (exp);\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  enum tree_code code = TREE_CODE (exp);\n+  const int ignore = (target == const0_rtx\n+\t\t      || ((code == NON_LVALUE_EXPR || code == NOP_EXPR\n+\t\t\t   || code == CONVERT_EXPR || code == REFERENCE_EXPR\n+\t\t\t   || code == COND_EXPR)\n+\t\t\t  && TREE_CODE (type) == VOID_TYPE));\n+\n+  if (! optimize && ! CALLED_AS_BUILT_IN (fndecl))\n+    return expand_call (exp, target, ignore);\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_PRINTF:\n+      target = c_expand_builtin_printf (arglist, target, tmode,\n+\t\t\t\t\tmodifier, ignore);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    default:\t\t\t/* just do library call, if unknown builtin */\n+      error (\"built-in function `%s' not currently supported\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+    }\n+\n+  /* The switch statement above can drop through to cause the function\n+     to be called normally.  */\n+  return expand_call (exp, target, ignore);\n+}\n+\n+/* Check an arglist to *printf for problems.  The arglist should start\n+   at the format specifier, with the remaining arguments immediately\n+   following it. */\n+static int\n+is_valid_printf_arglist (arglist)\n+  tree arglist;\n+{\n+  /* Save this value so we can restore it later. */\n+  const int SAVE_pedantic = pedantic;\n+  int diagnostic_occurred = 0;\n+\n+  /* Set this to a known value so the user setting won't affect code\n+     generation.  */\n+  pedantic = 1;\n+  /* Check to make sure there are no format specifier errors. */\n+  check_function_format (&diagnostic_occurred,\n+\t\t\t maybe_get_identifier(\"printf\"),\n+\t\t\t NULL_TREE, arglist);\n+\n+  /* Restore the value of `pedantic'. */\n+  pedantic = SAVE_pedantic;\n+\n+  /* If calling `check_function_format_ptr' produces a warning, we\n+     return false, otherwise we return true. */\n+  return ! diagnostic_occurred;\n+}\n+\n+/* If the arguments passed to printf are suitable for optimizations,\n+   we attempt to transform the call. */\n+static rtx\n+c_expand_builtin_printf (arglist, target, tmode, modifier, ignore)\n+     tree arglist;\n+     rtx target;\n+     enum machine_mode tmode;\n+     enum expand_modifier modifier;\n+     int ignore;\n+{\n+  tree fn_putchar = built_in_decls[BUILT_IN_PUTCHAR],\n+    fn_puts = built_in_decls[BUILT_IN_PUTS];\n+  tree fn, format_arg, stripped_string;\n+\n+  /* If the return value is used, or the replacement _DECL isn't\n+     initialized, don't do the transformation. */\n+  if (!ignore || !fn_putchar || !fn_puts)\n+    return 0;\n+\n+  /* Verify the required arguments in the original call. */\n+  if (arglist == 0\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE))\n+    return 0;\n+  \n+  /* Check the specifier vs. the parameters. */\n+  if (!is_valid_printf_arglist (arglist))\n+    return 0;\n+  \n+  format_arg = TREE_VALUE (arglist);\n+  stripped_string = format_arg;\n+  STRIP_NOPS (stripped_string);\n+  if (stripped_string && TREE_CODE (stripped_string) == ADDR_EXPR)\n+    stripped_string = TREE_OPERAND (stripped_string, 0);\n+\n+  /* If the format specifier isn't a STRING_CST, punt.  */\n+  if (TREE_CODE (stripped_string) != STRING_CST)\n+    return 0;\n+  \n+  /* OK!  We can attempt optimization.  */\n+\n+  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg2). */\n+  if (strcmp (TREE_STRING_POINTER (stripped_string), \"%s\\n\") == 0)\n+    {\n+      arglist = TREE_CHAIN (arglist);\n+      fn = fn_puts;\n+    }\n+  /* If the format specifier was \"%c\", call __builtin_putchar (arg2). */\n+  else if (strcmp (TREE_STRING_POINTER (stripped_string), \"%c\") == 0)\n+    {\n+      arglist = TREE_CHAIN (arglist);\n+      fn = fn_putchar;\n+    }\n+  else\n+    {\n+     /* We can't handle anything else with % args or %% ... yet. */\n+      if (strchr (TREE_STRING_POINTER (stripped_string), '%'))\n+\treturn 0;\n+      \n+      /* If the resulting constant string has a length of 1, call\n+         putchar.  Note, TREE_STRING_LENGTH includes the terminating\n+         NULL in its count.  */\n+      if (TREE_STRING_LENGTH (stripped_string) == 2)\n+        {\n+\t  /* Given printf(\"c\"), (where c is any one character,)\n+             convert \"c\"[0] to an int and pass that to the replacement\n+             function. */\n+\t  arglist = build_int_2 (TREE_STRING_POINTER (stripped_string)[0], 0);\n+\t  arglist = build_tree_list (NULL_TREE, arglist);\n+\t  \n+\t  fn = fn_putchar;\n+        }\n+      /* If the resulting constant was \"string\\n\", call\n+         __builtin_puts(\"string\").  Ensure \"string\" has at least one\n+         character besides the trailing \\n.  Note, TREE_STRING_LENGTH\n+         includes the terminating NULL in its count.  */\n+      else if (TREE_STRING_LENGTH (stripped_string) > 2\n+\t       && TREE_STRING_POINTER (stripped_string)\n+\t       [TREE_STRING_LENGTH (stripped_string) - 2] == '\\n')\n+        {\n+\t  /* Create a NULL-terminated string that's one char shorter\n+\t     than the original, stripping off the trailing '\\n'.  */\n+\t  const int newlen = TREE_STRING_LENGTH (stripped_string) - 1;\n+\t  char *newstr = (char *) alloca (newlen);\n+\t  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);\n+\t  newstr[newlen - 1] = 0;\n+\t  \n+\t  arglist = build_string (newlen, newstr);\n+\t  TREE_TYPE (arglist) = \n+\t    build_type_variant (char_array_type_node, 1, 0);\n+\t  arglist = build_tree_list (NULL_TREE, arglist);\n+\t  fn = fn_puts;\n+\t}\n+      else\n+\t/* We'd like to arrange to call fputs(string) here, but we\n+           need stdout and don't have a way to get it ... yet.  */\n+\treturn 0;\n+    }\n+  \n+  return expand_expr (build_function_call (fn, arglist),\n+\t\t      (ignore ? const0_rtx : target),\n+\t\t      tmode, modifier);\n+}"}, {"sha": "24db762fc6544d529259ce33c7280456de3b5bf7", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -683,6 +683,8 @@ extern tree c_add_case_label                    PARAMS ((splay_tree,\n \t\t\t\t\t\t\t tree, tree,\n \t\t\t\t\t\t\t tree));\n \n+extern tree build_function_call\t\t\tPARAMS ((tree, tree));\n+\n #ifdef RTX_CODE\n \n extern struct rtx_def *c_expand_expr            PARAMS ((tree, rtx,"}, {"sha": "c36d61fcb9646cb6775a94aa747cfd7ffc206cc2", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -7163,7 +7163,13 @@ expand_expr (exp, target, tmode, modifier)\n \t  && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n \t      == FUNCTION_DECL)\n \t  && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n-\treturn expand_builtin (exp, target, subtarget, tmode, ignore);\n+        {\n+\t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t      == BUILT_IN_FRONTEND)\n+\t    return (*lang_expand_expr) (exp, original_target, tmode, modifier);\n+\t  else\n+\t    return expand_builtin (exp, target, subtarget, tmode, ignore);\n+\t}\n \n       /* If this call was expanded already by preexpand_calls,\n \t just return the result we got.  */"}, {"sha": "6eafd910edf0836e43dbb3e9d427aa16b42d3515", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -246,10 +246,6 @@ static int next_decl_uid;\n /* Unique id for next type created.  */\n static int next_type_uid = 1;\n \n-/* Pointer to function to check the format of printf, etc.  This is\n-   used by the backend, e.g. builtins.c.  */\n-void (*check_function_format_ptr) PARAMS ((int *, tree, tree, tree)) = 0;\n-\n /* Here is how primitive or already-canonicalized types' hash\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)"}, {"sha": "c00fafd840fefcdf22236cda400e0915b7012ab2", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70eaeafa005e95e565806c8c9b30e54c8e8642f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c70eaeafa005e95e565806c8c9b30e54c8e8642f", "patch": "@@ -2446,9 +2446,6 @@ extern const char * const language_string;\n extern tree builtin_function\t\t\tPARAMS ((const char *, tree, int,\n \t\t\t\t\t\t       enum built_in_class,\n \t\t\t\t\t\t       const char *));\n-/* Pointer to function to check the format of printf, etc.  This is\n-   used by the backend, e.g. builtins.c.  */\n-extern void (*check_function_format_ptr) PARAMS ((int *, tree, tree, tree));\n \f\n /* In tree.c */\n extern char *perm_calloc\t\t\tPARAMS ((int, long));"}]}