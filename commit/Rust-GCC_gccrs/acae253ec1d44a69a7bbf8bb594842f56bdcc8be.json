{"sha": "acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhZTI1M2VjMWQ0NGE2OWE3YmJmOGJiNTk0ODQyZjU2YmRjYzhiZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-24T01:31:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-24T01:31:13Z"}, "message": "re PR libstdc++/5198 (3.0.3 linux x m68k build fail: invalid opcodes in c++locale.cc)\n\n        PR libstdc++/5198\n        * config/cpu/m68k/bits/atomicity.h (__exchange_and_add): Only use\n        CAS on the cpu variants that support it.  Add versions that use\n        TAS and that disable interrupts.\n        (__atomic_add): Use __exchange_and_add to guarantee atomicity.\n\nFrom-SVN: r49160", "tree": {"sha": "43bb31632eb3cbbf75f7047242a100be3fab4a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43bb31632eb3cbbf75f7047242a100be3fab4a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acae253ec1d44a69a7bbf8bb594842f56bdcc8be/comments", "author": null, "committer": null, "parents": [{"sha": "88a446c0368eebe2b230ee2ade33a2fcdf3bd479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a446c0368eebe2b230ee2ade33a2fcdf3bd479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a446c0368eebe2b230ee2ade33a2fcdf3bd479"}], "stats": {"total": 103, "additions": 93, "deletions": 10}, "files": [{"sha": "bf0a1fd9cc478a6538ef61ef4dbc8f5b0d9912ac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae253ec1d44a69a7bbf8bb594842f56bdcc8be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae253ec1d44a69a7bbf8bb594842f56bdcc8be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "patch": "@@ -1,3 +1,11 @@\n+2002-01-23  Richard Henderson  <rth@redhat.com>\n+\n+\tPR libstdc++/5198\n+\t* config/cpu/m68k/bits/atomicity.h (__exchange_and_add): Only use\n+\tCAS on the cpu variants that support it.  Add versions that use\n+\tTAS and that disable interrupts.\n+\t(__atomic_add): Use __exchange_and_add to guarantee atomicity.\n+\n 2002-01-23  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* include/bits/locale_facets.tcc: Remove old comments."}, {"sha": "0b8f4e84d5a4993bbb27499f8edc8abd7514b8c8", "filename": "libstdc++-v3/config/cpu/m68k/bits/atomicity.h", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae253ec1d44a69a7bbf8bb594842f56bdcc8be/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fbits%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae253ec1d44a69a7bbf8bb594842f56bdcc8be/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fbits%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fbits%2Fatomicity.h?ref=acae253ec1d44a69a7bbf8bb594842f56bdcc8be", "patch": "@@ -1,6 +1,6 @@\n-// Low-level functions for atomic operations: m680x0, x >= 2 version -*- C++ -*-\n+// Low-level functions for atomic operations: m68k version -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,30 +32,105 @@\n \n typedef int _Atomic_word;\n \n+#if defined(__mc68020__) || defined(__mc68030__) \\\n+    || defined(__mc68040__) || defined(__mc68060__)\n+// These variants support compare-and-swap.\n+\n static inline _Atomic_word \n __attribute__ ((__unused__))\n __exchange_and_add (volatile _Atomic_word *__mem, int __val)\n {\n   register _Atomic_word __result = *__mem;\n   register _Atomic_word __temp;\n-  __asm__ __volatile__ (\"1: move%.l %0,%1;\"\n-\t\t\t\"   add%.l %2,%1;\"\n-\t\t\t\"   cas%.l %0,%1,%3;\"\n-\t\t\t\"   jbne 1b\"\n+  __asm__ __volatile__ (\"1: move%.l %0,%1\\n\\t\"\n+\t\t\t\"add%.l %2,%1\\n\\t\"\n+\t\t\t\"cas%.l %0,%1,%3\\n\\t\"\n+\t\t\t\"jbne 1b\"\n \t\t\t: \"=d\" (__result), \"=&d\" (__temp)\n \t\t\t: \"d\" (__val), \"m\" (*__mem), \"0\" (__result)\n \t\t\t: \"memory\");\n   return __result;\n }\n \n+#elif !defined(__mcf5200__) && !defined(__mcf5300__)\n+// 68000, 68010, cpu32 and 5400 support test-and-set.\n+\n+template <int __inst>\n+struct __Atomicity_lock\n+{\n+  static volatile unsigned char _S_atomicity_lock;\n+};\n+\n+template <int __inst>\n+volatile unsigned char __Atomicity_lock<__inst>::_S_atomicity_lock = 0;\n+\n+template volatile unsigned char __Atomicity_lock<0>::_S_atomicity_lock;\n+\n+static inline _Atomic_word \n+__attribute__ ((__unused__))\n+__exchange_and_add (volatile _Atomic_word *__mem, int __val)\n+{\n+  _Atomic_word __result;\n+\n+  __asm__ __volatile__(\"1: tas %0\\n\\tjbne 1b\"\n+\t\t       : \"=m\"(__Atomicity_lock<0>::_S_atomicity_lock)\n+\t\t       : \"m\"(__Atomicity_lock<0>::_S_atomicity_lock));\n+\n+  __result = *__mem;\n+  *__mem = __result + __val;\n+\n+  __Atomicity_lock<0>::_S_atomicity_lock = 0;\n+\n+  return __result;\n+}\n+\n+#else\n+// These variants do not support any atomic operations at all.\n+// The best we can hope for is to disable interrupts, which we\n+// can only do from supervisor mode.\n+\n+#if defined(__rtems__) || defined(__vxWorks__) || defined(__embedded__)\n+static inline _Atomic_word \n+__attribute__ ((__unused__))\n+__exchange_and_add (volatile _Atomic_word *__mem, int __val)\n+{\n+  _Atomic_word __result;\n+  short __level, __tmpsr;\n+  __asm__ __volatile__ (\"move%.w %%sr,%0\\n\\tor%.l %0,%1\\n\\tmove%.w %1,%%sr\"\n+\t\t  \t: \"=d\"(__level), \"=d\"(__tmpsr) : \"1\"(0x700));\n+\n+  __result = *__mem;\n+  *__mem = __result + __val;\n+\n+  __asm__ __volatile__ (\"move%.w %0,%%sr\" : : \"d\"(__level));\n+\n+  return __result;\n+}\n+#else\n+#warning \"__exchange_and_add is not atomic for this target\"\n+\n+static inline _Atomic_word\n+__attribute__ ((__unused__))\n+__exchange_and_add (volatile _Atomic_word *__mem, int __val)\n+{\n+  _Atomic_word __result;\n+\n+  __result = *__mem;\n+  *__mem = __result + __val;\n+\n+  return __result;\n+}\n+\n+#endif /* embedded */\n+#endif /* CAS / TAS / IRQ */\n+\n static inline void\n __attribute__ ((__unused__))\n __atomic_add (volatile _Atomic_word* __mem, int __val)\n {\n-  __asm__ __volatile__ (\"add%.l %0,%1\"\n-\t\t\t: : \"id\" (__val), \"m\" (*__mem) : \"memory\");\n+  // Careful: using add.l with a memory destination is not\n+  // architecturally guaranteed to be atomic.\n+  (void) __exchange_and_add (__mem, __val);\n }\n \n #endif /* atomicity.h */\n-\n-"}]}