{"sha": "97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdiMGFkZTMwM2JiZmUwN2VmOGIwYTkwNzFmNzE4ZjRkOGNkMDAyZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-07-08T07:42:02Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-08T07:42:02Z"}, "message": "explow.c (optimize_save_area_alloca): Do not accept parameters.\n\n2004-07-08  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* explow.c (optimize_save_area_alloca): Do not accept parameters.\n\t* passes.c (rest_of_handle_final): Handle symout.\n\t(rest_of_handle_new_regalloc, rest_of_handle_old_regalloc):\n\tPush timevar here.\n\t(rest_of_handle_sched): Break out SMS.  Remove ifs for\n\tflag_schedule_insns and flag_modulo_sched.\n\t(rest_of_handle_addressof, rest_of_handle_cse2): Garbage\n\tcollect at the end.\n\t(rest_of_handle_gcse2): Put under timevar TV_RELOAD_CSE_REGS.\n\t(rest_of_handle_partition_blocks, rest_of_handle_sms,\n\trest_of_handle_if_after_reload, rest_of_handle_peephole2,\n\trest_of_handle_mode_switching, rest_of_handle_jump,\n\trest_of_handle_guess_branch_prob, rest_of_handle_eh,\n\trest_of_handle_jump2, rest_of_handle_postreload,\n\trest_of_handle_flow2, rest_of_clean_state,\n\trest_of_handle_shorten_branches,\n\trest_of_handle_prologue_epilogue,\n\trest_of_handle_branch_target_load_optimize): New.\n\t(rest_of_compilation): Call the above.  Remove ggc_collect\n\tcalls moved to rest_of_handle_*.\n\t* rtl.h (optimize_save_area_alloca): Do not accept parameters.\n\n\t* dwarf2out.c (dwarf2out_begin_prologue): Use TREE_NOTHROW.\n\t* except.c (set_nothrow_function_flags): Set TREE_NOTHROW.\n\t* except.h (set_nothrow_function_flags): Update comment.\n\t* function.c (current_function_nothrow): Remove.\n\t* output.h (current_function_nothrow): Remove.\n\t* passes.c (rest_of_compilation): Do not set TREE_NOTHROW.\n\t* config/arm/arm.c (arm_compute_func_type): Use TREE_NOTHROW.\n\nFrom-SVN: r84274", "tree": {"sha": "c82976caa4298918349d2f84c423cf32b921aa31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c82976caa4298918349d2f84c423cf32b921aa31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9185691da58b8ee0e714e46f5f15bdc12c6b00d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9185691da58b8ee0e714e46f5f15bdc12c6b00d"}], "stats": {"total": 944, "additions": 525, "deletions": 419}, "files": [{"sha": "7ea2a223756b903295a78e5341a0d4f2c0e1e57e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -1,3 +1,35 @@\n+2004-07-08  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* explow.c (optimize_save_area_alloca): Do not accept parameters.\n+\t* passes.c (rest_of_handle_final): Handle symout.\n+\t(rest_of_handle_new_regalloc, rest_of_handle_old_regalloc):\n+\tPush timevar here.\n+\t(rest_of_handle_sched): Break out SMS.  Remove ifs for\n+\tflag_schedule_insns and flag_modulo_sched.\n+\t(rest_of_handle_addressof, rest_of_handle_cse2): Garbage\n+\tcollect at the end.\n+\t(rest_of_handle_gcse2): Put under timevar TV_RELOAD_CSE_REGS.\n+\t(rest_of_handle_partition_blocks, rest_of_handle_sms,\n+\trest_of_handle_if_after_reload, rest_of_handle_peephole2,\n+\trest_of_handle_mode_switching, rest_of_handle_jump,\n+\trest_of_handle_guess_branch_prob, rest_of_handle_eh,\n+\trest_of_handle_jump2, rest_of_handle_postreload,\n+\trest_of_handle_flow2, rest_of_clean_state,\n+\trest_of_handle_shorten_branches,\n+\trest_of_handle_prologue_epilogue,\n+\trest_of_handle_branch_target_load_optimize): New.\n+\t(rest_of_compilation): Call the above.  Remove ggc_collect\n+\tcalls moved to rest_of_handle_*.\n+\t* rtl.h (optimize_save_area_alloca): Do not accept parameters.\n+\n+\t* dwarf2out.c (dwarf2out_begin_prologue): Use TREE_NOTHROW.\n+\t* except.c (set_nothrow_function_flags): Set TREE_NOTHROW.\n+\t* except.h (set_nothrow_function_flags): Update comment.\n+\t* function.c (current_function_nothrow): Remove.\n+\t* output.h (current_function_nothrow): Remove.\n+\t* passes.c (rest_of_compilation): Do not set TREE_NOTHROW.\n+\t* config/arm/arm.c (arm_compute_func_type): Use TREE_NOTHROW.\n+\n 2004-07-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR bootstrap/16326"}, {"sha": "a6826cd4237f2e284da4cf57ffa1b088b04d5a1b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -1110,7 +1110,7 @@ arm_compute_func_type (void)\n      register values that will never be needed again.  This optimization\n      was added to speed up context switching in a kernel application.  */\n   if (optimize > 0\n-      && current_function_nothrow\n+      && TREE_NOTHROW (current_function_decl)\n       && TREE_THIS_VOLATILE (current_function_decl))\n     type |= ARM_FT_VOLATILE;\n   "}, {"sha": "549773dddce2250e4664d3e93860e3d123af33fa", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -2406,7 +2406,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n   fde->funcdef_number = current_function_funcdef_no;\n-  fde->nothrow = current_function_nothrow;\n+  fde->nothrow = TREE_NOTHROW (current_function_decl);\n   fde->uses_eh_lsda = cfun->uses_eh_lsda;\n   fde->all_throwers_are_sibcalls = cfun->all_throwers_are_sibcalls;\n "}, {"sha": "5a2fe121336ab2927f3d1e33e13cff0242727ccc", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -3188,14 +3188,14 @@ can_throw_external (rtx insn)\n   return can_throw_external_1 (INTVAL (XEXP (note, 0)));\n }\n \n-/* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */\n+/* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n \n void\n set_nothrow_function_flags (void)\n {\n   rtx insn;\n \n-  current_function_nothrow = 1;\n+  TREE_NOTHROW (current_function_decl) = 1;\n \n   /* Assume cfun->all_throwers_are_sibcalls until we encounter\n      something that can throw an exception.  We specifically exempt\n@@ -3211,7 +3211,7 @@ set_nothrow_function_flags (void)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (can_throw_external (insn))\n       {\n-\tcurrent_function_nothrow = 0;\n+        TREE_NOTHROW (current_function_decl) = 0;\n \n \tif (GET_CODE (insn) != CALL_INSN || !SIBLING_CALL_P (insn))\n \t  {\n@@ -3224,7 +3224,7 @@ set_nothrow_function_flags (void)\n        insn = XEXP (insn, 1))\n     if (can_throw_external (insn))\n       {\n-\tcurrent_function_nothrow = 0;\n+        TREE_NOTHROW (current_function_decl) = 0;\n \n \tif (GET_CODE (insn) != CALL_INSN || !SIBLING_CALL_P (insn))\n \t  {"}, {"sha": "6f6a6813043aa493b4e7a671935660ef98464877", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -99,7 +99,7 @@ extern bool can_throw_internal (rtx);\n extern bool can_throw_external_1 (int);\n extern bool can_throw_external (rtx);\n \n-/* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */\n+/* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n extern void set_nothrow_function_flags (void);\n \n /* After initial rtl generation, call back to finish generating"}, {"sha": "1d137a17e635acbde49585dea2634fd205bf1796", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -1110,11 +1110,11 @@ update_nonlocal_goto_save_area (void)\n    frame, thus causing a crash if a longjmp unwinds to it.  */\n \n void\n-optimize_save_area_alloca (rtx insns)\n+optimize_save_area_alloca (void)\n {\n   rtx insn;\n \n-  for (insn = insns; insn; insn = NEXT_INSN(insn))\n+  for (insn = get_insns (); insn; insn = NEXT_INSN(insn))\n     {\n       rtx note;\n "}, {"sha": "d2d1dba69e682db114d8eaaaaed0c9823b600ee6", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -103,11 +103,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    compiler passes.  */\n int current_function_is_leaf;\n \n-/* Nonzero if function being compiled doesn't contain any instructions\n-   that can throw an exception.  This is set prior to final.  */\n-\n-int current_function_nothrow;\n-\n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n    life_analysis has run.  */"}, {"sha": "25d16bfd2df06109e54bb87761df17c002586d40", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -399,11 +399,6 @@ extern const char *weak_global_object_name;\n \n extern int current_function_is_leaf;\n \n-/* Nonzero if function being compiled doesn't contain any instructions\n-   that can throw an exception.  This is set prior to final.  */\n-\n-extern int current_function_nothrow;\n-\n /* Nonzero if function being compiled doesn't modify the stack pointer\n    (ignoring the prologue and epilogue).  This is only valid after\n    life_analysis has run.  */"}, {"sha": "0e85c1c57bc5ea603805047e0e0ae3c852fced42", "filename": "gcc/passes.c", "status": "modified", "additions": 483, "deletions": 399, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -86,7 +86,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"dwarf2out.h\"\n #endif\n \n-#if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n+#if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n #include \"dbxout.h\"\n #endif\n \n@@ -472,9 +472,24 @@ rest_of_handle_final (void)\n     /* Release all memory held by regsets now.  */\n     regset_release_memory ();\n   }\n-  timevar_pop (TV_FINAL);\n+\n+  /* Write DBX symbols if requested.  */\n+\n+  /* Note that for those inline functions where we don't initially\n+     know for certain that we will be generating an out-of-line copy,\n+     the first invocation of this routine (rest_of_compilation) will\n+     skip over this code by doing a `goto exit_rest_of_compilation;'.\n+     Later on, wrapup_global_declarations will (indirectly) call\n+     rest_of_compilation again for those inline functions that need\n+     to have out-of-line copies generated.  During that call, we\n+     *will* be routed past here.  */\n+\n+  timevar_push (TV_SYMOUT);\n+  (*debug_hooks->function_decl) (current_function_decl);\n+  timevar_pop (TV_SYMOUT);\n \n   ggc_collect ();\n+  timevar_pop (TV_FINAL);\n }\n \n #ifdef DELAY_SLOTS\n@@ -488,9 +503,10 @@ rest_of_handle_delay_slots (void)\n   dbr_schedule (get_insns (), dump_file);\n \n   close_dump_file (DFI_dbr, print_rtl, get_insns ());\n-  timevar_pop (TV_DBR_SCHED);\n \n   ggc_collect ();\n+\n+  timevar_pop (TV_DBR_SCHED);\n }\n #endif\n \n@@ -532,9 +548,9 @@ rest_of_handle_stack_regs (void)\n     }\n \n   close_dump_file (DFI_stack, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_REG_STACK);\n \n   ggc_collect ();\n+  timevar_pop (TV_REG_STACK);\n }\n #endif\n \n@@ -551,7 +567,7 @@ rest_of_handle_variable_tracking (void)\n   timevar_pop (TV_VAR_TRACKING);\n }\n \n-/* Machine independent reorg pass.  */\n+/* Machine dependent reorg pass.  */\n static void\n rest_of_handle_machine_reorg (void)\n {\n@@ -561,9 +577,9 @@ rest_of_handle_machine_reorg (void)\n   targetm.machine_dependent_reorg ();\n \n   close_dump_file (DFI_mach, print_rtl, get_insns ());\n-  timevar_pop (TV_MACH_DEP);\n \n   ggc_collect ();\n+  timevar_pop (TV_MACH_DEP);\n }\n \n \n@@ -574,17 +590,14 @@ rest_of_handle_new_regalloc (void)\n {\n   int failure;\n \n+  timevar_push (TV_LOCAL_ALLOC);\n+  open_dump_file (DFI_lreg, current_function_decl);\n+\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   reg_alloc ();\n \n   timevar_pop (TV_LOCAL_ALLOC);\n-  if (dump_file_tbl[DFI_lreg].enabled)\n-    {\n-      timevar_push (TV_DUMP);\n-\n-      close_dump_file (DFI_lreg, NULL, NULL);\n-      timevar_pop (TV_DUMP);\n-    }\n+  close_dump_file (DFI_lreg, NULL, NULL);\n \n   /* XXX clean up the whole mess to bring live info in shape again.  */\n   timevar_push (TV_GLOBAL_ALLOC);\n@@ -595,14 +608,14 @@ rest_of_handle_new_regalloc (void)\n \n   timevar_pop (TV_GLOBAL_ALLOC);\n \n+  ggc_collect ();\n+\n   if (dump_file_tbl[DFI_greg].enabled)\n     {\n       timevar_push (TV_DUMP);\n-\n       dump_global_regs (dump_file);\n-\n-      close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_DUMP);\n+      close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n     }\n \n   if (failure)\n@@ -621,6 +634,9 @@ rest_of_handle_old_regalloc (void)\n   int failure;\n   int rebuild_notes;\n \n+  timevar_push (TV_LOCAL_ALLOC);\n+  open_dump_file (DFI_lreg, current_function_decl);\n+\n   /* Allocate the reg_renumber array.  */\n   allocate_reg_info (max_regno, FALSE, TRUE);\n \n@@ -651,14 +667,13 @@ rest_of_handle_old_regalloc (void)\n   if (dump_file_tbl[DFI_lreg].enabled)\n     {\n       timevar_push (TV_DUMP);\n-\n       dump_flow_info (dump_file);\n       dump_local_alloc (dump_file);\n-\n-      close_dump_file (DFI_lreg, print_rtl_with_bb, get_insns ());\n       timevar_pop (TV_DUMP);\n     }\n \n+  close_dump_file (DFI_lreg, print_rtl_with_bb, get_insns ());\n+\n   ggc_collect ();\n \n   timevar_push (TV_GLOBAL_ALLOC);\n@@ -675,18 +690,19 @@ rest_of_handle_old_regalloc (void)\n       failure = reload (get_insns (), 0);\n     }\n \n-  timevar_pop (TV_GLOBAL_ALLOC);\n-\n   if (dump_file_tbl[DFI_greg].enabled)\n     {\n       timevar_push (TV_DUMP);\n-\n       dump_global_regs (dump_file);\n+      timevar_pop (TV_DUMP);\n \n       close_dump_file (DFI_greg, print_rtl_with_bb, get_insns ());\n-      timevar_pop (TV_DUMP);\n     }\n \n+  ggc_collect ();\n+\n+  timevar_pop (TV_GLOBAL_ALLOC);\n+\n   return failure;\n }\n \n@@ -738,52 +754,65 @@ rest_of_handle_reorder_blocks (void)\n   close_dump_file (DFI_bbro, print_rtl_with_bb, get_insns ());\n }\n \n+/* Partition hot and cold basic blocks.  */\n+static void\n+rest_of_handle_partition_blocks (void)\n+{\n+  no_new_pseudos = 0;\n+  partition_hot_cold_basic_blocks ();\n+  allocate_reg_life_data ();\n+  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, \n+\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+  no_new_pseudos = 1;\n+}\n+\n #ifdef INSN_SCHEDULING\n /* Run instruction scheduler.  */\n+/* Perform SMS module scheduling.  */\n static void\n-rest_of_handle_sched (void)\n+rest_of_handle_sms (void)\n {\n   timevar_push (TV_SMS);\n-  if (optimize > 0 && flag_modulo_sched)\n-    {\n+  open_dump_file (DFI_sms, current_function_decl);\n \n-      /* Perform SMS module scheduling.  */\n-      open_dump_file (DFI_sms, current_function_decl);\n+  /* We want to be able to create new pseudos.  */\n+  no_new_pseudos = 0;\n+  sms_schedule (dump_file);\n+  close_dump_file (DFI_sms, print_rtl, get_insns ());\n \n-      /* We want to be able to create new pseudos.  */\n-      no_new_pseudos = 0;\n-      sms_schedule (dump_file);\n-      close_dump_file (DFI_sms, print_rtl, get_insns ());\n \n+  /* Update the life information, because we add pseudos.  */\n+  max_regno = max_reg_num ();\n+  allocate_reg_info (max_regno, FALSE, FALSE);\n+  update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t\t    (PROP_DEATH_NOTES\n+\t\t\t\t     | PROP_KILL_DEAD_CODE\n+\t\t\t\t     | PROP_SCAN_DEAD_CODE));\n+  no_new_pseudos = 1;\n \n-      /* Update the life information, because we add pseudos.  */\n-      max_regno = max_reg_num ();\n-      allocate_reg_info (max_regno, FALSE, FALSE);\n-      update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t\t\t(PROP_DEATH_NOTES\n-\t\t\t\t\t | PROP_KILL_DEAD_CODE\n-\t\t\t\t\t | PROP_SCAN_DEAD_CODE));\n-      no_new_pseudos = 1;\n-    }\n+  ggc_collect ();\n   timevar_pop (TV_SMS);\n+}\n+\n+/* Run instruction scheduler.  */\n+static void\n+rest_of_handle_sched (void)\n+{\n   timevar_push (TV_SCHED);\n \n   /* Print function header into sched dump now\n      because doing the sched analysis makes some of the dump.  */\n-  if (optimize > 0 && flag_schedule_insns)\n-    {\n-      open_dump_file (DFI_sched, current_function_decl);\n+  open_dump_file (DFI_sched, current_function_decl);\n \n-      /* Do control and data sched analysis,\n-\t and write some of the results to dump file.  */\n+  /* Do control and data sched analysis,\n+     and write some of the results to dump file.  */\n \n-      schedule_insns (dump_file);\n+  schedule_insns (dump_file);\n \n-      close_dump_file (DFI_sched, print_rtl_with_bb, get_insns ());\n-    }\n-  timevar_pop (TV_SCHED);\n+  close_dump_file (DFI_sched, print_rtl_with_bb, get_insns ());\n \n   ggc_collect ();\n+  timevar_pop (TV_SCHED);\n }\n \n /* Run second scheduling pass after reload.  */\n@@ -810,15 +839,17 @@ rest_of_handle_sched2 (void)\n     schedule_insns (dump_file);\n \n   close_dump_file (DFI_sched2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_SCHED2);\n \n   ggc_collect ();\n+\n+  timevar_pop (TV_SCHED2);\n }\n #endif\n \n static void\n rest_of_handle_gcse2 (void)\n {\n+  timevar_push (TV_RELOAD_CSE_REGS);\n   open_dump_file (DFI_gcse2, current_function_decl);\n \n   gcse_after_reload_main (get_insns (), dump_file);\n@@ -831,6 +862,8 @@ rest_of_handle_gcse2 (void)\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n+\n+  timevar_pop (TV_RELOAD_CSE_REGS);\n }\n \n /* Register allocation pre-pass, to reduce number of moves necessary\n@@ -845,9 +878,9 @@ rest_of_handle_regmove (void)\n \n   cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n   close_dump_file (DFI_regmove, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_REGMOVE);\n \n   ggc_collect ();\n+  timevar_pop (TV_REGMOVE);\n }\n \n /* Run tracer.  */\n@@ -867,22 +900,25 @@ rest_of_handle_tracer (void)\n static void\n rest_of_handle_if_conversion (void)\n {\n+  timevar_push (TV_IFCVT);\n   open_dump_file (DFI_ce1, current_function_decl);\n+\n   if (flag_if_conversion)\n     {\n-      timevar_push (TV_IFCVT);\n       if (dump_file)\n \tdump_flow_info (dump_file);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n       reg_scan (get_insns (), max_reg_num (), 0);\n       if_convert (0);\n-      timevar_pop (TV_IFCVT);\n     }\n+\n   timevar_push (TV_JUMP);\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   reg_scan (get_insns (), max_reg_num (), 0);\n   timevar_pop (TV_JUMP);\n+\n   close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_IFCVT);\n }\n \n /* Rerun if-conversion, as combine may have simplified things enough\n@@ -901,6 +937,23 @@ rest_of_handle_if_after_combine (void)\n   timevar_pop (TV_IFCVT);\n }\n \n+static void\n+rest_of_handle_if_after_reload (void)\n+{\n+  timevar_push (TV_IFCVT2);\n+  open_dump_file (DFI_ce3, current_function_decl);\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  cleanup_cfg (CLEANUP_EXPENSIVE\n+\t       | CLEANUP_UPDATE_LIFE \n+\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+  if (flag_if_conversion2)\n+    if_convert (1);\n+  close_dump_file (DFI_ce3, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_IFCVT2);\n+}\n+\n static void\n rest_of_handle_web (void)\n {\n@@ -920,6 +973,7 @@ static void\n rest_of_handle_branch_prob (void)\n {\n   struct loops loops;\n+\n   timevar_push (TV_BRANCH_PROB);\n   open_dump_file (DFI_bp, current_function_decl);\n \n@@ -1026,7 +1080,7 @@ rest_of_handle_combine (void)\n   rebuild_jump_labels_after_combine\n     = combine_instructions (get_insns (), max_reg_num ());\n \n-  /* Combining get_insns () may have turned an indirect jump into a\n+  /* Combining insns may have turned an indirect jump into a\n      direct jump.  Rebuild the JUMP_LABEL fields of jumping\n      instructions.  */\n   if (rebuild_jump_labels_after_combine)\n@@ -1059,7 +1113,6 @@ rest_of_handle_life (void)\n     cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n \t\t | CLEANUP_LOG_LINKS\n \t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-  timevar_pop (TV_FLOW);\n \n   if (extra_warnings)\n     {\n@@ -1093,6 +1146,7 @@ static void\n rest_of_handle_cse (void)\n {\n   int tem;\n+\n   open_dump_file (DFI_cse, current_function_decl);\n   if (dump_file)\n     dump_flow_info (dump_file);\n@@ -1117,13 +1171,16 @@ rest_of_handle_cse (void)\n \n   timevar_pop (TV_CSE);\n   close_dump_file (DFI_cse, print_rtl_with_bb, get_insns ());\n+\n+  ggc_collect ();\n }\n \n /* Run second CSE pass after loop optimizations.  */\n static void\n rest_of_handle_cse2 (void)\n {\n   int tem;\n+\n   timevar_push (TV_CSE2);\n   open_dump_file (DFI_cse2, current_function_decl);\n   if (dump_file)\n@@ -1149,8 +1206,9 @@ rest_of_handle_cse2 (void)\n     }\n   reg_scan (get_insns (), max_reg_num (), 0);\n   close_dump_file (DFI_cse2, print_rtl_with_bb, get_insns ());\n-  ggc_collect ();\n   timevar_pop (TV_CSE2);\n+\n+  ggc_collect ();\n }\n \n /* Perform global cse.  */\n@@ -1159,6 +1217,7 @@ rest_of_handle_gcse (void)\n {\n   int save_csb, save_cfj;\n   int tem2 = 0, tem;\n+\n   timevar_push (TV_GCSE);\n   open_dump_file (DFI_gcse, current_function_decl);\n \n@@ -1258,9 +1317,9 @@ rest_of_handle_loop_optimize (void)\n \n   /* Loop can create trivially dead instructions.  */\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n   close_dump_file (DFI_loop, print_rtl, get_insns ());\n   timevar_pop (TV_LOOP);\n-  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n \n   ggc_collect ();\n }\n@@ -1330,91 +1389,63 @@ rest_of_handle_loop2 (void)\n   ggc_collect ();\n }\n \n-/* This is called from finish_function (within langhooks.parse_file)\n-   after each top-level definition is parsed.\n-   It is supposed to compile that function or variable\n-   and output the assembler code for it.\n-   After we return, the tree storage is freed.  */\n-\n-void\n-rest_of_compilation (void)\n+static void\n+rest_of_handle_branch_target_load_optimize (void)\n {\n-  /* There's no need to defer outputting this function any more; we\n-     know we want to output it.  */\n-  DECL_DEFER_OUTPUT (current_function_decl) = 0;\n-\n-  /* There's no need to defer outputting this function any more; we\n-     know we want to output it.  */\n-  DECL_DEFER_OUTPUT (current_function_decl) = 0;\n-\n-  /* Register rtl specific functions for cfg.  */\n-  rtl_register_cfg_hooks ();\n-\n-  /* Now that we're out of the frontend, we shouldn't have any more\n-     CONCATs anywhere.  */\n-  generating_concat_p = 0;\n-\n-  /* When processing delayed functions, prepare_function_start() won't\n-     have been run to re-initialize it.  */\n-  cse_not_expected = ! optimize;\n-\n-  finalize_block_changes ();\n-\n-  /* Dump the rtl code if we are dumping rtl.  */\n-  if (open_dump_file (DFI_rtl, current_function_decl))\n-    close_dump_file (DFI_rtl, print_rtl, get_insns ());\n-\n-  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n-     sorts of eh initialization.  Delay this until after the\n-     initial rtl dump so that we can see the original nesting.  */\n-  convert_from_eh_region_ranges ();\n-\n-  /* If we're emitting a nested function, make sure its parent gets\n-     emitted as well.  Doing otherwise confuses debug info.  */\n-  {\n-    tree parent;\n-    for (parent = DECL_CONTEXT (current_function_decl);\n-\t parent != NULL_TREE;\n-\t parent = get_containing_scope (parent))\n-      if (TREE_CODE (parent) == FUNCTION_DECL)\n-\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n-  }\n-\n-  /* We are now committed to emitting code for this function.  Do any\n-     preparation, such as emitting abstract debug info for the inline\n-     before it gets mangled by optimization.  */\n-  if (cgraph_function_possibly_inlined_p (current_function_decl))\n-    (*debug_hooks->outlining_inline_function) (current_function_decl);\n+  static int warned = 0;\n+\n+  /* Leave this a warning for now so that it is possible to experiment\n+     with running this pass twice.  In 3.6, we should either make this\n+     an error, or use separate dump files.  */\n+  if (flag_branch_target_load_optimize\n+      && flag_branch_target_load_optimize2\n+      && !warned)\n+    {\n+      warning (\"branch target register load optimization is not intended \"\n+\t       \"to be run twice\");\n \n-  /* Remove any notes we don't need.  That will make iterating\n-     over the instruction sequence faster, and allow the garbage\n-     collector to reclaim the memory used by the notes.  */\n-  remove_unnecessary_notes ();\n+      warned = 1;\n+    }\n \n+  open_dump_file (DFI_branch_target_load, current_function_decl);\n+  branch_target_load_optimize (epilogue_completed);\n+  close_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n   ggc_collect ();\n+}\n \n-  /* Initialize some variables used by the optimizers.  */\n-  init_function_for_compilation ();\n+#ifdef OPTIMIZE_MODE_SWITCHING\n+static void\n+rest_of_handle_mode_switching (void)\n+{\n+  timevar_push (TV_MODE_SWITCH);\n \n-  TREE_ASM_WRITTEN (current_function_decl) = 1;\n+  no_new_pseudos = 0;\n+  optimize_mode_switching (NULL);\n+  no_new_pseudos = 1;\n \n-  /* Now that integrate will no longer see our rtl, we need not\n-     distinguish between the return value of this function and the\n-     return value of called functions.  Also, we can remove all SETs\n-     of subregs of hard registers; they are only here because of\n-     integrate.  Also, we can now initialize pseudos intended to\n-     carry magic hard reg data throughout the function.  */\n-  rtx_equal_function_value_matters = 0;\n-  purge_hard_subreg_sets (get_insns ());\n+  timevar_pop (TV_MODE_SWITCH);\n+}\n+#endif\n \n-  /* Early return if there were errors.  We can run afoul of our\n-     consistency checks, and there's not really much point in fixing them.  */\n-  if (rtl_dump_and_exit || flag_syntax_only || errorcount || sorrycount)\n-    goto exit_rest_of_compilation;\n+static void\n+rest_of_handle_jump (void)\n+{\n+  ggc_collect ();\n \n   timevar_push (TV_JUMP);\n   open_dump_file (DFI_sibling, current_function_decl);\n \n+  /* ??? We may get caled either via tree_rest_of_compilation when the CFG\n+     is already built or directly (for instance from coverage code).\n+     The direct callers shall be updated.  */\n+  if (!basic_block_info)\n+    {\n+      init_flow ();\n+      rebuild_jump_labels (get_insns ());\n+      find_exception_handler_labels ();\n+      find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n+    }\n+\n   /* ??? We may get called either via tree_rest_of_compilation when the CFG\n      is already built or directly (for instance from coverage code).\n      The direct callers shall be updated.  */\n@@ -1427,22 +1458,26 @@ rest_of_compilation (void)\n     }\n   delete_unreachable_blocks ();\n #ifdef ENABLE_CHECKING\n-  verify_flow_info();\n+  verify_flow_info ();\n #endif\n+  timevar_pop (TV_JUMP);\n+}\n \n+static void\n+rest_of_handle_guess_branch_prob (void)\n+{\n   /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n   if (flag_guess_branch_prob)\n     {\n       timevar_push (TV_BRANCH_PROB);\n       note_prediction_to_br_prob ();\n       timevar_pop (TV_BRANCH_PROB);\n     }\n+}\n \n-  timevar_pop (TV_JUMP);\n-\n-  if (cfun->tail_call_emit)\n-    fixup_tail_calls ();\n-\n+static void\n+rest_of_handle_eh (void)\n+{\n   insn_locators_initialize ();\n   /* Complete generation of exception handling code.  */\n   if (doing_eh (0))\n@@ -1455,35 +1490,81 @@ rest_of_compilation (void)\n       close_dump_file (DFI_eh, print_rtl, get_insns ());\n       timevar_pop (TV_JUMP);\n     }\n+}\n \n-  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n-     generation, which might create new sets.  */\n-  emit_initial_value_sets ();\n \n-#ifdef FINALIZE_PIC\n-  /* If we are doing position-independent code generation, now\n-     is the time to output special prologues and epilogues.\n-     We do not want to do this earlier, because it just clutters\n-     up inline functions with meaningless insns.  */\n-  if (flag_pic)\n-    FINALIZE_PIC;\n-#endif\n+static void\n+rest_of_handle_prologue_epilogue (void)\n+{\n+  if (optimize && !flow2_completed)\n+    cleanup_cfg (CLEANUP_EXPENSIVE);\n \n-  /* Copy any shared structure that should not be shared.  */\n-  unshare_all_rtl ();\n+  /* On some machines, the prologue and epilogue code, or parts thereof,\n+     can be represented as RTL.  Doing so lets us schedule insns between\n+     it and the rest of the code and also allows delayed branch\n+     scheduling to operate in the epilogue.  */\n+  thread_prologue_and_epilogue_insns (get_insns ());\n+  epilogue_completed = 1;\n \n-#ifdef SETJMP_VIA_SAVE_AREA\n-  /* This must be performed before virtual register instantiation.\n-     Please be aware that everything in the compiler that can look\n-     at the RTL up to this point must understand that REG_SAVE_AREA\n-     is just like a use of the REG contained inside.  */\n-  if (current_function_calls_alloca)\n-    optimize_save_area_alloca (get_insns ());\n+  if (optimize && flow2_completed)\n+    life_analysis (dump_file, PROP_POSTRELOAD);\n+}\n+\n+static void\n+rest_of_handle_stack_adjustments (void)\n+{\n+  life_analysis (dump_file, PROP_POSTRELOAD);\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+    \n+  /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n+     even for machines with possibly nonzero RETURN_POPS_ARGS\n+     and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+     push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n #endif\n+    combine_stack_adjustments ();\n+}\n \n-  /* Instantiate all virtual registers.  */\n-  instantiate_virtual_regs ();\n+static void\n+rest_of_handle_flow2 (void)\n+{\n+  timevar_push (TV_FLOW2);\n+  open_dump_file (DFI_flow2, current_function_decl);\n \n+  /* Re-create the death notes which were deleted during reload.  */\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  /* If optimizing, then go ahead and split insns now.  */\n+#ifndef STACK_REGS\n+  if (optimize > 0)\n+#endif\n+    split_all_insns (0);\n+\n+  if (flag_branch_target_load_optimize)\n+    rest_of_handle_branch_target_load_optimize ();\n+\n+  if (!targetm.late_rtl_prologue_epilogue)\n+    rest_of_handle_prologue_epilogue ();\n+\n+  if (optimize)\n+    rest_of_handle_stack_adjustments ();\n+\n+  flow2_completed = 1;\n+\n+  close_dump_file (DFI_flow2, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_FLOW2);\n+\n+  ggc_collect ();\n+}\n+\n+\n+static void\n+rest_of_handle_jump2 (void)\n+{\n   open_dump_file (DFI_jump, current_function_decl);\n \n   /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n@@ -1497,7 +1578,7 @@ rest_of_compilation (void)\n     expected_value_to_br_prob ();\n \n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n-  reg_scan (get_insns(), max_reg_num (), 0);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n@@ -1507,8 +1588,6 @@ rest_of_compilation (void)\n \n   purge_line_number_notes (get_insns ());\n \n-  close_dump_file (DFI_jump, print_rtl, get_insns ());\n-\n   if (optimize)\n     cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n@@ -1518,17 +1597,231 @@ rest_of_compilation (void)\n      maximum instruction UID, so if we can reduce the maximum UID\n      we'll save big on memory.  */\n   renumber_insns (dump_file);\n-  timevar_pop (TV_JUMP);\n \n   close_dump_file (DFI_jump, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_JUMP);\n \n   ggc_collect ();\n+}\n+\n+#ifdef HAVE_peephole2\n+static void\n+rest_of_handle_peephole2 (void)\n+{\n+  timevar_push (TV_PEEPHOLE2);\n+  open_dump_file (DFI_peephole2, current_function_decl);\n+\n+  peephole2_optimize (dump_file);\n+\n+  close_dump_file (DFI_peephole2, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_PEEPHOLE2);\n+}\n+#endif\n+\n+static void\n+rest_of_handle_postreload (void)\n+{\n+  timevar_push (TV_RELOAD_CSE_REGS);\n+  open_dump_file (DFI_postreload, current_function_decl);\n+\n+  /* Do a very simple CSE pass over just the hard registers.  */\n+  reload_cse_regs (get_insns ());\n+  /* reload_cse_regs can eliminate potentially-trapping MEMs.\n+     Remove any EH edges associated with them.  */\n+  if (flag_non_call_exceptions)\n+    purge_all_dead_edges (0);\n+\n+  close_dump_file (DFI_postreload, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_RELOAD_CSE_REGS);\n+}\n+\n+static void\n+rest_of_handle_shorten_branches (void)\n+{\n+  /* Shorten branches.  */\n+  timevar_push (TV_SHORTEN_BRANCH);\n+  shorten_branches (get_insns ());\n+  timevar_pop (TV_SHORTEN_BRANCH);\n+}\n+\n+static void\n+rest_of_clean_state (void)\n+{\n+  coverage_end_function ();\n+\n+  /* In case the function was not output,\n+     don't leave any temporary anonymous types\n+     queued up for sdb output.  */\n+#ifdef SDB_DEBUGGING_INFO\n+  if (write_symbols == SDB_DEBUG)\n+    sdbout_types (NULL_TREE);\n+#endif\n+\n+  reload_completed = 0;\n+  epilogue_completed = 0;\n+  flow2_completed = 0;\n+  no_new_pseudos = 0;\n+\n+  timevar_push (TV_FINAL);\n+\n+  /* Clear out the insn_length contents now that they are no\n+     longer valid.  */\n+  init_insn_lengths ();\n+\n+  /* Show no temporary slots allocated.  */\n+  init_temp_slots ();\n+\n+  free_basic_block_vars ();\n+  free_bb_for_insn ();\n+\n+  timevar_pop (TV_FINAL);\n+\n+  if (targetm.binds_local_p (current_function_decl))\n+    {\n+      int pref = cfun->preferred_stack_boundary;\n+      if (cfun->recursive_call_emit\n+          && cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n+\tpref = cfun->stack_alignment_needed;\n+      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n+        = pref;\n+    }\n+\n+  /* Make sure volatile mem refs aren't considered valid operands for\n+     arithmetic insns.  We must call this here if this is a nested inline\n+     function, since the above code leaves us in the init_recog state\n+     (from final.c), and the function context push/pop code does not\n+     save/restore volatile_ok.\n+\n+     ??? Maybe it isn't necessary for expand_start_function to call this\n+     anymore if we do it here?  */\n+\n+  init_recog_no_volatile ();\n+\n+  /* We're done with this function.  Free up memory if we can.  */\n+  free_after_parsing (cfun);\n+}\n+\f\n+\n+/* This is called from finish_function (within langhooks.parse_file)\n+   after each top-level definition is parsed.\n+   It is supposed to compile that function or variable\n+   and output the assembler code for it.\n+   After we return, the tree storage is freed.  */\n+\n+void\n+rest_of_compilation (void)\n+{\n+  /* There's no need to defer outputting this function any more; we\n+     know we want to output it.  */\n+  DECL_DEFER_OUTPUT (current_function_decl) = 0;\n+\n+  /* Register rtl specific functions for cfg.  */\n+  rtl_register_cfg_hooks ();\n+\n+  /* Now that we're out of the frontend, we shouldn't have any more\n+     CONCATs anywhere.  */\n+  generating_concat_p = 0;\n+\n+  /* When processing delayed functions, prepare_function_start () won't\n+     have been run to re-initialize it.  */\n+  cse_not_expected = ! optimize;\n+\n+  finalize_block_changes ();\n+\n+  /* Dump the rtl code if we are dumping rtl.  */\n+  if (open_dump_file (DFI_rtl, current_function_decl))\n+    close_dump_file (DFI_rtl, print_rtl, get_insns ());\n+\n+  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n+     sorts of eh initialization.  Delay this until after the\n+     initial rtl dump so that we can see the original nesting.  */\n+  convert_from_eh_region_ranges ();\n+\n+  /* If we're emitting a nested function, make sure its parent gets\n+     emitted as well.  Doing otherwise confuses debug info.  */\n+  {\n+    tree parent;\n+    for (parent = DECL_CONTEXT (current_function_decl);\n+\t parent != NULL_TREE;\n+\t parent = get_containing_scope (parent))\n+      if (TREE_CODE (parent) == FUNCTION_DECL)\n+\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+  }\n+\n+  /* We are now committed to emitting code for this function.  Do any\n+     preparation, such as emitting abstract debug info for the inline\n+     before it gets mangled by optimization.  */\n+  if (cgraph_function_possibly_inlined_p (current_function_decl))\n+    (*debug_hooks->outlining_inline_function) (current_function_decl);\n+\n+  /* Remove any notes we don't need.  That will make iterating\n+     over the instruction sequence faster, and allow the garbage\n+     collector to reclaim the memory used by the notes.  */\n+  remove_unnecessary_notes ();\n+\n+  /* Initialize some variables used by the optimizers.  */\n+  init_function_for_compilation ();\n+\n+  TREE_ASM_WRITTEN (current_function_decl) = 1;\n+\n+  /* Now that integrate will no longer see our rtl, we need not\n+     distinguish between the return value of this function and the\n+     return value of called functions.  Also, we can remove all SETs\n+     of subregs of hard registers; they are only here because of\n+     integrate.  Also, we can now initialize pseudos intended to\n+     carry magic hard reg data throughout the function.\n+\n+     FIXME: All this looks thoroughly obsolete... maybe we can\n+     get rid of both these lines unconditionally?  */\n+  rtx_equal_function_value_matters = 0;\n+  purge_hard_subreg_sets (get_insns ());\n+\n+  /* Early return if there were errors.  We can run afoul of our\n+     consistency checks, and there's not really much point in fixing them.  */\n+  if (rtl_dump_and_exit || flag_syntax_only || errorcount || sorrycount)\n+    goto exit_rest_of_compilation;\n+\n+  rest_of_handle_jump ();\n+  rest_of_handle_guess_branch_prob ();\n+\n+  if (cfun->tail_call_emit)\n+    fixup_tail_calls ();\n+\n+  rest_of_handle_eh ();\n+\n+  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n+     generation, which might create new sets.  */\n+  emit_initial_value_sets ();\n+\n+#ifdef FINALIZE_PIC\n+  /* If we are doing position-independent code generation, now\n+     is the time to output special prologues and epilogues.\n+     We do not want to do this earlier, because it just clutters\n+     up inline functions with meaningless insns.  */\n+  if (flag_pic)\n+    FINALIZE_PIC;\n+#endif\n+\n+  /* Copy any shared structure that should not be shared.  */\n+  unshare_all_rtl ();\n+\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  /* This must be performed before virtual register instantiation.\n+     Please be aware that everything in the compiler that can look\n+     at the RTL up to this point must understand that REG_SAVE_AREA\n+     is just like a use of the REG contained inside.  */\n+  if (current_function_calls_alloca)\n+    optimize_save_area_alloca ();\n+#endif\n+\n+  /* Instantiate all virtual registers.  */\n+  instantiate_virtual_regs ();\n+\n+  rest_of_handle_jump2 ();\n \n   if (optimize > 0)\n     rest_of_handle_cse ();\n \n-  ggc_collect ();\n-\n   if (optimize > 0)\n     {\n       if (flag_gcse)\n@@ -1542,7 +1835,6 @@ rest_of_compilation (void)\n     }\n \n   timevar_push (TV_FLOW);\n-\n   rest_of_handle_cfg ();\n \n   if (!flag_tree_based_profiling\n@@ -1566,42 +1858,36 @@ rest_of_compilation (void)\n   if (optimize > 0)\n     rest_of_handle_if_conversion ();\n \n-  if (flag_tracer)\n+  if (optimize > 0 && flag_tracer)\n     rest_of_handle_tracer ();\n \n   if (optimize > 0\n       && flag_loop_optimize2)\n     rest_of_handle_loop2 ();\n \n-  if (flag_web)\n+  if (optimize > 0 && flag_web)\n     rest_of_handle_web ();\n \n-  if (flag_rerun_cse_after_loop)\n+  if (optimize > 0 && flag_rerun_cse_after_loop)\n     rest_of_handle_cse2 ();\n \n   cse_not_expected = 1;\n \n   rest_of_handle_life ();\n+  timevar_pop (TV_FLOW);\n \n   if (optimize > 0)\n     rest_of_handle_combine ();\n \n-  if (flag_if_conversion)\n+  if (optimize > 0 && flag_if_conversion)\n     rest_of_handle_if_after_combine ();\n \n   /* The optimization to partition hot/cold basic blocks into separate\n      sections of the .o file does not work well with exception handling.\n      Don't call it if there are exceptions.  */\n \n-  if (flag_reorder_blocks_and_partition && !flag_exceptions)\n-    {\n-      no_new_pseudos = 0;\n-      partition_hot_cold_basic_blocks ();\n-      allocate_reg_life_data ();\n-      update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES, \n-\t\t\tPROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n-      no_new_pseudos = 1;\n-    }\n+  if (optimize > 0 && flag_reorder_blocks_and_partition && !flag_exceptions)\n+    rest_of_handle_partition_blocks ();\n \n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n     rest_of_handle_regmove ();\n@@ -1611,13 +1897,7 @@ rest_of_compilation (void)\n   split_all_insns (1);\n \n #ifdef OPTIMIZE_MODE_SWITCHING\n-  timevar_push (TV_MODE_SWITCH);\n-\n-  no_new_pseudos = 0;\n-  optimize_mode_switching (NULL);\n-  no_new_pseudos = 1;\n-\n-  timevar_pop (TV_MODE_SWITCH);\n+  rest_of_handle_mode_switching ();\n #endif\n \n   /* Any of the several passes since flow1 will have munged register\n@@ -1626,17 +1906,18 @@ rest_of_compilation (void)\n   recompute_reg_usage (get_insns (), !optimize_size);\n \n #ifdef INSN_SCHEDULING\n-  rest_of_handle_sched ();\n+  if (optimize > 0 && flag_modulo_sched)\n+    rest_of_handle_sms ();\n+\n+  if (flag_schedule_insns)\n+    rest_of_handle_sched ();\n #endif\n \n   /* Determine if the current function is a leaf before running reload\n      since this can impact optimizations done by the prologue and\n      epilogue thus changing register elimination offsets.  */\n   current_function_is_leaf = leaf_function_p ();\n \n-  timevar_push (TV_LOCAL_ALLOC);\n-  open_dump_file (DFI_lreg, current_function_decl);\n-\n   if (flag_new_regalloc)\n     {\n       if (rest_of_handle_new_regalloc ())\n@@ -1648,117 +1929,21 @@ rest_of_compilation (void)\n \tgoto exit_rest_of_compilation;\n     }\n \n-  ggc_collect ();\n-\n-  open_dump_file (DFI_postreload, current_function_decl);\n-\n-  /* Do a very simple CSE pass over just the hard registers.  */\n   if (optimize > 0)\n-    {\n-      timevar_push (TV_RELOAD_CSE_REGS);\n-      reload_cse_regs (get_insns ());\n-      /* reload_cse_regs can eliminate potentially-trapping MEMs.\n-\t Remove any EH edges associated with them.  */\n-      if (flag_non_call_exceptions)\n-\tpurge_all_dead_edges (0);\n-      timevar_pop (TV_RELOAD_CSE_REGS);\n-    }\n-\n-  close_dump_file (DFI_postreload, print_rtl_with_bb, get_insns ());\n+    rest_of_handle_postreload ();\n \n   if (optimize > 0 && flag_gcse_after_reload)\n     rest_of_handle_gcse2 ();\n \n-  /* Re-create the death notes which were deleted during reload.  */\n-  timevar_push (TV_FLOW2);\n-  open_dump_file (DFI_flow2, current_function_decl);\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  /* If optimizing, then go ahead and split get_insns () now.  */\n-#ifndef STACK_REGS\n-  if (optimize > 0)\n-#endif\n-    split_all_insns (0);\n-\n-    if (flag_branch_target_load_optimize)\n-      {\n-\topen_dump_file (DFI_branch_target_load, current_function_decl);\n-\n-\tbranch_target_load_optimize (/*after_prologue_epilogue_gen=*/false);\n-\n-\tclose_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n-\n-\tggc_collect ();\n-      }\n-\n-  if (! targetm.late_rtl_prologue_epilogue)\n-    {\n-      if (optimize)\n-\tcleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-      /* On some machines, the prologue and epilogue code, or parts thereof,\n-\t can be represented as RTL.  Doing so lets us schedule insns between\n-\t it and the rest of the code and also allows delayed branch\n-\t scheduling to operate in the epilogue.  */\n-      thread_prologue_and_epilogue_insns (get_insns ());\n-      epilogue_completed = 1;\n-    }\n-\n-  if (optimize)\n-    {\n-      life_analysis (dump_file, PROP_POSTRELOAD);\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-\n-      /* This is kind of a heuristic.  We need to run combine_stack_adjustments\n-         even for machines with possibly nonzero RETURN_POPS_ARGS\n-         and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n-         push instructions will have popping returns.  */\n-#ifndef PUSH_ROUNDING\n-      if (!ACCUMULATE_OUTGOING_ARGS)\n-#endif\n-\tcombine_stack_adjustments ();\n-\n-      ggc_collect ();\n-    }\n-\n-  flow2_completed = 1;\n-\n-  close_dump_file (DFI_flow2, print_rtl_with_bb, get_insns ());\n-  timevar_pop (TV_FLOW2);\n+  rest_of_handle_flow2 ();\n \n #ifdef HAVE_peephole2\n   if (optimize > 0 && flag_peephole2)\n-    {\n-      timevar_push (TV_PEEPHOLE2);\n-      open_dump_file (DFI_peephole2, current_function_decl);\n-\n-      peephole2_optimize (dump_file);\n-\n-      close_dump_file (DFI_peephole2, print_rtl_with_bb, get_insns ());\n-      timevar_pop (TV_PEEPHOLE2);\n-    }\n+    rest_of_handle_peephole2 ();\n #endif\n \n-  open_dump_file (DFI_ce3, current_function_decl);\n-  if (optimize)\n-    /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-       splitting possibly introduced more crossjumping opportunities.  */\n-    cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t | CLEANUP_UPDATE_LIFE \n-\t\t | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n-  if (flag_if_conversion2)\n-    {\n-      timevar_push (TV_IFCVT2);\n-\n-      if_convert (1);\n-\n-      timevar_pop (TV_IFCVT2);\n-    }\n-  close_dump_file (DFI_ce3, print_rtl_with_bb, get_insns ());\n+  if (optimize > 0)\n+    rest_of_handle_if_after_reload ();\n \n   if (optimize > 0)\n     {\n@@ -1769,39 +1954,15 @@ rest_of_compilation (void)\n     }\n \n   if (flag_branch_target_load_optimize2)\n-    {\n-      /* Leave this a warning for now so that it is possible to experiment\n-\t with running this pass twice.  In 3.6, we should either make this\n-\t an error, or use separate dump files.  */\n-      if (flag_branch_target_load_optimize)\n-\twarning (\"branch target register load optimization is not intended \"\n-\t\t \"to be run twice\");\n-\n-      open_dump_file (DFI_branch_target_load, current_function_decl);\n-\n-      branch_target_load_optimize (/*after_prologue_epilogue_gen=*/true);\n-\n-      close_dump_file (DFI_branch_target_load, print_rtl_with_bb, get_insns ());\n-\n-      ggc_collect ();\n-    }\n+    rest_of_handle_branch_target_load_optimize ();\n \n #ifdef LEAF_REGISTERS\n   current_function_uses_only_leaf_regs\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n   if (targetm.late_rtl_prologue_epilogue)\n-    {\n-      /* On some machines, the prologue and epilogue code, or parts thereof,\n-\t can be represented as RTL.  Doing so lets us schedule insns between\n-\t it and the rest of the code and also allows delayed branch\n-\t scheduling to operate in the epilogue.  */\n-      thread_prologue_and_epilogue_insns (get_insns ());\n-      epilogue_completed = 1;\n-      if (optimize)\n-\tlife_analysis (dump_file, PROP_POSTRELOAD);\n-    }\n+    rest_of_handle_prologue_epilogue ();\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n@@ -1827,7 +1988,7 @@ rest_of_compilation (void)\n   cleanup_barriers ();\n \n #ifdef DELAY_SLOTS\n-  if (optimize > 0 && flag_delayed_branch)\n+  if (flag_delayed_branch)\n     rest_of_handle_delay_slots ();\n #endif\n \n@@ -1839,88 +2000,15 @@ rest_of_compilation (void)\n \n   convert_to_eh_region_ranges ();\n \n-  /* Shorten branches.  */\n-  timevar_push (TV_SHORTEN_BRANCH);\n-  shorten_branches (get_insns ());\n-  timevar_pop (TV_SHORTEN_BRANCH);\n+  rest_of_handle_shorten_branches ();\n \n   set_nothrow_function_flags ();\n-  if (current_function_nothrow)\n-    /* Now we know that this can't throw; set the flag for the benefit\n-       of other functions later in this translation unit.  */\n-    TREE_NOTHROW (current_function_decl) = 1;\n \n   rest_of_handle_final ();\n \n-  /* Write DBX symbols if requested.  */\n-\n-  /* Note that for those inline functions where we don't initially\n-     know for certain that we will be generating an out-of-line copy,\n-     the first invocation of this routine (rest_of_compilation) will\n-     skip over this code by doing a `goto exit_rest_of_compilation;'.\n-     Later on, wrapup_global_declarations will (indirectly) call\n-     rest_of_compilation again for those inline functions that need\n-     to have out-of-line copies generated.  During that call, we\n-     *will* be routed past here.  */\n-\n-  timevar_push (TV_SYMOUT);\n-  (*debug_hooks->function_decl) (current_function_decl);\n-  timevar_pop (TV_SYMOUT);\n-\n  exit_rest_of_compilation:\n \n-  coverage_end_function ();\n-\n-  /* In case the function was not output,\n-     don't leave any temporary anonymous types\n-     queued up for sdb output.  */\n-#ifdef SDB_DEBUGGING_INFO\n-  if (write_symbols == SDB_DEBUG)\n-    sdbout_types (NULL_TREE);\n-#endif\n-\n-  reload_completed = 0;\n-  epilogue_completed = 0;\n-  flow2_completed = 0;\n-  no_new_pseudos = 0;\n-\n-  timevar_push (TV_FINAL);\n-\n-  /* Clear out the insn_length contents now that they are no\n-     longer valid.  */\n-  init_insn_lengths ();\n-\n-  /* Show no temporary slots allocated.  */\n-  init_temp_slots ();\n-\n-  free_basic_block_vars ();\n-  free_bb_for_insn ();\n-\n-  timevar_pop (TV_FINAL);\n-\n-  if (targetm.binds_local_p (current_function_decl))\n-    {\n-      int pref = cfun->preferred_stack_boundary;\n-      if (cfun->recursive_call_emit\n-          && cfun->stack_alignment_needed > cfun->preferred_stack_boundary)\n-\tpref = cfun->stack_alignment_needed;\n-      cgraph_rtl_info (current_function_decl)->preferred_incoming_stack_boundary\n-        = pref;\n-    }\n-\n-  /* Make sure volatile mem refs aren't considered valid operands for\n-     arithmetic insns.  We must call this here if this is a nested inline\n-     function, since the above code leaves us in the init_recog state\n-     (from final.c), and the function context push/pop code does not\n-     save/restore volatile_ok.\n-\n-     ??? Maybe it isn't necessary for expand_start_function to call this\n-     anymore if we do it here?  */\n-\n-  init_recog_no_volatile ();\n-\n-  /* We're done with this function.  Free up memory if we can.  */\n-  free_after_parsing (cfun);\n+  rest_of_clean_state ();\n }\n \n void\n@@ -1934,23 +2022,18 @@ init_optimization_passes (void)\n void\n finish_optimization_passes (void)\n {\n+  timevar_push (TV_DUMP);\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      timevar_push (TV_DUMP);\n       open_dump_file (DFI_bp, NULL);\n-\n       end_branch_prob ();\n-\n       close_dump_file (DFI_bp, NULL, NULL_RTX);\n-      timevar_pop (TV_DUMP);\n     }\n \n   if (optimize > 0 && open_dump_file (DFI_combine, NULL))\n     {\n-      timevar_push (TV_DUMP);\n       dump_combine_total_stats (dump_file);\n       close_dump_file (DFI_combine, NULL, NULL_RTX);\n-      timevar_pop (TV_DUMP);\n     }\n \n   dump_file = cgraph_dump_file;\n@@ -1975,6 +2058,7 @@ finish_optimization_passes (void)\n \t  }\n     }\n \n+  timevar_pop (TV_DUMP);\n }\n \n bool"}, {"sha": "2585dd268a46ea6ba27c00b0344eec869060ca27", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b0ade303bbfe07ef8b0a9071f718f4d8cd002d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=97b0ade303bbfe07ef8b0a9071f718f4d8cd002d", "patch": "@@ -1581,7 +1581,7 @@ extern void set_stack_check_libfunc (rtx);\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n extern rtx plus_constant_wide (rtx, HOST_WIDE_INT);\n extern rtx plus_constant_for_output_wide (rtx, HOST_WIDE_INT);\n-extern void optimize_save_area_alloca (rtx);\n+extern void optimize_save_area_alloca (void);\n \n /* In emit-rtl.c */\n extern rtvec gen_rtvec (int, ...);"}]}