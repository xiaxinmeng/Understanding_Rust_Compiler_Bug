{"sha": "8ad4c89538959cda77bcf90164c79b4b74f9f602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkNGM4OTUzODk1OWNkYTc3YmNmOTAxNjRjNzliNGI3NGY5ZjYwMg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-22T02:32:29Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-22T02:32:29Z"}, "message": "re PR libfortran/25307 (internal read with end=label aborts)\n\n2005-12-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/25307\n\t* io/list_read.c (next_char): Handle end-of-file conditions for\n\tinternal units and add support for internal character array units.\n\nFrom-SVN: r108938", "tree": {"sha": "871b80d81409f915ff1628c74e62c226afb69b93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/871b80d81409f915ff1628c74e62c226afb69b93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad4c89538959cda77bcf90164c79b4b74f9f602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad4c89538959cda77bcf90164c79b4b74f9f602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad4c89538959cda77bcf90164c79b4b74f9f602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad4c89538959cda77bcf90164c79b4b74f9f602/comments", "author": null, "committer": null, "parents": [{"sha": "4e2d94a91774249326515786963ada455c0dcd6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2d94a91774249326515786963ada455c0dcd6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e2d94a91774249326515786963ada455c0dcd6d"}], "stats": {"total": 71, "additions": 58, "deletions": 13}, "files": [{"sha": "02d38d95331c1d58f2b3b3fc85c9d36f6101ea77", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad4c89538959cda77bcf90164c79b4b74f9f602/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad4c89538959cda77bcf90164c79b4b74f9f602/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8ad4c89538959cda77bcf90164c79b4b74f9f602", "patch": "@@ -1,3 +1,9 @@\n+2005-12-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/25307\n+\t* io/list_read.c (next_char): Handle end-of-file conditions for\n+\tinternal units and add support for internal character array units.\n+\n 2005-12-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/25463"}, {"sha": "9784403a39c9d18f7325ba32daf4ac658028e8ef", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad4c89538959cda77bcf90164c79b4b74f9f602/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad4c89538959cda77bcf90164c79b4b74f9f602/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=8ad4c89538959cda77bcf90164c79b4b74f9f602", "patch": "@@ -121,6 +121,7 @@ static char\n next_char (st_parameter_dt *dtp)\n {\n   int length;\n+  gfc_offset record;\n   char c, *p;\n \n   if (dtp->u.p.last_char != '\\0')\n@@ -133,26 +134,64 @@ next_char (st_parameter_dt *dtp)\n \n   length = 1;\n \n-  p = salloc_r (dtp->u.p.current_unit->s, &length);\n-  if (p == NULL)\n+  /* Handle the end-of-record condition for internal array unit */\n+  if (is_array_io(dtp) && dtp->u.p.current_unit->bytes_left == 0)\n     {\n-      generate_error (&dtp->common, ERROR_OS, NULL);\n-      return '\\0';\n+      c = '\\n';\n+      record = next_array_record (dtp, dtp->u.p.current_unit->ls);\n+\n+      /* Check for \"end-of-file\" condition */      \n+      if (record == 0)\n+\tlongjmp (*dtp->u.p.eof_jump, 1);\n+\n+      record *= dtp->u.p.current_unit->recl;\n+      \n+      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n+\tlongjmp (*dtp->u.p.eof_jump, 1);\n+\n+      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n+      goto done;\n     }\n \n-  if (length == 0)\n+  /* Get the next character and handle end-of-record conditions */\n+  p = salloc_r (dtp->u.p.current_unit->s, &length);\n+\n+  if (is_internal_unit(dtp))\n     {\n-      /* For internal files return a newline instead of signalling EOF.  */\n-      /* ??? This isn't quite right, but we don't handle internal files\n-\t with multiple records.  */\n-      if (is_internal_unit (dtp))\n-\tc = '\\n';\n+      if (is_array_io(dtp))\n+\t{\n+\t  /* End of record is handled in the next pass through, above.  The\n+\t     check for NULL here is cautionary. */\n+\t  if (p == NULL)\n+\t    {\n+\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      return '\\0';\n+\t    }\n+\n+\t  dtp->u.p.current_unit->bytes_left--;\n+\t  c = *p;\n+\t}\n       else\n-\tlongjmp (*dtp->u.p.eof_jump, 1);\n+\t{\n+\t  if (p == NULL)\n+\t    longjmp (*dtp->u.p.eof_jump, 1);\n+\t  if (length == 0)\n+\t    c = '\\n';\n+\t  else\n+\t    c = *p;\n+\t}\n     }\n   else\n-    c = *p;\n-\n+    {\n+      if (p == NULL)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return '\\0';\n+\t}\n+      if (length == 0)\n+\tlongjmp (*dtp->u.p.eof_jump, 1);\n+      c = *p;\n+    }\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n   return c;"}]}