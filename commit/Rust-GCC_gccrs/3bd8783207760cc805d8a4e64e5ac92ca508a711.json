{"sha": "3bd8783207760cc805d8a4e64e5ac92ca508a711", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkODc4MzIwNzc2MGNjODA1ZDhhNGU2NGU1YWM5MmNhNTA4YTcxMQ==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:31:43Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-11-25T16:35:39Z"}, "message": "libsanitizer: options:  Add hwasan flags and argument parsing\n\nThese flags can't be used at the same time as any of the other\nsanitizers.\nWe add an equivalent flag to -static-libasan in -static-libhwasan to\nensure static linking.\n\nThe -fsanitize=kernel-hwaddress option is for compiling targeting the\nkernel.  This flag has defaults to match the LLVM implementation and\nsets some other behaviors to work in the kernel (e.g. accounting for\nthe fact that the stack pointer will have 0xff in the top byte and to not\ncall the userspace library initialisation routines).\nThe defaults are that we do not sanitize variables on the stack and\nalways recover from a detected bug.\n\nSince we are introducing a few more conflicts between sanitizer flags we\nrefactor the checking for such conflicts to use a helper function which\nmakes checking for such conflicts more easy and consistent.\n\nWe introduce a backend hook `targetm.memtag.can_tag_addresses` that\nindicates to the mid-end whether a target has a feature like AArch64 TBI\nwhere the top byte of an address is ignored.\nWithout this feature hwasan sanitization is not done.\n\ngcc/ChangeLog:\n\n\t* common.opt (flag_sanitize_recover): Default for kernel\n\thwaddress.\n\t(static-libhwasan): New cli option.\n\t* config/aarch64/aarch64.c (aarch64_can_tag_addresses): New.\n\t(TARGET_MEMTAG_CAN_TAG_ADDRESSES): New.\n\t* config/gnu-user.h (LIBHWASAN_EARLY_SPEC): hwasan equivalent of\n\tasan command line flags.\n\t* cppbuiltin.c (define_builtin_macros_for_compilation_flags):\n\tAdd hwasan equivalent of __SANITIZE_ADDRESS__.\n\t* doc/invoke.texi: Document hwasan command line flags.\n\t* doc/tm.texi: Document new hook.\n\t* doc/tm.texi.in: Document new hook.\n\t* flag-types.h (enum sanitize_code): New sanitizer values.\n\t* gcc.c (STATIC_LIBHWASAN_LIBS): New macro.\n\t(LIBHWASAN_SPEC): New macro.\n\t(LIBHWASAN_EARLY_SPEC): New macro.\n\t(SANITIZER_EARLY_SPEC): Update to include hwasan.\n\t(SANITIZER_SPEC): Update to include hwasan.\n\t(sanitize_spec_function): Use hwasan options.\n\t* opts.c (finish_options): Describe conflicts between address\n\tsanitizers.\n\t(find_sanitizer_argument): New.\n\t(report_conflicting_sanitizer_options): New.\n\t(sanitizer_opts): Introduce new sanitizer flags.\n\t(common_handle_option): Add defaults for kernel sanitizer.\n\t* params.opt (hwasan--instrument-stack): New\n\t(hwasan-random-frame-tag): New\n\t(hwasan-instrument-allocas): New\n\t(hwasan-instrument-reads): New\n\t(hwasan-instrument-writes): New\n\t(hwasan-instrument-mem-intrinsics): New\n\t* target.def (HOOK_PREFIX): Add new hook.\n\t(can_tag_addresses): Add new hook under memtag prefix.\n\t* targhooks.c (default_memtag_can_tag_addresses): New.\n\t* targhooks.h (default_memtag_can_tag_addresses): New decl.\n\t* toplev.c (process_options): Ensure hwasan only on\n\tarchitectures that advertise the possibility.", "tree": {"sha": "1d270dc01883654cbe0681e5f06c2aea5c1e460f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d270dc01883654cbe0681e5f06c2aea5c1e460f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd8783207760cc805d8a4e64e5ac92ca508a711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd8783207760cc805d8a4e64e5ac92ca508a711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd8783207760cc805d8a4e64e5ac92ca508a711", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd8783207760cc805d8a4e64e5ac92ca508a711/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "170e618ef559a9b1220174c1d33cd7e5b1045cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170e618ef559a9b1220174c1d33cd7e5b1045cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170e618ef559a9b1220174c1d33cd7e5b1045cc8"}], "stats": {"total": 303, "additions": 283, "deletions": 20}, "files": [{"sha": "582e2aa87749592f46e37c398efadfe2d749a7d7", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -218,7 +218,7 @@ unsigned int flag_sanitize\n \n ; What sanitizers should recover from errors\n Variable\n-unsigned int flag_sanitize_recover = (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT | SANITIZE_KERNEL_ADDRESS) & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN)\n+unsigned int flag_sanitize_recover = (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT | SANITIZE_KERNEL_ADDRESS | SANITIZE_KERNEL_HWADDRESS) & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN)\n \n ; What the coverage sanitizers should instrument\n Variable\n@@ -3448,6 +3448,9 @@ Driver\n static-libasan\n Driver\n \n+static-libhwasan\n+Driver\n+\n static-libtsan\n Driver\n "}, {"sha": "140ee79679abb93536f14e221bb84b660c9e6806", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -23321,6 +23321,15 @@ aarch64_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1,\n   return NULL;\n }\n \n+/* Implement TARGET_MEMTAG_CAN_TAG_ADDRESSES.  Here we tell the rest of the\n+   compiler that we automatically ignore the top byte of our pointers, which\n+   allows using -fsanitize=hwaddress.  */\n+bool\n+aarch64_can_tag_addresses ()\n+{\n+  return !TARGET_ILP32;\n+}\n+\n /* Implement TARGET_ASM_FILE_END for AArch64.  This adds the AArch64 GNU NOTE\n    section at the end if needed.  */\n #define GNU_PROPERTY_AARCH64_FEATURE_1_AND\t0xc0000000\n@@ -24140,6 +24149,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_FNTYPE_ABI\n #define TARGET_FNTYPE_ABI aarch64_fntype_abi\n \n+#undef TARGET_MEMTAG_CAN_TAG_ADDRESSES\n+#define TARGET_MEMTAG_CAN_TAG_ADDRESSES aarch64_can_tag_addresses\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}, {"sha": "92950245e2b95c500da9df8b85940380e62030fa", "filename": "gcc/config/gnu-user.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fconfig%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fconfig%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-user.h?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -129,14 +129,18 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Link -lasan early on the command line.  For -static-libasan, don't link\n    it for -shared link, the executable should be compiled with -static-libasan\n    in that case, and for executable link with --{,no-}whole-archive around\n-   it to force everything into the executable.  And similarly for -ltsan\n-   and -llsan.  */\n+   it to force everything into the executable.  And similarly for -ltsan,\n+   -lhwasan, and -llsan.  */\n #if defined(HAVE_LD_STATIC_DYNAMIC)\n #undef LIBASAN_EARLY_SPEC\n #define LIBASAN_EARLY_SPEC \"%{!shared:libasan_preinit%O%s} \" \\\n   \"%{static-libasan:%{!shared:\" \\\n   LD_STATIC_OPTION \" --whole-archive -lasan --no-whole-archive \" \\\n   LD_DYNAMIC_OPTION \"}}%{!static-libasan:-lasan}\"\n+#undef LIBHWASAN_EARLY_SPEC\n+#define LIBHWASAN_EARLY_SPEC \"%{static-libhwasan:%{!shared:\" \\\n+  LD_STATIC_OPTION \" --whole-archive -lhwasan --no-whole-archive \" \\\n+  LD_DYNAMIC_OPTION \"}}%{!static-libhwasan:-lhwasan}\"\n #undef LIBTSAN_EARLY_SPEC\n #define LIBTSAN_EARLY_SPEC \"%{!shared:libtsan_preinit%O%s} \" \\\n   \"%{static-libtsan:%{!shared:\" \\"}, {"sha": "fc61c78a99373fcfbc2bb03a01134248214eb2d4", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -93,6 +93,9 @@ define_builtin_macros_for_compilation_flags (cpp_reader *pfile)\n   if (flag_sanitize & SANITIZE_ADDRESS)\n     cpp_define (pfile, \"__SANITIZE_ADDRESS__\");\n \n+  if (flag_sanitize & SANITIZE_HWADDRESS)\n+    cpp_define (pfile, \"__SANITIZE_HWADDRESS__\");\n+\n   if (flag_sanitize & SANITIZE_THREAD)\n     cpp_define (pfile, \"__SANITIZE_THREAD__\");\n "}, {"sha": "0621d47f44a15dbaefe8e0818e03c1f8b17a0eec", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -13829,6 +13829,53 @@ is greater or equal to this number, use callbacks instead of inline checks.\n E.g. to disable inline code use\n @option{--param asan-instrumentation-with-call-threshold=0}.\n \n+@item hwasan-instrument-stack\n+Enable hwasan instrumentation of statically sized stack-allocated variables.\n+This kind of instrumentation is enabled by default when using\n+@option{-fsanitize=hwaddress} and disabled by default when using\n+@option{-fsanitize=kernel-hwaddress}.\n+To disable stack instrumentation use\n+@option{--param hwasan-instrument-stack=0}, and to enable it use\n+@option{--param hwasan-instrument-stack=1}.\n+\n+@item hwasan-random-frame-tag\n+When using stack instrumentation, decide tags for stack variables using a\n+deterministic sequence beginning at a random tag for each frame.  With this\n+parameter unset tags are chosen using the same sequence but beginning from 1.\n+This is enabled by default for @option{-fsanitize=hwaddress} and unavailable\n+for @option{-fsanitize=kernel-hwaddress}.\n+To disable it use @option{--param hwasan-random-frame-tag=0}.\n+\n+@item hwasan-instrument-allocas\n+Enable hwasan instrumentation of dynamically sized stack-allocated variables.\n+This kind of instrumentation is enabled by default when using\n+@option{-fsanitize=hwaddress} and disabled by default when using\n+@option{-fsanitize=kernel-hwaddress}.\n+To disable instrumentation of such variables use\n+@option{--param hwasan-instrument-allocas=0}, and to enable it use\n+@option{--param hwasan-instrument-allocas=1}.\n+\n+@item hwasan-instrument-reads\n+Enable hwasan checks on memory reads.  Instrumentation of reads is enabled by\n+default for both @option{-fsanitize=hwaddress} and\n+@option{-fsanitize=kernel-hwaddress}.\n+To disable checking memory reads use\n+@option{--param hwasan-instrument-reads=0}.\n+\n+@item hwasan-instrument-writes\n+Enable hwasan checks on memory writes.  Instrumentation of writes is enabled by\n+default for both @option{-fsanitize=hwaddress} and\n+@option{-fsanitize=kernel-hwaddress}.\n+To disable checking memory writes use\n+@option{--param hwasan-instrument-writes=0}.\n+\n+@item hwasan-instrument-mem-intrinsics\n+Enable hwasan instrumentation of builtin functions.  Instrumentation of these\n+builtin functions is enabled by default for both @option{-fsanitize=hwaddress}\n+and @option{-fsanitize=kernel-hwaddress}.\n+To disable instrumentation of builtin functions use\n+@option{--param hwasan-instrument-mem-intrinsics=0}.\n+\n @item use-after-scope-direct-emission-threshold\n If the size of a local variable in bytes is smaller or equal to this\n number, directly poison (or unpoison) shadow memory instead of using\n@@ -14391,13 +14438,47 @@ more details.  The run-time behavior can be influenced using the\n the available options are shown at startup of the instrumented program.  See\n @url{https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags}\n for a list of supported options.\n-The option cannot be combined with @option{-fsanitize=thread}.\n+The option cannot be combined with @option{-fsanitize=thread} or\n+@option{-fsanitize=hwaddress}.  Note that the only target this option is\n+currently supported on is AArch64.\n \n @item -fsanitize=kernel-address\n @opindex fsanitize=kernel-address\n Enable AddressSanitizer for Linux kernel.\n See @uref{https://github.com/google/kasan/wiki} for more details.\n \n+@item -fsanitize=hwaddress\n+@opindex fsanitize=hwaddress\n+Enable Hardware-assisted AddressSanitizer, which uses a hardware ability to\n+ignore the top byte of a pointer to allow the detection of memory errors with\n+a low memory overhead.\n+Memory access instructions are instrumented to detect out-of-bounds and\n+use-after-free bugs.\n+The option enables @option{-fsanitize-address-use-after-scope}.\n+See\n+@uref{https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html}\n+for more details.  The run-time behavior can be influenced using the\n+@env{HWASAN_OPTIONS} environment variable.  When set to @code{help=1},\n+the available options are shown at startup of the instrumented program.\n+The option cannot be combined with @option{-fsanitize=thread} or\n+@option{-fsanitize=address}, and is currently only available on AArch64.\n+\n+@item -fsanitize=kernel-hwaddress\n+@opindex fsanitize=kernel-hwaddress\n+Enable Hardware-assisted AddressSanitizer for compilation of the Linux kernel.\n+Similar to @option{-fsanitize=kernel-address} but using an alternate\n+instrumentation method, and similar to @option{-fsanitize=hwaddress} but with\n+instrumentation differences necessary for compiling the Linux kernel.\n+These differences are to avoid hwasan library initialization calls and to\n+account for the stack pointer having a different value in its top byte.\n+\n+@emph{Note:} This option has different defaults to the @option{-fsanitize=hwaddress}.\n+Instrumenting the stack and alloca calls are not on by default but are still\n+possible by specifying the command-line options\n+@option{--param hwasan-instrument-stack=1} and\n+@option{--param hwasan-instrument-allocas=1} respectively. Using a random frame\n+tag is not implemented for kernel instrumentation.\n+\n @item -fsanitize=pointer-compare\n @opindex fsanitize=pointer-compare\n Instrument comparison operation (<, <=, >, >=) with pointer operands."}, {"sha": "dda71bb89dd17830b71dfa81310b91386e343b43", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -12222,3 +12222,12 @@ This target hook can be used to generate a target-specific code\n @deftypefn {Target Hook} void TARGET_RUN_TARGET_SELFTESTS (void)\n If selftests are enabled, run any selftests for this target.\n @end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_MEMTAG_CAN_TAG_ADDRESSES ()\n+True if the backend architecture naturally supports ignoring some region\n+of pointers.  This feature means that @option{-fsanitize=hwaddress} can\n+work.\n+\n+At preset, this feature does not support address spaces.  It also requires\n+@code{Pmode} to be the same as @code{ptr_mode}.\n+@end deftypefn"}, {"sha": "8fbd36e2bf31e098f7827ce331fd7059c8a747bc", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -8184,3 +8184,5 @@ maintainer is familiar with.\n @hook TARGET_SPECULATION_SAFE_VALUE\n \n @hook TARGET_RUN_TARGET_SELFTESTS\n+\n+@hook TARGET_MEMTAG_CAN_TAG_ADDRESSES"}, {"sha": "9342bd87be303f5b5812b48fba2d10c6e1cedda3", "filename": "gcc/flag-types.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -276,6 +276,9 @@ enum sanitize_code {\n   SANITIZE_BUILTIN = 1UL << 25,\n   SANITIZE_POINTER_COMPARE = 1UL << 26,\n   SANITIZE_POINTER_SUBTRACT = 1UL << 27,\n+  SANITIZE_HWADDRESS = 1UL << 28,\n+  SANITIZE_USER_HWADDRESS = 1UL << 29,\n+  SANITIZE_KERNEL_HWADDRESS = 1UL << 30,\n   SANITIZE_SHIFT = SANITIZE_SHIFT_BASE | SANITIZE_SHIFT_EXPONENT,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN"}, {"sha": "16a6ee551de79c16c2de894f0371a11132a6f294", "filename": "gcc/gcc.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -749,6 +749,24 @@ proper position among the other output files.  */\n #define LIBASAN_EARLY_SPEC \"\"\n #endif\n \n+#ifndef LIBHWASAN_SPEC\n+#define STATIC_LIBHWASAN_LIBS \\\n+  \" %{static-libhwasan|static:%:include(libsanitizer.spec)%(link_libhwasan)}\"\n+#ifdef LIBHWASAN_EARLY_SPEC\n+#define LIBHWASAN_SPEC STATIC_LIBHWASAN_LIBS\n+#elif defined(HAVE_LD_STATIC_DYNAMIC)\n+#define LIBHWASAN_SPEC \"%{static-libhwasan:\" LD_STATIC_OPTION \\\n+\t\t     \"} -lhwasan %{static-libhwasan:\" LD_DYNAMIC_OPTION \"}\" \\\n+\t\t     STATIC_LIBHWASAN_LIBS\n+#else\n+#define LIBHWASAN_SPEC \"-lhwasan\" STATIC_LIBHWASAN_LIBS\n+#endif\n+#endif\n+\n+#ifndef LIBHWASAN_EARLY_SPEC\n+#define LIBHWASAN_EARLY_SPEC \"\"\n+#endif\n+\n #ifndef LIBTSAN_SPEC\n #define STATIC_LIBTSAN_LIBS \\\n   \" %{static-libtsan|static:%:include(libsanitizer.spec)%(link_libtsan)}\"\n@@ -1071,6 +1089,7 @@ proper position among the other output files.  */\n #ifndef SANITIZER_EARLY_SPEC\n #define SANITIZER_EARLY_SPEC \"\\\n %{!nostdlib:%{!r:%{!nodefaultlibs:%{%:sanitize(address):\" LIBASAN_EARLY_SPEC \"} \\\n+    %{%:sanitize(hwaddress):\" LIBHWASAN_EARLY_SPEC \"} \\\n     %{%:sanitize(thread):\" LIBTSAN_EARLY_SPEC \"} \\\n     %{%:sanitize(leak):\" LIBLSAN_EARLY_SPEC \"}}}}\"\n #endif\n@@ -1080,6 +1099,8 @@ proper position among the other output files.  */\n #define SANITIZER_SPEC \"\\\n %{!nostdlib:%{!r:%{!nodefaultlibs:%{%:sanitize(address):\" LIBASAN_SPEC \"\\\n     %{static:%ecannot specify -static with -fsanitize=address}}\\\n+    %{%:sanitize(hwaddress):\" LIBHWASAN_SPEC \"\\\n+\t%{static:%ecannot specify -static with -fsanitize=hwaddress}}\\\n     %{%:sanitize(thread):\" LIBTSAN_SPEC \"\\\n     %{static:%ecannot specify -static with -fsanitize=thread}}\\\n     %{%:sanitize(undefined):\" LIBUBSAN_SPEC \"}\\\n@@ -10131,8 +10152,12 @@ sanitize_spec_function (int argc, const char **argv)\n \n   if (strcmp (argv[0], \"address\") == 0)\n     return (flag_sanitize & SANITIZE_USER_ADDRESS) ? \"\" : NULL;\n+  if (strcmp (argv[0], \"hwaddress\") == 0)\n+    return (flag_sanitize & SANITIZE_USER_HWADDRESS) ? \"\" : NULL;\n   if (strcmp (argv[0], \"kernel-address\") == 0)\n     return (flag_sanitize & SANITIZE_KERNEL_ADDRESS) ? \"\" : NULL;\n+  if (strcmp (argv[0], \"kernel-hwaddress\") == 0)\n+    return (flag_sanitize & SANITIZE_KERNEL_HWADDRESS) ? \"\" : NULL;\n   if (strcmp (argv[0], \"thread\") == 0)\n     return (flag_sanitize & SANITIZE_THREAD) ? \"\" : NULL;\n   if (strcmp (argv[0], \"undefined\") == 0)"}, {"sha": "cc1d0cc04f64133a22bac464732fd9b7fd8b5858", "filename": "gcc/opts.c", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -823,6 +823,57 @@ control_options_for_live_patching (struct gcc_options *opts,\n /* --help option argument if set.  */\n vec<const char *> help_option_arguments;\n \n+/* Return the string name describing a sanitizer argument which has been\n+   provided on the command line and has set this particular flag.  */\n+const char *\n+find_sanitizer_argument (struct gcc_options *opts, unsigned int flags)\n+{\n+  for (int i = 0; sanitizer_opts[i].name != NULL; ++i)\n+    {\n+      /* Need to find the sanitizer_opts element which:\n+\t a) Could have set the flags requested.\n+\t b) Has been set on the command line.\n+\n+\t Can have (a) without (b) if the flag requested is e.g.\n+\t SANITIZE_ADDRESS, since both -fsanitize=address and\n+\t -fsanitize=kernel-address set this flag.\n+\n+\t Can have (b) without (a) by requesting more than one sanitizer on the\n+\t command line.  */\n+      if ((sanitizer_opts[i].flag & opts->x_flag_sanitize)\n+\t  != sanitizer_opts[i].flag)\n+\tcontinue;\n+      if ((sanitizer_opts[i].flag & flags) != flags)\n+\tcontinue;\n+      return sanitizer_opts[i].name;\n+    }\n+  return NULL;\n+}\n+\n+\n+/* Report an error to the user about sanitizer options they have requested\n+   which have set conflicting flags.\n+\n+   LEFT and RIGHT indicate sanitizer flags which conflict with each other, this\n+   function reports an error if both have been set in OPTS->x_flag_sanitize and\n+   ensures the error identifies the requested command line options that have\n+   set these flags.  */\n+static void\n+report_conflicting_sanitizer_options (struct gcc_options *opts, location_t loc,\n+\t\t\t\t      unsigned int left, unsigned int right)\n+{\n+  unsigned int left_seen = (opts->x_flag_sanitize & left);\n+  unsigned int right_seen = (opts->x_flag_sanitize & right);\n+  if (left_seen && right_seen)\n+    {\n+      const char* left_arg = find_sanitizer_argument (opts, left_seen);\n+      const char* right_arg = find_sanitizer_argument (opts, right_seen);\n+      gcc_assert (left_arg && right_arg);\n+      error_at (loc,\n+\t\t\"%<-fsanitize=%s%> is incompatible with %<-fsanitize=%s%>\",\n+\t\tleft_arg, right_arg);\n+    }\n+}\n \n /* After all options at LOC have been read into OPTS and OPTS_SET,\n    finalize settings of those options and diagnose incompatible\n@@ -1074,22 +1125,22 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\t  \"%<-fsanitize=address%> or %<-fsanitize=kernel-address%>\");\n     }\n \n-  /* Userspace and kernel ASan conflict with each other.  */\n-  if ((opts->x_flag_sanitize & SANITIZE_USER_ADDRESS)\n-      && (opts->x_flag_sanitize & SANITIZE_KERNEL_ADDRESS))\n-    error_at (loc, \"%qs is incompatible with %qs\",\n-\t      \"-fsanitize=address\", \"-fsanitize=kernel-address\");\n+  /* Address sanitizers conflict with the thread sanitizer.  */\n+  report_conflicting_sanitizer_options (opts, loc, SANITIZE_THREAD,\n+\t\t\t\t\tSANITIZE_ADDRESS | SANITIZE_HWADDRESS);\n+  /* The leak sanitizer conflicts with the thread sanitizer.  */\n+  report_conflicting_sanitizer_options (opts, loc, SANITIZE_LEAK,\n+\t\t\t\t\tSANITIZE_THREAD);\n \n-  /* And with TSan.  */\n-  if ((opts->x_flag_sanitize & SANITIZE_ADDRESS)\n-      && (opts->x_flag_sanitize & SANITIZE_THREAD))\n-    error_at (loc, \"%qs is incompatible with %qs\",\n-\t      \"-fsanitize=thread\", \"-fsanitize=address|kernel-address\");\n+  /* No combination of HWASAN and ASAN work together.  */\n+  report_conflicting_sanitizer_options (opts, loc,\n+\t\t\t\t\tSANITIZE_HWADDRESS, SANITIZE_ADDRESS);\n \n-  if ((opts->x_flag_sanitize & SANITIZE_LEAK)\n-      && (opts->x_flag_sanitize & SANITIZE_THREAD))\n-    error_at (loc, \"%qs is incompatible with %qs\",\n-\t      \"-fsanitize=leak\", \"-fsanitize=thread\");\n+  /* The userspace and kernel address sanitizers conflict with each other.  */\n+  report_conflicting_sanitizer_options (opts, loc, SANITIZE_USER_HWADDRESS,\n+\t\t\t\t\tSANITIZE_KERNEL_HWADDRESS);\n+  report_conflicting_sanitizer_options (opts, loc, SANITIZE_USER_ADDRESS,\n+\t\t\t\t\tSANITIZE_KERNEL_ADDRESS);\n \n   /* Check error recovery for -fsanitize-recover option.  */\n   for (int i = 0; sanitizer_opts[i].name != NULL; ++i)\n@@ -1108,9 +1159,10 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n   if (opts->x_flag_sanitize & ~(SANITIZE_LEAK | SANITIZE_UNREACHABLE))\n     opts->x_flag_aggressive_loop_optimizations = 0;\n \n-  /* Enable -fsanitize-address-use-after-scope if address sanitizer is\n+  /* Enable -fsanitize-address-use-after-scope if either address sanitizer is\n      enabled.  */\n-  if (opts->x_flag_sanitize & SANITIZE_USER_ADDRESS)\n+  if (opts->x_flag_sanitize\n+      & (SANITIZE_USER_ADDRESS | SANITIZE_USER_HWADDRESS))\n     SET_OPTION_IF_UNSET (opts, opts_set, flag_sanitize_address_use_after_scope,\n \t\t\t true);\n \n@@ -1724,8 +1776,13 @@ const struct sanitizer_opts_s sanitizer_opts[] =\n #define SANITIZER_OPT(name, flags, recover) \\\n     { #name, flags, sizeof #name - 1, recover }\n   SANITIZER_OPT (address, (SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS), true),\n+  SANITIZER_OPT (hwaddress, (SANITIZE_HWADDRESS | SANITIZE_USER_HWADDRESS),\n+\t\t true),\n   SANITIZER_OPT (kernel-address, (SANITIZE_ADDRESS | SANITIZE_KERNEL_ADDRESS),\n \t\t true),\n+  SANITIZER_OPT (kernel-hwaddress,\n+\t\t (SANITIZE_HWADDRESS | SANITIZE_KERNEL_HWADDRESS),\n+\t\t true),\n   SANITIZER_OPT (pointer-compare, SANITIZE_POINTER_COMPARE, true),\n   SANITIZER_OPT (pointer-subtract, SANITIZE_POINTER_SUBTRACT, true),\n   SANITIZER_OPT (thread, SANITIZE_THREAD, false),\n@@ -2304,6 +2361,15 @@ common_handle_option (struct gcc_options *opts,\n \t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_protect_allocas, 0);\n \t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_use_after_return, 0);\n \t}\n+      if (opts->x_flag_sanitize & SANITIZE_KERNEL_HWADDRESS)\n+\t{\n+\t  SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t\t       param_hwasan_instrument_stack, 0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t\t       param_hwasan_random_frame_tag, 0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t\t       param_hwasan_instrument_allocas, 0);\n+\t}\n       break;\n \n     case OPT_fsanitize_recover_:"}, {"sha": "ec15357bc273fff63e9a420f02631fc78c4cfdb8", "filename": "gcc/params.opt", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -62,6 +62,30 @@ Enable asan stack protection.\n Common Joined UInteger Var(param_asan_use_after_return) Init(1) IntegerRange(0, 1) Param Optimization\n Enable asan detection of use-after-return bugs.\n \n+-param=hwasan-instrument-stack=\n+Common Joined UInteger Var(param_hwasan_instrument_stack) Init(1) IntegerRange(0, 1) Param Optimization\n+Enable hwasan instrumentation of statically sized stack-allocated variables.\n+\n+-param=hwasan-random-frame-tag=\n+Common Joined UInteger Var(param_hwasan_random_frame_tag) Init(1) IntegerRange(0, 1) Param Optimization\n+Use random base tag for each frame, as opposed to base always zero.\n+\n+-param=hwasan-instrument-allocas=\n+Common Joined UInteger Var(param_hwasan_instrument_allocas) Init(1) IntegerRange(0, 1) Param Optimization\n+Enable hwasan instrumentation of allocas/VLAs.\n+\n+-param=hwasan-instrument-reads=\n+Common Joined UInteger Var(param_hwasan_instrument_reads) Init(1) IntegerRange(0, 1) Param Optimization\n+Enable hwasan instrumentation of load operations.\n+\n+-param=hwasan-instrument-writes=\n+Common Joined UInteger Var(param_hwasan_instrument_writes) Init(1) IntegerRange(0, 1) Param Optimization\n+Enable hwasan instrumentation of store operations.\n+\n+-param=hwasan-instrument-mem-intrinsics=\n+Common Joined UInteger Var(param_hwasan_instrument_mem_intrinsics) Init(1) IntegerRange(0, 1) Param Optimization\n+Enable hwasan instrumentation of builtin functions.\n+\n -param=avg-loop-niter=\n Common Joined UInteger Var(param_avg_loop_niter) Init(10) IntegerRange(1, 65536) Param Optimization\n Average number of iterations of a loop."}, {"sha": "31e33ecc9a5772cd22976faa59b425c049c1801a", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -6862,6 +6862,21 @@ DEFHOOK\n \n HOOK_VECTOR_END (mode_switching)\n \n+#undef HOOK_PREFIX\n+#define HOOK_PREFIX \"TARGET_MEMTAG_\"\n+HOOK_VECTOR (TARGET_MEMTAG_, memtag)\n+\n+DEFHOOK\n+(can_tag_addresses,\n+ \"True if the backend architecture naturally supports ignoring some region\\n\\\n+of pointers.  This feature means that @option{-fsanitize=hwaddress} can\\n\\\n+work.\\n\\\n+\\n\\\n+At preset, this feature does not support address spaces.  It also requires\\n\\\n+@code{Pmode} to be the same as @code{ptr_mode}.\",\n+ bool, (), default_memtag_can_tag_addresses)\n+\n+HOOK_VECTOR_END (memtag)\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_\"\n "}, {"sha": "46cb536041d396c32fd08042581d6d5cd5ad0395", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -2415,4 +2415,10 @@ default_speculation_safe_value (machine_mode mode ATTRIBUTE_UNUSED,\n   return result;\n }\n \n+bool\n+default_memtag_can_tag_addresses ()\n+{\n+  return false;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "0065c686978d7120978430013c73b1055aaf95c7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -286,4 +286,5 @@ extern bool default_have_speculation_safe_value (bool);\n extern bool speculation_safe_value_not_needed (bool);\n extern rtx default_speculation_safe_value (machine_mode, rtx, rtx, rtx);\n \n+extern bool default_memtag_can_tag_addresses ();\n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "2a3e7c064a5fbb6913481104975ca85615e49f8e", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd8783207760cc805d8a4e64e5ac92ca508a711/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3bd8783207760cc805d8a4e64e5ac92ca508a711", "patch": "@@ -1853,6 +1853,15 @@ process_options (void)\n       flag_sanitize &= ~SANITIZE_ADDRESS;\n     }\n \n+  /* HWAsan requires top byte ignore feature in the backend.  */\n+  if (flag_sanitize & SANITIZE_HWADDRESS\n+      && ! targetm.memtag.can_tag_addresses ())\n+    {\n+      warning_at (UNKNOWN_LOCATION, 0, \"%qs is not supported for this target\",\n+\t\t  \"-fsanitize=hwaddress\");\n+      flag_sanitize &= ~SANITIZE_HWADDRESS;\n+    }\n+\n  /* Do not use IPA optimizations for register allocation if profiler is active\n     or patchable function entries are inserted for run-time instrumentation\n     or port does not emit prologue and epilogue as RTL.  */"}]}