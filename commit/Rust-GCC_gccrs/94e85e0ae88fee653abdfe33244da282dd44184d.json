{"sha": "94e85e0ae88fee653abdfe33244da282dd44184d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlODVlMGFlODhmZWU2NTNhYmRmZTMzMjQ0ZGEyODJkZDQ0MTg0ZA==", "commit": {"author": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-04-20T17:00:37Z"}, "committer": {"name": "Xinliang David Li", "email": "davidxl@gcc.gnu.org", "date": "2010-04-20T17:00:37Z"}, "message": "new folding rule\n\nFrom-SVN: r158567", "tree": {"sha": "cfb7472bcd31a0ac649da7ca0ba1431b1f0ee0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb7472bcd31a0ac649da7ca0ba1431b1f0ee0ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e85e0ae88fee653abdfe33244da282dd44184d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e85e0ae88fee653abdfe33244da282dd44184d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e85e0ae88fee653abdfe33244da282dd44184d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e85e0ae88fee653abdfe33244da282dd44184d/comments", "author": null, "committer": null, "parents": [{"sha": "54fb1ae03e7eda76d322545955cd128412887d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54fb1ae03e7eda76d322545955cd128412887d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54fb1ae03e7eda76d322545955cd128412887d23"}], "stats": {"total": 65, "additions": 63, "deletions": 2}, "files": [{"sha": "687bde182bf2a37efa34e70650d14e23042d43e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94e85e0ae88fee653abdfe33244da282dd44184d", "patch": "@@ -1,3 +1,8 @@\n+2010-04-20  Xinliang David Li  <davidxl@gcc.gnu.org>\n+\n+\tPR middle-end/41952\n+\t* fold-const.c (fold_comparison): New folding rule. \n+\n 2010-04-20  Anatoly Sokolov  <aesok@post.ru\n \n \t* double-int.h (double_int_setbit): Declare."}, {"sha": "cdae661733c5b4e59e93745e3529e08b5325e255", "filename": "gcc/fold-const.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=94e85e0ae88fee653abdfe33244da282dd44184d", "patch": "@@ -8643,9 +8643,33 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  offset1 = TREE_OPERAND (arg1, 1);\n \t}\n \n+      /* A local variable can never be pointed to by\n+         the default SSA name of an incoming parameter.  */\n+      if ((TREE_CODE (arg0) == ADDR_EXPR\n+           && indirect_base0\n+           && TREE_CODE (base0) == VAR_DECL\n+           && auto_var_in_fn_p (base0, current_function_decl)\n+           && !indirect_base1\n+           && TREE_CODE (base1) == SSA_NAME\n+           && TREE_CODE (SSA_NAME_VAR (base1)) == PARM_DECL\n+           && SSA_NAME_IS_DEFAULT_DEF (base1))\n+          || (TREE_CODE (arg1) == ADDR_EXPR\n+              && indirect_base1\n+              && TREE_CODE (base1) == VAR_DECL\n+              && auto_var_in_fn_p (base1, current_function_decl)\n+              && !indirect_base0\n+              && TREE_CODE (base0) == SSA_NAME\n+              && TREE_CODE (SSA_NAME_VAR (base0)) == PARM_DECL\n+              && SSA_NAME_IS_DEFAULT_DEF (base0)))\n+        {\n+          if (code == NE_EXPR)\n+            return constant_boolean_node (1, type);\n+          else if (code == EQ_EXPR)\n+            return constant_boolean_node (0, type);\n+        }\n       /* If we have equivalent bases we might be able to simplify.  */\n-      if (indirect_base0 == indirect_base1\n-\t  && operand_equal_p (base0, base1, 0))\n+      else if (indirect_base0 == indirect_base1\n+               && operand_equal_p (base0, base1, 0))\n \t{\n \t  /* We can fold this expression to a constant if the non-constant\n \t     offset parts are equal.  */"}, {"sha": "6d9cb8b2de385161b36ca1772121fd732b6355f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94e85e0ae88fee653abdfe33244da282dd44184d", "patch": "@@ -1,3 +1,7 @@\n+2010-04-20  Xinliang David Li  <davidxl@google.com>\n+\n+\t* g++.dg/tree-ssa/fold-compare.C: New.\n+\n 2010-04-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/39417"}, {"sha": "2b4c41103baf2d62dd393ecef9de933264c73e45", "filename": "gcc/testsuite/g++.dg/tree-ssa/fold-compare.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffold-compare.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e85e0ae88fee653abdfe33244da282dd44184d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffold-compare.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ffold-compare.C?ref=94e85e0ae88fee653abdfe33244da282dd44184d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+struct ExtentsBase {\n+ ExtentsBase() : startx_(), endx_() { }\n+ ExtentsBase(const ExtentsBase &b) {\n+  *this = b;\n+ }\n+\n+ const ExtentsBase & operator=(const ExtentsBase &b) {\n+  if (this != &b) {\n+    startx_ = b.startx_;\n+  }\n+  return *this;\n+ }\n+\n+ int startx_;\n+  int endx_;\n+};\n+\n+int f(const ExtentsBase &e1) {\n+ ExtentsBase my_extents = e1;\n+ return my_extents.startx_;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"&my_extents\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+"}]}