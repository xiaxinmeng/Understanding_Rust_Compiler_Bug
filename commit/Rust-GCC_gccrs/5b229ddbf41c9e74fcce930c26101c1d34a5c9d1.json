{"sha": "5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyMjlkZGJmNDFjOWU3NGZjY2U5MzBjMjYxMDFjMWQzNGE1YzlkMQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-08-14T21:38:11Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-08-16T21:30:49Z"}, "message": "Use builtin bool instead of creating new bool types for ComparisonExpr\n\nThe TypeCheckExpr creates a new TyTy::BoolType for a\nComparisonExpr. This new BoolType is unknown to TyTyResolveCompile\nwhich causes a crash when trying to compile the inferred new\nBoolType. Resolve this by looking up the builtin bool type.\nThe new \"bools_eq.rs\" testcase uses several bools which show\nthis issue.\n\nAlso the lhs and rhs types need to be compatible, but don't\nneed to be bool type themselves. So don't append the reference\nto the inferred type. The existing \"ifunaryexpr.rs\" testcase\nwill fail without this fix.", "tree": {"sha": "43d75121ca9c9b69b3baf9ca04271d39b73e3b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43d75121ca9c9b69b3baf9ca04271d39b73e3b0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1/comments", "author": null, "committer": null, "parents": [{"sha": "52c1cdc9c63baeb090680daf6762c02362f2c6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c1cdc9c63baeb090680daf6762c02362f2c6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c1cdc9c63baeb090680daf6762c02362f2c6cd"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "a833822e9b3d111078f19b8751f5376d6d9f4b4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "patch": "@@ -630,10 +630,8 @@ class TypeCheckExpr : public TypeCheckBase\n     if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n-    // we expect this to be\n-    infered = new TyTy::BoolType (expr.get_mappings ().get_hirid ());\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n+    bool ok = context->lookup_builtin (\"bool\", &infered);\n+    rust_assert (ok);\n   }\n \n   void visit (HIR::LazyBooleanExpr &expr) override"}, {"sha": "965127b5d542d1dec031872b72d3215de951f7b6", "filename": "gcc/testsuite/rust/compile/torture/bools_eq.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbools_eq.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b229ddbf41c9e74fcce930c26101c1d34a5c9d1/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbools_eq.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbools_eq.rs?ref=5b229ddbf41c9e74fcce930c26101c1d34a5c9d1", "patch": "@@ -0,0 +1,18 @@\n+extern \"C\"\n+{\n+  fn abort ();\n+}\n+\n+fn beq (a: bool, b: bool) -> bool\n+{\n+  let bools_eq = a == b;\n+  bools_eq\n+}\n+\n+pub fn main ()\n+{\n+  let a = true;\n+  let b = false;\n+  let r = beq (a, b);\n+  if r { unsafe { abort (); } }\n+}"}]}