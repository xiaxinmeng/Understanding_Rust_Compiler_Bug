{"sha": "f353609778d9079592f24a6abcad0ae21e78b7e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1MzYwOTc3OGQ5MDc5NTkyZjI0YTZhYmNhZDBhZTIxZTc4YjdlMw==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2009-06-03T09:36:50Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-06-03T09:36:50Z"}, "message": "predicates.md: Use REG_P...\n\n2009-06-03  Shujing Zhao  <pearly.zhao@oracle.com>\n\n\t* config/sh/predicates.md: Use REG_P, MEM_P, CONST_INT_P, LABEL_P,\n\tJUMP_P, CALL_P, NONJUMP_INSN_P, NOTE_P, BARRIER_P and\n\tJUMP_TABLE_DATA_P where applicable.\n\t* config/sh/sh.c: Ditto.\n\t* config/sh/sh.h: Ditto.\n\t* config/sh/sh.md: Ditto.\n\t* config/sh/symbian.c: Ditto.\n\nFrom-SVN: r148119", "tree": {"sha": "345765caae66bec5e7ba10b783743411dbd7d2e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/345765caae66bec5e7ba10b783743411dbd7d2e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f353609778d9079592f24a6abcad0ae21e78b7e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f353609778d9079592f24a6abcad0ae21e78b7e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f353609778d9079592f24a6abcad0ae21e78b7e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f353609778d9079592f24a6abcad0ae21e78b7e3/comments", "author": null, "committer": null, "parents": [{"sha": "d6ced3b79dc8da841fbb5e475b0bfbfb7fcc7116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ced3b79dc8da841fbb5e475b0bfbfb7fcc7116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ced3b79dc8da841fbb5e475b0bfbfb7fcc7116"}], "stats": {"total": 502, "additions": 250, "deletions": 252}, "files": [{"sha": "3295f64865e22803077430868805010555b5b4f6", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=f353609778d9079592f24a6abcad0ae21e78b7e3", "patch": "@@ -29,7 +29,7 @@\n   cond = XEXP (op, 0);\n   mem = XEXP (op, 1);\n   res = XEXP (op, 2);\n-  if (GET_CODE (mem) != MEM\n+  if (!MEM_P (mem)\n       || (GET_CODE (res) != SIGN_EXTEND && GET_CODE (res) != TRUNCATE))\n     return 0;\n   tar = XEXP (res, 0);\n@@ -52,8 +52,8 @@\n   and = XEXP (cond, 0);\n   return (GET_CODE (and) == AND\n \t  && rtx_equal_p (XEXP (and, 0), tar)\n-\t  && GET_CODE (XEXP (and, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (cond, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (and, 1))\n+\t  && CONST_INT_P (XEXP (cond, 1))\n \t  && INTVAL (XEXP (and, 1)) == 3\n \t  && INTVAL (XEXP (cond, 1)) == 3);\n })\n@@ -108,11 +108,11 @@\n \t attempting to transform a sequence of two 64-bit sets of the\n \t same register from literal constants into a set and an add,\n \t when the difference is too wide for an add.  */\n-      if (GET_CODE (op) == CONST_INT\n+      if (CONST_INT_P (op)\n \t  || satisfies_constraint_Css (op))\n \treturn 1;\n       else if (GET_CODE (op) == TRUNCATE\n-\t       && GET_CODE (XEXP (op, 0)) == REG\n+\t       && REG_P (XEXP (op, 0))\n \t       && ! system_reg_operand (XEXP (op, 0), VOIDmode)\n \t       && (mode == VOIDmode || mode == GET_MODE (op))\n \t       && (GET_MODE_SIZE (GET_MODE (op))\n@@ -152,9 +152,9 @@\n     {\n       int regno;\n \n-      if (GET_CODE (op) == REG)\n+      if (REG_P (op))\n \tregno = REGNO (op);\n-      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n \tregno = REGNO (SUBREG_REG (op));\n       else\n \treturn 1;\n@@ -175,7 +175,7 @@\n #if 0 /* Can't do this because of PROMOTE_MODE for unsigned vars.  */\n   if (GET_MODE (op) == SImode && GET_CODE (op) == SIGN_EXTEND\n       && GET_MODE (XEXP (op, 0)) == HImode\n-      && GET_CODE (XEXP (op, 0)) == REG\n+      && REG_P (XEXP (op, 0))\n       && REGNO (XEXP (op, 0)) <= LAST_GENERAL_REG)\n     return register_operand (XEXP (op, 0), VOIDmode);\n #endif\n@@ -223,13 +223,13 @@\n {\n   if (GET_CODE (op) == PLUS)\n     {\n-      if (GET_CODE (XEXP (op, 0)) != REG)\n+      if (!REG_P (XEXP (op, 0)))\n \treturn 0;\n-      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+      if (!CONST_INT_P (XEXP (op, 1))\n \t  || (INTVAL (XEXP (op, 1)) & 31))\n \treturn 0;\n     }\n-  else if (GET_CODE (op) != REG)\n+  else if (!REG_P (op))\n     return 0;\n   return address_operand (op, mode);\n })\n@@ -253,7 +253,7 @@\n (define_predicate \"cmpsi_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n-  if (GET_CODE (op) == REG && REGNO (op) == T_REG\n+  if (REG_P (op) && REGNO (op) == T_REG\n       && GET_MODE (op) == SImode\n       && TARGET_SH1)\n     return 1;\n@@ -319,9 +319,9 @@\n     {\n       int regno;\n \n-      if (GET_CODE (op) == REG)\n+      if (REG_P (op))\n \tregno = REGNO (op);\n-      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+      else if (GET_CODE (op) == SUBREG && REG_P (SUBREG_REG (op)))\n \tregno = REGNO (SUBREG_REG (op));\n       else\n \treturn 1;\n@@ -337,7 +337,7 @@\n (define_predicate \"fpscr_operand\"\n   (match_code \"reg\")\n {\n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) == FPSCR_REG\n \t      || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t\t  && !(reload_in_progress || reload_completed)))\n@@ -352,7 +352,7 @@\n   if (TARGET_SHMEDIA)\n     return fp_arith_reg_operand (op, mode);\n \n-  return (GET_CODE (op) == REG\n+  return (REG_P (op)\n \t  && (REGNO (op) == FPUL_REG || REGNO (op) >= FIRST_PSEUDO_REGISTER)\n \t  && GET_MODE (op) == mode);\n })\n@@ -374,7 +374,7 @@\n (define_predicate \"general_movsrc_operand\"\n   (match_code \"subreg,reg,const_int,const_double,mem,symbol_ref,label_ref,const,const_vector\")\n {\n-  if (GET_CODE (op) == MEM)\n+  if (MEM_P (op))\n     {\n       rtx inside = XEXP (op, 0);\n       if (GET_CODE (inside) == CONST)\n@@ -385,7 +385,7 @@\n \n       if (GET_CODE (inside) == PLUS\n \t  && GET_CODE (XEXP (inside, 0)) == LABEL_REF\n-\t  && GET_CODE (XEXP (inside, 1)) == CONST_INT)\n+\t  && CONST_INT_P (XEXP (inside, 1)))\n \treturn 1;\n \n       /* Only post inc allowed.  */\n@@ -411,7 +411,7 @@\n   (match_code \"subreg,reg,mem\")\n {\n   /* Only pre dec allowed.  */\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n+  if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC)\n     return 0;\n   if (mode == DImode && TARGET_SHMEDIA && GET_CODE (op) == SUBREG\n       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8\n@@ -428,15 +428,15 @@\n {\n   rtx inside;\n \n-  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n+  if (!MEM_P (op) || GET_MODE (op) != mode)\n     return 0;\n \n   inside = XEXP (op, 0);\n \n   if (GET_CODE (inside) == POST_INC)\n     inside = XEXP (inside, 0);\n \n-  if (GET_CODE (inside) == REG)\n+  if (REG_P (inside))\n     return 1;\n \n   return 0;\n@@ -457,7 +457,7 @@\n   op = XEXP (op, 0);\n   /* Can't use true_regnum here because copy_cost wants to know about\n      SECONDARY_INPUT_RELOAD_CLASS.  */\n-  return GET_CODE (op) == REG && FP_REGISTER_P (REGNO (op));\n+  return REG_P (op) && FP_REGISTER_P (REGNO (op));\n })\n \n ;; TODO: Add a comment here.\n@@ -532,7 +532,7 @@\n {\n   HOST_WIDE_INT i;\n \n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   i = INTVAL (op);\n   return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n@@ -575,7 +575,7 @@\n     return 0;\n   i = XVECLEN (op, 0) - 1;\n   for (; i >= 0; i--)\n-    if (GET_CODE (XVECEXP (op, 0, i)) != CONST_INT)\n+    if (!CONST_INT_P (XVECEXP (op, 0, i)))\n       return 0;\n   return 1;\n })\n@@ -597,12 +597,12 @@\n   /* Determine numbers of last and of least significant elements.  */\n   last = XVECLEN (op, 0) - 1;\n   least = TARGET_LITTLE_ENDIAN ? 0 : last;\n-  if (GET_CODE (XVECEXP (op, 0, least)) != CONST_INT)\n+  if (!CONST_INT_P (XVECEXP (op, 0, least)))\n     return 0;\n   sign_ix = least;\n   if (GET_MODE_UNIT_SIZE (mode) == 1)\n     sign_ix = TARGET_LITTLE_ENDIAN ? 1 : last - 1;\n-  if (GET_CODE (XVECEXP (op, 0, sign_ix)) != CONST_INT)\n+  if (!CONST_INT_P (XVECEXP (op, 0, sign_ix)))\n     return 0;\n   unit_size = GET_MODE_UNIT_SIZE (GET_MODE (op));\n   sign = (INTVAL (XVECEXP (op, 0, sign_ix)) >> (unit_size * BITS_PER_UNIT - 1)\n@@ -660,7 +660,7 @@\n   (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,zero_extend,sign_extend\")\n {\n   return (CONSTANT_P (op)\n-\t  ? (GET_CODE (op) == CONST_INT\n+\t  ? (CONST_INT_P (op)\n \t     ? (unsigned) INTVAL (op) < GET_MODE_BITSIZE (mode)\n \t     : nonmemory_operand (op, mode))\n \t  : shift_count_reg_operand (op, mode));\n@@ -728,7 +728,7 @@\n   if (GET_CODE (op) == SUBREG)\n     op = XEXP (op, 0);\n \n-  if (GET_CODE (op) != REG)\n+  if (!REG_P (op))\n     return 0;\n \n   /* We must protect ourselves from matching pseudos that are virtual\n@@ -784,7 +784,7 @@\n (define_predicate \"xor_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n-  if (GET_CODE (op) == CONST_INT)\n+  if (CONST_INT_P (op))\n     return (TARGET_SHMEDIA\n \t    ? (satisfies_constraint_I06 (op)\n \t       || (!can_create_pseudo_p () && INTVAL (op) == 0xff))\n@@ -799,13 +799,13 @@\n (define_predicate \"bitwise_memory_operand\"\n   (match_code \"mem\")\n {\n-  if (GET_CODE (op) == MEM)\n+  if (MEM_P (op))\n     {\n       if (REG_P (XEXP (op, 0)))\n \treturn 1;\n \n       if (GET_CODE (XEXP (op, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+\t  && REG_P (XEXP (XEXP (op, 0), 0))\n \t  && satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1)))\n         return 1;\n     }"}, {"sha": "06d10710a3fd1cfba0a8a631a7d6eee7c65d3030", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 131, "deletions": 133, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f353609778d9079592f24a6abcad0ae21e78b7e3", "patch": "@@ -829,7 +829,7 @@ print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     case 't':\n-      gcc_assert (GET_CODE (x) == MEM);\n+      gcc_assert (MEM_P (x));\n       x = XEXP (x, 0);\n       switch (GET_CODE (x))\n \t{\n@@ -862,15 +862,15 @@ print_operand (FILE *stream, rtx x, int code)\n     case 'M':\n       if (TARGET_SHMEDIA)\n \t{\n-\t  if (GET_CODE (x) == MEM\n+\t  if (MEM_P (x)\n \t      && GET_CODE (XEXP (x, 0)) == PLUS\n-\t      && (GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n+\t      && (REG_P (XEXP (XEXP (x, 0), 1))\n \t\t  || GET_CODE (XEXP (XEXP (x, 0), 1)) == SUBREG))\n \t    fputc ('x', stream);\n \t}\n       else\n \t{\n-\t  if (GET_CODE (x) == MEM)\n+\t  if (MEM_P (x))\n \t    {\n \t      switch (GET_MODE (x))\n \t\t{\n@@ -886,7 +886,7 @@ print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     case 'm':\n-      gcc_assert (GET_CODE (x) == MEM);\n+      gcc_assert (MEM_P (x));\n       x = XEXP (x, 0);\n       /* Fall through.  */\n     case 'U':\n@@ -926,7 +926,7 @@ print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     case 'd':\n-      gcc_assert (GET_CODE (x) == REG && GET_MODE (x) == V2SFmode);\n+      gcc_assert (REG_P (x) && GET_MODE (x) == V2SFmode);\n \n       fprintf ((stream), \"d%s\", reg_names[REGNO (x)] + 1);\n       break;\n@@ -939,7 +939,7 @@ print_operand (FILE *stream, rtx x, int code)\n \t}\n       goto default_output;\n     case 'u':\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \t{\n \t  fprintf ((stream), \"%u\", (unsigned) INTVAL (x) & (0x10000 - 1));\n \t  break;\n@@ -965,7 +965,7 @@ print_operand (FILE *stream, rtx x, int code)\n \t\t    == GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner))))\n \t\t&& subreg_lowpart_p (inner))\n \t      inner = SUBREG_REG (inner);\n-\t    if (GET_CODE (inner) == CONST_INT)\n+\t    if (CONST_INT_P (inner))\n \t      {\n \t\tx = GEN_INT (trunc_int_for_mode (INTVAL (inner), GET_MODE (x)));\n \t\tgoto default_output;\n@@ -974,15 +974,15 @@ print_operand (FILE *stream, rtx x, int code)\n \t    if (GET_CODE (inner) == SUBREG\n \t\t&& (GET_MODE_SIZE (GET_MODE (inner))\n \t\t    < GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner))))\n-\t\t&& GET_CODE (SUBREG_REG (inner)) == REG)\n+\t\t&& REG_P (SUBREG_REG (inner)))\n \t      {\n \t\toffset = subreg_regno_offset (REGNO (SUBREG_REG (inner)),\n \t\t\t\t\t      GET_MODE (SUBREG_REG (inner)),\n \t\t\t\t\t      SUBREG_BYTE (inner),\n \t\t\t\t\t      GET_MODE (inner));\n \t\tinner = SUBREG_REG (inner);\n \t      }\n-\t    if (GET_CODE (inner) != REG || GET_MODE_SIZE (inner_mode) > 8)\n+\t    if (!REG_P (inner) || GET_MODE_SIZE (inner_mode) > 8)\n \t      abort ();\n \t    /* Floating point register pairs are always big endian;\n \t       general purpose registers are 64 bit wide.  */\n@@ -1007,7 +1007,7 @@ print_operand (FILE *stream, rtx x, int code)\n \t  goto default_output;\n \tcase SUBREG:\n \t  gcc_assert (SUBREG_BYTE (x) == 0\n-\t\t      && GET_CODE (SUBREG_REG (x)) == REG);\n+\t\t      && REG_P (SUBREG_REG (x)));\n \n \t  x = SUBREG_REG (x);\n \t  /* Fall through.  */\n@@ -1021,7 +1021,7 @@ print_operand (FILE *stream, rtx x, int code)\n \t  else if (FP_REGISTER_P (REGNO (x))\n \t\t   && mode == V4SFmode)\n \t    fprintf ((stream), \"fv%s\", reg_names[regno] + 2);\n-\t  else if (GET_CODE (x) == REG\n+\t  else if (REG_P (x)\n \t\t   && mode == V2SFmode)\n \t    fprintf ((stream), \"fp%s\", reg_names[regno] + 2);\n \t  else if (FP_REGISTER_P (REGNO (x))\n@@ -1078,7 +1078,7 @@ int\n expand_block_move (rtx *operands)\n {\n   int align = INTVAL (operands[3]);\n-  int constp = (GET_CODE (operands[2]) == CONST_INT);\n+  int constp = (CONST_INT_P (operands[2]));\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n \n   if (! constp)\n@@ -1224,7 +1224,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n       rtx temp;\n       if (SYMBOLIC_CONST_P (operands[1]))\n \t{\n-\t  if (GET_CODE (operands[0]) == MEM)\n+\t  if (MEM_P (operands[0]))\n \t    operands[1] = force_reg (Pmode, operands[1]);\n \t  else if (TARGET_SHMEDIA\n \t\t   && GET_CODE (operands[1]) == LABEL_REF\n@@ -1261,7 +1261,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t  && ! sh_register_operand (operands[1], mode))\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n \n-      if (GET_CODE (operands[0]) == MEM && ! memory_operand (operands[0], mode))\n+      if (MEM_P (operands[0]) && ! memory_operand (operands[0], mode))\n \t{\n \t  /* This is like change_address_1 (operands[0], mode, 0, 1) ,\n \t     except that we can't use that function because it is static.  */\n@@ -1276,9 +1276,9 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t being used for the source.  */\n       else if (TARGET_SH1\n \t       && refers_to_regno_p (R0_REG, R0_REG + 1, operands[1], (rtx *)0)\n-\t       && GET_CODE (operands[0]) == MEM\n+\t       && MEM_P (operands[0])\n \t       && GET_CODE (XEXP (operands[0], 0)) == PLUS\n-\t       && GET_CODE (XEXP (XEXP (operands[0], 0), 1)) == REG)\n+\t       && REG_P (XEXP (XEXP (operands[0], 0), 1)))\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n \n@@ -1384,16 +1384,16 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n     comparison = GET_CODE (operands[0]);\n   else\n     scratch = operands[4];\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && GET_CODE (operands[2]) != CONST_INT)\n+  if (CONST_INT_P (operands[1])\n+      && !CONST_INT_P (operands[2]))\n     {\n       rtx tmp = operands[1];\n \n       operands[1] = operands[2];\n       operands[2] = tmp;\n       comparison = swap_condition (comparison);\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n       HOST_WIDE_INT val = INTVAL (operands[2]);\n       if ((val == -1 || val == -0x81)\n@@ -1444,7 +1444,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n      allocated to a different hard register, thus we load the constant into\n      a register unless it is zero.  */\n   if (!REG_P (operands[2])\n-      && (GET_CODE (operands[2]) != CONST_INT\n+      && (!CONST_INT_P (operands[2])\n \t  || (mode == SImode && operands[2] != CONST0_RTX (SImode)\n \t      && ((comparison != EQ && comparison != NE)\n \t\t  || (REG_P (op1) && REGNO (op1) != R0_REG)\n@@ -1569,7 +1569,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n       break;\n     case GTU: case GT:\n       msw_taken = comparison;\n-      if (GET_CODE (op2l) == CONST_INT && INTVAL (op2l) == -1)\n+      if (CONST_INT_P (op2l) && INTVAL (op2l) == -1)\n \tbreak;\n       if (comparison != GTU || op2h != CONST0_RTX (SImode))\n \tmsw_skip = swap_condition (msw_taken);\n@@ -1593,7 +1593,7 @@ expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n       lsw_taken = LTU;\n       break;\n     case LEU: case LE:\n-      if (GET_CODE (op2l) == CONST_INT && INTVAL (op2l) == -1)\n+      if (CONST_INT_P (op2l) && INTVAL (op2l) == -1)\n \tmsw_taken = comparison;\n       else\n \t{\n@@ -1960,7 +1960,7 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n   rtx dst = operands[0];\n   rtx src = operands[1];\n \n-  if (GET_CODE (dst) == MEM\n+  if (MEM_P (dst)\n       && GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n     return \"mov.l\t%T1,%0\\n\\tmov.l\t%1,%0\";\n \n@@ -1978,7 +1978,7 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n       else\n \treturn \"mov\t%1,%0\\n\\tmov\t%T1,%T0\";\n     }\n-  else if (GET_CODE (src) == CONST_INT)\n+  else if (CONST_INT_P (src))\n     {\n       if (INTVAL (src) < 0)\n \toutput_asm_insn (\"mov\t#-1,%S0\", operands);\n@@ -1987,7 +1987,7 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \n       return \"mov\t%1,%R0\";\n     }\n-  else if (GET_CODE (src) == MEM)\n+  else if (MEM_P (src))\n     {\n       int ptrreg = -1;\n       int dreg = REGNO (dst);\n@@ -2012,7 +2012,7 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t     supported, so we can't use the 'o' constraint.\n \t     Thus we must check for and handle r0+REG addresses here.\n \t     We punt for now, since this is likely very rare.  */\n-\t  gcc_assert (GET_CODE (XEXP (inside, 1)) != REG);\n+\t  gcc_assert (!REG_P (XEXP (inside, 1)));\n \t  break;\n \t  \n \tcase LABEL_REF:\n@@ -2076,7 +2076,7 @@ output_far_jump (rtx insn, rtx op)\n \tjump = \"mov.l\t%O0,%1; jmp\t@%1\";\n     }\n   /* If we have a scratch register available, use it.  */\n-  if (GET_CODE ((prev = prev_nonnote_insn (insn))) == INSN\n+  if (NONJUMP_INSN_P ((prev = prev_nonnote_insn (insn)))\n       && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)\n     {\n       this_jmp.reg = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));\n@@ -2235,7 +2235,7 @@ output_branchy_insn (enum rtx_code code, const char *templ,\n {\n   rtx next_insn = NEXT_INSN (insn);\n \n-  if (next_insn && GET_CODE (next_insn) == JUMP_INSN && condjump_p (next_insn))\n+  if (next_insn && JUMP_P (next_insn) && condjump_p (next_insn))\n     {\n       rtx src = SET_SRC (PATTERN (next_insn));\n       if (GET_CODE (src) == IF_THEN_ELSE && GET_CODE (XEXP (src, 0)) != code)\n@@ -2348,7 +2348,7 @@ sh_cannot_copy_insn_p (rtx insn)\n   if (!reload_completed || !flag_pic)\n     return false;\n \n-  if (GET_CODE (insn) != INSN)\n+  if (!NONJUMP_INSN_P (insn))\n     return false;\n   if (asm_noperands (insn) >= 0)\n     return false;\n@@ -2443,15 +2443,15 @@ shiftcosts (rtx x)\n   if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n     {\n       if (GET_MODE (x) == DImode\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) == 1)\n \treturn 2;\n \n       /* Everything else is invalid, because there is no pattern for it.  */\n       return MAX_COST;\n     }\n   /* If shift by a non constant, then this will be expensive.  */\n-  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+  if (!CONST_INT_P (XEXP (x, 1)))\n     return SH_DYNAMIC_SHIFT_COST;\n \n   /* Otherwise, return the true cost in instructions.  Cope with out of range\n@@ -2478,7 +2478,7 @@ andcosts (rtx x)\n   int i;\n \n   /* Anding with a register is a single cycle and instruction.  */\n-  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+  if (!CONST_INT_P (XEXP (x, 1)))\n     return 1;\n \n   i = INTVAL (XEXP (x, 1));\n@@ -2514,12 +2514,12 @@ static inline int\n addsubcosts (rtx x)\n {\n   /* Adding a register is a single cycle insn.  */\n-  if (GET_CODE (XEXP (x, 1)) == REG\n+  if (REG_P (XEXP (x, 1))\n       || GET_CODE (XEXP (x, 1)) == SUBREG)\n     return 1;\n \n   /* Likewise for small constants.  */\n-  if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+  if (CONST_INT_P (XEXP (x, 1))\n       && CONST_OK_FOR_ADD (INTVAL (XEXP (x, 1))))\n     return 1;\n \n@@ -2820,7 +2820,7 @@ gen_shifty_op (int code, rtx *operands)\n \t{\n \t  /* There is a two instruction sequence for 31 bit left shifts,\n \t     but it requires r0.  */\n-\t  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 0)\n+\t  if (REG_P (operands[0]) && REGNO (operands[0]) == 0)\n \t    {\n \t      emit_insn (gen_andsi3 (operands[0], operands[0], const1_rtx));\n \t      emit_insn (gen_rotlsi3_31 (operands[0], operands[0]));\n@@ -2888,7 +2888,7 @@ expand_ashiftrt (rtx *operands)\n \n   if (TARGET_SH3)\n     {\n-      if (GET_CODE (operands[2]) != CONST_INT)\n+      if (!CONST_INT_P (operands[2]))\n \t{\n \t  rtx count = copy_to_mode_reg (SImode, operands[2]);\n \t  emit_insn (gen_negsi2 (count, count));\n@@ -2904,7 +2904,7 @@ expand_ashiftrt (rtx *operands)\n \t  return 1;\n \t}\n     }\n-  if (GET_CODE (operands[2]) != CONST_INT)\n+  if (!CONST_INT_P (operands[2]))\n     return 0;\n \n   value = INTVAL (operands[2]) & 31;\n@@ -2995,7 +2995,7 @@ shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n \n   if (left < 0 || left > 31)\n     return 0;\n-  if (GET_CODE (mask_rtx) == CONST_INT)\n+  if (CONST_INT_P (mask_rtx))\n     mask = (unsigned HOST_WIDE_INT) INTVAL (mask_rtx) >> left;\n   else\n     mask = (unsigned HOST_WIDE_INT) GET_MODE_MASK (SImode) >> left;\n@@ -3732,7 +3732,7 @@ dump_table (rtx start, rtx barrier)\n       scan = emit_insn_after (gen_align_4 (), scan);\n       need_align = 0;\n       for (; start != barrier; start = NEXT_INSN (start))\n-\tif (GET_CODE (start) == INSN\n+\tif (NONJUMP_INSN_P (start)\n \t    && recog_memoized (start) == CODE_FOR_casesi_worker_2)\n \t  {\n \t    rtx src = SET_SRC (XVECEXP (PATTERN (start), 0, 0));\n@@ -3876,7 +3876,7 @@ dump_table (rtx start, rtx barrier)\n static int\n hi_const (rtx src)\n {\n-  return (GET_CODE (src) == CONST_INT\n+  return (CONST_INT_P (src)\n \t  && INTVAL (src) >= -32768\n \t  && INTVAL (src) <= 32767);\n }\n@@ -3892,7 +3892,7 @@ hi_const (rtx src)\n static int\n broken_move (rtx insn)\n {\n-  if (GET_CODE (insn) == INSN)\n+  if (NONJUMP_INSN_P (insn))\n     {\n       rtx pat = PATTERN (insn);\n       if (GET_CODE (pat) == PARALLEL)\n@@ -3920,7 +3920,7 @@ broken_move (rtx insn)\n \t\t&& (! TARGET_SH4 || TARGET_FMOVD\n \t\t    || (GET_CODE (XEXP (XVECEXP (PATTERN (insn), 0, 2), 0))\n \t\t\t== SCRATCH))\n-\t\t&& GET_CODE (SET_DEST (pat)) == REG\n+\t\t&& REG_P (SET_DEST (pat))\n \t\t&& FP_REGISTER_P (REGNO (SET_DEST (pat))))\n \t  && ! (TARGET_SH2A\n \t\t&& GET_MODE (SET_DEST (pat)) == SImode\n@@ -3936,7 +3936,7 @@ broken_move (rtx insn)\n static int\n mova_p (rtx insn)\n {\n-  return (GET_CODE (insn) == INSN\n+  return (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n \t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPEC_MOVA\n@@ -3964,9 +3964,9 @@ fixup_mova (rtx mova)\n \t{\n \t  worker = NEXT_INSN (worker);\n \t  gcc_assert (worker\n-\t\t      && GET_CODE (worker) != CODE_LABEL\n-\t\t      && GET_CODE (worker) != JUMP_INSN);\n-\t} while (GET_CODE (worker) == NOTE\n+\t\t      && !LABEL_P (worker)\n+\t\t      && !JUMP_P (worker));\n+\t} while (NOTE_P (worker)\n \t\t || recog_memoized (worker) != CODE_FOR_casesi_worker_1);\n       wpat = PATTERN (worker);\n       wpat0 = XVECEXP (wpat, 0, 0);\n@@ -4084,12 +4084,12 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t call, determine the alignment.  N.B.  When find_barrier recurses for\n \t an out-of-reach mova, we might see labels at the start of previously\n \t inserted constant tables.  */\n-      if (GET_CODE (from) == CODE_LABEL\n+      if (LABEL_P (from)\n \t  && CODE_LABEL_NUMBER (from) <= max_labelno_before_reorg)\n \t{\n \t  if (optimize)\n \t    new_align = 1 << label_to_alignment (from);\n-\t  else if (GET_CODE (prev_nonnote_insn (from)) == BARRIER)\n+\t  else if (BARRIER_P (prev_nonnote_insn (from)))\n \t    new_align = 1 << barrier_align (from);\n \t  else\n \t    new_align = 1;\n@@ -4099,20 +4099,20 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t for explicit alignments.  If the table is long, we might be forced\n \t to emit the new table in front of it; the length of the alignment\n \t might be the last straw.  */\n-      else if (GET_CODE (from) == INSN\n+      else if (NONJUMP_INSN_P (from)\n \t       && GET_CODE (PATTERN (from)) == UNSPEC_VOLATILE\n \t       && XINT (PATTERN (from), 1) == UNSPECV_ALIGN)\n \tnew_align = INTVAL (XVECEXP (PATTERN (from), 0, 0));\n       /* When we find the end of a constant table, paste the new constant\n \t at the end.  That is better than putting it in front because\n \t this way, we don't need extra alignment for adding a 4-byte-aligned\n \t mov(a) label to a 2/4 or 8/4 byte aligned table.  */\n-      else if (GET_CODE (from) == INSN\n+      else if (NONJUMP_INSN_P (from)\n \t       && GET_CODE (PATTERN (from)) == UNSPEC_VOLATILE\n \t       && XINT (PATTERN (from), 1) == UNSPECV_CONST_END)\n \treturn from;\n \n-      if (GET_CODE (from) == BARRIER)\n+      if (BARRIER_P (from))\n \t{\n \t  rtx next;\n \n@@ -4198,9 +4198,7 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t  if (found_si > count_si)\n \t    count_si = found_si;\n \t}\n-      else if (GET_CODE (from) == JUMP_INSN\n-\t       && (GET_CODE (PATTERN (from)) == ADDR_VEC\n-\t\t   || GET_CODE (PATTERN (from)) == ADDR_DIFF_VEC))\n+      else if (JUMP_TABLE_DATA_P (from))\n \t{\n \t  if ((num_mova > 1 && GET_MODE (prev_nonnote_insn (from)) == VOIDmode)\n \t      || (num_mova\n@@ -4227,7 +4225,7 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t    }\n \t}\n       /* For the SH1, we generate alignments even after jumps-around-jumps.  */\n-      else if (GET_CODE (from) == JUMP_INSN\n+      else if (JUMP_P (from)\n \t       && ! TARGET_SH2\n \t       && ! TARGET_SMALLCODE)\n \tnew_align = 4;\n@@ -4298,8 +4296,8 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t around the constant pool table will be hit.  Putting it before\n \t a jump makes it more likely that the bra delay slot will be\n \t filled.  */\n-      while (GET_CODE (from) == JUMP_INSN || GET_CODE (from) == NOTE\n-\t     || GET_CODE (from) == CODE_LABEL)\n+      while (NOTE_P (from) || JUMP_P (from)\n+\t     || LABEL_P (from))\n \tfrom = PREV_INSN (from);\n \n       from = emit_jump_insn_after (gen_jump (label), from);\n@@ -4322,7 +4320,7 @@ sfunc_uses_reg (rtx insn)\n   int i;\n   rtx pattern, part, reg_part, reg;\n \n-  if (GET_CODE (insn) != INSN)\n+  if (!NONJUMP_INSN_P (insn))\n     return 0;\n   pattern = PATTERN (insn);\n   if (GET_CODE (pattern) != PARALLEL || get_attr_type (insn) != TYPE_SFUNC)\n@@ -4343,7 +4341,7 @@ sfunc_uses_reg (rtx insn)\n       if (part == reg_part || GET_CODE (part) == CLOBBER)\n \tcontinue;\n       if (reg_mentioned_p (reg, ((GET_CODE (part) == SET\n-\t\t\t\t  && GET_CODE (SET_DEST (part)) == REG)\n+\t\t\t\t  && REG_P (SET_DEST (part)))\n \t\t\t\t ? SET_SRC (part) : part)))\n \treturn 0;\n     }\n@@ -4366,18 +4364,18 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n     {\n       pattern = single_set (insn);\n       if (pattern\n-\t  && GET_CODE (SET_DEST (pattern)) == REG\n+\t  && REG_P (SET_DEST (pattern))\n \t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n \t*set = pattern;\n       return 0;\n     }\n-  if (GET_CODE (insn) != CALL_INSN)\n+  if (!CALL_P (insn))\n     {\n       /* We don't use rtx_equal_p because we don't care if the mode is\n \t different.  */\n       pattern = single_set (insn);\n       if (pattern\n-\t  && GET_CODE (SET_DEST (pattern)) == REG\n+\t  && REG_P (SET_DEST (pattern))\n \t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n \t{\n \t  rtx par, part;\n@@ -4416,7 +4414,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n \t{\n \t  /* We don't use rtx_equal_p, because we don't care if the\n              mode is different.  */\n-\t  if (GET_CODE (SET_DEST (pattern)) != REG\n+\t  if (!REG_P (SET_DEST (pattern))\n \t      || REGNO (reg) != REGNO (SET_DEST (pattern)))\n \t    return 1;\n \n@@ -4427,7 +4425,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n     }\n \n   if (GET_CODE (pattern) != CALL\n-      || GET_CODE (XEXP (pattern, 0)) != MEM\n+      || !MEM_P (XEXP (pattern, 0))\n       || ! rtx_equal_p (reg, XEXP (XEXP (pattern, 0), 0)))\n     return 1;\n \n@@ -4460,7 +4458,7 @@ regs_used (rtx x, int is_dest)\n       {\n \trtx y = SUBREG_REG (x);\n \n-\tif (GET_CODE (y) != REG)\n+\tif (!REG_P (y))\n \t  break;\n \tif (REGNO (y) < 16)\n \t  return (((1 << HARD_REGNO_NREGS (0, GET_MODE (x))) - 1)\n@@ -4523,7 +4521,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n   rtx dest;\n \n   /* First, check if we already have an instruction that satisfies our need.  */\n-  if (prev && GET_CODE (prev) == INSN && ! INSN_DELETED_P (prev))\n+  if (prev && NONJUMP_INSN_P (prev) && ! INSN_DELETED_P (prev))\n     {\n       if (INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)\n \treturn prev;\n@@ -4620,7 +4618,7 @@ gen_block_redirect (rtx jump, int addr, int need_block)\n   else if (optimize && need_block >= 0)\n     {\n       rtx next = next_active_insn (next_active_insn (dest));\n-      if (next && GET_CODE (next) == JUMP_INSN\n+      if (next && JUMP_P (next)\n \t  && GET_CODE (PATTERN (next)) == SET\n \t  && recog_memoized (next) == CODE_FOR_jump_compact)\n \t{\n@@ -4737,7 +4735,7 @@ fixup_addr_diff_vecs (rtx first)\n     {\n       rtx vec_lab, pat, prev, prevpat, x, braf_label;\n \n-      if (GET_CODE (insn) != JUMP_INSN\n+      if (!JUMP_P (insn)\n \t  || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n \tcontinue;\n       pat = PATTERN (insn);\n@@ -4746,7 +4744,7 @@ fixup_addr_diff_vecs (rtx first)\n       /* Search the matching casesi_jump_2.  */\n       for (prev = vec_lab; ; prev = PREV_INSN (prev))\n \t{\n-\t  if (GET_CODE (prev) != JUMP_INSN)\n+\t  if (!JUMP_P (prev))\n \t    continue;\n \t  prevpat = PATTERN (prev);\n \t  if (GET_CODE (prevpat) != PARALLEL || XVECLEN (prevpat, 0) != 2)\n@@ -4835,7 +4833,7 @@ barrier_align (rtx barrier_or_label)\n       prev = prev_real_insn (prev);\n \n       for (slot = 2, credit = (1 << (CACHE_LOG - 2)) + 2;\n-\t   credit >= 0 && prev && GET_CODE (prev) == INSN;\n+\t   credit >= 0 && prev && NONJUMP_INSN_P (prev);\n \t   prev = prev_real_insn (prev))\n \t{\n \t  jump_to_next = 0;\n@@ -4859,7 +4857,7 @@ barrier_align (rtx barrier_or_label)\n \t  credit -= get_attr_length (prev);\n \t}\n       if (prev\n-\t  && GET_CODE (prev) == JUMP_INSN\n+\t  && JUMP_P (prev)\n \t  && JUMP_LABEL (prev))\n \t{\n \t  rtx x;\n@@ -4903,7 +4901,7 @@ sh_loop_align (rtx label)\n \n   do\n     next = next_nonnote_insn (next);\n-  while (next && GET_CODE (next) == CODE_LABEL);\n+  while (next && LABEL_P (next));\n \n   if (! next\n       || ! INSN_P (next)\n@@ -4969,7 +4967,7 @@ sh_reorg (void)\n \t  rtx pattern, reg, link, set, scan, dies, label;\n \t  int rescan = 0, foundinsn = 0;\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      pattern = PATTERN (insn);\n \n@@ -4979,7 +4977,7 @@ sh_reorg (void)\n \t\tpattern = SET_SRC (pattern);\n \n \t      if (GET_CODE (pattern) != CALL\n-\t\t  || GET_CODE (XEXP (pattern, 0)) != MEM)\n+\t\t  || !MEM_P (XEXP (pattern, 0)))\n \t\tcontinue;\n \n \t      reg = XEXP (XEXP (pattern, 0), 0);\n@@ -4991,13 +4989,13 @@ sh_reorg (void)\n \t\tcontinue;\n \t    }\n \n-\t  if (GET_CODE (reg) != REG)\n+\t  if (!REG_P (reg))\n \t    continue;\n \n \t  /* Try scanning backward to find where the register is set.  */\n \t  link = NULL;\n \t  for (scan = PREV_INSN (insn);\n-\t       scan && GET_CODE (scan) != CODE_LABEL;\n+\t       scan && !LABEL_P (scan);\n \t       scan = PREV_INSN (scan))\n \t    {\n \t      if (! INSN_P (scan))\n@@ -5049,7 +5047,7 @@ sh_reorg (void)\n \t\t the call, and can result in situations where a single call\n \t\t insn may have two targets depending on where we came from.  */\n \n-\t      if (GET_CODE (scan) == CODE_LABEL && ! foundinsn)\n+\t      if (LABEL_P (scan) && ! foundinsn)\n \t\tbreak;\n \n \t      if (! INSN_P (scan))\n@@ -5059,7 +5057,7 @@ sh_reorg (void)\n                  safely, we would have to check that all the\n                  instructions at the jump destination did not use REG.  */\n \n-\t      if (GET_CODE (scan) == JUMP_INSN)\n+\t      if (JUMP_P (scan))\n \t\tbreak;\n \n \t      if (! reg_mentioned_p (reg, scan))\n@@ -5072,7 +5070,7 @@ sh_reorg (void)\n \t\tfoundinsn = 1;\n \n \t      if (scan != insn\n-\t\t  && (GET_CODE (scan) == CALL_INSN || sfunc_uses_reg (scan)))\n+\t\t  && (CALL_P (scan) || sfunc_uses_reg (scan)))\n \t\t{\n \t\t  /* There is a function call to this register other\n                      than the one we are checking.  If we optimize\n@@ -5128,7 +5126,7 @@ sh_reorg (void)\n \n \t\t  scan = NEXT_INSN (scan);\n \t\t  if (scan != insn\n-\t\t      && ((GET_CODE (scan) == CALL_INSN\n+\t\t      && ((CALL_P (scan)\n \t\t\t   && reg_mentioned_p (reg, scan))\n \t\t\t  || ((reg2 = sfunc_uses_reg (scan))\n \t\t\t      && REGNO (reg2) == REGNO (reg))))\n@@ -5168,7 +5166,7 @@ sh_reorg (void)\n \t      num_mova = 0;\n \t    }\n \t}\n-      else if (GET_CODE (insn) == JUMP_INSN\n+      else if (JUMP_P (insn)\n \t       && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n \t       && num_mova\n \t       /* ??? loop invariant motion can also move a mova out of a\n@@ -5203,7 +5201,7 @@ sh_reorg (void)\n \t    }\n \t}\n       if (broken_move (insn)\n-\t  || (GET_CODE (insn) == INSN\n+\t  || (NONJUMP_INSN_P (insn)\n \t      && recog_memoized (insn) == CODE_FOR_casesi_worker_2))\n \t{\n \t  rtx scan;\n@@ -5223,9 +5221,9 @@ sh_reorg (void)\n \t  /* Now find all the moves between the points and modify them.  */\n \t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n \t    {\n-\t      if (GET_CODE (scan) == CODE_LABEL)\n+\t      if (LABEL_P (scan))\n \t\tlast_float = 0;\n-\t      if (GET_CODE (scan) == INSN\n+\t      if (NONJUMP_INSN_P (scan)\n \t\t  && recog_memoized (scan) == CODE_FOR_casesi_worker_2)\n \t\tneed_aligned_label = 1;\n \t      if (broken_move (scan))\n@@ -5258,7 +5256,7 @@ sh_reorg (void)\n \t\t\t}\n \t\t      dst = gen_rtx_REG (HImode, REGNO (dst) + offset);\n \t\t    }\n-\t\t  if (GET_CODE (dst) == REG && FP_ANY_REGISTER_P (REGNO (dst)))\n+\t\t  if (REG_P (dst) && FP_ANY_REGISTER_P (REGNO (dst)))\n \t\t    {\n \t\t      /* This must be an insn that clobbers r0.  */\n \t\t      rtx *clobberp = &XVECEXP (PATTERN (scan), 0,\n@@ -5387,7 +5385,7 @@ get_dest_uid (rtx label, int max_uid)\n       dest = NEXT_INSN (dest);\n       dest_uid = INSN_UID (dest);\n     }\n-  if (GET_CODE (dest) == JUMP_INSN && GET_CODE (PATTERN (dest)) == RETURN)\n+  if (JUMP_P (dest) && GET_CODE (PATTERN (dest)) == RETURN)\n     return 0;\n   return dest_uid;\n }\n@@ -5421,7 +5419,7 @@ split_branches (rtx first)\n \t   so transform it into a note.  */\n \tSET_INSN_DELETED (insn);\n       }\n-    else if (GET_CODE (insn) == JUMP_INSN\n+    else if (JUMP_P (insn)\n \t     /* Don't mess with ADDR_DIFF_VEC */\n \t     && (GET_CODE (PATTERN (insn)) == SET\n \t\t || GET_CODE (PATTERN (insn)) == RETURN))\n@@ -5509,9 +5507,9 @@ split_branches (rtx first)\n \t\t\t\t\t    0));\n \n \t\tif (beyond\n-\t\t    && (GET_CODE (beyond) == JUMP_INSN\n+\t\t    && (JUMP_P (beyond)\n \t\t\t|| ((beyond = next_active_insn (beyond))\n-\t\t\t    && GET_CODE (beyond) == JUMP_INSN))\n+\t\t\t    && JUMP_P (beyond)))\n \t\t    && GET_CODE (PATTERN (beyond)) == SET\n \t\t    && recog_memoized (beyond) == CODE_FOR_jump_compact\n \t\t    && ((INSN_ADDRESSES\n@@ -5524,9 +5522,9 @@ split_branches (rtx first)\n \n \t    next = next_active_insn (insn);\n \n-\t    if ((GET_CODE (next) == JUMP_INSN\n+\t    if ((JUMP_P (next)\n \t\t || ((next = next_active_insn (next))\n-\t\t     && GET_CODE (next) == JUMP_INSN))\n+\t\t     && JUMP_P (next)))\n \t\t&& GET_CODE (PATTERN (next)) == SET\n \t\t&& recog_memoized (next) == CODE_FOR_jump_compact\n \t\t&& ((INSN_ADDRESSES\n@@ -6090,7 +6088,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n     {\n       rtx pr_initial = has_hard_reg_initial_val (Pmode, PR_REG);\n       pr_live = (pr_initial\n-\t\t ? (GET_CODE (pr_initial) != REG\n+\t\t ? (!REG_P (pr_initial)\n \t\t    || REGNO (pr_initial) != (PR_REG))\n \t\t : df_regs_ever_live_p (PR_REG));\n       /* For Shcompact, if not optimizing, we end up with a memory reference\n@@ -8657,7 +8655,7 @@ reg_unused_after (rtx reg, rtx insn)\n      case.  Disregard the case where this is a store to memory, since\n      we are checking a register used in the store address.  */\n   set = single_set (insn);\n-  if (set && GET_CODE (SET_DEST (set)) != MEM\n+  if (set && !MEM_P (SET_DEST (set))\n       && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n     return 1;\n \n@@ -8696,9 +8694,9 @@ reg_unused_after (rtx reg, rtx insn)\n \t      rtx this_insn = XVECEXP (PATTERN (insn), 0, i);\n \t      rtx set = single_set (this_insn);\n \n-\t      if (GET_CODE (this_insn) == CALL_INSN)\n+\t      if (CALL_P (this_insn))\n \t\tcode = CALL_INSN;\n-\t      else if (GET_CODE (this_insn) == JUMP_INSN)\n+\t      else if (JUMP_P (this_insn))\n \t\t{\n \t\t  if (INSN_ANNULLED_BRANCH_P (this_insn))\n \t\t    return 0;\n@@ -8709,7 +8707,7 @@ reg_unused_after (rtx reg, rtx insn)\n \t\treturn 0;\n \t      if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \t\t{\n-\t\t  if (GET_CODE (SET_DEST (set)) != MEM)\n+\t\t  if (!MEM_P (SET_DEST (set)))\n \t\t    retval = 1;\n \t\t  else\n \t\t    return 0;\n@@ -8728,7 +8726,7 @@ reg_unused_after (rtx reg, rtx insn)\n       if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n \treturn 0;\n       if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\treturn GET_CODE (SET_DEST (set)) != MEM;\n+\treturn !MEM_P (SET_DEST (set));\n       if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \treturn 0;\n \n@@ -8883,11 +8881,11 @@ sh_insn_length_adjustment (rtx insn)\n {\n   /* Instructions with unfilled delay slots take up an extra two bytes for\n      the nop in the delay slot.  */\n-  if (((GET_CODE (insn) == INSN\n+  if (((NONJUMP_INSN_P (insn)\n \t&& GET_CODE (PATTERN (insn)) != USE\n \t&& GET_CODE (PATTERN (insn)) != CLOBBER)\n-       || GET_CODE (insn) == CALL_INSN\n-       || (GET_CODE (insn) == JUMP_INSN\n+       || CALL_P (insn)\n+       || (JUMP_P (insn)\n \t   && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n \t   && GET_CODE (PATTERN (insn)) != ADDR_VEC))\n       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (insn)))) != SEQUENCE\n@@ -8897,7 +8895,7 @@ sh_insn_length_adjustment (rtx insn)\n   /* SH2e has a bug that prevents the use of annulled branches, so if\n      the delay slot is not filled, we'll have to put a NOP in it.  */\n   if (sh_cpu_attr == CPU_SH2E\n-      && GET_CODE (insn) == JUMP_INSN\n+      && JUMP_P (insn)\n       && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC\n       && GET_CODE (PATTERN (insn)) != ADDR_VEC\n       && get_attr_type (insn) == TYPE_CBRANCH\n@@ -8906,7 +8904,7 @@ sh_insn_length_adjustment (rtx insn)\n \n   /* sh-dsp parallel processing insn take four bytes instead of two.  */\n \n-  if (GET_CODE (insn) == INSN)\n+  if (NONJUMP_INSN_P (insn))\n     {\n       int sum = 0;\n       rtx body = PATTERN (insn);\n@@ -8978,7 +8976,7 @@ sh_insn_length_adjustment (rtx insn)\n bool\n sh_legitimate_index_p (enum machine_mode mode, rtx op)\n {\n-  if (GET_CODE (op) == CONST_INT)\n+  if (CONST_INT_P (op))\n     {\n       if (TARGET_SHMEDIA)\n \t{\n@@ -9171,7 +9169,7 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n   if (GET_CODE (x) == PLUS\n       && (GET_MODE_SIZE (mode) == 4\n \t  || GET_MODE_SIZE (mode) == 8)\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && CONST_INT_P (XEXP (x, 1))\n       && BASE_REGISTER_RTX_P (XEXP (x, 0))\n       && ! TARGET_SHMEDIA\n       && ! ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && mode == DFmode)\n@@ -9233,7 +9231,7 @@ mark_constant_pool_use (rtx x)\n   lab = x;\n   for (insn = PREV_INSN (x); insn; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) != CODE_LABEL\n+      if (!LABEL_P (insn)\n \t  || LABEL_REFS (insn) != NEXT_INSN (insn))\n \tbreak;\n       lab = insn;\n@@ -9245,7 +9243,7 @@ mark_constant_pool_use (rtx x)\n   /* Mark constants in a window.  */\n   for (insn = NEXT_INSN (x); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) != INSN)\n+      if (!NONJUMP_INSN_P (insn))\n \tcontinue;\n \n       pattern = PATTERN (insn);\n@@ -9419,15 +9417,15 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n \t}\n       /* The only input for a call that is timing-critical is the\n \t function's address.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx call = PATTERN (insn);\n \n \t  if (GET_CODE (call) == PARALLEL)\n \t    call = XVECEXP (call, 0 ,0);\n \t  if (GET_CODE (call) == SET)\n \t    call = SET_SRC (call);\n-\t  if (GET_CODE (call) == CALL && GET_CODE (XEXP (call, 0)) == MEM\n+\t  if (GET_CODE (call) == CALL && MEM_P (XEXP (call, 0))\n \t\t  /* sibcalli_thunk uses a symbol_ref in an unspec.  */\n \t      && (GET_CODE (XEXP (XEXP (call, 0), 0)) == UNSPEC\n \t\t  || ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn)))\n@@ -9605,7 +9603,7 @@ find_set_regmode_weight (rtx x, enum machine_mode mode)\n     return 1;\n   if (GET_CODE (x) == SET && register_operand (SET_DEST (x), mode))\n     {\n-      if (GET_CODE (SET_DEST (x)) == REG)\n+      if (REG_P (SET_DEST (x)))\n \t{\n \t  if (!reg_mentioned_p (SET_DEST (x), SET_SRC (x)))\n \t    return 1;\n@@ -9642,7 +9640,7 @@ find_insn_regmode_weight (rtx insn, enum machine_mode mode)\n       if (REG_NOTE_KIND (x) == REG_DEAD || REG_NOTE_KIND (x) == REG_UNUSED)\n \t{\n \t  rtx note = XEXP (x, 0);\n-\t  if (GET_CODE (note) == REG && GET_MODE (note) == mode)\n+\t  if (REG_P (note) && GET_MODE (note) == mode)\n \t    reg_weight--;\n \t}\n     }\n@@ -10684,7 +10682,7 @@ sh_mark_label (rtx address, int nuses)\n       address = XVECEXP (address, 0, 0);\n     }\n   if (GET_CODE (address) == LABEL_REF\n-      && GET_CODE (XEXP (address, 0)) == CODE_LABEL)\n+      && LABEL_P (XEXP (address, 0)))\n     LABEL_NUSES (XEXP (address, 0)) += nuses;\n }\n \n@@ -11074,10 +11072,10 @@ sh_expand_t_scc (rtx operands[])\n   rtx result = target;\n   HOST_WIDE_INT val;\n \n-  if (GET_CODE (op0) != REG || REGNO (op0) != T_REG\n-      || GET_CODE (op1) != CONST_INT)\n+  if (!REG_P (op0) || REGNO (op0) != T_REG\n+      || !CONST_INT_P (op1))\n     return 0;\n-  if (GET_CODE (result) != REG)\n+  if (!REG_P (result))\n     result = gen_reg_rtx (SImode);\n   val = INTVAL (op1);\n   if ((code == EQ && val == 1) || (code == NE && val == 0))\n@@ -11131,7 +11129,7 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n   /* Search for the sfunc.  It should really come right after INSN.  */\n   while ((insn = NEXT_INSN (insn)))\n     {\n-      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n+      if (LABEL_P (insn) || JUMP_P (insn))\n \tbreak;\n       if (! INSN_P (insn))\n \tcontinue;\n@@ -11319,7 +11317,7 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n       rtx new_rtx = replace_n_hard_rtx (SUBREG_REG (x), replacements,\n \t\t\t\t    n_replacements, modify);\n \n-      if (GET_CODE (new_rtx) == CONST_INT)\n+      if (CONST_INT_P (new_rtx))\n \t{\n \t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t       GET_MODE (SUBREG_REG (x)),\n@@ -11332,7 +11330,7 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n \n       return x;\n     }\n-  else if (GET_CODE (x) == REG)\n+  else if (REG_P (x))\n     {\n       unsigned regno = REGNO (x);\n       unsigned nregs = (regno < FIRST_PSEUDO_REGISTER\n@@ -11345,7 +11343,7 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n \t  rtx to = replacements[i*2+1];\n \t  unsigned from_regno, from_nregs, to_regno, new_regno;\n \n-\t  if (GET_CODE (from) != REG)\n+\t  if (!REG_P (from))\n \t    continue;\n \t  from_regno = REGNO (from);\n \t  from_nregs = (from_regno < FIRST_PSEUDO_REGISTER\n@@ -11354,7 +11352,7 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n \t    {\n \t      if (regno < from_regno\n \t\t  || regno + nregs > from_regno + nregs\n-\t\t  || GET_CODE (to) != REG\n+\t\t  || !REG_P (to)\n \t\t  || result)\n \t\treturn NULL_RTX;\n \t      to_regno = REGNO (to);\n@@ -11379,7 +11377,7 @@ replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n       rtx new_rtx = replace_n_hard_rtx (XEXP (x, 0), replacements,\n \t\t\t\t    n_replacements, modify);\n \n-      if (GET_CODE (new_rtx) == CONST_INT)\n+      if (CONST_INT_P (new_rtx))\n \t{\n \t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n@@ -11455,7 +11453,7 @@ shmedia_cleanup_truncate (rtx *p, void *n_changes)\n   if (GET_CODE (x) != TRUNCATE)\n     return 0;\n   reg = XEXP (x, 0);\n-  if (GET_MODE_SIZE (GET_MODE (reg)) > 8 && GET_CODE (reg) == REG)\n+  if (GET_MODE_SIZE (GET_MODE (reg)) > 8 && REG_P (reg))\n     {\n       enum machine_mode reg_mode = GET_MODE (reg);\n       XEXP (x, 0) = simplify_subreg (DImode, reg, reg_mode,\n@@ -11475,7 +11473,7 @@ shmedia_cleanup_truncate (rtx *p, void *n_changes)\n static int\n sh_contains_memref_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n-  return (GET_CODE (*loc) == MEM);\n+  return (MEM_P (*loc));\n }\n \n /* Return nonzero iff INSN contains a MEM.  */\n@@ -11574,7 +11572,7 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t    abort ();\n \t  }\n       if (rclass == FPUL_REGS\n-          && ((GET_CODE (x) == REG\n+          && ((REG_P (x)\n                && (REGNO (x) == MACL_REG || REGNO (x) == MACH_REG\n                    || REGNO (x) == T_REG))\n               || GET_CODE (x) == PLUS))\n@@ -11589,8 +11587,8 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n \t  return NO_REGS;\n \t}\n       if (rclass == FPSCR_REGS\n-          && ((GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-              || (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == PLUS)))\n+          && ((REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+              || (MEM_P (x) && GET_CODE (XEXP (x, 0)) == PLUS)))\n         return GENERAL_REGS;\n       if (REGCLASS_HAS_FP_REG (rclass)\n           && TARGET_SHMEDIA\n@@ -11611,21 +11609,21 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n     } /* end of input-only processing.  */\n \n   if (((REGCLASS_HAS_FP_REG (rclass)\n-\t&& (GET_CODE (x) == REG\n+\t&& (REG_P (x)\n \t    && (GENERAL_OR_AP_REGISTER_P (REGNO (x))\n \t\t|| (FP_REGISTER_P (REGNO (x)) && mode == SImode\n \t\t    && TARGET_FMOVD))))\n        || (REGCLASS_HAS_GENERAL_REG (rclass)\n-\t   && GET_CODE (x) == REG\n+\t   && REG_P (x)\n \t   && FP_REGISTER_P (REGNO (x))))\n       && ! TARGET_SHMEDIA\n       && (mode == SFmode || mode == SImode))\n     return FPUL_REGS;\n   if ((rclass == FPUL_REGS\n        || (REGCLASS_HAS_FP_REG (rclass)\n            && ! TARGET_SHMEDIA && mode == SImode))\n-      && (GET_CODE (x) == MEM\n-          || (GET_CODE (x) == REG\n+      && (MEM_P (x)\n+          || (REG_P (x)\n               && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n                   || REGNO (x) == T_REG\n                   || system_reg_operand (x, VOIDmode)))))\n@@ -11637,13 +11635,13 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class rclass,\n   if ((rclass == TARGET_REGS\n        || (TARGET_SHMEDIA && rclass == SIBCALL_REGS))\n       && !satisfies_constraint_Csy (x)\n-      && (GET_CODE (x) != REG || ! GENERAL_REGISTER_P (REGNO (x))))\n+      && (!REG_P (x) || ! GENERAL_REGISTER_P (REGNO (x))))\n     return GENERAL_REGS;\n   if ((rclass == MAC_REGS || rclass == PR_REGS)\n-      && GET_CODE (x) == REG && ! GENERAL_REGISTER_P (REGNO (x))\n+      && REG_P (x) && ! GENERAL_REGISTER_P (REGNO (x))\n       && rclass != REGNO_REG_CLASS (REGNO (x)))\n     return GENERAL_REGS;\n-  if (rclass != GENERAL_REGS && GET_CODE (x) == REG\n+  if (rclass != GENERAL_REGS && REG_P (x)\n       && TARGET_REGISTER_P (REGNO (x)))\n     return GENERAL_REGS;\n   return NO_REGS;"}, {"sha": "6f46b816cbce12d376fde53af21cdfa244ac0e72", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f353609778d9079592f24a6abcad0ae21e78b7e3", "patch": "@@ -888,7 +888,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LABEL_ALIGN(A_LABEL) \\\n (\t\t\t\t\t\t\t\t\t\\\n   (PREV_INSN (A_LABEL)\t\t\t\t\t\t\t\\\n-   && GET_CODE (PREV_INSN (A_LABEL)) == INSN\t\t\t\t\\\n+   && NONJUMP_INSN_P (PREV_INSN (A_LABEL))\t\t\t\t\\\n    && GET_CODE (PATTERN (PREV_INSN (A_LABEL))) == UNSPEC_VOLATILE\t\\\n    && XINT (PATTERN (PREV_INSN (A_LABEL)), 1) == UNSPECV_ALIGN)\t\t\\\n    /* explicit alignment insn in constant tables.  */\t\t\t\\\n@@ -900,9 +900,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* The base two logarithm of the known minimum alignment of an insn length.  */\n #define INSN_LENGTH_ALIGNMENT(A_INSN)\t\t\t\t\t\\\n-  (GET_CODE (A_INSN) == INSN\t\t\t\t\t\t\\\n+  (NONJUMP_INSN_P (A_INSN)\t\t\t\t\t\t\\\n    ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n-   : GET_CODE (A_INSN) == JUMP_INSN || GET_CODE (A_INSN) == CALL_INSN\t\\\n+   : JUMP_P (A_INSN) || CALL_P (A_INSN)\t\t\t\t\t\\\n    ? 1 << TARGET_SHMEDIA\t\t\t\t\t\t\\\n    : CACHE_LOG)\n \f\n@@ -1547,35 +1547,35 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #if 0\n #define SECONDARY_INOUT_RELOAD_CLASS(CLASS,MODE,X,ELSE) \\\n   ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n-      && (GET_CODE (X) == REG\t\t\t\t\t\t\\\n+      && (REG_P (X)\t\t\t\t\t\t\t\\\n       && (GENERAL_OR_AP_REGISTER_P (REGNO (X))\t\t\t\t\\\n \t  || (FP_REGISTER_P (REGNO (X)) && (MODE) == SImode\t\t\\\n \t      && TARGET_FMOVD))))\t\t\t\t\t\\\n      || (REGCLASS_HAS_GENERAL_REG (CLASS) \t\t\t\t\\\n-\t && GET_CODE (X) == REG\t\t\t\t\t\t\\\n+\t && REG_P (X)\t\t\t\t\t\t\t\\\n \t && FP_REGISTER_P (REGNO (X))))\t\t\t\t\t\\\n     && ! TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n     && ((MODE) == SFmode || (MODE) == SImode))\t\t\t\t\\\n    ? FPUL_REGS\t\t\t\t\t\t\t\t\\\n    : (((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n        || (REGCLASS_HAS_FP_REG (CLASS)\t\t\t\t\t\\\n \t   && ! TARGET_SHMEDIA && MODE == SImode))\t\t\t\\\n-      && (GET_CODE (X) == MEM\t\t\t\t\t\t\\\n-\t  || (GET_CODE (X) == REG\t\t\t\t\t\\\n+      && (MEM_P (X)\t\t\t\t\t\t\t\\\n+\t  || (REG_P (X)\t\t\t\t\t\t\t\\\n \t      && (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\t\t\\\n \t\t  || REGNO (X) == T_REG\t\t\t\t\t\\\n \t\t  || system_reg_operand (X, VOIDmode)))))\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (((CLASS) == TARGET_REGS\t\t\t\t\t\t\\\n        || (TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\t\t\t\\\n       && !satisfies_constraint_Csy (X)\t\t\t\t\t\\\n-      && (GET_CODE (X) != REG || ! GENERAL_REGISTER_P (REGNO (X))))\t\\\n+      && (!REG_P (X) || ! GENERAL_REGISTER_P (REGNO (X))))\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (((CLASS) == MAC_REGS || (CLASS) == PR_REGS)\t\t\t\\\n-      && GET_CODE (X) == REG && ! GENERAL_REGISTER_P (REGNO (X))\t\\\n+      && REG_P (X) && ! GENERAL_REGISTER_P (REGNO (X))\t\t\t\\\n       && (CLASS) != REGNO_REG_CLASS (REGNO (X)))\t\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n-   : ((CLASS) != GENERAL_REGS && GET_CODE (X) == REG\t\t\t\\\n+   : ((CLASS) != GENERAL_REGS && REG_P (X)\t\t\t\t\\\n       && TARGET_REGISTER_P (REGNO (X)))\t\t\t\t\t\\\n    ? GENERAL_REGS : (ELSE))\n \n@@ -1590,7 +1590,7 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n \t  && (MODE) == SFmode && fldi_ok ()))\t\t\t\t\\\n    ? R0_REGS\t\t\t\t\t\t\t\t\\\n    : ((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n-      && ((GET_CODE (X) == REG\t\t\t\t\t\t\\\n+      && ((REG_P (X)\t\t\t\t\t\t\t\\\n \t   && (REGNO (X) == MACL_REG || REGNO (X) == MACH_REG\t\t\\\n \t       || REGNO (X) == T_REG))\t\t\t\t\t\\\n \t  || GET_CODE (X) == PLUS))\t\t\t\t\t\\\n@@ -1600,8 +1600,8 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n       ? GENERAL_REGS\t\t\t\t\t\t\t\\\n       : R0_REGS)\t\t\t\t\t\t\t\\\n    : ((CLASS) == FPSCR_REGS\t\t\t\t\t\t\\\n-      && ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\\\n-\t  || (GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS)))\\\n+      && ((REG_P (X) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+\t  || (MEM_P (X) && GET_CODE (XEXP ((X), 0)) == PLUS)))\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\\n       && TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n@@ -2218,11 +2218,11 @@ struct sh_args {\n    || (GET_CODE ((OP)) == CONST\t\t\t\t\t\t\\\n        && GET_CODE (XEXP ((OP), 0)) == PLUS\t\t\t\t\\\n        && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == LABEL_REF\t\t\\\n-       && GET_CODE (XEXP (XEXP ((OP), 0), 1)) == CONST_INT))\n+       && CONST_INT_P (XEXP (XEXP ((OP), 0), 1))))\n \n #define IS_NON_EXPLICIT_CONSTANT_P(OP)\t\t\t\t\t\\\n   (CONSTANT_P (OP)\t\t\t\t\t\t\t\\\n-   && GET_CODE (OP) != CONST_INT\t\t\t\t\t\\\n+   && !CONST_INT_P (OP)\t\t\t\t\t\\\n    && GET_CODE (OP) != CONST_DOUBLE\t\t\t\t\t\\\n    && (!flag_pic\t\t\t\t\t\t\t\\\n        || (LEGITIMATE_PIC_OPERAND_P (OP)\t\t\t\t\\\n@@ -2252,7 +2252,7 @@ struct sh_args {\n    && (UNSPEC_GOTOFF_P (XEXP ((OP), 0)) \\\n        || (GET_CODE (XEXP ((OP), 0)) == PLUS \\\n            && UNSPEC_GOTOFF_P (XEXP (XEXP ((OP), 0), 0)) \\\n-\t   && GET_CODE (XEXP (XEXP ((OP), 0), 1)) == CONST_INT)))\n+\t   && CONST_INT_P (XEXP (XEXP ((OP), 0), 1)))))\n \n #define PIC_ADDR_P(OP) \\\n   (GET_CODE (OP) == CONST && GET_CODE (XEXP ((OP), 0)) == UNSPEC \\\n@@ -2273,7 +2273,7 @@ struct sh_args {\n        && (GET_CODE (XEXP (XEXP ((OP), 0), 0)) == SYMBOL_REF \\\n \t   || GET_CODE (XEXP (XEXP ((OP), 0), 0)) == LABEL_REF \\\n \t   || DATALABEL_REF_NO_CONST_P (XEXP (XEXP ((OP), 0), 0))) \\\n-       && GET_CODE (XEXP (XEXP ((OP), 0), 1)) == CONST_INT))\n+       && CONST_INT_P (XEXP (XEXP ((OP), 0), 1))))\n \n #define PIC_REFERENCE_P(OP) \\\n   (GOT_ENTRY_P (OP) || GOTPLT_ENTRY_P (OP) \\\n@@ -2286,22 +2286,22 @@ struct sh_args {\n    : NON_PIC_REFERENCE_P (OP))\n \f\n #define MAYBE_BASE_REGISTER_RTX_P(X, STRICT)\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X, STRICT))\t\\\n+  ((REG_P (X) && REG_OK_FOR_BASE_P (X, STRICT))\t\\\n    || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n        && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE ((X))),\t\\\n \t\t\t\t GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (X)))) \\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\\\n+       && REG_P (SUBREG_REG (X))\t\t\t\\\n        && REG_OK_FOR_BASE_P (SUBREG_REG (X), STRICT)))\n \n /* Since this must be r0, which is a single register class, we must check\n    SUBREGs more carefully, to be sure that we don't accept one that extends\n    outside the class.  */\n #define MAYBE_INDEX_REGISTER_RTX_P(X, STRICT)\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X, STRICT))\t\\\n+  ((REG_P (X) && REG_OK_FOR_INDEX_P (X, STRICT))\t\\\n    || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n        && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE ((X))), \\\n \t\t\t\t GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (X)))) \\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n+       && REG_P (SUBREG_REG (X))\t\t\\\n        && SUBREG_OK_FOR_INDEX_P (SUBREG_REG (X), SUBREG_BYTE (X), STRICT)))\n \n #ifdef REG_OK_STRICT\n@@ -2332,7 +2332,7 @@ struct sh_args {\n {\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n       && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+      && CONST_INT_P (XEXP (X, 1))\t\t\t\t\t\\\n       && BASE_REGISTER_RTX_P (XEXP (X, 0))\t\t\t\t\\\n       && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n       && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\t\\\n@@ -2387,9 +2387,9 @@ struct sh_args {\n   else if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n \t   && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n \t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n+\t   && CONST_INT_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n \t   && BASE_REGISTER_RTX_P (XEXP (XEXP (X, 0), 0))\t\t\\\n-\t   && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t   && CONST_INT_P (XEXP (X, 1))\t\t\t\t\t\\\n \t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n \t   && ! (TARGET_SH2E && MODE == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2521,14 +2521,14 @@ struct sh_args {\n    in particular.  */\n \n #define INSN_SETS_ARE_DELAYED(X) \t\t\\\n-  ((GET_CODE (X) == INSN\t\t\t\\\n+  ((NONJUMP_INSN_P (X)\t\t\t\\\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n     && get_attr_is_sfunc (X)))\n \n #define INSN_REFERENCES_ARE_DELAYED(X) \t\t\\\n-  ((GET_CODE (X) == INSN\t\t\t\\\n+  ((NONJUMP_INSN_P (X)\t\t\t\\\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\"}, {"sha": "e446164eaea2c06e076588800a28dd92ae077be5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f353609778d9079592f24a6abcad0ae21e78b7e3", "patch": "@@ -1044,7 +1044,7 @@\n \t (match_dup 0)\n \t (match_dup 2)))]\n   \"TARGET_SHMEDIA && peep2_reg_dead_p (2, operands[0])\n-   && (GET_CODE (operands[1]) != REG || GENERAL_REGISTER_P (REGNO (operands[1])))\"\n+   && (!REG_P (operands[1]) || GENERAL_REGISTER_P (REGNO (operands[1])))\"\n   [(set (match_dup 2)\n \t(if_then_else:SI (match_dup 4) (match_dup 1) (match_dup 2)))]\n   \"\n@@ -1548,7 +1548,7 @@\n   \"\"\n   \"\n {\n-  if (TARGET_SH1 && GET_CODE (operands[1]) == CONST_INT)\n+  if (TARGET_SH1 && CONST_INT_P (operands[1]))\n     {\n       emit_insn (gen_negsi2 (operands[0], operands[2]));\n       emit_insn (gen_addsi3 (operands[0], operands[0], operands[1]));\n@@ -3054,7 +3054,7 @@ label:\n   \"\n {\n   if (TARGET_SH1\n-      && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 255)\n+      && CONST_INT_P (operands[2]) && INTVAL (operands[2]) == 255)\n     {\n       emit_insn (gen_zero_extendqisi2 (operands[0],\n \t\t\t\t       gen_lowpart (QImode, operands[1])));\n@@ -3247,7 +3247,7 @@ label:\n       offset = SUBREG_BYTE (operands[0]);\n       operands[0] = SUBREG_REG (operands[0]);\n     }\n-  gcc_assert (GET_CODE (operands[0]) == REG);\n+  gcc_assert (REG_P (operands[0]));\n   if (! TARGET_LITTLE_ENDIAN)\n     offset += 8 - GET_MODE_SIZE (inmode);\n   operands[5] = gen_rtx_SUBREG (inmode, operands[0], offset);\n@@ -3360,7 +3360,7 @@ label:\n \n   int count, choice;\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n+  if (!CONST_INT_P (operands[2]))\n     FAIL;\n   count = INTVAL (operands[2]);\n   choice = rot_tab[count];\n@@ -3415,7 +3415,7 @@ label:\n   \"TARGET_SH1\"\n   \"\n {\n-  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 8)\n+  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 8)\n     FAIL;\n }\")\n \n@@ -3448,7 +3448,7 @@ label:\n    #\"\n   \"TARGET_SH3\n    && reload_completed\n-   && GET_CODE (operands[2]) == CONST_INT\n+   && CONST_INT_P (operands[2])\n    && ! satisfies_constraint_P27 (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel\n@@ -3522,7 +3522,7 @@ label:\n       emit_insn (gen_ashlsi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && sh_dynamicalize_shift_p (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n   if (TARGET_SH3)\n@@ -3557,7 +3557,7 @@ label:\n   \"TARGET_SH1\"\n   \"\n {\n-  if (GET_CODE (operands[2]) != CONST_INT)\n+  if (!CONST_INT_P (operands[2]))\n     FAIL;\n   /* It may be possible to call gen_ashlhi3 directly with more generic\n      operands.  Make sure operands[1] is a HImode register here.  */\n@@ -3824,7 +3824,7 @@ label:\n       emit_insn (gen_lshrsi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && sh_dynamicalize_shift_p (operands[2]))\n     operands[2] = force_reg (SImode, operands[2]);\n   if (TARGET_SH3 && arith_reg_operand (operands[2], GET_MODE (operands[2])))\n@@ -3910,13 +3910,13 @@ label:\n       emit_insn (gen_ashldi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT\n+  if (CONST_INT_P (operands[2])\n       && INTVAL (operands[2]) == 1)\n     {\n       emit_insn (gen_ashldi3_k (operands[0], operands[1]));\n       DONE;\n     }\n-  else if (GET_CODE (operands[2]) == CONST_INT\n+  else if (CONST_INT_P (operands[2])\n       && INTVAL (operands[2]) < 32)\n     {\n       emit_insn (gen_ashldi3_std (operands[0], operands[1], operands[2]));\n@@ -3944,7 +3944,7 @@ label:\n \t\t     (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n   \"TARGET_SHMEDIA\n    && (arith_reg_dest (operands[0], DImode)\n-       || (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 32))\"\n+       || (CONST_INT_P (operands[2]) && INTVAL (operands[2]) > 32))\"\n   \"@\n \tshlrd\t%1, %2, %0\n \tshlri\t%1, %2, %0\"\n@@ -3972,7 +3972,7 @@ label:\n       emit_insn (gen_lshrdi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (GET_CODE (operands[2]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n       || INTVAL (operands[2]) != 1)\n     FAIL;\n }\")\n@@ -3995,7 +3995,7 @@ label:\n \t\t     (match_operand:DI 2 \"shift_count_operand\" \"r,n\")))]\n   \"TARGET_SHMEDIA\n    && (arith_reg_dest (operands[0], DImode)\n-       || (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 32))\"\n+       || (CONST_INT_P (operands[2]) && INTVAL (operands[2]) >= 32))\"\n   \"@\n \tshard\t%1, %2, %0\n \tshari\t%1, %2, %0\"\n@@ -4041,7 +4041,7 @@ label:\n       emit_insn (gen_ashrdi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (GET_CODE (operands[2]) != CONST_INT\n+  if (!CONST_INT_P (operands[2])\n       || INTVAL (operands[2]) != 1)\n     FAIL;\n }\")\n@@ -5091,7 +5091,7 @@ label:\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(match_operand:SI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n-   && ((GET_CODE (operands[1]) == CONST_INT\n+   && ((CONST_INT_P (operands[1])\n \t&& ! satisfies_constraint_I16 (operands[1]))\n        || GET_CODE (operands[1]) == CONST_DOUBLE)\"\n   [(set (subreg:DI (match_dup 0) 0) (match_dup 1))])\n@@ -5279,9 +5279,9 @@ label:\n   \"TARGET_SH1\n    && (arith_reg_operand (operands[0], HImode)\n        || arith_reg_operand (operands[1], HImode))\n-   && (GET_CODE (operands[0]) != MEM\n+   && (!MEM_P (operands[0])\n        || GET_CODE (XEXP (operands[0], 0)) != PLUS\n-       || GET_CODE (XEXP (XEXP (operands[0], 0), 1)) != REG\n+       || !REG_P (XEXP (XEXP (operands[0], 0), 1))\n        || ! refers_to_regno_p (R0_REG, R0_REG + 1, operands[1], (rtx *)0))\"\n   \"@\n \tmov.w\t%1,%0\n@@ -5366,9 +5366,9 @@ label:\n {\n   int regno;\n \n-  if ((GET_CODE (operands[0]) == MEM\n+  if ((MEM_P (operands[0])\n        && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-      || (GET_CODE (operands[1]) == MEM\n+      || (MEM_P (operands[1])\n \t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n     FAIL;\n \n@@ -5532,7 +5532,7 @@ label:\n   [(set (match_operand:DI 0 \"ext_dest_operand\" \"\")\n \t(match_operand:DI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n-   && GET_CODE (operands[1]) == CONST_INT\n+   && CONST_INT_P (operands[1])\n    && ! satisfies_constraint_I16 (operands[1])\"\n   [(set (match_dup 0) (match_dup 2))\n    (match_dup 1)]\n@@ -5764,8 +5764,8 @@ label:\n   \"TARGET_SH1\n    && (! (TARGET_SH4 || TARGET_SH2A_DOUBLE) || reload_completed\n        /* ??? We provide some insn so that direct_{load,store}[DFmode] get set */\n-       || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3)\n-       || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3))\n+       || (REG_P (operands[0]) && REGNO (operands[0]) == 3)\n+       || (REG_P (operands[1]) && REGNO (operands[1]) == 3))\n    && (arith_reg_operand (operands[0], DFmode)\n        || arith_reg_operand (operands[1], DFmode))\"\n   \"* return output_movedouble (insn, operands, DFmode);\"\n@@ -5890,12 +5890,12 @@ label:\n     }\n   if (GET_CODE (mem) == SUBREG && SUBREG_BYTE (mem) == 0)\n     mem = SUBREG_REG (mem);\n-  if (GET_CODE (mem) == MEM)\n+  if (MEM_P (mem))\n     {\n       rtx addr = XEXP (mem, 0);\n       if (GET_CODE (addr) == PLUS\n-\t  && GET_CODE (XEXP (addr, 0)) == REG\n-\t  && GET_CODE (XEXP (addr, 1)) == REG)\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && REG_P (XEXP (addr, 1)))\n \t{\n \t  int offset;\n \t  rtx reg0 = gen_rtx_REG (Pmode, 0);\n@@ -6115,9 +6115,9 @@ label:\n {\n   int regno;\n \n-  if ((GET_CODE (operands[0]) == MEM\n+  if ((MEM_P (operands[0])\n        && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-      || (GET_CODE (operands[1]) == MEM\n+      || (MEM_P (operands[1])\n \t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n     FAIL;\n \n@@ -6171,15 +6171,15 @@ label:\n {\n   rtx addr, reg, const_int;\n \n-  if (GET_CODE (operands[1]) != MEM)\n+  if (!MEM_P (operands[1]))\n     FAIL;\n   addr = XEXP (operands[1], 0);\n   if (GET_CODE (addr) != PLUS)\n     FAIL;\n   reg = XEXP (addr, 0);\n   const_int = XEXP (addr, 1);\n   if (! (BASE_REGISTER_RTX_P (reg) && INDEX_REGISTER_RTX_P (operands[2])\n-\t && GET_CODE (const_int) == CONST_INT))\n+\t && CONST_INT_P (const_int)))\n     FAIL;\n   emit_move_insn (operands[2], const_int);\n   emit_move_insn (operands[0],\n@@ -6199,15 +6199,15 @@ label:\n {\n   rtx addr, reg, const_int;\n \n-  if (GET_CODE (operands[1]) != MEM)\n+  if (!MEM_P (operands[1]))\n     FAIL;\n   addr = XEXP (operands[1], 0);\n   if (GET_CODE (addr) != PLUS)\n     FAIL;\n   reg = XEXP (addr, 0);\n   const_int = XEXP (addr, 1);\n   if (! (BASE_REGISTER_RTX_P (reg) && INDEX_REGISTER_RTX_P (operands[2])\n-\t && GET_CODE (const_int) == CONST_INT))\n+\t && CONST_INT_P (const_int)))\n     FAIL;\n   emit_move_insn (operands[2], const_int);\n   emit_move_insn (change_address (operands[1], VOIDmode,\n@@ -6333,13 +6333,13 @@ label:\n     {\n       rtx x, y;\n \n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n \tx = adjust_address (operands[0], V2SFmode,\n \t\t\t    i * GET_MODE_SIZE (V2SFmode));\n       else\n \tx = simplify_gen_subreg (V2SFmode, operands[0], V4SFmode, i * 8);\n \n-      if (GET_CODE (operands[1]) == MEM)\n+      if (MEM_P (operands[1]))\n \ty = adjust_address (operands[1], V2SFmode,\n \t\t\t    i * GET_MODE_SIZE (V2SFmode));\n       else\n@@ -6377,7 +6377,7 @@ label:\n     {\n       rtx x,y;\n \n-      if (GET_CODE (operands[0]) == MEM)\n+      if (MEM_P (operands[0]))\n \tx = adjust_address (operands[0], V2SFmode,\n \t\t\t    i * GET_MODE_SIZE (V2SFmode));\n       else\n@@ -6386,7 +6386,7 @@ label:\n \t  alter_subreg (&x);\n \t}\n \n-      if (GET_CODE (operands[1]) == MEM)\n+      if (MEM_P (operands[1]))\n \ty = adjust_address (operands[1], V2SFmode,\n \t\t\t    i * GET_MODE_SIZE (V2SFmode));\n       else\n@@ -6475,8 +6475,8 @@ label:\n   \"TARGET_SH1\n    && (! TARGET_SH2E\n        /* ??? We provide some insn so that direct_{load,store}[SFmode] get set */\n-       || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3)\n-       || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3))\n+       || (REG_P (operands[0]) && REGNO (operands[0]) == 3)\n+       || (REG_P (operands[1]) && REGNO (operands[1]) == 3))\n    && (arith_reg_operand (operands[0], SFmode)\n        || arith_reg_operand (operands[1], SFmode))\"\n   \"@\n@@ -7400,7 +7400,7 @@ label:\n       XEXP (operands[0], 0) = reg;\n     }\n   if (!flag_pic && TARGET_SH2A\n-      && GET_CODE (operands[0]) == MEM\n+      && MEM_P (operands[0])\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n     {\n       if (sh2a_is_function_vector_call (XEXP (operands[0], 0)))\n@@ -7411,7 +7411,7 @@ label:\n \t}\n     }\n   if (flag_pic && TARGET_SH2\n-      && GET_CODE (operands[0]) == MEM\n+      && MEM_P (operands[0])\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n     {\n       emit_call_insn (gen_call_pcrel (XEXP (operands[0], 0), operands[1]));\n@@ -7594,7 +7594,7 @@ label:\n       XEXP (operands[1], 0) = reg;\n     }\n   if (!flag_pic && TARGET_SH2A\n-      && GET_CODE (operands[1]) == MEM\n+      && MEM_P (operands[1])\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n     {\n       if (sh2a_is_function_vector_call (XEXP (operands[1], 0)))\n@@ -7605,7 +7605,7 @@ label:\n \t}\n     }\n   if (flag_pic && TARGET_SH2\n-      && GET_CODE (operands[1]) == MEM\n+      && MEM_P (operands[1])\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n     {\n       emit_call_insn (gen_call_value_pcrel (operands[0], XEXP (operands[1], 0),\n@@ -7800,7 +7800,7 @@ label:\n       XEXP (operands[0], 0) = reg;\n     }\n   if (flag_pic && TARGET_SH2\n-      && GET_CODE (operands[0]) == MEM\n+      && MEM_P (operands[0])\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n       /* The PLT needs the PIC register, but the epilogue would have\n \t to restore it, so we can only use PC-relative PIC calls for\n@@ -7992,7 +7992,7 @@ label:\n       XEXP (operands[1], 0) = reg;\n     }\n   if (flag_pic && TARGET_SH2\n-      && GET_CODE (operands[1]) == MEM\n+      && MEM_P (operands[1])\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n       /* The PLT needs the PIC register, but the epilogue would have\n \t to restore it, so we can only use PC-relative PIC calls for\n@@ -8123,7 +8123,7 @@ label:\n       /* If epilogue clobbers r0, preserve it in macl.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \tif ((set = single_set (insn))\n-\t    && GET_CODE (SET_DEST (set)) == REG\n+\t    && REG_P (SET_DEST (set))\n \t    && REGNO (SET_DEST (set)) == R0_REG)\n \t  {\n \t    rtx r0 = gen_rtx_REG (SImode, R0_REG);\n@@ -9604,7 +9604,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"TARGET_SH2E\n    && (! reload_completed\n        || true_regnum (operands[0]) != FPSCR_REG\n-       || GET_CODE (operands[1]) != MEM\n+       || !MEM_P (operands[1])\n        || GET_CODE (XEXP (operands[1], 0)) != PLUS)\"\n   \"@\n \t! precision stays the same\n@@ -10862,7 +10862,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   size = bitsize / 8;\n   orig_address = XEXP (operands[0], 0);\n   shift_reg = gen_reg_rtx (SImode);\n-  if (GET_CODE (x) == CONST_INT)\n+  if (CONST_INT_P (x))\n     {\n       v = INTVAL (x);\n       qi_val = force_reg (QImode, GEN_INT (trunc_int_for_mode (v, QImode)));\n@@ -10879,7 +10879,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n   while (size -= 1)\n     {\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \tqi_val\n \t  = force_reg (QImode, GEN_INT (trunc_int_for_mode (v >>= 8, QImode)));\n       else\n@@ -10939,7 +10939,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   if (TARGET_SH4A_ARCH\n       && INTVAL (operands[2]) == 32\n       && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-      && GET_CODE (operands[1]) == MEM && MEM_ALIGN (operands[1]) < 32)\n+      && MEM_P (operands[1]) && MEM_ALIGN (operands[1]) < 32)\n     {\n       rtx src = adjust_address (operands[1], BLKmode, 0);\n       set_mem_size (src, GEN_INT (4));\n@@ -10971,7 +10971,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   if (TARGET_SH4A_ARCH\n       && INTVAL (operands[2]) == 32\n       && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-      && GET_CODE (operands[1]) == MEM && MEM_ALIGN (operands[1]) < 32)\n+      && MEM_P (operands[1]) && MEM_ALIGN (operands[1]) < 32)\n     {\n       rtx src = adjust_address (operands[1], BLKmode, 0);\n       set_mem_size (src, GEN_INT (4));\n@@ -11304,7 +11304,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (set (mem:SF (match_dup 0))\n \t(match_operand:SF 2 \"general_movsrc_operand\" \"\"))]\n   \"TARGET_SH1 && REGNO (operands[0]) == 0\n-   && ((GET_CODE (operands[2]) == REG && REGNO (operands[2]) < 16)\n+   && ((REG_P (operands[2]) && REGNO (operands[2]) < 16)\n        || (GET_CODE (operands[2]) == SUBREG\n \t   && REGNO (SUBREG_REG (operands[2])) < 16))\n    && reg_unused_after (operands[0], insn)\"\n@@ -11317,7 +11317,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n \t(mem:SF (match_dup 0)))]\n   \"TARGET_SH1 && REGNO (operands[0]) == 0\n-   && ((GET_CODE (operands[2]) == REG && REGNO (operands[2]) < 16)\n+   && ((REG_P (operands[2]) && REGNO (operands[2]) < 16)\n        || (GET_CODE (operands[2]) == SUBREG\n \t   && REGNO (SUBREG_REG (operands[2])) < 16))\n    && reg_unused_after (operands[0], insn)\"\n@@ -11329,7 +11329,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (set (mem:SF (match_dup 0))\n \t(match_operand:SF 2 \"general_movsrc_operand\" \"\"))]\n   \"TARGET_SH2E && REGNO (operands[0]) == 0\n-   && ((GET_CODE (operands[2]) == REG\n+   && ((REG_P (operands[2])\n         && FP_OR_XD_REGISTER_P (REGNO (operands[2])))\n        || (GET_CODE (operands[2]) == SUBREG\n \t   && FP_OR_XD_REGISTER_P (REGNO (SUBREG_REG (operands[2])))))\n@@ -11343,7 +11343,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n \t(mem:SF (match_dup 0)))]\n   \"TARGET_SH2E && REGNO (operands[0]) == 0\n-   && ((GET_CODE (operands[2]) == REG\n+   && ((REG_P (operands[2])\n \t&& FP_OR_XD_REGISTER_P (REGNO (operands[2])))\n        || (GET_CODE (operands[2]) == SUBREG\n \t   && FP_OR_XD_REGISTER_P (REGNO (SUBREG_REG (operands[2])))))\n@@ -11432,7 +11432,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   operands[1] = XVECEXP (operands[1], 0, 0);\n   if (unit_size < 2)\n     {\n-      if (GET_CODE (operands[1]) == CONST_INT && GET_CODE (elt1) == CONST_INT)\n+      if (CONST_INT_P (operands[1]) && CONST_INT_P (elt1))\n \toperands[1]\n \t  = GEN_INT (TARGET_LITTLE_ENDIAN\n \t\t     ? (INTVAL (operands[1]) & 0xff) + (INTVAL (elt1) << 8)\n@@ -13194,8 +13194,8 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"\n {\n   if (GET_MODE (operands[0]) != Pmode\n-      || GET_CODE (operands[1]) != CONST_INT\n-      || GET_CODE (operands[2]) != CONST_INT)\n+      || !CONST_INT_P (operands[1])\n+      || !CONST_INT_P (operands[2]))\n     FAIL;\n   if (! TARGET_SHMEDIA)\n     operands[0] = force_reg (Pmode, operands[0]);"}, {"sha": "b4dbc3fb3c2f6d3e844151b13b62b3e73ed0864c", "filename": "gcc/config/sh/symbian.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f353609778d9079592f24a6abcad0ae21e78b7e3/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=f353609778d9079592f24a6abcad0ae21e78b7e3", "patch": "@@ -217,7 +217,7 @@ sh_symbian_mark_dllexport (tree decl)\n   tree idp;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == MEM)\n+  if (MEM_P (rtlname))\n     rtlname = XEXP (rtlname, 0);\n   gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n   oldname = XSTR (rtlname, 0);\n@@ -262,7 +262,7 @@ sh_symbian_mark_dllimport (tree decl)\n   rtx newrtl;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == MEM)\n+  if (MEM_P (rtlname))\n     rtlname = XEXP (rtlname, 0);\n   gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n   oldname = XSTR (rtlname, 0);\n@@ -312,8 +312,8 @@ sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n   else if (  (TREE_CODE (decl) == FUNCTION_DECL\n \t   || TREE_CODE (decl) == VAR_DECL)\n \t   && DECL_RTL (decl) != NULL_RTX\n-\t   && GET_CODE (DECL_RTL (decl)) == MEM\n-\t   && GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n+\t   && MEM_P (DECL_RTL (decl))\n+\t   && MEM_P (XEXP (DECL_RTL (decl), 0))\n \t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n \t   && sh_symbian_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n     {"}]}