{"sha": "e03a46f571d5c4144e326ec9965db0a539473090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAzYTQ2ZjU3MWQ1YzQxNDRlMzI2ZWM5OTY1ZGIwYTUzOTQ3MzA5MA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-01-18T03:54:38Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-01-18T03:54:38Z"}, "message": "re PR tree-optimization/19121 (ICE: in merge_alias_info, at tree-ssa-copy.c:236)\n\n\n\tPR tree-optimization/19121\n\t* tree-ssa-alias.c (compute_flow_sensitive_aliasing): When\n\tadding aliases to a name tag, also add them to the pointer's\n\ttype tag.\n\t* tree-ssa-copy.c (merge_alias_info): Do not merge flow\n\tsensitive alias info at all.  Only check that the two pointers\n\thave compatible pointed-to sets.\n\t* tree-ssa.c (verify_name_tags): Verify that the alias set of\n\ta pointer's type tag is a superset of the alias set of the\n\tpointer's name tag.\n\ntestsuite/ChangeLog:\n\n\tPR tree-optimization/19121\n\t* gcc.c-torture/compile/pr19121.c: New test.\n\nFrom-SVN: r93810", "tree": {"sha": "0905041f83c7d584e9670c50b9a13715c323e6d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0905041f83c7d584e9670c50b9a13715c323e6d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e03a46f571d5c4144e326ec9965db0a539473090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03a46f571d5c4144e326ec9965db0a539473090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e03a46f571d5c4144e326ec9965db0a539473090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03a46f571d5c4144e326ec9965db0a539473090/comments", "author": null, "committer": null, "parents": [{"sha": "696a2ca15ffb199bf85594121380dc0d7399e0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696a2ca15ffb199bf85594121380dc0d7399e0c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/696a2ca15ffb199bf85594121380dc0d7399e0c9"}], "stats": {"total": 172, "additions": 124, "deletions": 48}, "files": [{"sha": "be9c0a45cb88487020c8b2883cb73b3d309ef9cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -1,3 +1,16 @@\n+2005-01-17  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19121\n+\t* tree-ssa-alias.c (compute_flow_sensitive_aliasing): When\n+\tadding aliases to a name tag, also add them to the pointer's\n+\ttype tag.\n+\t* tree-ssa-copy.c (merge_alias_info): Do not merge flow\n+\tsensitive alias info at all.  Only check that the two pointers\n+\thave compatible pointed-to sets.\n+\t* tree-ssa.c (verify_name_tags): Verify that the alias set of\n+\ta pointer's type tag is a superset of the alias set of the\n+\tpointer's name tag.\n+\n 2005-01-17  James E Wilson  <wilson@specifixinc.com>\n \n \tPR target/19357"}, {"sha": "3c1611399e655d1ec231b3eefa717f7ebc21124e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -1,3 +1,8 @@\n+2005-01-17  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19121\n+\t* gcc.c-torture/compile/pr19121.c: New test.\n+\n 2005-01-17  James E. Wilson  <wilson@specifixinc.com>\n \n \tPR target/19357"}, {"sha": "b8f4c21f9eee38e699dc93620f8ac674e37afd59", "filename": "gcc/testsuite/gcc.c-torture/compile/pr19121.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19121.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19121.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr19121.c?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -0,0 +1,23 @@\n+typedef struct interpreter {\n+  char Itokenbuf[256];\n+} PerlInterpreter;\n+static inline void S_missingterm(char *s)\n+{\n+  char tmpbuf[3] = \"\";\n+  char q;\n+  if (!s)\n+    s = tmpbuf;\n+  q = strchr(s,'\"') ? '\\'' : '\"';\n+}\n+void S_scan_heredoc(PerlInterpreter *my_perl, char *s, int i)\n+{\n+  char term;\n+  term = *my_perl->Itokenbuf;\n+  if (i)\n+  {\n+    *s = term;\n+    S_missingterm(my_perl->Itokenbuf);\n+  }\n+  else\n+    S_missingterm(my_perl->Itokenbuf);\n+}"}, {"sha": "a41021792a7061445f748916fddc46e211bd7800", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -913,6 +913,7 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n \t  {\n \t    add_may_alias (pi->name_mem_tag, referenced_var (j));\n+\t    add_may_alias (v_ann->type_mem_tag, referenced_var (j));\n \t  }\n \n       /* If the name tag is call clobbered, so is the type tag"}, {"sha": "c679eb221be8420dd45da9403869887c85c1dee8", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -178,10 +178,10 @@ merge_alias_info (tree orig, tree new)\n   tree orig_sym = SSA_NAME_VAR (orig);\n   var_ann_t new_ann = var_ann (new_sym);\n   var_ann_t orig_ann = var_ann (orig_sym);\n-  struct ptr_info_def *orig_ptr_info;\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (orig)));\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (new)));\n+\n #if defined ENABLE_CHECKING\n   gcc_assert (lang_hooks.types_compatible_p (TREE_TYPE (orig),\n \t\t\t\t\t     TREE_TYPE (new)));\n@@ -202,41 +202,30 @@ merge_alias_info (tree orig, tree new)\n   else\n     gcc_assert (new_ann->type_mem_tag == orig_ann->type_mem_tag);\n \n-  orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n-  if (orig_ptr_info && orig_ptr_info->name_mem_tag)\n-    {\n-      struct ptr_info_def *new_ptr_info = get_ptr_info (new);\n-\n-      if (new_ptr_info->name_mem_tag == NULL_TREE)\n-\t{\n-\t  /* If ORIG had a name tag, it means that was dereferenced in\n-\t     the code, and since pointer NEW will now replace every\n-\t     occurrence of ORIG, we have to make sure that NEW has an\n-\t     appropriate tag.  If, NEW did not have a name tag, get it\n-\t     from ORIG.  */\n-\t  memcpy (new_ptr_info, orig_ptr_info, sizeof (*new_ptr_info));\n-\t  new_ptr_info->pt_vars = BITMAP_GGC_ALLOC ();\n-\t  bitmap_copy (new_ptr_info->pt_vars, orig_ptr_info->pt_vars);\n-\t  new_ptr_info->name_mem_tag = orig_ptr_info->name_mem_tag;\n-\t}\n-      else\n-\t{\n-\t  /* If NEW already had a name tag, nothing needs to be done.\n-\t     Note that pointer NEW may actually have a different set of\n-\t     pointed-to variables.\n-\t     \n-\t     However, since NEW is being copy-propagated into ORIG, it must\n-\t     always be true that the pointed-to set for pointer NEW is the\n-\t     same, or a subset, of the pointed-to set for pointer ORIG.  If\n-\t     this isn't the case, we shouldn't have been able to do the\n-\t     propagation of NEW into ORIG.  */\n #if defined ENABLE_CHECKING\n-\t  if (orig_ptr_info->pt_vars && new_ptr_info->pt_vars)\n-\t    gcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n-\t\t\t\t\t    orig_ptr_info->pt_vars));\n-#endif\n-\t}\n+  {\n+    struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n+    struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new);\n+\n+    if (orig_ptr_info\n+\t&& new_ptr_info\n+\t&& orig_ptr_info->name_mem_tag\n+\t&& new_ptr_info->name_mem_tag\n+\t&& orig_ptr_info->pt_vars\n+\t&& new_ptr_info->pt_vars)\n+    {\n+      /* Note that pointer NEW may actually have a different set of\n+\t pointed-to variables.  However, since NEW is being\n+\t copy-propagated into ORIG, it must always be true that the\n+\t pointed-to set for pointer NEW is the same, or a subset, of\n+\t the pointed-to set for pointer ORIG.  If this isn't the case,\n+\t we shouldn't have been able to do the propagation of NEW into\n+\t ORIG.  */\n+      gcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n+\t\t\t\t      orig_ptr_info->pt_vars));\n     }\n+  }\n+#endif\n }   \n \n "}, {"sha": "fe608f61987e65ba767017d7e20160ed1221ecf2", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e03a46f571d5c4144e326ec9965db0a539473090/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e03a46f571d5c4144e326ec9965db0a539473090", "patch": "@@ -469,7 +469,11 @@ DEF_VEC_MALLOC_P (bitmap);\n    same name tag must have the same points-to set. \n    So we check a single variable for each name tag, and verify that its\n    points-to set is different from every other points-to set for other name\n-   tags.  */\n+   tags.\n+\n+   Additionally, given a pointer P_i with name tag NMT and type tag\n+   TMT, this function verified the alias set of TMT is a superset of\n+   the alias set of NMT.  */\n \n static void\n verify_name_tags (void)\n@@ -479,25 +483,62 @@ verify_name_tags (void)\n   bitmap first, second;  \n   VEC (tree) *name_tag_reps = NULL;\n   VEC (bitmap) *pt_vars_for_reps = NULL;\n+  bitmap type_aliases = BITMAP_XMALLOC ();\n \n   /* First we compute the name tag representatives and their points-to sets.  */\n   for (i = 0; i < num_ssa_names; i++)\n     {\n-      if (ssa_name (i))\n+      struct ptr_info_def *pi;\n+      tree tmt, ptr = ssa_name (i);\n+\n+      if (ptr == NULL_TREE)\n+\tcontinue;\n+      \n+      pi = SSA_NAME_PTR_INFO (ptr);\n+\n+      if (!TREE_VISITED (ptr) \n+\t  || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n+\t  || !pi\n+\t  || !pi->name_mem_tag \n+\t  || TREE_VISITED (pi->name_mem_tag))\n+\tcontinue;\n+\n+      TREE_VISITED (pi->name_mem_tag) = 1;\n+\n+      if (pi->pt_vars == NULL)\n+\tcontinue;\n+\n+      VEC_safe_push (tree, name_tag_reps, ptr);\n+      VEC_safe_push (bitmap, pt_vars_for_reps, pi->pt_vars);\n+\n+      /* Verify that alias set of PTR's type tag is a superset of the\n+\t alias set of PTR's name tag.  */\n+      tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+      if (tmt)\n \t{\n-\t  tree ptr = ssa_name (i);\n-\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n-\t  if (!TREE_VISITED (ptr) \n-\t      || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n-\t      || !pi\n-\t      || !pi->name_mem_tag \n-\t      || TREE_VISITED (pi->name_mem_tag))\n+\t  size_t i;\n+\t  varray_type aliases = var_ann (tmt)->may_aliases;\n+\t  bitmap_clear (type_aliases);\n+\t  for (i = 0; aliases && i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\t    {\n+\t      tree alias = VARRAY_TREE (aliases, i);\n+\t      bitmap_set_bit (type_aliases, var_ann (alias)->uid);\n+\t    }\n+\n+\t  /* When grouping, we may have added PTR's type tag into the\n+\t     alias set of PTR's name tag.  To prevent a false\n+\t     positive, pretend that TMT is in its own alias set.  */\n+\t  bitmap_set_bit (type_aliases, var_ann (tmt)->uid);\n+\n+\t  if (bitmap_equal_p (type_aliases, pi->pt_vars))\n \t    continue;\n-\t  TREE_VISITED (pi->name_mem_tag) = 1;\n-\t  if (pi->pt_vars != NULL)\n-\t    {    \n-\t      VEC_safe_push (tree, name_tag_reps, ptr);\n-\t      VEC_safe_push (bitmap, pt_vars_for_reps, pi->pt_vars);\n+\n+\t  if (!bitmap_intersect_compl_p (type_aliases, pi->pt_vars))\n+\t    {\n+\t      error (\"Alias set of a pointer's type tag should be a superset of the corresponding name tag\");\n+\t      debug_variable (tmt);\n+\t      debug_variable (pi->name_mem_tag);\n+\t      goto err;\n \t    }\n \t}\n     }\n@@ -532,13 +573,17 @@ verify_name_tags (void)\n \t  TREE_VISITED (pi->name_mem_tag) = 0;\n \t}\n     } \n+\n   VEC_free (bitmap, pt_vars_for_reps);\n+  BITMAP_FREE (type_aliases);\n   return;\n   \n err:\n   debug_variable (VEC_index (tree, name_tag_reps, i));\n   internal_error (\"verify_name_tags failed\");\n }\n+\n+\n /* Verify the consistency of aliasing information.  */\n \n static void"}]}