{"sha": "09359ea364bf042d6508b6098166bdaf9c61e254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzNTllYTM2NGJmMDQyZDY1MDhiNjA5ODE2NmJkYWY5YzYxZTI1NA==", "commit": {"author": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-10-30T18:28:36Z"}, "committer": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-10-30T18:28:36Z"}, "message": "Part 1/2 for contributing PPC64LE support for X86 SSE2 instrisics.\n\nPart 1/2 for contributing PPC64LE support for X86 SSE2\ninstrisics. This patch includes the new (for PPC) emmintrin.h,\nchanges x86intrin.h to include xmmintrin.h, and associated\nconfig.gcc changes.\n\nFrom-SVN: r254234", "tree": {"sha": "64831c310ca2d98564a3dc1915c5c3d2775aeed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64831c310ca2d98564a3dc1915c5c3d2775aeed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09359ea364bf042d6508b6098166bdaf9c61e254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09359ea364bf042d6508b6098166bdaf9c61e254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09359ea364bf042d6508b6098166bdaf9c61e254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09359ea364bf042d6508b6098166bdaf9c61e254/comments", "author": null, "committer": null, "parents": [{"sha": "1df07b3da8f37ac73c52dc5ee1be3d2b868e7989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df07b3da8f37ac73c52dc5ee1be3d2b868e7989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df07b3da8f37ac73c52dc5ee1be3d2b868e7989"}], "stats": {"total": 2350, "additions": 2349, "deletions": 1}, "files": [{"sha": "380ae334cf06eb0b7ac42a77ab2d26f6dfbc8a7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09359ea364bf042d6508b6098166bdaf9c61e254", "patch": "@@ -1,3 +1,9 @@\n+2017-10-30  Steven Munroe  <munroesj@gcc.gnu.org>\n+\n+\t* config.gcc (powerpc*-*-*): Add emmintrin.h.\n+\t* config/rs6000/emmintrin.h: New file.\n+\t* config/rs6000/x86intrin.h [__ALTIVEC__]: Include emmintrin.h.\n+\n 2017-10-30  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/arm/vfp.md (movdi_vfp): Merge changes from movdi_vfp_cortexa8."}, {"sha": "6b8ef51f13d374bc40797b08deb3d8a4399530b6", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=09359ea364bf042d6508b6098166bdaf9c61e254", "patch": "@@ -459,7 +459,7 @@ powerpc*-*-*)\n \textra_objs=\"rs6000-string.o rs6000-p8swap.o\"\n \textra_headers=\"ppc-asm.h altivec.h htmintrin.h htmxlintrin.h\"\n \textra_headers=\"${extra_headers} bmi2intrin.h bmiintrin.h\"\n-\textra_headers=\"${extra_headers} xmmintrin.h mm_malloc.h\"\n+\textra_headers=\"${extra_headers} xmmintrin.h mm_malloc.h emmintrin.h\"\n \textra_headers=\"${extra_headers} mmintrin.h x86intrin.h\"\n \textra_headers=\"${extra_headers} ppu_intrinsics.h spu2vmx.h vec_types.h si2vmx.h\"\n \textra_headers=\"${extra_headers} paired.h\""}, {"sha": "6a33ad9dd13551dabb3580dbd10133c827af4559", "filename": "gcc/config/rs6000/emmintrin.h", "status": "added", "additions": 2340, "deletions": 0, "changes": 2340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig%2Frs6000%2Femmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig%2Frs6000%2Femmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Femmintrin.h?ref=09359ea364bf042d6508b6098166bdaf9c61e254", "patch": "@@ -0,0 +1,2340 @@\n+/* Copyright (C) 2003-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 9.0.  */\n+\n+#ifndef NO_WARN_X86_INTRINSICS\n+/* This header is distributed to simplify porting x86_64 code that\n+   makes explicit use of Intel intrinsics to powerpc64le.\n+   It is the user's responsibility to determine if the results are\n+   acceptable and make additional changes as necessary.\n+   Note that much code that uses Intel intrinsics can be rewritten in\n+   standard C or GNU C extensions, which are more portable and better\n+   optimized across multiple targets.\n+\n+   In the specific case of X86 SSE2 (__m128i, __m128d) intrinsics,\n+   the PowerPC VMX/VSX ISA is a good match for vector double SIMD\n+   operations.  However scalar double operations in vector (XMM)\n+   registers require the POWER8 VSX ISA (2.07) level. Also there are\n+   important differences for data format and placement of double\n+   scalars in the vector register.\n+\n+   For PowerISA Scalar double is in FPRs (left most 64-bits of the\n+   low 32 VSRs), while X86_64 SSE2 uses the right most 64-bits of\n+   the XMM. These differences require extra steps on POWER to match\n+   the SSE2 scalar double semantics.\n+\n+   Most SSE2 scalar double intrinsic operations can be performed more\n+   efficiently as C language double scalar operations or optimized to\n+   use vector SIMD operations.  We recommend this for new applications.\n+\n+   Another difference is the format and details of the X86_64 MXSCR vs\n+   the PowerISA FPSCR / VSCR registers. We recommend applications\n+   replace direct access to the MXSCR with the more portable <fenv.h>\n+   Posix APIs. */\n+#warning \"Please read comment above.  Use -DNO_WARN_X86_INTRINSICS to disable this warning.\"\n+#endif\n+\n+#ifndef EMMINTRIN_H_\n+#define EMMINTRIN_H_\n+\n+#include <altivec.h>\n+#include <assert.h>\n+\n+/* We need definitions from the SSE header files.  */\n+#include <xmmintrin.h>\n+\n+/* SSE2 */\n+typedef __vector double __v2df;\n+typedef __vector long long __v2di;\n+typedef __vector unsigned long long __v2du;\n+typedef __vector int __v4si;\n+typedef __vector unsigned int __v4su;\n+typedef __vector short __v8hi;\n+typedef __vector unsigned short __v8hu;\n+typedef __vector signed char __v16qi;\n+typedef __vector unsigned char __v16qu;\n+\n+/* The Intel API is flexible enough that we must allow aliasing with other\n+   vector types, and their scalar components.  */\n+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));\n+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+/* Unaligned version of the same types.  */\n+typedef long long __m128i_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n+typedef double __m128d_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n+\n+/* Create a vector with element 0 as F and the rest zero.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_sd (double __F)\n+{\n+  return __extension__ (__m128d){ __F, 0.0 };\n+}\n+\n+/* Create a vector with both elements equal to F.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_pd (double __F)\n+{\n+  return __extension__ (__m128d){ __F, __F };\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pd1 (double __F)\n+{\n+  return _mm_set1_pd (__F);\n+}\n+\n+/* Create a vector with the lower value X and upper value W.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pd (double __W, double __X)\n+{\n+  return __extension__ (__m128d){ __X, __W };\n+}\n+\n+/* Create a vector with the lower value W and upper value X.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_pd (double __W, double __X)\n+{\n+  return __extension__ (__m128d){ __W, __X };\n+}\n+\n+/* Create an undefined vector.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_undefined_pd (void)\n+{\n+  __m128d __Y = __Y;\n+  return __Y;\n+}\n+\n+/* Create a vector of zeros.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setzero_pd (void)\n+{\n+  return (__m128d) vec_splats (0);\n+}\n+\n+/* Sets the low DPFP value of A from the low value of B.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_move_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df result = (__v2df) __A;\n+  result [0] = ((__v2df) __B)[0];\n+  return (__m128d) result;\n+}\n+\n+/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_pd (double const *__P)\n+{\n+  assert(((unsigned long)__P & 0xfUL) == 0UL);\n+  return ((__m128d)vec_ld(0, (__v16qu*)__P));\n+}\n+\n+/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadu_pd (double const *__P)\n+{\n+  return (vec_vsx_ld(0, __P));\n+}\n+\n+/* Create a vector with all two elements equal to *P.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load1_pd (double const *__P)\n+{\n+  return (vec_splats (*__P));\n+}\n+\n+/* Create a vector with element 0 as *P and the rest zero.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_sd (double const *__P)\n+{\n+  return _mm_set_sd (*__P);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_pd1 (double const *__P)\n+{\n+  return _mm_load1_pd (__P);\n+}\n+\n+/* Load two DPFP values in reverse order.  The address must be aligned.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadr_pd (double const *__P)\n+{\n+  __v2df __tmp = _mm_load_pd (__P);\n+  return (__m128d)vec_xxpermdi (__tmp, __tmp, 2);\n+}\n+\n+/* Store two DPFP values.  The address must be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_pd (double *__P, __m128d __A)\n+{\n+  assert(((unsigned long)__P & 0xfUL) == 0UL);\n+  vec_st((__v16qu)__A, 0, (__v16qu*)__P);\n+}\n+\n+/* Store two DPFP values.  The address need not be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storeu_pd (double *__P, __m128d __A)\n+{\n+  *(__m128d *)__P = __A;\n+}\n+\n+/* Stores the lower DPFP value.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_sd (double *__P, __m128d __A)\n+{\n+  *__P = ((__v2df)__A)[0];\n+}\n+\n+extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsd_f64 (__m128d __A)\n+{\n+  return ((__v2df)__A)[0];\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storel_pd (double *__P, __m128d __A)\n+{\n+  _mm_store_sd (__P, __A);\n+}\n+\n+/* Stores the upper DPFP value.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storeh_pd (double *__P, __m128d __A)\n+{\n+  *__P = ((__v2df)__A)[1];\n+}\n+/* Store the lower DPFP value across two words.\n+   The address must be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store1_pd (double *__P, __m128d __A)\n+{\n+  _mm_store_pd (__P, vec_splat (__A, 0));\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_pd1 (double *__P, __m128d __A)\n+{\n+  _mm_store1_pd (__P, __A);\n+}\n+\n+/* Store two DPFP values in reverse order.  The address must be aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storer_pd (double *__P, __m128d __A)\n+{\n+  _mm_store_pd (__P, vec_xxpermdi (__A, __A, 2));\n+}\n+\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi128_si64 (__m128i __A)\n+{\n+  return ((__v2di)__A)[0];\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi128_si64x (__m128i __A)\n+{\n+  return ((__v2di)__A)[0];\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) ((__v2df)__A + (__v2df)__B);\n+}\n+\n+/* Add the lower double-precision (64-bit) floating-point element in\n+   a and b, store the result in the lower element of dst, and copy\n+   the upper element from a to the upper element of dst. */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_sd (__m128d __A, __m128d __B)\n+{\n+  __A[0] = __A[0] + __B[0];\n+  return (__A);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) ((__v2df)__A - (__v2df)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_sd (__m128d __A, __m128d __B)\n+{\n+  __A[0] = __A[0] - __B[0];\n+  return (__A);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) ((__v2df)__A * (__v2df)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_sd (__m128d __A, __m128d __B)\n+{\n+  __A[0] = __A[0] * __B[0];\n+  return (__A);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_div_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) ((__v2df)__A / (__v2df)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_div_sd (__m128d __A, __m128d __B)\n+{\n+  __A[0] = __A[0] / __B[0];\n+  return (__A);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sqrt_pd (__m128d __A)\n+{\n+  return (vec_sqrt (__A));\n+}\n+\n+/* Return pair {sqrt (B[0]), A[1]}.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sqrt_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df c;\n+  c = vec_sqrt ((__v2df) _mm_set1_pd (__B[0]));\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_min (__A, __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = vec_min (a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_max (__A, __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = vec_max (a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmpeq ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmplt ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmple_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmple ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmpgt ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpge_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmpge ((__v2df) __A,(__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpneq_pd (__m128d __A, __m128d __B)\n+{\n+  __v2df temp = (__v2df) vec_cmpeq ((__v2df) __A, (__v2df)__B);\n+  return ((__m128d)vec_nor (temp, temp));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnlt_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmpge ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnle_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmpgt ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpngt_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmple ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnge_pd (__m128d __A, __m128d __B)\n+{\n+  return ((__m128d)vec_cmplt ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpord_pd (__m128d __A, __m128d __B)\n+{\n+#if _ARCH_PWR8\n+  __v2du c, d;\n+  /* Compare against self will return false (0's) if NAN.  */\n+  c = (__v2du)vec_cmpeq (__A, __A);\n+  d = (__v2du)vec_cmpeq (__B, __B);\n+#else\n+  __v2du a, b;\n+  __v2du c, d;\n+  const __v2du double_exp_mask  = {0x7ff0000000000000, 0x7ff0000000000000};\n+  a = (__v2du)vec_abs ((__v2df)__A);\n+  b = (__v2du)vec_abs ((__v2df)__B);\n+  c = (__v2du)vec_cmpgt (double_exp_mask, a);\n+  d = (__v2du)vec_cmpgt (double_exp_mask, b);\n+#endif\n+  /* A != NAN and B != NAN.  */\n+  return ((__m128d)vec_and(c, d));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpunord_pd (__m128d __A, __m128d __B)\n+{\n+#if _ARCH_PWR8\n+  __v2du c, d;\n+  /* Compare against self will return false (0's) if NAN.  */\n+  c = (__v2du)vec_cmpeq ((__v2df)__A, (__v2df)__A);\n+  d = (__v2du)vec_cmpeq ((__v2df)__B, (__v2df)__B);\n+  /* A == NAN OR B == NAN converts too:\n+     NOT(A != NAN) OR NOT(B != NAN).  */\n+  c = vec_nor (c, c);\n+  return ((__m128d)vec_orc(c, d));\n+#else\n+  __v2du c, d;\n+  /* Compare against self will return false (0's) if NAN.  */\n+  c = (__v2du)vec_cmpeq ((__v2df)__A, (__v2df)__A);\n+  d = (__v2du)vec_cmpeq ((__v2df)__B, (__v2df)__B);\n+  /* Convert the true ('1's) is NAN.  */\n+  c = vec_nor (c, c);\n+  d = vec_nor (d, d);\n+  return ((__m128d)vec_or(c, d));\n+#endif\n+}\n+\n+extern __inline  __m128d  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_sd(__m128d  __A, __m128d  __B)\n+{\n+  __v2df a, b, c;\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+     results. So to insure we don't generate spurious exceptions\n+     (from the upper double values) we splat the lower double\n+     before we do the operation. */\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmpeq(a, b);\n+  /* Then we merge the lower double result with the original upper\n+     double from __A.  */\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmplt(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmple_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmple(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmpgt(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpge_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmpge(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpneq_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  c = (__v2df) vec_cmpeq(a, b);\n+  c = vec_nor (c, c);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnlt_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  /* Not less than is just greater than or equal.  */\n+  c = (__v2df) vec_cmpge(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnle_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  /* Not less than or equal is just greater than.  */\n+  c = (__v2df) vec_cmpge(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpngt_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  /* Not greater than is just less than or equal.  */\n+  c = (__v2df) vec_cmple(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnge_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df a, b, c;\n+  a = vec_splats (__A[0]);\n+  b = vec_splats (__B[0]);\n+  /* Not greater than or equal is just less than.  */\n+  c = (__v2df) vec_cmplt(a, b);\n+  return (__m128d) _mm_setr_pd (c[0], __A[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpord_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df r;\n+  r = (__v2df)_mm_cmpord_pd (vec_splats (__A[0]), vec_splats (__B[0]));\n+  return (__m128d) _mm_setr_pd (r[0], ((__v2df)__A)[1]);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpunord_sd (__m128d __A, __m128d __B)\n+{\n+  __v2df r;\n+  r = _mm_cmpunord_pd (vec_splats (__A[0]), vec_splats (__B[0]));\n+  return (__m128d) _mm_setr_pd (r[0], __A[1]);\n+}\n+\n+/* FIXME\n+   The __mm_comi??_sd and __mm_ucomi??_sd implementations below are\n+   exactly the same because GCC for PowerPC only generates unordered\n+   compares (scalar and vector).\n+   Technically __mm_comieq_sp et all should be using the ordered\n+   compare and signal for QNaNs.  The __mm_ucomieq_sd et all should\n+   be OK.   */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comieq_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] == __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comilt_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] < __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comile_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] <= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comigt_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] > __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comige_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] >= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comineq_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] != __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomieq_sd (__m128d __A, __m128d __B)\n+{\n+\treturn (__A[0] == __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomilt_sd (__m128d __A, __m128d __B)\n+{\n+\treturn (__A[0] < __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomile_sd (__m128d __A, __m128d __B)\n+{\n+\treturn (__A[0] <= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomigt_sd (__m128d __A, __m128d __B)\n+{\n+\treturn (__A[0] > __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomige_sd (__m128d __A, __m128d __B)\n+{\n+\treturn (__A[0] >= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomineq_sd (__m128d __A, __m128d __B)\n+{\n+  return (__A[0] != __B[0]);\n+}\n+\n+/* Create a vector of Qi, where i is the element number.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_epi64x (long long __q1, long long __q0)\n+{\n+  return __extension__ (__m128i)(__v2di){ __q0, __q1 };\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_epi64 (__m64 __q1,  __m64 __q0)\n+{\n+  return _mm_set_epi64x ((long long)__q1, (long long)__q0);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n+{\n+  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,\n+\t       short __q3, short __q2, short __q1, short __q0)\n+{\n+  return __extension__ (__m128i)(__v8hi){\n+    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n+\t      char __q11, char __q10, char __q09, char __q08,\n+\t      char __q07, char __q06, char __q05, char __q04,\n+\t      char __q03, char __q02, char __q01, char __q00)\n+{\n+  return __extension__ (__m128i)(__v16qi){\n+    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,\n+    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15\n+  };\n+}\n+\n+/* Set all of the elements of the vector to A.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_epi64x (long long __A)\n+{\n+  return _mm_set_epi64x (__A, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_epi64 (__m64 __A)\n+{\n+  return _mm_set_epi64 (__A, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_epi32 (int __A)\n+{\n+  return _mm_set_epi32 (__A, __A, __A, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_epi16 (short __A)\n+{\n+  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_epi8 (char __A)\n+{\n+  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,\n+\t\t       __A, __A, __A, __A, __A, __A, __A, __A);\n+}\n+\n+/* Create a vector of Qi, where i is the element number.\n+   The parameter order is reversed from the _mm_set_epi* functions.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_epi64 (__m64 __q0, __m64 __q1)\n+{\n+  return _mm_set_epi64 (__q1, __q0);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)\n+{\n+  return _mm_set_epi32 (__q3, __q2, __q1, __q0);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,\n+\t        short __q4, short __q5, short __q6, short __q7)\n+{\n+  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n+\t       char __q04, char __q05, char __q06, char __q07,\n+\t       char __q08, char __q09, char __q10, char __q11,\n+\t       char __q12, char __q13, char __q14, char __q15)\n+{\n+  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,\n+\t\t       __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);\n+}\n+\n+/* Create a vector with element 0 as *P and the rest zero.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_si128 (__m128i const *__P)\n+{\n+  return *__P;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadu_si128 (__m128i_u const *__P)\n+{\n+  return (__m128i) (vec_vsx_ld(0, (signed int const *)__P));\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadl_epi64 (__m128i_u const *__P)\n+{\n+  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_si128 (__m128i *__P, __m128i __B)\n+{\n+  assert(((unsigned long )__P & 0xfUL) == 0UL);\n+  vec_st ((__v16qu) __B, 0, (__v16qu*)__P);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n+{\n+  *__P = __B;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storel_epi64 (__m128i_u *__P, __m128i __B)\n+{\n+  *(long long *)__P = ((__v2di)__B)[0];\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movepi64_pi64 (__m128i_u __B)\n+{\n+  return (__m64) ((__v2di)__B)[0];\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movpi64_epi64 (__m64 __A)\n+{\n+  return _mm_set_epi64 ((__m64)0LL, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_move_epi64 (__m128i __A)\n+{\n+  return _mm_set_epi64 ((__m64)0LL, (__m64)__A[0]);\n+}\n+\n+/* Create an undefined vector.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_undefined_si128 (void)\n+{\n+  __m128i __Y = __Y;\n+  return __Y;\n+}\n+\n+/* Create a vector of zeros.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setzero_si128 (void)\n+{\n+  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtepi32_pd (__m128i __A)\n+{\n+  __v2di val;\n+  /* For LE need to generate Vector Unpack Low Signed Word.\n+     Which is generated from unpackh.  */\n+  val = (__v2di)vec_unpackh ((__v4si)__A);\n+\n+  return (__m128d)vec_ctf (val, 0);\n+}\n+#endif\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtepi32_ps (__m128i __A)\n+{\n+  return ((__m128)vec_ctf((__v4si)__A, 0));\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpd_epi32 (__m128d __A)\n+{\n+  __v2df rounded = vec_rint (__A);\n+  __v4si result, temp;\n+  const __v4si vzero =\n+    { 0, 0, 0, 0 };\n+\n+  /* VSX Vector truncate Double-Precision to integer and Convert to\n+   Signed Integer Word format with Saturate.  */\n+  __asm__(\n+      \"xvcvdpsxws %x0,%x1\"\n+      : \"=wa\" (temp)\n+      : \"wa\" (rounded)\n+      : );\n+\n+#ifdef _ARCH_PWR8\n+  temp = vec_mergeo (temp, temp);\n+  result = (__v4si)vec_vpkudum ((vector long)temp, (vector long)vzero);\n+#else\n+  {\n+    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,\n+\t0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };\n+    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);\n+  }\n+#endif\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpd_pi32 (__m128d __A)\n+{\n+  __m128i result = _mm_cvtpd_epi32(__A);\n+\n+  return (__m64) result[0];\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpd_ps (__m128d __A)\n+{\n+  __v4sf result;\n+  __v4si temp;\n+  const __v4si vzero = { 0, 0, 0, 0 };\n+\n+  __asm__(\n+      \"xvcvdpsp %x0,%x1\"\n+      : \"=wa\" (temp)\n+      : \"wa\" (__A)\n+      : );\n+\n+#ifdef _ARCH_PWR8\n+  temp = vec_mergeo (temp, temp);\n+  result = (__v4sf)vec_vpkudum ((vector long)temp, (vector long)vzero);\n+#else\n+  {\n+    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,\n+\t0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };\n+    result = (__v4sf) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);\n+  }\n+#endif\n+  return ((__m128)result);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttpd_epi32 (__m128d __A)\n+{\n+  __v4si result;\n+  __v4si temp;\n+  const __v4si vzero = { 0, 0, 0, 0 };\n+\n+  /* VSX Vector truncate Double-Precision to integer and Convert to\n+   Signed Integer Word format with Saturate.  */\n+  __asm__(\n+      \"xvcvdpsxws %x0,%x1\"\n+      : \"=wa\" (temp)\n+      : \"wa\" (__A)\n+      : );\n+\n+#ifdef _ARCH_PWR8\n+  temp = vec_mergeo (temp, temp);\n+  result = (__v4si)vec_vpkudum ((vector long)temp, (vector long)vzero);\n+#else\n+  {\n+    const __v16qu pkperm = {0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b,\n+\t0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f };\n+    result = (__v4si) vec_perm ((__v16qu) temp, (__v16qu) vzero, pkperm);\n+  }\n+#endif\n+\n+  return ((__m128i) result);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttpd_pi32 (__m128d __A)\n+{\n+  __m128i result = _mm_cvttpd_epi32 (__A);\n+\n+  return (__m64) result[0];\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi128_si32 (__m128i __A)\n+{\n+  return ((__v4si)__A)[0];\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpi32_pd (__m64 __A)\n+{\n+  __v4si temp;\n+  __v2di tmp2;\n+  __v2df result;\n+\n+  temp = (__v4si)vec_splats (__A);\n+  tmp2 = (__v2di)vec_unpackl (temp);\n+  result = vec_ctf ((__vector signed long)tmp2, 0);\n+  return (__m128d)result;\n+}\n+#endif\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtps_epi32 (__m128 __A)\n+{\n+  __v4sf rounded;\n+  __v4si result;\n+\n+  rounded = vec_rint((__v4sf) __A);\n+  result = vec_cts (rounded, 0);\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttps_epi32 (__m128 __A)\n+{\n+  __v4si result;\n+\n+  result = vec_cts ((__v4sf) __A, 0);\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtps_pd (__m128 __A)\n+{\n+  /* Check if vec_doubleh is defined by <altivec.h>. If so use that. */\n+#ifdef vec_doubleh\n+  return (__m128d) vec_doubleh ((__v4sf)__A);\n+#else\n+  /* Otherwise the compiler is not current and so need to generate the\n+     equivalent code.  */\n+  __v4sf a = (__v4sf)__A;\n+  __v4sf temp;\n+  __v2df result;\n+#ifdef __LITTLE_ENDIAN__\n+  /* The input float values are in elements {[0], [1]} but the convert\n+     instruction needs them in elements {[1], [3]}, So we use two\n+     shift left double vector word immediates to get the elements\n+     lined up.  */\n+  temp = __builtin_vsx_xxsldwi (a, a, 3);\n+  temp = __builtin_vsx_xxsldwi (a, temp, 2);\n+#elif __BIG_ENDIAN__\n+  /* The input float values are in elements {[0], [1]} but the convert\n+     instruction needs them in elements {[0], [2]}, So we use two\n+     shift left double vector word immediates to get the elements\n+     lined up.  */\n+  temp = vec_vmrghw (a, a);\n+#endif\n+  __asm__(\n+      \" xvcvspdp %x0,%x1\"\n+      : \"=wa\" (result)\n+      : \"wa\" (temp)\n+      : );\n+  return (__m128d) result;\n+#endif\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsd_si32 (__m128d __A)\n+{\n+  __v2df rounded = vec_rint((__v2df) __A);\n+  int result = ((__v2df)rounded)[0];\n+\n+  return result;\n+}\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsd_si64 (__m128d __A)\n+{\n+  __v2df rounded = vec_rint ((__v2df) __A );\n+  long long result = ((__v2df) rounded)[0];\n+\n+  return result;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsd_si64x (__m128d __A)\n+{\n+  return _mm_cvtsd_si64 ((__v2df)__A);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttsd_si32 (__m128d __A)\n+{\n+  int result = ((__v2df)__A)[0];\n+\n+  return result;\n+}\n+\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttsd_si64 (__m128d __A)\n+{\n+  long long result = ((__v2df)__A)[0];\n+\n+  return result;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttsd_si64x (__m128d __A)\n+{\n+  return _mm_cvttsd_si64 (__A);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsd_ss (__m128 __A, __m128d __B)\n+{\n+  __v4sf result = (__v4sf)__A;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  __v4sf temp_s;\n+  /* Copy double element[0] to element [1] for conversion.  */\n+  __v2df temp_b = vec_splat((__v2df)__B, 0);\n+\n+  /* Pre-rotate __A left 3 (logically right 1) elements.  */\n+  result = __builtin_vsx_xxsldwi (result, result, 3);\n+  /* Convert double to single float scalar in a vector.  */\n+  __asm__(\n+      \"xscvdpsp %x0,%x1\"\n+      : \"=wa\" (temp_s)\n+      : \"wa\" (temp_b)\n+      : );\n+  /* Shift the resulting scalar into vector element [0].  */\n+  result = __builtin_vsx_xxsldwi (result, temp_s, 1);\n+#else\n+  result [0] = ((__v2df)__B)[0];\n+#endif\n+  return (__m128) result;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi32_sd (__m128d __A, int __B)\n+{\n+  __v2df result = (__v2df)__A;\n+  double db = __B;\n+  result [0] = db;\n+  return (__m128d)result;\n+}\n+\n+/* Intel intrinsic.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_sd (__m128d __A, long long __B)\n+{\n+  __v2df result = (__v2df)__A;\n+  double db = __B;\n+  result [0] = db;\n+  return (__m128d)result;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64x_sd (__m128d __A, long long __B)\n+{\n+  return _mm_cvtsi64_sd (__A, __B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtss_sd (__m128d __A, __m128 __B)\n+{\n+#ifdef __LITTLE_ENDIAN__\n+  /* Use splat to move element [0] into position for the convert. */\n+  __v4sf temp = vec_splat ((__v4sf)__B, 0);\n+  __v2df res;\n+  /* Convert single float scalar to double in a vector.  */\n+  __asm__(\n+      \"xscvspdp %x0,%x1\"\n+      : \"=wa\" (res)\n+      : \"wa\" (temp)\n+      : );\n+  return (__m128d) vec_mergel (res, (__v2df)__A);\n+#else\n+  __v2df res = (__v2df)__A;\n+  res [0] = ((__v4sf)__B) [0];\n+  return (__m128d) res;\n+#endif\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)\n+{\n+  __vector double result;\n+  const int litmsk = __mask & 0x3;\n+\n+  if (litmsk == 0)\n+    result = vec_mergeh (__A, __B);\n+#if __GNUC__ < 6\n+  else if (litmsk == 1)\n+    result = vec_xxpermdi (__B, __A, 2);\n+  else if (litmsk == 2)\n+    result = vec_xxpermdi (__B, __A, 1);\n+#else\n+  else if (litmsk == 1)\n+    result = vec_xxpermdi (__A, __B, 2);\n+  else if (litmsk == 2)\n+    result = vec_xxpermdi (__A, __B, 1);\n+#endif\n+  else\n+    result = vec_mergel (__A, __B);\n+\n+  return result;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) vec_mergel ((__v2df)__A, (__v2df)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_pd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) vec_mergeh ((__v2df)__A, (__v2df)__B);\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadh_pd (__m128d __A, double const *__B)\n+{\n+  __v2df result = (__v2df)__A;\n+  result [1] = *__B;\n+  return (__m128d)result;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadl_pd (__m128d __A, double const *__B)\n+{\n+  __v2df result = (__v2df)__A;\n+  result [0] = *__B;\n+  return (__m128d)result;\n+}\n+\n+#ifdef _ARCH_PWR8\n+/* Intrinsic functions that require PowerISA 2.07 minimum.  */\n+\n+/* Creates a 2-bit mask from the most significant bits of the DPFP values.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movemask_pd (__m128d  __A)\n+{\n+  __vector __m64 result;\n+  static const __vector unsigned int perm_mask =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t0x80800040, 0x80808080, 0x80808080, 0x80808080\n+#elif __BIG_ENDIAN__\n+      0x80808080, 0x80808080, 0x80808080, 0x80800040\n+#endif\n+    };\n+\n+  result = (__vector __m64) vec_vbpermq ((__vector unsigned char) __A,\n+\t\t\t\t\t (__vector unsigned char) perm_mask);\n+\n+#ifdef __LITTLE_ENDIAN__\n+  return result[1];\n+#elif __BIG_ENDIAN__\n+  return result[0];\n+#endif\n+}\n+#endif /* _ARCH_PWR8 */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packs_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_packs ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packs_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_packs ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packus_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_packsu ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergel ((__v16qu)__A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergel ((__v8hu)__A, (__v8hu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergel ((__v4su)__A, (__v4su)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_epi64 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergel ((__vector long)__A, (__vector long)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergeh ((__v16qu)__A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergeh ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergeh ((__v4si)__A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_epi64 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_mergeh ((__vector long)__A, (__vector long)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v16qu)__A + (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v8hu)__A + (__v8hu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v4su)__A + (__v4su)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_epi64 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v2du)__A + (__v2du)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_adds ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_adds ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_epu8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_adds ((__v16qu)__A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_epu16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_adds ((__v8hu)__A, (__v8hu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v16qu)__A - (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v8hu)__A - (__v8hu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v4su)__A - (__v4su)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_epi64 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) ((__v2du)__A - (__v2du)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_subs ((__v16qi)__A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_subs ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_epu8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_subs ((__v16qu)__A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_epu16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_subs ((__v8hu)__A, (__v8hu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_madd_epi16 (__m128i __A, __m128i __B)\n+{\n+  __vector signed int zero = {0, 0, 0, 0};\n+\n+  return (__m128i) vec_vmsumshm ((__v8hi)__A, (__v8hi)__B, zero);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mulhi_epi16 (__m128i __A, __m128i __B)\n+{\n+  __vector signed int w0, w1;\n+\n+  __vector unsigned char xform1 = {\n+#ifdef __LITTLE_ENDIAN__\n+      0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,\n+      0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F\n+#elif __BIG_ENDIAN__\n+      0x00, 0x01, 0x10, 0x11,  0x04, 0x05, 0x14, 0x15,\n+      0x08, 0x09, 0x18, 0x19,  0x0C, 0x0D, 0x1C, 0x1D\n+#endif\n+    };\n+\n+  w0 = vec_vmulesh ((__v8hi)__A, (__v8hi)__B);\n+  w1 = vec_vmulosh ((__v8hi)__A, (__v8hi)__B);\n+  return (__m128i) vec_perm (w0, w1, xform1);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mullo_epi16 (__m128i __A, __m128i __B)\n+{\n+    return (__m128i) ((__v8hi)__A * (__v8hi)__B);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_su32 (__m64 __A, __m64 __B)\n+{\n+  unsigned int a = __A;\n+  unsigned int b = __B;\n+\n+  return ((__m64)a * (__m64)b);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_epu32 (__m128i __A, __m128i __B)\n+{\n+#if __GNUC__ < 8\n+  __v2du result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  /* VMX Vector Multiply Odd Unsigned Word.  */\n+  __asm__(\n+      \"vmulouw %0,%1,%2\"\n+      : \"=v\" (result)\n+      : \"v\" (__A), \"v\" (__B)\n+      : );\n+#elif __BIG_ENDIAN__\n+  /* VMX Vector Multiply Even Unsigned Word.  */\n+  __asm__(\n+      \"vmuleuw %0,%1,%2\"\n+      : \"=v\" (result)\n+      : \"v\" (__A), \"v\" (__B)\n+      : );\n+#endif\n+  return (__m128i) result;\n+#else\n+#ifdef __LITTLE_ENDIAN__\n+  return (__m128i) vec_mule ((__v4su)__A, (__v4su)__B);\n+#elif __BIG_ENDIAN__\n+  return (__m128i) vec_mulo ((__v4su)__A, (__v4su)__B);\n+#endif\n+#endif\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_epi16 (__m128i __A, int __B)\n+{\n+  __v8hu lshift;\n+  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+  if (__B < 16)\n+    {\n+      if (__builtin_constant_p(__B))\n+\t  lshift = (__v8hu) vec_splat_s16(__B);\n+      else\n+\t  lshift = vec_splats ((unsigned short) __B);\n+\n+      result = vec_vslh ((__v8hi) __A, lshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_epi32 (__m128i __A, int __B)\n+{\n+  __v4su lshift;\n+  __v4si result = { 0, 0, 0, 0 };\n+\n+  if (__B < 32)\n+    {\n+      if (__builtin_constant_p(__B))\n+\tlshift = (__v4su) vec_splat_s32(__B);\n+      else\n+\tlshift = vec_splats ((unsigned int) __B);\n+\n+      result = vec_vslw ((__v4si) __A, lshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_epi64 (__m128i __A, int __B)\n+{\n+  __v2du lshift;\n+  __v2di result = { 0, 0 };\n+\n+  if (__B < 64)\n+    {\n+      if (__builtin_constant_p(__B))\n+\t{\n+\t  if (__B < 32)\n+\t      lshift = (__v2du) vec_splat_s32(__B);\n+\t    else\n+\t      lshift = (__v2du) vec_splats((unsigned long long)__B);\n+\t}\n+      else\n+\t  lshift = (__v2du) vec_splats ((unsigned int) __B);\n+\n+      result = vec_vsld ((__v2di) __A, lshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+#endif\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srai_epi16 (__m128i __A, int __B)\n+{\n+  __v8hu rshift = { 15, 15, 15, 15, 15, 15, 15, 15 };\n+  __v8hi result;\n+\n+  if (__B < 16)\n+    {\n+      if (__builtin_constant_p(__B))\n+\trshift = (__v8hu) vec_splat_s16(__B);\n+      else\n+\trshift = vec_splats ((unsigned short) __B);\n+    }\n+  result = vec_vsrah ((__v8hi) __A, rshift);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srai_epi32 (__m128i __A, int __B)\n+{\n+  __v4su rshift = { 31, 31, 31, 31 };\n+  __v4si result;\n+\n+  if (__B < 32)\n+    {\n+      if (__builtin_constant_p(__B))\n+\t{\n+\t  if (__B < 16)\n+\t      rshift = (__v4su) vec_splat_s32(__B);\n+\t    else\n+\t      rshift = (__v4su) vec_splats((unsigned int)__B);\n+\t}\n+      else\n+\trshift = vec_splats ((unsigned int) __B);\n+    }\n+  result = vec_vsraw ((__v4si) __A, rshift);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_bslli_si128 (__m128i __A, const int __N)\n+{\n+  __v16qu result;\n+  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+  if (__N < 16)\n+    result = vec_sld ((__v16qu) __A, zeros, __N);\n+  else\n+    result = zeros;\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_bsrli_si128 (__m128i __A, const int __N)\n+{\n+  __v16qu result;\n+  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+  if (__N < 16)\n+    if (__builtin_constant_p(__N))\n+      /* Would like to use Vector Shift Left Double by Octet\n+\t Immediate here to use the immediate form and avoid\n+\t load of __N * 8 value into a separate VR.  */\n+      result = vec_sld (zeros, (__v16qu) __A, (16 - __N));\n+    else\n+      {\n+\t__v16qu shift = vec_splats((unsigned char)(__N*8));\n+\tresult = vec_sro ((__v16qu)__A, shift);\n+      }\n+  else\n+    result = zeros;\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_si128 (__m128i __A, const int __N)\n+{\n+  return _mm_bsrli_si128 (__A, __N);\n+}\n+\n+extern __inline  __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_si128 (__m128i __A, const int _imm5)\n+{\n+  __v16qu result;\n+  const __v16qu zeros = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+  if (_imm5 < 16)\n+#ifdef __LITTLE_ENDIAN__\n+    result = vec_sld ((__v16qu) __A, zeros, _imm5);\n+#elif __BIG_ENDIAN__\n+    result = vec_sld (zeros, (__v16qu) __A, (16 - _imm5));\n+#endif\n+  else\n+    result = zeros;\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+\n+_mm_srli_epi16 (__m128i  __A, int __B)\n+{\n+  __v8hu rshift;\n+  __v8hi result = { 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+  if (__B < 16)\n+    {\n+      if (__builtin_constant_p(__B))\n+\trshift = (__v8hu) vec_splat_s16(__B);\n+      else\n+\trshift = vec_splats ((unsigned short) __B);\n+\n+      result = vec_vsrh ((__v8hi) __A, rshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_epi32 (__m128i __A, int __B)\n+{\n+  __v4su rshift;\n+  __v4si result = { 0, 0, 0, 0 };\n+\n+  if (__B < 32)\n+    {\n+      if (__builtin_constant_p(__B))\n+\t{\n+\t  if (__B < 16)\n+\t      rshift = (__v4su) vec_splat_s32(__B);\n+\t    else\n+\t      rshift = (__v4su) vec_splats((unsigned int)__B);\n+\t}\n+      else\n+\trshift = vec_splats ((unsigned int) __B);\n+\n+      result = vec_vsrw ((__v4si) __A, rshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_epi64 (__m128i __A, int __B)\n+{\n+  __v2du rshift;\n+  __v2di result = { 0, 0 };\n+\n+  if (__B < 64)\n+    {\n+      if (__builtin_constant_p(__B))\n+\t{\n+\t  if (__B < 16)\n+\t      rshift = (__v2du) vec_splat_s32(__B);\n+\t    else\n+\t      rshift = (__v2du) vec_splats((unsigned long long)__B);\n+\t}\n+      else\n+\trshift = (__v2du) vec_splats ((unsigned int) __B);\n+\n+      result = vec_vsrd ((__v2di) __A, rshift);\n+    }\n+\n+  return (__m128i) result;\n+}\n+#endif\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_epi16 (__m128i __A, __m128i __B)\n+{\n+  __v8hu lshift, shmask;\n+  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };\n+  __v8hu result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  lshift = vec_splat ((__v8hu)__B, 0);\n+#elif __BIG_ENDIAN__\n+  lshift = vec_splat ((__v8hu)__B, 3);\n+#endif\n+  shmask = lshift <= shmax;\n+  result = vec_vslh ((__v8hu) __A, lshift);\n+  result = vec_sel (shmask, result, shmask);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_epi32 (__m128i __A, __m128i __B)\n+{\n+  __v4su lshift, shmask;\n+  const __v4su shmax = { 32, 32, 32, 32 };\n+  __v4su result;\n+#ifdef __LITTLE_ENDIAN__\n+  lshift = vec_splat ((__v4su)__B, 0);\n+#elif __BIG_ENDIAN__\n+  lshift = vec_splat ((__v4su)__B, 1);\n+#endif\n+  shmask = lshift < shmax;\n+  result = vec_vslw ((__v4su) __A, lshift);\n+  result = vec_sel (shmask, result, shmask);\n+\n+  return (__m128i) result;\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_epi64 (__m128i __A, __m128i __B)\n+{\n+  __v2du lshift, shmask;\n+  const __v2du shmax = { 64, 64 };\n+  __v2du result;\n+\n+  lshift = (__v2du) vec_splat ((__v2du)__B, 0);\n+  shmask = lshift < shmax;\n+  result = vec_vsld ((__v2du) __A, lshift);\n+  result = (__v2du) vec_sel ((__v2df) shmask, (__v2df) result,\n+\t\t\t      (__v2df) shmask);\n+\n+  return (__m128i) result;\n+}\n+#endif\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sra_epi16 (__m128i __A, __m128i __B)\n+{\n+  const __v8hu rshmax = { 15, 15, 15, 15, 15, 15, 15, 15 };\n+  __v8hu rshift;\n+  __v8hi result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  rshift = vec_splat ((__v8hu)__B, 0);\n+#elif __BIG_ENDIAN__\n+  rshift = vec_splat ((__v8hu)__B, 3);\n+#endif\n+  rshift = vec_min (rshift, rshmax);\n+  result = vec_vsrah ((__v8hi) __A, rshift);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sra_epi32 (__m128i __A, __m128i __B)\n+{\n+  const __v4su rshmax = { 31, 31, 31, 31 };\n+  __v4su rshift;\n+  __v4si result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  rshift = vec_splat ((__v4su)__B, 0);\n+#elif __BIG_ENDIAN__\n+  rshift = vec_splat ((__v4su)__B, 1);\n+#endif\n+  rshift = vec_min (rshift, rshmax);\n+  result = vec_vsraw ((__v4si) __A, rshift);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_epi16 (__m128i __A, __m128i __B)\n+{\n+  __v8hu rshift, shmask;\n+  const __v8hu shmax = { 15, 15, 15, 15, 15, 15, 15, 15 };\n+  __v8hu result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  rshift = vec_splat ((__v8hu)__B, 0);\n+#elif __BIG_ENDIAN__\n+  rshift = vec_splat ((__v8hu)__B, 3);\n+#endif\n+  shmask = rshift <= shmax;\n+  result = vec_vsrh ((__v8hu) __A, rshift);\n+  result = vec_sel (shmask, result, shmask);\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_epi32 (__m128i __A, __m128i __B)\n+{\n+  __v4su rshift, shmask;\n+  const __v4su shmax = { 32, 32, 32, 32 };\n+  __v4su result;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  rshift = vec_splat ((__v4su)__B, 0);\n+#elif __BIG_ENDIAN__\n+  rshift = vec_splat ((__v4su)__B, 1);\n+#endif\n+  shmask = rshift < shmax;\n+  result = vec_vsrw ((__v4su) __A, rshift);\n+  result = vec_sel (shmask, result, shmask);\n+\n+  return (__m128i) result;\n+}\n+\n+#ifdef _ARCH_PWR8\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_epi64 (__m128i __A, __m128i __B)\n+{\n+  __v2du rshift, shmask;\n+  const __v2du shmax = { 64, 64 };\n+  __v2du result;\n+\n+  rshift = (__v2du) vec_splat ((__v2du)__B, 0);\n+  shmask = rshift < shmax;\n+  result = vec_vsrd ((__v2du) __A, rshift);\n+  result = (__v2du)vec_sel ((__v2du)shmask, (__v2du)result, (__v2du)shmask);\n+\n+  return (__m128i) result;\n+}\n+#endif\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_and_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_and ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_andnot_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_andc ((__v2df) __B, (__v2df) __A));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_or_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_or ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_xor_pd (__m128d __A, __m128d __B)\n+{\n+  return (vec_xor ((__v2df) __A, (__v2df) __B));\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpeq ((__v16qi) __A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpeq ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpeq ((__v4si) __A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmplt ((__v16qi) __A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmplt ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmplt ((__v4si) __A, (__v4si)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpgt ((__v16qi) __A, (__v16qi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpgt ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_cmpgt ((__v4si) __A, (__v4si)__B);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_extract_epi16 (__m128i const __A, int const __N)\n+{\n+  return (unsigned short) ((__v8hi)__A)[__N & 7];\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_insert_epi16 (__m128i const __A, int const __D, int const __N)\n+{\n+  __v8hi result = (__v8hi)__A;\n+\n+  result [(__N & 7)] = __D;\n+\n+  return (__m128i) result;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_max ((__v8hi)__A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_epu8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_max ((__v16qu) __A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_epi16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_min ((__v8hi) __A, (__v8hi)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_epu8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_min ((__v16qu) __A, (__v16qu)__B);\n+}\n+\n+\n+#ifdef _ARCH_PWR8\n+/* Intrinsic functions that require PowerISA 2.07 minimum.  */\n+\n+/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movemask_epi8 (__m128i __A)\n+{\n+  __vector __m64 result;\n+  static const __vector unsigned char perm_mask =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,\n+\t0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08, 0x00\n+#elif __BIG_ENDIAN__\n+\t0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38,\n+\t0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78\n+#endif\n+    };\n+\n+  result = (__vector __m64) vec_vbpermq ((__vector unsigned char) __A,\n+\t\t\t\t\t (__vector unsigned char) perm_mask);\n+\n+#ifdef __LITTLE_ENDIAN__\n+  return result[1];\n+#elif __BIG_ENDIAN__\n+  return result[0];\n+#endif\n+}\n+#endif /* _ARCH_PWR8 */\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mulhi_epu16 (__m128i __A, __m128i __B)\n+{\n+  __v4su w0, w1;\n+  __v16qu xform1 = {\n+#ifdef __LITTLE_ENDIAN__\n+      0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,\n+      0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F\n+#elif __BIG_ENDIAN__\n+      0x00, 0x01, 0x10, 0x11,  0x04, 0x05, 0x14, 0x15,\n+      0x08, 0x09, 0x18, 0x19,  0x0C, 0x0D, 0x1C, 0x1D\n+#endif\n+    };\n+\n+  w0 = vec_vmuleuh ((__v8hu)__A, (__v8hu)__B);\n+  w1 = vec_vmulouh ((__v8hu)__A, (__v8hu)__B);\n+  return (__m128i) vec_perm (w0, w1, xform1);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shufflehi_epi16 (__m128i __A, const int __mask)\n+{\n+  unsigned long element_selector_98 = __mask & 0x03;\n+  unsigned long element_selector_BA = (__mask >> 2) & 0x03;\n+  unsigned long element_selector_DC = (__mask >> 4) & 0x03;\n+  unsigned long element_selector_FE = (__mask >> 6) & 0x03;\n+  static const unsigned short permute_selectors[4] =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t      0x0908, 0x0B0A, 0x0D0C, 0x0F0E\n+#elif __BIG_ENDIAN__\n+\t      0x0607, 0x0405, 0x0203, 0x0001\n+#endif\n+    };\n+  __v2du pmask =\n+#ifdef __LITTLE_ENDIAN__\n+      { 0x1716151413121110UL,  0x1f1e1d1c1b1a1918UL};\n+#elif __BIG_ENDIAN__\n+      { 0x1011121314151617UL,  0x18191a1b1c1d1e1fUL};\n+#endif\n+  __m64_union t;\n+  __v2du a, r;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  t.as_short[0] = permute_selectors[element_selector_98];\n+  t.as_short[1] = permute_selectors[element_selector_BA];\n+  t.as_short[2] = permute_selectors[element_selector_DC];\n+  t.as_short[3] = permute_selectors[element_selector_FE];\n+#elif __BIG_ENDIAN__\n+  t.as_short[3] = permute_selectors[element_selector_98];\n+  t.as_short[2] = permute_selectors[element_selector_BA];\n+  t.as_short[1] = permute_selectors[element_selector_DC];\n+  t.as_short[0] = permute_selectors[element_selector_FE];\n+#endif\n+#ifdef __LITTLE_ENDIAN__\n+  pmask[1] = t.as_m64;\n+#elif __BIG_ENDIAN__\n+  pmask[0] = t.as_m64;\n+#endif\n+  a = (__v2du)__A;\n+  r = vec_perm (a, a, (__vector unsigned char)pmask);\n+  return (__m128i) r;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shufflelo_epi16 (__m128i __A, const int __mask)\n+{\n+  unsigned long element_selector_10 = __mask & 0x03;\n+  unsigned long element_selector_32 = (__mask >> 2) & 0x03;\n+  unsigned long element_selector_54 = (__mask >> 4) & 0x03;\n+  unsigned long element_selector_76 = (__mask >> 6) & 0x03;\n+  static const unsigned short permute_selectors[4] =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t      0x0100, 0x0302, 0x0504, 0x0706\n+#elif __BIG_ENDIAN__\n+\t      0x0e0f, 0x0c0d, 0x0a0b, 0x0809\n+#endif\n+    };\n+  __v2du pmask = { 0x1011121314151617UL,  0x1f1e1d1c1b1a1918UL};\n+  __m64_union t;\n+  __v2du a, r;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  t.as_short[0] = permute_selectors[element_selector_10];\n+  t.as_short[1] = permute_selectors[element_selector_32];\n+  t.as_short[2] = permute_selectors[element_selector_54];\n+  t.as_short[3] = permute_selectors[element_selector_76];\n+#elif __BIG_ENDIAN__\n+  t.as_short[3] = permute_selectors[element_selector_10];\n+  t.as_short[2] = permute_selectors[element_selector_32];\n+  t.as_short[1] = permute_selectors[element_selector_54];\n+  t.as_short[0] = permute_selectors[element_selector_76];\n+#endif\n+#ifdef __LITTLE_ENDIAN__\n+  pmask[0] = t.as_m64;\n+#elif __BIG_ENDIAN__\n+  pmask[1] = t.as_m64;\n+#endif\n+  a = (__v2du)__A;\n+  r = vec_perm (a, a, (__vector unsigned char)pmask);\n+  return (__m128i) r;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shuffle_epi32 (__m128i __A, const int __mask)\n+{\n+  unsigned long element_selector_10 = __mask & 0x03;\n+  unsigned long element_selector_32 = (__mask >> 2) & 0x03;\n+  unsigned long element_selector_54 = (__mask >> 4) & 0x03;\n+  unsigned long element_selector_76 = (__mask >> 6) & 0x03;\n+  static const unsigned int permute_selectors[4] =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C\n+#elif __BIG_ENDIAN__\n+      0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203\n+#endif\n+    };\n+  __v4su t;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  t[0] = permute_selectors[element_selector_10];\n+  t[1] = permute_selectors[element_selector_32];\n+  t[2] = permute_selectors[element_selector_54] + 0x10101010;\n+  t[3] = permute_selectors[element_selector_76] + 0x10101010;\n+#elif __BIG_ENDIAN__\n+  t[3] = permute_selectors[element_selector_10] + 0x10101010;\n+  t[2] = permute_selectors[element_selector_32] + 0x10101010;\n+  t[1] = permute_selectors[element_selector_54];\n+  t[0] = permute_selectors[element_selector_76];\n+#endif\n+  return (__m128i)vec_perm ((__v4si) __A, (__v4si)__A, (__vector unsigned char)t);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)\n+{\n+  __v2du hibit = { 0x7f7f7f7f7f7f7f7fUL, 0x7f7f7f7f7f7f7f7fUL};\n+  __v16qu mask, tmp;\n+  __m128i *p = (__m128i*)__C;\n+\n+  tmp = (__v16qu)_mm_loadu_si128(p);\n+  mask = (__v16qu)vec_cmpgt ((__v16qu)__B, (__v16qu)hibit);\n+  tmp = vec_sel (tmp, (__v16qu)__A, mask);\n+  _mm_storeu_si128 (p, (__m128i)tmp);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_avg_epu8 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_avg ((__v16qu)__A, (__v16qu)__B);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_avg_epu16 (__m128i __A, __m128i __B)\n+{\n+  return (__m128i) vec_avg ((__v8hu)__A, (__v8hu)__B);\n+}\n+\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sad_epu8 (__m128i __A, __m128i __B)\n+{\n+  __v16qu a, b;\n+  __v16qu vmin, vmax, vabsdiff;\n+  __v4si vsum;\n+  const __v4su zero = { 0, 0, 0, 0 };\n+  __v4si result;\n+\n+  a = (__v16qu) __A;\n+  b = (__v16qu) __B;\n+  vmin = vec_min (a, b);\n+  vmax = vec_max (a, b);\n+  vabsdiff = vec_sub (vmax, vmin);\n+  /* Sum four groups of bytes into integers.  */\n+  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);\n+  /* Sum across four integers with two integer results.  */\n+  result = vec_sum2s (vsum, (__vector signed int) zero);\n+  /* Rotate the sums into the correct position.  */\n+#ifdef __LITTLE_ENDIAN__\n+  result = vec_sld (result, result, 4);\n+#elif __BIG_ENDIAN__\n+  result = vec_sld (result, result, 6);\n+#endif\n+  /* Rotate the sums into the correct position.  */\n+  return (__m128i) result;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_si32 (int *__A, int __B)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"dcbtstt 0,%0\"\n+    :\n+    : \"b\" (__A)\n+    : \"memory\"\n+  );\n+  *__A = __B;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_si64 (long long int *__A, long long int __B)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"\tdcbtstt\t0,%0\"\n+    :\n+    : \"b\" (__A)\n+    : \"memory\"\n+  );\n+  *__A = __B;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_si128 (__m128i *__A, __m128i __B)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"dcbtstt 0,%0\"\n+    :\n+    : \"b\" (__A)\n+    : \"memory\"\n+  );\n+  *__A = __B;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_pd (double *__A, __m128d __B)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"dcbtstt 0,%0\"\n+    :\n+    : \"b\" (__A)\n+    : \"memory\"\n+  );\n+  *(__m128d*)__A = __B;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_clflush (void const *__A)\n+{\n+  /* Use the data cache block flush.  */\n+  __asm__ (\n+    \"dcbf 0,%0\"\n+    :\n+    : \"b\" (__A)\n+    : \"memory\"\n+  );\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_lfence (void)\n+{\n+  /* Use light weight sync for load to load ordering.  */\n+  __atomic_thread_fence (__ATOMIC_RELEASE);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mfence (void)\n+{\n+  /* Use heavy weight sync for any to any ordering.  */\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi32_si128 (int __A)\n+{\n+  return _mm_set_epi32 (0, 0, 0, __A);\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_si128 (long long __A)\n+{\n+  return __extension__ (__m128i)(__v2di){ __A, 0LL };\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64x_si128 (long long __A)\n+{\n+  return __extension__ (__m128i)(__v2di){ __A, 0LL };\n+}\n+\n+/* Casts between various SP, DP, INT vector types.  Note that these do no\n+   conversion of values, they just change the type.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castpd_ps(__m128d __A)\n+{\n+  return (__m128) __A;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castpd_si128(__m128d __A)\n+{\n+  return (__m128i) __A;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castps_pd(__m128 __A)\n+{\n+  return (__m128d) __A;\n+}\n+\n+extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castps_si128(__m128 __A)\n+{\n+  return (__m128i) __A;\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castsi128_ps(__m128i __A)\n+{\n+  return (__m128) __A;\n+}\n+\n+extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_castsi128_pd(__m128i __A)\n+{\n+  return (__m128d) __A;\n+}\n+\n+#endif /* EMMINTRIN_H_ */"}, {"sha": "33e3176108bb12cdeee8669d7154865162f80021", "filename": "gcc/config/rs6000/x86intrin.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09359ea364bf042d6508b6098166bdaf9c61e254/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx86intrin.h?ref=09359ea364bf042d6508b6098166bdaf9c61e254", "patch": "@@ -39,6 +39,8 @@\n #include <mmintrin.h>\n \n #include <xmmintrin.h>\n+\n+#include <emmintrin.h>\n #endif /* __ALTIVEC__ */\n \n #include <bmiintrin.h>"}]}