{"sha": "3d7ff7286de5a44da1b843ace99262c777079714", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3ZmY3Mjg2ZGU1YTQ0ZGExYjg0M2FjZTk5MjYyYzc3NzA3OTcxNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-29T19:45:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-29T19:45:42Z"}, "message": "PR c++/80891 (#1,#5)\n\n\tPR c++/80891 (#1,#5)\n\t* cp-tree.h (lookup_maybe_add): Add DEDUPING argument.\n\t* name-lookup.c (name_lookup): Add deduping field.\n\t(name_lookup::preserve_state, name_lookup::restore_state): Deal\n\twith deduping.\n\t(name_lookup::add_overload): New.\n\t(name_lookup::add_value, name_lookup::add_fns): Call add_overload.\n\t(name_lookup::search_adl): Set deduping.  Don't unmark here.\n\t* pt.c (most_specialized_instantiation): Revert previous change,\n\tAssert not given duplicates.\n\t* tree.c (lookup_mark): Just mark the underlying decls.\n\t(lookup_maybe_add): Dedup using marked decls.\n\n\tPR c++/80891 (#5)\n\t* g++.dg/lookup/pr80891-5.C: New.\n\nFrom-SVN: r248578", "tree": {"sha": "2d31b8b170e163b02c6de6c2a30672f5d6e24eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d31b8b170e163b02c6de6c2a30672f5d6e24eab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d7ff7286de5a44da1b843ace99262c777079714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7ff7286de5a44da1b843ace99262c777079714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7ff7286de5a44da1b843ace99262c777079714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7ff7286de5a44da1b843ace99262c777079714/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd262197d74626579a784ee1cc0f3f3a0e3f33e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd262197d74626579a784ee1cc0f3f3a0e3f33e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd262197d74626579a784ee1cc0f3f3a0e3f33e9"}], "stats": {"total": 305, "additions": 200, "deletions": 105}, "files": [{"sha": "d471f37c538a2896233ea71631ca2d4917ec90ec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -1,5 +1,18 @@\n 2017-05-29  Nathan Sidwell  <nathan@acm.org>\n \n+\tPR c++/80891 (#1,#5)\n+\t* cp-tree.h (lookup_maybe_add): Add DEDUPING argument.\n+\t* name-lookup.c (name_lookup): Add deduping field.\n+\t(name_lookup::preserve_state, name_lookup::restore_state): Deal\n+\twith deduping.\n+\t(name_lookup::add_overload): New.\n+\t(name_lookup::add_value, name_lookup::add_fns): Call add_overload.\n+\t(name_lookup::search_adl): Set deduping.  Don't unmark here.\n+\t* pt.c (most_specialized_instantiation): Revert previous change,\n+\tAssert not given duplicates.\n+\t* tree.c (lookup_mark): Just mark the underlying decls.\n+\t(lookup_maybe_add): Dedup using marked decls.\n+\n \tPR c++/80891 (#4)\n \t* ptree.c (cxx_print_xnode): Show internal OVERLOAD structure.\n \t* tree.c (ovl_insert, ovl_iterator_remove_node): Fix copying assert."}, {"sha": "b9c1b130cc6a5d73883b484c729005397feea37d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -6916,7 +6916,8 @@ extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n extern tree ovl_skip_hidden\t\t\t(tree) ATTRIBUTE_PURE;\n extern void lookup_mark\t\t\t\t(tree lookup, bool val);\n extern tree lookup_add\t\t\t\t(tree fns, tree lookup);\n-extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup);\n+extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup,\n+\t\t\t\t\t\t bool deduping);\n extern void lookup_keep\t\t\t\t(tree lookup, bool keep);\n extern int is_overloaded_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern bool really_overloaded_fn\t\t(tree) ATTRIBUTE_PURE;"}, {"sha": "861580fc21d000482ef50ca0affa0b790f076733", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -48,7 +48,11 @@ static void set_identifier_type_value_with_scope (tree id, tree decl,\n #define MAYBE_STAT_DECL(N) (STAT_HACK_P (N) ? STAT_DECL (N) : N)\n #define MAYBE_STAT_TYPE(N) (STAT_HACK_P (N) ? STAT_TYPE (N) : NULL_TREE)\n \n-static tree stat_hack (tree decl = NULL_TREE, tree type = NULL_TREE)\n+/* Create a STAT_HACK node with DECL as the value binding and TYPE as\n+   the type binding.  */\n+\n+static tree\n+stat_hack (tree decl = NULL_TREE, tree type = NULL_TREE)\n {\n   tree result = make_node (OVERLOAD);\n \n@@ -179,6 +183,8 @@ struct name_lookup\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n   tree type;\t/* A type that has been found.  */\n   int flags;\t/* Lookup flags.  */\n+  bool deduping; /* Full deduping is needed because using declarations\n+\t\t    are in play.  */\n   vec<tree, va_heap, vl_embed> *scopes;\n   name_lookup *previous; /* Previously active lookup.  */\n \n@@ -191,7 +197,7 @@ struct name_lookup\n public:\n   name_lookup (tree n, int f = 0)\n   : name (n), value (NULL_TREE), type (NULL_TREE), flags (f),\n-    scopes (NULL), previous (NULL)\n+    deduping (false), scopes (NULL), previous (NULL)\n   {\n     preserve_state ();\n   }\n@@ -235,6 +241,7 @@ struct name_lookup\n \n private:\n   static tree ambiguous (tree thing, tree current);\n+  void add_overload (tree fns);\n   void add_value (tree new_val);\n   void add_type (tree new_type);\n   bool process_binding (tree val_bind, tree type_bind);\n@@ -321,7 +328,8 @@ name_lookup::preserve_state ()\n \t}\n \n       /* Unmark the outer partial lookup.  */\n-      lookup_mark (previous->value, false);\n+      if (previous->deduping)\n+\tlookup_mark (previous->value, false);\n     }\n   else\n     scopes = shared_scopes;\n@@ -333,6 +341,9 @@ name_lookup::preserve_state ()\n void\n name_lookup::restore_state ()\n {\n+  if (deduping)\n+    lookup_mark (value, false);\n+\n   /* Unmark and empty this lookup's scope stack.  */\n   for (unsigned ix = vec_safe_length (scopes); ix--;)\n     {\n@@ -371,7 +382,8 @@ name_lookup::restore_state ()\n \t}\n \n       /* Remark the outer partial lookup.  */\n-      lookup_mark (previous->value, true);\n+      if (previous->deduping)\n+\tlookup_mark (previous->value, true);\n     }\n   else\n     shared_scopes = scopes;\n@@ -415,23 +427,53 @@ name_lookup::ambiguous (tree thing, tree current)\n   return current;\n }\n \n+/* FNS is a new overload set to add to the exising set.  */\n+\n+void\n+name_lookup::add_overload (tree fns)\n+{\n+  if (!deduping && TREE_CODE (fns) == OVERLOAD)\n+    {\n+      tree probe = fns;\n+      if (flags & LOOKUP_HIDDEN)\n+\tprobe = ovl_skip_hidden (probe);\n+      if (probe && TREE_CODE (probe) == OVERLOAD && OVL_USING_P (probe))\n+\t{\n+\t  /* We're about to add something found by a using\n+\t     declaration, so need to engage deduping mode.  */\n+\t  lookup_mark (value, true);\n+\t  deduping = true;\n+\t}\n+    }\n+\n+  value = lookup_maybe_add (fns, value, deduping);\n+}\n+\n /* Add a NEW_VAL, a found value binding into the current value binding.  */\n \n void\n name_lookup::add_value (tree new_val)\n {\n-  if (!value)\n+  if (OVL_P (new_val) && (!value || OVL_P (value)))\n+    add_overload (new_val);\n+  else if (!value)\n     value = new_val;\n   else if (value == new_val)\n     ;\n   else if ((TREE_CODE (value) == TYPE_DECL\n \t    && TREE_CODE (new_val) == TYPE_DECL\n \t    && same_type_p (TREE_TYPE (value), TREE_TYPE (new_val))))\n     ;\n-  else if (OVL_P (value) && OVL_P (new_val))\n-    value = lookup_add (new_val, value);\n   else\n-    value = ambiguous (new_val, value);\n+    {\n+      if (deduping)\n+\t{\n+\t  /* Disengage deduping mode.  */\n+\t  lookup_mark (value, false);\n+\t  deduping = false;\n+\t}\n+      value = ambiguous (new_val, value);\n+    }\n }\n \n /* Add a NEW_TYPE, a found type binding into the current type binding.  */\n@@ -703,8 +745,7 @@ name_lookup::add_fns (tree fns)\n   else if (!DECL_DECLARES_FUNCTION_P (fns))\n     return;\n \n-  /* Only add those that aren't already there.  */\n-  value = lookup_maybe_add (fns, value);\n+  add_overload (fns);\n }\n \n /* Add functions of a namespace to the lookup structure.  */\n@@ -1004,7 +1045,11 @@ name_lookup::adl_template_arg (tree arg)\n tree\n name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n {\n-  lookup_mark (fns, true);\n+  if (fns)\n+    {\n+      deduping = true;\n+      lookup_mark (fns, true);\n+    }\n   value = fns;\n \n   unsigned ix;\n@@ -1019,7 +1064,6 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n       adl_expr (arg);\n \n   fns = value;\n-  lookup_mark (fns, false);\n \n   return fns;\n }"}, {"sha": "360216632ef7e6e8bc677331cd94d69e1430dd74", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -21728,32 +21728,32 @@ most_specialized_instantiation (tree templates)\n \n   champ = templates;\n   for (fn = TREE_CHAIN (templates); fn; fn = TREE_CHAIN (fn))\n-    if (TREE_VALUE (champ) != TREE_VALUE (fn))\n-      {\n-\tint fate = more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn));\n-\tif (fate == -1)\n+    {\n+      gcc_assert (TREE_VALUE (champ) != TREE_VALUE (fn));\n+      int fate = more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn));\n+      if (fate == -1)\n+\tchamp = fn;\n+      else if (!fate)\n+\t{\n+\t  /* Equally specialized, move to next function.  If there\n+\t     is no next function, nothing's most specialized.  */\n+\t  fn = TREE_CHAIN (fn);\n \t  champ = fn;\n-\telse if (!fate)\n-\t  {\n-\t    /* Equally specialized, move to next function.  If there\n-\t       is no next function, nothing's most specialized.  */\n-\t    fn = TREE_CHAIN (fn);\n-\t    champ = fn;\n-\t    if (!fn)\n-\t      break;\n-\t  }\n-      }\n+\t  if (!fn)\n+\t    break;\n+\t}\n+    }\n \n   if (champ)\n     /* Now verify that champ is better than everything earlier in the\n        instantiation list.  */\n-    for (fn = templates; fn != champ; fn = TREE_CHAIN (fn))\n-      if (TREE_VALUE (champ) != TREE_VALUE (fn)\n-\t  && more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn)) != 1)\n-\t{\n-\t  champ = NULL_TREE;\n-\t  break;\n-\t}\n+    for (fn = templates; fn != champ; fn = TREE_CHAIN (fn)) {\n+      if (more_specialized_inst (TREE_VALUE (champ), TREE_VALUE (fn)) != 1)\n+      {\n+        champ = NULL_TREE;\n+        break;\n+      }\n+    }\n \n   processing_template_decl--;\n "}, {"sha": "bb17278c611ca12e546cf03c24895be640de4efc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 35, "deletions": 71, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -2293,21 +2293,10 @@ ovl_iterator::remove_node (tree overload, tree node)\n void\n lookup_mark (tree ovl, bool val)\n {\n-  /* For every node that is a lookup, mark the thing it points to.  */\n-  for (; ovl && TREE_CODE (ovl) == OVERLOAD && OVL_LOOKUP_P (ovl);\n-       ovl = OVL_CHAIN (ovl))\n-    {\n-      tree targ = OVL_FUNCTION (ovl);\n-      gcc_checking_assert (LOOKUP_SEEN_P (targ) != val);\n-      LOOKUP_SEEN_P (targ) = val;\n-    }\n-\n-  if (ovl && (TREE_CODE (ovl) == OVERLOAD ||\n-\t      TREE_CODE (ovl) == FUNCTION_DECL))\n+  for (lkp_iterator iter (ovl); iter; ++iter)\n     {\n-      /* Mark the overload itsef.  */\n-      gcc_checking_assert (LOOKUP_SEEN_P (ovl) != val);\n-      LOOKUP_SEEN_P (ovl) = val;\n+      gcc_checking_assert (LOOKUP_SEEN_P (*iter) != val);\n+      LOOKUP_SEEN_P (*iter) = val;\n     }\n }\n \n@@ -2327,73 +2316,48 @@ lookup_add (tree fns, tree lookup)\n   return lookup;\n }\n \n-/* FNS is a new overload set, add it to LOOKUP, if it is not already\n-   present there.  */\n+/* FNS is a new overload set, add them to LOOKUP, if they are not\n+   already present there.  */\n \n tree\n-lookup_maybe_add (tree fns, tree lookup)\n+lookup_maybe_add (tree fns, tree lookup, bool deduping)\n {\n-  if (LOOKUP_SEEN_P (fns))\n-    return lookup;\n-\n-  if (lookup && TREE_CODE (fns) == OVERLOAD)\n-    {\n-      /* Determine if we already have some part of this overload in\n-\t the overload set.  If so fix things up so we only have the\n-\t overload set once.  */\n-      tree marked = NULL_TREE;\n+  if (deduping)\n+    for (tree next, probe = fns; probe; probe = next)\n+      {\n+\ttree fn = probe;\n+\tnext = NULL_TREE;\n \n-      for (tree probe = fns; probe; probe = OVL_CHAIN (probe))\n-\tif (LOOKUP_SEEN_P (probe))\n+\tif (TREE_CODE (probe) == OVERLOAD)\n \t  {\n-\t    marked = probe;\n-\t    break;\n+\t    fn = OVL_FUNCTION (probe);\n+\t    next = OVL_CHAIN (probe);\n \t  }\n-\telse if (TREE_CODE (probe) != OVERLOAD)\n-\t  break;\n \n-      if (marked)\n-\t{\n-\t  /* The tail of this overload is already in the lookup\n-\t     set.  Stitch out the tail case, which might involve\n-\t     copying.  */\n-\t  bool rewrite = false;\n-\n-\t  LOOKUP_SEEN_P (marked) = false;\n-\t  for (tree *prev = &lookup, probe = *prev;\n-\t       ; prev = &OVL_CHAIN (probe), probe = *prev)\n-\t    {\n-\t      if (probe == marked)\n-\t\t{\n-\t\t  *prev = NULL_TREE;\n-\t\t  break;\n-\t\t}\n-\t      gcc_checking_assert (OVL_LOOKUP_P (probe));\n-\t      if (marked == OVL_FUNCTION (probe))\n-\t\t{\n-\t\t  *prev = OVL_CHAIN (probe);\n-\t\t  break;\n-\t\t}\n+\tif (!LOOKUP_SEEN_P (fn))\n+\t  LOOKUP_SEEN_P (fn) = true;\n+\telse\n+\t  {\n+\t    /* This function was already seen.  Insert all the\n+\t       predecessors onto the lookup.  */\n+\t    for (; fns != probe; fns = OVL_CHAIN (fns))\n+\t      {\n+\t\tlookup = lookup_add (OVL_FUNCTION (fns), lookup);\n+\t\t/* Propagate OVL_USING, but OVL_HIDDEN doesn't matter.  */\n+\t\tif (OVL_USING_P (fns))\n+\t\t  OVL_USING_P (lookup) = true;\n+\t      }\n \n-\t      /* If we're in a used part of the lookup set, copy the\n-\t\t node, so as to not disturb stored uses.  */\n-\t      gcc_checking_assert (!rewrite || OVL_USED_P (probe));\n-\t      if (OVL_USED_P (probe))\n-\t\t{\n-\t\t  rewrite = true;\n-\t\t  probe = ovl_copy (probe);\n-\t\t  OVL_LOOKUP_P (probe) = true;\n-\t\t  *prev = probe;\n-\t\t}\n-\t    }\n-\t}\n-    }\n+\t    /* And now skip this function.  */\n+\t    fns = next;\n+\t  }\n+      }\n \n-  /* Finally mark the new overload and prepend it to the current\n-     lookup.  */\n-  LOOKUP_SEEN_P (fns) = true;\n+  if (fns)\n+    /* We ended in a set of new functions.  Add them all in one go.  */\n+    lookup = lookup_add (fns, lookup);\n \n-  return lookup_add (fns, lookup);\n+  return lookup;\n }\n \n /* Regular overload OVL is part of a kept lookup.  Mark the nodes on"}, {"sha": "1b7ef9779db1d616a29ef9fb76595acb9a3d3614", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -1,3 +1,8 @@\n+2017-05-29  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/80891 (#5)\n+\t* g++.dg/lookup/pr80891-5.C: New.\n+\n 2017-05-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/53029"}, {"sha": "ebf64f8758e8afc1d392498a0f3b4913c5977f0d", "filename": "gcc/testsuite/g++.dg/lookup/pr80891-5.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80891-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7ff7286de5a44da1b843ace99262c777079714/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80891-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr80891-5.C?ref=3d7ff7286de5a44da1b843ace99262c777079714", "patch": "@@ -0,0 +1,68 @@\n+// PR c++/80891 part 4\n+\n+// ICE copying an augmented lookup during ADL\n+\n+struct __normal_iterator get(); // { dg-message \"candidate: .__normal_iterator get\\\\(\\\\).\" }\n+namespace boost {\n+template <class> void get(); // { dg-message \"candidate: .template<class> void boost::get\\\\(\\\\).\" }\n+struct A {\n+  A(int);\n+};\n+enum problem_selector { subgraph_iso };\n+template <typename, typename, typename, typename,\n+          typename SubGraphIsoMapCallback, problem_selector>\n+struct B {\n+  B(A, A, int, int, int, int);\n+  void m_fn1(SubGraphIsoMapCallback p1) {\n+    __normal_iterator __trans_tmp_1();\n+    p1(__trans_tmp_1, 0);\n+  }\n+};\n+template <typename Graph1, typename Graph2, typename IndexMap1,\n+          typename IndexMap2, typename VertexOrder1,\n+          typename EdgeEquivalencePredicate,\n+          typename VertexEquivalencePredicate, typename SubGraphIsoMapCallback,\n+          problem_selector problem_selection>\n+void match(\n+    Graph1, Graph2, SubGraphIsoMapCallback p3, VertexOrder1,\n+    B<IndexMap1, IndexMap2, EdgeEquivalencePredicate,\n+      VertexEquivalencePredicate, SubGraphIsoMapCallback, problem_selection>\n+        p5) {\n+  p5.m_fn1(p3);\n+}\n+template <problem_selector problem_selection, typename GraphSmall,\n+          typename GraphLarge, typename IndexMapSmall, typename IndexMapLarge,\n+          typename VertexOrderSmall, typename EdgeEquivalencePredicate,\n+          typename VertexEquivalencePredicate, typename SubGraphIsoMapCallback>\n+void vf2_subgraph_morphism(GraphSmall, GraphLarge, SubGraphIsoMapCallback p3,\n+                           IndexMapSmall, IndexMapLarge, VertexOrderSmall,\n+                           EdgeEquivalencePredicate,\n+                           VertexEquivalencePredicate) {\n+  B<IndexMapSmall, IndexMapLarge, EdgeEquivalencePredicate,\n+    VertexEquivalencePredicate, SubGraphIsoMapCallback, problem_selection>\n+      s(0, 0, 0, 0, 0, 0);\n+  match(0, 0, p3, 0, s);\n+}\n+template <typename GraphSmall, typename GraphLarge, typename IndexMapSmall,\n+          typename IndexMapLarge, typename VertexOrderSmall,\n+          typename EdgeEquivalencePredicate,\n+          typename VertexEquivalencePredicate, typename SubGraphIsoMapCallback>\n+int vf2_subgraph_iso(GraphSmall, GraphLarge, SubGraphIsoMapCallback p3,\n+                     IndexMapSmall, IndexMapLarge, VertexOrderSmall,\n+                     EdgeEquivalencePredicate, VertexEquivalencePredicate) {\n+  vf2_subgraph_morphism<subgraph_iso>(0, 0, p3, 0, 0, 0, 0, 0);\n+}\n+}\n+using namespace boost;\n+struct C {\n+  C(int) : graph1_(0), graph2_(0) {}\n+  template <typename CorrespondenceMap1To2, typename CorrespondenceMap2To1>\n+  void operator()(CorrespondenceMap1To2 p1, CorrespondenceMap2To1) {\n+    get(p1); // { dg-error \"no matching function\" }\n+  }\n+  A graph1_;\n+  A graph2_;\n+};\n+template <typename> void get(); // { dg-message \"candidate: .template<class> void get\\\\(\\\\).\" }\n+void test_vf2_sub_graph_iso() { C a(vf2_subgraph_iso(0, 0, a, 0, 0, 0, 0, 0));\n+}"}]}