{"sha": "8c2da345e08b313dfd0548064cdb3813a7c86d5a", "node_id": "C_kwDOANBUbNoAKDhjMmRhMzQ1ZTA4YjMxM2RmZDA1NDgwNjRjZGIzODEzYTdjODZkNWE", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-09T13:52:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:27Z"}, "message": "rust constexpr: porting cxx_eval_builtin_function_call\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "7927fa67eed53bb2719da40c5a7025215115b856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7927fa67eed53bb2719da40c5a7025215115b856"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c2da345e08b313dfd0548064cdb3813a7c86d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2da345e08b313dfd0548064cdb3813a7c86d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2da345e08b313dfd0548064cdb3813a7c86d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2da345e08b313dfd0548064cdb3813a7c86d5a/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9350b3733aef7c93ccd3b50d610e2831016db02b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9350b3733aef7c93ccd3b50d610e2831016db02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9350b3733aef7c93ccd3b50d610e2831016db02b"}], "stats": {"total": 735, "additions": 735, "deletions": 0}, "files": [{"sha": "e1e56fc83365d8d7d716a0b4c44a8bee41e660a3", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 680, "deletions": 0, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2da345e08b313dfd0548064cdb3813a7c86d5a/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2da345e08b313dfd0548064cdb3813a7c86d5a/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=8c2da345e08b313dfd0548064cdb3813a7c86d5a", "patch": "@@ -5257,4 +5257,684 @@ fold_builtin_is_pointer_inverconvertible_with_class (location_t loc, int nargs,\n \t\t      build_zero_cst (TREE_TYPE (arg)));\n }\n \n+/* Used for communication between c_common_type_for_mode and\n+   c_register_builtin_type.  */\n+tree registered_builtin_types;\n+\n+/* Return a data type that has machine mode MODE.\n+   If the mode is an integer,\n+   then UNSIGNEDP selects between signed and unsigned types.\n+   If the mode is a fixed-point mode,\n+   then UNSIGNEDP selects between saturating and nonsaturating types.  */\n+\n+tree\n+c_common_type_for_mode (machine_mode mode, int unsignedp)\n+{\n+  tree t;\n+  int i;\n+\n+  if (mode == TYPE_MODE (integer_type_node))\n+    return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+  if (mode == TYPE_MODE (signed_char_type_node))\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n+  if (mode == TYPE_MODE (short_integer_type_node))\n+    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_integer_type_node))\n+    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+  if (mode == TYPE_MODE (long_long_integer_type_node))\n+    return unsignedp ? long_long_unsigned_type_node\n+\t\t     : long_long_integer_type_node;\n+\n+  for (i = 0; i < NUM_INT_N_ENTS; i++)\n+    if (int_n_enabled_p[i] && mode == int_n_data[i].m)\n+      return (unsignedp ? int_n_trees[i].unsigned_type\n+\t\t\t: int_n_trees[i].signed_type);\n+\n+  if (mode == QImode)\n+    return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n+\n+  if (mode == HImode)\n+    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n+\n+  if (mode == SImode)\n+    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n+\n+  if (mode == DImode)\n+    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n+\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+  if (mode == TYPE_MODE (intTI_type_node))\n+    return unsignedp ? unsigned_intTI_type_node : intTI_type_node;\n+#endif\n+\n+  if (mode == TYPE_MODE (float_type_node))\n+    return float_type_node;\n+\n+  if (mode == TYPE_MODE (double_type_node))\n+    return double_type_node;\n+\n+  if (mode == TYPE_MODE (long_double_type_node))\n+    return long_double_type_node;\n+\n+  for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+    if (FLOATN_NX_TYPE_NODE (i) != NULL_TREE\n+\t&& mode == TYPE_MODE (FLOATN_NX_TYPE_NODE (i)))\n+      return FLOATN_NX_TYPE_NODE (i);\n+\n+  if (mode == TYPE_MODE (void_type_node))\n+    return void_type_node;\n+\n+  if (mode == TYPE_MODE (build_pointer_type (char_type_node))\n+      || mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n+    {\n+      unsigned int precision\n+\t= GET_MODE_PRECISION (as_a<scalar_int_mode> (mode));\n+      return (unsignedp ? make_unsigned_type (precision)\n+\t\t\t: make_signed_type (precision));\n+    }\n+\n+  if (COMPLEX_MODE_P (mode))\n+    {\n+      machine_mode inner_mode;\n+      tree inner_type;\n+\n+      if (mode == TYPE_MODE (complex_float_type_node))\n+\treturn complex_float_type_node;\n+      if (mode == TYPE_MODE (complex_double_type_node))\n+\treturn complex_double_type_node;\n+      if (mode == TYPE_MODE (complex_long_double_type_node))\n+\treturn complex_long_double_type_node;\n+\n+      for (i = 0; i < NUM_FLOATN_NX_TYPES; i++)\n+\tif (COMPLEX_FLOATN_NX_TYPE_NODE (i) != NULL_TREE\n+\t    && mode == TYPE_MODE (COMPLEX_FLOATN_NX_TYPE_NODE (i)))\n+\t  return COMPLEX_FLOATN_NX_TYPE_NODE (i);\n+\n+      if (mode == TYPE_MODE (complex_integer_type_node) && !unsignedp)\n+\treturn complex_integer_type_node;\n+\n+      inner_mode = GET_MODE_INNER (mode);\n+      inner_type = c_common_type_for_mode (inner_mode, unsignedp);\n+      if (inner_type != NULL_TREE)\n+\treturn build_complex_type (inner_type);\n+    }\n+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      unsigned int elem_bits\n+\t= vector_element_size (GET_MODE_BITSIZE (mode), GET_MODE_NUNITS (mode));\n+      tree bool_type = build_nonstandard_boolean_type (elem_bits);\n+      return build_vector_type_for_mode (bool_type, mode);\n+    }\n+  else if (VECTOR_MODE_P (mode)\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      machine_mode inner_mode = GET_MODE_INNER (mode);\n+      tree inner_type = c_common_type_for_mode (inner_mode, unsignedp);\n+      if (inner_type != NULL_TREE)\n+\treturn build_vector_type_for_mode (inner_type, mode);\n+    }\n+\n+  if (dfloat32_type_node != NULL_TREE && mode == TYPE_MODE (dfloat32_type_node))\n+    return dfloat32_type_node;\n+  if (dfloat64_type_node != NULL_TREE && mode == TYPE_MODE (dfloat64_type_node))\n+    return dfloat64_type_node;\n+  if (dfloat128_type_node != NULL_TREE\n+      && mode == TYPE_MODE (dfloat128_type_node))\n+    return dfloat128_type_node;\n+\n+  if (ALL_SCALAR_FIXED_POINT_MODE_P (mode))\n+    {\n+      if (mode == TYPE_MODE (short_fract_type_node))\n+\treturn unsignedp ? sat_short_fract_type_node : short_fract_type_node;\n+      if (mode == TYPE_MODE (fract_type_node))\n+\treturn unsignedp ? sat_fract_type_node : fract_type_node;\n+      if (mode == TYPE_MODE (long_fract_type_node))\n+\treturn unsignedp ? sat_long_fract_type_node : long_fract_type_node;\n+      if (mode == TYPE_MODE (long_long_fract_type_node))\n+\treturn unsignedp ? sat_long_long_fract_type_node\n+\t\t\t : long_long_fract_type_node;\n+\n+      if (mode == TYPE_MODE (unsigned_short_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_short_fract_type_node\n+\t\t\t : unsigned_short_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_fract_type_node\n+\t\t\t : unsigned_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_long_fract_type_node\n+\t\t\t : unsigned_long_fract_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_long_fract_type_node))\n+\treturn unsignedp ? sat_unsigned_long_long_fract_type_node\n+\t\t\t : unsigned_long_long_fract_type_node;\n+\n+      if (mode == TYPE_MODE (short_accum_type_node))\n+\treturn unsignedp ? sat_short_accum_type_node : short_accum_type_node;\n+      if (mode == TYPE_MODE (accum_type_node))\n+\treturn unsignedp ? sat_accum_type_node : accum_type_node;\n+      if (mode == TYPE_MODE (long_accum_type_node))\n+\treturn unsignedp ? sat_long_accum_type_node : long_accum_type_node;\n+      if (mode == TYPE_MODE (long_long_accum_type_node))\n+\treturn unsignedp ? sat_long_long_accum_type_node\n+\t\t\t : long_long_accum_type_node;\n+\n+      if (mode == TYPE_MODE (unsigned_short_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_short_accum_type_node\n+\t\t\t : unsigned_short_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_accum_type_node\n+\t\t\t : unsigned_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_long_accum_type_node\n+\t\t\t : unsigned_long_accum_type_node;\n+      if (mode == TYPE_MODE (unsigned_long_long_accum_type_node))\n+\treturn unsignedp ? sat_unsigned_long_long_accum_type_node\n+\t\t\t : unsigned_long_long_accum_type_node;\n+\n+      if (mode == QQmode)\n+\treturn unsignedp ? sat_qq_type_node : qq_type_node;\n+      if (mode == HQmode)\n+\treturn unsignedp ? sat_hq_type_node : hq_type_node;\n+      if (mode == SQmode)\n+\treturn unsignedp ? sat_sq_type_node : sq_type_node;\n+      if (mode == DQmode)\n+\treturn unsignedp ? sat_dq_type_node : dq_type_node;\n+      if (mode == TQmode)\n+\treturn unsignedp ? sat_tq_type_node : tq_type_node;\n+\n+      if (mode == UQQmode)\n+\treturn unsignedp ? sat_uqq_type_node : uqq_type_node;\n+      if (mode == UHQmode)\n+\treturn unsignedp ? sat_uhq_type_node : uhq_type_node;\n+      if (mode == USQmode)\n+\treturn unsignedp ? sat_usq_type_node : usq_type_node;\n+      if (mode == UDQmode)\n+\treturn unsignedp ? sat_udq_type_node : udq_type_node;\n+      if (mode == UTQmode)\n+\treturn unsignedp ? sat_utq_type_node : utq_type_node;\n+\n+      if (mode == HAmode)\n+\treturn unsignedp ? sat_ha_type_node : ha_type_node;\n+      if (mode == SAmode)\n+\treturn unsignedp ? sat_sa_type_node : sa_type_node;\n+      if (mode == DAmode)\n+\treturn unsignedp ? sat_da_type_node : da_type_node;\n+      if (mode == TAmode)\n+\treturn unsignedp ? sat_ta_type_node : ta_type_node;\n+\n+      if (mode == UHAmode)\n+\treturn unsignedp ? sat_uha_type_node : uha_type_node;\n+      if (mode == USAmode)\n+\treturn unsignedp ? sat_usa_type_node : usa_type_node;\n+      if (mode == UDAmode)\n+\treturn unsignedp ? sat_uda_type_node : uda_type_node;\n+      if (mode == UTAmode)\n+\treturn unsignedp ? sat_uta_type_node : uta_type_node;\n+    }\n+\n+  for (t = registered_builtin_types; t; t = TREE_CHAIN (t))\n+    {\n+      tree type = TREE_VALUE (t);\n+      if (TYPE_MODE (type) == mode\n+\t  && VECTOR_TYPE_P (type) == VECTOR_MODE_P (mode)\n+\t  && !!unsignedp == !!TYPE_UNSIGNED (type))\n+\treturn type;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Implement the __underlying_type keyword: Return the underlying\n+   type of TYPE, suitable for use as a type-specifier.  */\n+\n+tree\n+finish_underlying_type (tree type)\n+{\n+  tree underlying_type;\n+\n+  if (!complete_type_or_else (type, NULL_TREE))\n+    return error_mark_node;\n+\n+  if (TREE_CODE (type) != ENUMERAL_TYPE)\n+    {\n+      error (\"%qT is not an enumeration type\", type);\n+      return error_mark_node;\n+    }\n+\n+  underlying_type = ENUM_UNDERLYING_TYPE (type);\n+\n+  /* Fixup necessary in this case because ENUM_UNDERLYING_TYPE\n+     includes TYPE_MIN_VALUE and TYPE_MAX_VALUE information.\n+     See finish_enum_value_list for details.  */\n+  if (!ENUM_FIXED_UNDERLYING_TYPE_P (type))\n+    underlying_type = c_common_type_for_mode (TYPE_MODE (underlying_type),\n+\t\t\t\t\t      TYPE_UNSIGNED (underlying_type));\n+\n+  return underlying_type;\n+}\n+\n+/* Return true if TYPE1 and TYPE2 are layout-compatible types.  */\n+\n+bool\n+layout_compatible_type_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+  if (type1 == type2)\n+    return true;\n+  if (TREE_CODE (type1) != TREE_CODE (type2))\n+    return false;\n+\n+  type1 = rs_build_qualified_type (type1, TYPE_UNQUALIFIED);\n+  type2 = rs_build_qualified_type (type2, TYPE_UNQUALIFIED);\n+\n+  if (TREE_CODE (type1) == ENUMERAL_TYPE)\n+    return (TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+\t    && tree_int_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2))\n+\t    && same_type_p (finish_underlying_type (type1),\n+\t\t\t    finish_underlying_type (type2)));\n+\n+  if (CLASS_TYPE_P (type1) && std_layout_type_p (type1)\n+      && std_layout_type_p (type2) && TYPE_ALIGN (type1) == TYPE_ALIGN (type2)\n+      && tree_int_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2)))\n+    {\n+      tree field1 = TYPE_FIELDS (type1);\n+      tree field2 = TYPE_FIELDS (type2);\n+      if (TREE_CODE (type1) == RECORD_TYPE)\n+\t{\n+\t  while (1)\n+\t    {\n+\t      if (!next_common_initial_seqence (field1, field2))\n+\t\treturn false;\n+\t      if (field1 == NULL_TREE)\n+\t\treturn true;\n+\t      field1 = DECL_CHAIN (field1);\n+\t      field2 = DECL_CHAIN (field2);\n+\t    }\n+\t}\n+      /* Otherwise both types must be union types.\n+\t The standard says:\n+\t \"Two standard-layout unions are layout-compatible if they have\n+\t the same number of non-static data members and corresponding\n+\t non-static data members (in any order) have layout-compatible\n+\t types.\"\n+\t but the code anticipates that bitfield vs. non-bitfield,\n+\t different bitfield widths or presence/absence of\n+\t [[no_unique_address]] should be checked as well.  */\n+      auto_vec<tree, 16> vec;\n+      unsigned int count = 0;\n+      for (; field1; field1 = DECL_CHAIN (field1))\n+\tif (TREE_CODE (field1) == FIELD_DECL)\n+\t  count++;\n+      for (; field2; field2 = DECL_CHAIN (field2))\n+\tif (TREE_CODE (field2) == FIELD_DECL)\n+\t  vec.safe_push (field2);\n+      /* Discussions on core lean towards treating multiple union fields\n+\t of the same type as the same field, so this might need changing\n+\t in the future.  */\n+      if (count != vec.length ())\n+\treturn false;\n+      for (field1 = TYPE_FIELDS (type1); field1; field1 = DECL_CHAIN (field1))\n+\t{\n+\t  if (TREE_CODE (field1) != FIELD_DECL)\n+\t    continue;\n+\t  unsigned int j;\n+\t  tree t1 = DECL_BIT_FIELD_TYPE (field1);\n+\t  if (t1 == NULL_TREE)\n+\t    t1 = TREE_TYPE (field1);\n+\t  FOR_EACH_VEC_ELT (vec, j, field2)\n+\t    {\n+\t      tree t2 = DECL_BIT_FIELD_TYPE (field2);\n+\t      if (t2 == NULL_TREE)\n+\t\tt2 = TREE_TYPE (field2);\n+\t      if (DECL_BIT_FIELD_TYPE (field1))\n+\t\t{\n+\t\t  if (!DECL_BIT_FIELD_TYPE (field2))\n+\t\t    continue;\n+\t\t  if (TYPE_PRECISION (TREE_TYPE (field1))\n+\t\t      != TYPE_PRECISION (TREE_TYPE (field2)))\n+\t\t    continue;\n+\t\t}\n+\t      else if (DECL_BIT_FIELD_TYPE (field2))\n+\t\tcontinue;\n+\t      if (!layout_compatible_type_p (t1, t2))\n+\t\tcontinue;\n+\t      if ((!lookup_attribute (\"no_unique_address\",\n+\t\t\t\t      DECL_ATTRIBUTES (field1)))\n+\t\t  != !lookup_attribute (\"no_unique_address\",\n+\t\t\t\t\tDECL_ATTRIBUTES (field2)))\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\t  if (j == vec.length ())\n+\t    return false;\n+\t  vec.unordered_remove (j);\n+\t}\n+      return true;\n+    }\n+\n+  return same_type_p (type1, type2);\n+}\n+\n+/* Helper function for is_corresponding_member_aggr.  Return true if\n+   MEMBERTYPE pointer-to-data-member ARG can be found in anonymous\n+   union or structure BASETYPE.  */\n+\n+static bool\n+is_corresponding_member_union (tree basetype, tree membertype, tree arg)\n+{\n+  for (tree field = TYPE_FIELDS (basetype); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) != FIELD_DECL || DECL_BIT_FIELD_TYPE (field))\n+      continue;\n+    else if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field),\n+\t\t\t\t\t\t\tmembertype))\n+      {\n+\tif (TREE_CODE (arg) != INTEGER_CST\n+\t    || tree_int_cst_equal (arg, byte_position (field)))\n+\t  return true;\n+      }\n+    else if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+      {\n+\ttree narg = arg;\n+\tif (TREE_CODE (basetype) != UNION_TYPE\n+\t    && TREE_CODE (narg) == INTEGER_CST)\n+\t  narg = size_binop (MINUS_EXPR, arg, byte_position (field));\n+\tif (is_corresponding_member_union (TREE_TYPE (field), membertype, narg))\n+\t  return true;\n+      }\n+  return false;\n+}\n+\n+/* Helper function for layout_compatible_type_p and\n+   is_corresponding_member_aggr.  Advance to next members (NULL if\n+   no further ones) and return true if those members are still part of\n+   the common initial sequence.  */\n+\n+bool\n+next_common_initial_seqence (tree &memb1, tree &memb2)\n+{\n+  while (memb1)\n+    {\n+      if (TREE_CODE (memb1) != FIELD_DECL\n+\t  || (DECL_FIELD_IS_BASE (memb1) && is_empty_field (memb1)))\n+\t{\n+\t  memb1 = DECL_CHAIN (memb1);\n+\t  continue;\n+\t}\n+      if (DECL_FIELD_IS_BASE (memb1))\n+\t{\n+\t  memb1 = TYPE_FIELDS (TREE_TYPE (memb1));\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  while (memb2)\n+    {\n+      if (TREE_CODE (memb2) != FIELD_DECL\n+\t  || (DECL_FIELD_IS_BASE (memb2) && is_empty_field (memb2)))\n+\t{\n+\t  memb2 = DECL_CHAIN (memb2);\n+\t  continue;\n+\t}\n+      if (DECL_FIELD_IS_BASE (memb2))\n+\t{\n+\t  memb2 = TYPE_FIELDS (TREE_TYPE (memb2));\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  if (memb1 == NULL_TREE && memb2 == NULL_TREE)\n+    return true;\n+  if (memb1 == NULL_TREE || memb2 == NULL_TREE)\n+    return false;\n+  if (DECL_BIT_FIELD_TYPE (memb1))\n+    {\n+      if (!DECL_BIT_FIELD_TYPE (memb2))\n+\treturn false;\n+      if (!layout_compatible_type_p (DECL_BIT_FIELD_TYPE (memb1),\n+\t\t\t\t     DECL_BIT_FIELD_TYPE (memb2)))\n+\treturn false;\n+      if (TYPE_PRECISION (TREE_TYPE (memb1))\n+\t  != TYPE_PRECISION (TREE_TYPE (memb2)))\n+\treturn false;\n+    }\n+  else if (DECL_BIT_FIELD_TYPE (memb2))\n+    return false;\n+  else if (!layout_compatible_type_p (TREE_TYPE (memb1), TREE_TYPE (memb2)))\n+    return false;\n+  if ((!lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (memb1)))\n+      != !lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (memb2)))\n+    return false;\n+  if (!tree_int_cst_equal (bit_position (memb1), bit_position (memb2)))\n+    return false;\n+  return true;\n+}\n+\n+/* Helper function for fold_builtin_is_corresponding_member call.\n+   Return boolean_false_node if MEMBERTYPE1 BASETYPE1::*ARG1 and\n+   MEMBERTYPE2 BASETYPE2::*ARG2 aren't corresponding members,\n+   boolean_true_node if they are corresponding members, or for\n+   non-constant ARG2 the highest member offset for corresponding\n+   members.  */\n+\n+static tree\n+is_corresponding_member_aggr (location_t loc, tree basetype1, tree membertype1,\n+\t\t\t      tree arg1, tree basetype2, tree membertype2,\n+\t\t\t      tree arg2)\n+{\n+  tree field1 = TYPE_FIELDS (basetype1);\n+  tree field2 = TYPE_FIELDS (basetype2);\n+  tree ret = boolean_false_node;\n+  while (1)\n+    {\n+      bool r = next_common_initial_seqence (field1, field2);\n+      if (field1 == NULL_TREE || field2 == NULL_TREE)\n+\tbreak;\n+      if (r\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field1),\n+\t\t\t\t\t\t\tmembertype1)\n+\t  && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field2),\n+\t\t\t\t\t\t\tmembertype2))\n+\t{\n+\t  tree pos = byte_position (field1);\n+\t  if (TREE_CODE (arg1) == INTEGER_CST && tree_int_cst_equal (arg1, pos))\n+\t    {\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\treturn boolean_true_node;\n+\t      return pos;\n+\t    }\n+\t  else if (TREE_CODE (arg1) != INTEGER_CST)\n+\t    ret = pos;\n+\t}\n+      else if (ANON_AGGR_TYPE_P (TREE_TYPE (field1))\n+\t       && ANON_AGGR_TYPE_P (TREE_TYPE (field2)))\n+\t{\n+\t  if ((!lookup_attribute (\"no_unique_address\",\n+\t\t\t\t  DECL_ATTRIBUTES (field1)))\n+\t      != !lookup_attribute (\"no_unique_address\",\n+\t\t\t\t    DECL_ATTRIBUTES (field2)))\n+\t    break;\n+\t  if (!tree_int_cst_equal (bit_position (field1),\n+\t\t\t\t   bit_position (field2)))\n+\t    break;\n+\t  bool overlap = true;\n+\t  tree pos = byte_position (field1);\n+\t  if (TREE_CODE (arg1) == INTEGER_CST)\n+\t    {\n+\t      tree off1 = fold_convert (sizetype, arg1);\n+\t      tree sz1 = TYPE_SIZE_UNIT (TREE_TYPE (field1));\n+\t      if (tree_int_cst_lt (off1, pos)\n+\t\t  || tree_int_cst_le (size_binop (PLUS_EXPR, pos, sz1), off1))\n+\t\toverlap = false;\n+\t    }\n+\t  if (TREE_CODE (arg2) == INTEGER_CST)\n+\t    {\n+\t      tree off2 = fold_convert (sizetype, arg2);\n+\t      tree sz2 = TYPE_SIZE_UNIT (TREE_TYPE (field2));\n+\t      if (tree_int_cst_lt (off2, pos)\n+\t\t  || tree_int_cst_le (size_binop (PLUS_EXPR, pos, sz2), off2))\n+\t\toverlap = false;\n+\t    }\n+\t  if (overlap && NON_UNION_CLASS_TYPE_P (TREE_TYPE (field1))\n+\t      && NON_UNION_CLASS_TYPE_P (TREE_TYPE (field2)))\n+\t    {\n+\t      tree narg1 = arg1;\n+\t      if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\tnarg1\n+\t\t  = size_binop (MINUS_EXPR, fold_convert (sizetype, arg1), pos);\n+\t      tree narg2 = arg2;\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\tnarg2\n+\t\t  = size_binop (MINUS_EXPR, fold_convert (sizetype, arg2), pos);\n+\t      tree t1 = TREE_TYPE (field1);\n+\t      tree t2 = TREE_TYPE (field2);\n+\t      tree nret\n+\t\t= is_corresponding_member_aggr (loc, t1, membertype1, narg1, t2,\n+\t\t\t\t\t\tmembertype2, narg2);\n+\t      if (nret != boolean_false_node)\n+\t\t{\n+\t\t  if (nret == boolean_true_node)\n+\t\t    return nret;\n+\t\t  if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\t    return size_binop (PLUS_EXPR, nret, pos);\n+\t\t  ret = size_binop (PLUS_EXPR, nret, pos);\n+\t\t}\n+\t    }\n+\t  else if (overlap && TREE_CODE (TREE_TYPE (field1)) == UNION_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (field2)) == UNION_TYPE)\n+\t    {\n+\t      tree narg1 = arg1;\n+\t      if (TREE_CODE (arg1) == INTEGER_CST)\n+\t\tnarg1\n+\t\t  = size_binop (MINUS_EXPR, fold_convert (sizetype, arg1), pos);\n+\t      tree narg2 = arg2;\n+\t      if (TREE_CODE (arg2) == INTEGER_CST)\n+\t\tnarg2\n+\t\t  = size_binop (MINUS_EXPR, fold_convert (sizetype, arg2), pos);\n+\t      if (is_corresponding_member_union (TREE_TYPE (field1),\n+\t\t\t\t\t\t membertype1, narg1)\n+\t\t  && is_corresponding_member_union (TREE_TYPE (field2),\n+\t\t\t\t\t\t    membertype2, narg2))\n+\t\t{\n+\t\t  sorry_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t\t\t \"not well defined for anonymous unions\");\n+\t\t  return boolean_false_node;\n+\t\t}\n+\t    }\n+\t}\n+      if (!r)\n+\tbreak;\n+      field1 = DECL_CHAIN (field1);\n+      field2 = DECL_CHAIN (field2);\n+    }\n+  return ret;\n+}\n+\n+/* Returns true iff T is a null member pointer value (4.11).  */\n+\n+bool\n+null_member_pointer_value_p (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+  if (!type)\n+    return false;\n+  else if (TYPE_PTRMEMFUNC_P (type))\n+    return (TREE_CODE (t) == CONSTRUCTOR && CONSTRUCTOR_NELTS (t)\n+\t    && integer_zerop (CONSTRUCTOR_ELT (t, 0)->value));\n+  else if (TYPE_PTRDATAMEM_P (type))\n+    return integer_all_onesp (t);\n+  else\n+    return false;\n+}\n+\n+/* Fold __builtin_is_corresponding_member call.  */\n+\n+tree\n+fold_builtin_is_corresponding_member (location_t loc, int nargs, tree *args)\n+{\n+  /* Unless users call the builtin directly, the following 3 checks should be\n+     ensured from std::is_corresponding_member function template.  */\n+  if (nargs != 2)\n+    {\n+      error_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t     \"needs two arguments\");\n+      return boolean_false_node;\n+    }\n+  tree arg1 = args[0];\n+  tree arg2 = args[1];\n+  if (error_operand_p (arg1) || error_operand_p (arg2))\n+    return boolean_false_node;\n+  if (!TYPE_PTRMEM_P (TREE_TYPE (arg1)) || !TYPE_PTRMEM_P (TREE_TYPE (arg2)))\n+    {\n+      error_at (loc, \"%<__builtin_is_corresponding_member%> \"\n+\t\t     \"argument is not pointer to member\");\n+      return boolean_false_node;\n+    }\n+\n+  if (!TYPE_PTRDATAMEM_P (TREE_TYPE (arg1))\n+      || !TYPE_PTRDATAMEM_P (TREE_TYPE (arg2)))\n+    return boolean_false_node;\n+\n+  tree membertype1 = TREE_TYPE (TREE_TYPE (arg1));\n+  tree basetype1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg1));\n+  if (!complete_type_or_else (basetype1, NULL_TREE))\n+    return boolean_false_node;\n+\n+  tree membertype2 = TREE_TYPE (TREE_TYPE (arg2));\n+  tree basetype2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg2));\n+  if (!complete_type_or_else (basetype2, NULL_TREE))\n+    return boolean_false_node;\n+\n+  if (!NON_UNION_CLASS_TYPE_P (basetype1) || !NON_UNION_CLASS_TYPE_P (basetype2)\n+      || !std_layout_type_p (basetype1) || !std_layout_type_p (basetype2))\n+    return boolean_false_node;\n+\n+  /* If the member types aren't layout compatible, then they\n+     can't be corresponding members.  */\n+  if (!layout_compatible_type_p (membertype1, membertype2))\n+    return boolean_false_node;\n+\n+  if (null_member_pointer_value_p (arg1) || null_member_pointer_value_p (arg2))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST\n+      && !tree_int_cst_equal (arg1, arg2))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg2) == INTEGER_CST && TREE_CODE (arg1) != INTEGER_CST)\n+    {\n+      std::swap (arg1, arg2);\n+      std::swap (membertype1, membertype2);\n+      std::swap (basetype1, basetype2);\n+    }\n+\n+  tree ret = is_corresponding_member_aggr (loc, basetype1, membertype1, arg1,\n+\t\t\t\t\t   basetype2, membertype2, arg2);\n+  if (TREE_TYPE (ret) == boolean_type_node)\n+    return ret;\n+  /* If both arg1 and arg2 are INTEGER_CSTs, is_corresponding_member_aggr\n+     already returns boolean_{true,false}_node whether those particular\n+     members are corresponding members or not.  Otherwise, if only\n+     one of them is INTEGER_CST (canonicalized to first being INTEGER_CST\n+     above), it returns boolean_false_node if it is certainly not a\n+     corresponding member and otherwise we need to do a runtime check that\n+     those two OFFSET_TYPE offsets are equal.\n+     If neither of the operands is INTEGER_CST, is_corresponding_member_aggr\n+     returns the largest offset at which the members would be corresponding\n+     members, so perform arg1 <= ret && arg1 == arg2 runtime check.  */\n+  gcc_assert (TREE_CODE (arg2) != INTEGER_CST);\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    return fold_build2 (EQ_EXPR, boolean_type_node, arg1,\n+\t\t\tfold_convert (TREE_TYPE (arg1), arg2));\n+  ret = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t     fold_convert (pointer_sized_int_node, arg1),\n+\t\t     fold_convert (pointer_sized_int_node, ret));\n+  return fold_build2 (TRUTH_AND_EXPR, boolean_type_node, ret,\n+\t\t      fold_build2 (EQ_EXPR, boolean_type_node, arg1,\n+\t\t\t\t   fold_convert (TREE_TYPE (arg1), arg2)));\n+}\n+\n } // namespace Rust"}, {"sha": "57440af632d0142a4d33bedad4fb19dc3a5fac74", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2da345e08b313dfd0548064cdb3813a7c86d5a/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2da345e08b313dfd0548064cdb3813a7c86d5a/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=8c2da345e08b313dfd0548064cdb3813a7c86d5a", "patch": "@@ -1319,6 +1319,33 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n   (CLASS_TYPE_P (NODE) && LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr)\n #define SET_ANON_AGGR_TYPE_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->anon_aggr = 1)\n \n+/* Nonzero if T is a class type but not a union.  */\n+#define NON_UNION_CLASS_TYPE_P(T)                                              \\\n+  (TREE_CODE (T) == RECORD_TYPE && TYPE_LANG_FLAG_5 (T))\n+\n+/* Determines whether an ENUMERAL_TYPE has an explicit\n+   underlying type.  */\n+#define ENUM_FIXED_UNDERLYING_TYPE_P(NODE) (TYPE_LANG_FLAG_5 (NODE))\n+\n+/* Returns the underlying type of the given enumeration type. The\n+   underlying type is determined in different ways, depending on the\n+   properties of the enum:\n+\n+     - In C++0x, the underlying type can be explicitly specified, e.g.,\n+\n+\t enum E1 : char { ... } // underlying type is char\n+\n+     - In a C++0x scoped enumeration, the underlying type is int\n+       unless otherwises specified:\n+\n+\t enum class E2 { ... } // underlying type is int\n+\n+     - Otherwise, the underlying type is determined based on the\n+       values of the enumerators. In this case, the\n+       ENUM_UNDERLYING_TYPE will not be set until after the definition\n+       of the enumeration is completed by finish_enum.  */\n+#define ENUM_UNDERLYING_TYPE(TYPE) TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -2764,6 +2791,34 @@ is_class_type (tree, int);\n \n extern tree braced_lists_to_strings (tree, tree);\n \n+extern tree\n+fold_builtin_is_pointer_inverconvertible_with_class (location_t, int, tree *);\n+\n+extern bool layout_compatible_type_p (tree, tree);\n+\n+extern tree finish_underlying_type (tree);\n+\n+extern tree\n+c_common_type_for_mode (machine_mode, int);\n+\n+extern bool std_layout_type_p (const_tree);\n+\n+extern tree complete_type (tree);\n+\n+extern tree complete_type_or_else (tree, tree);\n+\n+extern void note_failed_type_completion_for_satisfaction (tree);\n+\n+extern tree complete_type_or_maybe_complain (tree, tree, tsubst_flags_t);\n+\n+extern bool\n+next_common_initial_seqence (tree &, tree &);\n+\n+extern bool null_member_pointer_value_p (tree);\n+\n+extern tree\n+fold_builtin_is_corresponding_member (location_t, int, tree *);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum"}]}