{"sha": "240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQwYjVjZWFiOThjOGM2NmNhMzI2OWQ3YThlZjY4OWE1MDE5ZDk2Yw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-12-06T22:52:43Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-12-06T22:52:43Z"}, "message": "re PR rtl-optimization/36365 (Hang in df_analyze)\n\n\tPR rtl-optimization/36365\n\t* df-core.c (df_worklist_dataflow_overeager): Remove.\n\t(df_worklist_dataflow): Don't call it, use double-queue only.\n\t* params.def (PARAM_DF_DOUBLE_QUQUQ_THRESHOLD_FACTOR): Remove.\n\nFrom-SVN: r142529", "tree": {"sha": "42da354fbe09901eb9b84024810c9710b0d3f16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42da354fbe09901eb9b84024810c9710b0d3f16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/comments", "author": null, "committer": null, "parents": [{"sha": "97b14ba880379f3c588ce4c9528ac02e114940b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b14ba880379f3c588ce4c9528ac02e114940b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b14ba880379f3c588ce4c9528ac02e114940b0"}], "stats": {"total": 99, "additions": 15, "deletions": 84}, "files": [{"sha": "0c889a18243751587d86210e71b5cc650e679eae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "patch": "@@ -1,3 +1,10 @@\n+2008-12-06  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/36365\n+\t* df-core.c (df_worklist_dataflow_overeager): Remove.\n+\t(df_worklist_dataflow): Don't call it, use double-queue only.\n+\t* params.def (PARAM_DF_DOUBLE_QUQUQ_THRESHOLD_FACTOR): Remove.\n+\n 2008-12-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/38428"}, {"sha": "7b83dce53f6a04f94f747800b705e74f3b10fb75", "filename": "gcc/df-core.c", "status": "modified", "additions": 8, "deletions": 78, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "patch": "@@ -943,47 +943,6 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n \n \n /* This will free \"pending\". */\n-static void \n-df_worklist_dataflow_overeager (struct dataflow *dataflow,\n-\t\t\t\tbitmap pending,\n-                                sbitmap considered,\n-                                int *blocks_in_postorder,\n-\t\t\t\tunsigned *bbindex_to_postorder)\n-{\n-  enum df_flow_dir dir = dataflow->problem->dir;\n-  int count = 0;\n-\n-  while (!bitmap_empty_p (pending))\n-    {\n-      unsigned bb_index;\n-      int index;\n-      count++;\n-\n-      index = bitmap_first_set_bit (pending);\n-      bitmap_clear_bit (pending, index);\n-\n-      bb_index = blocks_in_postorder[index];\n-\n-      if (dir == DF_FORWARD)\n-\tdf_worklist_propagate_forward (dataflow, bb_index,\n-\t\t\t\t       bbindex_to_postorder,\n-\t\t\t\t       pending, considered);\n-      else \n-\tdf_worklist_propagate_backward (dataflow, bb_index,\n-\t\t\t\t\tbbindex_to_postorder,\n-\t\t\t\t\tpending, considered);\n-    }\n-\n-  BITMAP_FREE (pending);\n-\n-  /* Dump statistics. */\n-  if (dump_file)\n-    fprintf (dump_file, \"df_worklist_dataflow_overeager:\"\n-\t     \"n_basic_blocks %d n_edges %d\"\n-\t     \" count %d (%5.2g)\\n\",\n-\t     n_basic_blocks, n_edges,\n-\t     count, count / (float)n_basic_blocks);\n-}\n \n static void \n df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n@@ -1042,23 +1001,10 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \n /* Worklist-based dataflow solver. It uses sbitmap as a worklist,\n    with \"n\"-th bit representing the n-th block in the reverse-postorder order. \n-   This is so-called over-eager algorithm where it propagates\n-   changes on demand. This algorithm may visit blocks more than\n-   iterative method if there are deeply nested loops. \n-   Worklist algorithm works better than iterative algorithm\n-   for CFGs with no nested loops.\n-   In practice, the measurement shows worklist algorithm beats \n-   iterative algorithm by some margin overall.  \n-   Note that this is slightly different from the traditional textbook worklist solver,\n-   in that the worklist is effectively sorted by the reverse postorder.\n-   For CFGs with no nested loops, this is optimal. \n-   \n-   The overeager algorithm while works well for typical inputs,\n-   it could degenerate into excessive iterations given CFGs with high loop nests\n-   and unstructured loops. To cap the excessive iteration on such case,\n-   we switch to double-queueing when the original algorithm seems to \n-   get into such.\n-   */\n+   The solver is a double-queue algorithm similar to the \"double stack\" solver\n+   from Cooper, Harvey and Kennedy, \"Iterative data-flow analysis, Revisited\".\n+   The only significant difference is that the worklist in this implementation\n+   is always sorted in RPO of the CFG visiting direction.  */\n \n void \n df_worklist_dataflow (struct dataflow *dataflow,\n@@ -1103,26 +1049,10 @@ df_worklist_dataflow (struct dataflow *dataflow,\n   if (dataflow->problem->init_fun)\n     dataflow->problem->init_fun (blocks_to_consider);\n \n-  /* Solve it. Determine the solving algorithm\n-     based on a simple heuristic. */\n-  if (n_edges > PARAM_VALUE (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR)\n-      * n_basic_blocks)\n-    {\n-      /* High average connectivity, meaning dense graph\n-         with more likely deep nested loops\n-\t or unstructured loops. */\n-      df_worklist_dataflow_doublequeue (dataflow, pending, considered,\n-\t\t\t\t\tblocks_in_postorder,\n-\t\t\t\t\tbbindex_to_postorder);\n-    }\n-  else \n-    {\n-      /* Most inputs fall into this case\n-        with relatively flat or structured CFG. */\n-      df_worklist_dataflow_overeager (dataflow, pending, considered,\n-\t\t\t\t      blocks_in_postorder,\n-\t\t\t\t      bbindex_to_postorder);\n-    }\n+  /* Solve it.  */\n+  df_worklist_dataflow_doublequeue (dataflow, pending, considered,\n+\t\t\t\t    blocks_in_postorder,\n+\t\t\t\t    bbindex_to_postorder);\n \n   sbitmap_free (considered);\n   free (bbindex_to_postorder);"}, {"sha": "ea3015b3640ad872fb9928f529160968a6b9df29", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/240b5ceab98c8c66ca3269d7a8ef689a5019d96c/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=240b5ceab98c8c66ca3269d7a8ef689a5019d96c", "patch": "@@ -745,12 +745,6 @@ DEFPARAM (PARAM_SCCVN_MAX_SCC_SIZE,\n \t  \"Maximum size of a SCC before SCCVN stops processing a function\",\n \t  10000, 10, 0)\n \n-\n-DEFPARAM (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR,\n-\t  \"df-double-queue-threshold-factor\",\n-\t  \"Multiplier used for determining the double-queueing threshold\",\n-\t  2, 0, 0)\n-\n DEFPARAM (PARAM_IRA_MAX_LOOPS_NUM,\n \t  \"ira-max-loops-num\",\n \t  \"max loops number for regional RA\","}]}