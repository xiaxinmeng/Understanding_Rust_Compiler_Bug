{"sha": "28895c1265e19a3e854040610d8478cfb8768d0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg4OTVjMTI2NWUxOWEzZTg1NDA0MDYxMGQ4NDc4Y2ZiODc2OGQwYQ==", "commit": {"author": {"name": "lrh2000", "email": "lrh2000@pku.edu.cn", "date": "2021-04-22T13:22:11Z"}, "committer": {"name": "lrh2000", "email": "lrh2000@pku.edu.cn", "date": "2021-04-22T14:05:12Z"}, "message": "Merge branch 'origin/master'", "tree": {"sha": "eec0947af5d1e9bcbddb29c3b1935136d1948e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec0947af5d1e9bcbddb29c3b1935136d1948e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28895c1265e19a3e854040610d8478cfb8768d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28895c1265e19a3e854040610d8478cfb8768d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28895c1265e19a3e854040610d8478cfb8768d0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28895c1265e19a3e854040610d8478cfb8768d0a/comments", "author": {"login": "lrh2000", "id": 41988959, "node_id": "MDQ6VXNlcjQxOTg4OTU5", "avatar_url": "https://avatars.githubusercontent.com/u/41988959?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lrh2000", "html_url": "https://github.com/lrh2000", "followers_url": "https://api.github.com/users/lrh2000/followers", "following_url": "https://api.github.com/users/lrh2000/following{/other_user}", "gists_url": "https://api.github.com/users/lrh2000/gists{/gist_id}", "starred_url": "https://api.github.com/users/lrh2000/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lrh2000/subscriptions", "organizations_url": "https://api.github.com/users/lrh2000/orgs", "repos_url": "https://api.github.com/users/lrh2000/repos", "events_url": "https://api.github.com/users/lrh2000/events{/privacy}", "received_events_url": "https://api.github.com/users/lrh2000/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lrh2000", "id": 41988959, "node_id": "MDQ6VXNlcjQxOTg4OTU5", "avatar_url": "https://avatars.githubusercontent.com/u/41988959?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lrh2000", "html_url": "https://github.com/lrh2000", "followers_url": "https://api.github.com/users/lrh2000/followers", "following_url": "https://api.github.com/users/lrh2000/following{/other_user}", "gists_url": "https://api.github.com/users/lrh2000/gists{/gist_id}", "starred_url": "https://api.github.com/users/lrh2000/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lrh2000/subscriptions", "organizations_url": "https://api.github.com/users/lrh2000/orgs", "repos_url": "https://api.github.com/users/lrh2000/repos", "events_url": "https://api.github.com/users/lrh2000/events{/privacy}", "received_events_url": "https://api.github.com/users/lrh2000/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aeb9f47187f9b7ad55e32bcd273556823f383c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aeb9f47187f9b7ad55e32bcd273556823f383c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "dd3c58b2ce55ce6585916607927c3bca087610c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3c58b2ce55ce6585916607927c3bca087610c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3c58b2ce55ce6585916607927c3bca087610c6"}], "stats": {"total": 95837, "additions": 1035, "deletions": 94802}, "files": [{"sha": "9ba545733e6e78e5e84ed2dc7f9017b1f0c02240", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -79,7 +79,8 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n-\trust/rust-hir-liveness.o \\\n+    rust/rust-hir-const-fold.o \\\n+    rust/rust-hir-liveness.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "11e791c065180511d404429820b2be6b5007d6c2", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-hir-const-fold-ctx.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -43,7 +44,8 @@ class Context\n   Context (::Backend *backend)\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n-      mappings (Analysis::Mappings::get ())\n+      mappings (Analysis::Mappings::get ()),\n+      const_ctx (ConstFold::Context::get ())\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -104,6 +106,7 @@ class Context\n   Resolver::Resolver *get_resolver () { return resolver; }\n   Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n   Analysis::Mappings *get_mappings () { return mappings; }\n+  ConstFold::Context *get_const_ctx () { return const_ctx; }\n \n   void push_block (Bblock *scope)\n   {\n@@ -260,6 +263,7 @@ class Context\n   Resolver::Resolver *resolver;\n   Resolver::TypeCheckContext *tyctx;\n   Analysis::Mappings *mappings;\n+  ConstFold::Context *const_ctx;\n \n   // state\n   std::vector<fncontext> fn_stack;\n@@ -420,16 +424,10 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &type) override\n   {\n-    mpz_t ival;\n-    mpz_init_set_ui (ival, type.get_capacity ());\n-\n-    Btype *capacity_type = ctx->get_backend ()->integer_type (true, 32);\n-    Bexpression *length\n-      = ctx->get_backend ()->integer_constant_expression (capacity_type, ival);\n-\n     Btype *element_type\n       = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n-    translated = ctx->get_backend ()->array_type (element_type, length);\n+    translated\n+      = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n   }\n \n   void visit (TyTy::BoolType &type) override"}, {"sha": "59ae815937f81b21f66428f6946f57d5075c97ad", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -275,7 +275,12 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *array_type = TyTyResolveCompile::compile (ctx, tyty);\n+    rust_assert (tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+    TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n+    capacity_expr = array_tyty->get_capacity ();\n+\n+    Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+    rust_assert (array_type != nullptr);\n \n     expr.get_internal_elements ()->accept_vis (*this);\n     std::vector<unsigned long> indexes;\n@@ -302,7 +307,11 @@ class CompileExpr : public HIRCompileBase\n     Bexpression *translated_expr\n       = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n \n-    for (size_t i = 0; i < elems.get_num_elements (); ++i)\n+    size_t capacity;\n+    bool ok = ctx->get_backend ()->const_size_cast (capacity_expr, &capacity);\n+    rust_assert (ok);\n+\n+    for (size_t i = 0; i < capacity; ++i)\n       constructor.push_back (translated_expr);\n   }\n \n@@ -786,9 +795,12 @@ class CompileExpr : public HIRCompileBase\n   }\n \n private:\n-  CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+  CompileExpr (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n+  {}\n \n   Bexpression *translated;\n+  Bexpression *capacity_expr;\n   std::vector<Bexpression *> constructor;\n };\n "}, {"sha": "33fc45bc2e59c6044b8ed0a651a4694725ce3279", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -27,42 +27,6 @@\n namespace Rust {\n namespace HIR {\n \n-class ArrayCapacityConstant : public ASTLoweringBase\n-{\n-  using Rust::HIR::ASTLoweringBase::visit;\n-\n-public:\n-  static bool fold (AST::Expr *expr, size_t *folded_result)\n-  {\n-    ArrayCapacityConstant folder;\n-    expr->accept_vis (folder);\n-    *folded_result = folder.result;\n-    return folder.ok;\n-  }\n-\n-  void visit (AST::LiteralExpr &expr) override\n-  {\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase AST::Literal::LitType::INT: {\n-\t  ok = true;\n-\t  std::stringstream ss (expr.as_string ());\n-\t  ss >> result;\n-\t}\n-\tbreak;\n-\n-      default:\n-\treturn;\n-      }\n-  }\n-\n-private:\n-  ArrayCapacityConstant () : ok (false), result (-1) {}\n-\n-  bool ok;\n-  size_t result;\n-}; // namespace Resolver\n-\n class ASTLowerPathInExpression : public ASTLoweringBase\n {\n   using Rust::HIR::ASTLoweringBase::visit;\n@@ -332,18 +296,9 @@ class ASTLoweringExpr : public ASTLoweringBase\n     HIR::Expr *num_copies\n       = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n \n-    size_t folded;\n-    if (!ArrayCapacityConstant::fold (elems.get_num_copies ().get (), &folded))\n-      {\n-\trust_fatal_error (elems.get_num_copies ()->get_locus_slow (),\n-\t\t\t  \"failed to fold capacity constant\");\n-\treturn;\n-      }\n-\n     translated_array_elems\n       = new HIR::ArrayElemsCopied (std::unique_ptr<HIR::Expr> (element),\n-\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies),\n-\t\t\t\t   folded);\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies));\n   }\n \n   void visit (AST::LiteralExpr &expr) override"}, {"sha": "50f1eb81e9190e0139a123ab80ce0b27d52697d6", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -825,8 +825,6 @@ class ArrayElems\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n-  virtual size_t get_num_elements () const = 0;\n-\n protected:\n   // pure virtual clone implementation\n   virtual ArrayElems *clone_array_elems_impl () const = 0;\n@@ -870,7 +868,7 @@ class ArrayElemsValues : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  size_t get_num_elements () const override { return values.size (); }\n+  size_t get_num_elements () const { return values.size (); }\n \n   void iterate (std::function<bool (Expr *)> cb)\n   {\n@@ -893,33 +891,26 @@ class ArrayElemsCopied : public ArrayElems\n {\n   std::unique_ptr<Expr> elem_to_copy;\n   std::unique_ptr<Expr> num_copies;\n-  size_t folded_copy_amount;\n-\n-  // TODO: should this store location data?\n \n public:\n   // Constructor requires pointers for polymorphism\n   ArrayElemsCopied (std::unique_ptr<Expr> copied_elem,\n-\t\t    std::unique_ptr<Expr> copy_amount,\n-\t\t    size_t folded_copy_amount)\n+\t\t    std::unique_ptr<Expr> copy_amount)\n     : elem_to_copy (std::move (copied_elem)),\n-      num_copies (std::move (copy_amount)),\n-      folded_copy_amount (folded_copy_amount)\n+      num_copies (std::move (copy_amount))\n   {}\n \n   // Copy constructor required due to unique_ptr - uses custom clone\n   ArrayElemsCopied (ArrayElemsCopied const &other)\n     : elem_to_copy (other.elem_to_copy->clone_expr ()),\n-      num_copies (other.num_copies->clone_expr ()),\n-      folded_copy_amount (other.folded_copy_amount)\n+      num_copies (other.num_copies->clone_expr ())\n   {}\n \n   // Overloaded assignment operator for deep copying\n   ArrayElemsCopied &operator= (ArrayElemsCopied const &other)\n   {\n     elem_to_copy = other.elem_to_copy->clone_expr ();\n     num_copies = other.num_copies->clone_expr ();\n-    folded_copy_amount = other.folded_copy_amount;\n \n     return *this;\n   }\n@@ -932,10 +923,10 @@ class ArrayElemsCopied : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  size_t get_num_elements () const override { return folded_copy_amount; }\n-\n   Expr *get_elem_to_copy () { return elem_to_copy.get (); }\n \n+  Expr *get_num_copies_expr () { return num_copies.get (); }\n+\n protected:\n   ArrayElemsCopied *clone_array_elems_impl () const override\n   {"}, {"sha": "262a04a608c3fe7e2c8f66bb238b51e08dd8b3f2", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -165,11 +165,11 @@ struct GenericArgs\n   GenericArgs &operator= (GenericArgs &&other) = default;\n \n   // Creates an empty GenericArgs (no arguments)\n-  static GenericArgs create_empty ()\n+  static GenericArgs create_empty (Location locus = Location ())\n   {\n     return GenericArgs (std::vector<Lifetime> (),\n \t\t\tstd::vector<std::unique_ptr<Type> > (),\n-\t\t\tstd::vector<GenericArgsBinding> ());\n+\t\t\tstd::vector<GenericArgsBinding> (), locus);\n   }\n \n   bool is_empty () const"}, {"sha": "b999c41b10189a39dbd3e47b585ce24c6fc0dbcc", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -217,10 +217,7 @@ class ResolveType : public ResolverBase\n       }\n   }\n \n-  void visit (AST::ArrayType &type) override\n-  {\n-    type.get_elem_type ()->accept_vis (*this);\n-  }\n+  void visit (AST::ArrayType &type) override;\n \n   void visit (AST::ReferenceType &type) override\n   {"}, {"sha": "41c6938ea6132af44982aac2902ea29618f0f389", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -589,5 +589,14 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     }\n }\n \n+// rust-ast-resolve-type.h\n+\n+void\n+ResolveType::visit (AST::ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e71d81ed1cca54f1e9594787a9eda4423df26881", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -93,6 +93,11 @@ class Backend\n   virtual void debug (Bvariable *) = 0;\n   virtual void debug (Blabel *) = 0;\n \n+  // const folder helpers\n+  virtual bool const_size_cast (Bexpression *, size_t *) = 0;\n+  virtual std::string const_size_val_to_string (Bexpression *) = 0;\n+  virtual bool const_values_equal (Bexpression *, Bexpression *) = 0;\n+\n   // Types.\n \n   // Produce an error type.  Actually the backend could probably just\n@@ -283,6 +288,9 @@ class Backend\n   // going without crashing.\n   virtual Bexpression *error_expression () = 0;\n \n+  // return whether this is error_mark_node\n+  virtual bool is_error_expression (Bexpression *) = 0;\n+\n   // Create a nil pointer expression.\n   virtual Bexpression *nil_pointer_expression () = 0;\n "}, {"sha": "ed89c94ebee282588583c1088d6b9618e67aa4a6", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -167,7 +167,6 @@ class Gcc_backend : public Backend\n   void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n \n   // Types.\n-\n   Btype *error_type () { return this->make_type (error_mark_node); }\n \n   Btype *void_type () { return this->make_type (void_type_node); }\n@@ -176,6 +175,46 @@ class Gcc_backend : public Backend\n \n   Btype *char_type () { return this->make_type (char_type_node); }\n \n+  bool const_size_cast (Bexpression *expr, size_t *result)\n+  {\n+    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+\n+    unsigned char buf[sizeof (size_t) + 1];\n+    memset (buf, 0, sizeof (buf));\n+\n+    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    if (ret <= 0)\n+      return false;\n+\n+    size_t *tmp = (size_t *) buf;\n+    *result = *tmp;\n+    return true;\n+  }\n+\n+  std::string const_size_val_to_string (Bexpression *expr)\n+  {\n+    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+\n+    unsigned char buf[sizeof (size_t) + 1];\n+    memset (buf, 0, sizeof (buf));\n+\n+    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    rust_assert (ret > 0);\n+\n+    size_t *ptr = (size_t *) buf;\n+    return std::to_string (*ptr);\n+  }\n+\n+  bool const_values_equal (Bexpression *a, Bexpression *b)\n+  {\n+    return operand_equal_p (a->get_tree (), b->get_tree (),\n+\t\t\t    OEP_ONLY_CONST | OEP_PURE_SAME);\n+    // printf (\"comparing!\\n\");\n+    // debug_tree (a->get_tree ());\n+    // debug_tree (b->get_tree ());\n+    // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n+  }\n+\n   Btype *wchar_type ()\n   {\n     // i think this is meant to be 32 bit from\n@@ -250,6 +289,11 @@ class Gcc_backend : public Backend\n     return this->make_expression (error_mark_node);\n   }\n \n+  bool is_error_expression (Bexpression *expr)\n+  {\n+    return expr->get_tree () == error_mark_node;\n+  }\n+\n   Bexpression *nil_pointer_expression ()\n   {\n     return this->make_expression (null_pointer_node);"}, {"sha": "da788b563d54a3fc2f4898b6a4ec69a8fef98840", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -52,6 +52,7 @@\n #include \"rust-hir-scan-deadcode.h\"\n #include \"rust-tycheck-dump.h\"\n #include \"rust-ast-resolve-unused.h\"\n+#include \"rust-hir-const-fold.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -325,6 +326,9 @@ Session::init ()\n \n   // setup backend to GCC GIMPLE\n   backend = rust_get_backend ();\n+\n+  // the constant folder uses gcc\n+  ConstFold::Context::init (backend);\n }\n \n /* Initialise default options. Actually called before handle_option, unlike init"}, {"sha": "bcb59ef23c8f340f118b8c47bdb629a8249b31d6", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,235 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_BASE_H\n+#define RUST_HIR_CONST_FOLD_BASE_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-const-fold-ctx.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+// base class to allow derivatives to overload as needed\n+class ConstFoldBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~ConstFoldBase () {}\n+\n+  virtual void visit (HIR::Token &) override {}\n+  virtual void visit (HIR::DelimTokenTree &) override {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n+  virtual void visit (HIR::IdentifierExpr &) override {}\n+  virtual void visit (HIR::Lifetime &) override {}\n+  virtual void visit (HIR::LifetimeParam &) override {}\n+  virtual void visit (HIR::PathInExpression &) override {}\n+  virtual void visit (HIR::TypePathSegment &) override {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &) override {}\n+  virtual void visit (HIR::TypePathSegmentFunction &) override {}\n+  virtual void visit (HIR::TypePath &) override {}\n+  virtual void visit (HIR::QualifiedPathInExpression &) override {}\n+  virtual void visit (HIR::QualifiedPathInType &) override {}\n+\n+  virtual void visit (HIR::LiteralExpr &) override {}\n+  virtual void visit (HIR::AttrInputLiteral &) override {}\n+  virtual void visit (HIR::MetaItemLitExpr &) override {}\n+  virtual void visit (HIR::MetaItemPathLit &) override {}\n+  virtual void visit (HIR::BorrowExpr &) override {}\n+  virtual void visit (HIR::DereferenceExpr &) override {}\n+  virtual void visit (HIR::ErrorPropagationExpr &) override {}\n+  virtual void visit (HIR::NegationExpr &) override {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (HIR::ComparisonExpr &) override {}\n+  virtual void visit (HIR::LazyBooleanExpr &) override {}\n+  virtual void visit (HIR::TypeCastExpr &) override {}\n+  virtual void visit (HIR::AssignmentExpr &) override {}\n+\n+  virtual void visit (HIR::GroupedExpr &) override {}\n+\n+  virtual void visit (HIR::ArrayElemsValues &) override {}\n+  virtual void visit (HIR::ArrayElemsCopied &) override {}\n+  virtual void visit (HIR::ArrayExpr &) override {}\n+  virtual void visit (HIR::ArrayIndexExpr &) override {}\n+  virtual void visit (HIR::TupleExpr &) override {}\n+  virtual void visit (HIR::TupleIndexExpr &) override {}\n+  virtual void visit (HIR::StructExprStruct &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::StructExprStructFields &) override {}\n+  virtual void visit (HIR::StructExprStructBase &) override {}\n+  virtual void visit (HIR::StructExprTuple &) override {}\n+  virtual void visit (HIR::StructExprUnit &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::EnumExprStruct &) override {}\n+  virtual void visit (HIR::EnumExprTuple &) override {}\n+  virtual void visit (HIR::EnumExprFieldless &) override {}\n+  virtual void visit (HIR::CallExpr &) override {}\n+  virtual void visit (HIR::MethodCallExpr &) override {}\n+  virtual void visit (HIR::FieldAccessExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInner &) override {}\n+  virtual void visit (HIR::BlockExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &) override {}\n+  virtual void visit (HIR::ContinueExpr &) override {}\n+  virtual void visit (HIR::BreakExpr &) override {}\n+  virtual void visit (HIR::RangeFromToExpr &) override {}\n+  virtual void visit (HIR::RangeFromExpr &) override {}\n+  virtual void visit (HIR::RangeToExpr &) override {}\n+  virtual void visit (HIR::RangeFullExpr &) override {}\n+  virtual void visit (HIR::RangeFromToInclExpr &) override {}\n+  virtual void visit (HIR::RangeToInclExpr &) override {}\n+  virtual void visit (HIR::ReturnExpr &) override {}\n+  virtual void visit (HIR::UnsafeBlockExpr &) override {}\n+  virtual void visit (HIR::LoopExpr &) override {}\n+  virtual void visit (HIR::WhileLoopExpr &) override {}\n+  virtual void visit (HIR::WhileLetLoopExpr &) override {}\n+  virtual void visit (HIR::ForLoopExpr &) override {}\n+  virtual void visit (HIR::IfExpr &) override {}\n+  virtual void visit (HIR::IfExprConseqElse &) override {}\n+  virtual void visit (HIR::IfExprConseqIf &) override {}\n+  virtual void visit (HIR::IfExprConseqIfLet &) override {}\n+  virtual void visit (HIR::IfLetExpr &) override {}\n+  virtual void visit (HIR::IfLetExprConseqElse &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIf &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (HIR::MatchExpr &) override {}\n+  virtual void visit (HIR::AwaitExpr &) override {}\n+  virtual void visit (HIR::AsyncBlockExpr &) override {}\n+\n+  virtual void visit (HIR::TypeParam &) override {}\n+\n+  virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (HIR::Method &) override {}\n+  virtual void visit (HIR::ModuleBodied &) override {}\n+  virtual void visit (HIR::ModuleNoBody &) override {}\n+  virtual void visit (HIR::ExternCrate &) override {}\n+\n+  virtual void visit (HIR::UseTreeGlob &) override {}\n+  virtual void visit (HIR::UseTreeList &) override {}\n+  virtual void visit (HIR::UseTreeRebind &) override {}\n+  virtual void visit (HIR::UseDeclaration &) override {}\n+  virtual void visit (HIR::Function &) override {}\n+  virtual void visit (HIR::TypeAlias &) override {}\n+  virtual void visit (HIR::StructStruct &) override {}\n+  virtual void visit (HIR::TupleStruct &) override {}\n+  virtual void visit (HIR::EnumItem &) override {}\n+  virtual void visit (HIR::EnumItemTuple &) override {}\n+  virtual void visit (HIR::EnumItemStruct &) override {}\n+  virtual void visit (HIR::EnumItemDiscriminant &) override {}\n+  virtual void visit (HIR::Enum &) override {}\n+  virtual void visit (HIR::Union &) override {}\n+  virtual void visit (HIR::ConstantItem &) override {}\n+  virtual void visit (HIR::StaticItem &) override {}\n+  virtual void visit (HIR::TraitItemFunc &) override {}\n+  virtual void visit (HIR::TraitItemMethod &) override {}\n+  virtual void visit (HIR::TraitItemConst &) override {}\n+  virtual void visit (HIR::TraitItemType &) override {}\n+  virtual void visit (HIR::Trait &) override {}\n+  virtual void visit (HIR::InherentImpl &) override {}\n+  virtual void visit (HIR::TraitImpl &) override {}\n+\n+  virtual void visit (HIR::ExternalStaticItem &) override {}\n+  virtual void visit (HIR::ExternalFunctionItem &) override {}\n+  virtual void visit (HIR::ExternBlock &) override {}\n+\n+  virtual void visit (HIR::MacroMatchFragment &) override {}\n+  virtual void visit (HIR::MacroMatchRepetition &) override {}\n+  virtual void visit (HIR::MacroMatcher &) override {}\n+  virtual void visit (HIR::MacroRulesDefinition &) override {}\n+  virtual void visit (HIR::MacroInvocation &) override {}\n+  virtual void visit (HIR::MetaItemPath &) override {}\n+  virtual void visit (HIR::MetaItemSeq &) override {}\n+  virtual void visit (HIR::MetaWord &) override {}\n+  virtual void visit (HIR::MetaNameValueStr &) override {}\n+  virtual void visit (HIR::MetaListPaths &) override {}\n+  virtual void visit (HIR::MetaListNameValueStr &) override {}\n+\n+  virtual void visit (HIR::LiteralPattern &) override {}\n+  virtual void visit (HIR::IdentifierPattern &) override {}\n+  virtual void visit (HIR::WildcardPattern &) override {}\n+\n+  virtual void visit (HIR::RangePatternBoundLiteral &) override {}\n+  virtual void visit (HIR::RangePatternBoundPath &) override {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &) override {}\n+  virtual void visit (HIR::RangePattern &) override {}\n+  virtual void visit (HIR::ReferencePattern &) override {}\n+\n+  virtual void visit (HIR::StructPatternFieldTuplePat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdent &) override {}\n+  virtual void visit (HIR::StructPattern &) override {}\n+\n+  virtual void visit (HIR::TupleStructItemsNoRange &) override {}\n+  virtual void visit (HIR::TupleStructItemsRange &) override {}\n+  virtual void visit (HIR::TupleStructPattern &) override {}\n+\n+  virtual void visit (HIR::TuplePatternItemsMultiple &) override {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &) override {}\n+  virtual void visit (HIR::TuplePattern &) override {}\n+  virtual void visit (HIR::GroupedPattern &) override {}\n+  virtual void visit (HIR::SlicePattern &) override {}\n+\n+  virtual void visit (HIR::EmptyStmt &) override {}\n+  virtual void visit (HIR::LetStmt &) override {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  virtual void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (HIR::TraitBound &) override {}\n+  virtual void visit (HIR::ImplTraitType &) override {}\n+  virtual void visit (HIR::TraitObjectType &) override {}\n+  virtual void visit (HIR::ParenthesisedType &) override {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n+  virtual void visit (HIR::TupleType &) override {}\n+  virtual void visit (HIR::NeverType &) override {}\n+  virtual void visit (HIR::RawPointerType &) override {}\n+  virtual void visit (HIR::ReferenceType &) override {}\n+  virtual void visit (HIR::ArrayType &) override {}\n+  virtual void visit (HIR::SliceType &) override {}\n+  virtual void visit (HIR::InferredType &) override {}\n+  virtual void visit (HIR::BareFunctionType &) override {}\n+\n+protected:\n+  ConstFoldBase ()\n+    : mappings (Analysis::Mappings::get ()),\n+      resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()), ctx (Context::get ())\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Context *ctx;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_BASE_H"}, {"sha": "7ec296c66c37d5bde8d793c7e875cf8458bbd79b", "filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_CTX_H\n+#define RUST_HIR_CONST_FOLD_CTX_H\n+\n+#include \"rust-backend.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+class Context\n+{\n+public:\n+  ~Context () {}\n+\n+  static void init (::Backend *backend);\n+\n+  static Context *get ();\n+\n+  ::Backend *get_backend () { return backend; }\n+\n+  bool lookup_const (HirId id, Bexpression **expr);\n+\n+  void insert_const (HirId, Bexpression *expr);\n+\n+private:\n+  Context (::Backend *backend);\n+\n+  ::Backend *backend;\n+  std::map<HirId, Bexpression *> ctx;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_CTX_H"}, {"sha": "ecad200e518aadb98ff48d9841e29e7f884295c9", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-const-fold-ctx.h\"\n+#include \"rust-hir-const-fold.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+static Context *context = nullptr;\n+\n+Context::Context (::Backend *backend) : backend (backend) {}\n+\n+void\n+Context::init (::Backend *backend)\n+{\n+  rust_assert (context == nullptr);\n+  context = new Context (backend);\n+}\n+\n+Context *\n+Context::get ()\n+{\n+  rust_assert (context != nullptr);\n+  return context;\n+}\n+\n+bool\n+Context::lookup_const (HirId id, Bexpression **expr)\n+{\n+  auto it = ctx.find (id);\n+  if (it == ctx.end ())\n+    return false;\n+\n+  *expr = it->second;\n+  return true;\n+}\n+\n+void\n+Context::insert_const (HirId id, Bexpression *expr)\n+{\n+  rust_assert (ctx.find (id) == ctx.end ());\n+  ctx[id] = expr;\n+}\n+\n+// rust-hir-const-fold.h\n+\n+void\n+ConstFoldItem::visit (HIR::ConstantItem &item)\n+{\n+  auto folded_expr = ConstFoldExpr::fold (item.get_expr ());\n+  if (folded_expr == nullptr)\n+    return;\n+\n+  folded = folded_expr;\n+}\n+\n+} // namespace ConstFold\n+} // namespace Rust"}, {"sha": "4c030c587c6d6e1a1fbd5ec632de118ae1551c5e", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,366 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_H\n+#define RUST_HIR_CONST_FOLD_H\n+\n+#include \"rust-hir-const-fold-base.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+class ConstFoldType : public TyTy::TyVisitor\n+{\n+public:\n+  static Btype *fold (TyTy::BaseType *type, ::Backend *backend)\n+  {\n+    ConstFoldType folder (backend);\n+    type->accept_vis (folder);\n+    return folder.translated;\n+  };\n+\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::FnType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::TupleType &type) override\n+  {\n+    if (type.num_fields () == 0)\n+      translated = backend->void_type ();\n+    else\n+      gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::BoolType &) override\n+  {\n+    translated = backend->named_type (\"bool\", backend->bool_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::IntType &type) override\n+  {\n+    switch (type.get_int_kind ())\n+      {\n+      case TyTy::IntType::I8:\n+\ttranslated\n+\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I64:\n+\ttranslated\n+\t  = backend->named_type (\"i64\", backend->integer_type (false, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I128:\n+\ttranslated\n+\t  = backend->named_type (\"i128\", backend->integer_type (false, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UintType &type) override\n+  {\n+    switch (type.get_uint_kind ())\n+      {\n+      case TyTy::UintType::U8:\n+\ttranslated = backend->named_type (\"u8\", backend->integer_type (true, 8),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U16:\n+\ttranslated\n+\t  = backend->named_type (\"u16\", backend->integer_type (true, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U32:\n+\ttranslated\n+\t  = backend->named_type (\"u32\", backend->integer_type (true, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U64:\n+\ttranslated\n+\t  = backend->named_type (\"u64\", backend->integer_type (true, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U128:\n+\ttranslated\n+\t  = backend->named_type (\"u128\", backend->integer_type (true, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::FloatType &type) override\n+  {\n+    switch (type.get_float_kind ())\n+      {\n+      case TyTy::FloatType::F32:\n+\ttranslated = backend->named_type (\"f32\", backend->float_type (32),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::FloatType::F64:\n+\ttranslated = backend->named_type (\"f64\", backend->float_type (64),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::USizeType &) override\n+  {\n+    translated = backend->named_type (\n+      \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::ISizeType &) override\n+  {\n+    translated = backend->named_type (\n+      \"isize\", backend->integer_type (false, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::CharType &) override\n+  {\n+    translated = backend->named_type (\"char\", backend->wchar_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::StrType &) override\n+  {\n+    Btype *raw_str = backend->raw_str_type ();\n+    translated\n+      = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+\n+private:\n+  ConstFoldType (::Backend *backend)\n+    : backend (backend), translated (backend->error_type ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Btype *translated;\n+};\n+\n+class ConstFoldItem : public ConstFoldBase\n+{\n+  using ConstFoldBase::visit;\n+\n+public:\n+  static Bexpression *fold (HIR::Item &item)\n+  {\n+    ConstFoldItem folder;\n+    item.accept_vis (folder);\n+    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n+      {\n+\trust_error_at (item.get_locus_slow (), \"non const value\");\n+\treturn nullptr;\n+      }\n+\n+    folder.ctx->insert_const (item.get_mappings ().get_hirid (), folder.folded);\n+    return folder.folded;\n+  };\n+\n+  void visit (HIR::ConstantItem &item) override;\n+\n+private:\n+  ConstFoldItem ()\n+    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  Bexpression *folded;\n+};\n+\n+class ConstFoldExpr : public ConstFoldBase\n+{\n+  using ConstFoldBase::visit;\n+\n+public:\n+  static Bexpression *fold (HIR::Expr *expr)\n+  {\n+    ConstFoldExpr folder;\n+    expr->accept_vis (folder);\n+    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n+      {\n+\trust_error_at (expr->get_locus_slow (), \"non const value\");\n+\treturn nullptr;\n+      }\n+\n+    folder.ctx->insert_const (expr->get_mappings ().get_hirid (),\n+\t\t\t      folder.folded);\n+    return folder.folded;\n+  };\n+\n+  void visit (HIR::IdentifierExpr &expr) override\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tResolver::Definition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // lookup constant\n+    ctx->lookup_const (ref, &folded);\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr) override\n+  {\n+    auto literal_value = expr.get_literal ();\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::INT: {\n+\t  mpz_t ival;\n+\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n+\t      != 0)\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n+\t      return;\n+\t    }\n+\n+\t  TyTy::BaseType *tyty = nullptr;\n+\t  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this literal expr\");\n+\t      return;\n+\t    }\n+\n+\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  folded\n+\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n+\t}\n+\treturn;\n+\n+\t/* handle other literals */\n+\n+      default:\n+\tgcc_unreachable ();\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n+  {\n+    auto lhs = ConstFoldExpr::fold (expr.get_lhs ());\n+    if (lhs == nullptr)\n+      return;\n+\n+    auto rhs = ConstFoldExpr::fold (expr.get_rhs ());\n+    if (rhs == nullptr)\n+      return;\n+\n+    auto op = expr.get_expr_type ();\n+    auto location = expr.get_locus ();\n+\n+    folded\n+      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t       location);\n+  }\n+\n+  void visit (HIR::NegationExpr &expr) override\n+  {\n+    auto negated_expr = ConstFoldExpr::fold (expr.get_expr ());\n+    if (negated_expr == nullptr)\n+      return;\n+\n+    auto op = expr.get_expr_type ();\n+    auto location = expr.get_locus ();\n+\n+    folded\n+      = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n+  }\n+\n+private:\n+  ConstFoldExpr ()\n+    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  Bexpression *folded;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_H"}, {"sha": "5643ad6180ce49fe16112c5c689abd45f20d3c9d", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-hir-method-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-const-fold.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -688,21 +689,23 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::ArrayType *array_type = (TyTy::ArrayType *) infered;\n+    TyTy::ArrayType *array_type = static_cast<TyTy::ArrayType *> (infered);\n     infered = array_type->get_element_type ()->clone ();\n   }\n \n   void visit (HIR::ArrayExpr &expr) override\n   {\n     HIR::ArrayElems *elements = expr.get_internal_elements ();\n-    size_t num_elems = elements->get_num_elements ();\n \n-    // Check the type of array elements\n     elements->accept_vis (*this);\n-    rust_assert (infered_array_elems != nullptr);\n+    if (infered_array_elems == nullptr)\n+      return;\n+    if (folded_array_capacity == nullptr)\n+      return;\n \n     infered\n-      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (), num_elems,\n+      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n+\t\t\t     folded_array_capacity,\n \t\t\t     TyTy::TyVar (infered_array_elems->get_ref ()));\n   }\n \n@@ -724,10 +727,40 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tinfered_array_elems->append_reference (elem->get_ref ());\n       }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    std::string capacity_str = std::to_string (elems.get_num_elements ());\n+    HIR::LiteralExpr implicit_literal_capacity (\n+      mapping, capacity_str, HIR::Literal::LitType::INT,\n+      PrimitiveCoreType::CORETYPE_USIZE, Location ());\n+\n+    // mark the type for this implicit node\n+    context->insert_type (mapping, new TyTy::USizeType (mapping.get_hirid ()));\n+\n+    folded_array_capacity\n+      = ConstFold::ConstFoldExpr::fold (&implicit_literal_capacity);\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n   {\n+    auto capacity_type\n+      = TypeCheckExpr::Resolve (elems.get_num_copies_expr (), false);\n+\n+    TyTy::USizeType *expected_ty = new TyTy::USizeType (\n+      elems.get_num_copies_expr ()->get_mappings ().get_hirid ());\n+    context->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n+\t\t\t  expected_ty);\n+\n+    auto unified = expected_ty->unify (capacity_type);\n+    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    folded_array_capacity\n+      = ConstFold::ConstFoldExpr::fold (elems.get_num_copies_expr ());\n+\n     infered_array_elems\n       = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n   }\n@@ -985,7 +1018,7 @@ class TypeCheckExpr : public TypeCheckBase\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n-      inside_loop (inside_loop)\n+      folded_array_capacity (nullptr), inside_loop (inside_loop)\n   {}\n \n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n@@ -1069,6 +1102,8 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n \t       || (type->get_kind () == TyTy::TypeKind::FLOAT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL))\n@@ -1082,6 +1117,8 @@ class TypeCheckExpr : public TypeCheckBase\n       case ArithmeticOrLogicalOperator::BITWISE_XOR:\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::BOOL)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n@@ -1092,6 +1129,8 @@ class TypeCheckExpr : public TypeCheckBase\n       case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL));\n@@ -1105,6 +1144,7 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n+  Bexpression *folded_array_capacity;\n \n   bool inside_loop;\n }; // namespace Resolver"}, {"sha": "7426a7531a16a18bcdf060e376f08bbd00e455ab", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -48,6 +48,9 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+\n+    // notify the constant folder of this\n+    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "d1d5681fb17a7b481eb5b45aaf9d479cb3c9a994", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -140,6 +140,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+\n+    // notify the constant folder of this\n+    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override\n@@ -214,10 +217,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n     auto self\n       = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n     if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (impl_block.get_locus (), \"failed to resolve impl type\");\n-\treturn;\n-      }\n+      return;\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self,"}, {"sha": "74e3ed3e126eed9cb13bccacab0ba22194ee5071", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 48, "deletions": 100, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -26,53 +26,14 @@\n namespace Rust {\n namespace Resolver {\n \n-class ArrayCapacityConstant : public TypeCheckBase\n-{\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n-public:\n-  static bool fold (HIR::Expr *expr, size_t *folded_result)\n-  {\n-    ArrayCapacityConstant folder;\n-    expr->accept_vis (folder);\n-    *folded_result = folder.result;\n-    return folder.ok;\n-  }\n-\n-  virtual ~ArrayCapacityConstant () {}\n-\n-  void visit (HIR::LiteralExpr &expr) override\n-  {\n-    auto literal_value = expr.get_literal ();\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase HIR::Literal::LitType::INT: {\n-\t  ok = true;\n-\t  std::stringstream ss (literal_value->as_string ());\n-\t  ss >> result;\n-\t}\n-\tbreak;\n-\n-      default:\n-\treturn;\n-      }\n-  }\n-\n-private:\n-  ArrayCapacityConstant () : TypeCheckBase (), ok (false), result (-1) {}\n-\n-  bool ok;\n-  size_t result;\n-}; // namespace Resolver\n-\n class TypeCheckResolveGenericArguments : public TypeCheckBase\n {\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n   static HIR::GenericArgs resolve (HIR::TypePathSegment *segment)\n   {\n-    TypeCheckResolveGenericArguments resolver;\n+    TypeCheckResolveGenericArguments resolver (segment->get_locus ());\n     segment->accept_vis (resolver);\n     return resolver.args;\n   };\n@@ -83,8 +44,8 @@ class TypeCheckResolveGenericArguments : public TypeCheckBase\n   }\n \n private:\n-  TypeCheckResolveGenericArguments ()\n-    : TypeCheckBase (), args (HIR::GenericArgs::create_empty ())\n+  TypeCheckResolveGenericArguments (Location locus)\n+    : TypeCheckBase (), args (HIR::GenericArgs::create_empty (locus))\n   {}\n \n   HIR::GenericArgs args;\n@@ -165,74 +126,61 @@ class TypeCheckType : public TypeCheckBase\n \treturn;\n       }\n \n-    // reverse lookup the hir node from ast node id\n     HirId hir_lookup;\n-    if (context->lookup_type_by_node_id (ref, &hir_lookup))\n+    if (!context->lookup_type_by_node_id (ref, &hir_lookup))\n       {\n-\t// we got an HIR node\n-\tif (context->lookup_type (hir_lookup, &translated))\n-\t  {\n-\t    translated = translated->clone ();\n-\t    auto ref = path.get_mappings ().get_hirid ();\n-\t    translated->set_ref (ref);\n-\n-\t    HIR::TypePathSegment *final_seg = path.get_final_segment ();\n-\t    HIR::GenericArgs args\n-\t      = TypeCheckResolveGenericArguments::resolve (final_seg);\n-\n-\t    bool path_declared_generic_arguments = !args.is_empty ();\n-\t    if (path_declared_generic_arguments)\n-\t      {\n-\t\tif (translated->has_subsititions_defined ())\n-\t\t  {\n-\t\t    translated\n-\t\t      = SubstMapper::Resolve (translated, path.get_locus (),\n-\t\t\t\t\t      &args);\n-\t\t    if (translated->get_kind () != TyTy::TypeKind::ERROR\n-\t\t\t&& mappings != nullptr)\n-\t\t      {\n-\t\t\tcheck_for_unconstrained (args.get_type_args ());\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    rust_error_at (\n-\t\t      path.get_locus (),\n-\t\t      \"TypePath %s declares generic argument's but \"\n-\t\t      \"the type %s does not have any\",\n-\t\t      path.as_string ().c_str (),\n-\t\t      translated->as_string ().c_str ());\n-\t\t  }\n-\t      }\n-\t    else if (translated->has_subsititions_defined ())\n-\t      {\n-\t\ttranslated\n-\t\t  = SubstMapper::InferSubst (translated, path.get_locus ());\n-\t      }\n-\n-\t    return;\n-\t  }\n+\trust_error_at (path.get_locus (), \"failed to lookup HIR node\");\n+\treturn;\n       }\n \n-    rust_error_at (path.get_locus (), \"failed to type-resolve TypePath: %s\",\n-\t\t   path.as_string ().c_str ());\n-  }\n-\n-  void visit (HIR::ArrayType &type) override\n-  {\n-    size_t capacity;\n-    if (!ArrayCapacityConstant::fold (type.get_size_expr (), &capacity))\n+    TyTy::BaseType *lookup = nullptr;\n+    if (!context->lookup_type (hir_lookup, &lookup))\n       {\n-\trust_error_at (type.get_size_expr ()->get_locus_slow (),\n-\t\t       \"non-constant value\");\n+\trust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n \treturn;\n       }\n \n-    TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n-    translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (),\n-\t\t\t\t      capacity, TyTy::TyVar (base->get_ref ()));\n+    TyTy::BaseType *path_type = lookup->clone ();\n+    path_type->set_ref (path.get_mappings ().get_hirid ());\n+\n+    HIR::TypePathSegment *final_seg = path.get_final_segment ();\n+    HIR::GenericArgs args\n+      = TypeCheckResolveGenericArguments::resolve (final_seg);\n+\n+    bool is_big_self = final_seg->is_ident_only ()\n+\t\t       && (final_seg->as_string ().compare (\"Self\") == 0);\n+\n+    if (path_type->needs_generic_substitutions ())\n+      {\n+\tif (is_big_self)\n+\t  {\n+\t    translated = path_type;\n+\t    return;\n+\t  }\n+\n+\ttranslated = SubstMapper::Resolve (path_type, path.get_locus (), &args);\n+\tif (translated->get_kind () != TyTy::TypeKind::ERROR\n+\t    && mappings != nullptr)\n+\t  {\n+\t    check_for_unconstrained (args.get_type_args ());\n+\t  }\n+      }\n+    else if (!args.is_empty ())\n+      {\n+\trust_error_at (path.get_locus (),\n+\t\t       \"TypePath %s declares generic argument's but \"\n+\t\t       \"the type %s does not have any\",\n+\t\t       path.as_string ().c_str (),\n+\t\t       translated->as_string ().c_str ());\n+      }\n+    else\n+      {\n+\ttranslated = path_type;\n+      }\n   }\n \n+  void visit (HIR::ArrayType &type) override;\n+\n   void visit (HIR::ReferenceType &type) override\n   {\n     TyTy::BaseType *base"}, {"sha": "3484eeebdee53e5e1c3d69c6d117f2ad657e6d6f", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-inherent-impl-overlap.h\"\n+#include \"rust-hir-const-fold.h\"\n \n extern bool\n saw_errors (void);\n@@ -379,5 +380,31 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n     }\n }\n \n+// rust-hir-type-check-type.h\n+\n+void\n+TypeCheckType::visit (HIR::ArrayType &type)\n+{\n+  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr (), false);\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::USizeType *expected_ty\n+    = new TyTy::USizeType (type.get_size_expr ()->get_mappings ().get_hirid ());\n+  context->insert_type (type.get_size_expr ()->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto capacity = ConstFold::ConstFoldExpr::fold (type.get_size_expr ());\n+  if (capacity == nullptr)\n+    return;\n+\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n+  translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (), capacity,\n+\t\t\t\t    TyTy::TyVar (base->get_ref ()));\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "37a82c41608a278ddec8a8db5a2772d0606dd771", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -57,6 +57,9 @@ class SubstMapper : public TyTy::TyVisitor\n       {\n \tTyTy::SubstitutionArgumentMappings mappings\n \t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n \tconcrete = type.handle_substitions (mappings);\n       }\n \n@@ -77,6 +80,9 @@ class SubstMapper : public TyTy::TyVisitor\n       {\n \tTyTy::SubstitutionArgumentMappings mappings\n \t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n \tconcrete = type.handle_substitions (mappings);\n       }\n "}, {"sha": "06bb33fc6de52c09fdb0b3ec5177db40a0ba8e00", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -25,6 +25,9 @@\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n \n+extern ::Backend *\n+rust_get_backend ();\n+\n namespace Rust {\n namespace TyTy {\n \n@@ -714,11 +717,12 @@ class ArrayRules : public BaseRules\n \treturn;\n       }\n \n+    auto backend = rust_get_backend ();\n+\n     // need to check the base types and capacity\n-    if (type.get_capacity () != base->get_capacity ())\n+    if (!backend->const_values_equal (type.get_capacity (),\n+\t\t\t\t      base->get_capacity ()))\n       {\n-\tLocation locus = mappings->lookup_location (type.get_ref ());\n-\trust_error_at (locus, \"mismatch in array capacity\");\n \tBaseRules::visit (type);\n \treturn;\n       }"}, {"sha": "baa997b000bda418c4c8201b3c1bda316b107cdd", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -26,6 +26,9 @@\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n+extern ::Backend *\n+rust_get_backend ();\n+\n namespace Rust {\n namespace TyTy {\n \n@@ -801,8 +804,14 @@ ArrayType::accept_vis (TyVisitor &vis)\n std::string\n ArrayType::as_string () const\n {\n-  return \"[\" + get_element_type ()->as_string () + \":\"\n-\t + std::to_string (capacity) + \"]\";\n+  return \"[\" + get_element_type ()->as_string () + \":\" + capacity_string ()\n+\t + \"]\";\n+}\n+\n+std::string\n+ArrayType::capacity_string () const\n+{\n+  return rust_get_backend ()->const_size_val_to_string (get_capacity ());\n }\n \n BaseType *"}, {"sha": "bc4c9c49aa64c6fb9aa2f2cb8c4d6a50b2f35108", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_TYTY\n #define RUST_TYTY\n \n+#include \"rust-backend.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-full.h\"\n \n@@ -871,13 +872,13 @@ class FnPtr : public BaseType\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, size_t capacity, TyVar base,\n+  ArrayType (HirId ref, Bexpression *capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, size_t capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, Bexpression *capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n@@ -894,7 +895,8 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  size_t get_capacity () const { return capacity; }\n+  Bexpression *get_capacity () const { return capacity; }\n+  std::string capacity_string () const;\n \n   BaseType *get_element_type () const;\n \n@@ -906,7 +908,7 @@ class ArrayType : public BaseType\n   }\n \n private:\n-  size_t capacity;\n+  Bexpression *capacity;\n   TyVar element_type;\n };\n "}, {"sha": "528380b3e7da01ddee76023855274b24fa4e020f", "filename": "gcc/testsuite/lib/rust.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Flib%2Frust.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Flib%2Frust.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Frust.exp?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -181,7 +181,7 @@ proc rust_target_compile { source dest type options } {\n     ## FIXME: until the compiler is made less verbose, we need to prune its output almost completely.\n     # Only keep lines containing certain diagnostics so that we can check these.\n     global additional_prunes\n-    lappend additional_prunes \"^((?!(error: |warning: )).)*$\"\n+    lappend additional_prunes \"^((?!(error: |warning: |\\[Ii\\]nternal compiler error: )).)*$\"\n \n     return [target_compile $source $dest $type $options]\n }"}, {"sha": "372d969aa07746a3069da5ceabd5571a2581fa3b", "filename": "gcc/testsuite/rust.test/compile/arrays3.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,6 @@\n+const TEST: usize = 6;\n+\n+fn main() {\n+    let a: [_; 12] = [123; TEST * 2];\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "ac317fedf44fef5c635366bb13f85cbc246fc2a4", "filename": "gcc/testsuite/rust.test/compile/arrays4.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,6 @@\n+const TEST: usize = 4;\n+\n+fn main() {\n+    let a: [_; TEST + 1 + 2] = [123; 7];\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "e35508050d5f8a807b03db4f25006333befc467a", "filename": "gcc/testsuite/rust.test/xfail_compile/arrays2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let array: [i32; 5] = [1, 2, 3]; // { dg-error \"mismatch in array capacity\" }\n-                                     // { dg-error \"expected ..i32:5.. got ..i32:3..\" \"\" { target { *-*-* } } .-1 }\n+    let array: [i32; 5] = [1, 2, 3];\n+    // { dg-error \"expected ..i32:5.. got ..i32:3..\" \"\" { target { *-*-* } } .-1 }\n }"}, {"sha": "b92c48f56a7e6ad3d1c26ee9d8729aa56401c195", "filename": "gcc/testsuite/rust.test/xfail_compile/expected_type_args2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args2.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,6 @@\n+struct Foo<A>(A);\n+\n+fn main() {\n+    let a: Foo = Foo::<i32>(123);\n+    // { dg-error \"Invalid number of generic arguments to generic type\" \"\" { target { *-*-* } } .-1 }\n+}"}, {"sha": "4c164ffc9dcb507d456c8e255169ab1747d8b93b", "filename": "gcc/testsuite/rust.test/xfail_compile/expected_type_args3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fexpected_type_args3.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,8 @@\n+struct Foo<A>(A);\n+\n+impl Foo {\n+    // { dg-error \"Invalid number of generic arguments to generic type\" \"\" { target { *-*-* } } .-1 }\n+    fn test() -> i32 {\n+        123\n+    }\n+}"}, {"sha": "70bad1a4c1c8c20befb7589e743c01c91a8244ac", "filename": "gcc/testsuite/rust.test/xfail_compile/generics8.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics8.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,15 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<i32, T> {\n+    fn test(a: T) -> T { // { dg-error \"duplicate definitions with name test\" }\n+        a\n+    }\n+}\n+\n+impl Foo<i32, f32> {\n+    fn test() -> f32 { // { dg-error \"duplicate definitions with name test\" }\n+        123f32\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d0cb87d84ed658f8178924ffa2bda5d4684d3841", "filename": "gcc/testsuite/rust.test/xfail_compile/unsafe.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Funsafe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28895c1265e19a3e854040610d8478cfb8768d0a/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Funsafe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Funsafe.rs?ref=28895c1265e19a3e854040610d8478cfb8768d0a", "patch": "@@ -0,0 +1,5 @@\n+fn main() { // { dg-ice \"#382\" }\n+    unsafe {\n+    }\n+    ()\n+}"}, {"sha": "94a9ed024d3859793618152ea559a168bbcbb5e2", "filename": "libgrust/COPYING", "status": "removed", "additions": 0, "deletions": 674, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FCOPYING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FCOPYING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2FCOPYING?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,674 +0,0 @@\n-                    GNU GENERAL PUBLIC LICENSE\n-                       Version 3, 29 June 2007\n-\n- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n- Everyone is permitted to copy and distribute verbatim copies\n- of this license document, but changing it is not allowed.\n-\n-                            Preamble\n-\n-  The GNU General Public License is a free, copyleft license for\n-software and other kinds of works.\n-\n-  The licenses for most software and other practical works are designed\n-to take away your freedom to share and change the works.  By contrast,\n-the GNU General Public License is intended to guarantee your freedom to\n-share and change all versions of a program--to make sure it remains free\n-software for all its users.  We, the Free Software Foundation, use the\n-GNU General Public License for most of our software; it applies also to\n-any other work released this way by its authors.  You can apply it to\n-your programs, too.\n-\n-  When we speak of free software, we are referring to freedom, not\n-price.  Our General Public Licenses are designed to make sure that you\n-have the freedom to distribute copies of free software (and charge for\n-them if you wish), that you receive source code or can get it if you\n-want it, that you can change the software or use pieces of it in new\n-free programs, and that you know you can do these things.\n-\n-  To protect your rights, we need to prevent others from denying you\n-these rights or asking you to surrender the rights.  Therefore, you have\n-certain responsibilities if you distribute copies of the software, or if\n-you modify it: responsibilities to respect the freedom of others.\n-\n-  For example, if you distribute copies of such a program, whether\n-gratis or for a fee, you must pass on to the recipients the same\n-freedoms that you received.  You must make sure that they, too, receive\n-or can get the source code.  And you must show them these terms so they\n-know their rights.\n-\n-  Developers that use the GNU GPL protect your rights with two steps:\n-(1) assert copyright on the software, and (2) offer you this License\n-giving you legal permission to copy, distribute and/or modify it.\n-\n-  For the developers' and authors' protection, the GPL clearly explains\n-that there is no warranty for this free software.  For both users' and\n-authors' sake, the GPL requires that modified versions be marked as\n-changed, so that their problems will not be attributed erroneously to\n-authors of previous versions.\n-\n-  Some devices are designed to deny users access to install or run\n-modified versions of the software inside them, although the manufacturer\n-can do so.  This is fundamentally incompatible with the aim of\n-protecting users' freedom to change the software.  The systematic\n-pattern of such abuse occurs in the area of products for individuals to\n-use, which is precisely where it is most unacceptable.  Therefore, we\n-have designed this version of the GPL to prohibit the practice for those\n-products.  If such problems arise substantially in other domains, we\n-stand ready to extend this provision to those domains in future versions\n-of the GPL, as needed to protect the freedom of users.\n-\n-  Finally, every program is threatened constantly by software patents.\n-States should not allow patents to restrict development and use of\n-software on general-purpose computers, but in those that do, we wish to\n-avoid the special danger that patents applied to a free program could\n-make it effectively proprietary.  To prevent this, the GPL assures that\n-patents cannot be used to render the program non-free.\n-\n-  The precise terms and conditions for copying, distribution and\n-modification follow.\n-\n-                       TERMS AND CONDITIONS\n-\n-  0. Definitions.\n-\n-  \"This License\" refers to version 3 of the GNU General Public License.\n-\n-  \"Copyright\" also means copyright-like laws that apply to other kinds of\n-works, such as semiconductor masks.\n-\n-  \"The Program\" refers to any copyrightable work licensed under this\n-License.  Each licensee is addressed as \"you\".  \"Licensees\" and\n-\"recipients\" may be individuals or organizations.\n-\n-  To \"modify\" a work means to copy from or adapt all or part of the work\n-in a fashion requiring copyright permission, other than the making of an\n-exact copy.  The resulting work is called a \"modified version\" of the\n-earlier work or a work \"based on\" the earlier work.\n-\n-  A \"covered work\" means either the unmodified Program or a work based\n-on the Program.\n-\n-  To \"propagate\" a work means to do anything with it that, without\n-permission, would make you directly or secondarily liable for\n-infringement under applicable copyright law, except executing it on a\n-computer or modifying a private copy.  Propagation includes copying,\n-distribution (with or without modification), making available to the\n-public, and in some countries other activities as well.\n-\n-  To \"convey\" a work means any kind of propagation that enables other\n-parties to make or receive copies.  Mere interaction with a user through\n-a computer network, with no transfer of a copy, is not conveying.\n-\n-  An interactive user interface displays \"Appropriate Legal Notices\"\n-to the extent that it includes a convenient and prominently visible\n-feature that (1) displays an appropriate copyright notice, and (2)\n-tells the user that there is no warranty for the work (except to the\n-extent that warranties are provided), that licensees may convey the\n-work under this License, and how to view a copy of this License.  If\n-the interface presents a list of user commands or options, such as a\n-menu, a prominent item in the list meets this criterion.\n-\n-  1. Source Code.\n-\n-  The \"source code\" for a work means the preferred form of the work\n-for making modifications to it.  \"Object code\" means any non-source\n-form of a work.\n-\n-  A \"Standard Interface\" means an interface that either is an official\n-standard defined by a recognized standards body, or, in the case of\n-interfaces specified for a particular programming language, one that\n-is widely used among developers working in that language.\n-\n-  The \"System Libraries\" of an executable work include anything, other\n-than the work as a whole, that (a) is included in the normal form of\n-packaging a Major Component, but which is not part of that Major\n-Component, and (b) serves only to enable use of the work with that\n-Major Component, or to implement a Standard Interface for which an\n-implementation is available to the public in source code form.  A\n-\"Major Component\", in this context, means a major essential component\n-(kernel, window system, and so on) of the specific operating system\n-(if any) on which the executable work runs, or a compiler used to\n-produce the work, or an object code interpreter used to run it.\n-\n-  The \"Corresponding Source\" for a work in object code form means all\n-the source code needed to generate, install, and (for an executable\n-work) run the object code and to modify the work, including scripts to\n-control those activities.  However, it does not include the work's\n-System Libraries, or general-purpose tools or generally available free\n-programs which are used unmodified in performing those activities but\n-which are not part of the work.  For example, Corresponding Source\n-includes interface definition files associated with source files for\n-the work, and the source code for shared libraries and dynamically\n-linked subprograms that the work is specifically designed to require,\n-such as by intimate data communication or control flow between those\n-subprograms and other parts of the work.\n-\n-  The Corresponding Source need not include anything that users\n-can regenerate automatically from other parts of the Corresponding\n-Source.\n-\n-  The Corresponding Source for a work in source code form is that\n-same work.\n-\n-  2. Basic Permissions.\n-\n-  All rights granted under this License are granted for the term of\n-copyright on the Program, and are irrevocable provided the stated\n-conditions are met.  This License explicitly affirms your unlimited\n-permission to run the unmodified Program.  The output from running a\n-covered work is covered by this License only if the output, given its\n-content, constitutes a covered work.  This License acknowledges your\n-rights of fair use or other equivalent, as provided by copyright law.\n-\n-  You may make, run and propagate covered works that you do not\n-convey, without conditions so long as your license otherwise remains\n-in force.  You may convey covered works to others for the sole purpose\n-of having them make modifications exclusively for you, or provide you\n-with facilities for running those works, provided that you comply with\n-the terms of this License in conveying all material for which you do\n-not control copyright.  Those thus making or running the covered works\n-for you must do so exclusively on your behalf, under your direction\n-and control, on terms that prohibit them from making any copies of\n-your copyrighted material outside their relationship with you.\n-\n-  Conveying under any other circumstances is permitted solely under\n-the conditions stated below.  Sublicensing is not allowed; section 10\n-makes it unnecessary.\n-\n-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n-\n-  No covered work shall be deemed part of an effective technological\n-measure under any applicable law fulfilling obligations under article\n-11 of the WIPO copyright treaty adopted on 20 December 1996, or\n-similar laws prohibiting or restricting circumvention of such\n-measures.\n-\n-  When you convey a covered work, you waive any legal power to forbid\n-circumvention of technological measures to the extent such circumvention\n-is effected by exercising rights under this License with respect to\n-the covered work, and you disclaim any intention to limit operation or\n-modification of the work as a means of enforcing, against the work's\n-users, your or third parties' legal rights to forbid circumvention of\n-technological measures.\n-\n-  4. Conveying Verbatim Copies.\n-\n-  You may convey verbatim copies of the Program's source code as you\n-receive it, in any medium, provided that you conspicuously and\n-appropriately publish on each copy an appropriate copyright notice;\n-keep intact all notices stating that this License and any\n-non-permissive terms added in accord with section 7 apply to the code;\n-keep intact all notices of the absence of any warranty; and give all\n-recipients a copy of this License along with the Program.\n-\n-  You may charge any price or no price for each copy that you convey,\n-and you may offer support or warranty protection for a fee.\n-\n-  5. Conveying Modified Source Versions.\n-\n-  You may convey a work based on the Program, or the modifications to\n-produce it from the Program, in the form of source code under the\n-terms of section 4, provided that you also meet all of these conditions:\n-\n-    a) The work must carry prominent notices stating that you modified\n-    it, and giving a relevant date.\n-\n-    b) The work must carry prominent notices stating that it is\n-    released under this License and any conditions added under section\n-    7.  This requirement modifies the requirement in section 4 to\n-    \"keep intact all notices\".\n-\n-    c) You must license the entire work, as a whole, under this\n-    License to anyone who comes into possession of a copy.  This\n-    License will therefore apply, along with any applicable section 7\n-    additional terms, to the whole of the work, and all its parts,\n-    regardless of how they are packaged.  This License gives no\n-    permission to license the work in any other way, but it does not\n-    invalidate such permission if you have separately received it.\n-\n-    d) If the work has interactive user interfaces, each must display\n-    Appropriate Legal Notices; however, if the Program has interactive\n-    interfaces that do not display Appropriate Legal Notices, your\n-    work need not make them do so.\n-\n-  A compilation of a covered work with other separate and independent\n-works, which are not by their nature extensions of the covered work,\n-and which are not combined with it such as to form a larger program,\n-in or on a volume of a storage or distribution medium, is called an\n-\"aggregate\" if the compilation and its resulting copyright are not\n-used to limit the access or legal rights of the compilation's users\n-beyond what the individual works permit.  Inclusion of a covered work\n-in an aggregate does not cause this License to apply to the other\n-parts of the aggregate.\n-\n-  6. Conveying Non-Source Forms.\n-\n-  You may convey a covered work in object code form under the terms\n-of sections 4 and 5, provided that you also convey the\n-machine-readable Corresponding Source under the terms of this License,\n-in one of these ways:\n-\n-    a) Convey the object code in, or embodied in, a physical product\n-    (including a physical distribution medium), accompanied by the\n-    Corresponding Source fixed on a durable physical medium\n-    customarily used for software interchange.\n-\n-    b) Convey the object code in, or embodied in, a physical product\n-    (including a physical distribution medium), accompanied by a\n-    written offer, valid for at least three years and valid for as\n-    long as you offer spare parts or customer support for that product\n-    model, to give anyone who possesses the object code either (1) a\n-    copy of the Corresponding Source for all the software in the\n-    product that is covered by this License, on a durable physical\n-    medium customarily used for software interchange, for a price no\n-    more than your reasonable cost of physically performing this\n-    conveying of source, or (2) access to copy the\n-    Corresponding Source from a network server at no charge.\n-\n-    c) Convey individual copies of the object code with a copy of the\n-    written offer to provide the Corresponding Source.  This\n-    alternative is allowed only occasionally and noncommercially, and\n-    only if you received the object code with such an offer, in accord\n-    with subsection 6b.\n-\n-    d) Convey the object code by offering access from a designated\n-    place (gratis or for a charge), and offer equivalent access to the\n-    Corresponding Source in the same way through the same place at no\n-    further charge.  You need not require recipients to copy the\n-    Corresponding Source along with the object code.  If the place to\n-    copy the object code is a network server, the Corresponding Source\n-    may be on a different server (operated by you or a third party)\n-    that supports equivalent copying facilities, provided you maintain\n-    clear directions next to the object code saying where to find the\n-    Corresponding Source.  Regardless of what server hosts the\n-    Corresponding Source, you remain obligated to ensure that it is\n-    available for as long as needed to satisfy these requirements.\n-\n-    e) Convey the object code using peer-to-peer transmission, provided\n-    you inform other peers where the object code and Corresponding\n-    Source of the work are being offered to the general public at no\n-    charge under subsection 6d.\n-\n-  A separable portion of the object code, whose source code is excluded\n-from the Corresponding Source as a System Library, need not be\n-included in conveying the object code work.\n-\n-  A \"User Product\" is either (1) a \"consumer product\", which means any\n-tangible personal property which is normally used for personal, family,\n-or household purposes, or (2) anything designed or sold for incorporation\n-into a dwelling.  In determining whether a product is a consumer product,\n-doubtful cases shall be resolved in favor of coverage.  For a particular\n-product received by a particular user, \"normally used\" refers to a\n-typical or common use of that class of product, regardless of the status\n-of the particular user or of the way in which the particular user\n-actually uses, or expects or is expected to use, the product.  A product\n-is a consumer product regardless of whether the product has substantial\n-commercial, industrial or non-consumer uses, unless such uses represent\n-the only significant mode of use of the product.\n-\n-  \"Installation Information\" for a User Product means any methods,\n-procedures, authorization keys, or other information required to install\n-and execute modified versions of a covered work in that User Product from\n-a modified version of its Corresponding Source.  The information must\n-suffice to ensure that the continued functioning of the modified object\n-code is in no case prevented or interfered with solely because\n-modification has been made.\n-\n-  If you convey an object code work under this section in, or with, or\n-specifically for use in, a User Product, and the conveying occurs as\n-part of a transaction in which the right of possession and use of the\n-User Product is transferred to the recipient in perpetuity or for a\n-fixed term (regardless of how the transaction is characterized), the\n-Corresponding Source conveyed under this section must be accompanied\n-by the Installation Information.  But this requirement does not apply\n-if neither you nor any third party retains the ability to install\n-modified object code on the User Product (for example, the work has\n-been installed in ROM).\n-\n-  The requirement to provide Installation Information does not include a\n-requirement to continue to provide support service, warranty, or updates\n-for a work that has been modified or installed by the recipient, or for\n-the User Product in which it has been modified or installed.  Access to a\n-network may be denied when the modification itself materially and\n-adversely affects the operation of the network or violates the rules and\n-protocols for communication across the network.\n-\n-  Corresponding Source conveyed, and Installation Information provided,\n-in accord with this section must be in a format that is publicly\n-documented (and with an implementation available to the public in\n-source code form), and must require no special password or key for\n-unpacking, reading or copying.\n-\n-  7. Additional Terms.\n-\n-  \"Additional permissions\" are terms that supplement the terms of this\n-License by making exceptions from one or more of its conditions.\n-Additional permissions that are applicable to the entire Program shall\n-be treated as though they were included in this License, to the extent\n-that they are valid under applicable law.  If additional permissions\n-apply only to part of the Program, that part may be used separately\n-under those permissions, but the entire Program remains governed by\n-this License without regard to the additional permissions.\n-\n-  When you convey a copy of a covered work, you may at your option\n-remove any additional permissions from that copy, or from any part of\n-it.  (Additional permissions may be written to require their own\n-removal in certain cases when you modify the work.)  You may place\n-additional permissions on material, added by you to a covered work,\n-for which you have or can give appropriate copyright permission.\n-\n-  Notwithstanding any other provision of this License, for material you\n-add to a covered work, you may (if authorized by the copyright holders of\n-that material) supplement the terms of this License with terms:\n-\n-    a) Disclaiming warranty or limiting liability differently from the\n-    terms of sections 15 and 16 of this License; or\n-\n-    b) Requiring preservation of specified reasonable legal notices or\n-    author attributions in that material or in the Appropriate Legal\n-    Notices displayed by works containing it; or\n-\n-    c) Prohibiting misrepresentation of the origin of that material, or\n-    requiring that modified versions of such material be marked in\n-    reasonable ways as different from the original version; or\n-\n-    d) Limiting the use for publicity purposes of names of licensors or\n-    authors of the material; or\n-\n-    e) Declining to grant rights under trademark law for use of some\n-    trade names, trademarks, or service marks; or\n-\n-    f) Requiring indemnification of licensors and authors of that\n-    material by anyone who conveys the material (or modified versions of\n-    it) with contractual assumptions of liability to the recipient, for\n-    any liability that these contractual assumptions directly impose on\n-    those licensors and authors.\n-\n-  All other non-permissive additional terms are considered \"further\n-restrictions\" within the meaning of section 10.  If the Program as you\n-received it, or any part of it, contains a notice stating that it is\n-governed by this License along with a term that is a further\n-restriction, you may remove that term.  If a license document contains\n-a further restriction but permits relicensing or conveying under this\n-License, you may add to a covered work material governed by the terms\n-of that license document, provided that the further restriction does\n-not survive such relicensing or conveying.\n-\n-  If you add terms to a covered work in accord with this section, you\n-must place, in the relevant source files, a statement of the\n-additional terms that apply to those files, or a notice indicating\n-where to find the applicable terms.\n-\n-  Additional terms, permissive or non-permissive, may be stated in the\n-form of a separately written license, or stated as exceptions;\n-the above requirements apply either way.\n-\n-  8. Termination.\n-\n-  You may not propagate or modify a covered work except as expressly\n-provided under this License.  Any attempt otherwise to propagate or\n-modify it is void, and will automatically terminate your rights under\n-this License (including any patent licenses granted under the third\n-paragraph of section 11).\n-\n-  However, if you cease all violation of this License, then your\n-license from a particular copyright holder is reinstated (a)\n-provisionally, unless and until the copyright holder explicitly and\n-finally terminates your license, and (b) permanently, if the copyright\n-holder fails to notify you of the violation by some reasonable means\n-prior to 60 days after the cessation.\n-\n-  Moreover, your license from a particular copyright holder is\n-reinstated permanently if the copyright holder notifies you of the\n-violation by some reasonable means, this is the first time you have\n-received notice of violation of this License (for any work) from that\n-copyright holder, and you cure the violation prior to 30 days after\n-your receipt of the notice.\n-\n-  Termination of your rights under this section does not terminate the\n-licenses of parties who have received copies or rights from you under\n-this License.  If your rights have been terminated and not permanently\n-reinstated, you do not qualify to receive new licenses for the same\n-material under section 10.\n-\n-  9. Acceptance Not Required for Having Copies.\n-\n-  You are not required to accept this License in order to receive or\n-run a copy of the Program.  Ancillary propagation of a covered work\n-occurring solely as a consequence of using peer-to-peer transmission\n-to receive a copy likewise does not require acceptance.  However,\n-nothing other than this License grants you permission to propagate or\n-modify any covered work.  These actions infringe copyright if you do\n-not accept this License.  Therefore, by modifying or propagating a\n-covered work, you indicate your acceptance of this License to do so.\n-\n-  10. Automatic Licensing of Downstream Recipients.\n-\n-  Each time you convey a covered work, the recipient automatically\n-receives a license from the original licensors, to run, modify and\n-propagate that work, subject to this License.  You are not responsible\n-for enforcing compliance by third parties with this License.\n-\n-  An \"entity transaction\" is a transaction transferring control of an\n-organization, or substantially all assets of one, or subdividing an\n-organization, or merging organizations.  If propagation of a covered\n-work results from an entity transaction, each party to that\n-transaction who receives a copy of the work also receives whatever\n-licenses to the work the party's predecessor in interest had or could\n-give under the previous paragraph, plus a right to possession of the\n-Corresponding Source of the work from the predecessor in interest, if\n-the predecessor has it or can get it with reasonable efforts.\n-\n-  You may not impose any further restrictions on the exercise of the\n-rights granted or affirmed under this License.  For example, you may\n-not impose a license fee, royalty, or other charge for exercise of\n-rights granted under this License, and you may not initiate litigation\n-(including a cross-claim or counterclaim in a lawsuit) alleging that\n-any patent claim is infringed by making, using, selling, offering for\n-sale, or importing the Program or any portion of it.\n-\n-  11. Patents.\n-\n-  A \"contributor\" is a copyright holder who authorizes use under this\n-License of the Program or a work on which the Program is based.  The\n-work thus licensed is called the contributor's \"contributor version\".\n-\n-  A contributor's \"essential patent claims\" are all patent claims\n-owned or controlled by the contributor, whether already acquired or\n-hereafter acquired, that would be infringed by some manner, permitted\n-by this License, of making, using, or selling its contributor version,\n-but do not include claims that would be infringed only as a\n-consequence of further modification of the contributor version.  For\n-purposes of this definition, \"control\" includes the right to grant\n-patent sublicenses in a manner consistent with the requirements of\n-this License.\n-\n-  Each contributor grants you a non-exclusive, worldwide, royalty-free\n-patent license under the contributor's essential patent claims, to\n-make, use, sell, offer for sale, import and otherwise run, modify and\n-propagate the contents of its contributor version.\n-\n-  In the following three paragraphs, a \"patent license\" is any express\n-agreement or commitment, however denominated, not to enforce a patent\n-(such as an express permission to practice a patent or covenant not to\n-sue for patent infringement).  To \"grant\" such a patent license to a\n-party means to make such an agreement or commitment not to enforce a\n-patent against the party.\n-\n-  If you convey a covered work, knowingly relying on a patent license,\n-and the Corresponding Source of the work is not available for anyone\n-to copy, free of charge and under the terms of this License, through a\n-publicly available network server or other readily accessible means,\n-then you must either (1) cause the Corresponding Source to be so\n-available, or (2) arrange to deprive yourself of the benefit of the\n-patent license for this particular work, or (3) arrange, in a manner\n-consistent with the requirements of this License, to extend the patent\n-license to downstream recipients.  \"Knowingly relying\" means you have\n-actual knowledge that, but for the patent license, your conveying the\n-covered work in a country, or your recipient's use of the covered work\n-in a country, would infringe one or more identifiable patents in that\n-country that you have reason to believe are valid.\n-\n-  If, pursuant to or in connection with a single transaction or\n-arrangement, you convey, or propagate by procuring conveyance of, a\n-covered work, and grant a patent license to some of the parties\n-receiving the covered work authorizing them to use, propagate, modify\n-or convey a specific copy of the covered work, then the patent license\n-you grant is automatically extended to all recipients of the covered\n-work and works based on it.\n-\n-  A patent license is \"discriminatory\" if it does not include within\n-the scope of its coverage, prohibits the exercise of, or is\n-conditioned on the non-exercise of one or more of the rights that are\n-specifically granted under this License.  You may not convey a covered\n-work if you are a party to an arrangement with a third party that is\n-in the business of distributing software, under which you make payment\n-to the third party based on the extent of your activity of conveying\n-the work, and under which the third party grants, to any of the\n-parties who would receive the covered work from you, a discriminatory\n-patent license (a) in connection with copies of the covered work\n-conveyed by you (or copies made from those copies), or (b) primarily\n-for and in connection with specific products or compilations that\n-contain the covered work, unless you entered into that arrangement,\n-or that patent license was granted, prior to 28 March 2007.\n-\n-  Nothing in this License shall be construed as excluding or limiting\n-any implied license or other defenses to infringement that may\n-otherwise be available to you under applicable patent law.\n-\n-  12. No Surrender of Others' Freedom.\n-\n-  If conditions are imposed on you (whether by court order, agreement or\n-otherwise) that contradict the conditions of this License, they do not\n-excuse you from the conditions of this License.  If you cannot convey a\n-covered work so as to satisfy simultaneously your obligations under this\n-License and any other pertinent obligations, then as a consequence you may\n-not convey it at all.  For example, if you agree to terms that obligate you\n-to collect a royalty for further conveying from those to whom you convey\n-the Program, the only way you could satisfy both those terms and this\n-License would be to refrain entirely from conveying the Program.\n-\n-  13. Use with the GNU Affero General Public License.\n-\n-  Notwithstanding any other provision of this License, you have\n-permission to link or combine any covered work with a work licensed\n-under version 3 of the GNU Affero General Public License into a single\n-combined work, and to convey the resulting work.  The terms of this\n-License will continue to apply to the part which is the covered work,\n-but the special requirements of the GNU Affero General Public License,\n-section 13, concerning interaction through a network will apply to the\n-combination as such.\n-\n-  14. Revised Versions of this License.\n-\n-  The Free Software Foundation may publish revised and/or new versions of\n-the GNU General Public License from time to time.  Such new versions will\n-be similar in spirit to the present version, but may differ in detail to\n-address new problems or concerns.\n-\n-  Each version is given a distinguishing version number.  If the\n-Program specifies that a certain numbered version of the GNU General\n-Public License \"or any later version\" applies to it, you have the\n-option of following the terms and conditions either of that numbered\n-version or of any later version published by the Free Software\n-Foundation.  If the Program does not specify a version number of the\n-GNU General Public License, you may choose any version ever published\n-by the Free Software Foundation.\n-\n-  If the Program specifies that a proxy can decide which future\n-versions of the GNU General Public License can be used, that proxy's\n-public statement of acceptance of a version permanently authorizes you\n-to choose that version for the Program.\n-\n-  Later license versions may give you additional or different\n-permissions.  However, no additional obligations are imposed on any\n-author or copyright holder as a result of your choosing to follow a\n-later version.\n-\n-  15. Disclaimer of Warranty.\n-\n-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\n-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\n-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\n-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\n-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\n-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\n-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n-\n-  16. Limitation of Liability.\n-\n-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\n-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\n-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\n-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\n-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\n-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\n-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\n-SUCH DAMAGES.\n-\n-  17. Interpretation of Sections 15 and 16.\n-\n-  If the disclaimer of warranty and limitation of liability provided\n-above cannot be given local legal effect according to their terms,\n-reviewing courts shall apply local law that most closely approximates\n-an absolute waiver of all civil liability in connection with the\n-Program, unless a warranty or assumption of liability accompanies a\n-copy of the Program in return for a fee.\n-\n-                     END OF TERMS AND CONDITIONS\n-\n-            How to Apply These Terms to Your New Programs\n-\n-  If you develop a new program, and you want it to be of the greatest\n-possible use to the public, the best way to achieve this is to make it\n-free software which everyone can redistribute and change under these terms.\n-\n-  To do so, attach the following notices to the program.  It is safest\n-to attach them to the start of each source file to most effectively\n-state the exclusion of warranty; and each file should have at least\n-the \"copyright\" line and a pointer to where the full notice is found.\n-\n-    <one line to give the program's name and a brief idea of what it does.>\n-    Copyright (C) <year>  <name of author>\n-\n-    This program is free software: you can redistribute it and/or modify\n-    it under the terms of the GNU General Public License as published by\n-    the Free Software Foundation, either version 3 of the License, or\n-    (at your option) any later version.\n-\n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n-\n-    You should have received a copy of the GNU General Public License\n-    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-Also add information on how to contact you by electronic and paper mail.\n-\n-  If the program does terminal interaction, make it output a short\n-notice like this when it starts in an interactive mode:\n-\n-    <program>  Copyright (C) <year>  <name of author>\n-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n-    This is free software, and you are welcome to redistribute it\n-    under certain conditions; type `show c' for details.\n-\n-The hypothetical commands `show w' and `show c' should show the appropriate\n-parts of the General Public License.  Of course, your program's commands\n-might be different; for a GUI interface, you would use an \"about box\".\n-\n-  You should also get your employer (if you work as a programmer) or school,\n-if any, to sign a \"copyright disclaimer\" for the program, if necessary.\n-For more information on this, and how to apply and follow the GNU GPL, see\n-<http://www.gnu.org/licenses/>.\n-\n-  The GNU General Public License does not permit incorporating your program\n-into proprietary programs.  If your program is a subroutine library, you\n-may consider it more useful to permit linking proprietary applications with\n-the library.  If this is what you want to do, use the GNU Lesser General\n-Public License instead of this License.  But first, please read\n-<http://www.gnu.org/philosophy/why-not-lgpl.html>."}, {"sha": "e01ee82ed16c47ac44656ffe4e4c52955db91642", "filename": "libgrust/Makefile.am", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2FMakefile.am?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,20 +0,0 @@\n-## Process this file with automake to produce Makefile.in\n-LIBFFI = @LIBFFI@\n-LIBFFIINCS = @LIBFFIINCS@\n-\n-lib_LTLIBRARIES = libgrust.la\n-\n-AM_CPPFLAGS = -I$(top_srcdir)/include\n-AM_CFLAGS = -g -O2 -std=gnu99 -Wall -Werror -fgcse $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n-\n-library_includedir = $(includedir)/grust\n-library_include_HEADERS = \\\n-\tinclude/rust/rust.h \\\n-\tinclude/rust/lang-hooks.h\n-\n-libgrust_la_CFLAGS = -DGRUST -DSHARED -g -O2 -std=gnu99 -Wall -Werror $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n-libgrust_la_LDFLAGS = -release 0.1.0 $(LIBFFI) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n-libgrust_la_LIBADD = $(PTHREAD_LIBS) $(MATH_LIBS)\n-libgrust_la_SOURCES = \\\n-\tsrc/rust-main.c \\\n-\tsrc/lang-hooks.c"}, {"sha": "f668ec358f7fe6c3c8841532570ed5e061f91f28", "filename": "libgrust/Makefile.in", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2FMakefile.in?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,590 +0,0 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = .\n-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n-\t$(top_srcdir)/configure $(am__configure_deps) \\\n-\t$(srcdir)/config.h.in $(srcdir)/../mkinstalldirs \\\n-\t$(srcdir)/../depcomp $(library_include_HEADERS)\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../libtool.m4 \\\n-\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n-\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n-\t$(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = config.h\n-CONFIG_CLEAN_FILES =\n-CONFIG_CLEAN_VPATH_FILES =\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__installdirs = \"$(DESTDIR)$(libdir)\" \\\n-\t\"$(DESTDIR)$(library_includedir)\"\n-LTLIBRARIES = $(lib_LTLIBRARIES)\n-am__DEPENDENCIES_1 =\n-libgrust_la_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)\n-am_libgrust_la_OBJECTS = libgrust_la-rust-main.lo \\\n-\tlibgrust_la-lang-hooks.lo\n-libgrust_la_OBJECTS = $(am_libgrust_la_OBJECTS)\n-libgrust_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libgrust_la_CFLAGS) \\\n-\t$(CFLAGS) $(libgrust_la_LDFLAGS) $(LDFLAGS) -o $@\n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-SOURCES = $(libgrust_la_SOURCES)\n-HEADERS = $(library_include_HEADERS)\n-ETAGS = etags\n-CTAGS = ctags\n-ACLOCAL = @ACLOCAL@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CC_FOR_BUILD = @CC_FOR_BUILD@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBFFI = @LIBFFI@\n-LIBFFIINCS = @LIBFFIINCS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MATH_LIBS = @MATH_LIBS@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJCOPY = @OBJCOPY@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-PTHREAD_CFLAGS = @PTHREAD_CFLAGS@\n-PTHREAD_LIBS = @PTHREAD_LIBS@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-WARN_FLAGS = @WARN_FLAGS@\n-WERROR = @WERROR@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-enable_shared = @enable_shared@\n-enable_static = @enable_static@\n-exec_prefix = @exec_prefix@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-libtool_VERSION = @libtool_VERSION@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-lib_LTLIBRARIES = libgrust.la\n-AM_CPPFLAGS = -I$(top_srcdir)/include\n-AM_CFLAGS = -g -O2 -std=gnu99 -Wall -Werror -fgcse $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n-library_includedir = $(includedir)/grust\n-library_include_HEADERS = \\\n-\tinclude/rust/rust.h \\\n-\tinclude/rust/lang-hooks.h\n-\n-libgrust_la_CFLAGS = -DGRUST -DSHARED -g -O2 -std=gnu99 -Wall -Werror $(LIBFFIINCS) $(PTHREAD_CFLAGS)\n-libgrust_la_LDFLAGS = -release 0.1.0 $(LIBFFI) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n-libgrust_la_LIBADD = $(PTHREAD_LIBS) $(MATH_LIBS)\n-libgrust_la_SOURCES = \\\n-\tsrc/rust-main.c \\\n-\tsrc/lang-hooks.c\n-\n-all: config.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .lo .o .obj\n-am--refresh:\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-config.h: stamp-h1\n-\t@if test ! -f $@; then \\\n-\t  rm -f stamp-h1; \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n-\telse :; fi\n-\n-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f config.h stamp-h1\n-install-libLTLIBRARIES: $(lib_LTLIBRARIES)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(libdir)\" || $(MKDIR_P) \"$(DESTDIR)$(libdir)\"\n-\t@list='$(lib_LTLIBRARIES)'; test -n \"$(libdir)\" || list=; \\\n-\tlist2=; for p in $$list; do \\\n-\t  if test -f $$p; then \\\n-\t    list2=\"$$list2 $$p\"; \\\n-\t  else :; fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(libdir)\"; \\\n-\t}\n-\n-uninstall-libLTLIBRARIES:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(lib_LTLIBRARIES)'; test -n \"$(libdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(libdir)/$$f\"; \\\n-\tdone\n-\n-clean-libLTLIBRARIES:\n-\t-test -z \"$(lib_LTLIBRARIES)\" || rm -f $(lib_LTLIBRARIES)\n-\t@list='$(lib_LTLIBRARIES)'; for p in $$list; do \\\n-\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n-\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n-\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n-\t  rm -f \"$${dir}/so_locations\"; \\\n-\tdone\n-libgrust.la: $(libgrust_la_OBJECTS) $(libgrust_la_DEPENDENCIES) \n-\t$(libgrust_la_LINK) -rpath $(libdir) $(libgrust_la_OBJECTS) $(libgrust_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgrust_la-lang-hooks.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgrust_la-rust-main.Plo@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n-\n-libgrust_la-rust-main.lo: src/rust-main.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgrust_la_CFLAGS) $(CFLAGS) -MT libgrust_la-rust-main.lo -MD -MP -MF $(DEPDIR)/libgrust_la-rust-main.Tpo -c -o libgrust_la-rust-main.lo `test -f 'src/rust-main.c' || echo '$(srcdir)/'`src/rust-main.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libgrust_la-rust-main.Tpo $(DEPDIR)/libgrust_la-rust-main.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='src/rust-main.c' object='libgrust_la-rust-main.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgrust_la_CFLAGS) $(CFLAGS) -c -o libgrust_la-rust-main.lo `test -f 'src/rust-main.c' || echo '$(srcdir)/'`src/rust-main.c\n-\n-libgrust_la-lang-hooks.lo: src/lang-hooks.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgrust_la_CFLAGS) $(CFLAGS) -MT libgrust_la-lang-hooks.lo -MD -MP -MF $(DEPDIR)/libgrust_la-lang-hooks.Tpo -c -o libgrust_la-lang-hooks.lo `test -f 'src/lang-hooks.c' || echo '$(srcdir)/'`src/lang-hooks.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libgrust_la-lang-hooks.Tpo $(DEPDIR)/libgrust_la-lang-hooks.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='src/lang-hooks.c' object='libgrust_la-lang-hooks.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgrust_la_CFLAGS) $(CFLAGS) -c -o libgrust_la-lang-hooks.lo `test -f 'src/lang-hooks.c' || echo '$(srcdir)/'`src/lang-hooks.c\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-install-library_includeHEADERS: $(library_include_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(library_includedir)\" || $(MKDIR_P) \"$(DESTDIR)$(library_includedir)\"\n-\t@list='$(library_include_HEADERS)'; test -n \"$(library_includedir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(library_includedir)'\"; \\\n-\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(library_includedir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-library_includeHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(library_include_HEADERS)'; test -n \"$(library_includedir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(library_includedir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(library_includedir)\" && rm -f $$files\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(LTLIBRARIES) $(HEADERS) config.h\n-installdirs:\n-\tfor dir in \"$(DESTDIR)$(libdir)\" \"$(DESTDIR)$(library_includedir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \\\n-\tmostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am: install-library_includeHEADERS\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am: install-libLTLIBRARIES\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-libLTLIBRARIES \\\n-\tuninstall-library_includeHEADERS\n-\n-.MAKE: all install-am install-strip\n-\n-.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \\\n-\tclean-generic clean-libLTLIBRARIES clean-libtool ctags \\\n-\tdistclean distclean-compile distclean-generic distclean-hdr \\\n-\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-libLTLIBRARIES install-library_includeHEADERS \\\n-\tinstall-man install-pdf install-pdf-am install-ps \\\n-\tinstall-ps-am install-strip installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \\\n-\tuninstall-am uninstall-libLTLIBRARIES \\\n-\tuninstall-library_includeHEADERS\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "aac001c621eea3d12f08bacffc13a82789f69498", "filename": "libgrust/README.org", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FREADME.org", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FREADME.org", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2FREADME.org?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,2 +0,0 @@\n-* librust\n-TODO"}, {"sha": "a46d213d96f655d9fc7dc8730d05c47bbd4d5ac4", "filename": "libgrust/TO_notes.txt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FTO_notes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2FTO_notes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2FTO_notes.txt?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,3 +0,0 @@\n-TO notes:\n-\n-This is the Rust runtime library, i.e. not the actual compiler bit.\n\\ No newline at end of file"}, {"sha": "8cb5ec357b3c1e2e19ccf1c550d000d63b4e8ca9", "filename": "libgrust/aclocal.m4", "status": "removed", "additions": 0, "deletions": 996, "changes": 996, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Faclocal.m4?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,996 +0,0 @@\n-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n-[m4_warning([this file was generated for autoconf 2.64.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically `autoreconf'.])])\n-\n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.11'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.1], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.1])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 9\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 10\n-\n-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n-       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n-       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n-       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                   [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named `D' -- because `-MD' means `put the output\n-  # in D'.\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n-      # Solaris 8's {/usr,}/bin/sh.\n-      touch sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle `-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # after this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvisualcpp | msvcmsys)\n-      # This compiler won't grok `-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE(dependency-tracking,\n-[  --disable-dependency-tracking  speeds up one-time build\n-  --enable-dependency-tracking   do not reject slow dependency extractors])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-#serial 5\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named `Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running `make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # When using ansi2knr, U may be empty or an underscore; expand it\n-    U=`sed -n 's/^U = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each `.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 16\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.62])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES(CC)],\n-\t\t  [define([AC_PROG_CC],\n-\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES(CXX)],\n-\t\t  [define([AC_PROG_CXX],\n-\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES(OBJC)],\n-\t\t  [define([AC_PROG_OBJC],\n-\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n-])\n-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-])\n-\n-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST(install_sh)])\n-\n-# Copyright (C) 2003, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# Check whether the underlying file-system supports filenames\n-# with a leading dot.  For instance MS-DOS doesn't.\n-AC_DEFUN([AM_SET_LEADING_DOT],\n-[rm -rf .tst 2>/dev/null\n-mkdir .tst 2>/dev/null\n-if test -d .tst; then\n-  am__leading_dot=.\n-else\n-  am__leading_dot=_\n-fi\n-rmdir .tst 2>/dev/null\n-AC_SUBST([am__leading_dot])])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless `enable' is passed literally.\n-# For symmetry, `disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      [USE_MAINTAINER_MODE=$enableval],\n-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 4\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from `make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check for `mkdir -p'.\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[AC_PREREQ([2.60])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n-dnl while keeping a definition of mkdir_p for backward compatibility.\n-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n-dnl Makefile.ins that do not define MKDIR_P, so we do our own\n-dnl adjustment using top_builddir (which is defined more often than\n-dnl MKDIR_P).\n-AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n-case $mkdir_p in\n-  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n-  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n-esac\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 4\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# ------------------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ----------------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n-esac\n-\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t \"$srcdir/configure\" conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of `v7', `ustar', or `pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.\n-AM_MISSING_PROG([AMTAR], [tar])\n-m4_if([$1], [v7],\n-     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n-     [m4_case([$1], [ustar],, [pax],,\n-              [m4_fatal([Unknown tar format])])\n-AC_MSG_CHECKING([how to create a $1 tar archive])\n-# Loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-# Do not fold the above two line into one, because Tru64 sh and\n-# Solaris sh will not grok spaces in the rhs of `-'.\n-for _am_tool in $_am_tools\n-do\n-  case $_am_tool in\n-  gnutar)\n-    for _am_tar in tar gnutar gtar;\n-    do\n-      AM_RUN_LOG([$_am_tar --version]) && break\n-    done\n-    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-    am__untar=\"$_am_tar -xf -\"\n-    ;;\n-  plaintar)\n-    # Must skip GNU tar: if it does not support --format= it doesn't create\n-    # ustar tarball either.\n-    (tar --version) >/dev/null 2>&1 && continue\n-    am__tar='tar chf - \"$$tardir\"'\n-    am__tar_='tar chf - \"$tardir\"'\n-    am__untar='tar xf -'\n-    ;;\n-  pax)\n-    am__tar='pax -L -x $1 -w \"$$tardir\"'\n-    am__tar_='pax -L -x $1 -w \"$tardir\"'\n-    am__untar='pax -r'\n-    ;;\n-  cpio)\n-    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-    am__untar='cpio -i -H $1 -d'\n-    ;;\n-  none)\n-    am__tar=false\n-    am__tar_=false\n-    am__untar=false\n-    ;;\n-  esac\n-\n-  # If the value was cached, stop now.  We just wanted to have am__tar\n-  # and am__untar set.\n-  test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-  # tar/untar a dummy directory, and stop if the command works\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  echo GrepMe > conftest.dir/file\n-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-  rm -rf conftest.dir\n-  if test -s conftest.tar; then\n-    AM_RUN_LOG([$am__untar <conftest.tar])\n-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-  fi\n-done\n-rm -rf conftest.dir\n-\n-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])"}, {"sha": "cc3274f2500894d4c9217f88ce4dff69b8fb1324", "filename": "libgrust/config.h.in", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Fconfig.h.in?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,222 +0,0 @@\n-/* config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-#undef AC_APPLE_UNIVERSAL_BUILD\n-\n-/* Define to 1 if you have the <assert.h> header file. */\n-#undef HAVE_ASSERT_H\n-\n-/* Define to 1 if you have the `atof' function. */\n-#undef HAVE_ATOF\n-\n-/* Define to 1 if you have the `atoi' function. */\n-#undef HAVE_ATOI\n-\n-/* Define to 1 if you have the `calloc' function. */\n-#undef HAVE_CALLOC\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#undef HAVE_DLFCN_H\n-\n-/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n-#undef HAVE_DOPRNT\n-\n-/* Define to 1 if you have the `execl' function. */\n-#undef HAVE_EXECL\n-\n-/* Define to 1 if you have the `exit' function. */\n-#undef HAVE_EXIT\n-\n-/* Define to 1 if you have the `fclose' function. */\n-#undef HAVE_FCLOSE\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#undef HAVE_FCNTL_H\n-\n-/* Define to 1 if you have the `fdopen' function. */\n-#undef HAVE_FDOPEN\n-\n-/* Define to 1 if you have the `fgets' function. */\n-#undef HAVE_FGETS\n-\n-/* Define to 1 if you have the `fopen' function. */\n-#undef HAVE_FOPEN\n-\n-/* Define to 1 if you have the `fork' function. */\n-#undef HAVE_FORK\n-\n-/* Define to 1 if you have the `fprintf' function. */\n-#undef HAVE_FPRINTF\n-\n-/* Define to 1 if you have the `getc' function. */\n-#undef HAVE_GETC\n-\n-/* Define to 1 if you have the <getopt.h> header file. */\n-#undef HAVE_GETOPT_H\n-\n-/* Define to 1 if you have the `getopt_long' function. */\n-#undef HAVE_GETOPT_LONG\n-\n-/* Define to 1 if you have the `getpid' function. */\n-#undef HAVE_GETPID\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#undef HAVE_INTTYPES_H\n-\n-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and\n-   to 0 otherwise. */\n-#undef HAVE_MALLOC\n-\n-/* Define to 1 if you have the `memcmp' function. */\n-#undef HAVE_MEMCMP\n-\n-/* Define to 1 if you have the `memcpy' function. */\n-#undef HAVE_MEMCPY\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#undef HAVE_MEMORY_H\n-\n-/* Define to 1 if you have the `pipe' function. */\n-#undef HAVE_PIPE\n-\n-/* Define to 1 if you have the `popen' function. */\n-#undef HAVE_POPEN\n-\n-/* Define to 1 if you have the <pthread.h> header file. */\n-#undef HAVE_PTHREAD_H\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#undef HAVE_SIGNAL_H\n-\n-/* Define to 1 if you have the `sprintf' function. */\n-#undef HAVE_SPRINTF\n-\n-/* Define to 1 if you have the <stdarg.h> header file. */\n-#undef HAVE_STDARG_H\n-\n-/* Define to 1 if stdbool.h conforms to C99. */\n-#undef HAVE_STDBOOL_H\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#undef HAVE_STDINT_H\n-\n-/* Define to 1 if you have the <stdio.h> header file. */\n-#undef HAVE_STDIO_H\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#undef HAVE_STDLIB_H\n-\n-/* Define to 1 if you have the `strcmp' function. */\n-#undef HAVE_STRCMP\n-\n-/* Define to 1 if you have the `strcpy' function. */\n-#undef HAVE_STRCPY\n-\n-/* Define to 1 if you have the `strdup' function. */\n-#undef HAVE_STRDUP\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#undef HAVE_STRINGS_H\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#undef HAVE_STRING_H\n-\n-/* Define to 1 if you have the `strlen' function. */\n-#undef HAVE_STRLEN\n-\n-/* Define to 1 if you have the `sysconf' function. */\n-#undef HAVE_SYSCONF\n-\n-/* Define to 1 if you have the `system' function. */\n-#undef HAVE_SYSTEM\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#undef HAVE_SYS_STAT_H\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#undef HAVE_SYS_TYPES_H\n-\n-/* Define to 1 if you have the <sys/wait.h> header file. */\n-#undef HAVE_SYS_WAIT_H\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#undef HAVE_UNISTD_H\n-\n-/* Define to 1 if you have the <utime.h> header file. */\n-#undef HAVE_UTIME_H\n-\n-/* Define to 1 if `utime(file, NULL)' sets file's timestamp to the present. */\n-#undef HAVE_UTIME_NULL\n-\n-/* Define to 1 if you have the `vfprintf' function. */\n-#undef HAVE_VFPRINTF\n-\n-/* Define to 1 if you have the `vprintf' function. */\n-#undef HAVE_VPRINTF\n-\n-/* Define to 1 if you have the `wait' function. */\n-#undef HAVE_WAIT\n-\n-/* Define to 1 if you have the `waitpid' function. */\n-#undef HAVE_WAITPID\n-\n-/* Define to 1 if the system has the type `_Bool'. */\n-#undef HAVE__BOOL\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#undef LT_OBJDIR\n-\n-/* GCC Rust Runtime */\n-#undef PACKAGE\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#undef PACKAGE_BUGREPORT\n-\n-/* Define to the full name of this package. */\n-#undef PACKAGE_NAME\n-\n-/* Define to the full name and version of this package. */\n-#undef PACKAGE_STRING\n-\n-/* Define to the one symbol short name of this package. */\n-#undef PACKAGE_TARNAME\n-\n-/* Define to the home page for this package. */\n-#undef PACKAGE_URL\n-\n-/* Define to the version of this package. */\n-#undef PACKAGE_VERSION\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#undef STDC_HEADERS\n-\n-/* Define if we're to use libffi. */\n-#undef USE_LIBFFI\n-\n-/* 0.1 */\n-#undef VERSION\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-#  undef WORDS_BIGENDIAN\n-# endif\n-#endif\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-#undef const\n-\n-/* Define to rpl_malloc if the replacement function should be used. */\n-#undef malloc\n-\n-/* Define to `int' if <sys/types.h> does not define. */\n-#undef pid_t\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-#undef size_t"}, {"sha": "231dda016fe60766559e4336f52effbd0e4413ec", "filename": "libgrust/configure", "status": "removed", "additions": 0, "deletions": 14027, "changes": 14027, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Fconfigure?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "207182e35108ead6f4ce198ae8864d88855baaba", "filename": "libgrust/configure.ac", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Fconfigure.ac?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,144 +0,0 @@\n-#   Copyright (C) 2013 Free Software Foundation, Inc.\n-#\n-# This file is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful, but\n-# WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-# General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-##############################################################################\n-### WARNING: this file contains embedded tabs.  Do not run untabify on this file.\n-# Process this file with autoconf to produce a configure script, like so:\n-# aclocal && autoconf && autoheader && automake\n-\n-AC_PREREQ(2.64)\n-AC_INIT(GCC-Rust-runtime, 0.1, http://gcc.gnu.org, libgrust,\n-\t\t       https://github.com/redbrain/gccrs)\n-AC_CONFIG_SRCDIR(Makefile.am)\n-AC_CONFIG_HEADER(config.h)\n-\n-libtool_VERSION=1:0:0\n-AC_SUBST(libtool_VERSION)\n-\n-AC_CANONICAL_SYSTEM\n-target_alias=${target_alias-$host_alias}\n-\n-\n-AM_INIT_AUTOMAKE([1.9.3 no-define foreign no-dist -Wall -Wno-portability])\n-AH_TEMPLATE(PACKAGE, [GCC Rust Runtime])\n-AH_TEMPLATE(VERSION, [0.1])\n-\n-m4_rename([_AC_ARG_VAR_PRECIOUS],[glibgrust_PRECIOUS])\n-m4_define([_AC_ARG_VAR_PRECIOUS],[])\n-AC_PROG_CC\n-m4_rename_force([glibgrust_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n-\n-AC_SUBST(CFLAGS)\n-\n-AM_MAINTAINER_MODE\n-\n-AC_PROG_LD\n-AC_CHECK_TOOL(OBJCOPY, objcopy, missing-objcopy)\n-\n-AC_LIBTOOL_DLOPEN\n-AM_PROG_LIBTOOL\n-AC_SUBST(enable_shared)\n-AC_SUBST(enable_static)\n-\n-CC_FOR_BUILD=${CC_FOR_BUILD:-gcc}\n-AC_SUBST(CC_FOR_BUILD)\n-\n-AC_PROG_AWK\n-\n-WARN_FLAGS='-Wall -Wextra -Wwrite-strings -Wcast-qual'\n-AC_SUBST(WARN_FLAGS)\n-\n-dnl FIXME: This should be controlled by --enable-maintainer-mode.\n-WERROR=\"-Werror\"\n-AC_SUBST(WERROR)\n-\n-# See if the user wants to configure without libffi.  Some\n-# architectures don't support it.  FIXME: We should set a default\n-# based on the host.\n-AC_ARG_WITH(libffi,\n-  AS_HELP_STRING([--without-libffi],\n-                 [don't use libffi]),\n-  [:],\n-  [with_libffi=${with_libffi_default-yes}])\n-\n-LIBFFI=\n-LIBFFIINCS=\n-if test \"$with_libffi\" != no; then\n-   AC_DEFINE(USE_LIBFFI, 1, [Define if we're to use libffi.])\n-   LIBFFI=../libffi/libffi_convenience.la\n-   LIBFFIINCS='-I$(top_srcdir)/../libffi/include -I../libffi/include'\n-fi\n-AC_SUBST(LIBFFI)\n-AC_SUBST(LIBFFIINCS)\n-\n-dnl Test for the -lm library.\n-MATH_LIBS=\n-AC_CHECK_LIB([m], [sqrt], MATH_LIBS=-lm)\n-AC_SUBST(MATH_LIBS)\n-\n-dnl Test whether the compiler supports the -pthread option.\n-AC_CACHE_CHECK([whether -pthread is supported],\n-[libgpython_cv_lib_pthread],\n-[CFLAGS_hold=$CFLAGS\n-CFLAGS=\"$CFLAGS -pthread\"\n-AC_COMPILE_IFELSE([[int i;]],\n-[libgpython_cv_lib_pthread=yes],\n-[libgpython_cv_lib_pthread=no])\n-CFLAGS=$CFLAGS_hold])\n-PTHREAD_CFLAGS=\n-if test \"$libgpython_cv_lib_pthread\" = yes; then\n-  PTHREAD_CFLAGS=-pthread\n-fi\n-AC_SUBST(PTHREAD_CFLAGS)\n-\n-dnl Test for the -lpthread library.\n-PTHREAD_LIBS=\n-AC_CHECK_LIB([pthread], [pthread_create], PTHREAD_LIBS=-lpthread)\n-AC_SUBST(PTHREAD_LIBS)\n-\n-AC_C_BIGENDIAN\n-\n-GCC_CHECK_UNWIND_GETIPINFO\n-\n-AC_SUBST(CFLAGS)\n-AC_SUBST(LDFLAGS)\n-\n-# Checks for header files.\n-AC_HEADER_STDBOOL\n-AC_HEADER_STDC\n-AC_CHECK_HEADERS([stdlib.h string.h stdarg.h unistd.h \\\n-   \t      stdint.h stdio.h getopt.h \\\n-\t      assert.h sys/types.h signal.h \\\n-\t      fcntl.h pthread.h sys/wait.h])\n-\n-# Checks for typedefs, structures, and compiler characteristics.\n-AC_C_CONST\n-AC_TYPE_PID_T\n-AC_TYPE_SIZE_T\n-AC_CHECK_FUNCS([popen fopen fclose sprintf fprintf strdup \\\n-\t\t      strlen strcpy strcmp getopt_long \\\n-\t   \t      memcpy calloc system sysconf atoi \\\n-\t   \t      getpid execl fork wait exit atof \\\n-\t  \t      vfprintf memcmp getc fgets pipe \\\n-\t\t      waitpid fdopen])\n-\n-# Checks for library functions.\n-AC_FUNC_MALLOC\n-AC_FUNC_UTIME_NULL\n-AC_FUNC_VPRINTF\n-\n-AC_CONFIG_FILES(Makefile)\n-AC_OUTPUT"}, {"sha": "c7dfaa45721111a6b0d7746313a579accdd56511", "filename": "libgrust/include/rust/lang-hooks.h", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Finclude%2Frust%2Flang-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Finclude%2Frust%2Flang-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Finclude%2Frust%2Flang-hooks.h?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,24 +0,0 @@\n-/* This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. */\n-\n-#ifndef __GCC_RUST_LANG_HOOKS_H__\n-#define __GCC_RUST_LANG_HOOKS_H__\n-\n-#define LANG_HOOK(name)\t     __GRUST_##name\n-\n-extern void LANG_HOOK(println) (const char *);\n-\n-#endif //__GCC_RUST_LANG_HOOKS_H__"}, {"sha": "73bea3b87519c4230695dba87f395081286fdb9d", "filename": "libgrust/include/rust/rust.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Finclude%2Frust%2Frust.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Finclude%2Frust%2Frust.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Finclude%2Frust%2Frust.h?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,31 +0,0 @@\n-/* This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. */\n-\n-#ifndef __GCC_RUST_H__\n-#define __GCC_RUST_H__\n-\n-#ifdef HAVE_CONFIG_H\n-# include \"config.h\"\n-#endif\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <stdbool.h>\n-\n-#include <rust/lang-hooks.h>\n-\n-#endif //__GCC_RUST_H__"}, {"sha": "e02bf9f4ba8a316cf57b81770635db5590df078b", "filename": "libgrust/libstd/any.rs", "status": "removed", "additions": 0, "deletions": 444, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fany.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fany.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,444 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module implements the `Any` trait, which enables dynamic typing\n-//! of any type.\n-\n-use cast::transmute;\n-use cmp::Eq;\n-use option::{Option, Some, None};\n-use to_bytes::{IterBytes, Cb};\n-use to_str::ToStr;\n-use unstable::intrinsics;\n-use util::Void;\n-\n-///////////////////////////////////////////////////////////////////////////////\n-// TypeId\n-///////////////////////////////////////////////////////////////////////////////\n-\n-/// `TypeId` represents a globally unique identifier for a type\n-pub struct TypeId {\n-    priv t: u64,\n-}\n-\n-impl TypeId {\n-    /// Returns the `TypeId` of the type this generic function has been instantiated with\n-    #[inline]\n-    pub fn of<T: 'static>() -> TypeId {\n-        TypeId{ t: unsafe { intrinsics::type_id::<T>() } }\n-    }\n-}\n-\n-impl Eq for TypeId {\n-    #[inline]\n-    fn eq(&self, &other: &TypeId) -> bool {\n-        self.t == other.t\n-    }\n-}\n-\n-impl IterBytes for TypeId {\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.t.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-// Any trait\n-///////////////////////////////////////////////////////////////////////////////\n-\n-/// The `Any` trait is implemented by all types, and can be used as a trait object\n-/// for dynamic typing\n-pub trait Any {\n-    /// Get the `TypeId` of `self`\n-    fn get_type_id(&self) -> TypeId;\n-\n-    /// Get a void pointer to `self`\n-    fn as_void_ptr(&self) -> *Void;\n-\n-    /// Get a mutable void pointer to `self`\n-    fn as_mut_void_ptr(&mut self) -> *mut Void;\n-}\n-\n-impl<T: 'static> Any for T {\n-    /// Get the `TypeId` of `self`\n-    fn get_type_id(&self) -> TypeId {\n-        TypeId::of::<T>()\n-    }\n-\n-    /// Get a void pointer to `self`\n-    fn as_void_ptr(&self) -> *Void {\n-        self as *T as *Void\n-    }\n-\n-    /// Get a mutable void pointer to `self`\n-    fn as_mut_void_ptr(&mut self) -> *mut Void {\n-        self as *mut T as *mut Void\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-// Extension methods for Any trait objects.\n-// Implemented as three extension traits so that generics work.\n-///////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods for a referenced `Any` trait object\n-pub trait AnyRefExt<'self> {\n-    /// Returns true if the boxed type is the same as `T`\n-    fn is<T: 'static>(self) -> bool;\n-\n-    /// Returns some reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    fn as_ref<T: 'static>(self) -> Option<&'self T>;\n-}\n-\n-impl<'self> AnyRefExt<'self> for &'self Any {\n-    #[inline]\n-    fn is<T: 'static>(self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n-        let t = TypeId::of::<T>();\n-\n-        // Get TypeId of the type in the trait object\n-        let boxed = self.get_type_id();\n-\n-        // Compare both TypeIds on equality\n-        t == boxed\n-    }\n-\n-    #[inline]\n-    fn as_ref<T: 'static>(self) -> Option<&'self T> {\n-        if self.is::<T>() {\n-            Some(unsafe { transmute(self.as_void_ptr()) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extension methods for a mutable referenced `Any` trait object\n-pub trait AnyMutRefExt<'self> {\n-    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    fn as_mut<T: 'static>(self) -> Option<&'self mut T>;\n-}\n-\n-impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n-    #[inline]\n-    fn as_mut<T: 'static>(self) -> Option<&'self mut T> {\n-        if self.is::<T>() {\n-            Some(unsafe { transmute(self.as_mut_void_ptr()) })\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extension methods for a owning `Any` trait object\n-pub trait AnyOwnExt {\n-    /// Returns the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    fn move<T: 'static>(self) -> Option<~T>;\n-}\n-\n-impl AnyOwnExt for ~Any {\n-    #[inline]\n-    fn move<T: 'static>(self) -> Option<~T> {\n-        if self.is::<T>() {\n-            unsafe {\n-                // Extract the pointer to the boxed value, temporary alias with self\n-                let ptr: ~T = transmute(self.as_void_ptr());\n-\n-                // Prevent destructor on self being run\n-                intrinsics::forget(self);\n-\n-                Some(ptr)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-// Trait implementations\n-///////////////////////////////////////////////////////////////////////////////\n-\n-impl ToStr for ~Any {\n-    fn to_str(&self) -> ~str { ~\"~Any\" }\n-}\n-\n-impl<'self> ToStr for &'self Any {\n-    fn to_str(&self) -> ~str { ~\"&Any\" }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use super::AnyRefExt;\n-    use option::{Some, None};\n-    use hash::Hash;\n-\n-    #[deriving(Eq)]\n-    struct Test;\n-\n-    static TEST: &'static str = \"Test\";\n-\n-    #[test]\n-    fn type_id() {\n-        let (a, b, c) = (TypeId::of::<uint>(), TypeId::of::<&'static str>(),\n-                         TypeId::of::<Test>());\n-        let (d, e, f) = (TypeId::of::<uint>(), TypeId::of::<&'static str>(),\n-                         TypeId::of::<Test>());\n-\n-        assert!(a != b);\n-        assert!(a != c);\n-        assert!(b != c);\n-\n-        assert_eq!(a, d);\n-        assert_eq!(b, e);\n-        assert_eq!(c, f);\n-    }\n-\n-    #[test]\n-    fn type_id_hash() {\n-        let (a, b) = (TypeId::of::<uint>(), TypeId::of::<uint>());\n-\n-        assert_eq!(a.hash(), b.hash());\n-    }\n-\n-    #[test]\n-    fn any_as_void_ptr() {\n-        let (a, b, c) = (~5u as ~Any, ~TEST as ~Any, ~Test as ~Any);\n-        let a_r: &Any = a;\n-        let b_r: &Any = b;\n-        let c_r: &Any = c;\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-\n-        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n-        let a_r: &Any = a;\n-        let b_r: &Any = b;\n-        let c_r: &Any = c;\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-\n-        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n-        let a_r: &Any = a;\n-        let b_r: &Any = b;\n-        let c_r: &Any = c;\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-\n-        let mut x = Test;\n-        let mut y: &'static str = \"Test\";\n-        let (a, b, c) = (&mut 5u as &mut Any,\n-                         &mut y as &mut Any,\n-                         &mut x as &mut Any);\n-        let a_r: &Any = a;\n-        let b_r: &Any = b;\n-        let c_r: &Any = c;\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-\n-        let (a, b, c) = (5u, \"hello\", Test);\n-        let (a_r, b_r, c_r) = (&a as &Any, &b as &Any, &c as &Any);\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-    }\n-\n-    #[test]\n-    fn any_as_mut_void_ptr() {\n-        let y: &'static str = \"Test\";\n-        let mut a = ~5u as ~Any;\n-        let mut b = ~y as ~Any;\n-        let mut c = ~Test as ~Any;\n-\n-        let a_ptr = a.as_mut_void_ptr();\n-        let b_ptr = b.as_mut_void_ptr();\n-        let c_ptr = c.as_mut_void_ptr();\n-\n-        let a_r: &mut Any = a;\n-        let b_r: &mut Any = b;\n-        let c_r: &mut Any = c;\n-\n-        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n-        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n-        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n-\n-        let mut x = Test;\n-        let mut y: &'static str = \"Test\";\n-        let a = &mut 5u as &mut Any;\n-        let b = &mut y as &mut Any;\n-        let c = &mut x as &mut Any;\n-\n-        let a_ptr = a.as_mut_void_ptr();\n-        let b_ptr = b.as_mut_void_ptr();\n-        let c_ptr = c.as_mut_void_ptr();\n-\n-        let a_r: &mut Any = a;\n-        let b_r: &mut Any = b;\n-        let c_r: &mut Any = c;\n-\n-        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n-        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n-        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n-\n-        let y: &'static str = \"Test\";\n-        let mut a = 5u;\n-        let mut b = y;\n-        let mut c = Test;\n-\n-        let a_ptr = a.as_mut_void_ptr();\n-        let b_ptr = b.as_mut_void_ptr();\n-        let c_ptr = c.as_mut_void_ptr();\n-\n-        let (a_r, b_r, c_r) = (&mut a as &mut Any, &mut b as &mut Any, &mut c as &mut Any);\n-\n-        assert_eq!(a_ptr, a_r.as_mut_void_ptr());\n-        assert_eq!(b_ptr, b_r.as_mut_void_ptr());\n-        assert_eq!(c_ptr, c_r.as_mut_void_ptr());\n-    }\n-\n-    #[test]\n-    fn any_referenced() {\n-        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_owning() {\n-        let (a, b, c) = (~5u as ~Any, ~TEST as ~Any, ~Test as ~Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_managed() {\n-        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_as_ref() {\n-        let a = &5u as &Any;\n-\n-        match a.as_ref::<uint>() {\n-            Some(&5) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match a.as_ref::<Test>() {\n-            None => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_as_mut() {\n-        let mut a = 5u;\n-        let mut b = ~7u;\n-\n-        let a_r = &mut a as &mut Any;\n-        let tmp: &mut uint = b;\n-        let b_r = tmp as &mut Any;\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 5u);\n-                *x = 612;\n-            }\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 7u);\n-                *x = 413;\n-            }\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match a_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match b_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(&612) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(&413) => {}\n-            x => fail!(\"Unexpected value {:?}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_move() {\n-        let a = ~8u as ~Any;\n-        let b = ~Test as ~Any;\n-\n-        assert_eq!(a.move(), Some(~8u));\n-        assert_eq!(b.move(), Some(~Test));\n-\n-        let a = ~8u as ~Any;\n-        let b = ~Test as ~Any;\n-\n-        assert_eq!(a.move(), None::<~Test>);\n-        assert_eq!(b.move(), None::<~uint>);\n-    }\n-}"}, {"sha": "c43b4e9b6ea29997418d05337ba9fe6fa8b422e8", "filename": "libgrust/libstd/ascii.rs", "status": "removed", "additions": 0, "deletions": 662, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fascii.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,662 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations on ASCII strings and characters.\n-\n-use to_str::{ToStr,ToStrConsume};\n-use str;\n-use str::StrSlice;\n-use str::OwnedStr;\n-use container::Container;\n-use cast;\n-use iter::Iterator;\n-use vec::{ImmutableVector, MutableVector};\n-use to_bytes::IterBytes;\n-use option::{Some, None};\n-\n-/// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq)]\n-pub struct Ascii { priv chr: u8 }\n-\n-impl Ascii {\n-    /// Converts a ascii character into a `u8`.\n-    #[inline]\n-    pub fn to_byte(self) -> u8 {\n-        self.chr\n-    }\n-\n-    /// Converts a ascii character into a `char`.\n-    #[inline]\n-    pub fn to_char(self) -> char {\n-        self.chr as char\n-    }\n-\n-    /// Convert to lowercase.\n-    #[inline]\n-    pub fn to_lower(self) -> Ascii {\n-        Ascii{chr: ASCII_LOWER_MAP[self.chr]}\n-    }\n-\n-    /// Convert to uppercase.\n-    #[inline]\n-    pub fn to_upper(self) -> Ascii {\n-        Ascii{chr: ASCII_UPPER_MAP[self.chr]}\n-    }\n-\n-    /// Compares two ascii characters of equality, ignoring case.\n-    #[inline]\n-    pub fn eq_ignore_case(self, other: Ascii) -> bool {\n-        ASCII_LOWER_MAP[self.chr] == ASCII_LOWER_MAP[other.chr]\n-    }\n-\n-    // the following methods are like ctype, and the implementation is inspired by musl\n-\n-    /// Check if the character is a letter (a-z, A-Z)\n-    #[inline]\n-    pub fn is_alpha(&self) -> bool {\n-        (self.chr >= 0x41 && self.chr <= 0x5A) || (self.chr >= 0x61 && self.chr <= 0x7A)\n-    }\n-\n-    /// Check if the character is a number (0-9)\n-    #[inline]\n-    pub fn is_digit(&self) -> bool {\n-        self.chr >= 0x30 && self.chr <= 0x39\n-    }\n-\n-    /// Check if the character is a letter or number\n-    #[inline]\n-    pub fn is_alnum(&self) -> bool {\n-        self.is_alpha() || self.is_digit()\n-    }\n-\n-    /// Check if the character is a space or horizontal tab\n-    #[inline]\n-    pub fn is_blank(&self) -> bool {\n-        self.chr == ' ' as u8 || self.chr == '\\t' as u8\n-    }\n-\n-    /// Check if the character is a control character\n-    #[inline]\n-    pub fn is_control(&self) -> bool {\n-        self.chr < 0x20 || self.chr == 0x7F\n-    }\n-\n-    /// Checks if the character is printable (except space)\n-    #[inline]\n-    pub fn is_graph(&self) -> bool {\n-        (self.chr - 0x21) < 0x5E\n-    }\n-\n-    /// Checks if the character is printable (including space)\n-    #[inline]\n-    pub fn is_print(&self) -> bool {\n-        (self.chr - 0x20) < 0x5F\n-    }\n-\n-    /// Checks if the character is lowercase\n-    #[inline]\n-    pub fn is_lower(&self) -> bool {\n-        (self.chr - 'a' as u8) < 26\n-    }\n-\n-    /// Checks if the character is uppercase\n-    #[inline]\n-    pub fn is_upper(&self) -> bool {\n-        (self.chr - 'A' as u8) < 26\n-    }\n-\n-    /// Checks if the character is punctuation\n-    #[inline]\n-    pub fn is_punctuation(&self) -> bool {\n-        self.is_graph() && !self.is_alnum()\n-    }\n-\n-    /// Checks if the character is a valid hex digit\n-    #[inline]\n-    pub fn is_hex(&self) -> bool {\n-        self.is_digit() || ((self.chr | 32u8) - 'a' as u8) < 6\n-    }\n-}\n-\n-impl ToStr for Ascii {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        // self.chr is always a valid utf8 byte, no need for the check\n-        unsafe { str::raw::from_byte(self.chr) }\n-    }\n-}\n-\n-/// Trait for converting into an ascii type.\n-pub trait AsciiCast<T> {\n-    /// Convert to an ascii type\n-    fn to_ascii(&self) -> T;\n-\n-    /// Convert to an ascii type, not doing any range asserts\n-    unsafe fn to_ascii_nocheck(&self) -> T;\n-\n-    /// Check if convertible to ascii\n-    fn is_ascii(&self) -> bool;\n-}\n-\n-impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n-    #[inline]\n-    fn to_ascii(&self) -> &'self[Ascii] {\n-        assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n-    }\n-\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n-        cast::transmute(*self)\n-    }\n-\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        for b in self.iter() {\n-            if !b.is_ascii() { return false; }\n-        }\n-        true\n-    }\n-}\n-\n-impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n-    #[inline]\n-    fn to_ascii(&self) -> &'self [Ascii] {\n-        assert!(self.is_ascii());\n-        unsafe { self.to_ascii_nocheck() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n-        cast::transmute(*self)\n-    }\n-\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii())\n-    }\n-}\n-\n-impl AsciiCast<Ascii> for u8 {\n-    #[inline]\n-    fn to_ascii(&self) -> Ascii {\n-        assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n-    }\n-\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n-        Ascii{ chr: *self }\n-    }\n-\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self & 128 == 0u8\n-    }\n-}\n-\n-impl AsciiCast<Ascii> for char {\n-    #[inline]\n-    fn to_ascii(&self) -> Ascii {\n-        assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n-    }\n-\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n-        Ascii{ chr: *self as u8 }\n-    }\n-\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self as u32 - ('\\x7F' as u32 & *self as u32) == 0\n-    }\n-}\n-\n-/// Trait for copyless casting to an ascii vector.\n-pub trait OwnedAsciiCast {\n-    /// Take ownership and cast to an ascii vector.\n-    fn into_ascii(self) -> ~[Ascii];\n-\n-    /// Take ownership and cast to an ascii vector.\n-    /// Does not perform validation checks.\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii];\n-}\n-\n-impl OwnedAsciiCast for ~[u8] {\n-    #[inline]\n-    fn into_ascii(self) -> ~[Ascii] {\n-        assert!(self.is_ascii());\n-        unsafe {self.into_ascii_nocheck()}\n-    }\n-\n-    #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n-        cast::transmute(self)\n-    }\n-}\n-\n-impl OwnedAsciiCast for ~str {\n-    #[inline]\n-    fn into_ascii(self) -> ~[Ascii] {\n-        assert!(self.is_ascii());\n-        unsafe {self.into_ascii_nocheck()}\n-    }\n-\n-    #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n-        cast::transmute(self)\n-    }\n-}\n-\n-/// Trait for converting an ascii type to a string. Needed to convert\n-/// `&[Ascii]` to `&str`.\n-pub trait AsciiStr {\n-    /// Convert to a string.\n-    fn as_str_ascii<'a>(&'a self) -> &'a str;\n-\n-    /// Convert to vector representing a lower cased ascii string.\n-    fn to_lower(&self) -> ~[Ascii];\n-\n-    /// Convert to vector representing a upper cased ascii string.\n-    fn to_upper(&self) -> ~[Ascii];\n-\n-    /// Compares two Ascii strings ignoring case.\n-    fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n-}\n-\n-impl<'self> AsciiStr for &'self [Ascii] {\n-    #[inline]\n-    fn as_str_ascii<'a>(&'a self) -> &'a str {\n-        unsafe { cast::transmute(*self) }\n-    }\n-\n-    #[inline]\n-    fn to_lower(&self) -> ~[Ascii] {\n-        self.map(|a| a.to_lower())\n-    }\n-\n-    #[inline]\n-    fn to_upper(&self) -> ~[Ascii] {\n-        self.map(|a| a.to_upper())\n-    }\n-\n-    #[inline]\n-    fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n-        self.iter().zip(other.iter()).all(|(&a, &b)| a.eq_ignore_case(b))\n-    }\n-}\n-\n-impl ToStrConsume for ~[Ascii] {\n-    #[inline]\n-    fn into_str(self) -> ~str {\n-        unsafe { cast::transmute(self) }\n-    }\n-}\n-\n-impl IterBytes for Ascii {\n-    #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n-        f([self.to_byte()])\n-    }\n-}\n-\n-/// Trait to convert to a owned byte array by consuming self\n-pub trait ToBytesConsume {\n-    /// Converts to a owned byte array by consuming self\n-    fn into_bytes(self) -> ~[u8];\n-}\n-\n-impl ToBytesConsume for ~[Ascii] {\n-    fn into_bytes(self) -> ~[u8] {\n-        unsafe { cast::transmute(self) }\n-    }\n-}\n-\n-/// Extension methods for ASCII-subset only operations on owned strings\n-pub trait OwnedStrAsciiExt {\n-    /// Convert the string to ASCII upper case:\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_upper(self) -> ~str;\n-\n-    /// Convert the string to ASCII lower case:\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_lower(self) -> ~str;\n-}\n-\n-/// Extension methods for ASCII-subset only operations on string slices\n-pub trait StrAsciiExt {\n-    /// Makes a copy of the string in ASCII upper case:\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    fn to_ascii_upper(&self) -> ~str;\n-\n-    /// Makes a copy of the string in ASCII lower case:\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lower(&self) -> ~str;\n-\n-    /// Check that two strings are an ASCII case-insensitive match.\n-    /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n-    /// but without allocating and copying temporary strings.\n-    fn eq_ignore_ascii_case(&self, other: &str) -> bool;\n-}\n-\n-impl<'self> StrAsciiExt for &'self str {\n-    #[inline]\n-    fn to_ascii_upper(&self) -> ~str {\n-        unsafe { str_copy_map_bytes(*self, ASCII_UPPER_MAP) }\n-    }\n-\n-    #[inline]\n-    fn to_ascii_lower(&self) -> ~str {\n-        unsafe { str_copy_map_bytes(*self, ASCII_LOWER_MAP) }\n-    }\n-\n-    #[inline]\n-    fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n-        self.len() == other.len() && self.as_bytes().iter().zip(other.as_bytes().iter()).all(\n-            |(byte_self, byte_other)| ASCII_LOWER_MAP[*byte_self] == ASCII_LOWER_MAP[*byte_other])\n-    }\n-}\n-\n-impl OwnedStrAsciiExt for ~str {\n-    #[inline]\n-    fn into_ascii_upper(self) -> ~str {\n-        unsafe { str_map_bytes(self, ASCII_UPPER_MAP) }\n-    }\n-\n-    #[inline]\n-    fn into_ascii_lower(self) -> ~str {\n-        unsafe { str_map_bytes(self, ASCII_LOWER_MAP) }\n-    }\n-}\n-\n-#[inline]\n-unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n-    let mut bytes = string.into_bytes();\n-\n-    for b in bytes.mut_iter() {\n-        *b = map[*b];\n-    }\n-\n-    str::raw::from_utf8_owned(bytes)\n-}\n-\n-#[inline]\n-unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n-    let bytes = string.bytes().map(|b| map[b]).to_owned_vec();\n-\n-    str::raw::from_utf8_owned(bytes)\n-}\n-\n-static ASCII_LOWER_MAP: &'static [u8] = &[\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n-    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n-    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n-    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n-    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n-    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n-    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n-    0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n-    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n-    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n-    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n-    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-static ASCII_UPPER_MAP: &'static [u8] = &[\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n-    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n-    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n-    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n-    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n-    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n-    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n-    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n-    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n-    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n-    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n-    0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use str::from_char;\n-    use char::from_u32;\n-\n-    macro_rules! v2ascii (\n-        ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n-        (~[$($e:expr),*]) => (~[$(Ascii{chr:$e}),*]);\n-    )\n-\n-    #[test]\n-    fn test_ascii() {\n-        assert_eq!(65u8.to_ascii().to_byte(), 65u8);\n-        assert_eq!(65u8.to_ascii().to_char(), 'A');\n-        assert_eq!('A'.to_ascii().to_char(), 'A');\n-        assert_eq!('A'.to_ascii().to_byte(), 65u8);\n-\n-        assert_eq!('A'.to_ascii().to_lower().to_char(), 'a');\n-        assert_eq!('Z'.to_ascii().to_lower().to_char(), 'z');\n-        assert_eq!('a'.to_ascii().to_upper().to_char(), 'A');\n-        assert_eq!('z'.to_ascii().to_upper().to_char(), 'Z');\n-\n-        assert_eq!('@'.to_ascii().to_lower().to_char(), '@');\n-        assert_eq!('['.to_ascii().to_lower().to_char(), '[');\n-        assert_eq!('`'.to_ascii().to_upper().to_char(), '`');\n-        assert_eq!('{'.to_ascii().to_upper().to_char(), '{');\n-\n-        assert!('0'.to_ascii().is_digit());\n-        assert!('9'.to_ascii().is_digit());\n-        assert!(!'/'.to_ascii().is_digit());\n-        assert!(!':'.to_ascii().is_digit());\n-\n-        assert!((0x1fu8).to_ascii().is_control());\n-        assert!(!' '.to_ascii().is_control());\n-        assert!((0x7fu8).to_ascii().is_control());\n-\n-        assert!(\"banana\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n-    }\n-\n-    #[test]\n-    fn test_ascii_vec() {\n-        assert_eq!((&[40u8, 32u8, 59u8]).to_ascii(), v2ascii!([40, 32, 59]));\n-        assert_eq!(\"( ;\".to_ascii(),                 v2ascii!([40, 32, 59]));\n-        // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n-        // if chained-from directly\n-        let v = ~[40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n-        let v = ~\"( ;\";              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n-\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), ~\"abcdef&?#\");\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), ~\"ABCDEF&?#\");\n-\n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), ~\"\");\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), ~\"ymca\");\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), ~\"ABCDEFXYZ:.;\");\n-\n-        assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n-\n-        assert!(\"\".is_ascii());\n-        assert!(\"a\".is_ascii());\n-        assert!(!\"\\u2009\".is_ascii());\n-\n-    }\n-\n-    #[test]\n-    fn test_owned_ascii_vec() {\n-        assert_eq!((~\"( ;\").into_ascii(), v2ascii!(~[40, 32, 59]));\n-        assert_eq!((~[40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n-    }\n-\n-    #[test]\n-    fn test_ascii_as_str() {\n-        let v = v2ascii!([40, 32, 59]);\n-        assert_eq!(v.as_str_ascii(), \"( ;\");\n-    }\n-\n-    #[test]\n-    fn test_ascii_into_str() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), ~\"( ;\");\n-    }\n-\n-    #[test]\n-    fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), ~[40u8, 32u8, 59u8]);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_vec_fail_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_vec_fail_str_slice() { \"zo\u00e4\u534e\".to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_fail_u8_slice() { 255u8.to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_fail_char_slice() { '\u03bb'.to_ascii(); }\n-\n-    #[test]\n-    fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), ~\"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), ~\"H\u0131\u212a\u00df\");\n-\n-        let mut i = 0;\n-        while i <= 500 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()))\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), ~\"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), ~\"h\u0130\u212a\u00df\");\n-\n-        let mut i = 0;\n-        while i <= 500 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()))\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_ascii_upper() {\n-        assert_eq!((~\"url()URL()uRl()\u00fcrl\").into_ascii_upper(), ~\"URL()URL()URL()\u00fcRL\");\n-        assert_eq!((~\"h\u0131\u212a\u00df\").into_ascii_upper(), ~\"H\u0131\u212a\u00df\");\n-\n-        let mut i = 0;\n-        while i <= 500 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).into_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()))\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_ascii_lower() {\n-        assert_eq!((~\"url()URL()uRl()\u00dcrl\").into_ascii_lower(), ~\"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((~\"H\u0130\u212a\u00df\").into_ascii_lower(), ~\"h\u0130\u212a\u00df\");\n-\n-        let mut i = 0;\n-        while i <= 500 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).into_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()))\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eq_ignore_ascii_case() {\n-        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n-        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n-        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n-        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n-        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n-\n-        let mut i = 0;\n-        while i <= 500 {\n-            let c = i;\n-            let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n-                        else { c };\n-            assert!(from_char(from_u32(i).unwrap()).\n-                eq_ignore_ascii_case(from_char(from_u32(lower).unwrap())));\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_str() {\n-        let s = Ascii{ chr: 't' as u8 }.to_str();\n-        assert_eq!(s, ~\"t\");\n-    }\n-\n-\n-}"}, {"sha": "2b105a3fa7d2375bf593740beeedecd7f2ba0f6d", "filename": "libgrust/libstd/at_vec.rs", "status": "removed", "additions": 0, "deletions": 412, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fat_vec.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,412 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Managed vectors\n-\n-use clone::Clone;\n-use container::Container;\n-use iter::{Iterator, FromIterator};\n-use option::{Option, Some, None};\n-use mem;\n-use unstable::raw::Repr;\n-use vec::{ImmutableVector, OwnedVector};\n-\n-/// Code for dealing with @-vectors. This is pretty incomplete, and\n-/// contains a bunch of duplication from the code for ~-vectors.\n-\n-/// Returns the number of elements the vector can hold without reallocating\n-#[inline]\n-pub fn capacity<T>(v: @[T]) -> uint {\n-    unsafe {\n-        let box = v.repr();\n-        (*box).data.alloc / mem::size_of::<T>()\n-    }\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * The initial size for the vector may optionally be specified\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n-    let mut vec = @[];\n-    unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n-    builder(|x| unsafe { raw::push(&mut vec, x) });\n-    vec\n-}\n-\n-// Appending\n-\n-/// Iterates over the `rhs` vector, copying each element and appending it to the\n-/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline]\n-pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    build(Some(lhs.len() + rhs.len()), |push| {\n-        for x in lhs.iter() {\n-            push((*x).clone());\n-        }\n-        for elt in rhs.iter() {\n-            push(elt.clone());\n-        }\n-    })\n-}\n-\n-\n-/// Apply a function to each element of a vector and return the results\n-pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n-    build(Some(v.len()), |push| {\n-        for elem in v.iter() {\n-            push(f(elem));\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(op(i)); i += 1u; }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts {\n-            push(t.clone());\n-            i += 1u;\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by moving all the\n- * elements from an owned vector.\n- */\n-pub fn to_managed_move<T>(v: ~[T]) -> @[T] {\n-    let mut av = @[];\n-    unsafe {\n-        raw::reserve(&mut av, v.len());\n-        for x in v.move_iter() {\n-            raw::push(&mut av, x);\n-        }\n-        av\n-    }\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by copying all the\n- * elements of a slice.\n- */\n-pub fn to_managed<T:Clone>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| v[i].clone())\n-}\n-\n-impl<T> Clone for @[T] {\n-    fn clone(&self) -> @[T] {\n-        *self\n-    }\n-}\n-\n-impl<A> FromIterator<A> for @[A] {\n-    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n-        let (lower, _) = iterator.size_hint();\n-        build(Some(lower), |push| {\n-            for x in *iterator {\n-                push(x);\n-            }\n-        })\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use at_vec::append;\n-    use clone::Clone;\n-    use ops::Add;\n-    use vec::Vector;\n-\n-    impl<'self,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> @[T] {\n-            append(*self, rhs.as_slice())\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-#[allow(missing_doc)]\n-pub mod raw {\n-    use at_vec::capacity;\n-    use cast;\n-    use cast::{transmute, transmute_copy};\n-    use ptr;\n-    use mem;\n-    use uint;\n-    use unstable::intrinsics::{move_val_init, TyDesc};\n-    use unstable::intrinsics;\n-    use unstable::raw::{Box, Vec};\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    #[inline]\n-    pub unsafe fn set_len<T>(v: &mut @[T], new_len: uint) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        (*repr).data.fill = new_len * mem::size_of::<T>();\n-    }\n-\n-    /**\n-     * Pushes a new value onto this vector.\n-     */\n-    #[inline]\n-    pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n-        let full = {\n-            let repr: *Box<Vec<T>> = cast::transmute_copy(v);\n-            (*repr).data.alloc > (*repr).data.fill\n-        };\n-        if full {\n-            push_fast(v, initval);\n-        } else {\n-            push_slow(v, initval);\n-        }\n-    }\n-\n-    #[inline] // really pretty please\n-    unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        let amt = v.len();\n-        (*repr).data.fill += mem::size_of::<T>();\n-        let p = ptr::offset(&(*repr).data.data as *T, amt as int) as *mut T;\n-        move_val_init(&mut(*p), initval);\n-    }\n-\n-    unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n-        reserve_at_least(v, v.len() + 1u);\n-        push_fast(v, initval);\n-    }\n-\n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if capacity(*v) < n {\n-            let ptr: *mut *mut Box<Vec<()>> = transmute(v);\n-            let ty = intrinsics::get_tydesc::<T>();\n-            return reserve_raw(ty, ptr, n);\n-        }\n-    }\n-\n-    // Implementation detail. Shouldn't be public\n-    #[allow(missing_doc)]\n-    pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut Box<Vec<()>>, n: uint) {\n-        // check for `uint` overflow\n-        unsafe {\n-            if n > (**ptr).data.alloc / (*ty).size {\n-                let alloc = n * (*ty).size;\n-                let total_size = alloc + mem::size_of::<Vec<()>>();\n-                if alloc / (*ty).size != n || total_size < alloc {\n-                    fail!(\"vector size is too large: {}\", n);\n-                }\n-                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n-                (**ptr).data.alloc = alloc;\n-            }\n-        }\n-\n-        fn local_realloc(ptr: *(), size: uint) -> *() {\n-            use rt::local::Local;\n-            use rt::task::Task;\n-\n-            Local::borrow(|task: &mut Task| {\n-                task.heap.realloc(ptr as *mut Box<()>, size) as *()\n-            })\n-        }\n-    }\n-\n-    /**\n-     * Reserves capacity for at least `n` elements in the given vector.\n-     *\n-     * This function will over-allocate in order to amortize the\n-     * allocation costs in scenarios where the caller may need to\n-     * repeatedly reserve additional space.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n-        reserve(v, uint::next_power_of_two(n));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use prelude::*;\n-    use bh = extra::test::BenchHarness;\n-\n-    #[test]\n-    fn test() {\n-        // Some code that could use that, then:\n-        fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            build(None, |push| {\n-                for i in range(lo, hi) {\n-                    push(i);\n-                }\n-            })\n-        }\n-\n-        assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-        assert_eq!(from_fn(5, |x| x+1), @[1, 2, 3, 4, 5]);\n-        assert_eq!(from_elem(5, 3.14), @[3.14, 3.14, 3.14, 3.14, 3.14]);\n-    }\n-\n-    #[test]\n-    fn append_test() {\n-        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed_move() {\n-        assert_eq!(to_managed_move::<int>(~[]), @[]);\n-        assert_eq!(to_managed_move(~[true]), @[true]);\n-        assert_eq!(to_managed_move(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed_move(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n-        assert_eq!(to_managed_move(~[~[42]]), @[~[42]]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed() {\n-        assert_eq!(to_managed::<int>([]), @[]);\n-        assert_eq!(to_managed([true]), @[true]);\n-        assert_eq!(to_managed([1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed([@\"abc\", @\"123\"]), @[@\"abc\", @\"123\"]);\n-        assert_eq!(to_managed([@[42]]), @[@[42]]);\n-    }\n-\n-    #[bench]\n-    fn bench_capacity(b: &mut bh) {\n-        let x = @[1, 2, 3];\n-        b.iter(|| {\n-            let _ = capacity(x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build_sized(b: &mut bh) {\n-        let len = 64;\n-        b.iter(|| {\n-            build(Some(len), |push| for i in range(0, 1024) { push(i) });\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build(b: &mut bh) {\n-        b.iter(|| {\n-            for i in range(0, 95) {\n-                build(None, |push| push(i));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_append(b: &mut bh) {\n-        let lhs = @[7, ..128];\n-        let rhs = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = append(lhs, rhs);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_map(b: &mut bh) {\n-        let elts = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = map(elts, |x| x*2);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_fn(1024, |x| x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_elem(1024, 0u64);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed_move(b: &mut bh) {\n-        b.iter(|| {\n-            let elts = range(0, 1024).to_owned_vec(); // yikes! can't move out of capture, though\n-            to_managed_move(elts);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed(b: &mut bh) {\n-        let elts = range(0, 1024).to_owned_vec();\n-        b.iter(|| {\n-            let _ = to_managed(elts);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_clone(b: &mut bh) {\n-        let elts = to_managed(range(0, 1024).to_owned_vec());\n-        b.iter(|| {\n-            let _ = elts.clone();\n-        });\n-    }\n-}"}, {"sha": "29c304f9ac539a3d12bb63c93bba8764d0028c60", "filename": "libgrust/libstd/bool.rs", "status": "removed", "additions": 0, "deletions": 445, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fbool.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,445 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `bool` module contains useful code to help work with boolean values.\n-//!\n-//! A quick summary:\n-//!\n-//! ## Trait implementations for `bool`\n-//!\n-//! Implementations of the following traits:\n-//!\n-//! * `FromStr`\n-//! * `ToStr`\n-//! * `Not`\n-//! * `Ord`\n-//! * `TotalOrd`\n-//! * `Eq`\n-//! * `Default`\n-//! * `Zero`\n-//!\n-//! ## Various functions to compare `bool`s\n-//!\n-//! All of the standard comparison functions one would expect: `and`, `eq`, `or`,\n-//! and more.\n-//!\n-//! Also, a few conversion functions: `to_bit` and `to_str`.\n-\n-use option::{None, Option, Some};\n-use from_str::FromStr;\n-use to_str::ToStr;\n-use num::FromPrimitive;\n-\n-#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n-#[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Freestanding functions\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Iterates over all truth values, passing them to the given block.\n-///\n-/// There are no guarantees about the order values will be given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// std::bool::all_values(|x: bool| {\n-///     println(x.to_str());\n-/// })\n-/// ```\n-#[inline]\n-pub fn all_values(blk: |v: bool|) {\n-    blk(true);\n-    blk(false);\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Methods on `bool`\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods on a `bool`\n-pub trait Bool {\n-    /// Conjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.and(true), true);\n-    /// assert_eq!(true.and(false), false);\n-    /// assert_eq!(false.and(true), false);\n-    /// assert_eq!(false.and(false), false);\n-    /// ```\n-    fn and(self, b: bool) -> bool;\n-\n-    /// Disjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.or(true), true);\n-    /// assert_eq!(true.or(false), true);\n-    /// assert_eq!(false.or(true), true);\n-    /// assert_eq!(false.or(false), false);\n-    /// ```\n-    fn or(self, b: bool) -> bool;\n-\n-    /// An 'exclusive or' of two boolean values.\n-    ///\n-    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.xor(true), false);\n-    /// assert_eq!(true.xor(false), true);\n-    /// assert_eq!(false.xor(true), true);\n-    /// assert_eq!(false.xor(false), false);\n-    /// ```\n-    fn xor(self, b: bool) -> bool;\n-\n-    /// Implication between two boolean values.\n-    ///\n-    /// Implication is often phrased as 'if a then b.'\n-    ///\n-    /// 'if a then b' is equivalent to `!a || b`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.implies(true), true);\n-    /// assert_eq!(true.implies(false), false);\n-    /// assert_eq!(false.implies(true), true);\n-    /// assert_eq!(false.implies(false), true);\n-    /// ```\n-    fn implies(self, b: bool) -> bool;\n-\n-    /// Convert a `bool` to a `u8`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.to_bit::<u8>(), 1u8);\n-    /// assert_eq!(false.to_bit::<u8>(), 0u8);\n-    /// ```\n-    fn to_bit<N: FromPrimitive>(self) -> N;\n-}\n-\n-impl Bool for bool {\n-    #[inline]\n-    fn and(self, b: bool) -> bool { self && b }\n-\n-    #[inline]\n-    fn or(self, b: bool) -> bool { self || b }\n-\n-    #[inline]\n-    fn xor(self, b: bool) -> bool { self ^ b }\n-\n-    #[inline]\n-    fn implies(self, b: bool) -> bool { !self || b }\n-\n-    #[inline]\n-    fn to_bit<N: FromPrimitive>(self) -> N {\n-        if self { FromPrimitive::from_u8(1).unwrap() }\n-        else    { FromPrimitive::from_u8(0).unwrap() }\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Trait impls on `bool`\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl FromStr for bool {\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n-        match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n-        }\n-    }\n-}\n-\n-impl ToStr for bool {\n-    /// Convert a `bool` to a string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.to_str(), ~\"true\");\n-    /// assert_eq!(false.to_str(), ~\"false\");\n-    /// ```\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        if *self { ~\"true\" } else { ~\"false\" }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<bool> for bool {\n-    /// The logical complement of a boolean value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(!true, false);\n-    /// assert_eq!(!false, true);\n-    /// ```\n-    #[inline]\n-    fn not(&self) -> bool { !*self }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<bool, bool> for bool {\n-    /// Conjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitand(&false), false);\n-    /// assert_eq!(true.bitand(&false), false);\n-    /// assert_eq!(false.bitand(&true), false);\n-    /// assert_eq!(true.bitand(&true), true);\n-    ///\n-    /// assert_eq!(false & false, false);\n-    /// assert_eq!(true & false, false);\n-    /// assert_eq!(false & true, false);\n-    /// assert_eq!(true & true, true);\n-    /// ```\n-    #[inline]\n-    fn bitand(&self, b: &bool) -> bool { *self & *b }\n-}\n-\n-#[cfg(not(test))]\n-impl BitOr<bool, bool> for bool {\n-    /// Disjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitor(&false), false);\n-    /// assert_eq!(true.bitor(&false), true);\n-    /// assert_eq!(false.bitor(&true), true);\n-    /// assert_eq!(true.bitor(&true), true);\n-    ///\n-    /// assert_eq!(false | false, false);\n-    /// assert_eq!(true | false, true);\n-    /// assert_eq!(false | true, true);\n-    /// assert_eq!(true | true, true);\n-    /// ```\n-    #[inline]\n-    fn bitor(&self, b: &bool) -> bool { *self | *b }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<bool, bool> for bool {\n-    /// An 'exclusive or' of two boolean values.\n-    ///\n-    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitxor(&false), false);\n-    /// assert_eq!(true.bitxor(&false), true);\n-    /// assert_eq!(false.bitxor(&true), true);\n-    /// assert_eq!(true.bitxor(&true), false);\n-    ///\n-    /// assert_eq!(false ^ false, false);\n-    /// assert_eq!(true ^ false, true);\n-    /// assert_eq!(false ^ true, true);\n-    /// assert_eq!(true ^ true, false);\n-    /// ```\n-    #[inline]\n-    fn bitxor(&self, b: &bool) -> bool { *self ^ *b }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for bool {\n-    #[inline]\n-    fn lt(&self, other: &bool) -> bool { self.to_bit::<u8>() < other.to_bit() }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for bool {\n-    #[inline]\n-    fn cmp(&self, other: &bool) -> Ordering { self.to_bit::<u8>().cmp(&other.to_bit()) }\n-}\n-\n-/// Equality between two boolean values.\n-///\n-/// Two booleans are equal if they have the same value.\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// assert_eq!(false.eq(&true), false);\n-/// assert_eq!(false == false, true);\n-/// assert_eq!(false != true, true);\n-/// assert_eq!(false.ne(&false), false);\n-/// ```\n-#[cfg(not(test))]\n-impl Eq for bool {\n-    #[inline]\n-    fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Default for bool {\n-    fn default() -> bool { false }\n-}\n-\n-#[cfg(not(test))]\n-impl Zero for bool {\n-    fn zero() -> bool { false }\n-    fn is_zero(&self) -> bool { *self == false }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use cmp::{Equal, Greater, Less, Eq, TotalOrd};\n-    use ops::{BitAnd, BitXor, BitOr};\n-    use from_str::{FromStr, from_str};\n-    use option::{Some, None};\n-    use super::all_values;\n-\n-    #[test]\n-    fn test_bool() {\n-        assert_eq!(false.eq(&true), false);\n-        assert_eq!(false == false, true);\n-        assert_eq!(false != true, true);\n-        assert_eq!(false.ne(&false), false);\n-\n-        assert_eq!(false.bitand(&false), false);\n-        assert_eq!(true.bitand(&false), false);\n-        assert_eq!(false.bitand(&true), false);\n-        assert_eq!(true.bitand(&true), true);\n-\n-        assert_eq!(false & false, false);\n-        assert_eq!(true & false, false);\n-        assert_eq!(false & true, false);\n-        assert_eq!(true & true, true);\n-\n-        assert_eq!(false.bitor(&false), false);\n-        assert_eq!(true.bitor(&false), true);\n-        assert_eq!(false.bitor(&true), true);\n-        assert_eq!(true.bitor(&true), true);\n-\n-        assert_eq!(false | false, false);\n-        assert_eq!(true | false, true);\n-        assert_eq!(false | true, true);\n-        assert_eq!(true | true, true);\n-\n-        assert_eq!(false.bitxor(&false), false);\n-        assert_eq!(true.bitxor(&false), true);\n-        assert_eq!(false.bitxor(&true), true);\n-        assert_eq!(true.bitxor(&true), false);\n-\n-        assert_eq!(false ^ false, false);\n-        assert_eq!(true ^ false, true);\n-        assert_eq!(false ^ true, true);\n-        assert_eq!(true ^ true, false);\n-\n-        assert_eq!(!true, false);\n-        assert_eq!(!false, true);\n-\n-        assert_eq!(true.to_str(), ~\"true\");\n-        assert_eq!(false.to_str(), ~\"false\");\n-\n-        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-\n-        assert_eq!(true.and(true), true);\n-        assert_eq!(true.and(false), false);\n-        assert_eq!(false.and(true), false);\n-        assert_eq!(false.and(false), false);\n-\n-        assert_eq!(true.or(true), true);\n-        assert_eq!(true.or(false), true);\n-        assert_eq!(false.or(true), true);\n-        assert_eq!(false.or(false), false);\n-\n-        assert_eq!(true.xor(true), false);\n-        assert_eq!(true.xor(false), true);\n-        assert_eq!(false.xor(true), true);\n-        assert_eq!(false.xor(false), false);\n-\n-        assert_eq!(true.implies(true), true);\n-        assert_eq!(true.implies(false), false);\n-        assert_eq!(false.implies(true), true);\n-        assert_eq!(false.implies(false), true);\n-\n-        assert_eq!(true.to_bit::<u8>(), 1u8);\n-        assert_eq!(false.to_bit::<u8>(), 0u8);\n-    }\n-\n-    #[test]\n-    fn test_bool_from_str() {\n-        all_values(|v| {\n-            assert!(Some(v) == FromStr::from_str(v.to_str()))\n-        });\n-    }\n-\n-    #[test]\n-    fn test_bool_to_str() {\n-        assert_eq!(false.to_str(), ~\"false\");\n-        assert_eq!(true.to_str(), ~\"true\");\n-    }\n-\n-    #[test]\n-    fn test_bool_to_bit() {\n-        all_values(|v| {\n-            assert_eq!(v.to_bit::<u8>(), if v { 1u8 } else { 0u8 });\n-            assert_eq!(v.to_bit::<uint>(), if v { 1u } else { 0u });\n-            assert_eq!(v.to_bit::<int>(), if v { 1i } else { 0i });\n-        });\n-    }\n-\n-    #[test]\n-    fn test_bool_ord() {\n-        assert!(true > false);\n-        assert!(!(false > true));\n-\n-        assert!(false < true);\n-        assert!(!(true < false));\n-\n-        assert!(false <= false);\n-        assert!(false >= false);\n-        assert!(true <= true);\n-        assert!(true >= true);\n-\n-        assert!(false <= true);\n-        assert!(!(false >= true));\n-        assert!(true >= false);\n-        assert!(!(true <= false));\n-    }\n-\n-    #[test]\n-    fn test_bool_totalord() {\n-        assert_eq!(true.cmp(&true), Equal);\n-        assert_eq!(false.cmp(&false), Equal);\n-        assert_eq!(true.cmp(&false), Greater);\n-        assert_eq!(false.cmp(&true), Less);\n-    }\n-}"}, {"sha": "0626b3fc6183c5ff56044421788139c3dae4051e", "filename": "libgrust/libstd/borrow.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fborrow.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Borrowed pointer utilities\n-\n-#[cfg(not(test))]\n-use prelude::*;\n-\n-/// Cast a region pointer - &T - to a uint.\n-#[inline]\n-pub fn to_uint<T>(thing: &T) -> uint {\n-    thing as *T as uint\n-}\n-\n-/// Determine if two borrowed pointers point to the same thing.\n-#[inline]\n-pub fn ref_eq<'a, 'b, T>(thing: &'a T, other: &'b T) -> bool {\n-    (thing as *T) == (other as *T)\n-}\n-\n-// Equality for region pointers\n-#[cfg(not(test))]\n-impl<'self, T: Eq> Eq for &'self T {\n-    #[inline]\n-    fn eq(&self, other: & &'self T) -> bool {\n-        *(*self) == *(*other)\n-    }\n-    #[inline]\n-    fn ne(&self, other: & &'self T) -> bool {\n-        *(*self) != *(*other)\n-    }\n-}\n-\n-// Comparison for region pointers\n-#[cfg(not(test))]\n-impl<'self, T: Ord> Ord for &'self T {\n-    #[inline]\n-    fn lt(&self, other: & &'self T) -> bool {\n-        *(*self) < *(*other)\n-    }\n-    #[inline]\n-    fn le(&self, other: & &'self T) -> bool {\n-        *(*self) <= *(*other)\n-    }\n-    #[inline]\n-    fn ge(&self, other: & &'self T) -> bool {\n-        *(*self) >= *(*other)\n-    }\n-    #[inline]\n-    fn gt(&self, other: & &'self T) -> bool {\n-        *(*self) > *(*other)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, T: TotalOrd> TotalOrd for &'self T {\n-    #[inline]\n-    fn cmp(&self, other: & &'self T) -> Ordering { (**self).cmp(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, T: TotalEq> TotalEq for &'self T {\n-    #[inline]\n-    fn equals(&self, other: & &'self T) -> bool { (**self).equals(*other) }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::ref_eq;\n-\n-    #[test]\n-    fn test_ref_eq() {\n-        let x = 1;\n-        let y = 1;\n-\n-        assert!(ref_eq(&x, &x));\n-        assert!(!ref_eq(&x, &y));\n-    }\n-}"}, {"sha": "306ee331929bb70bc95eb1e47b40ab8a8b552938", "filename": "libgrust/libstd/c_str.rs", "status": "removed", "additions": 0, "deletions": 686, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fc_str.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,686 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-C-string manipulation and management\n-\n-This modules provides the basic methods for creating and manipulating\n-null-terminated strings for use with FFI calls (back to C). Most C APIs require\n-that the string being passed to them is null-terminated, and by default rust's\n-string types are *not* null terminated.\n-\n-The other problem with translating Rust strings to C strings is that Rust\n-strings can validly contain a null-byte in the middle of the string (0 is a\n-valid unicode codepoint). This means that not all Rust strings can actually be\n-translated to C strings.\n-\n-# Creation of a C string\n-\n-A C string is managed through the `CString` type defined in this module. It\n-\"owns\" the internal buffer of characters and will automatically deallocate the\n-buffer when the string is dropped. The `ToCStr` trait is implemented for `&str`\n-and `&[u8]`, but the conversions can fail due to some of the limitations\n-explained above.\n-\n-This also means that currently whenever a C string is created, an allocation\n-must be performed to place the data elsewhere (the lifetime of the C string is\n-not tied to the lifetime of the original string/data buffer). If C strings are\n-heavily used in applications, then caching may be advisable to prevent\n-unnecessary amounts of allocations.\n-\n-An example of creating and using a C string would be:\n-\n-```rust\n-use std::libc;\n-extern {\n-    fn puts(s: *libc::c_char);\n-}\n-\n-let my_string = \"Hello, world!\";\n-\n-// Allocate the C string with an explicit local that owns the string. The\n-// `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n-let my_c_string = my_string.to_c_str();\n-my_c_string.with_ref(|c_buffer| {\n-    unsafe { puts(c_buffer); }\n-})\n-\n-// Don't save off the allocation of the C string, the `c_buffer` will be\n-// deallocated when this block returns!\n-my_string.with_c_str(|c_buffer| {\n-    unsafe { puts(c_buffer); }\n-})\n- ```\n-\n-*/\n-\n-use cast;\n-use container::Container;\n-use iter::{Iterator, range};\n-use libc;\n-use ops::Drop;\n-use option::{Option, Some, None};\n-use ptr::RawPtr;\n-use ptr;\n-use str::StrSlice;\n-use str;\n-use vec::{CopyableVector, ImmutableVector, MutableVector};\n-use vec;\n-use unstable::intrinsics;\n-\n-/// Resolution options for the `null_byte` condition\n-pub enum NullByteResolution {\n-    /// Truncate at the null byte\n-    Truncate,\n-    /// Use a replacement byte\n-    ReplaceWith(libc::c_char)\n-}\n-\n-condition! {\n-    // This should be &[u8] but there's a lifetime issue (#5370).\n-    pub null_byte: (~[u8]) -> NullByteResolution;\n-}\n-\n-/// The representation of a C String.\n-///\n-/// This structure wraps a `*libc::c_char`, and will automatically free the\n-/// memory it is pointing to when it goes out of scope.\n-pub struct CString {\n-    priv buf: *libc::c_char,\n-    priv owns_buffer_: bool,\n-}\n-\n-impl CString {\n-    /// Create a C String from a pointer.\n-    pub unsafe fn new(buf: *libc::c_char, owns_buffer: bool) -> CString {\n-        CString { buf: buf, owns_buffer_: owns_buffer }\n-    }\n-\n-    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n-    /// Any ownership of the buffer by the `CString` wrapper is forgotten.\n-    pub unsafe fn unwrap(self) -> *libc::c_char {\n-        let mut c_str = self;\n-        c_str.owns_buffer_ = false;\n-        c_str.buf\n-    }\n-\n-    /// Calls a closure with a reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n-    pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n-        f(self.buf)\n-    }\n-\n-    /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n-    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n-        f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n-    }\n-\n-    /// Returns true if the CString is a null.\n-    pub fn is_null(&self) -> bool {\n-        self.buf.is_null()\n-    }\n-\n-    /// Returns true if the CString is not null.\n-    pub fn is_not_null(&self) -> bool {\n-        self.buf.is_not_null()\n-    }\n-\n-    /// Returns whether or not the `CString` owns the buffer.\n-    pub fn owns_buffer(&self) -> bool {\n-        self.owns_buffer_\n-    }\n-\n-    /// Converts the CString into a `&[u8]` without copying.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n-    #[inline]\n-    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n-        unsafe {\n-            cast::transmute((self.buf, self.len() + 1))\n-        }\n-    }\n-\n-    /// Converts the CString into a `&str` without copying.\n-    /// Returns None if the CString is not UTF-8 or is null.\n-    #[inline]\n-    pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        if self.buf.is_null() { return None; }\n-        let buf = self.as_bytes();\n-        let buf = buf.slice_to(buf.len()-1); // chop off the trailing NUL\n-        str::from_utf8_slice_opt(buf)\n-    }\n-\n-    /// Return a CString iterator.\n-    pub fn iter<'a>(&'a self) -> CStringIterator<'a> {\n-        CStringIterator {\n-            ptr: self.buf,\n-            lifetime: unsafe { cast::transmute(self.buf) },\n-        }\n-    }\n-}\n-\n-impl Drop for CString {\n-    fn drop(&mut self) {\n-        if self.owns_buffer_ {\n-            unsafe {\n-                libc::free(self.buf as *libc::c_void)\n-            }\n-        }\n-    }\n-}\n-\n-impl Container for CString {\n-    #[inline]\n-    fn len(&self) -> uint {\n-        unsafe {\n-            ptr::position(self.buf, |c| *c == 0)\n-        }\n-    }\n-}\n-\n-/// A generic trait for converting a value to a CString.\n-pub trait ToCStr {\n-    /// Copy the receiver into a CString.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the receiver has an interior null.\n-    fn to_c_str(&self) -> CString;\n-\n-    /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n-    unsafe fn to_c_str_unchecked(&self) -> CString;\n-\n-    /// Work with a temporary CString constructed from the receiver.\n-    /// The provided `*libc::c_char` will be freed immediately upon return.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"PATH\".with_c_str(|path| libc::getenv(path))\n-    /// ```\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the receiver has an interior null.\n-    #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.to_c_str().with_ref(f)\n-    }\n-\n-    /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.to_c_str_unchecked().with_ref(f)\n-    }\n-}\n-\n-impl<'self> ToCStr for &'self str {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        self.as_bytes().to_c_str()\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_bytes().to_c_str_unchecked()\n-    }\n-\n-    #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.as_bytes().with_c_str(f)\n-    }\n-\n-    #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        self.as_bytes().with_c_str_unchecked(f)\n-    }\n-}\n-\n-// The length of the stack allocated buffer for `vec.with_c_str()`\n-static BUF_LEN: uint = 128;\n-\n-impl<'self> ToCStr for &'self [u8] {\n-    fn to_c_str(&self) -> CString {\n-        let mut cs = unsafe { self.to_c_str_unchecked() };\n-        cs.with_mut_ref(|buf| check_for_null(*self, buf));\n-        cs\n-    }\n-\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_imm_buf(|self_buf, self_len| {\n-            let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-            if buf.is_null() {\n-                fail!(\"failed to allocate memory!\");\n-            }\n-\n-            ptr::copy_memory(buf, self_buf, self_len);\n-            *ptr::mut_offset(buf, self_len as int) = 0;\n-\n-            CString::new(buf as *libc::c_char, true)\n-        })\n-    }\n-\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        unsafe { with_c_str(*self, true, f) }\n-    }\n-\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n-        with_c_str(*self, false, f)\n-    }\n-}\n-\n-// Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n-    if v.len() < BUF_LEN {\n-        let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n-        vec::bytes::copy_memory(buf, v, v.len());\n-        buf[v.len()] = 0;\n-\n-        buf.as_mut_buf(|buf, _| {\n-            if checked {\n-                check_for_null(v, buf as *mut libc::c_char);\n-            }\n-\n-            f(buf as *libc::c_char)\n-        })\n-    } else if checked {\n-        v.to_c_str().with_ref(f)\n-    } else {\n-        v.to_c_str_unchecked().with_ref(f)\n-    }\n-}\n-\n-#[inline]\n-fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n-    for i in range(0, v.len()) {\n-        unsafe {\n-            let p = buf.offset(i as int);\n-            if *p == 0 {\n-                match null_byte::cond.raise(v.to_owned()) {\n-                    Truncate => break,\n-                    ReplaceWith(c) => *p = c\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// External iterator for a CString's bytes.\n-///\n-/// Use with the `std::iter` module.\n-pub struct CStringIterator<'self> {\n-    priv ptr: *libc::c_char,\n-    priv lifetime: &'self libc::c_char, // FIXME: #5922\n-}\n-\n-impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n-    fn next(&mut self) -> Option<libc::c_char> {\n-        let ch = unsafe { *self.ptr };\n-        if ch == 0 {\n-            None\n-        } else {\n-            self.ptr = unsafe { ptr::offset(self.ptr, 1) };\n-            Some(ch)\n-        }\n-    }\n-}\n-\n-/// Parses a C \"multistring\", eg windows env values or\n-/// the req->ptr result in a uv_fs_readdir() call.\n-///\n-/// Optionally, a `count` can be passed in, limiting the\n-/// parsing to only being done `count`-times.\n-///\n-/// The specified closure is invoked with each string that\n-/// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring(buf: *libc::c_char,\n-                                 count: Option<uint>,\n-                                 f: |&CString|) -> uint {\n-\n-    let mut curr_ptr: uint = buf as uint;\n-    let mut ctr = 0;\n-    let (limited_count, limit) = match count {\n-        Some(limit) => (true, limit),\n-        None => (false, 0)\n-    };\n-    while ((limited_count && ctr < limit) || !limited_count)\n-          && *(curr_ptr as *libc::c_char) != 0 as libc::c_char {\n-        let cstr = CString::new(curr_ptr as *libc::c_char, false);\n-        f(&cstr);\n-        curr_ptr += cstr.len() + 1;\n-        ctr += 1;\n-    }\n-    return ctr;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use libc;\n-    use ptr;\n-    use option::{Some, None};\n-    use vec;\n-\n-    #[test]\n-    fn test_str_multistring_parsing() {\n-        unsafe {\n-            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n-            let ptr = vec::raw::to_ptr(input);\n-            let expected = [\"zero\", \"one\"];\n-            let mut it = expected.iter();\n-            let result = from_c_multistring(ptr as *libc::c_char, None, |c| {\n-                let cbytes = c.as_bytes().slice_to(c.len());\n-                assert_eq!(cbytes, it.next().unwrap().as_bytes());\n-            });\n-            assert_eq!(result, 2);\n-            assert!(it.next().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_str_to_c_str() {\n-        \"\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n-        });\n-\n-        \"hello\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_vec_to_c_str() {\n-        let b: &[u8] = [];\n-        b.to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n-        });\n-\n-        let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n-            }\n-        });\n-\n-        let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'f' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 1), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 2), 'o' as libc::c_char);\n-                assert_eq!(*ptr::offset(buf, 3), 0xff);\n-                assert_eq!(*ptr::offset(buf, 4), 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_is_null() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        assert!(c_str.is_null());\n-        assert!(!c_str.is_not_null());\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        let c_str = \"hello\".to_c_str();\n-        unsafe { libc::free(c_str.unwrap() as *libc::c_void) }\n-    }\n-\n-    #[test]\n-    fn test_with_ref() {\n-        let c_str = \"hello\".to_c_str();\n-        let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n-        assert!(!c_str.is_null());\n-        assert!(c_str.is_not_null());\n-        assert_eq!(len, 5);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_with_ref_empty_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.with_ref(|_| ());\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let c_str = \"\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), None);\n-\n-        let c_str = \"hello\".to_c_str();\n-        let mut iter = c_str.iter();\n-        assert_eq!(iter.next(), Some('h' as libc::c_char));\n-        assert_eq!(iter.next(), Some('e' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('l' as libc::c_char));\n-        assert_eq!(iter.next(), Some('o' as libc::c_char));\n-        assert_eq!(iter.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_fail() {\n-        use c_str::null_byte::cond;\n-\n-        let mut error_happened = false;\n-        cond.trap(|err| {\n-            assert_eq!(err, bytes!(\"he\", 0, \"llo\").to_owned())\n-            error_happened = true;\n-            Truncate\n-        }).inside(|| \"he\\x00llo\".to_c_str());\n-        assert!(error_happened);\n-\n-        cond.trap(|_| {\n-            ReplaceWith('?' as libc::c_char)\n-        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), '?' as libc::c_char);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(6), 0);\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_to_c_str_unchecked() {\n-        unsafe {\n-            \"he\\x00llo\".to_c_str_unchecked().with_ref(|buf| {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), 0);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(6), 0);\n-            })\n-        }\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"hello\", 0));\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(0));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"foo\", 0xff, 0));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_as_bytes_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_bytes();\n-    }\n-\n-    #[test]\n-    fn test_as_str() {\n-        let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"hello\"));\n-        let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_str(), Some(\"\"));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_str(), None);\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        assert_eq!(c_str.as_str(), None);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    use iter::range;\n-    use libc;\n-    use option::Some;\n-    use ptr;\n-    use extra::test::BenchHarness;\n-\n-    #[inline]\n-    fn check(s: &str, c_str: *libc::c_char) {\n-        s.as_imm_buf(|s_buf, s_len| {\n-            for i in range(0, s_len) {\n-                unsafe {\n-                    assert_eq!(\n-                        *ptr::offset(s_buf, i as int) as libc::c_char,\n-                        *ptr::offset(c_str, i as int));\n-                }\n-            }\n-        })\n-    }\n-\n-    static s_short: &'static str = \"Mary\";\n-    static s_medium: &'static str = \"Mary had a little lamb\";\n-    static s_long: &'static str = \"\\\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\n-        Mary had a little lamb, Little lamb\";\n-\n-    fn bench_to_str(bh: &mut BenchHarness, s: &str) {\n-        bh.iter(|| {\n-            let c_str = s.to_c_str();\n-            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_short(bh: &mut BenchHarness) {\n-        bench_to_str(bh, s_short)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_medium(bh: &mut BenchHarness) {\n-        bench_to_str(bh, s_medium)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_long(bh: &mut BenchHarness) {\n-        bench_to_str(bh, s_long)\n-    }\n-\n-    fn bench_to_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        bh.iter(|| {\n-            let c_str = unsafe { s.to_c_str_unchecked() };\n-            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_short(bh: &mut BenchHarness) {\n-        bench_to_c_str_unchecked(bh, s_short)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_medium(bh: &mut BenchHarness) {\n-        bench_to_c_str_unchecked(bh, s_medium)\n-    }\n-\n-    #[bench]\n-    fn bench_to_c_str_unchecked_long(bh: &mut BenchHarness) {\n-        bench_to_c_str_unchecked(bh, s_long)\n-    }\n-\n-    fn bench_with_c_str(bh: &mut BenchHarness, s: &str) {\n-        bh.iter(|| {\n-            s.with_c_str(|c_str_buf| check(s, c_str_buf))\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_short(bh: &mut BenchHarness) {\n-        bench_with_c_str(bh, s_short)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_medium(bh: &mut BenchHarness) {\n-        bench_with_c_str(bh, s_medium)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_long(bh: &mut BenchHarness) {\n-        bench_with_c_str(bh, s_long)\n-    }\n-\n-    fn bench_with_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        bh.iter(|| {\n-            unsafe {\n-                s.with_c_str_unchecked(|c_str_buf| check(s, c_str_buf))\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_short(bh: &mut BenchHarness) {\n-        bench_with_c_str_unchecked(bh, s_short)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_medium(bh: &mut BenchHarness) {\n-        bench_with_c_str_unchecked(bh, s_medium)\n-    }\n-\n-    #[bench]\n-    fn bench_with_c_str_unchecked_long(bh: &mut BenchHarness) {\n-        bench_with_c_str_unchecked(bh, s_long)\n-    }\n-}"}, {"sha": "bc4579c00a00c85ccc0a8ad463e44e1afa8df146", "filename": "libgrust/libstd/cast.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcast.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,159 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unsafe casting functions\n-\n-use ptr::RawPtr;\n-use mem;\n-use unstable::intrinsics;\n-use ptr::copy_nonoverlapping_memory;\n-\n-/// Casts the value at `src` to U. The two types must have the same length.\n-#[inline]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = intrinsics::uninit();\n-    let dest_ptr: *mut u8 = transmute(&mut dest);\n-    let src_ptr: *u8 = transmute(src);\n-    copy_nonoverlapping_memory(dest_ptr, src_ptr, mem::size_of::<U>());\n-    dest\n-}\n-\n-/**\n- * Move a thing into the void\n- *\n- * The forget function will take ownership of the provided value but neglect\n- * to run any required cleanup or memory-management operations on it. This\n- * can be used for various acts of magick.\n- */\n-#[inline]\n-pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }\n-\n-/**\n- * Force-increment the reference count on a shared box. If used\n- * carelessly, this can leak the box.\n- */\n-#[inline]\n-pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n-\n-/**\n- * Transform a value of one type into a value of another type.\n- * Both types must have the same size and alignment.\n- *\n- * # Example\n- *\n- * ```rust\n- * let v: &[u8] = transmute(\"L\");\n- * assert!(v == [76u8]);\n- * ```\n- */\n-#[inline]\n-pub unsafe fn transmute<L, G>(thing: L) -> G {\n-    intrinsics::transmute(thing)\n-}\n-\n-/// Coerce an immutable reference to be mutable.\n-#[inline]\n-pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n-\n-/// Coerce a mutable reference to be immutable.\n-#[inline]\n-pub unsafe fn transmute_immut<'a,T>(ptr: &'a mut T) -> &'a T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce a borrowed pointer to have an arbitrary associated region.\n-#[inline]\n-pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce an immutable reference to be mutable.\n-#[inline]\n-pub unsafe fn transmute_mut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *mut T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce an immutable reference to be mutable.\n-#[inline]\n-pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n-    transmute(ptr)\n-}\n-\n-/// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n-#[inline]\n-pub unsafe fn transmute_mut_region<'a,'b,T>(ptr: &'a mut T) -> &'b mut T {\n-    transmute(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_lifetime<'a,S,T>(_ptr: &'a S, ptr: &T) -> &'a T {\n-    transmute_region(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_mut_lifetime<'a,S,T>(_ptr: &'a mut S, ptr: &mut T) -> &'a mut T {\n-    transmute_mut_region(ptr)\n-}\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n-    transmute_region(ptr)\n-}\n-\n-\n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n-#[cfg(test)]\n-mod tests {\n-    use cast::{bump_box_refcount, transmute};\n-    use unstable::raw;\n-\n-    #[test]\n-    fn test_transmute_copy() {\n-        assert_eq!(1u, unsafe { ::cast::transmute_copy(&1) });\n-    }\n-\n-    #[test]\n-    fn test_bump_box_refcount() {\n-        unsafe {\n-            let box = @~\"box box box\";       // refcount 1\n-            bump_box_refcount(box);         // refcount 2\n-            let ptr: *int = transmute(box); // refcount 2\n-            let _box1: @~str = ::cast::transmute_copy(&ptr);\n-            let _box2: @~str = ::cast::transmute_copy(&ptr);\n-            assert!(*_box1 == ~\"box box box\");\n-            assert!(*_box2 == ~\"box box box\");\n-            // Will destroy _box1 and _box2. Without the bump, this would\n-            // use-after-free. With too many bumps, it would leak.\n-        }\n-    }\n-\n-    #[test]\n-    fn test_transmute() {\n-        unsafe {\n-            let x = @100u8;\n-            let x: *raw::Box<u8> = transmute(x);\n-            assert!((*x).data == 100);\n-            let _x: @int = transmute(x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_transmute2() {\n-        unsafe {\n-            assert_eq!(~[76u8], transmute(~\"L\"));\n-        }\n-    }\n-}"}, {"sha": "e49cf3e5303b3c585cae0c3865417900a747a1e3", "filename": "libgrust/libstd/cell.rs", "status": "removed", "additions": 0, "deletions": 366, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcell.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,366 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types dealing with dynamic mutability\n-\n-use prelude::*;\n-use cast;\n-use util::NonCopyable;\n-\n-\n-/*\n-A dynamic, mutable location.\n-\n-Similar to a mutable option type, but friendlier.\n-*/\n-\n-#[no_freeze]\n-#[deriving(Clone, DeepClone, Eq)]\n-#[allow(missing_doc)]\n-pub struct Cell<T> {\n-    priv value: Option<T>\n-}\n-\n-impl<T> Cell<T> {\n-    /// Creates a new full cell with the given value.\n-    pub fn new(value: T) -> Cell<T> {\n-        Cell { value: Some(value) }\n-    }\n-\n-    /// Yields the value, failing if the cell is empty.\n-    pub fn take(&self) -> T {\n-        let this = unsafe { cast::transmute_mut(self) };\n-        if this.is_empty() {\n-            fail!(\"attempt to take an empty cell\");\n-        }\n-\n-        this.value.take_unwrap()\n-    }\n-\n-    /// Yields the value if the cell is full, or `None` if it is empty.\n-    pub fn take_opt(&self) -> Option<T> {\n-        let this = unsafe { cast::transmute_mut(self) };\n-        this.value.take()\n-    }\n-\n-    /// Returns true if the cell is empty and false if the cell is full.\n-    pub fn is_empty(&self) -> bool {\n-        self.value.is_none()\n-    }\n-}\n-\n-#[test]\n-fn test_basic() {\n-    let value_cell = Cell::new(~10);\n-    assert!(!value_cell.is_empty());\n-    let value = value_cell.take();\n-    assert!(value == ~10);\n-    assert!(value_cell.is_empty());\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_take_empty() {\n-    let value_cell: Cell<~int> = Cell::new(~0);\n-    value_cell.take();\n-    value_cell.take();\n-}\n-\n-\n-/// A mutable memory location with dynamically checked borrow rules\n-#[no_freeze]\n-pub struct RefCell<T> {\n-    priv value: T,\n-    priv borrow: BorrowFlag,\n-    priv nc: NonCopyable\n-}\n-\n-// Values [1, MAX-1] represent the number of `Ref` active\n-// (will not outgrow its range since `uint` is the size of the address space)\n-type BorrowFlag = uint;\n-static UNUSED: BorrowFlag = 0;\n-static WRITING: BorrowFlag = -1;\n-\n-impl<T> RefCell<T> {\n-    /// Create a new `RefCell` containing `value`\n-    pub fn new(value: T) -> RefCell<T> {\n-        RefCell {\n-            value: value,\n-            borrow: UNUSED,\n-            nc: NonCopyable\n-        }\n-    }\n-\n-    /// Consumes the `RefCell`, returning the wrapped value.\n-    pub fn unwrap(self) -> T {\n-        assert!(self.borrow == UNUSED);\n-        self.value\n-    }\n-\n-    unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {\n-        cast::transmute_mut(self)\n-    }\n-\n-    /// Attempts to immutably borrow the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// Returns `None` if the value is currently mutably borrowed.\n-    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match self.borrow {\n-            WRITING => None,\n-            _ => {\n-                unsafe { self.as_mut().borrow += 1; }\n-                Some(Ref { parent: self })\n-            }\n-        }\n-    }\n-\n-    /// Immutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n-        match self.try_borrow() {\n-            Some(ptr) => ptr,\n-            None => fail!(\"RefCell<T> already mutably borrowed\")\n-        }\n-    }\n-\n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// Returns `None` if the value is currently borrowed.\n-    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match self.borrow {\n-            UNUSED => unsafe {\n-                let mut_self = self.as_mut();\n-                mut_self.borrow = WRITING;\n-                Some(RefMut { parent: mut_self })\n-            },\n-            _ => None\n-        }\n-    }\n-\n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts untile the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently borrowed.\n-    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n-        match self.try_borrow_mut() {\n-            Some(ptr) => ptr,\n-            None => fail!(\"RefCell<T> already borrowed\")\n-        }\n-    }\n-\n-    /// Immutably borrows the wrapped value and applies `blk` to it.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently mutably borrowed.\n-    #[inline]\n-    pub fn with<U>(&self, blk: |&T| -> U) -> U {\n-        let ptr = self.borrow();\n-        blk(ptr.get())\n-    }\n-\n-    /// Mutably borrows the wrapped value and applies `blk` to it.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is currently borrowed.\n-    #[inline]\n-    pub fn with_mut<U>(&self, blk: |&mut T| -> U) -> U {\n-        let mut ptr = self.borrow_mut();\n-        blk(ptr.get())\n-    }\n-}\n-\n-impl<T: Clone> Clone for RefCell<T> {\n-    fn clone(&self) -> RefCell<T> {\n-        let x = self.borrow();\n-        RefCell::new(x.get().clone())\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for RefCell<T> {\n-    fn deep_clone(&self) -> RefCell<T> {\n-        let x = self.borrow();\n-        RefCell::new(x.get().deep_clone())\n-    }\n-}\n-\n-impl<T: Eq> Eq for RefCell<T> {\n-    fn eq(&self, other: &RefCell<T>) -> bool {\n-        let a = self.borrow();\n-        let b = other.borrow();\n-        a.get() == b.get()\n-    }\n-}\n-\n-/// Wraps a borrowed reference to a value in a `RefCell` box.\n-pub struct Ref<'box, T> {\n-    priv parent: &'box RefCell<T>\n-}\n-\n-#[unsafe_destructor]\n-impl<'box, T> Drop for Ref<'box, T> {\n-    fn drop(&mut self) {\n-        assert!(self.parent.borrow != WRITING && self.parent.borrow != UNUSED);\n-        unsafe { self.parent.as_mut().borrow -= 1; }\n-    }\n-}\n-\n-impl<'box, T> Ref<'box, T> {\n-    /// Retrieve an immutable reference to the stored value.\n-    #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        &self.parent.value\n-    }\n-}\n-\n-/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-pub struct RefMut<'box, T> {\n-    priv parent: &'box mut RefCell<T>\n-}\n-\n-#[unsafe_destructor]\n-impl<'box, T> Drop for RefMut<'box, T> {\n-    fn drop(&mut self) {\n-        assert!(self.parent.borrow == WRITING);\n-        self.parent.borrow = UNUSED;\n-    }\n-}\n-\n-impl<'box, T> RefMut<'box, T> {\n-    /// Retrieve a mutable reference to the stored value.\n-    #[inline]\n-    pub fn get<'a>(&'a mut self) -> &'a mut T {\n-        &mut self.parent.value\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn double_imm_borrow() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn no_mut_then_imm_borrow() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow().is_none());\n-    }\n-\n-    #[test]\n-    fn no_imm_then_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn no_double_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn imm_release_borrow_mut() {\n-        let x = RefCell::new(0);\n-        {\n-            let _b1 = x.borrow();\n-        }\n-        x.borrow_mut();\n-    }\n-\n-    #[test]\n-    fn mut_release_borrow_mut() {\n-        let x = RefCell::new(0);\n-        {\n-            let _b1 = x.borrow_mut();\n-        }\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn double_borrow_single_release_no_borrow_mut() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        {\n-            let _b2 = x.borrow();\n-        }\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn with_ok() {\n-        let x = RefCell::new(0);\n-        assert_eq!(1, x.with(|x| *x+1));\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mut_borrow_with() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow_mut();\n-        x.with(|x| *x+1);\n-    }\n-\n-    #[test]\n-    fn borrow_with() {\n-        let x = RefCell::new(0);\n-        let _b1 = x.borrow();\n-        assert_eq!(1, x.with(|x| *x+1));\n-    }\n-\n-    #[test]\n-    fn with_mut_ok() {\n-        let x = RefCell::new(0);\n-        x.with_mut(|x| *x += 1);\n-        let b = x.borrow();\n-        assert_eq!(1, *b.get());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn borrow_with_mut() {\n-        let x = RefCell::new(0);\n-        let _b = x.borrow();\n-        x.with_mut(|x| *x += 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn discard_doesnt_unborrow() {\n-        let x = RefCell::new(0);\n-        let _b = x.borrow();\n-        let _ = _b;\n-        let _b = x.borrow_mut();\n-    }\n-}"}, {"sha": "3019e47c9f93e7e7be7e1486c8c1c62c5ee8f133", "filename": "libgrust/libstd/char.rs", "status": "removed", "additions": 0, "deletions": 570, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fchar.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,570 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utilities for manipulating the char type\n-\n-use cast::transmute;\n-use option::{None, Option, Some};\n-use iter::{Iterator, range_step};\n-use str::StrSlice;\n-use unicode::{derived_property, property, general_category, decompose};\n-use to_str::ToStr;\n-use str;\n-\n-#[cfg(test)] use str::OwnedStr;\n-\n-#[cfg(not(test))] use cmp::{Eq, Ord};\n-#[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n-\n-// UTF-8 ranges and tags for encoding characters\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n-\n-/*\n-    Lu  Uppercase_Letter        an uppercase letter\n-    Ll  Lowercase_Letter        a lowercase letter\n-    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n-    Lm  Modifier_Letter         a modifier letter\n-    Lo  Other_Letter            other letters, including syllables and ideographs\n-    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n-    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n-    Me  Enclosing_Mark          an enclosing combining mark\n-    Nd  Decimal_Number          a decimal digit\n-    Nl  Letter_Number           a letterlike numeric character\n-    No  Other_Number            a numeric character of other type\n-    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n-    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n-    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n-    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n-    Pi  Initial_Punctuation     an initial quotation mark\n-    Pf  Final_Punctuation       a final quotation mark\n-    Po  Other_Punctuation       a punctuation mark of other type\n-    Sm  Math_Symbol             a symbol of primarily mathematical use\n-    Sc  Currency_Symbol         a currency sign\n-    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n-    So  Other_Symbol            a symbol of other type\n-    Zs  Space_Separator         a space character (of various non-zero widths)\n-    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n-    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n-    Cc  Control                 a C0 or C1 control code\n-    Cf  Format                  a format control character\n-    Cs  Surrogate               a surrogate code point\n-    Co  Private_Use             a private-use character\n-    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n-*/\n-\n-/// The highest valid code point\n-pub static MAX: char = '\\U0010ffff';\n-\n-/// Convert from `u32` to a character.\n-pub fn from_u32(i: u32) -> Option<char> {\n-    // catch out-of-bounds and surrogates\n-    if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n-        None\n-    } else {\n-        Some(unsafe { transmute(i) })\n-    }\n-}\n-\n-/// Returns whether the specified character is considered a unicode alphabetic\n-/// character\n-pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n-#[allow(missing_doc)]\n-pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n-#[allow(missing_doc)]\n-pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n-\n-///\n-/// Indicates whether a character is in lower case, defined\n-/// in terms of the Unicode Derived Core Property 'Lowercase'.\n-///\n-#[inline]\n-pub fn is_lowercase(c: char) -> bool { derived_property::Lowercase(c) }\n-\n-///\n-/// Indicates whether a character is in upper case, defined\n-/// in terms of the Unicode Derived Core Property 'Uppercase'.\n-///\n-#[inline]\n-pub fn is_uppercase(c: char) -> bool { derived_property::Uppercase(c) }\n-\n-///\n-/// Indicates whether a character is whitespace. Whitespace is defined in\n-/// terms of the Unicode Property 'White_Space'.\n-///\n-#[inline]\n-pub fn is_whitespace(c: char) -> bool {\n-    // As an optimization ASCII whitespace characters are checked separately\n-    c == ' '\n-        || ('\\x09' <= c && c <= '\\x0d')\n-        || property::White_Space(c)\n-}\n-\n-///\n-/// Indicates whether a character is alphanumeric. Alphanumericness is\n-/// defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n-/// and the Derived Core Property 'Alphabetic'.\n-///\n-#[inline]\n-pub fn is_alphanumeric(c: char) -> bool {\n-    derived_property::Alphabetic(c)\n-        || general_category::Nd(c)\n-        || general_category::Nl(c)\n-        || general_category::No(c)\n-}\n-\n-///\n-/// Indicates whether a character is a control character. Control\n-/// characters are defined in terms of the Unicode General Category\n-/// 'Cc'.\n-///\n-#[inline]\n-pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n-\n-/// Indicates whether the character is numeric (Nd, Nl, or No)\n-#[inline]\n-pub fn is_digit(c: char) -> bool {\n-    general_category::Nd(c)\n-        || general_category::Nl(c)\n-        || general_category::No(c)\n-}\n-\n-///\n-/// Checks if a character parses as a numeric digit in the given radix.\n-/// Compared to `is_digit()`, this function only recognizes the\n-/// characters `0-9`, `a-z` and `A-Z`.\n-///\n-/// # Return value\n-///\n-/// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-/// otherwise.\n-///\n-/// # Failure\n-///\n-/// Fails if given a `radix` > 36.\n-///\n-/// # Note\n-///\n-/// This just wraps `to_digit()`.\n-///\n-#[inline]\n-pub fn is_digit_radix(c: char, radix: uint) -> bool {\n-    match to_digit(c, radix) {\n-        Some(_) => true,\n-        None    => false,\n-    }\n-}\n-\n-///\n-/// Convert a char to the corresponding digit.\n-///\n-/// # Return value\n-///\n-/// If `c` is between '0' and '9', the corresponding value\n-/// between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n-/// 'b' or 'B', 11, etc. Returns none if the char does not\n-/// refer to a digit in the given radix.\n-///\n-/// # Failure\n-///\n-/// Fails if given a `radix` outside the range `[0..36]`.\n-///\n-#[inline]\n-pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n-    if radix > 36 {\n-        fail!(\"to_digit: radix {} is too high (maximum 36)\", radix);\n-    }\n-    let val = match c {\n-      '0' .. '9' => c as uint - ('0' as uint),\n-      'a' .. 'z' => c as uint + 10u - ('a' as uint),\n-      'A' .. 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None,\n-    };\n-    if val < radix { Some(val) }\n-    else { None }\n-}\n-\n-///\n-/// Converts a number to the character representing it.\n-///\n-/// # Return value\n-///\n-/// Returns `Some(char)` if `num` represents one digit under `radix`,\n-/// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n-///\n-/// # Failure\n-///\n-/// Fails if given an `radix` > 36.\n-///\n-#[inline]\n-pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n-    if radix > 36 {\n-        fail!(\"from_digit: radix {} is to high (maximum 36)\", num);\n-    }\n-    if num < radix {\n-        unsafe {\n-            if num < 10 {\n-                Some(transmute(('0' as uint + num) as u32))\n-            } else {\n-                Some(transmute(('a' as uint + num - 10u) as u32))\n-            }\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-// Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n-static S_BASE: uint = 0xAC00;\n-static L_BASE: uint = 0x1100;\n-static V_BASE: uint = 0x1161;\n-static T_BASE: uint = 0x11A7;\n-static L_COUNT: uint = 19;\n-static V_COUNT: uint = 21;\n-static T_COUNT: uint = 28;\n-static N_COUNT: uint = (V_COUNT * T_COUNT);\n-static S_COUNT: uint = (L_COUNT * N_COUNT);\n-\n-// Decompose a precomposed Hangul syllable\n-fn decompose_hangul(s: char, f: |char|) {\n-    let si = s as uint - S_BASE;\n-\n-    let li = si / N_COUNT;\n-    unsafe {\n-        f(transmute((L_BASE + li) as u32));\n-\n-        let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute((V_BASE + vi) as u32));\n-\n-        let ti = si % T_COUNT;\n-        if ti > 0 {\n-            f(transmute((T_BASE + ti) as u32));\n-        }\n-    }\n-}\n-\n-/// Returns the canonical decompostion of a character\n-pub fn decompose_canonical(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n-        decompose::canonical(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n-/// Returns the compatibility decompostion of a character\n-pub fn decompose_compatible(c: char, f: |char|) {\n-    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n-        decompose::compatibility(c, f);\n-    } else {\n-        decompose_hangul(c, f);\n-    }\n-}\n-\n-///\n-/// Return the hexadecimal unicode escape of a char.\n-///\n-/// The rules are as follows:\n-///\n-/// - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n-/// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n-/// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n-///\n-pub fn escape_unicode(c: char, f: |char|) {\n-    // avoid calling str::to_str_radix because we don't really need to allocate\n-    // here.\n-    f('\\\\');\n-    let pad = match () {\n-        _ if c <= '\\xff'    => { f('x'); 2 }\n-        _ if c <= '\\uffff'  => { f('u'); 4 }\n-        _                   => { f('U'); 8 }\n-    };\n-    for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n-        unsafe {\n-            match ((c as i32) >> offset) & 0xf {\n-                i @ 0 .. 9 => { f(transmute('0' as i32 + i)); }\n-                i => { f(transmute('a' as i32 + (i - 10))); }\n-            }\n-        }\n-    }\n-}\n-\n-///\n-/// Return a 'default' ASCII and C++11-like char-literal escape of a char.\n-///\n-/// The default is chosen with a bias toward producing literals that are\n-/// legal in a variety of languages, including C++11 and similar C-family\n-/// languages. The exact rules are:\n-///\n-/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n-/// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n-///\n-pub fn escape_default(c: char, f: |char|) {\n-    match c {\n-        '\\t' => { f('\\\\'); f('t'); }\n-        '\\r' => { f('\\\\'); f('r'); }\n-        '\\n' => { f('\\\\'); f('n'); }\n-        '\\\\' => { f('\\\\'); f('\\\\'); }\n-        '\\'' => { f('\\\\'); f('\\''); }\n-        '\"'  => { f('\\\\'); f('\"'); }\n-        '\\x20' .. '\\x7e' => { f(c); }\n-        _ => c.escape_unicode(f),\n-    }\n-}\n-\n-/// Returns the amount of bytes this character would need if encoded in utf8\n-pub fn len_utf8_bytes(c: char) -> uint {\n-    static MAX_ONE_B:   uint = 128u;\n-    static MAX_TWO_B:   uint = 2048u;\n-    static MAX_THREE_B: uint = 65536u;\n-    static MAX_FOUR_B:  uint = 2097152u;\n-\n-    let code = c as uint;\n-    match () {\n-        _ if code < MAX_ONE_B   => 1u,\n-        _ if code < MAX_TWO_B   => 2u,\n-        _ if code < MAX_THREE_B => 3u,\n-        _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail!(\"invalid character!\"),\n-    }\n-}\n-\n-impl ToStr for char {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        str::from_char(*self)\n-    }\n-}\n-\n-#[allow(missing_doc)]\n-pub trait Char {\n-    fn is_alphabetic(&self) -> bool;\n-    fn is_XID_start(&self) -> bool;\n-    fn is_XID_continue(&self) -> bool;\n-    fn is_lowercase(&self) -> bool;\n-    fn is_uppercase(&self) -> bool;\n-    fn is_whitespace(&self) -> bool;\n-    fn is_alphanumeric(&self) -> bool;\n-    fn is_control(&self) -> bool;\n-    fn is_digit(&self) -> bool;\n-    fn is_digit_radix(&self, radix: uint) -> bool;\n-    fn to_digit(&self, radix: uint) -> Option<uint>;\n-    fn from_digit(num: uint, radix: uint) -> Option<char>;\n-    fn escape_unicode(&self, f: |char|);\n-    fn escape_default(&self, f: |char|);\n-    fn len_utf8_bytes(&self) -> uint;\n-\n-    /// Encodes this character as utf-8 into the provided byte-buffer. The\n-    /// buffer must be at least 4 bytes long or a runtime failure will occur.\n-    ///\n-    /// This will then return the number of characters written to the slice.\n-    fn encode_utf8(&self, dst: &mut [u8]) -> uint;\n-}\n-\n-impl Char for char {\n-    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n-\n-    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n-\n-    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n-\n-    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n-\n-    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n-\n-    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n-\n-    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n-\n-    fn is_control(&self) -> bool { is_control(*self) }\n-\n-    fn is_digit(&self) -> bool { is_digit(*self) }\n-\n-    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n-\n-    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n-\n-    fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n-\n-    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n-\n-    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n-\n-    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n-\n-    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n-        let code = *self as uint;\n-        if code < MAX_ONE_B {\n-            dst[0] = code as u8;\n-            return 1;\n-        } else if code < MAX_TWO_B {\n-            dst[0] = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-            dst[1] = (code & 63u | TAG_CONT) as u8;\n-            return 2;\n-        } else if code < MAX_THREE_B {\n-            dst[0] = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-            dst[1] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code & 63u | TAG_CONT) as u8;\n-            return 3;\n-        } else {\n-            dst[0] = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-            dst[1] = (code >> 12u & 63u | TAG_CONT) as u8;\n-            dst[2] = (code >> 6u & 63u | TAG_CONT) as u8;\n-            dst[3] = (code & 63u | TAG_CONT) as u8;\n-            return 4;\n-        }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for char {\n-    #[inline]\n-    fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for char {\n-    #[inline]\n-    fn lt(&self, other: &char) -> bool { *self < *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Default for char {\n-    #[inline]\n-    fn default() -> char { '\\x00' }\n-}\n-\n-#[cfg(not(test))]\n-impl Zero for char {\n-    #[inline]\n-    fn zero() -> char { '\\x00' }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == '\\x00' }\n-}\n-\n-#[test]\n-fn test_is_lowercase() {\n-    assert!('a'.is_lowercase());\n-    assert!('\u00f6'.is_lowercase());\n-    assert!('\u00df'.is_lowercase());\n-    assert!(!'\u00dc'.is_lowercase());\n-    assert!(!'P'.is_lowercase());\n-}\n-\n-#[test]\n-fn test_is_uppercase() {\n-    assert!(!'h'.is_uppercase());\n-    assert!(!'\u00e4'.is_uppercase());\n-    assert!(!'\u00df'.is_uppercase());\n-    assert!('\u00d6'.is_uppercase());\n-    assert!('T'.is_uppercase());\n-}\n-\n-#[test]\n-fn test_is_whitespace() {\n-    assert!(' '.is_whitespace());\n-    assert!('\\u2007'.is_whitespace());\n-    assert!('\\t'.is_whitespace());\n-    assert!('\\n'.is_whitespace());\n-    assert!(!'a'.is_whitespace());\n-    assert!(!'_'.is_whitespace());\n-    assert!(!'\\u0000'.is_whitespace());\n-}\n-\n-#[test]\n-fn test_to_digit() {\n-    assert_eq!('0'.to_digit(10u), Some(0u));\n-    assert_eq!('1'.to_digit(2u), Some(1u));\n-    assert_eq!('2'.to_digit(3u), Some(2u));\n-    assert_eq!('9'.to_digit(10u), Some(9u));\n-    assert_eq!('a'.to_digit(16u), Some(10u));\n-    assert_eq!('A'.to_digit(16u), Some(10u));\n-    assert_eq!('b'.to_digit(16u), Some(11u));\n-    assert_eq!('B'.to_digit(16u), Some(11u));\n-    assert_eq!('z'.to_digit(36u), Some(35u));\n-    assert_eq!('Z'.to_digit(36u), Some(35u));\n-    assert_eq!(' '.to_digit(10u), None);\n-    assert_eq!('$'.to_digit(36u), None);\n-}\n-\n-#[test]\n-fn test_is_control() {\n-    assert!('\\u0000'.is_control());\n-    assert!('\\u0003'.is_control());\n-    assert!('\\u0006'.is_control());\n-    assert!('\\u0009'.is_control());\n-    assert!('\\u007f'.is_control());\n-    assert!('\\u0092'.is_control());\n-    assert!(!'\\u0020'.is_control());\n-    assert!(!'\\u0055'.is_control());\n-    assert!(!'\\u0068'.is_control());\n-}\n-\n-#[test]\n-fn test_is_digit() {\n-   assert!('2'.is_digit());\n-   assert!('7'.is_digit());\n-   assert!(!'c'.is_digit());\n-   assert!(!'i'.is_digit());\n-   assert!(!'z'.is_digit());\n-   assert!(!'Q'.is_digit());\n-}\n-\n-#[test]\n-fn test_escape_default() {\n-    fn string(c: char) -> ~str {\n-        let mut result = ~\"\";\n-        escape_default(c, |c| { result.push_char(c); });\n-        return result;\n-    }\n-    assert_eq!(string('\\n'), ~\"\\\\n\");\n-    assert_eq!(string('\\r'), ~\"\\\\r\");\n-    assert_eq!(string('\\''), ~\"\\\\'\");\n-    assert_eq!(string('\"'), ~\"\\\\\\\"\");\n-    assert_eq!(string(' '), ~\" \");\n-    assert_eq!(string('a'), ~\"a\");\n-    assert_eq!(string('~'), ~\"~\");\n-    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(string('\\x1f'), ~\"\\\\x1f\");\n-    assert_eq!(string('\\x7f'), ~\"\\\\x7f\");\n-    assert_eq!(string('\\xff'), ~\"\\\\xff\");\n-    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n-}\n-\n-#[test]\n-fn test_escape_unicode() {\n-    fn string(c: char) -> ~str {\n-        let mut result = ~\"\";\n-        escape_unicode(c, |c| { result.push_char(c); });\n-        return result;\n-    }\n-    assert_eq!(string('\\x00'), ~\"\\\\x00\");\n-    assert_eq!(string('\\n'), ~\"\\\\x0a\");\n-    assert_eq!(string(' '), ~\"\\\\x20\");\n-    assert_eq!(string('a'), ~\"\\\\x61\");\n-    assert_eq!(string('\\u011b'), ~\"\\\\u011b\");\n-    assert_eq!(string('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n-}\n-\n-#[test]\n-fn test_to_str() {\n-    let s = 't'.to_str();\n-    assert_eq!(s, ~\"t\");\n-}"}, {"sha": "7c972ed86b4ddbc37feb3ecefd18d006db142176", "filename": "libgrust/libstd/cleanup.rs", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcleanup.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,133 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[doc(hidden)];\n-\n-use libc::c_void;\n-use ptr;\n-use unstable::intrinsics::TyDesc;\n-use unstable::raw;\n-\n-type DropGlue<'self> = 'self |**TyDesc, *c_void|;\n-\n-/*\n- * Box annihilation\n- *\n- * This runs at task death to free all boxes.\n- */\n-\n-struct AnnihilateStats {\n-    n_total_boxes: uint,\n-    n_unique_boxes: uint,\n-    n_bytes_freed: uint\n-}\n-\n-unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |box: *mut raw::Box<()>, uniq: bool| -> bool)\n-                          -> bool {\n-    //! Walks the internal list of allocations\n-\n-    use managed;\n-    use rt::local_heap;\n-\n-    let mut box = local_heap::live_allocs();\n-    while box != ptr::mut_null() {\n-        let next_before = (*box).next;\n-        let uniq = (*box).ref_count == managed::RC_MANAGED_UNIQUE;\n-\n-        if !f(box as *mut raw::Box<()>, uniq) {\n-            return false;\n-        }\n-\n-        if read_next_before {\n-            box = next_before;\n-        } else {\n-            box = (*box).next;\n-        }\n-    }\n-    return true;\n-}\n-\n-#[cfg(unix)]\n-fn debug_mem() -> bool {\n-    // XXX: Need to port the environment struct to newsched\n-    false\n-}\n-\n-#[cfg(windows)]\n-fn debug_mem() -> bool {\n-    false\n-}\n-\n-/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n-pub unsafe fn annihilate() {\n-    use rt::local_heap::local_free;\n-    use mem;\n-    use managed;\n-\n-    let mut stats = AnnihilateStats {\n-        n_total_boxes: 0,\n-        n_unique_boxes: 0,\n-        n_bytes_freed: 0\n-    };\n-\n-    // Pass 1: Make all boxes immortal.\n-    //\n-    // In this pass, nothing gets freed, so it does not matter whether\n-    // we read the next field before or after the callback.\n-    each_live_alloc(true, |box, uniq| {\n-        stats.n_total_boxes += 1;\n-        if uniq {\n-            stats.n_unique_boxes += 1;\n-        } else {\n-            (*box).ref_count = managed::RC_IMMORTAL;\n-        }\n-        true\n-    });\n-\n-    // Pass 2: Drop all boxes.\n-    //\n-    // In this pass, unique-managed boxes may get freed, but not\n-    // managed boxes, so we must read the `next` field *after* the\n-    // callback, as the original value may have been freed.\n-    each_live_alloc(false, |box, uniq| {\n-        if !uniq {\n-            let tydesc = (*box).type_desc;\n-            let data = &(*box).data as *();\n-            ((*tydesc).drop_glue)(data as *i8);\n-        }\n-        true\n-    });\n-\n-    // Pass 3: Free all boxes.\n-    //\n-    // In this pass, managed boxes may get freed (but not\n-    // unique-managed boxes, though I think that none of those are\n-    // left), so we must read the `next` field before, since it will\n-    // not be valid after.\n-    each_live_alloc(true, |box, uniq| {\n-        if !uniq {\n-            stats.n_bytes_freed +=\n-                (*((*box).type_desc)).size\n-                + mem::size_of::<raw::Box<()>>();\n-            local_free(box as *i8);\n-        }\n-        true\n-    });\n-\n-    if debug_mem() {\n-        // We do logging here w/o allocation.\n-        debug!(\"annihilator stats:\\n  \\\n-                       total boxes: {}\\n  \\\n-                      unique boxes: {}\\n  \\\n-                       bytes freed: {}\",\n-                stats.n_total_boxes, stats.n_unique_boxes, stats.n_bytes_freed);\n-    }\n-}"}, {"sha": "584963c36ca231906a8bc85412d47a062edc18f3", "filename": "libgrust/libstd/clone.rs", "status": "removed", "additions": 0, "deletions": 299, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fclone.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,299 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! The Clone trait for types that cannot be \"implicitly copied\"\n-\n-In Rust, some simple types are \"implicitly copyable\" and when you\n-assign them or pass them as arguments, the receiver will get a copy,\n-leaving the original value in place. These types do not require\n-allocation to copy and do not have finalizers (i.e. they do not\n-contain owned boxes or implement `Drop`), so the compiler considers\n-them cheap and safe to copy. For other types copies must be made\n-explicitly, by convention implementing the `Clone` trait and calling\n-the `clone` method.\n-\n-*/\n-\n-use std::kinds::Freeze;\n-\n-/// A common trait for cloning an object.\n-pub trait Clone {\n-    /// Returns a copy of the value. The contents of owned pointers\n-    /// are copied to maintain uniqueness, while the contents of\n-    /// managed pointers are not copied.\n-    fn clone(&self) -> Self;\n-\n-    /// Perform copy-assignment from `source`.\n-    ///\n-    /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n-    /// but can be overriden to reuse the resources of `a` to avoid unnecessary\n-    /// allocations.\n-    #[inline(always)]\n-    fn clone_from(&mut self, source: &Self) {\n-        *self = source.clone()\n-    }\n-}\n-\n-impl<T: Clone> Clone for ~T {\n-    /// Return a copy of the owned box.\n-    #[inline]\n-    fn clone(&self) -> ~T { ~(**self).clone() }\n-\n-    /// Perform copy-assignment from `source` by reusing the existing allocation.\n-    fn clone_from(&mut self, source: &~T) {\n-        **self = (**source).clone()\n-    }\n-}\n-\n-impl<T> Clone for @T {\n-    /// Return a shallow copy of the managed box.\n-    #[inline]\n-    fn clone(&self) -> @T { *self }\n-}\n-\n-impl<T> Clone for @mut T {\n-    /// Return a shallow copy of the managed box.\n-    #[inline]\n-    fn clone(&self) -> @mut T { *self }\n-}\n-\n-impl<'self, T> Clone for &'self T {\n-    /// Return a shallow copy of the borrowed pointer.\n-    #[inline]\n-    fn clone(&self) -> &'self T { *self }\n-}\n-\n-impl<'self, T> Clone for &'self [T] {\n-    /// Return a shallow copy of the slice.\n-    #[inline]\n-    fn clone(&self) -> &'self [T] { *self }\n-}\n-\n-impl<'self> Clone for &'self str {\n-    /// Return a shallow copy of the slice.\n-    #[inline]\n-    fn clone(&self) -> &'self str { *self }\n-}\n-\n-macro_rules! clone_impl(\n-    ($t:ty) => {\n-        impl Clone for $t {\n-            /// Return a deep copy of the value.\n-            #[inline]\n-            fn clone(&self) -> $t { *self }\n-        }\n-    }\n-)\n-\n-clone_impl!(int)\n-clone_impl!(i8)\n-clone_impl!(i16)\n-clone_impl!(i32)\n-clone_impl!(i64)\n-\n-clone_impl!(uint)\n-clone_impl!(u8)\n-clone_impl!(u16)\n-clone_impl!(u32)\n-clone_impl!(u64)\n-\n-clone_impl!(f32)\n-clone_impl!(f64)\n-\n-clone_impl!(())\n-clone_impl!(bool)\n-clone_impl!(char)\n-\n-macro_rules! extern_fn_clone(\n-    ($($A:ident),*) => (\n-        impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n-            #[inline]\n-            fn clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n-        }\n-    )\n-)\n-\n-extern_fn_clone!()\n-extern_fn_clone!(A)\n-extern_fn_clone!(A, B)\n-extern_fn_clone!(A, B, C)\n-extern_fn_clone!(A, B, C, D)\n-extern_fn_clone!(A, B, C, D, E)\n-extern_fn_clone!(A, B, C, D, E, F)\n-extern_fn_clone!(A, B, C, D, E, F, G)\n-extern_fn_clone!(A, B, C, D, E, F, G, H)\n-\n-/// A trait distinct from `Clone` which represents \"deep copies\" of things like\n-/// managed boxes which would otherwise not be copied.\n-pub trait DeepClone: Clone {\n-    /// Return a deep copy of the value. Unlike `Clone`, the contents of shared pointer types\n-    /// *are* copied.\n-    fn deep_clone(&self) -> Self;\n-\n-    /// Perform deep copy-assignment from `source`.\n-    ///\n-    /// `a.deep_clone_from(&b)` is equivalent to `a = b.deep_clone()` in\n-    /// functionality, but can be overriden to reuse the resources of `a` to\n-    /// avoid unnecessary allocations.\n-    #[inline(always)]\n-    fn deep_clone_from(&mut self, source: &Self) {\n-        *self = source.deep_clone()\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for ~T {\n-    /// Return a deep copy of the owned box.\n-    #[inline]\n-    fn deep_clone(&self) -> ~T { ~(**self).deep_clone() }\n-\n-    /// Perform deep copy-assignment from `source` by reusing the existing allocation.\n-    fn deep_clone_from(&mut self, source: &~T) {\n-        **self = (**source).deep_clone()\n-    }\n-}\n-\n-// FIXME: #6525: should also be implemented for `T: Send + DeepClone`\n-impl<T: Freeze + DeepClone + 'static> DeepClone for @T {\n-    /// Return a deep copy of the managed box. The `Freeze` trait is required to prevent performing\n-    /// a deep clone of a potentially cyclical type.\n-    #[inline]\n-    fn deep_clone(&self) -> @T { @(**self).deep_clone() }\n-}\n-\n-// FIXME: #6525: should also be implemented for `T: Send + DeepClone`\n-impl<T: Freeze + DeepClone + 'static> DeepClone for @mut T {\n-    /// Return a deep copy of the managed box. The `Freeze` trait is required to prevent performing\n-    /// a deep clone of a potentially cyclical type.\n-    #[inline]\n-    fn deep_clone(&self) -> @mut T { @mut (**self).deep_clone() }\n-}\n-\n-macro_rules! deep_clone_impl(\n-    ($t:ty) => {\n-        impl DeepClone for $t {\n-            /// Return a deep copy of the value.\n-            #[inline]\n-            fn deep_clone(&self) -> $t { *self }\n-        }\n-    }\n-)\n-\n-deep_clone_impl!(int)\n-deep_clone_impl!(i8)\n-deep_clone_impl!(i16)\n-deep_clone_impl!(i32)\n-deep_clone_impl!(i64)\n-\n-deep_clone_impl!(uint)\n-deep_clone_impl!(u8)\n-deep_clone_impl!(u16)\n-deep_clone_impl!(u32)\n-deep_clone_impl!(u64)\n-\n-deep_clone_impl!(f32)\n-deep_clone_impl!(f64)\n-\n-deep_clone_impl!(())\n-deep_clone_impl!(bool)\n-deep_clone_impl!(char)\n-\n-macro_rules! extern_fn_deep_clone(\n-    ($($A:ident),*) => (\n-        impl<$($A,)* ReturnType> DeepClone for extern \"Rust\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n-            #[inline]\n-            fn deep_clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n-        }\n-    )\n-)\n-\n-extern_fn_deep_clone!()\n-extern_fn_deep_clone!(A)\n-extern_fn_deep_clone!(A, B)\n-extern_fn_deep_clone!(A, B, C)\n-extern_fn_deep_clone!(A, B, C, D)\n-extern_fn_deep_clone!(A, B, C, D, E)\n-extern_fn_deep_clone!(A, B, C, D, E, F)\n-extern_fn_deep_clone!(A, B, C, D, E, F, G)\n-extern_fn_deep_clone!(A, B, C, D, E, F, G, H)\n-\n-#[test]\n-fn test_owned_clone() {\n-    let a = ~5i;\n-    let b: ~int = a.clone();\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_managed_clone() {\n-    let a = @5i;\n-    let b: @int = a.clone();\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_managed_mut_deep_clone() {\n-    let x = @mut 5i;\n-    let y: @mut int = x.deep_clone();\n-    *x = 20;\n-    assert_eq!(*y, 5);\n-}\n-\n-#[test]\n-fn test_managed_mut_clone() {\n-    let a = @mut 5i;\n-    let b: @mut int = a.clone();\n-    assert_eq!(a, b);\n-    *b = 10;\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_borrowed_clone() {\n-    let x = 5i;\n-    let y: &int = &x;\n-    let z: &int = (&y).clone();\n-    assert_eq!(*z, 5);\n-}\n-\n-#[test]\n-fn test_clone_from() {\n-    let a = ~5;\n-    let mut b = ~10;\n-    b.clone_from(&a);\n-    assert_eq!(*b, 5);\n-}\n-\n-#[test]\n-fn test_deep_clone_from() {\n-    let a = ~5;\n-    let mut b = ~10;\n-    b.deep_clone_from(&a);\n-    assert_eq!(*b, 5);\n-}\n-\n-#[test]\n-fn test_extern_fn_clone() {\n-    trait Empty {}\n-    impl Empty for int {}\n-\n-    fn test_fn_a() -> f64 { 1.0 }\n-    fn test_fn_b<T: Empty>(x: T) -> T { x }\n-    fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}\n-\n-    let _ = test_fn_a.clone();\n-    let _ = test_fn_b::<int>.clone();\n-    let _ = test_fn_c.clone();\n-\n-    let _ = test_fn_a.deep_clone();\n-    let _ = test_fn_b::<int>.deep_clone();\n-    let _ = test_fn_c.deep_clone();\n-}"}, {"sha": "4bfcf2ce92dec7a8a77936278291a4eafa466840", "filename": "libgrust/libstd/cmp.rs", "status": "removed", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcmp.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,245 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `Ord` and `Eq` comparison traits\n-\n-This module contains the definition of both `Ord` and `Eq` which define\n-the common interfaces for doing comparison. Both are language items\n-that the compiler uses to implement the comparison operators. Rust code\n-may implement `Ord` to overload the `<`, `<=`, `>`, and `>=` operators,\n-and `Eq` to overload the `==` and `!=` operators.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-/**\n-* Trait for values that can be compared for equality and inequality.\n-*\n-* This trait allows partial equality, where types can be unordered instead of strictly equal or\n-* unequal. For example, with the built-in floating-point types `a == b` and `a != b` will both\n-* evaluate to false if either `a` or `b` is NaN (cf. IEEE 754-2008 section 5.11).\n-*\n-* Eq only requires the `eq` method to be implemented; `ne` is its negation by default.\n-*\n-* Eventually, this will be implemented by default for types that implement `TotalEq`.\n-*/\n-#[lang=\"eq\"]\n-pub trait Eq {\n-    fn eq(&self, other: &Self) -> bool;\n-\n-    #[inline]\n-    fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n-}\n-\n-/// Trait for equality comparisons where `a == b` and `a != b` are strict inverses.\n-pub trait TotalEq {\n-    fn equals(&self, other: &Self) -> bool;\n-}\n-\n-macro_rules! totaleq_impl(\n-    ($t:ty) => {\n-        impl TotalEq for $t {\n-            #[inline]\n-            fn equals(&self, other: &$t) -> bool { *self == *other }\n-        }\n-    }\n-)\n-\n-totaleq_impl!(bool)\n-\n-totaleq_impl!(u8)\n-totaleq_impl!(u16)\n-totaleq_impl!(u32)\n-totaleq_impl!(u64)\n-\n-totaleq_impl!(i8)\n-totaleq_impl!(i16)\n-totaleq_impl!(i32)\n-totaleq_impl!(i64)\n-\n-totaleq_impl!(int)\n-totaleq_impl!(uint)\n-\n-totaleq_impl!(char)\n-\n-/// Trait for testing approximate equality\n-pub trait ApproxEq<Eps> {\n-    fn approx_epsilon() -> Eps;\n-    fn approx_eq(&self, other: &Self) -> bool;\n-    fn approx_eq_eps(&self, other: &Self, approx_epsilon: &Eps) -> bool;\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }\n-\n-/// Trait for types that form a total order\n-pub trait TotalOrd: TotalEq {\n-    fn cmp(&self, other: &Self) -> Ordering;\n-}\n-\n-impl TotalEq for Ordering {\n-    #[inline]\n-    fn equals(&self, other: &Ordering) -> bool {\n-        *self == *other\n-    }\n-}\n-impl TotalOrd for Ordering {\n-    #[inline]\n-    fn cmp(&self, other: &Ordering) -> Ordering {\n-        (*self as int).cmp(&(*other as int))\n-    }\n-}\n-\n-impl Ord for Ordering {\n-    #[inline]\n-    fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n-}\n-\n-macro_rules! totalord_impl(\n-    ($t:ty) => {\n-        impl TotalOrd for $t {\n-            #[inline]\n-            fn cmp(&self, other: &$t) -> Ordering {\n-                if *self < *other { Less }\n-                else if *self > *other { Greater }\n-                else { Equal }\n-            }\n-        }\n-    }\n-)\n-\n-totalord_impl!(u8)\n-totalord_impl!(u16)\n-totalord_impl!(u32)\n-totalord_impl!(u64)\n-\n-totalord_impl!(i8)\n-totalord_impl!(i16)\n-totalord_impl!(i32)\n-totalord_impl!(i64)\n-\n-totalord_impl!(int)\n-totalord_impl!(uint)\n-\n-totalord_impl!(char)\n-\n-/// Compares (a1, b1) against (a2, b2), where the a values are more significant.\n-pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n-    a1: &A, b1: &B,\n-    a2: &A, b2: &B) -> Ordering\n-{\n-    match a1.cmp(a2) {\n-        Less => Less,\n-        Greater => Greater,\n-        Equal => b1.cmp(b2)\n-    }\n-}\n-\n-/**\n-Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n-lexical ordering on a type `(int, int)`.\n-*/\n-#[inline]\n-pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n-    match o1 {\n-        Equal => o2,\n-        _ => o1\n-    }\n-}\n-\n-/**\n-* Trait for values that can be compared for a sort-order.\n-*\n-* Ord only requires implementation of the `lt` method,\n-* with the others generated from default implementations.\n-*\n-* However it remains possible to implement the others separately,\n-* for compatibility with floating-point NaN semantics\n-* (cf. IEEE 754-2008 section 5.11).\n-*/\n-#[lang=\"ord\"]\n-pub trait Ord {\n-    fn lt(&self, other: &Self) -> bool;\n-    #[inline]\n-    fn le(&self, other: &Self) -> bool { !other.lt(self) }\n-    #[inline]\n-    fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n-    #[inline]\n-    fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n-}\n-\n-/// The equivalence relation. Two values may be equivalent even if they are\n-/// of different types. The most common use case for this relation is\n-/// container types; e.g. it is often desirable to be able to use `&str`\n-/// values to look up entries in a container with `~str` keys.\n-pub trait Equiv<T> {\n-    fn equiv(&self, other: &T) -> bool;\n-}\n-\n-#[inline]\n-pub fn min<T:Ord>(v1: T, v2: T) -> T {\n-    if v1 < v2 { v1 } else { v2 }\n-}\n-\n-#[inline]\n-pub fn max<T:Ord>(v1: T, v2: T) -> T {\n-    if v1 > v2 { v1 } else { v2 }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::lexical_ordering;\n-\n-    #[test]\n-    fn test_int_totalord() {\n-        assert_eq!(5.cmp(&10), Less);\n-        assert_eq!(10.cmp(&5), Greater);\n-        assert_eq!(5.cmp(&5), Equal);\n-        assert_eq!((-5).cmp(&12), Less);\n-        assert_eq!(12.cmp(-5), Greater);\n-    }\n-\n-    #[test]\n-    fn test_cmp2() {\n-        assert_eq!(cmp2(1, 2, 3, 4), Less);\n-        assert_eq!(cmp2(3, 2, 3, 4), Less);\n-        assert_eq!(cmp2(5, 2, 3, 4), Greater);\n-        assert_eq!(cmp2(5, 5, 5, 4), Greater);\n-    }\n-\n-    #[test]\n-    fn test_int_totaleq() {\n-        assert!(5.equals(&5));\n-        assert!(!2.equals(&17));\n-    }\n-\n-    #[test]\n-    fn test_ordering_order() {\n-        assert!(Less < Equal);\n-        assert_eq!(Greater.cmp(&Less), Greater);\n-    }\n-\n-    #[test]\n-    fn test_lexical_ordering() {\n-        fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n-            assert_eq!(lexical_ordering(o1, o2), e);\n-        }\n-\n-        let xs = [Less, Equal, Greater];\n-        for &o in xs.iter() {\n-            t(Less, o, Less);\n-            t(Equal, o, o);\n-            t(Greater, o, Greater);\n-         }\n-    }\n-}"}, {"sha": "fcba4a6bbdbf8ae0d8b342744ccdb0531b6ed4ee", "filename": "libgrust/libstd/comm.rs", "status": "removed", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcomm.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,310 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Message passing\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use clone::Clone;\n-use iter::Iterator;\n-use kinds::Send;\n-use option::Option;\n-use rtcomm = rt::comm;\n-\n-/// A trait for things that can send multiple messages.\n-pub trait GenericChan<T> {\n-    /// Sends a message.\n-    fn send(&self, x: T);\n-}\n-\n-/// Things that can send multiple messages and can detect when the receiver\n-/// is closed\n-pub trait GenericSmartChan<T> {\n-    /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(&self, x: T) -> bool;\n-}\n-\n-/// Trait for non-rescheduling send operations, similar to `send_deferred` on ChanOne.\n-pub trait SendDeferred<T> {\n-    fn send_deferred(&self, val: T);\n-    fn try_send_deferred(&self, val: T) -> bool;\n-}\n-\n-/// A trait for things that can receive multiple messages.\n-pub trait GenericPort<T> {\n-    /// Receives a message, or fails if the connection closes.\n-    fn recv(&self) -> T;\n-\n-    /// Receives a message, or returns `none` if\n-    /// the connection is closed or closes.\n-    fn try_recv(&self) -> Option<T>;\n-\n-    /// Returns an iterator that breaks once the connection closes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~rust\n-    /// do spawn {\n-    ///     for x in port.recv_iter() {\n-    ///         if pred(x) { break; }\n-    ///         println!(\"{}\", x);\n-    ///     }\n-    /// }\n-    /// ~~~\n-    fn recv_iter<'a>(&'a self) -> RecvIterator<'a, Self> {\n-        RecvIterator { port: self }\n-    }\n-}\n-\n-pub struct RecvIterator<'a, P> {\n-    priv port: &'a P,\n-}\n-\n-impl<'a, T, P: GenericPort<T>> Iterator<T> for RecvIterator<'a, P> {\n-    fn next(&mut self) -> Option<T> {\n-        self.port.try_recv()\n-    }\n-}\n-\n-/// Ports that can `peek`\n-pub trait Peekable<T> {\n-    /// Returns true if a message is available\n-    fn peek(&self) -> bool;\n-}\n-\n-pub struct PortOne<T> { priv x: rtcomm::PortOne<T> }\n-pub struct ChanOne<T> { priv x: rtcomm::ChanOne<T> }\n-\n-pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-    let (p, c) = rtcomm::oneshot();\n-    (PortOne { x: p }, ChanOne { x: c })\n-}\n-\n-pub struct Port<T> { priv x: rtcomm::Port<T> }\n-pub struct Chan<T> { priv x: rtcomm::Chan<T> }\n-\n-pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n-    let (p, c) = rtcomm::stream();\n-    (Port { x: p }, Chan { x: c })\n-}\n-\n-impl<T: Send> ChanOne<T> {\n-    pub fn send(self, val: T) {\n-        let ChanOne { x: c } = self;\n-        c.send(val)\n-    }\n-\n-    pub fn try_send(self, val: T) -> bool {\n-        let ChanOne { x: c } = self;\n-        c.try_send(val)\n-    }\n-\n-    pub fn send_deferred(self, val: T) {\n-        let ChanOne { x: c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    pub fn try_send_deferred(self, val: T) -> bool {\n-        let ChanOne{ x: c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> PortOne<T> {\n-    pub fn recv(self) -> T {\n-        let PortOne { x: p } = self;\n-        p.recv()\n-    }\n-\n-    pub fn try_recv(self) -> Option<T> {\n-        let PortOne { x: p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Peekable<T>  for PortOne<T> {\n-    fn peek(&self) -> bool {\n-        let &PortOne { x: ref p } = self;\n-        p.peek()\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for Chan<T> {\n-    fn send(&self, val: T) {\n-        let &Chan { x: ref c } = self;\n-        c.send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        let &Chan { x: ref c } = self;\n-        c.try_send(val)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for Chan<T> {\n-    fn send_deferred(&self, val: T) {\n-        let &Chan { x: ref c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        let &Chan { x: ref c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        let &Port { x: ref p } = self;\n-        p.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let &Port { x: ref p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool {\n-        let &Port { x: ref p } = self;\n-        p.peek()\n-    }\n-}\n-\n-\n-pub struct SharedChan<T> { priv x: rtcomm::SharedChan<T> }\n-\n-impl<T: Send> SharedChan<T> {\n-    pub fn new(c: Chan<T>) -> SharedChan<T> {\n-        let Chan { x: c } = c;\n-        SharedChan { x: rtcomm::SharedChan::new(c) }\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, val: T) {\n-        let &SharedChan { x: ref c } = self;\n-        c.send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        let &SharedChan { x: ref c } = self;\n-        c.try_send(val)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for SharedChan<T> {\n-    fn send_deferred(&self, val: T) {\n-        let &SharedChan { x: ref c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        let &SharedChan { x: ref c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedChan<T> {\n-    fn clone(&self) -> SharedChan<T> {\n-        let &SharedChan { x: ref c } = self;\n-        SharedChan { x: c.clone() }\n-    }\n-}\n-\n-pub struct SharedPort<T> { priv x: rtcomm::SharedPort<T> }\n-\n-impl<T: Send> SharedPort<T> {\n-    pub fn new(p: Port<T>) -> SharedPort<T> {\n-        let Port { x: p } = p;\n-        SharedPort { x: rtcomm::SharedPort::new(p) }\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for SharedPort<T> {\n-    fn recv(&self) -> T {\n-        let &SharedPort { x: ref p } = self;\n-        p.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let &SharedPort { x: ref p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedPort<T> {\n-    fn clone(&self) -> SharedPort<T> {\n-        let &SharedPort { x: ref p } = self;\n-        SharedPort { x: p.clone() }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use comm::*;\n-    use prelude::*;\n-\n-    #[test]\n-    fn test_nested_recv_iter() {\n-        let (port, chan) = stream::<int>();\n-        let (total_port, total_chan) = oneshot::<int>();\n-\n-        do spawn {\n-            let mut acc = 0;\n-            for x in port.recv_iter() {\n-                acc += x;\n-                for x in port.recv_iter() {\n-                    acc += x;\n-                    for x in port.try_recv().move_iter() {\n-                        acc += x;\n-                        total_chan.send(acc);\n-                    }\n-                }\n-            }\n-        }\n-\n-        chan.send(3);\n-        chan.send(1);\n-        chan.send(2);\n-        assert_eq!(total_port.recv(), 6);\n-    }\n-\n-    #[test]\n-    fn test_recv_iter_break() {\n-        let (port, chan) = stream::<int>();\n-        let (count_port, count_chan) = oneshot::<int>();\n-\n-        do spawn {\n-            let mut count = 0;\n-            for x in port.recv_iter() {\n-                if count >= 3 {\n-                    count_chan.send(count);\n-                    break;\n-                } else {\n-                    count += x;\n-                }\n-            }\n-        }\n-\n-        chan.send(2);\n-        chan.send(2);\n-        chan.send(2);\n-        chan.send(2);\n-        assert_eq!(count_port.recv(), 4);\n-    }\n-}"}, {"sha": "e34e94ac10cc5e651866567116e11560f00aab02", "filename": "libgrust/libstd/condition.rs", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcondition.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,325 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Condition handling\n-\n-Conditions are a utility used to deal with handling error conditions. The syntax\n-of a condition handler strikes a resemblance to try/catch blocks in other\n-languages, but condition handlers are *not* a form of exception handling in the\n-same manner.\n-\n-A condition is declared through the `condition!` macro provided by the compiler:\n-\n-```rust\n-condition! {\n-    pub my_error: int -> ~str;\n-}\n- ```\n-\n-This macro declares an inner module called `my_error` with one static variable,\n-`cond` that is a static `Condition` instance. To help understand what the other\n-parameters are used for, an example usage of this condition would be:\n-\n-```rust\n-my_error::cond.trap(|raised_int| {\n-\n-    // the condition `my_error` was raised on, and the value it raised is stored\n-    // in `raised_int`. This closure must return a `~str` type (as specified in\n-    // the declaration of the condition\n-    if raised_int == 3 { ~\"three\" } else { ~\"oh well\" }\n-\n-}).inside(|| {\n-\n-    // The condition handler above is installed for the duration of this block.\n-    // That handler will override any previous handler, but the previous handler\n-    // is restored when this block returns (handlers nest)\n-    //\n-    // If any code from this block (or code from another block) raises on the\n-    // condition, then the above handler will be invoked (so long as there's no\n-    // other nested handler).\n-\n-    println(my_error::cond.raise(3)); // prints \"three\"\n-    println(my_error::cond.raise(4)); // prints \"oh well\"\n-\n-})\n- ```\n-\n-Condition handling is useful in cases where propagating errors is either to\n-cumbersome or just not necessary in the first place. It should also be noted,\n-though, that if there is not handler installed when a condition is raised, then\n-the task invokes `fail!()` and will terminate.\n-\n-## More Info\n-\n-Condition handlers as an error strategy is well explained in the [conditions\n-tutorial](http://static.rust-lang.org/doc/master/tutorial-conditions.html),\n-along with comparing and contrasting it with other error handling strategies.\n-\n-*/\n-\n-use local_data;\n-use prelude::*;\n-use unstable::raw::Closure;\n-\n-#[doc(hidden)]\n-pub struct Handler<T, U> {\n-    priv handle: Closure,\n-    priv prev: Option<@Handler<T, U>>,\n-}\n-\n-/// This struct represents the state of a condition handler. It contains a key\n-/// into TLS which holds the currently install handler, along with the name of\n-/// the condition (useful for debugging).\n-///\n-/// This struct should never be created directly, but rather only through the\n-/// `condition!` macro provided to all libraries using libstd.\n-pub struct Condition<T, U> {\n-    /// Name of the condition handler\n-    name: &'static str,\n-    /// TLS key used to insert/remove values in TLS.\n-    key: local_data::Key<@Handler<T, U>>\n-}\n-\n-impl<T, U> Condition<T, U> {\n-    /// Creates an object which binds the specified handler. This will also save\n-    /// the current handler *on creation* such that when the `Trap` is consumed,\n-    /// it knows which handler to restore.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// condition! { my_error: int -> int; }\n-    ///\n-    /// let trap = my_error::cond.trap(|error| error + 3);\n-    ///\n-    /// // use `trap`'s inside method to register the handler and then run a\n-    /// // block of code with the handler registered\n-    /// ```\n-    pub fn trap<'a>(&'a self, h: 'a |T| -> U) -> Trap<'a, T, U> {\n-        let h: Closure = unsafe { ::cast::transmute(h) };\n-        let prev = local_data::get(self.key, |k| k.map(|x| *x));\n-        let h = @Handler { handle: h, prev: prev };\n-        Trap { cond: self, handler: h }\n-    }\n-\n-    /// Raises on this condition, invoking any handler if one has been\n-    /// registered, or failing the current task otherwise.\n-    ///\n-    /// While a condition handler is being run, the condition will have no\n-    /// handler listed, so a task failure will occur if the condition is\n-    /// re-raised during the handler.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * t - The argument to pass along to the condition handler.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If a handler is found, its return value is returned, otherwise this\n-    /// function will not return.\n-    pub fn raise(&self, t: T) -> U {\n-        let msg = format!(\"Unhandled condition: {}: {:?}\", self.name, t);\n-        self.raise_default(t, || fail!(\"{}\", msg.clone()))\n-    }\n-\n-    /// Performs the same functionality as `raise`, except that when no handler\n-    /// is found the `default` argument is called instead of failing the task.\n-    pub fn raise_default(&self, t: T, default: || -> U) -> U {\n-        match local_data::pop(self.key) {\n-            None => {\n-                debug!(\"Condition.raise: found no handler\");\n-                default()\n-            }\n-            Some(handler) => {\n-                debug!(\"Condition.raise: found handler\");\n-                match handler.prev {\n-                    None => {}\n-                    Some(hp) => local_data::set(self.key, hp)\n-                }\n-                let handle : |T| -> U = unsafe {\n-                    ::cast::transmute(handler.handle)\n-                };\n-                let u = handle(t);\n-                local_data::set(self.key, handler);\n-                u\n-            }\n-        }\n-    }\n-}\n-\n-/// A `Trap` is created when the `trap` method is invoked on a `Condition`, and\n-/// it is used to actually bind a handler into the TLS slot reserved for this\n-/// condition.\n-///\n-/// Normally this object is not dealt with directly, but rather it's directly\n-/// used after being returned from `trap`\n-struct Trap<'self, T, U> {\n-    priv cond: &'self Condition<T, U>,\n-    priv handler: @Handler<T, U>\n-}\n-\n-impl<'self, T, U> Trap<'self, T, U> {\n-    /// Execute a block of code with this trap handler's exception handler\n-    /// registered.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// condition! { my_error: int -> int; }\n-    ///\n-    /// let result = my_error::cond.trap(|error| error + 3).inside(|| {\n-    ///     my_error::cond.raise(4)\n-    /// });\n-    /// assert_eq!(result, 7);\n-    /// ```\n-    pub fn inside<V>(&self, inner: 'self || -> V) -> V {\n-        let _g = Guard { cond: self.cond };\n-        debug!(\"Trap: pushing handler to TLS\");\n-        local_data::set(self.cond.key, self.handler);\n-        inner()\n-    }\n-}\n-\n-#[doc(hidden)]\n-struct Guard<'self, T, U> {\n-    priv cond: &'self Condition<T, U>\n-}\n-\n-#[unsafe_destructor]\n-impl<'self, T, U> Drop for Guard<'self, T, U> {\n-    fn drop(&mut self) {\n-        debug!(\"Guard: popping handler from TLS\");\n-        let curr = local_data::pop(self.cond.key);\n-        match curr {\n-            None => {}\n-            Some(h) => match h.prev {\n-                None => {}\n-                Some(hp) => local_data::set(self.cond.key, hp)\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    condition! {\n-        sadness: int -> int;\n-    }\n-\n-    fn trouble(i: int) {\n-        debug!(\"trouble: raising condition\");\n-        let j = sadness::cond.raise(i);\n-        debug!(\"trouble: handler recovered with {}\", j);\n-    }\n-\n-    fn nested_trap_test_inner() {\n-        let mut inner_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_inner: in handler\");\n-            inner_trapped = true;\n-            0\n-        }).inside(|| {\n-            debug!(\"nested_trap_test_inner: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(inner_trapped);\n-    }\n-\n-    #[test]\n-    fn nested_trap_test_outer() {\n-        let mut outer_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_outer: in handler\");\n-            outer_trapped = true; 0\n-        }).inside(|| {\n-            debug!(\"nested_guard_test_outer: in protected block\");\n-            nested_trap_test_inner();\n-            trouble(1);\n-        });\n-\n-        assert!(outer_trapped);\n-    }\n-\n-    fn nested_reraise_trap_test_inner() {\n-        let mut inner_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_inner: in handler\");\n-            inner_trapped = true;\n-            let i = 10;\n-            debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n-            sadness::cond.raise(i)\n-        }).inside(|| {\n-            debug!(\"nested_reraise_trap_test_inner: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(inner_trapped);\n-    }\n-\n-    #[test]\n-    fn nested_reraise_trap_test_outer() {\n-        let mut outer_trapped = false;\n-\n-        sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_outer: in handler\");\n-            outer_trapped = true; 0\n-        }).inside(|| {\n-            debug!(\"nested_reraise_trap_test_outer: in protected block\");\n-            nested_reraise_trap_test_inner();\n-        });\n-\n-        assert!(outer_trapped);\n-    }\n-\n-    #[test]\n-    fn test_default() {\n-        let mut trapped = false;\n-\n-        sadness::cond.trap(|j| {\n-            debug!(\"test_default: in handler\");\n-            sadness::cond.raise_default(j, || { trapped=true; 5 })\n-        }).inside(|| {\n-            debug!(\"test_default: in protected block\");\n-            trouble(1);\n-        });\n-\n-        assert!(trapped);\n-    }\n-\n-    // Issue #6009\n-    mod m {\n-        condition! {\n-            // #6009, #8215: should this truly need a `pub` for access from n?\n-            pub sadness: int -> int;\n-        }\n-\n-        mod n {\n-            use super::sadness;\n-\n-            #[test]\n-            fn test_conditions_are_public() {\n-                let mut trapped = false;\n-                sadness::cond.trap(|_| {\n-                    trapped = true;\n-                    0\n-                }).inside(|| {\n-                    sadness::cond.raise(0);\n-                });\n-                assert!(trapped);\n-            }\n-        }\n-    }\n-}"}, {"sha": "c91a53f966388dd4590530949e48d0f4190a54ce", "filename": "libgrust/libstd/container.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fcontainer.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Container traits\n-\n-use option::Option;\n-\n-/// A trait to represent the abstract idea of a container. The only concrete\n-/// knowledge known is the number of elements contained within.\n-pub trait Container {\n-    /// Return the number of elements in the container\n-    fn len(&self) -> uint;\n-\n-    /// Return true if the container contains no elements\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-/// A trait to represent mutable containers\n-pub trait Mutable: Container {\n-    /// Clear the container, removing all values.\n-    fn clear(&mut self);\n-}\n-\n-/// A map is a key-value store where values may be looked up by their keys. This\n-/// trait provides basic operations to operate on these stores.\n-pub trait Map<K, V>: Container {\n-    /// Return a reference to the value corresponding to the key\n-    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n-\n-    /// Return true if the map contains a value for the specified key\n-    #[inline]\n-    fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n-    }\n-}\n-\n-/// This trait provides basic operations to modify the contents of a map.\n-pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n-    /// not already exist in the map.\n-    #[inline]\n-    fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    #[inline]\n-    fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n-    }\n-\n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n-    fn swap(&mut self, k: K, v: V) -> Option<V>;\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    fn pop(&mut self, k: &K) -> Option<V>;\n-\n-    /// Return a mutable reference to the value corresponding to the key\n-    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n-}\n-\n-/// A set is a group of objects which are each distinct from one another. This\n-/// trait represents actions which can be performed on sets to iterate over\n-/// them.\n-pub trait Set<T>: Container {\n-    /// Return true if the set contains a value\n-    fn contains(&self, value: &T) -> bool;\n-\n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    fn is_disjoint(&self, other: &Self) -> bool;\n-\n-    /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &Self) -> bool;\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &Self) -> bool;\n-\n-    // FIXME #8154: Add difference, sym. difference, intersection and union iterators\n-}\n-\n-/// This trait represents actions which can be performed on sets to mutate\n-/// them.\n-pub trait MutableSet<T>: Set<T> + Mutable {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: T) -> bool;\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &T) -> bool;\n-}"}, {"sha": "120cf3fa8013bbb4e3bd50df1bbc655165ef33c7", "filename": "libgrust/libstd/default.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fdefault.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fdefault.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fdefault.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Default trait\n-\n-/// A trait that types which have a useful default value should implement.\n-pub trait Default {\n-    /// Return the \"default value\" for a type.\n-    fn default() -> Self;\n-}\n-\n-impl<T: Default + 'static> Default for @mut T {\n-    fn default() -> @mut T { @mut Default::default() }\n-}\n-\n-impl<T: Default + 'static> Default for @T {\n-    fn default() -> @T { @Default::default() }\n-}\n-\n-impl<T: Default> Default for ~T {\n-    fn default() -> ~T { ~Default::default() }\n-}"}, {"sha": "6d152d8c179a818fce9a97f9217d754c37790f56", "filename": "libgrust/libstd/either.rs", "status": "removed", "additions": 0, "deletions": 435, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Feither.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Feither.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,435 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A type that represents one of two alternatives\n-\n-#[allow(missing_doc)];\n-\n-use option::{Some, None};\n-use option;\n-use clone::Clone;\n-use container::Container;\n-use cmp::Eq;\n-use iter::{Iterator, FilterMap};\n-use result::Result;\n-use result;\n-use str::StrSlice;\n-use vec;\n-use vec::{OwnedVector, ImmutableVector};\n-\n-/// `Either` is a type that represents one of two alternatives\n-#[deriving(Clone, Eq, IterBytes)]\n-pub enum Either<L, R> {\n-    Left(L),\n-    Right(R)\n-}\n-\n-impl<L, R> Either<L, R> {\n-    /// Applies a function based on the given either value\n-    ///\n-    /// If `value` is `Left(L)` then `f_left` is applied to its contents, if\n-    /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n-    /// result is returned.\n-    #[inline]\n-    pub fn either<T>(&self, f_left: |&L| -> T, f_right: |&R| -> T) -> T {\n-        match *self {\n-            Left(ref l) => f_left(l),\n-            Right(ref r) => f_right(r)\n-        }\n-    }\n-\n-    /// Flips between left and right of a given `Either`\n-    #[inline]\n-    pub fn flip(self) -> Either<R, L> {\n-        match self {\n-            Right(r) => Left(r),\n-            Left(l) => Right(l)\n-        }\n-    }\n-\n-    /// Checks whether the given value is a `Left`\n-    #[inline]\n-    pub fn is_left(&self) -> bool {\n-        match *self {\n-            Left(_) => true,\n-            _ => false\n-        }\n-    }\n-\n-    /// Checks whether the given value is a `Right`\n-    #[inline]\n-    pub fn is_right(&self) -> bool {\n-        match *self {\n-            Right(_) => true,\n-            _ => false\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Left`.\n-    /// Fails with a specified reason if the `Either` is `Right`.\n-    #[inline]\n-    pub fn expect_left(self, reason: &str) -> L {\n-        match self {\n-            Left(x) => x,\n-            Right(_) => fail!(\"{}\", reason.to_owned())\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Left`. Fails if the `Either` is `Right`.\n-    #[inline]\n-    pub fn unwrap_left(self) -> L {\n-        self.expect_left(\"called Either::unwrap_left()` on `Right` value\")\n-    }\n-\n-    /// Retrieves the value from a `Right`.\n-    /// Fails with a specified reason if the `Either` is `Left`.\n-    #[inline]\n-    pub fn expect_right(self, reason: &str) -> R {\n-        match self {\n-            Right(x) => x,\n-            Left(_) => fail!(\"{}\", reason.to_owned())\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Right`. Fails if the `Either` is `Left`.\n-    #[inline]\n-    pub fn unwrap_right(self) -> R {\n-        self.expect_right(\"called Either::unwrap_right()` on `Left` value\")\n-    }\n-}\n-\n-/// A generic trait for converting a value to a `Either`\n-pub trait ToEither<L, R> {\n-    /// Convert to the `either` type\n-    fn to_either(&self) -> Either<L, R>;\n-}\n-\n-/// A generic trait for converting a value to a `Either`\n-pub trait IntoEither<L, R> {\n-    /// Convert to the `either` type\n-    fn into_either(self) -> Either<L, R>;\n-}\n-\n-/// A generic trait for converting a value to a `Either`\n-pub trait AsEither<L, R> {\n-    /// Convert to the `either` type\n-    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R>;\n-}\n-\n-impl<L, R: Clone> option::ToOption<R> for Either<L, R> {\n-    #[inline]\n-    fn to_option(&self)-> option::Option<R> {\n-        match *self {\n-            Left(_) => None,\n-            Right(ref r) => Some(r.clone()),\n-        }\n-    }\n-}\n-\n-impl<L, R> option::IntoOption<R> for Either<L, R> {\n-    #[inline]\n-    fn into_option(self)-> option::Option<R> {\n-        match self {\n-            Left(_) => None,\n-            Right(r) => Some(r),\n-        }\n-    }\n-}\n-\n-impl<L, R> option::AsOption<R> for Either<L, R> {\n-    #[inline]\n-    fn as_option<'a>(&'a self) -> option::Option<&'a R> {\n-        match *self {\n-            Left(_) => None,\n-            Right(ref r) => Some(r),\n-        }\n-    }\n-}\n-\n-impl<L: Clone, R: Clone> result::ToResult<R, L> for Either<L, R> {\n-    #[inline]\n-    fn to_result(&self)-> result::Result<R, L> {\n-        match *self {\n-            Left(ref l) => result::Err(l.clone()),\n-            Right(ref r) => result::Ok(r.clone()),\n-        }\n-    }\n-}\n-\n-impl<L, R> result::IntoResult<R, L> for Either<L, R> {\n-    #[inline]\n-    fn into_result(self)-> result::Result<R, L> {\n-        match self {\n-            Left(l) => result::Err(l),\n-            Right(r) => result::Ok(r),\n-        }\n-    }\n-}\n-\n-impl<L, R> result::AsResult<R, L> for Either<L, R> {\n-    #[inline]\n-    fn as_result<'a>(&'a self) -> result::Result<&'a R, &'a L> {\n-        match *self {\n-            Left(ref l) => result::Err(l),\n-            Right(ref r) => result::Ok(r),\n-        }\n-    }\n-}\n-\n-impl<L: Clone, R: Clone> ToEither<L, R> for Either<L, R> {\n-    fn to_either(&self) -> Either<L, R> { self.clone() }\n-}\n-\n-impl<L, R> IntoEither<L, R> for Either<L, R> {\n-    fn into_either(self) -> Either<L, R> { self }\n-}\n-\n-impl<L, R> AsEither<L, R> for Either<L, R> {\n-    fn as_either<'a>(&'a self) -> Either<&'a L, &'a R> {\n-        match *self {\n-            Left(ref l) => Left(l),\n-            Right(ref r) => Right(r),\n-        }\n-    }\n-}\n-\n-/// An iterator yielding the `Left` values of its source\n-pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n-\n-/// An iterator yielding the `Right` values of its source\n-pub type Rights<L, R, Iter> = FilterMap<'static, Either<L, R>, R, Iter>;\n-\n-/// Extracts all the left values\n-pub fn lefts<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n-    -> Lefts<L, R, Iter> {\n-    eithers.filter_map(|elt| {\n-        match elt {\n-            Left(x) => Some(x),\n-            _ => None,\n-        }\n-    })\n-}\n-\n-/// Extracts all the right values\n-pub fn rights<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n-    -> Rights<L, R, Iter> {\n-    eithers.filter_map(|elt| {\n-        match elt {\n-            Right(x) => Some(x),\n-            _ => None,\n-        }\n-    })\n-}\n-\n-\n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Extracts from a vector of either all the left values and right values\n-///\n-/// Returns a structure containing a vector of left values and a vector of\n-/// right values.\n-pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n-    let n_lefts = eithers.iter().count(|elt| elt.is_left());\n-    let mut lefts = vec::with_capacity(n_lefts);\n-    let mut rights = vec::with_capacity(eithers.len() - n_lefts);\n-    for elt in eithers.move_iter() {\n-        match elt {\n-            Left(l) => lefts.push(l),\n-            Right(r) => rights.push(r)\n-        }\n-    }\n-    return (lefts, rights);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use option::{IntoOption, ToOption, AsOption};\n-    use option;\n-    use result::{IntoResult, ToResult, AsResult};\n-    use result;\n-\n-    #[test]\n-    fn test_either_left() {\n-        let val = Left(10);\n-        fn f_left(x: &int) -> bool { *x == 10 }\n-        fn f_right(_x: &uint) -> bool { false }\n-        assert!(val.either(f_left, f_right));\n-    }\n-\n-    #[test]\n-    fn test_either_right() {\n-        let val = Right(10u);\n-        fn f_left(_x: &int) -> bool { false }\n-        fn f_right(x: &uint) -> bool { *x == 10u }\n-        assert!(val.either(f_left, f_right));\n-    }\n-\n-    #[test]\n-    fn test_lefts() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result, ~[10, 12, 14]);\n-    }\n-\n-    #[test]\n-    fn test_lefts_none() {\n-        let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_lefts_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_rights() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result, ~[11, 13]);\n-    }\n-\n-    #[test]\n-    fn test_rights_none() {\n-        let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_rights_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_partition() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts[0], 10);\n-        assert_eq!(lefts[1], 12);\n-        assert_eq!(lefts[2], 14);\n-        assert_eq!(rights[0], 11);\n-        assert_eq!(rights[1], 13);\n-    }\n-\n-    #[test]\n-    fn test_partition_no_lefts() {\n-        let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 0u);\n-        assert_eq!(rights.len(), 2u);\n-    }\n-\n-    #[test]\n-    fn test_partition_no_rights() {\n-        let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 2u);\n-        assert_eq!(rights.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_partition_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 0u);\n-        assert_eq!(rights.len(), 0u);\n-    }\n-\n-    #[test]\n-    pub fn test_to_option() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.to_option(), option::Some(100));\n-        assert_eq!(left.to_option(), option::None);\n-    }\n-\n-    #[test]\n-    pub fn test_into_option() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.into_option(), option::Some(100));\n-        assert_eq!(left.into_option(), option::None);\n-    }\n-\n-    #[test]\n-    pub fn test_as_option() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.as_option().unwrap(), &100);\n-        assert_eq!(left.as_option(), option::None);\n-    }\n-\n-    #[test]\n-    pub fn test_to_result() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.to_result(), result::Ok(100));\n-        assert_eq!(left.to_result(), result::Err(404));\n-    }\n-\n-    #[test]\n-    pub fn test_into_result() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.into_result(), result::Ok(100));\n-        assert_eq!(left.into_result(), result::Err(404));\n-    }\n-\n-    #[test]\n-    pub fn test_as_result() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        let x = 100;\n-        assert_eq!(right.as_result(), result::Ok(&x));\n-\n-        let x = 404;\n-        assert_eq!(left.as_result(), result::Err(&x));\n-    }\n-\n-    #[test]\n-    pub fn test_to_either() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.to_either(), Right(100));\n-        assert_eq!(left.to_either(), Left(404));\n-    }\n-\n-    #[test]\n-    pub fn test_into_either() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.into_either(), Right(100));\n-        assert_eq!(left.into_either(), Left(404));\n-    }\n-\n-    #[test]\n-    pub fn test_as_either() {\n-        let right: Either<int, int> = Right(100);\n-        let left: Either<int, int> = Left(404);\n-\n-        assert_eq!(right.as_either().unwrap_right(), &100);\n-        assert_eq!(left.as_either().unwrap_left(), &404);\n-    }\n-}"}, {"sha": "9fa2c7ab1f3b4f36a3916ac9c0875917dbffebed", "filename": "libgrust/libstd/fmt/mod.rs", "status": "removed", "additions": 0, "deletions": 1151, "changes": 1151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ffmt%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,1151 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The Formatting Module\n-\n-This module contains the runtime support for the `format!` syntax extension.\n-This macro is implemented in the compiler to emit calls to this module in order\n-to format arguments at runtime into strings and streams.\n-\n-The functions contained in this module should not normally be used in everyday\n-use cases of `format!`. The assumptions made by these functions are unsafe for\n-all inputs, and the compiler performs a large amount of validation on the\n-arguments to `format!` in order to ensure safety at runtime. While it is\n-possible to call these functions directly, it is not recommended to do so in the\n-general case.\n-\n-## Usage\n-\n-The `format!` macro is intended to be familiar to those coming from C's\n-printf/fprintf functions or Python's `str.format` function. In its current\n-revision, the `format!` macro returns a `~str` type which is the result of the\n-formatting. In the future it will also be able to pass in a stream to format\n-arguments directly while performing minimal allocations.\n-\n-Some examples of the `format!` extension are:\n-\n-```rust\n-format!(\"Hello\")                  // => ~\"Hello\"\n-format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n-format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n-format!(\"{:?}\", ~[3, 4])          // => ~\"~[3, 4]\"\n-format!(\"{value}\", value=4)       // => ~\"4\"\n-format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n-```\n-\n-From these, you can see that the first argument is a format string. It is\n-required by the compiler for this to be a string literal; it cannot be a\n-variable passed in (in order to perform validity checking). The compiler will\n-then parse the format string and determine if the list of arguments provided is\n-suitable to pass to this format string.\n-\n-### Positional parameters\n-\n-Each formatting argument is allowed to specify which value argument it's\n-referencing, and if omitted it is assumed to be \"the next argument\". For\n-example, the format string `{} {} {}` would take three parameters, and they\n-would be formatted in the same order as they're given. The format string\n-`{2} {1} {0}`, however, would format arguments in reverse order.\n-\n-Things can get a little tricky once you start intermingling the two types of\n-positional specifiers. The \"next argument\" specifier can be thought of as an\n-iterator over the argument. Each time a \"next argument\" specifier is seen, the\n-iterator advances. This leads to behavior like this:\n-\n-```rust\n-format!(\"{1} {} {0} {}\", 1, 2) // => ~\"2 1 1 2\"\n-```\n-\n-The internal iterator over the argument has not been advanced by the time the\n-first `{}` is seen, so it prints the first argument. Then upon reaching the\n-second `{}`, the iterator has advanced forward to the second argument.\n-Essentially, parameters which explicitly name their argument do not affect\n-parameters which do not name an argument in terms of positional specifiers.\n-\n-A format string is required to use all of its arguments, otherwise it is a\n-compile-time error. You may refer to the same argument more than once in the\n-format string, although it must always be referred to with the same type.\n-\n-### Named parameters\n-\n-Rust itself does not have a Python-like equivalent of named parameters to a\n-function, but the `format!` macro is a syntax extension which allows it to\n-leverage named parameters. Named parameters are listed at the end of the\n-argument list and have the syntax:\n-\n-```\n-identifier '=' expression\n-```\n-\n-For example, the following `format!` expressions all use named argument:\n-\n-```rust\n-format!(\"{argument}\", argument = \"test\")       // => ~\"test\"\n-format!(\"{name} {}\", 1, name = 2)              // => ~\"2 1\"\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3) // => ~\"a 3 ()\"\n-```\n-\n-It is illegal to put positional parameters (those without names) after arguments\n-which have names. Like positional parameters, it is illegal to provided named\n-parameters that are unused by the format string.\n-\n-### Argument types\n-\n-Each argument's type is dictated by the format string. It is a requirement that\n-every argument is only ever referred to by one type. When specifying the format\n-of an argument, however, a string like `{}` indicates no type. This is allowed,\n-and if all references to one argument do not provide a type, then the format `?`\n-is used (the type's rust-representation is printed). For example, this is an\n-invalid format string:\n-\n-```\n-{0:d} {0:s}\n-```\n-\n-Because the first argument is both referred to as an integer as well as a\n-string.\n-\n-Because formatting is done via traits, there is no requirement that the\n-`d` format actually takes an `int`, but rather it simply requires a type which\n-ascribes to the `Signed` formatting trait. There are various parameters which do\n-require a particular type, however. Namely if the syntax `{:.*s}` is used, then\n-the number of characters to print from the string precedes the actual string and\n-must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n-illegal to reference an argument as such. For example, this is another invalid\n-format string:\n-\n-```\n-{:.*s} {0:u}\n-```\n-\n-### Formatting traits\n-\n-When requesting that an argument be formatted with a particular type, you are\n-actually requesting that an argument ascribes to a particular trait. This allows\n-multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).\n-The current mapping of types to traits is:\n-\n-* `?` \u21d2 `Poly`\n-* `d` \u21d2 `Signed`\n-* `i` \u21d2 `Signed`\n-* `u` \u21d2 `Unsigned`\n-* `b` \u21d2 `Bool`\n-* `c` \u21d2 `Char`\n-* `o` \u21d2 `Octal`\n-* `x` \u21d2 `LowerHex`\n-* `X` \u21d2 `UpperHex`\n-* `s` \u21d2 `String`\n-* `p` \u21d2 `Pointer`\n-* `t` \u21d2 `Binary`\n-* `f` \u21d2 `Float`\n-* *nothing* \u21d2 `Default`\n-\n-What this means is that any type of argument which implements the\n-`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are\n-provided for these traits for a number of primitive types by the standard\n-library as well. If no format is specified (as in `{}` or `{:6}`), then the\n-format trait used is the `Default` trait. This is one of the more commonly\n-implemented traits when formatting a custom type.\n-\n-When implementing a format trait for your own time, you will have to implement a\n-method of the signature:\n-\n-```rust\n-fn fmt(value: &T, f: &mut std::fmt::Formatter);\n-```\n-\n-Your type will be passed by-reference in `value`, and then the function should\n-emit output into the `f.buf` stream. It is up to each format trait\n-implementation to correctly adhere to the requested formatting parameters. The\n-values of these parameters will be listed in the fields of the `Formatter`\n-struct. In order to help with this, the `Formatter` struct also provides some\n-helper methods. An example of implementing the formatting traits would look\n-like:\n-\n-```rust\n-use std::fmt;\n-use std::f64;\n-\n-struct Vector2D {\n-    x: int,\n-    y: int,\n-}\n-\n-impl fmt::Default for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n-        // The `f.buf` value is of the type `&mut io::Writer`, which is what th\n-        // write! macro is expecting. Note that this formatting ignores the\n-        // various flags provided to format strings.\n-        write!(f.buf, \"({}, {})\", obj.x, obj.y)\n-    }\n-}\n-\n-// Different traits allow different forms of output of a type. The meaning of\n-// this format is to print the magnitude of a vector.\n-impl fmt::Binary for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n-        let magnitude = (obj.x * obj.x + obj.y * obj.y) as f64;\n-        let magnitude = magnitude.sqrt();\n-\n-        // Respect the formatting flags by using the helper method\n-        // `pad_integral` on the Formatter object. See the method documentation\n-        // for details, and the function `pad` can be used to pad strings.\n-        let decimals = f.precision.unwrap_or(3);\n-        let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(string.as_bytes(), \"\", true);\n-    }\n-}\n-\n-fn main() {\n-    let myvector = Vector2D { x: 3, y: 4 };\n-\n-    println!(\"{}\", myvector);       // => \"(3, 4)\"\n-    println!(\"{:10.3t}\", myvector); // => \"     5.000\"\n-}\n-```\n-\n-### Related macros\n-\n-There are a number of related macros in the `format!` family. The ones that are\n-currently implemented are:\n-\n-```rust\n-format!      // described above\n-write!       // first argument is a &mut io::Writer, the destination\n-writeln!     // same as write but appends a newline\n-print!       // the format string is printed to the standard output\n-println!     // same as print but appends a newline\n-format_args! // described below.\n-```\n-\n-\n-#### `write!`\n-\n-This and `writeln` are two macros which are used to emit the format string to a\n-specified stream. This is used to prevent intermediate allocations of format\n-strings and instead directly write the output. Under the hood, this function is\n-actually invoking the `write` function defined in this module. Example usage is:\n-\n-```rust\n-use std::io;\n-\n-let mut w = io::mem::MemWriter::new();\n-write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n-```\n-\n-#### `print!`\n-\n-This and `println` emit their output to stdout. Similarly to the `write!` macro,\n-the goal of these macros is to avoid intermediate allocations when printing\n-output. Example usage is:\n-\n-```rust\n-print!(\"Hello {}!\", \"world\");\n-println!(\"I have a newline {}\", \"character at the end\");\n-```\n-\n-#### `format_args!`\n-This is a curious macro which is used to safely pass around\n-an opaque object describing the format string. This object\n-does not require any heap allocations to create, and it only\n-references information on the stack. Under the hood, all of\n-the related macros are implemented in terms of this. First\n-off, some example usage is:\n-\n-```rust\n-use std::fmt;\n-\n-format_args!(fmt::format, \"this returns {}\", \"~str\");\n-format_args!(|args| { fmt::write(my_writer, args) }, \"some {}\", \"args\");\n-format_args!(my_fn, \"format {}\", \"string\");\n-```\n-\n-The first argument of the `format_args!` macro is a function (or closure) which\n-takes one argument of type `&fmt::Arguments`. This structure can then be\n-passed to the `write` and `format` functions inside this module in order to\n-process the format string. The goal of this macro is to even further prevent\n-intermediate allocations when dealing formatting strings.\n-\n-For example, a logging library could use the standard formatting syntax, but it\n-would internally pass around this structure until it has been determined where\n-output should go to.\n-\n-It is unsafe to programmatically create an instance of `fmt::Arguments` because\n-the operations performed when executing a format string require the compile-time\n-checks provided by the compiler. The `format_args!` macro is the only method of\n-safely creating these structures, but they can be unsafely created with the\n-constructor provided.\n-\n-## Internationalization\n-\n-The formatting syntax supported by the `format!` extension supports\n-internationalization by providing \"methods\" which execute various different\n-outputs depending on the input. The syntax and methods provided are similar to\n-other internationalization systems, so again nothing should seem alien.\n-Currently two methods are supported by this extension: \"select\" and \"plural\".\n-\n-Each method will execute one of a number of clauses, and then the value of the\n-clause will become what's the result of the argument's format. Inside of the\n-cases, nested argument strings may be provided, but all formatting arguments\n-must not be done through implicit positional means. All arguments inside of each\n-case of a method must be explicitly selected by their name or their integer\n-position.\n-\n-Furthermore, whenever a case is running, the special character `#` can be used\n-to reference the string value of the argument which was selected upon. As an\n-example:\n-\n-```rust\n-format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n-```\n-\n-This example is the equivalent of `{0:s}` essentially.\n-\n-### Select\n-\n-The select method is a switch over a `&str` parameter, and the parameter *must*\n-be of the type `&str`. An example of the syntax is:\n-\n-```\n-{0, select, male{...} female{...} other{...}}\n-```\n-\n-Breaking this down, the `0`-th argument is selected upon with the `select`\n-method, and then a number of cases follow. Each case is preceded by an\n-identifier which is the match-clause to execute the given arm. In this case,\n-there are two explicit cases, `male` and `female`. The case will be executed if\n-the string argument provided is an exact match to the case selected.\n-\n-The `other` case is also a required case for all `select` methods. This arm will\n-be executed if none of the other arms matched the word being selected over.\n-\n-### Plural\n-\n-The plural method is a switch statement over a `uint` parameter, and the\n-parameter *must* be a `uint`. A plural method in its full glory can be specified\n-as:\n-\n-```\n-{0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n-```\n-\n-To break this down, the first `0` indicates that this method is selecting over\n-the value of the first positional parameter to the format string. Next, the\n-`plural` method is being executed. An optionally-supplied `offset` is then given\n-which indicates a number to subtract from argument `0` when matching. This is\n-then followed by a list of cases.\n-\n-Each case is allowed to supply a specific value to match upon with the syntax\n-`=N`. This case is executed if the value at argument `0` matches N exactly,\n-without taking the offset into account. A case may also be specified by one of\n-five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched\n-on after argument `0` has the offset taken into account. Currently the\n-definitions of `many` and `few` are hardcoded, but they are in theory defined by\n-the current locale.\n-\n-Finally, all `plural` methods must have an `other` case supplied which will be\n-executed if none of the other cases match.\n-\n-## Syntax\n-\n-The syntax for the formatting language used is drawn from other languages, so it\n-should not be too alien. Arguments are formatted with python-like syntax,\n-meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n-actual grammar for the formatting syntax is:\n-\n-```\n-format_string := <text> [ format <text> ] *\n-format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n-argument := integer | identifier\n-\n-format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n-fill := character\n-align := '<' | '>'\n-sign := '+' | '-'\n-width := count\n-precision := count | '*'\n-type := identifier | ''\n-count := parameter | integer\n-parameter := integer '$'\n-\n-function_spec := plural | select\n-select := 'select' ',' ( identifier arm ) *\n-plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n-selector := '=' integer | keyword\n-keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n-arm := '{' format_string '}'\n-```\n-\n-## Formatting Parameters\n-\n-Each argument being formatted can be transformed by a number of formatting\n-parameters (corresponding to `format_spec` in the syntax above). These\n-parameters affect the string representation of what's being formatted. This\n-syntax draws heavily from Python's, so it may seem a bit familiar.\n-\n-### Fill/Alignment\n-\n-The fill character is provided normally in conjunction with the `width`\n-parameter. This indicates that if the value being formatted is smaller than\n-`width` some extra characters will be printed around it. The extra characters\n-are specified by `fill`, and the alignment can be one of two options:\n-\n-* `<` - the argument is left-aligned in `width` columns\n-* `>` - the argument is right-aligned in `width` columns\n-\n-### Sign/#/0\n-\n-These can all be interpreted as flags for a particular formatter.\n-\n-* '+' - This is intended for numeric types and indicates that the sign should\n-        always be printed. Positive signs are never printed by default, and the\n-        negative sign is only printed by default for the `Signed` trait. This\n-        flag indicates that the correct sign (+ or -) should always be printed.\n-* '-' - Currently not used\n-* '#' - This flag is indicates that the \"alternate\" form of printing should be\n-        used. By default, this only applies to the integer formatting traits and\n-        performs like:\n-    * `x` - precedes the argument with a \"0x\"\n-    * `X` - precedes the argument with a \"0x\"\n-    * `t` - precedes the argument with a \"0b\"\n-    * `o` - precedes the argument with a \"0o\"\n-* '0' - This is used to indicate for integer formats that the padding should\n-        both be done with a `0` character as well as be sign-aware. A format\n-        like `{:08d}` would yield `00000001` for the integer `1`, while the same\n-        format would yield `-0000001` for the integer `-1`. Notice that the\n-        negative version has one fewer zero than the positive version.\n-\n-### Width\n-\n-This is a parameter for the \"minimum width\" that the format should take up. If\n-the value's string does not fill up this many characters, then the padding\n-specified by fill/alignment will be used to take up the required space.\n-\n-The default fill/alignment for non-numerics is a space and left-aligned. The\n-defaults for numeric formatters is also a space but with right-alignment. If the\n-'0' flag is specified for numerics, then the implicit fill character is '0'.\n-\n-The value for the width can also be provided as a `uint` in the list of\n-parameters by using the `2$` syntax indicating that the second argument is a\n-`uint` specifying the width.\n-\n-### Precision\n-\n-For non-numeric types, this can be considered a \"maximum width\". If the\n-resulting string is longer than this width, then it is truncated down to this\n-many characters and only those are emitted.\n-\n-For integral types, this has no meaning currently.\n-\n-For floating-point types, this indicates how many digits after the decimal point\n-should be printed.\n-\n-## Escaping\n-\n-The literal characters `{`, `}`, or `#` may be included in a string by\n-preceding them with the `\\` character. Since `\\` is already an\n-escape character in Rust strings, a string literal using this escape\n-will look like `\"\\\\{\"`.\n-\n-*/\n-\n-use prelude::*;\n-\n-use cast;\n-use char::Char;\n-use io::Decorator;\n-use io::mem::MemWriter;\n-use io;\n-use str;\n-use repr;\n-use util;\n-use vec;\n-\n-pub mod parse;\n-pub mod rt;\n-\n-/// A struct to represent both where to emit formatting strings to and how they\n-/// should be formatted. A mutable version of this is passed to all formatting\n-/// traits.\n-pub struct Formatter<'self> {\n-    /// Flags for formatting (packed version of rt::Flag)\n-    flags: uint,\n-    /// Character used as 'fill' whenever there is alignment\n-    fill: char,\n-    /// Boolean indication of whether the output should be left-aligned\n-    align: parse::Alignment,\n-    /// Optionally specified integer width that the output should be\n-    width: Option<uint>,\n-    /// Optionally specified precision for numeric types\n-    precision: Option<uint>,\n-\n-    /// Output buffer.\n-    buf: &'self mut io::Writer,\n-    priv curarg: vec::VecIterator<'self, Argument<'self>>,\n-    priv args: &'self [Argument<'self>],\n-}\n-\n-/// This struct represents the generic \"argument\" which is taken by the Xprintf\n-/// family of functions. It contains a function to format the given value. At\n-/// compile time it is ensured that the function and the value have the correct\n-/// types, and then this struct is used to canonicalize arguments to one type.\n-pub struct Argument<'self> {\n-    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n-    priv value: &'self util::Void,\n-}\n-\n-impl<'self> Arguments<'self> {\n-    /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n-    /// which is valid because the compiler performs all necessary validation to\n-    /// ensure that the resulting call to format/write would be safe.\n-    #[doc(hidden)] #[inline]\n-    pub unsafe fn new<'a>(fmt: &'static [rt::Piece<'static>],\n-                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments{ fmt: cast::transmute(fmt), args: args }\n-    }\n-}\n-\n-/// This structure represents a safely precompiled version of a format string\n-/// and its arguments. This cannot be generated at runtime because it cannot\n-/// safely be done so, so no constructors are given and the fields are private\n-/// to prevent modification.\n-///\n-/// The `format_args!` macro will safely create an instance of this structure\n-/// and pass it to a user-supplied function. The macro validates the format\n-/// string at compile-time so usage of the `write` and `format` functions can\n-/// be safely performed.\n-pub struct Arguments<'self> {\n-    priv fmt: &'self [rt::Piece<'self>],\n-    priv args: &'self [Argument<'self>],\n-}\n-\n-/// When a format is not otherwise specified, types are formatted by ascribing\n-/// to this trait. There is not an explicit way of selecting this trait to be\n-/// used for formatting, it is only if no other format is specified.\n-#[allow(missing_doc)]\n-pub trait Default { fn fmt(&Self, &mut Formatter); }\n-\n-/// Format trait for the `b` character\n-#[allow(missing_doc)]\n-pub trait Bool { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `c` character\n-#[allow(missing_doc)]\n-pub trait Char { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `i` and `d` characters\n-#[allow(missing_doc)]\n-pub trait Signed { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `u` character\n-#[allow(missing_doc)]\n-pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `o` character\n-#[allow(missing_doc)]\n-pub trait Octal { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `b` character\n-#[allow(missing_doc)]\n-pub trait Binary { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `x` character\n-#[allow(missing_doc)]\n-pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `X` character\n-#[allow(missing_doc)]\n-pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `s` character\n-#[allow(missing_doc)]\n-pub trait String { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `?` character\n-#[allow(missing_doc)]\n-pub trait Poly { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `p` character\n-#[allow(missing_doc)]\n-pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n-/// Format trait for the `f` character\n-#[allow(missing_doc)]\n-pub trait Float { fn fmt(&Self, &mut Formatter); }\n-\n-/// The `write` function takes an output stream, a precompiled format string,\n-/// and a list of arguments. The arguments will be formatted according to the\n-/// specified format string into the output stream provided.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * args - the precompiled arguments generated by `format_args!`\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-/// let w: &mut io::Writer = ...;\n-/// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n-/// ```\n-pub fn write(output: &mut io::Writer, args: &Arguments) {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-}\n-\n-/// The `writeln` function takes the same arguments as `write`, except that it\n-/// will also write a newline (`\\n`) character at the end of the format string.\n-pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-    output.write(['\\n' as u8]);\n-}\n-\n-/// The `write_unsafe` function takes an output stream, a precompiled format\n-/// string, and a list of arguments. The arguments will be formatted according\n-/// to the specified format string into the output stream provided.\n-///\n-/// See the documentation for `format` for why this function is unsafe and care\n-/// should be taken if calling it manually.\n-///\n-/// Thankfully the rust compiler provides the macro `fmtf!` which will perform\n-/// all of this validation at compile-time and provides a safe interface for\n-/// invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * output - the buffer to write output to\n-///   * fmts - the precompiled format string to emit\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn write_unsafe(output: &mut io::Writer,\n-                           fmt: &[rt::Piece],\n-                           args: &[Argument]) {\n-    let mut formatter = Formatter {\n-        flags: 0,\n-        width: None,\n-        precision: None,\n-        buf: output,\n-        align: parse::AlignUnknown,\n-        fill: ' ',\n-        args: args,\n-        curarg: args.iter(),\n-    };\n-    for piece in fmt.iter() {\n-        formatter.run(piece, None);\n-    }\n-}\n-\n-/// The format function takes a precompiled format string and a list of\n-/// arguments, to return the resulting formatted string.\n-///\n-/// # Arguments\n-///\n-///   * args - a structure of arguments generated via the `format_args!` macro.\n-///            Because this structure can only be safely generated at\n-///            compile-time, this function is safe.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::fmt;\n-/// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\");\n-/// ```\n-pub fn format(args: &Arguments) -> ~str {\n-    unsafe { format_unsafe(args.fmt, args.args) }\n-}\n-\n-/// The unsafe version of the formatting function.\n-///\n-/// This is currently an unsafe function because the types of all arguments\n-/// aren't verified by immediate callers of this function. This currently does\n-/// not validate that the correct types of arguments are specified for each\n-/// format specifier, nor that each argument itself contains the right function\n-/// for formatting the right type value. Because of this, the function is marked\n-/// as `unsafe` if this is being called manually.\n-///\n-/// Thankfully the rust compiler provides the macro `format!` which will perform\n-/// all of this validation at compile-time and provides a safe interface for\n-/// invoking this function.\n-///\n-/// # Arguments\n-///\n-///   * fmts - the precompiled format string to emit.\n-///   * args - the list of arguments to the format string. These are only the\n-///            positional arguments (not named)\n-///\n-/// Note that this function assumes that there are enough arguments for the\n-/// format string.\n-pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n-    let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args);\n-    return str::from_utf8_owned(output.inner());\n-}\n-\n-impl<'self> Formatter<'self> {\n-\n-    // First up is the collection of functions used to execute a format string\n-    // at runtime. This consumes all of the compile-time statics generated by\n-    // the format! syntax extension.\n-\n-    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n-        match *piece {\n-            rt::String(s) => { self.buf.write(s.as_bytes()); }\n-            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n-            rt::Argument(ref arg) => {\n-                // Fill in the format parameters into the formatter\n-                self.fill = arg.format.fill;\n-                self.align = arg.format.align;\n-                self.flags = arg.format.flags;\n-                self.width = self.getcount(&arg.format.width);\n-                self.precision = self.getcount(&arg.format.precision);\n-\n-                // Extract the correct argument\n-                let value = match arg.position {\n-                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n-                    rt::ArgumentIs(i) => self.args[i],\n-                };\n-\n-                // Then actually do some printing\n-                match arg.method {\n-                    None => { (value.formatter)(value.value, self); }\n-                    Some(ref method) => { self.execute(*method, value); }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n-        match *cnt {\n-            rt::CountIs(n) => { Some(n) }\n-            rt::CountImplied => { None }\n-            rt::CountIsParam(i) => {\n-                let v = self.args[i].value;\n-                unsafe { Some(*(v as *util::Void as *uint)) }\n-            }\n-            rt::CountIsNextParam => {\n-                let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *util::Void as *uint)) }\n-            }\n-        }\n-    }\n-\n-    fn execute(&mut self, method: &rt::Method, arg: Argument) {\n-        match *method {\n-            // Pluralization is selection upon a numeric value specified as the\n-            // parameter.\n-            rt::Plural(offset, ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // '&uint' value.\n-                let value: &uint = unsafe { cast::transmute(arg.value) };\n-                let value = *value;\n-\n-                // First, attempt to match against explicit values without the\n-                // offsetted value\n-                for s in selectors.iter() {\n-                    match s.selector {\n-                        Right(val) if value == val => {\n-                            return self.runplural(value, s.result);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Next, offset the value and attempt to match against the\n-                // keyword selectors.\n-                let value = value - match offset { Some(i) => i, None => 0 };\n-                for s in selectors.iter() {\n-                    let run = match s.selector {\n-                        Left(parse::Zero) => value == 0,\n-                        Left(parse::One) => value == 1,\n-                        Left(parse::Two) => value == 2,\n-\n-                        // XXX: Few/Many should have a user-specified boundary\n-                        //      One possible option would be in the function\n-                        //      pointer of the 'arg: Argument' struct.\n-                        Left(parse::Few) => value < 8,\n-                        Left(parse::Many) => value >= 8,\n-\n-                        Right(..) => false\n-                    };\n-                    if run {\n-                        return self.runplural(value, s.result);\n-                    }\n-                }\n-\n-                self.runplural(value, *default);\n-            }\n-\n-            // Select is just a matching against the string specified.\n-            rt::Select(ref selectors, ref default) => {\n-                // This is validated at compile-time to be a pointer to a\n-                // string slice,\n-                let value: & &str = unsafe { cast::transmute(arg.value) };\n-                let value = *value;\n-\n-                for s in selectors.iter() {\n-                    if s.selector == value {\n-                        for piece in s.result.iter() {\n-                            self.run(piece, Some(value));\n-                        }\n-                        return;\n-                    }\n-                }\n-                for piece in default.iter() {\n-                    self.run(piece, Some(value));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n-        ::uint::to_str_bytes(value, 10, |buf| {\n-            let valuestr = str::from_utf8_slice(buf);\n-            for piece in pieces.iter() {\n-                self.run(piece, Some(valuestr));\n-            }\n-        })\n-    }\n-\n-    // Helper methods used for padding and processing formatting arguments that\n-    // all formatting traits can use.\n-\n-    /// Performs the correct padding for an integer which has already been\n-    /// emitted into a byte-array. The byte-array should *not* contain the sign\n-    /// for the integer, that will be added by this method.\n-    ///\n-    /// # Arguments\n-    ///\n-    ///     * s - the byte array that the number has been formatted into\n-    ///     * alternate_prefix - if the '#' character (FlagAlternate) is\n-    ///       provided, this is the prefix to put in front of the number.\n-    ///       Currently this is 0x/0o/0b/etc.\n-    ///     * positive - whether the original integer was positive or not.\n-    ///\n-    /// This function will correctly account for the flags provided as well as\n-    /// the minimum width. It will not take precision into account.\n-    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n-                        positive: bool) {\n-        use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n-\n-        let mut actual_len = s.len();\n-        if self.flags & 1 << (FlagAlternate as uint) != 0 {\n-            actual_len += alternate_prefix.len();\n-        }\n-        if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n-            actual_len += 1;\n-        } else if !positive {\n-            actual_len += 1;\n-        }\n-\n-        let mut signprinted = false;\n-        let sign = |this: &mut Formatter| {\n-            if !signprinted {\n-                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    this.buf.write(['+' as u8]);\n-                } else if !positive {\n-                    this.buf.write(['-' as u8]);\n-                }\n-                if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    this.buf.write(alternate_prefix.as_bytes());\n-                }\n-                signprinted = true;\n-            }\n-        };\n-\n-        let emit = |this: &mut Formatter| {\n-            sign(this);\n-            this.buf.write(s);\n-        };\n-\n-        match self.width {\n-            None => { emit(self) }\n-            Some(min) if actual_len >= min => { emit(self) }\n-            Some(min) => {\n-                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n-                    self.fill = '0';\n-                    sign(self);\n-                }\n-                self.with_padding(min - actual_len, parse::AlignRight, |me| {\n-                    emit(me);\n-                })\n-            }\n-        }\n-    }\n-\n-    /// This function takes a string slice and emits it to the internal buffer\n-    /// after applying the relevant formatting flags specified. The flags\n-    /// recognized for generic strings are:\n-    ///\n-    /// * width - the minimum width of what to emit\n-    /// * fill/align - what to emit and where to emit it if the string\n-    ///                provided needs to be padded\n-    /// * precision - the maximum length to emit, the string is truncated if it\n-    ///               is longer than this length\n-    ///\n-    /// Notably this function ignored the `flag` parameters\n-    pub fn pad(&mut self, s: &str) {\n-        // Make sure there's a fast path up front\n-        if self.width.is_none() && self.precision.is_none() {\n-            self.buf.write(s.as_bytes());\n-            return\n-        }\n-        // The `precision` field can be interpreted as a `max-width` for the\n-        // string being formatted\n-        match self.precision {\n-            Some(max) => {\n-                // If there's a maximum width and our string is longer than\n-                // that, then we must always have truncation. This is the only\n-                // case where the maximum length will matter.\n-                let char_len = s.char_len();\n-                if char_len >= max {\n-                    let nchars = ::uint::min(max, char_len);\n-                    self.buf.write(s.slice_chars(0, nchars).as_bytes());\n-                    return\n-                }\n-            }\n-            None => {}\n-        }\n-\n-        // The `width` field is more of a `min-width` parameter at this point.\n-        match self.width {\n-            // If we're under the maximum length, and there's no minimum length\n-            // requirements, then we can just emit the string\n-            None => { self.buf.write(s.as_bytes()) }\n-\n-            // If we're under the maximum width, check if we're over the minimum\n-            // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.char_len() >= width => {\n-                self.buf.write(s.as_bytes())\n-            }\n-\n-            // If we're under both the maximum and the minimum width, then fill\n-            // up the minimum width with the specified string + some alignment.\n-            Some(width) => {\n-                self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes());\n-                })\n-            }\n-        }\n-    }\n-\n-    fn with_padding(&mut self,\n-                    padding: uint,\n-                    default: parse::Alignment,\n-                    f: |&mut Formatter|) {\n-        let align = match self.align {\n-            parse::AlignUnknown => default,\n-            parse::AlignLeft | parse::AlignRight => self.align\n-        };\n-        if align == parse::AlignLeft {\n-            f(self);\n-        }\n-        let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill);\n-        for _ in range(0, padding) {\n-            self.buf.write(fill.slice_to(len));\n-        }\n-        if align == parse::AlignRight {\n-            f(self);\n-        }\n-    }\n-}\n-\n-/// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `format` function.\n-#[doc(hidden)] #[inline]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n-                       t: &'a T) -> Argument<'a> {\n-    unsafe {\n-        Argument {\n-            formatter: cast::transmute(f),\n-            value: cast::transmute(t)\n-        }\n-    }\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a string\n-/// (such as for select), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(String::fmt, s)\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for plural), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Unsigned::fmt, s)\n-}\n-\n-// Implementations of the core formatting traits\n-\n-impl Bool for bool {\n-    fn fmt(b: &bool, f: &mut Formatter) {\n-        String::fmt(&(if *b {\"true\"} else {\"false\"}), f);\n-    }\n-}\n-\n-impl<'self, T: str::Str> String for T {\n-    fn fmt(s: &T, f: &mut Formatter) {\n-        f.pad(s.as_slice());\n-    }\n-}\n-\n-impl Char for char {\n-    fn fmt(c: &char, f: &mut Formatter) {\n-        let mut utf8 = [0u8, ..4];\n-        let amt = c.encode_utf8(utf8);\n-        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n-        String::fmt(&s, f);\n-    }\n-}\n-\n-macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n-                       $name:ident, $prefix:expr) => {\n-    impl $name for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n-            ::$into::to_str_bytes(*c as $into, $base, |buf| {\n-                f.pad_integral(buf, $prefix, true);\n-            })\n-        }\n-    }\n-})\n-macro_rules! upper_hex(($ty:ident, $into:ident) => {\n-    impl UpperHex for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n-            ::$into::to_str_bytes(*c as $into, 16, |buf| {\n-                upperhex(buf, f);\n-            })\n-        }\n-    }\n-})\n-// Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n-// when inlined into the above macro...\n-#[doc(hidden)]\n-pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n-    let mut local = [0u8, ..16];\n-    for i in ::iter::range(0, buf.len()) {\n-        local[i] = match buf[i] as char {\n-            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n-            c => c as u8,\n-        }\n-    }\n-    f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n-}\n-\n-// FIXME(#4375) shouldn't need an inner module\n-macro_rules! integer(($signed:ident, $unsigned:ident) => {\n-    mod $signed {\n-        use super::*;\n-\n-        // Signed is special because it actuall emits the negative sign,\n-        // nothing else should do that, however.\n-        impl Signed for $signed {\n-            fn fmt(c: &$signed, f: &mut Formatter) {\n-                ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                    f.pad_integral(buf, \"\", *c >= 0);\n-                })\n-            }\n-        }\n-        int_base!($signed, $unsigned, 2, Binary, \"0b\")\n-        int_base!($signed, $unsigned, 8, Octal, \"0o\")\n-        int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n-        upper_hex!($signed, $unsigned)\n-\n-        int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n-        int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n-        int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n-        int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n-        upper_hex!($unsigned, $unsigned)\n-    }\n-})\n-\n-integer!(int, uint)\n-integer!(i8, u8)\n-integer!(i16, u16)\n-integer!(i32, u32)\n-integer!(i64, u64)\n-\n-macro_rules! floating(($ty:ident) => {\n-    impl Float for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n-            // XXX: this shouldn't perform an allocation\n-            let s = match fmt.precision {\n-                Some(i) => ::$ty::to_str_exact(f.abs(), i),\n-                None => ::$ty::to_str_digits(f.abs(), 6)\n-            };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n-        }\n-    }\n-})\n-floating!(f32)\n-floating!(f64)\n-\n-impl<T> Poly for T {\n-    fn fmt(t: &T, f: &mut Formatter) {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                repr::write_repr(f.buf, t);\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_str(t);\n-                f.pad(s);\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Pointer for *T {\n-    fn fmt(t: &*T, f: &mut Formatter) {\n-        f.flags |= 1 << (parse::FlagAlternate as uint);\n-        ::uint::to_str_bytes(*t as uint, 16, |buf| {\n-            f.pad_integral(buf, \"0x\", true);\n-        })\n-    }\n-}\n-impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) { Pointer::fmt(&(*t as *T), f) }\n-}\n-\n-// Implementation of Default for various core types\n-\n-macro_rules! delegate(($ty:ty to $other:ident) => {\n-    impl<'self> Default for $ty {\n-        fn fmt(me: &$ty, f: &mut Formatter) {\n-            $other::fmt(me, f)\n-        }\n-    }\n-})\n-delegate!(int to Signed)\n-delegate!( i8 to Signed)\n-delegate!(i16 to Signed)\n-delegate!(i32 to Signed)\n-delegate!(i64 to Signed)\n-delegate!(uint to Unsigned)\n-delegate!(  u8 to Unsigned)\n-delegate!( u16 to Unsigned)\n-delegate!( u32 to Unsigned)\n-delegate!( u64 to Unsigned)\n-delegate!(@str to String)\n-delegate!(~str to String)\n-delegate!(&'self str to String)\n-delegate!(bool to Bool)\n-delegate!(char to Char)\n-delegate!(f32 to Float)\n-delegate!(f64 to Float)\n-\n-impl<T> Default for *T {\n-    fn fmt(me: &*T, f: &mut Formatter) { Pointer::fmt(me, f) }\n-}\n-impl<T> Default for *mut T {\n-    fn fmt(me: &*mut T, f: &mut Formatter) { Pointer::fmt(me, f) }\n-}\n-\n-// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n-// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "6489ff79205b4886393775cffdd42266ab7c33c4", "filename": "libgrust/libstd/fmt/parse.rs", "status": "removed", "additions": 0, "deletions": 964, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ffmt%2Fparse.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,964 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Parsing of format strings\n-//!\n-//! These structures are used when parsing format strings for the compiler.\n-//! Parsing does not currently happen at runtime (structures of std::fmt::rt are\n-//! generated instead).\n-\n-use prelude::*;\n-\n-use char;\n-use str;\n-\n-condition! { pub parse_error: ~str -> (); }\n-\n-/// A piece is a portion of the format string which represents the next part to\n-/// emit. These are emitted as a stream by the `Parser` class.\n-#[deriving(Eq)]\n-pub enum Piece<'self> {\n-    /// A literal string which should directly be emitted\n-    String(&'self str),\n-    /// A back-reference to whatever the current argument is. This is used\n-    /// inside of a method call to refer back to the original argument.\n-    CurrentArgument,\n-    /// This describes that formatting should process the next argument (as\n-    /// specified inside) for emission.\n-    Argument(Argument<'self>),\n-}\n-\n-/// Representation of an argument specification.\n-#[deriving(Eq)]\n-pub struct Argument<'self> {\n-    /// Where to find this argument\n-    position: Position<'self>,\n-    /// How to format the argument\n-    format: FormatSpec<'self>,\n-    /// If not `None`, what method to invoke on the argument\n-    method: Option<~Method<'self>>\n-}\n-\n-/// Specification for the formatting of an argument in the format string.\n-#[deriving(Eq)]\n-pub struct FormatSpec<'self> {\n-    /// Optionally specified character to fill alignment with\n-    fill: Option<char>,\n-    /// Optionally specified alignment\n-    align: Alignment,\n-    /// Packed version of various flags provided\n-    flags: uint,\n-    /// The integer precision to use\n-    precision: Count<'self>,\n-    /// The string width requested for the resulting format\n-    width: Count<'self>,\n-    /// The descriptor string representing the name of the format desired for\n-    /// this argument, this can be empty or any number of characters, although\n-    /// it is required to be one word.\n-    ty: &'self str\n-}\n-\n-/// Enum describing where an argument for a format can be located.\n-#[deriving(Eq)]\n-#[allow(missing_doc)]\n-pub enum Position<'self> {\n-    ArgumentNext, ArgumentIs(uint), ArgumentNamed(&'self str)\n-}\n-\n-/// Enum of alignments which are supported.\n-#[deriving(Eq)]\n-#[allow(missing_doc)]\n-pub enum Alignment { AlignLeft, AlignRight, AlignUnknown }\n-\n-/// Various flags which can be applied to format strings, the meaning of these\n-/// flags is defined by the formatters themselves.\n-#[deriving(Eq)]\n-#[allow(missing_doc)]\n-pub enum Flag {\n-    FlagSignPlus,\n-    FlagSignMinus,\n-    FlagAlternate,\n-    FlagSignAwareZeroPad,\n-}\n-\n-/// A count is used for the precision and width parameters of an integer, and\n-/// can reference either an argument or a literal integer.\n-#[deriving(Eq)]\n-#[allow(missing_doc)]\n-pub enum Count<'self> {\n-    CountIs(uint),\n-    CountIsName(&'self str),\n-    CountIsParam(uint),\n-    CountIsNextParam,\n-    CountImplied,\n-}\n-\n-/// Enum describing all of the possible methods which the formatting language\n-/// currently supports.\n-#[deriving(Eq)]\n-pub enum Method<'self> {\n-    /// A plural method selects on an integer over a list of either integer or\n-    /// keyword-defined clauses. The meaning of the keywords is defined by the\n-    /// current locale.\n-    ///\n-    /// An offset is optionally present at the beginning which is used to match\n-    /// against keywords, but it is not matched against the literal integers.\n-    ///\n-    /// The final element of this enum is the default \"other\" case which is\n-    /// always required to be specified.\n-    Plural(Option<uint>, ~[PluralArm<'self>], ~[Piece<'self>]),\n-\n-    /// A select method selects over a string. Each arm is a different string\n-    /// which can be selected for.\n-    ///\n-    /// As with `Plural`, a default \"other\" case is required as well.\n-    Select(~[SelectArm<'self>], ~[Piece<'self>]),\n-}\n-\n-/// Structure representing one \"arm\" of the `plural` function.\n-#[deriving(Eq)]\n-pub struct PluralArm<'self> {\n-    /// A selector can either be specified by a keyword or with an integer\n-    /// literal.\n-    selector: Either<PluralKeyword, uint>,\n-    /// Array of pieces which are the format of this arm\n-    result: ~[Piece<'self>],\n-}\n-\n-/// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that is\n-/// specially placed in the `Plural` variant of `Method`\n-///\n-/// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(Eq, IterBytes)]\n-#[allow(missing_doc)]\n-pub enum PluralKeyword {\n-    Zero, One, Two, Few, Many\n-}\n-\n-/// Structure representing one \"arm\" of the `select` function.\n-#[deriving(Eq)]\n-pub struct SelectArm<'self> {\n-    /// String selector which guards this arm\n-    selector: &'self str,\n-    /// Array of pieces which are the format of this arm\n-    result: ~[Piece<'self>],\n-}\n-\n-/// The parser structure for interpreting the input format string. This is\n-/// modelled as an iterator over `Piece` structures to form a stream of tokens\n-/// being output.\n-///\n-/// This is a recursive-descent parser for the sake of simplicity, and if\n-/// necessary there's probably lots of room for improvement performance-wise.\n-pub struct Parser<'self> {\n-    priv input: &'self str,\n-    priv cur: str::CharOffsetIterator<'self>,\n-    priv depth: uint,\n-}\n-\n-impl<'self> Iterator<Piece<'self>> for Parser<'self> {\n-    fn next(&mut self) -> Option<Piece<'self>> {\n-        match self.cur.clone().next() {\n-            Some((_, '#')) => { self.cur.next(); Some(CurrentArgument) }\n-            Some((_, '{')) => {\n-                self.cur.next();\n-                let ret = Some(Argument(self.argument()));\n-                self.must_consume('}');\n-                ret\n-            }\n-            Some((pos, '\\\\')) => {\n-                self.cur.next();\n-                self.escape(); // ensure it's a valid escape sequence\n-                Some(String(self.string(pos + 1))) // skip the '\\' character\n-            }\n-            Some((_, '}')) if self.depth == 0 => {\n-                self.cur.next();\n-                self.err(\"unmatched `}` found\");\n-                None\n-            }\n-            Some((_, '}')) | None => { None }\n-            Some((pos, _)) => {\n-                Some(String(self.string(pos)))\n-            }\n-        }\n-    }\n-}\n-\n-impl<'self> Parser<'self> {\n-    /// Creates a new parser for the given format string\n-    pub fn new<'a>(s: &'a str) -> Parser<'a> {\n-        Parser {\n-            input: s,\n-            cur: s.char_indices(),\n-            depth: 0,\n-        }\n-    }\n-\n-    /// Notifies of an error. The message doesn't actually need to be of type\n-    /// ~str, but I think it does when this eventually uses conditions so it\n-    /// might as well start using it now.\n-    fn err(&self, msg: &str) {\n-        parse_error::cond.raise(\"invalid format string: \" + msg);\n-    }\n-\n-    /// Optionally consumes the specified character. If the character is not at\n-    /// the current position, then the current iterator isn't moved and false is\n-    /// returned, otherwise the character is consumed and true is returned.\n-    fn consume(&mut self, c: char) -> bool {\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n-                self.cur.next();\n-                true\n-            }\n-            Some(..) | None => false,\n-        }\n-    }\n-\n-    /// Forces consumption of the specified character. If the character is not\n-    /// found, an error is emitted.\n-    fn must_consume(&mut self, c: char) {\n-        self.ws();\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n-                self.cur.next();\n-            }\n-            Some((_, other)) => {\n-                self.err(\n-                    format!(\"expected `{}` but found `{}`\", c, other));\n-            }\n-            None => {\n-                self.err(\n-                    format!(\"expected `{}` but string was terminated\", c));\n-            }\n-        }\n-    }\n-\n-    /// Attempts to consume any amount of whitespace followed by a character\n-    fn wsconsume(&mut self, c: char) -> bool {\n-        self.ws(); self.consume(c)\n-    }\n-\n-    /// Consumes all whitespace characters until the first non-whitespace\n-    /// character\n-    fn ws(&mut self) {\n-        loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n-                Some(..) | None => { return }\n-            }\n-        }\n-    }\n-\n-    /// Consumes an escape sequence, failing if there is not a valid character\n-    /// to be escaped.\n-    fn escape(&mut self) -> char {\n-        match self.cur.next() {\n-            Some((_, c @ '#')) | Some((_, c @ '{')) |\n-            Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n-            Some((_, c)) => {\n-                self.err(format!(\"invalid escape character `{}`\", c));\n-                c\n-            }\n-            None => {\n-                self.err(\"expected an escape sequence, but format string was \\\n-                           terminated\");\n-                ' '\n-            }\n-        }\n-    }\n-\n-    /// Parses all of a string which is to be considered a \"raw literal\" in a\n-    /// format string. This is everything outside of the braces.\n-    fn string(&mut self, start: uint) -> &'self str {\n-        loop {\n-            // we may not consume the character, so clone the iterator\n-            match self.cur.clone().next() {\n-                Some((pos, '\\\\')) | Some((pos, '#')) |\n-                Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input.slice(start, pos);\n-                }\n-                Some(..) => { self.cur.next(); }\n-                None => {\n-                    self.cur.next();\n-                    return self.input.slice(start, self.input.len());\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Parses an Argument structure, or what's contained within braces inside\n-    /// the format string\n-    fn argument(&mut self) -> Argument<'self> {\n-        Argument {\n-            position: self.position(),\n-            format: self.format(),\n-            method: self.method(),\n-        }\n-    }\n-\n-    /// Parses a positional argument for a format. This could either be an\n-    /// integer index of an argument, a named argument, or a blank string.\n-    fn position(&mut self) -> Position<'self> {\n-        match self.integer() {\n-            Some(i) => { ArgumentIs(i) }\n-            None => {\n-                match self.cur.clone().next() {\n-                    Some((_, c)) if char::is_alphabetic(c) => {\n-                        ArgumentNamed(self.word())\n-                    }\n-                    _ => ArgumentNext\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Parses a format specifier at the current position, returning all of the\n-    /// relevant information in the FormatSpec struct.\n-    fn format(&mut self) -> FormatSpec<'self> {\n-        let mut spec = FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            width: CountImplied,\n-            ty: self.input.slice(0, 0),\n-        };\n-        if !self.consume(':') { return spec }\n-\n-        // fill character\n-        match self.cur.clone().next() {\n-            Some((_, c)) => {\n-                match self.cur.clone().skip(1).next() {\n-                    Some((_, '>')) | Some((_, '<')) => {\n-                        spec.fill = Some(c);\n-                        self.cur.next();\n-                    }\n-                    Some(..) | None => {}\n-                }\n-            }\n-            None => {}\n-        }\n-        // Alignment\n-        if self.consume('<') {\n-            spec.align = AlignLeft;\n-        } else if self.consume('>') {\n-            spec.align = AlignRight;\n-        }\n-        // Sign flags\n-        if self.consume('+') {\n-            spec.flags |= 1 << (FlagSignPlus as uint);\n-        } else if self.consume('-') {\n-            spec.flags |= 1 << (FlagSignMinus as uint);\n-        }\n-        // Alternate marker\n-        if self.consume('#') {\n-            spec.flags |= 1 << (FlagAlternate as uint);\n-        }\n-        // Width and precision\n-        let mut havewidth = false;\n-        if self.consume('0') {\n-            // small ambiguity with '0$' as a format string. In theory this is a\n-            // '0' flag and then an ill-formatted format string with just a '$'\n-            // and no count, but this is better if we instead interpret this as\n-            // no '0' flag and '0$' as the width instead.\n-            if self.consume('$') {\n-                spec.width = CountIsParam(0);\n-                havewidth = true;\n-            } else {\n-                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n-            }\n-        }\n-        if !havewidth {\n-            spec.width = self.count();\n-        }\n-        if self.consume('.') {\n-            if self.consume('*') {\n-                spec.precision = CountIsNextParam;\n-            } else {\n-                spec.precision = self.count();\n-            }\n-        }\n-        // Finally the actual format specifier\n-        if self.consume('?') {\n-            spec.ty = \"?\";\n-        } else {\n-            spec.ty = self.word();\n-        }\n-        return spec;\n-    }\n-\n-    /// Parses a method to be applied to the previously specified argument and\n-    /// its format. The two current supported methods are 'plural' and 'select'\n-    fn method(&mut self) -> Option<~Method<'self>> {\n-        if !self.wsconsume(',') {\n-            return None;\n-        }\n-        self.ws();\n-        match self.word() {\n-            \"select\" => {\n-                self.must_consume(',');\n-                Some(self.select())\n-            }\n-            \"plural\" => {\n-                self.must_consume(',');\n-                Some(self.plural())\n-            }\n-            \"\" => {\n-                self.err(\"expected method after comma\");\n-                return None;\n-            }\n-            method => {\n-                self.err(format!(\"unknown method: `{}`\", method));\n-                return None;\n-            }\n-        }\n-    }\n-\n-    /// Parses a 'select' statement (after the initial 'select' word)\n-    fn select(&mut self) -> ~Method<'self> {\n-        let mut other = None;\n-        let mut arms = ~[];\n-        // Consume arms one at a time\n-        loop {\n-            self.ws();\n-            let selector = self.word();\n-            if selector == \"\" {\n-                self.err(\"cannot have an empty selector\");\n-                break\n-            }\n-            self.must_consume('{');\n-            self.depth += 1;\n-            let pieces = self.collect();\n-            self.depth -= 1;\n-            self.must_consume('}');\n-            if selector == \"other\" {\n-                if !other.is_none() {\n-                    self.err(\"multiple `other` statements in `select\");\n-                }\n-                other = Some(pieces);\n-            } else {\n-                arms.push(SelectArm { selector: selector, result: pieces });\n-            }\n-            self.ws();\n-            match self.cur.clone().next() {\n-                Some((_, '}')) => { break }\n-                Some(..) | None => {}\n-            }\n-        }\n-        // The \"other\" selector must be present\n-        let other = match other {\n-            Some(arm) => { arm }\n-            None => {\n-                self.err(\"`select` statement must provide an `other` case\");\n-                ~[]\n-            }\n-        };\n-        ~Select(arms, other)\n-    }\n-\n-    /// Parses a 'plural' statement (after the initial 'plural' word)\n-    fn plural(&mut self) -> ~Method<'self> {\n-        let mut offset = None;\n-        let mut other = None;\n-        let mut arms = ~[];\n-\n-        // First, attempt to parse the 'offset:' field. We know the set of\n-        // selector words which can appear in plural arms, and the only ones\n-        // which start with 'o' are \"other\" and \"offset\", hence look two\n-        // characters deep to see if we can consume the word \"offset\"\n-        self.ws();\n-        let mut it = self.cur.clone();\n-        match it.next() {\n-            Some((_, 'o')) => {\n-                match it.next() {\n-                    Some((_, 'f')) => {\n-                        let word = self.word();\n-                        if word != \"offset\" {\n-                            self.err(format!(\"expected `offset`, found `{}`\",\n-                                             word));\n-                        } else {\n-                            self.must_consume(':');\n-                            match self.integer() {\n-                                Some(i) => { offset = Some(i); }\n-                                None => {\n-                                    self.err(\"offset must be an integer\");\n-                                }\n-                            }\n-                        }\n-                    }\n-                    Some(..) | None => {}\n-                }\n-            }\n-            Some(..) | None => {}\n-        }\n-\n-        // Next, generate all the arms\n-        loop {\n-            let mut isother = false;\n-            let selector = if self.wsconsume('=') {\n-                match self.integer() {\n-                    Some(i) => Right(i),\n-                    None => {\n-                        self.err(\"plural `=` selectors must be followed by an \\\n-                                  integer\");\n-                        Right(0)\n-                    }\n-                }\n-            } else {\n-                let word = self.word();\n-                match word {\n-                    \"other\" => { isother = true; Left(Zero) }\n-                    \"zero\"  => Left(Zero),\n-                    \"one\"   => Left(One),\n-                    \"two\"   => Left(Two),\n-                    \"few\"   => Left(Few),\n-                    \"many\"  => Left(Many),\n-                    word    => {\n-                        self.err(format!(\"unexpected plural selector `{}`\",\n-                                         word));\n-                        if word == \"\" {\n-                            break\n-                        } else {\n-                            Left(Zero)\n-                        }\n-                    }\n-                }\n-            };\n-            self.must_consume('{');\n-            self.depth += 1;\n-            let pieces = self.collect();\n-            self.depth -= 1;\n-            self.must_consume('}');\n-            if isother {\n-                if !other.is_none() {\n-                    self.err(\"multiple `other` statements in `select\");\n-                }\n-                other = Some(pieces);\n-            } else {\n-                arms.push(PluralArm { selector: selector, result: pieces });\n-            }\n-            self.ws();\n-            match self.cur.clone().next() {\n-                Some((_, '}')) => { break }\n-                Some(..) | None => {}\n-            }\n-        }\n-\n-        let other = match other {\n-            Some(arm) => { arm }\n-            None => {\n-                self.err(\"`plural` statement must provide an `other` case\");\n-                ~[]\n-            }\n-        };\n-        ~Plural(offset, arms, other)\n-    }\n-\n-    /// Parses a Count parameter at the current position. This does not check\n-    /// for 'CountIsNextParam' because that is only used in precision, not\n-    /// width.\n-    fn count(&mut self) -> Count<'self> {\n-        match self.integer() {\n-            Some(i) => {\n-                if self.consume('$') {\n-                    CountIsParam(i)\n-                } else {\n-                    CountIs(i)\n-                }\n-            }\n-            None => {\n-                let tmp = self.cur.clone();\n-                match self.word() {\n-                    word if word.len() > 0 && self.consume('$') => {\n-                        CountIsName(word)\n-                    }\n-                    _ => {\n-                        self.cur = tmp;\n-                        CountImplied\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Parses a word starting at the current position. A word is considered to\n-    /// be an alphabetic character followed by any number of alphanumeric\n-    /// characters.\n-    fn word(&mut self) -> &'self str {\n-        let start = match self.cur.clone().next() {\n-            Some((pos, c)) if char::is_XID_start(c) => {\n-                self.cur.next();\n-                pos\n-            }\n-            Some(..) | None => { return self.input.slice(0, 0); }\n-        };\n-        let mut end;\n-        loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if char::is_XID_continue(c) => {\n-                    self.cur.next();\n-                }\n-                Some((pos, _)) => { end = pos; break }\n-                None => { end = self.input.len(); break }\n-            }\n-        }\n-        self.input.slice(start, end)\n-    }\n-\n-    /// Optionally parses an integer at the current position. This doesn't deal\n-    /// with overflow at all, it's just accumulating digits.\n-    fn integer(&mut self) -> Option<uint> {\n-        let mut cur = 0;\n-        let mut found = false;\n-        loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) => {\n-                    match char::to_digit(c, 10) {\n-                        Some(i) => {\n-                            cur = cur * 10 + i;\n-                            found = true;\n-                            self.cur.next();\n-                        }\n-                        None => { break }\n-                    }\n-                }\n-                None => { break }\n-            }\n-        }\n-        if found {\n-            return Some(cur);\n-        } else {\n-            return None;\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    fn same(fmt: &'static str, p: ~[Piece<'static>]) {\n-        let mut parser = Parser::new(fmt);\n-        assert_eq!(p, parser.collect());\n-    }\n-\n-    fn fmtdflt() -> FormatSpec<'static> {\n-        return FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            width: CountImplied,\n-            ty: \"\",\n-        }\n-    }\n-\n-    fn musterr(s: &str) {\n-        Parser::new(s).next();\n-    }\n-\n-    #[test]\n-    fn simple() {\n-        same(\"asdf\", ~[String(\"asdf\")]);\n-        same(\"a\\\\{b\", ~[String(\"a\"), String(\"{b\")]);\n-        same(\"a\\\\#b\", ~[String(\"a\"), String(\"#b\")]);\n-        same(\"a\\\\}b\", ~[String(\"a\"), String(\"}b\")]);\n-        same(\"a\\\\}\", ~[String(\"a\"), String(\"}\")]);\n-        same(\"\\\\}\", ~[String(\"}\")]);\n-    }\n-\n-    #[test] #[should_fail] fn invalid01() { musterr(\"{\") }\n-    #[test] #[should_fail] fn invalid02() { musterr(\"\\\\\") }\n-    #[test] #[should_fail] fn invalid03() { musterr(\"\\\\a\") }\n-    #[test] #[should_fail] fn invalid04() { musterr(\"{3a}\") }\n-    #[test] #[should_fail] fn invalid05() { musterr(\"{:|}\") }\n-    #[test] #[should_fail] fn invalid06() { musterr(\"{:>>>}\") }\n-\n-    #[test]\n-    fn format_nothing() {\n-        same(\"{}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_position() {\n-        same(\"{3}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_position_nothing_else() {\n-        same(\"{3:}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_type() {\n-        same(\"{3:a}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_align_fill() {\n-        same(\"{3:>}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignRight,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{3:0<}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('0'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{3:*<abcd}\", ~[Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('*'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"abcd\",\n-            },\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_counts() {\n-        same(\"{:10s}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountIs(10),\n-                ty: \"s\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{:10$.10s}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIs(10),\n-                width: CountIsParam(10),\n-                ty: \"s\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{:.*s}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsNextParam,\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{:.10$s}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsParam(10),\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{:a$.b$s}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsName(\"b\"),\n-                width: CountIsName(\"a\"),\n-                ty: \"s\",\n-            },\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_flags() {\n-        same(\"{:-}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as uint),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-            method: None,\n-        })]);\n-        same(\"{:+#}\", ~[Argument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-            method: None,\n-        })]);\n-    }\n-    #[test]\n-    fn format_mixture() {\n-        same(\"abcd {3:a} efg\", ~[String(\"abcd \"), Argument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-            method: None,\n-        }), String(\" efg\")]);\n-    }\n-\n-    #[test]\n-    fn select_simple() {\n-        same(\"{, select, other { haha } }\", ~[Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(~Select(~[], ~[String(\" haha \")]))\n-        })]);\n-        same(\"{1, select, other { haha } }\", ~[Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(~Select(~[], ~[String(\" haha \")]))\n-        })]);\n-        same(\"{1, select, other {#} }\", ~[Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(~Select(~[], ~[CurrentArgument]))\n-        })]);\n-        same(\"{1, select, other {{2, select, other {lol}}} }\", ~[Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(~Select(~[], ~[Argument(Argument{\n-                position: ArgumentIs(2),\n-                format: fmtdflt(),\n-                method: Some(~Select(~[], ~[String(\"lol\")]))\n-            })])) // wat\n-        })]);\n-    }\n-\n-    #[test]\n-    fn select_cases() {\n-        same(\"{1, select, a{1} b{2} c{3} other{4} }\", ~[Argument(Argument{\n-            position: ArgumentIs(1),\n-            format: fmtdflt(),\n-            method: Some(~Select(~[\n-                SelectArm{ selector: \"a\", result: ~[String(\"1\")] },\n-                SelectArm{ selector: \"b\", result: ~[String(\"2\")] },\n-                SelectArm{ selector: \"c\", result: ~[String(\"3\")] },\n-            ], ~[String(\"4\")]))\n-        })]);\n-    }\n-\n-    #[test] #[should_fail] fn badselect01() {\n-        musterr(\"{select, }\")\n-    }\n-    #[test] #[should_fail] fn badselect02() {\n-        musterr(\"{1, select}\")\n-    }\n-    #[test] #[should_fail] fn badselect03() {\n-        musterr(\"{1, select, }\")\n-    }\n-    #[test] #[should_fail] fn badselect04() {\n-        musterr(\"{1, select, a {}}\")\n-    }\n-    #[test] #[should_fail] fn badselect05() {\n-        musterr(\"{1, select, other }}\")\n-    }\n-    #[test] #[should_fail] fn badselect06() {\n-        musterr(\"{1, select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect07() {\n-        musterr(\"{select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect08() {\n-        musterr(\"{1 select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect09() {\n-        musterr(\"{:d select, other {}\")\n-    }\n-    #[test] #[should_fail] fn badselect10() {\n-        musterr(\"{1:d select, other {}\")\n-    }\n-\n-    #[test]\n-    fn plural_simple() {\n-        same(\"{, plural, other { haha } }\", ~[Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n-        })]);\n-        same(\"{:, plural, other { haha } }\", ~[Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n-        })]);\n-        same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n-        ~[Argument(Argument{\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-            method: Some(~Plural(Some(1), ~[\n-                PluralArm{ selector: Right(2), result: ~[String(\"2\")] },\n-                PluralArm{ selector: Right(3), result: ~[String(\"3\")] },\n-                PluralArm{ selector: Left(Many), result: ~[String(\"yes\")] }\n-            ], ~[String(\"haha\")]))\n-        })]);\n-    }\n-}"}, {"sha": "b20af1a35b8c780b5c2b9b8d2deaa7d3f2f30945", "filename": "libgrust/libstd/fmt/rt.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ffmt%2Frt.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This is an internal module used by the ifmt! runtime. These structures are\n-//! emitted to static arrays to precompile format strings ahead of time.\n-//!\n-//! These definitions are similar to their `ct` equivalents, but differ in that\n-//! these can be statically allocated and are slightly optimized for the runtime\n-\n-#[allow(missing_doc)];\n-#[doc(hidden)];\n-\n-use either::Either;\n-use fmt::parse;\n-use option::Option;\n-\n-pub enum Piece<'self> {\n-    String(&'self str),\n-    // FIXME(#8259): this shouldn't require the unit-value here\n-    CurrentArgument(()),\n-    Argument(Argument<'self>),\n-}\n-\n-pub struct Argument<'self> {\n-    position: Position,\n-    format: FormatSpec,\n-    method: Option<&'self Method<'self>>\n-}\n-\n-pub struct FormatSpec {\n-    fill: char,\n-    align: parse::Alignment,\n-    flags: uint,\n-    precision: Count,\n-    width: Count,\n-}\n-\n-pub enum Count {\n-    CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n-}\n-\n-pub enum Position {\n-    ArgumentNext, ArgumentIs(uint)\n-}\n-\n-pub enum Method<'self> {\n-    Plural(Option<uint>, &'self [PluralArm<'self>], &'self [Piece<'self>]),\n-    Select(&'self [SelectArm<'self>], &'self [Piece<'self>]),\n-}\n-\n-pub struct PluralArm<'self> {\n-    selector: Either<parse::PluralKeyword, uint>,\n-    result: &'self [Piece<'self>],\n-}\n-\n-pub struct SelectArm<'self> {\n-    selector: &'self str,\n-    result: &'self [Piece<'self>],\n-}"}, {"sha": "e5bf9f6bb2a417d652010890da5a332f5a4f09b8", "filename": "libgrust/libstd/from_str.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ffrom_str.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The trait for types that can be created from strings\n-\n-use option::Option;\n-\n-/// A trait to abstract the idea of creating a new instance of a type from a\n-/// string.\n-pub trait FromStr {\n-    /// Parses a string `s` to return an optional value of this type. If the\n-    /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStr::from_str\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n-    FromStr::from_str(s)\n-}"}, {"sha": "d3bec8ca6c907c18fc2d75a414e7dd35839c3d92", "filename": "libgrust/libstd/gc.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fgc.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Task-local garbage-collected boxes\n-\n-The `Gc` type provides shared ownership of an immutable value. Destruction is not deterministic, and\n-will occur some time between every `Gc` handle being gone and the end of the task. The garbage\n-collector is task-local so `Gc<T>` is not sendable.\n-\n-*/\n-\n-use kinds::Send;\n-use clone::{Clone, DeepClone};\n-\n-/// Immutable garbage-collected pointer type\n-#[no_send]\n-#[deriving(Clone)]\n-pub struct Gc<T> {\n-    priv ptr: @T\n-}\n-\n-impl<T: 'static> Gc<T> {\n-    /// Construct a new garbage-collected box\n-    #[inline]\n-    pub fn new(value: T) -> Gc<T> {\n-        Gc { ptr: @value }\n-    }\n-}\n-\n-impl<T: 'static> Gc<T> {\n-    /// Borrow the value contained in the garbage-collected box\n-    #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        &*self.ptr\n-    }\n-}\n-\n-/// The `Send` bound restricts this to acyclic graphs where it is well-defined.\n-///\n-/// A `Freeze` bound would also work, but `Send` *or* `Freeze` cannot be expressed.\n-impl<T: DeepClone + Send + 'static> DeepClone for Gc<T> {\n-    #[inline]\n-    fn deep_clone(&self) -> Gc<T> {\n-        Gc::new(self.borrow().deep_clone())\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use cell::RefCell;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Gc::new(RefCell::new(5));\n-        let y = x.clone();\n-        x.borrow().with_mut(|inner| {\n-            *inner = 20;\n-        });\n-        assert_eq!(y.borrow().with(|x| *x), 20);\n-    }\n-\n-    #[test]\n-    fn test_deep_clone() {\n-        let x = Gc::new(RefCell::new(5));\n-        let y = x.deep_clone();\n-        x.borrow().with_mut(|inner| {\n-            *inner = 20;\n-        });\n-        assert_eq!(y.borrow().with(|x| *x), 5);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Gc::new(5);\n-        assert_eq!(*x.borrow(), 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Gc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x.borrow(), 5);\n-        assert_eq!(*y.borrow(), 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x = Gc::new(~5);\n-        assert_eq!(**x.borrow(), 5);\n-    }\n-}"}, {"sha": "5a671eea7a34851f1dfd99047ee6d882af52513f", "filename": "libgrust/libstd/hash.rs", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fhash.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,608 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Implementation of SipHash 2-4\n- *\n- * See: http://131002.net/siphash/\n- *\n- * Consider this as a main \"general-purpose\" hash for all hashtables: it\n- * runs at good speed (competitive with spooky and city) and permits\n- * strong _keyed_ hashing. Key your hashtables from a strong RNG,\n- * such as rand::rng.\n- *\n- * Although the SipHash algorithm is considered to be cryptographically\n- * strong, this implementation has not been reviewed for such purposes.\n- * As such, all cryptographic uses of this implementation are strongly\n- * discouraged.\n- */\n-\n-#[allow(missing_doc)];\n-\n-use container::Container;\n-use iter::Iterator;\n-use option::{Some, None};\n-use io::Writer;\n-use str::OwnedStr;\n-use to_bytes::IterBytes;\n-use vec::ImmutableVector;\n-use num::ToStrRadix;\n-\n-// Alias `SipState` to `State`.\n-pub use State = hash::SipState;\n-\n-/**\n- * Types that can meaningfully be hashed should implement this.\n- *\n- * Note that this trait is likely to change somewhat as it is\n- * closely related to `to_bytes::IterBytes` and in almost all\n- * cases presently the two are (and must be) used together.\n- *\n- * In general, most types only need to implement `IterBytes`,\n- * and the implementation of `Hash` below will take care of\n- * the rest. This is the recommended approach, since constructing\n- * good keyed hash functions is quite difficult.\n- */\n-pub trait Hash {\n-    /**\n-     * Compute a \"keyed\" hash of the value implementing the trait,\n-     * taking `k0` and `k1` as \"keying\" parameters that randomize or\n-     * otherwise perturb the hash function in such a way that a\n-     * hash table built using such \"keyed hash functions\" cannot\n-     * be made to perform linearly by an attacker controlling the\n-     * hashtable's contents.\n-     *\n-     * In practical terms, we implement this using the SipHash 2-4\n-     * function and require most types to only implement the\n-     * IterBytes trait, that feeds SipHash.\n-     */\n-    fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n-\n-    #[inline]\n-    fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n-}\n-\n-/// Streaming hash-functions should implement this.\n-pub trait Streaming {\n-    fn input(&mut self, &[u8]);\n-    // These can be refactored some when we have default methods.\n-    fn result_bytes(&mut self) -> ~[u8];\n-    fn result_str(&mut self) -> ~str;\n-    fn result_u64(&mut self) -> u64;\n-    fn reset(&mut self);\n-}\n-\n-impl<A:IterBytes> Hash for A {\n-    #[inline]\n-    fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        let mut s = State::new(k0, k1);\n-        self.iter_bytes(true, |bytes| {\n-            s.input(bytes);\n-            true\n-        });\n-        s.result_u64()\n-    }\n-}\n-\n-fn hash_keyed_2<A: IterBytes,\n-                B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_3<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_4<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes>(\n-                a: &A,\n-                b: &B,\n-                c: &C,\n-                d: &D,\n-                k0: u64,\n-                k1: u64)\n-                -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    d.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-fn hash_keyed_5<A: IterBytes,\n-                B: IterBytes,\n-                C: IterBytes,\n-                D: IterBytes,\n-                E: IterBytes>(\n-                a: &A,\n-                b: &B,\n-                c: &C,\n-                d: &D,\n-                e: &E,\n-                k0: u64,\n-                k1: u64)\n-                -> u64 {\n-    let mut s = State::new(k0, k1);\n-    a.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    b.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    c.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    d.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    e.iter_bytes(true, |bytes| {\n-        s.input(bytes);\n-        true\n-    });\n-    s.result_u64()\n-}\n-\n-#[inline]\n-pub fn default_state() -> State {\n-    State::new(0, 0)\n-}\n-\n-struct SipState {\n-    k0: u64,\n-    k1: u64,\n-    length: uint, // how many bytes we've processed\n-    v0: u64,      // hash state\n-    v1: u64,\n-    v2: u64,\n-    v3: u64,\n-    tail: [u8, ..8], // unprocessed bytes\n-    ntail: uint,  // how many bytes in tail are valid\n-}\n-\n-impl SipState {\n-    #[inline]\n-    fn new(key0: u64, key1: u64) -> SipState {\n-        let mut state = SipState {\n-            k0: key0,\n-            k1: key1,\n-            length: 0,\n-            v0: 0,\n-            v1: 0,\n-            v2: 0,\n-            v3: 0,\n-            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n-            ntail: 0,\n-        };\n-        state.reset();\n-        state\n-    }\n-}\n-\n-// sadly, these macro definitions can't appear later,\n-// because they're needed in the following defs;\n-// this design could be improved.\n-\n-macro_rules! u8to64_le (\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     $buf[1+$i] as u64 << 8 |\n-     $buf[2+$i] as u64 << 16 |\n-     $buf[3+$i] as u64 << 24 |\n-     $buf[4+$i] as u64 << 32 |\n-     $buf[5+$i] as u64 << 40 |\n-     $buf[6+$i] as u64 << 48 |\n-     $buf[7+$i] as u64 << 56)\n-)\n-\n-macro_rules! rotl (\n-    ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64 - $b)))\n-)\n-\n-macro_rules! compress (\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-    ({\n-        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-        $v0 = rotl!($v0, 32);\n-        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-        $v2 = rotl!($v2, 32);\n-    })\n-)\n-\n-\n-impl Writer for SipState {\n-    // Methods for io::writer\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n-        let length = msg.len();\n-        self.length += length;\n-\n-        let mut needed = 0u;\n-\n-        if self.ntail != 0 {\n-            needed = 8 - self.ntail;\n-\n-            if length < needed {\n-                let mut t = 0;\n-                while t < length {\n-                    self.tail[self.ntail+t] = msg[t];\n-                    t += 1;\n-                }\n-                self.ntail += length;\n-                return;\n-            }\n-\n-            let mut t = 0;\n-            while t < needed {\n-                self.tail[self.ntail+t] = msg[t];\n-                t += 1;\n-            }\n-\n-            let m = u8to64_le!(self.tail, 0);\n-\n-            self.v3 ^= m;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= m;\n-\n-            self.ntail = 0;\n-        }\n-\n-        // Buffered tail is now flushed, process new input.\n-        let len = length - needed;\n-        let end = len & (!0x7);\n-        let left = len & 0x7;\n-\n-        let mut i = needed;\n-        while i < end {\n-            let mi = u8to64_le!(msg, i);\n-\n-            self.v3 ^= mi;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= mi;\n-\n-            i += 8;\n-        }\n-\n-        let mut t = 0u;\n-        while t < left {\n-            self.tail[t] = msg[i+t];\n-            t += 1\n-        }\n-        self.ntail = left;\n-    }\n-\n-    fn flush(&mut self) {\n-        // No-op\n-    }\n-}\n-\n-impl Streaming for SipState {\n-    #[inline]\n-    fn input(&mut self, buf: &[u8]) {\n-        self.write(buf);\n-    }\n-\n-    #[inline]\n-    fn result_u64(&mut self) -> u64 {\n-        let mut v0 = self.v0;\n-        let mut v1 = self.v1;\n-        let mut v2 = self.v2;\n-        let mut v3 = self.v3;\n-\n-        let mut b : u64 = (self.length as u64 & 0xff) << 56;\n-\n-        if self.ntail > 0 { b |= self.tail[0] as u64 <<  0; }\n-        if self.ntail > 1 { b |= self.tail[1] as u64 <<  8; }\n-        if self.ntail > 2 { b |= self.tail[2] as u64 << 16; }\n-        if self.ntail > 3 { b |= self.tail[3] as u64 << 24; }\n-        if self.ntail > 4 { b |= self.tail[4] as u64 << 32; }\n-        if self.ntail > 5 { b |= self.tail[5] as u64 << 40; }\n-        if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n-\n-        v3 ^= b;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        v0 ^= b;\n-\n-        v2 ^= 0xff;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-\n-        return (v0 ^ v1 ^ v2 ^ v3);\n-    }\n-\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let h = self.result_u64();\n-        ~[(h >> 0) as u8,\n-          (h >> 8) as u8,\n-          (h >> 16) as u8,\n-          (h >> 24) as u8,\n-          (h >> 32) as u8,\n-          (h >> 40) as u8,\n-          (h >> 48) as u8,\n-          (h >> 56) as u8,\n-        ]\n-    }\n-\n-    fn result_str(&mut self) -> ~str {\n-        let r = self.result_bytes();\n-        let mut s = ~\"\";\n-        for b in r.iter() {\n-            s.push_str((*b as uint).to_str_radix(16u));\n-        }\n-        s\n-    }\n-\n-    #[inline]\n-    fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'self>(&'self [u8]);\n-    impl<'self> IterBytes for Bytes<'self> {\n-        fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n-            f(**self)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_siphash() {\n-        let vecs : [[u8, ..8], ..64] = [\n-            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-        ];\n-\n-        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf : ~[u8] = ~[];\n-        let mut t = 0;\n-        let mut stream_inc = SipState::new(k0, k1);\n-        let mut stream_full = SipState::new(k0, k1);\n-\n-        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n-            let mut s = ~\"\";\n-            for b in r.iter() {\n-                s.push_str((*b as uint).to_str_radix(16u));\n-            }\n-            s\n-        }\n-\n-        while t < 64 {\n-            debug!(\"siphash test {}\", t);\n-            let vec = u8to64_le!(vecs[t], 0);\n-            let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n-            debug!(\"got {:?}, expected {:?}\", out, vec);\n-            assert_eq!(vec, out);\n-\n-            stream_full.reset();\n-            stream_full.input(buf);\n-            let f = stream_full.result_str();\n-            let i = stream_inc.result_str();\n-            let v = to_hex_str(&vecs[t]);\n-            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n-\n-            assert!(f == i && f == v);\n-\n-            buf.push(t as u8);\n-            stream_inc.input([t as u8]);\n-\n-            t += 1;\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!((val as u64).hash() != (val as uint).hash());\n-        assert_eq!((val as u32).hash(), (val as uint).hash());\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!((val as u64).hash(), (val as uint).hash());\n-        assert!((val as u32).hash() != (val as uint).hash());\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!((val as u64).hash() != (val as uint).hash());\n-        assert_eq!((val as u32).hash(), (val as uint).hash());\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        val64.hash() == val64.hash();\n-        let val32 = 0xdeadbeef_u32;\n-        val32.hash() == val32.hash();\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(val.hash() != zero_byte(val, 0).hash());\n-        assert!(val.hash() != zero_byte(val, 1).hash());\n-        assert!(val.hash() != zero_byte(val, 2).hash());\n-        assert!(val.hash() != zero_byte(val, 3).hash());\n-        assert!(val.hash() != zero_byte(val, 4).hash());\n-        assert!(val.hash() != zero_byte(val, 5).hash());\n-        assert!(val.hash() != zero_byte(val, 6).hash());\n-        assert!(val.hash() != zero_byte(val, 7).hash());\n-\n-        fn zero_byte(val: u64, byte: uint) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(val.hash() != zero_byte(val, 0).hash());\n-        assert!(val.hash() != zero_byte(val, 1).hash());\n-        assert!(val.hash() != zero_byte(val, 2).hash());\n-        assert!(val.hash() != zero_byte(val, 3).hash());\n-\n-        fn zero_byte(val: u32, byte: uint) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_float_hashes_differ() {\n-        assert!(0.0.hash() != 1.0.hash());\n-        assert!(1.0.hash() != (-1.0).hash());\n-    }\n-\n-    #[test]\n-    fn test_float_hashes_of_zero() {\n-        assert_eq!(0.0.hash(), (-0.0).hash());\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        let v = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w = (&[1u8, 0, 0, 0], &[], &[]);\n-\n-        assert!(v != w);\n-        assert!(s.hash() != t.hash() && s.hash() != u.hash());\n-        assert!(v.hash() != w.hash());\n-    }\n-}"}, {"sha": "e7eb8e60704655ca7d6f9e44fe28539006e2ffd9", "filename": "libgrust/libstd/hashmap.rs", "status": "removed", "additions": 0, "deletions": 1244, "changes": 1244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fhashmap.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,1244 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An unordered map and set type implemented as hash tables\n-//!\n-//! The tables use a keyed hash with new random keys generated for each container, so the ordering\n-//! of a set of keys in a hash table is randomized.\n-\n-use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n-use clone::Clone;\n-use cmp::{Eq, Equiv};\n-use default::Default;\n-use hash::Hash;\n-use iter::{Iterator, FromIterator, Extendable};\n-use iter::{FilterMap, Chain, Repeat, Zip};\n-use num;\n-use option::{None, Option, Some};\n-use rand::Rng;\n-use rand;\n-use uint;\n-use util::replace;\n-use vec::{ImmutableVector, MutableVector, OwnedVector};\n-use vec;\n-\n-static INITIAL_CAPACITY: uint = 32u; // 2^5\n-\n-struct Bucket<K,V> {\n-    hash: uint,\n-    key: K,\n-    value: V,\n-}\n-\n-/// A hash map implementation which uses linear probing along with the SipHash\n-/// hash function for internal state. This means that the order of all hash maps\n-/// is randomized by keying each hash map randomly on creation.\n-///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by just implementing the `Eq` and\n-/// `IterBytes` traits as `Hash` is automatically implemented for types that\n-/// implement `IterBytes`.\n-pub struct HashMap<K,V> {\n-    priv k0: u64,\n-    priv k1: u64,\n-    priv resize_at: uint,\n-    priv size: uint,\n-    priv buckets: ~[Option<Bucket<K, V>>],\n-}\n-\n-// We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n-// which would be nifty\n-enum SearchResult {\n-    FoundEntry(uint), FoundHole(uint), TableFull\n-}\n-\n-#[inline]\n-fn resize_at(capacity: uint) -> uint {\n-    (capacity * 3) / 4\n-}\n-\n-impl<K:Hash + Eq,V> HashMap<K, V> {\n-    #[inline]\n-    fn to_bucket(&self, h: uint) -> uint {\n-        // A good hash function with entropy spread over all of the\n-        // bits is assumed. SipHash is more than good enough.\n-        h % self.buckets.len()\n-    }\n-\n-    #[inline]\n-    fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n-        (idx + 1) % len_buckets\n-    }\n-\n-    #[inline]\n-    fn bucket_sequence(&self, hash: uint, op: |uint| -> bool) -> bool {\n-        let start_idx = self.to_bucket(hash);\n-        let len_buckets = self.buckets.len();\n-        let mut idx = start_idx;\n-        loop {\n-            if !op(idx) { return false; }\n-            idx = self.next_bucket(idx, len_buckets);\n-            if idx == start_idx {\n-                return true;\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn bucket_for_key(&self, k: &K) -> SearchResult {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        self.bucket_for_key_with_hash(hash, k)\n-    }\n-\n-    #[inline]\n-    fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n-                                               -> SearchResult {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        self.bucket_for_key_with_hash_equiv(hash, k)\n-    }\n-\n-    #[inline]\n-    fn bucket_for_key_with_hash(&self,\n-                                hash: uint,\n-                                k: &K)\n-                             -> SearchResult {\n-        let mut ret = TableFull;\n-        self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n-                Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n-                    ret = FoundEntry(i); false\n-                },\n-                None => { ret = FoundHole(i); false }\n-                _ => true,\n-            }\n-        });\n-        ret\n-    }\n-\n-    #[inline]\n-    fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n-                                                  hash: uint,\n-                                                  k: &Q)\n-                                               -> SearchResult {\n-        let mut ret = TableFull;\n-        self.bucket_sequence(hash, |i| {\n-            match self.buckets[i] {\n-                Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n-                    ret = FoundEntry(i); false\n-                },\n-                None => { ret = FoundHole(i); false }\n-                _ => true,\n-            }\n-        });\n-        ret\n-    }\n-\n-    /// Expand the capacity of the array to the next power of two\n-    /// and re-insert each of the existing buckets.\n-    #[inline]\n-    fn expand(&mut self) {\n-        let new_capacity = self.buckets.len() * 2;\n-        self.resize(new_capacity);\n-    }\n-\n-    /// Expands the capacity of the array and re-insert each of the\n-    /// existing buckets.\n-    fn resize(&mut self, new_capacity: uint) {\n-        self.resize_at = resize_at(new_capacity);\n-\n-        let old_buckets = replace(&mut self.buckets,\n-                                  vec::from_fn(new_capacity, |_| None));\n-\n-        self.size = 0;\n-        // move_rev_iter is more efficient\n-        for bucket in old_buckets.move_rev_iter() {\n-            self.insert_opt_bucket(bucket);\n-        }\n-    }\n-\n-    fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K, V>>) {\n-        match bucket {\n-            Some(Bucket{hash: hash, key: key, value: value}) => {\n-                self.insert_internal(hash, key, value);\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    #[inline]\n-    fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n-        match self.buckets[idx] {\n-            Some(ref bkt) => &bkt.value,\n-            None => fail!(\"HashMap::find: internal logic error\"),\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n-        match self.buckets[idx] {\n-            Some(ref mut bkt) => &mut bkt.value,\n-            None => unreachable!()\n-        }\n-    }\n-\n-    /// Inserts the key value pair into the buckets.\n-    /// Assumes that there will be a bucket.\n-    /// True if there was no previous entry with that key\n-    fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n-        match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => { fail!(\"Internal logic error\"); }\n-            FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                                value: v});\n-                self.size += 1;\n-                None\n-            }\n-            FoundEntry(idx) => {\n-                match self.buckets[idx] {\n-                    None => { fail!(\"insert_internal: Internal logic error\") }\n-                    Some(ref mut b) => {\n-                        b.hash = hash;\n-                        b.key = k;\n-                        Some(replace(&mut b.value, v))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n-        // Removing from an open-addressed hashtable\n-        // is, well, painful.  The problem is that\n-        // the entry may lie on the probe path for other\n-        // entries, so removing it would make you think that\n-        // those probe paths are empty.\n-        //\n-        // To address this we basically have to keep walking,\n-        // re-inserting entries we find until we reach an empty\n-        // bucket.  We know we will eventually reach one because\n-        // we insert one ourselves at the beginning (the removed\n-        // entry).\n-        //\n-        // I found this explanation elucidating:\n-        // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n-        let mut idx = match self.bucket_for_key_with_hash(hash, k) {\n-            TableFull | FoundHole(_) => return None,\n-            FoundEntry(idx) => idx\n-        };\n-\n-        let len_buckets = self.buckets.len();\n-        let bucket = self.buckets[idx].take();\n-\n-        let value = bucket.map(|bucket| bucket.value);\n-\n-        /* re-inserting buckets may cause changes in size, so remember\n-        what our new size is ahead of time before we start insertions */\n-        let size = self.size - 1;\n-        idx = self.next_bucket(idx, len_buckets);\n-        while self.buckets[idx].is_some() {\n-            let bucket = self.buckets[idx].take();\n-            self.insert_opt_bucket(bucket);\n-            idx = self.next_bucket(idx, len_buckets);\n-        }\n-        self.size = size;\n-\n-        value\n-    }\n-}\n-\n-impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n-    /// Return the number of elements in the map\n-    fn len(&self) -> uint { self.size }\n-}\n-\n-impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n-    /// Clear the map, removing all key-value pairs.\n-    fn clear(&mut self) {\n-        for bkt in self.buckets.mut_iter() {\n-            *bkt = None;\n-        }\n-        self.size = 0;\n-    }\n-}\n-\n-impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n-    /// Return a reference to the value corresponding to the key\n-    fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n-        match self.bucket_for_key(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-}\n-\n-impl<K:Hash + Eq,V> MutableMap<K, V> for HashMap<K, V> {\n-    /// Return a mutable reference to the value corresponding to the key\n-    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n-        let idx = match self.bucket_for_key(k) {\n-            FoundEntry(idx) => idx,\n-            TableFull | FoundHole(_) => return None\n-        };\n-        Some(self.mut_value_for_bucket(idx))\n-    }\n-\n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n-    fn swap(&mut self, k: K, v: V) -> Option<V> {\n-        // this could be faster.\n-\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        self.insert_internal(hash, k, v)\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    fn pop(&mut self, k: &K) -> Option<V> {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        self.pop_internal(hash, k)\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> HashMap<K, V> {\n-    /// Create an empty HashMap\n-    pub fn new() -> HashMap<K, V> {\n-        HashMap::with_capacity(INITIAL_CAPACITY)\n-    }\n-\n-    /// Create an empty HashMap with space for at least `capacity`\n-    /// elements in the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V> {\n-        let mut r = rand::task_rng();\n-        HashMap::with_capacity_and_keys(r.gen(), r.gen(), capacity)\n-    }\n-\n-    /// Create an empty HashMap with space for at least `capacity`\n-    /// elements, using `k0` and `k1` as the keys.\n-    ///\n-    /// Warning: `k0` and `k1` are normally randomly generated, and\n-    /// are designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting them\n-    /// manually using this function can expose a DoS attack vector.\n-    pub fn with_capacity_and_keys(k0: u64, k1: u64, capacity: uint) -> HashMap<K, V> {\n-        let cap = num::max(INITIAL_CAPACITY, capacity);\n-        HashMap {\n-            k0: k0, k1: k1,\n-            resize_at: resize_at(cap),\n-            size: 0,\n-            buckets: vec::from_fn(cap, |_| None)\n-        }\n-    }\n-\n-    /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        if n > self.buckets.len() {\n-            let buckets = n * 4 / 3 + 1;\n-            self.resize(uint::next_power_of_two(buckets));\n-        }\n-    }\n-\n-    /// Modify and return the value corresponding to the key in the map, or\n-    /// insert and return a new value if it doesn't exist.\n-    pub fn mangle<'a,\n-                  A>(\n-                  &'a mut self,\n-                  k: K,\n-                  a: A,\n-                  not_found: |&K, A| -> V,\n-                  found: |&K, &mut V, A|)\n-                  -> &'a mut V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n-            FoundHole(idx) => {\n-                let v = not_found(&k, a);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k, value: v});\n-                self.size += 1;\n-                idx\n-            }\n-        };\n-\n-        self.mut_value_for_bucket(idx)\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        self.mangle(k, v, |_k, a| a, |_k,_v,_a| ())\n-    }\n-\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n-                               -> &'a mut V {\n-        self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n-    }\n-\n-    /// Insert a key-value pair into the map if the key is not already present.\n-    /// Otherwise, modify the existing value for the key.\n-    /// Returns the new or modified value for the key.\n-    pub fn insert_or_update_with<'a>(\n-                                 &'a mut self,\n-                                 k: K,\n-                                 v: V,\n-                                 f: |&K, &mut V|)\n-                                 -> &'a mut V {\n-        self.mangle(k, v, |_k,a| a, |k,v,_a| f(k,v))\n-    }\n-\n-    /// Retrieves a value for the given key, failing if the key is not\n-    /// present.\n-    pub fn get<'a>(&'a self, k: &K) -> &'a V {\n-        match self.find(k) {\n-            Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k),\n-        }\n-    }\n-\n-    /// Retrieves a (mutable) value for the given key, failing if the key\n-    /// is not present.\n-    pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n-        match self.find_mut(k) {\n-            Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k),\n-        }\n-    }\n-\n-    /// Return true if the map contains a value for the specified key,\n-    /// using equivalence\n-    pub fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n-        match self.bucket_for_key_equiv(key) {\n-            FoundEntry(_) => {true}\n-            TableFull | FoundHole(_) => {false}\n-        }\n-    }\n-\n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence\n-    pub fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q)\n-                                             -> Option<&'a V> {\n-        match self.bucket_for_key_equiv(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n-    }\n-\n-    /// Visit all keys\n-    pub fn each_key(&self, blk: |k: &K| -> bool) -> bool {\n-        self.iter().advance(|(k, _)| blk(k))\n-    }\n-\n-    /// Visit all values\n-    pub fn each_value<'a>(&'a self, blk: |v: &'a V| -> bool) -> bool {\n-        self.iter().advance(|(_, v)| blk(v))\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is (&'a K, &'a V).\n-    pub fn iter<'a>(&'a self) -> HashMapIterator<'a, K, V> {\n-        HashMapIterator { iter: self.buckets.iter() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order,\n-    /// with mutable references to the values.\n-    /// Iterator element type is (&'a K, &'a mut V).\n-    pub fn mut_iter<'a>(&'a mut self) -> HashMapMutIterator<'a, K, V> {\n-        HashMapMutIterator { iter: self.buckets.mut_iter() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each key-value\n-    /// pair out of the map in arbitrary order. The map cannot be used after\n-    /// calling this.\n-    pub fn move_iter(self) -> HashMapMoveIterator<K, V> {\n-        // `move_rev_iter` is more efficient than `move_iter` for vectors\n-        HashMapMoveIterator {iter: self.buckets.move_rev_iter()}\n-    }\n-}\n-\n-impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n-    /// Like `find`, but returns a copy of the value.\n-    pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map(|v| (*v).clone())\n-    }\n-\n-    /// Like `get`, but returns a copy of the value.\n-    pub fn get_copy(&self, k: &K) -> V {\n-        (*self.get(k)).clone()\n-    }\n-}\n-\n-impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n-    fn eq(&self, other: &HashMap<K, V>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|(key, value)| {\n-            match other.find(key) {\n-                None => false,\n-                Some(v) => value == v\n-            }\n-        })\n-    }\n-\n-    fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n-}\n-\n-impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n-    fn clone(&self) -> HashMap<K,V> {\n-        let mut new_map = HashMap::with_capacity(self.len());\n-        for (key, value) in self.iter() {\n-            new_map.insert((*key).clone(), (*value).clone());\n-        }\n-        new_map\n-    }\n-}\n-\n-/// HashMap iterator\n-#[deriving(Clone)]\n-pub struct HashMapIterator<'self, K, V> {\n-    priv iter: vec::VecIterator<'self, Option<Bucket<K, V>>>,\n-}\n-\n-/// HashMap mutable values iterator\n-pub struct HashMapMutIterator<'self, K, V> {\n-    priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n-}\n-\n-/// HashMap move iterator\n-pub struct HashMapMoveIterator<K, V> {\n-    priv iter: vec::MoveRevIterator<Option<Bucket<K, V>>>,\n-}\n-\n-/// HashSet iterator\n-#[deriving(Clone)]\n-pub struct HashSetIterator<'self, K> {\n-    priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n-}\n-\n-/// HashSet move iterator\n-pub struct HashSetMoveIterator<K> {\n-    priv iter: vec::MoveRevIterator<Option<Bucket<K, ()>>>,\n-}\n-\n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'self, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'self K, &'self mut V)> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(K, V)> {\n-        for elt in self.iter {\n-            match elt {\n-                Some(Bucket {key, value, ..}) => return Some((key, value)),\n-                None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self K> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref bucket) => return Some(&bucket.key),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K> Iterator<K> for HashSetMoveIterator<K> {\n-    #[inline]\n-    fn next(&mut self) -> Option<K> {\n-        for elt in self.iter {\n-            match elt {\n-                Some(bucket) => return Some(bucket.key),\n-                None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K: Eq + Hash, V> FromIterator<(K, V)> for HashMap<K, V> {\n-    fn from_iterator<T: Iterator<(K, V)>>(iter: &mut T) -> HashMap<K, V> {\n-        let (lower, _) = iter.size_hint();\n-        let mut map = HashMap::with_capacity(lower);\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-impl<K: Eq + Hash, V> Extendable<(K, V)> for HashMap<K, V> {\n-    fn extend<T: Iterator<(K, V)>>(&mut self, iter: &mut T) {\n-        for (k, v) in *iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-impl<K: Eq + Hash, V> Default for HashMap<K, V> {\n-    fn default() -> HashMap<K, V> { HashMap::new() }\n-}\n-\n-/// An implementation of a hash set using the underlying representation of a\n-/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n-/// requires that the elements implement the `Eq` and `Hash` traits.\n-pub struct HashSet<T> {\n-    priv map: HashMap<T, ()>\n-}\n-\n-impl<T:Hash + Eq> Eq for HashSet<T> {\n-    fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n-    fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n-}\n-\n-impl<T:Hash + Eq> Container for HashSet<T> {\n-    /// Return the number of elements in the set\n-    fn len(&self) -> uint { self.map.len() }\n-}\n-\n-impl<T:Hash + Eq> Mutable for HashSet<T> {\n-    /// Clear the set, removing all values.\n-    fn clear(&mut self) { self.map.clear() }\n-}\n-\n-impl<T:Hash + Eq> Set<T> for HashSet<T> {\n-    /// Return true if the set contains a value\n-    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n-\n-    /// Return true if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n-    }\n-\n-    /// Return true if the set is a subset of another\n-    fn is_subset(&self, other: &HashSet<T>) -> bool {\n-        self.iter().all(|v| other.contains(v))\n-    }\n-\n-    /// Return true if the set is a superset of another\n-    fn is_superset(&self, other: &HashSet<T>) -> bool {\n-        other.is_subset(self)\n-    }\n-}\n-\n-impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {\n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-impl<T:Hash + Eq> HashSet<T> {\n-    /// Create an empty HashSet\n-    pub fn new() -> HashSet<T> {\n-        HashSet::with_capacity(INITIAL_CAPACITY)\n-    }\n-\n-    /// Create an empty HashSet with space for at least `n` elements in\n-    /// the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashSet<T> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n-    }\n-\n-    /// Create an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `k0` and `k1` as the keys.\n-    ///\n-    /// Warning: `k0` and `k1` are normally randomly generated, and\n-    /// are designed to allow HashSets to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting them\n-    /// manually using this function can expose a DoS attack vector.\n-    pub fn with_capacity_and_keys(k0: u64, k1: u64, capacity: uint) -> HashSet<T> {\n-        HashSet { map: HashMap::with_capacity_and_keys(k0, k1, capacity) }\n-    }\n-\n-    /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve_at_least(&mut self, n: uint) {\n-        self.map.reserve_at_least(n)\n-    }\n-\n-    /// Returns true if the hash set contains a value equivalent to the\n-    /// given query value.\n-    pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n-      self.map.contains_key_equiv(value)\n-    }\n-\n-    /// An iterator visiting all elements in arbitrary order.\n-    /// Iterator element type is &'a T.\n-    pub fn iter<'a>(&'a self) -> HashSetIterator<'a, T> {\n-        HashSetIterator { iter: self.map.buckets.iter() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out\n-    /// of the set in arbitrary order. The set cannot be used after calling\n-    /// this.\n-    pub fn move_iter(self) -> HashSetMoveIterator<T> {\n-        // `move_rev_iter` is more efficient than `move_iter` for vectors\n-        HashSetMoveIterator {iter: self.map.buckets.move_rev_iter()}\n-    }\n-\n-    /// Visit the values representing the difference\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n-        Repeat::new(other)\n-            .zip(self.iter())\n-            .filter_map(|(other, elt)| {\n-                if !other.contains(elt) { Some(elt) } else { None }\n-            })\n-    }\n-\n-    /// Visit the values representing the symmetric difference\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.difference(other).chain(other.difference(self))\n-    }\n-\n-    /// Visit the values representing the intersection\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T>)\n-        -> SetAlgebraIter<'a, T> {\n-        Repeat::new(other)\n-            .zip(self.iter())\n-            .filter_map(|(other, elt)| {\n-                if other.contains(elt) { Some(elt) } else { None }\n-            })\n-    }\n-\n-    /// Visit the values representing the union\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T>)\n-        -> Chain<HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.iter().chain(other.difference(self))\n-    }\n-\n-}\n-\n-impl<T:Hash + Eq + Clone> Clone for HashSet<T> {\n-    fn clone(&self) -> HashSet<T> {\n-        HashSet {\n-            map: self.map.clone()\n-        }\n-    }\n-}\n-\n-impl<K: Eq + Hash> FromIterator<K> for HashSet<K> {\n-    fn from_iterator<T: Iterator<K>>(iter: &mut T) -> HashSet<K> {\n-        let (lower, _) = iter.size_hint();\n-        let mut set = HashSet::with_capacity(lower);\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl<K: Eq + Hash> Extendable<K> for HashSet<K> {\n-    fn extend<T: Iterator<K>>(&mut self, iter: &mut T) {\n-        for k in *iter {\n-            self.insert(k);\n-        }\n-    }\n-}\n-\n-impl<K: Eq + Hash> Default for HashSet<K> {\n-    fn default() -> HashSet<K> { HashSet::new() }\n-}\n-\n-// `Repeat` is used to feed the filter closure an explicit capture\n-// of a reference to the other set\n-/// Set operations iterator\n-pub type SetAlgebraIter<'self, T> =\n-    FilterMap<'static,(&'self HashSet<T>, &'self T), &'self T,\n-              Zip<Repeat<&'self HashSet<T>>,HashSetIterator<'self,T>>>;\n-\n-\n-#[cfg(test)]\n-mod test_map {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn test_create_capacity_zero() {\n-        let mut m = HashMap::with_capacity(0);\n-        assert!(m.insert(1, 1));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(2, 4));\n-        assert_eq!(*m.get(&1), 2);\n-        assert_eq!(*m.get(&2), 4);\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 12));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n-        let new = 100;\n-        match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.find(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_insert_overwrite() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 2));\n-        assert_eq!(*m.get(&1), 2);\n-        assert!(!m.insert(1, 3));\n-        assert_eq!(*m.get(&1), 3);\n-    }\n-\n-    #[test]\n-    fn test_insert_conflicts() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(5, 3));\n-        assert!(m.insert(9, 4));\n-        assert_eq!(*m.get(&9), 4);\n-        assert_eq!(*m.get(&5), 3);\n-        assert_eq!(*m.get(&1), 2);\n-    }\n-\n-    #[test]\n-    fn test_conflict_remove() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(5, 3));\n-        assert!(m.insert(9, 4));\n-        assert!(m.remove(&1));\n-        assert_eq!(*m.get(&9), 4);\n-        assert_eq!(*m.get(&5), 3);\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2));\n-        assert!(!m.is_empty());\n-        assert!(m.remove(&1));\n-        assert!(m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = HashMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.swap(1, 2), None);\n-        assert_eq!(m.swap(1, 3), Some(2));\n-        assert_eq!(m.swap(1, 4), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_find_or_insert() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.find_or_insert(1, 2), 2);\n-        assert_eq!(*m.find_or_insert(1, 3), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_or_insert_with() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n-        assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n-    }\n-\n-    #[test]\n-    fn test_insert_or_update_with() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 2);\n-        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 3);\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let hm = {\n-            let mut hm = HashMap::new();\n-\n-            hm.insert('a', 1);\n-            hm.insert('b', 2);\n-\n-            hm\n-        };\n-\n-        let v = hm.move_iter().collect::<~[(char, int)]>();\n-        assert!([('a', 1), ('b', 2)] == v || [('b', 2), ('a', 1)] == v);\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut m = HashMap::with_capacity(4);\n-        for i in range(0u, 32) {\n-            assert!(m.insert(i, i*2));\n-        }\n-        let mut observed = 0;\n-        for (k, v) in m.iter() {\n-            assert_eq!(*v, *k * 2);\n-            observed |= (1 << *k);\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let mut m = HashMap::new();\n-        assert!(m.find(&1).is_none());\n-        m.insert(1, 2);\n-        match m.find(&1) {\n-            None => fail!(),\n-            Some(v) => assert!(*v == 2)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut m1 = HashMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n-\n-        let mut m2 = HashMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n-\n-        assert!(m1 != m2);\n-\n-        m2.insert(3, 4);\n-\n-        assert_eq!(m1, m2);\n-    }\n-\n-    #[test]\n-    fn test_expand() {\n-        let mut m = HashMap::new();\n-\n-        assert_eq!(m.len(), 0);\n-        assert!(m.is_empty());\n-\n-        let mut i = 0u;\n-        let old_resize_at = m.resize_at;\n-        while old_resize_at == m.resize_at {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-\n-        assert_eq!(m.len(), i);\n-        assert!(!m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_find_equiv() {\n-        let mut m = HashMap::new();\n-\n-        let (foo, bar, baz) = (1,2,3);\n-        m.insert(~\"foo\", foo);\n-        m.insert(~\"bar\", bar);\n-        m.insert(~\"baz\", baz);\n-\n-\n-        assert_eq!(m.find_equiv(&(\"foo\")), Some(&foo));\n-        assert_eq!(m.find_equiv(&(\"bar\")), Some(&bar));\n-        assert_eq!(m.find_equiv(&(\"baz\")), Some(&baz));\n-\n-        assert_eq!(m.find_equiv(&(\"qux\")), None);\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n-\n-        for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_set {\n-    use super::*;\n-    use prelude::*;\n-    use container::Container;\n-    use vec::ImmutableEqVector;\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = HashSet::new();\n-        let mut ys = HashSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = HashSet::new();\n-        assert!(a.insert(0));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = HashSet::new();\n-        assert!(b.insert(0));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut a = HashSet::new();\n-        for i in range(0u, 32) {\n-            assert!(a.insert(i));\n-        }\n-        let mut observed = 0;\n-        for k in a.iter() {\n-            observed |= (1 << *k);\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-        assert!(a.insert(-5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(-9));\n-        assert!(b.insert(-42));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for x in a.intersection(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for x in a.difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(22));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 5, 11, 14, 22];\n-        for x in a.symmetric_difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-        assert!(a.insert(16));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for x in a.union(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let hs = {\n-            let mut hs = HashSet::new();\n-\n-            hs.insert('a');\n-            hs.insert('b');\n-\n-            hs\n-        };\n-\n-        let v = hs.move_iter().collect::<~[char]>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut s1 = HashSet::new();\n-        s1.insert(1);\n-        s1.insert(2);\n-        s1.insert(3);\n-\n-        let mut s2 = HashSet::new();\n-        s2.insert(1);\n-        s2.insert(2);\n-\n-        assert!(s1 != s2);\n-\n-        s2.insert(3);\n-\n-        assert_eq!(s1, s2);\n-    }\n-}"}, {"sha": "8c1897339cbef9d7e11d977407bd24e6907fc2a4", "filename": "libgrust/libstd/io/buffered.rs", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fbuffered.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,459 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Buffering wrappers for I/O traits\n-//!\n-//! It can be excessively inefficient to work directly with a `Reader` or\n-//! `Writer`. Every call to `read` or `write` on `TcpStream` results in a\n-//! system call, for example. This module provides structures that wrap\n-//! `Readers`, `Writers`, and `Streams` and buffer input and output to them.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! let tcp_stream = TcpStream::connect(addr);\n-//! let reader = BufferedReader::new(tcp_stream);\n-//!\n-//! let mut buf: ~[u8] = vec::from_elem(100, 0u8);\n-//! match reader.read(buf.as_slice()) {\n-//!     Some(nread) => println!(\"Read {} bytes\", nread),\n-//!     None => println!(\"At the end of the stream!\")\n-//! }\n-//! ```\n-//!\n-//! ```\n-//! let tcp_stream = TcpStream::connect(addr);\n-//! let writer = BufferedWriter::new(tcp_stream);\n-//!\n-//! writer.write(\"hello, world\".as_bytes());\n-//! writer.flush();\n-//! ```\n-//!\n-//! ```\n-//! let tcp_stream = TcpStream::connect(addr);\n-//! let stream = BufferedStream::new(tcp_stream);\n-//!\n-//! stream.write(\"hello, world\".as_bytes());\n-//! stream.flush();\n-//!\n-//! let mut buf = vec::from_elem(100, 0u8);\n-//! match stream.read(buf.as_slice()) {\n-//!     Some(nread) => println!(\"Read {} bytes\", nread),\n-//!     None => println!(\"At the end of the stream!\")\n-//! }\n-//! ```\n-//!\n-\n-use prelude::*;\n-\n-use num;\n-use vec;\n-use super::{Stream, Decorator};\n-\n-// libuv recommends 64k buffers to maximize throughput\n-// https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-static DEFAULT_CAPACITY: uint = 64 * 1024;\n-\n-/// Wraps a Reader and buffers input from it\n-pub struct BufferedReader<R> {\n-    priv inner: R,\n-    priv buf: ~[u8],\n-    priv pos: uint,\n-    priv cap: uint\n-}\n-\n-impl<R: Reader> BufferedReader<R> {\n-    /// Creates a new `BufferedReader` with with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {\n-        // It's *much* faster to create an uninitialized buffer than it is to\n-        // fill everything in with 0. This buffer is entirely an implementation\n-        // detail and is never exposed, so we're safe to not initialize\n-        // everything up-front. This allows creation of BufferedReader instances\n-        // to be very cheap (large mallocs are not nearly as expensive as large\n-        // callocs).\n-        let mut buf = vec::with_capacity(cap);\n-        unsafe { vec::raw::set_len(&mut buf, cap); }\n-        BufferedReader {\n-            inner: inner,\n-            buf: buf,\n-            pos: 0,\n-            cap: 0\n-        }\n-    }\n-\n-    /// Creates a new `BufferedReader` with a default buffer capacity\n-    pub fn new(inner: R) -> BufferedReader<R> {\n-        BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n-    }\n-}\n-\n-impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] {\n-        if self.pos == self.cap {\n-            match self.inner.read(self.buf) {\n-                Some(cap) => {\n-                    self.pos = 0;\n-                    self.cap = cap;\n-                }\n-                None => {}\n-            }\n-        }\n-        return self.buf.slice(self.pos, self.cap);\n-    }\n-\n-    fn consume(&mut self, amt: uint) {\n-        self.pos += amt;\n-        assert!(self.pos <= self.cap);\n-    }\n-}\n-\n-impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        let nread = {\n-            let available = self.fill();\n-            if available.len() == 0 {\n-                return None;\n-            }\n-            let nread = num::min(available.len(), buf.len());\n-            vec::bytes::copy_memory(buf, available, nread);\n-            nread\n-        };\n-        self.pos += nread;\n-        Some(nread)\n-    }\n-\n-    fn eof(&mut self) -> bool {\n-        self.pos == self.cap && self.inner.eof()\n-    }\n-}\n-\n-impl<R: Reader> Decorator<R> for BufferedReader<R> {\n-    fn inner(self) -> R { self.inner }\n-    fn inner_ref<'a>(&'a self) -> &'a R { &self.inner }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.inner }\n-}\n-\n-/// Wraps a Writer and buffers output to it\n-///\n-/// Note that `BufferedWriter` will NOT flush its buffer when dropped.\n-pub struct BufferedWriter<W> {\n-    priv inner: W,\n-    priv buf: ~[u8],\n-    priv pos: uint\n-}\n-\n-impl<W: Writer> BufferedWriter<W> {\n-    /// Creates a new `BufferedWriter` with with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n-        // See comments in BufferedReader for why this uses unsafe code.\n-        let mut buf = vec::with_capacity(cap);\n-        unsafe { vec::raw::set_len(&mut buf, cap); }\n-        BufferedWriter {\n-            inner: inner,\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Creates a new `BufferedWriter` with a default buffer capacity\n-    pub fn new(inner: W) -> BufferedWriter<W> {\n-        BufferedWriter::with_capacity(DEFAULT_CAPACITY, inner)\n-    }\n-}\n-\n-impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n-        if self.pos + buf.len() > self.buf.len() {\n-            self.flush();\n-        }\n-\n-        if buf.len() > self.buf.len() {\n-            self.inner.write(buf);\n-        } else {\n-            let dst = self.buf.mut_slice_from(self.pos);\n-            vec::bytes::copy_memory(dst, buf, buf.len());\n-            self.pos += buf.len();\n-        }\n-    }\n-\n-    fn flush(&mut self) {\n-        if self.pos != 0 {\n-            self.inner.write(self.buf.slice_to(self.pos));\n-            self.pos = 0;\n-        }\n-        self.inner.flush();\n-    }\n-}\n-\n-impl<W: Writer> Decorator<W> for BufferedWriter<W> {\n-    fn inner(self) -> W { self.inner }\n-    fn inner_ref<'a>(&'a self) -> &'a W { &self.inner }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { &mut self.inner }\n-}\n-\n-/// Wraps a Writer and buffers output to it, flushing whenever a newline (0xa,\n-/// '\\n') is detected.\n-///\n-/// Note that this structure does NOT flush the output when dropped.\n-pub struct LineBufferedWriter<W> {\n-    priv inner: BufferedWriter<W>,\n-}\n-\n-impl<W: Writer> LineBufferedWriter<W> {\n-    /// Creates a new `LineBufferedWriter`\n-    pub fn new(inner: W) -> LineBufferedWriter<W> {\n-        // Lines typically aren't that long, don't use a giant buffer\n-        LineBufferedWriter {\n-            inner: BufferedWriter::with_capacity(1024, inner)\n-        }\n-    }\n-}\n-\n-impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n-        match buf.iter().position(|&b| b == '\\n' as u8) {\n-            Some(i) => {\n-                self.inner.write(buf.slice_to(i + 1));\n-                self.inner.flush();\n-                self.inner.write(buf.slice_from(i + 1));\n-            }\n-            None => self.inner.write(buf),\n-        }\n-    }\n-\n-    fn flush(&mut self) { self.inner.flush() }\n-}\n-\n-impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n-    fn inner(self) -> W { self.inner.inner() }\n-    fn inner_ref<'a>(&'a self) -> &'a W { self.inner.inner_ref() }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W { self.inner.inner_mut_ref() }\n-}\n-\n-struct InternalBufferedWriter<W>(BufferedWriter<W>);\n-\n-impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n-    fn eof(&mut self) -> bool { self.inner.eof() }\n-}\n-\n-/// Wraps a Stream and buffers input and output to and from it\n-///\n-/// Note that `BufferedStream` will NOT flush its output buffer when dropped.\n-pub struct BufferedStream<S> {\n-    priv inner: BufferedReader<InternalBufferedWriter<S>>\n-}\n-\n-impl<S: Stream> BufferedStream<S> {\n-    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)\n-                           -> BufferedStream<S> {\n-        let writer = BufferedWriter::with_capacity(writer_cap, inner);\n-        let internal_writer = InternalBufferedWriter(writer);\n-        let reader = BufferedReader::with_capacity(reader_cap,\n-                                                   internal_writer);\n-        BufferedStream { inner: reader }\n-    }\n-\n-    pub fn new(inner: S) -> BufferedStream<S> {\n-        BufferedStream::with_capacities(DEFAULT_CAPACITY, DEFAULT_CAPACITY,\n-                                        inner)\n-    }\n-}\n-\n-impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.inner.fill() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n-}\n-\n-impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n-    fn eof(&mut self) -> bool { self.inner.eof() }\n-}\n-\n-impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) { self.inner.inner.write(buf) }\n-    fn flush(&mut self) { self.inner.inner.flush() }\n-}\n-\n-impl<S: Stream> Decorator<S> for BufferedStream<S> {\n-    fn inner(self) -> S { self.inner.inner.inner() }\n-    fn inner_ref<'a>(&'a self) -> &'a S { self.inner.inner.inner_ref() }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n-        self.inner.inner.inner_mut_ref()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-    use io;\n-    use super::super::mem::{MemReader, MemWriter};\n-    use Harness = extra::test::BenchHarness;\n-\n-    /// A type, free to create, primarily intended for benchmarking creation of wrappers that, just\n-    /// for construction, don't need a Reader/Writer that does anything useful. Is equivalent to\n-    /// `/dev/null` in semantics.\n-    #[deriving(Clone,Eq,Ord)]\n-    pub struct NullStream;\n-\n-    impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n-        }\n-\n-        fn eof(&mut self) -> bool {\n-            true\n-        }\n-    }\n-\n-    impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) { }\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader() {\n-        let inner = MemReader::new(~[0, 1, 2, 3, 4]);\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(buf);\n-        assert_eq!(Some(2), nread);\n-        assert_eq!([0, 1, 0], buf);\n-        assert!(!reader.eof());\n-\n-        let mut buf = [0];\n-        let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n-        assert_eq!([2], buf);\n-        assert!(!reader.eof());\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n-        assert_eq!([3, 0, 0], buf);\n-        assert!(!reader.eof());\n-\n-        let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n-        assert_eq!([4, 0, 0], buf);\n-        assert!(reader.eof());\n-\n-        assert_eq!(None, reader.read(buf));\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer() {\n-        let inner = MemWriter::new();\n-        let mut writer = BufferedWriter::with_capacity(2, inner);\n-\n-        writer.write([0, 1]);\n-        assert_eq!([], writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([2]);\n-        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([3]);\n-        assert_eq!([0, 1], writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.flush();\n-        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([4]);\n-        writer.write([5]);\n-        assert_eq!([0, 1, 2, 3], writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([6]);\n-        assert_eq!([0, 1, 2, 3, 4, 5],\n-                   writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([7, 8]);\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6],\n-                   writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.write([9, 10, 11]);\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n-                   writer.inner_ref().inner_ref().as_slice());\n-\n-        writer.flush();\n-        assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n-                   writer.inner_ref().inner_ref().as_slice());\n-    }\n-\n-    // This is just here to make sure that we don't infinite loop in the\n-    // newtype struct autoderef weirdness\n-    #[test]\n-    fn test_buffered_stream() {\n-        struct S;\n-\n-        impl io::Writer for S {\n-            fn write(&mut self, _: &[u8]) {}\n-        }\n-\n-        impl io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> Option<uint> { None }\n-            fn eof(&mut self) -> bool { true }\n-        }\n-\n-        let mut stream = BufferedStream::new(S);\n-        let mut buf = [];\n-        stream.read(buf);\n-        stream.eof();\n-        stream.write(buf);\n-        stream.flush();\n-    }\n-\n-    #[test]\n-    fn test_read_until() {\n-        let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Some(~[0]));\n-        assert_eq!(reader.read_until(2), Some(~[1, 2]));\n-        assert_eq!(reader.read_until(1), Some(~[1]));\n-        assert_eq!(reader.read_until(8), Some(~[0]));\n-        assert_eq!(reader.read_until(9), None);\n-    }\n-\n-    #[test]\n-    fn test_line_buffer() {\n-        let mut writer = LineBufferedWriter::new(MemWriter::new());\n-        writer.write([0]);\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n-        writer.write([1]);\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[]);\n-        writer.flush();\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1]);\n-        writer.write([0, '\\n' as u8, 1]);\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1, 0, '\\n' as u8]);\n-        writer.flush();\n-        assert_eq!(*writer.inner_ref().inner_ref(), ~[0, 1, 0, '\\n' as u8, 1]);\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_reader(bh: &mut Harness) {\n-        bh.iter(|| {\n-            BufferedReader::new(NullStream);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_writer(bh: &mut Harness) {\n-        bh.iter(|| {\n-            BufferedWriter::new(NullStream);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_stream(bh: &mut Harness) {\n-        bh.iter(|| {\n-            BufferedStream::new(NullStream);\n-        });\n-    }\n-}"}, {"sha": "98dbec27fb9612fea2dd0e7e42bc544589b794a2", "filename": "libgrust/libstd/io/comm_adapters.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use option::Option;\n-use comm::{GenericPort, GenericChan};\n-use super::{Reader, Writer};\n-\n-struct PortReader<P>;\n-\n-impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(_port: P) -> PortReader<P> { fail!() }\n-}\n-\n-impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n-\n-    fn eof(&mut self) -> bool { fail!() }\n-}\n-\n-struct ChanWriter<C>;\n-\n-impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n-    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n-}\n-\n-impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n-}\n-\n-struct ReaderPort<R>;\n-\n-impl<R: Reader> ReaderPort<R> {\n-    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n-}\n-\n-impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n-    fn recv(&self) -> ~[u8] { fail!() }\n-\n-    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n-}\n-\n-struct WriterChan<W>;\n-\n-impl<W: Writer> WriterChan<W> {\n-    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n-}\n-\n-impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n-    fn send(&self, _x: ~[u8]) { fail!() }\n-}"}, {"sha": "564e664027f73ec32f1e5a9ae6e3812273cdf5cb", "filename": "libgrust/libstd/io/extensions.rs", "status": "removed", "additions": 0, "deletions": 489, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fextensions.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,489 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utility mixins that apply to all Readers and Writers\n-\n-// XXX: Not sure how this should be structured\n-// XXX: Iteration should probably be considered separately\n-\n-use iter::Iterator;\n-use option::Option;\n-use io::{Reader, Decorator};\n-\n-/// An iterator that reads a single byte on each iteration,\n-/// until `.read_byte()` returns `None`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `ByteIterator` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Failure\n-///\n-/// Raises the same conditions as the `read` method, for\n-/// each call to its `.next()` method.\n-/// Yields `None` if the condition is handled.\n-pub struct ByteIterator<T> {\n-    priv reader: T,\n-}\n-\n-impl<R: Reader> ByteIterator<R> {\n-    pub fn new(r: R) -> ByteIterator<R> {\n-        ByteIterator { reader: r }\n-    }\n-}\n-\n-impl<R> Decorator<R> for ByteIterator<R> {\n-    fn inner(self) -> R { self.reader }\n-    fn inner_ref<'a>(&'a self) -> &'a R { &self.reader }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.reader }\n-}\n-\n-impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.reader.read_byte()\n-    }\n-}\n-\n-pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[n as u8,\n-              (n >> 8) as u8]),\n-      4u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8]),\n-      8u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8,\n-              (n >> 32) as u8,\n-              (n >> 40) as u8,\n-              (n >> 48) as u8,\n-              (n >> 56) as u8]),\n-      _ => {\n-\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        let mut n = n;\n-        while i > 0u {\n-            bytes.push((n & 255_u64) as u8);\n-            n >>= 8_u64;\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[(n >> 8) as u8,\n-              n as u8]),\n-      4u => f(&[(n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      8u => f(&[(n >> 56) as u8,\n-              (n >> 48) as u8,\n-              (n >> 40) as u8,\n-              (n >> 32) as u8,\n-              (n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      _ => {\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        while i > 0u {\n-            let shift = ((i - 1u) * 8u) as u64;\n-            bytes.push((n >> shift) as u8);\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_from_be_bytes(data: &[u8],\n-                         start: uint,\n-                         size: uint)\n-                      -> u64 {\n-    let mut sz = size;\n-    assert!((sz <= 8u));\n-    let mut val = 0_u64;\n-    let mut pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data[pos] as u64) << ((sz * 8u) as u64);\n-        pos += 1u;\n-    }\n-    return val;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use option::{None, Option, Some};\n-    use io::mem::{MemReader, MemWriter};\n-    use io::{Reader, io_error, placeholder_error};\n-    use vec::ImmutableVector;\n-\n-    struct InitialZeroByteReader {\n-        count: int,\n-    }\n-\n-    impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                Some(0)\n-            } else {\n-                buf[0] = 10;\n-                Some(1)\n-            }\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    struct EofReader;\n-\n-    impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    struct ErroringReader;\n-\n-    impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            io_error::cond.raise(placeholder_error());\n-            None\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    struct PartialReader {\n-        count: int,\n-    }\n-\n-    impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Some(2)\n-            } else {\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Some(2)\n-            }\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    struct ErroringLaterReader {\n-        count: int,\n-    }\n-\n-    impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                Some(1)\n-            } else {\n-                io_error::cond.raise(placeholder_error());\n-                None\n-            }\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    struct ThreeChunkReader {\n-        count: int,\n-    }\n-\n-    impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Some(2)\n-            } else if self.count == 1 {\n-                self.count = 2;\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Some(2)\n-            } else {\n-                None\n-            }\n-        }\n-        fn eof(&mut self) -> bool {\n-            false\n-        }\n-    }\n-\n-    #[test]\n-    fn read_byte() {\n-        let mut reader = MemReader::new(~[10]);\n-        let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_0_bytes() {\n-        let mut reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_eof() {\n-        let mut reader = EofReader;\n-        let byte = reader.read_byte();\n-        assert!(byte == None);\n-    }\n-\n-    #[test]\n-    fn read_byte_error() {\n-        let mut reader = ErroringReader;\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            let byte = reader.read_byte();\n-            assert!(byte == None);\n-        });\n-    }\n-\n-    #[test]\n-    fn bytes_0_bytes() {\n-        let reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.bytes().next();\n-        assert!(byte == Some(10));\n-    }\n-\n-    #[test]\n-    fn bytes_eof() {\n-        let reader = EofReader;\n-        let byte = reader.bytes().next();\n-        assert!(byte == None);\n-    }\n-\n-    #[test]\n-    fn bytes_error() {\n-        let reader = ErroringReader;\n-        let mut it = reader.bytes();\n-        io_error::cond.trap(|_| ()).inside(|| {\n-            let byte = it.next();\n-            assert!(byte == None);\n-        })\n-    }\n-\n-    #[test]\n-    fn read_bytes() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let bytes = reader.read_bytes(4);\n-        assert!(bytes == ~[10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let bytes = reader.read_bytes(4);\n-        assert!(bytes == ~[10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            assert!(reader.read_bytes(4) == ~[10, 11]);\n-        })\n-    }\n-\n-    #[test]\n-    fn push_bytes() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_bytes_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_bytes_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n-        let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-            assert!(buf == ~[8, 9, 10, 11]);\n-        })\n-    }\n-\n-    #[test]\n-    fn push_bytes_error() {\n-        let mut reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| { } ).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-        });\n-        assert!(buf == ~[8, 9, 10]);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn push_bytes_fail_reset_len() {\n-        // push_bytes unsafely sets the vector length. This is testing that\n-        // upon failure the length is reset correctly.\n-        let mut reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        let buf = @mut ~[8, 9];\n-        (|| {\n-            reader.push_bytes(&mut *buf, 4);\n-        }).finally(|| {\n-            // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n-            // FIXME: #7049 This fails because buf is still borrowed\n-            //rtassert!(*buf == ~[8, 9, 10]);\n-        })\n-    }\n-\n-    #[test]\n-    fn read_to_end() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end();\n-        assert!(buf == ~[10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn read_to_end_error() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end();\n-        assert!(buf == ~[10, 11]);\n-    }\n-\n-    #[test]\n-    fn test_read_write_le_mem() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n-\n-        let mut writer = MemWriter::new();\n-        for i in uints.iter() {\n-            writer.write_le_u64(*i);\n-        }\n-\n-        let mut reader = MemReader::new(writer.inner());\n-        for i in uints.iter() {\n-            assert!(reader.read_le_u64() == *i);\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_read_write_be() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n-\n-        let mut writer = MemWriter::new();\n-        for i in uints.iter() {\n-            writer.write_be_u64(*i);\n-        }\n-\n-        let mut reader = MemReader::new(writer.inner());\n-        for i in uints.iter() {\n-            assert!(reader.read_be_u64() == *i);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_be_int_n() {\n-        let ints = [::i32::min_value, -123456, -42, -5, 0, 1, ::i32::max_value];\n-\n-        let mut writer = MemWriter::new();\n-        for i in ints.iter() {\n-            writer.write_be_i32(*i);\n-        }\n-\n-        let mut reader = MemReader::new(writer.inner());\n-        for i in ints.iter() {\n-            // this tests that the sign extension is working\n-            // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4) == *i as i64);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_f32() {\n-        //big-endian floating-point 8.1250\n-        let buf = ~[0x41, 0x02, 0x00, 0x00];\n-\n-        let mut writer = MemWriter::new();\n-        writer.write(buf);\n-\n-        let mut reader = MemReader::new(writer.inner());\n-        let f = reader.read_be_f32();\n-        assert!(f == 8.1250);\n-    }\n-\n-    #[test]\n-    fn test_read_write_f32() {\n-        let f:f32 = 8.1250;\n-\n-        let mut writer = MemWriter::new();\n-        writer.write_be_f32(f);\n-        writer.write_le_f32(f);\n-\n-        let mut reader = MemReader::new(writer.inner());\n-        assert!(reader.read_be_f32() == 8.1250);\n-        assert!(reader.read_le_f32() == 8.1250);\n-    }\n-\n-}"}, {"sha": "8a5aa171eb805d55c7dcb00f284580acf242313e", "filename": "libgrust/libstd/io/flate.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fflate.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fflate.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Some various other I/O types\n-\n-// FIXME(#3660): should move to libextra\n-\n-use prelude::*;\n-use super::*;\n-\n-/// A Writer decorator that compresses using the 'deflate' scheme\n-pub struct DeflateWriter<W> {\n-    priv inner_writer: W\n-}\n-\n-impl<W: Writer> DeflateWriter<W> {\n-    pub fn new(inner_writer: W) -> DeflateWriter<W> {\n-        DeflateWriter {\n-            inner_writer: inner_writer\n-        }\n-    }\n-}\n-\n-impl<W: Writer> Writer for DeflateWriter<W> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n-\n-    fn flush(&mut self) { fail!() }\n-}\n-\n-impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n-    fn inner(self) -> W {\n-        match self {\n-            DeflateWriter { inner_writer: w } => w\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a W {\n-        match *self {\n-            DeflateWriter { inner_writer: ref w } => w\n-        }\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n-        match *self {\n-            DeflateWriter { inner_writer: ref mut w } => w\n-        }\n-    }\n-}\n-\n-/// A Reader decorator that decompresses using the 'deflate' scheme\n-pub struct InflateReader<R> {\n-    priv inner_reader: R\n-}\n-\n-impl<R: Reader> InflateReader<R> {\n-    pub fn new(inner_reader: R) -> InflateReader<R> {\n-        InflateReader {\n-            inner_reader: inner_reader\n-        }\n-    }\n-}\n-\n-impl<R: Reader> Reader for InflateReader<R> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n-\n-    fn eof(&mut self) -> bool { fail!() }\n-}\n-\n-impl<R: Reader> Decorator<R> for InflateReader<R> {\n-    fn inner(self) -> R {\n-        match self {\n-            InflateReader { inner_reader: r } => r\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a R {\n-        match *self {\n-            InflateReader { inner_reader: ref r } => r\n-        }\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n-        match *self {\n-            InflateReader { inner_reader: ref mut r } => r\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-    use super::super::mem::*;\n-    use super::super::Decorator;\n-\n-    use str;\n-\n-    #[test]\n-    #[ignore]\n-    fn smoke_test() {\n-        let mem_writer = MemWriter::new();\n-        let mut deflate_writer = DeflateWriter::new(mem_writer);\n-        let in_msg = \"test\";\n-        let in_bytes = in_msg.as_bytes();\n-        deflate_writer.write(in_bytes);\n-        deflate_writer.flush();\n-        let buf = deflate_writer.inner().inner();\n-        let mem_reader = MemReader::new(buf);\n-        let mut inflate_reader = InflateReader::new(mem_reader);\n-        let mut out_bytes = [0, .. 100];\n-        let bytes_read = inflate_reader.read(out_bytes).unwrap();\n-        assert_eq!(bytes_read, in_bytes.len());\n-        let out_msg = str::from_utf8(out_bytes);\n-        assert!(in_msg == out_msg);\n-    }\n-}"}, {"sha": "a4be74d1d7f814e32e090beec62bc0a01c69930b", "filename": "libgrust/libstd/io/fs.rs", "status": "removed", "additions": 0, "deletions": 1274, "changes": 1274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Ffs.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,1274 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Synchronous File I/O\n-\n-This module provides a set of functions and traits for working\n-with regular files & directories on a filesystem.\n-\n-At the top-level of the module are a set of freestanding functions, associated\n-with various filesystem operations. They all operate on a `Path` object.\n-\n-All operations in this module, including those as part of `File` et al\n-block the task during execution. Most will raise `std::io::io_error`\n-conditions in the event of failure.\n-\n-Also included in this module is an implementation block on the `Path` object\n-defined in `std::path::Path`. The impl adds useful methods about inspecting the\n-metadata of a file. This includes getting the `stat` information, reading off\n-particular bits of it, etc.\n-\n-# Example\n-\n-    use std::io::{File, fs};\n-\n-    let path = Path::new(\"foo.txt\");\n-\n-    // create the file, whether it exists or not\n-    let mut file = File::create(&path);\n-    file.write(bytes!(\"foobar\"));\n-\n-    // open the file in read-only mode\n-    let mut file = File::open(&path);\n-    file.read_to_end();\n-\n-    println!(\"{}\", path.stat().size);\n-    fs::symlink(&path, &Path::new(\"bar.txt\"));\n-    fs::unlink(&path);\n-\n-*/\n-\n-use c_str::ToCStr;\n-use clone::Clone;\n-use iter::Iterator;\n-use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n-            FileMode, FileAccess, FileStat, io_error, FilePermission};\n-use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n-use io;\n-use option::{Some, None, Option};\n-use result::{Ok, Err, Result};\n-use path;\n-use path::{Path, GenericPath};\n-use vec::{OwnedVector, ImmutableVector};\n-\n-/// Unconstrained file access type that exposes read and write operations\n-///\n-/// Can be constructed via `File::open()`, `File::create()`, and\n-/// `File::open_mode()`.\n-///\n-/// # Errors\n-///\n-/// This type will raise an io_error condition if operations are attempted against\n-/// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `File::open_mode()`.\n-pub struct File {\n-    priv fd: ~RtioFileStream,\n-    priv path: Path,\n-    priv last_nread: int,\n-}\n-\n-fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    with_local_io(|io| {\n-        match f(io) {\n-            Ok(t) => Some(t),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    })\n-}\n-\n-impl File {\n-    /// Open a file at `path` in the mode specified by the `mode` and `access`\n-    /// arguments\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::io::{File, io_error, Open, ReadWrite};\n-    ///\n-    ///     let p = Path::new(\"/some/file/path.txt\");\n-    ///\n-    ///     io_error::cond.trap(|_| {\n-    ///         // hoo-boy...\n-    ///     }).inside(|| {\n-    ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n-    ///             Some(s) => s,\n-    ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n-    ///         };\n-    ///         // do some stuff with that file\n-    ///\n-    ///         // the file will be closed at the end of this block\n-    ///     })\n-    ///     // ..\n-    ///\n-    /// `FileMode` and `FileAccess` provide information about the permissions\n-    /// context in which a given stream is created. More information about them\n-    /// can be found in `std::io`'s docs. If a file is opened with `Write`\n-    /// or `ReadWrite` access, then it will be created it it does not already\n-    /// exist.\n-    ///\n-    /// Note that, with this function, a `File` is returned regardless of the\n-    /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-    /// `File` opened as `Read` will raise an `io_error` condition at runtime).\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise an `io_error` condition under a number of\n-    /// different circumstances, to include but not limited to:\n-    ///\n-    /// * Opening a file that does not exist with `Read` access.\n-    /// * Attempting to open a file with a `FileAccess` that the user lacks\n-    ///   permissions for\n-    /// * Filesystem-level errors (full disk, etc)\n-    pub fn open_mode(path: &Path,\n-                     mode: FileMode,\n-                     access: FileAccess) -> Option<File> {\n-        with_local_io(|io| {\n-            match io.fs_open(&path.to_c_str(), mode, access) {\n-                Ok(fd) => Some(File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n-            }\n-        })\n-    }\n-\n-    /// Attempts to open a file in read-only mode. This function is equivalent to\n-    /// `File::open_mode(path, Open, Read)`, and will raise all of the same\n-    /// errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::io::File;\n-    ///\n-    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n-    pub fn open(path: &Path) -> Option<File> {\n-        File::open_mode(path, Open, Read)\n-    }\n-\n-    /// Attempts to create a file in write-only mode. This function is\n-    /// equivalent to `File::open_mode(path, Truncate, Write)`, and will\n-    /// raise all of the same errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Example\n-    ///\n-    ///     use std::io::File;\n-    ///\n-    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n-    ///     f.write(bytes!(\"This is a sample file\"));\n-    pub fn create(path: &Path) -> Option<File> {\n-        File::open_mode(path, Truncate, Write)\n-    }\n-\n-    /// Returns the original path which was used to open this file.\n-    pub fn path<'a>(&'a self) -> &'a Path {\n-        &self.path\n-    }\n-\n-    /// Synchronizes all modifications to this file to its permanent storage\n-    /// device. This will flush any internal buffers necessary to perform this\n-    /// operation.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn fsync(&mut self) {\n-        self.fd.fsync().map_err(|e| io_error::cond.raise(e));\n-    }\n-\n-    /// This function is similar to `fsync`, except that it may not synchronize\n-    /// file metadata to the filesystem. This is intended for use case which\n-    /// must synchronize content, but don't need the metadata on disk. The goal\n-    /// of this method is to reduce disk operations.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn datasync(&mut self) {\n-        self.fd.datasync().map_err(|e| io_error::cond.raise(e));\n-    }\n-\n-    /// Either truncates or extends the underlying file, updating the size of\n-    /// this file to become `size`. This is equivalent to unix's `truncate`\n-    /// function.\n-    ///\n-    /// If the `size` is less than the current file's size, then the file will\n-    /// be shrunk. If it is greater than the current file's size, then the file\n-    /// will be extended to `size` and have all of the intermediate data filled\n-    /// in with 0s.\n-    ///\n-    /// # Errors\n-    ///\n-    /// On error, this function will raise on the `io_error` condition.\n-    pub fn truncate(&mut self, size: i64) {\n-        self.fd.truncate(size).map_err(|e| io_error::cond.raise(e));\n-    }\n-}\n-\n-/// Unlink a file from the underlying filesystem.\n-///\n-/// # Example\n-///\n-///     use std::io::fs;\n-///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     fs::unlink(&p);\n-///     // if we made it here without failing, then the\n-///     // unlink operation was successful\n-///\n-/// Note that, just because an unlink call was successful, it is not\n-/// guaranteed that a file is immediately deleted (e.g. depending on\n-/// platform, other open file descriptors may prevent immediate removal)\n-///\n-/// # Errors\n-///\n-/// This function will raise an `io_error` condition if the path points to a\n-/// directory, the user lacks permissions to remove the file, or if some\n-/// other filesystem-level error occurs.\n-pub fn unlink(path: &Path) {\n-    io_raise(|io| io.fs_unlink(&path.to_c_str()));\n-}\n-\n-/// Given a path, query the file system to get information about a file,\n-/// directory, etc. This function will traverse symlinks to query\n-/// information about the destination file.\n-///\n-/// Returns a fully-filled out stat structure on succes, and on failure it\n-/// will return a dummy stat structure (it is expected that the condition\n-/// raised is handled as well).\n-///\n-/// # Example\n-///\n-///     use std::io;\n-///     use std::io::fs;\n-///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     match io::result(|| fs::stat(&p)) {\n-///         Ok(stat) => { /* ... */ }\n-///         Err(e) => { /* handle error */ }\n-///     }\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks the\n-/// requisite permissions to perform a `stat` call on the given path or if\n-/// there is no entry in the filesystem at the provided path.\n-pub fn stat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_stat(&path.to_c_str())).unwrap_or_else(dummystat)\n-}\n-\n-fn dummystat() -> FileStat {\n-    FileStat {\n-        path: Path::new(\"\"),\n-        size: 0,\n-        kind: io::TypeFile,\n-        perm: 0,\n-        created: 0,\n-        modified: 0,\n-        accessed: 0,\n-        unstable: io::UnstableFileStat {\n-            device: 0,\n-            inode: 0,\n-            rdev: 0,\n-            nlink: 0,\n-            uid: 0,\n-            gid: 0,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n-}\n-\n-/// Perform the same operation as the `stat` function, except that this\n-/// function does not traverse through symlinks. This will return\n-/// information about the symlink file instead of the file that it points\n-/// to.\n-///\n-/// # Errors\n-///\n-/// See `stat`\n-pub fn lstat(path: &Path) -> FileStat {\n-    io_raise(|io| io.fs_lstat(&path.to_c_str())).unwrap_or_else(dummystat)\n-}\n-\n-/// Rename a file or directory to a new name.\n-///\n-/// # Example\n-///\n-///     use std::io::fs;\n-///\n-///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n-///     // Oh boy, nothing was raised!\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n-pub fn rename(from: &Path, to: &Path) {\n-    io_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n-}\n-\n-/// Copies the contents of one file to another. This function will also\n-/// copy the permission bits of the original file to the destination file.\n-///\n-/// Note that if `from` and `to` both point to the same file, then the file\n-/// will likely get truncated by this operation.\n-///\n-/// # Example\n-///\n-///     use std::io::fs;\n-///\n-///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n-///     // Oh boy, nothing was raised!\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition is the following situtations, but is\n-/// not limited to just these cases:\n-///\n-/// * The `from` path is not a file\n-/// * The `from` file does not exist\n-/// * The current process does not have the permission rights to access\n-///   `from` or write `to`\n-///\n-/// Note that this copy is not atomic in that once the destination is\n-/// ensured to not exist, there is nothing preventing the destination from\n-/// being created and then destroyed by this operation.\n-pub fn copy(from: &Path, to: &Path) {\n-    if !from.is_file() {\n-        return io_error::cond.raise(IoError {\n-            kind: io::MismatchedFileTypeForOperation,\n-            desc: \"the source path is not an existing file\",\n-            detail: None,\n-        });\n-    }\n-\n-    let mut reader = match File::open(from) { Some(f) => f, None => return };\n-    let mut writer = match File::create(to) { Some(f) => f, None => return };\n-    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n-\n-    loop {\n-        match reader.read(buf) {\n-            Some(amt) => writer.write(buf.slice_to(amt)),\n-            None => break\n-        }\n-    }\n-\n-    chmod(to, from.stat().perm)\n-}\n-\n-/// Changes the permission mode bits found on a file or a directory. This\n-/// function takes a mask from the `io` module\n-///\n-/// # Example\n-///\n-///     use std::io;\n-///     use std::io::fs;\n-///\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n-///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n-///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n-///\n-/// # Errors\n-///\n-/// If this funciton encounters an I/O error, it will raise on the `io_error`\n-/// condition. Some possible error situations are not having the permission to\n-/// change the attributes of a file or the file not existing.\n-pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    io_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n-}\n-\n-/// Change the user and group owners of a file at the specified path.\n-///\n-/// # Errors\n-///\n-/// This funtion will raise on the `io_error` condition on failure.\n-pub fn chown(path: &Path, uid: int, gid: int) {\n-    io_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n-}\n-\n-/// Creates a new hard link on the filesystem. The `dst` path will be a\n-/// link pointing to the `src` path. Note that systems often require these\n-/// two paths to both be located on the same filesystem.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n-pub fn link(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n-}\n-\n-/// Creates a new symbolic link on the filesystem. The `dst` path will be a\n-/// symlink pointing to the `src` path.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n-pub fn symlink(src: &Path, dst: &Path) {\n-    io_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n-}\n-\n-/// Reads a symlink, returning the file that the symlink points to.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure. Failure\n-/// conditions include reading a file that does not exist or reading a file\n-/// which is not a symlink.\n-pub fn readlink(path: &Path) -> Option<Path> {\n-    io_raise(|io| io.fs_readlink(&path.to_c_str()))\n-}\n-\n-/// Create a new, empty directory at the provided path\n-///\n-/// # Example\n-///\n-///     use std::libc::S_IRWXU;\n-///     use std::io::fs;\n-///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::mkdir(&p, S_IRWXU as int);\n-///     // If we got here, our directory exists! Horray!\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to make a new directory at the provided path, or if the directory already\n-/// exists.\n-pub fn mkdir(path: &Path, mode: FilePermission) {\n-    io_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n-}\n-\n-/// Remove an existing, empty directory\n-///\n-/// # Example\n-///\n-///     use std::io::fs;\n-///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::rmdir(&p);\n-///     // good riddance, you mean ol' directory\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to remove the directory at the provided path, or if the directory isn't\n-/// empty.\n-pub fn rmdir(path: &Path) {\n-    io_raise(|io| io.fs_rmdir(&path.to_c_str()));\n-}\n-\n-/// Retrieve a vector containing all entries within a provided directory\n-///\n-/// # Example\n-///\n-///     use std::io::fs;\n-///\n-///     // one possible implementation of fs::walk_dir only visiting files\n-///     fn visit_dirs(dir: &Path, cb: |&Path|) {\n-///         if dir.is_dir() {\n-///             let contents = fs::readdir(dir).unwrap();\n-///             for entry in contents.iter() {\n-///                 if entry.is_dir() { visit_dirs(entry, cb); }\n-///                 else { cb(entry); }\n-///             }\n-///         }\n-///         else { fail!(\"nope\"); }\n-///     }\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n-pub fn readdir(path: &Path) -> ~[Path] {\n-    io_raise(|io| io.fs_readdir(&path.to_c_str(), 0)).unwrap_or_else(|| ~[])\n-}\n-\n-/// Returns an iterator which will recursively walk the directory structure\n-/// rooted at `path`. The path given will not be iterated over, and this will\n-/// perform iteration in a top-down order.\n-pub fn walk_dir(path: &Path) -> WalkIterator {\n-    WalkIterator { stack: readdir(path) }\n-}\n-\n-/// An iterator which walks over a directory\n-pub struct WalkIterator {\n-    priv stack: ~[Path],\n-}\n-\n-impl Iterator<Path> for WalkIterator {\n-    fn next(&mut self) -> Option<Path> {\n-        match self.stack.shift_opt() {\n-            Some(path) => {\n-                if path.is_dir() {\n-                    self.stack.push_all_move(readdir(&path));\n-                }\n-                Some(path)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-/// Recursively create a directory and all of its parent components if they\n-/// are missing.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens, see `fs::mkdir` for more information about error conditions\n-/// and performance.\n-pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n-    // tjc: if directory exists but with different permissions,\n-    // should we return false?\n-    if path.is_dir() {\n-        return\n-    }\n-    if path.filename().is_some() {\n-        mkdir_recursive(&path.dir_path(), mode);\n-    }\n-    mkdir(path, mode)\n-}\n-\n-/// Removes a directory at this path, after removing all its contents. Use\n-/// carefully!\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens. See `file::unlink` and `fs::readdir` for possible error\n-/// conditions.\n-pub fn rmdir_recursive(path: &Path) {\n-    let children = readdir(path);\n-    for child in children.iter() {\n-        if child.is_dir() {\n-            rmdir_recursive(child);\n-        } else {\n-            unlink(child);\n-        }\n-    }\n-    // Directory should now be empty\n-    rmdir(path);\n-}\n-\n-/// Changes the timestamps for a file's last modification and access time.\n-/// The file at the path specified will have its last access time set to\n-/// `atime` and its modification time set to `mtime`. The times specified should\n-/// be in milliseconds.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens.\n-// FIXME(#10301) these arguments should not be u64\n-pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    io_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n-}\n-\n-impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.fd.read(buf) {\n-            Ok(read) => {\n-                self.last_nread = read;\n-                match read {\n-                    0 => None,\n-                    _ => Some(read as uint)\n-                }\n-            },\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != io::EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    fn eof(&mut self) -> bool { self.last_nread == 0 }\n-}\n-\n-impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.fd.write(buf) {\n-            Ok(()) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n-}\n-\n-impl Seek for File {\n-    fn tell(&self) -> u64 {\n-        let res = self.fd.tell();\n-        match res {\n-            Ok(cursor) => cursor,\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return -1;\n-            }\n-        }\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        match self.fd.seek(pos, style) {\n-            Ok(_) => {\n-                // successful seek resets EOF indicator\n-                self.last_nread = -1;\n-                ()\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n-}\n-\n-impl path::Path {\n-    /// Get information on the file, directory, etc at this path.\n-    ///\n-    /// Consult the `file::stat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n-    pub fn stat(&self) -> FileStat { stat(self) }\n-\n-    /// Boolean value indicator whether the underlying file exists on the local\n-    /// filesystem. This will return true if the path points to either a\n-    /// directory or a file.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    pub fn exists(&self) -> bool {\n-        io::result(|| self.stat()).is_ok()\n-    }\n-\n-    /// Whether the underlying implemention (be it a file path, or something\n-    /// else) points at a \"regular file\" on the FS. Will return false for paths\n-    /// to non-existent locations or directories or other non-regular files\n-    /// (named pipes, etc).\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    pub fn is_file(&self) -> bool {\n-        match io::result(|| self.stat()) {\n-            Ok(s) => s.kind == io::TypeFile,\n-            Err(..) => false\n-        }\n-    }\n-\n-    /// Whether the underlying implemention (be it a file path,\n-    /// or something else) is pointing at a directory in the underlying FS.\n-    /// Will return false for paths to non-existent locations or if the item is\n-    /// not a directory (eg files, named pipes, links, etc)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    pub fn is_dir(&self) -> bool {\n-        match io::result(|| self.stat()) {\n-            Ok(s) => s.kind == io::TypeDirectory,\n-            Err(..) => false\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-#[allow(unused_imports)]\n-mod test {\n-    use prelude::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-             ReadWrite};\n-    use io;\n-    use str;\n-    use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n-                 mkdir_recursive, copy, unlink, stat, symlink, link,\n-                 readlink, chmod, lstat, change_file_times};\n-    use util;\n-    use path::Path;\n-    use io;\n-    use ops::Drop;\n-\n-    struct TempDir(Path);\n-\n-    impl Drop for TempDir {\n-        fn drop(&mut self) {\n-            // Gee, seeing how we're testing the fs module I sure hope that we\n-            // at least implement this correctly!\n-            io::fs::rmdir_recursive(&**self);\n-        }\n-    }\n-\n-    fn tmpdir() -> TempDir {\n-        use os;\n-        use rand;\n-        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        io::fs::mkdir(&ret, io::UserRWX);\n-        TempDir(ret)\n-    }\n-\n-    macro_rules! test (\n-        { fn $name:ident() $b:block } => (\n-            mod $name {\n-                use prelude::*;\n-                use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-                         ReadWrite};\n-                use io;\n-                use str;\n-                use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n-                             mkdir_recursive, copy, unlink, stat, symlink, link,\n-                             readlink, chmod, lstat, change_file_times};\n-                use io::fs::test::tmpdir;\n-                use util;\n-\n-                fn f() $b\n-\n-                #[test] fn uv() { f() }\n-                #[test] fn native() {\n-                    use rt::test::run_in_newsched_task;\n-                    run_in_newsched_task(f);\n-                }\n-            }\n-        )\n-    )\n-\n-    test!(fn file_test_io_smoke_test() {\n-        let message = \"it's alright. have a good time\";\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n-        {\n-            let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            write_stream.write(message.as_bytes());\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            let mut read_buf = [0, .. 1028];\n-            let read_str = match read_stream.read(read_buf).unwrap() {\n-                -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n))\n-            };\n-            assert!(read_str == message.to_owned());\n-        }\n-        unlink(filename);\n-    })\n-\n-    test!(fn invalid_path_raises() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| {\n-            let result = File::open_mode(filename, Open, Read);\n-            assert!(result.is_none());\n-        });\n-        assert!(called);\n-    })\n-\n-    test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| unlink(filename));\n-        assert!(called);\n-    })\n-\n-    test!(fn file_test_io_non_positional_read() {\n-        let message = \"ten-four\";\n-        let mut read_mem = [0, .. 8];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            {\n-                let read_buf = read_mem.mut_slice(0, 4);\n-                read_stream.read(read_buf);\n-            }\n-            {\n-                let read_buf = read_mem.mut_slice(4, 8);\n-                read_stream.read(read_buf);\n-            }\n-        }\n-        unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.to_owned());\n-    })\n-\n-    test!(fn file_test_io_seek_and_tell_smoke_test() {\n-        let message = \"ten-four\";\n-        let mut read_mem = [0, .. 4];\n-        let set_cursor = 4 as u64;\n-        let mut tell_pos_pre_read;\n-        let mut tell_pos_post_read;\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.seek(set_cursor as i64, SeekSet);\n-            tell_pos_pre_read = read_stream.tell();\n-            read_stream.read(read_mem);\n-            tell_pos_post_read = read_stream.tell();\n-        }\n-        unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.slice(4, 8).to_owned());\n-        assert!(tell_pos_pre_read == set_cursor);\n-        assert!(tell_pos_post_read == message.len() as u64);\n-    })\n-\n-    test!(fn file_test_io_seek_and_write() {\n-        let initial_msg =   \"food-is-yummy\";\n-        let overwrite_msg =    \"-the-bar!!\";\n-        let final_msg =     \"foo-the-bar!!\";\n-        let seek_idx = 3;\n-        let mut read_mem = [0, .. 13];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n-            rw_stream.seek(seek_idx as i64, SeekSet);\n-            rw_stream.write(overwrite_msg.as_bytes());\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.read(read_mem);\n-        }\n-        unlink(filename);\n-        let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == final_msg.to_owned());\n-    })\n-\n-    test!(fn file_test_io_seek_shakedown() {\n-        use std::str;          // 01234567890123\n-        let initial_msg =   \"qwer-asdf-zxcv\";\n-        let chunk_one = \"qwer\";\n-        let chunk_two = \"asdf\";\n-        let chunk_three = \"zxcv\";\n-        let mut read_mem = [0, .. 4];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-\n-            read_stream.seek(-4, SeekEnd);\n-            read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_three.to_owned());\n-\n-            read_stream.seek(-9, SeekCur);\n-            read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_two.to_owned());\n-\n-            read_stream.seek(0, SeekSet);\n-            read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_one.to_owned());\n-        }\n-        unlink(filename);\n-    })\n-\n-    test!(fn file_test_stat_is_correct_on_is_file() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n-        {\n-            let mut fs = File::open_mode(filename, Open, ReadWrite);\n-            let msg = \"hw\";\n-            fs.write(msg.as_bytes());\n-        }\n-        let stat_res = stat(filename);\n-        assert_eq!(stat_res.kind, io::TypeFile);\n-        unlink(filename);\n-    })\n-\n-    test!(fn file_test_stat_is_correct_on_is_dir() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        mkdir(filename, io::UserRWX);\n-        let stat_res = filename.stat();\n-        assert!(stat_res.kind == io::TypeDirectory);\n-        rmdir(filename);\n-    })\n-\n-    test!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        mkdir(dir, io::UserRWX);\n-        assert!(dir.is_file() == false);\n-        rmdir(dir);\n-    })\n-\n-    test!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        let tmpdir = tmpdir();\n-        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        File::create(file).write(bytes!(\"foo\"));\n-        assert!(file.exists());\n-        unlink(file);\n-        assert!(!file.exists());\n-    })\n-\n-    test!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"before_and_after_dir\");\n-        assert!(!dir.exists());\n-        mkdir(dir, io::UserRWX);\n-        assert!(dir.exists());\n-        assert!(dir.is_dir());\n-        rmdir(dir);\n-        assert!(!dir.exists());\n-    })\n-\n-    test!(fn file_test_directoryinfo_readdir() {\n-        use std::str;\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"di_readdir\");\n-        mkdir(dir, io::UserRWX);\n-        let prefix = \"foo\";\n-        for n in range(0,3) {\n-            let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = File::create(&f);\n-            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n-            let msg = msg_str.as_bytes();\n-            w.write(msg);\n-        }\n-        let files = readdir(dir);\n-        let mut mem = [0u8, .. 4];\n-        for f in files.iter() {\n-            {\n-                let n = f.filestem_str();\n-                File::open(f).read(mem);\n-                let read_str = str::from_utf8(mem);\n-                let expected = match n {\n-                    None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n-                    Some(n) => prefix+n\n-                };\n-                assert!(expected == read_str);\n-            }\n-            unlink(f);\n-        }\n-        rmdir(dir);\n-    })\n-\n-    test!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n-    })\n-\n-    test!(fn unicode_path_is_dir() {\n-        assert!(Path::new(\".\").is_dir());\n-        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n-\n-        let tmpdir = tmpdir();\n-\n-        let mut dirpath = tmpdir.clone();\n-        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        mkdir(&dirpath, io::UserRWX);\n-        assert!(dirpath.is_dir());\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        File::create(&filepath); // ignore return; touch only\n-        assert!(!filepath.is_dir());\n-        assert!(filepath.exists());\n-    })\n-\n-    test!(fn unicode_path_exists() {\n-        assert!(Path::new(\".\").exists());\n-        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n-\n-        let tmpdir = tmpdir();\n-        let unicode = tmpdir.clone();\n-        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        mkdir(&unicode, io::UserRWX);\n-        assert!(unicode.exists());\n-        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-    })\n-\n-    test!(fn copy_file_does_not_exist() {\n-        let from = Path::new(\"test/nonexistent-bogus-path\");\n-        let to = Path::new(\"test/other-bogus-path\");\n-        match io::result(|| copy(&from, &to)) {\n-            Ok(..) => fail!(),\n-            Err(..) => {\n-                assert!(!from.exists());\n-                assert!(!to.exists());\n-            }\n-        }\n-    })\n-\n-    test!(fn copy_file_ok() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        File::create(&input).write(bytes!(\"hello\"));\n-        copy(&input, &out);\n-        let contents = File::open(&out).read_to_end();\n-        assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n-\n-        assert_eq!(input.stat().perm, out.stat().perm);\n-    })\n-\n-    test!(fn copy_file_dst_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        File::create(&out);\n-        match io::result(|| copy(&out, &*tmpdir)) {\n-            Ok(..) => fail!(), Err(..) => {}\n-        }\n-    })\n-\n-    test!(fn copy_file_dst_exists() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in\");\n-        let output = tmpdir.join(\"out\");\n-\n-        File::create(&input).write(\"foo\".as_bytes());\n-        File::create(&output).write(\"bar\".as_bytes());\n-        copy(&input, &output);\n-\n-        assert_eq!(File::open(&output).read_to_end(),\n-                   (bytes!(\"foo\")).to_owned());\n-    })\n-\n-    test!(fn copy_file_src_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        match io::result(|| copy(&*tmpdir, &out)) {\n-            Ok(..) => fail!(), Err(..) => {}\n-        }\n-        assert!(!out.exists());\n-    })\n-\n-    test!(fn copy_file_preserves_perm_bits() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        File::create(&input);\n-        chmod(&input, io::UserRead);\n-        copy(&input, &out);\n-        assert!(out.stat().perm & io::UserWrite == 0);\n-\n-        chmod(&input, io::UserFile);\n-        chmod(&out, io::UserFile);\n-    })\n-\n-    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    test!(fn symlinks_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        File::create(&input).write(\"foobar\".as_bytes());\n-        symlink(&input, &out);\n-        if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeSymlink);\n-        }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n-    })\n-\n-    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    test!(fn symlink_noexist() {\n-        let tmpdir = tmpdir();\n-        // symlinks can point to things that don't exist\n-        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n-        assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n-    })\n-\n-    test!(fn readlink_not_symlink() {\n-        let tmpdir = tmpdir();\n-        match io::result(|| readlink(&*tmpdir)) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    })\n-\n-    test!(fn links_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        File::create(&input).write(\"foobar\".as_bytes());\n-        link(&input, &out);\n-        if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeFile);\n-            assert_eq!(stat(&out).unstable.nlink, 2);\n-        }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n-\n-        // can't link to yourself\n-        match io::result(|| link(&input, &input)) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-        // can't link to something that doesn't exist\n-        match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    })\n-\n-    test!(fn chmod_works() {\n-        let tmpdir = tmpdir();\n-        let file = tmpdir.join(\"in.txt\");\n-\n-        File::create(&file);\n-        assert!(stat(&file).perm & io::UserWrite == io::UserWrite);\n-        chmod(&file, io::UserRead);\n-        assert!(stat(&file).perm & io::UserWrite == 0);\n-\n-        match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n-            Ok(..) => fail!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-\n-        chmod(&file, io::UserFile);\n-    })\n-\n-    test!(fn sync_doesnt_kill_anything() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.fsync();\n-        file.datasync();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n-        file.datasync();\n-        util::ignore(file);\n-    })\n-\n-    test!(fn truncate_works() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n-\n-        // Do some simple things with truncation\n-        assert_eq!(stat(&path).size, 3);\n-        file.truncate(10);\n-        assert_eq!(stat(&path).size, 10);\n-        file.write(bytes!(\"bar\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 10);\n-        assert_eq!(File::open(&path).read_to_end(),\n-                   (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n-\n-        // Truncate to a smaller length, don't seek, and then write something.\n-        // Ensure that the intermediate zeroes are all filled in (we're seeked\n-        // past the end of the file).\n-        file.truncate(2);\n-        assert_eq!(stat(&path).size, 2);\n-        file.write(bytes!(\"wut\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 9);\n-        assert_eq!(File::open(&path).read_to_end(),\n-                   (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n-        util::ignore(file);\n-    })\n-\n-    test!(fn open_flavors() {\n-        let tmpdir = tmpdir();\n-\n-        match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n-                                            io::Read)) {\n-            Ok(..) => fail!(), Err(..) => {}\n-        }\n-        File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n-\n-        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes());\n-        File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n-        {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n-                                        io::Read).unwrap();\n-            match io::result(|| f.write(\"wut\".as_bytes())) {\n-                Ok(..) => fail!(), Err(..) => {}\n-            }\n-        }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n-        {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n-        }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 6);\n-        {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n-        }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n-    })\n-\n-    #[test]\n-    fn utime() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"a\");\n-        File::create(&path);\n-\n-        change_file_times(&path, 1000, 2000);\n-        assert_eq!(path.stat().accessed, 1000);\n-        assert_eq!(path.stat().modified, 2000);\n-    }\n-\n-    #[test]\n-    fn utime_noexist() {\n-        let tmpdir = tmpdir();\n-\n-        match io::result(|| change_file_times(&tmpdir.join(\"a\"), 100, 200)) {\n-            Ok(..) => fail!(),\n-            Err(..) => {}\n-        }\n-    }\n-}"}, {"sha": "b08f4af9a54c6c3db981e1801ab8fecbb355429d", "filename": "libgrust/libstd/io/mem.rs", "status": "removed", "additions": 0, "deletions": 407, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fmem.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,407 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Readers and Writers for in-memory buffers\n-//!\n-//! # XXX\n-//!\n-//! * Should probably have something like this for strings.\n-//! * Should they implement Closable? Would take extra state.\n-use cmp::max;\n-use cmp::min;\n-use prelude::*;\n-use super::*;\n-use vec;\n-\n-/// Writes to an owned, growable byte vector\n-pub struct MemWriter {\n-    priv buf: ~[u8],\n-    priv pos: uint,\n-}\n-\n-impl MemWriter {\n-    pub fn new() -> MemWriter {\n-        MemWriter { buf: vec::with_capacity(128), pos: 0 }\n-    }\n-}\n-\n-impl Writer for MemWriter {\n-    fn write(&mut self, buf: &[u8]) {\n-        // Make sure the internal buffer is as least as big as where we\n-        // currently are\n-        let difference = self.pos as i64 - self.buf.len() as i64;\n-        if difference > 0 {\n-            self.buf.grow(difference as uint, &0);\n-        }\n-\n-        // Figure out what bytes will be used to overwrite what's currently\n-        // there (left), and what will be appended on the end (right)\n-        let cap = self.buf.len() - self.pos;\n-        let (left, right) = if cap <= buf.len() {\n-            (buf.slice_to(cap), buf.slice_from(cap))\n-        } else {\n-            (buf, &[])\n-        };\n-\n-        // Do the necessary writes\n-        if left.len() > 0 {\n-            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n-                                    left, left.len());\n-        }\n-        if right.len() > 0 {\n-            self.buf.push_all(right);\n-        }\n-\n-        // Bump us forward\n-        self.pos += buf.len();\n-    }\n-}\n-\n-// FIXME(#10432)\n-impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n-    }\n-}\n-\n-impl Decorator<~[u8]> for MemWriter {\n-    fn inner(self) -> ~[u8] { self.buf }\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n-}\n-\n-/// Reads from an owned byte vector\n-pub struct MemReader {\n-    priv buf: ~[u8],\n-    priv pos: uint\n-}\n-\n-impl MemReader {\n-    pub fn new(buf: ~[u8]) -> MemReader {\n-        MemReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-}\n-\n-impl Reader for MemReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        { if self.eof() { return None; } }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.mut_slice(0, write_len);\n-            assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input, write_len);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Some(write_len);\n-    }\n-\n-    fn eof(&mut self) -> bool { self.pos == self.buf.len() }\n-}\n-\n-impl Seek for MemReader {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n-\n-impl Buffer for MemReader {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n-}\n-\n-impl Decorator<~[u8]> for MemReader {\n-    fn inner(self) -> ~[u8] { self.buf }\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n-}\n-\n-\n-/// Writes to a fixed-size byte slice\n-///\n-/// If a write will not fit in the buffer, it raises the `io_error`\n-/// condition and does not write any data.\n-pub struct BufWriter<'self> {\n-    priv buf: &'self mut [u8],\n-    priv pos: uint\n-}\n-\n-impl<'self> BufWriter<'self> {\n-    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n-        BufWriter {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-}\n-\n-impl<'self> Writer for BufWriter<'self> {\n-    fn write(&mut self, buf: &[u8]) {\n-        // raises a condition if the entire write does not fit in the buffer\n-        let max_size = self.buf.len();\n-        if self.pos >= max_size || (self.pos + buf.len()) > max_size {\n-            io_error::cond.raise(IoError {\n-                kind: OtherIoError,\n-                desc: \"Trying to write past end of buffer\",\n-                detail: None\n-            });\n-            return;\n-        }\n-\n-        vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n-                                buf, buf.len());\n-        self.pos += buf.len();\n-    }\n-}\n-\n-// FIXME(#10432)\n-impl<'self> Seek for BufWriter<'self> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n-    }\n-}\n-\n-\n-/// Reads from a fixed-size byte slice\n-pub struct BufReader<'self> {\n-    priv buf: &'self [u8],\n-    priv pos: uint\n-}\n-\n-impl<'self> BufReader<'self> {\n-    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n-        BufReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-}\n-\n-impl<'self> Reader for BufReader<'self> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        { if self.eof() { return None; } }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.mut_slice(0, write_len);\n-            assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input, write_len);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Some(write_len);\n-     }\n-\n-    fn eof(&mut self) -> bool { self.pos == self.buf.len() }\n-}\n-\n-impl<'self> Seek for BufReader<'self> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n-}\n-\n-impl<'self> Buffer for BufReader<'self> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n-}\n-\n-///Calls a function with a MemWriter and returns\n-///the writer's stored vector.\n-pub fn with_mem_writer(writeFn: |&mut MemWriter|) -> ~[u8] {\n-    let mut writer = MemWriter::new();\n-    writeFn(&mut writer);\n-    writer.inner()\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::*;\n-    use io::*;\n-\n-    #[test]\n-    fn test_mem_writer() {\n-        let mut writer = MemWriter::new();\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([0]);\n-        assert_eq!(writer.tell(), 1);\n-        writer.write([1, 2, 3]);\n-        writer.write([4, 5, 6, 7]);\n-        assert_eq!(writer.tell(), 8);\n-        assert_eq!(*writer.inner_ref(), ~[0, 1, 2, 3, 4, 5, 6, 7]);\n-\n-        writer.seek(0, SeekSet);\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([3, 4]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 3, 4, 5, 6, 7]);\n-\n-        writer.seek(1, SeekCur);\n-        writer.write([0, 1]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 7]);\n-\n-        writer.seek(-1, SeekEnd);\n-        writer.write([1, 2]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n-\n-        writer.seek(1, SeekEnd);\n-        writer.write([1]);\n-        assert_eq!(*writer.inner_ref(), ~[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer() {\n-        let mut buf = [0 as u8, ..8];\n-        {\n-            let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([0]);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([1, 2, 3]);\n-            writer.write([4, 5, 6, 7]);\n-            assert_eq!(writer.tell(), 8);\n-        }\n-        assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7]);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_seek() {\n-        let mut buf = [0 as u8, ..8];\n-        {\n-            let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([1]);\n-            assert_eq!(writer.tell(), 1);\n-\n-            writer.seek(2, SeekSet);\n-            assert_eq!(writer.tell(), 2);\n-            writer.write([2]);\n-            assert_eq!(writer.tell(), 3);\n-\n-            writer.seek(-2, SeekCur);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([3]);\n-            assert_eq!(writer.tell(), 2);\n-\n-            writer.seek(-1, SeekEnd);\n-            assert_eq!(writer.tell(), 7);\n-            writer.write([4]);\n-            assert_eq!(writer.tell(), 8);\n-\n-        }\n-        assert_eq!(buf, [1, 3, 2, 0, 0, 0, 0, 4]);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_error() {\n-        let mut buf = [0 as u8, ..2];\n-        let mut writer = BufWriter::new(buf);\n-        writer.write([0]);\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, OtherIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.write([0, 0]);\n-        });\n-        assert!(called);\n-    }\n-\n-    #[test]\n-    fn test_mem_reader() {\n-        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n-        let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n-        assert_eq!(buf, [0]);\n-        let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n-        assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n-        assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert!(reader.eof());\n-        assert_eq!(reader.read(buf), None);\n-        assert!(reader.eof());\n-    }\n-\n-    #[test]\n-    fn test_buf_reader() {\n-        let in_buf = ~[0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = BufReader::new(in_buf);\n-        let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n-        assert_eq!(buf, [0]);\n-        let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n-        assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n-        assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert!(reader.eof());\n-        assert_eq!(reader.read(buf), None);\n-        assert!(reader.eof());\n-    }\n-\n-    #[test]\n-    fn test_with_mem_writer() {\n-        let buf = with_mem_writer(|wr| wr.write([1,2,3,4,5,6,7]));\n-        assert_eq!(buf, ~[1,2,3,4,5,6,7]);\n-    }\n-\n-    #[test]\n-    fn test_read_char() {\n-        let mut r = BufReader::new(bytes!(\"Vi\u1ec7t\"));\n-        assert_eq!(r.read_char(), Some('V'));\n-        assert_eq!(r.read_char(), Some('i'));\n-        assert_eq!(r.read_char(), Some('\u1ec7'));\n-        assert_eq!(r.read_char(), Some('t'));\n-        assert_eq!(r.read_char(), None);\n-    }\n-\n-    #[test]\n-    fn test_read_bad_char() {\n-        let mut r = BufReader::new(bytes!(0x80));\n-        assert_eq!(r.read_char(), None);\n-    }\n-}"}, {"sha": "8b680020fd9178cb5ddf00608a2b0db27f570373", "filename": "libgrust/libstd/io/mod.rs", "status": "removed", "additions": 0, "deletions": 1305, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,1305 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Synchronous I/O\n-\n-This module defines the Rust interface for synchronous I/O.\n-It models byte-oriented input and output with the Reader and Writer traits.\n-Types that implement both `Reader` and `Writer` are called 'streams',\n-and automatically implement the `Stream` trait.\n-Implementations are provided for common I/O streams like\n-file, TCP, UDP, Unix domain sockets.\n-Readers and Writers may be composed to add capabilities like string\n-parsing, encoding, and compression.\n-\n-# Examples\n-\n-Some examples of obvious things you might want to do\n-\n-* Read lines from stdin\n-\n-    for stdin().each_line |line| {\n-        println(line)\n-    }\n-\n-* Read a complete file to a string, (converting newlines?)\n-\n-    let contents = File::open(\"message.txt\").read_to_str(); // read_to_str??\n-\n-* Write a line to a file\n-\n-    let file = File::open(\"message.txt\", Create, Write);\n-    file.write_line(\"hello, file!\");\n-\n-* Iterate over the lines of a file\n-\n-    File::open(\"message.txt\").each_line(|line| {\n-        println(line)\n-    })\n-\n-* Pull the lines of a file into a vector of strings\n-\n-    let lines = File::open(\"message.txt\").lines().to_vec();\n-\n-* Make an simple HTTP request\n-\n-    let socket = TcpStream::open(\"localhost:8080\");\n-    socket.write_line(\"GET / HTTP/1.0\");\n-    socket.write_line(\"\");\n-    let response = socket.read_to_end();\n-\n-* Connect based on URL? Requires thinking about where the URL type lives\n-  and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n-  yields a `TcpStream`.\n-\n-    connect(\"tcp://localhost:8080\");\n-\n-# Terms\n-\n-* Reader - An I/O source, reads bytes into a buffer\n-* Writer - An I/O sink, writes bytes from a buffer\n-* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n-  and are collectively referred to a `streams`.\n-* Decorator - A Reader or Writer that composes with others to add additional capabilities\n-  such as encoding or decoding\n-\n-# Blocking and synchrony\n-\n-When discussing I/O you often hear the terms 'synchronous' and\n-'asynchronous', along with 'blocking' and 'non-blocking' compared and\n-contrasted. A synchronous I/O interface performs each I/O operation to\n-completion before proceeding to the next. Synchronous interfaces are\n-usually used in imperative style as a sequence of commands. An\n-asynchronous interface allows multiple I/O requests to be issued\n-simultaneously, without waiting for each to complete before proceeding\n-to the next.\n-\n-Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n-traditional single-threaded systems, performing a synchronous I/O\n-operation means that the program stops all activity (it 'blocks')\n-until the I/O is complete. Blocking is bad for performance when\n-there are other computations that could be done.\n-\n-Asynchronous interfaces are most often associated with the callback\n-(continuation-passing) style popularised by node.js. Such systems rely\n-on all computations being run inside an event loop which maintains a\n-list of all pending I/O events; when one completes the registered\n-callback is run and the code that made the I/O request continues.\n-Such interfaces achieve non-blocking at the expense of being more\n-difficult to reason about.\n-\n-Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n-\n-Remember that Rust tasks are 'green threads', lightweight threads that\n-are multiplexed onto a single operating system thread. If that system\n-thread blocks then no other task may proceed. Rust tasks are\n-relatively cheap to create, so as long as other tasks are free to\n-execute then non-blocking code may be written by simply creating a new\n-task.\n-\n-When discussing blocking in regards to Rust's I/O model, we are\n-concerned with whether performing I/O blocks other Rust tasks from\n-proceeding. In other words, when a task calls `read`, it must then\n-wait (or 'sleep', or 'block') until the call to `read` is complete.\n-During this time, other tasks may or may not be executed, depending on\n-how `read` is implemented.\n-\n-\n-Rust's default I/O implementation is non-blocking; by cooperating\n-directly with the task scheduler it arranges to never block progress\n-of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n-per-scheduler (and hence per-thread) event loop. Synchronous I/O\n-requests are implemented by descheduling the running task and\n-performing an asynchronous request; the task is only resumed once the\n-asynchronous request completes.\n-\n-For blocking (but possibly more efficient) implementations, look\n-in the `io::native` module.\n-\n-# Error Handling\n-\n-I/O is an area where nearly every operation can result in unexpected\n-errors. It should allow errors to be handled efficiently.\n-It needs to be convenient to use I/O when you don't care\n-about dealing with specific errors.\n-\n-Rust's I/O employs a combination of techniques to reduce boilerplate\n-while still providing feedback about errors. The basic strategy:\n-\n-* Errors are fatal by default, resulting in task failure\n-* Errors raise the `io_error` condition which provides an opportunity to inspect\n-  an IoError object containing details.\n-* Return values must have a sensible null or zero value which is returned\n-  if a condition is handled successfully. This may be an `Option`, an empty\n-  vector, or other designated error value.\n-* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n-  so that nullable values do not have to be 'unwrapped' before use.\n-\n-These features combine in the API to allow for expressions like\n-`File::new(\"diary.txt\").write_line(\"met a girl\")` without having to\n-worry about whether \"diary.txt\" exists or whether the write\n-succeeds. As written, if either `new` or `write_line` encounters\n-an error the task will fail.\n-\n-If you wanted to handle the error though you might write\n-\n-    let mut error = None;\n-    do io_error::cond(|e: IoError| {\n-        error = Some(e);\n-    }).in {\n-        File::new(\"diary.txt\").write_line(\"met a girl\");\n-    }\n-\n-    if error.is_some() {\n-        println(\"failed to write my diary\");\n-    }\n-\n-XXX: Need better condition handling syntax\n-\n-In this case the condition handler will have the opportunity to\n-inspect the IoError raised by either the call to `new` or the call to\n-`write_line`, but then execution will continue.\n-\n-So what actually happens if `new` encounters an error? To understand\n-that it's important to know that what `new` returns is not a `File`\n-but an `Option<File>`.  If the file does not open, and the condition\n-is handled, then `new` will simply return `None`. Because there is an\n-implementation of `Writer` (the trait required ultimately required for\n-types to implement `write_line`) there is no need to inspect or unwrap\n-the `Option<File>` and we simply call `write_line` on it.  If `new`\n-returned a `None` then the followup call to `write_line` will also\n-raise an error.\n-\n-## Concerns about this strategy\n-\n-This structure will encourage a programming style that is prone\n-to errors similar to null pointer dereferences.\n-In particular code written to ignore errors and expect conditions to be unhandled\n-will start passing around null or zero objects when wrapped in a condition handler.\n-\n-* XXX: How should we use condition handlers that return values?\n-* XXX: Should EOF raise default conditions when EOF is not an error?\n-\n-# Issues with i/o scheduler affinity, work stealing, task pinning\n-\n-# Resource management\n-\n-* `close` vs. RAII\n-\n-# Paths, URLs and overloaded constructors\n-\n-\n-\n-# Scope\n-\n-In scope for core\n-\n-* Url?\n-\n-Some I/O things don't belong in core\n-\n-  - url\n-  - net - `fn connect`\n-    - http\n-  - flate\n-\n-Out of scope\n-\n-* Async I/O. We'll probably want it eventually\n-\n-\n-# XXX Questions and issues\n-\n-* Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n-  Overloading would be nice.\n-* Add overloading for Path and &str and Url &str\n-* stdin/err/out\n-* print, println, etc.\n-* fsync\n-* relationship with filesystem querying, Directory, File types etc.\n-* Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n-* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n-* Trait for things that are both readers and writers, Stream?\n-* How to handle newline conversion\n-* String conversion\n-* open vs. connect for generic stream opening\n-* Do we need `close` at all? dtors might be good enough\n-* How does I/O relate to the Iterator trait?\n-* std::base64 filters\n-* Using conditions is a big unknown since we don't have much experience with them\n-* Too many uses of OtherIoError\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use cast;\n-use container::Container;\n-use int;\n-use iter::Iterator;\n-use option::{Option, Some, None};\n-use path::Path;\n-use result::{Ok, Err, Result};\n-use str;\n-use str::{StrSlice, OwnedStr};\n-use to_str::ToStr;\n-use uint;\n-use unstable::finally::Finally;\n-use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCopyableVector};\n-use vec;\n-\n-// Reexports\n-pub use self::stdio::stdin;\n-pub use self::stdio::stdout;\n-pub use self::stdio::stderr;\n-pub use self::stdio::print;\n-pub use self::stdio::println;\n-\n-pub use self::fs::File;\n-pub use self::timer::Timer;\n-pub use self::net::ip::IpAddr;\n-pub use self::net::tcp::TcpListener;\n-pub use self::net::tcp::TcpStream;\n-pub use self::net::udp::UdpStream;\n-pub use self::pipe::PipeStream;\n-pub use self::process::Process;\n-\n-/// Synchronous, non-blocking filesystem operations.\n-pub mod fs;\n-\n-/// Synchronous, in-memory I/O.\n-pub mod pipe;\n-\n-/// Child process management.\n-pub mod process;\n-\n-/// Synchronous, non-blocking network I/O.\n-pub mod net;\n-\n-/// Readers and Writers for memory buffers and strings.\n-pub mod mem;\n-\n-/// Non-blocking access to stdin, stdout, stderr\n-pub mod stdio;\n-\n-/// Implementations for Option\n-mod option;\n-\n-/// Basic stream compression. XXX: Belongs with other flate code\n-pub mod flate;\n-\n-/// Interop between byte streams and pipes. Not sure where it belongs\n-pub mod comm_adapters;\n-\n-/// Extension traits\n-pub mod extensions;\n-\n-/// Basic Timer\n-pub mod timer;\n-\n-/// Buffered I/O wrappers\n-pub mod buffered;\n-\n-pub mod native;\n-\n-/// Signal handling\n-pub mod signal;\n-\n-/// The default buffer size for various I/O operations\n-static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n-\n-/// The type passed to I/O condition handlers to indicate error\n-///\n-/// # XXX\n-///\n-/// Is something like this sufficient? It's kind of archaic\n-pub struct IoError {\n-    kind: IoErrorKind,\n-    desc: &'static str,\n-    detail: Option<~str>\n-}\n-\n-// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n-impl ToStr for IoError {\n-    fn to_str(&self) -> ~str {\n-        let mut s = ~\"IoError { kind: \";\n-        s.push_str(self.kind.to_str());\n-        s.push_str(\", desc: \");\n-        s.push_str(self.desc);\n-        s.push_str(\", detail: \");\n-        s.push_str(self.detail.to_str());\n-        s.push_str(\" }\");\n-        s\n-    }\n-}\n-\n-#[deriving(Eq)]\n-pub enum IoErrorKind {\n-    PreviousIoError,\n-    OtherIoError,\n-    EndOfFile,\n-    FileNotFound,\n-    PermissionDenied,\n-    ConnectionFailed,\n-    Closed,\n-    ConnectionRefused,\n-    ConnectionReset,\n-    ConnectionAborted,\n-    NotConnected,\n-    BrokenPipe,\n-    PathAlreadyExists,\n-    PathDoesntExist,\n-    MismatchedFileTypeForOperation,\n-    ResourceUnavailable,\n-    IoUnavailable,\n-}\n-\n-// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n-impl ToStr for IoErrorKind {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            PreviousIoError => ~\"PreviousIoError\",\n-            OtherIoError => ~\"OtherIoError\",\n-            EndOfFile => ~\"EndOfFile\",\n-            FileNotFound => ~\"FileNotFound\",\n-            PermissionDenied => ~\"PermissionDenied\",\n-            ConnectionFailed => ~\"ConnectionFailed\",\n-            Closed => ~\"Closed\",\n-            ConnectionRefused => ~\"ConnectionRefused\",\n-            ConnectionReset => ~\"ConnectionReset\",\n-            NotConnected => ~\"NotConnected\",\n-            BrokenPipe => ~\"BrokenPipe\",\n-            PathAlreadyExists => ~\"PathAlreadyExists\",\n-            PathDoesntExist => ~\"PathDoesntExist\",\n-            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\",\n-            IoUnavailable => ~\"IoUnavailable\",\n-            ResourceUnavailable => ~\"ResourceUnavailable\",\n-            ConnectionAborted => ~\"ConnectionAborted\",\n-        }\n-    }\n-}\n-\n-// XXX: Can't put doc comments on macros\n-// Raised by `I/O` operations on error.\n-condition! {\n-    pub io_error: IoError -> ();\n-}\n-\n-/// Helper for wrapper calls where you want to\n-/// ignore any io_errors that might be raised\n-pub fn ignore_io_error<T>(cb: || -> T) -> T {\n-    io_error::cond.trap(|_| {\n-        // just swallow the error.. downstream users\n-        // who can make a decision based on a None result\n-        // won't care\n-    }).inside(|| cb())\n-}\n-\n-/// Helper for catching an I/O error and wrapping it in a Result object. The\n-/// return result will be the last I/O error that happened or the result of the\n-/// closure if no error occurred.\n-pub fn result<T>(cb: || -> T) -> Result<T, IoError> {\n-    let mut err = None;\n-    let ret = io_error::cond.trap(|e| {\n-        if err.is_none() {\n-            err = Some(e);\n-        }\n-    }).inside(cb);\n-    match err {\n-        Some(e) => Err(e),\n-        None => Ok(ret),\n-    }\n-}\n-\n-pub trait Reader {\n-\n-    // Only two methods which need to get implemented for this trait\n-\n-    /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read. The number of bytes read my\n-    /// be less than the number requested, even 0. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. If the condition\n-    /// is handled then no guarantee is made about the number of bytes\n-    /// read and the contents of `buf`. If the condition is handled\n-    /// returns `None` (XXX see below).\n-    ///\n-    /// # XXX\n-    ///\n-    /// * Should raise_default error on eof?\n-    /// * If the condition is handled it should still return the bytes read,\n-    ///   in which case there's no need to return Option - but then you *have*\n-    ///   to install a handler to detect eof.\n-    ///\n-    /// This doesn't take a `len` argument like the old `read`.\n-    /// Will people often need to slice their vectors to call this\n-    /// and will that be annoying?\n-    /// Is it actually possible for 0 bytes to be read successfully?\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n-\n-    /// Return whether the Reader has reached the end of the stream.\n-    ///\n-    /// # Example\n-    ///\n-    ///     let reader = File::open(&Path::new(\"foo.txt\"))\n-    ///     while !reader.eof() {\n-    ///         println(reader.read_line());\n-    ///     }\n-    ///\n-    /// # Failure\n-    ///\n-    /// Returns `true` on failure.\n-    fn eof(&mut self) -> bool;\n-\n-    // Convenient helper methods based on the above methods\n-\n-    /// Reads a single byte. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method. Returns\n-    /// `None` if the condition is handled.\n-    fn read_byte(&mut self) -> Option<u8> {\n-        let mut buf = [0];\n-        match self.read(buf) {\n-            Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n-                self.read_byte()\n-            }\n-            Some(1) => Some(buf[0]),\n-            Some(_) => unreachable!(),\n-            None => None\n-        }\n-    }\n-\n-    /// Reads `len` bytes and appends them to a vector.\n-    ///\n-    /// May push fewer than the requested number of bytes on error\n-    /// or EOF. Returns true on success, false on EOF or error.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n-    /// than the requested number of bytes.\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n-        unsafe {\n-            let start_len = buf.len();\n-            let mut total_read = 0;\n-\n-            buf.reserve_additional(len);\n-            vec::raw::set_len(buf, start_len + len);\n-\n-            (|| {\n-                while total_read < len {\n-                    let len = buf.len();\n-                    let slice = buf.mut_slice(start_len + total_read, len);\n-                    match self.read(slice) {\n-                        Some(nread) => {\n-                            total_read += nread;\n-                        }\n-                        None => {\n-                            io_error::cond.raise(standard_error(EndOfFile));\n-                            break;\n-                        }\n-                    }\n-                }\n-            }).finally(|| vec::raw::set_len(buf, start_len + total_read))\n-        }\n-    }\n-\n-    /// Reads `len` bytes and gives you back a new vector of length `len`\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then the returned vector may\n-    /// contain less than the requested number of bytes.\n-    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        self.push_bytes(&mut buf, len);\n-        return buf;\n-    }\n-\n-    /// Reads all remaining bytes from the stream.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method.\n-    fn read_to_end(&mut self) -> ~[u8] {\n-        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n-        let mut keep_reading = true;\n-        io_error::cond.trap(|e| {\n-            if e.kind == EndOfFile {\n-                keep_reading = false;\n-            } else {\n-                io_error::cond.raise(e)\n-            }\n-        }).inside(|| {\n-            while keep_reading {\n-                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n-            }\n-        });\n-        return buf;\n-    }\n-\n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method, for\n-    /// each call to its `.next()` method.\n-    /// Ends the iteration if the condition is handled.\n-    fn bytes(self) -> extensions::ByteIterator<Self> {\n-        extensions::ByteIterator::new(self)\n-    }\n-\n-    // Byte conversion helpers\n-\n-    /// Reads `n` little-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        val\n-    }\n-\n-    /// Reads `n` little-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n-    }\n-\n-    /// Reads `n` big-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n-        }\n-        val\n-    }\n-\n-    /// Reads `n` big-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n-    }\n-\n-    /// Reads a little-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_le_uint(&mut self) -> uint {\n-        self.read_le_uint_n(uint::bytes) as uint\n-    }\n-\n-    /// Reads a little-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_le_int(&mut self) -> int {\n-        self.read_le_int_n(int::bytes) as int\n-    }\n-\n-    /// Reads a big-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_be_uint(&mut self) -> uint {\n-        self.read_be_uint_n(uint::bytes) as uint\n-    }\n-\n-    /// Reads a big-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependant.\n-    fn read_be_int(&mut self) -> int {\n-        self.read_be_int_n(int::bytes) as int\n-    }\n-\n-    /// Reads a big-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> u64 {\n-        self.read_be_uint_n(8) as u64\n-    }\n-\n-    /// Reads a big-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n-    }\n-\n-    /// Reads a big-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n-    }\n-\n-    /// Reads a big-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> i64 {\n-        self.read_be_int_n(8) as i64\n-    }\n-\n-    /// Reads a big-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> i32 {\n-        self.read_be_int_n(4) as i32\n-    }\n-\n-    /// Reads a big-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> i16 {\n-        self.read_be_int_n(2) as i16\n-    }\n-\n-    /// Reads a big-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n-        }\n-    }\n-\n-    /// Reads a big-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n-        }\n-    }\n-\n-    /// Reads a little-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> u64 {\n-        self.read_le_uint_n(8) as u64\n-    }\n-\n-    /// Reads a little-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n-    }\n-\n-    /// Reads a little-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n-    }\n-\n-    /// Reads a little-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> i64 {\n-        self.read_le_int_n(8) as i64\n-    }\n-\n-    /// Reads a little-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> i32 {\n-        self.read_le_int_n(4) as i32\n-    }\n-\n-    /// Reads a little-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> i16 {\n-        self.read_le_int_n(2) as i16\n-    }\n-\n-    /// Reads a little-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n-        }\n-    }\n-\n-    /// Reads a little-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n-        }\n-    }\n-\n-    /// Read a u8.\n-    ///\n-    /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> u8 {\n-        match self.read_byte() {\n-            Some(b) => b as u8,\n-            None => 0\n-        }\n-    }\n-\n-    /// Read an i8.\n-    ///\n-    /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> i8 {\n-        match self.read_byte() {\n-            Some(b) => b as i8,\n-            None => 0\n-        }\n-    }\n-\n-}\n-\n-impl Reader for ~Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n-    fn eof(&mut self) -> bool { self.eof() }\n-}\n-\n-impl<'self> Reader for &'self mut Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n-    fn eof(&mut self) -> bool { self.eof() }\n-}\n-\n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n-pub trait Writer {\n-    /// Write the given buffer\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error\n-    fn write(&mut self, buf: &[u8]);\n-\n-    /// Flush this output stream, ensuring that all intermediately buffered\n-    /// contents reach their destination.\n-    ///\n-    /// This is by default a no-op and implementors of the `Writer` trait should\n-    /// decide whether their stream needs to be buffered or not.\n-    fn flush(&mut self) {}\n-\n-    /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&mut self, n: int) {\n-        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-\n-    /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&mut self, n: uint) {\n-        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-\n-    /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&mut self, n: uint) {\n-        extensions::u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&mut self, n: int) {\n-        extensions::u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&mut self, n: uint) {\n-        extensions::u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&mut self, n: int) {\n-        extensions::u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&mut self, n: u64) {\n-        extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&mut self, n: u32) {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&mut self, n: u16) {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&mut self, n: i64) {\n-        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&mut self, n: i32) {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&mut self, n: i16) {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&mut self, f: f64) {\n-        unsafe {\n-            self.write_be_u64(cast::transmute(f))\n-        }\n-    }\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&mut self, f: f32) {\n-        unsafe {\n-            self.write_be_u32(cast::transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&mut self, n: u64) {\n-        extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&mut self, n: u32) {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&mut self, n: u16) {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&mut self, n: i64) {\n-        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&mut self, n: i32) {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&mut self, n: i16) {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    fn write_le_f64(&mut self, f: f64) {\n-        unsafe {\n-            self.write_le_u64(cast::transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    fn write_le_f32(&mut self, f: f32) {\n-        unsafe {\n-            self.write_le_u32(cast::transmute(f))\n-        }\n-    }\n-\n-    /// Write a u8 (1 byte).\n-    fn write_u8(&mut self, n: u8) {\n-        self.write([n])\n-    }\n-\n-    /// Write a i8 (1 byte).\n-    fn write_i8(&mut self, n: i8) {\n-        self.write([n as u8])\n-    }\n-}\n-\n-impl Writer for ~Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n-}\n-\n-impl<'self> Writer for &'self mut Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n-}\n-\n-pub trait Stream: Reader + Writer { }\n-\n-impl<T: Reader + Writer> Stream for T {}\n-\n-/// A Buffer is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n-/// This type extends the `Reader` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n-pub trait Buffer: Reader {\n-    /// Fills the internal buffer of this object, returning the buffer contents.\n-    /// Note that none of the contents will be \"read\" in the sense that later\n-    /// calling `read` may return the same contents.\n-    ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n-    ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n-    fn fill<'a>(&'a mut self) -> &'a [u8];\n-\n-    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n-    /// so they should no longer be returned in calls to `fill` or `read`.\n-    fn consume(&mut self, amt: uint);\n-\n-    /// Reads the next line of input, interpreted as a sequence of utf-8\n-    /// encoded unicode codepoints. If a newline is encountered, then the\n-    /// newline is contained in the returned string.\n-    ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered. The task will also fail if sequence of bytes leading up to\n-    /// the newline character are not valid utf-8.\n-    fn read_line(&mut self) -> Option<~str> {\n-        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n-    }\n-\n-    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n-    /// specified byte is encountered, reading ceases and the bytes up to and\n-    /// including the delimiter are returned.\n-    ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n-    fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n-        let mut res = ~[];\n-        let mut used;\n-        loop {\n-            {\n-                let available = self.fill();\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n-                        used = i + 1;\n-                        break\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        used = available.len();\n-                    }\n-                }\n-            }\n-            if used == 0 {\n-                break\n-            }\n-            self.consume(used);\n-        }\n-        self.consume(used);\n-        return if res.len() == 0 {None} else {Some(res)};\n-    }\n-\n-    /// Reads the next utf8-encoded character from the underlying stream.\n-    ///\n-    /// This will return `None` if the following sequence of bytes in the\n-    /// stream are not a valid utf8-sequence, or if an I/O error is encountered.\n-    ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n-    fn read_char(&mut self) -> Option<char> {\n-        let width = {\n-            let available = self.fill();\n-            if available.len() == 0 { return None } // read error\n-            str::utf8_char_width(available[0])\n-        };\n-        if width == 0 { return None } // not uf8\n-        let mut buf = [0, ..4];\n-        match self.read(buf.mut_slice_to(width)) {\n-            Some(n) if n == width => {}\n-            Some(..) | None => return None // read error\n-        }\n-        match str::from_utf8_slice_opt(buf.slice_to(width)) {\n-            Some(s) => Some(s.char_at(0)),\n-            None => None\n-        }\n-    }\n-}\n-\n-pub enum SeekStyle {\n-    /// Seek from the beginning of the stream\n-    SeekSet,\n-    /// Seek from the end of the stream\n-    SeekEnd,\n-    /// Seek from the current position\n-    SeekCur,\n-}\n-\n-/// # XXX\n-/// * Are `u64` and `i64` the right choices?\n-pub trait Seek {\n-    /// Return position of file cursor in the stream\n-    fn tell(&self) -> u64;\n-\n-    /// Seek to an offset in a stream\n-    ///\n-    /// A successful seek clears the EOF indicator.\n-    ///\n-    /// # XXX\n-    ///\n-    /// * What is the behavior when seeking past the end of a stream?\n-    fn seek(&mut self, pos: i64, style: SeekStyle);\n-}\n-\n-/// A listener is a value that can consume itself to start listening for connections.\n-/// Doing so produces some sort of Acceptor.\n-pub trait Listener<T, A: Acceptor<T>> {\n-    /// Spin up the listener and start queueing incoming connections\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises `io_error` condition. If the condition is handled,\n-    /// then `listen` returns `None`.\n-    fn listen(self) -> Option<A>;\n-}\n-\n-/// An acceptor is a value that presents incoming connections\n-pub trait Acceptor<T> {\n-    /// Wait for and accept an incoming connection\n-    ///\n-    /// # Failure\n-    /// Raise `io_error` condition. If the condition is handled,\n-    /// then `accept` returns `None`.\n-    fn accept(&mut self) -> Option<T>;\n-\n-    /// Create an iterator over incoming connection attempts\n-    fn incoming<'r>(&'r mut self) -> IncomingIterator<'r, Self> {\n-        IncomingIterator { inc: self }\n-    }\n-}\n-\n-/// An infinite iterator over incoming connection attempts.\n-/// Calling `next` will block the task until a connection is attempted.\n-///\n-/// Since connection attempts can continue forever, this iterator always returns Some.\n-/// The Some contains another Option representing whether the connection attempt was succesful.\n-/// A successful connection will be wrapped in Some.\n-/// A failed connection is represented as a None and raises a condition.\n-struct IncomingIterator<'self, A> {\n-    priv inc: &'self mut A,\n-}\n-\n-impl<'self, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingIterator<'self, A> {\n-    fn next(&mut self) -> Option<Option<T>> {\n-        Some(self.inc.accept())\n-    }\n-}\n-\n-/// Common trait for decorator types.\n-///\n-/// Provides accessors to get the inner, 'decorated' values. The I/O library\n-/// uses decorators to add functionality like compression and encryption to I/O\n-/// streams.\n-///\n-/// # XXX\n-///\n-/// Is this worth having a trait for? May be overkill\n-pub trait Decorator<T> {\n-    /// Destroy the decorator and extract the decorated value\n-    ///\n-    /// # XXX\n-    ///\n-    /// Because this takes `self' one could never 'undecorate' a Reader/Writer\n-    /// that has been boxed. Is that ok? This feature is mostly useful for\n-    /// extracting the buffer from MemWriter\n-    fn inner(self) -> T;\n-\n-    /// Take an immutable reference to the decorated value\n-    fn inner_ref<'a>(&'a self) -> &'a T;\n-\n-    /// Take a mutable reference to the decorated value\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n-}\n-\n-pub fn standard_error(kind: IoErrorKind) -> IoError {\n-    match kind {\n-        PreviousIoError => {\n-            IoError {\n-                kind: PreviousIoError,\n-                desc: \"Failing due to a previous I/O error\",\n-                detail: None\n-            }\n-        }\n-        EndOfFile => {\n-            IoError {\n-                kind: EndOfFile,\n-                desc: \"End of file\",\n-                detail: None\n-            }\n-        }\n-        IoUnavailable => {\n-            IoError {\n-                kind: IoUnavailable,\n-                desc: \"I/O is unavailable\",\n-                detail: None\n-            }\n-        }\n-        _ => fail!()\n-    }\n-}\n-\n-pub fn placeholder_error() -> IoError {\n-    IoError {\n-        kind: OtherIoError,\n-        desc: \"Placeholder error. You shouldn't be seeing this\",\n-        detail: None\n-    }\n-}\n-\n-/// A mode specifies how a file should be opened or created. These modes are\n-/// passed to `File::open_mode` and are used to control where the file is\n-/// positioned when it is initially opened.\n-pub enum FileMode {\n-    /// Opens a file positioned at the beginning.\n-    Open,\n-    /// Opens a file positioned at EOF.\n-    Append,\n-    /// Opens a file, truncating it if it already exists.\n-    Truncate,\n-}\n-\n-/// Access permissions with which the file should be opened. `File`s\n-/// opened with `Read` will raise an `io_error` condition if written to.\n-pub enum FileAccess {\n-    Read,\n-    Write,\n-    ReadWrite,\n-}\n-\n-/// Different kinds of files which can be identified by a call to stat\n-#[deriving(Eq)]\n-pub enum FileType {\n-    TypeFile,\n-    TypeDirectory,\n-    TypeNamedPipe,\n-    TypeBlockSpecial,\n-    TypeSymlink,\n-    TypeUnknown,\n-}\n-\n-pub struct FileStat {\n-    /// The path that this stat structure is describing\n-    path: Path,\n-    /// The size of the file, in bytes\n-    size: u64,\n-    /// The kind of file this path points to (directory, file, pipe, etc.)\n-    kind: FileType,\n-    /// The file permissions currently on the file\n-    perm: FilePermission,\n-\n-    // FIXME(#10301): These time fields are pretty useless without an actual\n-    //                time representation, what are the milliseconds relative\n-    //                to?\n-\n-    /// The time that the file was created at, in platform-dependent\n-    /// milliseconds\n-    created: u64,\n-    /// The time that this file was last modified, in platform-dependent\n-    /// milliseconds\n-    modified: u64,\n-    /// The time that this file was last accessed, in platform-dependent\n-    /// milliseconds\n-    accessed: u64,\n-\n-    /// Information returned by stat() which is not guaranteed to be\n-    /// platform-independent. This information may be useful on some platforms,\n-    /// but it may have different meanings or no meaning at all on other\n-    /// platforms.\n-    ///\n-    /// Usage of this field is discouraged, but if access is desired then the\n-    /// fields are located here.\n-    #[unstable]\n-    unstable: UnstableFileStat,\n-}\n-\n-/// This structure represents all of the possible information which can be\n-/// returned from a `stat` syscall which is not contained in the `FileStat`\n-/// structure. This information is not necessarily platform independent, and may\n-/// have different meanings or no meaning at all on some platforms.\n-#[unstable]\n-pub struct UnstableFileStat {\n-    device: u64,\n-    inode: u64,\n-    rdev: u64,\n-    nlink: u64,\n-    uid: u64,\n-    gid: u64,\n-    blksize: u64,\n-    blocks: u64,\n-    flags: u64,\n-    gen: u64,\n-}\n-\n-/// A set of permissions for a file or directory is represented by a set of\n-/// flags which are or'd together.\n-pub type FilePermission = u32;\n-\n-// Each permission bit\n-pub static UserRead: FilePermission     = 0x100;\n-pub static UserWrite: FilePermission    = 0x080;\n-pub static UserExecute: FilePermission  = 0x040;\n-pub static GroupRead: FilePermission    = 0x020;\n-pub static GroupWrite: FilePermission   = 0x010;\n-pub static GroupExecute: FilePermission = 0x008;\n-pub static OtherRead: FilePermission    = 0x004;\n-pub static OtherWrite: FilePermission   = 0x002;\n-pub static OtherExecute: FilePermission = 0x001;\n-\n-// Common combinations of these bits\n-pub static UserRWX: FilePermission  = UserRead | UserWrite | UserExecute;\n-pub static GroupRWX: FilePermission = GroupRead | GroupWrite | GroupExecute;\n-pub static OtherRWX: FilePermission = OtherRead | OtherWrite | OtherExecute;\n-\n-/// A set of permissions for user owned files, this is equivalent to 0644 on\n-/// unix-like systems.\n-pub static UserFile: FilePermission = UserRead | UserWrite | GroupRead | OtherRead;\n-/// A set of permissions for user owned directories, this is equivalent to 0755\n-/// on unix-like systems.\n-pub static UserDir: FilePermission = UserRWX | GroupRead | GroupExecute |\n-                                     OtherRead | OtherExecute;\n-/// A set of permissions for user owned executables, this is equivalent to 0755\n-/// on unix-like systems.\n-pub static UserExec: FilePermission = UserDir;\n-\n-/// A mask for all possible permission bits\n-pub static AllPermissions: FilePermission = 0x1ff;"}, {"sha": "218040b72d6b9dacd884551f4f2d51f6ce5ac5df", "filename": "libgrust/libstd/io/native/file.rs", "status": "removed", "additions": 0, "deletions": 976, "changes": 976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,976 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-\n-#[allow(non_camel_case_types)];\n-\n-use c_str::CString;\n-use io::IoError;\n-use io;\n-use libc::c_int;\n-use libc;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use os;\n-use path::{Path, GenericPath};\n-use ptr::RawPtr;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use super::IoResult;\n-use unstable::intrinsics;\n-use vec::ImmutableVector;\n-use vec;\n-\n-#[cfg(windows)] use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-#[cfg(windows)] use ptr;\n-#[cfg(windows)] use str;\n-\n-fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n-    #[cfg(windows)] static eintr: int = 0; // doesn't matter\n-    #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n-\n-    let (data, origamt) = data.as_imm_buf(|data, amt| (data, amt));\n-    let mut data = data;\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let mut ret;\n-        loop {\n-            ret = f(data, amt);\n-            if cfg!(not(windows)) { break } // windows has no eintr\n-            // if we get an eintr, then try again\n-            if ret != -1 || os::errno() as int != eintr { break }\n-        }\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n-pub type fd_t = libc::c_int;\n-\n-pub struct FileDesc {\n-    priv fd: fd_t,\n-    priv close_on_drop: bool,\n-}\n-\n-impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { fd: fd, close_on_drop: close_on_drop }\n-    }\n-\n-    fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        #[cfg(windows)] type rlen = libc::c_uint;\n-        #[cfg(not(windows))] type rlen = libc::size_t;\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::read(self.fd, buf as *mut libc::c_void, len as rlen) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        #[cfg(windows)] type wlen = libc::c_uint;\n-        #[cfg(not(windows))] type wlen = libc::size_t;\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.inner_read(buf) { Ok(n) => Some(n), Err(..) => None }\n-    }\n-    fn eof(&mut self) -> bool { false }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.inner_write(buf);\n-    }\n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                let mut bytes_read = 0;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::ReadFile(handle, buf as libc::LPVOID,\n-                                     amt as libc::DWORD,\n-                                     &mut bytes_read, &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(bytes_read as int)\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            match unsafe {\n-                libc::pread(fd, buf as *libc::c_void, amt as libc::size_t,\n-                            offset as libc::off_t)\n-            } {\n-                -1 => Err(super::last_error()),\n-                n => Ok(n as int)\n-            }\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n-\n-        #[cfg(windows)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            unsafe {\n-                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n-                let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n-                overlap.Offset = offset as libc::DWORD;\n-                overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-\n-                match libc::WriteFile(handle, buf as libc::LPVOID,\n-                                      amt as libc::DWORD,\n-                                      ptr::mut_null(), &mut overlap) {\n-                    0 => Err(super::last_error()),\n-                    _ => Ok(()),\n-                }\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            super::mkerr_libc(unsafe {\n-                libc::pwrite(fd, buf as *libc::c_void, amt as libc::size_t,\n-                             offset as libc::off_t)\n-            } as c_int)\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::FILE_BEGIN,\n-            io::SeekEnd => libc::FILE_END,\n-            io::SeekCur => libc::FILE_CURRENT,\n-        };\n-        unsafe {\n-            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n-            let mut newpos = 0;\n-            match libc::SetFilePointerEx(handle, pos, &mut newpos, whence) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(newpos as u64),\n-            }\n-        }\n-    }\n-    #[cfg(unix)]\n-    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match whence {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let n = unsafe { libc::lseek(self.fd, 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        return os_fsync(self.fd);\n-\n-        #[cfg(windows)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_winbool(unsafe {\n-                let handle = libc::get_osfhandle(fd);\n-                libc::FlushFileBuffers(handle as libc::HANDLE)\n-            })\n-        }\n-        #[cfg(unix)]\n-        fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_libc(unsafe { libc::fsync(fd) })\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n-\n-    #[cfg(not(windows))]\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        return super::mkerr_libc(os_datasync(self.fd));\n-\n-        #[cfg(target_os = \"macos\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fdatasync(fd) } }\n-        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n-        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fsync(fd) } }\n-    }\n-\n-    #[cfg(windows)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        let orig_pos = match self.tell() { Ok(i) => i, Err(e) => return Err(e) };\n-        match self.seek(offset, io::SeekSet) {\n-            Ok(_) => {}, Err(e) => return Err(e),\n-        };\n-        let ret = unsafe {\n-            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n-            match libc::SetEndOfFile(handle) {\n-                0 => Err(super::last_error()),\n-                _ => Ok(())\n-            }\n-        };\n-        self.seek(orig_pos as i64, io::SeekSet);\n-        return ret;\n-    }\n-    #[cfg(unix)]\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        super::mkerr_libc(unsafe {\n-            libc::ftruncate(self.fd, offset as libc::off_t)\n-        })\n-    }\n-}\n-\n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.inner_write(buf)\n-    }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n-}\n-\n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            unsafe { libc::close(self.fd); }\n-        }\n-    }\n-}\n-\n-pub struct CFile {\n-    priv file: *libc::FILE,\n-    priv fd: FileDesc,\n-}\n-\n-impl CFile {\n-    /// Create a `CFile` from an open `FILE` pointer.\n-    ///\n-    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n-    /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile {\n-        CFile {\n-            file: file,\n-            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n-        }\n-    }\n-\n-    pub fn flush(&mut self) -> Result<(), IoError> {\n-        super::mkerr_libc(unsafe { libc::fflush(self.file) })\n-    }\n-}\n-\n-impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as int)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        self.flush();\n-        self.fd.pread(buf, offset)\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        self.flush();\n-        self.fd.pwrite(buf, offset)\n-    }\n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n-        let whence = match style {\n-            io::SeekSet => libc::SEEK_SET,\n-            io::SeekEnd => libc::SEEK_END,\n-            io::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        let ret = unsafe { libc::ftell(self.file) };\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        self.flush();\n-        self.fd.fsync()\n-    }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        self.flush();\n-        self.fd.fsync()\n-    }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        self.flush();\n-        self.fd.truncate(offset)\n-    }\n-}\n-\n-impl Drop for CFile {\n-    fn drop(&mut self) {\n-        unsafe { libc::fclose(self.file); }\n-    }\n-}\n-\n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<FileDesc> {\n-    let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        io::Read => (flags | libc::O_RDONLY, 0),\n-        io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                      libc::S_IRUSR | libc::S_IWUSR),\n-        io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                          libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    return match os_open(path, flags, mode) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    };\n-\n-    #[cfg(windows)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        as_utf16_p(path.as_str().unwrap(), |path| {\n-            unsafe { libc::wopen(path, flags, mode) }\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        unsafe { libc::open(path.with_ref(|p| p), flags, mode) }\n-    }\n-}\n-\n-pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return os_mkdir(p, mode as c_int);\n-\n-    #[cfg(windows)]\n-    fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            // FIXME: turn mode into something useful? #2623\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::CreateDirectoryW(buf, ptr::mut_null())\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_mkdir(p: &CString, mode: c_int) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n-            libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n-        })\n-    }\n-}\n-\n-pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n-    fn prune(root: &CString, dirs: ~[Path]) -> ~[Path] {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n-        let root = Path::new(root);\n-\n-        dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }).map(|path| root.join(path)).collect()\n-    }\n-\n-    unsafe {\n-        #[cfg(not(windows))]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::{dirent_t};\n-            use libc::{opendir, readdir, closedir};\n-            extern {\n-                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-            }\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-            let dir_ptr = p.with_ref(|buf| opendir(buf));\n-\n-            if (dir_ptr as uint != 0) {\n-                let mut paths = ~[];\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                let mut entry_ptr = readdir(dir_ptr);\n-                while (entry_ptr as uint != 0) {\n-                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::new(cstr));\n-                    entry_ptr = readdir(dir_ptr);\n-                }\n-                closedir(dir_ptr);\n-                Ok(paths)\n-            } else {\n-                Err(super::last_error())\n-            }\n-        }\n-\n-        #[cfg(windows)]\n-        unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::{wcslen, free};\n-            use libc::funcs::extra::kernel32::{\n-                FindFirstFileW,\n-                FindNextFileW,\n-                FindClose,\n-            };\n-            use libc::types::os::arch::extra::HANDLE;\n-            use os::win32::{\n-                as_utf16_p\n-            };\n-            use rt::global_heap::malloc_raw;\n-\n-            #[nolink]\n-            extern {\n-                fn rust_list_dir_wfd_size() -> libc::size_t;\n-                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-            }\n-            let p = CString::new(p.with_ref(|p| p), false);\n-            let p = Path::new(p);\n-            let star = p.join(\"*\");\n-            as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                    let mut paths = ~[];\n-                    let mut more_files = 1 as libc::c_int;\n-                    while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n-                        if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                        }\n-                        else {\n-                            let fp_vec = vec::from_buf(\n-                                fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_str = str::from_utf16(fp_vec);\n-                            paths.push(Path::new(fp_str));\n-                        }\n-                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                    }\n-                    FindClose(find_handle);\n-                    free(wfd_ptr);\n-                    Ok(paths)\n-                } else {\n-                    Err(super::last_error())\n-                }\n-            })\n-        }\n-\n-        get_list(p).map(|paths| prune(p, paths))\n-    }\n-}\n-\n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    return os_unlink(p);\n-\n-    #[cfg(windows)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::DeleteFileW(buf)\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::unlink(p.with_ref(|p| p)) })\n-    }\n-}\n-\n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n-    return os_rename(old, new);\n-\n-    #[cfg(windows)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(unsafe {\n-            as_utf16_p(old.as_str().unwrap(), |old| {\n-                as_utf16_p(new.as_str().unwrap(), |new| {\n-                    libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-                })\n-            })\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n-            libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n-        })\n-    }\n-}\n-\n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n-    return super::mkerr_libc(os_chmod(p, mode as c_int));\n-\n-    #[cfg(windows)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wchmod(p, mode))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) }\n-    }\n-}\n-\n-pub fn rmdir(p: &CString) -> IoResult<()> {\n-    return super::mkerr_libc(os_rmdir(p));\n-\n-    #[cfg(windows)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wrmdir(p))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_rmdir(p: &CString) -> c_int {\n-        unsafe { libc::rmdir(p.with_ref(|p| p)) }\n-    }\n-}\n-\n-pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n-    return super::mkerr_libc(os_chown(p, uid, gid));\n-\n-    // libuv has this as a no-op, so seems like this should as well?\n-    #[cfg(windows)]\n-    fn os_chown(_p: &CString, _uid: int, _gid: int) -> c_int { 0 }\n-\n-    #[cfg(unix)]\n-    fn os_chown(p: &CString, uid: int, gid: int) -> c_int {\n-        unsafe {\n-            libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n-                        gid as libc::gid_t)\n-        }\n-    }\n-}\n-\n-pub fn readlink(p: &CString) -> IoResult<Path> {\n-    return os_readlink(p);\n-\n-    // XXX: I have a feeling that this reads intermediate symlinks as well.\n-    #[cfg(windows)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let handle = unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| {\n-                libc::CreateFileW(p,\n-                                  libc::GENERIC_READ,\n-                                  libc::FILE_SHARE_READ,\n-                                  ptr::mut_null(),\n-                                  libc::OPEN_EXISTING,\n-                                  libc::FILE_ATTRIBUTE_NORMAL,\n-                                  ptr::mut_null())\n-            })\n-        };\n-        if handle == ptr::mut_null() { return Err(super::last_error()) }\n-        let ret = fill_utf16_buf_and_decode(|buf, sz| {\n-            unsafe {\n-                libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n-                                                libc::VOLUME_NAME_NT)\n-            }\n-        });\n-        let ret = match ret {\n-            Some(s) => Ok(Path::new(s)),\n-            None => Err(super::last_error()),\n-        };\n-        unsafe { libc::CloseHandle(handle) };\n-        return ret;\n-\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_readlink(p: &CString) -> IoResult<Path> {\n-        let p = p.with_ref(|p| p);\n-        let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n-        if len == -1 {\n-            len = 1024; // XXX: read PATH_MAX from C ffi?\n-        }\n-        let mut buf = vec::with_capacity::<u8>(len as uint);\n-        match unsafe {\n-            libc::readlink(p, vec::raw::to_ptr(buf) as *mut libc::c_char,\n-                           len as libc::size_t)\n-        } {\n-            -1 => Err(super::last_error()),\n-            n => {\n-                assert!(n > 0);\n-                unsafe { vec::raw::set_len(&mut buf, n as uint); }\n-                Ok(Path::new(buf))\n-            }\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_symlink(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n-            })\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n-            libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        })\n-    }\n-}\n-\n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    return os_link(src, dst);\n-\n-    #[cfg(windows)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-            as_utf16_p(dst.as_str().unwrap(), |dst| {\n-                unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-            })\n-        }))\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n-            libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        })\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: stat.st_ctime as u64,\n-        modified: stat.st_mtime as u64,\n-        accessed: stat.st_atime as u64,\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn mkstat(stat: &libc::stat, path: &CString) -> io::FileStat {\n-    let path = unsafe { CString::new(path.with_ref(|p| p), false) };\n-\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(target_os = \"linux\"), not(target_os = \"android\"))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(target_os = \"linux\")] #[cfg(target_os = \"android\")]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    io::FileStat {\n-        path: Path::new(path),\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode) as io::FilePermission & io::AllPermissions,\n-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: flags(stat),\n-            gen: gen(stat),\n-        }\n-    }\n-}\n-\n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_stat(p);\n-\n-    #[cfg(windows)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        as_utf16_p(p.as_str().unwrap(), |up| {\n-            match unsafe { libc::wstat(up, &mut stat) } {\n-                0 => Ok(mkstat(&stat, p)),\n-                _ => Err(super::last_error()),\n-            }\n-        })\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        match unsafe { libc::stat(p.with_ref(|p| p), &mut stat) } {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n-    return os_lstat(p);\n-\n-    // XXX: windows implementation is missing\n-    #[cfg(windows)]\n-    fn os_lstat(_p: &CString) -> IoResult<io::FileStat> {\n-        Err(super::unimpl())\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        match unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) } {\n-            0 => Ok(mkstat(&stat, p)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    return super::mkerr_libc(os_utime(p, atime, mtime));\n-\n-    #[cfg(windows)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time64_t,\n-            modtime: (mtime / 1000) as libc::time64_t,\n-        };\n-        unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wutime(p, &buf))\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn os_utime(p: &CString, atime: u64, mtime: u64) -> c_int {\n-        let buf = libc::utimbuf {\n-            actime: (atime / 1000) as libc::time_t,\n-            modtime: (mtime / 1000) as libc::time_t,\n-        };\n-        unsafe { libc::utime(p.with_ref(|p| p), &buf) }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use io::native::file::{CFile, FileDesc};\n-    use io::fs;\n-    use io;\n-    use libc;\n-    use os;\n-    use path::Path;\n-    use rand;\n-    use result::Ok;\n-    use rt::rtio::RtioFileStream;\n-\n-    fn tmpdir() -> Path {\n-        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        fs::mkdir(&ret, io::UserRWX);\n-        ret\n-    }\n-\n-    #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        unsafe {\n-            let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input, true);\n-            let mut writer = FileDesc::new(out, true);\n-\n-            writer.inner_write(bytes!(\"test\"));\n-            let mut buf = [0u8, ..4];\n-            match reader.inner_read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-\n-            assert!(writer.inner_read(buf).is_err());\n-            assert!(reader.inner_write(buf).is_err());\n-        }\n-    }\n-\n-    #[ignore(cfg(windows))] // apparently windows doesn't like tmpfile\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n-\n-            file.write(bytes!(\"test\"));\n-            let mut buf = [0u8, ..4];\n-            file.seek(0, io::SeekSet);\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n-            }\n-        }\n-    }\n-}"}, {"sha": "cec0de00ec2b5f06cea114646be0279bbb22d66c", "filename": "libgrust/libstd/io/native/mod.rs", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnative%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6", "patch": "@@ -1,222 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native thread-blocking I/O implementation\n-//!\n-//! This module contains the implementation of native thread-blocking\n-//! implementations of I/O on all platforms. This module is not intended to be\n-//! used directly, but rather the rust runtime will fall back to using it if\n-//! necessary.\n-//!\n-//! Rust code normally runs inside of green tasks with a local scheduler using\n-//! asynchronous I/O to cooperate among tasks. This model is not always\n-//! available, however, and that's where these native implementations come into\n-//! play. The only dependencies of these modules are the normal system libraries\n-//! that you would find on the respective platform.\n-\n-use c_str::CString;\n-use comm::SharedChan;\n-use libc::c_int;\n-use libc;\n-use option::{Option, None, Some};\n-use os;\n-use path::Path;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket, RtioUnixListener,\n-               RtioPipe, RtioFileStream, RtioProcess, RtioSignal, RtioTTY,\n-               CloseBehavior, RtioTimer};\n-use io;\n-use io::IoError;\n-use io::net::ip::SocketAddr;\n-use io::process::ProcessConfig;\n-use io::signal::Signum;\n-use ai = io::net::addrinfo;\n-\n-// Local re-exports\n-pub use self::file::FileDesc;\n-pub use self::process::Process;\n-\n-// Native I/O implementations\n-pub mod file;\n-pub mod process;\n-\n-type IoResult<T> = Result<T, IoError>;\n-\n-fn unimpl() -> IoError {\n-    IoError {\n-        kind: io::IoUnavailable,\n-        desc: \"unimplemented I/O interface\",\n-        detail: None,\n-    }\n-}\n-\n-fn last_error() -> IoError {\n-    #[cfg(windows)]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-            _ => (io::OtherIoError, \"unknown error\"),\n-        }\n-    }\n-\n-    #[cfg(not(windows))]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        // XXX: this should probably be a bit more descriptive...\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-\n-            // These two constants can have the same value on some systems, but\n-            // different values on others, so we can't use a match clause\n-            x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-            _ => (io::OtherIoError, \"unknown error\"),\n-        }\n-    }\n-\n-    let (kind, desc) = get_err(os::errno() as i32);\n-    IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: Some(os::last_os_error())\n-    }\n-}\n-\n-// unix has nonzero values as errors\n-fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n-    if ret != 0 {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-// windows has zero values as errors\n-fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n-    if ret == 0 {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-/// Implementation of rt::rtio's IoFactory trait to generate handles to the\n-/// native I/O functionality.\n-pub struct IoFactory;\n-\n-impl rtio::IoFactory for IoFactory {\n-    // networking\n-    fn tcp_connect(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n-        Err(unimpl())\n-    }\n-    fn tcp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n-        Err(unimpl())\n-    }\n-    fn udp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n-        Err(unimpl())\n-    }\n-    fn unix_bind(&mut self, _path: &CString) -> IoResult<~RtioUnixListener> {\n-        Err(unimpl())\n-    }\n-    fn unix_connect(&mut self, _path: &CString) -> IoResult<~RtioPipe> {\n-        Err(unimpl())\n-    }\n-    fn get_host_addresses(&mut self, _host: Option<&str>, _servname: Option<&str>,\n-                          _hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n-        Err(unimpl())\n-    }\n-\n-    // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: CloseBehavior) -> ~RtioFileStream {\n-        let close = match close {\n-            rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n-            rtio::DontClose => false\n-        };\n-        ~file::FileDesc::new(fd, close) as ~RtioFileStream\n-    }\n-    fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n-        -> IoResult<~RtioFileStream> {\n-        file::open(path, fm, fa).map(|fd| ~fd as ~RtioFileStream)\n-    }\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n-        file::unlink(path)\n-    }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n-        file::stat(path)\n-    }\n-    fn fs_mkdir(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n-        file::mkdir(path, mode)\n-    }\n-    fn fs_chmod(&mut self, path: &CString,\n-                mode: io::FilePermission) -> IoResult<()> {\n-        file::chmod(path, mode)\n-    }\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n-        file::rmdir(path)\n-    }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n-        file::rename(path, to)\n-    }\n-    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<~[Path]> {\n-        file::readdir(path)\n-    }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<io::FileStat> {\n-        file::lstat(path)\n-    }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n-        file::chown(path, uid, gid)\n-    }\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<Path> {\n-        file::readlink(path)\n-    }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::symlink(src, dst)\n-    }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::link(src, dst)\n-    }\n-    fn fs_utime(&mut self, src: &CString, atime: u64,\n-                mtime: u64) -> IoResult<()> {\n-        file::utime(src, atime, mtime)\n-    }\n-\n-    // misc\n-    fn timer_init(&mut self) -> IoResult<~RtioTimer> {\n-        Err(unimpl())\n-    }\n-    fn spawn(&mut self, config: ProcessConfig)\n-            -> IoResult<(~RtioProcess, ~[Option<~RtioPipe>])> {\n-        process::Process::spawn(config).map(|(p, io)| {\n-            (~p as ~RtioProcess,\n-             io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe)).collect())\n-        })\n-    }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe> {\n-        Ok(~file::FileDesc::new(fd, true) as ~RtioPipe)\n-    }\n-    fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n-        if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n-        } else {\n-            Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n-                desc: \"file descriptor is not a TTY\",\n-                detail: None,\n-            })\n-        }\n-    }\n-    fn signal(&mut self, _signal: Signum, _channel: SharedChan<Signum>)\n-        -> IoResult<~RtioSignal> {\n-        Err(unimpl())\n-    }\n-}"}, {"sha": "1b61485273754385bed2aee4a16bd5932ccaae9d", "filename": "libgrust/libstd/io/native/process.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "03af64cc6dccfe2e6c42f6a9a5288f75d22dd892", "filename": "libgrust/libstd/io/net/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "6a97a21673d29b38540d0a0063c704240565f15e", "filename": "libgrust/libstd/io/net/ip.rs", "status": "removed", "additions": 0, "deletions": 443, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "cf109167089d40ca6581ce6bdade64927d65dfc0", "filename": "libgrust/libstd/io/net/mod.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "aa7a64d2210748d65d66ac3181e4b914daee1a0d", "filename": "libgrust/libstd/io/net/tcp.rs", "status": "removed", "additions": 0, "deletions": 725, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f02fc1ae4471cc856da94218bc9c733c335e899b", "filename": "libgrust/libstd/io/net/udp.rs", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "6d2deccaa4cfe738bab906d8d5c17957f040f512", "filename": "libgrust/libstd/io/net/unix.rs", "status": "removed", "additions": 0, "deletions": 295, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "61c5411f3602fa611759a702009c2632ba792951", "filename": "libgrust/libstd/io/option.rs", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Foption.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "373de1649edc4370a20237fc8a84460306aafea1", "filename": "libgrust/libstd/io/pipe.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fpipe.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "308e969c43a1f57a3d465b1de73db52995ac2a42", "filename": "libgrust/libstd/io/process.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fprocess.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f6e79a03323218766861c71a1f6b0a3f3b4ba879", "filename": "libgrust/libstd/io/signal.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fsignal.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "fe0385c9a957198c476282d8a58cbe5574e008c7", "filename": "libgrust/libstd/io/stdio.rs", "status": "removed", "additions": 0, "deletions": 329, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Fstdio.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "8dda79358887eac32eaadff4de407af3a4a31c3a", "filename": "libgrust/libstd/io/timer.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fio%2Ftimer.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "75a7d5db1321e392845d7ef31643108bf539a7e7", "filename": "libgrust/libstd/iter.rs", "status": "removed", "additions": 0, "deletions": 2917, "changes": 2917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fiter.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "6a48e18a3cc2a3340826c9eed45a0a5d23d112f4", "filename": "libgrust/libstd/kinds.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fkinds.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "a72bc6b832863e0700e35d599f0804b9d57596bb", "filename": "libgrust/libstd/lib.rs", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Flib.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "556009c2838967614406b40528aa7db3f50cb253", "filename": "libgrust/libstd/libc.rs", "status": "removed", "additions": 0, "deletions": 3549, "changes": 3549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Flibc.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "335bbc8b1da30d519b1a36d9e1238413c6113fe9", "filename": "libgrust/libstd/local_data.rs", "status": "removed", "additions": 0, "deletions": 570, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Flocal_data.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4af6d1d53be3b5bb376b413cf1eba82aecaae47f", "filename": "libgrust/libstd/logging.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Flogging.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "7322f0b0647a8ffba03dec71885b11e15bad9cfc", "filename": "libgrust/libstd/managed.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fmanaged.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "c4a546f71c315e88bb9df62bdcd46224607c7e57", "filename": "libgrust/libstd/mem.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fmem.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "72051a933980e610eca725ca54a1edab570455f6", "filename": "libgrust/libstd/num/cmath.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fcmath.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "a0dddffd85184faeb1663230ef187cdcfdeaee54", "filename": "libgrust/libstd/num/f32.rs", "status": "removed", "additions": 0, "deletions": 1283, "changes": 1283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Ff32.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "8cb7fa180018646958da64909d3bcae7fde04695", "filename": "libgrust/libstd/num/f64.rs", "status": "removed", "additions": 0, "deletions": 1333, "changes": 1333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Ff64.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "5c077c7e633d0cc16caa38fbc4ad810bb0a50a1f", "filename": "libgrust/libstd/num/i16.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fi16.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f076e33b3a2183808cbe533378380d174cee4500", "filename": "libgrust/libstd/num/i32.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fi32.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d991bf0330034a7e387280208e51c4d646d41e81", "filename": "libgrust/libstd/num/i64.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fi64.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "a807f6b9e53f3dbd9d5cd9fcdf6f61fc07fc995b", "filename": "libgrust/libstd/num/i8.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fi8.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "c5364fa3dab963d652d80b5f477f4b1138dacb3f", "filename": "libgrust/libstd/num/int.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fint.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "fc56bf91c2a77da3be867d8b5ce627921ea67cae", "filename": "libgrust/libstd/num/int_macros.rs", "status": "removed", "additions": 0, "deletions": 784, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fint_macros.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "456011d51720e2654a0354243aa86401d828a0d5", "filename": "libgrust/libstd/num/mod.rs", "status": "removed", "additions": 0, "deletions": 1725, "changes": 1725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "1028cef9dc6475754703644e1ee8bd7a040bcc88", "filename": "libgrust/libstd/num/strconv.rs", "status": "removed", "additions": 0, "deletions": 765, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fstrconv.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "e227947ca6e5f8d2f60ecf5a97459fc4f2c6e4c5", "filename": "libgrust/libstd/num/u16.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fu16.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4dbd543da7b0b252f71a881df0bc3a948ac33506", "filename": "libgrust/libstd/num/u32.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fu32.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d3077333077d3f65ecf2e3530dce3617f093a869", "filename": "libgrust/libstd/num/u64.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fu64.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "ca54af5cecc43808fc85a2131005a96bb962e9f8", "filename": "libgrust/libstd/num/u8.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fu8.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "cf28083bb09b941d6106614d85e3f3cbd113d299", "filename": "libgrust/libstd/num/uint.rs", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fuint.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "3c276378df86356577e183bc6967af28dd545e42", "filename": "libgrust/libstd/num/uint_macros.rs", "status": "removed", "additions": 0, "deletions": 557, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fnum%2Fuint_macros.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "cdc63608122a8ef4d512e97a9b4ad2a193f668df", "filename": "libgrust/libstd/ops.rs", "status": "removed", "additions": 0, "deletions": 488, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fops.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fops.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "715072653a7ab616fce00e4e6ad2afbbb235f915", "filename": "libgrust/libstd/option.rs", "status": "removed", "additions": 0, "deletions": 780, "changes": 780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Foption.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Foption.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "3433176961463ba7b31843facd71fef1cca23a85", "filename": "libgrust/libstd/os.rs", "status": "removed", "additions": 0, "deletions": 1492, "changes": 1492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fos.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fos.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "424c4fd6b2f44d0e4f4102e04e1827a62f667670", "filename": "libgrust/libstd/owned.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fowned.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "2b6009206acf7fc91ec0b9f1cfe5784847d635ab", "filename": "libgrust/libstd/path/mod.rs", "status": "removed", "additions": 0, "deletions": 704, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fpath%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "9b6b82266a2af40005ad72819c5eba5103acea5c", "filename": "libgrust/libstd/path/posix.rs", "status": "removed", "additions": 0, "deletions": 1407, "changes": 1407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fpath%2Fposix.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "cc2af54fd105c62fe2db9cf35d30f1f1a3964767", "filename": "libgrust/libstd/path/windows.rs", "status": "removed", "additions": 0, "deletions": 2360, "changes": 2360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fpath%2Fwindows.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "60fe21bb8d2b68a56535ded399c926c585006c44", "filename": "libgrust/libstd/prelude.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fprelude.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "9b9636af901f241c6b52662d55c7b68fb8ec3071", "filename": "libgrust/libstd/ptr.rs", "status": "removed", "additions": 0, "deletions": 707, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fptr.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "e042874245967af31fed9e5fa2f944571db63b14", "filename": "libgrust/libstd/rand/distributions/gamma.rs", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4778e81f95169510e2ff019e9935afe3815de16d", "filename": "libgrust/libstd/rand/distributions/mod.rs", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "db9cefa4d799d3f39d78d0f84d789a43ff25e18b", "filename": "libgrust/libstd/rand/distributions/range.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fdistributions%2Frange.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "049ef3dbb5936933b894b9dfe9891fa872affa97", "filename": "libgrust/libstd/rand/distributions/ziggurat_tables.rs", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fziggurat_tables.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fdistributions%2Fziggurat_tables.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fdistributions%2Fziggurat_tables.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "877df1fb644f49c443c78eb67ca2c76841d67fd8", "filename": "libgrust/libstd/rand/isaac.rs", "status": "removed", "additions": 0, "deletions": 536, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fisaac.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "ae53ef8b7c0b15ace73bdf2f66c32bfbb2270dfa", "filename": "libgrust/libstd/rand/mod.rs", "status": "removed", "additions": 0, "deletions": 951, "changes": 951, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "5558b8b33487bd08bb6e78b8f42dd8eb8bafa90d", "filename": "libgrust/libstd/rand/os.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Fos.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "ff722b739a86a70eceb2ae140185aea1bc105969", "filename": "libgrust/libstd/rand/rand_impls.rs", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Frand_impls.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4beabb8bf6aa461c30b7323aff314e847a69256e", "filename": "libgrust/libstd/rand/reader.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Freader.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "7055b7af3ded643c8a3cf791d6a9f911c5f1f1a4", "filename": "libgrust/libstd/rand/reseeding.rs", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Freseeding.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frand%2Freseeding.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f2beea992c67a13d430c90ec41eaf3668ce00c26", "filename": "libgrust/libstd/rc.rs", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frc.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "8a3e60eb3e2d521dc9da6356a47d49c6f7a6439b", "filename": "libgrust/libstd/reflect.rs", "status": "removed", "additions": 0, "deletions": 484, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Freflect.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "081673e86cb5099ad81bc86bffa4b3586041a332", "filename": "libgrust/libstd/repr.rs", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frepr.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "afcf092b4f6cb251f9726a5eff1907fb79cdb08c", "filename": "libgrust/libstd/result.rs", "status": "removed", "additions": 0, "deletions": 618, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fresult.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "7b27161ab5d7c9fd7954ee3d2d604fd13ef05f05", "filename": "libgrust/libstd/rt/args.rs", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fargs.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d857f39ceaf0aa9cd94f8a92248448906ae9d61e", "filename": "libgrust/libstd/rt/basic.rs", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fbasic.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "30c2264bd869790afa919e109ce568d1cdf4c9e2", "filename": "libgrust/libstd/rt/borrowck.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fborrowck.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "06743bce9bf49a3293ac5ac46876a9cf910dcb31", "filename": "libgrust/libstd/rt/comm.rs", "status": "removed", "additions": 0, "deletions": 1166, "changes": 1166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fcomm.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "418557f659b0092c3dd2ad1063d9599b115162f9", "filename": "libgrust/libstd/rt/context.rs", "status": "removed", "additions": 0, "deletions": 460, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fcontext.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "6dcbd4a129e5c62ef7d227ca2e9c3f163fe7f366", "filename": "libgrust/libstd/rt/crate_map.rs", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fcrate_map.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d1bd450afe2756d8b5e9ae9dbcaa92d0b40e4e27", "filename": "libgrust/libstd/rt/env.rs", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fenv.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "3147e3c8a078e18e6196a10043f10598908c7638", "filename": "libgrust/libstd/rt/global_heap.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fglobal_heap.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "56c77ffaa0d3772a18d7a4adc298f1410fa238fa", "filename": "libgrust/libstd/rt/kill.rs", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fkill.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "2375ce55766806969d633145e7449406a4505f80", "filename": "libgrust/libstd/rt/local.rs", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Flocal.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "c98a66453eb158bd0a74eb918e6a5ebd562b231d", "filename": "libgrust/libstd/rt/local_heap.rs", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Flocal_heap.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "803938589afcf3a26f7ca07a48218589248b80eb", "filename": "libgrust/libstd/rt/local_ptr.rs", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Flocal_ptr.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "13e18f7d9b75ee83c5c8d82f41bc6fc3d6a23c11", "filename": "libgrust/libstd/rt/logging.rs", "status": "removed", "additions": 0, "deletions": 338, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Flogging.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "3ef57710344dc06c700b834770099fa83a292dde", "filename": "libgrust/libstd/rt/macros.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fmacros.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "10e457368f007e3e36ccdb8f2e33a2fd7105b192", "filename": "libgrust/libstd/rt/message_queue.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fmessage_queue.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "78ec32ead3ccba1816dd809138e71daa2ed3fbfd", "filename": "libgrust/libstd/rt/mod.rs", "status": "removed", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "7f607fcf12a63a70290add3a0b4cb3fe57191688", "filename": "libgrust/libstd/rt/mpmc_bounded_queue.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4f39a1df4fa53f1f041c5f15da739b0c13e1c7bc", "filename": "libgrust/libstd/rt/mpsc_queue.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmpsc_queue.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fmpsc_queue.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "2699dab6d38a871586762b7f331092b32fbc2d6b", "filename": "libgrust/libstd/rt/rc.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Frc.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f83932f9ffa28ed571108a347e0bb74c5d3fd50c", "filename": "libgrust/libstd/rt/rtio.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Frtio.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d66bd1e4135650b6a03b1e2112bbba896e4a1ec6", "filename": "libgrust/libstd/rt/sched.rs", "status": "removed", "additions": 0, "deletions": 1371, "changes": 1371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fsched.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "6cde0a1f2169f5f6f47c38040d1dc15570e5f7f4", "filename": "libgrust/libstd/rt/select.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fselect.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "39c7431837f6eed810594a59217f4eaf34b2eb25", "filename": "libgrust/libstd/rt/sleeper_list.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fsleeper_list.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4358390da9f710be8201bf4659892716d3144224", "filename": "libgrust/libstd/rt/stack.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fstack.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "e5f7c08912ae3cd711e645f527a5356ff6d82b41", "filename": "libgrust/libstd/rt/task.rs", "status": "removed", "additions": 0, "deletions": 793, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Ftask.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "943b76dd1a0ecd992bef605e8144f9fdd5517668", "filename": "libgrust/libstd/rt/test.rs", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Ftest.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "9031147f8b139a6a128afdb41849113b511d3bf8", "filename": "libgrust/libstd/rt/thread.rs", "status": "removed", "additions": 0, "deletions": 220, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fthread.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "62e1b6c50d65f82ec73004513396e3f2520dbc62", "filename": "libgrust/libstd/rt/thread_local_storage.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "0d4171d5a643ca1c70a44b25cfe68631ee201e8b", "filename": "libgrust/libstd/rt/tube.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Ftube.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "93721986f3c259d88d89aea9f442165a38a4ffb8", "filename": "libgrust/libstd/rt/util.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Futil.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "02ea8ab4f5037b65fc442cd770081280eae4e47b", "filename": "libgrust/libstd/rt/work_queue.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frt%2Fwork_queue.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "7f977fdd2a39f5a15b49fc093adbc033bae900b8", "filename": "libgrust/libstd/run.rs", "status": "removed", "additions": 0, "deletions": 601, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frun.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Frun.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "43f1c3c529671281f0c8bba088589365d024b935", "filename": "libgrust/libstd/select.rs", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fselect.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "3ef99d48a034546c9225d279f70290253ee48d9d", "filename": "libgrust/libstd/send_str.rs", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fsend_str.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f65ec6971aba7af47d466c835014c4dc2a58a72a", "filename": "libgrust/libstd/str.rs", "status": "removed", "additions": 0, "deletions": 4008, "changes": 4008, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fstr.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "a587515bb16269211906ea583ddbb89a5804b07b", "filename": "libgrust/libstd/task/mod.rs", "status": "removed", "additions": 0, "deletions": 844, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ftask%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "198fe596a896ee4fc18432bd99d7535ecf6c8233", "filename": "libgrust/libstd/task/spawn.rs", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ftask%2Fspawn.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d81fe0c2fbd8a87460b988b17a428a350a0eb106", "filename": "libgrust/libstd/to_bytes.rs", "status": "removed", "additions": 0, "deletions": 389, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fto_bytes.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "554b9a851004835dba303540008bf3b68546e579", "filename": "libgrust/libstd/to_str.rs", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fto_str.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "97209e99bd67027e46258440df22773e43608fac", "filename": "libgrust/libstd/trie.rs", "status": "removed", "additions": 0, "deletions": 797, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ftrie.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "623909b79759e6f962d6c04b5b1281bc355d367d", "filename": "libgrust/libstd/tuple.rs", "status": "removed", "additions": 0, "deletions": 444, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Ftuple.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "f19ce98ff1a331e440064db208b7ba62e8df8dca", "filename": "libgrust/libstd/unicode.rs", "status": "removed", "additions": 0, "deletions": 5520, "changes": 5520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funicode.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "c27f6e3d086b68840794f0f9bdd3433f8b1e8861", "filename": "libgrust/libstd/unit.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funit.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funit.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "9aaccb3ebbac4adc35f5801b5d4bd191e7c94b82", "filename": "libgrust/libstd/unstable/atomics.rs", "status": "removed", "additions": 0, "deletions": 600, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fatomics.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "2a6e40dc3a0df93870ca30f9c6929a9f794f9f7e", "filename": "libgrust/libstd/unstable/dynamic_lib.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "57aff6031bafd7940e4c92344cbd76eb28a918c4", "filename": "libgrust/libstd/unstable/finally.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Ffinally.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "89a51a5ddddd3e4956e72f96638d08ab064626c7", "filename": "libgrust/libstd/unstable/intrinsics.rs", "status": "removed", "additions": 0, "deletions": 488, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fintrinsics.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "06f9ba65ae77331e014ffcf4e1c4bf3feb9abd5f", "filename": "libgrust/libstd/unstable/lang.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Flang.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "63528036ffaecd1f958e3bb29ec8398422e476ad", "filename": "libgrust/libstd/unstable/mod.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fmod.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "ff46824d82359cb2e9ecaaaf31df6ef1837dd9e0", "filename": "libgrust/libstd/unstable/mutex.rs", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fmutex.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "4ad4656af7bf2a418d9ffbd12f803abe95678cf8", "filename": "libgrust/libstd/unstable/raw.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fraw.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "a05f6e8af5a64108f8872d11dc88cc003744936c", "filename": "libgrust/libstd/unstable/simd.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fsimd.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fsimd.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fsimd.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "02b35992f8c40cbeea89e68fbd35a68ec744f1fe", "filename": "libgrust/libstd/unstable/sync.rs", "status": "removed", "additions": 0, "deletions": 639, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Funstable%2Fsync.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "d75c60c0bf2c29d90aefa1a03629a14e35fff6c7", "filename": "libgrust/libstd/util.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Futil.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Futil.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "e76251e8a1e72b79211087535e10c2d7ad6c376c", "filename": "libgrust/libstd/vec.rs", "status": "removed", "additions": 0, "deletions": 4155, "changes": 4155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibstd%2Fvec.rs?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "b00423f23c18de3f75f8f43bad9822c95f33c9c9", "filename": "libgrust/src/lang-hooks.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fsrc%2Flang-hooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fsrc%2Flang-hooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Fsrc%2Flang-hooks.c?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}, {"sha": "1cca88343401bb00b937ad6ee910775fdfd2b33f", "filename": "libgrust/src/rust-main.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fsrc%2Frust-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aeb9f47187f9b7ad55e32bcd273556823f383c6/libgrust%2Fsrc%2Frust-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Fsrc%2Frust-main.c?ref=3aeb9f47187f9b7ad55e32bcd273556823f383c6"}]}