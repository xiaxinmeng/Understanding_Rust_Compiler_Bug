{"sha": "b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyYWVmM2E4Y2JjYzgxN2MxOGM0NzQ4MDZhMjlhZDdmMzQ1M2Y2ZA==", "commit": {"author": {"name": "Thomas Rodgers", "email": "trodgers@redhat.com", "date": "2021-04-20T10:54:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-20T14:14:58Z"}, "message": "libstdc++: Refactor/cleanup of C++20 atomic wait implementation\n\nThis is a substantial rewrite of the atomic wait/notify (and timed wait\ncounterparts) implementation.\n\nThe previous __platform_wait looped on EINTR however this behavior is\nnot required by the standard. A new _GLIBCXX_HAVE_PLATFORM_WAIT macro\nnow controls whether wait/notify are implemented using a platform\nspecific primitive or with a platform agnostic mutex/condvar. This\npatch only supplies a definition for linux futexes. A future update\ncould add support __ulock_wait/wake on Darwin, for instance.\n\nThe members of __waiters were lifted to a new base class. The members\nare now arranged such that overall sizeof(__waiter_pool_base) fits in\ntwo cache lines (on platforms with at least 64 byte cache lines). The\ndefinition will also use destructive_interference_size for this if it is\navailable.\n\nThe __waiters type is now specific to untimed waits, and is renamed to\n__waiter_pool. Timed waits have a corresponding __timed_waiter_pool\ntype.  Much of the code has been moved from the previous __atomic_wait()\nfree function to the __waiter_base template and a __waiter derived type\nis provided to implement the un-timed wait operations. A similar change\nhas been made to the timed wait implementation.\n\nThe __atomic_spin code has been extended to take a spin policy which is\ninvoked after the initial busy wait loop. The default policy is to\nreturn from the spin. The timed wait code adds a timed backoff spinning\npolicy. The code from <thread> which implements this_thread::sleep_for,\nsleep_until has been moved to a new <bits/std_thread_sleep.h> header\nwhich allows the thread sleep code to be consumed without pulling in the\nwhole of <thread>.\n\nThe entry points into the wait/notify code have been restructured to\nsupport either -\n   * Testing the current value of the atomic stored at the given address\n     and waiting on a notification.\n   * Applying a predicate to determine if the wait was satisfied.\nThe entry points were renamed to make it clear that the wait and wake\noperations operate on addresses. The first variant takes the expected\nvalue and a function which returns the current value that should be used\nin comparison operations, these operations are named with a _v suffix\n(e.g. 'value'). All atomic<_Tp> wait/notify operations use the first\nvariant. Barriers, latches and semaphores use the predicate variant.\n\nThis change also centralizes what it means to compare values for the\npurposes of atomic<T>::wait rather than scattering through individual\npredicates.\n\nThis change also centralizes the repetitive code which adjusts for\ndifferent user supplied clocks (this should be moved elsewhere\nand all such adjustments should use a common implementation).\n\nThis change also removes the hashing of the pointer and uses\nthe pointer value directly for indexing into the waiters table.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new <bits/this_thread_sleep.h> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/this_thread_sleep.h: New file.\n\t* include/bits/atomic_base.h: Adjust all calls\n\tto __atomic_wait/__atomic_notify for new call signatures.\n\t* include/bits/atomic_timed_wait.h: Extensive rewrite.\n\t* include/bits/atomic_wait.h: Likewise.\n\t* include/bits/semaphore_base.h: Adjust all calls\n\tto __atomic_wait/__atomic_notify for new call signatures.\n\t* include/std/atomic: Likewise.\n\t* include/std/barrier: Likewise.\n\t* include/std/latch: Likewise.\n\t* include/std/semaphore: Likewise.\n\t* include/std/thread (this_thread::sleep_for)\n\t(this_thread::sleep_until): Move to new header.\n\t* testsuite/29_atomics/atomic/wait_notify/bool.cc: Simplify\n\ttest.\n\t* testsuite/29_atomics/atomic/wait_notify/generic.cc: Likewise.\n\t* testsuite/29_atomics/atomic/wait_notify/pointers.cc: Likewise.\n\t* testsuite/29_atomics/atomic_flag/wait_notify/1.cc: Likewise.\n\t* testsuite/29_atomics/atomic_float/wait_notify.cc: Likewise.\n\t* testsuite/29_atomics/atomic_integral/wait_notify.cc: Likewise.\n\t* testsuite/29_atomics/atomic_ref/wait_notify.cc: Likewise.", "tree": {"sha": "3fcae37f744e25f8f58cea587ee95ae9da7783b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fcae37f744e25f8f58cea587ee95ae9da7783b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/comments", "author": {"login": "rodgert", "id": 120839, "node_id": "MDQ6VXNlcjEyMDgzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/120839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodgert", "html_url": "https://github.com/rodgert", "followers_url": "https://api.github.com/users/rodgert/followers", "following_url": "https://api.github.com/users/rodgert/following{/other_user}", "gists_url": "https://api.github.com/users/rodgert/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodgert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodgert/subscriptions", "organizations_url": "https://api.github.com/users/rodgert/orgs", "repos_url": "https://api.github.com/users/rodgert/repos", "events_url": "https://api.github.com/users/rodgert/events{/privacy}", "received_events_url": "https://api.github.com/users/rodgert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6156df483fa50a08f561b6c248819f2992aa380d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6156df483fa50a08f561b6c248819f2992aa380d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6156df483fa50a08f561b6c248819f2992aa380d"}], "stats": {"total": 1688, "additions": 978, "deletions": 710}, "files": [{"sha": "40a41ef2a1c24c6fc73cb97603e038f07f588282", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -225,6 +225,7 @@ bits_headers = \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\\n+\t${bits_srcdir}/this_thread_sleep.h \\\n \t${bits_srcdir}/uniform_int_dist.h \\\n \t${bits_srcdir}/unique_lock.h \\\n \t${bits_srcdir}/unique_ptr.h \\"}, {"sha": "fcd2b5b2d40cacb24dcd48f43b5a257af33ba9a4", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -575,6 +575,7 @@ bits_headers = \\\n \t${bits_srcdir}/streambuf.tcc \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\\n+\t${bits_srcdir}/this_thread_sleep.h \\\n \t${bits_srcdir}/uniform_int_dist.h \\\n \t${bits_srcdir}/unique_lock.h \\\n \t${bits_srcdir}/unique_ptr.h \\"}, {"sha": "029b8ad65a9f6b4d22eabc28501dc29814f610ab", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -235,22 +235,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     wait(bool __old,\n \tmemory_order __m = memory_order_seq_cst) const noexcept\n     {\n-      std::__atomic_wait(&_M_i, static_cast<__atomic_flag_data_type>(__old),\n-\t\t\t [__m, this, __old]()\n-\t\t\t { return this->test(__m) != __old; });\n+      const __atomic_flag_data_type __v\n+\t= __old ? __GCC_ATOMIC_TEST_AND_SET_TRUEVAL : 0;\n+\n+      std::__atomic_wait_address_v(&_M_i, __v,\n+\t  [__m, this] { return __atomic_load_n(&_M_i, int(__m)); });\n     }\n \n     // TODO add const volatile overload\n \n     _GLIBCXX_ALWAYS_INLINE void\n     notify_one() const noexcept\n-    { std::__atomic_notify(&_M_i, false); }\n+    { std::__atomic_notify_address(&_M_i, false); }\n \n     // TODO add const volatile overload\n \n     _GLIBCXX_ALWAYS_INLINE void\n     notify_all() const noexcept\n-    { std::__atomic_notify(&_M_i, true); }\n+    { std::__atomic_notify_address(&_M_i, true); }\n \n     // TODO add const volatile overload\n #endif // __cpp_lib_atomic_wait\n@@ -609,22 +611,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait(__int_type __old,\n \t  memory_order __m = memory_order_seq_cst) const noexcept\n       {\n-\tstd::__atomic_wait(&_M_i, __old,\n-\t\t\t   [__m, this, __old]\n-\t\t\t   { return this->load(__m) != __old; });\n+\tstd::__atomic_wait_address_v(&_M_i, __old,\n+\t\t\t   [__m, this] { return this->load(__m); });\n       }\n \n       // TODO add const volatile overload\n \n       _GLIBCXX_ALWAYS_INLINE void\n       notify_one() const noexcept\n-      { std::__atomic_notify(&_M_i, false); }\n+      { std::__atomic_notify_address(&_M_i, false); }\n \n       // TODO add const volatile overload\n \n       _GLIBCXX_ALWAYS_INLINE void\n       notify_all() const noexcept\n-      { std::__atomic_notify(&_M_i, true); }\n+      { std::__atomic_notify_address(&_M_i, true); }\n \n       // TODO add const volatile overload\n #endif // __cpp_lib_atomic_wait\n@@ -903,22 +904,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait(__pointer_type __old,\n \t   memory_order __m = memory_order_seq_cst) noexcept\n       {\n-\tstd::__atomic_wait(&_M_p, __old,\n-\t\t      [__m, this, __old]()\n-\t\t      { return this->load(__m) != __old; });\n+\tstd::__atomic_wait_address_v(&_M_p, __old,\n+\t\t\t\t     [__m, this]\n+\t\t\t\t     { return this->load(__m); });\n       }\n \n       // TODO add const volatile overload\n \n       _GLIBCXX_ALWAYS_INLINE void\n       notify_one() const noexcept\n-      { std::__atomic_notify(&_M_p, false); }\n+      { std::__atomic_notify_address(&_M_p, false); }\n \n       // TODO add const volatile overload\n \n       _GLIBCXX_ALWAYS_INLINE void\n       notify_all() const noexcept\n-      { std::__atomic_notify(&_M_p, true); }\n+      { std::__atomic_notify_address(&_M_p, true); }\n \n       // TODO add const volatile overload\n #endif // __cpp_lib_atomic_wait\n@@ -1017,23 +1018,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       wait(const _Tp* __ptr, _Val<_Tp> __old,\n \t   memory_order __m = memory_order_seq_cst) noexcept\n       {\n-\tstd::__atomic_wait(__ptr, __old,\n-\t    [=]() { return load(__ptr, __m) == __old; });\n+\tstd::__atomic_wait_address_v(__ptr, __old,\n+\t    [__ptr, __m]() { return __atomic_impl::load(__ptr, __m); });\n       }\n \n       // TODO add const volatile overload\n \n     template<typename _Tp>\n       _GLIBCXX_ALWAYS_INLINE void\n       notify_one(const _Tp* __ptr) noexcept\n-      { std::__atomic_notify(__ptr, false); }\n+      { std::__atomic_notify_address(__ptr, false); }\n \n       // TODO add const volatile overload\n \n     template<typename _Tp>\n       _GLIBCXX_ALWAYS_INLINE void\n       notify_all(const _Tp* __ptr) noexcept\n-      { std::__atomic_notify(__ptr, true); }\n+      { std::__atomic_notify_address(__ptr, true); }\n \n       // TODO add const volatile overload\n #endif // __cpp_lib_atomic_wait"}, {"sha": "70e5335cfd7485c3a3bce428e74bda97097e77b3", "filename": "libstdc++-v3/include/bits/atomic_timed_wait.h", "status": "modified", "additions": 306, "deletions": 159, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -36,6 +36,7 @@\n \n #if __cpp_lib_atomic_wait\n #include <bits/functional_hash.h>\n+#include <bits/this_thread_sleep.h>\n \n #include <chrono>\n \n@@ -48,19 +49,38 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  enum class __atomic_wait_status { no_timeout, timeout };\n-\n   namespace __detail\n   {\n+    using __wait_clock_t = chrono::steady_clock;\n+\n+    template<typename _Clock, typename _Dur>\n+      __wait_clock_t::time_point\n+      __to_wait_clock(const chrono::time_point<_Clock, _Dur>& __atime) noexcept\n+      {\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __wait_clock_t::time_point __w_entry = __wait_clock_t::now();\n+\tconst auto __delta = __atime - __c_entry;\n+\tusing __w_dur = typename __wait_clock_t::duration;\n+\treturn __w_entry + chrono::ceil<__w_dur>(__delta);\n+      }\n+\n+    template<typename _Dur>\n+      __wait_clock_t::time_point\n+      __to_wait_clock(const chrono::time_point<__wait_clock_t,\n+\t\t\t\t\t       _Dur>& __atime) noexcept\n+      {\n+\tusing __w_dur = typename __wait_clock_t::duration;\n+\treturn chrono::ceil<__w_dur>(__atime);\n+      }\n+\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-    using __platform_wait_clock_t = chrono::steady_clock;\n-\n-    template<typename _Duration>\n-      __atomic_wait_status\n-      __platform_wait_until_impl(__platform_wait_t* __addr,\n-\t\t\t\t __platform_wait_t __val,\n-\t\t\t\t const chrono::time_point<\n-\t\t\t\t\t  __platform_wait_clock_t, _Duration>&\n+#define _GLIBCXX_HAVE_PLATFORM_TIMED_WAIT\n+    // returns true if wait ended before timeout\n+    template<typename _Dur>\n+      bool\n+      __platform_wait_until_impl(const __platform_wait_t* __addr,\n+\t\t\t\t __platform_wait_t __old,\n+\t\t\t\t const chrono::time_point<__wait_clock_t, _Dur>&\n \t\t\t\t      __atime) noexcept\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n@@ -75,52 +95,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tauto __e = syscall (SYS_futex, __addr,\n \t\t\t    static_cast<int>(__futex_wait_flags::\n \t\t\t\t\t\t__wait_bitset_private),\n-\t\t\t    __val, &__rt, nullptr,\n+\t\t\t    __old, &__rt, nullptr,\n \t\t\t    static_cast<int>(__futex_wait_flags::\n \t\t\t\t\t\t__bitset_match_any));\n-\tif (__e && !(errno == EINTR || errno == EAGAIN || errno == ETIMEDOUT))\n-\t    std::terminate();\n-\treturn (__platform_wait_clock_t::now() < __atime)\n-\t       ? __atomic_wait_status::no_timeout\n-\t       : __atomic_wait_status::timeout;\n+\n+\tif (__e)\n+\t  {\n+\t    if ((errno != ETIMEDOUT) && (errno != EINTR)\n+\t\t&& (errno != EAGAIN))\n+\t      __throw_system_error(errno);\n+\t    return true;\n+\t  }\n+\treturn false;\n       }\n \n-    template<typename _Clock, typename _Duration>\n-      __atomic_wait_status\n-      __platform_wait_until(__platform_wait_t* __addr, __platform_wait_t __val,\n-\t\t\t    const chrono::time_point<_Clock, _Duration>&\n-\t\t\t\t__atime)\n+    // returns true if wait ended before timeout\n+    template<typename _Clock, typename _Dur>\n+      bool\n+      __platform_wait_until(const __platform_wait_t* __addr, __platform_wait_t __old,\n+\t\t\t    const chrono::time_point<_Clock, _Dur>& __atime)\n       {\n-\tif constexpr (is_same_v<__platform_wait_clock_t, _Clock>)\n+\tif constexpr (is_same_v<__wait_clock_t, _Clock>)\n \t  {\n-\t    return __detail::__platform_wait_until_impl(__addr, __val, __atime);\n+\t    return __platform_wait_until_impl(__addr, __old, __atime);\n \t  }\n \telse\n \t  {\n-\t    const typename _Clock::time_point __c_entry = _Clock::now();\n-\t    const __platform_wait_clock_t::time_point __s_entry =\n-\t\t    __platform_wait_clock_t::now();\n-\t    const auto __delta = __atime - __c_entry;\n-\t    const auto __s_atime = __s_entry + __delta;\n-\t    if (__detail::__platform_wait_until_impl(__addr, __val, __s_atime)\n-\t\t  == __atomic_wait_status::no_timeout)\n-\t      return __atomic_wait_status::no_timeout;\n-\n-\t    // We got a timeout when measured against __clock_t but\n-\t    // we need to check against the caller-supplied clock\n-\t    // to tell whether we should return a timeout.\n-\t    if (_Clock::now() < __atime)\n-\t      return __atomic_wait_status::no_timeout;\n-\t    return __atomic_wait_status::timeout;\n+\t    if (!__platform_wait_until_impl(__addr, __old,\n+\t\t\t\t\t    __to_wait_clock(__atime)))\n+\t      {\n+\t\t// We got a timeout when measured against __clock_t but\n+\t\t// we need to check against the caller-supplied clock\n+\t\t// to tell whether we should return a timeout.\n+\t\tif (_Clock::now() < __atime)\n+\t\t  return true;\n+\t      }\n+\t    return false;\n \t  }\n       }\n-#else // ! FUTEX\n-\n-#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n-    template<typename _Duration>\n-      __atomic_wait_status\n+#else\n+// define _GLIBCXX_HAVE_PLATFORM_TIMED_WAIT and implement __platform_wait_until()\n+// if there is a more efficient primitive supported by the platform\n+// (e.g. __ulock_wait())which is better than pthread_cond_clockwait\n+#endif // ! PLATFORM_TIMED_WAIT\n+\n+    // returns true if wait ended before timeout\n+    template<typename _Dur>\n+      bool\n       __cond_wait_until_impl(__condvar& __cv, mutex& __mx,\n-\t  const chrono::time_point<chrono::steady_clock, _Duration>& __atime)\n+\t  const chrono::time_point<chrono::steady_clock, _Dur>& __atime)\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n \tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n@@ -131,45 +154,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n \t__cv.wait_until(__mx, CLOCK_MONOTONIC, __ts);\n-\n-\treturn (chrono::steady_clock::now() < __atime)\n-\t       ? __atomic_wait_status::no_timeout\n-\t       : __atomic_wait_status::timeout;\n-      }\n-#endif\n-\n-    template<typename _Duration>\n-      __atomic_wait_status\n-      __cond_wait_until_impl(__condvar& __cv, mutex& __mx,\n-\t  const chrono::time_point<chrono::system_clock, _Duration>& __atime)\n-      {\n-\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n-\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t__gthread_time_t __ts =\n-\t{\n-\t  static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t  static_cast<long>(__ns.count())\n-\t};\n-\n+\treturn chrono::steady_clock::now() < __atime;\n+#else\n \t__cv.wait_until(__mx, __ts);\n-\n-\treturn (chrono::system_clock::now() < __atime)\n-\t       ? __atomic_wait_status::no_timeout\n-\t       : __atomic_wait_status::timeout;\n+\treturn chrono::system_clock::now() < __atime;\n+#endif // ! _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n       }\n \n-    // return true if timeout\n-    template<typename _Clock, typename _Duration>\n-      __atomic_wait_status\n+    // returns true if wait ended before timeout\n+    template<typename _Clock, typename _Dur>\n+      bool\n       __cond_wait_until(__condvar& __cv, mutex& __mx,\n-\t  const chrono::time_point<_Clock, _Duration>& __atime)\n+\t  const chrono::time_point<_Clock, _Dur>& __atime)\n       {\n-#ifndef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n-\tusing __clock_t = chrono::system_clock;\n-#else\n-\tusing __clock_t = chrono::steady_clock;\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n \tif constexpr (is_same_v<_Clock, chrono::steady_clock>)\n \t  return __detail::__cond_wait_until_impl(__cv, __mx, __atime);\n \telse\n@@ -178,118 +178,265 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return __detail::__cond_wait_until_impl(__cv, __mx, __atime);\n \telse\n \t  {\n-\t    const typename _Clock::time_point __c_entry = _Clock::now();\n-\t    const __clock_t::time_point __s_entry = __clock_t::now();\n-\t    const auto __delta = __atime - __c_entry;\n-\t    const auto __s_atime = __s_entry + __delta;\n-\t    if (__detail::__cond_wait_until_impl(__cv, __mx, __s_atime)\n-\t\t== __atomic_wait_status::no_timeout)\n-\t      return __atomic_wait_status::no_timeout;\n-\t    // We got a timeout when measured against __clock_t but\n-\t    // we need to check against the caller-supplied clock\n-\t    // to tell whether we should return a timeout.\n-\t    if (_Clock::now() < __atime)\n-\t      return __atomic_wait_status::no_timeout;\n-\t    return __atomic_wait_status::timeout;\n+\t    if (__cond_wait_until_impl(__cv, __mx,\n+\t\t\t\t       __to_wait_clock(__atime)))\n+\t      {\n+\t\t// We got a timeout when measured against __clock_t but\n+\t\t// we need to check against the caller-supplied clock\n+\t\t// to tell whether we should return a timeout.\n+\t\tif (_Clock::now() < __atime)\n+\t\t  return true;\n+\t      }\n+\t    return false;\n \t  }\n       }\n-#endif // FUTEX\n \n-    struct __timed_waiters : __waiters\n+    struct __timed_waiter_pool : __waiter_pool_base\n     {\n-      template<typename _Clock, typename _Duration>\n-\t__atomic_wait_status\n-\t_M_do_wait_until(__platform_wait_t __version,\n-\t\t\t const chrono::time_point<_Clock, _Duration>& __atime)\n+      // returns true if wait ended before timeout\n+      template<typename _Clock, typename _Dur>\n+\tbool\n+\t_M_do_wait_until(__platform_wait_t* __addr, __platform_wait_t __old,\n+\t\t\t const chrono::time_point<_Clock, _Dur>& __atime)\n \t{\n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-\t  return __detail::__platform_wait_until(&_M_ver, __version, __atime);\n+#ifdef _GLIBCXX_HAVE_PLATFORM_TIMED_WAIT\n+\t  return __platform_wait_until(__addr, __old, __atime);\n #else\n-\t  __platform_wait_t __cur = 0;\n-\t  __waiters::__lock_t __l(_M_mtx);\n-\t  while (__cur <= __version)\n+\t  __platform_wait_t __val;\n+\t  __atomic_load(__addr, &__val, __ATOMIC_RELAXED);\n+\t  if (__val == __old)\n \t    {\n-\t      if (__detail::__cond_wait_until(_M_cv, _M_mtx, __atime)\n-\t\t    == __atomic_wait_status::timeout)\n-\t\treturn __atomic_wait_status::timeout;\n-\n-\t      __platform_wait_t __last = __cur;\n-\t      __atomic_load(&_M_ver, &__cur, __ATOMIC_ACQUIRE);\n-\t      if (__cur < __last)\n-\t\tbreak; // break the loop if version overflows\n+\t      lock_guard<mutex> __l(_M_mtx);\n+\t      return __cond_wait_until(_M_cv, _M_mtx, __atime);\n \t    }\n-\t  return __atomic_wait_status::no_timeout;\n-#endif\n+#endif // _GLIBCXX_HAVE_PLATFORM_TIMED_WAIT\n \t}\n+    };\n \n-      static __timed_waiters&\n-      _S_timed_for(void* __t)\n+    struct __timed_backoff_spin_policy\n+    {\n+      __wait_clock_t::time_point _M_deadline;\n+      __wait_clock_t::time_point _M_t0;\n+\n+      template<typename _Clock, typename _Dur>\n+\t__timed_backoff_spin_policy(chrono::time_point<_Clock, _Dur>\n+\t\t\t\t      __deadline = _Clock::time_point::max(),\n+\t\t\t\t    chrono::time_point<_Clock, _Dur>\n+\t\t\t\t      __t0 = _Clock::now()) noexcept\n+\t  : _M_deadline(__to_wait_clock(__deadline))\n+\t  , _M_t0(__to_wait_clock(__t0))\n+\t{ }\n+\n+      bool\n+      operator()() const noexcept\n       {\n-\tstatic_assert(sizeof(__timed_waiters) == sizeof(__waiters));\n-\treturn static_cast<__timed_waiters&>(__waiters::_S_for(__t));\n+\tusing namespace literals::chrono_literals;\n+\tauto __now = __wait_clock_t::now();\n+\tif (_M_deadline <= __now)\n+\t  return false;\n+\n+\tauto __elapsed = __now - _M_t0;\n+\tif (__elapsed > 128ms)\n+\t  {\n+\t    this_thread::sleep_for(64ms);\n+\t  }\n+\telse if (__elapsed > 64us)\n+\t  {\n+\t    this_thread::sleep_for(__elapsed / 2);\n+\t  }\n+\telse if (__elapsed > 4us)\n+\t  {\n+\t    __thread_yield();\n+\t  }\n+\telse\n+\t  return false;\n+\treturn true;\n       }\n     };\n+\n+    template<typename _EntersWait>\n+      struct __timed_waiter : __waiter_base<__timed_waiter_pool>\n+      {\n+\tusing __base_type = __waiter_base<__timed_waiter_pool>;\n+\n+\ttemplate<typename _Tp>\n+\t  __timed_waiter(const _Tp* __addr) noexcept\n+\t  : __base_type(__addr)\n+\t{\n+\t  if constexpr (_EntersWait::value)\n+\t    _M_w._M_enter_wait();\n+\t}\n+\n+\t~__timed_waiter()\n+\t{\n+\t  if constexpr (_EntersWait::value)\n+\t    _M_w._M_leave_wait();\n+\t}\n+\n+\t// returns true if wait ended before timeout\n+\ttemplate<typename _Tp, typename _ValFn,\n+\t\t typename _Clock, typename _Dur>\n+\t  bool\n+\t  _M_do_wait_until_v(_Tp __old, _ValFn __vfn,\n+\t\t\t     const chrono::time_point<_Clock, _Dur>&\n+\t\t\t\t\t\t\t\t__atime) noexcept\n+\t  {\n+\t    __platform_wait_t __val;\n+\t    if (_M_do_spin(__old, std::move(__vfn), __val,\n+\t\t\t   __timed_backoff_spin_policy(__atime)))\n+\t      return true;\n+\t    return __base_type::_M_w._M_do_wait_until(__base_type::_M_addr, __val, __atime);\n+\t  }\n+\n+\t// returns true if wait ended before timeout\n+\ttemplate<typename _Pred,\n+\t\t typename _Clock, typename _Dur>\n+\t  bool\n+\t  _M_do_wait_until(_Pred __pred, __platform_wait_t __val,\n+\t\t\t  const chrono::time_point<_Clock, _Dur>&\n+\t\t\t\t\t\t\t      __atime) noexcept\n+\t  {\n+\t    for (auto __now = _Clock::now(); __now < __atime;\n+\t\t  __now = _Clock::now())\n+\t      {\n+\t\tif (__base_type::_M_w._M_do_wait_until(\n+\t\t      __base_type::_M_addr, __val, __atime)\n+\t\t    && __pred())\n+\t\t  return true;\n+\n+\t\tif (__base_type::_M_do_spin(__pred, __val,\n+\t\t\t       __timed_backoff_spin_policy(__atime, __now)))\n+\t\t  return true;\n+\t      }\n+\t    return false;\n+\t  }\n+\n+\t// returns true if wait ended before timeout\n+\ttemplate<typename _Pred,\n+\t\t typename _Clock, typename _Dur>\n+\t  bool\n+\t  _M_do_wait_until(_Pred __pred,\n+\t\t\t   const chrono::time_point<_Clock, _Dur>&\n+\t\t\t\t\t\t\t\t__atime) noexcept\n+\t  {\n+\t    __platform_wait_t __val;\n+\t    if (__base_type::_M_do_spin(__pred, __val,\n+\t\t\t\t\t__timed_backoff_spin_policy(__atime)))\n+\t      return true;\n+\t    return _M_do_wait_until(__pred, __val, __atime);\n+\t  }\n+\n+\ttemplate<typename _Tp, typename _ValFn,\n+\t\t typename _Rep, typename _Period>\n+\t  bool\n+\t  _M_do_wait_for_v(_Tp __old, _ValFn __vfn,\n+\t\t\t   const chrono::duration<_Rep, _Period>&\n+\t\t\t\t\t\t\t\t__rtime) noexcept\n+\t  {\n+\t    __platform_wait_t __val;\n+\t    if (_M_do_spin_v(__old, std::move(__vfn), __val))\n+\t      return true;\n+\n+\t    if (!__rtime.count())\n+\t      return false; // no rtime supplied, and spin did not acquire\n+\n+\t    auto __reltime = chrono::ceil<__wait_clock_t::duration>(__rtime);\n+\n+\t    return __base_type::_M_w._M_do_wait_until(\n+\t\t\t\t\t  __base_type::_M_addr,\n+\t\t\t\t\t  __val,\n+\t\t\t\t\t  chrono::steady_clock::now() + __reltime);\n+\t  }\n+\n+\ttemplate<typename _Pred,\n+\t\t typename _Rep, typename _Period>\n+\t  bool\n+\t  _M_do_wait_for(_Pred __pred,\n+\t\t\t const chrono::duration<_Rep, _Period>& __rtime) noexcept\n+\t  {\n+\t    __platform_wait_t __val;\n+\t    if (__base_type::_M_do_spin(__pred, __val))\n+\t      return true;\n+\n+\t    if (!__rtime.count())\n+\t      return false; // no rtime supplied, and spin did not acquire\n+\n+\t    auto __reltime = chrono::ceil<__wait_clock_t::duration>(__rtime);\n+\n+\t    return _M_do_wait_until(__pred, __val,\n+\t\t\t\t    chrono::steady_clock::now() + __reltime);\n+\t  }\n+      };\n+\n+    using __enters_timed_wait = __timed_waiter<std::true_type>;\n+    using __bare_timed_wait = __timed_waiter<std::false_type>;\n   } // namespace __detail\n \n-  template<typename _Tp, typename _Pred,\n-\t   typename _Clock, typename _Duration>\n+  // returns true if wait ended before timeout\n+  template<typename _Tp, typename _ValFn,\n+\t   typename _Clock, typename _Dur>\n     bool\n-    __atomic_wait_until(const _Tp* __addr, _Tp __old, _Pred __pred,\n-\t\t\tconst chrono::time_point<_Clock, _Duration>&\n+    __atomic_wait_address_until_v(const _Tp* __addr, _Tp&& __old, _ValFn&& __vfn,\n+\t\t\tconst chrono::time_point<_Clock, _Dur>&\n \t\t\t    __atime) noexcept\n     {\n-      using namespace __detail;\n+      __detail::__enters_timed_wait __w{__addr};\n+      return __w._M_do_wait_until_v(__old, __vfn, __atime);\n+    }\n \n-      if (std::__atomic_spin(__pred))\n-\treturn true;\n+  template<typename _Tp, typename _Pred,\n+\t   typename _Clock, typename _Dur>\n+    bool\n+    __atomic_wait_address_until(const _Tp* __addr, _Pred __pred,\n+\t\t\t\tconst chrono::time_point<_Clock, _Dur>&\n+\t\t\t\t\t\t\t      __atime) noexcept\n+    {\n+      __detail::__enters_timed_wait __w{__addr};\n+      return __w._M_do_wait_until(__pred, __atime);\n+    }\n \n-      auto& __w = __timed_waiters::_S_timed_for((void*)__addr);\n-      auto __version = __w._M_enter_wait();\n-      do\n-\t{\n-\t  __atomic_wait_status __res;\n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-\t  if constexpr (__platform_wait_uses_type<_Tp>)\n-\t    {\n-\t      __res = __detail::__platform_wait_until((__platform_wait_t*)(void*) __addr,\n-\t\t\t\t\t\t      __old, __atime);\n-\t    }\n-\t  else\n-#endif\n-\t    {\n-\t      __res = __w._M_do_wait_until(__version, __atime);\n-\t    }\n-\t  if (__res == __atomic_wait_status::timeout)\n-\t    return false;\n-\t}\n-      while (!__pred() && __atime < _Clock::now());\n-      __w._M_leave_wait();\n+  template<typename _Pred,\n+\t   typename _Clock, typename _Dur>\n+    bool\n+    __atomic_wait_address_until_bare(const __detail::__platform_wait_t* __addr,\n+\t\t\t\t_Pred __pred,\n+\t\t\t\tconst chrono::time_point<_Clock, _Dur>&\n+\t\t\t\t\t\t\t      __atime) noexcept\n+    {\n+      __detail::__bare_timed_wait __w{__addr};\n+      return __w._M_do_wait_until(__pred, __atime);\n+    }\n \n-      // if timed out, return false\n-      return (_Clock::now() < __atime);\n+  template<typename _Tp, typename _ValFn,\n+\t   typename _Rep, typename _Period>\n+    bool\n+    __atomic_wait_address_for_v(const _Tp* __addr, _Tp&& __old, _ValFn&& __vfn,\n+\t\t      const chrono::duration<_Rep, _Period>& __rtime) noexcept\n+    {\n+      __detail::__enters_timed_wait __w{__addr};\n+      return __w._M_do_wait_for_v(__old, __vfn, __rtime);\n     }\n \n   template<typename _Tp, typename _Pred,\n \t   typename _Rep, typename _Period>\n     bool\n-    __atomic_wait_for(const _Tp* __addr, _Tp __old, _Pred __pred,\n+    __atomic_wait_address_for(const _Tp* __addr, _Pred __pred,\n \t\t      const chrono::duration<_Rep, _Period>& __rtime) noexcept\n     {\n-      using namespace __detail;\n \n-      if (std::__atomic_spin(__pred))\n-\treturn true;\n-\n-      if (!__rtime.count())\n-\treturn false; // no rtime supplied, and spin did not acquire\n-\n-      using __dur = chrono::steady_clock::duration;\n-      auto __reltime = chrono::duration_cast<__dur>(__rtime);\n-      if (__reltime < __rtime)\n-\t++__reltime;\n+      __detail::__enters_timed_wait __w{__addr};\n+      return __w._M_do_wait_for(__pred, __rtime);\n+    }\n \n-      return __atomic_wait_until(__addr, __old, std::move(__pred),\n-\t\t\t\t chrono::steady_clock::now() + __reltime);\n+  template<typename _Pred,\n+\t   typename _Rep, typename _Period>\n+    bool\n+    __atomic_wait_address_for_bare(const __detail::__platform_wait_t* __addr,\n+\t\t\t_Pred __pred,\n+\t\t\tconst chrono::duration<_Rep, _Period>& __rtime) noexcept\n+    {\n+      __detail::__bare_timed_wait __w{__addr};\n+      return __w._M_do_wait_for(__pred, __rtime);\n     }\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "0ac5575190c6a1c83dc07582746d898aa923d552", "filename": "libstdc++-v3/include/bits/atomic_wait.h", "status": "modified", "additions": 316, "deletions": 141, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -44,33 +44,41 @@\n # include <unistd.h>\n # include <syscall.h>\n # include <bits/functexcept.h>\n-// TODO get this from Autoconf\n-# define _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE 1\n-#else\n-# include <bits/std_mutex.h>  // std::mutex, std::__condvar\n #endif\n \n+# include <bits/std_mutex.h>  // std::mutex, std::__condvar\n+\n #define __cpp_lib_atomic_wait 201907L\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   namespace __detail\n   {\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n     using __platform_wait_t = int;\n+    static constexpr size_t __platform_wait_alignment = 4;\n+#else\n+    using __platform_wait_t = uint64_t;\n+    static constexpr size_t __platform_wait_alignment\n+      = __alignof__(__platform_wait_t);\n+#endif\n+  } // namespace __detail\n \n-    constexpr auto __atomic_spin_count_1 = 16;\n-    constexpr auto __atomic_spin_count_2 = 12;\n-\n-    template<typename _Tp>\n-      inline constexpr bool __platform_wait_uses_type\n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-\t= is_same_v<remove_cv_t<_Tp>, __platform_wait_t>;\n+  template<typename _Tp>\n+    inline constexpr bool __platform_wait_uses_type\n+#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT\n+      = is_scalar_v<_Tp>\n+\t&& ((sizeof(_Tp) == sizeof(__detail::__platform_wait_t))\n+\t&& (alignof(_Tp*) >= __platform_wait_alignment));\n #else\n-\t= false;\n+      = false;\n #endif\n \n+  namespace __detail\n+  {\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+#define _GLIBCXX_HAVE_PLATFORM_WAIT 1\n     enum class __futex_wait_flags : int\n     {\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE\n@@ -93,89 +101,138 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       __platform_wait(const _Tp* __addr, __platform_wait_t __val) noexcept\n       {\n-\tfor(;;)\n-\t  {\n-\t    auto __e = syscall (SYS_futex, static_cast<const void*>(__addr),\n-\t\t\t\t  static_cast<int>(__futex_wait_flags::__wait_private),\n-\t\t\t\t    __val, nullptr);\n-\t    if (!__e || errno == EAGAIN)\n-\t      break;\n-\t    else if (errno != EINTR)\n-\t      __throw_system_error(__e);\n-\t  }\n+\tauto __e = syscall (SYS_futex, static_cast<const void*>(__addr),\n+\t\t\t    static_cast<int>(__futex_wait_flags::__wait_private),\n+\t\t\t    __val, nullptr);\n+\tif (!__e || errno == EAGAIN)\n+\t  return;\n+\tif (errno != EINTR)\n+\t  __throw_system_error(errno);\n       }\n \n     template<typename _Tp>\n       void\n       __platform_notify(const _Tp* __addr, bool __all) noexcept\n       {\n \tsyscall (SYS_futex, static_cast<const void*>(__addr),\n-\t\t  static_cast<int>(__futex_wait_flags::__wake_private),\n-\t\t    __all ? INT_MAX : 1);\n+\t\t static_cast<int>(__futex_wait_flags::__wake_private),\n+\t\t __all ? INT_MAX : 1);\n       }\n+#else\n+// define _GLIBCX_HAVE_PLATFORM_WAIT and implement __platform_wait()\n+// and __platform_notify() if there is a more efficient primitive supported\n+// by the platform (e.g. __ulock_wait()/__ulock_wake()) which is better than\n+// a mutex/condvar based wait\n #endif\n \n-    struct __waiters\n+    inline void\n+    __thread_yield() noexcept\n     {\n-      alignas(64) __platform_wait_t _M_ver = 0;\n-      alignas(64) __platform_wait_t _M_wait = 0;\n-\n-#ifndef _GLIBCXX_HAVE_LINUX_FUTEX\n-      using __lock_t = lock_guard<mutex>;\n-      mutex _M_mtx;\n-      __condvar _M_cv;\n+#if defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD\n+     __gthread_yield();\n+#endif\n+    }\n \n-      __waiters() noexcept = default;\n+    inline void\n+    __thread_relax() noexcept\n+    {\n+#if defined __i386__ || defined __x86_64__\n+      __builtin_ia32_pause();\n+#else\n+      __thread_yield();\n #endif\n+    }\n \n-      __platform_wait_t\n-      _M_enter_wait() noexcept\n+    constexpr auto __atomic_spin_count_1 = 12;\n+    constexpr auto __atomic_spin_count_2 = 4;\n+\n+    struct __default_spin_policy\n+    {\n+      bool\n+      operator()() const noexcept\n+      { return false; }\n+    };\n+\n+    template<typename _Pred,\n+\t     typename _Spin = __default_spin_policy>\n+      bool\n+      __atomic_spin(_Pred& __pred, _Spin __spin = _Spin{ }) noexcept\n       {\n-\t__platform_wait_t __res;\n-\t__atomic_load(&_M_ver, &__res, __ATOMIC_ACQUIRE);\n-\t__atomic_fetch_add(&_M_wait, 1, __ATOMIC_ACQ_REL);\n-\treturn __res;\n+\tfor (auto __i = 0; __i < __atomic_spin_count_1; ++__i)\n+\t  {\n+\t    if (__pred())\n+\t      return true;\n+\t    __detail::__thread_relax();\n+\t  }\n+\n+\tfor (auto __i = 0; __i < __atomic_spin_count_2; ++__i)\n+\t  {\n+\t    if (__pred())\n+\t      return true;\n+\t    __detail::__thread_yield();\n+\t  }\n+\n+\twhile (__spin())\n+\t  {\n+\t    if (__pred())\n+\t      return true;\n+\t  }\n+\n+\treturn false;\n       }\n \n-      void\n-      _M_leave_wait() noexcept\n+    template<typename _Tp>\n+      bool __atomic_compare(const _Tp& __a, const _Tp& __b)\n       {\n-\t__atomic_fetch_sub(&_M_wait, 1, __ATOMIC_ACQ_REL);\n+\t// TODO make this do the correct padding bit ignoring comparison\n+\treturn __builtin_memcmp(&__a, &__b, sizeof(_Tp)) != 0;\n       }\n \n-      void\n-      _M_do_wait(__platform_wait_t __version) noexcept\n-      {\n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-\t__platform_wait(&_M_ver, __version);\n+    struct __waiter_pool_base\n+    {\n+#ifdef __cpp_lib_hardware_interference_size\n+    static constexpr auto _S_align = hardware_destructive_interference_size;\n #else\n-\t__platform_wait_t __cur = 0;\n-\twhile (__cur <= __version)\n-\t  {\n-\t    __waiters::__lock_t __l(_M_mtx);\n-\t    _M_cv.wait(_M_mtx);\n-\t    __platform_wait_t __last = __cur;\n-\t    __atomic_load(&_M_ver, &__cur, __ATOMIC_ACQUIRE);\n-\t    if (__cur < __last)\n-\t      break; // break the loop if version overflows\n-\t  }\n+    static constexpr auto _S_align = 64;\n #endif\n-      }\n+\n+      alignas(_S_align) __platform_wait_t _M_wait = 0;\n+\n+#ifndef _GLIBCXX_HAVE_PLATFORM_WAIT\n+      mutex _M_mtx;\n+#endif\n+\n+      alignas(_S_align) __platform_wait_t _M_ver = 0;\n+\n+#ifndef _GLIBCXX_HAVE_PLATFORM_WAIT\n+      __condvar _M_cv;\n+#endif\n+      __waiter_pool_base() = default;\n+\n+      void\n+      _M_enter_wait() noexcept\n+      { __atomic_fetch_add(&_M_wait, 1, __ATOMIC_ACQ_REL); }\n+\n+      void\n+      _M_leave_wait() noexcept\n+      { __atomic_fetch_sub(&_M_wait, 1, __ATOMIC_ACQ_REL); }\n \n       bool\n       _M_waiting() const noexcept\n       {\n \t__platform_wait_t __res;\n \t__atomic_load(&_M_wait, &__res, __ATOMIC_ACQUIRE);\n-\treturn __res;\n+\treturn __res > 0;\n       }\n \n       void\n-      _M_notify(bool __all) noexcept\n+      _M_notify(const __platform_wait_t* __addr, bool __all) noexcept\n       {\n-\t__atomic_fetch_add(&_M_ver, 1, __ATOMIC_ACQ_REL);\n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-\t__platform_notify(&_M_ver, __all);\n+\tif (!_M_waiting())\n+\t  return;\n+\n+#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT\n+\t__platform_notify(__addr, __all);\n #else\n \tif (__all)\n \t  _M_cv.notify_all();\n@@ -184,114 +241,232 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n       }\n \n-      static __waiters&\n-      _S_for(const void* __t)\n+      static __waiter_pool_base&\n+      _S_for(const void* __addr) noexcept\n       {\n-\tconst unsigned char __mask = 0xf;\n-\tstatic __waiters __w[__mask + 1];\n-\n-\tauto __key = _Hash_impl::hash(__t) & __mask;\n+\tconstexpr uintptr_t __ct = 16;\n+\tstatic __waiter_pool_base __w[__ct];\n+\tauto __key = (uintptr_t(__addr) >> 2) % __ct;\n \treturn __w[__key];\n       }\n     };\n \n-    struct __waiter\n+    struct __waiter_pool : __waiter_pool_base\n     {\n-      __waiters& _M_w;\n-      __platform_wait_t _M_version;\n+      void\n+      _M_do_wait(const __platform_wait_t* __addr, __platform_wait_t __old) noexcept\n+      {\n+#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT\n+\t__platform_wait(__addr, __old);\n+#else\n+\t__platform_wait_t __val;\n+\t__atomic_load(__addr, &__val, __ATOMIC_RELAXED);\n+\tif (__val == __old)\n+\t  {\n+\t    lock_guard<mutex> __l(_M_mtx);\n+\t    _M_cv.wait(_M_mtx);\n+\t  }\n+#endif // __GLIBCXX_HAVE_PLATFORM_WAIT\n+      }\n+    };\n \n-      template<typename _Tp>\n-\t__waiter(const _Tp* __addr) noexcept\n-\t  : _M_w(__waiters::_S_for(static_cast<const void*>(__addr)))\n-\t  , _M_version(_M_w._M_enter_wait())\n-\t{ }\n+    template<typename _Tp>\n+      struct __waiter_base\n+      {\n+\tusing __waiter_type = _Tp;\n \n-      ~__waiter()\n-      { _M_w._M_leave_wait(); }\n+\t__waiter_type& _M_w;\n+\t__platform_wait_t* _M_addr;\n \n-      void _M_do_wait() noexcept\n-      { _M_w._M_do_wait(_M_version); }\n-    };\n+\ttemplate<typename _Up>\n+\t  static __platform_wait_t*\n+\t  _S_wait_addr(const _Up* __a, __platform_wait_t* __b)\n+\t  {\n+\t    if constexpr (__platform_wait_uses_type<_Up>)\n+\t      return reinterpret_cast<__platform_wait_t*>(const_cast<_Up*>(__a));\n+\t    else\n+\t      return __b;\n+\t  }\n \n-    inline void\n-    __thread_yield() noexcept\n-    {\n-#if defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD\n-      __gthread_yield();\n-#endif\n-    }\n+\tstatic __waiter_type&\n+\t_S_for(const void* __addr) noexcept\n+\t{\n+\t  static_assert(sizeof(__waiter_type) == sizeof(__waiter_pool_base));\n+\t  auto& res = __waiter_pool_base::_S_for(__addr);\n+\t  return reinterpret_cast<__waiter_type&>(res);\n+\t}\n \n-    inline void\n-    __thread_relax() noexcept\n-    {\n-#if defined __i386__ || defined __x86_64__\n-      __builtin_ia32_pause();\n-#else\n-      __thread_yield();\n-#endif\n-    }\n-  } // namespace __detail\n+\ttemplate<typename _Up>\n+\t  explicit __waiter_base(const _Up* __addr) noexcept\n+\t    : _M_w(_S_for(__addr))\n+\t    , _M_addr(_S_wait_addr(__addr, &_M_w._M_ver))\n+\t  {\n+\t  }\n \n-  template<typename _Pred>\n-    bool\n-    __atomic_spin(_Pred& __pred) noexcept\n-    {\n-      for (auto __i = 0; __i < __detail::__atomic_spin_count_1; ++__i)\n+\tvoid\n+\t_M_notify(bool __all)\n \t{\n-\t  if (__pred())\n-\t    return true;\n+\t  if (_M_addr == &_M_w._M_ver)\n+\t    __atomic_fetch_add(_M_addr, 1, __ATOMIC_ACQ_REL);\n+\t  _M_w._M_notify(_M_addr, __all);\n+\t}\n \n-\t  if (__i < __detail::__atomic_spin_count_2)\n-\t    __detail::__thread_relax();\n-\t  else\n-\t    __detail::__thread_yield();\n+\ttemplate<typename _Up, typename _ValFn,\n+\t\t typename _Spin = __default_spin_policy>\n+\t  static bool\n+\t  _S_do_spin_v(__platform_wait_t* __addr,\n+\t\t       const _Up& __old, _ValFn __vfn,\n+\t\t       __platform_wait_t& __val,\n+\t\t       _Spin __spin = _Spin{ })\n+\t  {\n+\t    auto const __pred = [=]\n+\t      { return __detail::__atomic_compare(__old, __vfn()); };\n+\n+\t    if constexpr (__platform_wait_uses_type<_Up>)\n+\t      {\n+\t\t__val == __old;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__atomic_load(__addr, &__val, __ATOMIC_RELAXED);\n+\t      }\n+\t    return __atomic_spin(__pred, __spin);\n+\t  }\n+\n+\ttemplate<typename _Up, typename _ValFn,\n+\t\t typename _Spin = __default_spin_policy>\n+\t  bool\n+\t  _M_do_spin_v(const _Up& __old, _ValFn __vfn,\n+\t\t       __platform_wait_t& __val,\n+\t\t       _Spin __spin = _Spin{ })\n+\t  { return _S_do_spin_v(_M_addr, __old, __vfn, __val, __spin); }\n+\n+\ttemplate<typename _Pred,\n+\t\t typename _Spin = __default_spin_policy>\n+\t  static bool\n+\t  _S_do_spin(const __platform_wait_t* __addr,\n+\t\t     _Pred __pred,\n+\t\t     __platform_wait_t& __val,\n+\t\t     _Spin __spin = _Spin{ })\n+\t  {\n+\t    __atomic_load(__addr, &__val, __ATOMIC_RELAXED);\n+\t    return __atomic_spin(__pred, __spin);\n+\t  }\n+\n+\ttemplate<typename _Pred,\n+\t\t typename _Spin = __default_spin_policy>\n+\t  bool\n+\t  _M_do_spin(_Pred __pred, __platform_wait_t& __val,\n+\t\t     _Spin __spin = _Spin{ })\n+\t  { return _S_do_spin(_M_addr, __pred, __val, __spin); }\n+      };\n+\n+    template<typename _EntersWait>\n+      struct __waiter : __waiter_base<__waiter_pool>\n+      {\n+\tusing __base_type = __waiter_base<__waiter_pool>;\n+\n+\ttemplate<typename _Tp>\n+\t  explicit __waiter(const _Tp* __addr) noexcept\n+\t    : __base_type(__addr)\n+\t  {\n+\t    if constexpr (_EntersWait::value)\n+\t      _M_w._M_enter_wait();\n+\t  }\n+\n+\t~__waiter()\n+\t{\n+\t  if constexpr (_EntersWait::value)\n+\t    _M_w._M_leave_wait();\n \t}\n-      return false;\n+\n+\ttemplate<typename _Tp, typename _ValFn>\n+\t  void\n+\t  _M_do_wait_v(_Tp __old, _ValFn __vfn)\n+\t  {\n+\t    __platform_wait_t __val;\n+\t    if (__base_type::_M_do_spin_v(__old, __vfn, __val))\n+\t      return;\n+\t    __base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);\n+\t  }\n+\n+\ttemplate<typename _Pred>\n+\t  void\n+\t  _M_do_wait(_Pred __pred) noexcept\n+\t  {\n+\t    do\n+\t      {\n+\t\t__platform_wait_t __val;\n+\t\tif (__base_type::_M_do_spin(__pred, __val))\n+\t\t  return;\n+\t\t__base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);\n+\t      }\n+\t    while (!__pred());\n+\t  }\n+      };\n+\n+    using __enters_wait = __waiter<std::true_type>;\n+    using __bare_wait = __waiter<std::false_type>;\n+  } // namespace __detail\n+\n+  template<typename _Tp, typename _ValFn>\n+    void\n+    __atomic_wait_address_v(const _Tp* __addr, _Tp __old,\n+\t\t\t    _ValFn __vfn) noexcept\n+    {\n+      __detail::__enters_wait __w(__addr);\n+      __w._M_do_wait_v(__old, __vfn);\n     }\n \n   template<typename _Tp, typename _Pred>\n     void\n-    __atomic_wait(const _Tp* __addr, _Tp __old, _Pred __pred) noexcept\n+    __atomic_wait_address(const _Tp* __addr, _Pred __pred) noexcept\n     {\n-      using namespace __detail;\n-      if (std::__atomic_spin(__pred))\n-\treturn;\n+      __detail::__enters_wait __w(__addr);\n+      __w._M_do_wait(__pred);\n+    }\n \n-      __waiter __w(__addr);\n-      while (!__pred())\n+  // This call is to be used by atomic types which track contention externally\n+  template<typename _Pred>\n+    void\n+    __atomic_wait_address_bare(const __detail::__platform_wait_t* __addr,\n+\t\t\t       _Pred __pred) noexcept\n+    {\n+#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT\n+      do\n \t{\n-\t  if constexpr (__platform_wait_uses_type<_Tp>)\n-\t    {\n-\t      __platform_wait(__addr, __old);\n-\t    }\n-\t  else\n-\t    {\n-\t      // TODO support timed backoff when this can be moved into the lib\n-\t      __w._M_do_wait();\n-\t    }\n+\t  __detail::__platform_wait_t __val;\n+\t  if (__detail::__bare_wait::_S_do_spin(__addr, __pred, __val))\n+\t    return;\n+\t  __detail::__platform_wait(__addr, __val);\n \t}\n+      while (!__pred());\n+#else // !_GLIBCXX_HAVE_PLATFORM_WAIT\n+      __detail::__bare_wait __w(__addr);\n+      __w._M_do_wait(__pred);\n+#endif\n     }\n \n   template<typename _Tp>\n     void\n-    __atomic_notify(const _Tp* __addr, bool __all) noexcept\n+    __atomic_notify_address(const _Tp* __addr, bool __all) noexcept\n     {\n-      using namespace __detail;\n-      auto& __w = __waiters::_S_for((void*)__addr);\n-      if (!__w._M_waiting())\n-\treturn;\n+      __detail::__bare_wait __w(__addr);\n+      __w._M_notify(__all);\n+    }\n \n-#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-      if constexpr (__platform_wait_uses_type<_Tp>)\n-\t{\n-\t  __platform_notify((__platform_wait_t*)(void*) __addr, __all);\n-\t}\n-      else\n+  // This call is to be used by atomic types which track contention externally\n+  inline void\n+  __atomic_notify_address_bare(const __detail::__platform_wait_t* __addr,\n+\t\t\t       bool __all) noexcept\n+  {\n+#ifdef _GLIBCXX_HAVE_PLATFORM_WAIT\n+    __detail::__platform_notify(__addr, __all);\n+#else\n+    __detail::__bare_wait __w(__addr);\n+    __w._M_notify(__all);\n #endif\n-\t{\n-\t  __w._M_notify(__all);\n-\t}\n-    }\n+  }\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n #endif // GTHREADS || LINUX_FUTEX"}, {"sha": "7e3235d182e9954dd3366bf378fe8ac7a42b56d0", "filename": "libstdc++-v3/include/bits/semaphore_base.h", "status": "modified", "additions": 77, "deletions": 114, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -35,8 +35,8 @@\n #include <bits/atomic_base.h>\n #if __cpp_lib_atomic_wait\n #include <bits/atomic_timed_wait.h>\n-\n #include <ext/numeric_traits.h>\n+#endif // __cpp_lib_atomic_wait\n \n #ifdef _GLIBCXX_HAVE_POSIX_SEMAPHORE\n # include <limits.h>\n@@ -164,138 +164,101 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n #endif // _GLIBCXX_HAVE_POSIX_SEMAPHORE\n \n-  template<typename _Tp>\n-    struct __atomic_semaphore\n+#if __cpp_lib_atomic_wait\n+  struct __atomic_semaphore\n+  {\n+    static constexpr ptrdiff_t _S_max = __gnu_cxx::__int_traits<int>::__max;\n+    explicit __atomic_semaphore(__detail::__platform_wait_t __count) noexcept\n+      : _M_counter(__count)\n     {\n-      static_assert(std::is_integral_v<_Tp>);\n-      static_assert(__gnu_cxx::__int_traits<_Tp>::__max\n-\t\t      <= __gnu_cxx::__int_traits<ptrdiff_t>::__max);\n-      static constexpr ptrdiff_t _S_max = __gnu_cxx::__int_traits<_Tp>::__max;\n+      __glibcxx_assert(__count >= 0 && __count <= _S_max);\n+    }\n \n-      explicit __atomic_semaphore(_Tp __count) noexcept\n-\t: _M_counter(__count)\n-      {\n-\t__glibcxx_assert(__count >= 0 && __count <= _S_max);\n-      }\n+    __atomic_semaphore(const __atomic_semaphore&) = delete;\n+    __atomic_semaphore& operator=(const __atomic_semaphore&) = delete;\n+\n+    static _GLIBCXX_ALWAYS_INLINE bool\n+    _S_do_try_acquire(__detail::__platform_wait_t* __counter,\n+\t\t      __detail::__platform_wait_t& __old) noexcept\n+    {\n+      if (__old == 0)\n+\treturn false;\n+\n+      return __atomic_impl::compare_exchange_strong(__counter,\n+\t\t\t\t\t\t    __old, __old - 1,\n+\t\t\t\t\t\t    memory_order::acquire,\n+\t\t\t\t\t\t    memory_order::relaxed);\n+    }\n+\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_acquire() noexcept\n+    {\n+      auto __old = __atomic_impl::load(&_M_counter, memory_order::acquire);\n+      auto const __pred =\n+\t[this, &__old] { return _S_do_try_acquire(&this->_M_counter, __old); };\n+      std::__atomic_wait_address_bare(&_M_counter, __pred);\n+    }\n \n-      __atomic_semaphore(const __atomic_semaphore&) = delete;\n-      __atomic_semaphore& operator=(const __atomic_semaphore&) = delete;\n+    bool\n+    _M_try_acquire() noexcept\n+    {\n+      auto __old = __atomic_impl::load(&_M_counter, memory_order::acquire);\n+      auto const __pred =\n+\t[this, &__old] { return _S_do_try_acquire(&this->_M_counter, __old); };\n+      return std::__detail::__atomic_spin(__pred);\n+    }\n \n-      _GLIBCXX_ALWAYS_INLINE void\n-      _M_acquire() noexcept\n+    template<typename _Clock, typename _Duration>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_try_acquire_until(const chrono::time_point<_Clock,\n+\t\t\t   _Duration>& __atime) noexcept\n       {\n-\tauto const __pred = [this]\n-\t  {\n-\t    auto __old = __atomic_impl::load(&this->_M_counter,\n-\t\t\t    memory_order::acquire);\n-\t    if (__old == 0)\n-\t      return false;\n-\t    return __atomic_impl::compare_exchange_strong(&this->_M_counter,\n-\t\t      __old, __old - 1,\n-\t\t      memory_order::acquire,\n-\t\t      memory_order::release);\n-\t  };\n \tauto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n-\tstd::__atomic_wait(&_M_counter, __old, __pred);\n-      }\n+\tauto const __pred =\n+\t  [this, &__old] { return _S_do_try_acquire(&this->_M_counter, __old); };\n \n-      bool\n-      _M_try_acquire() noexcept\n-      {\n-\tauto __old = __atomic_impl::load(&_M_counter, memory_order::acquire);\n-\tauto const __pred = [this, __old]\n-\t  {\n-\t    if (__old == 0)\n-\t      return false;\n-\n-\t    auto __prev = __old;\n-\t    return __atomic_impl::compare_exchange_weak(&this->_M_counter,\n-\t\t      __prev, __prev - 1,\n-\t\t      memory_order::acquire,\n-\t\t      memory_order::release);\n-\t  };\n-\treturn std::__atomic_spin(__pred);\n+\treturn __atomic_wait_address_until_bare(&_M_counter, __pred, __atime);\n       }\n \n-      template<typename _Clock, typename _Duration>\n-\t_GLIBCXX_ALWAYS_INLINE bool\n-\t_M_try_acquire_until(const chrono::time_point<_Clock,\n-\t\t\t     _Duration>& __atime) noexcept\n-\t{\n-\t  auto const __pred = [this]\n-\t    {\n-\t      auto __old = __atomic_impl::load(&this->_M_counter,\n-\t\t\t      memory_order::acquire);\n-\t      if (__old == 0)\n-\t\treturn false;\n-\t      return __atomic_impl::compare_exchange_strong(&this->_M_counter,\n-\t\t\t      __old, __old - 1,\n-\t\t\t      memory_order::acquire,\n-\t\t\t      memory_order::release);\n-\t    };\n-\n-\t  auto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n-\t  return __atomic_wait_until(&_M_counter, __old, __pred, __atime);\n-\t}\n-\n-      template<typename _Rep, typename _Period>\n-\t_GLIBCXX_ALWAYS_INLINE bool\n-\t_M_try_acquire_for(const chrono::duration<_Rep, _Period>& __rtime)\n-\t  noexcept\n-\t{\n-\t  auto const __pred = [this]\n-\t    {\n-\t      auto __old = __atomic_impl::load(&this->_M_counter,\n-\t\t\t      memory_order::acquire);\n-\t      if (__old == 0)\n-\t\treturn false;\n-\t      return  __atomic_impl::compare_exchange_strong(&this->_M_counter,\n-\t\t\t      __old, __old - 1,\n-\t\t\t      memory_order::acquire,\n-\t\t\t      memory_order::release);\n-\t    };\n-\n-\t  auto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n-\t  return __atomic_wait_for(&_M_counter, __old, __pred, __rtime);\n-\t}\n-\n-      _GLIBCXX_ALWAYS_INLINE void\n-      _M_release(ptrdiff_t __update) noexcept\n+    template<typename _Rep, typename _Period>\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_try_acquire_for(const chrono::duration<_Rep, _Period>& __rtime)\n+\tnoexcept\n       {\n-\tif (0 < __atomic_impl::fetch_add(&_M_counter, __update, memory_order_release))\n-\t  return;\n-\tif (__update > 1)\n-\t  __atomic_impl::notify_all(&_M_counter);\n-\telse\n-\t  __atomic_impl::notify_one(&_M_counter);\n+\tauto __old = __atomic_impl::load(&_M_counter, memory_order_relaxed);\n+\tauto const __pred =\n+\t  [this, &__old] { return _S_do_try_acquire(&this->_M_counter, __old); };\n+\n+\treturn __atomic_wait_address_for_bare(&_M_counter, __pred, __rtime);\n       }\n \n-    private:\n-      alignas(__alignof__(_Tp)) _Tp _M_counter;\n-    };\n+    _GLIBCXX_ALWAYS_INLINE void\n+    _M_release(ptrdiff_t __update) noexcept\n+    {\n+      if (0 < __atomic_impl::fetch_add(&_M_counter, __update, memory_order_release))\n+\treturn;\n+      if (__update > 1)\n+\t__atomic_notify_address_bare(&_M_counter, true);\n+      else\n+\t__atomic_notify_address_bare(&_M_counter, false);\n+    }\n+\n+  private:\n+    alignas(__detail::__platform_wait_alignment)\n+    __detail::__platform_wait_t _M_counter;\n+  };\n+#endif // __cpp_lib_atomic_wait\n \n // Note: the _GLIBCXX_REQUIRE_POSIX_SEMAPHORE macro can be used to force the\n // use of Posix semaphores (sem_t). Doing so however, alters the ABI.\n-#if defined _GLIBCXX_HAVE_LINUX_FUTEX && !_GLIBCXX_REQUIRE_POSIX_SEMAPHORE\n-  // Use futex if available and didn't force use of POSIX\n-  using __fast_semaphore = __atomic_semaphore<__detail::__platform_wait_t>;\n+#if defined __cpp_lib_atomic_wait && !_GLIBCXX_REQUIRE_POSIX_SEMAPHORE\n+  using __semaphore_impl = __atomic_semaphore;\n #elif _GLIBCXX_HAVE_POSIX_SEMAPHORE\n-  using __fast_semaphore = __platform_semaphore;\n+  using __semaphore_impl = __platform_semaphore;\n #else\n-  using __fast_semaphore = __atomic_semaphore<ptrdiff_t>;\n+#  error \"No suitable semaphore implementation available\"\n #endif\n \n-template<ptrdiff_t __least_max_value>\n-  using __semaphore_impl = conditional_t<\n-\t\t(__least_max_value > 1),\n-\t\tconditional_t<\n-\t\t    (__least_max_value <= __fast_semaphore::_S_max),\n-\t\t    __fast_semaphore,\n-\t\t    __atomic_semaphore<ptrdiff_t>>,\n-\t\t__fast_semaphore>;\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n-\n-#endif // __cpp_lib_atomic_wait\n #endif // _GLIBCXX_SEMAPHORE_BASE_H"}, {"sha": "a87da388ec5f8241d69191ad7e8bb0f97709c9f6", "filename": "libstdc++-v3/include/bits/this_thread_sleep.h", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -0,0 +1,119 @@\n+// std::this_thread::sleep_for/until declarations -*- C++ -*-\n+\n+// Copyright (C) 2008-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/std_thread_sleep.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{thread}\n+ */\n+\n+#ifndef _GLIBCXX_THIS_THREAD_SLEEP_H\n+#define _GLIBCXX_THIS_THREAD_SLEEP_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201103L\n+#include <bits/c++config.h>\n+\n+#include <chrono> // std::chrono::*\n+\n+#ifdef _GLIBCXX_USE_NANOSLEEP\n+# include <cerrno>  // errno, EINTR\n+# include <time.h>  // nanosleep\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /** @addtogroup threads\n+   *  @{\n+   */\n+\n+  /** @namespace std::this_thread\n+   *  @brief ISO C++ 2011 namespace for interacting with the current thread\n+   *\n+   *  C++11 30.3.2 [thread.thread.this] Namespace this_thread.\n+   */\n+  namespace this_thread\n+  {\n+#ifndef _GLIBCXX_NO_SLEEP\n+\n+#ifndef _GLIBCXX_USE_NANOSLEEP\n+    void\n+    __sleep_for(chrono::seconds, chrono::nanoseconds);\n+#endif\n+\n+    /// this_thread::sleep_for\n+    template<typename _Rep, typename _Period>\n+      inline void\n+      sleep_for(const chrono::duration<_Rep, _Period>& __rtime)\n+      {\n+\tif (__rtime <= __rtime.zero())\n+\t  return;\n+\tauto __s = chrono::duration_cast<chrono::seconds>(__rtime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);\n+#ifdef _GLIBCXX_USE_NANOSLEEP\n+\tstruct ::timespec __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\twhile (::nanosleep(&__ts, &__ts) == -1 && errno == EINTR)\n+\t  { }\n+#else\n+\t__sleep_for(__s, __ns);\n+#endif\n+      }\n+\n+    /// this_thread::sleep_until\n+    template<typename _Clock, typename _Duration>\n+      inline void\n+      sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)\n+      {\n+#if __cplusplus > 201703L\n+\tstatic_assert(chrono::is_clock_v<_Clock>);\n+#endif\n+\tauto __now = _Clock::now();\n+\tif (_Clock::is_steady)\n+\t  {\n+\t    if (__now < __atime)\n+\t      sleep_for(__atime - __now);\n+\t    return;\n+\t  }\n+\twhile (__now < __atime)\n+\t  {\n+\t    sleep_for(__atime - __now);\n+\t    __now = _Clock::now();\n+\t  }\n+      }\n+  } // namespace this_thread\n+#endif // ! NO_SLEEP\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // C++11\n+\n+#endif // _GLIBCXX_THIS_THREAD_SLEEP_H"}, {"sha": "9b1fb15ac4112cf3d2a06aeb4f49b6519a60261e", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -384,26 +384,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept\n     {\n-      std::__atomic_wait(&_M_i, __old,\n-\t\t\t [__m, this, __old]\n-\t\t\t {\n-\t\t\t   const auto __v = this->load(__m);\n-\t\t\t   // TODO make this ignore padding bits when we\n-\t\t\t   // can do that\n-\t\t\t   return __builtin_memcmp(&__old, &__v,\n-\t\t\t\t\t\t    sizeof(_Tp)) != 0;\n-\t\t\t });\n+      std::__atomic_wait_address_v(&_M_i, __old,\n+\t\t\t [__m, this] { return this->load(__m); });\n     }\n \n     // TODO add const volatile overload\n \n     void\n     notify_one() const noexcept\n-    { std::__atomic_notify(&_M_i, false); }\n+    { std::__atomic_notify_address(&_M_i, false); }\n \n     void\n     notify_all() const noexcept\n-    { std::__atomic_notify(&_M_i, true); }\n+    { std::__atomic_notify_address(&_M_i, true); }\n #endif // __cpp_lib_atomic_wait \n \n     };"}, {"sha": "fd61fb4f9da5d8eed1f96a914e2d238d27de642c", "filename": "libstdc++-v3/include/std/barrier", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbarrier?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -94,7 +94,7 @@ It looks different from literature pseudocode for two main reasons:\n       alignas(__phase_alignment) __barrier_phase_t  _M_phase;\n \n       bool\n-      _M_arrive(__barrier_phase_t __old_phase)\n+      _M_arrive(__barrier_phase_t __old_phase, size_t __current)\n       {\n \tconst auto __old_phase_val = static_cast<unsigned char>(__old_phase);\n \tconst auto __half_step =\n@@ -104,8 +104,7 @@ It looks different from literature pseudocode for two main reasons:\n \n \tsize_t __current_expected = _M_expected;\n \tstd::hash<std::thread::id> __hasher;\n-\tsize_t __current = __hasher(std::this_thread::get_id())\n-\t\t\t\t\t  % ((_M_expected + 1) >> 1);\n+\t__current %= ((_M_expected + 1) >> 1);\n \n \tfor (int __round = 0; ; ++__round)\n \t  {\n@@ -163,12 +162,14 @@ It looks different from literature pseudocode for two main reasons:\n       [[nodiscard]] arrival_token\n       arrive(ptrdiff_t __update)\n       {\n+\tstd::hash<std::thread::id> __hasher;\n+\tsize_t __current = __hasher(std::this_thread::get_id());\n \t__atomic_phase_ref_t __phase(_M_phase);\n \tconst auto __old_phase = __phase.load(memory_order_relaxed);\n \tconst auto __cur = static_cast<unsigned char>(__old_phase);\n \tfor(; __update; --__update)\n \t  {\n-\t    if(_M_arrive(__old_phase))\n+\t    if(_M_arrive(__old_phase, __current))\n \t      {\n \t\t_M_completion();\n \t\t_M_expected += _M_expected_adjustment.load(memory_order_relaxed);\n@@ -185,11 +186,11 @@ It looks different from literature pseudocode for two main reasons:\n       wait(arrival_token&& __old_phase) const\n       {\n \t__atomic_phase_const_ref_t __phase(_M_phase);\n-\tauto const __test_fn = [=, this]\n+\tauto const __test_fn = [=]\n \t  {\n \t    return __phase.load(memory_order_acquire) != __old_phase;\n \t  };\n-\tstd::__atomic_wait(&_M_phase, __old_phase, __test_fn);\n+\tstd::__atomic_wait_address(&_M_phase, __test_fn);\n       }\n \n       void"}, {"sha": "20b75f8181ab6e17ad1462ce41153aa7e830b6ae", "filename": "libstdc++-v3/include/std/latch", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flatch?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -48,7 +48,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   public:\n     static constexpr ptrdiff_t\n     max() noexcept\n-    { return __gnu_cxx::__int_traits<ptrdiff_t>::__max; }\n+    { return __gnu_cxx::__int_traits<__detail::__platform_wait_t>::__max; }\n \n     constexpr explicit latch(ptrdiff_t __expected) noexcept\n       : _M_a(__expected) { }\n@@ -73,8 +73,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX_ALWAYS_INLINE void\n     wait() const noexcept\n     {\n-      auto const __old = __atomic_impl::load(&_M_a, memory_order::acquire);\n-      std::__atomic_wait(&_M_a, __old, [this] { return this->try_wait(); });\n+      auto const __pred = [this] { return this->try_wait(); };\n+      std::__atomic_wait_address(&_M_a, __pred);\n     }\n \n     _GLIBCXX_ALWAYS_INLINE void\n@@ -85,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   private:\n-    alignas(__alignof__(ptrdiff_t)) ptrdiff_t _M_a;\n+    alignas(__alignof__(__detail::__platform_wait_t)) __detail::__platform_wait_t _M_a;\n   };\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "02a8214e569779b135bd3d47ff49e2d4b093f6e1", "filename": "libstdc++-v3/include/std/semaphore", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsemaphore?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -33,22 +33,20 @@\n \n #if __cplusplus > 201703L\n #include <bits/semaphore_base.h>\n-#if __cpp_lib_atomic_wait\n-#include <ext/numeric_traits.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #define __cpp_lib_semaphore 201907L\n \n-  template<ptrdiff_t __least_max_value =\n-\t\t\t__gnu_cxx::__int_traits<ptrdiff_t>::__max>\n+  template<ptrdiff_t __least_max_value = __semaphore_impl::_S_max>\n     class counting_semaphore\n     {\n       static_assert(__least_max_value >= 0);\n+      static_assert(__least_max_value <= __semaphore_impl::_S_max);\n \n-      __semaphore_impl<__least_max_value> _M_sem;\n+      __semaphore_impl _M_sem;\n \n     public:\n       explicit counting_semaphore(ptrdiff_t __desired) noexcept\n@@ -91,6 +89,5 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n-#endif // __cpp_lib_atomic_wait\n #endif // C++20\n #endif // _GLIBCXX_SEMAPHORE"}, {"sha": "886994c132060c3d89481ad65ee3b6ecb26dc42d", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -35,19 +35,13 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <chrono> // std::chrono::*\n-\n #if __cplusplus > 201703L\n # include <compare>\t// std::strong_ordering\n # include <stop_token>\t// std::stop_source, std::stop_token, std::nostopstate\n #endif\n \n #include <bits/std_thread.h> // std::thread, get_id, yield\n-\n-#ifdef _GLIBCXX_USE_NANOSLEEP\n-# include <cerrno>  // errno, EINTR\n-# include <time.h>  // nanosleep\n-#endif\n+#include <bits/this_thread_sleep.h> // std::this_thread::sleep_for, sleep_until\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -103,66 +97,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn __out << __id._M_thread;\n     }\n \n-  /** @namespace std::this_thread\n-   *  @brief ISO C++ 2011 namespace for interacting with the current thread\n-   *\n-   *  C++11 30.3.2 [thread.thread.this] Namespace this_thread.\n-   */\n-  namespace this_thread\n-  {\n-#ifndef _GLIBCXX_NO_SLEEP\n-\n-#ifndef _GLIBCXX_USE_NANOSLEEP\n-    void\n-    __sleep_for(chrono::seconds, chrono::nanoseconds);\n-#endif\n-\n-    /// this_thread::sleep_for\n-    template<typename _Rep, typename _Period>\n-      inline void\n-      sleep_for(const chrono::duration<_Rep, _Period>& __rtime)\n-      {\n-\tif (__rtime <= __rtime.zero())\n-\t  return;\n-\tauto __s = chrono::duration_cast<chrono::seconds>(__rtime);\n-\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);\n-#ifdef _GLIBCXX_USE_NANOSLEEP\n-\tstruct ::timespec __ts =\n-\t  {\n-\t    static_cast<std::time_t>(__s.count()),\n-\t    static_cast<long>(__ns.count())\n-\t  };\n-\twhile (::nanosleep(&__ts, &__ts) == -1 && errno == EINTR)\n-\t  { }\n-#else\n-\t__sleep_for(__s, __ns);\n-#endif\n-      }\n-\n-    /// this_thread::sleep_until\n-    template<typename _Clock, typename _Duration>\n-      inline void\n-      sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-      {\n-#if __cplusplus > 201703L\n-\tstatic_assert(chrono::is_clock_v<_Clock>);\n-#endif\n-\tauto __now = _Clock::now();\n-\tif (_Clock::is_steady)\n-\t  {\n-\t    if (__now < __atime)\n-\t      sleep_for(__atime - __now);\n-\t    return;\n-\t  }\n-\twhile (__now < __atime)\n-\t  {\n-\t    sleep_for(__atime - __now);\n-\t    __now = _Clock::now();\n-\t  }\n-      }\n-  } // namespace this_thread\n-#endif // ! NO_SLEEP\n-\n #ifdef __cpp_lib_jthread\n \n   /// A thread that can be requested to stop and automatically joined."}, {"sha": "da25cc75c23fd2ebf3d120ea3a8ccc9a9d590c20", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/bool.cc", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fbool.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -23,42 +23,21 @@\n \n #include <atomic>\n #include <thread>\n-#include <mutex>\n-#include <condition_variable>\n-#include <type_traits>\n-#include <chrono>\n \n #include <testsuite_hooks.h>\n \n int\n main ()\n {\n-  using namespace std::literals::chrono_literals;\n-\n-  std::mutex m;\n-  std::condition_variable cv;\n-  std::unique_lock<std::mutex> l(m);\n-\n-  std::atomic<bool> a(false);\n-  std::atomic<bool> b(false);\n+  std::atomic<bool> a{ true };\n+  VERIFY( a.load() );\n+  a.wait(false);\n   std::thread t([&]\n-\t\t{\n-\t\t  {\n-\t\t    // This ensures we block until cv.wait(l) starts.\n-\t\t    std::lock_guard<std::mutex> ll(m);\n-\t\t  }\n-\t\t  cv.notify_one();\n-\t\t  a.wait(false);\n-\t\t  if (a.load())\n-\t\t    {\n-\t\t      b.store(true);\n-\t\t    }\n-\t\t});\n-  cv.wait(l);\n-  std::this_thread::sleep_for(100ms);\n-  a.store(true);\n-  a.notify_one();\n+    {\n+      a.store(false);\n+      a.notify_one();\n+    });\n+  a.wait(true);\n   t.join();\n-  VERIFY( b.load() );\n   return 0;\n }"}, {"sha": "fb68b4253681d9e02431f3bcc9bf73ecd1929d57", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/generic.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fgeneric.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -21,12 +21,27 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"atomic/wait_notify_util.h\"\n+#include <atomic>\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n \n int\n main ()\n {\n   struct S{ int i; };\n-  check<S> check_s{S{0},S{42}};\n+  S aa{ 0 };\n+  S bb{ 42 };\n+\n+  std::atomic<S> a{ aa };\n+  VERIFY( a.load().i == aa.i );\n+  a.wait(bb);\n+  std::thread t([&]\n+    {\n+      a.store(bb);\n+      a.notify_one();\n+    });\n+  a.wait(aa);\n+  t.join();\n   return 0;\n }"}, {"sha": "53080bbaef0e35acc3d952fa58bfa4315208bb6a", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/wait_notify/pointers.cc", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fwait_notify%2Fpointers.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -23,42 +23,24 @@\n \n #include <atomic>\n #include <thread>\n-#include <mutex>\n-#include <condition_variable>\n-#include <type_traits>\n-#include <chrono>\n \n #include <testsuite_hooks.h>\n \n int\n main ()\n {\n-  using namespace std::literals::chrono_literals;\n-\n-  std::mutex m;\n-  std::condition_variable cv;\n-  std::unique_lock<std::mutex> l(m);\n-\n   long aa;\n   long bb;\n-\n-  std::atomic<long*> a(nullptr);\n+  std::atomic<long*> a(&aa);\n+  VERIFY( a.load() == &aa );\n+  a.wait(&bb);\n   std::thread t([&]\n-\t\t{\n-\t\t  {\n-\t\t    // This ensures we block until cv.wait(l) starts.\n-\t\t    std::lock_guard<std::mutex> ll(m);\n-\t\t  }\n-\t\t  cv.notify_one();\n-\t\t  a.wait(nullptr);\n-\t\t  if (a.load() == &aa)\n-\t\t    a.store(&bb);\n-\t\t});\n-  cv.wait(l);\n-  std::this_thread::sleep_for(100ms);\n-  a.store(&aa);\n-  a.notify_one();\n+    {\n+      a.store(&bb);\n+      a.notify_one();\n+    });\n+  a.wait(&aa);\n   t.join();\n-  VERIFY( a.load() == &bb);\n+\n   return 0;\n }"}, {"sha": "9872a56a20ed2772abba4c3edf18f133ab18736f", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/wait_notify/1.cc", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fwait_notify%2F1.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -22,45 +22,22 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <atomic>\n-#include <chrono>\n-#include <condition_variable>\n-#include <concepts>\n-#include <mutex>\n #include <thread>\n \n #include <testsuite_hooks.h>\n \n int\n main()\n {\n-  using namespace std::literals::chrono_literals;\n-\n-  std::mutex m;\n-  std::condition_variable cv;\n-  std::unique_lock<std::mutex> l(m);\n-\n   std::atomic_flag a;\n-  std::atomic_flag b;\n+  VERIFY( !a.test() );\n+  a.wait(true);\n   std::thread t([&]\n-\t\t{\n-\t\t  {\n-\t\t    // This ensures we block until cv.wait(l) starts.\n-\t\t    std::lock_guard<std::mutex> ll(m);\n-\t\t  }\n-\t\t  cv.notify_one();\n-\t\t  a.wait(false);\n-\t\t  b.test_and_set();\n-\t\t  b.notify_one();\n-\t\t});\n-\n-  cv.wait(l);\n-  std::this_thread::sleep_for(100ms);\n-  a.test_and_set();\n-  a.notify_one();\n-  b.wait(false);\n+    {\n+      a.test_and_set();\n+      a.notify_one();\n+    });\n+  a.wait(false);\n   t.join();\n-\n-  VERIFY( a.test() );\n-  VERIFY( b.test() );\n   return 0;\n }"}, {"sha": "01768da290b75868586e0456169f88a8961147fd", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_float/wait_notify.cc", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_float%2Fwait_notify.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -21,12 +21,32 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"atomic/wait_notify_util.h\"\n+\n+#include <atomic>\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n+\n+template<typename Tp>\n+  void\n+  check()\n+  {\n+    std::atomic<Tp> a{ 1.0 };\n+    VERIFY( a.load() != 0.0 );\n+    a.wait( 0.0 );\n+    std::thread t([&]\n+      {\n+        a.store(0.0);\n+        a.notify_one();\n+      });\n+    a.wait(1.0);\n+    t.join();\n+  }\n \n int\n main ()\n {\n-  check<float> f;\n-  check<double> d;\n+  check<float>();\n+  check<double>();\n   return 0;\n }"}, {"sha": "d1bf081160202601b7725f498c1890323613f892", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/wait_notify.cc", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fwait_notify.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -21,46 +21,57 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"atomic/wait_notify_util.h\"\n \n-void\n-test01()\n-{\n-  struct S{ int i; };\n-  std::atomic<S> s;\n+#include <atomic>\n+#include <thread>\n \n-  s.wait(S{42});\n-}\n+#include <testsuite_hooks.h>\n+\n+template<typename Tp>\n+  void\n+  check()\n+  {\n+    std::atomic<Tp> a{ Tp(1) };\n+    VERIFY( a.load() == Tp(1) );\n+    a.wait( Tp(0) );\n+    std::thread t([&]\n+      {\n+        a.store(Tp(0));\n+        a.notify_one();\n+      });\n+    a.wait(Tp(1));\n+    t.join();\n+  }\n \n int\n main ()\n {\n   // check<bool> bb;\n-  check<char> ch;\n-  check<signed char> sch;\n-  check<unsigned char> uch;\n-  check<short> s;\n-  check<unsigned short> us;\n-  check<int> i;\n-  check<unsigned int> ui;\n-  check<long> l;\n-  check<unsigned long> ul;\n-  check<long long> ll;\n-  check<unsigned long long> ull;\n+  check<char>();\n+  check<signed char>();\n+  check<unsigned char>();\n+  check<short>();\n+  check<unsigned short>();\n+  check<int>();\n+  check<unsigned int>();\n+  check<long>();\n+  check<unsigned long>();\n+  check<long long>();\n+  check<unsigned long long>();\n \n-  check<wchar_t> wch;\n-  check<char8_t> ch8;\n-  check<char16_t> ch16;\n-  check<char32_t> ch32;\n+  check<wchar_t>();\n+  check<char8_t>();\n+  check<char16_t>();\n+  check<char32_t>();\n \n-  check<int8_t> i8;\n-  check<int16_t> i16;\n-  check<int32_t> i32;\n-  check<int64_t> i64;\n+  check<int8_t>();\n+  check<int16_t>();\n+  check<int32_t>();\n+  check<int64_t>();\n \n-  check<uint8_t> u8;\n-  check<uint16_t> u16;\n-  check<uint32_t> u32;\n-  check<uint64_t> u64;\n+  check<uint8_t>();\n+  check<uint16_t>();\n+  check<uint32_t>();\n+  check<uint64_t>();\n   return 0;\n }"}, {"sha": "2fd313042222af16a55f1ddeb2b5475248b82fc2", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_ref/wait_notify.cc", "status": "modified", "additions": 13, "deletions": 61, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52aef3a8cbcc817c18c474806a29ad7f3453f6d/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_ref%2Fwait_notify.cc?ref=b52aef3a8cbcc817c18c474806a29ad7f3453f6d", "patch": "@@ -23,73 +23,25 @@\n \n #include <atomic>\n #include <thread>\n-#include <mutex>\n-#include <condition_variable>\n-#include <chrono>\n-#include <type_traits>\n \n #include <testsuite_hooks.h>\n \n-template<typename Tp>\n-Tp check_wait_notify(Tp val1, Tp val2)\n+int\n+main ()\n {\n-  using namespace std::literals::chrono_literals;\n+  struct S{ int i; };\n+  S aa{ 0 };\n+  S bb{ 42 };\n \n-  std::mutex m;\n-  std::condition_variable cv;\n-  std::unique_lock<std::mutex> l(m);\n-\n-  Tp aa = val1;\n-  std::atomic_ref<Tp> a(aa);\n+  std::atomic_ref<S> a{ aa };\n+  VERIFY( a.load().i == aa.i );\n+  a.wait(bb);\n   std::thread t([&]\n-\t\t{\n-\t\t  {\n-\t\t    // This ensures we block until cv.wait(l) starts.\n-\t\t    std::lock_guard<std::mutex> ll(m);\n-\t\t  }\n-\t\t  cv.notify_one();\n-\t\t  a.wait(val1);\n-\t\t  if (a.load() != val2)\n-\t\t    a = val1;\n-\t\t});\n-  cv.wait(l);\n-  std::this_thread::sleep_for(100ms);\n-  a.store(val2);\n-  a.notify_one();\n+    {\n+      a.store(bb);\n+      a.notify_one();\n+    });\n+  a.wait(aa);\n   t.join();\n-  return a.load();\n-}\n-\n-template<typename Tp,\n-\t bool = std::is_integral_v<Tp>\n-\t || std::is_floating_point_v<Tp>>\n-struct check;\n-\n-template<typename Tp>\n-struct check<Tp, true>\n-{\n-  check()\n-  {\n-    Tp a = 0;\n-    Tp b = 42;\n-    VERIFY(check_wait_notify(a, b) == b);\n-  }\n-};\n-\n-template<typename Tp>\n-struct check<Tp, false>\n-{\n-  check(Tp b)\n-  {\n-    Tp a;\n-    VERIFY(check_wait_notify(a, b) == b);\n-  }\n-};\n-\n-int\n-main ()\n-{\n-  check<long>();\n-  check<double>();\n   return 0;\n }"}]}