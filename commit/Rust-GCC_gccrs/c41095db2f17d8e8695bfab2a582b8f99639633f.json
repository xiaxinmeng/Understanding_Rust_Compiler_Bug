{"sha": "c41095db2f17d8e8695bfab2a582b8f99639633f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxMDk1ZGIyZjE3ZDhlODY5NWJmYWIyYTU4MmI4Zjk5NjM5NjMzZg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@cs.tamu.edu", "date": "2010-11-02T01:31:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-11-02T01:31:02Z"}, "message": "semantics.c (constexpr_call): New datatype.\n\n\t* semantics.c (constexpr_call): New datatype.\n\t(constexpr_call_table): New global table.\n\t(constexpr_call_hash): New.\n\t(constexpr_call_equal): Likewise.\n\t(maybe_initialize_constexpr_call_table): Likewise.\n\t(lookup_parameter_binding): Likewise.\n\t(cxx_eval_builtin_function_call): Likewise.\n\t(cxx_bind_parameters_in_call): Likewise.\n\t(cxx_eval_call_expression): Likewise.\n\t(cxx_eval_unary_expression): Likewise.\n\t(cxx_eval_binary_expression): Likewise.\n\t(cxx_eval_conditional_expression): Likewise.\n\t(cxx_eval_array_reference): Likewise.\n\t(cxx_eval_component_reference): Likewise.\n\t(cxx_eval_logical_expression): Likewise.\n\t(cxx_eval_object_construction): Likewise.\n\t(cxx_eval_constant_expression): Likewise.\n\t(cxx_eval_indirect_ref): Likewise.\n\t(cxx_constant_value): Likewise.\n\t(cxx_eval_bare_aggregate): Likewise.\n\t(adjust_temp_type): New.\n\t(reduced_constant_expression_p): New.\n\t(verify_constant): New.\n\t(cxx_eval_vec_init, cxx_eval_vec_init_1): New.\n\t(cxx_eval_outermost_constant_expr): New.\n\t(maybe_constant_value, maybe_constant_init): New.\n\t(cxx_eval_constant_expression): Use them.\n\t* cp-tree.h: Declare fns.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r166166", "tree": {"sha": "f31986452fdc89bcb7b1f979bfe06f64c121e126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f31986452fdc89bcb7b1f979bfe06f64c121e126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c41095db2f17d8e8695bfab2a582b8f99639633f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41095db2f17d8e8695bfab2a582b8f99639633f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c41095db2f17d8e8695bfab2a582b8f99639633f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41095db2f17d8e8695bfab2a582b8f99639633f/comments", "author": null, "committer": null, "parents": [{"sha": "66e61a34b5ba3d0748578bb553d9ef15202eee9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e61a34b5ba3d0748578bb553d9ef15202eee9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e61a34b5ba3d0748578bb553d9ef15202eee9f"}], "stats": {"total": 1310, "additions": 1308, "deletions": 2}, "files": [{"sha": "0f013702dacc5fcf0d96262957ea0023546ec2b2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c41095db2f17d8e8695bfab2a582b8f99639633f", "patch": "@@ -1,6 +1,36 @@\n 2010-11-01  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n \t    Jason Merrill  <jason@redhat.com>\n \n+\t* semantics.c (constexpr_call): New datatype.\n+\t(constexpr_call_table): New global table.\n+\t(constexpr_call_hash): New.\n+\t(constexpr_call_equal): Likewise.\n+\t(maybe_initialize_constexpr_call_table): Likewise.\n+\t(lookup_parameter_binding): Likewise.\n+\t(cxx_eval_builtin_function_call): Likewise.\n+\t(cxx_bind_parameters_in_call): Likewise.\n+\t(cxx_eval_call_expression): Likewise.\n+\t(cxx_eval_unary_expression): Likewise.\n+\t(cxx_eval_binary_expression): Likewise.\n+\t(cxx_eval_conditional_expression): Likewise.\n+\t(cxx_eval_array_reference): Likewise.\n+\t(cxx_eval_component_reference): Likewise.\n+\t(cxx_eval_logical_expression): Likewise.\n+\t(cxx_eval_object_construction): Likewise.\n+\t(cxx_eval_constant_expression): Likewise.\n+\t(cxx_eval_indirect_ref): Likewise.\n+\t(cxx_constant_value): Likewise.\n+\t(cxx_eval_bare_aggregate): Likewise.\n+\t(adjust_temp_type): New.\n+\t(reduced_constant_expression_p): New.\n+\t(verify_constant): New.\n+\t(cxx_eval_vec_init, cxx_eval_vec_init_1): New.\n+\t(cxx_eval_outermost_constant_expr): New.\n+\t(maybe_constant_value, maybe_constant_init): New.\n+\t(cxx_eval_constant_expression): Use them.\n+\t* pt.c (iterative_hash_template_arg): No longer static.\n+\t* cp-tree.h: Declare fns.\n+\n \t* cp-tree.h (register_constexpr_fundef): Declare.\n \t* decl.c (maybe_save_function_definition): New.\n \t(finish_function): Use it."}, {"sha": "96fefae441f027ecc0d6d617ad8e5de9391e0a48", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c41095db2f17d8e8695bfab2a582b8f99639633f", "patch": "@@ -5122,6 +5122,7 @@ extern tree get_template_innermost_arguments\t(const_tree);\n extern tree get_template_argument_pack_elems\t(const_tree);\n extern tree get_function_template_decl\t\t(const_tree);\n extern tree resolve_nondeduced_context\t\t(tree);\n+extern hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);\n@@ -5254,6 +5255,10 @@ extern bool literal_type_p (tree);\n extern tree validate_constexpr_fundecl (tree);\n extern tree register_constexpr_fundef (tree, tree);\n extern tree ensure_literal_type_for_constexpr_object (tree);\n+extern tree cxx_constant_value (tree);\n+extern tree maybe_constant_value (tree);\n+extern tree maybe_constant_init (tree);\n+extern bool reduced_constant_expression_p (tree);\n \n enum {\n   BCS_NO_SCOPE = 1,"}, {"sha": "9a72ea844a61c286ad0a94d0cccf9a074fbe9bc0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c41095db2f17d8e8695bfab2a582b8f99639633f", "patch": "@@ -187,7 +187,6 @@ static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n \t\t\t\t\t\t\tlocation_t);\n-static hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n \n@@ -1458,7 +1457,7 @@ hash_specialization (const void *p)\n /* Recursively calculate a hash value for a template argument ARG, for use\n    in the hash tables of template specializations.  */\n \n-static hashval_t\n+hashval_t\n iterative_hash_template_arg (tree arg, hashval_t val)\n {\n   unsigned HOST_WIDE_INT i;"}, {"sha": "039f0a50282e8a998c717e6ec7767d41208d3bc4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1272, "deletions": 0, "changes": 1272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c41095db2f17d8e8695bfab2a582b8f99639633f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c41095db2f17d8e8695bfab2a582b8f99639633f", "patch": "@@ -5562,6 +5562,89 @@ register_constexpr_fundef (tree fun, tree body)\n   return fun;\n }\n \n+/* Objects of this type represent calls to constexpr functions\n+   along with the bindings of parameters to their arguments, for\n+   the purpose of compile time evaluation.  */\n+\n+typedef struct GTY(()) constexpr_call {\n+  /* Description of the constexpr function definition.  */\n+  constexpr_fundef *fundef;\n+  /* Parameter bindings enironment.  A TREE_LIST where each TREE_PURPOSE\n+     is a parameter _DECL and the TREE_VALUE is the value of the parameter.\n+     Note: This arrangement is made to accomodate the use of\n+     iterative_hash_template_arg (see pt.c).  If you change this\n+     representation, also change the hash calculation in\n+     cxx_eval_call_expression.  */\n+  tree bindings;\n+  /* Result of the call.\n+       NULL means the call is being evaluated.\n+       error_mark_node means that the evaluation was erroneous;\n+       otherwise, the actuall value of the call.  */\n+  tree result;\n+  /* The hash of this call; we remember it here to avoid having to\n+     recalculate it when expanding the hash table.  */\n+  hashval_t hash;\n+} constexpr_call;\n+\n+/* A table of all constexpr calls that have been evaluated by the\n+   compiler in this translation unit.  */\n+\n+static GTY ((param_is (constexpr_call))) htab_t constexpr_call_table;\n+\n+static tree cxx_eval_constant_expression (const constexpr_call *, tree,\n+\t\t\t\t\t  bool, bool, bool *);\n+\n+/* Compute a hash value for a constexpr call representation.  */\n+\n+static hashval_t\n+constexpr_call_hash (const void *p)\n+{\n+  const constexpr_call *info = (const constexpr_call *) p;\n+  return info->hash;\n+}\n+\n+/* Return 1 if the objects pointed to by P and Q represent calls\n+   to the same constexpr function with the same arguments.\n+   Otherwise, return 0.  */\n+\n+static int\n+constexpr_call_equal (const void *p, const void *q)\n+{\n+  const constexpr_call *lhs = (const constexpr_call *) p;\n+  const constexpr_call *rhs = (const constexpr_call *) q;\n+  tree lhs_bindings;\n+  tree rhs_bindings;\n+  if (lhs == rhs)\n+    return 1;\n+  if (!constexpr_fundef_equal (lhs->fundef, rhs->fundef))\n+    return 0;\n+  lhs_bindings = lhs->bindings;\n+  rhs_bindings = rhs->bindings;\n+  while (lhs_bindings != NULL && rhs_bindings != NULL)\n+    {\n+      tree lhs_arg = TREE_VALUE (lhs_bindings);\n+      tree rhs_arg = TREE_VALUE (rhs_bindings);\n+      gcc_assert (TREE_TYPE (lhs_arg) == TREE_TYPE (rhs_arg));\n+      if (!cp_tree_equal (lhs_arg, rhs_arg))\n+        return 0;\n+      lhs_bindings = TREE_CHAIN (lhs_bindings);\n+      rhs_bindings = TREE_CHAIN (rhs_bindings);\n+    }\n+  return lhs_bindings == rhs_bindings;\n+}\n+\n+/* Initialize the constexpr call table, if needed.  */\n+\n+static void\n+maybe_initialize_constexpr_call_table (void)\n+{\n+  if (constexpr_call_table == NULL)\n+    constexpr_call_table = htab_create_ggc (101,\n+                                            constexpr_call_hash,\n+                                            constexpr_call_equal,\n+                                            ggc_free);\n+}\n+\n /* Return true if T designates the implied `this' parameter.  */\n \n static inline bool\n@@ -5618,6 +5701,1195 @@ get_nth_callarg (tree t, int n)\n     }\n }\n \n+/* Look up the binding of the function parameter T in a constexpr\n+   function call context CALL.  */\n+\n+static tree\n+lookup_parameter_binding (const constexpr_call *call, tree t)\n+{\n+  tree b = purpose_member (t, call->bindings);\n+  return TREE_VALUE (b);\n+}\n+\n+/* Attempt to evaluate T which represents a call to a builtin function.\n+   We assume here that all builtin functions evaluate to scalar types\n+   represented by _CST nodes.  */\n+\n+static tree\n+cxx_eval_builtin_function_call (const constexpr_call *call, tree t,\n+\t\t\t\tbool allow_non_constant, bool addr,\n+\t\t\t\tbool *non_constant_p)\n+{\n+  const int nargs = call_expr_nargs (t);\n+  tree *args = (tree *) alloca (nargs * sizeof (tree));\n+  tree new_call;\n+  int i;\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      args[i] = cxx_eval_constant_expression (call, CALL_EXPR_ARG (t, i),\n+\t\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t\t      non_constant_p);\n+      if (allow_non_constant && *non_constant_p)\n+\treturn t;\n+    }\n+  if (*non_constant_p)\n+    return t;\n+  new_call = build_call_array_loc (EXPR_LOCATION (t), TREE_TYPE (t),\n+                                   CALL_EXPR_FN (t), nargs, args);\n+  return fold (new_call);\n+}\n+\n+/* TEMP is the constant value of a temporary object of type TYPE.  Adjust\n+   the type of the value to match.  */\n+\n+static tree\n+adjust_temp_type (tree type, tree temp)\n+{\n+  if (TREE_TYPE (temp) == type)\n+    return temp;\n+  /* Avoid wrapping an aggregate value in a NOP_EXPR.  */\n+  if (TREE_CODE (temp) == CONSTRUCTOR)\n+    return build_constructor (type, CONSTRUCTOR_ELTS (temp));\n+  gcc_assert (SCALAR_TYPE_P (type));\n+  return fold_convert (type, temp);\n+}\n+\n+/* Subroutine of cxx_eval_call_expression.\n+   We are processing a call expression (either CALL_EXPR or\n+   AGGR_INIT_EXPR) in the call context of OLD_CALL.  Evaluate\n+   all arguments and bind their values to correspondings\n+   parameters, making up the NEW_CALL context.  */\n+\n+static void\n+cxx_bind_parameters_in_call (const constexpr_call *old_call, tree t,\n+                             constexpr_call *new_call,\n+\t\t\t     bool allow_non_constant,\n+\t\t\t     bool *non_constant_p)\n+{\n+  const int nargs = call_expr_nargs (t);\n+  tree fun = new_call->fundef->decl;\n+  tree parms = DECL_ARGUMENTS (fun);\n+  int i;\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      tree x, arg;\n+      tree type = parms ? TREE_TYPE (parms) : void_type_node;\n+      /* For member function, the first argument is a pointer to the implied\n+         object.  And for an object contruction, don't bind `this' before\n+         it is fully constructed.  */\n+      if (i == 0 && DECL_CONSTRUCTOR_P (fun))\n+        goto next;\n+      x = get_nth_callarg (t, i);\n+      arg = cxx_eval_constant_expression (old_call, x, allow_non_constant,\n+\t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n+\t\t\t\t\t  non_constant_p);\n+      /* Don't VERIFY_CONSTANT here.  */\n+      if (*non_constant_p && allow_non_constant)\n+\treturn;\n+      /* Just discard ellipsis args after checking their constantitude.  */\n+      if (!parms)\n+\tcontinue;\n+\n+      /* Make sure the binding has the same type as the parm.  */\n+      if (TREE_CODE (type) != REFERENCE_TYPE)\n+\targ = adjust_temp_type (type, arg);\n+      new_call->bindings = tree_cons (parms, arg, new_call->bindings);\n+    next:\n+      parms = TREE_CHAIN (parms);\n+    }\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Evaluate the call expression tree T in the context of OLD_CALL expression\n+   evaluation.  */\n+\n+static tree\n+cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n+\t\t\t  bool allow_non_constant, bool addr,\n+\t\t\t  bool *non_constant_p)\n+{\n+  location_t loc = EXPR_LOCATION (t);\n+  tree fun = get_function_named_in_call (t);\n+  tree result;\n+  constexpr_call new_call = { NULL, NULL, NULL, 0 };\n+  constexpr_call **slot;\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = input_location;\n+  if (TREE_CODE (fun) != FUNCTION_DECL)\n+    {\n+      /* Might be a constexpr function pointer.  */\n+      fun = cxx_eval_constant_expression (old_call, fun, allow_non_constant,\n+\t\t\t\t\t  /*addr*/false, non_constant_p);\n+      if (TREE_CODE (fun) == ADDR_EXPR)\n+\tfun = TREE_OPERAND (fun, 0);\n+    }\n+  if (TREE_CODE (fun) != FUNCTION_DECL)\n+    {\n+      if (!allow_non_constant)\n+\terror_at (loc, \"expression %qE does not designate a constexpr \"\n+\t\t  \"function\", fun);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  if (DECL_CLONED_FUNCTION_P (fun))\n+    fun = DECL_CLONED_FUNCTION (fun);\n+  if (is_builtin_fn (fun))\n+    return cxx_eval_builtin_function_call (old_call, t, allow_non_constant,\n+\t\t\t\t\t   addr, non_constant_p);\n+  if (!DECL_DECLARED_CONSTEXPR_P (fun))\n+    {\n+      if (!allow_non_constant)\n+\t{\n+\t  error_at (loc, \"%qD is not a constexpr function\", fun);\n+\t  if (DECL_TEMPLATE_INSTANTIATION (fun)\n+\t      && DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT\n+\t\t\t\t\t    (DECL_TI_TEMPLATE (fun))))\n+\t    is_valid_constexpr_fn (fun, true);\n+\t}\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* If in direct recursive call, optimize definition search.  */\n+  if (old_call != NULL && old_call->fundef->decl == fun)\n+    new_call.fundef = old_call->fundef;\n+  else\n+    {\n+      new_call.fundef = retrieve_constexpr_fundef (fun);\n+      if (new_call.fundef == NULL || new_call.fundef->body == NULL)\n+        {\n+\t  if (!allow_non_constant)\n+\t    error_at (loc, \"%qD used before its definition\", fun);\n+\t  *non_constant_p = true;\n+          return t;\n+        }\n+    }\n+  cxx_bind_parameters_in_call (old_call, t, &new_call,\n+\t\t\t       allow_non_constant, non_constant_p);\n+  if (*non_constant_p)\n+    return t;\n+\n+  new_call.hash\n+    = iterative_hash_template_arg (new_call.bindings,\n+\t\t\t\t   constexpr_fundef_hash (new_call.fundef));\n+\n+  /* If we have seen this call before, we are done.  */\n+  maybe_initialize_constexpr_call_table ();\n+  slot = (constexpr_call **)\n+    htab_find_slot (constexpr_call_table, &new_call, INSERT);\n+  if (*slot != NULL)\n+    {\n+      /* Calls which are in progress have their result set to NULL\n+         so that we can detect circular dependencies.  */\n+      if ((*slot)->result == NULL)\n+        {\n+\t  if (!allow_non_constant)\n+\t    error (\"call has circular dependency\");\n+\t  (*slot)->result = result = error_mark_node;\n+        }\n+      else\n+\t{\n+\t  result = (*slot)->result;\n+\t  if (result == error_mark_node && !allow_non_constant)\n+\t    /* Re-evaluate to get the error.  */\n+\t    cxx_eval_constant_expression (&new_call, new_call.fundef->body,\n+\t\t\t\t\t  allow_non_constant, addr,\n+\t\t\t\t\t  non_constant_p);\n+\t}\n+    }\n+  else\n+    {\n+      /* We need to keep a pointer to the entry, not just the slot, as the\n+\t slot can move in the call to cxx_eval_builtin_function_call.  */\n+      constexpr_call *entry = ggc_alloc_constexpr_call ();\n+      *entry = new_call;\n+      *slot = entry;\n+      result\n+\t= cxx_eval_constant_expression (&new_call, new_call.fundef->body,\n+\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\tnon_constant_p);\n+      if (*non_constant_p)\n+\tentry->result = result = error_mark_node;\n+      else\n+\t{\n+\t  /* If this was a call to initialize an object, set the type of\n+\t     the CONSTRUCTOR to the type of that object.  */\n+\t  if (DECL_CONSTRUCTOR_P (fun))\n+\t    {\n+\t      tree ob_arg = get_nth_callarg (t, 0);\n+\t      STRIP_NOPS (ob_arg);\n+\t      gcc_assert (TREE_CODE (TREE_TYPE (ob_arg)) == POINTER_TYPE\n+\t\t\t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (ob_arg))));\n+\t      result = adjust_temp_type (TREE_TYPE (TREE_TYPE (ob_arg)),\n+\t\t\t\t\t result);\n+\t    }\n+\t  entry->result = result;\n+\t}\n+    }\n+\n+  if (result == error_mark_node)\n+    {\n+      if (!allow_non_constant)\n+\terror_at (loc, \"in expansion of %qE\", t);\n+      *non_constant_p = true;\n+      result = t;\n+    }\n+  return result;\n+}\n+\n+bool\n+reduced_constant_expression_p (tree t)\n+{\n+  /* FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n+  if (cxx_dialect >= cxx0x && TREE_OVERFLOW_P (t))\n+    /* In C++0x, integer overflow makes this not a constant expression.\n+       FIXME arithmetic overflow is different from conversion truncation */\n+    return false;\n+  /* FIXME are we calling this too much?  */\n+  return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n+}\n+\n+/* Some expressions may have constant operands but are not constant\n+   themselves, such as 1/0.  Call this function (or rather, the macro\n+   following it) to check for that condition.\n+\n+   We only call this in places that require an arithmetic constant, not in\n+   places where we might have a non-constant expression that can be a\n+   component of a constant expression, such as the address of a constexpr\n+   variable that might be dereferenced later.  */\n+\n+static bool\n+verify_constant (tree t, bool allow_non_constant, bool *non_constant_p)\n+{\n+  if (!*non_constant_p && !reduced_constant_expression_p (t))\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%qE is not a constant expression\", t);\n+      *non_constant_p = true;\n+    }\n+  return *non_constant_p;\n+}\n+#define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (verify_constant ((X), allow_non_constant, non_constant_p))\t\\\n+    return t;\t\t\t\t\t\t\t\t\\\n+ } while (0)\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to reduce the unary expression tree T to a compile time value.\n+   If successful, return the value.  Otherwise issue a diagnostic\n+   and return error_mark_node.  */\n+\n+static tree\n+cxx_eval_unary_expression (const constexpr_call *call, tree t,\n+\t\t\t   bool allow_non_constant, bool addr,\n+\t\t\t   bool *non_constant_p)\n+{\n+  tree r;\n+  tree orig_arg = TREE_OPERAND (t, 0);\n+  tree arg = cxx_eval_constant_expression (call, orig_arg, allow_non_constant,\n+\t\t\t\t\t   addr, non_constant_p);\n+  VERIFY_CONSTANT (arg);\n+  if (arg == orig_arg)\n+    return t;\n+  r = fold_build1 (TREE_CODE (t), TREE_TYPE (t), arg);\n+  VERIFY_CONSTANT (r);\n+  return r;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Like cxx_eval_unary_expression, except for binary expressions.  */\n+\n+static tree\n+cxx_eval_binary_expression (const constexpr_call *call, tree t,\n+\t\t\t    bool allow_non_constant, bool addr,\n+\t\t\t    bool *non_constant_p)\n+{\n+  tree r;\n+  tree orig_lhs = TREE_OPERAND (t, 0);\n+  tree orig_rhs = TREE_OPERAND (t, 1);\n+  tree lhs, rhs;\n+  lhs = cxx_eval_constant_expression (call, orig_lhs,\n+\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t      non_constant_p);\n+  VERIFY_CONSTANT (lhs);\n+  rhs = cxx_eval_constant_expression (call, orig_rhs,\n+\t\t\t\t      allow_non_constant, addr,\n+\t\t\t\t      non_constant_p);\n+  VERIFY_CONSTANT (rhs);\n+  if (lhs == orig_lhs && rhs == orig_rhs)\n+    return t;\n+  r = fold_build2 (TREE_CODE (t), TREE_TYPE (t), lhs, rhs);\n+  VERIFY_CONSTANT (r);\n+  return r;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to evaluate condition expressions.  Dead branches are not\n+   looked into.  */\n+\n+static tree\n+cxx_eval_conditional_expression (const constexpr_call *call, tree t,\n+\t\t\t\t bool allow_non_constant, bool addr,\n+\t\t\t\t bool *non_constant_p)\n+{\n+  tree val = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p);\n+  VERIFY_CONSTANT (val);\n+  if (val == boolean_true_node)\n+    return cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+\t\t\t\t\t allow_non_constant, addr,\n+\t\t\t\t\t non_constant_p);\n+  gcc_assert (val == boolean_false_node);\n+  /* Don't VERIFY_CONSTANT here.  */\n+  return cxx_eval_constant_expression (call, TREE_OPERAND (t, 2),\n+\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       non_constant_p);\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to reduce a reference to an array slot.  */\n+\n+static tree\n+cxx_eval_array_reference (const constexpr_call *call, tree t,\n+\t\t\t  bool allow_non_constant, bool addr,\n+\t\t\t  bool *non_constant_p)\n+{\n+  tree oldary = TREE_OPERAND (t, 0);\n+  tree ary = cxx_eval_constant_expression (call, oldary,\n+\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p);\n+  tree index, oldidx;\n+  HOST_WIDE_INT i;\n+  unsigned len;\n+  if (*non_constant_p)\n+    return t;\n+  oldidx = TREE_OPERAND (t, 1);\n+  index = cxx_eval_constant_expression (call, oldidx,\n+\t\t\t\t\tallow_non_constant, false,\n+\t\t\t\t\tnon_constant_p);\n+  VERIFY_CONSTANT (index);\n+  if (addr && ary == oldary && index == oldidx)\n+    return t;\n+  else if (addr)\n+    return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n+  len = (TREE_CODE (ary) == CONSTRUCTOR\n+\t ? CONSTRUCTOR_NELTS (ary)\n+\t : (unsigned)TREE_STRING_LENGTH (ary));\n+  if (compare_tree_int (index, len) >= 0)\n+    {\n+      if (!allow_non_constant)\n+\terror (\"array subscript out of bound\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  i = tree_low_cst (index, 0);\n+  if (TREE_CODE (ary) == CONSTRUCTOR)\n+    return VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ary), i)->value;\n+  else\n+    return build_int_cst (cv_unqualified (TREE_TYPE (TREE_TYPE (ary))),\n+\t\t\t  TREE_STRING_POINTER (ary)[i]);\n+  /* Don't VERIFY_CONSTANT here.  */\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to reduce a field access of a value of class type.  */\n+\n+static tree\n+cxx_eval_component_reference (const constexpr_call *call, tree t,\n+\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool *non_constant_p)\n+{\n+  unsigned HOST_WIDE_INT i;\n+  tree field;\n+  tree value;\n+  tree part = TREE_OPERAND (t, 1);\n+  tree orig_whole = TREE_OPERAND (t, 0);\n+  tree whole = cxx_eval_constant_expression (call, orig_whole,\n+\t\t\t\t\t     allow_non_constant, addr,\n+\t\t\t\t\t     non_constant_p);\n+  if (whole == orig_whole)\n+    return t;\n+  if (addr)\n+    return fold_build3 (COMPONENT_REF, TREE_TYPE (t),\n+\t\t\twhole, part, NULL_TREE);\n+  /* Don't VERIFY_CONSTANT here; we only want to check that we got a\n+     CONSTRUCTOR.  */\n+  if (!*non_constant_p && TREE_CODE (whole) != CONSTRUCTOR)\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%qE is not a constant expression\", orig_whole);\n+      *non_constant_p = true;\n+    }\n+  if (*non_constant_p)\n+    return t;\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)\n+    {\n+      if (field == part)\n+        return value;\n+    }\n+  if (TREE_CODE (TREE_TYPE (whole)) == UNION_TYPE)\n+    {\n+      /* FIXME Mike Miller wants this to be OK.  */\n+      if (!allow_non_constant)\n+\terror (\"accessing %qD member instead of initialized %qD member in \"\n+\t       \"constant expression\", part, CONSTRUCTOR_ELT (whole, 0)->index);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  gcc_unreachable();\n+  return error_mark_node;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Evaluate a short-circuited logical expression T in the context\n+   of a given constexpr CALL.  BAILOUT_VALUE is the value for\n+   early return.  CONTINUE_VALUE is used here purely for\n+   sanity check purposes.  */\n+\n+static tree\n+cxx_eval_logical_expression (const constexpr_call *call, tree t,\n+                             tree bailout_value, tree continue_value,\n+\t\t\t     bool allow_non_constant, bool addr,\n+\t\t\t     bool *non_constant_p)\n+{\n+  tree r;\n+  tree lhs = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p);\n+  VERIFY_CONSTANT (lhs);\n+  if (lhs == bailout_value)\n+    return lhs;\n+  gcc_assert (lhs == continue_value);\n+  r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+\t\t\t\t    allow_non_constant, addr, non_constant_p);\n+  VERIFY_CONSTANT (r);\n+  return r;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   The expression tree T denotes a C-style array or a C-style\n+   aggregate.  Reduce it to a constant expression.  */\n+\n+static tree\n+cxx_eval_bare_aggregate (const constexpr_call *call, tree t,\n+\t\t\t bool allow_non_constant, bool addr,\n+\t\t\t bool *non_constant_p)\n+{\n+  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (t);\n+  VEC(constructor_elt,gc) *n = VEC_alloc (constructor_elt, gc,\n+\t\t\t\t\t  VEC_length (constructor_elt, v));\n+  constructor_elt *ce;\n+  HOST_WIDE_INT i;\n+  bool changed = false;\n+  tree type = TREE_TYPE (t);\n+  gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (t));\n+  for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+    {\n+      tree elt = cxx_eval_constant_expression (call, ce->value,\n+\t\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t\t       non_constant_p);\n+      /* Don't VERIFY_CONSTANT here.  */\n+      if (allow_non_constant && *non_constant_p)\n+\tgoto fail;\n+      if (elt != ce->value)\n+\tchanged = true;\n+      if (TREE_CODE (type) != ARRAY_TYPE\n+\t  && !(same_type_ignoring_top_level_qualifiers_p\n+\t       (DECL_CONTEXT (ce->index), type)))\n+\t{\n+\t  /* Push our vtable pointer down into the base where it belongs.  */\n+\t  tree vptr_base = DECL_CONTEXT (ce->index);\n+\t  tree base_ctor;\n+\t  gcc_assert (ce->index == TYPE_VFIELD (type));\n+\t  for (base_ctor = VEC_index (constructor_elt, n, 0)->value; ;\n+\t       base_ctor = CONSTRUCTOR_ELT (base_ctor, 0)->value)\n+\t    if (TREE_TYPE (base_ctor) == vptr_base)\n+\t      {\n+\t\tconstructor_elt *p = CONSTRUCTOR_ELT (base_ctor, 0);\n+\t\tgcc_assert (p->index == ce->index);\n+\t\tp->value = elt;\n+\t\tbreak;\n+\t      }\n+\t}\n+      else\n+\tCONSTRUCTOR_APPEND_ELT (n, ce->index, elt);\n+    }\n+  if (*non_constant_p || !changed)\n+    {\n+    fail:\n+      VEC_free (constructor_elt, gc, n);\n+      return t;\n+    }\n+  t = build_constructor (TREE_TYPE (t), n);\n+  TREE_CONSTANT (t) = true;\n+  return t;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   The expression tree T is a VEC_INIT_EXPR which denotes the desired\n+   initialization of a non-static data member of array type.  Reduce it to a\n+   CONSTRUCTOR.\n+\n+   Note that this is only intended to support the initializations done by\n+   defaulted constructors for classes with non-static data members of array\n+   type.  In this case, VEC_INIT_EXPR_INIT will either be NULL_TREE for the\n+   default constructor, or a COMPONENT_REF for the copy/move\n+   constructor.  */\n+\n+static tree\n+cxx_eval_vec_init_1 (const constexpr_call *call, tree atype, tree init,\n+\t\t     bool allow_non_constant, bool addr,\n+\t\t     bool *non_constant_p)\n+{\n+  tree elttype = TREE_TYPE (atype);\n+  int max = tree_low_cst (array_type_nelts (atype), 0);\n+  VEC(constructor_elt,gc) *n = VEC_alloc (constructor_elt, gc, max + 1);\n+  int i;\n+\n+  /* For the default constructor, build up a call to the default\n+     constructor of the element type.  We only need to handle class types\n+     here, as for a constructor to be constexpr, all members must be\n+     initialized, which for a defaulted default constructor means they must\n+     be of a class type with a constexpr default constructor.  */\n+  if (!init)\n+    {\n+      VEC(tree,gc) *argvec = make_tree_vector ();\n+      init = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t\t&argvec, elttype, LOOKUP_NORMAL,\n+\t\t\t\t\ttf_warning_or_error);\n+      release_tree_vector (argvec);\n+      init = cxx_eval_constant_expression (call, init, allow_non_constant,\n+\t\t\t\t\t   addr, non_constant_p);\n+    }\n+\n+  if (*non_constant_p && !allow_non_constant)\n+    goto fail;\n+\n+  for (i = 0; i <= max; ++i)\n+    {\n+      tree idx = build_int_cst (size_type_node, i);\n+      tree eltinit;\n+      if (TREE_CODE (elttype) == ARRAY_TYPE)\n+\t{\n+\t  /* A multidimensional array; recurse.  */\n+\t  eltinit = cp_build_array_ref (input_location, init, idx,\n+\t\t\t\t\ttf_warning_or_error);\n+\t  eltinit = cxx_eval_vec_init_1 (call, elttype, eltinit,\n+\t\t\t\t\t allow_non_constant, addr,\n+\t\t\t\t\t non_constant_p);\n+\t}\n+      else if (TREE_CODE (init) == CONSTRUCTOR)\n+\t{\n+\t  /* Initializing an element using the call to the default\n+\t     constructor we just built above.  */\n+\t  eltinit = unshare_expr (init);\n+\t}\n+      else\n+\t{\n+\t  /* Copying an element.  */\n+\t  VEC(tree,gc) *argvec;\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (atype, TREE_TYPE (init)));\n+\t  eltinit = cp_build_array_ref (input_location, init, idx,\n+\t\t\t\t\ttf_warning_or_error);\n+\t  if (!real_lvalue_p (init))\n+\t    eltinit = move (eltinit);\n+\t  argvec = make_tree_vector ();\n+\t  VEC_quick_push (tree, argvec, eltinit);\n+\t  eltinit = (build_special_member_call\n+\t\t     (NULL_TREE, complete_ctor_identifier, &argvec,\n+\t\t      elttype, LOOKUP_NORMAL, tf_warning_or_error));\n+\t  release_tree_vector (argvec);\n+\t  eltinit = cxx_eval_constant_expression\n+\t    (call, eltinit, allow_non_constant, addr, non_constant_p);\n+\t}\n+      if (*non_constant_p && !allow_non_constant)\n+\tgoto fail;\n+      CONSTRUCTOR_APPEND_ELT (n, idx, eltinit);\n+    }\n+\n+  if (!*non_constant_p)\n+    {\n+      init = build_constructor (TREE_TYPE (atype), n);\n+      TREE_CONSTANT (init) = true;\n+      return init;\n+    }\n+\n+ fail:\n+  VEC_free (constructor_elt, gc, n);\n+  return init;\n+}\n+\n+static tree\n+cxx_eval_vec_init (const constexpr_call *call, tree t,\n+\t\t   bool allow_non_constant, bool addr,\n+\t\t   bool *non_constant_p)\n+{\n+  tree atype = TREE_TYPE (t);\n+  tree init = VEC_INIT_EXPR_INIT (t);\n+  tree r = cxx_eval_vec_init_1 (call, atype, init, allow_non_constant,\n+\t\t\t\taddr, non_constant_p);\n+  if (*non_constant_p)\n+    return t;\n+  else\n+    return r;\n+}\n+\n+/* A less strict version of fold_indirect_ref_1, which requires cv-quals to\n+   match.  We want to be less strict for simple *& folding; if we have a\n+   non-const temporary that we access through a const pointer, that should\n+   work.  We handle this here rather than change fold_indirect_ref_1\n+   because we're dealing with things like ADDR_EXPR of INTEGER_CST which\n+   don't really make sense outside of constant expression evaluation.  Also\n+   we want to allow folding to COMPONENT_REF, which could cause trouble\n+   with TBAA in fold_indirect_ref_1.  */\n+\n+static tree\n+cxx_eval_indirect_ref (const constexpr_call *call, tree t,\n+\t\t       bool allow_non_constant, bool addr,\n+\t\t       bool *non_constant_p)\n+{\n+  tree orig_op0 = TREE_OPERAND (t, 0);\n+  tree op0 = cxx_eval_constant_expression (call, orig_op0, allow_non_constant,\n+\t\t\t\t\t   /*addr*/false, non_constant_p);\n+  tree type, sub, subtype, r;\n+  bool empty_base;\n+\n+  /* Don't VERIFY_CONSTANT here.  */\n+  if (*non_constant_p)\n+    return t;\n+\n+  type = TREE_TYPE (t);\n+  sub = op0;\n+  r = NULL_TREE;\n+  empty_base = false;\n+\n+  STRIP_NOPS (sub);\n+  subtype = TREE_TYPE (sub);\n+  gcc_assert (POINTER_TYPE_P (subtype));\n+\n+  if (TREE_CODE (sub) == ADDR_EXPR)\n+    {\n+      tree op = TREE_OPERAND (sub, 0);\n+      tree optype = TREE_TYPE (op);\n+\n+      if (same_type_ignoring_top_level_qualifiers_p (optype, type))\n+\tr = op;\n+      /* Also handle conversion to an empty base class, which\n+\t is represented with a NOP_EXPR.  */\n+      else if (!addr && is_empty_class (type)\n+\t       && CLASS_TYPE_P (optype)\n+\t       && DERIVED_FROM_P (type, optype))\n+\t{\n+\t  r = op;\n+\t  empty_base = true;\n+\t}\n+      /* *(foo *)&struct_with_foo_field => COMPONENT_REF */\n+      else if (RECORD_OR_UNION_TYPE_P (optype))\n+\t{\n+\t  tree field = TYPE_FIELDS (optype);\n+\t  for (; field; field = DECL_CHAIN (field))\n+\t    if (TREE_CODE (field) == FIELD_DECL\n+\t\t&& integer_zerop (byte_position (field))\n+\t\t&& (same_type_ignoring_top_level_qualifiers_p\n+\t\t    (TREE_TYPE (field), type)))\n+\t      {\n+\t\tr = fold_build3 (COMPONENT_REF, type, op, field, NULL_TREE);\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+  else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n+    {\n+      tree op00 = TREE_OPERAND (sub, 0);\n+      tree op01 = TREE_OPERAND (sub, 1);\n+\n+      STRIP_NOPS (op00);\n+      if (TREE_CODE (op00) == ADDR_EXPR)\n+\t{\n+\t  tree op00type;\n+\t  op00 = TREE_OPERAND (op00, 0);\n+\t  op00type = TREE_TYPE (op00);\n+\n+\t  /* ((foo *)&struct_with_foo_field)[1] => COMPONENT_REF */\n+\t  if (RECORD_OR_UNION_TYPE_P (op00type))\n+\t    {\n+\t      tree field = TYPE_FIELDS (op00type);\n+\t      for (; field; field = DECL_CHAIN (field))\n+\t\tif (TREE_CODE (field) == FIELD_DECL\n+\t\t    && tree_int_cst_equal (byte_position (field), op01)\n+\t\t    && (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t(TREE_TYPE (field), type)))\n+\t\t  {\n+\t\t    r = fold_build3 (COMPONENT_REF, type, op00,\n+\t\t\t\t     field, NULL_TREE);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+\n+  /* Let build_fold_indirect_ref handle the cases it does fine with.  */\n+  if (r == NULL_TREE)\n+    r = build_fold_indirect_ref (op0);\n+  if (TREE_CODE (r) != INDIRECT_REF)\n+    r = cxx_eval_constant_expression (call, r, allow_non_constant,\n+\t\t\t\t      addr, non_constant_p);\n+  else if (TREE_CODE (sub) == ADDR_EXPR\n+\t   || TREE_CODE (sub) == POINTER_PLUS_EXPR)\n+    {\n+      gcc_assert (!same_type_ignoring_top_level_qualifiers_p\n+\t\t  (TREE_TYPE (TREE_TYPE (sub)), TREE_TYPE (t)));\n+      /* FIXME Mike Miller wants this to be OK.  */\n+      if (!allow_non_constant)\n+\terror (\"accessing value of %qE through a %qT glvalue in a \"\n+\t       \"constant expression\", build_fold_indirect_ref (sub),\n+\t       TREE_TYPE (t));\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* If we're pulling out the value of an empty base, make sure\n+     that the whole object is constant and then return an empty\n+     CONSTRUCTOR.  */\n+  if (empty_base)\n+    {\n+      VERIFY_CONSTANT (r);\n+      r = build_constructor (TREE_TYPE (t), NULL);\n+      TREE_CONSTANT (r) = true;\n+    }\n+\n+  if (TREE_CODE (r) == INDIRECT_REF && TREE_OPERAND (r, 0) == orig_op0)\n+    return t;\n+  return r;\n+}\n+\n+/* Attempt to reduce the expression T to a constant value.\n+   On failure, issue diagnostic and return error_mark_node.  */\n+/* FIXME unify with c_fully_fold */\n+\n+static tree\n+cxx_eval_constant_expression (const constexpr_call *call, tree t,\n+\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool *non_constant_p)\n+{\n+  tree r = t;\n+\n+  if (t == error_mark_node)\n+    {\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  if (CONSTANT_CLASS_P (t))\n+    {\n+      if (TREE_CODE (t) == PTRMEM_CST)\n+\tt = cplus_expand_constant (t);\n+      return t;\n+    }\n+  if (TREE_CODE (t) != NOP_EXPR\n+      && reduced_constant_expression_p (t))\n+    return fold (t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+      if (addr)\n+\treturn t;\n+      /* else fall through. */\n+    case CONST_DECL:\n+      r = integral_constant_value (t);\n+      if (TREE_CODE (r) == TARGET_EXPR\n+\t  && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n+\tr = TARGET_EXPR_INITIAL (r);\n+      if (DECL_P (r))\n+\t{\n+\t  if (!allow_non_constant)\n+\t    error (\"%qD cannot appear in a constant expression\", r);\n+\t  *non_constant_p = true;\n+\t}\n+      break;\n+\n+    case FUNCTION_DECL:\n+    case LABEL_DECL:\n+      return t;\n+\n+    case PARM_DECL:\n+      if (call && DECL_CONTEXT (t) == call->fundef->decl)\n+\tr = lookup_parameter_binding (call, t);\n+      else if (addr)\n+\t/* Defer in case this is only used for its type.  */;\n+      else\n+\t{\n+\t  if (!allow_non_constant)\n+\t    error (\"%qE is not a constant expression\", t);\n+\t  *non_constant_p = true;\n+\t}\n+      break;\n+\n+    case CALL_EXPR:\n+    case AGGR_INIT_EXPR:\n+      r = cxx_eval_call_expression (call, t, allow_non_constant, addr,\n+\t\t\t\t    non_constant_p);\n+      break;\n+\n+    case TARGET_EXPR:\n+    case INIT_EXPR:\n+      /* Pass false for 'addr' because these codes indicate\n+\t initialization of a temporary.  */\n+      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+\t\t\t\t\tallow_non_constant, false,\n+\t\t\t\t\tnon_constant_p);\n+      if (!*non_constant_p)\n+\t/* Adjust the type of the result to the type of the temporary.  */\n+\tr = adjust_temp_type (TREE_TYPE (t), r);\n+      break;\n+\n+    case SCOPE_REF:\n+      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 1),\n+\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\tnon_constant_p);\n+      break;\n+\n+    case RETURN_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case MUST_NOT_THROW_EXPR:\n+    case SAVE_EXPR:\n+      r = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\tnon_constant_p);\n+      break;\n+\n+      /* These differ from cxx_eval_unary_expression in that this doesn't\n+\t check for a constant operand or result; an address can be\n+\t constant without its operand being, and vice versa.  */\n+    case INDIRECT_REF:\n+      r = cxx_eval_indirect_ref (call, t, allow_non_constant, addr,\n+\t\t\t\t non_constant_p);\n+      break;\n+\n+    case ADDR_EXPR:\n+      {\n+\ttree oldop = TREE_OPERAND (t, 0);\n+\ttree op = cxx_eval_constant_expression (call, oldop,\n+\t\t\t\t\t\tallow_non_constant,\n+\t\t\t\t\t\t/*addr*/true,\n+\t\t\t\t\t\tnon_constant_p);\n+\t/* Don't VERIFY_CONSTANT here.  */\n+\tif (*non_constant_p)\n+\t  return t;\n+\t/* This function does more aggressive folding than fold itself.  */\n+\tr = build_fold_addr_expr_with_type (op, TREE_TYPE (t));\n+\tif (TREE_CODE (r) == ADDR_EXPR && TREE_OPERAND (r, 0) == oldop)\n+\t  return t;\n+\tbreak;\n+      }\n+\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case CONJ_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+      r = cxx_eval_unary_expression (call, t, allow_non_constant, addr,\n+\t\t\t\t     non_constant_p);\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      {\n+\t/* check_return_expr sometimes wraps a TARGET_EXPR in a\n+\t   COMPOUND_EXPR; don't get confused.  Also handle EMPTY_CLASS_EXPR\n+\t   introduced by build_call_a.  */\n+\ttree op0 = TREE_OPERAND (t, 0);\n+\ttree op1 = TREE_OPERAND (t, 1);\n+\tSTRIP_NOPS (op1);\n+\tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n+\t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n+\t  r = cxx_eval_constant_expression (call, op0, allow_non_constant,\n+\t\t\t\t\t    addr, non_constant_p);\n+\telse\n+\t  goto binary;\n+      }\n+      break;\n+\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case RANGE_EXPR:\n+    case COMPLEX_EXPR:\n+    binary:\n+      r = cxx_eval_binary_expression (call, t, allow_non_constant, addr,\n+\t\t\t\t      non_constant_p);\n+      break;\n+\n+      /* fold can introduce non-IF versions of these; still treat them as\n+\t short-circuiting.  */\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      r = cxx_eval_logical_expression (call, t, boolean_false_node,\n+\t\t\t\t       boolean_true_node,\n+\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       non_constant_p);\n+      break;\n+\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      r = cxx_eval_logical_expression (call, t, boolean_true_node,\n+\t\t\t\t       boolean_false_node,\n+\t\t\t\t       allow_non_constant, addr,\n+\t\t\t\t       non_constant_p);\n+      break;\n+\n+    case ARRAY_REF:\n+      r = cxx_eval_array_reference (call, t, allow_non_constant, addr,\n+\t\t\t\t    non_constant_p);\n+      break;\n+\n+    case COMPONENT_REF:\n+      r = cxx_eval_component_reference (call, t, allow_non_constant, addr,\n+\t\t\t\t\tnon_constant_p);\n+      break;\n+\n+    case COND_EXPR:\n+    case VEC_COND_EXPR:\n+      r = cxx_eval_conditional_expression (call, t, allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p);\n+      break;\n+\n+    case CONSTRUCTOR:\n+      r = cxx_eval_bare_aggregate (call, t, allow_non_constant, addr,\n+\t\t\t\t   non_constant_p);\n+      break;\n+\n+    case VEC_INIT_EXPR:\n+      /* We can get this in a defaulted constructor for a class with a\n+\t non-static data member of array type.  Either the initializer will\n+\t be NULL, meaning default-initialization, or it will be an lvalue\n+\t or xvalue of the same type, meaning direct-initialization from the\n+\t corresponding member.  */\n+      r = cxx_eval_vec_init (call, t, allow_non_constant, addr,\n+\t\t\t     non_constant_p);\n+      break;\n+\n+    case CONVERT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case NOP_EXPR:\n+      {\n+\ttree oldop = TREE_OPERAND (t, 0);\n+\ttree op = oldop;\n+\ttree to = TREE_TYPE (t);\n+\ttree source = TREE_TYPE (op);\n+        if (TYPE_PTR_P (source) && ARITHMETIC_TYPE_P (to)\n+\t    && !(TREE_CODE (op) == COMPONENT_REF\n+\t\t && TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (op, 0)))))\n+          {\n+            if (!allow_non_constant)\n+              error (\"conversion of expression %qE of pointer type \"\n+                     \"cannot yield a constant expression\", op);\n+\t    *non_constant_p = true;\n+\t    return t;\n+          }\n+\top = cxx_eval_constant_expression (call, TREE_OPERAND (t, 0),\n+\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p);\n+\tif (*non_constant_p)\n+\t  return t;\n+\tif (op == oldop)\n+\t  /* We didn't fold at the top so we could check for ptr-int\n+\t     conversion.  */\n+\t  return fold (t);\n+\tr = fold_build1 (TREE_CODE (t), to, op);\n+      }\n+      break;\n+\n+    case EMPTY_CLASS_EXPR:\n+      /* This is good enough for a function argument that might not get\n+\t used, and they can't do anything with it, so just return it.  */\n+      return t;\n+\n+    case LAMBDA_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case PSEUDO_DTOR_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+    case THROW_EXPR:\n+    case MODIFY_EXPR:\n+    case MODOP_EXPR:\n+      /* GCC internal stuff.  */\n+    case VA_ARG_EXPR:\n+    case OBJ_TYPE_REF:\n+    case WITH_CLEANUP_EXPR:\n+    case STATEMENT_LIST:\n+    case BIND_EXPR:\n+    case NON_DEPENDENT_EXPR:\n+    case BASELINK:\n+    case EXPR_STMT:\n+      if (!allow_non_constant)\n+        error_at (EXPR_LOC_OR_HERE (t),\n+\t\t  \"expression %qE is not a constant-expression\", t);\n+      *non_constant_p = true;\n+      break;\n+\n+    default:\n+      internal_error (\"unexpected expression %qE of kind %s\", t,\n+\t\t      tree_code_name[TREE_CODE (t)]);\n+      *non_constant_p = true;\n+      break;\n+    }\n+\n+  if (r == error_mark_node)\n+    *non_constant_p = true;\n+\n+  if (*non_constant_p)\n+    return t;\n+  else\n+    return r;\n+}\n+\n+static tree\n+cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant)\n+{\n+  bool non_constant_p = false;\n+  tree r = cxx_eval_constant_expression (NULL, t, allow_non_constant,\n+\t\t\t\t\t false, &non_constant_p);\n+\n+  if (!non_constant_p && !reduced_constant_expression_p (r))\n+    {\n+      if (!allow_non_constant)\n+\terror (\"%qE is not a constant expression\", t);\n+      non_constant_p = true;\n+    }\n+\n+  if (non_constant_p && !allow_non_constant)\n+    return error_mark_node;\n+  else if (non_constant_p && TREE_CONSTANT (t))\n+    {\n+      /* This isn't actually constant, so unset TREE_CONSTANT.  */\n+      if (EXPR_P (t) || TREE_CODE (t) == CONSTRUCTOR)\n+\tr = copy_node (t);\n+      else\n+\tr = build_nop (TREE_TYPE (t), t);\n+      TREE_CONSTANT (r) = false;\n+      return r;\n+    }\n+  else if (non_constant_p || r == t)\n+    return t;\n+  else if (TREE_CODE (r) == CONSTRUCTOR && CLASS_TYPE_P (TREE_TYPE (r)))\n+    {\n+      if (TREE_CODE (t) == TARGET_EXPR\n+\t  && TARGET_EXPR_INITIAL (t) == r)\n+\treturn t;\n+      else\n+\t{\n+\t  r = get_target_expr (r);\n+\t  TREE_CONSTANT (r) = true;\n+\t  return r;\n+\t}\n+    }\n+  else\n+    return r;\n+}\n+\n+/* If T represents a constant expression returns its reduced value.\n+   Otherwise return error_mark_node.  If T is dependent, then\n+   return NULL.  */\n+\n+tree\n+cxx_constant_value (tree t)\n+{\n+  return cxx_eval_outermost_constant_expr (t, false);\n+}\n+\n+/* If T is a constant expression, returns its reduced value.\n+   Otherwise, if T does not have TREE_CONSTANT set, returns T.\n+   Otherwise, returns a version of T without TREE_CONSTANT.  */\n+\n+tree\n+maybe_constant_value (tree t)\n+{\n+  tree r;\n+\n+  if (type_dependent_expression_p (t)\n+      /* FIXME shouldn't check value-dependence first; see comment before\n+\t value_dependent_expression_p.  */\n+      || value_dependent_expression_p (t))\n+    return t;\n+\n+  r = cxx_eval_outermost_constant_expr (t, true);\n+#ifdef ENABLE_CHECKING\n+  /* cp_tree_equal looks through NOPs, so allow them.  */\n+  gcc_assert (r == t\n+\t      || CONVERT_EXPR_P (t)\n+\t      || (TREE_CONSTANT (t) && !TREE_CONSTANT (r))\n+\t      || !cp_tree_equal (r, t));\n+#endif\n+  return r;\n+}\n+\n+/* Like maybe_constant_value, but returns a CONSTRUCTOR directly, rather\n+   than wrapped in a TARGET_EXPR.  */\n+\n+tree\n+maybe_constant_init (tree t)\n+{\n+  t = maybe_constant_value (t);\n+  if (TREE_CODE (t) == TARGET_EXPR)\n+    {\n+      tree init = TARGET_EXPR_INITIAL (t);\n+      if (TREE_CODE (init) == CONSTRUCTOR\n+\t  && TREE_CONSTANT (init))\n+\tt = init;\n+    }\n+  return t;\n+}\n+\n /* Return true if the object referred to by REF has automatic or thread\n    local storage.  */\n "}]}