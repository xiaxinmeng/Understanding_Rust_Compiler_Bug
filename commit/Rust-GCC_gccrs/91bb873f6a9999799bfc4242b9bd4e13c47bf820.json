{"sha": "91bb873f6a9999799bfc4242b9bd4e13c47bf820", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiYjg3M2Y2YTk5OTk3OTliZmM0MjQyYjliZDRlMTNjNDdiZjgyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-08-25T12:23:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-08-25T12:23:51Z"}, "message": "reload.c (operands_match_p): Handle rtvecs.\n\n        * reload.c (operands_match_p): Handle rtvecs.\n        * i386.c (legitimate_pic_address_disp_p): New.\n        (legitimate_address_p): Use it.\n        (legitimize_pic_address): Use unspecs to represent @GOT and @GOTOFF.\n        Handle constant pool symbols just like statics.\n        (emit_pic_move): Use Pmode not SImode for clarity.\n        (output_pic_addr_const) [SYMBOL_REF]: Remove @GOT and @GOTOFF hacks.\n        [UNSPEC]: New, handling what we killed above.\n        [PLUS]: Detect and abort on invalid symbol arithmetic.\n        * i386.h (CONSTANT_ADDRESS_P): Remove HIGH.\n\nFrom-SVN: r21968", "tree": {"sha": "e0bd10855584387801668f18203fd9790527c2e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0bd10855584387801668f18203fd9790527c2e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91bb873f6a9999799bfc4242b9bd4e13c47bf820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bb873f6a9999799bfc4242b9bd4e13c47bf820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bb873f6a9999799bfc4242b9bd4e13c47bf820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bb873f6a9999799bfc4242b9bd4e13c47bf820/comments", "author": null, "committer": null, "parents": [{"sha": "264fac3496eefa6bcd2d82e9dd55b53ad5df545e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/264fac3496eefa6bcd2d82e9dd55b53ad5df545e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/264fac3496eefa6bcd2d82e9dd55b53ad5df545e"}], "stats": {"total": 316, "additions": 206, "deletions": 110}, "files": [{"sha": "4e1dd654b93454cb975499ed78b45ff3bdf2a357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91bb873f6a9999799bfc4242b9bd4e13c47bf820", "patch": "@@ -1,3 +1,17 @@\n+Tue Aug 25 12:23:20 PDT 1998  Richard Henderson  <rth@cygnus.com>\n+\n+        * reload.c (operands_match_p): Handle rtvecs.\n+\n+        * i386.c (legitimate_pic_address_disp_p): New.\n+        (legitimate_address_p): Use it.\n+        (legitimize_pic_address): Use unspecs to represent @GOT and @GOTOFF.\n+        Handle constant pool symbols just like statics.\n+        (emit_pic_move): Use Pmode not SImode for clarity.\n+        (output_pic_addr_const) [SYMBOL_REF]: Remove @GOT and @GOTOFF hacks.\n+        [UNSPEC]: New, handling what we killed above.\n+        [PLUS]: Detect and abort on invalid symbol arithmetic.\n+        * i386.h (CONSTANT_ADDRESS_P): Remove HIGH.\n+\n Tue Aug 25 12:02:23 1998  Mark Mitchell  <mark@markmitchell.com>\n \n \t* alias.c: Include output.h."}, {"sha": "b316130924076c9e4a9f84c952279c24d422bbdd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 172, "deletions": 105, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=91bb873f6a9999799bfc4242b9bd4e13c47bf820", "patch": "@@ -2507,6 +2507,37 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n+static int\n+legitimate_pic_address_disp_p (disp)\n+     register rtx disp;\n+{\n+  if (GET_CODE (disp) != CONST)\n+    return 0;\n+  disp = XEXP (disp, 0);\n+\n+  if (GET_CODE (disp) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (disp, 1)) != CONST_INT)\n+\treturn 0;\n+      disp = XEXP (disp, 0);\n+    }\n+\n+  if (GET_CODE (disp) != UNSPEC\n+      || XVECLEN (disp, 0) != 1)\n+    return 0;\n+\n+  /* Must be @GOT or @GOTOFF.  */\n+  if (XINT (disp, 1) != 6\n+      && XINT (disp, 1) != 7)\n+    return 0;\n+\n+  if (GET_CODE (XVECEXP (disp, 0, 0)) != SYMBOL_REF\n+      && GET_CODE (XVECEXP (disp, 0, 0)) != LABEL_REF)\n+    return 0;\n+\n+  return 1;\n+}\n+\n int\n legitimate_address_p (mode, addr, strict)\n      enum machine_mode mode;\n@@ -2668,20 +2699,10 @@ legitimate_address_p (mode, addr, strict)\n \t}\n     }\n \n-  /* Validate displacement\n-     Constant pool addresses must be handled special.  They are\n-     considered legitimate addresses, but only if not used with regs.\n-     When printed, the output routines know to print the reference with the\n-     PIC reg, even though the PIC reg doesn't appear in the RTL. */\n+  /* Validate displacement.  */\n   if (disp)\n     {\n-      if (GET_CODE (disp) == SYMBOL_REF\n-\t  && CONSTANT_POOL_ADDRESS_P (disp)\n-\t  && base == 0\n-\t  && indx == 0)\n-\t;\n-\n-      else if (!CONSTANT_ADDRESS_P (disp))\n+      if (!CONSTANT_ADDRESS_P (disp))\n \t{\n \t  ADDR_INVALID (\"Displacement is not valid.\\n\", disp);\n \t  return FALSE;\n@@ -2693,20 +2714,32 @@ legitimate_address_p (mode, addr, strict)\n \t  return FALSE;\n \t}\n \n-      else if (flag_pic && SYMBOLIC_CONST (disp)\n-\t       && base != pic_offset_table_rtx\n-\t       && (indx != pic_offset_table_rtx || scale != NULL_RTX))\n+      if (flag_pic && SYMBOLIC_CONST (disp))\n \t{\n-\t  ADDR_INVALID (\"Displacement is an invalid pic reference.\\n\", disp);\n-\t  return FALSE;\n+\t  if (! legitimate_pic_address_disp_p (disp))\n+\t    {\n+\t      ADDR_INVALID (\"Displacement is an invalid PIC construct.\\n\",\n+\t\t\t    disp);\n+\t      return FALSE;\n+\t    }\n+\n+\t  if (base != pic_offset_table_rtx\n+\t      && (indx != pic_offset_table_rtx || scale != NULL_RTX))\n+\t    {\n+\t      ADDR_INVALID (\"PIC displacement against invalid base.\\n\", disp);\n+\t      return FALSE;\n+\t    }\n \t}\n \n-      else if (HALF_PIC_P () && HALF_PIC_ADDRESS_P (disp)\n-\t       && (base != NULL_RTX || indx != NULL_RTX))\n+      else if (HALF_PIC_P ())\n \t{\n-\t  ADDR_INVALID (\"Displacement is an invalid half-pic reference.\\n\",\n-\t\t\tdisp);\n-\t  return FALSE;\n+\t  if (! HALF_PIC_ADDRESS_P (disp)\n+\t      || (base != NULL_RTX || indx != NULL_RTX))\n+\t    {\n+\t      ADDR_INVALID (\"Displacement is an invalid half-pic reference.\\n\",\n+\t\t\t    disp);\n+\t      return FALSE;\n+\t    }\n \t}\n     }\n \n@@ -2720,29 +2753,20 @@ legitimate_address_p (mode, addr, strict)\n /* Return a legitimate reference for ORIG (an address) using the\n    register REG.  If REG is 0, a new pseudo is generated.\n \n-   There are three types of references that must be handled:\n+   There are two types of references that must be handled:\n \n    1. Global data references must load the address from the GOT, via\n       the PIC reg.  An insn is emitted to do this load, and the reg is\n       returned.\n \n-   2. Static data references must compute the address as an offset\n-      from the GOT, whose base is in the PIC reg.  An insn is emitted to\n-      compute the address into a reg, and the reg is returned.  Static\n-      data objects have SYMBOL_REF_FLAG set to differentiate them from\n-      global data objects.\n-\n-   3. Constant pool addresses must be handled special.  They are\n-      considered legitimate addresses, but only if not used with regs.\n-      When printed, the output routines know to print the reference with the\n-      PIC reg, even though the PIC reg doesn't appear in the RTL.\n+   2. Static data references, constant pool addresses, and code labels\n+      compute the address as an offset from the GOT, whose base is in\n+      the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to\n+      differentiate them from global data objects.  The returned\n+      address is the PIC reg + an unspec constant.\n \n    GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC\n-   reg also appears in the address (except for constant pool references,\n-   noted above).\n-\n-   \"switch\" statements also require special handling when generating\n-   PIC code.  See comments by the `casesi' insn in i386.md for details.  */\n+   reg also appears in the address.  */\n \n rtx\n legitimize_pic_address (orig, reg)\n@@ -2751,60 +2775,99 @@ legitimize_pic_address (orig, reg)\n {\n   rtx addr = orig;\n   rtx new = orig;\n+  rtx base;\n \n-  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+  if (GET_CODE (addr) == LABEL_REF\n+      || (GET_CODE (addr) == SYMBOL_REF\n+\t  && (CONSTANT_POOL_ADDRESS_P (addr)\n+\t      || SYMBOL_REF_FLAG (addr))))\n     {\n-      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n-\treg = new = orig;\n-      else\n-\t{\n-\t  if (reg == 0)\n-\t    reg = gen_reg_rtx (Pmode);\n+      /* This symbol may be referenced via a displacement from the PIC\n+\t base address (@GOTOFF).  */\n \n-\t  if ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FLAG (addr))\n-\t      || GET_CODE (addr) == LABEL_REF)\n-\t    new = gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig);\n-\t  else\n-\t    new = gen_rtx_MEM (Pmode,\n-\t\t\t   gen_rtx (PLUS, Pmode, pic_offset_table_rtx, orig));\n+      current_function_uses_pic_offset_table = 1;\n+      new = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, addr), 7);\n+      new = gen_rtx_CONST (VOIDmode, new);\n+      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \n+      if (reg != 0)\n+\t{\n \t  emit_move_insn (reg, new);\n+\t  new = reg;\n \t}\n-      current_function_uses_pic_offset_table = 1;\n-      return reg;\n     }\n-\n-  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n+  else if (GET_CODE (addr) == SYMBOL_REF)\n     {\n-      rtx base;\n+      /* This symbol must be referenced via a load from the\n+\t Global Offset Table (@GOT). */\n+\n+      current_function_uses_pic_offset_table = 1;\n+      new = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, addr), 6);\n+      new = gen_rtx_CONST (VOIDmode, new);\n+      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n+      new = gen_rtx_MEM (Pmode, new);\n+      RTX_UNCHANGING_P (new) = 1;\n \n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+      emit_move_insn (reg, new);\n+      new = reg;\n+    }      \n+  else\n+    {\n       if (GET_CODE (addr) == CONST)\n \t{\n \t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) != PLUS)\n-\t    abort ();\n+\t  if (GET_CODE (addr) == UNSPEC)\n+\t    {\n+\t      /* Check that the unspec is one of the ones we generate?  */\n+\t    }\n+\t  else if (GET_CODE (addr) != PLUS)\n+\t    abort();\n \t}\n+      if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n+\n+\t  /* Check first to see if this is a constant offset from a @GOTOFF\n+\t     symbol reference.  */\n+\t  if ((GET_CODE (op0) == LABEL_REF\n+\t       || (GET_CODE (op0) == SYMBOL_REF\n+\t\t   && (CONSTANT_POOL_ADDRESS_P (op0)\n+\t\t       || SYMBOL_REF_FLAG (op0))))\n+\t      && GET_CODE (op1) == CONST_INT)\n+\t    {\n+\t      current_function_uses_pic_offset_table = 1;\n+\t      new = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, op0), 7);\n+\t      new = gen_rtx_PLUS (VOIDmode, new, op1);\n+\t      new = gen_rtx_CONST (VOIDmode, new);\n+\t      new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new);\n \n-      if (XEXP (addr, 0) == pic_offset_table_rtx)\n-\treturn orig;\n-\n-      if (reg == 0)\n-\treg = gen_reg_rtx (Pmode);\n-\n-      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-      addr = legitimize_pic_address (XEXP (addr, 1),\n-\t\t\t\t     base == reg ? NULL_RTX : reg);\n-\n-      if (GET_CODE (addr) == CONST_INT)\n-\treturn plus_constant (base, INTVAL (addr));\n+\t      if (reg != 0)\n+\t\t{\n+\t\t  emit_move_insn (reg, new);\n+\t\t  new = reg;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      base = legitimize_pic_address (XEXP (addr, 0), reg);\n+\t      new  = legitimize_pic_address (XEXP (addr, 1),\n+\t\t\t\t\t     base == reg ? NULL_RTX : reg);\n \n-      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n-\t{\n-\t  base = gen_rtx (PLUS, Pmode, base, XEXP (addr, 0));\n-\t  addr = XEXP (addr, 1);\n+\t      if (GET_CODE (new) == CONST_INT)\n+\t\tnew = plus_constant (base, INTVAL (new));\n+\t      else\n+\t\t{\n+\t\t  if (GET_CODE (new) == PLUS && CONSTANT_P (XEXP (new, 1)))\n+\t\t    {\n+\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new, 0));\n+\t\t      new = XEXP (new, 1);\n+\t\t    }\n+\t\t  new = gen_rtx_PLUS (Pmode, base, new);\n+\t\t}\n+\t    }\n \t}\n-\n-      return gen_rtx (PLUS, Pmode, base, addr);\n     }\n   return new;\n }\n@@ -2819,7 +2882,7 @@ emit_pic_move (operands, mode)\n   rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n \n   if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n-    operands[1] = force_reg (SImode, operands[1]);\n+    operands[1] = force_reg (Pmode, operands[1]);\n   else\n     operands[1] = legitimize_pic_address (operands[1], temp);\n }\n@@ -3032,31 +3095,14 @@ output_pic_addr_const (file, x, code)\n       break;\n \n     case SYMBOL_REF:\n-    case LABEL_REF:\n-      if (GET_CODE (x) == SYMBOL_REF)\n-\tassemble_name (file, XSTR (x, 0));\n-      else\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"L\",\n-\t\t\t\t       CODE_LABEL_NUMBER (XEXP (x, 0)));\n-\t  assemble_name (asm_out_file, buf);\n-\t}\n-\n-      if (code == 'X')\n-\t; /* No suffix, dammit. */\n-      else if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n-\tfprintf (file, \"@GOTOFF(%%ebx)\");\n-      else if (code == 'P')\n-\tfprintf (file, \"@PLT\");\n-      else if (GET_CODE (x) == LABEL_REF)\n-\tfprintf (file, \"@GOTOFF\");\n-      else if (! SYMBOL_REF_FLAG (x))\n-\tfprintf (file, \"@GOT\");\n-      else\n-\tfprintf (file, \"@GOTOFF\");\n-\n+      assemble_name (file, XSTR (x, 0));\n+      if (code == 'P' && ! SYMBOL_REF_FLAG (x))\n+\tfputs (\"@PLT\", file);\n       break;\n \n+    case LABEL_REF:\n+      x = XEXP (x, 0);\n+      /* FALLTHRU */\n     case CODE_LABEL:\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n       assemble_name (asm_out_file, buf);\n@@ -3094,17 +3140,17 @@ output_pic_addr_const (file, x, code)\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \t{\n \t  output_pic_addr_const (file, XEXP (x, 0), code);\n-\t  if (INTVAL (XEXP (x, 1)) >= 0)\n-\t    fprintf (file, \"+\");\n+\t  fprintf (file, \"+\");\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n \t}\n-      else\n+      else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n-\t  if (INTVAL (XEXP (x, 0)) >= 0)\n-\t    fprintf (file, \"+\");\n+\t  fprintf (file, \"+\");\n \t  output_pic_addr_const (file, XEXP (x, 0), code);\n \t}\n+      else\n+\tabort ();\n       break;\n \n     case MINUS:\n@@ -3113,6 +3159,27 @@ output_pic_addr_const (file, x, code)\n       output_pic_addr_const (file, XEXP (x, 1), code);\n       break;\n \n+     case UNSPEC:\n+       if (XVECLEN (x, 0) != 1)\n+ \tabort ();\n+       output_pic_addr_const (file, XVECEXP (x, 0, 0), code);\n+       switch (XINT (x, 1))\n+ \t{\n+ \tcase 6:\n+ \t  fputs (\"@GOT\", file);\n+ \t  break;\n+ \tcase 7:\n+ \t  fputs (\"@GOTOFF\", file);\n+ \t  break;\n+ \tcase 8:\n+ \t  fputs (\"@PLT\", file);\n+ \t  break;\n+ \tdefault:\n+ \t  output_operand_lossage (\"invalid UNSPEC as operand\");\n+ \t  break;\n+ \t}\n+       break;\n+\n     default:\n       output_operand_lossage (\"invalid expression as operand\");\n     }"}, {"sha": "75e0298885d38346ebabd5a04426aa30cad3e157", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=91bb873f6a9999799bfc4242b9bd4e13c47bf820", "patch": "@@ -1703,10 +1703,9 @@ do {\t\t\t\t\t\t\\\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */"}, {"sha": "e65ca1c019ce5747b079984ba7551ab76e34ad7c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=91bb873f6a9999799bfc4242b9bd4e13c47bf820", "patch": "@@ -64,6 +64,9 @@\n ;;    prevent insns referencing it being scheduled across the initial\n ;;    decrement of the stack pointer.\n ;; 5  This is a `bsf' operation.\n+;; 6  This is the @GOT offset of a PIC address.\n+;; 7  This is the @GOTOFF offset of a PIC address.\n+;; 8  This is a reference to a symbol's @PLT address.\n \f\n ;; This shadows the processor_type enumeration, so changes must be made\n ;; to i386.h at the same time."}, {"sha": "d3dc14f69308cf22f81bbec92c03e11d2009d882", "filename": "gcc/reload.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bb873f6a9999799bfc4242b9bd4e13c47bf820/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=91bb873f6a9999799bfc4242b9bd4e13c47bf820", "patch": "@@ -2031,7 +2031,7 @@ operands_match_p (x, y)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      int val;\n+      int val, j;\n       switch (fmt[i])\n \t{\n \tcase 'w':\n@@ -2057,6 +2057,19 @@ operands_match_p (x, y)\n \tcase '0':\n \t  break;\n \n+\tcase 'E':\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; --j)\n+\t    {\n+\t      val = operands_match_p (XVECEXP (x, i, j), XVECEXP (y, i, j));\n+\t      if (val == 0)\n+\t\treturn 0;\n+\t      if (val == 2)\n+\t\tsuccess_2 = 1;\n+\t    }\n+\t  break;\n+\n \t  /* It is believed that rtx's at this level will never\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */"}]}