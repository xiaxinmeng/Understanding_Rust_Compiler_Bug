{"sha": "d281492de84960b5885f88fffeeb226650f5141d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4MTQ5MmRlODQ5NjBiNTg4NWY4OGZmZmVlYjIyNjY1MGY1MTQxZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-12T07:54:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-12T07:54:23Z"}, "message": "Support multiple operand counts for .md @ patterns\n\nThis patch extends the support for \"@...\" pattern names so that\nthe patterns can have different numbers of operands.  This allows\nthings like binary and ternary operations to be handled in a\nconsistent way, a bit like optabs.  The generators assert that\nthe number of operands passed is correct for the underlying\ninstruction.\n\nAlso, replace_operands_with_dups iterated over the old rtx format\neven after having decided to do a replacement, which broke with\nmatch_operator.\n\n2019-07-12  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/md.texi: Document that @ patterns can have different\n\tnumbers of operands.\n\t* genemit.c (handle_overloaded_gen): Handle this case.\n\t* genopinit.c (handle_overloaded_gen): Likewise.\n\t* gensupport.c (replace_operands_with_dups): Iterate over\n\tthe new rtx's format rather than the old one's.\n\nFrom-SVN: r273432", "tree": {"sha": "28304a490e6a430efab5d43f9479dbef727543b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28304a490e6a430efab5d43f9479dbef727543b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d281492de84960b5885f88fffeeb226650f5141d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d281492de84960b5885f88fffeeb226650f5141d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d281492de84960b5885f88fffeeb226650f5141d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d281492de84960b5885f88fffeeb226650f5141d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fdd6f0412922eb7438cbbadbb805fce8cc77485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fdd6f0412922eb7438cbbadbb805fce8cc77485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fdd6f0412922eb7438cbbadbb805fce8cc77485"}], "stats": {"total": 147, "additions": 91, "deletions": 56}, "files": [{"sha": "0894db7f0d30a80551926841e6db98766a89dac8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d281492de84960b5885f88fffeeb226650f5141d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d281492de84960b5885f88fffeeb226650f5141d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d281492de84960b5885f88fffeeb226650f5141d", "patch": "@@ -1,3 +1,12 @@\n+2019-07-12  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi: Document that @ patterns can have different\n+\tnumbers of operands.\n+\t* genemit.c (handle_overloaded_gen): Handle this case.\n+\t* genopinit.c (handle_overloaded_gen): Likewise.\n+\t* gensupport.c (replace_operands_with_dups): Iterate over\n+\tthe new rtx's format rather than the old one's.\n+\n 2019-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_ORDER."}, {"sha": "af216da6768807973215e9761d54da5fee2970dd", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d281492de84960b5885f88fffeeb226650f5141d", "patch": "@@ -11381,4 +11381,13 @@ name and same types of iterator.  For example:\n would produce a single set of functions that handles both\n @code{INTEGER_MODES} and @code{FLOAT_MODES}.\n \n+It is also possible for these @samp{@@} patterns to have different\n+numbers of operands from each other.  For example, patterns with\n+a binary rtl code might take three operands (one output and two inputs)\n+while patterns with a ternary rtl code might take four operands (one\n+output and three inputs).  This combination would produce separate\n+@samp{maybe_gen_@var{name}} and @samp{gen_@var{name}} functions for\n+each operand count, but it would still produce a single\n+@samp{maybe_code_for_@var{name}} and a single @samp{code_for_@var{name}}.\n+\n @end ifset"}, {"sha": "3ff819720ec6d7d90e5407bf7065544c5c65d84f", "filename": "gcc/genemit.c", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=d281492de84960b5885f88fffeeb226650f5141d", "patch": "@@ -811,42 +811,45 @@ handle_overloaded_code_for (overloaded_name *oname)\n static void\n handle_overloaded_gen (overloaded_name *oname)\n {\n+  unsigned HOST_WIDE_INT seen = 0;\n   /* All patterns must have the same number of operands.  */\n-  pattern_stats stats;\n-  get_pattern_stats (&stats, XVEC (oname->first_instance->insn, 1));\n   for (overloaded_instance *instance = oname->first_instance->next;\n        instance; instance = instance->next)\n     {\n-      pattern_stats stats2;\n-      get_pattern_stats (&stats2, XVEC (instance->insn, 1));\n-      if (stats.num_generator_args != stats2.num_generator_args)\n-\tfatal_at (get_file_location (instance->insn),\n-\t\t  \"inconsistent number of operands for '%s'; \"\n-\t\t  \"this instance has %d, but previous instances had %d\",\n-\t\t  oname->name, stats2.num_generator_args,\n-\t\t  stats.num_generator_args);\n+      pattern_stats stats;\n+      get_pattern_stats (&stats, XVEC (instance->insn, 1));\n+      unsigned HOST_WIDE_INT mask\n+\t= HOST_WIDE_INT_1U << stats.num_generator_args;\n+      if (seen & mask)\n+\tcontinue;\n+\n+      seen |= mask;\n+\n+      /* Print the function prototype.  */\n+      printf (\"\\nrtx\\nmaybe_gen_%s (\", oname->name);\n+      print_overload_arguments (oname);\n+      for (int i = 0; i < stats.num_generator_args; ++i)\n+\tprintf (\", rtx x%d\", i);\n+      printf (\")\\n{\\n\");\n+\n+      /* Use maybe_code_for_*, instead of duplicating the selection\n+\t logic here.  */\n+      printf (\"  insn_code code = maybe_code_for_%s (\", oname->name);\n+      for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+\tprintf (\"%sarg%d\", i == 0 ? \"\" : \", \", i);\n+      printf (\");\\n\"\n+\t      \"  if (code != CODE_FOR_nothing)\\n\"\n+\t      \"    {\\n\"\n+\t      \"      gcc_assert (insn_data[code].n_generator_args == %d);\\n\"\n+\t      \"      return GEN_FCN (code) (\", stats.num_generator_args);\n+      for (int i = 0; i < stats.num_generator_args; ++i)\n+\tprintf (\"%sx%d\", i == 0 ? \"\" : \", \", i);\n+      printf (\");\\n\"\n+\t      \"    }\\n\"\n+\t      \"  else\\n\"\n+\t      \"    return NULL_RTX;\\n\"\n+\t      \"}\\n\");\n     }\n-\n-  /* Print the function prototype.  */\n-  printf (\"\\nrtx\\nmaybe_gen_%s (\", oname->name);\n-  print_overload_arguments (oname);\n-  for (int i = 0; i < stats.num_generator_args; ++i)\n-    printf (\", rtx x%d\", i);\n-  printf (\")\\n{\\n\");\n-\n-  /* Use maybe_code_for_*, instead of duplicating the selection logic here.  */\n-  printf (\"  insn_code code = maybe_code_for_%s (\", oname->name);\n-  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n-    printf (\"%sarg%d\", i == 0 ? \"\" : \", \", i);\n-  printf (\");\\n\"\n-\t  \"  if (code != CODE_FOR_nothing)\\n\"\n-\t  \"    return GEN_FCN (code) (\");\n-  for (int i = 0; i < stats.num_generator_args; ++i)\n-    printf (\"%sx%d\", i == 0 ? \"\" : \", \", i);\n-  printf (\");\\n\"\n-\t  \"  else\\n\"\n-\t  \"    return NULL_RTX;\\n\"\n-\t  \"}\\n\");\n }\n \n int"}, {"sha": "1dd1d82d0485c5d11b4bc9085bf99ccb8bbb992b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=d281492de84960b5885f88fffeeb226650f5141d", "patch": "@@ -134,31 +134,43 @@ handle_overloaded_code_for (FILE *file, overloaded_name *oname)\n static void\n handle_overloaded_gen (FILE *file, overloaded_name *oname)\n {\n-  pattern_stats stats;\n-  get_pattern_stats (&stats, XVEC (oname->first_instance->insn, 1));\n-\n-  fprintf (file, \"\\nextern rtx maybe_gen_%s (\", oname->name);\n-  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n-    fprintf (file, \"%s%s\", i == 0 ? \"\" : \", \", oname->arg_types[i]);\n-  for (int i = 0; i < stats.num_generator_args; ++i)\n-    fprintf (file, \", rtx\");\n-  fprintf (file, \");\\n\");\n-\n-  fprintf (file, \"inline rtx\\ngen_%s (\", oname->name);\n-  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n-    fprintf (file, \"%s%s arg%d\", i == 0 ? \"\" : \", \", oname->arg_types[i], i);\n-  for (int i = 0; i < stats.num_generator_args; ++i)\n-    fprintf (file, \", rtx x%d\", i);\n-  fprintf (file, \")\\n{\\n  rtx res = maybe_gen_%s (\", oname->name);\n-  for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n-    fprintf (file, \"%sarg%d\", i == 0 ? \"\" : \", \", i);\n-  for (int i = 0; i < stats.num_generator_args; ++i)\n-    fprintf (file, \", x%d\", i);\n-  fprintf (file,\n-\t   \");\\n\"\n-\t   \"  gcc_assert (res);\\n\"\n-\t   \"  return res;\\n\"\n-\t   \"}\\n\");\n+  unsigned HOST_WIDE_INT seen = 0;\n+  for (overloaded_instance *instance = oname->first_instance->next;\n+       instance; instance = instance->next)\n+    {\n+      pattern_stats stats;\n+      get_pattern_stats (&stats, XVEC (instance->insn, 1));\n+      unsigned HOST_WIDE_INT mask\n+\t= HOST_WIDE_INT_1U << stats.num_generator_args;\n+      if (seen & mask)\n+\tcontinue;\n+\n+      seen |= mask;\n+\n+      fprintf (file, \"\\nextern rtx maybe_gen_%s (\", oname->name);\n+      for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+\tfprintf (file, \"%s%s\", i == 0 ? \"\" : \", \", oname->arg_types[i]);\n+      for (int i = 0; i < stats.num_generator_args; ++i)\n+\tfprintf (file, \", rtx\");\n+      fprintf (file, \");\\n\");\n+\n+      fprintf (file, \"inline rtx\\ngen_%s (\", oname->name);\n+      for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+\tfprintf (file, \"%s%s arg%d\", i == 0 ? \"\" : \", \",\n+\t\t oname->arg_types[i], i);\n+      for (int i = 0; i < stats.num_generator_args; ++i)\n+\tfprintf (file, \", rtx x%d\", i);\n+      fprintf (file, \")\\n{\\n  rtx res = maybe_gen_%s (\", oname->name);\n+      for (unsigned int i = 0; i < oname->arg_types.length (); ++i)\n+\tfprintf (file, \"%sarg%d\", i == 0 ? \"\" : \", \", i);\n+      for (int i = 0; i < stats.num_generator_args; ++i)\n+\tfprintf (file, \", x%d\", i);\n+      fprintf (file,\n+\t       \");\\n\"\n+\t       \"  gcc_assert (res);\\n\"\n+\t       \"  return res;\\n\"\n+\t       \"}\\n\");\n+    }\n }\n \n int"}, {"sha": "1aab711990184346eda51391c01b37aeb35b7d73", "filename": "gcc/gensupport.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d281492de84960b5885f88fffeeb226650f5141d/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=d281492de84960b5885f88fffeeb226650f5141d", "patch": "@@ -500,12 +500,14 @@ replace_operands_with_dups (rtx x)\n     {\n       newx = rtx_alloc (MATCH_DUP);\n       XINT (newx, 0) = XINT (x, 0);\n+      x = newx;\n     }\n   else if (GET_CODE (x) == MATCH_OPERATOR)\n     {\n       newx = rtx_alloc (MATCH_OP_DUP);\n       XINT (newx, 0) = XINT (x, 0);\n       XVEC (newx, 1) = XVEC (x, 2);\n+      x = newx;\n     }\n   else\n     newx = shallow_copy_rtx (x);"}]}