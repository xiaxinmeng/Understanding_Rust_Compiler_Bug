{"sha": "71c92d177874fee7e5da738a30523edb83cf29c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFjOTJkMTc3ODc0ZmVlN2U1ZGE3MzhhMzA1MjNlZGI4M2NmMjljOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-10-16T13:10:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-10-16T13:10:20Z"}, "message": "re PR tree-optimization/50596 (Problems in vectorization of condition expression)\n\n\tPR tree-optimization/50596\n\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 7.\n\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n\tvect_recog_bool_pattern.\n\t(check_bool_pattern, adjust_bool_pattern_cast,\n\tadjust_bool_pattern, vect_recog_bool_pattern): New functions.\n\n\t* gcc.dg/vect/vect-cond-9.c: New test.\n\nFrom-SVN: r180057", "tree": {"sha": "75f65f215df73a3f540b68ea3c063863d2773e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75f65f215df73a3f540b68ea3c063863d2773e2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71c92d177874fee7e5da738a30523edb83cf29c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c92d177874fee7e5da738a30523edb83cf29c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c92d177874fee7e5da738a30523edb83cf29c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c92d177874fee7e5da738a30523edb83cf29c9/comments", "author": null, "committer": null, "parents": [{"sha": "ea10ca9c757c2adeaa7e28b8aa096d4b88bb4a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea10ca9c757c2adeaa7e28b8aa096d4b88bb4a11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea10ca9c757c2adeaa7e28b8aa096d4b88bb4a11"}], "stats": {"total": 611, "additions": 604, "deletions": 7}, "files": [{"sha": "8c5017d95fd222fa6b20dde2995aac1d80eb8a94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71c92d177874fee7e5da738a30523edb83cf29c9", "patch": "@@ -1,4 +1,15 @@\n-2011-10-16 Ira Rosen  <ira.rosen@linaro.org>\n+2011-10-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* tree-vectorizer.h (NUM_PATTERNS): Increase to 7.\n+\t* tree-vect-patterns.c (vect_vect_recog_func_ptrs): Add\n+\tvect_recog_bool_pattern.\n+\t(check_bool_pattern, adjust_bool_pattern_cast,\n+\tadjust_bool_pattern, vect_recog_bool_pattern): New functions.\n+\n+\t* gcc.dg/vect/vect-cond-9.c: New test.\n+\n+2011-10-16  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* tree-vect-stmts.c (vectorizable_load): For SLP without permutation\n \ttreat the first load of the node as the first element in its"}, {"sha": "653453a77ed601610a7acacb1cd77b2987eee1d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71c92d177874fee7e5da738a30523edb83cf29c9", "patch": "@@ -1,4 +1,9 @@\n-2011-10-16 Ira Rosen  <ira.rosen@linaro.org>\n+2011-10-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* gcc.dg/vect/vect-cond-9.c: New test.\n+\n+2011-10-16  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* gcc.dg/vect/bb-slp-29.c: New test.\n "}, {"sha": "cfa0363b2fe8e68fb6091e7a1197b07cf146fe7b", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-9.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-9.c?ref=71c92d177874fee7e5da738a30523edb83cf29c9", "patch": "@@ -0,0 +1,200 @@\n+/* { dg-require-effective-target vect_cond_mixed } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+float a[N], b[N], c[N], d[N];\n+int j[N];\n+unsigned char k[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      unsigned int x = a[i] < b[i] ? -1 : 0;\n+      unsigned int y = c[i] < d[i] ? -1 : 0;\n+      j[i] = (x & y) >> 31;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      j[i] = x & y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    j[i] = (a[i] < b[i]) & (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      k[i] = x & y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = (a[i] < b[i]) & (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f6 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      unsigned int x = a[i] < b[i] ? -1 : 0;\n+      unsigned int y = c[i] < d[i] ? -1 : 0;\n+      j[i] = (x | y) >> 31;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f7 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      j[i] = x | y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    j[i] = (a[i] < b[i]) | (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f9 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      k[i] = x | y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f10 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = (a[i] < b[i]) | (c[i] < d[i]);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); a[i] = - i - 1; b[i] = i + 1; break;\n+\tcase 1: a[i] = 0; b[i] = 0; break;\n+\tcase 2: a[i] = i + 1; b[i] = - i - 1; break;\n+\tcase 3: a[i] = i; b[i] = i + 7; break;\n+\tcase 4: a[i] = i; b[i] = i; break;\n+\tcase 5: a[i] = i + 16; b[i] = i + 3; break;\n+\tcase 6: a[i] = - i - 5; b[i] = - i; break;\n+\tcase 7: a[i] = - i; b[i] = - i; break;\n+\tcase 8: a[i] = - i; b[i] = - i - 7; break;\n+\t}\n+    }\n+  for (i = 0; i < N; i++)\n+    {\n+      switch ((i / 9) % 3)\n+\t{\n+\tcase 0: c[i] = a[i / 9]; d[i] = b[i / 9]; break;\n+\tcase 1: c[i] = a[i / 9 + 3]; d[i] = b[i / 9 + 3]; break;\n+\tcase 2: c[i] = a[i / 9 + 6]; d[i] = b[i / 9 + 6]; break;\n+\t}\n+    }\n+  f1 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f3 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, -6, sizeof (k));\n+  f5 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, -6, sizeof (k));\n+  f6 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f7 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f8 ();\n+  for (i = 0; i < N; i++)\n+    if (j[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (j, -6, sizeof (j));\n+  f9 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, -6, sizeof (k));\n+  f10 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, -6, sizeof (k));\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"note: vectorized 1 loops\" 10 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b43ccc3de59abd5569432114dc4ae7f8764ebf64", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 385, "deletions": 4, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=71c92d177874fee7e5da738a30523edb83cf29c9", "patch": "@@ -51,13 +51,15 @@ static gimple vect_recog_over_widening_pattern (VEC (gimple, heap) **, tree *,\n                                                  tree *);\n static gimple vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **,\n \t\t\t\t\t\t  tree *, tree *);\n+static gimple vect_recog_bool_pattern (VEC (gimple, heap) **, tree *, tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n \tvect_recog_dot_prod_pattern,\n \tvect_recog_pow_pattern,\n \tvect_recog_over_widening_pattern,\n-\tvect_recog_mixed_size_cond_pattern};\n+\tvect_recog_mixed_size_cond_pattern,\n+\tvect_recog_bool_pattern};\n \n \n /* Function widened_name_p\n@@ -1068,10 +1070,8 @@ vect_operation_fits_smaller_type (gimple stmt, tree def, tree *new_type,\n    constants.\n    Check if S3 and S4 can be done on a smaller type than 'TYPE', it can either\n    be 'type' or some intermediate type.  For now, we expect S5 to be a type\n-   demotion operation.  We also check that S3 and S4 have only one use.\n-.\n+   demotion operation.  We also check that S3 and S4 have only one use.  */\n \n-*/\n static gimple\n vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n                                   tree *type_in, tree *type_out)\n@@ -1333,6 +1333,387 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n }\n \n \n+/* Helper function of vect_recog_bool_pattern.  Called recursively, return\n+   true if bool VAR can be optimized that way.  */\n+\n+static bool\n+check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n+{\n+  gimple def_stmt;\n+  enum vect_def_type dt;\n+  tree def, rhs1;\n+  enum tree_code rhs_code;\n+\n+  if (!vect_is_simple_use (var, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+    return false;\n+\n+  if (dt != vect_internal_def)\n+    return false;\n+\n+  if (!is_gimple_assign (def_stmt))\n+    return false;\n+\n+  if (!has_single_use (def))\n+    return false;\n+\n+  rhs1 = gimple_assign_rhs1 (def_stmt);\n+  rhs_code = gimple_assign_rhs_code (def_stmt);\n+  switch (rhs_code)\n+    {\n+    case SSA_NAME:\n+      return check_bool_pattern (rhs1, loop_vinfo);\n+\n+    CASE_CONVERT:\n+      if ((TYPE_PRECISION (TREE_TYPE (rhs1)) != 1\n+\t   || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n+\t  && TREE_CODE (TREE_TYPE (rhs1)) != BOOLEAN_TYPE)\n+\treturn false;\n+      return check_bool_pattern (rhs1, loop_vinfo);\n+\n+    case BIT_NOT_EXPR:\n+      return check_bool_pattern (rhs1, loop_vinfo);\n+\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      if (!check_bool_pattern (rhs1, loop_vinfo))\n+\treturn false;\n+      return check_bool_pattern (gimple_assign_rhs2 (def_stmt), loop_vinfo);\n+\n+    default:\n+      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+\t{\n+\t  tree vecitype, comp_vectype;\n+\n+\t  comp_vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t  if (comp_vectype == NULL_TREE)\n+\t    return false;\n+\n+\t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE)\n+\t    {\n+\t      enum machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n+\t      tree itype\n+\t\t= build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 0);\n+\t      vecitype = get_vectype_for_scalar_type (itype);\n+\t      if (vecitype == NULL_TREE)\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    vecitype = comp_vectype;\n+\t  return expand_vec_cond_expr_p (vecitype, comp_vectype);\n+\t}\n+      return false;\n+    }\n+}\n+\n+\n+/* Helper function of adjust_bool_pattern.  Add a cast to TYPE to a previous\n+   stmt (SSA_NAME_DEF_STMT of VAR) by moving the COND_EXPR from RELATED_STMT\n+   to PATTERN_DEF_STMT and adding a cast as RELATED_STMT.  */\n+\n+static tree\n+adjust_bool_pattern_cast (tree type, tree var)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (SSA_NAME_DEF_STMT (var));\n+  gimple cast_stmt, pattern_stmt;\n+\n+  gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo));\n+  pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = pattern_stmt;\n+  cast_stmt\n+    = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t    gimple_assign_lhs (pattern_stmt),\n+\t\t\t\t    NULL_TREE);\n+  STMT_VINFO_RELATED_STMT (stmt_vinfo) = cast_stmt;\n+  return gimple_assign_lhs (cast_stmt);\n+}\n+\n+\n+/* Helper function of vect_recog_bool_pattern.  Do the actual transformations,\n+   recursively.  VAR is an SSA_NAME that should be transformed from bool\n+   to a wider integer type, OUT_TYPE is the desired final integer type of\n+   the whole pattern, TRUEVAL should be NULL unless optimizing\n+   BIT_AND_EXPR into a COND_EXPR with one integer from one of the operands\n+   in the then_clause, STMTS is where statements with added pattern stmts\n+   should be pushed to.  */\n+\n+static tree\n+adjust_bool_pattern (tree var, tree out_type, tree trueval,\n+\t\t     VEC (gimple, heap) **stmts)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  enum tree_code rhs_code, def_rhs_code;\n+  tree itype, cond_expr, rhs1, rhs2, irhs1, irhs2;\n+  location_t loc;\n+  gimple pattern_stmt, def_stmt;\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+  rhs2 = gimple_assign_rhs2 (stmt);\n+  rhs_code = gimple_assign_rhs_code (stmt);\n+  loc = gimple_location (stmt);\n+  switch (rhs_code)\n+    {\n+    case SSA_NAME:\n+    CASE_CONVERT:\n+      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+      itype = TREE_TYPE (irhs1);\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (SSA_NAME,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tirhs1, NULL_TREE);\n+      break;\n+\n+    case BIT_NOT_EXPR:\n+      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+      itype = TREE_TYPE (irhs1);\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (BIT_XOR_EXPR,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tirhs1, build_int_cst (itype, 1));\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      /* Try to optimize x = y & (a < b ? 1 : 0); into\n+\t x = (a < b ? y : 0);\n+\n+\t E.g. for:\n+\t   bool a_b, b_b, c_b;\n+\t   TYPE d_T;\n+\n+\t   S1  a_b = x1 CMP1 y1;\n+\t   S2  b_b = x2 CMP2 y2;\n+\t   S3  c_b = a_b & b_b;\n+\t   S4  d_T = (TYPE) c_b;\n+\n+\t we would normally emit:\n+\n+\t   S1'  a_T = x1 CMP1 y1 ? 1 : 0;\n+\t   S2'  b_T = x2 CMP2 y2 ? 1 : 0;\n+\t   S3'  c_T = a_T & b_T;\n+\t   S4'  d_T = c_T;\n+\n+\t but we can save one stmt by using the\n+\t result of one of the COND_EXPRs in the other COND_EXPR and leave\n+\t BIT_AND_EXPR stmt out:\n+\n+\t   S1'  a_T = x1 CMP1 y1 ? 1 : 0;\n+\t   S3'  c_T = x2 CMP2 y2 ? a_T : 0;\n+\t   S4'  f_T = c_T;\n+\n+\t At least when VEC_COND_EXPR is implemented using masks\n+\t cond ? 1 : 0 is as expensive as cond ? var : 0, in both cases it\n+\t computes the comparison masks and ands it, in one case with\n+\t all ones vector, in the other case with a vector register.\n+\t Don't do this for BIT_IOR_EXPR, because cond ? 1 : var; is\n+\t often more expensive.  */\n+      def_stmt = SSA_NAME_DEF_STMT (rhs2);\n+      def_rhs_code = gimple_assign_rhs_code (def_stmt);\n+      if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n+\t{\n+\t  tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+\t  if (TYPE_PRECISION (TREE_TYPE (irhs1))\n+\t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (def_rhs1))))\n+\t    {\n+\t      gimple tstmt;\n+\t      stmt_vec_info stmt_def_vinfo = vinfo_for_stmt (def_stmt);\n+\t      irhs2 = adjust_bool_pattern (rhs2, out_type, irhs1, stmts);\n+\t      tstmt = VEC_pop (gimple, *stmts);\n+\t      gcc_assert (tstmt == def_stmt);\n+\t      VEC_quick_push (gimple, *stmts, stmt);\n+\t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n+\t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n+\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_def_vinfo));\n+\t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n+\t      return irhs2;\n+\t    }\n+\t  else\n+\t    irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n+\t  goto and_ior_xor;\n+\t}\n+      def_stmt = SSA_NAME_DEF_STMT (rhs1);\n+      def_rhs_code = gimple_assign_rhs_code (def_stmt);\n+      if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n+\t{\n+\t  tree def_rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n+\t  if (TYPE_PRECISION (TREE_TYPE (irhs2))\n+\t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (def_rhs1))))\n+\t    {\n+\t      gimple tstmt;\n+\t      stmt_vec_info stmt_def_vinfo = vinfo_for_stmt (def_stmt);\n+\t      irhs1 = adjust_bool_pattern (rhs1, out_type, irhs2, stmts);\n+\t      tstmt = VEC_pop (gimple, *stmts);\n+\t      gcc_assert (tstmt == def_stmt);\n+\t      VEC_quick_push (gimple, *stmts, stmt);\n+\t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt))\n+\t\t= STMT_VINFO_RELATED_STMT (stmt_def_vinfo);\n+\t      gcc_assert (!STMT_VINFO_PATTERN_DEF_STMT (stmt_def_vinfo));\n+\t      STMT_VINFO_RELATED_STMT (stmt_def_vinfo) = NULL;\n+\t      return irhs1;\n+\t    }\n+\t  else\n+\t    irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+\t  goto and_ior_xor;\n+\t}\n+      /* FALLTHRU */\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      irhs1 = adjust_bool_pattern (rhs1, out_type, NULL_TREE, stmts);\n+      irhs2 = adjust_bool_pattern (rhs2, out_type, NULL_TREE, stmts);\n+    and_ior_xor:\n+      if (TYPE_PRECISION (TREE_TYPE (irhs1))\n+\t  != TYPE_PRECISION (TREE_TYPE (irhs2)))\n+\t{\n+\t  int prec1 = TYPE_PRECISION (TREE_TYPE (irhs1));\n+\t  int prec2 = TYPE_PRECISION (TREE_TYPE (irhs2));\n+\t  int out_prec = TYPE_PRECISION (out_type);\n+\t  if (absu_hwi (out_prec - prec1) < absu_hwi (out_prec - prec2))\n+\t    irhs2 = adjust_bool_pattern_cast (TREE_TYPE (irhs1), rhs2);\n+\t  else if (absu_hwi (out_prec - prec1) > absu_hwi (out_prec - prec2))\n+\t    irhs1 = adjust_bool_pattern_cast (TREE_TYPE (irhs2), rhs1);\n+\t  else\n+\t    {\n+\t      irhs1 = adjust_bool_pattern_cast (out_type, rhs1);\n+\t      irhs2 = adjust_bool_pattern_cast (out_type, rhs2);\n+\t    }\n+\t}\n+      itype = TREE_TYPE (irhs1);\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (rhs_code,\n+\t\t\t\t\tvect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\tirhs1, irhs2);\n+      break;\n+\n+    default:\n+      gcc_assert (TREE_CODE_CLASS (rhs_code) == tcc_comparison);\n+      if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n+\t  || TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n+\t{\n+\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n+\t  itype\n+\t    = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 0);\n+\t}\n+      else\n+\titype = TREE_TYPE (rhs1);\n+      cond_expr = build2_loc (loc, rhs_code, itype, rhs1, rhs2);\n+      if (trueval == NULL_TREE)\n+\ttrueval = build_int_cst (itype, 1);\n+      else\n+\tgcc_checking_assert (useless_type_conversion_p (itype,\n+\t\t\t\t\t\t\tTREE_TYPE (trueval)));\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops3 (COND_EXPR,\n+\t\t\t\t\t vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t\t cond_expr, trueval,\n+\t\t\t\t\t build_int_cst (itype, 0));\n+      break;\n+    }\n+\n+  VEC_safe_push (gimple, heap, *stmts, stmt);\n+  gimple_set_location (pattern_stmt, loc);\n+  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n+  return gimple_assign_lhs (pattern_stmt);\n+}\n+\n+\n+/* Function vect_recog_bool_pattern\n+\n+   Try to find pattern like following:\n+\n+     bool a_b, b_b, c_b, d_b, e_b;\n+     TYPE f_T;\n+   loop:\n+     S1  a_b = x1 CMP1 y1;\n+     S2  b_b = x2 CMP2 y2;\n+     S3  c_b = a_b & b_b;\n+     S4  d_b = x3 CMP3 y3;\n+     S5  e_b = c_b | d_b;\n+     S6  f_T = (TYPE) e_b;\n+\n+   where type 'TYPE' is an integral type.\n+\n+   Input:\n+\n+   * LAST_STMT: A stmt at the end from which the pattern\n+\t\tsearch begins, i.e. cast of a bool to\n+\t\tan integer type.\n+\n+   Output:\n+\n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the pattern.\n+\n+\tAssuming size of TYPE is the same as size of all comparisons\n+\t(otherwise some casts would be added where needed), the above\n+\tsequence we create related pattern stmts:\n+\tS1'  a_T = x1 CMP1 y1 ? 1 : 0;\n+\tS3'  c_T = x2 CMP2 y2 ? a_T : 0;\n+\tS4'  d_T = x3 CMP3 y3 ? 1 : 0;\n+\tS5'  e_T = c_T | d_T;\n+\tS6'  f_T = e_T;\n+\n+\tInstead of the above S3' we could emit:\n+\tS2'  b_T = x2 CMP2 y2 ? 1 : 0;\n+\tS3'  c_T = a_T | b_T;\n+\tbut the above is more efficient.  */\n+\n+static gimple\n+vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n+\t\t\t tree *type_out)\n+{\n+  gimple last_stmt = VEC_pop (gimple, *stmts);\n+  enum tree_code rhs_code;\n+  tree var, lhs, rhs, vectype;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  gimple pattern_stmt;\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  var = gimple_assign_rhs1 (last_stmt);\n+  lhs = gimple_assign_lhs (last_stmt);\n+\n+  if ((TYPE_PRECISION (TREE_TYPE (var)) != 1\n+       || !TYPE_UNSIGNED (TREE_TYPE (var)))\n+      && TREE_CODE (TREE_TYPE (var)) != BOOLEAN_TYPE)\n+    return NULL;\n+\n+  rhs_code = gimple_assign_rhs_code (last_stmt);\n+  if (CONVERT_EXPR_CODE_P (rhs_code))\n+    {\n+      if (TREE_CODE (TREE_TYPE (lhs)) != INTEGER_TYPE)\n+\treturn NULL;\n+      vectype = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+      if (vectype == NULL_TREE)\n+\treturn NULL;\n+\n+      if (!check_bool_pattern (var, loop_vinfo))\n+\treturn NULL;\n+\n+      rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n+      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+      if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+\tpattern_stmt\n+\t  = gimple_build_assign_with_ops (SSA_NAME, lhs, rhs, NULL_TREE);\n+      else\n+\tpattern_stmt\n+\t  = gimple_build_assign_with_ops (NOP_EXPR, lhs, rhs, NULL_TREE);\n+      *type_out = vectype;\n+      *type_in = vectype;\n+      VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+      return pattern_stmt;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+\n /* Mark statements that are involved in a pattern.  */\n \n static inline void"}, {"sha": "3b1ce52deb723575e16ba5540dae15255fcdacbd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c92d177874fee7e5da738a30523edb83cf29c9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=71c92d177874fee7e5da738a30523edb83cf29c9", "patch": "@@ -902,7 +902,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n-#define NUM_PATTERNS 6\n+#define NUM_PATTERNS 7\n void vect_pattern_recog (loop_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}