{"sha": "bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "node_id": "C_kwDOANBUbNoAKGJjMGQ3MDBiNTc0YTIyZjEyZGI3Zjc1ODdjZTg4NWY2NGViY2JmYjA", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-09-28T14:37:34Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-10-12T18:37:52Z"}, "message": "c++: Remove maybe-rvalue OR in implicit move\n\nThis patch removes the two-stage overload resolution when performing\nimplicit move, whereby the compiler does two separate overload resolutions:\none treating the operand as an rvalue, and then (if that resolution fails)\nanother one treating the operand as an lvalue.  In the standard this was\nintroduced via CWG 1579 and implemented in gcc in r251035.  In r11-2412,\nwe disabled the fallback OR in C++20 (but not in C++17).  Then C++23 P2266\nremoved the fallback overload resolution, and changed the implicit move rules\nonce again.  So we wound up with three different behaviors.\n\nThe two overload resolutions approach was complicated and quirky, so\nusers should transition to the newer model.  Removing the maybe-rvalue\nOR also allows us to simplify our code, for instance, now we can get\nrid of LOOKUP_PREFER_RVALUE altogether.\n\nThis change means that code that previously didn't compile in C++17 will\nnow compile, for example:\n\n  struct S1 { S1(S1 &&); };\n  struct S2 : S1 {};\n\n  S1\n  f (S2 s)\n  {\n    return s; // OK, derived-to-base, use S1::S1(S1&&)\n  }\n\nAnd conversely, code that used to work in C++17 may not compile anymore:\n\n  struct W {\n    W();\n  };\n\n  struct F {\n    F(W&);\n    F(W&&) = delete;\n  };\n\n  F fn ()\n  {\n    W w;\n    return w; // use w as rvalue -> use of deleted function F::F(W&&)\n  }\n\nI plan to add a note to porting_to.html.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (standard_conversion): Remove LOOKUP_PREFER_RVALUE code.\n\t(reference_binding): Honor clk_implicit_rval even pre-C++20.\n\t(implicit_conversion_1): Remove LOOKUP_PREFER_RVALUE code.\n\t(build_user_type_conversion_1): Likewise.\n\t(convert_like_internal): Likewise.\n\t(build_over_call): Likewise.\n\t* cp-tree.h (LOOKUP_PREFER_RVALUE): Remove.\n\t(LOOKUP_NO_NARROWING): Adjust definition.\n\t* except.cc (build_throw): Don't perform two overload resolutions.\n\t* typeck.cc (maybe_warn_pessimizing_move): Don't use\n\tLOOKUP_PREFER_RVALUE.\n\t(check_return_expr): Don't perform two overload resolutions.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/Wredundant-move10.C: Adjust dg-warning.\n\t* g++.dg/cpp0x/Wredundant-move7.C: Likewise.\n\t* g++.dg/cpp0x/move-return2.C: Remove dg-error.\n\t* g++.dg/cpp0x/move-return4.C: Likewise.\n\t* g++.dg/cpp0x/ref-qual20.C: Adjust expected return value.\n\t* g++.dg/cpp0x/move-return5.C: New test.", "tree": {"sha": "8c4ce2f50e04ceea8dc2b9dcb986c2ade856aa50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c4ce2f50e04ceea8dc2b9dcb986c2ade856aa50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c1a059101a3067d96211cbc4fae5905796d1db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c1a059101a3067d96211cbc4fae5905796d1db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0c1a059101a3067d96211cbc4fae5905796d1db"}], "stats": {"total": 138, "additions": 41, "deletions": 97}, "files": [{"sha": "b9c08d628bcdd84795efe93a30bb8a4e0156885c", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -1272,9 +1272,6 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t    }\n \t}\n       conv = build_conv (ck_rvalue, from, conv);\n-      if (flags & LOOKUP_PREFER_RVALUE)\n-\t/* Tell convert_like to set LOOKUP_PREFER_RVALUE.  */\n-\tconv->rvaluedness_matches_p = true;\n       /* If we're performing copy-initialization, remember to skip\n \t explicit constructors.  */\n       if (flags & LOOKUP_ONLYCONVERTING)\n@@ -1572,9 +1569,6 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t type.  A temporary object is created to hold the result of\n \t the conversion unless we're binding directly to a reference.  */\n       conv->need_temporary_p = !(flags & LOOKUP_NO_TEMP_BIND);\n-      if (flags & LOOKUP_PREFER_RVALUE)\n-\t/* Tell convert_like to set LOOKUP_PREFER_RVALUE.  */\n-\tconv->rvaluedness_matches_p = true;\n       /* If we're performing copy-initialization, remember to skip\n \t explicit constructors.  */\n       if (flags & LOOKUP_ONLYCONVERTING)\n@@ -1883,7 +1877,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n \t  /* Unless it's really a C++20 lvalue being treated as an xvalue.\n \t     But in C++23, such an expression is just an xvalue, not a special\n \t     lvalue, so the binding is once again ill-formed.  */\n-\t  && !(cxx_dialect == cxx20\n+\t  && !(cxx_dialect <= cxx20\n \t       && (gl_kind & clk_implicit_rval))\n \t  && (!CP_TYPE_CONST_NON_VOLATILE_P (to)\n \t      || (flags & LOOKUP_NO_RVAL_BIND))\n@@ -2044,9 +2038,8 @@ implicit_conversion_1 (tree to, tree from, tree expr, bool c_cast_p,\n   /* Other flags only apply to the primary function in overload\n      resolution, or after we've chosen one.  */\n   flags &= (LOOKUP_ONLYCONVERTING|LOOKUP_NO_CONVERSION|LOOKUP_COPY_PARM\n-\t    |LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND|LOOKUP_PREFER_RVALUE\n-\t    |LOOKUP_NO_NARROWING|LOOKUP_PROTECT|LOOKUP_NO_NON_INTEGRAL\n-\t    |LOOKUP_SHORTCUT_BAD_CONVS);\n+\t    |LOOKUP_NO_TEMP_BIND|LOOKUP_NO_RVAL_BIND|LOOKUP_NO_NARROWING\n+\t    |LOOKUP_PROTECT|LOOKUP_NO_NON_INTEGRAL|LOOKUP_SHORTCUT_BAD_CONVS);\n \n   /* FIXME: actually we don't want warnings either, but we can't just\n      have 'complain &= ~(tf_warning|tf_error)' because it would cause\n@@ -4451,14 +4444,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   if (cand->viable == -1)\n     conv->bad_p = true;\n \n-  /* We're performing the maybe-rvalue overload resolution and\n-     a conversion function is in play.  Reject converting the return\n-     value of the conversion function to a base class.  */\n-  if ((flags & LOOKUP_PREFER_RVALUE) && !DECL_CONSTRUCTOR_P (cand->fn))\n-    for (conversion *t = cand->second_conv; t; t = next_conversion (t))\n-      if (t->kind == ck_base)\n-\treturn NULL;\n-\n   /* Remember that this was a list-initialization.  */\n   if (flags & LOOKUP_NO_NARROWING)\n     conv->check_narrowing = true;\n@@ -8292,9 +8277,6 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t explicit constructors.  */\n       if (convs->copy_init_p)\n \tflags |= LOOKUP_ONLYCONVERTING;\n-      if (convs->rvaluedness_matches_p)\n-\t/* standard_conversion got LOOKUP_PREFER_RVALUE.  */\n-\tflags |= LOOKUP_PREFER_RVALUE;\n       expr = build_temp (expr, totype, flags, &diag_kind, complain);\n       if (diag_kind && complain)\n \t{\n@@ -9560,23 +9542,6 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  ++arg_index;\n \t  parm = TREE_CHAIN (parm);\n \t}\n-\n-      if (cxx_dialect < cxx20\n-\t  && (cand->flags & LOOKUP_PREFER_RVALUE))\n-\t{\n-\t  /* The implicit move specified in 15.8.3/3 fails \"...if the type of\n-\t     the first parameter of the selected constructor is not an rvalue\n-\t     reference to the object's type (possibly cv-qualified)....\" */\n-\t  gcc_assert (!(complain & tf_error));\n-\t  tree ptype = convs[0]->type;\n-\t  /* Allow calling a by-value converting constructor even though it\n-\t     isn't permitted by the above, because we've allowed it since GCC 5\n-\t     (PR58051) and it's allowed in C++20.  But don't call a copy\n-\t     constructor.  */\n-\t  if ((TYPE_REF_P (ptype) && !TYPE_REF_IS_RVALUE (ptype))\n-\t      || CONVERSION_RANK (convs[0]) > cr_exact)\n-\t    return error_mark_node;\n-\t}\n     }\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)"}, {"sha": "3b67be651b9c54a29ca73f31b5c30274f74723db", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -5874,12 +5874,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_DESTRUCTOR (1 << 5)\n /* Do not permit references to bind to temporaries.  */\n #define LOOKUP_NO_TEMP_BIND (1 << 6)\n-/* We're trying to treat an lvalue as an rvalue.  */\n-/* FIXME remove when we extend the P1825 semantics to all standard modes, the\n-   C++20 approach uses IMPLICIT_RVALUE_P instead.  */\n-#define LOOKUP_PREFER_RVALUE (LOOKUP_NO_TEMP_BIND << 1)\n /* We're inside an init-list, so narrowing conversions are ill-formed.  */\n-#define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)\n+#define LOOKUP_NO_NARROWING (LOOKUP_NO_TEMP_BIND << 1)\n /* We're looking up a constructor for list-initialization.  */\n #define LOOKUP_LIST_INIT_CTOR (LOOKUP_NO_NARROWING << 1)\n /* This is the first parameter of a copy constructor.  */"}, {"sha": "703d1d566c9196200e0200160acb1bf9ef180104", "filename": "gcc/cp/except.cc", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Fexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.cc?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -715,25 +715,10 @@ build_throw (location_t loc, tree exp)\n \t     treated as an rvalue for the purposes of overload resolution\n \t     to favor move constructors over copy constructors.  */\n \t  if (tree moved = treat_lvalue_as_rvalue_p (exp, /*return*/false))\n-\t    {\n-\t      if (cxx_dialect < cxx20)\n-\t\t{\n-\t\t  releasing_vec exp_vec (make_tree_vector_single (moved));\n-\t\t  moved = (build_special_member_call\n-\t\t\t   (object, complete_ctor_identifier, &exp_vec,\n-\t\t\t    TREE_TYPE (object), flags|LOOKUP_PREFER_RVALUE,\n-\t\t\t    tf_none));\n-\t\t  if (moved != error_mark_node)\n-\t\t    {\n-\t\t      exp = moved;\n-\t\t      converted = true;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t/* In C++20 we just treat the return value as an rvalue that\n-\t\t   can bind to lvalue refs.  */\n-\t\texp = moved;\n-\t    }\n+\t    /* In C++20 we treat the return value as an rvalue that\n+\t       can bind to lvalue refs.  In C++23, such an expression is just\n+\t       an xvalue.  */\n+\t    exp = moved;\n \n \t  /* Call the copy constructor.  */\n \t  if (!converted)"}, {"sha": "69c378dbcf096af971851f34bfb5eeae7b98d06f", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -10697,21 +10697,12 @@ maybe_warn_pessimizing_move (tree expr, tree type, bool return_p)\n \t  tree t = convert_for_initialization (NULL_TREE, type,\n \t\t\t\t\t       moved,\n \t\t\t\t\t       (LOOKUP_NORMAL\n-\t\t\t\t\t\t| LOOKUP_ONLYCONVERTING\n-\t\t\t\t\t\t| LOOKUP_PREFER_RVALUE),\n+\t\t\t\t\t\t| LOOKUP_ONLYCONVERTING),\n \t\t\t\t\t       ICR_RETURN, NULL_TREE, 0,\n \t\t\t\t\t       tf_none);\n \t  /* If this worked, implicit rvalue would work, so the call to\n \t     std::move is redundant.  */\n-\t  if (t != error_mark_node\n-\t      /* Trying to move something const will never succeed unless\n-\t\t there's T(const T&&), which it almost never is, and if\n-\t\t so, T wouldn't be error_mark_node now: the above convert_\n-\t\t call with LOOKUP_PREFER_RVALUE returns an error if a const T&\n-\t\t overload is selected.  */\n-\t      || (CP_TYPE_CONST_P (TREE_TYPE (arg))\n-\t\t  && same_type_ignoring_top_level_qualifiers_p\n-\t\t  (TREE_TYPE (arg), type)))\n+\t  if (t != error_mark_node)\n \t    {\n \t      auto_diagnostic_group d;\n \t      if (warning_at (loc, OPT_Wredundant_move,\n@@ -11054,23 +11045,10 @@ check_return_expr (tree retval, bool *no_warning)\n \t     ? CLASS_TYPE_P (functype)\n \t     : !SCALAR_TYPE_P (functype) || !SCALAR_TYPE_P (TREE_TYPE (retval)))\n \t    && (moved = treat_lvalue_as_rvalue_p (retval, /*return*/true)))\n-\t{\n-\t  if (cxx_dialect < cxx20)\n-\t    {\n-\t      moved = convert_for_initialization\n-\t\t(NULL_TREE, functype, moved, flags|LOOKUP_PREFER_RVALUE,\n-\t\t ICR_RETURN, NULL_TREE, 0, tf_none);\n-\t      if (moved != error_mark_node)\n-\t\t{\n-\t\t  retval = moved;\n-\t\t  converted = true;\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* In C++20 we just treat the return value as an rvalue that\n-\t       can bind to lvalue refs.  */\n-\t    retval = moved;\n-\t}\n+\t  /* In C++20 and earlier we treat the return value as an rvalue\n+\t     that can bind to lvalue refs.  In C++23, such an expression is just\n+\t     an xvalue (see reference_binding).  */\n+\t  retval = moved;\n \n       /* The call in a (lambda) thunk needs no conversions.  */\n       if (TREE_CODE (retval) == CALL_EXPR"}, {"sha": "17dd807aea8937b7cc9492733665d99e9c301384", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move10.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -57,5 +57,5 @@ struct S2: S1 {};\n \n S1 f3(const S2 s)\n {\n-  return std::move(s); // { dg-warning \"redundant move\" \"\" { target c++20 } }\n+  return std::move(s); // { dg-warning \"redundant move\" }\n }"}, {"sha": "6547777c007d54ba9044bbd1d654577587107193", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move7.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -28,7 +28,7 @@ struct S2 : S1 {};\n S1\n f (S2 s)\n {\n-  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" }\n }\n \n struct R1 {\n@@ -40,7 +40,7 @@ struct R2 : R1 {};\n R1\n f2 (const R2 s)\n {\n-  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" }\n }\n \n struct T1 {\n@@ -55,5 +55,5 @@ f3 (const T2 s)\n {\n   // Without std::move: const T1 &\n   // With std::move: const T1 &&\n-  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" }\n }"}, {"sha": "8e750efb870ba550082caaa75197a6d29e30ded5", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -7,5 +7,5 @@ struct S2 : S1 {};\n S1\n f (S2 s)\n {\n-  return s; // { dg-error \"use of deleted function\" \"\" { target c++17_down } }\n+  return s;\n }"}, {"sha": "0f0ca1fc2532c12f376db95a16d951c5509518d3", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return4.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -13,5 +13,5 @@ struct A : Base\n A<int> foo()\n {\n     A<double> v;\n-    return v; // { dg-error \"cannot bind rvalue reference\" \"\" { target c++17_down } }\n+    return v;\n }"}, {"sha": "695000b26870086800da73827b10a24f139ff764", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return5.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return5.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++11 } }\n+// This used to compile in C++11...17 because we performed two\n+// separate overload resolutions: one treating the operand as\n+// an rvalue, and then (if that resolution fails) another one\n+// treating the operand as an lvalue.\n+\n+struct W {\n+  W();\n+};\n+\n+struct F {\n+  F(W&);\n+  F(W&&) = delete;\n+};\n+\n+F fn ()\n+{\n+  W w;\n+  return w; // { dg-error \"use of deleted function\" }\n+}"}, {"sha": "314f19bb864709bb6a8543f1b0305e4bb05c7aed", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0d700b574a22f12db7f7587ce885f64ebcbfb0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C?ref=bc0d700b574a22f12db7f7587ce885f64ebcbfb0", "patch": "@@ -52,7 +52,7 @@ f5 ()\n int\n main ()\n {\n-  int return_lval = __cplusplus > 201703L ? -1 : 2;\n+  int return_lval = -1;\n   Y y1 = f (A());\n   if (y1.y != return_lval)\n     __builtin_abort ();"}]}