{"sha": "f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlY2I2MjZiYjkwOWY4YTM1YThkOTBmYWI5ZWMzZDJjNWFkNWFhMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-12-18T13:52:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-12-18T13:52:45Z"}, "message": "df-scan.c (persistent_obstack, [...]): Remove.\n\n\t* df-scan.c (persistent_obstack, df_invalidated_by_call): Remove.\n\t(df_scan_start_dump, df_get_call_refs, df_hard_reg_init): Rename\n\tdf_invalidated_by_call to invalidated_by_call_regset.\n\t* df.h (df_invalidated_by_call): Remove.\n\t* regclass.c (regs_invalidated_by_call_regset, persistent_obstack): New\n\tvariables.\n\t(init_reg_sets_1): Initialize regs_invalidated_by_call_regset.\n\t(globalize_reg): Likewise.\n\t* df-problems.c (df_rd_local_compute, df_lr_confluence_n,\n\tdf_byte_lr_alloc): Rename df_invalidated_by_call to\n\tinvalidated_by_call_regset.\n\t* basic-block.h (regs_invalidated_by_call_regset): Declare.\n\nCo-Authored-By: Kai Tietz <kai.tietz@onevision.com>\n\nFrom-SVN: r142812", "tree": {"sha": "cad2942391876ddb7f5f3a36b391fc71f730cdb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cad2942391876ddb7f5f3a36b391fc71f730cdb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/comments", "author": null, "committer": null, "parents": [{"sha": "20377b474e11ac86b9217ea54bdcbe15200da0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20377b474e11ac86b9217ea54bdcbe15200da0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20377b474e11ac86b9217ea54bdcbe15200da0c4"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "07009dade543c93b3abd2e9fd5c11d83ed9a613c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -1,3 +1,19 @@\n+2008-12-18  Jan Hubicka  <jh@suse.cz>\n+\t    Kai Tietz <kai.tietz@onevision.com>\n+\n+\t* df-scan.c (persistent_obstack, df_invalidated_by_call): Remove.\n+\t(df_scan_start_dump, df_get_call_refs, df_hard_reg_init): Rename\n+\tdf_invalidated_by_call to invalidated_by_call_regset.\n+\t* df.h (df_invalidated_by_call): Remove.\n+\t* regclass.c (regs_invalidated_by_call_regset, persistent_obstack): New\n+\tvariables.\n+\t(init_reg_sets_1): Initialize regs_invalidated_by_call_regset.\n+\t(globalize_reg): Likewise.\n+\t* df-problems.c (df_rd_local_compute, df_lr_confluence_n,\n+\tdf_byte_lr_alloc): Rename df_invalidated_by_call to\n+\tinvalidated_by_call_regset.\n+\t* basic-block.h (regs_invalidated_by_call_regset): Declare.\n+\n 2008-12-18  Jan Hubicka  <jh@suse.cz>\n \t    Kai Tietz <kai.tietz@onevision.com>\n "}, {"sha": "bd741b52275db63a612a265e2c19b4d6cc5b2870", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -106,6 +106,11 @@ typedef bitmap_iterator reg_set_iterator;\n #define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, RSI) \\\n   EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, RSI)\t\\\n \n+/* Same information as REGS_INVALIDATED_BY_CALL but in regset form to be used\n+   in dataflow more conveniently.  */\n+\n+extern regset regs_invalidated_by_call_regset;\n+\n /* Type we use to hold basic block counters.  Should be at least\n    64bit.  Although a counter cannot be negative, we use a signed\n    type, because erroneous negative counts can be generated when the"}, {"sha": "9175f106c960b01fecb5ddc65927e20daaf91aa2", "filename": "gcc/df-problems.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -443,7 +443,7 @@ df_rd_local_compute (bitmap all_blocks)\n     }\n   \n   /* Set up the knockout bit vectors to be applied across EH_EDGES.  */\n-  EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, regno, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, regno, bi)\n     {\n       if (DF_DEFS_COUNT (regno) > DF_SPARSE_THRESHOLD)\n \tbitmap_set_bit (sparse_invalidated, regno);\n@@ -975,7 +975,7 @@ df_lr_confluence_n (edge e)\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n-    bitmap_ior_and_compl_into (op1, op2, df_invalidated_by_call);\n+    bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n   else\n     bitmap_ior_into (op1, op2);\n \n@@ -2542,7 +2542,7 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_byte_lr_expand_bitmap (problem_data->hardware_regs_used, \n \t\t\t    df->hardware_regs_used);\n   df_byte_lr_expand_bitmap (problem_data->invalidated_by_call, \n-\t\t\t    df_invalidated_by_call);\n+\t\t\t    regs_invalidated_by_call_regset);\n \n   EXECUTE_IF_SET_IN_BITMAP (df_byte_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {"}, {"sha": "14434d2c09280f2576341907acb4b272690d966a", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -75,20 +75,10 @@ along with GCC; see the file COPYING3.  If not see\n       free (V);  \\\n   } while (0)\n \n-/* The bitmap_obstack is used to hold some static variables that\n-   should not be reset after each function is compiled.  */\n-\n-static bitmap_obstack persistent_obstack;\n-\n /* The set of hard registers in eliminables[i].from. */\n \n static HARD_REG_SET elim_reg_set;\n \n-/* This is a bitmap copy of regs_invalidated_by_call so that we can\n-   easily add it into bitmaps, etc. */ \n-\n-bitmap df_invalidated_by_call = NULL;\n-\n /* Initialize ur_in and ur_out as if all hard registers were partially\n    available.  */\n \n@@ -436,7 +426,7 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n   rtx insn;\n \n   fprintf (file, \";;  invalidated by call \\t\");\n-  df_print_regset (file, df_invalidated_by_call);\n+  df_print_regset (file, regs_invalidated_by_call_regset);\n   fprintf (file, \";;  hardware regs used \\t\");\n   df_print_regset (file, df->hardware_regs_used);\n   fprintf (file, \";;  regular block artificial uses \\t\");\n@@ -3391,7 +3381,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n       }\n \n   is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n-  EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, ui, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, ui, bi)\n     {\n       if (!global_regs[ui]\n \t  && (!bitmap_bit_p (defs_generated, ui))\n@@ -4121,8 +4111,6 @@ df_hard_reg_init (void)\n   if (initialized)\n     return;\n \n-  bitmap_obstack_initialize (&persistent_obstack);\n-\n   /* Record which registers will be eliminated.  We use this in\n      mark_used_regs.  */\n   CLEAR_HARD_REG_SET (elim_reg_set);\n@@ -4134,14 +4122,6 @@ df_hard_reg_init (void)\n   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n #endif\n   \n-  df_invalidated_by_call = BITMAP_ALLOC (&persistent_obstack);\n-  \n-  /* Inconveniently, this is only readily available in hard reg set\n-     form.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n-    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-      bitmap_set_bit (df_invalidated_by_call, i);\n-  \n   initialized = true;\n }\n "}, {"sha": "dd00d9284d100d49f38653627a1cce593830f55e", "filename": "gcc/df.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -762,11 +762,6 @@ struct df\n \n extern bitmap_obstack df_bitmap_obstack;\n \n-/* This is a bitmap copy of regs_invalidated_by_call so that we can\n-   easily add it into bitmaps, etc. */ \n-\n-extern bitmap df_invalidated_by_call;\n-\n \n /* One of these structures is allocated for every basic block.  */\n struct df_scan_bb_info"}, {"sha": "f31ccd15e4026ddf4213c65b25abf6caeb6ed67c", "filename": "gcc/regclass.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=f2ecb626bb909f8a35a8d90fab9ec3d2c5ad5aa0", "patch": "@@ -145,6 +145,16 @@ char global_regs[FIRST_PSEUDO_REGISTER];\n \n HARD_REG_SET regs_invalidated_by_call;\n \n+/* Same information as REGS_INVALIDATED_BY_CALL but in regset form to be used\n+   in dataflow more conveniently.  */\n+\n+regset regs_invalidated_by_call_regset;\n+\n+/* The bitmap_obstack is used to hold some static variables that\n+   should not be reset after each function is compiled.  */\n+\n+static bitmap_obstack persistent_obstack;\n+\n /* Table of register numbers in the order in which to try to use them.  */\n #ifdef REG_ALLOC_ORDER\n int reg_alloc_order[FIRST_PSEUDO_REGISTER] = REG_ALLOC_ORDER;\n@@ -568,6 +578,13 @@ init_reg_sets_1 (void)\n   CLEAR_HARD_REG_SET (call_fixed_reg_set);\n   CLEAR_HARD_REG_SET (regs_invalidated_by_call);\n   CLEAR_HARD_REG_SET (losing_caller_save_reg_set);\n+  if (!regs_invalidated_by_call_regset)\n+    {\n+      bitmap_obstack_initialize (&persistent_obstack);\n+      regs_invalidated_by_call_regset = ALLOC_REG_SET (&persistent_obstack);\n+    }\n+  else\n+    CLEAR_REG_SET (regs_invalidated_by_call_regset);\n \n   memcpy (call_fixed_regs, fixed_regs, sizeof call_fixed_regs);\n \n@@ -602,7 +619,10 @@ init_reg_sets_1 (void)\n       if (i == STACK_POINTER_REGNUM)\n \t;\n       else if (global_regs[i])\n-\tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+        {\n+\t  SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+\t  SET_REGNO_REG_SET (regs_invalidated_by_call_regset, i);\n+\t}\n       else if (i == FRAME_POINTER_REGNUM)\n \t;\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n@@ -618,7 +638,10 @@ init_reg_sets_1 (void)\n \t;\n #endif\n       else if (CALL_REALLY_USED_REGNO_P (i))\n-\tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+        {\n+\t  SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+\t  SET_REGNO_REG_SET (regs_invalidated_by_call_regset, i);\n+        }\n     }\n \n   /* Preserve global registers if called more than once.  */\n@@ -912,7 +935,10 @@ globalize_reg (int i)\n      appropriate regs_invalidated_by_call bit, even if it's already\n      set in fixed_regs.  */\n   if (i != STACK_POINTER_REGNUM)\n-    SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+    {\n+      SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+      SET_REGNO_REG_SET (regs_invalidated_by_call_regset, i);\n+   }\n \n   /* If already fixed, nothing else to do.  */\n   if (fixed_regs[i])"}]}