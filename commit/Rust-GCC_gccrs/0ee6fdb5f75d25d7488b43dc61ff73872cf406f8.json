{"sha": "0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVlNmZkYjVmNzVkMjVkNzQ4OGI0M2RjNjFmZjczODcyY2Y0MDZmOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-09-20T07:33:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-09-20T07:33:25Z"}, "message": "real.h (enum real_value_class, [...]): Move from real.c.\n\n        * real.h (enum real_value_class, SIGNIFICAND_BITS, EXP_BITS,\n        MAX_EXP, SIGSZ, SIG_MSB, struct real_value): Move from real.c.\n        (struct realvaluetype): Remove.\n        (REAL_VALUE_TYPE): Use struct real_value.\n        (REAL_VALUE_TYPE_SIZE): Use SIGNIFICAND_BITS.\n        (test_real_width): New.\n        * real.c: Global replace struct real_value with REAL_VALUE_TYPE.\n        (real_arithmetic): Avoid hoops for REAL_VALUE_TYPE parameters.\n        (real_compare, real_exponent, real_ldexp, real_isinf, real_isnan,\n        real_isneg, real_isnegzero, real_identical, exact_real_inverse,\n        real_to_integer, real_to_integer2, real_to_decimal,\n        real_to_hexadecimal, real_from_string, real_from_integer,\n        real_inf, real_nan, real_2expN, real_convert, real_to_target,\n        real_from_target): Likewise.\n        * tree.h (struct tree_real_cst): Use real_value not realvaluetype.\n        * gengtype-yacc.y (bitfieldopt): Accept an ID as well.\n\nFrom-SVN: r57343", "tree": {"sha": "c54a7a01350d6852bd914b86bd519ff2f024d491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c54a7a01350d6852bd914b86bd519ff2f024d491"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/comments", "author": null, "committer": null, "parents": [{"sha": "42449812831c9db0df90acb0d57ca7a2d4497a90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42449812831c9db0df90acb0d57ca7a2d4497a90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42449812831c9db0df90acb0d57ca7a2d4497a90"}], "stats": {"total": 593, "additions": 289, "deletions": 304}, "files": [{"sha": "ba73addb9952c8148961dd300b5166caf88591c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "patch": "@@ -1,3 +1,22 @@\n+2002-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.h (enum real_value_class, SIGNIFICAND_BITS, EXP_BITS,\n+\tMAX_EXP, SIGSZ, SIG_MSB, struct real_value): Move from real.c.\n+\t(struct realvaluetype): Remove.\n+\t(REAL_VALUE_TYPE): Use struct real_value.\n+\t(REAL_VALUE_TYPE_SIZE): Use SIGNIFICAND_BITS.\n+\t(test_real_width): New.\n+\t* real.c: Global replace struct real_value with REAL_VALUE_TYPE.\n+\t(real_arithmetic): Avoid hoops for REAL_VALUE_TYPE parameters.\n+\t(real_compare, real_exponent, real_ldexp, real_isinf, real_isnan,\n+\treal_isneg, real_isnegzero, real_identical, exact_real_inverse,\n+\treal_to_integer, real_to_integer2, real_to_decimal,\n+\treal_to_hexadecimal, real_from_string, real_from_integer,\n+\treal_inf, real_nan, real_2expN, real_convert, real_to_target,\n+\treal_from_target): Likewise.\n+\t* tree.h (struct tree_real_cst): Use real_value not realvaluetype.\n+\t* gengtype-yacc.y (bitfieldopt): Accept an ID as well.\n+\n 2002-09-20  Richard Henderson  <rth@redhat.com>\n \n \t* real.h (UNKNOWN_FLOAT_FORMAT, IEEE_FLOAT_FORMAT, VAX_FLOAT_FORMAT,"}, {"sha": "bb350b43e594884068a37cb093f9728810505a54", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "patch": "@@ -214,6 +214,7 @@ struct_fields: { $$ = NULL; }\n \n bitfieldopt: /* empty */\n \t     | ':' NUM\n+\t     | ':' ID\n \t     ;\n \n type: SCALAR"}, {"sha": "26e527580cfdc0fa0e3fa026b4e6c5df2ae49b67", "filename": "gcc/real.c", "status": "modified", "additions": 231, "deletions": 287, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "patch": "@@ -63,44 +63,20 @@\n    adjust the significand to match.  */\n \n \n-/* Enumerate the special cases of numbers that we encounter.  */\n-enum real_value_class {\n-  rvc_zero,\n-  rvc_normal,\n-  rvc_inf,\n-  rvc_nan\n-};\n-\n /* Used to classify two numbers simultaneously.  */\n #define CLASS2(A, B)  ((A) << 2 | (B))\n \n-/* An expanded form of the represented number.  */\n-\n-#define SIGNIFICAND_BITS\t128\n-#define EXP_BITS\t\t(32 - 3)\n-#define MAX_EXP\t\t\t((1 << (EXP_BITS - 1)) - 1)\n-#define SIGSZ\t\t\t(SIGNIFICAND_BITS / HOST_BITS_PER_LONG)\n-#define SIG_MSB\t\t\t((unsigned long)1 << (HOST_BITS_PER_LONG - 1))\n-\n #if HOST_BITS_PER_LONG != 64 && HOST_BITS_PER_LONG != 32\n  #error \"Some constant folding done by hand to avoid shift count warnings\"\n #endif\n \n-struct real_value\n-{\n-  enum real_value_class class : 2;\n-  unsigned int sign : 1;\n-  int exp : EXP_BITS;\n-  unsigned long sig[SIGSZ];\n-};\n-\n /* Describes the properties of the specific target format in use.  */\n struct real_format\n {\n   /* Move to and from the target bytes.  */\n   void (*encode) (const struct real_format *, long *,\n-\t\t  const struct real_value *);\n-  void (*decode) (const struct real_format *, struct real_value *,\n+\t\t  const REAL_VALUE_TYPE *);\n+  void (*decode) (const struct real_format *, REAL_VALUE_TYPE *,\n \t\t  const long *);\n \n   /* The radix of the exponent and digits of the significand.  */\n@@ -130,64 +106,64 @@ struct real_format\n static const struct real_format *fmt_for_mode[TFmode - QFmode + 1];\n \n \n-static void get_zero PARAMS ((struct real_value *, int));\n-static void get_canonical_qnan PARAMS ((struct real_value *, int));\n-static void get_canonical_snan PARAMS ((struct real_value *, int));\n-static void get_inf PARAMS ((struct real_value *, int));\n-static void sticky_rshift_significand PARAMS ((struct real_value *,\n-\t\t\t\t\t       const struct real_value *,\n+static void get_zero PARAMS ((REAL_VALUE_TYPE *, int));\n+static void get_canonical_qnan PARAMS ((REAL_VALUE_TYPE *, int));\n+static void get_canonical_snan PARAMS ((REAL_VALUE_TYPE *, int));\n+static void get_inf PARAMS ((REAL_VALUE_TYPE *, int));\n+static void sticky_rshift_significand PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t       const REAL_VALUE_TYPE *,\n \t\t\t\t\t       unsigned int));\n-static void rshift_significand PARAMS ((struct real_value *,\n-\t\t\t\t\tconst struct real_value *,\n+static void rshift_significand PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\tconst REAL_VALUE_TYPE *,\n \t\t\t\t\tunsigned int));\n-static void lshift_significand PARAMS ((struct real_value *,\n-\t\t\t\t\tconst struct real_value *,\n+static void lshift_significand PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\tconst REAL_VALUE_TYPE *,\n \t\t\t\t\tunsigned int));\n-static void lshift_significand_1 PARAMS ((struct real_value *,\n-\t\t\t\t\t  const struct real_value *));\n-static bool add_significands PARAMS ((struct real_value *r,\n-\t\t\t\t      const struct real_value *,\n-\t\t\t\t      const struct real_value *));\n-static bool sub_significands PARAMS ((struct real_value *,\n-\t\t\t\t      const struct real_value *,\n-\t\t\t\t      const struct real_value *));\n-static void neg_significand PARAMS ((struct real_value *,\n-\t\t\t\t     const struct real_value *));\n-static int cmp_significands PARAMS ((const struct real_value *,\n-\t\t\t\t     const struct real_value *));\n-static void set_significand_bit PARAMS ((struct real_value *, unsigned int));\n-static void clear_significand_bit PARAMS ((struct real_value *, unsigned int));\n-static bool test_significand_bit PARAMS ((struct real_value *, unsigned int));\n-static void clear_significand_below PARAMS ((struct real_value *,\n+static void lshift_significand_1 PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t  const REAL_VALUE_TYPE *));\n+static bool add_significands PARAMS ((REAL_VALUE_TYPE *r,\n+\t\t\t\t      const REAL_VALUE_TYPE *,\n+\t\t\t\t      const REAL_VALUE_TYPE *));\n+static bool sub_significands PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t      const REAL_VALUE_TYPE *,\n+\t\t\t\t      const REAL_VALUE_TYPE *));\n+static void neg_significand PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t     const REAL_VALUE_TYPE *));\n+static int cmp_significands PARAMS ((const REAL_VALUE_TYPE *,\n+\t\t\t\t     const REAL_VALUE_TYPE *));\n+static void set_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n+static void clear_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n+static bool test_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n+static void clear_significand_below PARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t\t     unsigned int));\n-static bool div_significands PARAMS ((struct real_value *,\n-\t\t\t\t      const struct real_value *,\n-\t\t\t\t      const struct real_value *));\n-static void normalize PARAMS ((struct real_value *));\n-\n-static void do_add PARAMS ((struct real_value *, const struct real_value *,\n-\t\t\t    const struct real_value *, int));\n-static void do_multiply PARAMS ((struct real_value *,\n-\t\t\t\t const struct real_value *,\n-\t\t\t\t const struct real_value *));\n-static void do_divide PARAMS ((struct real_value *, const struct real_value *,\n-\t\t\t       const struct real_value *));\n-static int do_compare PARAMS ((const struct real_value *,\n-\t\t\t       const struct real_value *, int));\n-static void do_fix_trunc PARAMS ((struct real_value *,\n-\t\t\t\t  const struct real_value *));\n-\n-static const struct real_value * ten_to_ptwo PARAMS ((int));\n-static const struct real_value * real_digit PARAMS ((int));\n+static bool div_significands PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t      const REAL_VALUE_TYPE *,\n+\t\t\t\t      const REAL_VALUE_TYPE *));\n+static void normalize PARAMS ((REAL_VALUE_TYPE *));\n+\n+static void do_add PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t    const REAL_VALUE_TYPE *, int));\n+static void do_multiply PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t const REAL_VALUE_TYPE *,\n+\t\t\t\t const REAL_VALUE_TYPE *));\n+static void do_divide PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n+\t\t\t       const REAL_VALUE_TYPE *));\n+static int do_compare PARAMS ((const REAL_VALUE_TYPE *,\n+\t\t\t       const REAL_VALUE_TYPE *, int));\n+static void do_fix_trunc PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t  const REAL_VALUE_TYPE *));\n+\n+static const REAL_VALUE_TYPE * ten_to_ptwo PARAMS ((int));\n+static const REAL_VALUE_TYPE * real_digit PARAMS ((int));\n \n static void round_for_format PARAMS ((const struct real_format *,\n-\t\t\t\t      struct real_value *));\n+\t\t\t\t      REAL_VALUE_TYPE *));\n \f\n /* Initialize R with a positive zero.  */\n \n static inline void\n get_zero (r, sign)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      int sign;\n {\n   memset (r, 0, sizeof (*r));\n@@ -198,7 +174,7 @@ get_zero (r, sign)\n \n static inline void\n get_canonical_qnan (r, sign)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      int sign;\n {\n   memset (r, 0, sizeof (*r));\n@@ -209,7 +185,7 @@ get_canonical_qnan (r, sign)\n \n static inline void\n get_canonical_snan (r, sign)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      int sign;\n {\n   memset (r, 0, sizeof (*r));\n@@ -220,7 +196,7 @@ get_canonical_snan (r, sign)\n \n static inline void\n get_inf (r, sign)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      int sign;\n {\n   memset (r, 0, sizeof (*r));\n@@ -235,8 +211,8 @@ get_inf (r, sign)\n \n static void\n sticky_rshift_significand (r, a, n)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n      unsigned int n;\n {\n   unsigned long sticky = 0;\n@@ -276,8 +252,8 @@ sticky_rshift_significand (r, a, n)\n \n static void\n rshift_significand (r, a, n)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n      unsigned int n;\n {\n   unsigned int i, ofs = n / HOST_BITS_PER_LONG;\n@@ -307,8 +283,8 @@ rshift_significand (r, a, n)\n \n static void\n lshift_significand (r, a, n)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n      unsigned int n;\n {\n   unsigned int i, ofs = n / HOST_BITS_PER_LONG;\n@@ -335,8 +311,8 @@ lshift_significand (r, a, n)\n \n static inline void\n lshift_significand_1 (r, a)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n {\n   unsigned int i;\n \n@@ -350,8 +326,8 @@ lshift_significand_1 (r, a)\n \n static inline bool\n add_significands (r, a, b)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n   bool carry = false;\n   int i;\n@@ -380,8 +356,8 @@ add_significands (r, a, b)\n \n static inline bool\n sub_significands (r, a, b)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n   bool carry = false;\n   int i;\n@@ -409,8 +385,8 @@ sub_significands (r, a, b)\n \n static inline void\n neg_significand (r, a)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n {\n   bool carry = true;\n   int i;\n@@ -440,7 +416,7 @@ neg_significand (r, a)\n \n static inline int \n cmp_significands (a, b)\n-     const struct real_value *a, *b;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n   int i;\n \n@@ -462,7 +438,7 @@ cmp_significands (a, b)\n \n static inline void\n set_significand_bit (r, n)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      unsigned int n;\n {\n   r->sig[n / HOST_BITS_PER_LONG]\n@@ -473,7 +449,7 @@ set_significand_bit (r, n)\n \n static inline void\n clear_significand_bit (r, n)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      unsigned int n;\n {\n   r->sig[n / HOST_BITS_PER_LONG]\n@@ -484,7 +460,7 @@ clear_significand_bit (r, n)\n \n static inline bool\n test_significand_bit (r, n)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      unsigned int n;\n {\n   /* ??? Compiler bug here if we return this expression directly.\n@@ -498,7 +474,7 @@ test_significand_bit (r, n)\n \n static void\n clear_significand_below (r, n)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      unsigned int n;\n {\n   int i, w = n / HOST_BITS_PER_LONG;\n@@ -514,10 +490,10 @@ clear_significand_below (r, n)\n \n static inline bool\n div_significands (r, a, b)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n-  struct real_value u;\n+  REAL_VALUE_TYPE u;\n   int bit = SIGNIFICAND_BITS - 1;\n   int i;\n   long inexact;\n@@ -562,7 +538,7 @@ div_significands (r, a, b)\n \n static void\n normalize (r)\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n {\n   int shift = 0, exp;\n   int i, j;\n@@ -607,12 +583,12 @@ normalize (r)\n \n static void\n do_add (r, a, b, subtract_p)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n      int subtract_p;\n {\n   int dexp, sign, exp;\n-  struct real_value t;\n+  REAL_VALUE_TYPE t;\n \n   /* Determine if we need to add or subtract.  */\n   sign = a->sign;\n@@ -671,7 +647,7 @@ do_add (r, a, b, subtract_p)\n   dexp = a->exp - b->exp;\n   if (dexp < 0)\n     {\n-      const struct real_value *t;\n+      const REAL_VALUE_TYPE *t;\n       t = a, a = b, b = t;\n       dexp = -dexp;\n       sign ^= subtract_p;\n@@ -741,10 +717,10 @@ do_add (r, a, b, subtract_p)\n \n static void\n do_multiply (r, a, b)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n-  struct real_value u, t, *rr;\n+  REAL_VALUE_TYPE u, t, *rr;\n   unsigned int i, j, k;\n   int sign = a->sign ^ b->sign;\n \n@@ -870,11 +846,11 @@ do_multiply (r, a, b)\n \n static void\n do_divide (r, a, b)\n-     struct real_value *r;\n-     const struct real_value *a, *b;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a, *b;\n {\n   int exp, sign = a->sign ^ b->sign;\n-  struct real_value t, *rr;\n+  REAL_VALUE_TYPE t, *rr;\n   bool inexact;\n \n   switch (CLASS2 (a->class, b->class))\n@@ -962,7 +938,7 @@ do_divide (r, a, b)\n \n static int\n do_compare (a, b, nan_result)\n-     const struct real_value *a, *b;\n+     const REAL_VALUE_TYPE *a, *b;\n      int nan_result;\n {\n   int ret;\n@@ -1019,8 +995,8 @@ do_compare (a, b, nan_result)\n \n void\n do_fix_trunc (r, a)\n-     struct real_value *r;\n-     const struct real_value *a;\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *a;\n {\n   *r = *a;\n \n@@ -1047,14 +1023,11 @@ do_fix_trunc (r, a)\n    For a unary operation, leave OP1 NULL.  */\n \n void\n-real_arithmetic (tr, icode, top0, top1)\n-     REAL_VALUE_TYPE *tr;\n+real_arithmetic (r, icode, op0, op1)\n+     REAL_VALUE_TYPE *r;\n      int icode;\n-     const REAL_VALUE_TYPE *top0, *top1;\n+     const REAL_VALUE_TYPE *op0, *op1;\n {\n-  struct real_value *r = (struct real_value *) tr;\n-  const struct real_value *op0 = (const struct real_value *) top0;\n-  const struct real_value *op1 = (const struct real_value *) top1;\n   enum tree_code code = icode;\n \n   switch (code)\n@@ -1115,23 +1088,21 @@ real_arithmetic (tr, icode, top0, top1)\n /* Legacy.  Similar, but return the result directly.  */\n \n REAL_VALUE_TYPE\n-real_arithmetic2 (icode, top0, top1)\n+real_arithmetic2 (icode, op0, op1)\n      int icode;\n-     const REAL_VALUE_TYPE *top0, *top1;\n+     const REAL_VALUE_TYPE *op0, *op1;\n {\n   REAL_VALUE_TYPE r;\n-  real_arithmetic (&r, icode, top0, top1);\n+  real_arithmetic (&r, icode, op0, op1);\n   return r;\n }\n \n bool\n-real_compare (icode, top0, top1)\n+real_compare (icode, op0, op1)\n      int icode;\n-     const REAL_VALUE_TYPE *top0, *top1;\n+     const REAL_VALUE_TYPE *op0, *op1;\n {\n   enum tree_code code = icode;\n-  const struct real_value *op0 = (const struct real_value *) top0;\n-  const struct real_value *op1 = (const struct real_value *) top1;\n \n   switch (code)\n     {\n@@ -1170,11 +1141,9 @@ real_compare (icode, top0, top1)\n /* Return floor log2(R).  */\n \n int\n-real_exponent (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_exponent (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n-\n   switch (r->class)\n     {\n     case rvc_zero:\n@@ -1189,18 +1158,14 @@ real_exponent (tr)\n     }\n }\n \n-\n /* R = OP0 * 2**EXP.  */\n \n void\n-real_ldexp (tr, top0, exp)\n-     REAL_VALUE_TYPE *tr;\n-     const REAL_VALUE_TYPE *top0;\n+real_ldexp (r, op0, exp)\n+     REAL_VALUE_TYPE *r;\n+     const REAL_VALUE_TYPE *op0;\n      int exp;\n {\n-  struct real_value *r = (struct real_value *) tr;\n-  const struct real_value *op0 = (const struct real_value *) top0;\n-\n   *r = *op0;\n   switch (r->class)\n     {\n@@ -1227,51 +1192,45 @@ real_ldexp (tr, top0, exp)\n /* Determine whether a floating-point value X is infinite.  */\n \n bool\n-real_isinf (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_isinf (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n   return (r->class == rvc_inf);\n }\n \n /* Determine whether a floating-point value X is a NaN.  */\n \n bool\n-real_isnan (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_isnan (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n   return (r->class == rvc_nan);\n }\n \n /* Determine whether a floating-point value X is negative.  */\n \n bool\n-real_isneg (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_isneg (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n   return r->sign;\n }\n \n /* Determine whether a floating-point value X is minus zero.  */\n \n bool\n-real_isnegzero (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_isnegzero (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n   return r->sign && r->class == rvc_zero;\n }\n \n /* Compare two floating-point objects for bitwise identity.  */\n \n extern bool\n-real_identical (ta, tb)\n-     const REAL_VALUE_TYPE *ta, *tb;\n+real_identical (a, b)\n+     const REAL_VALUE_TYPE *a, *b;\n {\n-  const struct real_value *a = (const struct real_value *) ta;\n-  const struct real_value *b = (const struct real_value *) tb;\n   int i;\n \n   if (a->class != b->class)\n@@ -1306,13 +1265,12 @@ real_identical (ta, tb)\n    mode MODE.  Return true if successful.  */\n \n bool\n-exact_real_inverse (mode, tr)\n+exact_real_inverse (mode, r)\n      enum machine_mode mode;\n-     REAL_VALUE_TYPE *tr;\n+     REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *one = real_digit (1);\n-  struct real_value *r = (struct real_value *) tr;\n-  struct real_value u;\n+  const REAL_VALUE_TYPE *one = real_digit (1);\n+  REAL_VALUE_TYPE u;\n   int i;\n   \n   if (r->class != rvc_normal)\n@@ -1327,7 +1285,7 @@ exact_real_inverse (mode, tr)\n \n   /* Find the inverse and truncate to the required mode.  */\n   do_divide (&u, one, r);\n-  real_convert ((REAL_VALUE_TYPE *)&u, mode, (REAL_VALUE_TYPE *)&u);\n+  real_convert (&u, mode, &u);\n   \n   /* The rounding may have overflowed.  */\n   if (u.class != rvc_normal)\n@@ -1345,10 +1303,9 @@ exact_real_inverse (mode, tr)\n /* Render R as an integer.  */\n \n HOST_WIDE_INT\n-real_to_integer (tr)\n-     const REAL_VALUE_TYPE *tr;\n+real_to_integer (r)\n+     const REAL_VALUE_TYPE *r;\n {\n-  const struct real_value *r = (const struct real_value *) tr;\n   unsigned HOST_WIDE_INT i;\n \n   switch (r->class)\n@@ -1396,16 +1353,15 @@ real_to_integer (tr)\n /* Likewise, but to an integer pair, HI+LOW.  */\n \n void\n-real_to_integer2 (plow, phigh, tr)\n+real_to_integer2 (plow, phigh, r)\n      HOST_WIDE_INT *plow, *phigh;\n-     const REAL_VALUE_TYPE *tr;\n+     const REAL_VALUE_TYPE *r;\n {\n-  struct real_value r;\n+  REAL_VALUE_TYPE t;\n   HOST_WIDE_INT low, high;\n   int exp;\n \n-  r = *(const struct real_value *) tr;\n-  switch (r.class)\n+  switch (r->class)\n     {\n     case rvc_zero:\n     underflow:\n@@ -1416,7 +1372,7 @@ real_to_integer2 (plow, phigh, tr)\n     case rvc_nan:\n     overflow:\n       high = (unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1);\n-      if (r.sign)\n+      if (r->sign)\n \tlow = 0;\n       else\n \t{\n@@ -1426,32 +1382,32 @@ real_to_integer2 (plow, phigh, tr)\n       break;\n \n     case rvc_normal:\n-      exp = r.exp;\n+      exp = r->exp;\n       if (exp <= 0)\n \tgoto underflow;\n       if (exp >= 2*HOST_BITS_PER_WIDE_INT)\n \tgoto overflow;\n \n-      rshift_significand (&r, &r, 2*HOST_BITS_PER_WIDE_INT - exp);\n+      rshift_significand (&t, r, 2*HOST_BITS_PER_WIDE_INT - exp);\n       if (HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG)\n \t{\n-\t  high = r.sig[SIGSZ-1];\n-\t  low = r.sig[SIGSZ-2];\n+\t  high = t.sig[SIGSZ-1];\n+\t  low = t.sig[SIGSZ-2];\n \t}\n       else if (HOST_BITS_PER_WIDE_INT == 2*HOST_BITS_PER_LONG)\n \t{\n-\t  high = r.sig[SIGSZ-1];\n+\t  high = t.sig[SIGSZ-1];\n \t  high = high << (HOST_BITS_PER_LONG - 1) << 1;\n-\t  high |= r.sig[SIGSZ-2];\n+\t  high |= t.sig[SIGSZ-2];\n \n-\t  low = r.sig[SIGSZ-3];\n+\t  low = t.sig[SIGSZ-3];\n \t  low = low << (HOST_BITS_PER_LONG - 1) << 1;\n-\t  low |= r.sig[SIGSZ-4];\n+\t  low |= t.sig[SIGSZ-4];\n \t}\n       else\n \tabort ();\n \n-      if (r.sign)\n+      if (r->sign)\n \t{\n \t  if (low == 0)\n \t    high = -high;\n@@ -1480,13 +1436,13 @@ real_to_decimal (str, r_orig, digits)\n      const REAL_VALUE_TYPE *r_orig;\n      int digits;\n {\n-  struct real_value r;\n-  const struct real_value *one, *ten;\n+  REAL_VALUE_TYPE r;\n+  const REAL_VALUE_TYPE *one, *ten;\n   int dec_exp, max_digits, d, cmp_half;\n   char *p, *first, *last;\n   bool sign;\n \n-  r = *(const struct real_value *)r_orig;\n+  r = *r_orig;\n   switch (r.class)\n     {\n     case rvc_zero:\n@@ -1602,30 +1558,27 @@ real_to_decimal (str, r_orig, digits)\n    for the representation.  */\n \n void\n-real_to_hexadecimal (str, tr, digits)\n+real_to_hexadecimal (str, r, digits)\n      char *str;\n-     const REAL_VALUE_TYPE *tr;\n+     const REAL_VALUE_TYPE *r;\n      int digits;\n {\n-  struct real_value r;\n-  int i, j;\n+  int i, j, exp = r->exp;\n   char *p;\n \n-  r = *(const struct real_value *) tr;\n-\n-  switch (r.class)\n+  switch (r->class)\n     {\n     case rvc_zero:\n-      r.exp = 0;\n+      exp = 0;\n       break;\n     case rvc_normal:\n       break;\n     case rvc_inf:\n-      strcpy (str, (r.sign ? \"+Inf\" : \"-Inf\"));\n+      strcpy (str, (r->sign ? \"+Inf\" : \"-Inf\"));\n       return;\n     case rvc_nan:\n       /* ??? Print the significand as well, if not canonical?  */\n-      strcpy (str, (r.sign ? \"+NaN\" : \"-NaN\"));\n+      strcpy (str, (r->sign ? \"+NaN\" : \"-NaN\"));\n       return;\n     default:\n       abort ();\n@@ -1635,7 +1588,7 @@ real_to_hexadecimal (str, tr, digits)\n     digits = SIGNIFICAND_BITS / 4;\n \n   p = str;\n-  if (r.sign)\n+  if (r->sign)\n     *p++ = '-';\n   *p++ = '0';\n   *p++ = 'x';\n@@ -1645,23 +1598,22 @@ real_to_hexadecimal (str, tr, digits)\n   for (i = SIGSZ - 1; i >= 0; --i)\n     for (j = HOST_BITS_PER_LONG - 4; j >= 0; j -= 4)\n       {\n-\t*p++ = \"0123456789abcdef\"[(r.sig[i] >> j) & 15];\n+\t*p++ = \"0123456789abcdef\"[(r->sig[i] >> j) & 15];\n \tif (--digits == 0)\n \t  goto out;\n       }\n  out:\n-  sprintf (p, \"p%+d\", r.exp);\n+  sprintf (p, \"p%+d\", exp);\n }\n \n /* Initialize R from a decimal or hexadecimal string.  The string is\n    assumed to have been syntax checked already.  */\n \n void\n-real_from_string (tr, str)\n-     REAL_VALUE_TYPE *tr;\n+real_from_string (r, str)\n+     REAL_VALUE_TYPE *r;\n      const char *str;\n {\n-  struct real_value *r = (struct real_value *) tr;\n   int exp = 0;\n \n   get_zero (r, 0);\n@@ -1764,7 +1716,7 @@ real_from_string (tr, str)\n   else\n     {\n       /* Decimal floating point.  */\n-      const struct real_value *ten = ten_to_ptwo (0);\n+      const REAL_VALUE_TYPE *ten = ten_to_ptwo (0);\n       int d;\n \n       while (*str == '0')\n@@ -1868,15 +1820,13 @@ real_from_string2 (s, mode)\n /* Initialize R from the integer pair HIGH+LOW.  */\n \n void\n-real_from_integer (tr, mode, low, high, unsigned_p)\n-     REAL_VALUE_TYPE *tr;\n+real_from_integer (r, mode, low, high, unsigned_p)\n+     REAL_VALUE_TYPE *r;\n      enum machine_mode mode;\n      unsigned HOST_WIDE_INT low;\n      HOST_WIDE_INT high;\n      int unsigned_p;\n {\n-  struct real_value *r = (struct real_value *) tr;\n-\n   if (low == 0 && high == 0)\n     get_zero (r, 0);\n   else\n@@ -1916,16 +1866,16 @@ real_from_integer (tr, mode, low, high, unsigned_p)\n     }\n \n   if (mode != VOIDmode)\n-    real_convert (tr, mode, tr);\n+    real_convert (r, mode, r);\n }\n \n /* Returns 10**2**n.  */\n \n-static const struct real_value *\n+static const REAL_VALUE_TYPE *\n ten_to_ptwo (n)\n      int n;\n {\n-  static struct real_value tens[EXP_BITS];\n+  static REAL_VALUE_TYPE tens[EXP_BITS];\n \n   if (n < 0 || n >= EXP_BITS)\n     abort ();\n@@ -1940,11 +1890,11 @@ ten_to_ptwo (n)\n \t  for (i = 0; i < n; ++i)\n \t    t *= t;\n \n-\t  real_from_integer ((REAL_VALUE_TYPE *) &tens[n], VOIDmode, t, 0, 1);\n+\t  real_from_integer (&tens[n], VOIDmode, t, 0, 1);\n \t}\n       else\n \t{\n-\t  const struct real_value *t = ten_to_ptwo (n - 1);\n+\t  const REAL_VALUE_TYPE *t = ten_to_ptwo (n - 1);\n \t  do_multiply (&tens[n], t, t);\n \t}\n     }\n@@ -1954,28 +1904,28 @@ ten_to_ptwo (n)\n \n /* Returns N.  */\n \n-static const struct real_value *\n+static const REAL_VALUE_TYPE *\n real_digit (n)\n      int n;\n {\n-  static struct real_value num[10];\n+  static REAL_VALUE_TYPE num[10];\n \n   if (n < 0 || n > 9)\n     abort ();\n \n   if (n > 0 && num[n].class == rvc_zero)\n-    real_from_integer ((REAL_VALUE_TYPE *) &num[n], VOIDmode, n, 0, 1);\n+    real_from_integer (&num[n], VOIDmode, n, 0, 1);\n \n   return &num[n];\n }\n \n /* Fills R with +Inf.  */\n \n void\n-real_inf (tr)\n-     REAL_VALUE_TYPE *tr;\n+real_inf (r)\n+     REAL_VALUE_TYPE *r;\n {\n-  get_inf ((struct real_value *)tr, 0);\n+  get_inf (r, 0);\n }\n \n /* Fills R with a NaN whose significand is described by STR.  If QUIET,\n@@ -1984,13 +1934,12 @@ real_inf (tr)\n    if the string was successfully parsed.  */\n \n bool\n-real_nan (tr, str, quiet, mode)\n-     REAL_VALUE_TYPE *tr;\n+real_nan (r, str, quiet, mode)\n+     REAL_VALUE_TYPE *r;\n      const char *str;\n      int quiet;\n      enum machine_mode mode;\n {\n-  struct real_value *r = (struct real_value *) tr;\n   const struct real_format *fmt;\n \n   fmt = fmt_for_mode[mode - QFmode];\n@@ -2030,7 +1979,7 @@ real_nan (tr, str, quiet, mode)\n \n       while ((d = hex_value (*str)) < base)\n \t{\n-\t  struct real_value u;\n+\t  REAL_VALUE_TYPE u;\n \n \t  switch (base)\n \t    {\n@@ -2093,12 +2042,10 @@ real_nan (tr, str, quiet, mode)\n /* Fills R with 2**N.  */\n \n void\n-real_2expN (tr, n)\n-     REAL_VALUE_TYPE *tr;\n+real_2expN (r, n)\n+     REAL_VALUE_TYPE *r;\n      int n;\n {\n-  struct real_value *r = (struct real_value *) tr;\n-\n   memset (r, 0, sizeof (*r));\n \n   n++;\n@@ -2118,7 +2065,7 @@ real_2expN (tr, n)\n static void\n round_for_format (fmt, r)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n {\n   int p2, np2, i, w;\n   unsigned long sticky;\n@@ -2218,7 +2165,7 @@ round_for_format (fmt, r)\n   /* Round to even.  */\n   if (guard && (sticky || lsb))\n     {\n-      struct real_value u;\n+      REAL_VALUE_TYPE u;\n       get_zero (&u, 0);\n       set_significand_bit (&u, np2);\n \n@@ -2257,13 +2204,11 @@ round_for_format (fmt, r)\n /* Extend or truncate to a new mode.  */\n \n void\n-real_convert (tr, mode, ta)\n-     REAL_VALUE_TYPE *tr;\n+real_convert (r, mode, a)\n+     REAL_VALUE_TYPE *r;\n      enum machine_mode mode;\n-     const REAL_VALUE_TYPE *ta;\n+     const REAL_VALUE_TYPE *a;\n {\n-  struct real_value *r = (struct real_value *)tr;\n-  const struct real_value *a = (const struct real_value *)ta;\n   const struct real_format *fmt;\n \n   fmt = fmt_for_mode[mode - QFmode];\n@@ -2293,13 +2238,13 @@ real_value_truncate (mode, a)\n /* Return true if truncating to MODE is exact.  */\n \n bool\n-exact_real_truncate (mode, ta)\n+exact_real_truncate (mode, a)\n      enum machine_mode mode;\n-     const REAL_VALUE_TYPE *ta;\n+     const REAL_VALUE_TYPE *a;\n {\n   REAL_VALUE_TYPE t;\n-  real_convert (&t, mode, ta);\n-  return real_identical (&t, ta);\n+  real_convert (&t, mode, a);\n+  return real_identical (&t, a);\n }\n \n /* Write R to the target format of MODE.  Place the words of the \n@@ -2309,22 +2254,22 @@ exact_real_truncate (mode, ta)\n    Legacy: return word 0 for implementing REAL_VALUE_TO_TARGET_SINGLE.  */\n \n long\n-real_to_target (buf, tr, mode)\n+real_to_target (buf, r_orig, mode)\n      long *buf;\n-     const REAL_VALUE_TYPE *tr;\n+     const REAL_VALUE_TYPE *r_orig;\n      enum machine_mode mode;\n {\n-  struct real_value r;\n+  REAL_VALUE_TYPE r;\n   const struct real_format *fmt;\n   long buf1;\n \n-  r = *(const struct real_value *) tr;\n-\n   fmt = fmt_for_mode[mode - QFmode];\n   if (fmt == NULL)\n     abort ();\n \n+  r = *r_orig;\n   round_for_format (fmt, &r);\n+\n   if (!buf)\n     buf = &buf1;\n   (*fmt->encode) (fmt, buf, &r);\n@@ -2337,12 +2282,11 @@ real_to_target (buf, tr, mode)\n    in each long, no matter the size of the host long.  */\n \n void\n-real_from_target (tr, buf, mode)\n-     REAL_VALUE_TYPE *tr;\n+real_from_target (r, buf, mode)\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n      enum machine_mode mode;\n {\n-  struct real_value *r = (struct real_value *) tr;\n   const struct real_format *fmt;\n \n   fmt = fmt_for_mode[mode - QFmode];\n@@ -2371,15 +2315,15 @@ significand_size (mode)\n /* IEEE single-precision format.  */\n \n static void encode_ieee_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const struct real_value *));\n+\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n static void decode_ieee_single PARAMS ((const struct real_format *,\n-\t\t\t\t\tstruct real_value *, const long *));\n+\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n \n static void\n encode_ieee_single (fmt, buf, r)\n      const struct real_format *fmt;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image, sig, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -2430,7 +2374,7 @@ encode_ieee_single (fmt, buf, r)\n static void\n decode_ieee_single (fmt, r, buf)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image = buf[0] & 0xffffffff;\n@@ -2499,15 +2443,15 @@ const struct real_format ieee_single =\n /* IEEE double-precision format.  */\n \n static void encode_ieee_double PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const struct real_value *));\n+\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n static void decode_ieee_double PARAMS ((const struct real_format *,\n-\t\t\t\t\tstruct real_value *, const long *));\n+\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n \n static void\n encode_ieee_double (fmt, buf, r)\n      const struct real_format *fmt;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image_lo, image_hi, sig_lo, sig_hi, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -2583,7 +2527,7 @@ encode_ieee_double (fmt, buf, r)\n static void\n decode_ieee_double (fmt, r, buf)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image_hi, image_lo;\n@@ -2691,22 +2635,22 @@ const struct real_format ieee_double =\n    and Motorola's.  */\n \n static void encode_ieee_extended PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t  long *, const struct real_value *));\n+\t\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n static void decode_ieee_extended PARAMS ((const struct real_format *,\n-\t\t\t\t\t  struct real_value *, const long *));\n+\t\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n \n static void encode_ieee_extended_128 PARAMS ((const struct real_format *fmt,\n \t\t\t\t\t      long *,\n-\t\t\t\t\t      const struct real_value *));\n+\t\t\t\t\t      const REAL_VALUE_TYPE *));\n static void decode_ieee_extended_128 PARAMS ((const struct real_format *,\n-\t\t\t\t\t      struct real_value *,\n+\t\t\t\t\t      REAL_VALUE_TYPE *,\n \t\t\t\t\t      const long *));\n \n static void\n encode_ieee_extended (fmt, buf, r)\n      const struct real_format *fmt;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image_hi, sig_hi, sig_lo;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n@@ -2814,7 +2758,7 @@ static void\n encode_ieee_extended_128 (fmt, buf, r)\n      const struct real_format *fmt;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   buf[3 * !FLOAT_WORDS_BIG_ENDIAN] = 0;\n   encode_ieee_extended (fmt, buf+!!FLOAT_WORDS_BIG_ENDIAN, r);\n@@ -2823,7 +2767,7 @@ encode_ieee_extended_128 (fmt, buf, r)\n static void\n decode_ieee_extended (fmt, r, buf)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image_hi, sig_hi, sig_lo;\n@@ -2915,7 +2859,7 @@ decode_ieee_extended (fmt, r, buf)\n static void\n decode_ieee_extended_128 (fmt, r, buf)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   decode_ieee_extended (fmt, r, buf+!!FLOAT_WORDS_BIG_ENDIAN);\n@@ -2973,19 +2917,19 @@ const struct real_format ieee_extended_intel_128 =\n /* IEEE quad precision format.  */\n \n static void encode_ieee_quad PARAMS ((const struct real_format *fmt,\n-\t\t\t\t      long *, const struct real_value *));\n+\t\t\t\t      long *, const REAL_VALUE_TYPE *));\n static void decode_ieee_quad PARAMS ((const struct real_format *,\n-\t\t\t\t      struct real_value *, const long *));\n+\t\t\t\t      REAL_VALUE_TYPE *, const long *));\n \n static void\n encode_ieee_quad (fmt, buf, r)\n      const struct real_format *fmt;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image3, image2, image1, image0, exp;\n   bool denormal = (r->sig[SIGSZ-1] & SIG_MSB) == 0;\n-  struct real_value u;\n+  REAL_VALUE_TYPE u;\n \n   image3 = r->sign << 31;\n   image2 = 0;\n@@ -3093,7 +3037,7 @@ encode_ieee_quad (fmt, buf, r)\n static void\n decode_ieee_quad (fmt, r, buf)\n      const struct real_format *fmt;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image3, image2, image1, image0;\n@@ -3223,23 +3167,23 @@ const struct real_format ieee_quad =\n /* The VAX floating point formats.  */\n \n static void encode_vax_f PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const struct real_value *));\n+\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n static void decode_vax_f PARAMS ((const struct real_format *,\n-\t\t\t\t  struct real_value *, const long *));\n+\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n static void encode_vax_d PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const struct real_value *));\n+\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n static void decode_vax_d PARAMS ((const struct real_format *,\n-\t\t\t\t  struct real_value *, const long *));\n+\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n static void encode_vax_g PARAMS ((const struct real_format *fmt,\n-\t\t\t\t  long *, const struct real_value *));\n+\t\t\t\t  long *, const REAL_VALUE_TYPE *));\n static void decode_vax_g PARAMS ((const struct real_format *,\n-\t\t\t\t  struct real_value *, const long *));\n+\t\t\t\t  REAL_VALUE_TYPE *, const long *));\n \n static void\n encode_vax_f (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long sign, exp, sig, image;\n \n@@ -3273,7 +3217,7 @@ encode_vax_f (fmt, buf, r)\n static void\n decode_vax_f (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image = buf[0] & 0xffffffff;\n@@ -3296,7 +3240,7 @@ static void\n encode_vax_d (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n@@ -3348,7 +3292,7 @@ encode_vax_d (fmt, buf, r)\n static void\n decode_vax_d (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image0, image1;\n@@ -3397,7 +3341,7 @@ static void\n encode_vax_g (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image0, image1, sign = r->sign << 15;\n \n@@ -3449,7 +3393,7 @@ encode_vax_g (fmt, buf, r)\n static void\n decode_vax_g (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image0, image1;\n@@ -3551,19 +3495,19 @@ const struct real_format vax_g_format =\n */\n \n static void encode_i370_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const struct real_value *));\n+\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n static void decode_i370_single PARAMS ((const struct real_format *,\n-\t\t\t\t\tstruct real_value *, const long *));\n+\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n static void encode_i370_double PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\tlong *, const struct real_value *));\n+\t\t\t\t\tlong *, const REAL_VALUE_TYPE *));\n static void decode_i370_double PARAMS ((const struct real_format *,\n-\t\t\t\t\tstruct real_value *, const long *));\n+\t\t\t\t\tREAL_VALUE_TYPE *, const long *));\n \n static void\n encode_i370_single (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long sign, exp, sig, image;\n \n@@ -3593,7 +3537,7 @@ encode_i370_single (fmt, buf, r)\n static void\n decode_i370_single (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long sign, sig, image = buf[0];\n@@ -3619,7 +3563,7 @@ static void\n encode_i370_double (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long sign, exp, image_hi, image_lo;\n \n@@ -3666,7 +3610,7 @@ encode_i370_double (fmt, buf, r)\n static void\n decode_i370_double (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long sign, image_hi, image_lo;\n@@ -3738,19 +3682,19 @@ const struct real_format i370_double =\n /* TMS320C[34]x twos complement floating point format.  */\n \n static void encode_c4x_single PARAMS ((const struct real_format *fmt,\n-\t\t\t\t       long *, const struct real_value *));\n+\t\t\t\t       long *, const REAL_VALUE_TYPE *));\n static void decode_c4x_single PARAMS ((const struct real_format *,\n-\t\t\t\t       struct real_value *, const long *));\n+\t\t\t\t       REAL_VALUE_TYPE *, const long *));\n static void encode_c4x_extended PARAMS ((const struct real_format *fmt,\n-\t\t\t\t\t long *, const struct real_value *));\n+\t\t\t\t\t long *, const REAL_VALUE_TYPE *));\n static void decode_c4x_extended PARAMS ((const struct real_format *,\n-\t\t\t\t\t struct real_value *, const long *));\n+\t\t\t\t\t REAL_VALUE_TYPE *, const long *));\n \n static void\n encode_c4x_single (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long image, exp, sig;\n   \n@@ -3788,7 +3732,7 @@ encode_c4x_single (fmt, buf, r)\n static void\n decode_c4x_single (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long image = buf[0];\n@@ -3824,7 +3768,7 @@ static void\n encode_c4x_extended (fmt, buf, r)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n      long *buf;\n-     const struct real_value *r;\n+     const REAL_VALUE_TYPE *r;\n {\n   unsigned long exp, sig;\n   \n@@ -3872,7 +3816,7 @@ encode_c4x_extended (fmt, buf, r)\n static void\n decode_c4x_extended (fmt, r, buf)\n      const struct real_format *fmt ATTRIBUTE_UNUSED;\n-     struct real_value *r;\n+     REAL_VALUE_TYPE *r;\n      const long *buf;\n {\n   unsigned long sig;"}, {"sha": "6b9cc35a321c740fd3d8860526572cdc78c75c30", "filename": "gcc/real.h", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "patch": "@@ -24,26 +24,47 @@\n \n #include \"machmode.h\"\n \n-/* REAL_VALUE_TYPE is an array of the minimum number of HOST_WIDE_INTs\n-   required to hold a 128-bit floating point type.  This is true even\n-   if the maximum precision floating point type on the target is smaller.\n+/* An expanded form of the represented number.  */\n+\n+/* Enumerate the special cases of numbers that we encounter.  */\n+enum real_value_class {\n+  rvc_zero,\n+  rvc_normal,\n+  rvc_inf,\n+  rvc_nan\n+};\n+\n+#define SIGNIFICAND_BITS\t128\n+#define EXP_BITS\t\t(32 - 3)\n+#define MAX_EXP\t\t\t((1 << (EXP_BITS - 1)) - 1)\n+#define SIGSZ\t\t\t(SIGNIFICAND_BITS / HOST_BITS_PER_LONG)\n+#define SIG_MSB\t\t\t((unsigned long)1 << (HOST_BITS_PER_LONG - 1))\n+\n+struct real_value GTY(())\n+{\n+  enum real_value_class class : 2;\n+  unsigned int sign : 1;\n+  int exp : EXP_BITS;\n+  unsigned long sig[SIGSZ];\n+};\n \n-   The extra 32 bits are for storing the mode of the float.  Ideally\n-   we'd keep this elsewhere, but that's too drastic a change all at once.  */\n+/* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it\n+   needs to be a macro.  We do need to continue to have a structure tag\n+   so that other headers can forward declare it.  */\n+#define REAL_VALUE_TYPE struct real_value\n \n-#define REAL_VALUE_TYPE_SIZE (128 + 32)\n+/* We store a REAL_VALUE_TYPE into an rtx, and we do this by putting it in\n+   consecutive \"w\" slots.  Moreover, we've got to compute the number of \"w\"\n+   slots at preprocessor time, which means we can't use sizeof.  Guess.  */\n+\n+#define REAL_VALUE_TYPE_SIZE (SIGNIFICAND_BITS + 32)\n #define REAL_WIDTH \\\n   (REAL_VALUE_TYPE_SIZE/HOST_BITS_PER_WIDE_INT \\\n    + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n \n-struct realvaluetype GTY(()) {\n-  HOST_WIDE_INT r[REAL_WIDTH];\n-};\n-\n-/* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it needs\n-   to be a macro.  realvaluetype cannot be a typedef as this interferes with\n-   other headers declaring opaque pointers to it.  */\n-#define REAL_VALUE_TYPE struct realvaluetype\n+/* Verify the guess.  */\n+extern char test_real_width\n+  [sizeof(REAL_VALUE_TYPE) <= REAL_WIDTH*sizeof(HOST_WIDE_INT) ? 1 : -1];\n \n /* Calculate the format for CONST_DOUBLE.  We need as many slots as\n    are necessary to overlay a REAL_VALUE_TYPE on them.  This could be"}, {"sha": "c3faa82b0d90d9fe3207ffba969f135f33561926", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee6fdb5f75d25d7488b43dc61ff73872cf406f8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0ee6fdb5f75d25d7488b43dc61ff73872cf406f8", "patch": "@@ -726,10 +726,10 @@ struct tree_int_cst GTY(())\n \n #define TREE_CST_RTL(NODE) (CST_OR_CONSTRUCTOR_CHECK (NODE)->real_cst.rtl)\n \n-/* In a REAL_CST node.  struct realvaluetype is an opaque entity, with\n+/* In a REAL_CST node.  struct real_value is an opaque entity, with\n    manipulators defined in real.h.  We don't want tree.h depending on\n    real.h and transitively on tm.h.  */\n-struct realvaluetype;\n+struct real_value;\n \n #define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst_ptr)\n #define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))\n@@ -738,7 +738,7 @@ struct tree_real_cst GTY(())\n {\n   struct tree_common common;\n   rtx rtl;\t/* acts as link to register transfer language (rtl) info */\n-  struct realvaluetype * real_cst_ptr;\n+  struct real_value * real_cst_ptr;\n };\n \n /* In a STRING_CST */"}]}