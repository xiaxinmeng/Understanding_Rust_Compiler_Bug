{"sha": "8313c5f600fe935d00b4ff52539e01df67af928d", "node_id": "C_kwDOANBUbNoAKDgzMTNjNWY2MDBmZTkzNWQwMGI0ZmY1MjUzOWUwMWRmNjdhZjkyOGQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-15T13:47:44Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-05T14:29:58Z"}, "message": "ada: Revert to constrained allocation for string concatenation\n\nUsing an unconstrained allocation is less efficient in the general case.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): New local variable used\n\tthroughout instead of testing Is_Special_Return_Object every time.\n\tDo not rename an OK_To_Rename object for a special return object.\n\t* exp_ch4.adb (Expand_Concatenate): Revert to constrained allocation\n\tif the result is allocated on the secondary stack.", "tree": {"sha": "e4fbbea2d4034722937a195c655656c8ea7b44c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4fbbea2d4034722937a195c655656c8ea7b44c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8313c5f600fe935d00b4ff52539e01df67af928d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8313c5f600fe935d00b4ff52539e01df67af928d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8313c5f600fe935d00b4ff52539e01df67af928d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8313c5f600fe935d00b4ff52539e01df67af928d/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0776fec1557f60e256cd18a5456ee5ad04cf4262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0776fec1557f60e256cd18a5456ee5ad04cf4262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0776fec1557f60e256cd18a5456ee5ad04cf4262"}], "stats": {"total": 111, "additions": 50, "deletions": 61}, "files": [{"sha": "a76acf34d66a3bda133963cebe5b1a3a08fa25e0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8313c5f600fe935d00b4ff52539e01df67af928d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8313c5f600fe935d00b4ff52539e01df67af928d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8313c5f600fe935d00b4ff52539e01df67af928d", "patch": "@@ -6230,6 +6230,11 @@ package body Exp_Ch3 is\n       Base_Typ : constant Entity_Id  := Base_Type (Typ);\n       Next_N   : constant Node_Id    := Next (N);\n \n+      Special_Ret_Obj : constant Boolean := Is_Special_Return_Object (Def_Id);\n+      --  If this is a special return object, it will be allocated differently\n+      --  and ultimately rewritten as a renaming, so initialization activities\n+      --  need to be deferred until after that is done.\n+\n       function Build_Equivalent_Aggregate return Boolean;\n       --  If the object has a constrained discriminated type and no initial\n       --  value, it may be possible to build an equivalent aggregate instead,\n@@ -7343,7 +7348,7 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         if not Is_Special_Return_Object (Def_Id) then\n+         if not Special_Ret_Obj then\n             Default_Initialize_Object (Init_After);\n          end if;\n \n@@ -7403,7 +7408,7 @@ package body Exp_Ch3 is\n                Expander_Mode_Restore;\n             end if;\n \n-            if not Is_Special_Return_Object (Def_Id) then\n+            if not Special_Ret_Obj then\n                Convert_Aggr_In_Object_Decl (N);\n             end if;\n \n@@ -7479,7 +7484,7 @@ package body Exp_Ch3 is\n             --  case, the expansion of the return statement will take care of\n             --  creating the object (via allocator) and initializing it.\n \n-            if Is_Special_Return_Object (Def_Id) then\n+            if Special_Ret_Obj then\n \n                --  If the type needs finalization and is not inherently\n                --  limited, then the target is adjusted after the copy\n@@ -7791,7 +7796,7 @@ package body Exp_Ch3 is\n             if Present (Tag_Assign) then\n                if Present (Following_Address_Clause (N)) then\n                   Ensure_Freeze_Node (Def_Id);\n-               elsif not Is_Special_Return_Object (Def_Id) then\n+               elsif not Special_Ret_Obj then\n                   Insert_Action_After (Init_After, Tag_Assign);\n                end if;\n \n@@ -7931,7 +7936,7 @@ package body Exp_Ch3 is\n                 and then\n                   ((not Is_Library_Level_Entity (Def_Id)\n                      and then Is_Captured_Function_Call (Expr_Q)\n-                     and then (not Is_Special_Return_Object (Def_Id)\n+                     and then (not Special_Ret_Obj\n                                 or else Is_Related_To_Func_Return\n                                           (Entity (Prefix (Expr_Q))))\n                      and then not Is_Class_Wide_Type (Typ))\n@@ -7945,12 +7950,14 @@ package body Exp_Ch3 is\n \n                    --     Obj : Typ renames Expr;\n \n-                   or else OK_To_Rename_Ref (Expr_Q)\n+                   or else (OK_To_Rename_Ref (Expr_Q)\n+                             and then not Special_Ret_Obj)\n \n                    --  Likewise if it is a slice of such a variable\n \n                    or else (Nkind (Expr_Q) = N_Slice\n-                             and then OK_To_Rename_Ref (Prefix (Expr_Q))));\n+                             and then OK_To_Rename_Ref (Prefix (Expr_Q))\n+                             and then not Special_Ret_Obj));\n \n             --  If the type needs finalization and is not inherently limited,\n             --  then the target is adjusted after the copy and attached to the\n@@ -7971,9 +7978,7 @@ package body Exp_Ch3 is\n                    Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n                    Typ     => Base_Typ);\n \n-               if Present (Adj_Call)\n-                 and then not Is_Special_Return_Object (Def_Id)\n-               then\n+               if Present (Adj_Call) and then not Special_Ret_Obj then\n                   Insert_Action_After (Init_After, Adj_Call);\n                end if;\n             end if;\n@@ -8601,9 +8606,7 @@ package body Exp_Ch3 is\n             end;\n          end if;\n \n-         if Is_Special_Return_Object (Def_Id)\n-           and then Present (Tag_Assign)\n-         then\n+         if Special_Ret_Obj and then Present (Tag_Assign) then\n             Insert_Action_After (Init_After, Tag_Assign);\n          end if;\n "}, {"sha": "d9103b3387b430ec9f312cd8a20e96f73f697656", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8313c5f600fe935d00b4ff52539e01df67af928d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8313c5f600fe935d00b4ff52539e01df67af928d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8313c5f600fe935d00b4ff52539e01df67af928d", "patch": "@@ -2728,7 +2728,6 @@ package body Exp_Ch4 is\n       Len        : Unat;\n       J          : Nat;\n       Clen       : Node_Id;\n-      Decl       : Node_Id;\n       Set        : Boolean;\n \n    --  Start of processing for Expand_Concatenate\n@@ -3255,32 +3254,10 @@ package body Exp_Ch4 is\n       Set_Is_Internal       (Ent);\n       Set_Debug_Info_Needed (Ent);\n \n-      --  If the bound is statically known to be out of range, we do not want\n-      --  to abort, we want a warning and a constraint error at run time. Note\n-      --  that we have arranged that the result will not be treated as a static\n-      --  constant, so we won't get an illegality during the insertion. We also\n-      --  enable all checks (in particular range checks) in case the bounds of\n-      --  Subtyp_Ind are out of range.\n-\n-      Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Ent,\n-          Object_Definition   => Subtyp_Ind);\n-      Insert_Action (Cnode, Decl);\n-\n-      --  If the result of the concatenation appears as the initializing\n-      --  expression of an object declaration, we can just rename the\n-      --  result, rather than copying it.\n-\n-      Set_OK_To_Rename (Ent);\n-\n       --  If we are concatenating strings and the current scope already uses\n       --  the secondary stack, allocate the result also on the secondary stack\n       --  to avoid putting too much pressure on the primary stack.\n \n-      --  We use an unconstrained allocation, i.e. we also allocate the bounds,\n-      --  so that the result can be renamed in all contexts.\n-\n       --  Don't do this if -gnatd.h is set, as this will break the wrapping of\n       --  Cnode in an Expression_With_Actions, see Expand_N_Op_Concat.\n \n@@ -3291,33 +3268,32 @@ package body Exp_Ch4 is\n       then\n          --  Generate:\n          --     subtype Axx is String (<low-bound> .. <high-bound>)\n-         --     type Ayy is access String;\n+         --     type Ayy is access Axx;\n          --     Rxx : Ayy := new <Axx> [storage_pool = ss_pool];\n-         --     Sxx : String renames Rxx.all;\n+         --     Sxx : Axx renames Rxx.all;\n \n          declare\n             ConstrT : constant Entity_Id := Make_Temporary (Loc, 'A');\n             Acc_Typ : constant Entity_Id := Make_Temporary (Loc, 'A');\n \n-            Alloc   : Node_Id;\n-            Deref   : Node_Id;\n-            Temp    : Entity_Id;\n+            Alloc : Node_Id;\n+            Temp  : Entity_Id;\n \n          begin\n-            Insert_Action (Decl,\n+            Insert_Action (Cnode,\n               Make_Subtype_Declaration (Loc,\n                 Defining_Identifier => ConstrT,\n                 Subtype_Indication  => Subtyp_Ind),\n               Suppress => All_Checks);\n \n-            Freeze_Itype (ConstrT, Decl);\n+            Freeze_Itype (ConstrT, Cnode);\n \n-            Insert_Action (Decl,\n+            Insert_Action (Cnode,\n               Make_Full_Type_Declaration (Loc,\n                 Defining_Identifier => Acc_Typ,\n                 Type_Definition     =>\n                   Make_Access_To_Object_Definition (Loc,\n-                    Subtype_Indication => New_Occurrence_Of (Atyp, Loc))),\n+                    Subtype_Indication => New_Occurrence_Of (ConstrT, Loc))),\n               Suppress => All_Checks);\n \n             Mutate_Ekind (Acc_Typ, E_Access_Type);\n@@ -3335,33 +3311,43 @@ package body Exp_Ch4 is\n             Set_No_Initialization (Alloc);\n \n             Temp := Make_Temporary (Loc, 'R', Alloc);\n-            Insert_Action (Decl,\n+            Insert_Action (Cnode,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Temp,\n                 Object_Definition   => New_Occurrence_Of (Acc_Typ, Loc),\n                 Expression          => Alloc),\n               Suppress => All_Checks);\n \n-            Deref :=\n-              Make_Explicit_Dereference (Loc,\n-                Prefix => New_Occurrence_Of (Temp, Loc));\n-            Set_Etype (Deref, Atyp);\n-\n-            Rewrite (Decl,\n+            Insert_Action (Cnode,\n               Make_Object_Renaming_Declaration (Loc,\n                 Defining_Identifier => Ent,\n-                Subtype_Mark        => New_Occurrence_Of (Atyp, Loc),\n-                Name                => Deref));\n-\n-            --  We do not analyze this renaming declaration because this would\n-            --  change the subtype of Ent back to a constrained string.\n-\n-            Set_Etype (Ent, Atyp);\n-            Set_Renamed_Object (Ent, Deref);\n-            Set_Analyzed (Decl);\n+                Subtype_Mark        => New_Occurrence_Of (ConstrT, Loc),\n+                Name                =>\n+                  Make_Explicit_Dereference (Loc,\n+                    Prefix => New_Occurrence_Of (Temp, Loc))),\n+              Suppress => All_Checks);\n          end;\n+\n+      else\n+         --  If the bound is statically known to be out of range, we do not\n+         --  want to abort, we want a warning and a runtime constraint error.\n+         --  Note that we have arranged that the result will not be treated\n+         --  as a static constant, so we won't get an illegality during this\n+         --  insertion. We also enable checks (in particular range checks) in\n+         --  case the bounds of Subtyp_Ind are out of range.\n+\n+         Insert_Action (Cnode,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Ent,\n+             Object_Definition   => Subtyp_Ind));\n       end if;\n \n+      --  If the result of the concatenation appears as the initializing\n+      --  expression of an object declaration, we can just rename the\n+      --  result, rather than copying it.\n+\n+      Set_OK_To_Rename (Ent);\n+\n       --  Catch the static out of range case now\n \n       if Raises_Constraint_Error (High_Bound)"}]}