{"sha": "e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxZDQ2NGNhZmE5ODE1ZTY0Njc0YTJlM2IzZTlkMGU1ZWFjNmIzMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-14T14:33:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-14T14:33:44Z"}, "message": "re PR tree-optimization/87985 (Compile-time and memory hog w/ -O1 -ftree-slp-vectorize)\n\n2018-11-14  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/87985\n\t* tree-data-ref.c (split_constant_offset): Add wrapper\n\tallocating a cache hash-map.\n\t(split_constant_offset_1): Cache results of expanding\n\texpressions from SSA def stmts.\n\n\t* gcc.dg/pr87985.c: New testcase.\n\nFrom-SVN: r266147", "tree": {"sha": "a43ef4c7a9fd2d3f47b781e1e15c3a1315ef82cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a43ef4c7a9fd2d3f47b781e1e15c3a1315ef82cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78ef03b7c3a41afab87ad6b89c7c2dde5b600cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ef03b7c3a41afab87ad6b89c7c2dde5b600cbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ef03b7c3a41afab87ad6b89c7c2dde5b600cbc"}], "stats": {"total": 115, "additions": 96, "deletions": 19}, "files": [{"sha": "1a70b8ff591c7ec7410fe7f9a9903e44b0278f26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "patch": "@@ -1,3 +1,11 @@\n+2018-11-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/87985\n+\t* tree-data-ref.c (split_constant_offset): Add wrapper\n+\tallocating a cache hash-map.\n+\t(split_constant_offset_1): Cache results of expanding\n+\texpressions from SSA def stmts.\n+\n 2018-11-14  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/88021"}, {"sha": "50e53f0b1963c9b7353cc6f1c3c47f9375c6ccf5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "patch": "@@ -1,3 +1,8 @@\n+2018-11-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/87985\n+\t* gcc.dg/pr87985.c: New testcase.\n+\n 2018-11-14  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \t* gcc.target/s390/mrecord-mcount.c (profileme): Expect .long in"}, {"sha": "c0d07ff918fd6a2494955acef51ed341b8936ab7", "filename": "gcc/testsuite/gcc.dg/pr87985.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87985.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87985.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87985.c?ref=e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -ftree-slp-vectorize\" } */\n+\n+char *bar (void);\n+__INTPTR_TYPE__ baz (void);\n+\n+void\n+foo (__INTPTR_TYPE__ *q)\n+{\n+  char *p = bar ();\n+  __INTPTR_TYPE__ a = baz ();\n+  __INTPTR_TYPE__ b = baz ();\n+  int i = 0;\n+#define X q[i++] = a; q[i++] = b; a = a + b; b = b + a;\n+#define Y X X X X X X X X X X\n+#define Z Y Y Y Y Y Y Y Y Y Y\n+  Z Z Z Z Z Z Z Z Z Z\n+      p[a] = 1;\n+  p[b] = 2;\n+}"}, {"sha": "1fe32365887f6aacc7fdf5b6fdfdd32fd79136bf", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81d464cafa9815e64674a2e3b3e9d0e5eac6b31/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=e81d464cafa9815e64674a2e3b3e9d0e5eac6b31", "patch": "@@ -95,10 +95,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-affine.h\"\n #include \"params.h\"\n #include \"builtins.h\"\n-#include \"stringpool.h\"\n-#include \"tree-vrp.h\"\n-#include \"tree-ssanames.h\"\n #include \"tree-eh.h\"\n+#include \"ssa.h\"\n \n static struct datadep_stats\n {\n@@ -584,6 +582,10 @@ debug_ddrs (vec<ddr_p> ddrs)\n   dump_ddrs (stderr, ddrs);\n }\n \n+static void\n+split_constant_offset (tree exp, tree *var, tree *off,\n+\t\t       hash_map<tree, std::pair<tree, tree> > &cache);\n+\n /* Helper function for split_constant_offset.  Expresses OP0 CODE OP1\n    (the type of the result is TYPE) as VAR + OFF, where OFF is a nonzero\n    constant of type ssizetype, and returns true.  If we cannot do this\n@@ -592,7 +594,8 @@ debug_ddrs (vec<ddr_p> ddrs)\n \n static bool\n split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n-\t\t\t tree *var, tree *off)\n+\t\t\t tree *var, tree *off,\n+\t\t\t hash_map<tree, std::pair<tree, tree> > &cache)\n {\n   tree var0, var1;\n   tree off0, off1;\n@@ -613,8 +616,8 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n       /* FALLTHROUGH */\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      split_constant_offset (op0, &var0, &off0);\n-      split_constant_offset (op1, &var1, &off1);\n+      split_constant_offset (op0, &var0, &off0, cache);\n+      split_constant_offset (op1, &var1, &off1, cache);\n       *var = fold_build2 (code, type, var0, var1);\n       *off = size_binop (ocode, off0, off1);\n       return true;\n@@ -623,7 +626,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n       if (TREE_CODE (op1) != INTEGER_CST)\n \treturn false;\n \n-      split_constant_offset (op0, &var0, &off0);\n+      split_constant_offset (op0, &var0, &off0, cache);\n       *var = fold_build2 (MULT_EXPR, type, var0, op1);\n       *off = size_binop (MULT_EXPR, off0, fold_convert (ssizetype, op1));\n       return true;\n@@ -647,7 +650,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \n \tif (poffset)\n \t  {\n-\t    split_constant_offset (poffset, &poffset, &off1);\n+\t    split_constant_offset (poffset, &poffset, &off1, cache);\n \t    off0 = size_binop (PLUS_EXPR, off0, off1);\n \t    if (POINTER_TYPE_P (TREE_TYPE (base)))\n \t      base = fold_build_pointer_plus (base, poffset);\n@@ -691,18 +694,48 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \tif (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n \t  return false;\n \n-\tvar0 = gimple_assign_rhs1 (def_stmt);\n \tsubcode = gimple_assign_rhs_code (def_stmt);\n+\n+\t/* We are using a cache to avoid un-CSEing large amounts of code.  */\n+\tbool use_cache = false;\n+\tif (!has_single_use (op0)\n+\t    && (subcode == POINTER_PLUS_EXPR\n+\t\t|| subcode == PLUS_EXPR\n+\t\t|| subcode == MINUS_EXPR\n+\t\t|| subcode == MULT_EXPR\n+\t\t|| subcode == ADDR_EXPR\n+\t\t|| CONVERT_EXPR_CODE_P (subcode)))\n+\t  {\n+\t    use_cache = true;\n+\t    bool existed;\n+\t    std::pair<tree, tree> &e = cache.get_or_insert (op0, &existed);\n+\t    if (existed)\n+\t      {\n+\t\tif (integer_zerop (e.second))\n+\t\t  return false;\n+\t\t*var = e.first;\n+\t\t*off = e.second;\n+\t\treturn true;\n+\t      }\n+\t    e = std::make_pair (op0, ssize_int (0));\n+\t  }\n+\n+\tvar0 = gimple_assign_rhs1 (def_stmt);\n \tvar1 = gimple_assign_rhs2 (def_stmt);\n \n-\treturn split_constant_offset_1 (type, var0, subcode, var1, var, off);\n+\tbool res = split_constant_offset_1 (type, var0, subcode, var1,\n+\t\t\t\t\t    var, off, cache);\n+\tif (res && use_cache)\n+\t  *cache.get (op0) = std::make_pair (*var, *off);\n+\treturn res;\n       }\n     CASE_CONVERT:\n       {\n-\t/* We must not introduce undefined overflow, and we must not change the value.\n-\t   Hence we're okay if the inner type doesn't overflow to start with\n-\t   (pointer or signed), the outer type also is an integer or pointer\n-\t   and the outer precision is at least as large as the inner.  */\n+\t/* We must not introduce undefined overflow, and we must not change\n+\t   the value.  Hence we're okay if the inner type doesn't overflow\n+\t   to start with (pointer or signed), the outer type also is an\n+\t   integer or pointer and the outer precision is at least as large\n+\t   as the inner.  */\n \ttree itype = TREE_TYPE (op0);\n \tif ((POINTER_TYPE_P (itype)\n \t     || (INTEGRAL_TYPE_P (itype) && !TYPE_OVERFLOW_TRAPS (itype)))\n@@ -714,7 +747,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t/* Split the unconverted operand and try to prove that\n \t\t   wrapping isn't a problem.  */\n \t\ttree tmp_var, tmp_off;\n-\t\tsplit_constant_offset (op0, &tmp_var, &tmp_off);\n+\t\tsplit_constant_offset (op0, &tmp_var, &tmp_off, cache);\n \n \t\t/* See whether we have an SSA_NAME whose range is known\n \t\t   to be [A, B].  */\n@@ -749,7 +782,7 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t*off = wide_int_to_tree (ssizetype, diff);\n \t      }\n \t    else\n-\t      split_constant_offset (op0, &var0, off);\n+\t      split_constant_offset (op0, &var0, off, cache);\n \t    *var = fold_convert (type, var0);\n \t    return true;\n \t  }\n@@ -764,8 +797,9 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n /* Expresses EXP as VAR + OFF, where off is a constant.  The type of OFF\n    will be ssizetype.  */\n \n-void\n-split_constant_offset (tree exp, tree *var, tree *off)\n+static void\n+split_constant_offset (tree exp, tree *var, tree *off,\n+\t\t       hash_map<tree, std::pair<tree, tree> > &cache)\n {\n   tree type = TREE_TYPE (exp), op0, op1, e, o;\n   enum tree_code code;\n@@ -779,13 +813,23 @@ split_constant_offset (tree exp, tree *var, tree *off)\n \n   code = TREE_CODE (exp);\n   extract_ops_from_tree (exp, &code, &op0, &op1);\n-  if (split_constant_offset_1 (type, op0, code, op1, &e, &o))\n+  if (split_constant_offset_1 (type, op0, code, op1, &e, &o, cache))\n     {\n       *var = e;\n       *off = o;\n     }\n }\n \n+void\n+split_constant_offset (tree exp, tree *var, tree *off)\n+{\n+  static hash_map<tree, std::pair<tree, tree> > *cache;\n+  if (!cache)\n+    cache = new hash_map<tree, std::pair<tree, tree> > (37);\n+  split_constant_offset (exp, var, off, *cache);\n+  cache->empty ();\n+}\n+\n /* Returns the address ADDR of an object in a canonical shape (without nop\n    casts, and with type of pointer to the object).  */\n "}]}