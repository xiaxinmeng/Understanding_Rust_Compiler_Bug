{"sha": "6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExYTc4N2U0MTVmZmJiMDAyM2RkNjZjN2NmNGViZDM0NzViOGM3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2011-05-26T19:16:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-05-26T19:16:05Z"}, "message": "re PR rtl-optimization/48575 (RTL vector patterns are limited to 26 elements)\n\ngcc/\n\tPR rtl-optimization/48575\n\t* genrecog.c (position_type): New enum.\n\t(position): New structure.\n\t(decision): Use position structure instead of a string.\n\t(root_pos, peep2_insn_pos_list): New variables.\n\t(next_position, compare_positions): New functions.\n\t(new_decision): Use position structures instead of strings.\n\t(maybe_both_true): Likewise.\n\t(change_state): Likewise.\n\t(write_tree): Likewise.\n\t(make_insn_sequence): Likewise.\n\nFrom-SVN: r174305", "tree": {"sha": "abcd4742c25d4585e2108dc81cc43d5609b71e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abcd4742c25d4585e2108dc81cc43d5609b71e93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f256f612d49c99e153a024b2cf759537959dad29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f256f612d49c99e153a024b2cf759537959dad29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f256f612d49c99e153a024b2cf759537959dad29"}], "stats": {"total": 281, "additions": 204, "deletions": 77}, "files": [{"sha": "60553d56680126a684ac7517c357d47be5202b62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "patch": "@@ -1,3 +1,17 @@\n+2011-05-26  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR rtl-optimization/48575\n+\t* genrecog.c (position_type): New enum.\n+\t(position): New structure.\n+\t(decision): Use position structure instead of a string.\n+\t(root_pos, peep2_insn_pos_list): New variables.\n+\t(next_position, compare_positions): New functions.\n+\t(new_decision): Use position structures instead of strings.\n+\t(maybe_both_true): Likewise.\n+\t(change_state): Likewise.\n+\t(write_tree): Likewise.\n+\t(make_insn_sequence): Likewise.\n+\n 2011-05-26  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.c (initialize_tree_contains_struct): Mark TS_BLOCK as"}, {"sha": "08f63bd03eda328b0ba265616c0583fe54fc05a4", "filename": "gcc/genrecog.c", "status": "modified", "additions": 190, "deletions": 77, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=6a1a787e415ffbb0023dd66c7cf4ebd3475b8c7f", "patch": "@@ -62,6 +62,49 @@\n #define OUTPUT_LABEL(INDENT_STRING, LABEL_NUMBER) \\\n   printf(\"%sL%d: ATTRIBUTE_UNUSED_LABEL\\n\", (INDENT_STRING), (LABEL_NUMBER))\n \n+/* Ways of obtaining an rtx to be tested.  */\n+enum position_type {\n+  /* PATTERN (peep2_next_insn (ARG)).  */\n+  POS_PEEP2_INSN,\n+\n+  /* XEXP (BASE, ARG).  */\n+  POS_XEXP,\n+\n+  /* XVECEXP (BASE, 0, ARG).  */\n+  POS_XVECEXP0\n+};\n+\n+/* The position of an rtx relative to X0.  Each useful position is\n+   represented by exactly one instance of this structure.  */\n+struct position\n+{\n+  /* The parent rtx.  This is the root position for POS_PEEP2_INSNs.  */\n+  struct position *base;\n+\n+  /* A position with the same BASE and TYPE, but with the next value\n+     of ARG.  */\n+  struct position *next;\n+\n+  /* A list of all POS_XEXP positions that use this one as their base,\n+     chained by NEXT fields.  The first entry represents XEXP (this, 0),\n+     the second represents XEXP (this, 1), and so on.  */\n+  struct position *xexps;\n+\n+  /* A list of POS_XVECEXP0 positions that use this one as their base,\n+     chained by NEXT fields.  The first entry represents XVECEXP (this, 0, 0),\n+     the second represents XVECEXP (this, 0, 1), and so on.  */\n+  struct position *xvecexp0s;\n+\n+  /* The type of position.  */\n+  enum position_type type;\n+\n+  /* The argument to TYPE (shown as ARG in the position_type comments).  */\n+  int arg;\n+\n+  /* The depth of this position, with 0 as the root.  */\n+  int depth;\n+};\n+\n /* A listhead of decision trees.  The alternatives to a node are kept\n    in a doubly-linked list so we can easily add nodes to the proper\n    place when merging.  */\n@@ -132,7 +175,7 @@ struct decision\n   struct decision *afterward;\t/* Node to test on success,\n \t\t\t\t   but failure of successor nodes.  */\n \n-  const char *position;\t\t/* String denoting position in pattern.  */\n+  struct position *position;\t/* Position in pattern.  */\n \n   struct decision_test *tests;\t/* The tests for this node.  */\n \n@@ -170,9 +213,16 @@ static int max_depth;\n \n /* The line number of the start of the pattern currently being processed.  */\n static int pattern_lineno;\n+\n+/* The root position (x0).  */\n+static struct position root_pos;\n+\n+/* A list of all POS_PEEP2_INSNs.  The entry for insn 0 is the root position,\n+   since we are given that instruction's pattern as x0.  */\n+static struct position *peep2_insn_pos_list = &root_pos;\n \f\n static struct decision *new_decision\n-  (const char *, struct decision_head *);\n+  (struct position *, struct decision_head *);\n static struct decision_test *new_decision_test\n   (enum decision_type, struct decision_test ***);\n static rtx find_operand\n@@ -182,7 +232,7 @@ static rtx find_matching_operand\n static void validate_pattern\n   (rtx, rtx, rtx, int);\n static struct decision *add_to_sequence\n-  (rtx, struct decision_head *, const char *, enum routine_type, int);\n+  (rtx, struct decision_head *, struct position *, enum routine_type, int);\n \n static int maybe_both_true_2\n   (struct decision_test *, struct decision_test *);\n@@ -210,7 +260,7 @@ static void find_afterward\n   (struct decision_head *, struct decision *);\n \n static void change_state\n-  (const char *, const char *, const char *);\n+  (struct position *, struct position *, const char *);\n static void print_code\n   (enum rtx_code);\n static void write_afterward\n@@ -229,7 +279,7 @@ static int write_node\n static void write_tree_1\n   (struct decision_head *, int, enum routine_type);\n static void write_tree\n-  (struct decision_head *, const char *, enum routine_type, int);\n+  (struct decision_head *, struct position *, enum routine_type, int);\n static void write_subroutine\n   (struct decision_head *, enum routine_type);\n static void write_subroutines\n@@ -253,15 +303,66 @@ extern void debug_decision\n extern void debug_decision_list\n   (struct decision *);\n \f\n+/* Return a position with the given BASE, TYPE and ARG.  NEXT_PTR\n+   points to where the unique object that represents the position\n+   should be stored.  Create the object if it doesn't already exist,\n+   otherwise reuse the object that is already there.  */\n+\n+static struct position *\n+next_position (struct position **next_ptr, struct position *base,\n+\t       enum position_type type, int arg)\n+{\n+  struct position *pos;\n+\n+  pos = *next_ptr;\n+  if (!pos)\n+    {\n+      pos = XCNEW (struct position);\n+      pos->base = base;\n+      pos->type = type;\n+      pos->arg = arg;\n+      pos->depth = base->depth + 1;\n+      *next_ptr = pos;\n+    }\n+  return pos;\n+}\n+\n+/* Compare positions POS1 and POS2 lexicographically.  */\n+\n+static int\n+compare_positions (struct position *pos1, struct position *pos2)\n+{\n+  int diff;\n+\n+  diff = pos1->depth - pos2->depth;\n+  if (diff < 0)\n+    do\n+      pos2 = pos2->base;\n+    while (pos1->depth != pos2->depth);\n+  else if (diff > 0)\n+    do\n+      pos1 = pos1->base;\n+    while (pos1->depth != pos2->depth);\n+  while (pos1 != pos2)\n+    {\n+      diff = (int) pos1->type - (int) pos2->type;\n+      if (diff == 0)\n+\tdiff = pos1->arg - pos2->arg;\n+      pos1 = pos1->base;\n+      pos2 = pos2->base;\n+    }\n+  return diff;\n+}\n+\n /* Create a new node in sequence after LAST.  */\n \n static struct decision *\n-new_decision (const char *position, struct decision_head *last)\n+new_decision (struct position *pos, struct decision_head *last)\n {\n   struct decision *new_decision = XCNEW (struct decision);\n \n   new_decision->success = *last;\n-  new_decision->position = xstrdup (position);\n+  new_decision->position = pos;\n   new_decision->number = next_number++;\n \n   last->first = last->last = new_decision;\n@@ -636,35 +737,31 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n    LAST is a pointer to the listhead in the previous node in the chain (or\n    in the calling function, for the first node).\n \n-   POSITION is the string representing the current position in the insn.\n+   POSITION is the current position in the insn.\n \n    INSN_TYPE is the type of insn for which we are emitting code.\n \n    A pointer to the final node in the chain is returned.  */\n \n static struct decision *\n-add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n-\t\t enum routine_type insn_type, int top)\n+add_to_sequence (rtx pattern, struct decision_head *last,\n+\t\t struct position *pos, enum routine_type insn_type, int top)\n {\n   RTX_CODE code;\n   struct decision *this_decision, *sub;\n   struct decision_test *test;\n   struct decision_test **place;\n-  char *subpos;\n+  struct position *subpos, **subpos_ptr;\n   size_t i;\n   const char *fmt;\n-  int depth = strlen (position);\n   int len;\n   enum machine_mode mode;\n+  enum position_type pos_type;\n \n-  if (depth > max_depth)\n-    max_depth = depth;\n-\n-  subpos = XNEWVAR (char, depth + 2);\n-  strcpy (subpos, position);\n-  subpos[depth + 1] = 0;\n+  if (pos->depth > max_depth)\n+    max_depth = pos->depth;\n \n-  sub = this_decision = new_decision (position, last);\n+  sub = this_decision = new_decision (pos, last);\n   place = &this_decision->tests;\n \n  restart:\n@@ -694,15 +791,15 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \t      last->first = last->last = NULL;\n \t    }\n \n+\t  subpos_ptr = &peep2_insn_pos_list;\n \t  for (i = 0; i < (size_t) XVECLEN (pattern, 0); i++)\n \t    {\n-\t      /* Which insn we're looking at is represented by A-Z. We don't\n-\t         ever use 'A', however; it is always implied.  */\n-\n-\t      subpos[depth] = (i > 0 ? 'A' + i : 0);\n+\t      subpos = next_position (subpos_ptr, &root_pos,\n+\t\t\t\t      POS_PEEP2_INSN, i);\n \t      sub = add_to_sequence (XVECEXP (pattern, 0, i),\n \t\t\t\t     last, subpos, insn_type, 0);\n \t      last = &sub->success;\n+\t      subpos_ptr = &subpos->next;\n \t    }\n \t  goto ret;\n \t}\n@@ -786,12 +883,22 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \n \tif (was_code == MATCH_OPERATOR || was_code == MATCH_PARALLEL)\n \t  {\n-\t    char base = (was_code == MATCH_OPERATOR ? '0' : 'a');\n+\t    if (was_code == MATCH_OPERATOR)\n+\t      {\n+\t\tpos_type = POS_XEXP;\n+\t\tsubpos_ptr = &pos->xexps;\n+\t      }\n+\t    else\n+\t      {\n+\t\tpos_type = POS_XVECEXP0;\n+\t\tsubpos_ptr = &pos->xvecexp0s;\n+\t      }\n \t    for (i = 0; i < (size_t) XVECLEN (pattern, 2); i++)\n \t      {\n-\t\tsubpos[depth] = i + base;\n+\t\tsubpos = next_position (subpos_ptr, pos, pos_type, i);\n \t\tsub = add_to_sequence (XVECEXP (pattern, 2, i),\n \t\t\t\t       &sub->success, subpos, insn_type, 0);\n+\t\tsubpos_ptr = &subpos->next;\n \t      }\n \t  }\n \tgoto fini;\n@@ -806,11 +913,13 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n       test = new_decision_test (DT_accept_op, &place);\n       test->u.opno = XINT (pattern, 0);\n \n+      subpos_ptr = &pos->xvecexp0s;\n       for (i = 0; i < (size_t) XVECLEN (pattern, 1); i++)\n \t{\n-\t  subpos[depth] = i + '0';\n+\t  subpos = next_position (subpos_ptr, pos, POS_XVECEXP0, i);\n \t  sub = add_to_sequence (XVECEXP (pattern, 1, i),\n \t\t\t\t &sub->success, subpos, insn_type, 0);\n+\t  subpos_ptr = &subpos->next;\n \t}\n       goto fini;\n \n@@ -874,24 +983,29 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n     }\n \n   /* Now test our sub-patterns.  */\n+  subpos_ptr = &pos->xexps;\n   for (i = 0; i < (size_t) len; i++)\n     {\n+      subpos = next_position (subpos_ptr, pos, POS_XEXP, i);\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  subpos[depth] = '0' + i;\n \t  sub = add_to_sequence (XEXP (pattern, i), &sub->success,\n \t\t\t\t subpos, insn_type, 0);\n \t  break;\n \n \tcase 'E':\n \t  {\n+\t    struct position *subpos2, **subpos2_ptr;\n \t    int j;\n+\n+\t    subpos2_ptr = &pos->xvecexp0s;\n \t    for (j = 0; j < XVECLEN (pattern, i); j++)\n \t      {\n-\t\tsubpos[depth] = 'a' + j;\n+\t\tsubpos2 = next_position (subpos2_ptr, pos, POS_XVECEXP0, j);\n \t\tsub = add_to_sequence (XVECEXP (pattern, i, j),\n-\t\t\t\t       &sub->success, subpos, insn_type, 0);\n+\t\t\t\t       &sub->success, subpos2, insn_type, 0);\n+\t\tsubpos2_ptr = &subpos2->next;\n \t      }\n \t    break;\n \t  }\n@@ -905,6 +1019,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      subpos_ptr = &subpos->next;\n     }\n \n  fini:\n@@ -928,7 +1043,6 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n   gcc_assert (this_decision->tests);\n \n  ret:\n-  free (subpos);\n   return sub;\n }\n \f\n@@ -1094,12 +1208,12 @@ maybe_both_true (struct decision *d1, struct decision *d2,\n      of a node's success nodes (from the loop at the end of this function).\n      Skip forward until we come to a position that matches.\n \n-     Due to the way position strings are constructed, we know that iterating\n-     forward from the lexically lower position (e.g. \"00\") will run into\n-     the lexically higher position (e.g. \"1\") and not the other way around.\n-     This saves a bit of effort.  */\n+     Due to the way positions are constructed, we know that iterating\n+     forward from the lexically lower position will run into the lexically\n+     higher position and not the other way around.  This saves a bit\n+     of effort.  */\n \n-  cmp = strcmp (d1->position, d2->position);\n+  cmp = compare_positions (d1->position, d2->position);\n   if (cmp != 0)\n     {\n       gcc_assert (!toplevel);\n@@ -1214,7 +1328,7 @@ nodes_identical (struct decision *d1, struct decision *d2)\n      invoked.  */\n   if (d1->success.first\n       && d2->success.first\n-      && strcmp (d1->success.first->position, d2->success.first->position))\n+      && d1->success.first->position != d2->success.first->position)\n     return 0;\n \n   return 1;\n@@ -1284,7 +1398,7 @@ merge_trees (struct decision_head *oldh, struct decision_head *addh)\n     }\n \n   /* Trying to merge bits at different positions isn't possible.  */\n-  gcc_assert (!strcmp (oldh->first->position, addh->first->position));\n+  gcc_assert (oldh->first->position == addh->first->position);\n \n   for (add = addh->first; add ; add = next)\n     {\n@@ -1543,33 +1657,31 @@ find_afterward (struct decision_head *head, struct decision *real_afterward)\n    match multiple insns and we try to step past the end of the stream.  */\n \n static void\n-change_state (const char *oldpos, const char *newpos, const char *indent)\n+change_state (struct position *oldpos, struct position *newpos,\n+\t      const char *indent)\n {\n-  int odepth = strlen (oldpos);\n-  int ndepth = strlen (newpos);\n-  int depth;\n+  while (oldpos->depth > newpos->depth)\n+    oldpos = oldpos->base;\n \n-  /* Pop up as many levels as necessary.  */\n-  for (depth = odepth; strncmp (oldpos, newpos, depth) != 0; --depth)\n-    continue;\n+  if (oldpos != newpos)\n+    switch (newpos->type)\n+      {\n+      case POS_PEEP2_INSN:\n+\tprintf (\"%stem = peep2_next_insn (%d);\\n\", indent, newpos->arg);\n+\tprintf (\"%sx%d = PATTERN (tem);\\n\", indent, newpos->depth);\n+\tbreak;\n \n-  /* Go down to desired level.  */\n-  while (depth < ndepth)\n-    {\n-      /* It's a different insn from the first one.  */\n-      if (ISUPPER (newpos[depth]))\n-\t{\n-\t  printf (\"%stem = peep2_next_insn (%d);\\n\",\n-\t\t  indent, newpos[depth] - 'A');\n-\t  printf (\"%sx%d = PATTERN (tem);\\n\", indent, depth + 1);\n-\t}\n-      else if (ISLOWER (newpos[depth]))\n+      case POS_XEXP:\n+\tchange_state (oldpos, newpos->base, indent);\n+\tprintf (\"%sx%d = XEXP (x%d, %d);\\n\",\n+\t\tindent, newpos->depth, newpos->depth - 1, newpos->arg);\n+\tbreak;\n+\n+      case POS_XVECEXP0:\n+\tchange_state (oldpos, newpos->base, indent);\n \tprintf (\"%sx%d = XVECEXP (x%d, 0, %d);\\n\",\n-\t\tindent, depth + 1, depth, newpos[depth] - 'a');\n-      else\n-\tprintf (\"%sx%d = XEXP (x%d, %c);\\n\",\n-\t\tindent, depth + 1, depth, newpos[depth]);\n-      ++depth;\n+\t\tindent, newpos->depth, newpos->depth - 1, newpos->arg);\n+\tbreak;\n     }\n }\n \f\n@@ -1942,12 +2054,13 @@ write_action (struct decision *p, struct decision_test *test,\n \n \tcase PEEPHOLE2:\n \t  {\n-\t    int match_len = 0, i;\n+\t    int match_len = 0;\n+\t    struct position *pos;\n \n-\t    for (i = strlen (p->position) - 1; i >= 0; --i)\n-\t      if (ISUPPER (p->position[i]))\n+\t    for (pos = p->position; pos; pos = pos->base)\n+\t      if (pos->type == POS_PEEP2_INSN)\n \t\t{\n-\t\t  match_len = p->position[i] - 'A';\n+\t\t  match_len = pos->arg;\n \t\t  break;\n \t\t}\n \t    printf (\"%s*_pmatch_len = %d;\\n\", indent, match_len);\n@@ -2089,7 +2202,7 @@ write_tree_1 (struct decision_head *head, int depth,\n    position at the node that branched to this node.  */\n \n static void\n-write_tree (struct decision_head *head, const char *prevpos,\n+write_tree (struct decision_head *head, struct position *prevpos,\n \t    enum routine_type type, int initial)\n {\n   struct decision *p = head->first;\n@@ -2131,10 +2244,8 @@ write_tree (struct decision_head *head, const char *prevpos,\n     }\n   else\n     {\n-      int depth = strlen (p->position);\n-\n       change_state (prevpos, p->position, \"  \");\n-      write_tree_1 (head, depth, type);\n+      write_tree_1 (head, p->position->depth, type);\n \n       for (p = head->first; p; p = p->next)\n         if (p->success.first)\n@@ -2190,7 +2301,7 @@ peephole2%s (rtx x0 ATTRIBUTE_UNUSED,\\n\\trtx insn ATTRIBUTE_UNUSED,\\n\\tint *_pma\n     printf (\"  recog_data.insn = NULL_RTX;\\n\");\n \n   if (head->first)\n-    write_tree (head, \"\", type, 1);\n+    write_tree (head, &root_pos, type, 1);\n   else\n     printf (\"  goto ret0;\\n\");\n \n@@ -2287,12 +2398,12 @@ make_insn_sequence (rtx insn, enum routine_type type)\n   struct decision *last;\n   struct decision_test *test, **place;\n   struct decision_head head;\n-  char c_test_pos[2];\n+  struct position *c_test_pos, **pos_ptr;\n \n   /* We should never see an insn whose C test is false at compile time.  */\n   gcc_assert (truth);\n \n-  c_test_pos[0] = '\\0';\n+  c_test_pos = &root_pos;\n   if (type == PEEPHOLE2)\n     {\n       int i, j;\n@@ -2304,19 +2415,20 @@ make_insn_sequence (rtx insn, enum routine_type type)\n       x = rtx_alloc (PARALLEL);\n       PUT_MODE (x, VOIDmode);\n       XVEC (x, 0) = rtvec_alloc (XVECLEN (insn, 0));\n+      pos_ptr = &peep2_insn_pos_list;\n       for (i = j = 0; i < XVECLEN (insn, 0); i++)\n \t{\n \t  rtx tmp = XVECEXP (insn, 0, i);\n \t  if (GET_CODE (tmp) != MATCH_SCRATCH && GET_CODE (tmp) != MATCH_DUP)\n \t    {\n+\t      c_test_pos = next_position (pos_ptr, &root_pos,\n+\t\t\t\t\t  POS_PEEP2_INSN, i);\n \t      XVECEXP (x, 0, j) = tmp;\n \t      j++;\n+\t      pos_ptr = &c_test_pos->next;\n \t    }\n \t}\n       XVECLEN (x, 0) = j;\n-\n-      c_test_pos[0] = 'A' + j - 1;\n-      c_test_pos[1] = '\\0';\n     }\n   else if (XVECLEN (insn, type == RECOG) == 1)\n     x = XVECEXP (insn, type == RECOG, 0);\n@@ -2330,7 +2442,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n   validate_pattern (x, insn, NULL_RTX, 0);\n \n   memset(&head, 0, sizeof(head));\n-  last = add_to_sequence (x, &head, \"\", type, 1);\n+  last = add_to_sequence (x, &head, &root_pos, type, 1);\n \n   /* Find the end of the test chain on the last node.  */\n   for (test = last->tests; test->next; test = test->next)\n@@ -2396,7 +2508,8 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \n \t      /* Recognize it.  */\n \t      memset (&clobber_head, 0, sizeof(clobber_head));\n-\t      last = add_to_sequence (new_rtx, &clobber_head, \"\", type, 1);\n+\t      last = add_to_sequence (new_rtx, &clobber_head, &root_pos,\n+\t\t\t\t      type, 1);\n \n \t      /* Find the end of the test chain on the last node.  */\n \t      for (test = last->tests; test->next; test = test->next)\n@@ -2407,7 +2520,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n \t      place = &test->next;\n \t      if (test->type == DT_accept_op)\n \t\t{\n-\t\t  last = new_decision (\"\", &last->success);\n+\t\t  last = new_decision (&root_pos, &last->success);\n \t\t  place = &last->tests;\n \t\t}\n "}]}