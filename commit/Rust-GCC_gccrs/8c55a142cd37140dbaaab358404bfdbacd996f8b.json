{"sha": "8c55a142cd37140dbaaab358404bfdbacd996f8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM1NWExNDJjZDM3MTQwZGJhYWFiMzU4NDA0YmZkYmFjZDk5NmY4Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-31T04:00:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-31T04:00:55Z"}, "message": "re PR other/19696 (gcc.c-torture/execute/ieee/copysign1.c: Unsatisfied symbols: copysignl)\n\n        PR 19696\n        * optabs.c (expand_absneg_bit): Split out from expand_unop and\n        expand_abs_nojump and generalize.  Use operand_subword and\n        emit_no_conflict_block.  Support large modes.\n        (expand_abs_nojump): Use it.  Use HONOR_SIGNED_ZEROS to fall\n        back to maximum.\n        (expand_unop): Likewise.  Use HONOR_SIGNED_ZEROS to fall back\n        negation to subtraction.\n        (expand_copysign): Check that the format has signed zeros.\n        Use operand_subword and emit_no_conflict_block.  Support large modes.\n\nFrom-SVN: r94465", "tree": {"sha": "09297aae3d1ed64cda21964266a1ed1cea3ea1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09297aae3d1ed64cda21964266a1ed1cea3ea1b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c55a142cd37140dbaaab358404bfdbacd996f8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c55a142cd37140dbaaab358404bfdbacd996f8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c55a142cd37140dbaaab358404bfdbacd996f8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c55a142cd37140dbaaab358404bfdbacd996f8b/comments", "author": null, "committer": null, "parents": [{"sha": "6fc98adf766d2ce6179d8d7a165d101c8fc00391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc98adf766d2ce6179d8d7a165d101c8fc00391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc98adf766d2ce6179d8d7a165d101c8fc00391"}], "stats": {"total": 366, "additions": 224, "deletions": 142}, "files": [{"sha": "218a95aa7cd0f1d17a87e44b5124e675b0c503e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c55a142cd37140dbaaab358404bfdbacd996f8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c55a142cd37140dbaaab358404bfdbacd996f8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c55a142cd37140dbaaab358404bfdbacd996f8b", "patch": "@@ -1,3 +1,16 @@\n+2005-01-30  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 19696\n+\t* optabs.c (expand_absneg_bit): Split out from expand_unop and\n+\texpand_abs_nojump and generalize.  Use operand_subword and\n+\temit_no_conflict_block.  Support large modes.\n+\t(expand_abs_nojump): Use it.  Use HONOR_SIGNED_ZEROS to fall\n+\tback to maximum.\n+\t(expand_unop): Likewise.  Use HONOR_SIGNED_ZEROS to fall back\n+\tnegation to subtraction.\n+\t(expand_copysign): Check that the format has signed zeros.\n+\tUse operand_subword and emit_no_conflict_block.  Support large modes.\n+\n 2005-01-30  Daniel Berlin  <dberlin@dberlin.org>\n \n \tFix PR tree-optimization/19624"}, {"sha": "a4b85b121c204d321187e90adc0a7594085dd131", "filename": "gcc/optabs.c", "status": "modified", "additions": 211, "deletions": 142, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c55a142cd37140dbaaab358404bfdbacd996f8b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c55a142cd37140dbaaab358404bfdbacd996f8b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8c55a142cd37140dbaaab358404bfdbacd996f8b", "patch": "@@ -2148,6 +2148,111 @@ lowpart_subreg_maybe_copy (enum machine_mode omode, rtx val,\n   return ret;\n }\n \n+/* Expand a floating point absolute value or negation operation via a\n+   logical operation on the sign bit.  */\n+\n+static rtx\n+expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n+\t\t   rtx op0, rtx target)\n+{\n+  const struct real_format *fmt;\n+  int bitpos, word, nwords, i;\n+  enum machine_mode imode;\n+  HOST_WIDE_INT hi, lo;\n+  rtx temp, insns;\n+\n+  /* The format has to have a simple sign bit.  */\n+  fmt = REAL_MODE_FORMAT (mode);\n+  if (fmt == NULL)\n+    return NULL_RTX;\n+\n+  bitpos = fmt->signbit;\n+  if (bitpos < 0)\n+    return NULL_RTX;\n+\n+  /* Don't create negative zeros if the format doesn't support them.  */\n+  if (code == NEG && !fmt->has_signed_zero)\n+    return NULL_RTX;\n+\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+    {\n+      imode = int_mode_for_mode (mode);\n+      if (imode == BLKmode)\n+\treturn NULL_RTX;\n+      word = 0;\n+      nwords = 1;\n+    }\n+  else\n+    {\n+      imode = word_mode;\n+\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tword = (GET_MODE_BITSIZE (mode) - bitpos) / BITS_PER_WORD;\n+      else\n+\tword = bitpos / BITS_PER_WORD;\n+      bitpos = bitpos % BITS_PER_WORD;\n+      nwords = (GET_MODE_BITSIZE (mode) + BITS_PER_WORD - 1) / BITS_PER_WORD;\n+    }\n+\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+    {\n+      hi = 0;\n+      lo = (HOST_WIDE_INT) 1 << bitpos;\n+    }\n+  else\n+    {\n+      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n+      lo = 0;\n+    }\n+  if (code == ABS)\n+    lo = ~lo, hi = ~hi;\n+\n+  if (target == 0 || target == op0)\n+    target = gen_reg_rtx (mode);\n+\n+  if (nwords > 1)\n+    {\n+      start_sequence ();\n+\n+      for (i = 0; i < nwords; ++i)\n+\t{\n+\t  rtx targ_piece = operand_subword (target, i, 1, mode);\n+\t  rtx op0_piece = operand_subword_force (op0, i, mode);\n+\t\n+\t  if (i == word)\n+\t    {\n+\t      temp = expand_binop (imode, code == ABS ? and_optab : xor_optab,\n+\t\t\t\t   op0_piece,\n+\t\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t\t\t   targ_piece, 1, OPTAB_LIB_WIDEN);\n+\t      if (temp != targ_piece)\n+\t\temit_move_insn (targ_piece, temp);\n+\t    }\n+\t  else\n+\t    emit_move_insn (targ_piece, op0_piece);\n+\t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      temp = gen_rtx_fmt_e (code, mode, copy_rtx (op0));\n+      emit_no_conflict_block (insns, target, op0, NULL_RTX, temp);\n+    }\n+  else\n+    {\n+      temp = expand_binop (imode, code == ABS ? and_optab : xor_optab,\n+\t\t\t   gen_lowpart (imode, op0),\n+\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t           gen_lowpart (imode, target), 1, OPTAB_LIB_WIDEN);\n+      target = lowpart_subreg_maybe_copy (mode, temp, imode);\n+\n+      set_unique_reg_note (get_last_insn (), REG_EQUAL,\n+\t\t\t   gen_rtx_fmt_e (code, mode, copy_rtx (op0)));\n+    }\n+\n+  return target;\n+}\n+\n /* Generate code to perform an operation specified by UNOPTAB\n    on operand OP0, with result having machine-mode MODE.\n \n@@ -2299,55 +2404,27 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       return target;\n     }\n \n-  /* Try negating floating point values by flipping the sign bit.  */\n-  if (unoptab->code == NEG && class == MODE_FLOAT\n-      && GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT)\n+  if (unoptab->code == NEG)\n     {\n-      const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n-      enum machine_mode imode = int_mode_for_mode (mode);\n-      int bitpos = (fmt != 0) ? fmt->signbit : -1;\n-\n-      if (imode != BLKmode && bitpos >= 0 && fmt->has_signed_zero)\n+      /* Try negating floating point values by flipping the sign bit.  */\n+      if (class == MODE_FLOAT)\n \t{\n-\t  HOST_WIDE_INT hi, lo;\n-\t  rtx last = get_last_insn ();\n-\n-\t  /* Handle targets with different FP word orders.  */\n-\t  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n-\t    {\n-\t      int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n-\t      int word = nwords - (bitpos / BITS_PER_WORD) - 1;\n-\t      bitpos = word * BITS_PER_WORD + bitpos % BITS_PER_WORD;\n-\t    }\n+\t  temp = expand_absneg_bit (NEG, mode, op0, target);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n \n-\t  if (bitpos < HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      hi = 0;\n-\t      lo = (HOST_WIDE_INT) 1 << bitpos;\n-\t    }\n-\t  else\n-\t    {\n-\t      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-\t      lo = 0;\n-\t    }\n-\t  temp = expand_binop (imode, xor_optab,\n-\t\t\t       gen_lowpart (imode, op0),\n-\t\t\t       immed_double_const (lo, hi, imode),\n-\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t  if (temp != 0)\n-\t    {\n-\t      rtx insn;\n-\t      if (target == 0)\n-\t\ttarget = gen_reg_rtx (mode);\n-\t      temp = lowpart_subreg_maybe_copy (mode, temp, imode);\n-\t      insn = emit_move_insn (target, temp);\n-\t      set_unique_reg_note (insn, REG_EQUAL,\n-\t\t\t\t   gen_rtx_fmt_e (NEG, mode,\n-\t\t\t\t\t\t  copy_rtx (op0)));\n-\t      return target;\n-\t    }\n-\t  delete_insns_since (last);\n-        }\n+      /* If there is no negation pattern, and we have no negative zero,\n+\t try subtracting from zero.  */\n+      if (!HONOR_SIGNED_ZEROS (mode))\n+\t{\n+\t  temp = expand_binop (mode, (unoptab == negv_optab\n+\t\t\t\t      ? subv_optab : sub_optab),\n+\t\t\t       CONST0_RTX (mode), op0, target,\n+\t\t\t       unsignedp, OPTAB_DIRECT);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n     }\n \n   /* Try calculating parity (x) as popcount (x) % 2.  */\n@@ -2358,15 +2435,6 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \treturn temp;\n     }\n \n-  /* If there is no negation pattern, try subtracting from zero.  */\n-  if (unoptab == neg_optab && class == MODE_INT)\n-    {\n-      temp = expand_binop (mode, sub_optab, CONST0_RTX (mode), op0,\n-                           target, unsignedp, OPTAB_DIRECT);\n-      if (temp)\n-\treturn temp;\n-    }\n-\n  try_libcall:\n   /* Now try a library call in this mode.  */\n   if (unoptab->handlers[(int) mode].libfunc)\n@@ -2450,18 +2518,17 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t}\n     }\n \n-  /* If there is no negate operation, try doing a subtract from zero.\n-     The US Software GOFAST library needs this.  FIXME: This is *wrong*\n-     for floating-point operations due to negative zeros!  */\n-  if (unoptab->code == NEG)\n+  /* One final attempt at implementing negation via subtraction,\n+     this time allowing widening of the operand.  */\n+  if (unoptab->code == NEG && !HONOR_SIGNED_ZEROS (mode))\n     {\n       rtx temp;\n       temp = expand_binop (mode,\n                            unoptab == negv_optab ? subv_optab : sub_optab,\n                            CONST0_RTX (mode), op0,\n                            target, unsignedp, OPTAB_LIB_WIDEN);\n       if (temp)\n-\treturn temp;\n+        return temp;\n     }\n \n   return 0;\n@@ -2492,58 +2559,16 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n     return temp;\n \n   /* For floating point modes, try clearing the sign bit.  */\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_BITSIZE (mode) <= 2 * HOST_BITS_PER_WIDE_INT)\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n-      const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n-      enum machine_mode imode = int_mode_for_mode (mode);\n-      int bitpos = (fmt != 0) ? fmt->signbit : -1;\n-\n-      if (imode != BLKmode && bitpos >= 0)\n-\t{\n-\t  HOST_WIDE_INT hi, lo;\n-\t  rtx last = get_last_insn ();\n-\n-\t  /* Handle targets with different FP word orders.  */\n-\t  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n-\t    {\n-\t      int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n-\t      int word = nwords - (bitpos / BITS_PER_WORD) - 1;\n-\t      bitpos = word * BITS_PER_WORD + bitpos % BITS_PER_WORD;\n-\t    }\n-\n-\t  if (bitpos < HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      hi = 0;\n-\t      lo = (HOST_WIDE_INT) 1 << bitpos;\n-\t    }\n-\t  else\n-\t    {\n-\t      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-\t      lo = 0;\n-\t    }\n-\t  temp = expand_binop (imode, and_optab,\n-\t\t\t       gen_lowpart (imode, op0),\n-\t\t\t       immed_double_const (~lo, ~hi, imode),\n-\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\t  if (temp != 0)\n-\t    {\n-\t      rtx insn;\n-\t      if (target == 0)\n-\t\ttarget = gen_reg_rtx (mode);\n-\t      temp = lowpart_subreg_maybe_copy (mode, temp, imode);\n-\t      insn = emit_move_insn (target, temp);\n-\t      set_unique_reg_note (insn, REG_EQUAL,\n-\t\t\t\t   gen_rtx_fmt_e (ABS, mode,\n-\t\t\t\t\t\t  copy_rtx (op0)));\n-\t      return target;\n-\t    }\n-\t  delete_insns_since (last);\n-\t}\n+      temp = expand_absneg_bit (ABS, mode, op0, target);\n+      if (temp)\n+\treturn temp;\n     }\n \n   /* If we have a MAX insn, we can do this as MAX (x, -x).  */\n-  if (smax_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  if (smax_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+      && !HONOR_SIGNED_ZEROS (mode))\n     {\n       rtx last = get_last_insn ();\n \n@@ -2642,9 +2667,9 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n   enum machine_mode mode = GET_MODE (op0);\n   const struct real_format *fmt;\n   enum machine_mode imode;\n-  int bitpos;\n+  int bitpos, word, nwords, i, have_abs;\n   HOST_WIDE_INT hi, lo;\n-  rtx last, temp;\n+  rtx temp, insns;\n \n   gcc_assert (SCALAR_FLOAT_MODE_P (mode));\n   gcc_assert (GET_MODE (op1) == mode);\n@@ -2655,27 +2680,40 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n   if (temp)\n     return temp;\n \n-  /* Otherwise, use bit operations to move the sign from one to the other.  */\n-  if (GET_MODE_BITSIZE (mode) > 2 * HOST_BITS_PER_WIDE_INT)\n-    return NULL_RTX;\n-\n-  imode = int_mode_for_mode (mode);\n-  if (imode == BLKmode)\n+  fmt = REAL_MODE_FORMAT (mode);\n+  if (fmt == NULL || !fmt->has_signed_zero)\n     return NULL_RTX;\n \n-  fmt = REAL_MODE_FORMAT (mode);\n-  bitpos = (fmt != 0) ? fmt->signbit : -1;\n+  bitpos = fmt->signbit;\n   if (bitpos < 0)\n     return NULL_RTX;\n \n-  last = get_last_insn ();\n+  have_abs = false;\n+  if (GET_CODE (op0) == CONST_DOUBLE)\n+    {\n+      if (real_isneg (CONST_DOUBLE_REAL_VALUE (op0)))\n+\top0 = simplify_unary_operation (ABS, mode, op0, mode);\n+      have_abs = true;\n+    }\n \n-  /* Handle targets with different FP word orders.  */\n-  if (FLOAT_WORDS_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+    {\n+      imode = int_mode_for_mode (mode);\n+      if (imode == BLKmode)\n+\treturn NULL_RTX;\n+      word = 0;\n+      nwords = 1;\n+    }\n+  else\n     {\n-      int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n-      int word = nwords - (bitpos / BITS_PER_WORD) - 1;\n-      bitpos = word * BITS_PER_WORD + bitpos % BITS_PER_WORD;\n+      imode = word_mode;\n+\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\tword = (GET_MODE_BITSIZE (mode) - bitpos) / BITS_PER_WORD;\n+      else\n+\tword = bitpos / BITS_PER_WORD;\n+      bitpos = bitpos % BITS_PER_WORD;\n+      nwords = (GET_MODE_BITSIZE (mode) + BITS_PER_WORD - 1) / BITS_PER_WORD;\n     }\n \n   if (bitpos < HOST_BITS_PER_WIDE_INT)\n@@ -2689,29 +2727,60 @@ expand_copysign (rtx op0, rtx op1, rtx target)\n       lo = 0;\n     }\n \n-  op0 = expand_binop (imode, and_optab,\n-\t\t      gen_lowpart (imode, op0),\n-\t\t      immed_double_const (~lo, ~hi, imode),\n-\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-  op1 = expand_binop (imode, and_optab,\n-\t\t      gen_lowpart (imode, op1),\n-\t\t      immed_double_const (lo, hi, imode),\n-\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-  if (op0 && op1)\n+  if (target == 0 || target == op0 || target == op1)\n+    target = gen_reg_rtx (mode);\n+\n+  if (nwords > 1)\n     {\n-      target = expand_binop (imode, ior_optab, op0, op1, NULL,\n-\t\t\t     1, OPTAB_LIB_WIDEN);\n-      if (target)\n+      start_sequence ();\n+\n+      for (i = 0; i < nwords; ++i)\n \t{\n-\t  target = force_reg (imode, target);\n-\t  target = gen_lowpart (mode, target);\n+\t  rtx targ_piece = operand_subword (target, i, 1, mode);\n+\t  rtx op0_piece = operand_subword_force (op0, i, mode);\n+\t\n+\t  if (i == word)\n+\t    {\n+\t      if (!have_abs)\n+\t\top0_piece = expand_binop (imode, and_optab, op0_piece,\n+\t\t\t\t\t  immed_double_const (~lo, ~hi, imode),\n+\t\t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+\t      op1 = expand_binop (imode, and_optab,\n+\t\t\t\t  operand_subword_force (op1, i, mode),\n+\t\t\t\t  immed_double_const (lo, hi, imode),\n+\t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+\t      temp = expand_binop (imode, ior_optab, op0_piece, op1,\n+\t\t\t\t   targ_piece, 1, OPTAB_LIB_WIDEN);\n+\t      if (temp != targ_piece)\n+\t\temit_move_insn (targ_piece, temp);\n+\t    }\n+\t  else\n+\t    emit_move_insn (targ_piece, op0_piece);\n \t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, target, op0, op1, NULL_RTX);\n     }\n   else\n-    target = NULL_RTX;\n-\n-  if (!target)\n-    delete_insns_since (last);\n+    {\n+      op1 = expand_binop (imode, and_optab, gen_lowpart (imode, op1),\n+\t\t          immed_double_const (lo, hi, imode),\n+\t\t          NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+      op0 = gen_lowpart (imode, op0);\n+      if (!have_abs)\n+\top0 = expand_binop (imode, and_optab, op0,\n+\t\t\t    immed_double_const (~lo, ~hi, imode),\n+\t\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\n+      temp = expand_binop (imode, ior_optab, op0, op1,\n+\t\t\t   gen_lowpart (imode, target), 1, OPTAB_LIB_WIDEN);\n+      target = lowpart_subreg_maybe_copy (mode, temp, imode);\n+    }\n \n   return target;\n }"}]}