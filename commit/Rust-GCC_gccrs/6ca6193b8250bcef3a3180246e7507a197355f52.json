{"sha": "6ca6193b8250bcef3a3180246e7507a197355f52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNhNjE5M2I4MjUwYmNlZjNhMzE4MDI0NmU3NTA3YTE5NzM1NWY1Mg==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-09-29T18:25:20Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-09-29T18:25:20Z"}, "message": "* expmed.c (extract_bit_field): Fix bit-field extraction from SUBREGs.\n\nFrom-SVN: r57629", "tree": {"sha": "3090aa165727f2794affe010b3a28910ea6e18e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3090aa165727f2794affe010b3a28910ea6e18e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ca6193b8250bcef3a3180246e7507a197355f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca6193b8250bcef3a3180246e7507a197355f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca6193b8250bcef3a3180246e7507a197355f52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca6193b8250bcef3a3180246e7507a197355f52/comments", "author": null, "committer": null, "parents": [{"sha": "d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e"}], "stats": {"total": 45, "additions": 19, "deletions": 26}, "files": [{"sha": "2e488edf25aa3ca7c7469bf2006304538041f678", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca6193b8250bcef3a3180246e7507a197355f52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca6193b8250bcef3a3180246e7507a197355f52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ca6193b8250bcef3a3180246e7507a197355f52", "patch": "@@ -1,3 +1,7 @@\n+2002-09-29  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* expmed.c (extract_bit_field): Fix bit-field extraction from SUBREGs.\n+\n 2002-09-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* builtins.def: Fix comment formatting."}, {"sha": "730c4c1de036c7d36be299aeed98e5b3769ae59c", "filename": "gcc/expmed.c", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca6193b8250bcef3a3180246e7507a197355f52/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca6193b8250bcef3a3180246e7507a197355f52/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6ca6193b8250bcef3a3180246e7507a197355f52", "patch": "@@ -1031,25 +1031,15 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n   if (tmode == VOIDmode)\n     tmode = mode;\n+\n   while (GET_CODE (op0) == SUBREG)\n     {\n-      int outer_size = GET_MODE_BITSIZE (GET_MODE (op0));\n-      int inner_size = GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)));\n-\n-      offset += SUBREG_BYTE (op0) / UNITS_PER_WORD;\n-\n-      inner_size = MIN (inner_size, BITS_PER_WORD);\n-\n-      if (BYTES_BIG_ENDIAN && (outer_size < inner_size))\n+      bitpos += SUBREG_BYTE (op0) * BITS_PER_UNIT;\n+      if (bitpos > unit)\n \t{\n-\t  bitpos += inner_size - outer_size;\n-\t  if (bitpos > unit)\n-\t    {\n-\t      offset += (bitpos / unit);\n-\t      bitpos %= unit;\n-\t    }\n+\t  offset += (bitpos / unit);\n+\t  bitpos %= unit;\n \t}\n-\n       op0 = SUBREG_REG (op0);\n     }\n \n@@ -1086,9 +1076,13 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       set_mem_expr (op0, 0);\n     }\n \n-  /* ??? We currently assume TARGET is at least as big as BITSIZE.\n-     If that's wrong, the solution is to test for it and set TARGET to 0\n-     if needed.  */\n+  /* Extraction of a full-word or multi-word value from a structure\n+     in a register or aligned memory can be done with just a SUBREG.\n+     A subword value in the least significant part of a register\n+     can also be extracted with a SUBREG.  For this, we need the\n+     byte offset of the value in op0.  */\n+\n+  byte_offset = bitpos / BITS_PER_UNIT + offset * UNITS_PER_WORD;\n \n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n@@ -1098,14 +1092,9 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       && unit > GET_MODE_BITSIZE (GET_MODE (op0)))\n     bitpos += unit - GET_MODE_BITSIZE (GET_MODE (op0));\n \n-  /* Extracting a full-word or multi-word value\n-     from a structure in a register or aligned memory.\n-     This can be done with just SUBREG.\n-     So too extracting a subword value in\n-     the least significant part of the register.  */\n-\n-  byte_offset = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n-                + (offset * UNITS_PER_WORD);\n+  /* ??? We currently assume TARGET is at least as big as BITSIZE.\n+     If that's wrong, the solution is to test for it and set TARGET to 0\n+     if needed.  */\n \n   mode1  = (VECTOR_MODE_P (tmode)\n \t    ? mode"}]}