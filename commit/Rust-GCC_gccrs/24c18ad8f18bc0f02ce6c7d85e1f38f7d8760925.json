{"sha": "24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRjMThhZDhmMThiYzBmMDJjZTZjN2Q4NWUxZjM4ZjdkODc2MDkyNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-14T17:54:28Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-14T17:54:28Z"}, "message": "re PR target/50751 (SH Target: Displacement addressing does not work for QImode and HImode)\n\n\tPR target/50751\n\t* config/sh/constraints.md (Sra): New constraint.\n\t* config/sh/predicates.md (simple_mem_operand,\n\tdisplacement_mem_operand, zero_extend_movu_operand): New predicates.\n\t(zero_extend_operand): Check zero_extend_movu_operand for SH2A.\n\t* config/sh/sh.md (*zero_extendqisi2_disp_mem,\n\t*zero_extendhisi2_disp_mem): Add new insns and two new related\n\tpeephole2 patterns.\n\n\tPR target/50751\n\t* gcc.target/sh/pr50751-8.c: New.\n\nFrom-SVN: r190395", "tree": {"sha": "eb5a4b33277049c21203ba1ce59d9343c5995452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb5a4b33277049c21203ba1ce59d9343c5995452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/comments", "author": null, "committer": null, "parents": [{"sha": "bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbeffd6b40a97a661e78e10556a5b5f3edc4d78f"}], "stats": {"total": 227, "additions": 226, "deletions": 1}, "files": [{"sha": "5b7457bfa527215b49932fd7b58fb6ee68bf8565", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -1,3 +1,14 @@\n+2012-08-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* config/sh/constraints.md (Sra): New constraint.\n+\t* config/sh/predicates.md (simple_mem_operand,\n+\tdisplacement_mem_operand, zero_extend_movu_operand): New predicates.\n+\t(zero_extend_operand): Check zero_extend_movu_operand for SH2A.\n+\t* config/sh/sh.md (*zero_extendqisi2_disp_mem,\n+\t*zero_extendhisi2_disp_mem): Add new insns and two new related\n+\tpeephole2 patterns.\n+\n 2012-08-14  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* graphite-scop-detection.c (create_sese_edges): Compute dominance"}, {"sha": "47350dff22b5f6ed13405b137e91f1e25d4d79cf", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -49,6 +49,7 @@\n ;;  Sbw: QImode address with 12 bit displacement\n ;;  Snd: address without displacement\n ;;  Sdd: address with displacement\n+;;  Sra: simple register address\n ;; W: vector\n ;; Z: zero in any mode\n ;;\n@@ -307,3 +308,8 @@\n        (match_test \"GET_MODE (op) == QImode\")\n        (match_test \"satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1))\")))\n \n+(define_memory_constraint \"Sra\"\n+  \"A memory reference that uses a simple register addressing.\"\n+  (and (match_test \"MEM_P (op)\")\n+       (match_test \"REG_P (XEXP (op, 0))\")))\n+"}, {"sha": "12f69db976ea2d571c01cd8a2bbef03d0ebd13d7", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -368,12 +368,33 @@\n \t  : nonimmediate_operand) (op, mode);\n })\n \n+;; Returns 1 if OP is a simple register address.\n+(define_predicate \"simple_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"arith_reg_operand (XEXP (op, 0), SImode)\")))\n+\n+;; Returns 1 if OP is a valid displacement address.\n+(define_predicate \"displacement_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n+       (match_test \"arith_reg_operand (XEXP (XEXP (op, 0), 0), SImode)\")\n+       (match_test \"sh_legitimate_index_p (GET_MODE (op),\n+\t\t\t\t\t   XEXP (XEXP (op, 0), 1),\n+\t\t\t\t\t   TARGET_SH2A, true)\")))\n+\n+;; Returns 1 if the operand can be used in an SH2A movu.{b|w} insn.\n+(define_predicate \"zero_extend_movu_operand\"\n+  (and (match_operand 0 \"displacement_mem_operand\")\n+       (match_test \"GET_MODE (op) == QImode || GET_MODE (op) == HImode\")))\n+\n ;; Returns 1 if the operand can be used in a zero_extend.\n (define_predicate \"zero_extend_operand\"\n   (ior (and (match_test \"TARGET_SHMEDIA\")\n \t    (match_operand 0 \"general_extend_operand\"))\n        (and (match_test \"! TARGET_SHMEDIA\")\n-\t    (match_operand 0 \"arith_reg_operand\"))))\n+\t    (match_operand 0 \"arith_reg_operand\"))\n+       (and (match_test \"TARGET_SH2A\")\n+\t    (match_operand 0 \"zero_extend_movu_operand\"))))\n \n ;; Returns 1 if OP can be source of a simple move operation. Same as\n ;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as"}, {"sha": "3462dd19d614c99544e4c1e86e655d0d033539a1", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -4842,6 +4842,88 @@ label:\n   \"extu.b\t%1,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; SH2A supports two zero extending load instructions: movu.b and movu.w.\n+;; They could also be used for simple memory addresses like @Rn by setting\n+;; the displacement value to zero.  However, doing so too early results in\n+;; missed opportunities for other optimizations such as post-inc or index\n+;; addressing loads.\n+;; Although the 'zero_extend_movu_operand' predicate does not allow simple\n+;; register addresses (an address without a displacement, index, post-inc),\n+;; zero-displacement addresses might be generated during reload, wich are\n+;; simplified to simple register addresses in turn.  Thus, we have to\n+;; provide the Sdd and Sra alternatives in the patterns.\n+(define_insn \"*zero_extendqisi2_disp_mem\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(zero_extend:SI\n+\t  (match_operand:QI 1 \"zero_extend_movu_operand\" \"Sdd,Sra\")))]\n+  \"TARGET_SH2A\"\n+  \"@\n+\tmovu.b\t%1,%0\n+\tmovu.b\t@(0,%t1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*zero_extendhisi2_disp_mem\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(zero_extend:SI\n+\t  (match_operand:HI 1 \"zero_extend_movu_operand\" \"Sdd,Sra\")))]\n+  \"TARGET_SH2A\"\n+  \"@\n+\tmovu.w\t%1,%0\n+\tmovu.w\t@(0,%t1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Convert the zero extending loads in sequences such as:\n+;;\tmovu.b\t@(1,r5),r0\tmovu.w\t@(2,r5),r0\n+;;\tmov.b\tr0,@(1,r4)\tmov.b\tr0,@(1,r4)\n+;;\n+;; back to sign extending loads like:\n+;;\tmov.b\t@(1,r5),r0\tmov.w\t@(2,r5),r0\n+;;\tmov.b\tr0,@(1,r4)\tmov.b\tr0,@(1,r4)\n+;;\n+;; if the extension type is irrelevant.  The sign extending mov.{b|w} insn\n+;; is only 2 bytes in size if the displacement is {K04|K05}.\n+;; If the displacement is greater it doesn't matter, so we convert anyways.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(zero_extend:SI (match_operand 1 \"displacement_mem_operand\" \"\")))\n+   (set (match_operand 2 \"general_operand\" \"\")\n+\t(match_operand 3 \"arith_reg_operand\" \"\"))]\n+  \"TARGET_SH2A\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && peep2_reg_dead_p (2, operands[0])\n+   && GET_MODE_SIZE (GET_MODE (operands[2]))\n+      <= GET_MODE_SIZE (GET_MODE (operands[1]))\"\n+  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 2) (match_dup 3))])\n+\n+;; Fold sequences such as\n+;;\tmov.b\t@r3,r7\n+;;\textu.b\tr7,r7\n+;; into\n+;;\tmovu.b\t@(0,r3),r7\n+;; This does not reduce the code size but the number of instructions is\n+;; halved, which results in faster code.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI (match_operand 1 \"simple_mem_operand\" \"\")))\n+   (set (match_operand:SI 2 \"arith_reg_dest\" \"\")\n+\t(zero_extend:SI (match_operand 3 \"arith_reg_operand\" \"\")))]\n+  \"TARGET_SH2A\n+   && GET_MODE (operands[1]) == GET_MODE (operands[3])\n+   && (GET_MODE (operands[1]) == QImode || GET_MODE (operands[1]) == HImode)\n+   && REGNO (operands[0]) == REGNO (operands[3])\n+   && (REGNO (operands[2]) == REGNO (operands[0])\n+       || peep2_reg_dead_p (2, operands[0]))\"\n+  [(set (match_dup 2) (zero_extend:SI (match_dup 4)))]\n+{\n+  operands[4]\n+    = replace_equiv_address (operands[1],\n+\t\t\t     gen_rtx_PLUS (SImode, XEXP (operands[1], 0),\n+\t\t\t\t\t   const0_rtx));\n+})\n+\n ;; -------------------------------------------------------------------------\n ;; Sign extension instructions\n ;; -------------------------------------------------------------------------"}, {"sha": "c1325cdbe2f1f6a01f987f299faf0b94c2814a4d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -1,3 +1,8 @@\n+2012-08-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* gcc.target/sh/pr50751-8.c: New.\n+\n 2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/47586"}, {"sha": "bced631a17e3533c69780c01ad7fe70d70c72ee2", "filename": "gcc/testsuite/gcc.target/sh/pr50751-8.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr50751-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr50751-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr50751-8.c?ref=24c18ad8f18bc0f02ce6c7d85e1f38f7d8760925", "patch": "@@ -0,0 +1,100 @@\n+/* Check that on SH2A the 4 byte movu.b and movu.w displacement insns are\n+   generated.  This has to be checked with -O2 because some of the patterns\n+   rely on peepholes.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"movu.b\" 4 } } */\n+/* { dg-final { scan-assembler-times \"movu.w\" 3 } } */\n+\n+int\n+test_00 (unsigned char* x)\n+{\n+  /* 1x movu.b  */\n+  return x[0];\n+}\n+\n+int\n+test_01 (unsigned short* x)\n+{\n+  /* 1x movu.w  */\n+  return x[0];\n+}\n+\n+int\n+test_02 (unsigned char* x)\n+{\n+  /* 1x movu.b  */\n+  return x[1];\n+}\n+\n+int\n+test_03 (unsigned char* x)\n+{\n+  /* 1x movu.b  */\n+  return x[32];\n+}\n+\n+int\n+test_04 (unsigned char* x)\n+{\n+  /* 1x movu.b  */\n+  return x[9000];\n+}\n+\n+int\n+test_05 (unsigned short* x)\n+{\n+  /* 1x movu.w  */\n+  return x[9000];\n+}\n+\n+int\n+test_06 (unsigned char* x, int i)\n+{\n+  /* No movu.b expected here.  Should use mov.b (r0,r4) + extu.b instead.  */\n+  return x[i];\n+}\n+\n+int\n+test_07 (unsigned short* x, int i)\n+{\n+  /* No movu.w expected here.  Should use mov.w (r0,r4) + extu.w instead.  */\n+  return x[i];\n+}\n+\n+int\n+test_08 (unsigned char* x, int c)\n+{\n+  /* No movu.b expected here.  Should use post-inc addressing instead.  */\n+  int s = 0;\n+  int i;\n+  for (i = 0; i < c; ++i)\n+    s += x[i];\n+  return s;\n+}\n+\n+void\n+test_09 (unsigned char* x, unsigned char* y)\n+{\n+  /* No movu.b expected here, since the zero-extension is irrelevant.  */\n+  x[1] = y[1];\n+  x[2] = y[2];\n+}\n+\n+void\n+test_10 (unsigned char* x, unsigned short* y)\n+{\n+  /* No movu.w expected here, since the zero-extension is irrelevant.  */\n+  x[1] = y[1];\n+  x[2] = y[2];\n+}\n+\n+int\n+test_11 (unsigned char* x, unsigned short* y)\n+{\n+  /* 1x movu.w  */\n+  int yy = y[1];\n+  x[1] = yy;\n+  return yy;\n+}"}]}