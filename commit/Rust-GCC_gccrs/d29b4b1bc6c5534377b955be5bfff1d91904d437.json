{"sha": "d29b4b1bc6c5534377b955be5bfff1d91904d437", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5YjRiMWJjNmM1NTM0Mzc3Yjk1NWJlNWJmZmYxZDkxOTA0ZDQzNw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-04-13T18:34:23Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-04-13T18:34:23Z"}, "message": "CRIS prologue as RTL.\n\n\t* config/cris/cris-protos.h (cris_emit_movem_store)\n\t(cris_expand_prologue): Prototype.\n\t* config/cris/cris.c (struct machine_function): New member\n\tstdarg_regs.\n\t(cfa_label_num, cris_target_asm_function_prologue): Remove.\n\t(TARGET_ASM_FUNCTION_PROLOGUE): Don't override.\n\t(cris_general_operand_or_gotless_symbol): Accept CRIS_UNSPEC_GOT.\n\t(cris_load_multiple_op, cris_return_address_on_stack)\n\t(cris_return_address_on_stack_for_return): ISO-Cify.\n\t(cris_store_multiple_op): New predicate function.\n\t(cris_expand_prologue, cris_emit_movem_store): New functions.\n\t(cris_print_operand) <case 'O'>: Handle modifications other than\n\tpost-increment.\n\t(cris_symbol, cris_got_symbol): Return 0 for CRIS_UNSPEC_GOT.\n\t(cris_gotless_symbol): Return 1 for CRIS_UNSPEC_GOT.\n\t(cris_gen_movem_load): Rearrange slightly to make local variable\n\tsrc a parameter, removing osrc.\n\t(cris_setup_incoming_varargs): Set machine_function member\n\tstdarg_regs to correspond to the number of registers that need to\n\tbe saved.\n\t* config/cris/cris.h (EXTRA_CONSTRAINT_S): Accept\n\tCRIS_UNSPEC_GOT.\n\t(PREDICATE_CODES): Add cris_store_multiple_op.  Make\n\tcris_general_operand_or_gotless_symbol accept UNSPEC.\n\t* config/cris/cris.md (CRIS_UNSPEC_GOT): New constant.\n\t(\"*movsi_internal\") <alternative 8>: Handle CRIS_UNSPEC_GOT.\n\t(\"*cris_store_multiple\"): New pattern.  Tweak common comment above\n\tthis and \"*cris_load_multiple\".\n\t(\"prologue\"): New define_expand.\n\nFrom-SVN: r98103", "tree": {"sha": "a65e11008cd992f33285e7826f9ae9291179c433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a65e11008cd992f33285e7826f9ae9291179c433"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d29b4b1bc6c5534377b955be5bfff1d91904d437", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29b4b1bc6c5534377b955be5bfff1d91904d437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29b4b1bc6c5534377b955be5bfff1d91904d437", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29b4b1bc6c5534377b955be5bfff1d91904d437/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6dfafa0476fab3ab28020ca6b541b60d55c743c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dfafa0476fab3ab28020ca6b541b60d55c743c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6dfafa0476fab3ab28020ca6b541b60d55c743c"}], "stats": {"total": 984, "additions": 656, "deletions": 328}, "files": [{"sha": "ba9097747bae9222f0ee46db0dbc6a067bf64e58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d29b4b1bc6c5534377b955be5bfff1d91904d437", "patch": "@@ -1,5 +1,36 @@\n 2005-04-13  Hans-Peter Nilsson  <hp@axis.com>\n \n+\tCRIS prologue as RTL.\n+\t* config/cris/cris-protos.h (cris_emit_movem_store)\n+\t(cris_expand_prologue): Prototype.\n+\t* config/cris/cris.c (struct machine_function): New member\n+\tstdarg_regs.\n+\t(cfa_label_num, cris_target_asm_function_prologue): Remove.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE): Don't override.\n+\t(cris_general_operand_or_gotless_symbol): Accept CRIS_UNSPEC_GOT.\n+\t(cris_load_multiple_op, cris_return_address_on_stack)\n+\t(cris_return_address_on_stack_for_return): ISO-Cify.\n+\t(cris_store_multiple_op): New predicate function.\n+\t(cris_expand_prologue, cris_emit_movem_store): New functions.\n+\t(cris_print_operand) <case 'O'>: Handle modifications other than\n+\tpost-increment.\n+\t(cris_symbol, cris_got_symbol): Return 0 for CRIS_UNSPEC_GOT.\n+\t(cris_gotless_symbol): Return 1 for CRIS_UNSPEC_GOT.\n+\t(cris_gen_movem_load): Rearrange slightly to make local variable\n+\tsrc a parameter, removing osrc.\n+\t(cris_setup_incoming_varargs): Set machine_function member\n+\tstdarg_regs to correspond to the number of registers that need to\n+\tbe saved.\n+\t* config/cris/cris.h (EXTRA_CONSTRAINT_S): Accept\n+\tCRIS_UNSPEC_GOT.\n+\t(PREDICATE_CODES): Add cris_store_multiple_op.  Make\n+\tcris_general_operand_or_gotless_symbol accept UNSPEC.\n+\t* config/cris/cris.md (CRIS_UNSPEC_GOT): New constant.\n+\t(\"*movsi_internal\") <alternative 8>: Handle CRIS_UNSPEC_GOT.\n+\t(\"*cris_store_multiple\"): New pattern.  Tweak common comment above\n+\tthis and \"*cris_load_multiple\".\n+\t(\"prologue\"): New define_expand.\n+\n \t* config/cris/cris.md (\"epilogue\"): Conditionalize on\n \tTARGET_PROLOGUE_EPILOGUE.\n "}, {"sha": "571f1795cd2ab4c44451a5fcbd05ae47105be2bd", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=d29b4b1bc6c5534377b955be5bfff1d91904d437", "patch": "@@ -45,9 +45,11 @@ extern void cris_asm_output_symbol_ref (FILE *, rtx);\n extern bool cris_output_addr_const_extra (FILE *, rtx);\n extern int cris_cfun_uses_pic_table (void);\n extern rtx cris_gen_movem_load (rtx, rtx, int);\n+extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n #endif /* RTX_CODE */\n extern void cris_asm_output_label_ref (FILE *, char *);\n extern void cris_target_asm_named_section (const char *, unsigned int, tree);\n+extern void cris_expand_prologue (void);\n extern void cris_expand_epilogue (void);\n extern void cris_expand_return (bool);\n extern bool cris_return_address_on_stack_for_return (void);"}, {"sha": "f7822d4b112cc465dc7cdb320b8c544032d63787", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 567, "deletions": 306, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=d29b4b1bc6c5534377b955be5bfff1d91904d437", "patch": "@@ -74,6 +74,11 @@ enum cris_retinsn_type\n struct machine_function GTY(())\n  {\n    int needs_return_address_on_stack;\n+\n+   /* This is the number of registers we save in the prologue due to\n+      stdarg.  */\n+   int stdarg_regs;\n+\n    enum cris_retinsn_type return_type;\n  };\n \n@@ -111,8 +116,6 @@ static int cris_initial_frame_pointer_offset (void);\n \n static int saved_regs_mentioned (rtx);\n \n-static void cris_target_asm_function_prologue (FILE *, HOST_WIDE_INT);\n-\n static void cris_operand_lossage (const char *, rtx);\n \n static int cris_reg_saved_in_regsave_area  (unsigned int, bool);\n@@ -171,9 +174,6 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_ASM_UNALIGNED_DI_OP\n #define TARGET_ASM_UNALIGNED_DI_OP TARGET_ASM_ALIGNED_DI_OP\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE cris_target_asm_function_prologue\n-\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK cris_asm_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -431,12 +431,13 @@ cris_general_operand_or_symbol (rtx op, enum machine_mode mode)\n \n /* Since a PIC symbol without a GOT entry is not a general_operand, we\n    have to have a predicate that matches it.  We use this in the expanded\n-   \"movsi\" anonymous pattern for PIC symbols.  */\n+   \"movsi\" anonymous pattern.  */\n \n int\n cris_general_operand_or_gotless_symbol (rtx op, enum machine_mode mode)\n {\n   return general_operand (op, mode)\n+    || (GET_CODE (op) == UNSPEC && XINT (op, 1) == CRIS_UNSPEC_GOT)\n     || (CONSTANT_P (op) && cris_gotless_symbol (op));\n }\n \n@@ -556,13 +557,124 @@ cris_movem_load_rest_p (rtx op, int offs)\n /* Predicate for the parallel contents in a movem from-memory.  */\n \n int\n-cris_load_multiple_op (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cris_load_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return cris_movem_load_rest_p (op, 0);\n }\n \n+/* Predicate for the parallel contents in a movem to-memory.  */\n+\n+int\n+cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int reg_count = XVECLEN (op, 0);\n+  rtx dest;\n+  rtx dest_addr;\n+  rtx dest_base;\n+  int i;\n+  rtx elt;\n+  int setno;\n+  int regno_dir = 1;\n+  int regno = 0;\n+  int offset = 0;\n+\n+  /* Perform a quick check so we don't blow up below.  FIXME: Adjust for\n+     other than (MEM reg) and (MEM (PLUS reg const)).  */\n+  if (reg_count <= 1)\n+    return 0;\n+\n+  elt = XVECEXP (op, 0, 0);\n+\n+  if (GET_CODE (elt) != SET)\n+    return  0;\n+\n+  dest = SET_DEST (elt);\n+\n+  if (GET_CODE (SET_SRC (elt)) != REG\n+      || GET_CODE (dest) != MEM)\n+    return 0;\n+\n+  dest_addr = XEXP (dest, 0);\n+\n+  /* Check a possible post-inc indicator.  */\n+  if (GET_CODE (SET_SRC (XVECEXP (op, 0, 1))) == PLUS)\n+    {\n+      rtx reg = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 0);\n+      rtx inc = XEXP (SET_SRC (XVECEXP (op, 0, 1)), 1);\n+\n+      reg_count--;\n+\n+      if (reg_count == 1\n+\t  || !REG_P (reg)\n+\t  || !REG_P (SET_DEST (XVECEXP (op, 0, 1)))\n+\t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, 1)))\n+\t  || GET_CODE (inc) != CONST_INT\n+\t  /* Support increment by number of registers, and by the offset\n+\t     of the destination, if it has the form (MEM (PLUS reg\n+\t     offset)).  */\n+\t  || !((REG_P (dest_addr)\n+\t\t&& REGNO (dest_addr) == REGNO (reg)\n+\t\t&& INTVAL (inc) == (HOST_WIDE_INT) reg_count * 4)\n+\t       || (GET_CODE (dest_addr) == PLUS\n+\t\t   && REG_P (XEXP (dest_addr, 0))\n+\t\t   && REGNO (XEXP (dest_addr, 0)) == REGNO (reg)\n+\t\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT\n+\t\t   && INTVAL (XEXP (dest_addr, 1)) == INTVAL (inc))))\n+\treturn 0;\n+\n+      i = 2;\n+    }\n+  else\n+    i = 1;\n+\n+  /* FIXME: These two only for pre-v32.  */\n+  regno_dir = -1;\n+  regno = reg_count - 1;\n+\n+  if (GET_CODE (elt) != SET\n+      || GET_CODE (SET_SRC (elt)) != REG\n+      || GET_MODE (SET_SRC (elt)) != SImode\n+      || REGNO (SET_SRC (elt)) != (unsigned int) regno\n+      || GET_CODE (SET_DEST (elt)) != MEM\n+      || GET_MODE (SET_DEST (elt)) != SImode)\n+    return 0;\n+\n+  if (REG_P (dest_addr))\n+    {\n+      dest_base = dest_addr;\n+      offset = 0;\n+    }\n+  else if (GET_CODE (dest_addr) == PLUS\n+\t   && REG_P (XEXP (dest_addr, 0))\n+\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT)\n+    {\n+      dest_base = XEXP (dest_addr, 0);\n+      offset = INTVAL (XEXP (dest_addr, 1));\n+    }\n+  else\n+    return 0;\n+\n+  for (setno = 1; i < XVECLEN (op, 0); setno++, i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+      regno += regno_dir;\n+\n+      if (GET_CODE (elt) != SET\n+\t  || GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_MODE (SET_SRC (elt)) != SImode\n+\t  || REGNO (SET_SRC (elt)) != (unsigned int) regno\n+\t  || GET_CODE (SET_DEST (elt)) != MEM\n+\t  || GET_MODE (SET_DEST (elt)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+\t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_base)\n+\t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != setno * 4 + offset)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n /* The CONDITIONAL_REGISTER_USAGE worker.  */\n \n void\n@@ -775,280 +887,6 @@ cris_reg_saved_in_regsave_area (unsigned int regno, bool got_really_used)\n \t    || regno == EH_RETURN_DATA_REGNO (3)));\n }\n \n-/* This variable belongs to cris_target_asm_function_prologue but must\n-   be located outside it for GTY reasons.  */\n-static GTY(()) unsigned long cfa_label_num = 0;\n-\n-/* Textual function prologue.  */\n-\n-static void\n-cris_target_asm_function_prologue (FILE *file, HOST_WIDE_INT size)\n-{\n-  int regno;\n-\n-  /* Shorten the used name for readability.  */\n-  int cfoa_size = current_function_outgoing_args_size;\n-  int last_movem_reg = -1;\n-  int doing_dwarf = dwarf2out_do_frame ();\n-  int framesize;\n-  int faked_args_size = 0;\n-  int cfa_write_offset = 0;\n-  static char cfa_label[30];\n-  bool return_address_on_stack = cris_return_address_on_stack ();\n-  bool got_really_used = current_function_uses_pic_offset_table;\n-\n-  /* Don't do anything if no prologues or epilogues are wanted.  */\n-  if (!TARGET_PROLOGUE_EPILOGUE)\n-    return;\n-\n-  if (size < 0)\n-    abort ();\n-\n-  /* Align the size to what's best for the CPU model.  */\n-  if (TARGET_STACK_ALIGN)\n-    size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n-\n-  if (current_function_pretend_args_size)\n-    {\n-      int pretend = current_function_pretend_args_size;\n-      for (regno = CRIS_FIRST_ARG_REG + CRIS_MAX_ARGS_IN_REGS - 1;\n-\t   pretend > 0;\n-\t   regno--, pretend -= 4)\n-\t{\n-\t  fprintf (file, \"\\tpush $%s\\n\", reg_names[regno]);\n-\t  faked_args_size += 4;\n-\t}\n-    }\n-\n-  framesize = faked_args_size;\n-\n-  if (doing_dwarf)\n-    {\n-      /* FIXME: Slightly redundant calculation, as we do the same in\n-\t pieces below.  This offset must be the total adjustment of the\n-\t stack-pointer.  We can then def_cfa call at the end of this\n-\t function with the current implementation of execute_cfa_insn, but\n-\t that wouldn't really be clean.  */\n-\n-      int cfa_offset\n-\t= faked_args_size\n-\t+ (return_address_on_stack ? 4 : 0)\n-\t+ (frame_pointer_needed ? 4 : 0);\n-\n-      int cfa_reg;\n-\n-      if (frame_pointer_needed)\n-\tcfa_reg = FRAME_POINTER_REGNUM;\n-      else\n-\t{\n-\t  cfa_reg = STACK_POINTER_REGNUM;\n-\t  cfa_offset += cris_initial_frame_pointer_offset ();\n-\t}\n-\n-      ASM_GENERATE_INTERNAL_LABEL (cfa_label, \"LCFIT\",\n-\t\t\t\t   cfa_label_num++);\n-      dwarf2out_def_cfa (cfa_label, cfa_reg, cfa_offset);\n-\n-      cfa_write_offset = - faked_args_size - 4;\n-    }\n-\n-  /* Save SRP if not a leaf function.  */\n-  if (return_address_on_stack)\n-    {\n-      fprintf (file, \"\\tPush $srp\\n\");\n-      framesize += 4;\n-\n-      if (doing_dwarf)\n-\t{\n-\t  dwarf2out_return_save (cfa_label, cfa_write_offset);\n-\t  cfa_write_offset -= 4;\n-\t}\n-    }\n-\n-  /* Set up frame pointer if needed.  */\n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\tpush $%s\\n\\tmove.d $sp,$%s\\n\",\n-\t       reg_names[FRAME_POINTER_REGNUM],\n-\t       reg_names[FRAME_POINTER_REGNUM]);\n-      framesize += 4;\n-\n-      if (doing_dwarf)\n-\t{\n-\t  dwarf2out_reg_save (cfa_label, FRAME_POINTER_REGNUM,\n-\t\t\t      cfa_write_offset);\n-\t  cfa_write_offset -= 4;\n-\t}\n-    }\n-\n-  /* Local vars are located above saved regs.  */\n-  cfa_write_offset -= size;\n-\n-  /* Get a contiguous sequence of registers, starting with r0, that need\n-     to be saved.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    {\n-      if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n-\t{\n-\t  /* Check if movem may be used for registers so far.  */\n-\t  if (regno == last_movem_reg + 1)\n-\t    /* Yes, update next expected register.  */\n-\t    last_movem_reg++;\n-\t  else\n-\t    {\n-\t      /* We cannot use movem for all registers.  We have to flush\n-\t\t any movem:ed registers we got so far.  */\n-\t      if (last_movem_reg != -1)\n-\t\t{\n-\t\t  /* It is a win to use a side-effect assignment for\n-\t\t     64 <= size <= 128.  But side-effect on movem was\n-\t\t     not usable for CRIS v0..3.  Also only do it if\n-\t\t     side-effects insns are allowed.  */\n-\t\t  if ((last_movem_reg + 1) * 4 + size >= 64\n-\t\t      && (last_movem_reg + 1) * 4 + size <= 128\n-\t\t      && cris_cpu_version >= CRIS_CPU_SVINTO\n-\t\t      && TARGET_SIDE_EFFECT_PREFIXES)\n-\t\t    fprintf (file, \"\\tmovem $%s,[$sp=$sp-\"HOST_WIDE_INT_PRINT_DEC\"]\\n\",\n-\t\t\t     reg_names[last_movem_reg],\n-\t\t\t     (last_movem_reg + 1) * 4 + size);\n-\t\t  else\n-\t\t    {\n-\t\t      /* Avoid printing multiple subsequent sub:s for sp.  */\n-\t\t      fprintf (file, \"\\tsub%s \"HOST_WIDE_INT_PRINT_DEC\",$sp\\n\",\n-\t\t\t       ADDITIVE_SIZE_MODIFIER ((last_movem_reg + 1)\n-\t\t\t\t\t\t       * 4 + size),\n-\t\t\t       (last_movem_reg + 1) * 4 + size);\n-\n-\t\t      fprintf (file, \"\\tmovem $%s,[$sp]\\n\",\n-\t\t\t       reg_names[last_movem_reg]);\n-\t\t    }\n-\n-\t\t  framesize += (last_movem_reg + 1) * 4 + size;\n-\n-\t\t  if (TARGET_PDEBUG)\n-\t\t    fprintf (file, \"; frame \"HOST_WIDE_INT_PRINT_DEC\n-\t\t\t     \", #regs %d, bytes %d args %d\\n\",\n-\t\t\t     size,\n-\t\t\t     last_movem_reg + 1,\n-\t\t\t     (last_movem_reg + 1) * 4,\n-\t\t\t     current_function_args_size);\n-\n-\t\t  last_movem_reg = -1;\n-\t\t  size = 0;\n-\t\t}\n-\t      else if (size > 0)\n-\t\t{\n-\t\t  /* Local vars on stack, but there are no movem:s.\n-\t\t     Just allocate space.  */\n-\t\t  fprintf (file, \"\\tSub%s \"HOST_WIDE_INT_PRINT_DEC\",$sp\\n\",\n-\t\t\t   ADDITIVE_SIZE_MODIFIER (size),\n-\t\t\t   size);\n-\t\t  framesize += size;\n-\t\t  size = 0;\n-\t\t}\n-\n-\t      fprintf (file, \"\\tPush $%s\\n\", reg_names[regno]);\n-\t      framesize += 4;\n-\t    }\n-\n-\t  if (doing_dwarf)\n-\t    {\n-\t      /* Registers are stored lowest numbered at highest address,\n-\t\t which matches the loop order; we just need to update the\n-\t\t write-offset.  */\n-\t      dwarf2out_reg_save (cfa_label, regno, cfa_write_offset);\n-\t      cfa_write_offset -= 4;\n-\t    }\n-\t}\n-    }\n-\n-  /* Check after, if we can movem all registers.  This is the normal\n-     case.  */\n-  if (last_movem_reg != -1)\n-    {\n-      /* Side-effect assignment on movem was not supported for CRIS v0..3,\n-\t and don't do it if we're asked not to.\n-\n-\t The movem is already accounted for, for unwind.  */\n-\n-      if ((last_movem_reg + 1) * 4 + size >= 64\n-\t  && (last_movem_reg + 1) * 4 + size <= 128\n-\t  && cris_cpu_version >= CRIS_CPU_SVINTO\n-\t  && TARGET_SIDE_EFFECT_PREFIXES)\n-\tfprintf (file, \"\\tmovem $%s,[$sp=$sp-\"HOST_WIDE_INT_PRINT_DEC\"]\\n\",\n-\t\t reg_names[last_movem_reg],\n-\t\t (last_movem_reg+1) * 4 + size);\n-      else\n-\t{\n-\t  /* Avoid printing multiple subsequent sub:s for sp.  FIXME:\n-\t     Clean up the conditional expression.  */\n-\t  fprintf (file, \"\\tsub%s \"HOST_WIDE_INT_PRINT_DEC\",$sp\\n\",\n-\t\t   ADDITIVE_SIZE_MODIFIER ((last_movem_reg + 1) * 4 + size),\n-\t\t   (last_movem_reg + 1) * 4 + size);\n-\t  /* To be compatible with v0..v3 means we do not use an assignment\n-\t     addressing mode with movem.  We normally don't need that\n-\t     anyway.  It would only be slightly more efficient for 64..128\n-\t     bytes frame size.  */\n-\t  fprintf (file, \"\\tmovem $%s,[$sp]\\n\", reg_names[last_movem_reg]);\n-\t}\n-\n-      framesize += (last_movem_reg + 1) * 4 + size;\n-\n-      if (TARGET_PDEBUG)\n-\tfprintf (file, \"; frame \"HOST_WIDE_INT_PRINT_DEC\n-\t\t \", #regs %d, bytes %d args %d\\n\",\n-\t\t size,\n-\t\t last_movem_reg + 1,\n-\t\t (last_movem_reg + 1) * 4,\n-\t\t current_function_args_size);\n-\n-      /* We have to put outgoing argument space after regs.  */\n-      if (cfoa_size)\n-\t{\n-\t  /* This does not need to be accounted for, for unwind.  */\n-\n-\t  fprintf (file, \"\\tSub%s %d,$sp\\n\",\n-\t\t   ADDITIVE_SIZE_MODIFIER (cfoa_size),\n-\t\t   cfoa_size);\n-\t  framesize += cfoa_size;\n-\t}\n-    }\n-  else if ((size + cfoa_size) > 0)\n-    {\n-      /* This does not need to be accounted for, for unwind.  */\n-\n-      /* Local vars on stack, and we could not use movem.  Add a sub here.  */\n-      fprintf (file, \"\\tSub%s \"HOST_WIDE_INT_PRINT_DEC\",$sp\\n\",\n-\t       ADDITIVE_SIZE_MODIFIER (size + cfoa_size),\n-\t       cfoa_size + size);\n-      framesize += size + cfoa_size;\n-    }\n-\n-  /* Set up the PIC register.  */\n-  if (current_function_uses_pic_offset_table)\n-    fprintf (file, \"\\tmove.d $pc,$%s\\n\\tsub.d .:GOTOFF,$%s\\n\",\n-\t     reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t     reg_names[PIC_OFFSET_TABLE_REGNUM]);\n-\n-  if (doing_dwarf)\n-    ASM_OUTPUT_LABEL (file, cfa_label);\n-\n-  if (TARGET_PDEBUG)\n-    fprintf (file,\n-\t     \"; parm #%d @ %d; frame \" HOST_WIDE_INT_PRINT_DEC\n-\t     \", FP-SP is %d; leaf: %s%s; fp %s, outg: %d arg %d\\n\",\n-\t     CRIS_MAX_ARGS_IN_REGS + 1, FIRST_PARM_OFFSET (0),\n-\t     get_frame_size (),\n-\t     cris_initial_frame_pointer_offset (),\n-\t     leaf_function_p () ? \"yes\" : \"no\",\n-\t     return_address_on_stack ? \"no\" :\"yes\",\n-\t     frame_pointer_needed ? \"yes\" : \"no\",\n-\t     cfoa_size, current_function_args_size);\n-\n-  if (cris_max_stackframe && framesize > cris_max_stackframe)\n-    warning (\"stackframe too big: %d bytes\", framesize);\n-}\n-\n /* Return nonzero if there are regs mentioned in the insn that are not all\n    in the call_used regs.  This is part of the decision whether an insn\n    can be put in the epilogue.  */\n@@ -1176,11 +1014,24 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t  ? XEXP (SET_SRC (XVECEXP (x, 0, 0)), 0)\n \t  : XEXP (SET_DEST (XVECEXP (x, 0, 0)), 0);\n \n-\t/* The second item can be a (set reg (plus reg const)) to denote a\n-\t   post-increment.  */\n+\t/* The second item can be a (set reg (plus reg const)) to denote\n+\t   a modification.  */\n \tif (GET_CODE (SET_SRC (XVECEXP (x, 0, 1))) == PLUS)\n-\t  addr = gen_rtx_POST_INC (SImode, addr);\n-\n+\t  {\n+\t    /* It's a post-increment, if the address is a naked (reg).  */\n+\t    if (REG_P (addr))\n+\t      addr = gen_rtx_POST_INC (SImode, addr);\n+\t    else\n+\t      {\n+\t\t/* Otherwise, it's a side-effect; RN=RN+M.  */\n+\t\tfprintf (file, \"[$%s=$%s%s%d]\",\n+\t\t\t reg_names [REGNO (SET_DEST (XVECEXP (x, 0, 1)))],\n+\t\t\t reg_names [REGNO (XEXP (addr, 0))],\n+\t\t\t INTVAL (XEXP (addr, 1)) < 0 ? \"\" : \"+\",\n+\t\t\t (int) INTVAL (XEXP (addr, 1)));\n+\t\treturn;\n+\t      }\n+\t  }\n \toutput_address (addr);\n       }\n       return;\n@@ -1561,7 +1412,7 @@ cris_return_addr_rtx (int count, rtx frameaddr ATTRIBUTE_UNUSED)\n    there.  */\n \n bool\n-cris_return_address_on_stack ()\n+cris_return_address_on_stack (void)\n {\n   return regs_ever_live[CRIS_SRP_REGNUM]\n     || cfun->machine->needs_return_address_on_stack;\n@@ -1571,7 +1422,7 @@ cris_return_address_on_stack ()\n    there.  */\n \n bool\n-cris_return_address_on_stack_for_return ()\n+cris_return_address_on_stack_for_return (void)\n {\n   return cfun->machine->return_type == CRIS_RETINSN_RET ? false\n     : cris_return_address_on_stack ();\n@@ -2325,6 +2176,8 @@ cris_symbol (rtx x)\n       return 1;\n \n     case UNSPEC:\n+      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n+\treturn 0;\n       /* A PLT reference.  */\n       ASSERT_PLT_UNSPEC (x);\n       return 1;\n@@ -2363,6 +2216,8 @@ cris_gotless_symbol (rtx x)\n   switch (GET_CODE (x))\n     {\n     case UNSPEC:\n+      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n+\treturn 1;\n       ASSERT_PLT_UNSPEC (x);\n       return 1;\n \n@@ -2422,6 +2277,8 @@ cris_got_symbol (rtx x)\n   switch (GET_CODE (x))\n     {\n     case UNSPEC:\n+      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n+\treturn 0;\n       ASSERT_PLT_UNSPEC (x);\n       return 0;\n \n@@ -2806,6 +2663,277 @@ cris_split_movdx (rtx *operands)\n   return val;\n }\n \n+/* The expander for the prologue pattern name.  */\n+\n+void\n+cris_expand_prologue (void)\n+{\n+  int regno;\n+  int size = get_frame_size ();\n+  /* Shorten the used name for readability.  */\n+  int cfoa_size = current_function_outgoing_args_size;\n+  int last_movem_reg = -1;\n+  int framesize = 0;\n+  rtx mem, insn;\n+  int return_address_on_stack = cris_return_address_on_stack ();\n+  int got_really_used = current_function_uses_pic_offset_table;\n+  int n_movem_regs = 0;\n+  int pretend = current_function_pretend_args_size;\n+\n+  /* Don't do anything if no prologues or epilogues are wanted.  */\n+  if (!TARGET_PROLOGUE_EPILOGUE)\n+    return;\n+\n+  if (size < 0)\n+    abort ();\n+\n+  /* Align the size to what's best for the CPU model.  */\n+  if (TARGET_STACK_ALIGN)\n+    size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n+\n+  if (pretend)\n+    {\n+      /* See also cris_setup_incoming_varargs where\n+\t cfun->machine->stdarg_regs is set.  There are other setters of\n+\t current_function_pretend_args_size than stdarg handling, like\n+\t for an argument passed with parts in R13 and stack.  We must\n+\t not store R13 into the pretend-area for that case, as GCC does\n+\t that itself.  \"Our\" store would be marked as redundant and GCC\n+\t will attempt to remove it, which will then be flagged as an\n+\t internal error; trying to remove a frame-related insn.  */\n+      int stdarg_regs = cfun->machine->stdarg_regs;\n+\n+      framesize += pretend;\n+\n+      for (regno = CRIS_FIRST_ARG_REG + CRIS_MAX_ARGS_IN_REGS - 1;\n+\t   stdarg_regs > 0;\n+\t   regno--, pretend -= 4, stdarg_regs--)\n+\t{\n+\t  insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t-4)));\n+\t  /* FIXME: When dwarf2 frame output and unless asynchronous\n+\t     exceptions, make dwarf2 bundle together all stack\n+\t     adjustments like it does for registers between stack\n+\t     adjustments.  */\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+\t  set_mem_alias_set (mem, get_varargs_alias_set ());\n+\t  insn = emit_move_insn (mem, gen_rtx_raw_REG (SImode, regno));\n+\n+\t  /* Note the absence of RTX_FRAME_RELATED_P on the above insn:\n+\t     the value isn't restored, so we don't want to tell dwarf2\n+\t     that it's been stored to stack, else EH handling info would\n+\t     get confused.  */\n+\t}\n+\n+      /* For other setters of current_function_pretend_args_size, we\n+\t just adjust the stack by leaving the remaining size in\n+\t \"pretend\", handled below.  */\n+    }\n+\n+  /* Save SRP if not a leaf function.  */\n+  if (return_address_on_stack)\n+    {\n+      insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    -4 - pretend)));\n+      pretend = 0;\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n+      insn = emit_move_insn (mem, gen_rtx_raw_REG (SImode, CRIS_SRP_REGNUM));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      framesize += 4;\n+    }\n+\n+  /* Set up the frame pointer, if needed.  */\n+  if (frame_pointer_needed)\n+    {\n+      insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    -4 - pretend)));\n+      pretend = 0;\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+      set_mem_alias_set (mem, get_frame_alias_set ());\n+      insn = emit_move_insn (mem, frame_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      framesize += 4;\n+    }\n+\n+  /* Between frame-pointer and saved registers lie the area for local\n+     variables.  If we get here with \"pretended\" size remaining, count\n+     it into the general stack size.  */\n+  size += pretend;\n+\n+  /* Get a contiguous sequence of registers, starting with R0, that need\n+     to be saved.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n+\t{\n+\t  n_movem_regs++;\n+\n+\t  /* Check if movem may be used for registers so far.  */\n+\t  if (regno == last_movem_reg + 1)\n+\t    /* Yes, update next expected register.  */\n+\t    last_movem_reg = regno;\n+\t  else\n+\t    {\n+\t      /* We cannot use movem for all registers.  We have to flush\n+\t\t any movem:ed registers we got so far.  */\n+\t      if (last_movem_reg != -1)\n+\t\t{\n+\t\t  int n_saved\n+\t\t    = (n_movem_regs == 1) ? 1 : last_movem_reg + 1;\n+\n+\t\t  /* It is a win to use a side-effect assignment for\n+\t\t     64 <= size <= 128.  But side-effect on movem was\n+\t\t     not usable for CRIS v0..3.  Also only do it if\n+\t\t     side-effects insns are allowed.  */\n+\t\t  if ((last_movem_reg + 1) * 4 + size >= 64\n+\t\t      && (last_movem_reg + 1) * 4 + size <= 128\n+\t\t      && (cris_cpu_version >= CRIS_CPU_SVINTO || n_saved == 1)\n+\t\t      && TARGET_SIDE_EFFECT_PREFIXES)\n+\t\t    {\n+\t\t      mem\n+\t\t\t= gen_rtx_MEM (SImode,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      -(n_saved * 4 + size)));\n+\t\t      set_mem_alias_set (mem, get_frame_alias_set ());\n+\t\t      insn\n+\t\t\t= cris_emit_movem_store (mem, GEN_INT (n_saved),\n+\t\t\t\t\t\t -(n_saved * 4 + size),\n+\t\t\t\t\t\t true);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      insn\n+\t\t\t= gen_rtx_SET (VOIDmode,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      -(n_saved * 4 + size)));\n+\t\t      insn = emit_insn (insn);\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t\t      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+\t\t      set_mem_alias_set (mem, get_frame_alias_set ());\n+\t\t      insn = cris_emit_movem_store (mem, GEN_INT (n_saved),\n+\t\t\t\t\t\t    0, true);\n+\t\t    }\n+\n+\t\t  framesize += n_saved * 4 + size;\n+\t\t  last_movem_reg = -1;\n+\t\t  size = 0;\n+\t\t}\n+\n+\t      insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t    -4 - size)));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t      mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+\t      set_mem_alias_set (mem, get_frame_alias_set ());\n+\t      insn = emit_move_insn (mem, gen_rtx_raw_REG (SImode, regno));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t      framesize += 4 + size;\n+\t      size = 0;\n+\t    }\n+\t}\n+    }\n+\n+  /* Check after, if we could movem all registers.  This is the normal case.  */\n+  if (last_movem_reg != -1)\n+    {\n+      int n_saved\n+\t= (n_movem_regs == 1) ? 1 : last_movem_reg + 1;\n+\n+      /* Side-effect on movem was not usable for CRIS v0..3.  Also only\n+\t do it if side-effects insns are allowed.  */\n+      if ((last_movem_reg + 1) * 4 + size >= 64\n+\t  && (last_movem_reg + 1) * 4 + size <= 128\n+\t  && (cris_cpu_version >= CRIS_CPU_SVINTO || n_saved == 1)\n+\t  && TARGET_SIDE_EFFECT_PREFIXES)\n+\t{\n+\t  mem\n+\t    = gen_rtx_MEM (SImode,\n+\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t  -(n_saved * 4 + size)));\n+\t  set_mem_alias_set (mem, get_frame_alias_set ());\n+\t  insn = cris_emit_movem_store (mem, GEN_INT (n_saved),\n+\t\t\t\t\t-(n_saved * 4 + size), true);\n+\t}\n+      else\n+\t{\n+\t  insn\n+\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t  -(n_saved * 4 + size)));\n+\t  insn = emit_insn (insn);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  mem = gen_rtx_MEM (SImode, stack_pointer_rtx);\n+\t  set_mem_alias_set (mem, get_frame_alias_set ());\n+\t  insn = cris_emit_movem_store (mem, GEN_INT (n_saved), 0, true);\n+\t}\n+\n+      framesize += n_saved * 4 + size;\n+      /* We have to put outgoing argument space after regs.  */\n+      if (cfoa_size)\n+\t{\n+\t  insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t-cfoa_size)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  framesize += cfoa_size;\n+\t}\n+    }\n+  else if ((size + cfoa_size) > 0)\n+    {\n+      insn = emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t     stack_pointer_rtx,\n+\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    -(cfoa_size + size))));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      framesize += size + cfoa_size;\n+    }\n+\n+  /* Set up the PIC register, if it is used.  */\n+  if (got_really_used)\n+    {\n+      rtx got\n+\t= gen_rtx_UNSPEC (SImode, gen_rtvec (1, const0_rtx), CRIS_UNSPEC_GOT);\n+      emit_move_insn (pic_offset_table_rtx, got);\n+\n+      /* FIXME: This is a cover-up for flow2 messing up; it doesn't\n+\t follow exceptional paths and tries to delete the GOT load as\n+\t unused, if it isn't used on the non-exceptional paths.  Other\n+\t ports have similar or other cover-ups, or plain bugs marking\n+\t the GOT register load as maybe-dead.  To see this, remove the\n+\t line below and try libsupc++/vec.cc or a trivial\n+\t \"static void y (); void x () {try {y ();} catch (...) {}}\".  */\n+      emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+    }\n+\n+  if (cris_max_stackframe && framesize > cris_max_stackframe)\n+    warning (\"stackframe too big: %d bytes\", framesize);\n+}\n+\n /* The expander for the epilogue pattern.  */\n \n void\n@@ -2991,14 +3119,13 @@ cris_expand_epilogue (void)\n /* Worker function for generating movem from mem for load_multiple.  */\n \n rtx\n-cris_gen_movem_load (rtx osrc, rtx nregs_rtx, int nprefix)\n+cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n {\n   int nregs = INTVAL (nregs_rtx);\n   rtvec vec;\n   int eltno = 1;\n   int i;\n-  rtx srcreg = XEXP (osrc, 0);\n-  rtx src = osrc;\n+  rtx srcreg = XEXP (src, 0);\n   unsigned int regno = nregs - 1;\n   int regno_inc = -1;\n \n@@ -3009,25 +3136,26 @@ cris_gen_movem_load (rtx osrc, rtx nregs_rtx, int nprefix)\n     abort ();\n \n   /* Don't use movem for just one insn.  The insns are equivalent except\n-     for the pipeline hazard; movem does not forward the loaded\n-     registers so there's a three cycles penalty for use.  */\n+     for the pipeline hazard (on v32); movem does not forward the loaded\n+     registers so there's a three cycles penalty for their use.  */\n   if (nregs == 1)\n-    return gen_movsi (gen_rtx_REG (SImode, regno), osrc);\n+    return gen_movsi (gen_rtx_REG (SImode, 0), src);\n \n   vec = rtvec_alloc (nprefix + nregs\n-\t\t     + (GET_CODE (XEXP (osrc, 0)) == POST_INC));\n-  src = replace_equiv_address (osrc, srcreg);\n-  RTVEC_ELT (vec, nprefix)\n-    = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno), src);\n-  regno += regno_inc;\n+\t\t     + (GET_CODE (XEXP (src, 0)) == POST_INC));\n \n-  if (GET_CODE (XEXP (osrc, 0)) == POST_INC)\n+  if (GET_CODE (XEXP (src, 0)) == POST_INC)\n     {\n       RTVEC_ELT (vec, nprefix + 1)\n \t= gen_rtx_SET (VOIDmode, srcreg, plus_constant (srcreg, nregs * 4));\n       eltno++;\n     }\n \n+  src = replace_equiv_address (src, srcreg);\n+  RTVEC_ELT (vec, nprefix)\n+    = gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, regno), src);\n+  regno += regno_inc;\n+\n   for (i = 1; i < nregs; i++, eltno++)\n     {\n       RTVEC_ELT (vec, nprefix + eltno)\n@@ -3039,6 +3167,136 @@ cris_gen_movem_load (rtx osrc, rtx nregs_rtx, int nprefix)\n   return gen_rtx_PARALLEL (VOIDmode, vec);\n }\n \n+/* Worker function for generating movem to mem.  If FRAME_RELATED, notes\n+   are added that the dwarf2 machinery understands.  */\n+\n+rtx\n+cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n+\t\t       bool frame_related)\n+{\n+  int nregs = INTVAL (nregs_rtx);\n+  rtvec vec;\n+  int eltno = 1;\n+  int i;\n+  rtx insn;\n+  rtx destreg = XEXP (dest, 0);\n+  unsigned int regno = nregs - 1;\n+  int regno_inc = -1;\n+\n+  if (GET_CODE (destreg) == POST_INC)\n+    increment += nregs * 4;\n+\n+  if (GET_CODE (destreg) == POST_INC || GET_CODE (destreg) == PLUS)\n+    destreg = XEXP (destreg, 0);\n+\n+  if (!REG_P (destreg))\n+    abort ();\n+\n+  /* Don't use movem for just one insn.  The insns are equivalent except\n+     for the pipeline hazard (on v32); movem does not forward the loaded\n+     registers so there's a three cycles penalty for use.  */\n+  if (nregs == 1)\n+    {\n+      rtx mov = gen_rtx_SET (VOIDmode, dest, gen_rtx_REG (SImode, 0));\n+\n+      if (increment == 0)\n+\t{\n+\t  insn = emit_insn (mov);\n+\t  if (frame_related)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  return insn;\n+\t}\n+\n+      /* If there was a request for a side-effect, create the ordinary\n+         parallel.  */\n+      vec = rtvec_alloc (2);\n+\n+      RTVEC_ELT (vec, 0) = mov;\n+      RTVEC_ELT (vec, 1) = gen_rtx_SET (VOIDmode, destreg,\n+\t\t\t\t\tplus_constant (destreg, increment));\n+      if (frame_related)\n+\t{\n+\t  RTX_FRAME_RELATED_P (mov) = 1;\n+\t  RTX_FRAME_RELATED_P (RTVEC_ELT (vec, 1)) = 1;\n+\t}\n+    }\n+  else\n+    {\n+      vec = rtvec_alloc (nregs + (increment != 0 ? 1 : 0));\n+      RTVEC_ELT (vec, 0)\n+\t= gen_rtx_SET (VOIDmode,\n+\t\t       replace_equiv_address (dest,\n+\t\t\t\t\t      plus_constant (destreg,\n+\t\t\t\t\t\t\t     increment)),\n+\t\t       gen_rtx_REG (SImode, regno));\n+      regno += regno_inc;\n+\n+      /* The dwarf2 info wants this mark on each component in a parallel\n+\t that's part of the prologue (though it's optional on the first\n+\t component).  */\n+      if (frame_related)\n+\tRTX_FRAME_RELATED_P (RTVEC_ELT (vec, 0)) = 1;\n+\n+      if (increment != 0)\n+\t{\n+\t  RTVEC_ELT (vec, 1)\n+\t    = gen_rtx_SET (VOIDmode, destreg,\n+\t\t\t   plus_constant (destreg,\n+\t\t\t\t\t  increment != 0\n+\t\t\t\t\t  ? increment : nregs * 4));\n+\t  eltno++;\n+\n+\t  if (frame_related)\n+\t    RTX_FRAME_RELATED_P (RTVEC_ELT (vec, 1)) = 1;\n+\n+\t  /* Don't call adjust_address_nv on a post-incremented address if\n+\t     we can help it.  */\n+\t  if (GET_CODE (XEXP (dest, 0)) == POST_INC)\n+\t    dest = replace_equiv_address (dest, destreg);\n+\t}\n+\n+      for (i = 1; i < nregs; i++, eltno++)\n+\t{\n+\t  RTVEC_ELT (vec, eltno)\n+\t    = gen_rtx_SET (VOIDmode, adjust_address_nv (dest, SImode, i * 4),\n+\t\t\t   gen_rtx_REG (SImode, regno));\n+\t  if (frame_related)\n+\t    RTX_FRAME_RELATED_P (RTVEC_ELT (vec, eltno)) = 1;\n+\t  regno += regno_inc;\n+\t}\n+    }\n+\n+  insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+\n+  /* Because dwarf2out.c handles the insns in a parallel as a sequence,\n+     we need to keep the stack adjustment separate, after the\n+     MEM-setters.  Else the stack-adjustment in the second component of\n+     the parallel would be mishandled; the offsets for the SETs that\n+     follow it would be wrong.  We prepare for this by adding a\n+     REG_FRAME_RELATED_EXPR with the MEM-setting parts in a SEQUENCE\n+     followed by the increment.  Note that we have FRAME_RELATED_P on\n+     all the SETs, including the original stack adjustment SET in the\n+     parallel.  */\n+  if (frame_related)\n+    {\n+      if (increment != 0)\n+\t{\n+\t  rtx seq = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (nregs + 1));\n+\t  XVECEXP (seq, 0, 0) = XVECEXP (PATTERN (insn), 0, 0);\n+\t  for (i = 1; i < nregs; i++)\n+\t    XVECEXP (seq, 0, i) = XVECEXP (PATTERN (insn), 0, i + 1);\n+\t  XVECEXP (seq, 0, nregs) = XVECEXP (PATTERN (insn), 0, 1);\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, seq,\n+\t\t\t\t REG_NOTES (insn));\n+\t}\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  return insn;\n+}\n+\n /* Use from within code, from e.g. PRINT_OPERAND and\n    PRINT_OPERAND_ADDRESS.  Macros used in output_addr_const need to emit\n    different things depending on whether code operand or constant is\n@@ -3175,13 +3433,16 @@ cris_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n \t\t\t     int second_time)\n {\n   if (ca->regs < CRIS_MAX_ARGS_IN_REGS)\n-    *pretend_arg_size = (CRIS_MAX_ARGS_IN_REGS - ca->regs) * 4;\n-  if (TARGET_PDEBUG)\n     {\n-      fprintf (asm_out_file,\n-\t       \"\\n; VA:: ANSI: %d args before, anon @ #%d, %dtime\\n\",\n-\t       ca->regs, *pretend_arg_size, second_time);\n+      int stdarg_regs = CRIS_MAX_ARGS_IN_REGS - ca->regs;\n+      cfun->machine->stdarg_regs = stdarg_regs;\n+      *pretend_arg_size = stdarg_regs * 4;\n     }\n+\n+  if (TARGET_PDEBUG)\n+    fprintf (asm_out_file,\n+\t     \"\\n; VA:: ANSI: %d args before, anon @ #%d, %dtime\\n\",\n+\t     ca->regs, *pretend_arg_size, second_time);\n }\n \n /* Return true if TYPE must be passed by invisible reference."}, {"sha": "1b3a8f28755f5f7318b2a7f06fbd273df059dc10", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=d29b4b1bc6c5534377b955be5bfff1d91904d437", "patch": "@@ -854,8 +854,13 @@ enum reg_class\n \t\t  && BIAP_INDEX_P (XEXP (XEXP (X, 0), 0))))))\t\t\\\n  )\n \n-#define EXTRA_CONSTRAINT_S(X) \\\n- (flag_pic && CONSTANT_P (X) && cris_gotless_symbol (X))\n+/* We're kind of out of constraints, so we use \"S\" for both gotless\n+   symbols and the GOT-address load.  Both must go in a general register\n+   only: for pre-V32, arithmetic is done on the destination.  */\n+#define EXTRA_CONSTRAINT_S(X)\t\t\t\t\t\t\\\n+ (flag_pic\t\t\t\t\t\t\t\t\\\n+  && ((CONSTANT_P (X) && cris_gotless_symbol (X))\t\t\t\\\n+      || (GET_CODE (X) == UNSPEC && XINT ((X), 1) == CRIS_UNSPEC_GOT)))\n \n #define EXTRA_CONSTRAINT_U(X) \\\n  (flag_pic && CONSTANT_P (X) && cris_got_symbol (X))\n@@ -1629,6 +1634,8 @@ struct cum_args {int regs;};\n   {MEM}},\t\t\t\t\t\t\\\n  {\"cris_load_multiple_op\",\t\t\t\t\\\n   {PARALLEL}},\t\t\t\t\t\t\\\n+ {\"cris_store_multiple_op\",\t\t\t\t\\\n+  {PARALLEL}},\t\t\t\t\t\t\\\n  {\"cris_bdap_operand\",\t\t\t\t\t\\\n   {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n    CONST_DOUBLE, CONST, SIGN_EXTEND}},\t\t\t\\\n@@ -1637,7 +1644,7 @@ struct cum_args {int regs;};\n    CONST_DOUBLE, CONST, SIGN_EXTEND, MULT}},\t\t\\\n  {\"cris_general_operand_or_gotless_symbol\",\t\t\\\n   {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n-   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n+   LABEL_REF, SUBREG, REG, MEM, UNSPEC}},\t\t\\\n  {\"cris_general_operand_or_symbol\",\t\t\t\\\n   {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n    LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\"}, {"sha": "945685706b76105fa09a03a780eed575e86791bf", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d29b4b1bc6c5534377b955be5bfff1d91904d437/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=d29b4b1bc6c5534377b955be5bfff1d91904d437", "patch": "@@ -59,11 +59,12 @@\n ;; 0 PLT reference from call expansion: operand 0 is the address,\n ;;   the mode is VOIDmode.  Always wrapped in CONST.\n ;; 1 Stack frame deallocation barrier.\n+;; 2 The address of the global offset table as a source operand.\n \n (define_constants\n   [(CRIS_UNSPEC_PLT 0)\n-   (CRIS_UNSPEC_FRAME_DEALLOC 1)])\n-\n+   (CRIS_UNSPEC_FRAME_DEALLOC 1)\n+   (CRIS_UNSPEC_GOT 2)])\n \n ;; Register numbers.\n (define_constants\n@@ -1067,21 +1068,33 @@\n \t}\n       return \\\"move.d %1,%0\\\";\n \n-      case 8:\n-\t/* FIXME: Try and split this into pieces GCC makes better code of,\n-\t   than this multi-insn pattern.  Synopsis: wrap the GOT-relative\n-\t   symbol into an unspec, and when PIC, recognize the unspec\n-\t   everywhere a symbol is normally recognized.  (The PIC register\n-\t   should be recognized by GCC as pic_offset_table_rtx when needed\n-\t   and similar for PC.)  Each component can then be optimized with\n-\t   the rest of the code; it should be possible to have a constant\n-\t   term added on an unspec.  Don't forget to add a REG_EQUAL (or\n-\t   is it REG_EQUIV) note to the destination.  It might not be\n-\t   worth it.  Measure.\n-\n-\t   Note that the 'v' modifier makes PLT references be output as\n-\t   sym:PLT rather than [rPIC+sym:GOTPLT].  */\n-\treturn \\\"move.d %v1,%0\\;add.d %P1,%0\\\";\n+    case 8:\n+      /* FIXME: Try and split this into pieces GCC makes better code of,\n+\t than this multi-insn pattern.  Synopsis: wrap the GOT-relative\n+\t symbol into an unspec, and when PIC, recognize the unspec\n+\t everywhere a symbol is normally recognized.  (The PIC register\n+\t should be recognized by GCC as pic_offset_table_rtx when needed\n+\t and similar for PC.)  Each component can then be optimized with\n+\t the rest of the code; it should be possible to have a constant\n+\t term added on an unspec.  Don't forget to add a REG_EQUAL (or\n+\t is it REG_EQUIV) note to the destination.  It might not be\n+\t worth it.  Measure.\n+\n+\t Note that the 'v' modifier makes PLT references be output as\n+\t sym:PLT rather than [rPIC+sym:GOTPLT].  */\n+      if (GET_CODE (operands[1]) == UNSPEC\n+\t  && XINT (operands[1], 1) == CRIS_UNSPEC_GOT)\n+\t{\n+\t  /* We clobber cc0 rather than set it to GOT.  Should not\n+             matter, though.  */\n+\t  CC_STATUS_INIT;\n+\t  if (REGNO (operands[0]) != PIC_OFFSET_TABLE_REGNUM)\n+\t    abort ();\n+\n+\t  return \\\"move.d $pc,%0\\;sub.d .:GOTOFF,%0\\\";\n+\t}\n+\n+      return \\\"move.d %v1,%0\\;add.d %P1,%0\\\";\n \n     default:\n       return \\\"BOGUS: %1 to %0\\\";\n@@ -1387,8 +1400,8 @@\n    move %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no,yes,yes,yes,no,yes,no\")])\n \n-;; Note that the order of the registers is the reverse of that of the\n-;; standard pattern \"load_multiple\".\n+;; Note that the memory layout of the registers is the reverse of that\n+;; of the standard patterns \"load_multiple\" and \"store_multiple\".\n (define_insn \"*cris_load_multiple\"\n   [(match_parallel 0 \"cris_load_multiple_op\"\n \t\t   [(set (match_operand:SI 1 \"register_operand\" \"=r,r\")\n@@ -1404,6 +1417,15 @@\n    ;; FIXME: temporary change until all insn lengths are correctly\n    ;; described.  FIXME: have better target control over bb-reorder.\n    (set_attr \"length\" \"0\")])\n+\n+(define_insn \"*cris_store_multiple\"\n+  [(match_parallel 0 \"cris_store_multiple_op\"\n+\t\t   [(set (match_operand:SI 2 \"memory_operand\" \"=Q,m\")\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r,r\"))])]\n+  \"\"\n+  \"movem %o0,%O0\"\n+  [(set_attr \"cc\" \"none\")\n+   (set_attr \"slottable\" \"yes,no\")])\n \f\n \n ;; Sign- and zero-extend insns with standard names.\n@@ -3515,6 +3537,11 @@\n  \t (const_string \"no\")\n \t (const_string \"has_slot\")))])\n \n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"TARGET_PROLOGUE_EPILOGUE\"\n+  \"cris_expand_prologue (); DONE;\")\n+\n ;; Note that the (return) from the expander itself is always the last\n ;; insn in the epilogue.\n (define_expand \"epilogue\""}]}