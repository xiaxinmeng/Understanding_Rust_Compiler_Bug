{"sha": "4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2MDY4ZWFkY2Y5ODAxYjllZjRlNWYxYjdiNjM1NDk0N2MyN2NhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:14:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:14:16Z"}, "message": "poly_int: SLP max_units\n\nThis match makes tree-vect-slp.c track the maximum number of vector\nunits as a poly_uint64 rather than an unsigned int.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-slp.c (vect_record_max_nunits, vect_build_slp_tree_1)\n\t(vect_build_slp_tree_2, vect_build_slp_tree): Change max_nunits\n\tfrom an unsigned int * to a poly_uint64_pod *.\n\t(calculate_unrolling_factor): New function.\n\t(vect_analyze_slp_instance): Use it.  Track polynomial max_nunits.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256127", "tree": {"sha": "c6485575da5ad430ec8735c4b89a7c7d133bbf38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6485575da5ad430ec8735c4b89a7c7d133bbf38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8/comments", "author": null, "committer": null, "parents": [{"sha": "d9f21f6acb3aa615834e855e16b6311cd18c5668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f21f6acb3aa615834e855e16b6311cd18c5668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f21f6acb3aa615834e855e16b6311cd18c5668"}], "stats": {"total": 93, "additions": 58, "deletions": 35}, "files": [{"sha": "45579c740bc324e6bed0bdd47621c10b11fb68a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "patch": "@@ -1,3 +1,13 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-slp.c (vect_record_max_nunits, vect_build_slp_tree_1)\n+\t(vect_build_slp_tree_2, vect_build_slp_tree): Change max_nunits\n+\tfrom an unsigned int * to a poly_uint64_pod *.\n+\t(calculate_unrolling_factor): New function.\n+\t(vect_analyze_slp_instance): Use it.  Track polynomial max_nunits.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "26e7d652f44cea3562409b35ac2fe8659fa46faf", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "patch": "@@ -491,7 +491,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \n static bool\n vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n-\t\t\ttree vectype, unsigned int *max_nunits)\n+\t\t\ttree vectype, poly_uint64 *max_nunits)\n {\n   if (!vectype)\n     {\n@@ -508,8 +508,11 @@ vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n \n   /* If populating the vector type requires unrolling then fail\n      before adjusting *max_nunits for basic-block vectorization.  */\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned HOST_WIDE_INT const_nunits;\n   if (is_a <bb_vec_info> (vinfo)\n-      && TYPE_VECTOR_SUBPARTS (vectype) > group_size)\n+      && (!nunits.is_constant (&const_nunits)\n+\t  || const_nunits > group_size))\n     {\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t       \"Build SLP failed: unrolling required \"\n@@ -519,9 +522,7 @@ vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n     }\n \n   /* In case of multiple types we need to detect the smallest type.  */\n-  if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n-    *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\n+  vect_update_max_nunits (max_nunits, vectype);\n   return true;\n }\n \n@@ -542,7 +543,7 @@ vect_record_max_nunits (vec_info *vinfo, gimple *stmt, unsigned int group_size,\n static bool\n vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n-\t\t       unsigned nops, unsigned int *max_nunits,\n+\t\t       unsigned nops, poly_uint64 *max_nunits,\n \t\t       bool *matches, bool *two_operators)\n {\n   unsigned int i;\n@@ -970,16 +971,15 @@ static scalar_stmts_set_t *bst_fail;\n static slp_tree\n vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n-\t\t       unsigned int *max_nunits,\n+\t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t       unsigned max_tree_size);\n \n static slp_tree\n vect_build_slp_tree (vec_info *vinfo,\n-                     vec<gimple *> stmts, unsigned int group_size,\n-                     unsigned int *max_nunits,\n-                     vec<slp_tree> *loads,\n+\t\t     vec<gimple *> stmts, unsigned int group_size,\n+\t\t     poly_uint64 *max_nunits, vec<slp_tree> *loads,\n \t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t     unsigned max_tree_size)\n {\n@@ -1011,12 +1011,13 @@ vect_build_slp_tree (vec_info *vinfo,\n static slp_tree\n vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n-\t\t       unsigned int *max_nunits,\n+\t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t       unsigned max_tree_size)\n {\n-  unsigned nops, i, this_tree_size = 0, this_max_nunits = *max_nunits;\n+  unsigned nops, i, this_tree_size = 0;\n+  poly_uint64 this_max_nunits = *max_nunits;\n   gimple *stmt;\n   slp_tree node;\n \n@@ -1965,6 +1966,15 @@ vect_split_slp_store_group (gimple *first_stmt, unsigned group1_size)\n   return group2;\n }\n \n+/* Calculate the unrolling factor for an SLP instance with GROUP_SIZE\n+   statements and a vector of NUNITS elements.  */\n+\n+static poly_uint64\n+calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n+{\n+  return exact_div (common_multiple (nunits, group_size), group_size);\n+}\n+\n /* Analyze an SLP instance starting from a group of grouped stores.  Call\n    vect_build_slp_tree to build a tree of packed stmts if possible.\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n@@ -1976,11 +1986,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   slp_instance new_instance;\n   slp_tree node;\n   unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (stmt));\n-  unsigned int nunits;\n   tree vectype, scalar_type = NULL_TREE;\n   gimple *next;\n   unsigned int i;\n-  unsigned int max_nunits = 0;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n   vec<gimple *> scalar_stmts;\n@@ -2019,7 +2027,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n       return false;\n     }\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n@@ -2057,32 +2065,35 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n   bst_fail = new scalar_stmts_set_t ();\n+  poly_uint64 max_nunits = nunits;\n   node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n-\t\t\t\t   &max_nunits, &loads, matches, &npermutes,\n+\t\t\t      &max_nunits, &loads, matches, &npermutes,\n \t\t\t      NULL, max_tree_size);\n   delete bst_fail;\n   if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       poly_uint64 unrolling_factor\n-\t= least_common_multiple (max_nunits, group_size) / group_size;\n+\t= calculate_unrolling_factor (max_nunits, group_size);\n \n       if (maybe_ne (unrolling_factor, 1U)\n \t  && is_a <bb_vec_info> (vinfo))\n \t{\n-\n-\t  if (max_nunits > group_size)\n-        {\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t       \"Build SLP failed: store group \"\n-\t\t\t       \"size not a multiple of the vector size \"\n-\t\t\t       \"in basic block SLP\\n\");\n-\t  vect_free_slp_tree (node);\n-\t  loads.release ();\n-          return false;\n-        }\n+\t  unsigned HOST_WIDE_INT const_max_nunits;\n+\t  if (!max_nunits.is_constant (&const_max_nunits)\n+\t      || const_max_nunits > group_size)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: store group \"\n+\t\t\t\t \"size not a multiple of the vector size \"\n+\t\t\t\t \"in basic block SLP\\n\");\n+\t      vect_free_slp_tree (node);\n+\t      loads.release ();\n+\t      return false;\n+\t    }\n \t  /* Fatal mismatch.  */\n-\t  matches[group_size/max_nunits * max_nunits] = false;\n+\t  matches[group_size / const_max_nunits * const_max_nunits] = false;\n \t  vect_free_slp_tree (node);\n \t  loads.release ();\n \t}\n@@ -2201,30 +2212,32 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n   /* For basic block SLP, try to break the group up into multiples of the\n      vector size.  */\n+  unsigned HOST_WIDE_INT const_nunits;\n   if (is_a <bb_vec_info> (vinfo)\n       && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-      && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n+      && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n+      && nunits.is_constant (&const_nunits))\n     {\n       /* We consider breaking the group only on VF boundaries from the existing\n \t start.  */\n       for (i = 0; i < group_size; i++)\n \tif (!matches[i]) break;\n \n-      if (i >= nunits && i < group_size)\n+      if (i >= const_nunits && i < group_size)\n \t{\n \t  /* Split into two groups at the first vector boundary before i.  */\n-\t  gcc_assert ((nunits & (nunits - 1)) == 0);\n-\t  unsigned group1_size = i & ~(nunits - 1);\n+\t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n+\t  unsigned group1_size = i & ~(const_nunits - 1);\n \n \t  gimple *rest = vect_split_slp_store_group (stmt, group1_size);\n \t  bool res = vect_analyze_slp_instance (vinfo, stmt, max_tree_size);\n \t  /* If the first non-match was in the middle of a vector,\n \t     skip the rest of that vector.  */\n \t  if (group1_size < i)\n \t    {\n-\t      i = group1_size + nunits;\n+\t      i = group1_size + const_nunits;\n \t      if (i < group_size)\n-\t\trest = vect_split_slp_store_group (rest, nunits);\n+\t\trest = vect_split_slp_store_group (rest, const_nunits);\n \t    }\n \t  if (i < group_size)\n \t    res |= vect_analyze_slp_instance (vinfo, rest, max_tree_size);"}]}