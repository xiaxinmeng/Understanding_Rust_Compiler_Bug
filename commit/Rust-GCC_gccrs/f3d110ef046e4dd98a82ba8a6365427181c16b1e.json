{"sha": "f3d110ef046e4dd98a82ba8a6365427181c16b1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkMTEwZWYwNDZlNGRkOThhODJiYThhNjM2NTQyNzE4MWMxNmIxZQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2007-09-11T01:11:16Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2007-09-11T01:11:16Z"}, "message": "re PR c/30013 (Multiple flaws in decimal floating-point arithmetic conversions fixed)\n\ngcc/\n\tPR c/30013\n\t* config/dfp-bit.c: Don't skip TFmode conversions; move strto*\n\tdeclarations to top.\n\t(DFP_TO_BFP): Use for either XFmode or TFmode.\n\t(BFP_TO_DFP): Use for either XFmode or TFmode; always use cast\n\tof BFP_VIA_TYPE.\n\t* config/dfp-bit.h: Include float.h.\n\t(LONG_DOUBLE_HAS_XF_MODE, LONG_DOUBLE_HAS_TF_MODE): Define if long\n\tdouble is one of these modes, rather than using LIBGCC_HAS_*F_MODE\n\twhich doesn't mean the same thing.\n\t(BFP_KIND): Use 4 to mean TFmode.\n\t(BFP_FMT): Specify the number of decimal digits based on the\n\tnumber of mantissa digits.\n\t(BFP_VIA_TYPE): Binary float type to use as cast for sprintf.\n\t(BFP_TO_DFP, DFP_TO_BFP): Define names for TFmode variants.\n\t(STR_TO_BFP): Use strtold for XFmode or TFmode.\n\t(TFtype): Define if TFmode is supported.\n\t* doc/libgcc.texi (Decimal float library routines): Document\n\tTF conversion functions.\n\ngcc/testsuite/\n\t* gcc.dg/dfp/convert-bfp.c: Replace SKIP_LONG_DOUBLE with runtime\n\tchecks for size of long double.\n\t* gcc.dg/dfp/convert.h: New file.\n\t* gcc.dg/dfp/convert-bfp-2.c: New test.\n\t* gcc.dg/dfp/convert-bfp-3.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-4.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-5.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-6.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-7.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-8.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-9.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-10.c: Ditto.\n\t* gcc.dg/dfp/convert-bfp-11.c: Ditto.\n\nFrom-SVN: r128361", "tree": {"sha": "200c6b2a83392535448b0fad1e529f6969081b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/200c6b2a83392535448b0fad1e529f6969081b6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3d110ef046e4dd98a82ba8a6365427181c16b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d110ef046e4dd98a82ba8a6365427181c16b1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3d110ef046e4dd98a82ba8a6365427181c16b1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d110ef046e4dd98a82ba8a6365427181c16b1e/comments", "author": null, "committer": null, "parents": [{"sha": "9fc777ad2561e542ef0eec9d94ee8cb5edc68554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc777ad2561e542ef0eec9d94ee8cb5edc68554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc777ad2561e542ef0eec9d94ee8cb5edc68554"}], "stats": {"total": 1487, "additions": 1426, "deletions": 61}, "files": [{"sha": "2ed812ce9b5588e2fc0c4f3e7b0b94b6d30b481e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -1,3 +1,25 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\n+\tPR c/30013\n+\t* config/dfp-bit.c: Don't skip TFmode conversions; move strto*\n+\tdeclarations to top.\n+\t(DFP_TO_BFP): Use for either XFmode or TFmode.\n+\t(BFP_TO_DFP): Use for either XFmode or TFmode; always use cast\n+\tof BFP_VIA_TYPE.\n+\t* config/dfp-bit.h: Include float.h.\n+\t(LONG_DOUBLE_HAS_XF_MODE, LONG_DOUBLE_HAS_TF_MODE): Define if long\n+\tdouble is one of these modes, rather than using LIBGCC_HAS_*F_MODE\n+\twhich doesn't mean the same thing.\n+\t(BFP_KIND): Use 4 to mean TFmode.\n+\t(BFP_FMT): Specify the number of decimal digits based on the\n+\tnumber of mantissa digits.\n+\t(BFP_VIA_TYPE): Binary float type to use as cast for sprintf.\n+\t(BFP_TO_DFP, DFP_TO_BFP): Define names for TFmode variants.\n+\t(STR_TO_BFP): Use strtold for XFmode or TFmode.\n+\t(TFtype): Define if TFmode is supported.\n+\t* doc/libgcc.texi (Decimal float library routines): Document\n+\tTF conversion functions.\n+\n 2007-09-10  Chao-ying Fu  <fu@mips.com>\n \n \t* config/mips/mips.c (mips_scalar_mode_supported_p): Declare."}, {"sha": "8ee4dec6f444e60158b3ae28798d5b17a95f896b", "filename": "gcc/config/dfp-bit.c", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -34,16 +34,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    Contributed by Ben Elliston  <bje@au.ibm.com>.  */\n \n-/* The intended way to use this file is to make two copies, add `#define '\n-   to one copy, then compile both copies and add them to libgcc.a.  */\n-\n-/* FIXME: This implementation doesn't support TFmode conversions.  */\n-#if !(defined (L_sd_to_tf) || defined (L_dd_to_tf) \\\n-      || defined (L_td_to_tf) || defined (L_tf_to_sd) \\\n-      || defined (L_tf_to_dd) || defined (L_tf_to_td))\n-\n #include <stdio.h>\n #include <stdlib.h>\n+/* FIXME: compile with -std=gnu99 to get these from stdlib.h */\n+extern float strtof (const char *, char **);\n+extern long double strtold (const char *, char **);\n #include <string.h>\n #include <limits.h>\n \n@@ -471,7 +466,9 @@ INT_TO_DFP (INT_TYPE i)\n #if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n  || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n  || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n-     && LIBGCC2_HAS_XF_MODE)\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n BFP_TYPE\n DFP_TO_BFP (DFP_C_TYPE f)\n {\n@@ -489,7 +486,9 @@ DFP_TO_BFP (DFP_C_TYPE f)\n #if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n  || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n  || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n-     && LIBGCC2_HAS_XF_MODE)\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n DFP_C_TYPE\n BFP_TO_DFP (BFP_TYPE x)\n {\n@@ -502,12 +501,7 @@ BFP_TO_DFP (BFP_TYPE x)\n   DFP_INIT_ROUNDMODE (context.round);\n \n   /* Use a C library function to write the floating point value to a string.  */\n-#ifdef BFP_VIA_TYPE\n-  /* FIXME: Is there a better way to output an XFmode variable in C?  */\n   sprintf (buf, BFP_FMT, (BFP_VIA_TYPE) x);\n-#else\n-  sprintf (buf, BFP_FMT, x);\n-#endif\n \n   /* Convert from the floating point string to a decimal* type.  */\n   FROM_STRING (&s, buf, &context);\n@@ -543,7 +537,3 @@ DFP_UNORD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n   return (decNumberIsNaN (&arg1) || decNumberIsNaN (&arg2));\n }\n #endif /* L_unord_sd || L_unord_dd || L_unord_td */\n-\n-/* !(L_sd_to_tf || L_dd_to_tf || L_td_to_tf \\\n-     || L_tf_to_sd || L_tf_to_dd || L_tf_to_td)  */\n-#endif"}, {"sha": "27c6a8a26c7f075599a897dd61ebe3b19b172dc9", "filename": "gcc/config/dfp-bit.h", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fconfig%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fconfig%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.h?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #ifndef _DFPBIT_H\n #define _DFPBIT_H\n \n+#include <float.h>\n #include <fenv.h>\n #include <decRound.h>\n #include <decExcept.h>\n@@ -49,10 +50,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n #endif\n \n-#ifndef LIBGCC2_HAS_XF_MODE\n-#define LIBGCC2_HAS_XF_MODE \\\n+/* We need to know the size of long double that the C library supports.\n+   Don't use LIBGCC2_HAS_XF_MODE or LIBGCC2_HAS_TF_MODE here because\n+   some targets set both of those.  */\n+\n+#define LONG_DOUBLE_HAS_XF_MODE \\\n   (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n-#endif\n+\n+#define LONG_DOUBLE_HAS_TF_MODE \\\n+  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n \n /* Depending on WIDTH, define a number of macros:\n \n@@ -242,36 +248,58 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #elif defined (L_sd_to_xf) || defined (L_dd_to_xf ) || defined (L_td_to_xf) \\\n  ||   defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)\n #define BFP_KIND 3\n+#elif defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf) \\\n+ ||   defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)\n+#define BFP_KIND 4\n #endif\n \n /*  If BFP_KIND is defined, define additional macros:\n \n     BFP_TYPE: The binary floating point data type.\n \n     BFP_FMT: The format string for writing the value to a string.\n+    The number of decimal digits printed is\n+       ceil (nbits / log2 (10.) + 1)\n+    as described in David Matula's CACM 19(3) 716-723 June 1968 paper.\n \n+    BFP_VIA_TYPE: Type to which to cast a variable of BPF_TYPE for a\n+    call to sprintf.\n+    \n     STR_TO_BFP: The function to read the value from a string.  */\n \n #if BFP_KIND == 1\n-/* strtof is declared in <stdlib.h> only for C99.  */\n-extern float strtof (const char *, char **);\n #define BFP_TYPE SFtype\n-#define BFP_FMT \"%e\"\n+#define BFP_FMT \"%.9e\"\n+#define BFP_VIA_TYPE double\n #define STR_TO_BFP strtof\n \n #elif BFP_KIND == 2\n #define BFP_TYPE DFtype\n-#define BFP_FMT \"%e\"\n+#define BFP_FMT \"%.17e\"\n+#define BFP_VIA_TYPE double\n #define STR_TO_BFP strtod\n \n #elif BFP_KIND == 3\n-#if LIBGCC2_HAS_XF_MODE\n-/* These aren't used if XF mode is not supported.  */\n+#if LONG_DOUBLE_HAS_XF_MODE\n #define BFP_TYPE XFtype\n-#define BFP_FMT \"%e\"\n-#define BFP_VIA_TYPE double\n-#define STR_TO_BFP strtod\n-#endif\n+#define BFP_FMT \"%.21Le\"\n+#define BFP_VIA_TYPE long double\n+#define STR_TO_BFP strtold\n+#endif /* LONG_DOUBLE_HAS_XF_MODE */\n+\n+#elif BFP_KIND == 4\n+#if LONG_DOUBLE_HAS_TF_MODE\n+#define BFP_TYPE TFtype\n+#if LDBL_MANT_DIG == 106\n+#define BFP_FMT \"%.33Le\"\n+#elif LDBL_MANT_DIG == 113\n+#define BFP_FMT \"%.36Le\"\n+#else\n+#error \"unknown long double size, cannot define BFP_FMT\"\n+#endif /* LDBL_MANT_DIG */\n+#define STR_TO_BFP strtold\n+#define BFP_VIA_TYPE long double\n+#endif /* LONG_DOUBLE_HAS_TF_MODE */\n \n #endif /* BFP_KIND */\n \n@@ -455,6 +483,9 @@ extern float strtof (const char *, char **);\n #elif BFP_KIND == 3\n #define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfsd,__bid_truncxfsd)\n #define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdxf,__bid_extendsdxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfsd,__bid_trunctfsd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendsdtf,__bid_extendsdtf)\n #endif /* BFP_KIND */\n \n #elif WIDTH == 64\n@@ -467,6 +498,9 @@ extern float strtof (const char *, char **);\n #elif BFP_KIND == 3\n #define BFP_TO_DFP\tDPD_BID_NAME(__dpd_truncxfdd,__bid_truncxfdd)\n #define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddxf,__bid_extendddxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_trunctfdd,__bid_trunctfdd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_extendddtf,__bid_extendddtf)\n #endif /* BFP_KIND */\n \n #elif WIDTH == 128\n@@ -479,6 +513,9 @@ extern float strtof (const char *, char **);\n #elif BFP_KIND == 3\n #define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendxftd,__bid_extendxftd)\n #define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdxf,__bid_trunctdxf)\n+#elif BFP_KIND == 4\n+#define BFP_TO_DFP\tDPD_BID_NAME(__dpd_extendtftd,__bid_extendtftd)\n+#define DFP_TO_BFP\tDPD_BID_NAME(__dpd_trunctdtf,__bid_trunctdtf)\n #endif /* BFP_KIND */\n \n #endif /* WIDTH */\n@@ -487,9 +524,12 @@ extern float strtof (const char *, char **);\n \n typedef float SFtype __attribute__ ((mode (SF)));\n typedef float DFtype __attribute__ ((mode (DF)));\n-#if LIBGCC2_HAS_XF_MODE\n+#if LONG_DOUBLE_HAS_XF_MODE\n typedef float XFtype __attribute__ ((mode (XF)));\n-#endif /* LIBGCC2_HAS_XF_MODE */\n+#endif /* LONG_DOUBLE_HAS_XF_MODE */\n+#if LONG_DOUBLE_HAS_TF_MODE\n+typedef float TFtype __attribute__ ((mode (TF)));\n+#endif /* LONG_DOUBLE_HAS_TF_MODE */\n \n typedef int SItype __attribute__ ((mode (SI)));\n typedef int DItype __attribute__ ((mode (DI)));\n@@ -566,14 +606,18 @@ extern DFP_C_TYPE INT_TO_DFP (INT_TYPE);\n #if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n  || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n  || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n-     && LIBGCC2_HAS_XF_MODE)\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_sd_to_tf) || defined (L_dd_to_tf) || defined (L_td_to_tf)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n extern BFP_TYPE DFP_TO_BFP (DFP_C_TYPE);\n #endif\n \n #if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n  || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n  || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n-     && LIBGCC2_HAS_XF_MODE)\n+     && LONG_DOUBLE_HAS_XF_MODE) \\\n+ || ((defined (L_tf_to_sd) || defined (L_tf_to_dd) || defined (L_tf_to_td)) \\\n+     && LONG_DOUBLE_HAS_TF_MODE)\n extern DFP_C_TYPE BFP_TO_DFP (BFP_TYPE);\n #endif\n "}, {"sha": "e977b24de055c1caec6e2b855ed46f21b29909d6", "filename": "gcc/doc/libgcc.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fdoc%2Flibgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Fdoc%2Flibgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flibgcc.texi?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -585,8 +585,12 @@ to another.\n @deftypefnx {Runtime Function} _Decimal32 __bid_truncdfsd (double @var{a})\n @deftypefnx {Runtime Function} _Decimal32 __dpd_truncxfsd ({long double} @var{a})\n @deftypefnx {Runtime Function} _Decimal32 __bid_truncxfsd ({long double} @var{a})\n+@deftypefnx {Runtime Function} _Decimal32 __dpd_trunctfsd ({long double} @var{a})\n+@deftypefnx {Runtime Function} _Decimal32 __bid_trunctfsd ({long double} @var{a})\n @deftypefnx {Runtime Function} _Decimal64 __dpd_truncxfdd ({long double} @var{a})\n @deftypefnx {Runtime Function} _Decimal64 __bid_truncxfdd ({long double} @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __dpd_trunctfdd ({long double} @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __bid_trunctfdd ({long double} @var{a})\n These functions convert the value of @var{a} from a binary floating type\n to a decimal floating type of a different size.\n @end deftypefn\n@@ -605,6 +609,10 @@ to a decimal floating type of a different size.\n @deftypefnx {Runtime Function} {long double} __bid_extendddxf (_Decimal64 @var{a})\n @deftypefnx {Runtime Function} {long double} __dpd_trunctdxf (_Decimal128 @var{a})\n @deftypefnx {Runtime Function} {long double} __bid_trunctdxf (_Decimal128 @var{a})\n+@deftypefnx {Runtime Function} {long double} __dpd_extendsdtf (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} {long double} __bid_extendsdtf (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} {long double} __dpd_extendddtf (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} {long double} __bid_extendddtf (_Decimal64 @var{a})\n These functions convert the value of @var{a} from a decimal floating type\n to a binary floating type of a different size.\n @end deftypefn\n@@ -613,10 +621,14 @@ to a binary floating type of a different size.\n @deftypefnx {Runtime Function} _Decimal32 __bid_extendsfsd (float @var{a})\n @deftypefnx {Runtime Function} _Decimal64 __dpd_extenddfdd (double @var{a})\n @deftypefnx {Runtime Function} _Decimal64 __bid_extenddfdd (double @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __dpd_extendtftd ({long double} @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __bid_extendtftd ({long double} @var{a})\n @deftypefnx {Runtime Function} float __dpd_truncsdsf (_Decimal32 @var{a})\n @deftypefnx {Runtime Function} float __bid_truncsdsf (_Decimal32 @var{a})\n @deftypefnx {Runtime Function} double __dpd_truncdddf (_Decimal64 @var{a})\n @deftypefnx {Runtime Function} double __bid_truncdddf (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} {long double} __dpd_trunctdtf (_Decimal128 @var{a})\n+@deftypefnx {Runtime Function} {long double} __bid_trunctdtf (_Decimal128 @var{a})\n These functions convert the value of @var{a} between decimal and\n binary floating types of the same size.\n @end deftypefn"}, {"sha": "bce206ebb609f73840317269ca72d570d5ae4aba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -1,3 +1,18 @@\n+2007-09-10  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* gcc.dg/dfp/convert-bfp.c: Replace SKIP_LONG_DOUBLE with runtime\n+\tchecks for size of long double.\n+\t* gcc.dg/dfp/convert.h: New file.\n+\t* gcc.dg/dfp/convert-bfp-2.c: New test.\n+\t* gcc.dg/dfp/convert-bfp-3.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-4.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-5.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-6.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-7.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-8.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-9.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-10.c: Ditto.\n+\t* gcc.dg/dfp/convert-bfp-11.c: Ditto.\n 2007-09-10  Harsha Jagasia <harsha.jagasia@amd.com>\n \n         * gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: "}, {"sha": "dec7b515fcf77b8a169932f2200e584a6eef7809", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-10.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-10.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* This test assumes IEEE float and double.  */\n+\n+#define __STDC_WANT_DEC_FP__\n+#include <float.h>\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+\n+/* Conversions using denormalized float values.  */\n+CONVERT_VALID (111, sf, sd, 1.2e-38f, 1.2e-38df, 0.df)\n+CONVERT_VALID (112, sf, sd, 1.1e-38f, 1.1e-38df, 0.df)\n+CONVERT_VALID (113, sf, sd, 1.1e-40f, 1.1e-40df, 1.1e-45df)\n+\n+CONVERT_VALID (121, sd, sf, 1.2e-38df, 1.2e-38f, 0.f)\n+CONVERT_VALID (122, sd, sf, 1.1e-38df, 1.1e-38f, 0.f)\n+\n+CONVERT_VALID (131, sf, sd, -1.2e-38f, -1.2e-38df, 0.df)\n+CONVERT_VALID (132, sf, sd, -1.1e-38f, -1.1e-38df, 0.df)\n+\n+CONVERT_VALID (141, sd, sf, -1.2e-38df, -1.2e-38f, 0.f)\n+CONVERT_VALID (142, sd, sf, -1.1e-38df, -1.1e-38f, 0.f)\n+\n+/* Conversions using denormalized double values.  */\n+CONVERT_VALID (211, df, sd, 1.2e-38, 1.2e-38df, 0.df)\n+CONVERT_VALID (212, df, sd, 1.1e-38, 1.1e-38df, 0.df)\n+CONVERT_VALID (213, df, sd, 1.e-40, 1.e-40df, 0.df)\n+CONVERT_VALID (214, df, sd, 8.e-44, 8.e-44df, 0.df)\n+CONVERT_VALID (215, df, sd, 9.e-44, 9.e-44df, 0.df)\n+CONVERT_VALID (216, df, sd, 8.e-46, 8.e-46df, 0.df)\n+CONVERT_VALID (217, df, sd, 7.e-46, 7.e-46df, 0.df)\n+\n+CONVERT_VALID (221, sd, df, 1.2e-38df, 1.2e-38, 1.e-53)\n+CONVERT_VALID (222, sd, df, 1.1e-38df, 1.1e-38, 1.e-53)\n+CONVERT_VALID (223, sd, df, 1.e-40df, 1.e-40, 0.)\n+CONVERT_VALID (224, sd, df, 8.e-44df, 8.e-44, 0.)\n+CONVERT_VALID (225, sd, df, 9.e-44df, 9.e-44, 0.)\n+CONVERT_VALID (226, sd, df, 8.e-46df, 8.e-46, 0.)\n+CONVERT_VALID (227, sd, df, 7.e-46df, 7.e-46, 0.)\n+\n+CONVERT_VALID (231, df, sd, -1.2e-38, -1.2e-38df, 0.df)\n+CONVERT_VALID (232, df, sd, -1.1e-38f, -1.1e-38df, 0.df)\n+CONVERT_VALID (233, df, sd, -1.e-40, -1.e-40df, 0.df)\n+CONVERT_VALID (234, df, sd, -8.e-44, -8.e-44df, 0.df)\n+CONVERT_VALID (235, df, sd, -9.e-44, -9.e-44df, 0.df)\n+CONVERT_VALID (236, df, sd, -8.e-46, -8.e-46df, 0.df)\n+CONVERT_VALID (237, df, sd, -7.e-46, -7.e-46df, 0.df)\n+\n+CONVERT_VALID (241, sd, df, -1.2e-38df, -1.2e-38, 1.e-53)\n+CONVERT_VALID (242, sd, df, -1.1e-38df, -1.1e-38, 1.e-53)\n+CONVERT_VALID (243, sd, df, -1.e-40df, -1.e-40, 0.)\n+CONVERT_VALID (244, sd, df, -8.e-44df, -8.e-44, 0.)\n+CONVERT_VALID (245, sd, df, -9.e-44df, -9.e-44, 0.)\n+CONVERT_VALID (246, sd, df, -8.e-46df, -8.e-46, 0.)\n+CONVERT_VALID (247, sd, df, -7.e-46df, -7.e-46, 0.)\n+\n+int\n+main ()\n+{\n+  convert_111 ();\n+  convert_112 ();\n+  convert_113 ();\n+\n+  convert_121 ();\n+  convert_122 ();\n+\n+  convert_131 ();\n+  convert_132 ();\n+\n+  convert_141 ();\n+  convert_142 ();\n+\n+  convert_211 ();\n+  convert_212 ();\n+  convert_213 ();\n+  convert_214 ();\n+  convert_215 ();\n+  convert_216 ();\n+  convert_217 ();\n+\n+  convert_221 ();\n+  convert_222 ();\n+  convert_223 ();\n+  convert_224 ();\n+  convert_225 ();\n+  convert_226 ();\n+  convert_227 ();\n+\n+  convert_231 ();\n+  convert_232 ();\n+  convert_233 ();\n+  convert_234 ();\n+  convert_235 ();\n+  convert_236 ();\n+  convert_237 ();\n+\n+  convert_241 ();\n+  convert_242 ();\n+  convert_243 ();\n+  convert_244 ();\n+  convert_245 ();\n+  convert_246 ();\n+  convert_247 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "283f9bd4f882c6299a477a584cbbe904e325945f", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-11.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-11.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-options \"-std=gnu99\" } */\n+/* { dg-skip-if \"\" { ! \"powerpc*-*-linux*\" } { \"*\" } { \"\" } } */\n+\n+/* Test decimal float conversions to and from IBM 128-bit long double. \n+   Checks are skipped at runtime if long double is not 128 bits.\n+   Don't force 128-bit long doubles because runtime support depends\n+   on glibc.  */\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;\n+\n+/* A value slightly less than DEC32_MAX can be converted in both directions.  */\n+CONVERT_VALID (101, sd, tf, 9.999998e96df, 9.999998e96L, 1.e+81L)\n+CONVERT_VALID (102, tf, sd, 9.999998e96L, 9.999998e96df, 0.df)\n+\n+/* A value slightly less than DBL_MAX can be converted in both directions.  */\n+CONVERT_VALID (201, tf, dd, 1.79768e+308l, 1.79768e+308dd, 0.dd)\n+CONVERT_VALID (202, dd, tf, 1.79768e+308dd, 1.79768e+308l, 2.e292l)\n+CONVERT_VALID (203, tf, td, 1.79768e+308l, 1.79768e+308dl, 1.e292dl)\n+CONVERT_VALID (204, td, tf, 1.79768e+308dl, 1.79768e+308l, 2.e292l)\n+\n+/* Check values that are too large for the result type.  */\n+CONVERT_TO_PINF (301, dd, tf, 1.8e+308dd, l)\n+CONVERT_TO_PINF (302, dd, tf, 9.9e+384dd, l)\n+CONVERT_TO_PINF (303, td, tf, 1.8e+308dl, l)\n+CONVERT_TO_PINF (304, td, tf, 9.9e+384dl, l)\n+\n+CONVERT_TO_PINF (311, tf, sd, 1.0e+97L, d32)\n+CONVERT_TO_PINF (312, tf, sd, 1.6e+308L, d32)\n+\n+int\n+main ()\n+{\n+  if (sizeof (long double) != 16)\n+    return 0;\n+\n+  convert_101 ();\n+  convert_102 ();\n+\n+  convert_201 ();\n+  convert_202 ();\n+  convert_203 ();\n+  convert_204 ();\n+\n+  convert_301 ();\n+  convert_302 ();\n+  convert_303 ();\n+  convert_304 ();\n+  convert_311 ();\n+  convert_312 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "282735120053bb6d7b83bf35aecdbea5de846a6e", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-2.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* This test assumes IEEE float and double.  It also tests long double\n+   but makes no assumption about its size or range of values.  */\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;   /* might actually be df or xf, doesn't matter */\n+\n+CONVERT_VALID_ALL (t1, 0.0, 0.)\n+CONVERT_VALID_ALL (t2, 1.0, 0.)\n+CONVERT_VALID_ALL (t3, -11.5, 0.)\n+CONVERT_VALID_ALL (t4, 7.0, 0.1e-14)\n+CONVERT_VALID_ALL (t5, -7.0, 0.1e-14)\n+CONVERT_VALID_ALL (t6, 999999., 0.)\n+CONVERT_VALID_ALL (t7, -999999., 0.)\n+\n+int\n+main ()\n+{\n+  CALL_VALID_ALL (t1)\n+  CALL_VALID_ALL (t2)\n+  CALL_VALID_ALL (t3)\n+  CALL_VALID_ALL (t4)\n+  CALL_VALID_ALL (t5)\n+  CALL_VALID_ALL (t6)\n+  CALL_VALID_ALL (t7)\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "67d31c33ac9f9e67657682651bc984c1738f2a93", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-3.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* This test assumes IEEE float and double.  It also tests long double\n+   but makes no assumption about its size or range of values.  */\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;   /* might actually be df or xf, doesn't matter */\n+\n+CONVERT_ZEROES_ALL (t);\n+\n+int\n+main ()\n+{\n+  CALL_ZEROES_ALL (t)\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "feba37a9eaec921fca40e4dad236e4a6bbe39380", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-4.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* This test assumes IEEE float and double.  It also tests long double\n+   but makes no assumption about its size or range of values.  */\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;   /* might actually be df or xf, doesn't matter */\n+\n+CONVERT_INF_ALL (t);\n+\n+int\n+main ()\n+{\n+  CALL_INF_ALL (t)\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "cfb86fd015d53170b320b85098f860eeab9beea2", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-5.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-5.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* This test assumes IEEE float and double.  It also tests long double\n+   but makes no assumption about its size or range of values.  */\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;   /* might actually be df or xf, doesn't matter */\n+\n+CONVERT_NAN_ALL (t);\n+\n+int\n+main ()\n+{\n+  CALL_NAN_ALL (t)\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "6dc2a9e720e8846b2ef2fc4ab28d897176113e0c", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-6.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-6.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,179 @@\n+/* { dg-options \"-std=gnu99 -w\" } */\n+\n+/* This test assumes IEEE float and double.  */\n+\n+#define __STDC_WANT_DEC_FP__\n+#include <float.h>\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+volatile long double tf;\n+\n+CONVERT_VALID (101, td, sf, 0.000488281251dl, 0.00048828125f, 0.f)\n+\n+/* 2**(-25) = 0.298023223876953125E-7.  */\n+CONVERT_VALID (102, td, sf, 2.98023223876953125e-8dl, 2.9802322387695312e-08f,\n+               01.e-13f)\n+\n+/* Fractional part doesn't fit.  */\n+CONVERT_VALID (103, df, sd, 1.0e-20, 1.0e-20df, 0.df)\n+\n+/* Exact power of 2.  */\n+CONVERT_VALID (104, df, sd, 0.00048828125, 0.00048828125df, 0.df)\n+CONVERT_VALID (105, df, sd, 1.0e-96, 0.dd, DEC32_MIN)\n+\n+/* A value slightly less than FLT_MAX can be converted in both directions.  */\n+CONVERT_VALID (201, sf, sd, 3.402819e+38f, 3.402819e+38df, 0.df)\n+CONVERT_VALID (202, sd, sf, 3.402819e+38df, 3.402819e+38f, 0.f)\n+CONVERT_VALID (203, sf, dd, 3.402819e+38f, 3.402819e+38dd, 1.e+30dd)\n+CONVERT_VALID (204, dd, sf, 3.402819e+38dd, 3.402819e+38f, 0.f)\n+CONVERT_VALID (205, sf, td, 3.402819e+38f, 3.402819e+38dl, 1.e+30dl)\n+CONVERT_VALID (206, td, sf, 3.402819e+38dl, 3.402819e+38f, 0.f)\n+\n+/* A value slightly less than DEC32_MAX can be converted in both directions.  */\n+CONVERT_VALID (211, sd, df, 9.999998e96df, 9.999998e96, 0.)\n+CONVERT_VALID (212, df, sd, 9.999998e96, 9.999998e96df, 0.df)\n+\n+/* A value slightly less than DBL_MAX can be converted in both directions.  */\n+CONVERT_VALID (221, df, dd, 1.79768e+308, 1.79768e+308dd, 0.dd)\n+CONVERT_VALID (222, dd, df, 1.79768e+308dd, 1.79768e+308, 0.)\n+CONVERT_VALID (223, df, td, 1.79768e+308, 1.79768e+308dl, 1.e292dl)\n+CONVERT_VALID (224, td, df, 1.79768e+308dl, 1.79768e+308, 0.)\n+\n+/* An integral value with 6 digits (FLT_DIG) can be converted between float\n+   and _Decimal32 in both directions.  */\n+CONVERT_VALID (301, sd, sf, 100000.DF, 100000.F, 0.F)\n+CONVERT_VALID (302, sf, sd, 100000.F, 100000.DF, 0.DF)\n+CONVERT_VALID (303, sd, sf, 999999.DF, 999999.F, 0.F)\n+CONVERT_VALID (304, sf, sd, 999999.F, 999999.DF, 0.DF)\n+\n+/* An integral value with 7 digits (DEC32_MANT_DIG) can be converted between\n+   _Decimal32 and double in both directions.  */\n+CONVERT_VALID (311, sd, df, 1000000.DF, 1000000., 0.)\n+CONVERT_VALID (312, df, sd, 1000000., 1000000.DF, 0.DF)\n+CONVERT_VALID (313, sd, df, 9999999.DF, 9999999., 0.)\n+CONVERT_VALID (314, df, sd, 9999999., 9999999.DF, 0.DF)\n+\n+/* An integral value with 15 digits (DBL_DIG) can be converted between\n+   double and _Decimal64 in both directions.  */\n+CONVERT_VALID (321, dd, df, 100000000000000.DD, 100000000000000., 0.)\n+CONVERT_VALID (322, df, dd, 100000000000000., 100000000000000.DD, 0.DD);\n+CONVERT_VALID (323, dd, df, 999999999999999.DD, 999999999999999., 0.);\n+CONVERT_VALID (324, df, dd, 999999999999999., 999999999999999.DD, 0.DD);\n+\n+/* If LDBL_DIG is at least 16, an integral value with 16 digits can be\n+   converted between _Decimal64 and long double in both directions.  */\n+CONVERT_VALID (331, dd, tf, 1000000000000000.DD, 1000000000000000.L, 0.L)\n+CONVERT_VALID (332, td, dd, 1000000000000000.L, 1000000000000000.DD, 0.DD)\n+CONVERT_VALID (333, dd, tf, 9999999999999999.DD, 9999999999999999.L, 0.L)\n+CONVERT_VALID (334, td, dd, 9999999999999999.L, 9999999999999999.DD, 0.DD)\n+\n+/* If LDBL_DIG is at least 18, an integral value with 18 digits can be\n+   converted between long double and _Decimal128 in both directions.  */\n+CONVERT_VALID (341, td, tf, 100000000000000000.DL, 100000000000000000.L, 0.L)\n+CONVERT_VALID (342, tf, td, 100000000000000000.L, 100000000000000000.DL, 0.DL)\n+CONVERT_VALID (343, td, tf, 999999999999999999.DL, 999999999999999999.L, 0.L)\n+CONVERT_VALID (344, tf, td, 999999999999999999.L, 999999999999999999.DL, 0.DL)\n+\n+/* If LDBL_DIG is at least 31, an integral value with 31 digits can be\n+   converted between long double and _Decimal128 in both directions.  */\n+CONVERT_VALID (351, td, tf, 1000000000000000000000000000000.DL,\n+\t\t\t    1000000000000000000000000000000.L, 0.L)\n+CONVERT_VALID (352, tf, td, 1000000000000000000000000000000.L,\n+\t\t\t    1000000000000000000000000000000.DL, 0.DL)\n+CONVERT_VALID (353, td, tf, 9999999999999999999999999999999.DL,\n+\t\t\t    9999999999999999999999999999999.L, 0.L)\n+CONVERT_VALID (354, tf, td, 9999999999999999999999999999999.L,\n+\t\t\t    9999999999999999999999999999999.DL, 0.DL)\n+\n+/* If LDBL_DIG is at least 33, an integral value with 33 digits can be\n+   converted between long double and _Decimal128 in both directions.  */\n+CONVERT_VALID (361, td, tf, 100000000000000000000000000000000.DL,\n+\t\t\t    100000000000000000000000000000000.L, 0.L)\n+CONVERT_VALID (362, tf, td, 100000000000000000000000000000000.L,\n+\t\t\t    100000000000000000000000000000000.DL, 0.DL)\n+CONVERT_VALID (363, td, tf, 999999999999999999999999999999999.DL,\n+\t\t\t    999999999999999999999999999999999.L, 0.L)\n+CONVERT_VALID (364, tf, td, 999999999999999999999999999999999.L,\n+\t\t\t    999999999999999999999999999999999.DL, 0.DL)\n+\n+int\n+main ()\n+{\n+  convert_101 ();\n+  convert_102 ();\n+  convert_103 ();\n+  convert_104 ();\n+  convert_105 ();\n+\n+  convert_201 ();\n+  convert_202 ();\n+  convert_203 ();\n+  convert_204 ();\n+  convert_205 ();\n+  convert_206 ();\n+\n+  convert_211 ();\n+  convert_212 ();\n+\n+  convert_221 ();\n+  convert_222 ();\n+  convert_223 ();\n+  convert_224 ();\n+\n+  convert_301 ();\n+  convert_302 ();\n+  convert_303 ();\n+  convert_304 ();\n+\n+  convert_311 ();\n+  convert_312 ();\n+  convert_313 ();\n+  convert_314 ();\n+\n+  convert_321 ();\n+  convert_322 ();\n+  convert_323 ();\n+  convert_324 ();\n+\n+  if (LDBL_DIG >= 16)\n+    {\n+      convert_331 ();\n+      convert_332 ();\n+      convert_333 ();\n+      convert_334 ();\n+    }\n+\n+  if (LDBL_DIG >= 18)\n+    {\n+      convert_341 ();\n+      convert_342 ();\n+      convert_343 ();\n+      convert_344 ();\n+    }\n+\n+  if (LDBL_DIG >= 31)\n+    {\n+      convert_351 ();\n+      convert_352 ();\n+      convert_353 ();\n+      convert_354 ();\n+    }\n+\n+  if (LDBL_DIG >= 33)\n+    {\n+      convert_361 ();\n+      convert_362 ();\n+      convert_363 ();\n+      convert_364 ();\n+    }\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "0fb4f076d25f132db74bcc54116783ae9a057d57", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-7.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-7.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-options \"-std=gnu99 -w\" } */\n+\n+/* This test assumes IEEE float and double.  */\n+\n+#define __STDC_WANT_DEC_FP__\n+#include <float.h>\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+\n+/* Check values that are too large for the result type.  */\n+CONVERT_TO_PINF (301, sd, sf, 4.e+38df, f)\n+CONVERT_TO_PINF (303, dd, sf, 4.e+38dd, f)\n+CONVERT_TO_PINF (302, sd, sf, 9.9e+384df, f)\n+CONVERT_TO_PINF (304, dd, sf, 9.9e+384dd, f)\n+CONVERT_TO_PINF (305, td, sf, 4.e+38dl, f)\n+CONVERT_TO_PINF (306, td, sf, 1.e+39dl, f)\n+CONVERT_TO_MINF (311, sd, sf, -4.e+38df, f)\n+CONVERT_TO_MINF (312, dd, sf, -4.e+38dd, f)\n+CONVERT_TO_MINF (313, sd, sf, -9.9e+384df, f)\n+CONVERT_TO_MINF (314, dd, sf, -9.9e+384dd, f)\n+CONVERT_TO_MINF (315, td, sf, -4.e+38dl, f)\n+CONVERT_TO_MINF (316, td, sf, -1.e+39dl, f)\n+\n+CONVERT_TO_PINF (321, dd, df, 1.8e+308dd,)\n+CONVERT_TO_PINF (322, dd, df, 9.9e+384dd,)\n+CONVERT_TO_PINF (323, td, df, 1.8e+308dl,)\n+CONVERT_TO_PINF (324, td, df, 9.9e+384dl,)\n+CONVERT_TO_PINF (325, dd, df, 1.e309dd,)\n+CONVERT_TO_PINF (326, td, df, 1.e309dl,)\n+CONVERT_TO_MINF (331, dd, df, -1.8e+308dd,)\n+CONVERT_TO_MINF (332, dd, df, -9.9e+384dd,)\n+CONVERT_TO_MINF (333, td, df, -1.8e+308dl,)\n+CONVERT_TO_MINF (334, td, df, -9.9e+384dl,)\n+CONVERT_TO_MINF (335, dd, df, -1.e309dd,)\n+CONVERT_TO_MINF (336, td, df, -1.e309dl,)\n+\n+CONVERT_TO_PINF (341, df, sd, 1.0e+97, d32)\n+CONVERT_TO_PINF (342, df, sd, 1.6e+308, d32)\n+CONVERT_TO_MINF (351, df, sd, -1.0e+97, d32)\n+CONVERT_TO_MINF (352, df, sd, -1.6e+308, d32)\n+\n+int\n+main ()\n+{\n+  convert_301 ();\n+  convert_302 ();\n+  convert_303 ();\n+  convert_304 ();\n+  convert_305 ();\n+  convert_306 ();\n+  convert_311 ();\n+  convert_312 ();\n+  convert_313 ();\n+  convert_314 ();\n+  convert_315 ();\n+  convert_316 ();\n+\n+  convert_321 ();\n+  convert_322 ();\n+  convert_323 ();\n+  convert_324 ();\n+  convert_325 ();\n+  convert_326 ();\n+  convert_331 ();\n+  convert_332 ();\n+  convert_333 ();\n+  convert_334 ();\n+  convert_335 ();\n+  convert_336 ();\n+\n+  convert_341 ();\n+  convert_342 ();\n+  convert_351 ();\n+  convert_352 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "269fc37f208274c7728c1a16ae1ef35769811f72", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-8.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-8.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-options \"-std=gnu99 -w\" } */\n+\n+/* This test assumes IEEE float and double.  */\n+\n+#define __STDC_WANT_DEC_FP__\n+#include <float.h>\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+\n+/* Values slightly smaller than minimum (closest to zero) for result type.  */\n+CONVERT_VALID (401, sd, sf, 1.e-39df, 0.f, FLT_MIN)\n+CONVERT_VALID (402, sd, sf, -1.e-39df, 0.f, FLT_MIN)\n+CONVERT_VALID (403, sd, sf, 1.1e-38df, 0.f, FLT_MIN)\n+CONVERT_VALID (404, sd, sf, -1.1e-38df, 0.f, FLT_MIN)\n+\n+CONVERT_VALID (411, dd, sf, 1.e-39dd, 0.f, FLT_MIN)\n+CONVERT_VALID (412, dd, sf, -1.e-39dd, 0.f, FLT_MIN)\n+CONVERT_VALID (413, dd, sf, 1.1e-38dd, 0.f, FLT_MIN)\n+CONVERT_VALID (414, dd, sf, -1.1e-38dd, 0.f, FLT_MIN)\n+\n+CONVERT_VALID (421, dd, df, 3.e-309dd, 0., DBL_MIN)\n+CONVERT_VALID (422, dd, df, -3.e-309dd, 0., DBL_MIN)\n+CONVERT_VALID (423, dd, df, 2.e-308dd, 0., DBL_MIN)\n+CONVERT_VALID (424, dd, df, -2.e-308dd, 0., DBL_MIN)\n+\n+CONVERT_VALID (431, td, sf, 1.e-39dl, 0.f, FLT_MIN)\n+CONVERT_VALID (432, td, sf, -1.e-39dl, 0.f, FLT_MIN)\n+CONVERT_VALID (433, td, sf, 1.1e-38dl, 0.f, FLT_MIN)\n+CONVERT_VALID (434, td, sf, -1.1e-38dl, 0.f, FLT_MIN)\n+\n+CONVERT_VALID (441, td, df, 3.e-309dl, 0., DBL_MIN)\n+CONVERT_VALID (442, td, df, -3.e-309dl, 0., DBL_MIN)\n+CONVERT_VALID (443, td, df, 2.e-308dl, 0., DBL_MIN)\n+CONVERT_VALID (444, td, df, -2.e-308dl, 0., DBL_MIN)\n+\n+int\n+main ()\n+{\n+  convert_401 ();\n+  convert_402 ();\n+  convert_403 ();\n+  convert_404 ();\n+\n+  convert_411 ();\n+  convert_412 ();\n+  convert_413 ();\n+  convert_414 ();\n+\n+  convert_421 ();\n+  convert_422 ();\n+  convert_423 ();\n+  convert_424 ();\n+\n+  convert_431 ();\n+  convert_432 ();\n+  convert_433 ();\n+  convert_434 ();\n+\n+  convert_441 ();\n+  convert_442 ();\n+  convert_443 ();\n+  convert_444 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "86ae4303034a35fc88031f12281dcdaaa754cbf7", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp-9.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp-9.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,193 @@\n+/* { dg-options \"-std=gnu99 -w\" } */\n+\n+/* This test assumes IEEE float and double.  */\n+\n+#define __STDC_WANT_DEC_FP__\n+#include <float.h>\n+\n+#include \"convert.h\"\n+\n+volatile _Decimal32 sd;\n+volatile _Decimal64 dd;\n+volatile _Decimal128 td;\n+volatile float sf;\n+volatile double df;\n+\n+/* Exponent values that might cause problems with a particular\n+   implementation.  */\n+\n+CONVERT_VALID (101, dd, df, 1.e309dd, 1.e309, 0.) \n+CONVERT_VALID (102, dd, df, 1.e308dd, 1.e308, 0.)\n+CONVERT_VALID (103, dd, df, 1.e307dd, 1.e307, 0.) \n+CONVERT_VALID (104, dd, df, 1.e306dd, 1.e306, 0.) \n+CONVERT_VALID (105, dd, df, 1.e305dd, 1.e305, 0.)\n+CONVERT_VALID (106, dd, df, 1.e304dd, 1.e304, 0.)\n+CONVERT_VALID (107, dd, df, 1.e303dd, 1.e303, 0.) \n+CONVERT_VALID (108, dd, df, 1.e302dd, 1.e302, 0.) \n+CONVERT_VALID (109, dd, df, 1.e301dd, 1.e301, 0.) \n+CONVERT_VALID (110, dd, df, 1.e300dd, 1.e300, 0.) \n+CONVERT_VALID (111, dd, df, 1.e299dd, 1.e299, 0.) \n+CONVERT_VALID (112, dd, df, 1.e298dd, 1.e298, 0.) \n+CONVERT_VALID (113, dd, df, 1.e297dd, 1.e297, 0.) \n+CONVERT_VALID (114, dd, df, 1.e296dd, 1.e296, 0.) \n+CONVERT_VALID (115, dd, df, 1.e295dd, 1.e295, 0.) \n+CONVERT_VALID (116, dd, df, 1.e294dd, 1.e294, 0.) \n+CONVERT_VALID (117, dd, df, 1.e293dd, 1.e293, 0.) \n+CONVERT_VALID (118, dd, df, 1.e292dd, 1.e292, 0.) \n+CONVERT_VALID (119, dd, df, 1.e291dd, 1.e291, 0.)\n+CONVERT_VALID (120, dd, df, 1.e290dd, 1.e290, 0.)\n+\n+CONVERT_VALID (201, dd, df, 1.e-309dd, 1.e-309, 0.) \n+CONVERT_VALID (202, dd, df, 1.e-308dd, 1.e-308, 0.) \n+CONVERT_VALID (203, dd, df, 1.e-307dd, 1.e-307, 0.) \n+CONVERT_VALID (204, dd, df, 1.e-306dd, 1.e-306, 0.) \n+CONVERT_VALID (205, dd, df, 1.e-305dd, 1.e-305, 0.) \n+CONVERT_VALID (206, dd, df, 1.e-304dd, 1.e-304, 0.) \n+CONVERT_VALID (207, dd, df, 1.e-303dd, 1.e-303, 0.) \n+CONVERT_VALID (208, dd, df, 1.e-302dd, 1.e-302, 0.) \n+CONVERT_VALID (209, dd, df, 1.e-301dd, 1.e-301, 0.) \n+CONVERT_VALID (210, dd, df, 1.e-300dd, 1.e-300, 0.) \n+CONVERT_VALID (211, dd, df, 1.e-299dd, 1.e-299, 0.) \n+CONVERT_VALID (212, dd, df, 1.e-298dd, 1.e-298, 0.) \n+CONVERT_VALID (213, dd, df, 1.e-297dd, 1.e-297, 0.) \n+CONVERT_VALID (214, dd, df, 1.e-296dd, 1.e-296, 0.) \n+CONVERT_VALID (215, dd, df, 1.e-295dd, 1.e-295, 0.)\n+CONVERT_VALID (216, dd, df, 1.e-294dd, 1.e-294, 0.)\n+CONVERT_VALID (217, dd, df, 1.e-293dd, 1.e-293, 0.) \n+CONVERT_VALID (218, dd, df, 1.e-292dd, 1.e-292, 0.) \n+CONVERT_VALID (219, dd, df, 1.e-291dd, 1.e-291, 0.) \n+CONVERT_VALID (220, dd, df, 1.e-290dd, 1.e-290, 0.) \n+\n+CONVERT_VALID (301, td, df, 1.e309dl, 1.e309, 0.) \n+CONVERT_VALID (302, td, df, 1.e308dl, 1.e308, 0.)\n+CONVERT_VALID (303, td, df, 1.e307dl, 1.e307, 0.) \n+CONVERT_VALID (304, td, df, 1.e306dl, 1.e306, 0.) \n+CONVERT_VALID (305, td, df, 1.e305dl, 1.e305, 0.)\n+CONVERT_VALID (306, td, df, 1.e304dl, 1.e304, 0.)\n+CONVERT_VALID (307, td, df, 1.e303dl, 1.e303, 0.) \n+CONVERT_VALID (308, td, df, 1.e302dl, 1.e302, 0.) \n+CONVERT_VALID (309, td, df, 1.e301dl, 1.e301, 0.)\n+CONVERT_VALID (310, td, df, 1.e300dl, 1.e300, 0.) \n+CONVERT_VALID (311, td, df, 1.e299dl, 1.e299, 0.)\n+CONVERT_VALID (312, td, df, 1.e298dl, 1.e298, 0.)\n+CONVERT_VALID (313, td, df, 1.e297dl, 1.e297, 0.) \n+CONVERT_VALID (314, td, df, 1.e296dl, 1.e296, 0.) \n+CONVERT_VALID (315, td, df, 1.e295dl, 1.e295, 0.)\n+CONVERT_VALID (316, td, df, 1.e294dl, 1.e294, 0.)\n+CONVERT_VALID (317, td, df, 1.e293dl, 1.e293, 0.) \n+CONVERT_VALID (318, td, df, 1.e292dl, 1.e292, 0.) \n+CONVERT_VALID (319, td, df, 1.e291dl, 1.e291, 0.) \n+CONVERT_VALID (320, td, df, 1.e290dl, 1.e290, 0.)\n+\n+CONVERT_VALID (401, td, df, 1.e-309dl, 1.e-309, 0.) \n+CONVERT_VALID (402, td, df, 1.e-308dl, 1.e-308, 0.) \n+CONVERT_VALID (403, td, df, 1.e-307dl, 1.e-307, 0.) \n+CONVERT_VALID (404, td, df, 1.e-306dl, 1.e-306, 0.) \n+CONVERT_VALID (405, td, df, 1.e-305dl, 1.e-305, 0.) \n+CONVERT_VALID (406, td, df, 1.e-304dl, 1.e-304, 0.) \n+CONVERT_VALID (407, td, df, 1.e-303dl, 1.e-303, 0.) \n+CONVERT_VALID (408, td, df, 1.e-302dl, 1.e-302, 0.) \n+CONVERT_VALID (409, td, df, 1.e-301dl, 1.e-301, 0.) \n+CONVERT_VALID (410, td, df, 1.e-300dl, 1.e-300, 0.) \n+CONVERT_VALID (411, td, df, 1.e-299dl, 1.e-299, 0.) \n+CONVERT_VALID (412, td, df, 1.e-298dl, 1.e-298, 0.) \n+CONVERT_VALID (413, td, df, 1.e-297dl, 1.e-297, 0.) \n+CONVERT_VALID (414, td, df, 1.e-296dl, 1.e-296, 0.) \n+CONVERT_VALID (415, td, df, 1.e-295dl, 1.e-295, 0.) \n+CONVERT_VALID (416, td, df, 1.e-294dl, 1.e-294, 0.) \n+CONVERT_VALID (417, td, df, 1.e-293dl, 1.e-293, 0.) \n+CONVERT_VALID (418, td, df, 1.e-292dl, 1.e-292, 0.)\n+CONVERT_VALID (419, td, df, 1.e-291dl, 1.e-291, 0.) \n+CONVERT_VALID (420, td, df, 1.e-290dl, 1.e-290, 0.)\n+\n+int\n+main ()\n+{\n+  convert_101 ();\n+  convert_102 ();\n+  convert_103 ();\n+  convert_104 ();\n+  convert_105 ();\n+  convert_106 ();\n+  convert_107 ();\n+  convert_108 ();\n+  convert_109 ();\n+  convert_110 ();\n+  convert_111 ();\n+  convert_112 ();\n+  convert_113 ();\n+  convert_114 ();\n+  convert_115 ();\n+  convert_116 ();\n+  convert_117 ();\n+  convert_118 ();\n+  convert_119 ();\n+  convert_120 ();\n+\n+  convert_201 ();\n+  convert_202 ();\n+  convert_203 ();\n+  convert_204 ();\n+  convert_205 ();\n+  convert_206 ();\n+  convert_207 ();\n+  convert_208 ();\n+  convert_209 ();\n+  convert_210 ();\n+  convert_211 ();\n+  convert_212 ();\n+  convert_213 ();\n+  convert_214 ();\n+  convert_215 ();\n+  convert_216 ();\n+  convert_217 ();\n+  convert_218 ();\n+  convert_219 ();\n+  convert_220 ();\n+\n+  convert_301 ();\n+  convert_302 ();\n+  convert_303 ();\n+  convert_304 ();\n+  convert_305 ();\n+  convert_306 ();\n+  convert_307 ();\n+  convert_308 ();\n+  convert_309 ();\n+  convert_310 ();\n+  convert_311 ();\n+  convert_312 ();\n+  convert_313 ();\n+  convert_314 ();\n+  convert_315 ();\n+  convert_316 ();\n+  convert_317 ();\n+  convert_318 ();\n+  convert_319 ();\n+  convert_320 ();\n+\n+  convert_401 ();\n+  convert_402 ();\n+  convert_403 ();\n+  convert_404 ();\n+  convert_405 ();\n+  convert_406 ();\n+  convert_407 ();\n+  convert_408 ();\n+  convert_409 ();\n+  convert_410 ();\n+  convert_411 ();\n+  convert_412 ();\n+  convert_413 ();\n+  convert_414 ();\n+  convert_415 ();\n+  convert_416 ();\n+  convert_417 ();\n+  convert_418 ();\n+  convert_419 ();\n+  convert_420 ();\n+\n+  if (failcnt != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "b2e8ca87b164f70677c1edf2014022094a3da24a", "filename": "gcc/testsuite/gcc.dg/dfp/convert-bfp.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-bfp.c?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -5,10 +5,10 @@\n    C99 6.3.1.5(4) Conversions, arithmetic operands, real floating types.  */\n \n /* Long double isn't supported yet at runtime, so disable those checks.  */\n-#define SKIP_LONG_DOUBLE\n \n extern void abort (void);\n static int failcnt;\n+static int skip_long_double;\n \n /* Support compiling the test to report individual failures; default is\n    to abort as soon as a check fails.  */\n@@ -24,15 +24,16 @@ volatile _Decimal64 d64;\n volatile _Decimal128 d128;\n volatile float sf;\n volatile double df;\n-#ifndef SKIP_LONG_DOUBLE\n volatile long double tf;\n-#endif\n \n int\n main ()\n {\n   /* Conversions from decimal float to binary float. */\n \n+  if (sizeof (long double) == sizeof (double))\n+    skip_long_double = 1;\n+\n   /* Conversions from _Decimal32. */\n   d32 = 2.0df;\n   sf = d32;\n@@ -43,11 +44,12 @@ main ()\n   if (df != 2.0)\n     FAILURE\n \n-#ifndef SKIP_LONG_DOUBLE\n-  tf = d32;\n-  if (tf != 2.0l)\n-    FAILURE\n-#endif\n+  if (skip_long_double == 0)\n+    {\n+      tf = d32;\n+      if (tf != 2.0l)\n+\tFAILURE\n+    }\n \n   /* Conversions from _Decimal64. */\n   d64 = -7.0dd;\n@@ -59,11 +61,12 @@ main ()\n   if (df != -7.0)\n     FAILURE\n \n-#ifndef SKIP_LONG_DOUBLE\n-  tf = d64;\n-  if (tf != -7.0l)\n-    FAILURE\n-#endif\n+  if (skip_long_double == 0)\n+    {\n+      tf = d64;\n+      if (tf != -7.0l)\n+\tFAILURE\n+    }\n \n   /* Conversions from _Decimal128. */\n   d128 = 30.0dl;\n@@ -107,20 +110,21 @@ main ()\n   if (d128 != 30.0dl)\n     FAILURE\n \n-#ifndef SKIP_LONG_DOUBLE\n-  tf = -22.0l;\n-  d32 = tf;\n-  if (d32 != -22.0df)\n-    FAILURE\n+  if (skip_long_double == 0)\n+    {\n+      tf = -22.0l;\n+      d32 = tf;\n+      if (d32 != -22.0df)\n+\tFAILURE\n \n-  d64 = tf;\n-  if (d64 != -22.0dd)\n-    FAILURE\n+      d64 = tf;\n+      if (d64 != -22.0dd)\n+\tFAILURE\n \n-  d128 = tf;\n-  if (d128 != -22.0dl)\n-    FAILURE\n-#endif\n+      d128 = tf;\n+      if (d128 != -22.0dl)\n+\tFAILURE\n+     }\n \n   /* 2**(-11) = 0.00048828125. */\n   d128 = 0.000488281251dl;"}, {"sha": "bc9ef42f4dd508b9cd95fe22b58309c28d49f05a", "filename": "gcc/testsuite/gcc.dg/dfp/convert.h", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d110ef046e4dd98a82ba8a6365427181c16b1e/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert.h?ref=f3d110ef046e4dd98a82ba8a6365427181c16b1e", "patch": "@@ -0,0 +1,461 @@\n+extern void abort (void);\n+static int failcnt = 0;\n+\n+/* Macros are set up to skip using long double, which doesn't necessarily\n+   map to TF mode.  If there's a reason to skip those for a test, the\n+   test itself can define USE_TF to be zero.  */\n+#ifndef USE_TF\n+#define USE_TF 1\n+#endif\n+\n+/* Support compiling the test to report individual failures; default is\n+   to abort as soon as a check fails.  */\n+#if defined(DBG) || defined(DBG2)\n+#include <stdio.h>\n+#define FAILURE(NUM) \\\n+  { printf (\"failed for test %s\\n\", NUM); failcnt++; }\n+#else\n+#define FAILURE(N) abort ();\n+#endif\n+\n+/* This is useful when modifying the test to make sure that tests are\n+   actually run.  */\n+#if defined(DBG2)\n+#define REPORT(NUM) \\\n+  { printf (\"%s\\n\", NUM); }\n+#else\n+#define REPORT(N) ;\n+#endif\n+\n+#define CONVERT_VALID(NUM,FROM,TO,FROMVAL,TOVAL,DIFF)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \" \" #FROMVAL)\t\t\t\t\t\\\n+  FROM = FROMVAL;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (TO < (TOVAL - DIFF) || TO > (TOVAL + DIFF))\t\t\\\n+    FAILURE (#NUM);\t\t\t\t\t\t\\\n+}\n+\n+#define CONVERT_TO_PINF(NUM,FROM,TO,FROMVAL,TOSUFFIX)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \" \" #FROMVAL)\t\t\t\t\t\\\n+  FROM = FROMVAL;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (__builtin_isinf##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: isinf\");\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) != 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_TO_MINF(NUM,FROM,TO,FROMVAL,TOSUFFIX)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \" \" #FROMVAL)\t\t\t\t\t\\\n+  FROM = FROMVAL;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (__builtin_isinf##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: isinf\");\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_TO_PZERO(NUM,FROM,TO,FROMVAL,TOVAL,TOSUFFIX)\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \" \" #FROMVAL)\t\t\t\t\t\\\n+  FROM = FROMVAL;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (TO != TOVAL)\t\t\t\t\t\t\\\n+    FAILURE (#NUM \"_pzero: zero\")\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) != 0)\t\t\t\\\n+    FAILURE (#NUM \" _pzero: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_TO_MZERO(NUM,FROM,TO,FROMVAL,TOVAL,TOSUFFIX)\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \" \" #FROMVAL)\t\t\t\t\t\\\n+  FROM = FROMVAL;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (TO != TOVAL)\t\t\t\t\t\t\\\n+    FAILURE (#NUM \"_mzero: zero\")\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" _mzero: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_NAN(NUM,FROM,TO,FROMSUFFIX,TOSUFFIX)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM##_nan (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT(#NUM \"_nan\")\t\t\t\t\t\t\\\n+  FROM = __builtin_nan##FROMSUFFIX (\"\");\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (__builtin_isnan##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" nan\");\t\t\t\t\t\\\n+}\n+\n+#define CONVERT_PINF(NUM,FROM,TO,FROMSUFFIX,TOSUFFIX)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM##_pinf (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT (#NUM \"_pinf\")\t\t\t\t\t\t\\\n+  FROM = __builtin_inf##FROMSUFFIX ();\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (__builtin_isinf##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: isinf\");\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) != 0)\t\t\t\\\n+    FAILURE (#NUM \" pinf: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_MINF(NUM,FROM,TO,FROMSUFFIX,TOSUFFIX)\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM##_minf (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT (#NUM \"_minf\")\t\t\t\t\t\t\\\n+  FROM = -__builtin_inf##FROMSUFFIX ();\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (__builtin_isinf##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" minf: isinf\");\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" minf: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_PZERO(NUM,FROM,TO,FROMVALUE,TOVALUE,TOSUFFIX)\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM##_pzero (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT (#NUM \"_pzero\")\t\t\t\t\t\\\n+  FROM = FROMVALUE;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (TO != TOVALUE)\t\t\t\t\t\t\\\n+    FAILURE (#NUM \"pzero: zero\")\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) != 0)\t\t\t\\\n+    FAILURE (#NUM \" pzero: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_MZERO(NUM,FROM,TO,FROMVALUE,TOVALUE,TOSUFFIX)\t\\\n+void\t\t\t\t\t\t\t\t\\\n+convert_##NUM##_mzero (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  REPORT (#NUM \"_mzero\")\t\t\t\t\t\\\n+  FROM = FROMVALUE;\t\t\t\t\t\t\\\n+  TO = FROM;\t\t\t\t\t\t\t\\\n+  if (TO != TOVALUE)\t\t\t\t\t\t\\\n+    FAILURE (#NUM \"mzero: zero\")\t\t\t\t\\\n+  if (__builtin_signbit##TOSUFFIX (TO) == 0)\t\t\t\\\n+    FAILURE (#NUM \" mzero: sign\");\t\t\t\t\\\n+}\n+\n+#define CONVERT_VALID_NOTF(NUM,VAL,DIFF)\t\t\t\\\n+CONVERT_VALID (NUM##_sdsf, sd, sf, VAL##df, VAL##f, DIFF##f)\t\\\n+CONVERT_VALID (NUM##_sddf, sd, df, VAL##df, VAL, DIFF)\t\t\\\n+CONVERT_VALID (NUM##_ddsf, dd, sf, VAL##dd, VAL##f, DIFF##f)\t\\\n+CONVERT_VALID (NUM##_dddf, dd, df, VAL##dd, VAL, DIFF)\t\t\\\n+CONVERT_VALID (NUM##_tdsf, td, sf, VAL##dl, VAL##f, DIFF##f)\t\\\n+CONVERT_VALID (NUM##_tddf, td, df, VAL##dl, VAL, DIFF)\t\t\\\n+CONVERT_VALID (NUM##_sfsd, sf, sd, VAL##f, VAL##df, DIFF##df)\t\\\n+CONVERT_VALID (NUM##_sfdd, sf, dd, VAL##f, VAL##dd, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_sftd, sf, td, VAL##f, VAL##dl, DIFF##dl)\t\\\n+CONVERT_VALID (NUM##_dfsd, df, sd, VAL, VAL##df, DIFF##df)\t\\\n+CONVERT_VALID (NUM##_dfdd, df, dd, VAL, VAL##dd, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_dftd, df, td, VAL, VAL##dl, DIFF##dl)\t\\\n+CONVERT_VALID (NUM##_sddd, sd, dd, VAL##df, VAL##dd, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_sdtd, sd, dd, VAL##df, VAL##dd, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_ddsd, dd, sd, VAL##dd, VAL##df, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_ddtd, dd, td, VAL##dd, VAL##dl, DIFF##dl)\t\\\n+CONVERT_VALID (NUM##_tdsd, td, sd, VAL##dl, VAL##df, DIFF##df)\t\\\n+CONVERT_VALID (NUM##_tddd, td, dd, VAL##dl, VAL##dd, DIFF##dd)\n+\n+#if USE_TF == 0\n+#define CONVERT_VALID_TF(NUM,VAL,DIFF)\n+#else\n+#define CONVERT_VALID_TF(NUM,VAL,DIFF)\t\t\t\t\\\n+CONVERT_VALID (NUM##_sdtf, sd, tf, VAL##df, VAL##l, DIFF##l)\t\\\n+CONVERT_VALID (NUM##_tdtf, td, tf, VAL##dl, VAL##l, DIFF##l)\t\\\n+CONVERT_VALID (NUM##_ddtf, dd, tf, VAL##dd, VAL##l, DIFF##l)\t\\\n+CONVERT_VALID (NUM##_tfsd, tf, sd, VAL##l, VAL##df, DIFF##df)\t\\\n+CONVERT_VALID (NUM##_tfdd, tf, dd, VAL##l, VAL##dd, DIFF##dd)\t\\\n+CONVERT_VALID (NUM##_tftd, tf, td, VAL##l, VAL##dl, DIFF##dl)\n+#endif\n+\n+#define CONVERT_VALID_ALL(NUM,VAL,DIFF)\t\t\t\t\\\n+  CONVERT_VALID_NOTF(NUM,VAL,DIFF)\t\t\t\t\\\n+  CONVERT_VALID_TF(NUM,VAL,DIFF)\n+\n+#define CALL_VALID_NOTF(NUM)\t\t\t\t\t\\\n+  convert_##NUM##_sdsf ();\t\t\t\t\t\\\n+  convert_##NUM##_sddf ();\t\t\t\t\t\\\n+  convert_##NUM##_ddsf ();\t\t\t\t\t\\\n+  convert_##NUM##_dddf ();\t\t\t\t\t\\\n+  convert_##NUM##_tdsf ();\t\t\t\t\t\\\n+  convert_##NUM##_tddf ();\t\t\t\t\t\\\n+  convert_##NUM##_sfsd ();\t\t\t\t\t\\\n+  convert_##NUM##_sfdd ();\t\t\t\t\t\\\n+  convert_##NUM##_sftd ();\t\t\t\t\t\\\n+  convert_##NUM##_dfsd ();\t\t\t\t\t\\\n+  convert_##NUM##_dfdd ();\t\t\t\t\t\\\n+  convert_##NUM##_dftd ();\t\t\t\t\t\\\n+  convert_##NUM##_sddd ();\t\t\t\t\t\\\n+  convert_##NUM##_sdtd ();\t\t\t\t\t\\\n+  convert_##NUM##_ddsd ();\t\t\t\t\t\\\n+  convert_##NUM##_ddtd ();\t\t\t\t\t\\\n+  convert_##NUM##_tdsd ();\t\t\t\t\t\\\n+  convert_##NUM##_tddd ();\n+\n+#if USE_TF == 0\n+#define CALL_VALID_TF(NUM)\n+#else\n+#define CALL_VALID_TF(NUM)\t\t\t\t\t\\\n+  convert_##NUM##_sdtf ();\t\t\t\t\t\\\n+  convert_##NUM##_ddtf ();\t\t\t\t\t\\\n+  convert_##NUM##_tdtf ();\t\t\t\t\t\\\n+  convert_##NUM##_tfsd ();\t\t\t\t\t\\\n+  convert_##NUM##_tfdd ();\t\t\t\t\t\\\n+  convert_##NUM##_tftd ();\n+#endif\n+\n+#define CALL_VALID_ALL(NUM)\t\t\t\t\t\\\n+  CALL_VALID_NOTF(NUM)\t\t\t\t\t\t\\\n+  CALL_VALID_TF(NUM)\n+\n+#define CONVERT_ZEROES(NUM,FROM,TO,FROMVALUE,TOVALUE,TOSUFFIX)\t\\\n+CONVERT_PZERO(NUM, FROM, TO, FROMVALUE, TOVALUE, TOSUFFIX)\t\\\n+CONVERT_MZERO(NUM, FROM, TO, -FROMVALUE, -TOVALUE, TOSUFFIX)\n+\n+#define CONVERT_ZEROES_NOTF(NUM)\t\t\t\t\\\n+CONVERT_ZEROES (NUM##_sdsf, sd, sf, 0.0df, 0.0f, f)\t\t\\\n+CONVERT_ZEROES (NUM##_sddf, sd, df, 0.0df, 0.0, )\t\t\\\n+CONVERT_ZEROES (NUM##_ddsf, dd, sf, 0.0dd, 0.0f, f)\t\t\\\n+CONVERT_ZEROES (NUM##_dddf, dd, df, 0.0dd, 0.0, )\t\t\\\n+CONVERT_ZEROES (NUM##_tdsf, td, sf, 0.0dl, 0.0f, f)\t\t\\\n+CONVERT_ZEROES (NUM##_tddf, td, df, 0.0dl, 0.0, )\t\t\\\n+CONVERT_ZEROES (NUM##_sfsd, sf, sd, 0.0f, 0.0df, d32)\t\t\\\n+CONVERT_ZEROES (NUM##_sfdd, sf, dd, 0.0f, 0.0dd, d64)\t\t\\\n+CONVERT_ZEROES (NUM##_sftd, sf, td, 0.0f, 0.0dl, d128)\t\t\\\n+CONVERT_ZEROES (NUM##_dfsd, df, sd, 0.0, 0.0df, d32)\t\t\\\n+CONVERT_ZEROES (NUM##_dfdd, df, dd, 0.0, 0.0dd, d64)\t\t\\\n+CONVERT_ZEROES (NUM##_dftd, df, td, 0.0, 0.0dl, d128)\t\t\\\n+CONVERT_ZEROES (NUM##_sddd, sd, dd, 0.0df, 0.0dd, d64)\t\t\\\n+CONVERT_ZEROES (NUM##_sdtd, sd, td, 0.0dl, 0.0dl, d128)\t\t\\\n+CONVERT_ZEROES (NUM##_ddsd, dd, sd, 0.0dd, 0.0df, d32)\t\t\\\n+CONVERT_ZEROES (NUM##_ddtd, dd, td, 0.0dd, 0.0dl, d128)\t\t\\\n+CONVERT_ZEROES (NUM##_tdsd, td, sd, 0.0dl, 0.0df, d32)\t\t\\\n+CONVERT_ZEROES (NUM##_tddd, td, dd, 0.0dl, 0.0dd, d64)\n+\n+#if USE_TF == 0\n+#define CONVERT_ZEROES_TF(NUM)\n+#else\n+#define CONVERT_ZEROES_TF(NUM)\t\t\t\t\t\\\n+CONVERT_ZEROES (NUM##_sdtf, sd, tf, 0.0df, 0.0l, l)\t\t\\\n+CONVERT_ZEROES (NUM##_ddtf, dd, tf, 0.0dd, 0.0l, l)\t\t\\\n+CONVERT_ZEROES (NUM##_tdtf, td, tf, 0.0dl, 0.0l, l)\t\t\\\n+CONVERT_ZEROES (NUM##_tfsd, tf, sd, 0.0l, 0.0df, d32)\t\t\\\n+CONVERT_ZEROES (NUM##_tfdd, tf, dd, 0.0l, 0.0dd, d64)\t\t\\\n+CONVERT_ZEROES (NUM##_tftd, tf, td, 0.0l, 0.0dl, d128)\n+#endif\n+\n+#define CONVERT_ZEROES_ALL(NUM)\t\t\t\t\t\\\n+  CONVERT_ZEROES_NOTF(NUM)\t\t\t\t\t\\\n+  CONVERT_ZEROES_TF(NUM)\n+\n+#define CALL_ZEROES(NUM)\t\t\t\t\t\\\n+  convert_##NUM##_pzero ();\t\t\t\t\t\\\n+  convert_##NUM##_mzero ();\n+\n+#define CALL_ZEROES_NOTF(NUM)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sdsf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sddf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_ddsf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_dddf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tdsf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tddf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sfsd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sfdd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sftd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_dfsd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_dfdd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_dftd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sddd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sdtd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_ddsd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_ddtd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tdsd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tddd)\n+\n+#if USE_TF == 0\n+#define CALL_ZEROES_TF(NUM)\n+#else\n+#define CALL_ZEROES_TF(NUM)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_sdtf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_ddtf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tdtf)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tfsd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tfdd)\t\t\t\t\t\\\n+  CALL_ZEROES (NUM##_tftd)\n+#endif\n+\n+#define CALL_ZEROES_ALL(NUM)\t\t\t\t\t\\\n+  CALL_ZEROES_NOTF(NUM)\t\t\t\t\t\t\\\n+  CALL_ZEROES_TF(NUM)\n+\n+#define CONVERT_INF(NUM,FROM,TO,FROMSUFFIX,TOSUFFIX)\t\t\\\n+CONVERT_PINF (NUM, FROM, TO, FROMSUFFIX, TOSUFFIX)\t\t\\\n+CONVERT_MINF (NUM, FROM, TO, FROMSUFFIX, TOSUFFIX)\n+\n+#define CONVERT_INF_NOTF(NUM)\t\t\t\t\t\\\n+CONVERT_INF (NUM##_sdsf, sd, sf, d32, f)\t\t\t\\\n+CONVERT_INF (NUM##_sddf, sd, df, d32, )\t\t\t\t\\\n+CONVERT_INF (NUM##_ddsf, dd, sf, d64, f)\t\t\t\\\n+CONVERT_INF (NUM##_dddf, dd, df, d64, )\t\t\t\t\\\n+CONVERT_INF (NUM##_tdsf, td, sf, d128, f)\t\t\t\\\n+CONVERT_INF (NUM##_tddf, td, df, d128, )\t\t\t\\\n+CONVERT_INF (NUM##_sfsd, sf, sd, f, d32)\t\t\t\\\n+CONVERT_INF (NUM##_sfdd, sf, dd, f, d64)\t\t\t\\\n+CONVERT_INF (NUM##_sftd, sf, td, f, d128)\t\t\t\\\n+CONVERT_INF (NUM##_dfsd, df, sd, , d32)\t\t\t\t\\\n+CONVERT_INF (NUM##_dfdd, df, dd, , d64)\t\t\t\t\\\n+CONVERT_INF (NUM##_dftd, df, td, , d128)\t\t\t\\\n+CONVERT_INF (NUM##_sddd, sd, dd, d32, d64)\t\t\t\\\n+CONVERT_INF (NUM##_sdtd, sd, td, d32, d128)\t\t\t\\\n+CONVERT_INF (NUM##_ddsd, dd, sd, d64, d32)\t\t\t\\\n+CONVERT_INF (NUM##_ddtd, dd, td, d64, d128)\t\t\t\\\n+CONVERT_INF (NUM##_tdsd, td, sd, d128, d32)\t\t\t\\\n+CONVERT_INF (NUM##_tddd, td, dd, d128, d64)\n+\n+#if USE_TF == 0\n+#define CONVERT_INF_TF(NUM)\n+#else\n+#define CONVERT_INF_TF(NUM)\t\t\t\t\t\\\n+CONVERT_INF (NUM##_sdtf, sd, tf, d32, l)\t\t\t\\\n+CONVERT_INF (NUM##_ddtf, dd, tf, d64, l)\t\t\t\\\n+CONVERT_INF (NUM##_tdtf, td, tf, d128, l)\t\t\t\\\n+CONVERT_INF (NUM##_tfsd, tf, sd, l, d32)\t\t\t\\\n+CONVERT_INF (NUM##_tfdd, tf, dd, l, d64)\t\t\t\\\n+CONVERT_INF (NUM##_tftd, tf, td, l, d128)\n+#endif\n+\n+#define CONVERT_INF_ALL(NUM)\t\t\t\t\t\\\n+  CONVERT_INF_NOTF(NUM)\t\t\t\t\t\t\\\n+  CONVERT_INF_TF(NUM)\n+\n+#define CALL_INF(NUM)\t\t\t\t\t\t\\\n+  convert_##NUM##_pinf ();\t\t\t\t\t\\\n+  convert_##NUM##_minf ();\n+\n+#define CALL_INF_NOTF(NUM)\t\t\t\t\t\\\n+  CALL_INF (NUM##_sdsf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sddf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_ddsf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_dddf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tdsf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tddf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sfsd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sfdd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sftd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_dfsd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_dfdd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_dftd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sddd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_sdtd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_ddsd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_ddtd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tdsd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tddd)\n+\n+#if USE_TF == 0\n+#define CALL_INF_TF(NUM)\n+#else\n+#define CALL_INF_TF(NUM)\t\t\t\t\t\\\n+  CALL_INF (NUM##_sdtf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_ddtf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tdtf)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tfsd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tfdd)\t\t\t\t\t\t\\\n+  CALL_INF (NUM##_tftd)\n+#endif\n+\n+#define CALL_INF_ALL(NUM)\t\t\t\t\t\\\n+  CALL_INF_NOTF(NUM)\t\t\t\t\t\t\\\n+  CALL_INF_TF(NUM)\n+\n+#define CONVERT_NAN_NOTF(NUM)\t\t\t\t\t\\\n+CONVERT_NAN (NUM##_sdsf, sd, sf, d32, f)\t\t\t\\\n+CONVERT_NAN (NUM##_sddf, sd, df, d32, )\t\t\t\t\\\n+CONVERT_NAN (NUM##_ddsf, dd, sf, d64, f)\t\t\t\\\n+CONVERT_NAN (NUM##_dddf, dd, df, d64, )\t\t\t\t\\\n+CONVERT_NAN (NUM##_tdsf, td, sf, d128, f)\t\t\t\\\n+CONVERT_NAN (NUM##_tddf, td, df, d128, )\t\t\t\\\n+CONVERT_NAN (NUM##_sfsd, sf, sd, f, d32)\t\t\t\\\n+CONVERT_NAN (NUM##_sfdd, sf, dd, f, d64)\t\t\t\\\n+CONVERT_NAN (NUM##_sftd, sf, td, f, d128)\t\t\t\\\n+CONVERT_NAN (NUM##_dfsd, df, sd, , d32)\t\t\t\t\\\n+CONVERT_NAN (NUM##_dfdd, df, dd, , d64)\t\t\t\t\\\n+CONVERT_NAN (NUM##_dftd, df, td, , d128)\t\t\t\\\n+CONVERT_NAN (NUM##_sddd, sd, dd, d32, d64)\t\t\t\\\n+CONVERT_NAN (NUM##_sdtd, sd, td, d32, d128)\t\t\t\\\n+CONVERT_NAN (NUM##_ddsd, dd, sd, d64, d32)\t\t\t\\\n+CONVERT_NAN (NUM##_ddtd, dd, td, d64, d128)\t\t\t\\\n+CONVERT_NAN (NUM##_tdsd, td, sd, d128, d32)\t\t\t\\\n+CONVERT_NAN (NUM##_tddd, td, dd, d128, d64)\n+\n+#if USE_TF == 0\n+#define CONVERT_NAN_TF(NUM)\n+#else\n+#define CONVERT_NAN_TF(NUM)\t\t\t\t\t\\\n+CONVERT_NAN (NUM##_sdtf, sd, tf, d32, l)\t\t\t\\\n+CONVERT_NAN (NUM##_ddtf, dd, tf, d64, l)\t\t\t\\\n+CONVERT_NAN (NUM##_tdtf, td, tf, d128, l)\t\t\t\\\n+CONVERT_NAN (NUM##_tfsd, tf, sd, l, d32)\t\t\t\\\n+CONVERT_NAN (NUM##_tfdd, tf, dd, l, d64)\t\t\t\\\n+CONVERT_NAN (NUM##_tftd, tf, td, l, d128)\n+#endif\n+\n+#define CONVERT_NAN_ALL(NUM)\t\t\t\t\t\\\n+  CONVERT_NAN_NOTF(NUM)\t\t\t\t\t\t\\\n+  CONVERT_NAN_TF(NUM)\n+\n+#define CALL_NAN(NUM)\t\t\t\t\t\t\\\n+  convert_##NUM##_nan ();\n+\n+#define CALL_NAN_NOTF(NUM)\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sdsf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sddf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_ddsf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_dddf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tdsf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tddf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sfsd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sfdd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sftd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_dfsd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_dfdd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_dftd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sddd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sdtd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_ddsd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_ddtd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tdsd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tddd)\n+\n+#if USE_TF == 0\n+#define CALL_NAN_TF(NUM)\n+#else\n+#define CALL_NAN_TF(NUM)\t\t\t\t\t\\\n+  CALL_NAN (NUM##_sdtf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_ddtf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tdtf)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tfsd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tfdd)\t\t\t\t\t\t\\\n+  CALL_NAN (NUM##_tftd)\n+#endif\n+\n+#define CALL_NAN_ALL(NUM)\t\t\t\t\t\\\n+  CALL_NAN_NOTF(NUM)\t\t\t\t\t\t\\\n+  CALL_NAN_TF(NUM)"}]}