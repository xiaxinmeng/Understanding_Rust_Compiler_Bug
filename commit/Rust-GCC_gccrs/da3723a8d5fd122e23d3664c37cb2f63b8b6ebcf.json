{"sha": "da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEzNzIzYThkNWZkMTIyZTIzZDM2NjRjMzdjYjJmNjNiOGI2ZWJjZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-10-02T18:17:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-10-02T18:17:39Z"}, "message": "re PR fortran/82312 ([OOP] Pointer assignment to component of class variable results wrong vptr for the variable.)\n\n2017-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/82312\n\t* resolve.c (gfc_resolve_code): Simplify condition for class\n\tpointer assignments becoming regular assignments by asserting\n\tthat only class valued targets are permitted.\n\t* trans-expr.c (trans_class_pointer_fcn): New function using a\n\tblock of code from gfc_trans_pointer_assignment.\n\t(gfc_trans_pointer_assignment): Call the new function. Tidy up\n\ta minor whitespace issue.\n\n2017-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/82312\n\t* gfortran.dg/typebound_proc_36.f90 : New test.\n\nFrom-SVN: r253362", "tree": {"sha": "9bc2d2fccfec8b11b64c98728674df0220d06e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bc2d2fccfec8b11b64c98728674df0220d06e67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/comments", "author": null, "committer": null, "parents": [{"sha": "20a7e14aadb19439b36115bbf8e75ffc70f23501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a7e14aadb19439b36115bbf8e75ffc70f23501", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a7e14aadb19439b36115bbf8e75ffc70f23501"}], "stats": {"total": 164, "additions": 136, "deletions": 28}, "files": [{"sha": "0e7c7a8e787cb3eafc46b2209d86be59767eb6d9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "patch": "@@ -1,3 +1,14 @@\n+2017-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/82312\n+\t* resolve.c (gfc_resolve_code): Simplify condition for class\n+\tpointer assignments becoming regular assignments by asserting\n+\tthat only class valued targets are permitted.\n+\t* trans-expr.c (trans_class_pointer_fcn): New function using a\n+\tblock of code from gfc_trans_pointer_assignment.\n+\t(gfc_trans_pointer_assignment): Call the new function. Tidy up\n+\ta minor whitespace issue.\n+\n 2017-10-01  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR fortran/61450"}, {"sha": "698cf6de2fdc4a8392fc73ddde80b60126b80658", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "patch": "@@ -11119,11 +11119,8 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \t    /* Assigning a class object always is a regular assign.  */\n \t    if (code->expr2->ts.type == BT_CLASS\n+\t\t&& code->expr1->ts.type == BT_CLASS\n \t\t&& !CLASS_DATA (code->expr2)->attr.dimension\n-\t\t&& !(UNLIMITED_POLY (code->expr2)\n-\t\t     && code->expr1->ts.type == BT_DERIVED\n-\t\t     && (code->expr1->ts.u.derived->attr.sequence\n-\t\t\t || code->expr1->ts.u.derived->attr.is_bind_c))\n \t\t&& !(gfc_expr_attr (code->expr1).proc_pointer\n \t\t     && code->expr2->expr_type == EXPR_VARIABLE\n \t\t     && code->expr2->symtree->n.sym->attr.flavor"}, {"sha": "d1b61b5228bb26e1884f12d0747feee96d995104", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "patch": "@@ -8207,6 +8207,39 @@ pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)\n }\n \n \n+/* Do everything that is needed for a CLASS function expr2.  */\n+\n+static tree\n+trans_class_pointer_fcn (stmtblock_t *block, gfc_se *lse, gfc_se *rse,\n+\t\t\t gfc_expr *expr1, gfc_expr *expr2)\n+{\n+  tree expr1_vptr = NULL_TREE;\n+  tree tmp;\n+\n+  gfc_conv_function_expr (rse, expr2);\n+  rse->expr = gfc_evaluate_now (rse->expr, &rse->pre);\n+\n+  if (expr1->ts.type != BT_CLASS)\n+      rse->expr = gfc_class_data_get (rse->expr);\n+  else\n+    {\n+      expr1_vptr = trans_class_vptr_len_assignment (block, expr1,\n+\t\t\t\t\t\t    expr2, rse,\n+\t\t\t\t\t\t    NULL, NULL);\n+      gfc_add_block_to_block (block, &rse->pre);\n+      tmp = gfc_create_var (TREE_TYPE (rse->expr), \"ptrtemp\");\n+      gfc_add_modify (&lse->pre, tmp, rse->expr);\n+\n+      gfc_add_modify (&lse->pre, expr1_vptr,\n+\t\t      fold_convert (TREE_TYPE (expr1_vptr),\n+\t\t      gfc_class_vptr_get (tmp)));\n+      rse->expr = gfc_class_data_get (tmp);\n+    }\n+\n+  return expr1_vptr;\n+}\n+\n+\n tree\n gfc_trans_pointer_assign (gfc_code * code)\n {\n@@ -8224,6 +8257,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   stmtblock_t block;\n   tree desc;\n   tree tmp;\n+  tree expr1_vptr = NULL_TREE;\n   bool scalar, non_proc_pointer_assign;\n   gfc_ss *ss;\n \n@@ -8257,7 +8291,10 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_conv_expr (&lse, expr1);\n       gfc_init_se (&rse, NULL);\n       rse.want_pointer = 1;\n-      gfc_conv_expr (&rse, expr2);\n+      if (expr2->expr_type == EXPR_FUNCTION && expr2->ts.type == BT_CLASS)\n+\ttrans_class_pointer_fcn (&block, &lse, &rse, expr1, expr2);\n+      else\n+\tgfc_conv_expr (&rse, expr2);\n \n       if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)\n \t{\n@@ -8269,12 +8306,12 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       if (expr1->symtree->n.sym->attr.proc_pointer\n \t  && expr1->symtree->n.sym->attr.dummy)\n \tlse.expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t    lse.expr);\n+\t\t\t\t\t\tlse.expr);\n \n       if (expr2->symtree && expr2->symtree->n.sym->attr.proc_pointer\n \t  && expr2->symtree->n.sym->attr.dummy)\n \trse.expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t    rse.expr);\n+\t\t\t\t\t\trse.expr);\n \n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n@@ -8320,7 +8357,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     {\n       gfc_ref* remap;\n       bool rank_remap;\n-      tree expr1_vptr = NULL_TREE;\n       tree strlen_lhs;\n       tree strlen_rhs = NULL_TREE;\n \n@@ -8355,26 +8391,8 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  rse.byref_noassign = 1;\n \n \t  if (expr2->expr_type == EXPR_FUNCTION && expr2->ts.type == BT_CLASS)\n-\t    {\n-\t      gfc_conv_function_expr (&rse, expr2);\n-\n-\t      if (expr1->ts.type != BT_CLASS)\n-\t\trse.expr = gfc_class_data_get (rse.expr);\n-\t      else\n-\t\t{\n-\t\t  expr1_vptr = trans_class_vptr_len_assignment (&block, expr1,\n-\t\t\t\t\t\t\t\texpr2, &rse,\n-\t\t\t\t\t\t\t\tNULL, NULL);\n-\t\t  gfc_add_block_to_block (&block, &rse.pre);\n-\t\t  tmp = gfc_create_var (TREE_TYPE (rse.expr), \"ptrtemp\");\n-\t\t  gfc_add_modify (&lse.pre, tmp, rse.expr);\n-\n-\t\t  gfc_add_modify (&lse.pre, expr1_vptr,\n-\t\t\t\t  fold_convert (TREE_TYPE (expr1_vptr),\n-\t\t\t\t\t\tgfc_class_vptr_get (tmp)));\n-\t\t  rse.expr = gfc_class_data_get (tmp);\n-\t\t}\n-\t    }\n+\t    expr1_vptr = trans_class_pointer_fcn (&block, &lse, &rse,\n+\t\t\t\t\t\t  expr1, expr2);\n \t  else if (expr2->expr_type == EXPR_FUNCTION)\n \t    {\n \t      tree bound[GFC_MAX_DIMENSIONS];"}, {"sha": "8c5139433922853a037e8ff9d806167ae89713ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "patch": "@@ -1,3 +1,8 @@\n+2017-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/82312\n+\t* gfortran.dg/typebound_proc_36.f90 : New test.\n+\n 2017-10-02  Peter Bergner  <bergner@vnet.ibm.com>\n \n \tPR target/80210"}, {"sha": "5c9193c1e70d3ba965f77cca1cf21f799b226d1a", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_36.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_36.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_36.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_36.f90?ref=da3723a8d5fd122e23d3664c37cb2f63b8b6ebcf", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR82312.f90\n+!\n+! Posted on Stack Overflow:\n+! https://stackoverflow.com/questions/46369744\n+! /gfortran-associates-wrong-type-bound-procedure/46388339#46388339\n+!\n+module minimalisticcase\n+    implicit none\n+\n+    type, public :: DataStructure\n+        integer :: i\n+    contains\n+        procedure, pass :: init => init_data_structure\n+        procedure, pass :: a => beginning_of_alphabet\n+    end type\n+\n+    type, public :: DataLogger\n+        type(DataStructure), pointer :: data_structure\n+        contains\n+                procedure, pass :: init => init_data_logger\n+                procedure, pass :: do_something => do_something\n+    end type\n+\n+    integer :: ctr = 0\n+\n+contains\n+    subroutine init_data_structure(self)\n+        implicit none\n+        class(DataStructure), intent(inout) :: self\n+        write(*,*) 'init_data_structure'\n+        ctr = ctr + 1\n+    end subroutine\n+\n+    subroutine beginning_of_alphabet(self)\n+        implicit none\n+        class(DataStructure), intent(inout) :: self\n+\n+        write(*,*) 'beginning_of_alphabet'\n+        ctr = ctr + 10\n+    end subroutine\n+\n+    subroutine init_data_logger(self, data_structure)\n+        implicit none\n+        class(DataLogger), intent(inout) :: self\n+        class(DataStructure), target :: data_structure\n+        write(*,*) 'init_data_logger'\n+        ctr = ctr + 100\n+\n+        self%data_structure => data_structure ! Invalid change of 'self' vptr\n+        call self%do_something()\n+    end subroutine\n+\n+    subroutine do_something(self)\n+        implicit none\n+        class(DataLogger), intent(inout) :: self\n+\n+        write(*,*) 'do_something'\n+        ctr = ctr + 1000\n+\n+    end subroutine\n+end module\n+\n+program main\n+    use minimalisticcase\n+    implicit none\n+\n+    type(DataStructure) :: data_structure\n+    type(DataLogger) :: data_logger\n+\n+    call data_structure%init()\n+    call data_structure%a()\n+    call data_logger%init(data_structure)\n+\n+    if (ctr .ne. 1111) call abort\n+end program"}]}