{"sha": "ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E4MjNjODU4ODJmNWEwY2E5Nzc5ZDhjZDdhZGZjZWMwMjU0OWQzYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-25T11:04:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-25T11:04:01Z"}, "message": "tree-vectorizer.h (struct vec_info_shared): New structure with parts split out from struct vec_info and loop_nest from...\n\n2018-06-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct vec_info_shared): New structure\n\twith parts split out from struct vec_info and loop_nest from\n\tstruct _loop_vec_info.\n\t(struct vec_info): Adjust accordingly.\n\t(struct _loop_vec_info): Likewise.\n\t(LOOP_VINFO_LOOP_NEST): Adjust.\n\t(LOOP_VINFO_DATAREFS): Likewise.\n\t(LOOP_VINFO_DDRS): Likewise.\n\t(struct _bb_vec_info): Likewise.\n\t(BB_VINFO_DATAREFS): Likewise.\n\t(BB_VINFO_DDRS): Likewise.\n\t(struct _stmt_vec_info): Add dr_aux member.\n\t(DR_VECT_AUX): Adjust to refer to member of DR_STMTs vinfo.\n\t(DR_MISALIGNMENT_UNINITIALIZED): New.\n\t(set_dr_misalignment): Adjust.\n\t(dr_misalignment): Assert misalign isn't DR_MISALIGNMENT_UNINITIALIZED.\n\t(vect_analyze_loop): Adjust prototype.\n\t(vect_analyze_loop_form): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n\tCompute dependences lazily.\n\t(vect_record_base_alignments): Use shared datarefs/ddrs.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vect_analyze_data_refs_alignment): Likewise.\n\t(vect_analyze_data_ref_accesses): Likewise.\n\t(vect_analyze_data_refs): Likewise.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Add\n\tconstructor parameter for shared part.\n\t(vect_analyze_loop_form): Pass in shared part and adjust.\n\t(vect_analyze_loop_2): Pass in storage for the number of\n\tstmts.  Move loop nest finding to the caller.  Compute\n\tdatarefs lazily.\n\t(vect_analyze_loop): Pass in shared part.\n\t(vect_transform_loop): Verify shared datarefs are unchanged.\n\t* tree-vect-slp.c (_bb_vec_info::_bb_vec_info): Add\n\tconstructor parameter for shared part.\n\t(vect_slp_analyze_bb_1): Pass in shared part and adjust.\n\t(vect_slp_bb): Verify shared datarefs are unchanged before\n\ttransform.\n\t* tree-vect-stmts.c (ensure_base_align): Adjust for DR_AUX\n\tchange.\n\t(new_stmt_vec_info): Initialize DR_AUX misalignment to\n\tDR_MISALIGNMENT_UNINITIALIZED.\n\t* tree-vectorizer.c (vec_info::vec_info): Add constructor\n\tparameter for shared part.\n\t(vec_info::~vec_info): Adjust.\n\t(vec_info_shared::vec_info_shared): New.\n\t(vec_info_shared::~vec_info_shared): Likewise.\n\t(vec_info_shared::save_datarefs): Likewise.\n\t(vec_info_shared::check_datarefs): Likewise.\n\t(try_vectorize_loop_1): Construct shared part live for analyses\n\tof a single loop for multiple vector sizes.\n\t* tree-parloops.c (gather_scalar_reductions): Adjust.\n\nFrom-SVN: r262009", "tree": {"sha": "5ba2be9dfcf5d0e1a7deb28abaeace299556a695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba2be9dfcf5d0e1a7deb28abaeace299556a695"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2227a6696f136a181a208d291eb44769a7721e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2227a6696f136a181a208d291eb44769a7721e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2227a6696f136a181a208d291eb44769a7721e0"}], "stats": {"total": 329, "additions": 224, "deletions": 105}, "files": [{"sha": "0211050bd9ab9c693974bf030b41110d41f96296", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -1,3 +1,58 @@\n+2018-06-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct vec_info_shared): New structure\n+\twith parts split out from struct vec_info and loop_nest from\n+\tstruct _loop_vec_info.\n+\t(struct vec_info): Adjust accordingly.\n+\t(struct _loop_vec_info): Likewise.\n+\t(LOOP_VINFO_LOOP_NEST): Adjust.\n+\t(LOOP_VINFO_DATAREFS): Likewise.\n+\t(LOOP_VINFO_DDRS): Likewise.\n+\t(struct _bb_vec_info): Likewise.\n+\t(BB_VINFO_DATAREFS): Likewise.\n+\t(BB_VINFO_DDRS): Likewise.\n+\t(struct _stmt_vec_info): Add dr_aux member.\n+\t(DR_VECT_AUX): Adjust to refer to member of DR_STMTs vinfo.\n+\t(DR_MISALIGNMENT_UNINITIALIZED): New.\n+\t(set_dr_misalignment): Adjust.\n+\t(dr_misalignment): Assert misalign isn't DR_MISALIGNMENT_UNINITIALIZED.\n+\t(vect_analyze_loop): Adjust prototype.\n+\t(vect_analyze_loop_form): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n+\tCompute dependences lazily.\n+\t(vect_record_base_alignments): Use shared datarefs/ddrs.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t(vect_analyze_data_refs_alignment): Likewise.\n+\t(vect_analyze_data_ref_accesses): Likewise.\n+\t(vect_analyze_data_refs): Likewise.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Add\n+\tconstructor parameter for shared part.\n+\t(vect_analyze_loop_form): Pass in shared part and adjust.\n+\t(vect_analyze_loop_2): Pass in storage for the number of\n+\tstmts.  Move loop nest finding to the caller.  Compute\n+\tdatarefs lazily.\n+\t(vect_analyze_loop): Pass in shared part.\n+\t(vect_transform_loop): Verify shared datarefs are unchanged.\n+\t* tree-vect-slp.c (_bb_vec_info::_bb_vec_info): Add\n+\tconstructor parameter for shared part.\n+\t(vect_slp_analyze_bb_1): Pass in shared part and adjust.\n+\t(vect_slp_bb): Verify shared datarefs are unchanged before\n+\ttransform.\n+\t* tree-vect-stmts.c (ensure_base_align): Adjust for DR_AUX\n+\tchange.\n+\t(new_stmt_vec_info): Initialize DR_AUX misalignment to\n+\tDR_MISALIGNMENT_UNINITIALIZED.\n+\t* tree-vectorizer.c (vec_info::vec_info): Add constructor\n+\tparameter for shared part.\n+\t(vec_info::~vec_info): Adjust.\n+\t(vec_info_shared::vec_info_shared): New.\n+\t(vec_info_shared::~vec_info_shared): Likewise.\n+\t(vec_info_shared::save_datarefs): Likewise.\n+\t(vec_info_shared::check_datarefs): Likewise.\n+\t(try_vectorize_loop_1): Construct shared part live for analyses\n+\tof a single loop for multiple vector sizes.\n+\t* tree-parloops.c (gather_scalar_reductions): Adjust.\n+\n 2018-06-25  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Modify"}, {"sha": "c49f032b65515c42c7f39569ab333d7323dff866", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -2597,7 +2597,8 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n   stmt_vec_infos.create (50);\n   set_stmt_vec_info_vec (&stmt_vec_infos);\n \n-  simple_loop_info = vect_analyze_loop_form (loop);\n+  vec_info_shared shared;\n+  simple_loop_info = vect_analyze_loop_form (loop, &shared);\n   if (simple_loop_info == NULL)\n     goto gather_done;\n \n@@ -2636,7 +2637,8 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n \n   if (!double_reduc_phis.is_empty ())\n     {\n-      simple_loop_info = vect_analyze_loop_form (loop->inner);\n+      vec_info_shared shared;\n+      simple_loop_info = vect_analyze_loop_form (loop->inner, &shared);\n       if (simple_loop_info)\n \t{\n \t  gphi *phi;"}, {"sha": "9f848fefd1e7f89d491f47e72881f4d3f23978a8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -568,15 +568,20 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n \n   DUMP_VECT_SCOPE (\"vect_analyze_data_ref_dependences\");\n \n-  LOOP_VINFO_DDRS (loop_vinfo)\n-    .create (LOOP_VINFO_DATAREFS (loop_vinfo).length ()\n-\t     * LOOP_VINFO_DATAREFS (loop_vinfo).length ());\n+  if (!LOOP_VINFO_DDRS (loop_vinfo).exists ())\n+    {\n+      LOOP_VINFO_DDRS (loop_vinfo)\n+\t.create (LOOP_VINFO_DATAREFS (loop_vinfo).length ()\n+\t\t * LOOP_VINFO_DATAREFS (loop_vinfo).length ());\n+      /* We need read-read dependences to compute\n+\t STMT_VINFO_SAME_ALIGN_REFS.  */\n+      if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t    &LOOP_VINFO_DDRS (loop_vinfo),\n+\t\t\t\t    LOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n+\treturn false;\n+    }\n+\n   LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = true;\n-  /* We need read-read dependences to compute STMT_VINFO_SAME_ALIGN_REFS.  */\n-  if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t&LOOP_VINFO_DDRS (loop_vinfo),\n-\t\t\t\tLOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n-    return false;\n \n   /* For epilogues we either have no aliases or alias versioning\n      was applied to original loop.  Therefore we may just get max_vf\n@@ -833,7 +838,7 @@ vect_record_base_alignments (vec_info *vinfo)\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   data_reference *dr;\n   unsigned int i;\n-  FOR_EACH_VEC_ELT (vinfo->datarefs, i, dr)\n+  FOR_EACH_VEC_ELT (vinfo->shared->datarefs, i, dr)\n     {\n       gimple *stmt = vect_dr_stmt (dr);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1155,7 +1160,7 @@ verify_data_ref_alignment (data_reference_p dr)\n bool\n vect_verify_datarefs_alignment (loop_vec_info vinfo)\n {\n-  vec<data_reference_p> datarefs = vinfo->datarefs;\n+  vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n   struct data_reference *dr;\n   unsigned int i;\n \n@@ -2353,14 +2358,14 @@ vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n-  vec<ddr_p> ddrs = vinfo->ddrs;\n+  vec<ddr_p> ddrs = vinfo->shared->ddrs;\n   struct data_dependence_relation *ddr;\n   unsigned int i;\n \n   FOR_EACH_VEC_ELT (ddrs, i, ddr)\n     vect_find_same_alignment_drs (ddr);\n \n-  vec<data_reference_p> datarefs = vinfo->datarefs;\n+  vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n   struct data_reference *dr;\n \n   vect_record_base_alignments (vinfo);\n@@ -2914,7 +2919,7 @@ bool\n vect_analyze_data_ref_accesses (vec_info *vinfo)\n {\n   unsigned int i;\n-  vec<data_reference_p> datarefs = vinfo->datarefs;\n+  vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n   struct data_reference *dr;\n \n   DUMP_VECT_SCOPE (\"vect_analyze_data_ref_accesses\");\n@@ -4131,7 +4136,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n   /* Go through the data-refs, check that the analysis succeeded.  Update\n      pointer from stmt_vec_info struct to DR and vectype.  */\n \n-  vec<data_reference_p> datarefs = vinfo->datarefs;\n+  vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       gimple *stmt;"}, {"sha": "dacc8811636a34140ca61838a1c0bb71e53e3c96", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -803,8 +803,8 @@ bb_in_loop_p (const_basic_block bb, const void *data)\n /* Create and initialize a new loop_vec_info struct for LOOP_IN, as well as\n    stmt_vec_info structs for all the stmts in LOOP_IN.  */\n \n-_loop_vec_info::_loop_vec_info (struct loop *loop_in)\n-  : vec_info (vec_info::loop, init_cost (loop_in)),\n+_loop_vec_info::_loop_vec_info (struct loop *loop_in, vec_info_shared *shared)\n+  : vec_info (vec_info::loop, init_cost (loop_in), shared),\n     loop (loop_in),\n     bbs (XCNEWVEC (basic_block, loop->num_nodes)),\n     num_itersm1 (NULL_TREE),\n@@ -1351,7 +1351,7 @@ vect_analyze_loop_form_1 (struct loop *loop, gcond **loop_cond,\n /* Analyze LOOP form and return a loop_vec_info if it is of suitable form.  */\n \n loop_vec_info\n-vect_analyze_loop_form (struct loop *loop)\n+vect_analyze_loop_form (struct loop *loop, vec_info_shared *shared)\n {\n   tree assumptions, number_of_iterations, number_of_iterationsm1;\n   gcond *loop_cond, *inner_loop_cond = NULL;\n@@ -1361,7 +1361,7 @@ vect_analyze_loop_form (struct loop *loop)\n \t\t\t\t  &number_of_iterations, &inner_loop_cond))\n     return NULL;\n \n-  loop_vec_info loop_vinfo = new _loop_vec_info (loop);\n+  loop_vec_info loop_vinfo = new _loop_vec_info (loop, shared);\n   LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n@@ -1822,7 +1822,7 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n    for it.  The different analyses will record information in the\n    loop_vec_info struct.  */\n static bool\n-vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n+vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n {\n   bool ok;\n   int res;\n@@ -1836,29 +1836,25 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n      and analyze their evolution in the loop.  */\n \n   loop_p loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: loop nest containing two \"\n-\t\t\t \"or more consecutive inner loops cannot be \"\n-\t\t\t \"vectorized\\n\");\n-      return false;\n-    }\n \n   /* Gather the data references and count stmts in the loop.  */\n-  unsigned int n_stmts;\n-  if (!vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n-\t\t\t\t  &LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t\t\t\t  &n_stmts))\n+  if (!LOOP_VINFO_DATAREFS (loop_vinfo).exists ())\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: loop contains function \"\n-\t\t\t \"calls or data references that cannot \"\n-\t\t\t \"be analyzed\\n\");\n-      return false;\n+      if (!vect_get_datarefs_in_loop (loop, LOOP_VINFO_BBS (loop_vinfo),\n+\t\t\t\t      &LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t      n_stmts))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: loop contains function \"\n+\t\t\t     \"calls or data references that cannot \"\n+\t\t\t     \"be analyzed\\n\");\n+\t  return false;\n+\t}\n+      loop_vinfo->shared->save_datarefs ();\n     }\n+  else\n+    loop_vinfo->shared->check_datarefs ();\n \n   /* Analyze the data references and also adjust the minimal\n      vectorization factor according to the loads and stores.  */\n@@ -1947,7 +1943,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   unsigned th;\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, n_stmts);\n+  ok = vect_analyze_slp (loop_vinfo, *n_stmts);\n   if (!ok)\n     return false;\n \n@@ -2286,7 +2282,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n    loop_vec_info struct.  If ORIG_LOOP_VINFO is not NULL epilogue must\n    be vectorized.  */\n loop_vec_info\n-vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n+vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo,\n+\t\t   vec_info_shared *shared)\n {\n   loop_vec_info loop_vinfo;\n   auto_vector_sizes vector_sizes;\n@@ -2308,11 +2305,22 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n       return NULL;\n     }\n \n+  if (!find_loop_nest (loop, &shared->loop_nest))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: loop nest containing two \"\n+\t\t\t \"or more consecutive inner loops cannot be \"\n+\t\t\t \"vectorized\\n\");\n+      return NULL;\n+    }\n+\n+  unsigned n_stmts;\n   poly_uint64 autodetected_vector_size = 0;\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n-      loop_vinfo = vect_analyze_loop_form (loop);\n+      loop_vinfo = vect_analyze_loop_form (loop, shared);\n       if (!loop_vinfo)\n \t{\n \t  if (dump_enabled_p ())\n@@ -2326,7 +2334,7 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n       if (orig_loop_vinfo)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = orig_loop_vinfo;\n \n-      if (vect_analyze_loop_2 (loop_vinfo, fatal))\n+      if (vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts))\n \t{\n \t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n \n@@ -8385,6 +8393,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   DUMP_VECT_SCOPE (\"vec_transform_loop\");\n \n+  loop_vinfo->shared->check_datarefs ();\n+\n   /* Use the more conservative vectorization threshold.  If the number\n      of iterations is constant assume the cost check has been performed\n      by our caller.  If the threshold makes all loops profitable that"}, {"sha": "6739ade84cf63e7f2cd549c3cf7d290611a35574", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -2440,8 +2440,9 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n    REGION_BEGIN_IN (inclusive) and REGION_END_IN (exclusive).  */\n \n _bb_vec_info::_bb_vec_info (gimple_stmt_iterator region_begin_in,\n-\t\t\t    gimple_stmt_iterator region_end_in)\n-  : vec_info (vec_info::bb, init_cost (NULL)),\n+\t\t\t    gimple_stmt_iterator region_end_in,\n+\t\t\t    vec_info_shared *shared)\n+  : vec_info (vec_info::bb, init_cost (NULL), shared),\n     bb (gsi_bb (region_begin_in)),\n     region_begin (region_begin_in),\n     region_end (region_end_in)\n@@ -2803,7 +2804,7 @@ static bb_vec_info\n vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t       gimple_stmt_iterator region_end,\n \t\t       vec<data_reference_p> datarefs, int n_stmts,\n-\t\t       bool &fatal)\n+\t\t       bool &fatal, vec_info_shared *shared)\n {\n   bb_vec_info bb_vinfo;\n   slp_instance instance;\n@@ -2823,11 +2824,12 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  bb_vinfo = new _bb_vec_info (region_begin, region_end);\n+  bb_vinfo = new _bb_vec_info (region_begin, region_end, shared);\n   if (!bb_vinfo)\n     return NULL;\n \n   BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n+  bb_vinfo->shared->save_datarefs ();\n \n   /* Analyze the data references.  */\n \n@@ -3018,14 +3020,16 @@ vect_slp_bb (basic_block bb)\n \n       bool vectorized = false;\n       bool fatal = false;\n+      vec_info_shared shared;\n       bb_vinfo = vect_slp_analyze_bb_1 (region_begin, region_end,\n-\t\t\t\t\tdatarefs, insns, fatal);\n+\t\t\t\t\tdatarefs, insns, fatal, &shared);\n       if (bb_vinfo\n \t  && dbg_cnt (vect_slp))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB part\\n\");\n \n+\t  bb_vinfo->shared->check_datarefs ();\n \t  vect_schedule_slp (bb_vinfo);\n \n \t  unsigned HOST_WIDE_INT bytes;"}, {"sha": "07dc222b0dcedc2c5a33f072470a802d51139d0b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -6123,7 +6123,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n static void\n ensure_base_align (struct data_reference *dr)\n {\n-  if (!dr->aux)\n+  if (DR_VECT_AUX (dr)->misalignment == DR_MISALIGNMENT_UNINITIALIZED)\n     return;\n \n   if (DR_VECT_AUX (dr)->base_misaligned)\n@@ -9831,6 +9831,9 @@ new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n   res->gap = 0; /* GROUP_GAP */\n   res->same_dr_stmt = NULL; /* GROUP_SAME_DR_STMT */\n \n+  /* This is really \"uninitialized\" until vect_compute_data_ref_alignment.  */\n+  res->dr_aux.misalignment = DR_MISALIGNMENT_UNINITIALIZED;\n+\n   return res;\n }\n "}, {"sha": "41f5365a8c2b7e5dad3840ca2928b9f3849d0ef3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -450,10 +450,10 @@ shrink_simd_arrays\n /* Initialize the vec_info with kind KIND_IN and target cost data\n    TARGET_COST_DATA_IN.  */\n \n-vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in)\n+vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in,\n+\t\t    vec_info_shared *shared_)\n   : kind (kind_in),\n-    datarefs (vNULL),\n-    ddrs (vNULL),\n+    shared (shared_),\n     target_cost_data (target_cost_data_in)\n {\n   stmt_vec_infos.create (50);\n@@ -463,25 +463,50 @@ vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in)\n vec_info::~vec_info ()\n {\n   slp_instance instance;\n-  struct data_reference *dr;\n   unsigned int i;\n \n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    if (dr->aux)\n-      {\n-        free (dr->aux);\n-        dr->aux = NULL;\n-      }\n-\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     vect_free_slp_instance (instance);\n \n-  free_data_refs (datarefs);\n-  free_dependence_relations (ddrs);\n   destroy_cost_data (target_cost_data);\n   free_stmt_vec_infos (&stmt_vec_infos);\n }\n \n+vec_info_shared::vec_info_shared ()\n+  : datarefs (vNULL),\n+    datarefs_copy (vNULL),\n+    ddrs (vNULL)\n+{\n+}\n+\n+vec_info_shared::~vec_info_shared ()\n+{\n+  free_data_refs (datarefs);\n+  free_dependence_relations (ddrs);\n+  datarefs_copy.release ();\n+}\n+\n+void\n+vec_info_shared::save_datarefs ()\n+{\n+  if (!flag_checking)\n+    return;\n+  datarefs_copy.reserve_exact (datarefs.length ());\n+  for (unsigned i = 0; i < datarefs.length (); ++i)\n+    datarefs_copy.quick_push (*datarefs[i]);\n+}\n+\n+void\n+vec_info_shared::check_datarefs ()\n+{\n+  if (!flag_checking)\n+    return;\n+  gcc_assert (datarefs.length () == datarefs_copy.length ());\n+  for (unsigned i = 0; i < datarefs.length (); ++i)\n+    if (memcmp (&datarefs_copy[i], datarefs[i], sizeof (data_reference)) != 0)\n+      gcc_unreachable ();\n+}\n+\n /* A helper function to free scev and LOOP niter information, as well as\n    clear loop constraint LOOP_C_FINITE.  */\n \n@@ -669,14 +694,15 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \t\t      gimple *loop_dist_alias_call)\n {\n   unsigned ret = 0;\n+  vec_info_shared shared;\n   vect_location = find_loop_location (loop);\n   if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n       && dump_enabled_p ())\n     dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n \t\t LOCATION_FILE (vect_location),\n \t\t LOCATION_LINE (vect_location));\n \n-  loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo);\n+  loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo, &shared);\n   loop->aux = loop_vinfo;\n \n   if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))"}, {"sha": "55f8e6e440748692af962c19b3588bf12ef7a152", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca823c85882f5a0ca9779d8cd7adfcec02549d3b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ca823c85882f5a0ca9779d8cd7adfcec02549d3b", "patch": "@@ -187,33 +187,50 @@ struct vec_lower_bound {\n   poly_uint64 min_value;\n };\n \n+/* Vectorizer state shared between different analyses like vector sizes\n+   of the same CFG region.  */\n+struct vec_info_shared {\n+  vec_info_shared();\n+  ~vec_info_shared();\n+\n+  void save_datarefs();\n+  void check_datarefs();\n+\n+  /* All data references.  Freed by free_data_refs, so not an auto_vec.  */\n+  vec<data_reference_p> datarefs;\n+  vec<data_reference> datarefs_copy;\n+\n+  /* The loop nest in which the data dependences are computed.  */\n+  auto_vec<loop_p> loop_nest;\n+\n+  /* All data dependences.  Freed by free_dependence_relations, so not\n+     an auto_vec.  */\n+  vec<ddr_p> ddrs;\n+};\n+\n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n   enum vec_kind { bb, loop };\n \n-  vec_info (vec_kind, void *);\n+  vec_info (vec_kind, void *, vec_info_shared *);\n   ~vec_info ();\n \n   /* The type of vectorization.  */\n   vec_kind kind;\n \n+  /* Shared vectorizer state.  */\n+  vec_info_shared *shared;\n+\n   /* The mapping of GIMPLE UID to stmt_vec_info.  */\n   vec<struct _stmt_vec_info *> stmt_vec_infos;\n \n   /* All SLP instances.  */\n   auto_vec<slp_instance> slp_instances;\n \n-  /* All data references.  Freed by free_data_refs, so not an auto_vec.  */\n-  vec<data_reference_p> datarefs;\n-\n   /* Maps base addresses to an innermost_loop_behavior that gives the maximum\n      known alignment for that base.  */\n   vec_base_alignments base_alignments;\n \n-  /* All data dependences.  Freed by free_dependence_relations, so not\n-     an auto_vec.  */\n-  vec<ddr_p> ddrs;\n-\n   /* All interleaving chains of stores, represented by the first\n      stmt in the chain.  */\n   auto_vec<gimple *> grouped_stores;\n@@ -342,7 +359,7 @@ typedef auto_vec<rgroup_masks> vec_loop_masks;\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n typedef struct _loop_vec_info : public vec_info {\n-  _loop_vec_info (struct loop *);\n+  _loop_vec_info (struct loop *, vec_info_shared *);\n   ~_loop_vec_info ();\n \n   /* The loop to which this info struct refers to.  */\n@@ -408,9 +425,6 @@ typedef struct _loop_vec_info : public vec_info {\n   /* The mask used to check the alignment of pointers or arrays.  */\n   int ptr_mask;\n \n-  /* The loop nest in which the data dependences are computed.  */\n-  auto_vec<loop_p> loop_nest;\n-\n   /* Data Dependence Relations defining address ranges that are candidates\n      for a run-time aliasing check.  */\n   auto_vec<ddr_p> may_alias_ddrs;\n@@ -531,9 +545,9 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_MASK_SKIP_NITERS(L)     (L)->mask_skip_niters\n #define LOOP_VINFO_MASK_COMPARE_TYPE(L)    (L)->mask_compare_type\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n-#define LOOP_VINFO_LOOP_NEST(L)            (L)->loop_nest\n-#define LOOP_VINFO_DATAREFS(L)             (L)->datarefs\n-#define LOOP_VINFO_DDRS(L)                 (L)->ddrs\n+#define LOOP_VINFO_LOOP_NEST(L)            (L)->shared->loop_nest\n+#define LOOP_VINFO_DATAREFS(L)             (L)->shared->datarefs\n+#define LOOP_VINFO_DDRS(L)                 (L)->shared->ddrs\n #define LOOP_VINFO_INT_NITERS(L)           (TREE_INT_CST_LOW ((L)->num_iters))\n #define LOOP_VINFO_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L)         (L)->unaligned_dr\n@@ -596,7 +610,7 @@ nested_in_vect_loop_p (struct loop *loop, gimple *stmt)\n \n typedef struct _bb_vec_info : public vec_info\n {\n-  _bb_vec_info (gimple_stmt_iterator, gimple_stmt_iterator);\n+  _bb_vec_info (gimple_stmt_iterator, gimple_stmt_iterator, vec_info_shared *);\n   ~_bb_vec_info ();\n \n   basic_block bb;\n@@ -607,8 +621,8 @@ typedef struct _bb_vec_info : public vec_info\n #define BB_VINFO_BB(B)               (B)->bb\n #define BB_VINFO_GROUPED_STORES(B)   (B)->grouped_stores\n #define BB_VINFO_SLP_INSTANCES(B)    (B)->slp_instances\n-#define BB_VINFO_DATAREFS(B)         (B)->datarefs\n-#define BB_VINFO_DDRS(B)             (B)->ddrs\n+#define BB_VINFO_DATAREFS(B)         (B)->shared->datarefs\n+#define BB_VINFO_DDRS(B)             (B)->shared->ddrs\n #define BB_VINFO_TARGET_COST_DATA(B) (B)->target_cost_data\n \n static inline bb_vec_info\n@@ -734,6 +748,17 @@ enum vect_memory_access_type {\n   VMAT_GATHER_SCATTER\n };\n \n+struct dataref_aux {\n+  /* The misalignment in bytes of the reference, or -1 if not known.  */\n+  int misalignment;\n+  /* The byte alignment that we'd ideally like the reference to have,\n+     and the value that misalignment is measured against.  */\n+  int target_alignment;\n+  /* If true the alignment of base_decl needs to be increased.  */\n+  bool base_misaligned;\n+  tree base_decl;\n+};\n+\n typedef struct data_reference *dr_p;\n \n typedef struct _stmt_vec_info {\n@@ -772,6 +797,8 @@ typedef struct _stmt_vec_info {\n      relative to the inner-most containing loop.  */\n   struct data_reference *data_ref_info;\n \n+  dataref_aux dr_aux;\n+\n   /* Information about the data-ref relative to this loop\n      nest (the loop that is being considered for vectorization).  */\n   innermost_loop_behavior dr_wrt_vec_loop;\n@@ -981,18 +1008,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n-struct dataref_aux {\n-  /* The misalignment in bytes of the reference, or -1 if not known.  */\n-  int misalignment;\n-  /* The byte alignment that we'd ideally like the reference to have,\n-     and the value that misalignment is measured against.  */\n-  int target_alignment;\n-  /* If true the alignment of base_decl needs to be increased.  */\n-  bool base_misaligned;\n-  tree base_decl;\n-};\n-\n-#define DR_VECT_AUX(dr) ((dataref_aux *)(dr)->aux)\n+#define DR_VECT_AUX(dr) (&vinfo_for_stmt (DR_STMT (dr))->dr_aux)\n \n #define VECT_MAX_COST 1000\n \n@@ -1230,31 +1246,28 @@ add_stmt_costs (void *data, stmt_vector_for_cost *cost_vec)\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n+#define DR_MISALIGNMENT_UNKNOWN (-1)\n+#define DR_MISALIGNMENT_UNINITIALIZED (-2)\n+\n inline void\n set_dr_misalignment (struct data_reference *dr, int val)\n {\n   dataref_aux *data_aux = DR_VECT_AUX (dr);\n-\n-  if (!data_aux)\n-    {\n-      data_aux = XCNEW (dataref_aux);\n-      dr->aux = data_aux;\n-    }\n-\n   data_aux->misalignment = val;\n }\n \n inline int\n dr_misalignment (struct data_reference *dr)\n {\n-  return DR_VECT_AUX (dr)->misalignment;\n+  int misalign = DR_VECT_AUX (dr)->misalignment;\n+  gcc_assert (misalign != DR_MISALIGNMENT_UNINITIALIZED);\n+  return misalign;\n }\n \n /* Reflects actual alignment of first access in the vectorized loop,\n    taking into account peeling/versioning if applied.  */\n #define DR_MISALIGNMENT(DR) dr_misalignment (DR)\n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n-#define DR_MISALIGNMENT_UNKNOWN (-1)\n \n /* Only defined once DR_MISALIGNMENT is defined.  */\n #define DR_TARGET_ALIGNMENT(DR) DR_VECT_AUX (DR)->target_alignment\n@@ -1572,7 +1585,8 @@ extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *,\n extern bool check_reduction_path (location_t, loop_p, gphi *, tree,\n \t\t\t\t  enum tree_code);\n /* Drive for loop analysis stage.  */\n-extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n+extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info,\n+\t\t\t\t\tvec_info_shared *);\n extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);\n extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *,\n \t\t\t\t\t tree *, bool);\n@@ -1585,7 +1599,7 @@ extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n \n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);\n-extern loop_vec_info vect_analyze_loop_form (struct loop *);\n+extern loop_vec_info vect_analyze_loop_form (struct loop *, vec_info_shared *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, gimple **,\n \t\t\t\t\t stmt_vector_for_cost *);"}]}