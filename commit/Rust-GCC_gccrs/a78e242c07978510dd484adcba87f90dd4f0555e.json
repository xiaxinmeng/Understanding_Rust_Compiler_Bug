{"sha": "a78e242c07978510dd484adcba87f90dd4f0555e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4ZTI0MmMwNzk3ODUxMGRkNDg0YWRjYmE4N2Y5MGRkNGYwNTU1ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-27T15:20:14Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-27T15:20:14Z"}, "message": "postreload.c (try_replace_in_use): New static function.\n\n\t* postreload.c (try_replace_in_use): New static function.\n\t(reload_combine_recognize_const_pattern): Use it here.  Allow\n\tsubstituting into a final add insn, and substituting into a memory\n\treference in an insn that sets the reg.\n\nFrom-SVN: r162573", "tree": {"sha": "84746048bc8fb1990194b86d153cea947400830d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84746048bc8fb1990194b86d153cea947400830d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a78e242c07978510dd484adcba87f90dd4f0555e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78e242c07978510dd484adcba87f90dd4f0555e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78e242c07978510dd484adcba87f90dd4f0555e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78e242c07978510dd484adcba87f90dd4f0555e/comments", "author": null, "committer": null, "parents": [{"sha": "61ff2bdc6c2bc3f08a5e45aeb57e48ec21604e0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ff2bdc6c2bc3f08a5e45aeb57e48ec21604e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ff2bdc6c2bc3f08a5e45aeb57e48ec21604e0a"}], "stats": {"total": 157, "additions": 87, "deletions": 70}, "files": [{"sha": "3ca65bb0d5e599fd388e3a733f982ff41b322134", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78e242c07978510dd484adcba87f90dd4f0555e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78e242c07978510dd484adcba87f90dd4f0555e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a78e242c07978510dd484adcba87f90dd4f0555e", "patch": "@@ -1,3 +1,10 @@\n+2010-07-27  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* postreload.c (try_replace_in_use): New static function.\n+\t(reload_combine_recognize_const_pattern): Use it here.  Allow\n+\tsubstituting into a final add insn, and substituting into a memory\n+\treference in an insn that sets the reg.\n+\n 2010-07-27  Joseph Myers  <joseph@codesourcery.com>\n \n \t* common.opt (o): Add MissingArgError."}, {"sha": "093dce717b0d6cb028eb79ebec6c931e3e339236", "filename": "gcc/postreload.c", "status": "modified", "additions": 80, "deletions": 70, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78e242c07978510dd484adcba87f90dd4f0555e/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78e242c07978510dd484adcba87f90dd4f0555e/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=a78e242c07978510dd484adcba87f90dd4f0555e", "patch": "@@ -871,6 +871,61 @@ fixup_debug_insns (rtx reg, rtx replacement, rtx from, rtx to)\n     }\n }\n \n+/* Subroutine of reload_combine_recognize_const_pattern.  Try to replace REG\n+   with SRC in the insn described by USE, taking costs into account.  Return\n+   true if we made the replacement.  */\n+\n+static bool\n+try_replace_in_use (struct reg_use *use, rtx reg, rtx src)\n+{\n+  rtx use_insn = use->insn;\n+  rtx mem = use->containing_mem;\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n+\n+  if (mem != NULL_RTX)\n+    {\n+      addr_space_t as = MEM_ADDR_SPACE (mem);\n+      rtx oldaddr = XEXP (mem, 0);\n+      rtx newaddr = NULL_RTX;\n+      int old_cost = address_cost (oldaddr, GET_MODE (mem), as, speed);\n+      int new_cost;\n+\n+      newaddr = simplify_replace_rtx (oldaddr, reg, src);\n+      if (memory_address_addr_space_p (GET_MODE (mem), newaddr, as))\n+\t{\n+\t  XEXP (mem, 0) = newaddr;\n+\t  new_cost = address_cost (newaddr, GET_MODE (mem), as, speed);\n+\t  XEXP (mem, 0) = oldaddr;\n+\t  if (new_cost <= old_cost\n+\t      && validate_change (use_insn,\n+\t\t\t\t  &XEXP (mem, 0), newaddr, 0))\n+\t    return true;\n+\t}\n+    }\n+  else\n+    {\n+      rtx new_set = single_set (use_insn);\n+      if (new_set\n+\t  && REG_P (SET_DEST (new_set))\n+\t  && GET_CODE (SET_SRC (new_set)) == PLUS\n+\t  && REG_P (XEXP (SET_SRC (new_set), 0))\n+\t  && CONSTANT_P (XEXP (SET_SRC (new_set), 1)))\n+\t{\n+\t  rtx new_src;\n+\t  int old_cost = rtx_cost (SET_SRC (new_set), SET, speed);\n+\n+\t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n+\t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg, src);\n+\n+\t  if (rtx_cost (new_src, SET, speed) <= old_cost\n+\t      && validate_change (use_insn, &SET_SRC (new_set),\n+\t\t\t\t  new_src, 0))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Called by reload_combine when scanning INSN.  This function tries to detect\n    patterns where a constant is added to a register, and the result is used\n    in an address.\n@@ -940,10 +995,9 @@ reload_combine_recognize_const_pattern (rtx insn)\n \n       if (use && GET_MODE (*use->usep) == Pmode)\n \t{\n+\t  bool delete_add = false;\n \t  rtx use_insn = use->insn;\n \t  int use_ruid = use->ruid;\n-\t  rtx mem = use->containing_mem;\n-\t  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n \n \t  /* Avoid moving the add insn past a jump.  */\n \t  if (must_move_add && use_ruid <= last_jump_ruid)\n@@ -957,81 +1011,37 @@ reload_combine_recognize_const_pattern (rtx insn)\n \n \t  gcc_assert (reg_state[regno].store_ruid <= use_ruid);\n \t  /* Avoid moving a use of ADDREG past a point where it is stored.  */\n-\t  if (reg_state[REGNO (addreg)].store_ruid >= use_ruid)\n+\t  if (reg_state[REGNO (addreg)].store_ruid > use_ruid)\n \t    break;\n \n-\t  if (mem != NULL_RTX)\n+\t  /* We also must not move the addition past an insn that sets\n+\t     the same register, unless we can combine two add insns.  */\n+\t  if (must_move_add && reg_state[regno].store_ruid == use_ruid)\n \t    {\n-\t      addr_space_t as = MEM_ADDR_SPACE (mem);\n-\t      rtx oldaddr = XEXP (mem, 0);\n-\t      rtx newaddr = NULL_RTX;\n-\t      int old_cost = address_cost (oldaddr, GET_MODE (mem), as, speed);\n-\t      int new_cost;\n-\n-\t      newaddr = simplify_replace_rtx (oldaddr, reg, src);\n-\t      if (memory_address_addr_space_p (GET_MODE (mem), newaddr, as))\n-\t\t{\n-\t\t  XEXP (mem, 0) = newaddr;\n-\t\t  new_cost = address_cost (newaddr, GET_MODE (mem), as, speed);\n-\t\t  XEXP (mem, 0) = oldaddr;\n-\t\t  if (new_cost <= old_cost\n-\t\t      && validate_change (use_insn,\n-\t\t\t\t\t  &XEXP (mem, 0), newaddr, 0))\n-\t\t    {\n-\t\t      reload_combine_purge_insn_uses (use_insn);\n-\t\t      reload_combine_note_use (&PATTERN (use_insn), use_insn,\n-\t\t\t\t\t       use_ruid, NULL_RTX);\n-\n-\t\t      if (must_move_add)\n-\t\t\t{\n-\t\t\t  add_moved_after_insn = use_insn;\n-\t\t\t  add_moved_after_ruid = use_ruid;\n-\t\t\t}\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n+\t      if (use->containing_mem == NULL_RTX)\n+\t\tdelete_add = true;\n+\t      else\n+\t\tbreak;\n \t    }\n-\t  else\n-\t    {\n-\t      rtx new_set = single_set (use_insn);\n-\t      if (new_set\n-\t\t  && REG_P (SET_DEST (new_set))\n-\t\t  && GET_CODE (SET_SRC (new_set)) == PLUS\n-\t\t  && REG_P (XEXP (SET_SRC (new_set), 0))\n-\t\t  && CONSTANT_P (XEXP (SET_SRC (new_set), 1)))\n-\t\t{\n-\t\t  rtx new_src;\n-\t\t  int old_cost = rtx_cost (SET_SRC (new_set), SET, speed);\n-\n-\t\t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n-\t\t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg, src);\n \n-\t\t  if (rtx_cost (new_src, SET, speed) <= old_cost\n-\t\t      && validate_change (use_insn, &SET_SRC (new_set),\n-\t\t\t\t\t  new_src, 0))\n-\t\t    {\n-\t\t      reload_combine_purge_insn_uses (use_insn);\n-\t\t      reload_combine_note_use (&SET_SRC (new_set), use_insn,\n-\t\t\t\t\t       use_ruid, NULL_RTX);\n+\t  if (try_replace_in_use (use, reg, src))\n+\t    {\n+\t      reload_combine_purge_insn_uses (use_insn);\n+\t      reload_combine_note_use (&PATTERN (use_insn), use_insn,\n+\t\t\t\t       use_ruid, NULL_RTX);\n \n-\t\t      if (must_move_add)\n-\t\t\t{\n-\t\t\t  /* See if that took care of the add insn.  */\n-\t\t\t  if (rtx_equal_p (SET_DEST (new_set), reg))\n-\t\t\t    {\n-\t\t\t      fixup_debug_insns (reg, src, insn, use_insn);\n-\t\t\t      delete_insn (insn);\n-\t\t\t      return true;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      add_moved_after_insn = use_insn;\n-\t\t\t      add_moved_after_ruid = use_ruid;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      continue;\n-\t\t    }\n+\t      if (delete_add)\n+\t\t{\n+\t\t  fixup_debug_insns (reg, src, insn, use_insn);\n+\t\t  delete_insn (insn);\n+\t\t  return true;\n \t\t}\n+\t      if (must_move_add)\n+\t\t{\n+\t\t  add_moved_after_insn = use_insn;\n+\t\t  add_moved_after_ruid = use_ruid;\n+\t\t}\n+\t      continue;\n \t    }\n \t}\n       /* If we get here, we couldn't handle this use.  */"}]}