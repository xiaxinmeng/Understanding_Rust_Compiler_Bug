{"sha": "5f24901c296f7f44acddd2f4ea0556ef9df55bf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyNDkwMWMyOTZmN2Y0NGFjZGRkMmY0ZWEwNTU2ZWY5ZGY1NWJmNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T11:41:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T11:41:09Z"}, "message": "(adddi3, subdi3): Allow constant operand.\n\n(anddi3, iordi3, xordi3): New patterns.\n({and,ior,xor}si3_internal): Use corresponding output_???si3 function.\n\nFrom-SVN: r14430", "tree": {"sha": "7edf7920e6a7c37ad6d6796ab15c4a066e244864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7edf7920e6a7c37ad6d6796ab15c4a066e244864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f24901c296f7f44acddd2f4ea0556ef9df55bf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f24901c296f7f44acddd2f4ea0556ef9df55bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f24901c296f7f44acddd2f4ea0556ef9df55bf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f24901c296f7f44acddd2f4ea0556ef9df55bf5/comments", "author": null, "committer": null, "parents": [{"sha": "6b40374366298bd0a3419d0d43a002cd9b449b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b40374366298bd0a3419d0d43a002cd9b449b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b40374366298bd0a3419d0d43a002cd9b449b41"}], "stats": {"total": 357, "additions": 271, "deletions": 86}, "files": [{"sha": "40e59a0532af0e9b7c7b21bbbd341789af1ca9fa", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 271, "deletions": 86, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f24901c296f7f44acddd2f4ea0556ef9df55bf5/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f24901c296f7f44acddd2f4ea0556ef9df55bf5/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=5f24901c296f7f44acddd2f4ea0556ef9df55bf5", "patch": "@@ -2039,7 +2039,7 @@\n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=<,o<>,d,d,d\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"<,d,o>,d,a\")))\n+\t\t (match_operand:DI 2 \"general_operand\" \"<,d,no>,d,a\")))\n    (clobber (match_scratch:SI 3 \"=X,&d,&d,X,&d\"))]\n   \"\"\n   \"*\n@@ -2055,11 +2055,21 @@\n \t}\n       else\n \t{\n-\t  /* TODO : this should work also for CONST operands[2] */\n \t  if (GET_CODE (operands[2]) == REG)\n \t    operands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+\t  else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+\t    {\n+\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n+\t      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t    }\n+\t  else if (GET_CODE (operands[2]) == CONST_INT)\n+\t    {\n+\t      operands[1] = operands[2];\n+\t      operands[2] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+\t    }\n \t  else\n \t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\t  /* TODO : for consts, optimize move and add */\n \t  return \\\"move%.l %2,%3\\;add%.l %1,%R0\\;addx%.l %3,%0\\\";\n \t}\n     }\n@@ -2573,7 +2583,7 @@\n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=<,o<>,d,d,d\")\n \t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0,0\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"<,d,o>,d,a\")))\n+\t\t (match_operand:DI 2 \"general_operand\" \"<,d,no>,d,a\")))\n    (clobber (match_scratch:SI 3 \"=X,&d,&d,X,&d\"))]\n   \"\"\n   \"*\n@@ -2589,11 +2599,21 @@\n \t}\n       else\n \t{\n-\t  /* TODO : this should work also for CONST operands[2] */\n \t  if (GET_CODE (operands[2]) == REG)\n \t    operands[1] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+\t  else if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+\t    {\n+\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n+\t      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t    }\n+\t  else if (GET_CODE (operands[2]) == CONST_INT)\n+\t    {\n+\t      operands[1] = operands[2];\n+\t      operands[2] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+\t    }\n \t  else\n \t    operands[1] = adj_offsettable_operand (operands[2], 4);\n+\t  /* TODO : for consts, optimize move and sub */\n \t  return \\\"move%.l %2,%3\\;sub%.l %1,%R0\\;subx%.l %3,%0\\\";\n \t}\n     }\n@@ -3378,9 +3398,9 @@\n   \"*\n {\n #ifdef MOTOROLA\n-  output_asm_insn(\\\"ext%.l %0\\;divs%.w %2,%0\\\", operands);\n+  output_asm_insn (\\\"ext%.l %0\\;divs%.w %2,%0\\\", operands);\n #else\n-  output_asm_insn(\\\"extl %0\\;divs %2,%0\\\", operands);\n+  output_asm_insn (\\\"extl %0\\;divs %2,%0\\\", operands);\n #endif\n   if (!find_reg_note(insn, REG_UNUSED, operands[3]))\n     {\n@@ -3401,9 +3421,9 @@\n   \"*\n {\n #ifdef MOTOROLA\n-  output_asm_insn(\\\"and%.l %#0xFFFF,%0\\;divu%.w %2,%0\\\", operands);\n+  output_asm_insn (\\\"and%.l %#0xFFFF,%0\\;divu%.w %2,%0\\\", operands);\n #else\n-  output_asm_insn(\\\"and%.l %#0xFFFF,%0\\;divu %2,%0\\\", operands);\n+  output_asm_insn (\\\"and%.l %#0xFFFF,%0\\;divu %2,%0\\\", operands);\n #endif\n   if (!find_reg_note(insn, REG_UNUSED, operands[3]))\n     {\n@@ -3416,6 +3436,82 @@\n \f\n ;; logical-and instructions\n \n+;; \"anddi3\" is mainly here to help combine().\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,d\")\n+\t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n+  if (GET_CODE (operands[2]) == CONST_DOUBLE\n+     || GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx hi, lo;\n+\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+\t{\n+\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n+\t}\n+      else\n+\t{\n+\t  lo = operands[2];\n+\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n+\t}\n+      switch (INTVAL (hi))\n+\t{\n+\t  case 0 :\n+\t    output_asm_insn (\\\"clr%.l %0\\\", operands);\n+\t    break;\n+\t  case -1 :\n+\t    break;\n+\t  default :\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = hi;\n+\t    output_asm_insn (output_andsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      if (GET_CODE (operands[0]) == REG)\n+\toperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      else\n+\toperands[0] = adj_offsettable_operand (operands[0], 4);\n+      switch (INTVAL (lo))\n+\t{\n+\t  case 0 :\n+\t    output_asm_insn (\\\"clr%.l %0\\\", operands);\n+\t    break;\n+\t  case -1 :\n+\t    break;\n+\t  default :\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = lo;\n+\t    output_asm_insn (output_andsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      return \\\"\\\";\n+    }\n+  if (GET_CODE (operands[0]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      return \\\"and%.l %2,%0\\;and%.l %R2,%1\\\";\n+    }\n+  if (GET_CODE (operands[2]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[2], 4);\n+      return \\\"and%.l %2,%0\\;and%.l %1,%R0\\\";\n+    }\n+  return \\\"and%.l %2,%0\\;and%.l %R2,%R0\\\";\n+}\")\n+\n ;; Prevent AND from being made with sp.  This doesn't exist in the machine\n ;; and reload will cause inefficient code.  Since sp is a FIXED_REG, we\n ;; can't allocate pseudos into it.\n@@ -3434,41 +3530,7 @@\n   \"!TARGET_5200\"\n   \"*\n {\n-  int logval;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t     INTVAL (operands[2]) & 0xffff);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      if (operands[2] == const0_rtx)\n-        return \\\"clr%.w %0\\\";\n-      return \\\"and%.w %2,%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (logval = exact_log2 (~ INTVAL (operands[2]))) >= 0\n-      && (DATA_REG_P (operands[0])\n-          || offsettable_memref_p (operands[0])))\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        {\n-          operands[1] = gen_rtx (CONST_INT, VOIDmode, logval);\n-        }\n-      else\n-        {\n-\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, logval % 8);\n-        }\n-      /* This does not set condition codes in a standard way.  */\n-      CC_STATUS_INIT;\n-      return \\\"bclr %1,%0\\\";\n-    }\n-  return \\\"and%.l %2,%0\\\";\n+  return output_andsi3 (operands);\n }\")\n \n (define_insn \"andsi3_5200\"\n@@ -3522,6 +3584,86 @@\n \f\n ;; inclusive-or instructions\n \n+;; \"iordi3\" is mainly here to help combine().\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,d\")\n+\t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n+  \"!TARGET_5200\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n+  if (GET_CODE (operands[2]) == CONST_DOUBLE\n+     || GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx hi, lo;\n+\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+\t{\n+\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n+\t}\n+      else\n+\t{\n+\t  lo = operands[2];\n+\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n+\t}\n+      switch (INTVAL (hi))\n+\t{\n+\t  case 0 :\n+\t    break;\n+\t  case -1 :\n+\t    /* FIXME : a scratch register would be welcome here if operand[0]\n+\t       is not a register */\n+\t    output_asm_insn (\\\"move%.l %#-1,%0\\\", operands);\n+\t    break;\n+\t  default :\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = hi;\n+\t    output_asm_insn (output_iorsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      if (GET_CODE (operands[0]) == REG)\n+\toperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      else\n+\toperands[0] = adj_offsettable_operand (operands[0], 4);\n+      switch (INTVAL (lo))\n+\t{\n+\t  case 0 :\n+\t    break;\n+\t  case -1 :\n+\t    /* FIXME : a scratch register would be welcome here if operand[0]\n+\t       is not a register */\n+\t    output_asm_insn (\\\"move%.l %#-1,%R0\\\", operands);\n+\t    break;\n+\t  default :\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = lo;\n+\t    output_asm_insn (output_iorsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      return \\\"\\\";\n+    }\n+  if (GET_CODE (operands[0]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      return \\\"or%.l %2,%0\\;or%.l %R2,%1\\\";\n+    }\n+  if (GET_CODE (operands[2]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[2], 4);\n+      return \\\"or%.l %2,%0\\;or%.l %1,%R0\\\";\n+    }\n+  return \\\"or%.l %2,%0\\;or%.l %R2,%R0\\\";\n+}\")\n+\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"\")\n@@ -3533,39 +3675,10 @@\n   [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmMs\")))]\n-  \"!TARGET_5200\"\n+  \"\"\n   \"*\n {\n-  register int logval;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"or%.w %2,%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    {\n-      if (DATA_REG_P (operands[0]))\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, logval);\n-\t}\n-      else\n-        {\n-\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, logval % 8);\n-\t}\n-      CC_STATUS_INIT;\n-      return \\\"bset %1,%0\\\";\n-    }\n-  return \\\"or%.l %2,%0\\\";\n+  return output_iorsi3 (operands);\n }\")\n \n (define_insn \"iorsi3_5200\"\n@@ -3658,6 +3771,88 @@\n \f\n ;; xor instructions\n \n+;; \"xordi3\" is mainly here to help combine().\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=od\")\n+\t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"dn\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  /* We can get CONST_DOUBLE, but also const1_rtx etc. */\n+  if (GET_CODE (operands[2]) == CONST_DOUBLE\n+     || GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx hi, lo;\n+\n+      if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+\t{\n+\t  hi = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n+\t  lo = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n+\t}\n+      else\n+\t{\n+\t  lo = operands[2];\n+\t  hi = INTVAL (lo) < 0 ? constm1_rtx : const0_rtx;\n+\t}\n+      switch (INTVAL (hi))\n+\t{\n+\t  case 0 :\n+\t    break;\n+\t  case -1 :\n+\t    output_asm_insn (\\\"not%.l %0\\\", operands);\n+\t    break;\n+\t  default :\n+\t    /* FIXME : a scratch register would be welcome here if\n+\t       -128 <= INTVAL (hi) < -1 */\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = hi;\n+\t    output_asm_insn (output_xorsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      if (GET_CODE (operands[0]) == REG)\n+\toperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      else\n+\toperands[0] = adj_offsettable_operand (operands[0], 4);\n+      switch (INTVAL (lo))\n+\t{\n+\t  case 0 :\n+\t    break;\n+\t  case -1 :\n+\t    output_asm_insn (\\\"not%.l %0\\\", operands);\n+\t    break;\n+\t  default :\n+\t    /* FIXME : a scratch register would be welcome here if\n+\t       -128 <= INTVAL (lo) < -1 */\n+\t    operands[2] = lo;\n+\t    /* FIXME : this should be merged with xorsi3 */\n+\t    {\n+\t    rtx xoperands[3];\n+\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[2] = lo;\n+\t    output_asm_insn (output_xorsi3 (xoperands), xoperands);\n+\t    }\n+\t}\n+      return \\\"\\\";\n+    }\n+  if (GET_CODE (operands[0]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      return \\\"eor%.l %2,%0\\;eor%.l %R2,%1\\\";\n+    }\n+  if (GET_CODE (operands[2]) != REG)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[2], 4);\n+      return \\\"eor%.l %2,%0\\;eor%.l %1,%R0\\\";\n+    }\n+  return \\\"eor%.l %2,%0\\;eor%.l %R2,%R0\\\";\n+}\")\n+\n (define_expand \"xorsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"\")\n@@ -3672,17 +3867,7 @@\n   \"!TARGET_5200\"\n   \"*\n {\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0])))\n-    {\n-      if (! DATA_REG_P (operands[0]))\n-\toperands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"eor%.w %2,%0\\\";\n-    }\n-  return \\\"eor%.l %2,%0\\\";\n+  return output_xorsi3 (operands);\n }\")\n \n (define_insn \"xorsi3_5200\"\n@@ -4059,7 +4244,7 @@\n \f\n ;; one complement instructions\n \n-;; \"one_cmpldi2\" is only here to help combine().\n+;; \"one_cmpldi2\" is mainly here to help combine().\n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=dm\")\n \t(not:DI (match_operand:DI 1 \"general_operand\" \"0\")))]"}]}