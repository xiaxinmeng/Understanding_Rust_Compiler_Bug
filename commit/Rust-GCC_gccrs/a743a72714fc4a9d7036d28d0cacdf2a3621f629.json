{"sha": "a743a72714fc4a9d7036d28d0cacdf2a3621f629", "node_id": "C_kwDOANBUbNoAKGE3NDNhNzI3MTRmYzRhOWQ3MDM2ZDI4ZDBjYWNkZjJhMzYyMWY2Mjk", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2022-05-18T20:00:47Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2022-06-01T21:23:26Z"}, "message": "DSE: Use the constant store source if possible\n\nRTL DSE tracks redundant constant stores within a basic block.  When RTL\nloop invariant motion hoists a constant initialization out of the loop\ninto a separate basic block, the constant store value becomes unknown\nwithin the original basic block.  When recording store for RTL DSE, check\nif the source register is set only once to a constant by a non-partial\nunconditional load.  If yes, record the constant as the constant store\nsource.  It eliminates unrolled zero stores after memset 0 in a loop\nwhere a vector register is used as the zero store source.\n\ngcc/\n\n\tPR rtl-optimization/105638\n\t* df-core.cc (df_find_single_def_src): Moved and renamed from\n\tfind_single_def_src in loop-iv.cc.  Change the argument to rtx\n\tand use rtx_equal_p.  Return null for partial or conditional\n\tdefs.\n\t* df.h (df_find_single_def_src): New prototype.\n\t* dse.cc (record_store): Use the constant source if the source\n\tregister is set only once.\n\t* loop-iv.cc (find_single_def_src): Moved to df-core.cc.\n\t(replace_single_def_regs): Replace find_single_def_src with\n\tdf_find_single_def_src.\n\ngcc/testsuite/\n\n\tPR rtl-optimization/105638\n\t* g++.target/i386/pr105638.C: New test.", "tree": {"sha": "4a2da93e3ac20ae6f5be420e5792cc84a6f2f3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a2da93e3ac20ae6f5be420e5792cc84a6f2f3ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a743a72714fc4a9d7036d28d0cacdf2a3621f629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a743a72714fc4a9d7036d28d0cacdf2a3621f629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a743a72714fc4a9d7036d28d0cacdf2a3621f629", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a743a72714fc4a9d7036d28d0cacdf2a3621f629/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e471d83d16449a325315c0f33dc52b90ce0fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e471d83d16449a325315c0f33dc52b90ce0fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2e471d83d16449a325315c0f33dc52b90ce0fac"}], "stats": {"total": 139, "additions": 95, "deletions": 44}, "files": [{"sha": "e3a56bf6a9ff6ef942908c7db3620060d4d26831", "filename": "gcc/df-core.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdf-core.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdf-core.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.cc?ref=a743a72714fc4a9d7036d28d0cacdf2a3621f629", "patch": "@@ -2009,6 +2009,47 @@ df_reg_used (rtx_insn *insn, rtx reg)\n   return df_find_use (insn, reg) != NULL;\n }\n \n+/* If REG has a single definition, return its known value, otherwise return\n+   null.  */\n+\n+rtx\n+df_find_single_def_src (rtx reg)\n+{\n+  rtx src = NULL_RTX;\n+\n+  /* Don't look through unbounded number of single definition REG copies,\n+     there might be loops for sources with uninitialized variables.  */\n+  for (int cnt = 0; cnt < 128; cnt++)\n+    {\n+      df_ref adef = DF_REG_DEF_CHAIN (REGNO (reg));\n+      if (adef == NULL || DF_REF_NEXT_REG (adef) != NULL\n+\t  || DF_REF_IS_ARTIFICIAL (adef)\n+\t  || (DF_REF_FLAGS (adef)\n+\t      & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\treturn NULL_RTX;\n+\n+      rtx set = single_set (DF_REF_INSN (adef));\n+      if (set == NULL || !rtx_equal_p (SET_DEST (set), reg))\n+\treturn NULL_RTX;\n+\n+      rtx note = find_reg_equal_equiv_note (DF_REF_INSN (adef));\n+      if (note && function_invariant_p (XEXP (note, 0)))\n+\treturn XEXP (note, 0);\n+      src = SET_SRC (set);\n+\n+      if (REG_P (src))\n+\t{\n+\t  reg = src;\n+\t  continue;\n+\t}\n+      break;\n+    }\n+  if (!function_invariant_p (src))\n+    return NULL_RTX;\n+\n+  return src;\n+}\n+\n \f\n /*----------------------------------------------------------------------------\n    Debugging and printing functions."}, {"sha": "71e249ad20a5b6db2a92d9eddbba58d28230b893", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=a743a72714fc4a9d7036d28d0cacdf2a3621f629", "patch": "@@ -991,6 +991,7 @@ extern df_ref df_find_def (rtx_insn *, rtx);\n extern bool df_reg_defined (rtx_insn *, rtx);\n extern df_ref df_find_use (rtx_insn *, rtx);\n extern bool df_reg_used (rtx_insn *, rtx);\n+extern rtx df_find_single_def_src (rtx);\n extern void df_worklist_dataflow (struct dataflow *,bitmap, int *, int);\n extern void df_print_regset (FILE *file, const_bitmap r);\n extern void df_print_word_regset (FILE *file, const_bitmap r);"}, {"sha": "994c60dc189774d01191aea6b0b4ca67394c74d3", "filename": "gcc/dse.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Fdse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.cc?ref=a743a72714fc4a9d7036d28d0cacdf2a3621f629", "patch": "@@ -1508,6 +1508,14 @@ record_store (rtx body, bb_info_t bb_info)\n \n \t  if (tem && CONSTANT_P (tem))\n \t    const_rhs = tem;\n+\t  else\n+\t    {\n+\t      /* If RHS is set only once to a constant, set CONST_RHS\n+\t\t to the constant.  */\n+\t      rtx def_src = df_find_single_def_src (rhs);\n+\t      if (def_src != nullptr && CONSTANT_P (def_src))\n+\t\tconst_rhs = def_src;\n+\t    }\n \t}\n     }\n "}, {"sha": "d639336445a4e9304e514d2893c3a950564c009f", "filename": "gcc/loop-iv.cc", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Floop-iv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Floop-iv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.cc?ref=a743a72714fc4a9d7036d28d0cacdf2a3621f629", "patch": "@@ -1378,49 +1378,6 @@ simple_rhs_p (rtx rhs)\n     }\n }\n \n-/* If REGNO has a single definition, return its known value, otherwise return\n-   null.  */\n-\n-static rtx\n-find_single_def_src (unsigned int regno)\n-{\n-  rtx src = NULL_RTX;\n-\n-  /* Don't look through unbounded number of single definition REG copies,\n-     there might be loops for sources with uninitialized variables.  */\n-  for (int cnt = 0; cnt < 128; cnt++)\n-    {\n-      df_ref adef = DF_REG_DEF_CHAIN (regno);\n-      if (adef == NULL || DF_REF_NEXT_REG (adef) != NULL\n-\t  || DF_REF_IS_ARTIFICIAL (adef))\n-\treturn NULL_RTX;\n-\n-      rtx set = single_set (DF_REF_INSN (adef));\n-      if (set == NULL || !REG_P (SET_DEST (set))\n-\t  || REGNO (SET_DEST (set)) != regno)\n-\treturn NULL_RTX;\n-\n-      rtx note = find_reg_equal_equiv_note (DF_REF_INSN (adef));\n-      if (note && function_invariant_p (XEXP (note, 0)))\n-\t{\n-\t  src = XEXP (note, 0);\n-\t  break;\n-\t}\n-      src = SET_SRC (set);\n-\n-      if (REG_P (src))\n-\t{\n-\t  regno = REGNO (src);\n-\t  continue;\n-\t}\n-      break;\n-    }\n-  if (!function_invariant_p (src))\n-    return NULL_RTX;\n-\n-  return src;\n-}\n-\n /* If any registers in *EXPR that have a single definition, try to replace\n    them with the known-equivalent values.  */\n \n@@ -1433,7 +1390,7 @@ replace_single_def_regs (rtx *expr)\n     {\n       rtx x = *iter;\n       if (REG_P (x))\n-\tif (rtx new_x = find_single_def_src (REGNO (x)))\n+\tif (rtx new_x = df_find_single_def_src (x))\n \t  {\n \t    *expr = simplify_replace_rtx (*expr, x, new_x);\n \t    goto repeat;"}, {"sha": "ff40a459de14057103d7b500262ce9caa47defa9", "filename": "gcc/testsuite/g++.target/i386/pr105638.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr105638.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a743a72714fc4a9d7036d28d0cacdf2a3621f629/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr105638.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr105638.C?ref=a743a72714fc4a9d7036d28d0cacdf2a3621f629", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-std=gnu++20 -O2 -march=skylake\" } */\n+/* { dg-final { scan-assembler-not \"vpxor\" } } */\n+\n+#include <stdint.h>\n+#include <vector>\n+#include <tr1/array>\n+\n+class FastBoard {\n+public:\n+    typedef std::pair<int, int> movescore_t;\n+    typedef std::tr1::array<movescore_t, 24> scoredlist_t;\n+    \n+protected:\n+    std::vector<int> m_critical;\n+\n+    int m_boardsize;    \n+};\n+\n+class FastState {\n+public:        \n+    FastBoard board;\n+    \n+    int movenum;              \n+protected:\n+    FastBoard::scoredlist_t scoredmoves;\n+};\n+\n+class KoState : public FastState {\n+private:         \n+    std::vector<uint64_t> ko_hash_history;   \n+    std::vector<uint64_t> hash_history;     \n+};\n+\n+class GameState : public KoState {\n+public:                    \n+    void foo ();      \n+private:\n+    std::vector<KoState> game_history;                          \n+};\n+\n+void GameState::foo() {\n+    game_history.resize(movenum);\n+}"}]}