{"sha": "60a38ae15cbee078c0886720e3ee3d4118593216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBhMzhhZTE1Y2JlZTA3OGMwODg2NzIwZTNlZTNkNDExODU5MzIxNg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-05T07:02:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-05T07:02:51Z"}, "message": "[Ada] Failure to detect trivial infinite recursion\n\nThis patch reimplements the detection of trivial infinite recursion to\nremove the implicit assumptions concenring the structure and contents of\nthe enclosing subprogram statements.\n\n------------\n-- Source --\n------------\n\n--  infinite.adb\n\nprocedure Infinite with SPARK_Mode is\n   function Func_1 (Val : Integer) return Integer;\n   function Func_2 (Val : Integer) return Integer;\n   function Func_3 (Val : Integer) return Integer;\n   function Func_4 (Val : Integer) return Integer;\n   function Func_5 (Val : Integer) return Integer;\n   function Func_6 (Val : Integer) return Integer;\n   function Func_7 (Val : Integer) return Integer;\n   function Func_8 (Val_1 : Integer; Val_2 : Integer) return Integer;\n   procedure Proc_1 (Val : Integer);\n\n   function Func_1 (Val : Integer) return Integer is\n   begin\n      return Func_1 (Val);                                           --  WARN\n   end Func_1;\n\n   function Func_2 (Val : Integer) return Integer is\n   begin\n      return Func_2 (123);                                           --  none\n   end Func_2;\n\n   function Func_3 (Val : Integer) return Integer is\n      Temp : Integer;\n   begin\n      Temp := Func_3 (Val);                                          --  WARN\n      return Temp;\n   end Func_3;\n\n   function Func_4 (Val : Integer) return Integer is\n      Temp : Integer;\n   begin\n      Temp := Func_4 (123);                                          --  none\n      return Temp;\n   end Func_4;\n\n   function Func_5 (Val : Integer) return Integer is\n   begin\n      Proc_1 (Val);\n      return Func_5 (Val);                                           --  none\n   end Func_5;\n\n   function Func_6 (Val : Integer) return Integer is\n   begin\n      Proc_1 (Val);\n      return Func_6 (123);                                           --  none\n   end Func_6;\n\n   function Func_7 (Val : Integer) return Integer is\n   begin\n      raise Program_Error;\n      return Func_7 (Val);                                           --  none\n   end Func_7;\n\n   function Func_8 (Val_1 : Integer; Val_2 : Integer) return Integer is\n   begin\n      return Func_8 (Val_1, 123);                                    --  none\n   end Func_8;\n\n   procedure Proc_1 (Val : Integer) is\n   begin\n      Proc_1 (Val);                                                  --  WARN\n   end Proc_1;\n\nbegin null; end Infinite;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gcc -c infinite.adb\ninfinite.adb:14:14: infinite recursion\ninfinite.adb:14:14: Storage_Error would have been raised at run time\ninfinite.adb:25:15: infinite recursion\ninfinite.adb:25:15: Storage_Error would have been raised at run time\ninfinite.adb:61:07: infinite recursion\ninfinite.adb:61:07: Storage_Error would have been raised at run time\n\n2019-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* sem_res.adb (Check_Infinite_Recursion): Reimplemented.\n\t(Enclosing_Declaration_Or_Statement,\n\tInvoked_With_Different_Arguments, Is_Conditional_Statement,\n\tIs_Control_Flow_Statement, Is_Immediately_Within_Body,\n\tIs_Raise_Idiom, Is_Raise_Statement, Is_Sole_Statement,\n\tPreceded_By_Control_Flow_Statement,\n\tWithin_Conditional_Statement): New routines.\n\nFrom-SVN: r273116", "tree": {"sha": "d9385ed8f502e6abd2a8d5a1eb1c57ce9e8d05a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9385ed8f502e6abd2a8d5a1eb1c57ce9e8d05a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60a38ae15cbee078c0886720e3ee3d4118593216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60a38ae15cbee078c0886720e3ee3d4118593216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60a38ae15cbee078c0886720e3ee3d4118593216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60a38ae15cbee078c0886720e3ee3d4118593216/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43fa58c26a05f206ac36ab7d0340744c2769424f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43fa58c26a05f206ac36ab7d0340744c2769424f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43fa58c26a05f206ac36ab7d0340744c2769424f"}], "stats": {"total": 490, "additions": 371, "deletions": 119}, "files": [{"sha": "1ae3a777d8625c8f645a5023287f1ab76dcb34f1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60a38ae15cbee078c0886720e3ee3d4118593216/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60a38ae15cbee078c0886720e3ee3d4118593216/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=60a38ae15cbee078c0886720e3ee3d4118593216", "patch": "@@ -1,3 +1,13 @@\n+2019-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Check_Infinite_Recursion): Reimplemented.\n+\t(Enclosing_Declaration_Or_Statement,\n+\tInvoked_With_Different_Arguments, Is_Conditional_Statement,\n+\tIs_Control_Flow_Statement, Is_Immediately_Within_Body,\n+\tIs_Raise_Idiom, Is_Raise_Statement, Is_Sole_Statement,\n+\tPreceded_By_Control_Flow_Statement,\n+\tWithin_Conditional_Statement): New routines.\n+\n 2019-07-05  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Type_Conversion): Do not apply an"}, {"sha": "8dc8eebcaf2edbec5f6b73de27bb1781eb41e833", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 361, "deletions": 119, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60a38ae15cbee078c0886720e3ee3d4118593216/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60a38ae15cbee078c0886720e3ee3d4118593216/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=60a38ae15cbee078c0886720e3ee3d4118593216", "patch": "@@ -111,8 +111,8 @@ package body Sem_Res is\n       Pref : Node_Id);\n    --  Check that the type of the prefix of a dereference is not incomplete\n \n-   function Check_Infinite_Recursion (N : Node_Id) return Boolean;\n-   --  Given a call node, N, which is known to occur immediately within the\n+   function Check_Infinite_Recursion (Call : Node_Id) return Boolean;\n+   --  Given a call node, Call, which is known to occur immediately within the\n    --  subprogram being called, determines whether it is a detectable case of\n    --  an infinite recursion, and if so, outputs appropriate messages. Returns\n    --  True if an infinite recursion is detected, and False otherwise.\n@@ -695,164 +695,406 @@ package body Sem_Res is\n    -- Check_Infinite_Recursion --\n    ------------------------------\n \n-   function Check_Infinite_Recursion (N : Node_Id) return Boolean is\n-      P : Node_Id;\n-      C : Node_Id;\n+   function Check_Infinite_Recursion (Call : Node_Id) return Boolean is\n+      function Enclosing_Declaration_Or_Statement (N : Node_Id) return Node_Id;\n+      --  Return the nearest enclosing declaration or statement that houses\n+      --  arbitrary node N.\n \n-      function Same_Argument_List return Boolean;\n-      --  Check whether list of actuals is identical to list of formals of\n-      --  called function (which is also the enclosing scope).\n+      function Invoked_With_Different_Arguments (N : Node_Id) return Boolean;\n+      --  Determine whether call N invokes the related enclosing subprogram\n+      --  with actuals that differ from the subprogram's formals.\n \n-      ------------------------\n-      -- Same_Argument_List --\n-      ------------------------\n+      function Is_Conditional_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N denotes a conditional construct\n+\n+      function Is_Control_Flow_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N denotes a control flow statement\n+      --  or a construct that may contains such a statement.\n+\n+      function Is_Immediately_Within_Body (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N appears immediately within the\n+      --  statements of an entry or subprogram body.\n+\n+      function Is_Raise_Idiom (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N appears immediately within the\n+      --  body of an entry or subprogram, and is preceded by a single raise\n+      --  statement.\n \n-      function Same_Argument_List return Boolean is\n-         A    : Node_Id;\n-         F    : Entity_Id;\n-         Subp : Entity_Id;\n+      function Is_Raise_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N denotes a raise statement\n+\n+      function Is_Sole_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N is the sole source statement in\n+      --  the body of the enclosing subprogram.\n+\n+      function Preceded_By_Control_Flow_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N is preceded by a control flow\n+      --  statement.\n+\n+      function Within_Conditional_Statement (N : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node N appears within a conditional\n+      --  construct.\n+\n+      ----------------------------------------\n+      -- Enclosing_Declaration_Or_Statement --\n+      ----------------------------------------\n+\n+      function Enclosing_Declaration_Or_Statement\n+        (N : Node_Id) return Node_Id\n+      is\n+         Par : Node_Id;\n \n       begin\n-         if not Is_Entity_Name (Name (N)) then\n-            return False;\n-         else\n-            Subp := Entity (Name (N));\n-         end if;\n+         Par := N;\n+         while Present (Par) loop\n+            if Is_Declaration (Par) or else Is_Statement (Par) then\n+               return Par;\n \n-         F := First_Formal (Subp);\n-         A := First_Actual (N);\n-         while Present (F) and then Present (A) loop\n-            if not Is_Entity_Name (A) or else Entity (A) /= F then\n-               return False;\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n             end if;\n \n-            Next_Actual (A);\n-            Next_Formal (F);\n+            Par := Parent (Par);\n          end loop;\n \n-         return True;\n-      end Same_Argument_List;\n+         return N;\n+      end Enclosing_Declaration_Or_Statement;\n \n-   --  Start of processing for Check_Infinite_Recursion\n+      --------------------------------------\n+      -- Invoked_With_Different_Arguments --\n+      --------------------------------------\n \n-   begin\n-      --  Special case, if this is a procedure call and is a call to the\n-      --  current procedure with the same argument list, then this is for\n-      --  sure an infinite recursion and we insert a call to raise SE.\n+      function Invoked_With_Different_Arguments (N : Node_Id) return Boolean is\n+         Subp : constant Entity_Id := Entity (Name (N));\n \n-      if Is_List_Member (N)\n-        and then List_Length (List_Containing (N)) = 1\n-        and then Same_Argument_List\n-      then\n-         declare\n-            P : constant Node_Id := Parent (N);\n-         begin\n-            if Nkind (P) = N_Handled_Sequence_Of_Statements\n-              and then Nkind (Parent (P)) = N_Subprogram_Body\n-              and then Is_Empty_List (Declarations (Parent (P)))\n+         Actual : Node_Id;\n+         Formal : Entity_Id;\n+\n+      begin\n+         --  Determine whether the formals of the invoked subprogram are not\n+         --  used as actuals in the call.\n+\n+         Actual := First_Actual (Call);\n+         Formal := First_Formal (Subp);\n+         while Present (Actual) and then Present (Formal) loop\n+\n+            --  The current actual does not match the current formal\n+\n+            if not (Is_Entity_Name (Actual)\n+                     and then Entity (Actual) = Formal)\n             then\n-               Error_Msg_Warn := SPARK_Mode /= On;\n-               Error_Msg_N (\"!infinite recursion<<\", N);\n-               Error_Msg_N (\"\\!Storage_Error [<<\", N);\n-               Insert_Action (N,\n-                 Make_Raise_Storage_Error (Sloc (N),\n-                   Reason => SE_Infinite_Recursion));\n                return True;\n             end if;\n-         end;\n-      end if;\n \n-      --  If not that special case, search up tree, quitting if we reach a\n-      --  construct (e.g. a conditional) that tells us that this is not a\n-      --  case for an infinite recursion warning.\n+            Next_Actual (Actual);\n+            Next_Formal (Formal);\n+         end loop;\n \n-      C := N;\n-      loop\n-         P := Parent (C);\n+         return False;\n+      end Invoked_With_Different_Arguments;\n \n-         --  If no parent, then we were not inside a subprogram, this can for\n-         --  example happen when processing certain pragmas in a spec. Just\n-         --  return False in this case.\n+      ------------------------------\n+      -- Is_Conditional_Statement --\n+      ------------------------------\n \n-         if No (P) then\n+      function Is_Conditional_Statement (N : Node_Id) return Boolean is\n+      begin\n+         return\n+           Nkind_In (N, N_And_Then,\n+                        N_Case_Expression,\n+                        N_Case_Statement,\n+                        N_If_Expression,\n+                        N_If_Statement,\n+                        N_Or_Else);\n+      end Is_Conditional_Statement;\n+\n+      -------------------------------\n+      -- Is_Control_Flow_Statement --\n+      -------------------------------\n+\n+      function Is_Control_Flow_Statement (N : Node_Id) return Boolean is\n+      begin\n+         --  Delay statements do not affect the control flow because they\n+         --  simply postpone the execution of all subsequent statements.\n+\n+         if Nkind (N) in N_Delay_Statement then\n             return False;\n+\n+         --  Otherwise it is assumed that all other statements may affect the\n+         --  control flow in some way. A raise statement may be expanded into\n+         --  a non-statement node.\n+\n+         else\n+            return Is_Statement (N) or else Is_Raise_Statement (N);\n          end if;\n+      end Is_Control_Flow_Statement;\n \n-         --  Done if we get to subprogram body, this is definitely an infinite\n-         --  recursion case if we did not find anything to stop us.\n+      --------------------------------\n+      -- Is_Immediately_Within_Body --\n+      --------------------------------\n \n-         exit when Nkind (P) = N_Subprogram_Body;\n+      function Is_Immediately_Within_Body (N : Node_Id) return Boolean is\n+         HSS : constant Node_Id := Parent (N);\n \n-         --  If appearing in conditional, result is false\n+      begin\n+         return\n+           Nkind (HSS) = N_Handled_Sequence_Of_Statements\n+             and then Nkind_In (Parent (HSS), N_Entry_Body, N_Subprogram_Body)\n+             and then Is_List_Member (N)\n+             and then List_Containing (N) = Statements (HSS);\n+      end Is_Immediately_Within_Body;\n \n-         if Nkind_In (P, N_Or_Else,\n-                         N_And_Then,\n-                         N_Case_Expression,\n-                         N_Case_Statement,\n-                         N_If_Expression,\n-                         N_If_Statement)\n-         then\n-            return False;\n+      --------------------\n+      -- Is_Raise_Idiom --\n+      --------------------\n \n-         elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n-           and then C /= First (Statements (P))\n-         then\n-            --  If the call is the expression of a return statement and the\n-            --  actuals are identical to the formals, it's worth a warning.\n-            --  However, we skip this if there is an immediately preceding\n-            --  raise statement, since the call is never executed.\n+      function Is_Raise_Idiom (N : Node_Id) return Boolean is\n+         Raise_Stmt : Node_Id;\n+         Stmt       : Node_Id;\n \n-            --  Furthermore, this corresponds to a common idiom:\n+      begin\n+         if Is_Immediately_Within_Body (N) then\n \n-            --    function F (L : Thing) return Boolean is\n-            --    begin\n-            --       raise Program_Error;\n-            --       return F (L);\n-            --    end F;\n+            --  Assume that no raise statement has been seen yet\n \n-            --  for generating a stub function\n+            Raise_Stmt := Empty;\n \n-            if Nkind (Parent (N)) = N_Simple_Return_Statement\n-              and then Same_Argument_List\n-            then\n-               exit when not Is_List_Member (Parent (N));\n+            --  Examine the statements preceding the input node, skipping\n+            --  internally-generated constructs.\n \n-               --  OK, return statement is in a statement list, look for raise\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n \n-               declare\n-                  Nod : Node_Id;\n+               --  Multiple raise statements violate the idiom\n \n-               begin\n-                  --  Skip past N_Freeze_Entity nodes generated by expansion\n+               if Is_Raise_Statement (Stmt) then\n+                  if Present (Raise_Stmt) then\n+                     return False;\n+                  end if;\n \n-                  Nod := Prev (Parent (N));\n-                  while Present (Nod)\n-                    and then Nkind (Nod) = N_Freeze_Entity\n-                  loop\n-                     Prev (Nod);\n-                  end loop;\n+                  Raise_Stmt := Stmt;\n \n-                  --  If no raise statement, give warning. We look at the\n-                  --  original node, because in the case of \"raise ... with\n-                  --  ...\", the node has been transformed into a call.\n+               elsif Comes_From_Source (Stmt) then\n+                  exit;\n+               end if;\n \n-                  exit when Nkind (Original_Node (Nod)) /= N_Raise_Statement\n-                    and then\n-                      (Nkind (Nod) not in N_Raise_xxx_Error\n-                        or else Present (Condition (Nod)));\n-               end;\n-            end if;\n+               Stmt := Prev (Stmt);\n+            end loop;\n \n-            return False;\n+            --  At this point the node must be preceded by a raise statement,\n+            --  and the raise statement has to be the sole statement within\n+            --  the enclosing entry or subprogram body.\n \n-         else\n-            C := P;\n+            return\n+              Present (Raise_Stmt) and then Is_Sole_Statement (Raise_Stmt);\n          end if;\n-      end loop;\n \n-      Error_Msg_Warn := SPARK_Mode /= On;\n-      Error_Msg_N (\"!possible infinite recursion<<\", N);\n-      Error_Msg_N (\"\\!??Storage_Error ]<<\", N);\n+         return False;\n+      end Is_Raise_Idiom;\n+\n+      ------------------------\n+      -- Is_Raise_Statement --\n+      ------------------------\n+\n+      function Is_Raise_Statement (N : Node_Id) return Boolean is\n+      begin\n+         --  A raise statement may be transfomed into a Raise_xxx_Error node\n+\n+         return\n+           Nkind (N) = N_Raise_Statement\n+             or else Nkind (N) in N_Raise_xxx_Error;\n+      end Is_Raise_Statement;\n+\n+      -----------------------\n+      -- Is_Sole_Statement --\n+      -----------------------\n+\n+      function Is_Sole_Statement (N : Node_Id) return Boolean is\n+         Stmt : Node_Id;\n+\n+      begin\n+         --  The input node appears within the statements of an entry or\n+         --  subprogram body. Examine the statements preceding the node.\n+\n+         if Is_Immediately_Within_Body (N) then\n+            Stmt := Prev (N);\n+\n+            while Present (Stmt) loop\n+\n+               --  The statement is preceded by another statement or a source\n+               --  construct. This indicates that the node does not appear by\n+               --  itself.\n+\n+               if Is_Control_Flow_Statement (Stmt)\n+                 or else Comes_From_Source (Stmt)\n+               then\n+                  return False;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            return True;\n+         end if;\n+\n+         --  The input node is within a construct nested inside the entry or\n+         --  subprogram body.\n+\n+         return False;\n+      end Is_Sole_Statement;\n+\n+      ----------------------------------------\n+      -- Preceded_By_Control_Flow_Statement --\n+      ----------------------------------------\n+\n+      function Preceded_By_Control_Flow_Statement\n+        (N : Node_Id) return Boolean\n+      is\n+         Stmt : Node_Id;\n+\n+      begin\n+         if Is_List_Member (N) then\n+            Stmt := Prev (N);\n+\n+            --  Examine the statements preceding the input node\n+\n+            while Present (Stmt) loop\n+               if Is_Control_Flow_Statement (Stmt) then\n+                  return True;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            return False;\n+         end if;\n+\n+         --  Assume that the node is part of some control flow statement\n+\n+         return True;\n+      end Preceded_By_Control_Flow_Statement;\n+\n+      ----------------------------------\n+      -- Within_Conditional_Statement --\n+      ----------------------------------\n+\n+      function Within_Conditional_Statement (N : Node_Id) return Boolean is\n+         Stmt : Node_Id;\n+\n+      begin\n+         Stmt := Parent (N);\n+         while Present (Stmt) loop\n+            if Is_Conditional_Statement (Stmt) then\n+               return True;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Stmt) then\n+               exit;\n+            end if;\n+\n+            Stmt := Parent (Stmt);\n+         end loop;\n+\n+         return False;\n+      end Within_Conditional_Statement;\n+\n+      --  Local variables\n+\n+      Call_Context : constant Node_Id :=\n+                       Enclosing_Declaration_Or_Statement (Call);\n+\n+   --  Start of processing for Check_Infinite_Recursion\n+\n+   begin\n+      --  The call is assumed to be safe when the enclosing subprogram is\n+      --  invoked with actuals other than its formals.\n+      --\n+      --    procedure Proc (F1 : ...; F2 : ...; ...; FN : ...) is\n+      --    begin\n+      --       ...\n+      --       Proc (A1, A2, ..., AN);\n+      --       ...\n+      --    end Proc;\n+\n+      if Invoked_With_Different_Arguments (Call) then\n+         return False;\n+\n+      --  The call is assumed to be safe when the invocation of the enclosing\n+      --  subprogram depends on a conditional statement.\n+      --\n+      --    procedure Proc (F1 : ...; F2 : ...; ...; FN : ...) is\n+      --    begin\n+      --       ...\n+      --       if Some_Condition then\n+      --          Proc (F1, F2, ..., FN);\n+      --       end if;\n+      --       ...\n+      --    end Proc;\n+\n+      elsif Within_Conditional_Statement (Call) then\n+         return False;\n+\n+      --  The context of the call is assumed to be safe when the invocation of\n+      --  the enclosing subprogram is preceded by some control flow statement.\n+      --\n+      --    procedure Proc (F1 : ...; F2 : ...; ...; FN : ...) is\n+      --    begin\n+      --       ...\n+      --       if Some_Condition then\n+      --          ...\n+      --       end if;\n+      --       ...\n+      --       Proc (F1, F2, ..., FN);\n+      --       ...\n+      --    end Proc;\n+\n+      elsif Preceded_By_Control_Flow_Statement (Call_Context) then\n+         return False;\n+\n+      --  Detect an idiom where the context of the call is preceded by a single\n+      --  raise statement.\n+      --\n+      --    procedure Proc (F1 : ...; F2 : ...; ...; FN : ...) is\n+      --    begin\n+      --       raise ...;\n+      --       Proc (F1, F2, ..., FN);\n+      --    end Proc;\n+\n+      elsif Is_Raise_Idiom (Call_Context) then\n+         return False;\n+      end if;\n+\n+      --  At this point it is certain that infinite recursion will take place\n+      --  as long as the call is executed. Detect a case where the context of\n+      --  the call is the sole source statement within the subprogram body.\n+      --\n+      --    procedure Proc (F1 : ...; F2 : ...; ...; FN : ...) is\n+      --    begin\n+      --       Proc (F1, F2, ..., FN);\n+      --    end Proc;\n+      --\n+      --  Install an explicit raise to prevent the infinite recursion.\n+\n+      if Is_Sole_Statement (Call_Context) then\n+         Error_Msg_Warn := SPARK_Mode /= On;\n+         Error_Msg_N (\"!infinite recursion<<\", Call);\n+         Error_Msg_N (\"\\!Storage_Error [<<\", Call);\n+\n+         Insert_Action (Call,\n+           Make_Raise_Storage_Error (Sloc (Call),\n+             Reason => SE_Infinite_Recursion));\n+\n+      --  Otherwise infinite recursion could take place, considering other flow\n+      --  control constructs such as gotos, exit statements, etc.\n+\n+      else\n+         Error_Msg_Warn := SPARK_Mode /= On;\n+         Error_Msg_N (\"!possible infinite recursion<<\", Call);\n+         Error_Msg_N (\"\\!??Storage_Error ]<<\", Call);\n+      end if;\n \n       return True;\n    end Check_Infinite_Recursion;"}]}