{"sha": "437244c7737eeb63973e1e285d5dc6844ab13f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM3MjQ0Yzc3MzdlZWI2Mzk3M2UxZTI4NWQ1ZGM2ODQ0YWIxM2Y5Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-27T13:28:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-27T13:28:30Z"}, "message": "[multiple changes]\n\n2016-04-27  Arnaud Charlet  <charlet@adacore.com>\n\n\t* aa_util.adb, aa_util.ads: Removed, no longer used.\n\n2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): An object\n\trenaming declaration resulting from the expansion of an object\n\tdeclaration is a suitable context for pragma Ghost.\n\n2016-04-27  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c: Refine last checkin so the only requirement is the\n\tsignaling compilation unit is compiled with the same mode as\n\tthe compilation unit containing the initial landing pad.\n\n2016-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Valid_Default_Iterator): Better filter of illegal\n\tspecifications for Default_Iterator, including overloaded cases\n\twhere no interpretations are legal, and return types that are\n\tnot iterator types.\n\n2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Do not install\n\tan accessibility check when the left hand side of the assignment\n\tdenotes a container cursor.\n\t* exp_util.ads, exp_util.adb (Find_Primitive_Operations): Removed.\n\t* sem_ch4.adb (Find_Indexing_Operations): New routine.\n\t(Try_Container_Indexing): Code cleanup.\n\nFrom-SVN: r235505", "tree": {"sha": "e076d046cdb802cf813a64b0273c96591c31bc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e076d046cdb802cf813a64b0273c96591c31bc79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/437244c7737eeb63973e1e285d5dc6844ab13f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437244c7737eeb63973e1e285d5dc6844ab13f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437244c7737eeb63973e1e285d5dc6844ab13f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437244c7737eeb63973e1e285d5dc6844ab13f9f/comments", "author": null, "committer": null, "parents": [{"sha": "57323d5bd3d3b553788a6f13217829069bf95bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57323d5bd3d3b553788a6f13217829069bf95bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57323d5bd3d3b553788a6f13217829069bf95bfe"}], "stats": {"total": 1000, "additions": 324, "deletions": 676}, "files": [{"sha": "1fbc5985ad53d7c55f8df356b312a965dd45dd81", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -1,3 +1,35 @@\n+2016-04-27  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* aa_util.adb, aa_util.ads: Removed, no longer used.\n+\n+2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): An object\n+\trenaming declaration resulting from the expansion of an object\n+\tdeclaration is a suitable context for pragma Ghost.\n+\n+2016-04-27  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c: Refine last checkin so the only requirement is the\n+\tsignaling compilation unit is compiled with the same mode as\n+\tthe compilation unit containing the initial landing pad.\n+\n+2016-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Valid_Default_Iterator): Better filter of illegal\n+\tspecifications for Default_Iterator, including overloaded cases\n+\twhere no interpretations are legal, and return types that are\n+\tnot iterator types.\n+\n+2016-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Do not install\n+\tan accessibility check when the left hand side of the assignment\n+\tdenotes a container cursor.\n+\t* exp_util.ads, exp_util.adb (Find_Primitive_Operations): Removed.\n+\t* sem_ch4.adb (Find_Indexing_Operations): New routine.\n+\t(Try_Container_Indexing): Code cleanup.\n+\n 2016-04-27  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_ch10.adb, sem_case.adb: Mark messages udner -gnatwr when needed."}, {"sha": "6ea4421f570d8bd74f9d063099f2e440614875d2", "filename": "gcc/ada/aa_util.adb", "status": "removed", "additions": 0, "deletions": 458, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57323d5bd3d3b553788a6f13217829069bf95bfe/gcc%2Fada%2Faa_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57323d5bd3d3b553788a6f13217829069bf95bfe/gcc%2Fada%2Faa_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faa_util.adb?ref=57323d5bd3d3b553788a6f13217829069bf95bfe", "patch": "@@ -1,458 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAAMP COMPILER COMPONENTS                        --\n---                                                                          --\n---                              A A _ U T I L                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2012, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Sem_Aux; use Sem_Aux;\n-with Sinput;  use Sinput;\n-with Stand;   use Stand;\n-with Stringt; use Stringt;\n-\n-with GNAT.Case_Util;  use GNAT.Case_Util;\n-\n-package body AA_Util is\n-\n-   ----------------------\n-   -- Is_Global_Entity --\n-   ----------------------\n-\n-   function Is_Global_Entity (E : Entity_Id) return Boolean is\n-   begin\n-      return Enclosing_Dynamic_Scope (E) = Standard_Standard;\n-   end Is_Global_Entity;\n-\n-   -----------------\n-   -- New_Name_Id --\n-   -----------------\n-\n-   function New_Name_Id (Name : String) return Name_Id is\n-   begin\n-      for J in 1 .. Name'Length loop\n-         Name_Buffer (J) := Name (Name'First + (J - 1));\n-      end loop;\n-\n-      Name_Len := Name'Length;\n-      return Name_Find;\n-   end New_Name_Id;\n-\n-   -----------------\n-   -- Name_String --\n-   -----------------\n-\n-   function Name_String (Name : Name_Id) return String is\n-   begin\n-      pragma Assert (Name /= No_Name);\n-      return Get_Name_String (Name);\n-   end Name_String;\n-\n-   -------------------\n-   -- New_String_Id --\n-   -------------------\n-\n-   function New_String_Id (S : String) return String_Id is\n-   begin\n-      for J in 1 .. S'Length loop\n-         Name_Buffer (J) := S (S'First + (J - 1));\n-      end loop;\n-\n-      Name_Len := S'Length;\n-      return String_From_Name_Buffer;\n-   end New_String_Id;\n-\n-   ------------------\n-   -- String_Value --\n-   ------------------\n-\n-   function String_Value (Str_Id : String_Id) return String is\n-   begin\n-      --  ??? pragma Assert (Str_Id /= No_String);\n-\n-      if Str_Id = No_String then\n-         return \"\";\n-      end if;\n-\n-      String_To_Name_Buffer (Str_Id);\n-\n-      return Name_Buffer (1 .. Name_Len);\n-   end String_Value;\n-\n-   ---------------\n-   -- Next_Name --\n-   ---------------\n-\n-   function Next_Name\n-     (Name_Seq    : not null access Name_Sequencer;\n-      Name_Prefix : String) return Name_Id\n-   is\n-   begin\n-      Name_Seq.Sequence_Number := Name_Seq.Sequence_Number + 1;\n-\n-      declare\n-         Number_Image : constant String := Name_Seq.Sequence_Number'Img;\n-      begin\n-         return New_Name_Id\n-                  (Name_Prefix & \"__\" & Number_Image (2 .. Number_Image'Last));\n-      end;\n-   end Next_Name;\n-\n-   --------------------\n-   -- Elab_Spec_Name --\n-   --------------------\n-\n-   function Elab_Spec_Name (Module_Name : Name_Id) return Name_Id is\n-   begin\n-      return New_Name_Id (Name_String (Module_Name) & \"___elabs\");\n-   end Elab_Spec_Name;\n-\n-   --------------------\n-   -- Elab_Spec_Name --\n-   --------------------\n-\n-   function Elab_Body_Name (Module_Name : Name_Id) return Name_Id is\n-   begin\n-      return New_Name_Id (Name_String (Module_Name) & \"___elabb\");\n-   end Elab_Body_Name;\n-\n-   --------------------------------\n-   -- Source_Name_Without_Suffix --\n-   --------------------------------\n-\n-   function File_Name_Without_Suffix (File_Name : String) return String is\n-      Name_Index : Natural := File_Name'Last;\n-\n-   begin\n-      pragma Assert (File_Name'Length > 0);\n-\n-      --  We loop in reverse to ensure that file names that follow nonstandard\n-      --  naming conventions that include additional dots are handled properly,\n-      --  preserving dots in front of the main file suffix (for example,\n-      --  main.2.ada => main.2).\n-\n-      while Name_Index >= File_Name'First\n-        and then File_Name (Name_Index) /= '.'\n-      loop\n-         Name_Index := Name_Index - 1;\n-      end loop;\n-\n-      --  Return the part of the file name up to but not including the last dot\n-      --  in the name, or return the whole name as is if no dot character was\n-      --  found.\n-\n-      if Name_Index >= File_Name'First then\n-         return File_Name (File_Name'First .. Name_Index - 1);\n-\n-      else\n-         return File_Name;\n-      end if;\n-   end File_Name_Without_Suffix;\n-\n-   -----------------\n-   -- Source_Name --\n-   -----------------\n-\n-   function Source_Name (Sloc : Source_Ptr) return File_Name_Type is\n-   begin\n-      if Sloc = No_Location or Sloc = Standard_Location then\n-         return No_File;\n-      else\n-         return File_Name (Get_Source_File_Index (Sloc));\n-      end if;\n-   end Source_Name;\n-\n-   --------------------------------\n-   -- Source_Name_Without_Suffix --\n-   --------------------------------\n-\n-   function Source_Name_Without_Suffix (Sloc : Source_Ptr) return String is\n-      Src_Name  : constant String :=\n-        Name_String (Name_Id (Source_Name (Sloc)));\n-      Src_Index : Natural         := Src_Name'Last;\n-\n-   begin\n-      pragma Assert (Src_Name'Length > 0);\n-\n-      --  Treat the presence of a \".dg\" suffix specially, stripping it off\n-      --  in addition to any suffix preceding it.\n-\n-      if Src_Name'Length >= 4\n-        and then Src_Name (Src_Name'Last - 2 .. Src_Name'Last) = \".dg\"\n-      then\n-         Src_Index := Src_Index - 3;\n-      end if;\n-\n-      return File_Name_Without_Suffix (Src_Name (Src_Name'First .. Src_Index));\n-   end Source_Name_Without_Suffix;\n-\n-   ----------------------\n-   -- Source_Id_String --\n-   ----------------------\n-\n-   function Source_Id_String (Unit_Name : Name_Id) return String is\n-      Unit_String : String   := Name_String (Unit_Name);\n-      Name_Last   : Positive := Unit_String'Last;\n-      Name_Index  : Positive := Unit_String'First;\n-\n-   begin\n-      To_Mixed (Unit_String);\n-\n-      --  Replace any embedded sequences of two or more '_' characters\n-      --  with a single '.' character. Note that this will leave any\n-      --  leading or trailing single '_' characters untouched, but those\n-      --  should normally not occur in compilation unit names (and if\n-      --  they do then it's better to leave them as is).\n-\n-      while Name_Index <= Name_Last loop\n-         if Unit_String (Name_Index) = '_'\n-           and then Name_Index /= Name_Last\n-           and then Unit_String (Name_Index + 1) = '_'\n-         then\n-            Unit_String (Name_Index) := '.';\n-            Name_Index := Name_Index + 1;\n-\n-            while Unit_String (Name_Index) = '_'\n-              and then Name_Index <= Name_Last\n-            loop\n-               Unit_String (Name_Index .. Name_Last - 1)\n-                 := Unit_String (Name_Index + 1 .. Name_Last);\n-               Name_Last := Name_Last - 1;\n-            end loop;\n-\n-         else\n-            Name_Index := Name_Index + 1;\n-         end if;\n-      end loop;\n-\n-      return Unit_String (Unit_String'First .. Name_Last);\n-   end Source_Id_String;\n-\n-   --  This version of Source_Id_String is obsolescent and is being\n-   --  replaced with the above function.\n-\n-   function Source_Id_String (Sloc : Source_Ptr) return String is\n-      File_Index : Source_File_Index;\n-\n-   begin\n-      --  Use an arbitrary artificial 22-character value for package Standard,\n-      --  since Standard doesn't have an associated source file.\n-\n-      if Sloc <= Standard_Location then\n-         return \"20010101010101standard\";\n-\n-      --  Return the concatentation of the source file's timestamp and\n-      --  its 8-digit hex checksum.\n-\n-      else\n-         File_Index := Get_Source_File_Index (Sloc);\n-\n-         return String (Time_Stamp (File_Index))\n-                  & Get_Hex_String (Source_Checksum (File_Index));\n-      end if;\n-   end Source_Id_String;\n-\n-   ---------------\n-   -- Source_Id --\n-   ---------------\n-\n-   function Source_Id (Unit_Name : Name_Id) return String_Id is\n-   begin\n-      return New_String_Id (Source_Id_String (Unit_Name));\n-   end Source_Id;\n-\n-   --  This version of Source_Id is obsolescent and is being\n-   --  replaced with the above function.\n-\n-   function Source_Id (Sloc : Source_Ptr) return String_Id is\n-   begin\n-      return New_String_Id (Source_Id_String (Sloc));\n-   end Source_Id;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (I : Int) return String is\n-      Image_String : constant String := Pos'Image (I);\n-   begin\n-      if Image_String (1) = ' ' then\n-         return Image_String (2 .. Image_String'Last);\n-      else\n-         return Image_String;\n-      end if;\n-   end Image;\n-\n-   --------------\n-   -- UI_Image --\n-   --------------\n-\n-   function UI_Image (I : Uint; Format : Integer_Image_Format) return String is\n-   begin\n-      if Format = Decimal then\n-         UI_Image (I, Format => Decimal);\n-         return UI_Image_Buffer (1 .. UI_Image_Length);\n-\n-      elsif Format = Ada_Hex then\n-         UI_Image (I, Format => Hex);\n-         return UI_Image_Buffer (1 .. UI_Image_Length);\n-\n-      else\n-         pragma Assert (I >= Uint_0);\n-\n-         UI_Image (I, Format => Hex);\n-\n-         pragma Assert (UI_Image_Buffer (1 .. 3) = \"16#\"\n-                         and then UI_Image_Buffer (UI_Image_Length) = '#');\n-\n-         --  Declare a string where we will copy the digits from the UI_Image,\n-         --  interspersing '_' characters as 4-digit group separators. The\n-         --  underscores in UI_Image's result are not always at the places\n-         --  where we want them, which is why we do the following copy\n-         --  (e.g., we map \"16#ABCD_EF#\" to \"^AB_CDEF^\").\n-\n-         declare\n-            Hex_String     : String (1 .. UI_Image_Max);\n-            Last_Index     : Natural;\n-            Digit_Count    : Natural := 0;\n-            UI_Image_Index : Natural := 4; -- Skip past the \"16#\" bracket\n-            Sep_Count      : Natural := 0;\n-\n-         begin\n-            --  Count up the number of non-underscore characters in the\n-            --  literal value portion of the UI_Image string.\n-\n-            while UI_Image_Buffer (UI_Image_Index) /= '#' loop\n-               if UI_Image_Buffer (UI_Image_Index) /= '_' then\n-                  Digit_Count := Digit_Count + 1;\n-               end if;\n-\n-               UI_Image_Index := UI_Image_Index + 1;\n-            end loop;\n-\n-            UI_Image_Index := 4; -- Reset the index past the \"16#\" bracket\n-\n-            Last_Index := 1;\n-\n-            Hex_String (Last_Index) := '^';\n-            Last_Index := Last_Index + 1;\n-\n-            --  Copy digits from UI_Image_Buffer to Hex_String, adding\n-            --  underscore separators as appropriate. The initial value\n-            --  of Sep_Count accounts for the leading '^' and being one\n-            --  character ahead after inserting a digit.\n-\n-            Sep_Count := 2;\n-\n-            while UI_Image_Buffer (UI_Image_Index) /= '#' loop\n-               if UI_Image_Buffer (UI_Image_Index) /= '_' then\n-                  Hex_String (Last_Index) := UI_Image_Buffer (UI_Image_Index);\n-\n-                  Last_Index := Last_Index + 1;\n-\n-                  --  Add '_' characters to separate groups of four hex\n-                  --  digits for readability (grouping from right to left).\n-\n-                  if (Digit_Count - (Last_Index - Sep_Count)) mod 4 = 0 then\n-                     Hex_String (Last_Index) := '_';\n-                     Last_Index := Last_Index + 1;\n-                     Sep_Count := Sep_Count + 1;\n-                  end if;\n-               end if;\n-\n-               UI_Image_Index := UI_Image_Index + 1;\n-            end loop;\n-\n-            --  Back up before any trailing underscore\n-\n-            if Hex_String (Last_Index - 1) = '_' then\n-               Last_Index := Last_Index - 1;\n-            end if;\n-\n-            Hex_String (Last_Index) := '^';\n-\n-            return Hex_String (1 .. Last_Index);\n-         end;\n-      end if;\n-   end UI_Image;\n-\n-   --------------\n-   -- UR_Image --\n-   --------------\n-\n-   --  Shouldn't this be added to Urealp???\n-\n-   function UR_Image (R : Ureal) return String is\n-\n-      --  The algorithm used here for conversion of Ureal values\n-      --  is taken from the JGNAT back end.\n-\n-      Num    : Long_Long_Float := 0.0;\n-      Den    : Long_Long_Float := 0.0;\n-      Sign   : Long_Long_Float := 1.0;\n-      Result : Long_Long_Float;\n-      Tmp    : Uint;\n-      Index  : Integer;\n-\n-   begin\n-      if UR_Is_Negative (R) then\n-         Sign := -1.0;\n-      end if;\n-\n-      --  In the following calculus, we consider numbers modulo 2 ** 31,\n-      --  so that we don't have problems with signed Int...\n-\n-      Tmp := abs (Numerator (R));\n-      Index := 0;\n-      while Tmp > 0 loop\n-         Num := Num\n-           + Long_Long_Float (UI_To_Int (Tmp mod (Uint_2 ** 31)))\n-           * (2.0 ** Index);\n-         Tmp := Tmp / Uint_2 ** 31;\n-         Index := Index + 31;\n-      end loop;\n-\n-      Tmp := abs (Denominator (R));\n-      if Rbase (R) /= 0 then\n-         Tmp := Rbase (R) ** Tmp;\n-      end if;\n-\n-      Index := 0;\n-      while Tmp > 0 loop\n-         Den := Den\n-           + Long_Long_Float (UI_To_Int (Tmp mod (Uint_2 ** 31)))\n-           * (2.0 ** Index);\n-         Tmp := Tmp / Uint_2 ** 31;\n-         Index := Index + 31;\n-      end loop;\n-\n-      --  If the denominator denotes a negative power of Rbase,\n-      --  then multiply by the denominator.\n-\n-      if Rbase (R) /= 0 and then Denominator (R) < 0 then\n-         Result := Sign * Num * Den;\n-\n-      --  Otherwise compute the quotient\n-\n-      else\n-         Result := Sign * Num / Den;\n-      end if;\n-\n-      return Long_Long_Float'Image (Result);\n-   end UR_Image;\n-\n-end AA_Util;"}, {"sha": "27b6183248e7d7795c775dd4f91f74b2c1af55bd", "filename": "gcc/ada/aa_util.ads", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57323d5bd3d3b553788a6f13217829069bf95bfe/gcc%2Fada%2Faa_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57323d5bd3d3b553788a6f13217829069bf95bfe/gcc%2Fada%2Faa_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faa_util.ads?ref=57323d5bd3d3b553788a6f13217829069bf95bfe", "patch": "@@ -1,145 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAAMP COMPILER COMPONENTS                        --\n---                                                                          --\n---                              A A _ U T I L                               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2011, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides various utility operations used by GNAT back-ends\n---  (e.g. AAMP).\n-\n---  This package is a messy grab bag of stuff. These routines should be moved\n---  to appropriate units (sem_util,sem_aux,exp_util,namet,uintp,urealp). ???\n-\n-with Namet;  use Namet;\n-with Types;  use Types;\n-with Uintp;  use Uintp;\n-with Urealp; use Urealp;\n-\n-package AA_Util is\n-\n-   function Is_Global_Entity (E : Entity_Id) return Boolean;\n-   --  Returns true if and only if E is a library-level entity (excludes\n-   --  entities declared within blocks at the outer level of library packages).\n-\n-   function New_Name_Id (Name : String) return Name_Id;\n-   --  Returns a Name_Id corresponding to the given name string\n-\n-   function Name_String (Name : Name_Id) return String;\n-   --  Returns the name string associated with Name\n-\n-   function New_String_Id (S : String) return String_Id;\n-   --  Returns a String_Id corresponding to the given string\n-\n-   function String_Value (Str_Id : String_Id) return String;\n-   --  Returns the string associated with Str_Id\n-\n-   --  Name-generation utilities\n-\n-   type Name_Sequencer is private;\n-   --  This type is used to support back-end generation of unique symbol\n-   --  (e.g., for string literal objects or labels). By declaring an\n-   --  aliased object of type Name_Sequence and passing that object\n-   --  to the function Next_Name, a series of names with suffixes\n-   --  of the form \"__n\" will be produced, where n is a string denoting\n-   --  a positive integer.  The sequence starts with \"__1\", and increases\n-   --  by one on each successive call to Next_Name for a given Name_Sequencer.\n-\n-   function Next_Name\n-     (Name_Seq    : not null access Name_Sequencer;\n-      Name_Prefix : String) return Name_Id;\n-   --  Returns the Name_Id for a name composed of the given Name_Prefix\n-   --  concatentated with a unique number suffix of the form \"__n\",\n-   --  as detemined by the current state of Name_Seq.\n-\n-   function Elab_Spec_Name (Module_Name : Name_Id) return Name_Id;\n-   --  Returns a name id for the elaboration subprogram to be associated with\n-   --  the specification of the named module. The denoted name is of the form\n-   --  \"modulename___elabs\".\n-\n-   function Elab_Body_Name (Module_Name : Name_Id) return Name_Id;\n-   --  Returns a name id for the elaboration subprogram to be associated\n-   --  with the body of the named module. The denoted name is of the form\n-   --  \"modulename___elabb\".\n-\n-   function File_Name_Without_Suffix (File_Name : String) return String;\n-   --  Removes the suffix ('.' followed by other characters), if present, from\n-   --  the end of File_Name and returns the shortened name (otherwise simply\n-   --  returns File_Name).\n-\n-   function Source_Name (Sloc : Source_Ptr) return File_Name_Type;\n-   --  Returns file name corresponding to the source file name associated with\n-   --  the given source position Sloc.\n-\n-   function Source_Name_Without_Suffix (Sloc : Source_Ptr) return String;\n-   --  Returns a string corresponding to the source file name associated with\n-   --  the given source position Sloc, with its dot-preceded suffix, if any,\n-   --  removed. As examples, the name \"main.adb\" is mapped to \"main\" and the\n-   --  name \"main.2.ada\" is mapped to \"main.2\". As a special case, file names\n-   --  with a \".dg\" suffix will also strip off the \".dg\", so \"main.adb.dg\"\n-   --  becomes simply \"main\".\n-\n-   function Source_Id_String (Unit_Name : Name_Id) return String;\n-   --  Returns a string that uniquely identifies the unit with the given\n-   --  Unit_Name. This string is derived from Unit_Name by replacing any\n-   --  multiple underscores with dot ('.') characters and normalizing the\n-   --  casing to mixed case (e.g., \"ada__strings\" is mapped to (\"Ada.Strings\").\n-\n-   function Source_Id (Unit_Name : Name_Id) return String_Id;\n-   --  Returns a String_Id reference to a string that uniquely identifies\n-   --  the program unit having the given name (as defined for function\n-   --  Source_Id_String).\n-\n-   function Source_Id_String (Sloc : Source_Ptr) return String;\n-   --  Returns a string that uniquely identifies the source file containing\n-   --  the given source location.  This string is constructed from the\n-   --  concatentation of the date and time stamp of the file with a\n-   --  hexadecimal check sum (e.g., \"020425143059ABCDEF01\").\n-\n-   function Source_Id (Sloc : Source_Ptr) return String_Id;\n-   --  Returns a String_Id reference to a string that uniquely identifies the\n-   --  source file containing the given source location (as defined for\n-   --  function Source_Id_String).\n-\n-   function Image (I : Int) return String;\n-   --  Returns Int'Image (I), but without a leading space in the case where\n-   --  I is nonnegative. Useful for concatenating integers onto other names.\n-\n-   type Integer_Image_Format is (Decimal, Ada_Hex, AAMP_Hex);\n-\n-   function UI_Image (I : Uint; Format : Integer_Image_Format) return String;\n-   --  Returns the image of the universal integer I, with no leading spaces\n-   --  and in the format specified. The Format parameter specifies whether\n-   --  the integer representation should be decimal (the default), or Ada\n-   --  hexadecimal (Ada_Hex => \"16#xxxxx#\" format), or AAMP hexadecimal.\n-   --  In the latter case, the integer will have the form of a sequence of\n-   --  hexadecimal digits bracketed by '^' characters, and will contain '_'\n-   --  characters as separators for groups of four hexadecimal digits\n-   --  (e.g., ^1C_A3CD^). If the format AAMP_Hex is selected, the universal\n-   --  integer must have a nonnegative value.\n-\n-   function UR_Image (R : Ureal) return String;\n-   --  Returns a decimal image of the universal real value R\n-\n-private\n-\n-   type Name_Sequencer is record\n-      Sequence_Number : Natural := 0;\n-   end record;\n-\n-end AA_Util;"}, {"sha": "f3a6f69f250bf8e100a83a169bc1b6d8b5766bba", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -2030,10 +2030,13 @@ package body Exp_Ch5 is\n       end if;\n \n       --  Ada 2012 (AI05-148): Update current accessibility level if Rhs is a\n-      --  stand-alone obj of an anonymous access type.\n+      --  stand-alone obj of an anonymous access type. Do not install the check\n+      --  when the Lhs denotes a container cursor and the Next function employs\n+      --  an access type because this may never result in a dangling pointer.\n \n       if Is_Access_Type (Typ)\n         and then Is_Entity_Name (Lhs)\n+        and then Ekind (Entity (Lhs)) /= E_Loop_Parameter\n         and then Present (Effective_Extra_Accessibility (Entity (Lhs)))\n       then\n          declare"}, {"sha": "b4efc938060285575386691eda7e06645945d927", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -2793,50 +2793,6 @@ package body Exp_Util is\n       end if;\n    end Find_Optional_Prim_Op;\n \n-   -------------------------------\n-   -- Find_Primitive_Operations --\n-   -------------------------------\n-\n-   function Find_Primitive_Operations\n-     (T    : Entity_Id;\n-      Name : Name_Id) return Node_Id\n-   is\n-      Prim_Elmt : Elmt_Id;\n-      Prim_Id   : Entity_Id;\n-      Ref       : Node_Id;\n-      Typ       : Entity_Id := T;\n-\n-   begin\n-      if Is_Class_Wide_Type (Typ) then\n-         Typ := Root_Type (Typ);\n-      end if;\n-\n-      Typ := Underlying_Type (Typ);\n-\n-      Ref := Empty;\n-      Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n-      while Present (Prim_Elmt) loop\n-         Prim_Id := Node (Prim_Elmt);\n-            if Chars (Prim_Id) = Name then\n-\n-               --  If this is the first primitive operation found,\n-               --  create a reference to it.\n-\n-               if No (Ref) then\n-                  Ref := New_Occurrence_Of (Prim_Id, Sloc (T));\n-\n-               --  Otherwise, add interpretation to existing reference\n-\n-               else\n-                  Add_One_Interp (Ref, Prim_Id, Etype (Prim_Id));\n-               end if;\n-            end if;\n-         Next_Elmt (Prim_Elmt);\n-      end loop;\n-\n-      return Ref;\n-   end Find_Primitive_Operations;\n-\n    ------------------\n    -- Find_Prim_Op --\n    ------------------"}, {"sha": "1bde973f0e7200d7cd7f5d4c4fcf39496e434f3c", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -473,13 +473,6 @@ package Exp_Util is\n    --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n    --  return the record component containing the tag of Iface.\n \n-   function Find_Primitive_Operations\n-     (T    : Entity_Id;\n-      Name : Name_Id) return Node_Id;\n-   --  Return a reference to a primitive operation with given name. If\n-   --  operation is overloaded, the node carries the corresponding set\n-   --  of overloaded interpretations.\n-\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id;\n    --  Find the first primitive operation of a tagged type T with name Name.\n    --  This function allows the use of a primitive operation which is not"}, {"sha": "6d51896d13721bebb7501e014a6d0010bc4b7508", "filename": "gcc/ada/init.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -504,9 +504,13 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n   /* ARM Bump has to be an even number because of odd/even architecture.  */\n   mcontext->arm_pc+=2;\n #ifdef __thumb2__\n+#define CPSR_THUMB_BIT 5\n   /* For thumb, the return address much have the low order bit set, otherwise\n-     the unwwinder will reset to \"arm\" mode upon return.  It's a feature.  */\n-  mcontext->arm_pc+=1;\n+     the unwinder will reset to \"arm\" mode upon return.  As long as the\n+     compilation unit containing the landing pad is compiled with the same\n+     mode (arm vs thumb) as the signaling compilation unit, this works.  */\n+  if (mcontext->arm_cpsr & (1<<CPSR_THUMB_BIT))\n+    mcontext->arm_pc+=1;\n #endif\n #endif\n }"}, {"sha": "c6d0dba7a4a2157b37122722325a0c6caefe638d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -4323,10 +4323,21 @@ package body Sem_Ch13 is\n \n          function Valid_Default_Iterator (Subp : Entity_Id) return Boolean is\n             Formal : Entity_Id;\n+            Root_T : constant Entity_Id := Root_Type (Etype (Etype (Subp)));\n \n          begin\n             if not Check_Primitive_Function (Subp) then\n                return False;\n+\n+            --  The return type must be derived from a type in an instance\n+            --  of Iterator.Interfaces, and thus its root type must have a\n+            --  predefined name.\n+\n+            elsif Chars (Root_T) /= Name_Forward_Iterator\n+             and then Chars (Root_T) /= Name_Reversible_Iterator\n+            then\n+               return False;\n+\n             else\n                Formal := First_Formal (Subp);\n             end if;\n@@ -4409,6 +4420,9 @@ package body Sem_Ch13 is\n                if Present (Default) then\n                   Set_Entity (Expr, Default);\n                   Set_Is_Overloaded (Expr, False);\n+               else\n+                  Error_Msg_N\n+                    (\"No interpretation is a valid default iterator!\", Expr);\n                end if;\n             end;\n          end if;"}, {"sha": "719e4ed0e989c10633194b08257da7c04e1e038b", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 255, "deletions": 18, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -7214,11 +7214,22 @@ package body Sem_Ch4 is\n       Prefix : Node_Id;\n       Exprs  : List_Id) return Boolean\n    is\n+      Pref_Typ : constant Entity_Id := Etype (Prefix);\n+\n       function Constant_Indexing_OK return Boolean;\n       --  Constant_Indexing is legal if there is no Variable_Indexing defined\n       --  for the type, or else node not a target of assignment, or an actual\n       --  for an IN OUT or OUT formal (RM 4.1.6 (11)).\n \n+      function Find_Indexing_Operations\n+        (T           : Entity_Id;\n+         Nam         : Name_Id;\n+         Is_Constant : Boolean) return Node_Id;\n+      --  Return a reference to the primitive operation of type T denoted by\n+      --  name Nam. If the operation is overloaded, the reference carries all\n+      --  interpretations. Flag Is_Constant should be set when the context is\n+      --  constant indexing.\n+\n       --------------------------\n       -- Constant_Indexing_OK --\n       --------------------------\n@@ -7227,9 +7238,7 @@ package body Sem_Ch4 is\n          Par : Node_Id;\n \n       begin\n-         if No (Find_Value_Of_Aspect\n-                 (Etype (Prefix), Aspect_Variable_Indexing))\n-         then\n+         if No (Find_Value_Of_Aspect (Pref_Typ, Aspect_Variable_Indexing)) then\n             return True;\n \n          elsif not Is_Variable (Prefix) then\n@@ -7360,7 +7369,7 @@ package body Sem_Ch4 is\n                   end if;\n                end;\n \n-            elsif Nkind ((Par)) in N_Op then\n+            elsif Nkind (Par) in N_Op then\n                return True;\n             end if;\n \n@@ -7372,6 +7381,215 @@ package body Sem_Ch4 is\n          return True;\n       end Constant_Indexing_OK;\n \n+      ------------------------------\n+      -- Find_Indexing_Operations --\n+      ------------------------------\n+\n+      function Find_Indexing_Operations\n+        (T           : Entity_Id;\n+         Nam         : Name_Id;\n+         Is_Constant : Boolean) return Node_Id\n+      is\n+         procedure Inspect_Declarations\n+           (Typ : Entity_Id;\n+            Ref : in out Node_Id);\n+         --  Traverse the declarative list where type Typ resides and collect\n+         --  all suitable interpretations in node Ref.\n+\n+         procedure Inspect_Primitives\n+           (Typ : Entity_Id;\n+            Ref : in out Node_Id);\n+         --  Traverse the list of primitive operations of type Typ and collect\n+         --  all suitable interpretations in node Ref.\n+\n+         function Is_OK_Candidate\n+           (Subp_Id : Entity_Id;\n+            Typ     : Entity_Id) return Boolean;\n+         --  Determine whether subprogram Subp_Id is a suitable indexing\n+         --  operation for type Typ. To qualify as such, the subprogram must\n+         --  be a function, have at least two parameters, and the type of the\n+         --  first parameter must be either Typ, or Typ'Class, or access [to\n+         --  constant] with designated type Typ or Typ'Class.\n+\n+         procedure Record_Interp (Subp_Id : Entity_Id; Ref : in out Node_Id);\n+         --  Store subprogram Subp_Id as an interpretation in node Ref\n+\n+         --------------------------\n+         -- Inspect_Declarations --\n+         --------------------------\n+\n+         procedure Inspect_Declarations\n+           (Typ : Entity_Id;\n+            Ref : in out Node_Id)\n+         is\n+            Typ_Decl : constant Node_Id := Declaration_Node (Typ);\n+            Decl     : Node_Id;\n+            Subp_Id  : Entity_Id;\n+\n+         begin\n+            --  Ensure that the routine is not called with itypes which lack a\n+            --  declarative node.\n+\n+            pragma Assert (Present (Typ_Decl));\n+            pragma Assert (Is_List_Member (Typ_Decl));\n+\n+            Decl := First (List_Containing (Typ_Decl));\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Subprogram_Declaration then\n+                  Subp_Id := Defining_Entity (Decl);\n+\n+                  if Is_OK_Candidate (Subp_Id, Typ) then\n+                     Record_Interp (Subp_Id, Ref);\n+                  end if;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end Inspect_Declarations;\n+\n+         ------------------------\n+         -- Inspect_Primitives --\n+         ------------------------\n+\n+         procedure Inspect_Primitives\n+           (Typ : Entity_Id;\n+            Ref : in out Node_Id)\n+         is\n+            Prim_Elmt : Elmt_Id;\n+            Prim_Id   : Entity_Id;\n+\n+         begin\n+            Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+            while Present (Prim_Elmt) loop\n+               Prim_Id := Node (Prim_Elmt);\n+\n+               if Is_OK_Candidate (Prim_Id, Typ) then\n+                  Record_Interp (Prim_Id, Ref);\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end Inspect_Primitives;\n+\n+         ---------------------\n+         -- Is_OK_Candidate --\n+         ---------------------\n+\n+         function Is_OK_Candidate\n+           (Subp_Id : Entity_Id;\n+            Typ     : Entity_Id) return Boolean\n+         is\n+            Formal     : Entity_Id;\n+            Formal_Typ : Entity_Id;\n+            Param_Typ  : Node_Id;\n+\n+         begin\n+            --  The classify as a suitable candidate, the subprogram must be a\n+            --  function whose name matches the argument of aspect Constant or\n+            --  Variable_Indexing.\n+\n+            if Ekind (Subp_Id) = E_Function and then Chars (Subp_Id) = Nam then\n+               Formal := First_Formal (Subp_Id);\n+\n+               --  The candidate requires at least two parameters\n+\n+               if Present (Formal) and then Present (Next_Formal (Formal)) then\n+                  Formal_Typ := Empty;\n+                  Param_Typ  := Parameter_Type (Parent (Formal));\n+\n+                  --  Use the designated type when the first parameter is of an\n+                  --  access type.\n+\n+                  if Nkind (Param_Typ) = N_Access_Definition\n+                    and then Present (Subtype_Mark (Param_Typ))\n+                  then\n+                     --  When the context is a constant indexing, the access\n+                     --  definition must be access-to-constant. This does not\n+                     --  apply to variable indexing.\n+\n+                     if not Is_Constant\n+                       or else Constant_Present (Param_Typ)\n+                     then\n+                        Formal_Typ := Etype (Subtype_Mark (Param_Typ));\n+                     end if;\n+\n+                  --  Otherwise use the parameter type\n+\n+                  else\n+                     Formal_Typ := Etype (Param_Typ);\n+                  end if;\n+\n+                  if Present (Formal_Typ) then\n+\n+                     --  Use the specific type when the parameter type is\n+                     --  class-wide.\n+\n+                     if Is_Class_Wide_Type (Formal_Typ) then\n+                        Formal_Typ := Etype (Base_Type (Formal_Typ));\n+                     end if;\n+\n+                     --  Use the full view when the parameter type is private\n+                     --  or incomplete.\n+\n+                     if Is_Incomplete_Or_Private_Type (Formal_Typ)\n+                       and then Present (Full_View (Formal_Typ))\n+                     then\n+                        Formal_Typ := Full_View (Formal_Typ);\n+                     end if;\n+\n+                     --  The type of the first parameter must denote the type\n+                     --  of the container or acts as its ancestor type.\n+\n+                     return\n+                       Formal_Typ = Typ\n+                         or else Is_Ancestor (Formal_Typ, Typ);\n+                  end if;\n+               end if;\n+            end if;\n+\n+            return False;\n+         end Is_OK_Candidate;\n+\n+         -------------------\n+         -- Record_Interp --\n+         -------------------\n+\n+         procedure Record_Interp (Subp_Id : Entity_Id; Ref : in out Node_Id) is\n+         begin\n+            if Present (Ref) then\n+               Add_One_Interp (Ref, Subp_Id, Etype (Subp_Id));\n+\n+            --  Otherwise this is the first interpretation. Create a reference\n+            --  where all remaining interpretations will be collected.\n+\n+            else\n+               Ref := New_Occurrence_Of (Subp_Id, Sloc (T));\n+            end if;\n+         end Record_Interp;\n+\n+         --  Local variables\n+\n+         Ref : Node_Id;\n+         Typ : Entity_Id;\n+\n+      --  Start of processing for Find_Indexing_Operations\n+\n+      begin\n+         Typ := T;\n+\n+         if Is_Class_Wide_Type (Typ) then\n+            Typ := Root_Type (Typ);\n+         end if;\n+\n+         Ref := Empty;\n+         Typ := Underlying_Type (Typ);\n+\n+         Inspect_Primitives   (Typ, Ref);\n+         Inspect_Declarations (Typ, Ref);\n+\n+         return Ref;\n+      end Find_Indexing_Operations;\n+\n       --  Local variables\n \n       Loc       : constant Source_Ptr := Sloc (N);\n@@ -7381,6 +7599,11 @@ package body Sem_Ch4 is\n       Func_Name : Node_Id;\n       Indexing  : Node_Id;\n \n+      Is_Constant_Indexing : Boolean := False;\n+      --  This flag reflects the nature of the container indexing. Note that\n+      --  the context may be suited for constant indexing, but the type may\n+      --  lack a Constant_Indexing annotation.\n+\n    --  Start of processing for Try_Container_Indexing\n \n    begin\n@@ -7391,7 +7614,7 @@ package body Sem_Ch4 is\n          return True;\n       end if;\n \n-      C_Type := Etype (Prefix);\n+      C_Type := Pref_Typ;\n \n       --  If indexing a class-wide container, obtain indexing primitive from\n       --  specific type.\n@@ -7400,33 +7623,43 @@ package body Sem_Ch4 is\n          C_Type := Etype (Base_Type (C_Type));\n       end if;\n \n-      --  Check whether type has a specified indexing aspect\n+      --  Check whether type the has a specified indexing aspect\n \n       Func_Name := Empty;\n \n+      --  The context is suitable for constant indexing, obtain the name of the\n+      --  indexing function from aspect Constant_Indexing.\n+\n       if Constant_Indexing_OK then\n          Func_Name :=\n-           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Constant_Indexing);\n+           Find_Value_Of_Aspect (Pref_Typ, Aspect_Constant_Indexing);\n       end if;\n \n-      if No (Func_Name) then\n+      if Present (Func_Name) then\n+         Is_Constant_Indexing := True;\n+\n+      --  Otherwise attempt variable indexing\n+\n+      else\n          Func_Name :=\n-           Find_Value_Of_Aspect (Etype (Prefix), Aspect_Variable_Indexing);\n+           Find_Value_Of_Aspect (Pref_Typ, Aspect_Variable_Indexing);\n       end if;\n \n-      --  If aspect does not exist the expression is illegal. Error is\n-      --  diagnosed in caller.\n+      --  The type is not subject to either form of indexing, therefore the\n+      --  indexed component does not denote container indexing. If this is a\n+      --  true error, it is diagnosed by the caller.\n \n       if No (Func_Name) then\n \n-         --  The prefix itself may be an indexing of a container: rewrite as\n-         --  such and re-analyze.\n+         --  The prefix itself may be an indexing of a container. Rewrite it\n+         --  as such and retry.\n \n-         if Has_Implicit_Dereference (Etype (Prefix)) then\n-            Build_Explicit_Dereference\n-              (Prefix, First_Discriminant (Etype (Prefix)));\n+         if Has_Implicit_Dereference (Pref_Typ) then\n+            Build_Explicit_Dereference (Prefix, First_Discriminant (Pref_Typ));\n             return Try_Container_Indexing (N, Prefix, Exprs);\n \n+         --  Otherwise this is definitely not container indexing\n+\n          else\n             return False;\n          end if;\n@@ -7445,9 +7678,13 @@ package body Sem_Ch4 is\n       --  are derived from other types with a Reference aspect.\n \n       elsif Is_Derived_Type (C_Type)\n-        and then Etype (First_Formal (Entity (Func_Name))) /= Etype (Prefix)\n+        and then Etype (First_Formal (Entity (Func_Name))) /= Pref_Typ\n       then\n-         Func_Name := Find_Primitive_Operations (C_Type, Chars (Func_Name));\n+         Func_Name :=\n+           Find_Indexing_Operations\n+             (T           => C_Type,\n+              Nam         => Chars (Func_Name),\n+              Is_Constant => Is_Constant_Indexing);\n       end if;\n \n       Assoc := New_List (Relocate_Node (Prefix));"}, {"sha": "c02cb0f2e8c99cb7bd34b0abbbf6cc67bea7488d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/437244c7737eeb63973e1e285d5dc6844ab13f9f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=437244c7737eeb63973e1e285d5dc6844ab13f9f", "patch": "@@ -15034,6 +15034,18 @@ package body Sem_Prag is\n                      Id := Defining_Entity (Stmt);\n                      exit;\n \n+                  --  When pragma Ghost applies to an object declaration which\n+                  --  is initialized by means of a function call that returns\n+                  --  on the secondary stack, the object declaration becomes a\n+                  --  renaming.\n+\n+                  elsif Nkind (Stmt) = N_Object_Renaming_Declaration\n+                    and then Comes_From_Source (Orig_Stmt)\n+                    and then Nkind (Orig_Stmt) = N_Object_Declaration\n+                  then\n+                     Id := Defining_Entity (Stmt);\n+                     exit;\n+\n                   --  When pragma Ghost applies to an expression function, the\n                   --  expression function is transformed into a subprogram.\n "}]}