{"sha": "e38cf7336bb78c6e2234b273823e4a2581ea72e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4Y2Y3MzM2YmI3OGM2ZTIyMzRiMjczODIzZTRhMjU4MWVhNzJlNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-29T13:16:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-29T13:16:18Z"}, "message": "except.c (duplicate_eh_regions_0): Handle AKA bitmap.\n\n\t* except.c (duplicate_eh_regions_0): Handle AKA bitmap.\n\t(duplicate_eh_regions_1): Likewise.\n\t(duplicate_eh_regions): Likewise; cleanup code gorwing the region\n\tvector; call EH verification.\n\t(foreach_reachable_handler, can_throw_internal_1, can_throw_external_1):\n\tBe ready for region being removed.\n\nFrom-SVN: r145230", "tree": {"sha": "4e2736ef16b4efbcc231b2166efe21d2a23329bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e2736ef16b4efbcc231b2166efe21d2a23329bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e38cf7336bb78c6e2234b273823e4a2581ea72e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38cf7336bb78c6e2234b273823e4a2581ea72e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38cf7336bb78c6e2234b273823e4a2581ea72e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38cf7336bb78c6e2234b273823e4a2581ea72e6/comments", "author": null, "committer": null, "parents": [{"sha": "12802c2b3dfcb02d1a44be26c595643674583b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12802c2b3dfcb02d1a44be26c595643674583b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12802c2b3dfcb02d1a44be26c595643674583b20"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "964a4106f237d0944cde7a77a09b4778a01e10e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38cf7336bb78c6e2234b273823e4a2581ea72e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38cf7336bb78c6e2234b273823e4a2581ea72e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e38cf7336bb78c6e2234b273823e4a2581ea72e6", "patch": "@@ -1,3 +1,12 @@\n+2009-03-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (duplicate_eh_regions_0): Handle AKA bitmap.\n+\t(duplicate_eh_regions_1): Likewise.\n+\t(duplicate_eh_regions): Likewise; cleanup code gorwing the region\n+\tvector; call EH verification.\n+\t(foreach_reachable_handler, can_throw_internal_1, can_throw_external_1):\n+\tBe ready for region being removed.\n+\n 2009-03-29  Jan Hubicka  <jh@suse.cz>\n \n \t* bitmap.c (bitmap_last_set_bit): New function."}, {"sha": "9fad1563555e075d01fbc9be4d4bc9b7bd3ef1fd", "filename": "gcc/except.c", "status": "modified", "additions": 76, "deletions": 18, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e38cf7336bb78c6e2234b273823e4a2581ea72e6/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e38cf7336bb78c6e2234b273823e4a2581ea72e6/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e38cf7336bb78c6e2234b273823e4a2581ea72e6", "patch": "@@ -821,6 +821,17 @@ current_function_has_exception_handlers (void)\n static void\n duplicate_eh_regions_0 (eh_region o, int *min, int *max)\n {\n+  int i;\n+\n+  if (o->aka)\n+    {\n+      i = bitmap_first_set_bit (o->aka);\n+      if (i < *min)\n+\t*min = i;\n+      i = bitmap_last_set_bit (o->aka);\n+      if (i > *max)\n+\t*max = i;\n+    }\n   if (o->region_number < *min)\n     *min = o->region_number;\n   if (o->region_number > *max)\n@@ -852,7 +863,18 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n   *n = *old;\n   n->outer = outer;\n   n->next_peer = NULL;\n-  gcc_assert (!old->aka);\n+  if (old->aka)\n+    {\n+      unsigned i;\n+      bitmap_iterator bi;\n+      n->aka = BITMAP_GGC_ALLOC ();\n+\n+      EXECUTE_IF_SET_IN_BITMAP (old->aka, 0, i, bi)\n+      {\n+\tbitmap_set_bit (n->aka, i + eh_offset);\n+\tVEC_replace (eh_region, cfun->eh->region_array, i + eh_offset, n);\n+      }\n+    }\n \n   n->region_number += eh_offset;\n   VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n@@ -883,8 +905,11 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   int i, min_region, max_region, eh_offset, cfun_last_region_number;\n   int num_regions;\n \n-  if (!ifun->eh->region_tree)\n+  if (!ifun->eh)\n     return 0;\n+#ifdef ENABLE_CHECKING\n+  verify_eh_tree (ifun);\n+#endif\n \n   /* Find the range of region numbers to be copied.  The interface we \n      provide here mandates a single offset to find new number from old,\n@@ -905,23 +930,18 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   eh_offset = cfun_last_region_number + 1 - min_region;\n \n   /* If we've not yet created a region array, do so now.  */\n-  VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n-\t\t cfun_last_region_number + 1 + num_regions);\n-  cfun->eh->last_region_number = max_region + eh_offset;\n-\n-  /* We may have just allocated the array for the first time.\n-     Make sure that element zero is null.  */\n-  VEC_replace (eh_region, cfun->eh->region_array, 0, 0);\n-\n-  /* Zero all entries in the range allocated.  */\n-  memset (VEC_address (eh_region, cfun->eh->region_array)\n-\t  + cfun_last_region_number + 1, 0, num_regions * sizeof (eh_region));\n+  cfun->eh->last_region_number = cfun_last_region_number + num_regions;\n+  VEC_safe_grow_cleared (eh_region, gc, cfun->eh->region_array,\n+\t\t\t cfun->eh->last_region_number + 1);\n \n   /* Locate the spot at which to insert the new tree.  */\n   if (outer_region > 0)\n     {\n       outer = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n-      splice = &outer->inner;\n+      if (outer)\n+\tsplice = &outer->inner;\n+      else\n+\tsplice = &cfun->eh->region_tree;\n     }\n   else\n     {\n@@ -931,6 +951,20 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   while (*splice)\n     splice = &(*splice)->next_peer;\n \n+  if (!ifun->eh->region_tree)\n+    {\n+      if (outer)\n+\tfor (i = cfun_last_region_number + 1;\n+\t     i <= cfun->eh->last_region_number; i++)\n+\t  {\n+\t    VEC_replace (eh_region, cfun->eh->region_array, i, outer);\n+\t    if (outer->aka == NULL)\n+\t      outer->aka = BITMAP_GGC_ALLOC ();\n+\t    bitmap_set_bit (outer->aka, i);\n+\t  }\n+      return eh_offset;\n+    }\n+\n   /* Copy all the regions in the subtree.  */\n   if (copy_region > 0)\n     {\n@@ -960,9 +994,9 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n      the prev_try short-cuts for ERT_CLEANUP regions.  */\n   prev_try = NULL;\n   if (outer_region > 0)\n-    for (prev_try = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n-         prev_try && prev_try->type != ERT_TRY;\n-\t prev_try = prev_try->outer)\n+    for (prev_try =\n+\t VEC_index (eh_region, cfun->eh->region_array, outer_region);\n+\t prev_try && prev_try->type != ERT_TRY; prev_try = prev_try->outer)\n       if (prev_try->type == ERT_MUST_NOT_THROW\n \t  || (prev_try->type == ERT_ALLOWED_EXCEPTIONS\n \t      && !prev_try->u.allowed.type_list))\n@@ -978,7 +1012,23 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   for (i = cfun_last_region_number + 1;\n        VEC_iterate (eh_region, cfun->eh->region_array, i, cur); ++i)\n     {\n+      /* All removed EH that is toplevel in input function is now\n+         in outer EH of output function.  */\n       if (cur == NULL)\n+\t{\n+\t  gcc_assert (VEC_index\n+\t\t      (eh_region, ifun->eh->region_array,\n+\t\t       i - eh_offset) == NULL);\n+\t  if (outer)\n+\t    {\n+\t      VEC_replace (eh_region, cfun->eh->region_array, i, outer);\n+\t      if (outer->aka == NULL)\n+\t\touter->aka = BITMAP_GGC_ALLOC ();\n+\t      bitmap_set_bit (outer->aka, i);\n+\t    }\n+\t  continue;\n+\t}\n+      if (i != cur->region_number)\n \tcontinue;\n \n #define REMAP(REG) \\\n@@ -1014,6 +1064,9 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \n #undef REMAP\n     }\n+#ifdef ENABLE_CHECKING\n+  verify_eh_tree (cfun);\n+#endif\n \n   return eh_offset;\n }\n@@ -2316,7 +2369,6 @@ struct reachable_info\n   tree types_allowed;\n   void (*callback) (struct eh_region *, void *);\n   void *callback_data;\n-  bool saw_any_handlers;\n };\n \n /* A subroutine of reachable_next_level.  Return true if TYPE, or a\n@@ -2552,6 +2604,8 @@ foreach_reachable_handler (int region_number, bool is_resx, bool inlinable_call,\n   info.callback_data = callback_data;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n+  if (!region)\n+    return;\n \n   type_thrown = NULL_TREE;\n   if (is_resx)\n@@ -2642,6 +2696,8 @@ can_throw_internal_1 (int region_number, bool is_resx, bool inlinable_call)\n   tree type_thrown;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n+  if (!region)\n+    return false;\n \n   type_thrown = NULL_TREE;\n   if (is_resx)\n@@ -2703,6 +2759,8 @@ can_throw_external_1 (int region_number, bool is_resx, bool inlinable_call)\n   tree type_thrown;\n \n   region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n+  if (!region)\n+    return true;\n \n   type_thrown = NULL_TREE;\n   if (is_resx)"}]}