{"sha": "0bceb671062a463aadcf0059e19308845d713838", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJjZWI2NzEwNjJhNDYzYWFkY2YwMDU5ZTE5MzA4ODQ1ZDcxMzgzOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-05-23T10:59:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-23T10:59:35Z"}, "message": "ipa-inline-analysis.c (cgraph_2edge_hook_list, [...]): Remove.\n\n\n\t* ipa-inline-analysis.c (cgraph_2edge_hook_list, cgraph_edge_hook_list,\n\tinline_edge_removal_hook, inline_edge_duplication_hook): Remove.\n\t(inline_edge_summary_vec): Turn into ...\n\t(ipa_call_summaries): ... this one.\n\t(redirect_to_unreachable, edge_set_predicate,\n\tevaluate_properties_for_edge, inline_summary_alloc,\n\treset_ipa_call_summary, reset_inline_summary,\n\tinline_summary_t::duplicate): Update.\n\t(inline_edge_duplication_hook): Turn to ...\n\t(ipa_call_summary_t::duplicate): ... this one.\n\t(inline_edge_removal_hook): Turn to ...\n\t(ipa_call_summary_t::remove): ... this one.\n\t(dump_inline_edge_summary): Turn to ...\n\t(dump_ipa_call_summary): ... this one.\n\t(estimate_function_body_sizes): Update.\n\t(inline_update_callee_summaries): Update.\n\t(remap_edge_change_prob): Update.\n\t(remap_edge_summaries): Update.\n\t(inline_merge_summary): Update.\n\t(do_estimate_edge_time): Update.\n\t(inline_generate_summary): Update.\n\t(inline_read_section): Update.\n\t(inline_read_summary): Update.\n\t(inline_free_summary): Update.\n\t* ipa-inline.c (can_inline_edge_p): Update.\n\t(compute_inlined_call_time): Update.\n\t(want_inline_small_function_p): Update.\n\t(edge_badness): Update.\n\t(early_inliner): Update.\n\t* ipa-inline.h (inline_edge_summary): Turn to ...\n\t(ipa_call_summary): ... this one.\n\t(ipa_call_summary_t): New class.\n\t(inline_edge_summary_t, inline_edge_summary_vec): Remove.\n\t(ipa_call_summaries): New.\n\t(inline_edge_summary): Remove.\n\t(estimate_edge_growth): Update.\n\t* ipa-profile.c (ipa_propagate_frequency_1): Update.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n\t* ipa-split.c (execute_split_functions): Update.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Update.\n\nFrom-SVN: r248365", "tree": {"sha": "425d7dbe0a550b23ed410622c3ab724602dd8077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/425d7dbe0a550b23ed410622c3ab724602dd8077"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bceb671062a463aadcf0059e19308845d713838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bceb671062a463aadcf0059e19308845d713838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bceb671062a463aadcf0059e19308845d713838", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bceb671062a463aadcf0059e19308845d713838/comments", "author": null, "committer": null, "parents": [{"sha": "9d029ddfdadd3a469a8069ff498a29df8cdb5393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d029ddfdadd3a469a8069ff498a29df8cdb5393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d029ddfdadd3a469a8069ff498a29df8cdb5393"}], "stats": {"total": 600, "additions": 320, "deletions": 280}, "files": [{"sha": "b45cd01b68cb5ee2f485174dc7273477270610bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -1,3 +1,46 @@\n+2017-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (cgraph_2edge_hook_list, cgraph_edge_hook_list,\n+\tinline_edge_removal_hook, inline_edge_duplication_hook): Remove.\n+\t(inline_edge_summary_vec): Turn into ...\n+\t(ipa_call_summaries): ... this one.\n+\t(redirect_to_unreachable, edge_set_predicate,\n+\tevaluate_properties_for_edge, inline_summary_alloc,\n+\treset_ipa_call_summary, reset_inline_summary,\n+\tinline_summary_t::duplicate): Update.\n+\t(inline_edge_duplication_hook): Turn to ...\n+\t(ipa_call_summary_t::duplicate): ... this one.\n+\t(inline_edge_removal_hook): Turn to ...\n+\t(ipa_call_summary_t::remove): ... this one.\n+\t(dump_inline_edge_summary): Turn to ...\n+\t(dump_ipa_call_summary): ... this one.\n+\t(estimate_function_body_sizes): Update.\n+\t(inline_update_callee_summaries): Update.\n+\t(remap_edge_change_prob): Update.\n+\t(remap_edge_summaries): Update.\n+\t(inline_merge_summary): Update.\n+\t(do_estimate_edge_time): Update.\n+\t(inline_generate_summary): Update.\n+\t(inline_read_section): Update.\n+\t(inline_read_summary): Update.\n+\t(inline_free_summary): Update.\n+\t* ipa-inline.c (can_inline_edge_p): Update.\n+\t(compute_inlined_call_time): Update.\n+\t(want_inline_small_function_p): Update.\n+\t(edge_badness): Update.\n+\t(early_inliner): Update.\n+\t* ipa-inline.h (inline_edge_summary): Turn to ...\n+\t(ipa_call_summary): ... this one.\n+\t(ipa_call_summary_t): New class.\n+\t(inline_edge_summary_t, inline_edge_summary_vec): Remove.\n+\t(ipa_call_summaries): New.\n+\t(inline_edge_summary): Remove.\n+\t(estimate_edge_growth): Update.\n+\t* ipa-profile.c (ipa_propagate_frequency_1): Update.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): Update.\n+\t* ipa-split.c (execute_split_functions): Update.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Update.\n+\n 2017-05-23  Tom de Vries  <tom@codesourcery.com>\n \n \t* doc/sourcebuild.texi (Effective-Target Keywords, Other hardware"}, {"sha": "5c6b505d06bd48bd3461a6011d45d147e2f6d25b", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -1468,7 +1468,7 @@ afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n           current_function_decl) == NULL)\n     return false;\n \n-  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+  compute_fn_summary (cgraph_node::get (current_function_decl), true);\n \n   bool has_vpt = false;\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -1592,7 +1592,7 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n static void\n early_inline ()\n {\n-  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+  compute_fn_summary (cgraph_node::get (current_function_decl), true);\n   unsigned todo = early_inliner (cfun);\n   if (todo & TODO_update_ssa_any)\n     update_ssa (TODO_update_ssa);\n@@ -1670,7 +1670,7 @@ auto_profile (void)\n     free_dominance_info (CDI_DOMINATORS);\n     free_dominance_info (CDI_POST_DOMINATORS);\n     cgraph_edge::rebuild_edges ();\n-    compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+    compute_fn_summary (cgraph_node::get (current_function_decl), true);\n     pop_cfun ();\n   }\n "}, {"sha": "f27e2419390bfddb06cd1711ca1bd87dbdddfbbe", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -1389,7 +1389,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* True if this decl is a dispatcher for function versions.  */\n   unsigned dispatcher_function : 1;\n   /* True if this decl calls a COMDAT-local function.  This is set up in\n-     compute_inline_parameters and inline_call.  */\n+     compute_fn_summary and inline_call.  */\n   unsigned calls_comdat_local : 1;\n   /* True if node has been created by merge operation in IPA-ICF.  */\n   unsigned icf_merged: 1;"}, {"sha": "c1f4293778c428544eeaef4a6ccf0c2689217467", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -332,9 +332,17 @@ symbol_table::process_new_functions (void)\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  if ((state == IPA_SSA || state == IPA_SSA_AFTER_INLINING)\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n-\t    g->get_passes ()->execute_early_local_passes ();\n-\t  else if (inline_summaries != NULL)\n-\t    compute_inline_parameters (node, true);\n+\t    {\n+\t      bool summaried_computed = ipa_fn_summaries != NULL;\n+\t      g->get_passes ()->execute_early_local_passes ();\n+\t      /* Early passes compure inline parameters to do inlining\n+\t\t and splitting.  This is redundant for functions added late.\n+\t\t Just throw away whatever it did.  */\n+\t      if (!summaried_computed)\n+\t\tinline_free_summary ();\n+\t    }\n+\t  else if (ipa_fn_summaries != NULL)\n+\t    compute_fn_summary (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  pop_cfun ();"}, {"sha": "e68a151c753553fa42eb0d96b399d774ecfe517e", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -708,7 +708,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   init_caller_stats (&stats);\n   node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n-  if (inline_summaries->get (node)->self_size < stats.n_calls)\n+  if (ipa_fn_summaries->get (node)->self_size < stats.n_calls)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n@@ -2540,7 +2540,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n   for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n     {\n       struct cgraph_node *callee;\n-      struct inline_summary *isummary;\n+      struct ipa_fn_summary *isummary;\n       enum availability avail;\n       tree target;\n       bool speculative;\n@@ -2558,7 +2558,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       callee = callee->function_symbol (&avail);\n       if (avail < AVAIL_AVAILABLE)\n \tcontinue;\n-      isummary = inline_summaries->get (callee);\n+      isummary = ipa_fn_summaries->get (callee);\n       if (!isummary->inlinable)\n \tcontinue;\n \n@@ -2579,7 +2579,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n /* Return time bonus incurred because of HINTS.  */\n \n static int\n-hint_time_bonus (inline_hints hints)\n+hint_time_bonus (ipa_hints hints)\n {\n   int result = 0;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n@@ -2797,7 +2797,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n {\n   int size, time_benefit;\n   sreal time, base_time;\n-  inline_hints hints;\n+  ipa_hints hints;\n \n   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n \t\t\t\t     known_aggs_ptrs, &size, &time,\n@@ -2855,7 +2855,7 @@ estimate_local_effects (struct cgraph_node *node)\n       || (removable_params_cost && node->local.can_change_signature))\n     {\n       struct caller_statistics stats;\n-      inline_hints hints;\n+      ipa_hints hints;\n       sreal time, base_time;\n       int size;\n \n@@ -3258,7 +3258,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \tinitialize_node_lattices (node);\n       }\n     if (node->definition && !node->alias)\n-      overall_size += inline_summaries->get (node)->self_size;\n+      overall_size += ipa_fn_summaries->get (node)->self_size;\n     if (node->count > max_count)\n       max_count = node->count;\n   }\n@@ -3342,7 +3342,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n     }\n   /* Turning calls to direct calls will improve overall summary.  */\n   if (found)\n-    inline_update_overall_summary (node);\n+    ipa_update_overall_fn_summary (node);\n }\n \n /* Vector of pointers which for linked lists of clones of an original crgaph"}, {"sha": "0d1e629dcebf6bf37ab5bc99000881c796ef29e7", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -3771,7 +3771,7 @@ ipa_devirt (void)\n \t      }\n \t  }\n       if (update)\n-\tinline_update_overall_summary (n);\n+\tipa_update_overall_fn_summary (n);\n     }\n   if (warn_suggest_final_methods || warn_suggest_final_types)\n     {"}, {"sha": "d9006d1e21893c0467046cec676670859e7fd820", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 118, "deletions": 120, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -27,12 +27,12 @@ along with GCC; see the file COPYING3.  If not see\n    For each call\n      - call statement size, time and how often the parameters change\n \n-   inline_summary data structures store above information locally (i.e.\n+   ipa_fn_summary data structures store above information locally (i.e.\n    parameters of the function itself) and globally (i.e. parameters of\n    the function created by applying all the inline decisions already\n    present in the callgraph).\n \n-   We provide access to the inline_summary data structure and\n+   We provide access to the ipa_fn_summary data structure and\n    basic logic updating the parameters when inlining is performed. \n \n    The summaries are context sensitive.  Context means\n@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n    we use predicates.\n \n    estimate_edge_size_and_time can be used to query\n-   function size/time in the given context.  inline_merge_summary merges\n+   function size/time in the given context.  ipa_merge_fn_summary_after_inlining merges\n    properties of caller and callee after inlining.\n \n    Finally pass_inline_parameters is exported.  This is used to drive\n@@ -84,20 +84,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n \n /* Summaries.  */\n-function_summary <inline_summary *> *inline_summaries;\n+function_summary <ipa_fn_summary *> *ipa_fn_summaries;\n call_summary <ipa_call_summary *> *ipa_call_summaries;\n \n /* Edge predicates goes here.  */\n static object_allocator<predicate> edge_predicate_pool (\"edge predicates\");\n \n \n-/* Dump inline hints.  */\n+/* Dump IPA hints.  */\n void\n-dump_inline_hints (FILE *f, inline_hints hints)\n+ipa_dump_hints (FILE *f, ipa_hints hints)\n {\n   if (!hints)\n     return;\n-  fprintf (f, \"inline hints:\");\n+  fprintf (f, \"IPA hints:\");\n   if (hints & INLINE_HINT_indirect_call)\n     {\n       hints &= ~INLINE_HINT_indirect_call;\n@@ -153,7 +153,7 @@ dump_inline_hints (FILE *f, inline_hints hints)\n    will get optimized out in specialized clones of the function.   */\n \n void\n-inline_summary::account_size_time (int size, sreal time,\n+ipa_fn_summary::account_size_time (int size, sreal time,\n \t\t\t\t   const predicate &exec_pred,\n \t\t\t\t   const predicate &nonconst_pred_in)\n {\n@@ -198,7 +198,7 @@ inline_summary::account_size_time (int size, sreal time,\n     {\n       fprintf (dump_file,\n \t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate exec:\",\n-\t       ((double) size) / INLINE_SIZE_SCALE,\n+\t       ((double) size) / ipa_fn_summary::size_scale,\n \t       (time.to_double ()), found ? \"\" : \"new \");\n       exec_pred.dump (dump_file, conds, 0);\n       if (exec_pred != nonconst_pred)\n@@ -257,7 +257,8 @@ static void\n edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n {\n   /* If the edge is determined to be never executed, redirect it\n-     to BUILTIN_UNREACHABLE to save inliner from inlining into it.  */\n+     to BUILTIN_UNREACHABLE to make it clear to IPA passes the call will\n+     be optimized out.  */\n   if (predicate && *predicate == false\n       /* When handling speculative edges, we need to do the redirection\n          just once.  Do it always on the direct edge, so we do not\n@@ -327,7 +328,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n   clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n-  struct inline_summary *info = inline_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   int i;\n   struct condition *c;\n \n@@ -427,7 +428,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  struct inline_summary *info = inline_summaries->get (callee);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n@@ -522,15 +523,14 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n }\n \n \n-/* Allocate the inline summary vector or resize it to cover all cgraph nodes. */\n+/* Allocate the function summary. */\n \n static void\n-inline_summary_alloc (void)\n+ipa_fn_summary_alloc (void)\n {\n-  if (!inline_summaries)\n-    inline_summaries = inline_summary_t::create_ggc (symtab);\n-  if (!ipa_call_summaries)\n-    ipa_call_summaries = new ipa_call_summary_t (symtab, false);\n+  gcc_checking_assert (!ipa_fn_summaries);\n+  ipa_fn_summaries = ipa_fn_summary_t::create_ggc (symtab);\n+  ipa_call_summaries = new ipa_call_summary_t (symtab, false);\n }\n \n /* We are called multiple time for given function; clear\n@@ -550,7 +550,7 @@ ipa_call_summary::reset ()\n    data from previous run so they are not cumulated.  */\n \n void\n-inline_summary::reset (struct cgraph_node *node)\n+ipa_fn_summary::reset (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n \n@@ -589,7 +589,7 @@ inline_summary::reset (struct cgraph_node *node)\n /* Hook that is called by cgraph.c when a node is removed.  */\n \n void\n-inline_summary_t::remove (cgraph_node *node, inline_summary *info)\n+ipa_fn_summary_t::remove (cgraph_node *node, ipa_fn_summary *info)\n {\n   info->reset (node);\n }\n@@ -617,13 +617,12 @@ remap_hint_predicate_after_duplication (predicate **p,\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n void\n-inline_summary_t::duplicate (cgraph_node *src,\n+ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t\t\t     cgraph_node *dst,\n-\t\t\t     inline_summary *,\n-\t\t\t     inline_summary *info)\n+\t\t\t     ipa_fn_summary *,\n+\t\t\t     ipa_fn_summary *info)\n {\n-  inline_summary_alloc ();\n-  memcpy (info, inline_summaries->get (src), sizeof (inline_summary));\n+  memcpy (info, ipa_fn_summaries->get (src), sizeof (ipa_fn_summary));\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n@@ -708,7 +707,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t  new_predicate = es->predicate->remap_after_duplication\n \t    (possible_truths);\n \t  if (new_predicate == false && *es->predicate != false)\n-\t    optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n+\t    optimized_out_size += es->call_stmt_size * ipa_fn_summary::size_scale;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n \n@@ -726,7 +725,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t  new_predicate = es->predicate->remap_after_duplication\n \t\t\t\t (possible_truths);\n \t  if (new_predicate == false && *es->predicate != false)\n-\t    optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n+\t    optimized_out_size += es->call_stmt_size * ipa_fn_summary::size_scale;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n       remap_hint_predicate_after_duplication (&info->loop_iterations,\n@@ -765,7 +764,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n \t}\n     }\n   if (!dst->global.inlined_to)\n-    inline_update_overall_summary (dst);\n+    ipa_update_overall_fn_summary (dst);\n }\n \n \n@@ -806,7 +805,7 @@ ipa_call_summary_t::remove (struct cgraph_edge *,\n \n static void\n dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n-\t\t       struct inline_summary *info)\n+\t\t       struct ipa_fn_summary *info)\n {\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n@@ -823,8 +822,8 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->frequency,\n \t       es->call_stmt_size, es->call_stmt_time,\n-\t       (int) inline_summaries->get (callee)->size / INLINE_SIZE_SCALE,\n-\t       (int) inline_summaries->get (callee)->estimated_stack_size);\n+\t       (int) ipa_fn_summaries->get (callee)->size / ipa_fn_summary::size_scale,\n+\t       (int) ipa_fn_summaries->get (callee)->estimated_stack_size);\n \n       if (es->predicate)\n \t{\n@@ -850,9 +849,9 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t  fprintf (f, \"%*sStack frame offset %i, callee self size %i,\"\n \t\t   \" callee size %i\\n\",\n \t\t   indent + 2, \"\",\n-\t\t   (int) inline_summaries->get (callee)->stack_frame_offset,\n-\t\t   (int) inline_summaries->get (callee)->estimated_self_stack_size,\n-\t\t   (int) inline_summaries->get (callee)->estimated_stack_size);\n+\t\t   (int) ipa_fn_summaries->get (callee)->stack_frame_offset,\n+\t\t   (int) ipa_fn_summaries->get (callee)->estimated_self_stack_size,\n+\t\t   (int) ipa_fn_summaries->get (callee)->estimated_stack_size);\n \t  dump_ipa_call_summary (f, indent + 2, callee, info);\n \t}\n     }\n@@ -876,14 +875,14 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \n \n void\n-dump_inline_summary (FILE *f, struct cgraph_node *node)\n+ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->definition)\n     {\n-      struct inline_summary *s = inline_summaries->get (node);\n+      struct ipa_fn_summary *s = ipa_fn_summaries->get (node);\n       size_time_entry *e;\n       int i;\n-      fprintf (f, \"Inline summary for %s/%i\", node->name (),\n+      fprintf (f, \"IPA function summary for %s/%i\", node->name (),\n \t       node->order);\n       if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n \tfprintf (f, \" always_inline\");\n@@ -907,7 +906,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n       for (i = 0; vec_safe_iterate (s->size_time_table, i, &e); i++)\n \t{\n \t  fprintf (f, \"    size:%f, time:%f\",\n-\t\t   (double) e->size / INLINE_SIZE_SCALE,\n+\t\t   (double) e->size / ipa_fn_summary::size_scale,\n \t\t   e->time.to_double ());\n \t  if (e->exec_predicate != true)\n \t    {\n@@ -943,19 +942,19 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n }\n \n DEBUG_FUNCTION void\n-debug_inline_summary (struct cgraph_node *node)\n+ipa_debug_fn_summary (struct cgraph_node *node)\n {\n-  dump_inline_summary (stderr, node);\n+  ipa_dump_fn_summary (stderr, node);\n }\n \n void\n-dump_inline_summaries (FILE *f)\n+ipa_dump_fn_summaries (FILE *f)\n {\n   struct cgraph_node *node;\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to)\n-      dump_inline_summary (f, node);\n+      ipa_dump_fn_summary (f, node);\n }\n \n /* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n@@ -1207,7 +1206,7 @@ eliminated_by_inlining_prob (gimple *stmt)\n \n static void\n set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t\t   struct inline_summary *summary,\n+\t\t\t\t   struct ipa_fn_summary *summary,\n \t\t\t\t   basic_block bb)\n {\n   gimple *last;\n@@ -1292,7 +1291,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \n static void\n set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t\t     struct inline_summary *summary,\n+\t\t\t\t     struct ipa_fn_summary *summary,\n \t\t\t\t     basic_block bb)\n {\n   gimple *lastg;\n@@ -1358,7 +1357,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n static void\n compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t       struct cgraph_node *node,\n-\t\t       struct inline_summary *summary)\n+\t\t       struct ipa_fn_summary *summary)\n {\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   bool done = false;\n@@ -1431,7 +1430,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \n static predicate\n will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n-\t\t\t\t    struct inline_summary *summary,\n+\t\t\t\t    struct ipa_fn_summary *summary,\n \t\t\t\t    tree expr,\n \t\t\t\t    vec<predicate> nonconstant_names)\n {\n@@ -1498,7 +1497,7 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n \n static predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t       struct inline_summary *summary,\n+\t\t\t       struct ipa_fn_summary *summary,\n \t\t\t       gimple *stmt,\n \t\t\t       vec<predicate> nonconstant_names)\n {\n@@ -1728,7 +1727,7 @@ param_change_prob (gimple *stmt, int i)\n \n static bool\n phi_result_unknown_predicate (struct ipa_node_params *info,\n-\t\t\t      inline_summary *summary, basic_block bb,\n+\t\t\t      ipa_fn_summary *summary, basic_block bb,\n \t\t\t      predicate *p,\n \t\t\t      vec<predicate> nonconstant_names)\n {\n@@ -1787,7 +1786,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n    NONCONSTANT_NAMES, if possible.  */\n \n static void\n-predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n+predicate_for_phi_result (struct ipa_fn_summary *summary, gphi *phi,\n \t\t\t  predicate *p,\n \t\t\t  vec<predicate> nonconstant_names)\n {\n@@ -1817,7 +1816,7 @@ predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n /* Return predicate specifying when array index in access OP becomes non-constant.  */\n \n static predicate\n-array_index_predicate (inline_summary *info,\n+array_index_predicate (ipa_fn_summary *info,\n \t\t       vec< predicate> nonconstant_names, tree op)\n {\n   predicate p = false;\n@@ -1970,12 +1969,11 @@ fp_expression_p (gimple *stmt)\n   return false;\n }\n \n-/* Compute function body size parameters for NODE.\n-   When EARLY is true, we compute only simple summaries without\n-   non-trivial predicates to drive the early inliner.  */\n+/* Analyze function body for NODE.\n+   EARLY indicates run from early optimization pipeline.  */\n \n static void\n-estimate_function_body_sizes (struct cgraph_node *node, bool early)\n+analyze_function_body (struct cgraph_node *node, bool early)\n {\n   sreal time = 0;\n   /* Estimate static overhead for function prologue/epilogue and alignment. */\n@@ -1985,7 +1983,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   basic_block bb;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n-  struct inline_summary *info = inline_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate> nonconstant_names = vNULL;\n@@ -2040,7 +2038,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   info->account_size_time (0, 0, bb_predicate, bb_predicate);\n \n   bb_predicate = predicate::not_inlined ();\n-  info->account_size_time (2 * INLINE_SIZE_SCALE, 0, bb_predicate,\n+  info->account_size_time (2 * ipa_fn_summary::size_scale, 0, bb_predicate,\n \t\t           bb_predicate);\n \n   if (fbi.info)\n@@ -2253,7 +2251,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t}\n     }\n-  set_hint_predicate (&inline_summaries->get (node)->array_index, array_index);\n+  set_hint_predicate (&ipa_fn_summaries->get (node)->array_index, array_index);\n   time = time / CGRAPH_FREQ_BASE;\n   free (order);\n \n@@ -2339,9 +2337,9 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t    }\n \t  free (body);\n \t}\n-      set_hint_predicate (&inline_summaries->get (node)->loop_iterations,\n+      set_hint_predicate (&ipa_fn_summaries->get (node)->loop_iterations,\n \t\t\t  loop_iterations);\n-      set_hint_predicate (&inline_summaries->get (node)->loop_stride,\n+      set_hint_predicate (&ipa_fn_summaries->get (node)->loop_stride,\n \t\t\t  loop_stride);\n       scev_finalize ();\n     }\n@@ -2360,8 +2358,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  e->aux = NULL;\n \t}\n     }\n-  inline_summaries->get (node)->time = time;\n-  inline_summaries->get (node)->self_size = size;\n+  ipa_fn_summaries->get (node)->time = time;\n+  ipa_fn_summaries->get (node)->self_size = size;\n   nonconstant_names.release ();\n   ipa_release_body_info (&fbi);\n   if (opt_for_fn (node->decl, optimize))\n@@ -2375,26 +2373,27 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n\");\n-      dump_inline_summary (dump_file, node);\n+      ipa_dump_fn_summary (dump_file, node);\n     }\n }\n \n \n-/* Compute parameters of functions used by inliner.\n-   EARLY is true when we compute parameters for the early inliner  */\n+/* Compute function summary.\n+   EARLY is true when we compute parameters during early opts.  */\n \n void\n-compute_inline_parameters (struct cgraph_node *node, bool early)\n+compute_fn_summary (struct cgraph_node *node, bool early)\n {\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n-  struct inline_summary *info;\n+  struct ipa_fn_summary *info;\n \n   gcc_assert (!node->global.inlined_to);\n \n-  inline_summary_alloc ();\n+  if (!ipa_fn_summaries)\n+    ipa_fn_summary_alloc ();\n \n-  info = inline_summaries->get (node);\n+  info = ipa_fn_summaries->get (node);\n   info->reset (node);\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n@@ -2412,10 +2411,10 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       node->local.can_change_signature = false;\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n-      info->account_size_time (INLINE_SIZE_SCALE * 2, 2, t, t);\n+      info->account_size_time (ipa_fn_summary::size_scale * 2, 2, t, t);\n       t = predicate::not_inlined ();\n-      info->account_size_time (2 * INLINE_SIZE_SCALE, 0, t, t);\n-      inline_update_overall_summary (node);\n+      info->account_size_time (2 * ipa_fn_summary::size_scale, 0, t, t);\n+      ipa_update_overall_fn_summary (node);\n       info->self_size = info->size;\n       /* We can not inline instrumentation clones.  */\n       if (node->thunk.add_pointer_bounds_args)\n@@ -2474,7 +2473,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \t       node->local.can_change_signature = false;\n \t       break;\n \t     }\n-       estimate_function_body_sizes (node, early);\n+       analyze_function_body (node, early);\n        pop_cfun ();\n      }\n   for (e = node->callees; e; e = e->next_callee)\n@@ -2488,9 +2487,9 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->estimated_stack_size = info->estimated_self_stack_size;\n \n   /* Code above should compute exactly the same result as\n-     inline_update_overall_summary but because computation happens in\n+     ipa_update_overall_fn_summary but because computation happens in\n      different order the roundoff errors result in slight changes.  */\n-  inline_update_overall_summary (node);\n+  ipa_update_overall_fn_summary (node);\n   gcc_assert (info->size == info->self_size);\n }\n \n@@ -2499,9 +2498,9 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n    current_function_decl.  */\n \n static unsigned int\n-compute_inline_parameters_for_current (void)\n+compute_fn_summary_for_current (void)\n {\n-  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n+  compute_fn_summary (cgraph_node::get (current_function_decl), true);\n   return 0;\n }\n \n@@ -2531,7 +2530,7 @@ class pass_inline_parameters : public gimple_opt_pass\n   opt_pass * clone () { return new pass_inline_parameters (m_ctxt); }\n   virtual unsigned int execute (function *)\n     {\n-      return compute_inline_parameters_for_current ();\n+      return compute_fn_summary_for_current ();\n     }\n \n }; // class pass_inline_parameters\n@@ -2557,7 +2556,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n {\n   tree target;\n   struct cgraph_node *callee;\n-  struct inline_summary *isummary;\n+  struct ipa_fn_summary *isummary;\n   enum availability avail;\n   bool speculative;\n \n@@ -2583,7 +2582,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   callee = callee->function_symbol (&avail);\n   if (avail < AVAIL_AVAILABLE)\n     return false;\n-  isummary = inline_summaries->get (callee);\n+  isummary = ipa_fn_summaries->get (callee);\n   return isummary->inlinable;\n }\n \n@@ -2600,7 +2599,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t     inline_hints *hints)\n+\t\t\t     ipa_hints *hints)\n {\n   struct ipa_call_summary *es = ipa_call_summaries->get (e);\n   int call_size = es->call_stmt_size;\n@@ -2611,7 +2610,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t\t       known_vals, known_contexts, known_aggs)\n       && hints && e->maybe_hot_p ())\n     *hints |= INLINE_HINT_indirect_call;\n-  cur_size = call_size * INLINE_SIZE_SCALE;\n+  cur_size = call_size * ipa_fn_summary::size_scale;\n   *size += cur_size;\n   if (min_size)\n     *min_size += cur_size;\n@@ -2631,7 +2630,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t\t\t      int *min_size, sreal *time,\n-\t\t\t      inline_hints *hints,\n+\t\t\t      ipa_hints *hints,\n \t\t\t      clause_t possible_truths,\n \t\t\t      vec<tree> known_vals,\n \t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n@@ -2702,16 +2701,16 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     int *ret_size, int *ret_min_size,\n \t\t\t     sreal *ret_time,\n \t\t\t     sreal *ret_nonspecialized_time,\n-\t\t\t     inline_hints *ret_hints,\n+\t\t\t     ipa_hints *ret_hints,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n {\n-  struct inline_summary *info = inline_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   size_time_entry *e;\n   int size = 0;\n   sreal time = 0;\n   int min_size = 0;\n-  inline_hints hints = 0;\n+  ipa_hints hints = 0;\n   int i;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2804,8 +2803,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (DECL_DECLARED_INLINE_P (node->decl))\n     hints |= INLINE_HINT_declared_inline;\n \n-  size = RDIV (size, INLINE_SIZE_SCALE);\n-  min_size = RDIV (min_size, INLINE_SIZE_SCALE);\n+  size = RDIV (size, ipa_fn_summary::size_scale);\n+  min_size = RDIV (min_size, ipa_fn_summary::size_scale);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n   size:%i time:%f nonspec time:%f\\n\", (int) size,\n@@ -2837,7 +2836,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t\t   int *ret_size, sreal *ret_time,\n \t\t\t\t   sreal *ret_nonspec_time,\n-\t\t\t\t   inline_hints *hints)\n+\t\t\t\t   ipa_hints *hints)\n {\n   clause_t clause, nonspec_clause;\n \n@@ -2857,17 +2856,17 @@ static void\n inline_update_callee_summaries (struct cgraph_node *node, int depth)\n {\n   struct cgraph_edge *e;\n-  struct inline_summary *callee_info = inline_summaries->get (node);\n-  struct inline_summary *caller_info = inline_summaries->get (node->callers->caller);\n+  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (node);\n+  struct ipa_fn_summary *caller_info = ipa_fn_summaries->get (node->callers->caller);\n   HOST_WIDE_INT peak;\n \n   callee_info->stack_frame_offset\n     = caller_info->stack_frame_offset\n     + caller_info->estimated_self_stack_size;\n   peak = callee_info->stack_frame_offset\n     + callee_info->estimated_self_stack_size;\n-  if (inline_summaries->get (node->global.inlined_to)->estimated_stack_size < peak)\n-      inline_summaries->get (node->global.inlined_to)->estimated_stack_size = peak;\n+  if (ipa_fn_summaries->get (node->global.inlined_to)->estimated_stack_size < peak)\n+      ipa_fn_summaries->get (node->global.inlined_to)->estimated_stack_size = peak;\n   ipa_propagate_frequency (node);\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -2932,8 +2931,8 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n static void\n remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t\t      struct cgraph_node *node,\n-\t\t      struct inline_summary *info,\n-\t\t      struct inline_summary *callee_info,\n+\t\t      struct ipa_fn_summary *info,\n+\t\t      struct ipa_fn_summary *callee_info,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n \t\t      clause_t possible_truths,\n@@ -2988,8 +2987,8 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n /* Same as remap_predicate, but set result into hint *HINT.  */\n \n static void\n-remap_hint_predicate (struct inline_summary *info,\n-\t\t      struct inline_summary *callee_info,\n+remap_hint_predicate (struct ipa_fn_summary *info,\n+\t\t      struct ipa_fn_summary *callee_info,\n \t\t      predicate **hint,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n@@ -3016,12 +3015,12 @@ remap_hint_predicate (struct inline_summary *info,\n /* We inlined EDGE.  Update summary of the function we inlined into.  */\n \n void\n-inline_merge_summary (struct cgraph_edge *edge)\n+ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n {\n-  struct inline_summary *callee_info = inline_summaries->get (edge->callee);\n+  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (edge->callee);\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  struct inline_summary *info = inline_summaries->get (to);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n@@ -3129,13 +3128,13 @@ inline_merge_summary (struct cgraph_edge *edge)\n   offset_map.release ();\n }\n \n-/* For performance reasons inline_merge_summary is not updating overall size\n+/* For performance reasons ipa_merge_fn_summary_after_inlining is not updating overall size\n    and time.  Recompute it.  */\n \n void\n-inline_update_overall_summary (struct cgraph_node *node)\n+ipa_update_overall_fn_summary (struct cgraph_node *node)\n {\n-  struct inline_summary *info = inline_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   size_time_entry *e;\n   int i;\n \n@@ -3150,7 +3149,7 @@ inline_update_overall_summary (struct cgraph_node *node)\n \t\t\t\t&info->time, NULL,\n \t\t\t\t~(clause_t) (1 << predicate::false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n-  info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n+  info->size = (info->size + ipa_fn_summary::size_scale / 2) / ipa_fn_summary::size_scale;\n }\n \n \n@@ -3181,7 +3180,7 @@ inline_analyze_function (struct cgraph_node *node)\n \t     node->name (), node->order);\n   if (opt_for_fn (node->decl, optimize) && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n-  compute_inline_parameters (node, false);\n+  compute_fn_summary (node, false);\n   if (!optimize)\n     {\n       struct cgraph_edge *e;\n@@ -3198,7 +3197,7 @@ inline_analyze_function (struct cgraph_node *node)\n /* Called when new function is inserted to callgraph late.  */\n \n void\n-inline_summary_t::insert (struct cgraph_node *node, inline_summary *)\n+ipa_fn_summary_t::insert (struct cgraph_node *node, ipa_fn_summary *)\n {\n   inline_analyze_function (node);\n }\n@@ -3219,10 +3218,9 @@ inline_generate_summary (void)\n   if (!optimize && !flag_generate_lto && !flag_generate_offload && !flag_wpa)\n     return;\n \n-  if (!inline_summaries)\n-    inline_summaries = (inline_summary_t*) inline_summary_t::create_ggc (symtab);\n+  ipa_fn_summary_alloc ();\n \n-  inline_summaries->enable_insertion_hook ();\n+  ipa_fn_summaries->enable_insertion_hook ();\n \n   ipa_register_cgraph_hooks ();\n   inline_free_summary ();\n@@ -3283,7 +3281,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n     {\n       unsigned int index;\n       struct cgraph_node *node;\n-      struct inline_summary *info;\n+      struct ipa_fn_summary *info;\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n@@ -3293,7 +3291,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      info = inline_summaries->get (node);\n+      info = ipa_fn_summaries->get (node);\n \n       info->estimated_stack_size\n \t= info->estimated_self_stack_size = streamer_read_uhwi (&ib);\n@@ -3347,7 +3345,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \tread_ipa_call_summary (&ib, e);\n     }\n \n-  lto_free_section_data (file_data, LTO_section_inline_summary, NULL, data,\n+  lto_free_section_data (file_data, LTO_section_ipa_fn_summary, NULL, data,\n \t\t\t len);\n   lto_data_in_delete (data_in);\n }\n@@ -3364,13 +3362,13 @@ inline_read_summary (void)\n   struct lto_file_decl_data *file_data;\n   unsigned int j = 0;\n \n-  inline_summary_alloc ();\n+  ipa_fn_summary_alloc ();\n \n   while ((file_data = file_data_vec[j++]))\n     {\n       size_t len;\n       const char *data = lto_get_section_data (file_data,\n-\t\t\t\t\t       LTO_section_inline_summary,\n+\t\t\t\t\t       LTO_section_ipa_fn_summary,\n \t\t\t\t\t       NULL, &len);\n       if (data)\n \tinline_read_section (file_data, data, len);\n@@ -3388,8 +3386,8 @@ inline_read_summary (void)\n \tipa_prop_read_jump_functions ();\n     }\n \n-  gcc_assert (inline_summaries);\n-  inline_summaries->enable_insertion_hook ();\n+  gcc_assert (ipa_fn_summaries);\n+  ipa_fn_summaries->enable_insertion_hook ();\n }\n \n \n@@ -3421,7 +3419,7 @@ write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n void\n inline_write_summary (void)\n {\n-  struct output_block *ob = create_output_block (LTO_section_inline_summary);\n+  struct output_block *ob = create_output_block (LTO_section_ipa_fn_summary);\n   lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   unsigned int count = 0;\n   int i;\n@@ -3441,7 +3439,7 @@ inline_write_summary (void)\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n-\t  struct inline_summary *info = inline_summaries->get (cnode);\n+\t  struct ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n@@ -3516,9 +3514,9 @@ inline_free_summary (void)\n     return;\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->alias)\n-      inline_summaries->get (node)->reset (node);\n-  inline_summaries->release ();\n-  inline_summaries = NULL;\n+      ipa_fn_summaries->get (node)->reset (node);\n+  ipa_fn_summaries->release ();\n+  ipa_fn_summaries = NULL;\n   ipa_call_summaries->release ();\n   delete ipa_call_summaries;\n   ipa_call_summaries = NULL;"}, {"sha": "60f7e75ff44638b9d7ace37fa518b777817c34ef", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -25,10 +25,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-predicate.h\"\n \n \n-/* Inline hints are reasons why inline heuristics should preffer inlining given\n+/* Hints are reasons why IPA heuristics should preffer specializing given\n    function.  They are represtented as bitmap of the following values.  */\n-enum inline_hints_vals {\n-  /* When inlining turns indirect call into a direct call,\n+enum ipa_hints_vals {\n+  /* When specialization turns indirect call into a direct call,\n      it is good idea to do so.  */\n   INLINE_HINT_indirect_call = 1,\n   /* Inlining may make loop iterations or loop stride known.  It is good idea\n@@ -42,11 +42,11 @@ enum inline_hints_vals {\n      win.  */\n   INLINE_HINT_in_scc = 16,\n   /* If function is declared inline by user, it may be good idea to inline\n-     it.  */\n+     it.  Set by simple_edge_hints in ipa-inline-analysis.c.  */\n   INLINE_HINT_declared_inline = 32,\n   /* Programs are usually still organized for non-LTO compilation and thus\n      if functions are in different modules, inlining may not be so important. \n-   */\n+     Set by simple_edge_hints in ipa-inline-analysis.c.   */\n   INLINE_HINT_cross_module = 64,\n   /* If array indexes of loads/stores become known there may be room for\n      further optimization.  */\n@@ -55,7 +55,7 @@ enum inline_hints_vals {\n   INLINE_HINT_known_hot = 256\n };\n \n-typedef int inline_hints;\n+typedef int ipa_hints;\n \n /* Simple description of whether a memory load or a condition refers to a load\n    from an aggregate and if so, how and where from in the aggregate.\n@@ -69,12 +69,9 @@ struct agg_position_info\n   bool by_ref;\n };\n \n-/* Represnetation of function body size and time depending on the inline\n+/* Representation of function body size and time depending on the call\n    context.  We keep simple array of record, every containing of predicate\n-   and time/size to account.\n-\n-   We keep values scaled up, so fractional sizes can be accounted.  */\n-#define INLINE_SIZE_SCALE 2\n+   and time/size to account.  */\n struct GTY(()) size_time_entry\n {\n   /* Predicate for code to be executed.  */\n@@ -88,7 +85,7 @@ struct GTY(()) size_time_entry\n };\n \n /* Function inlining information.  */\n-struct GTY(()) inline_summary\n+struct GTY(()) ipa_fn_summary\n {\n   /* Information about the function body itself.  */\n \n@@ -116,7 +113,7 @@ struct GTY(()) inline_summary\n \n   /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_stack_size;\n-  /* Expected offset of the stack frame of inlined function.  */\n+  /* Expected offset of the stack frame of function.  */\n   HOST_WIDE_INT stack_frame_offset;\n   /* Estimated size of the function after inlining.  */\n   sreal GTY((skip)) time;\n@@ -146,7 +143,7 @@ struct GTY(()) inline_summary\n \n   /* Keep all field empty so summary dumping works during its computation.\n      This is useful for debugging.  */\n-  inline_summary ()\n+  ipa_fn_summary ()\n     : estimated_self_stack_size (0), self_size (0), min_size (0),\n       inlinable (false), contains_cilk_spawn (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n@@ -159,32 +156,35 @@ struct GTY(()) inline_summary\n   /* Record time and size under given predicates.  */\n   void account_size_time (int, sreal, const predicate &, const predicate &);\n \n-  /* Reset inline summary to empty state.  */\n+  /* Reset summary to empty state.  */\n   void reset (struct cgraph_node *node);\n+\n+  /* We keep values scaled up, so fractional sizes can be accounted.  */\n+  static const int size_scale = 2;\n };\n \n-class GTY((user)) inline_summary_t: public function_summary <inline_summary *>\n+class GTY((user)) ipa_fn_summary_t: public function_summary <ipa_fn_summary *>\n {\n public:\n-  inline_summary_t (symbol_table *symtab, bool ggc):\n-    function_summary <inline_summary *> (symtab, ggc) {}\n+  ipa_fn_summary_t (symbol_table *symtab, bool ggc):\n+    function_summary <ipa_fn_summary *> (symtab, ggc) {}\n \n-  static inline_summary_t *create_ggc (symbol_table *symtab)\n+  static ipa_fn_summary_t *create_ggc (symbol_table *symtab)\n   {\n-    struct inline_summary_t *summary = new (ggc_alloc <inline_summary_t> ())\n-      inline_summary_t(symtab, true);\n+    struct ipa_fn_summary_t *summary = new (ggc_alloc <ipa_fn_summary_t> ())\n+      ipa_fn_summary_t(symtab, true);\n     summary->disable_insertion_hook ();\n     return summary;\n   }\n \n \n-  virtual void insert (cgraph_node *, inline_summary *);\n-  virtual void remove (cgraph_node *node, inline_summary *);\n+  virtual void insert (cgraph_node *, ipa_fn_summary *);\n+  virtual void remove (cgraph_node *node, ipa_fn_summary *);\n   virtual void duplicate (cgraph_node *src, cgraph_node *dst,\n-\t\t\t  inline_summary *src_data, inline_summary *dst_data);\n+\t\t\t  ipa_fn_summary *src_data, ipa_fn_summary *dst_data);\n };\n \n-extern GTY(()) function_summary <inline_summary *> *inline_summaries;\n+extern GTY(()) function_summary <ipa_fn_summary *> *ipa_fn_summaries;\n \n /* Information kept about callgraph edges.  */\n struct ipa_call_summary\n@@ -227,26 +227,24 @@ class ipa_call_summary_t: public call_summary <ipa_call_summary *>\n extern call_summary <ipa_call_summary *> *ipa_call_summaries;\n \n /* In ipa-fnsummary.c  */\n-void debug_inline_summary (struct cgraph_node *);\n-void dump_inline_summaries (FILE *f);\n-void dump_inline_summary (FILE *f, struct cgraph_node *node);\n-void dump_inline_hints (FILE *f, inline_hints);\n+void ipa_debug_fn_summary (struct cgraph_node *);\n+void ipa_dump_fn_summaries (FILE *f);\n+void ipa_dump_fn_summary (FILE *f, struct cgraph_node *node);\n+void ipa_dump_hints (FILE *f, ipa_hints);\n void inline_generate_summary (void);\n void inline_read_summary (void);\n void inline_write_summary (void);\n void inline_free_summary (void);\n void inline_analyze_function (struct cgraph_node *node);\n-int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<tree>,\n \t\t\t\t\tvec<ipa_polymorphic_call_context>,\n \t\t\t\t\tvec<ipa_agg_jump_function_p>,\n \t\t\t\t\tint *, sreal *, sreal *,\n-\t\t\t\t        inline_hints *);\n-void inline_merge_summary (struct cgraph_edge *edge);\n-void inline_update_overall_summary (struct cgraph_node *node);\n-void compute_inline_parameters (struct cgraph_node *, bool);\n-bool inline_account_function_p (struct cgraph_node *node);\n+\t\t\t\t        ipa_hints *);\n+void ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge);\n+void ipa_update_overall_fn_summary (struct cgraph_node *node);\n+void compute_fn_summary (struct cgraph_node *, bool);\n \n \n void evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n@@ -265,7 +263,7 @@ void estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t  int *ret_size, int *ret_min_size,\n \t\t\t\t  sreal *ret_time,\n \t\t\t\t  sreal *ret_nonspecialized_time,\n-\t\t\t\t  inline_hints *ret_hints,\n+\t\t\t\t  ipa_hints *ret_hints,\n \t\t\t\t  vec<inline_param_summary>\n \t\t\t\t  inline_param_summary);\n "}, {"sha": "39f230924c745e3fea63d5b8daecbe8bbac4024d", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -1190,8 +1190,8 @@ sem_function::merge (sem_item *alias_item)\n \t    fprintf (dump_file,\n \t\t     \"can not create wrapper of stdarg function.\\n\");\n \t}\n-      else if (inline_summaries\n-\t       && inline_summaries->get (alias)->self_size <= 2)\n+      else if (ipa_fn_summaries\n+\t       && ipa_fn_summaries->get (alias)->self_size <= 2)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Wrapper creation is not \""}, {"sha": "f562ca5a4bddeeacaaea32249de2bd024bd7a96a", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -123,9 +123,9 @@ simple_edge_hints (struct cgraph_edge *edge)\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  if (inline_summaries->get (to)->scc_no\n-      && inline_summaries->get (to)->scc_no\n-\t == inline_summaries->get (callee)->scc_no\n+  if (ipa_fn_summaries->get (to)->scc_no\n+      && ipa_fn_summaries->get (to)->scc_no\n+\t == ipa_fn_summaries->get (callee)->scc_no\n       && !edge->recursive_p ())\n     hints |= INLINE_HINT_same_scc;\n \n@@ -149,7 +149,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n {\n   sreal time, nonspec_time;\n   int size;\n-  inline_hints hints;\n+  ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n@@ -187,7 +187,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache.exists ())\n     {\n-      inline_summaries->get (edge->callee)->min_size = min_size;\n+      ipa_fn_summaries->get (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n       edge_growth_cache[edge->uid].time = time;\n@@ -245,10 +245,10 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n /* Estimate the growth of the caller when inlining EDGE.\n    Only to be called via estimate_edge_size.  */\n \n-inline_hints\n+ipa_hints\n do_estimate_edge_hints (struct cgraph_edge *edge)\n {\n-  inline_hints hints;\n+  ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n   vec<tree> known_vals;\n@@ -293,11 +293,11 @@ estimate_size_after_inlining (struct cgraph_node *node,\n   struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n   if (!es->predicate || *es->predicate != false)\n     {\n-      int size = inline_summaries->get (node)->size + estimate_edge_growth (edge);\n+      int size = ipa_fn_summaries->get (node)->size + estimate_edge_growth (edge);\n       gcc_assert (size >= 0);\n       return size;\n     }\n-  return inline_summaries->get (node)->size;\n+  return ipa_fn_summaries->get (node)->size;\n }\n \n \n@@ -345,7 +345,7 @@ int\n estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, false, false, 0 };\n-  struct inline_summary *info = inline_summaries->get (node);\n+  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \n   node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n \n@@ -420,7 +420,7 @@ growth_likely_positive (struct cgraph_node *node,\n       || node->address_taken)\n     return true;\n \n-  max_callers = inline_summaries->get (node)->size * 4 / edge_growth + 2;\n+  max_callers = ipa_fn_summaries->get (node)->size * 4 / edge_growth + 2;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {"}, {"sha": "0bd0fdd65ef6b51660c938b3adbddc22196f98b2", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -204,7 +204,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t    {\n \t      gcc_assert (!e->callee->alias);\n \t      if (overall_size)\n-\t        *overall_size -= inline_summaries->get (e->callee)->size;\n+\t        *overall_size -= ipa_fn_summaries->get (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -288,7 +288,7 @@ mark_all_inlined_calls_cdtor (cgraph_node *node)\n    indirect edges are discovered in the process, add them to NEW_EDGES, unless\n    it is NULL. If UPDATE_OVERALL_SUMMARY is false, do not bother to recompute overall\n    size of caller after inlining. Caller is required to eventually do it via\n-   inline_update_overall_summary.\n+   ipa_update_overall_fn_summary.\n    If callee_removed is non-NULL, set it to true if we removed callee node.\n \n    Return true iff any new callgraph edges were discovered as a\n@@ -358,8 +358,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       reload_optimization_node = true;\n     }\n \n-  inline_summary *caller_info = inline_summaries->get (to);\n-  inline_summary *callee_info = inline_summaries->get (callee);\n+  ipa_fn_summary *caller_info = ipa_fn_summaries->get (to);\n+  ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n   if (!caller_info->fp_expressions && callee_info->fp_expressions)\n     {\n       caller_info->fp_expressions = true;\n@@ -451,22 +451,22 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   gcc_assert (curr->callee->global.inlined_to == to);\n \n-  old_size = inline_summaries->get (to)->size;\n-  inline_merge_summary (e);\n+  old_size = ipa_fn_summaries->get (to)->size;\n+  ipa_merge_fn_summary_after_inlining (e);\n   if (e->in_polymorphic_cdtor)\n     mark_all_inlined_calls_cdtor (e->callee);\n   if (opt_for_fn (e->caller->decl, optimize))\n     new_edges_found = ipa_propagate_indirect_call_infos (curr, new_edges);\n   check_speculations (e->callee);\n   if (update_overall_summary)\n-    inline_update_overall_summary (to);\n+    ipa_update_overall_fn_summary (to);\n   else\n     /* Update self size by the estimate so overall function growth limits\n        work for further inlining into this function.  Before inlining\n        the function we inlined to again we expect the caller to update\n        the overall summary.  */\n-    inline_summaries->get (to)->size += estimated_growth;\n-  new_size = inline_summaries->get (to)->size;\n+    ipa_fn_summaries->get (to)->size += estimated_growth;\n+  new_size = ipa_fn_summaries->get (to)->size;\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;\n@@ -485,7 +485,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n      See PR 65654.  */\n #if 0\n   /* Verify that estimated growth match real growth.  Allow off-by-one\n-     error due to INLINE_SIZE_SCALE roudoff errors.  */\n+     error due to ipa_fn_summary::size_scale roudoff errors.  */\n   gcc_assert (!update_overall_summary || !overall_size || new_edges_found\n \t      || abs (estimated_growth - (new_size - old_size)) <= 1\n \t      || speculation_removed\n@@ -500,7 +500,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n \n-  /* This must happen after inline_merge_summary that rely on jump\n+  /* This must happen after ipa_merge_fn_summary_after_inlining that rely on jump\n      functions of callee to not be updated.  */\n   return new_edges_found;\n }"}, {"sha": "5d907508c3163552ee1285e906246faa451b8d4a", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -150,7 +150,7 @@ caller_growth_limits (struct cgraph_edge *e)\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n-  inline_summary *info, *what_info, *outer_info = inline_summaries->get (to);\n+  ipa_fn_summary *info, *what_info, *outer_info = ipa_fn_summaries->get (to);\n \n   /* Look for function e->caller is inlined to.  While doing\n      so work out the largest function body on the way.  As\n@@ -162,7 +162,7 @@ caller_growth_limits (struct cgraph_edge *e)\n      too much in order to prevent compiler from exploding\".  */\n   while (true)\n     {\n-      info = inline_summaries->get (to);\n+      info = ipa_fn_summaries->get (to);\n       if (limit < info->self_size)\n \tlimit = info->self_size;\n       if (stack_size_limit < info->estimated_self_stack_size)\n@@ -173,7 +173,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \tbreak;\n     }\n \n-  what_info = inline_summaries->get (what);\n+  what_info = ipa_fn_summaries->get (what);\n \n   if (limit < what_info->self_size)\n     limit = what_info->self_size;\n@@ -364,7 +364,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n-  else if (!inline_summaries->get (callee)->inlinable)\n+  else if (!ipa_fn_summaries->get (callee)->inlinable)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;\n@@ -391,8 +391,8 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t     (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t      && lookup_attribute (\"always_inline\",\n \t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n-      inline_summary *caller_info = inline_summaries->get (caller);\n-      inline_summary *callee_info = inline_summaries->get (callee);\n+      ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n+      ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n \n      /* Until GCC 4.9 we did not check the semantics alterning flags\n \tbellow and inline across optimization boundry.\n@@ -647,7 +647,7 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n \n-  sreal caller_time = inline_summaries->get (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n   return uninlined_call_time + caller_time;\n }\n \n@@ -661,7 +661,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n-  sreal caller_time = inline_summaries->get (caller)->time;\n+  sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n   if (edge->count && caller->count)\n     time *= (sreal)edge->count / caller->count;\n@@ -722,15 +722,15 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n      MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count || !e->maybe_hot_p ()))\n-\t   && inline_summaries->get (callee)->min_size\n+\t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n     {\n       e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl) || e->count)\n-\t   && inline_summaries->get (callee)->min_size\n+\t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n \t      > 16 * MAX_INLINE_INSNS_SINGLE)\n     {\n@@ -742,7 +742,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   else\n     {\n       int growth = estimate_edge_growth (e);\n-      inline_hints hints = estimate_edge_hints (e);\n+      ipa_hints hints = estimate_edge_hints (e);\n       bool big_speedup = big_speedup_p (e);\n \n       if (growth <= 0)\n@@ -1005,8 +1005,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   int growth;\n   sreal edge_time, unspec_edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  struct inline_summary *callee_info = inline_summaries->get (callee);\n-  inline_hints hints;\n+  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n+  ipa_hints hints;\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n@@ -1030,7 +1030,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t       growth,\n \t       edge_time.to_double (),\n \t       unspec_edge_time.to_double ());\n-      dump_inline_hints (dump_file, hints);\n+      ipa_dump_hints (dump_file, hints);\n       if (big_speedup_p (edge))\n \tfprintf (dump_file, \" big_speedup\");\n       fprintf (dump_file, \"\\n\");\n@@ -1116,7 +1116,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n \t{\n-\t  struct inline_summary *caller_info = inline_summaries->get (caller);\n+\t  struct ipa_fn_summary *caller_info = ipa_fn_summaries->get (caller);\n \t  int caller_growth = caller_info->growth;\n \n \t  /* Only apply the penalty when caller looks like inline candidate,\n@@ -1322,7 +1322,7 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   struct ipa_ref *ref;\n \n-  if ((!node->alias && !inline_summaries->get (node)->inlinable)\n+  if ((!node->alias && !ipa_fn_summaries->get (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n@@ -1380,7 +1380,7 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n            don't need updating.  */\n \tif (e->inline_failed\n \t    && (callee = e->callee->ultimate_alias_target (&avail, e->caller))\n-\t    && inline_summaries->get (callee)->inlinable\n+\t    && ipa_fn_summaries->get (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->uid))\n \t  {\n@@ -1551,10 +1551,10 @@ recursive_inlining (struct cgraph_edge *edge,\n     fprintf (dump_file,\n \t     \"\\n   Inlined %i times, \"\n \t     \"body grown from size %i to %i, time %f to %f\\n\", n,\n-\t     inline_summaries->get (master_clone)->size,\n-\t     inline_summaries->get (node)->size,\n-\t     inline_summaries->get (master_clone)->time.to_double (),\n-\t     inline_summaries->get (node)->time.to_double ());\n+\t     ipa_fn_summaries->get (master_clone)->size,\n+\t     ipa_fn_summaries->get (node)->size,\n+\t     ipa_fn_summaries->get (master_clone)->time.to_double (),\n+\t     ipa_fn_summaries->get (node)->time.to_double ());\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -1681,7 +1681,7 @@ resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n       spec_rem += edge->count;\n       edge->resolve_speculation ();\n       reset_edge_caches (where);\n-      inline_update_overall_summary (where);\n+      ipa_update_overall_fn_summary (where);\n       update_caller_keys (edge_heap, where,\n \t\t\t  updated_nodes, NULL);\n       update_callee_keys (edge_heap, where,\n@@ -1751,7 +1751,7 @@ inline_small_functions (void)\n \tif (!node->alias && node->analyzed\n \t    && (node->has_gimple_body_p () || node->thunk.thunk_p))\n \t  {\n-\t    struct inline_summary *info = inline_summaries->get (node);\n+\t    struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out\n@@ -1772,7 +1772,7 @@ inline_small_functions (void)\n \t\tfor (n2 = node; n2;\n \t\t     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)\n \t\t  {\n-\t\t    struct inline_summary *info2 = inline_summaries->get (n2);\n+\t\t    struct ipa_fn_summary *info2 = ipa_fn_summaries->get (n2);\n \t\t    if (info2->scc_no)\n \t\t      break;\n \t\t    info2->scc_no = id;\n@@ -1835,7 +1835,7 @@ inline_small_functions (void)\n \t{\n \t  struct cgraph_node *where = node->global.inlined_to\n \t\t\t\t      ? node->global.inlined_to : node;\n-\t  inline_update_overall_summary (where);\n+\t  ipa_update_overall_fn_summary (where);\n \t  reset_edge_caches (where);\n           update_caller_keys (&edge_heap, where,\n \t\t\t      updated_nodes, NULL);\n@@ -1922,7 +1922,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s/%i with %i size\\n\",\n \t\t   callee->name (), callee->order,\n-\t\t   inline_summaries->get (callee)->size);\n+\t\t   ipa_fn_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n@@ -2053,8 +2053,8 @@ inline_small_functions (void)\n \t\t   \"net change of %+i.\\n\",\n \t\t   edge->callee->name (),\n \t\t   edge->caller->name (),\n-\t\t   inline_summaries->get (edge->caller)->time.to_double (),\n-\t\t   inline_summaries->get (edge->caller)->size,\n+\t\t   ipa_fn_summaries->get (edge->caller)->time.to_double (),\n+\t\t   ipa_fn_summaries->get (edge->caller)->size,\n \t\t   overall_size - old_size);\n \t}\n       if (min_size > overall_size)\n@@ -2154,7 +2154,7 @@ flatten_function (struct cgraph_node *node, bool early)\n \n   node->aux = NULL;\n   if (!node->global.inlined_to)\n-    inline_update_overall_summary (node);\n+    ipa_update_overall_fn_summary (node);\n }\n \n /* Inline NODE to all callers.  Worker for cgraph_for_node_and_aliases.\n@@ -2186,11 +2186,11 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n \t\t   node->name (),\n-\t\t   inline_summaries->get (node)->size);\n+\t\t   ipa_fn_summaries->get (node)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n \t\t   node->callers->caller->name (),\n-\t\t   inline_summaries->get (node->callers->caller)->size);\n+\t\t   ipa_fn_summaries->get (node->callers->caller)->size);\n \t}\n \n       /* Remember which callers we inlined to, delaying updating the\n@@ -2201,7 +2201,7 @@ inline_to_all_callers_1 (struct cgraph_node *node, void *data,\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n \t\t caller->name (),\n-\t\t inline_summaries->get (caller)->size);\n+\t\t ipa_fn_summaries->get (caller)->size);\n       if (!(*num_calls)--)\n \t{\n \t  if (dump_file)\n@@ -2227,7 +2227,7 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n      we have a lot of calls to the same function.  */\n   for (hash_set<cgraph_node *>::iterator i = callers.begin ();\n        i != callers.end (); ++i)\n-    inline_update_overall_summary (*i);\n+    ipa_update_overall_fn_summary (*i);\n   return res;\n }\n \n@@ -2242,7 +2242,7 @@ dump_overall_stats (void)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tsreal time = inline_summaries->get (node)->time;\n+\tsreal time = ipa_fn_summaries->get (node)->time;\n \tsum += time;\n \tsum_weighted += time * node->count;\n       }\n@@ -2377,7 +2377,7 @@ ipa_inline (void)\n   order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n \n   if (dump_file)\n-    dump_inline_summaries (dump_file);\n+    ipa_dump_fn_summaries (dump_file);\n \n   nnodes = ipa_reverse_postorder (order);\n \n@@ -2482,7 +2482,7 @@ ipa_inline (void)\n \t      struct cgraph_node *where = node->global.inlined_to\n \t\t\t\t\t  ? node->global.inlined_to : node;\n \t      reset_edge_caches (where);\n-\t      inline_update_overall_summary (where);\n+\t      ipa_update_overall_fn_summary (where);\n \t    }\n \t  if (want_inline_function_to_all_callers_p (node, cold))\n \t    {\n@@ -2510,7 +2510,7 @@ ipa_inline (void)\n     }\n \n   if (dump_file)\n-    dump_inline_summaries (dump_file);\n+    ipa_dump_fn_summaries (dump_file);\n   /* In WPA we use inline summaries for partitioning process.  */\n   if (!flag_wpa)\n     inline_free_summary ();\n@@ -2559,7 +2559,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n       inlined = true;\n     }\n   if (inlined)\n-    inline_update_overall_summary (node);\n+    ipa_update_overall_fn_summary (node);\n \n   return inlined;\n }\n@@ -2576,7 +2576,7 @@ early_inline_small_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-      if (!inline_summaries->get (callee)->inlinable\n+      if (!ipa_fn_summaries->get (callee)->inlinable\n \t  || !e->inline_failed)\n \tcontinue;\n \n@@ -2612,7 +2612,7 @@ early_inline_small_functions (struct cgraph_node *node)\n     }\n \n   if (inlined)\n-    inline_update_overall_summary (node);\n+    ipa_update_overall_fn_summary (node);\n \n   return inlined;\n }\n@@ -2699,7 +2699,7 @@ early_inliner (function *fun)\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n \t    }\n-\t  inline_update_overall_summary (node);\n+\t  ipa_update_overall_fn_summary (node);\n \t  inlined = false;\n \t  timevar_pop (TV_INTEGRATION);\n \t}\n@@ -2733,7 +2733,7 @@ early_inliner (function *fun)\n \t\t}\n \t    }\n \t  if (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS) - 1)\n-\t    inline_update_overall_summary (node);\n+\t    ipa_update_overall_fn_summary (node);\n \t  timevar_pop (TV_INTEGRATION);\n \t  iterations++;\n \t  inlined = false;"}, {"sha": "54c1ed97d5782e7586198c8cf2e9ea30f8205538", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -27,24 +27,18 @@ struct edge_growth_cache_entry\n {\n   sreal time, nonspec_time;\n   int size;\n-  inline_hints hints;\n+  ipa_hints hints;\n };\n \n extern vec<edge_growth_cache_entry> edge_growth_cache;\n \n /* In ipa-inline-analysis.c  */\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n-void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n-\t\t\t\t\tvec<tree>,\n-\t\t\t\t\tvec<ipa_polymorphic_call_context>,\n-\t\t\t\t\tvec<ipa_agg_jump_function_p>,\n-\t\t\t\t\tint *, sreal *, sreal *,\n-\t\t\t\t        inline_hints *);\n int estimate_growth (struct cgraph_node *);\n bool growth_likely_positive (struct cgraph_node *, int);\n int do_estimate_edge_size (struct cgraph_edge *edge);\n sreal do_estimate_edge_time (struct cgraph_edge *edge);\n-inline_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n+ipa_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n void initialize_growth_caches (void);\n void free_growth_caches (void);\n \n@@ -105,10 +99,10 @@ estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline inline_hints\n+static inline ipa_hints\n estimate_edge_hints (struct cgraph_edge *edge)\n {\n-  inline_hints ret;\n+  ipa_hints ret;\n   if ((int)edge_growth_cache.length () <= edge->uid\n       || !(ret = edge_growth_cache[edge->uid].hints))\n     return do_estimate_edge_hints (edge);"}, {"sha": "f10e2343a2262e3513460d3556d835c7d3fe61e7", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -387,7 +387,7 @@ predicate::remap_after_duplication (clause_t possible_truths)\n /* Translate all conditions from callee representation into caller\n    representation and symbolically evaluate predicate THIS into new predicate.\n \n-   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO\n+   INFO is ipa_fn_summary of function we are adding predicate into, CALLEE_INFO\n    is summary of function predicate P is from. OPERAND_MAP is array giving\n    callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clausule of all\n    callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n@@ -398,8 +398,8 @@ predicate::remap_after_duplication (clause_t possible_truths)\n    for other purposes).  */\n \n predicate\n-predicate::remap_after_inlining (struct inline_summary *info,\n-\t\t\t\t struct inline_summary *callee_info,\n+predicate::remap_after_inlining (struct ipa_fn_summary *info,\n+\t\t\t\t struct ipa_fn_summary *callee_info,\n \t\t\t\t vec<int> operand_map,\n \t\t\t\t vec<int> offset_map,\n \t\t\t\t clause_t possible_truths,\n@@ -522,7 +522,7 @@ predicate::stream_out (struct output_block *ob)\n    It can be NULL, which means this not a load from an aggregate.  */\n \n predicate\n-add_condition (struct inline_summary *summary, int operand_num,\n+add_condition (struct ipa_fn_summary *summary, int operand_num,\n \t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val)\n {"}, {"sha": "6d4881952a2b9f02b63d32d521f0d02af37f7a77", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -205,8 +205,8 @@ class predicate\n   predicate remap_after_duplication (clause_t);\n \n   /* Return predicate equal to THIS after inlining.  */\n-  predicate remap_after_inlining (struct inline_summary *,\n-\t\t\t          struct inline_summary *,\n+  predicate remap_after_inlining (struct ipa_fn_summary *,\n+\t\t\t          struct ipa_fn_summary *,\n \t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n \n   void stream_in (struct lto_input_block *);\n@@ -227,6 +227,6 @@ class predicate\n };\n \n void dump_condition (FILE *f, conditions conditions, int cond);\n-predicate add_condition (struct inline_summary *summary, int operand_num,\n+predicate add_condition (struct ipa_fn_summary *summary, int operand_num,\n \t\t\t HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t\t\t enum tree_code code, tree val);"}, {"sha": "682e8cea0c8d98272e770e154587bcee38ce9e9e", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -679,7 +679,7 @@ ipa_profile (void)\n \t    }\n \t }\n        if (update)\n-\t inline_update_overall_summary (n);\n+\t ipa_update_overall_fn_summary (n);\n      }\n   if (node_map_initialized)\n     del_node_map ();"}, {"sha": "7778b9c68134ef61d99c6cfba2e02579d7db0c19", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -1713,7 +1713,7 @@ split_function (basic_block return_bb, struct split_point *split_point,\n     }\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n-  compute_inline_parameters (node, true);\n+  compute_fn_summary (node, true);\n }\n \n /* Execute function splitting pass.  */\n@@ -1742,8 +1742,8 @@ execute_split_functions (void)\n     }\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n-  if (inline_summaries\n-      && !inline_summaries->get (node)->inlinable)\n+  if (ipa_fn_summaries\n+      && !ipa_fn_summaries->get (node)->inlinable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");"}, {"sha": "532e7c89c4fbf20bf39224bd16b911e8ac865881", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -626,7 +626,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t}\n       if (!preserve_body)\n         src->release_body ();\n-      inline_update_overall_summary (dst);\n+      ipa_update_overall_fn_summary (dst);\n     }\n   /* TODO: if there is no match, we can scale up.  */\n   src->decl = oldsrcdecl;"}, {"sha": "7a2b6ee78d06f3850bb43e9d7a9b4b8cc610de84", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -236,8 +236,8 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n                                target->order);\n \t    }\n \t  edge = edge->make_direct (target);\n-\t  if (inline_summaries)\n-\t    inline_update_overall_summary (node);\n+\t  if (ipa_fn_summaries)\n+\t    ipa_update_overall_fn_summary (node);\n \t  else if (edge->call_stmt)\n \t    {\n \t      edge->redirect_call_stmt_to_callee ();\n@@ -849,7 +849,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \n namespace {\n \n-const pass_data pass_data_ipa_free_inline_summary =\n+const pass_data pass_data_ipa_free_fn_summary =\n {\n   SIMPLE_IPA_PASS, /* type */\n   \"free-inline-summary\", /* name */\n@@ -865,11 +865,11 @@ const pass_data pass_data_ipa_free_inline_summary =\n   ( TODO_remove_functions | TODO_dump_symtab ), /* todo_flags_finish */\n };\n \n-class pass_ipa_free_inline_summary : public simple_ipa_opt_pass\n+class pass_ipa_free_fn_summary : public simple_ipa_opt_pass\n {\n public:\n-  pass_ipa_free_inline_summary (gcc::context *ctxt)\n-    : simple_ipa_opt_pass (pass_data_ipa_free_inline_summary, ctxt)\n+  pass_ipa_free_fn_summary (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_free_fn_summary, ctxt)\n   {}\n \n   /* opt_pass methods: */\n@@ -879,14 +879,14 @@ class pass_ipa_free_inline_summary : public simple_ipa_opt_pass\n       return 0;\n     }\n \n-}; // class pass_ipa_free_inline_summary\n+}; // class pass_ipa_free_fn_summary\n \n } // anon namespace\n \n simple_ipa_opt_pass *\n-make_pass_ipa_free_inline_summary (gcc::context *ctxt)\n+make_pass_ipa_free_fn_summary (gcc::context *ctxt)\n {\n-  return new pass_ipa_free_inline_summary (ctxt);\n+  return new pass_ipa_free_fn_summary (ctxt);\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must"}, {"sha": "7cf4b0b5fe96538e6df6a5bb3b600da817638ab4", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -228,7 +228,7 @@ enum lto_section_type\n   LTO_section_symtab_nodes,\n   LTO_section_opts,\n   LTO_section_cgraph_opt_sum,\n-  LTO_section_inline_summary,\n+  LTO_section_ipa_fn_summary,\n   LTO_section_ipcp_transform,\n   LTO_section_ipa_icf,\n   LTO_section_offload_table,"}, {"sha": "3600ab23bd9157aad76751912306abd498acae92", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -153,7 +153,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     {\n       struct cgraph_edge *e;\n       if (!node->alias)\n-        part->insns += inline_summaries->get (cnode)->self_size;\n+        part->insns += ipa_fn_summaries->get (cnode)->self_size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -277,7 +277,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n       partition->initializers_visited = NULL;\n \n       if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node)))\n-        partition->insns -= inline_summaries->get (cnode)->self_size;\n+        partition->insns -= ipa_fn_summaries->get (cnode)->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -480,7 +480,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \telse\n \t  order[n_nodes++] = node;\n \tif (!node->alias)\n-\t  total_size += inline_summaries->get (node)->size;\n+\t  total_size += ipa_fn_summaries->get (node)->size;\n       }\n \n   original_total_size = total_size;\n@@ -542,14 +542,14 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t     && noreorder[noreorder_pos]->order < current_order)\n \t{\n \t  if (!noreorder[noreorder_pos]->alias)\n-\t    total_size -= inline_summaries->get (noreorder[noreorder_pos])->size;\n+\t    total_size -= ipa_fn_summaries->get (noreorder[noreorder_pos])->size;\n \t  next_nodes.safe_push (noreorder[noreorder_pos++]);\n \t}\n       add_sorted_nodes (next_nodes, partition);\n \n       add_symbol_to_partition (partition, order[i]);\n       if (!order[i]->alias)\n-        total_size -= inline_summaries->get (order[i])->size;\n+        total_size -= ipa_fn_summaries->get (order[i])->size;\n \t  \n \n       /* Once we added a new node to the partition, we also want to add"}, {"sha": "2b460324b242265bf70281bd1c8efa65b2fe4f35", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -139,11 +139,11 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_target_clone);\n   NEXT_PASS (pass_ipa_chkp_produce_thunks);\n   NEXT_PASS (pass_ipa_auto_profile);\n-  NEXT_PASS (pass_ipa_free_inline_summary);\n   NEXT_PASS (pass_ipa_tree_profile);\n   PUSH_INSERT_PASSES_WITHIN (pass_ipa_tree_profile)\n       NEXT_PASS (pass_feedback_split_functions);\n   POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_ipa_free_fn_summary);\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_tm);\n   NEXT_PASS (pass_ipa_lower_emutls);"}, {"sha": "92a3426014c9b7f0ae98eb80b10148f153149971", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -496,8 +496,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_increase_alignment (gcc::context\n \t\t\t\t\t\t\t      *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_inline (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_free_lang_data (gcc::context *ctxt);\n-extern simple_ipa_opt_pass *make_pass_ipa_free_inline_summary (gcc::context\n-\t\t\t\t\t\t\t       *ctxt);\n+extern simple_ipa_opt_pass *make_pass_ipa_free_fn_summary (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_icf (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);"}, {"sha": "c399d21d0d1498daf2cdd43cc841951ab6e80006", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bceb671062a463aadcf0059e19308845d713838/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bceb671062a463aadcf0059e19308845d713838/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0bceb671062a463aadcf0059e19308845d713838", "patch": "@@ -5204,7 +5204,7 @@ convert_callers_for_node (struct cgraph_node *node,\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n \t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n-      compute_inline_parameters (cs->caller, true);\n+      compute_fn_summary (cs->caller, true);\n   BITMAP_FREE (recomputed_callers);\n \n   return true;\n@@ -5381,7 +5381,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_ONE_ONLY (node->decl) || DECL_EXTERNAL (node->decl))\n-      && inline_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n+      && ipa_fn_summaries->get (node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");"}]}