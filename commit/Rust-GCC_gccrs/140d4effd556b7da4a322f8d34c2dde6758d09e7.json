{"sha": "140d4effd556b7da4a322f8d34c2dde6758d09e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQwZDRlZmZkNTU2YjdkYTRhMzIyZjhkMzRjMmRkZTY3NThkMDllNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-09-30T19:21:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-09-30T19:21:34Z"}, "message": "re PR tree-optimization/31261 (Missed tree optimizations: (8 - (x & 7)) & 7)\n\n\tPR tree-optimization/31261\n\t* fold-const.c (fold_binary): Optimize ((A & N) + B) & M\n\tfor constants M and N, M == (1LL << cst) - 1 && (N & M) == M.\n\n\t* gcc.dg/tree-ssa/pr31261.c: New test.\n\nFrom-SVN: r164761", "tree": {"sha": "b8f4be9858411bbb0b971675fd0bd1a833a0e271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f4be9858411bbb0b971675fd0bd1a833a0e271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/140d4effd556b7da4a322f8d34c2dde6758d09e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140d4effd556b7da4a322f8d34c2dde6758d09e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/140d4effd556b7da4a322f8d34c2dde6758d09e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/140d4effd556b7da4a322f8d34c2dde6758d09e7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1826acc350a2fcf021b6fa20f515e0bd23b0eb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1826acc350a2fcf021b6fa20f515e0bd23b0eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1826acc350a2fcf021b6fa20f515e0bd23b0eb2"}], "stats": {"total": 178, "additions": 178, "deletions": 0}, "files": [{"sha": "ae7d85d188f976eaed93f4ad794b0c8d9e7c9384", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=140d4effd556b7da4a322f8d34c2dde6758d09e7", "patch": "@@ -1,3 +1,9 @@\n+2010-09-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/31261\n+\t* fold-const.c (fold_binary): Optimize ((A & N) + B) & M\n+\tfor constants M and N, M == (1LL << cst) - 1 && (N & M) == M.\n+\n 2010-09-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR bootstrap/45796"}, {"sha": "b2dbb981cfc2ce89fcbd37f6bbf611c6d7de0a1f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=140d4effd556b7da4a322f8d34c2dde6758d09e7", "patch": "@@ -11071,6 +11071,133 @@ fold_binary_loc (location_t loc,\n \t\t\t      fold_convert_loc (loc, type, arg0));\n \t}\n \n+      /* For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,\n+\t ((A & N) + B) & M -> (A + B) & M\n+\t Similarly if (N & M) == 0,\n+\t ((A | N) + B) & M -> (A + B) & M\n+\t and for - instead of + (or unary - instead of +)\n+\t and/or ^ instead of |.\n+\t If B is constant and (B & M) == 0, fold into A & M.  */\n+      if (host_integerp (arg1, 1))\n+\t{\n+\t  unsigned HOST_WIDE_INT cst1 = tree_low_cst (arg1, 1);\n+\t  if (~cst1 && (cst1 & (cst1 + 1)) == 0\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t      && (TREE_CODE (arg0) == PLUS_EXPR\n+\t\t  || TREE_CODE (arg0) == MINUS_EXPR\n+\t\t  || TREE_CODE (arg0) == NEGATE_EXPR)\n+\t      && (TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n+\t\t  || TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE))\n+\t    {\n+\t      tree pmop[2];\n+\t      int which = 0;\n+\t      unsigned HOST_WIDE_INT cst0;\n+\n+\t      /* Now we know that arg0 is (C + D) or (C - D) or\n+\t\t -C and arg1 (M) is == (1LL << cst) - 1.\n+\t\t Store C into PMOP[0] and D into PMOP[1].  */\n+\t      pmop[0] = TREE_OPERAND (arg0, 0);\n+\t      pmop[1] = NULL;\n+\t      if (TREE_CODE (arg0) != NEGATE_EXPR)\n+\t\t{\n+\t\t  pmop[1] = TREE_OPERAND (arg0, 1);\n+\t\t  which = 1;\n+\t\t}\n+\n+\t      if (!host_integerp (TYPE_MAX_VALUE (TREE_TYPE (arg0)), 1)\n+\t\t  || (tree_low_cst (TYPE_MAX_VALUE (TREE_TYPE (arg0)), 1)\n+\t\t      & cst1) != cst1)\n+\t\twhich = -1;\n+\n+\t      for (; which >= 0; which--)\n+\t\tswitch (TREE_CODE (pmop[which]))\n+\t\t  {\n+\t\t  case BIT_AND_EXPR:\n+\t\t  case BIT_IOR_EXPR:\n+\t\t  case BIT_XOR_EXPR:\n+\t\t    if (TREE_CODE (TREE_OPERAND (pmop[which], 1))\n+\t\t\t!= INTEGER_CST)\n+\t\t      break;\n+\t\t    /* tree_low_cst not used, because we don't care about\n+\t\t       the upper bits.  */\n+\t\t    cst0 = TREE_INT_CST_LOW (TREE_OPERAND (pmop[which], 1));\n+\t\t    cst0 &= cst1;\n+\t\t    if (TREE_CODE (pmop[which]) == BIT_AND_EXPR)\n+\t\t      {\n+\t\t\tif (cst0 != cst1)\n+\t\t\t  break;\n+\t\t      }\n+\t\t    else if (cst0 != 0)\n+\t\t      break;\n+\t\t    /* If C or D is of the form (A & N) where\n+\t\t       (N & M) == M, or of the form (A | N) or\n+\t\t       (A ^ N) where (N & M) == 0, replace it with A.  */\n+\t\t    pmop[which] = TREE_OPERAND (pmop[which], 0);\n+\t\t    break;\n+\t\t  case INTEGER_CST:\n+\t\t    /* If C or D is a N where (N & M) == 0, it can be\n+\t\t       omitted (assumed 0).  */\n+\t\t    if ((TREE_CODE (arg0) == PLUS_EXPR\n+\t\t\t || (TREE_CODE (arg0) == MINUS_EXPR && which == 0))\n+\t\t\t&& (TREE_INT_CST_LOW (pmop[which]) & cst1) == 0)\n+\t\t      pmop[which] = NULL;\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t      /* Only build anything new if we optimized one or both arguments\n+\t\t above.  */\n+\t      if (pmop[0] != TREE_OPERAND (arg0, 0)\n+\t\t  || (TREE_CODE (arg0) != NEGATE_EXPR\n+\t\t      && pmop[1] != TREE_OPERAND (arg0, 1)))\n+\t\t{\n+\t\t  tree utype = type;\n+\t\t  if (! TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))\n+\t\t    {\n+\t\t      /* Perform the operations in a type that has defined\n+\t\t\t overflow behavior.  */\n+\t\t      utype = unsigned_type_for (type);\n+\t\t      if (pmop[0] != NULL)\n+\t\t\tpmop[0] = fold_convert_loc (loc, utype, pmop[0]);\n+\t\t      if (pmop[1] != NULL)\n+\t\t\tpmop[1] = fold_convert_loc (loc, utype, pmop[1]);\n+\t\t    }\n+\n+\t\t  if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\t\t    tem = fold_build1_loc (loc, NEGATE_EXPR, utype, pmop[0]);\n+\t\t  else if (TREE_CODE (arg0) == PLUS_EXPR)\n+\t\t    {\n+\t\t      if (pmop[0] != NULL && pmop[1] != NULL)\n+\t\t\ttem = fold_build2_loc (loc, PLUS_EXPR, utype,\n+\t\t\t\t\t       pmop[0], pmop[1]);\n+\t\t      else if (pmop[0] != NULL)\n+\t\t\ttem = pmop[0];\n+\t\t      else if (pmop[1] != NULL)\n+\t\t\ttem = pmop[1];\n+\t\t      else\n+\t\t\treturn build_int_cst (type, 0);\n+\t\t    }\n+\t\t  else if (pmop[0] == NULL)\n+\t\t    tem = fold_build1_loc (loc, NEGATE_EXPR, utype, pmop[1]);\n+\t\t  else\n+\t\t    tem = fold_build2_loc (loc, MINUS_EXPR, utype,\n+\t\t\t\t\t   pmop[0], pmop[1]);\n+\t\t  /* TEM is now the new binary +, - or unary - replacement.  */\n+\t\t  if (utype == type)\n+\t\t    return fold_build2_loc (loc, BIT_AND_EXPR, type,\n+\t\t\t\t\t    tem, arg1);\n+\t\t  else\n+\t\t    {\n+\t\t      tem = fold_build2_loc (loc, BIT_AND_EXPR, utype, tem,\n+\t\t\t\t\t     fold_convert_loc (loc, utype,\n+\t\t\t\t\t     arg1));\t\t\n+\t\t      return fold_convert_loc (loc, type, tem);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n       t1 = distribute_bit_expr (loc, code, type, arg0, arg1);\n       if (t1 != NULL_TREE)\n \treturn t1;"}, {"sha": "1775235b92d2a43acc9832ff2174dbf841700377", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=140d4effd556b7da4a322f8d34c2dde6758d09e7", "patch": "@@ -1,3 +1,8 @@\n+2010-09-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/31261\n+\t* gcc.dg/tree-ssa/pr31261.c: New test.\n+\n 2010-09-30  Michael Eager  <eager@eagercon.com>\n \n \t* gcc.c-torture/execute/cmpsi-2.c: New testcase."}, {"sha": "42bd2a21ef3483fd68043565d0aec0d9532b4829", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr31261.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31261.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/140d4effd556b7da4a322f8d34c2dde6758d09e7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31261.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr31261.c?ref=140d4effd556b7da4a322f8d34c2dde6758d09e7", "patch": "@@ -0,0 +1,40 @@\n+/* PR tree-optimization/31261 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+unsigned int\n+f1 (unsigned int a)\n+{\n+  return (8 - (a & 7)) & 7;\n+}\n+\n+long int\n+f2 (long int b)\n+{\n+  return (16 + (b & 7)) & 15;\n+}\n+\n+char\n+f3 (char c)\n+{\n+  return -(c & 63) & 31;\n+}\n+\n+int\n+f4 (int d)\n+{\n+  return (12 - (d & 15)) & 7;\n+}\n+\n+int\n+f5 (int e)\n+{\n+  return (12 - (e & 7)) & 15;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return -a \\& 7;\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"return b \\& 7;\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"return \\\\(char\\\\) -\\\\(unsigned char\\\\) c \\& 31;\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"return \\\\(int\\\\) \\\\(12 - \\\\(unsigned int\\\\) d\\\\) \\& 7;\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 12 - \\\\(e \\& 7\\\\) \\& 15;\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}