{"sha": "3a04ff6433538b4cec71fe681ded309db4d91cab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EwNGZmNjQzMzUzOGI0Y2VjNzFmZTY4MWRlZDMwOWRiNGQ5MWNhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-12-09T23:54:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-12-09T23:54:01Z"}, "message": "target.h (gcc_target): Add cannot_force_const_mem.\n\n        * target.h (gcc_target): Add cannot_force_const_mem.\n        * target-def.h (TARGET_CANNOT_FORCE_CONST_MEM): New.\n        (TARGET_INITIALIZER): Add it.\n        * varasm.c (force_const_mem): Fail if cannot_force_const_mem.\n        * expr.c (emit_move_insn): Be prepared for force_const_mem to fail.\n        * reload1.c (reload): Likewise.\n        * hooks.c (hook_bool_rtx_false): New.\n        * hooks.h: Declare it.\n\n        * config/i386/i386.c (ix86_cannot_force_const_mem): New.\n        (TARGET_CANNOT_FORCE_CONST_MEM): New.\n        (ix86_expand_move): Remove de-const-pooling hack.\n\n\t* gcc.dg/tls/opt-4.c: New.\n\nFrom-SVN: r59971", "tree": {"sha": "57341f6e2c1ac600113f5797665b9c84f0d000d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57341f6e2c1ac600113f5797665b9c84f0d000d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a04ff6433538b4cec71fe681ded309db4d91cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a04ff6433538b4cec71fe681ded309db4d91cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a04ff6433538b4cec71fe681ded309db4d91cab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a04ff6433538b4cec71fe681ded309db4d91cab/comments", "author": null, "committer": null, "parents": [{"sha": "a9a4005fca1d4a58133419bc33c89a62fe534cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a4005fca1d4a58133419bc33c89a62fe534cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a4005fca1d4a58133419bc33c89a62fe534cbb"}], "stats": {"total": 136, "additions": 111, "deletions": 25}, "files": [{"sha": "0b812c18a53fddec258f0dca997173dbd797482a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -1,3 +1,18 @@\n+2002-12-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* target.h (gcc_target): Add cannot_force_const_mem.\n+\t* target-def.h (TARGET_CANNOT_FORCE_CONST_MEM): New.\n+\t(TARGET_INITIALIZER): Add it.\n+\t* varasm.c (force_const_mem): Fail if cannot_force_const_mem.\n+\t* expr.c (emit_move_insn): Be prepared for force_const_mem to fail.\n+\t* reload1.c (reload): Likewise.\n+\t* hooks.c (hook_bool_rtx_false): New.\n+\t* hooks.h: Declare it.\n+\n+\t* config/i386/i386.c (ix86_cannot_force_const_mem): New.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): New.\n+\t(ix86_expand_move): Remove de-const-pooling hack.\n+\n Mon Dec  9 21:33:38 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* toplev.c (dump_file): Fix order to match reality."}, {"sha": "42f6d93d3c3089e9c6c7bc8bcfef5e0fe027f7f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -763,6 +763,7 @@ struct ix86_address\n };\n \n static int ix86_decompose_address PARAMS ((rtx, struct ix86_address *));\n+static bool ix86_cannot_force_const_mem PARAMS ((rtx));\n \n static void ix86_encode_section_info PARAMS ((tree, int)) ATTRIBUTE_UNUSED;\n static const char *ix86_strip_name_encoding PARAMS ((const char *))\n@@ -900,6 +901,8 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS true\n #endif\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM ix86_cannot_force_const_mem\n \n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK x86_output_mi_thunk\n@@ -5050,6 +5053,17 @@ legitimate_constant_p (x)\n   return true;\n }\n \n+/* Determine if it's legal to put X into the constant pool.  This\n+   is not possible for the address of thread-local symbols, which\n+   is checked above.  */\n+\n+static bool\n+ix86_cannot_force_const_mem (x)\n+     rtx x;\n+{\n+  return !legitimate_constant_p (x);\n+}\n+\n /* Determine if a given RTX is a valid constant address.  */\n \n bool\n@@ -7686,29 +7700,6 @@ ix86_expand_move (mode, operands)\n   op0 = operands[0];\n   op1 = operands[1];\n \n-  /* ??? We have a slight problem.  We need to say that tls symbols are\n-     not legitimate constants so that reload does not helpfully reload\n-     these constants from a REG_EQUIV, which we cannot handle.  (Recall\n-     that general- and local-dynamic address resolution requires a\n-     function call.)\n-\n-     However, if we say that tls symbols are not legitimate constants,\n-     then emit_move_insn helpfully drop them into the constant pool.\n-\n-     It is far easier to work around emit_move_insn than reload.  Recognize\n-     the MEM that we would have created and extract the symbol_ref.  */\n-\n-  if (mode == Pmode\n-      && GET_CODE (op1) == MEM\n-      && RTX_UNCHANGING_P (op1))\n-    {\n-      tmp = maybe_get_pool_constant (op1);\n-      /* Note that we only care about symbolic constants here, which\n-\t unlike CONST_INT will always have a proper mode.  */\n-      if (tmp && GET_MODE (tmp) == Pmode)\n-\top1 = tmp;\n-    }\n-\n   if (tls_symbolic_operand (op1, Pmode))\n     {\n       op1 = legitimize_address (op1, op1, VOIDmode);"}, {"sha": "f1b2271edd89ed75712bc92baf6c5d8919c9d768", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -3146,6 +3146,12 @@ emit_move_insn (x, y)\n \t{\n \t  y_cst = y;\n \t  y = force_const_mem (mode, y);\n+\n+\t  /* If the target's cannot_force_const_mem prevented the spill,\n+\t     assume that the target's move expanders will also take care\n+\t     of the non-legitimate constant.  */\n+\t  if (!y)\n+\t    y = y_cst;\n \t}\n     }\n "}, {"sha": "3f212ef3e1b69f61237a21c3b10d1c4f0ca42fb9", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -114,3 +114,10 @@ hook_bool_tree_false (a)\n {\n   return false;\n }\n+\n+bool\n+hook_bool_rtx_false (a)\n+     rtx a ATTRIBUTE_UNUSED;\n+{\n+  return false;\n+}"}, {"sha": "8c28194f6aca6c2f80e8189f1186f0ca97336321", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -28,6 +28,7 @@ bool hook_bool_tree_hwi_hwi_tree_false\n   PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n bool hook_bool_tree_hwi_hwi_tree_true\n   PARAMS ((tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n+bool hook_bool_rtx_false PARAMS ((rtx));\n \n void hook_void_tree_int PARAMS ((tree, int));\n void hook_void_void PARAMS ((void));"}, {"sha": "0f5d688c8a516ce771b389d83bfe09634b10cae4", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -817,8 +817,12 @@ reload (first, global)\n \t\t      else if (LEGITIMATE_CONSTANT_P (x))\n \t\t\treg_equiv_constant[i] = x;\n \t\t      else\n-\t\t\treg_equiv_memory_loc[i]\n-\t\t\t  = force_const_mem (GET_MODE (SET_DEST (set)), x);\n+\t\t\t{\n+\t\t\t  reg_equiv_memory_loc[i]\n+\t\t\t    = force_const_mem (GET_MODE (SET_DEST (set)), x);\n+\t\t\t  if (!reg_equiv_memory_loc[i])\n+\t\t\t    continue;\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    continue;"}, {"sha": "154d58d47e9a78570883760130bc659e0b1a6662", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -241,6 +241,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n /* In hook.c.  */\n #define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n+#define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n #define TARGET_COMP_TYPE_ATTRIBUTES hook_int_tree_tree_1\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES hook_void_tree\n #define TARGET_INSERT_ATTRIBUTES hook_void_tree_treeptr\n@@ -272,6 +273,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_EXPAND_BUILTIN,\t\t\t\\\n   TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n   TARGET_CANNOT_MODIFY_JUMPS_P,\t\t\t\\\n+  TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_IN_SMALL_DATA_P,\t\t\t\\\n   TARGET_BINDS_LOCAL_P,\t\t\t\t\\\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\"}, {"sha": "0ac1c5aa17b60d0f7f80177654dd8183dfc3fb92", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -262,6 +262,9 @@ struct gcc_target\n      not, at the current point in the compilation.  */\n   bool (* cannot_modify_jumps_p) PARAMS ((void));\n \n+  /* True if the constant X cannot be placed in the constant pool.  */\n+  bool (* cannot_force_const_mem) PARAMS ((rtx));\n+\n   /* True if EXP should be placed in a \"small data\" section.  */\n   bool (* in_small_data_p) PARAMS ((tree));\n "}, {"sha": "3a95688963b20723b8210154e12dbf6d3a37a4eb", "filename": "gcc/testsuite/gcc.dg/tls/opt-4.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fopt-4.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+struct A\n+{\n+  int a1;\n+  int a2;\n+};\n+\n+extern __thread const unsigned char *tcc1, **tcc2;\n+\n+extern inline const unsigned char ** __attribute__ ((const))\n+foo (void)\n+{\n+  const unsigned char **a = &tcc1;\n+  if (*a == 0)\n+    *a = *tcc2 + 128;\n+  return a;\n+}\n+\n+extern inline int\n+bar (const struct A *x)\n+{\n+  int a;\n+\n+  if (x->a2 & 8)\n+    return 0;\n+  a = x->a1;\n+  return a > 0 && ((*foo ())[a] & 64);\n+}\n+\n+int\n+baz (const struct A *x, char *y)\n+{\n+  const struct A *a;\n+\n+  for (a = x; !!a->a1; a++)\n+    if (! (x->a2 & 8))\n+      if (bar (a))\n+\t{\n+\t  *y++ = a->a1;\n+\t  if (x->a1)\n+\t    *y++ = ':';\n+\t  *y = '\\0';\n+\t}\n+  return 0;\n+}\n+\n+/* Verify tcc1 and tcc2 variables show up only in the TLS access sequences.  */\n+/* { dg-final { scan-assembler \"tcc1@\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-assembler \"tcc2@\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-assembler-not \"tcc1\\[^@\\]\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-assembler-not \"tcc2\\[^@\\]\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "f8b33d080a62dceb8308bbb0c5820efda43c76b1", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a04ff6433538b4cec71fe681ded309db4d91cab/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3a04ff6433538b4cec71fe681ded309db4d91cab", "patch": "@@ -3209,6 +3209,10 @@ force_const_mem (mode, x)\n   struct pool_constant *pool;\n   unsigned int align;\n \n+  /* If we're not allowed to drop X into the constant pool, don't.  */\n+  if ((*targetm.cannot_force_const_mem) (x))\n+    return NULL_RTX;\n+\n   /* Compute hash code of X.  Search the descriptors for that hash code\n      to see if any of them describes X.  If yes, we have an rtx to use.  */\n   hash = const_hash_rtx (mode, x);"}]}