{"sha": "cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyYWMxYzMwYWYwZmE3ODNjOGQ3MmU1Mjc5MDRkZGE1ZDhjYzMzMA==", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-01-12T16:26:15Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2021-01-12T16:27:29Z"}, "message": "[PR97969] LRA: Transform pattern `plus (plus (hard reg, const),\tpseudo)` after elimination\n\nLRA can loop infinitely on targets without `reg + imm` insns.  Register elimination\non such targets can increase register pressure resulting in permanent\nstack size increase and changing elimination offset.  To avoid such situation, a simple\ntransformation can be done to avoid register pressure increase after\ngenerating reload insns containing eliminated hard regs.\n\ngcc/ChangeLog:\n\n\tPR target/97969\n\t* lra-eliminations.c (eliminate_regs_in_insn): Add transformation\n\tof pattern 'plus (plus (hard reg, const), pseudo)'.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/97969\n\t* gcc.target/arm/pr97969.c: New.", "tree": {"sha": "a4bc0604739c4732d2e9770af00f7eabcde03d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4bc0604739c4732d2e9770af00f7eabcde03d2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2ac1c30af0fa783c8d72e527904dda5d8cc330/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0bec6ceac47752616dd9fe0801344ed45db2fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bec6ceac47752616dd9fe0801344ed45db2fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0bec6ceac47752616dd9fe0801344ed45db2fd3"}], "stats": {"total": 82, "additions": 81, "deletions": 1}, "files": [{"sha": "ebcadd1006cee227008c8965c3ce40fe1066551d", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2ac1c30af0fa783c8d72e527904dda5d8cc330/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2ac1c30af0fa783c8d72e527904dda5d8cc330/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "patch": "@@ -885,7 +885,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n \t\t\tpoly_int64 update_sp_offset)\n {\n   int icode = recog_memoized (insn);\n-  rtx old_set = single_set (insn);\n+  rtx set, old_set = single_set (insn);\n   bool validate_p;\n   int i;\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n@@ -1038,6 +1038,32 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n   for (i = 0; i < static_id->n_dups; i++)\n     *id->dup_loc[i] = substed_operand[(int) static_id->dup_num[i]];\n \n+  /* Transform plus (plus (hard reg, const), pseudo) to plus (plus (pseudo,\n+     const), hard reg) in order to keep insn containing eliminated register\n+     after all reloads calculating its offset.  This permits to keep register\n+     pressure under control and helps to avoid LRA cycling in patalogical\n+     cases.  */\n+  if (! replace_p && (set = single_set (insn)) != NULL\n+      && GET_CODE (SET_SRC (set)) == PLUS\n+      && GET_CODE (XEXP (SET_SRC (set), 0)) == PLUS)\n+    {\n+      rtx reg1, reg2, op1, op2;\n+      \n+      reg1 = op1 = XEXP (XEXP (SET_SRC (set), 0), 0);\n+      reg2 = op2 = XEXP (SET_SRC (set), 1);\n+      if (GET_CODE (reg1) == SUBREG)\n+\treg1 = SUBREG_REG (reg1);\n+      if (GET_CODE (reg2) == SUBREG)\n+\treg2 = SUBREG_REG (reg2);\n+      if (REG_P (reg1) && REG_P (reg2)\n+\t  && REGNO (reg1) < FIRST_PSEUDO_REGISTER\n+\t  && REGNO (reg2) >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  XEXP (XEXP (SET_SRC (set), 0), 0) = op2;\n+\t  XEXP (SET_SRC (set), 1) = op1;\n+\t}\n+    }\n+\n   /* If we had a move insn but now we don't, re-recognize it.\n      This will cause spurious re-recognition if the old move had a\n      PARALLEL since the new one still will, but we can't call"}, {"sha": "714a1d1887097d13bb9d698025cb9465b48fa6e6", "filename": "gcc/testsuite/gcc.target/arm/pr97969.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2ac1c30af0fa783c8d72e527904dda5d8cc330/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr97969.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2ac1c30af0fa783c8d72e527904dda5d8cc330/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr97969.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr97969.c?ref=cf2ac1c30af0fa783c8d72e527904dda5d8cc330", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -fno-omit-frame-pointer -mthumb -w -Os\" } */\n+\n+typedef a[23];\n+enum { b };\n+typedef struct {\n+  int c;\n+  char *e;\n+  char f\n+} d;\n+typedef enum { g = 1 } h;\n+typedef struct {\n+  h i;\n+  int j\n+} k;\n+typedef struct {\n+  a l;\n+  int a;\n+  int m;\n+  int n;\n+  int o;\n+  short p;\n+  int q;\n+  k r;\n+  char e;\n+  char *s;\n+  d t;\n+  d *u;\n+  short v;\n+  int w\n+} aa;\n+c(char x, int y, char z, int ab) {\n+  aa ac;\n+  ac.r.i = 0;\n+  d ad;\n+  ac.t = ad;\n+  ac.u = 0;\n+  ae(&ac.v, 0, 0);\n+  ac.w = 0;\n+  af(&ac, x + y, z, z + ab);\n+  if (ag(0))\n+    return 0;\n+  if (x)\n+    ac.s = z + ab;\n+  else\n+    ac.s = x + y;\n+  ac.o |= g;\n+  if (!setjmp()) {\n+    ah(ac);\n+    ai(b);\n+    ac.e = z + ab;\n+    aj(ac);\n+  }\n+}"}]}