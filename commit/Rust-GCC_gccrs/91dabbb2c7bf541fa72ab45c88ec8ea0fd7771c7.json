{"sha": "91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkYWJiYjJjN2JmNTQxZmE3MmFiNDVjODhlYzhlYTBmZDc3NzFjNw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-30T00:01:07Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-30T00:01:07Z"}, "message": "Goodbye REG_LIVE_LENGTH\n\n\t* regs.h (struct reg_info_t): Delete live_length.\n\t(REG_LIVE_LENGTH): Delete macro.\n\t* regstat.c (regstat_bb_compute_ri): Delete artificial_uses,\n\tlocal_live, local_processed and local_live_last_luid params.\n\tReplace bb_index param with bb.  Don't set REG_LIVE_LENGTH.\n\tFormatting fixes.\n\t(regstat_compute_ri): Adjust for above.  Don't set\n\tREG_LIVE_LENGTH.\n\t(dump_reg_info): Don't print live length.\n\t* ira.c (update_equiv_regs): Replace test of REG_LIVE_LENGTH\n\twith test of setjmp_crosses.  Don't set REG_LIVE_LENGTH.\n\tLocalize loop_depth var.\n\nFrom-SVN: r235663", "tree": {"sha": "a016d44be068e81121dd50b88c7bb7e2b08e2c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a016d44be068e81121dd50b88c7bb7e2b08e2c1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "411e5c675d26d342493d8dba910c3887c8846257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/411e5c675d26d342493d8dba910c3887c8846257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/411e5c675d26d342493d8dba910c3887c8846257"}], "stats": {"total": 191, "additions": 38, "deletions": 153}, "files": [{"sha": "8e93e91598897f28886008ce757a64572034613f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "patch": "@@ -1,3 +1,18 @@\n+2016-04-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* regs.h (struct reg_info_t): Delete live_length.\n+\t(REG_LIVE_LENGTH): Delete macro.\n+\t* regstat.c (regstat_bb_compute_ri): Delete artificial_uses,\n+\tlocal_live, local_processed and local_live_last_luid params.\n+\tReplace bb_index param with bb.  Don't set REG_LIVE_LENGTH.\n+\tFormatting fixes.\n+\t(regstat_compute_ri): Adjust for above.  Don't set\n+\tREG_LIVE_LENGTH.\n+\t(dump_reg_info): Don't print live length.\n+\t* ira.c (update_equiv_regs): Replace test of REG_LIVE_LENGTH\n+\twith test of setjmp_crosses.  Don't set REG_LIVE_LENGTH.\n+\tLocalize loop_depth var.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \t* ira.c (enum valid_equiv): New."}, {"sha": "e597604b2ead0d18e732c92585b58bd108b2794a", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "patch": "@@ -3315,7 +3315,6 @@ update_equiv_regs (void)\n {\n   rtx_insn *insn;\n   basic_block bb;\n-  int loop_depth;\n \n   /* Scan insns and set pdx_subregs if the reg is used in a\n      paradoxical subreg.  Don't set such reg equivalent to a mem,\n@@ -3329,9 +3328,10 @@ update_equiv_regs (void)\n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)\n      a register can be set below its use.  */\n+  bitmap setjmp_crosses = regstat_get_setjmp_crosses ();\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      loop_depth = bb_loop_depth (bb);\n+      int loop_depth = bb_loop_depth (bb);\n \n       for (insn = BB_HEAD (bb);\n \t   insn != NEXT_INSN (BB_END (bb));\n@@ -3553,12 +3553,8 @@ update_equiv_regs (void)\n \t      reg_equiv[regno].loop_depth = (short) loop_depth;\n \n \t      /* Don't mess with things live during setjmp.  */\n-\t      if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n+\t      if (optimize && !bitmap_bit_p (setjmp_crosses, regno))\n \t\t{\n-\t\t  /* Note that the statement below does not affect the priority\n-\t\t     in local-alloc!  */\n-\t\t  REG_LIVE_LENGTH (regno) *= 2;\n-\n \t\t  /* If the register is referenced exactly twice, meaning it is\n \t\t     set once and used once, indicate that the reference may be\n \t\t     replaced by the equivalence we computed above.  Do this\n@@ -3744,7 +3740,6 @@ combine_and_move_insns (void)\n \t  REG_N_CALLS_CROSSED (regno) = 0;\n \t  REG_FREQ_CALLS_CROSSED (regno) = 0;\n \t  REG_N_THROWING_CALLS_CROSSED (regno) = 0;\n-\t  REG_LIVE_LENGTH (regno) = 2;\n \n \t  if (use_insn == BB_HEAD (use_bb))\n \t    BB_HEAD (use_bb) = new_insn;"}, {"sha": "244250d127ccb3c85390a2374a0732ed05e83b6a", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "patch": "@@ -105,7 +105,6 @@ struct reg_info_t\n {\n   int freq;\t\t\t/* # estimated frequency (REG n) is used or set */\n   int deaths;\t\t\t/* # of times (REG n) dies */\n-  int live_length;\t\t/* # of instructions (REG n) is live */\n   int calls_crossed;\t\t/* # of calls (REG n) is live across */\n   int freq_calls_crossed;\t/* # estimated frequency (REG n) crosses call */\n   int throw_calls_crossed;\t/* # of calls that may throw (REG n) is live across */\n@@ -170,20 +169,6 @@ extern size_t reg_info_p_size;\n \n #define REG_N_THROWING_CALLS_CROSSED(N) (reg_info_p[N].throw_calls_crossed)\n \n-/* Total number of instructions at which (REG n) is live.\n-   \n-   This is set in regstat.c whenever register info is requested and\n-   remains valid for the rest of the compilation of the function; it is\n-   used to control register allocation.  The larger this is, the less\n-   priority (REG n) gets for allocation in a hard register (in IRA in\n-   priority-coloring mode).\n-\n-   Negative values are special: -1 is used to mark a pseudo reg that\n-   should not be allocated to a hard register, because it crosses a\n-   setjmp call.  */\n-\n-#define REG_LIVE_LENGTH(N)  (reg_info_p[N].live_length)\n-\n /* Indexed by n, gives number of basic block that  (REG n) is used in.\n    If the value is REG_BLOCK_GLOBAL (-1),\n    it means (REG n) is used in more than one basic block."}, {"sha": "b25a63c8258e91f70cdd1163c73bb1addeed61b0", "filename": "gcc/regstat.c", "status": "modified", "additions": 20, "deletions": 130, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=91dabbb2c7bf541fa72ab45c88ec8ea0fd7771c7", "patch": "@@ -94,7 +94,7 @@ regstat_free_n_sets_and_refs (void)\n /*----------------------------------------------------------------------------\n    REGISTER INFORMATION\n \n-   Process REG_N_DEATHS, REG_LIVE_LENGTH, REG_N_CALLS_CROSSED,\n+   Process REG_N_DEATHS, REG_N_CALLS_CROSSED,\n    REG_N_THROWING_CALLS_CROSSED and REG_BASIC_BLOCK.\n \n    ----------------------------------------------------------------------------*/\n@@ -106,24 +106,17 @@ struct reg_info_t *reg_info_p;\n size_t reg_info_p_size;\n \n /* Compute register info: lifetime, bb, and number of defs and uses\n-   for basic block BB.  The three bitvectors are scratch regs used\n-   here.  */\n+   for basic block BB.  LIVE is a scratch bitvector used here.  */\n \n static void\n-regstat_bb_compute_ri (unsigned int bb_index,\n-\t\t       bitmap live, bitmap artificial_uses,\n-\t\t       bitmap local_live, bitmap local_processed,\n-\t\t       int *local_live_last_luid)\n+regstat_bb_compute_ri (basic_block bb, bitmap live)\n {\n-  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n   rtx_insn *insn;\n   df_ref def, use;\n-  int luid = 0;\n   bitmap_iterator bi;\n   unsigned int regno;\n \n   bitmap_copy (live, df_get_live_out (bb));\n-  bitmap_clear (artificial_uses);\n \n   /* Process the regs live at the end of the block.  Mark them as\n      not local to any one basic block.  */\n@@ -132,30 +125,26 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \n   /* Process the artificial defs and uses at the bottom of the block\n      to begin processing.  */\n-  FOR_EACH_ARTIFICIAL_DEF (def, bb_index)\n+  FOR_EACH_ARTIFICIAL_DEF (def, bb->index)\n     if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) == 0)\n       bitmap_clear_bit (live, DF_REF_REGNO (def));\n \n-  FOR_EACH_ARTIFICIAL_USE (use, bb_index)\n+  FOR_EACH_ARTIFICIAL_USE (use, bb->index)\n     if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == 0)\n       {\n \tregno = DF_REF_REGNO (use);\n \tbitmap_set_bit (live, regno);\n-\tbitmap_set_bit (artificial_uses, regno);\n       }\n \n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       bitmap_iterator bi;\n-      df_mw_hardreg *mw;\n       rtx link;\n \n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      luid++;\n-\n       link = REG_NOTES (insn);\n       while (link)\n \t{\n@@ -194,82 +183,24 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t    }\n \t}\n \n-      /* We only care about real sets for calls.  Clobbers cannot\n-\t be depended on.\n-\t Only do this if the value is totally dead.  */\n-      FOR_EACH_INSN_INFO_MW (mw, insn_info)\n-\tif (DF_MWS_REG_DEF_P (mw))\n-\t  {\n-\t    bool all_dead = true;\n-\t    unsigned int r;\n-\n-\t    for (r = mw->start_regno; r <= mw->end_regno; r++)\n-\t      if (bitmap_bit_p (artificial_uses, r)\n-\t\t  || bitmap_bit_p (live, r))\n-\t\t{\n-\t\t  all_dead = false;\n-\t\t  break;\n-\t\t}\n-\n-\t    if (all_dead)\n-\t      {\n-\t\tregno = mw->start_regno;\n-\t\tREG_LIVE_LENGTH (regno)++;\n-\t      }\n-\t  }\n-\n       /* All of the defs except the return value are some sort of\n \t clobber.  This code is for the return.  */\n       FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t{\n \t  if ((!CALL_P (insn))\n-\t      || (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n+\t      || (!(DF_REF_FLAGS (def)\n+\t\t    & (DF_REF_MUST_CLOBBER | DF_REF_MAY_CLOBBER))))\n \t    {\n \t      unsigned int dregno = DF_REF_REGNO (def);\n \n-\t      if (bitmap_bit_p (live, dregno))\n-\t\t{\n-\t\t  /* If we have seen a use of DREGNO somewhere before (i.e.\n-\t\t     later in this basic block), and DEF is not a subreg\n-\t\t     store or conditional store, then kill the register\n-\t\t     here and add the proper length to its REG_LIVE_LENGTH.\n-\n-\t\t     If we have not seen a use of DREGNO later in this basic\n-\t\t     block, then we need to add the length from here to the\n-\t\t     end of the block to the live length.  */\n-\t\t  if (bitmap_bit_p (local_live, dregno))\n-\t\t    {\n-\t\t      /* Note that LOCAL_LIVE implies LOCAL_PROCESSED, so\n-\t\t\t we don't have to set LOCAL_PROCESSED in this clause.  */\n-\t\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t\t{\n-\t\t\t  REG_LIVE_LENGTH (dregno) +=\n-\t\t\t    (luid - local_live_last_luid[dregno]);\n-\t\t\t  local_live_last_luid[dregno] = luid;\n-\t\t\t  bitmap_clear_bit (local_live, dregno);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      bitmap_set_bit (local_processed, dregno);\n-\t\t      REG_LIVE_LENGTH (dregno) += luid;\n-\t\t      local_live_last_luid[dregno] = luid;\n-\t\t    }\n-\n-\t\t  /* Kill this register if it is not a subreg store or\n-\t\t     conditional store.\n-\t\t     ??? This means that any partial store is live from\n-\t\t     the last use in a basic block to the start of this\n-\t\t     basic block.  This results in poor calculations of\n-\t\t     REG_LIVE_LENGTH in large basic blocks.  */\n-\t\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t    bitmap_clear_bit (live, dregno);\n-\t\t}\n-\t      else if ((!(DF_REF_FLAGS (def) & DF_REF_MW_HARDREG))\n-\t\t       && (!bitmap_bit_p (artificial_uses, dregno)))\n-\t\t{\n-\t\t  REG_LIVE_LENGTH (dregno)++;\n-\t\t}\n+\t      /* Kill this register if it is not a subreg store or\n+\t\t conditional store.\n+\t\t ??? This means that any partial store is live from\n+\t\t the last use in a basic block to the start of this\n+\t\t basic block.  */\n+\t      if (!(DF_REF_FLAGS (def)\n+\t\t    & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t\tbitmap_clear_bit (live, dregno);\n \n \t      if (dregno >= FIRST_PSEUDO_REGISTER)\n \t\t{\n@@ -300,37 +231,8 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t      else if (REG_BASIC_BLOCK (uregno) != bb->index)\n \t\tREG_BASIC_BLOCK (uregno) = REG_BLOCK_GLOBAL;\n \t    }\n-\n-\t  if (bitmap_set_bit (live, uregno))\n-\t    {\n-\t      /* This register is now live.  Begin to process it locally.\n-\n-\t\t Note that we don't even get here if the variable was live\n-\t\t at the end of the block since just a ref inside the block\n-\t\t does not effect the calculations.  */\n-\t      REG_LIVE_LENGTH (uregno) ++;\n-\t      local_live_last_luid[uregno] = luid;\n-\t      bitmap_set_bit (local_live, uregno);\n-\t      bitmap_set_bit (local_processed, uregno);\n-\t    }\n \t}\n     }\n-\n-  /* Add the liveness length to all registers that were used somewhere\n-     in this bock, but not between that use and the head of this block.  */\n-  EXECUTE_IF_SET_IN_BITMAP (local_live, 0, regno, bi)\n-    {\n-      REG_LIVE_LENGTH (regno) += (luid - local_live_last_luid[regno]);\n-    }\n-\n-  /* Add the length of the block to all of the registers that were not\n-     referenced, but still live in this block.  */\n-  bitmap_and_compl_into (live, local_processed);\n-  EXECUTE_IF_SET_IN_BITMAP (live, 0, regno, bi)\n-    REG_LIVE_LENGTH (regno) += luid;\n-\n-  bitmap_clear (local_processed);\n-  bitmap_clear (local_live);\n }\n \n \n@@ -340,12 +242,8 @@ regstat_compute_ri (void)\n {\n   basic_block bb;\n   bitmap live = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap artificial_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap local_live = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap local_processed = BITMAP_ALLOC (&df_bitmap_obstack);\n   unsigned int regno;\n   bitmap_iterator bi;\n-  int *local_live_last_luid;\n \n   /* Initialize everything.  */\n \n@@ -356,26 +254,18 @@ regstat_compute_ri (void)\n   max_regno = max_reg_num ();\n   reg_info_p_size = max_regno;\n   reg_info_p = XCNEWVEC (struct reg_info_t, max_regno);\n-  local_live_last_luid = XNEWVEC (int, max_regno);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      regstat_bb_compute_ri (bb->index, live, artificial_uses,\n-\t\t\t     local_live, local_processed,\n-\t\t\t     local_live_last_luid);\n+      regstat_bb_compute_ri (bb, live);\n     }\n \n   BITMAP_FREE (live);\n-  BITMAP_FREE (artificial_uses);\n-  BITMAP_FREE (local_live);\n-  BITMAP_FREE (local_processed);\n-  free (local_live_last_luid);\n \n   /* See the setjmp comment in regstat_bb_compute_ri.  */\n   EXECUTE_IF_SET_IN_BITMAP (setjmp_crosses, FIRST_PSEUDO_REGISTER, regno, bi)\n     {\n       REG_BASIC_BLOCK (regno) = REG_BLOCK_UNKNOWN;\n-      REG_LIVE_LENGTH (regno) = -1;\n     }\n \n   timevar_pop (TV_REG_STATS);\n@@ -533,11 +423,11 @@ dump_reg_info (FILE *file)\n       enum reg_class rclass, altclass;\n \n       if (regstat_n_sets_and_refs)\n-\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+\tfprintf (file, \"\\nRegister %d used %d times\",\n+\t\t i, REG_N_REFS (i));\n       else if (df)\n-\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i), REG_LIVE_LENGTH (i));\n+\tfprintf (file, \"\\nRegister %d used %d times\",\n+\t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i));\n \n       if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS)\n \tfprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));"}]}