{"sha": "77dec51842c1ffd485e43051b4a0228ff8941a18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdkZWM1MTg0MmMxZmZkNDg1ZTQzMDUxYjRhMDIyOGZmODk0MWExOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-09T22:52:33Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-09T22:52:33Z"}, "message": "Make-lang.in (convert.o): Depend on convert.h.\n\n\t* Make-lang.in (convert.o): Depend on convert.h.\n\t* convert.c: Header and comment cleanups.\n\t(gfc_thruthvalue_conversion): Rename static function\n\tto truthvalue_conversion.  Do not use 'internal_error' from here,\n\tuse 'gcc_unreachable' instead.\n\t(convert): Do not use 'error' for conversions to void, use\n\t'gcc_unreachable' instead.  Likewise for conversions to non-scalar\n\ttypes.  Do not hanlde ENUMERAL_TYPE, the front end never creates them.\n\tClean up #if 0 code.\n\nFrom-SVN: r185160", "tree": {"sha": "010b236b83a412fa904b1317cbd64a1b6ff04b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/010b236b83a412fa904b1317cbd64a1b6ff04b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77dec51842c1ffd485e43051b4a0228ff8941a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dec51842c1ffd485e43051b4a0228ff8941a18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77dec51842c1ffd485e43051b4a0228ff8941a18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dec51842c1ffd485e43051b4a0228ff8941a18/comments", "author": null, "committer": null, "parents": [{"sha": "935a74eea21a6f4a7d8eec67de92fb3325181279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935a74eea21a6f4a7d8eec67de92fb3325181279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935a74eea21a6f4a7d8eec67de92fb3325181279"}], "stats": {"total": 126, "additions": 42, "deletions": 84}, "files": [{"sha": "1683a10cdda973db0846eaf82d6b8eccb501adbf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=77dec51842c1ffd485e43051b4a0228ff8941a18", "patch": "@@ -1,3 +1,15 @@\n+2012-03-09  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* Make-lang.in (convert.o): Depend on convert.h.\n+\t* convert.c: Header and comment cleanups.\n+\t(gfc_thruthvalue_conversion): Rename static function\n+\tto truthvalue_conversion.  Do not use 'internal_error' from here,\n+\tuse 'gcc_unreachable' instead.\n+\t(convert): Do not use 'error' for conversions to void, use\n+\t'gcc_unreachable' instead.  Likewise for conversions to non-scalar\n+\ttypes.  Do not hanlde ENUMERAL_TYPE, the front end never creates them.\n+\tClean up #if 0 code.\n+\n 2012-03-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/52469"}, {"sha": "d5a6c88dad9a9f23b9b4579293d9278caf801f44", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=77dec51842c1ffd485e43051b4a0228ff8941a18", "patch": "@@ -1,6 +1,7 @@\n # -*- makefile -*-\n # Top level makefile fragment for GNU gfortran, the GNU Fortran 95 compiler.\n-# Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+# Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+# 2011, 2012\n # Free Software Foundation, Inc.\n # Contributed by Paul Brook <paul@nowt.org\n # and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -346,7 +347,7 @@ fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   $(TM_H) debug.h langhooks.h $(FLAGS_H) $(EXPR_H) $(LANGHOOKS_DEF_H) \\\n   libfuncs.h expr.h $(DIAGNOSTIC_H)\n fortran/scanner.o: toplev.h fortran/cpp.h\n-fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/convert.o: $(GFORTRAN_TRANS_DEPS) convert.h\n fortran/frontend-passes.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS) tree-iterator.h\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\"}, {"sha": "52476adbb52aaf6811fdaa50c0cf89e76fe7a067", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 25, "deletions": 81, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=77dec51842c1ffd485e43051b4a0228ff8941a18", "patch": "@@ -1,5 +1,5 @@\n-/* Language-level data type conversion for GNU C.\n-   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2007, 2008, 2010\n+/* Data type conversion\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2007, 2008, 2010, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -19,62 +19,23 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n \n-/* This file contains the functions for converting C expressions\n-   to different data types.  The only entry point is `convert'.\n-   Every language front end must have a `convert' function\n-   but what kind of conversions it does will depend on the language.  */\n-\n-/* copied from the f77 frontend I think */\n-\n-/* copied from c-convert.c without significant modification*/\n-/* Change of width--truncation and extension of integers or reals--\n-   is represented with NOP_EXPR.  Proper functioning of many things\n-   assumes that no other conversions can be NOP_EXPRs.\n-*/\n-\n-/* I've added support for WITH_RECORD_EXPR.  */\n+/* This file contains the functions for converting expressions to\n+   different data types for the translation of the gfortran internal\n+   representation to GIMPLE.  The only entry point is `convert'.  */\n \n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"flags.h\"\n #include \"convert.h\"\n-#include \"diagnostic-core.h\"\t/* For error.  */\n-#include \"gfortran.h\"\n-#include \"trans.h\"\n-\n-/*\n-   Conversion between integer and pointer is represented with CONVERT_EXPR.\n-   Converting integer to real uses FLOAT_EXPR\n-   and real to integer uses FIX_TRUNC_EXPR.\n-\n-   Here is a list of all the functions that assume that widening and\n-   narrowing is always done with a NOP_EXPR:\n-     In convert.c, convert_to_integer.\n-     In c-typeck.c, build_binary_op (boolean ops), and\n-\tc_common_truthvalue_conversion.\n-     In expr.c: expand_expr, for operands of a MULT_EXPR.\n-     In fold-const.c: fold.\n-     In tree.c: get_narrower and get_unwidened.  */\n-\n-/* Subroutines of `convert'.  */\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n-   or validate its data type for an `if' or `while' statement or ?..: exp.\n+   or validate its data type for a GIMPLE `if' or `while' statement.\n \n-   This preparation consists of taking the ordinary\n-   representation of an expression expr and producing a valid tree\n-   boolean expression describing whether expr is nonzero.  We could\n-   simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),\n-   but we optimize comparisons, &&, ||, and !.\n-\n-   The resulting type should always be `boolean_type_node'.\n-   This is much simpler than the corresponding C version because we have a\n-   distinct boolean type.  */\n+   The resulting type should always be `boolean_type_node'.  */\n \n static tree\n-gfc_truthvalue_conversion (tree expr)\n+truthvalue_conversion (tree expr)\n {\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n@@ -101,7 +62,7 @@ gfc_truthvalue_conversion (tree expr)\n \t\t\t\texpr, build_int_cst (TREE_TYPE (expr), 0));\n \n     default:\n-      internal_error (\"Unexpected type in truthvalue_conversion\");\n+      gcc_unreachable ();\n     }\n }\n \n@@ -110,50 +71,33 @@ gfc_truthvalue_conversion (tree expr)\n    is always TYPE.  This function implements all reasonable\n    conversions; callers should filter out those that are\n    not permitted by the language being compiled.  */\n-/* We are assuming that given a SIMPLE val, the result will be a SIMPLE rhs.\n-   If this is not the case, we will abort with an internal error.  */\n+\n tree\n convert (tree type, tree expr)\n {\n   tree e = expr;\n-  enum tree_code code = TREE_CODE (type);\n+  enum tree_code code;\n \n-  if (type == TREE_TYPE (expr)\n+  if (type == TREE_TYPE (expr))\n+    return expr;\n+\n+  if (TREE_CODE (type) == ERROR_MARK\n       || TREE_CODE (expr) == ERROR_MARK\n-      || code == ERROR_MARK || TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+      || TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return expr;\n \n+  gcc_checking_assert (TREE_CODE (TREE_TYPE (expr)) != VOID_TYPE);\n+\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n     return fold_build1_loc (input_location, NOP_EXPR, type, expr);\n-  if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n-    return error_mark_node;\n-  if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n-    {\n-      error (\"void value not ignored as it ought to be\");\n-      return error_mark_node;\n-    }\n+\n+  code = TREE_CODE (type);\n   if (code == VOID_TYPE)\n     return fold_build1_loc (input_location, CONVERT_EXPR, type, e);\n-#if 0\n-  /* This is incorrect.  A truncation can't be stripped this way.\n-     Extensions will be stripped by the use of get_unwidened.  */\n-  if (TREE_CODE (expr) == NOP_EXPR)\n-    return convert (type, TREE_OPERAND (expr, 0));\n-#endif\n-  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n-    return fold (convert_to_integer (type, e));\n   if (code == BOOLEAN_TYPE)\n-    {\n-      e = gfc_truthvalue_conversion (e);\n-\n-      /* If we have a NOP_EXPR, we must fold it here to avoid\n-\t infinite recursion between fold () and convert ().  */\n-      if (TREE_CODE (e) == NOP_EXPR)\n-\treturn fold_build1_loc (input_location, NOP_EXPR, type,\n-\t\t\t\tTREE_OPERAND (e, 0));\n-      else\n-\treturn fold_build1_loc (input_location, NOP_EXPR, type, e);\n-    }\n+    return truthvalue_conversion (e);\n+  if (code == INTEGER_TYPE)\n+    return fold (convert_to_integer (type, e));\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));\n   if (code == REAL_TYPE)\n@@ -163,6 +107,6 @@ convert (tree type, tree expr)\n   if (code == VECTOR_TYPE)\n     return fold (convert_to_vector (type, e));\n \n-  error (\"conversion to non-scalar type requested\");\n-  return error_mark_node;\n+  gcc_unreachable ();\n }\n+"}, {"sha": "52d1887661a04b881b85ca66cf2246b685f048c0", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dec51842c1ffd485e43051b4a0228ff8941a18/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=77dec51842c1ffd485e43051b4a0228ff8941a18", "patch": "@@ -1,5 +1,6 @@\n /* gfortran backend interface\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook.\n "}]}