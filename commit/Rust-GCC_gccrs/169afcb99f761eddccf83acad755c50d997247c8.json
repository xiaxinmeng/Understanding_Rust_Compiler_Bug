{"sha": "169afcb99f761eddccf83acad755c50d997247c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5YWZjYjk5Zjc2MWVkZGNjZjgzYWNhZDc1NWM1MGQ5OTcyNDdjOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-16T06:58:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-16T06:58:43Z"}, "message": "decl.c (make_type_from_size): Just copy TYPE_NAME.\n\n\t* gcc-interface/decl.c (make_type_from_size) <INTEGER_TYPE>: Just copy\n\tTYPE_NAME.\n\t* gcc-interface/trans.c (smaller_packable_type_p): Rename into...\n\t(smaller_form_type_p): ...this.  Change parameter and variable names.\n\t(call_to_gnu): Use the nominal type of the parameter to create the\n\ttemporary if it's a smaller form of the actual type.\n\t(addressable_p): Return false if the actual type is integral and its\n\tsize is greater than that of the expected type.\n\nFrom-SVN: r158398", "tree": {"sha": "662fccb4b15738e06e8970052669564113a2ab07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/662fccb4b15738e06e8970052669564113a2ab07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/169afcb99f761eddccf83acad755c50d997247c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/169afcb99f761eddccf83acad755c50d997247c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/169afcb99f761eddccf83acad755c50d997247c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/169afcb99f761eddccf83acad755c50d997247c8/comments", "author": null, "committer": null, "parents": [{"sha": "1f24872b632a4bfab84e21ec2ffac269a33478a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f24872b632a4bfab84e21ec2ffac269a33478a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f24872b632a4bfab84e21ec2ffac269a33478a7"}], "stats": {"total": 146, "additions": 114, "deletions": 32}, "files": [{"sha": "a12e7db32014868bdef6ff851dd87d83a0786aa3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -1,3 +1,14 @@\n+2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (make_type_from_size) <INTEGER_TYPE>: Just copy\n+\tTYPE_NAME.\n+\t* gcc-interface/trans.c (smaller_packable_type_p): Rename into...\n+\t(smaller_form_type_p): ...this.  Change parameter and variable names.\n+\t(call_to_gnu): Use the nominal type of the parameter to create the\n+\ttemporary if it's a smaller form of the actual type.\n+\t(addressable_p): Return false if the actual type is integral and its\n+\tsize is greater than that of the expected type.\n+\n 2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/cuintp.c (UI_To_gnu): Fix long line."}, {"sha": "44c39299558421c2d5ec20396313d3ed997173fc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -7748,14 +7748,9 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       SET_TYPE_RM_MAX_VALUE (new_type,\n \t\t\t     convert (TREE_TYPE (new_type),\n \t\t\t\t      TYPE_MAX_VALUE (type)));\n-      /* Propagate the name to avoid creating a fake subrange type.  */\n-      if (TYPE_NAME (type))\n-\t{\n-\t  if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n-\t    TYPE_NAME (new_type) = DECL_NAME (TYPE_NAME (type));\n-\t  else\n-\t    TYPE_NAME (new_type) = TYPE_NAME (type);\n-\t}\n+      /* Copy the name to show that it's essentially the same type and\n+\t not a subrange type.  */\n+      TYPE_NAME (new_type) = TYPE_NAME (type);\n       TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n       SET_TYPE_RM_SIZE (new_type, bitsize_int (size));\n       return new_type;"}, {"sha": "ee8eedcd15bd1d346378b8cb2ed2df929a8a24b9", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -207,7 +207,7 @@ static tree emit_check (tree, tree, int, Node_Id);\n static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool, Node_Id);\n-static bool smaller_packable_type_p (tree, tree);\n+static bool smaller_form_type_p (tree, tree);\n static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n@@ -2639,17 +2639,21 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t      (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))\n \t    gnu_orig = gnu_name = TREE_OPERAND (gnu_name, 0);\n \n-\t  /* Otherwise convert to the nominal type of the object if it's\n-\t     a record type.  There are several cases in which we need to\n-\t     make the temporary using this type instead of the actual type\n-\t     of the object if they are distinct, because the expectations\n-\t     of the callee would otherwise not be met:\n+\t  /* Otherwise convert to the nominal type of the object if needed.\n+\t     There are several cases in which we need to make the temporary\n+\t     using this type instead of the actual type of the object when\n+\t     they are distinct, because the expectations of the callee would\n+\t     otherwise not be met:\n \t       - if it's a justified modular type,\n-\t       - if the actual type is a smaller packable version of it.  */\n-\t  else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n-\t\t   && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)\n-\t\t       || smaller_packable_type_p (TREE_TYPE (gnu_name),\n-\t\t\t\t\t\t   gnu_name_type)))\n+\t       - if the actual type is a smaller form of it,\n+\t       - if it's a smaller form of the actual type.  */\n+\t  else if ((TREE_CODE (gnu_name_type) == RECORD_TYPE\n+\t\t    && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)\n+\t\t        || smaller_form_type_p (TREE_TYPE (gnu_name),\n+\t\t\t\t\t        gnu_name_type)))\n+\t\t   || (INTEGRAL_TYPE_P (gnu_name_type)\n+\t\t       && smaller_form_type_p (gnu_name_type,\n+\t\t\t\t\t       TREE_TYPE (gnu_name))))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n \t  /* Create an explicit temporary holding the copy.  This ensures that\n@@ -6873,28 +6877,28 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   return convert (gnu_type, gnu_result);\n }\n \f\n-/* Return true if TYPE is a smaller packable version of RECORD_TYPE.  */\n+/* Return true if TYPE is a smaller form of ORIG_TYPE.  */\n \n static bool\n-smaller_packable_type_p (tree type, tree record_type)\n+smaller_form_type_p (tree type, tree orig_type)\n {\n-  tree size, rsize;\n+  tree size, osize;\n \n   /* We're not interested in variants here.  */\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (record_type))\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig_type))\n     return false;\n \n   /* Like a variant, a packable version keeps the original TYPE_NAME.  */\n-  if (TYPE_NAME (type) != TYPE_NAME (record_type))\n+  if (TYPE_NAME (type) != TYPE_NAME (orig_type))\n     return false;\n \n   size = TYPE_SIZE (type);\n-  rsize = TYPE_SIZE (record_type);\n+  osize = TYPE_SIZE (orig_type);\n \n-  if (!(TREE_CODE (size) == INTEGER_CST && TREE_CODE (rsize) == INTEGER_CST))\n+  if (!(TREE_CODE (size) == INTEGER_CST && TREE_CODE (osize) == INTEGER_CST))\n     return false;\n \n-  return tree_int_cst_lt (size, rsize) != 0;\n+  return tree_int_cst_lt (size, osize) != 0;\n }\n \n /* Return true if GNU_EXPR can be directly addressed.  This is the case\n@@ -6959,13 +6963,21 @@ smaller_packable_type_p (tree type, tree record_type)\n static bool\n addressable_p (tree gnu_expr, tree gnu_type)\n {\n-  /* The size of the real type of the object must not be smaller than\n-     that of the expected type, otherwise an indirect access in the\n-     latter type would be larger than the object.  Only records need\n-     to be considered in practice.  */\n+  /* For an integral type, the size of the actual type of the object may not\n+     be greater than that of the expected type, otherwise an indirect access\n+     in the latter type wouldn't correctly set all the bits of the object.  */\n+  if (gnu_type\n+      && INTEGRAL_TYPE_P (gnu_type)\n+      && smaller_form_type_p (gnu_type, TREE_TYPE (gnu_expr)))\n+    return false;\n+\n+  /* The size of the actual type of the object may not be smaller than that\n+     of the expected type, otherwise an indirect access in the latter type\n+     would be larger than the object.  But only record types need to be\n+     considered in practice for this case.  */\n   if (gnu_type\n       && TREE_CODE (gnu_type) == RECORD_TYPE\n-      && smaller_packable_type_p (TREE_TYPE (gnu_expr), gnu_type))\n+      && smaller_form_type_p (TREE_TYPE (gnu_expr), gnu_type))\n     return false;\n \n   switch (TREE_CODE (gnu_expr))"}, {"sha": "a0ee05e5b6f56ef512e8b900fb90d12ddb66aa57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -1,3 +1,8 @@\n+2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/wide_boolean.adb: New test.\n+\t* gnat.dg/wide_boolean_pkg.ad[sb]: New helper.\n+\n 2010-04-15  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/ipa/ipa-pta-1.c: New testcase."}, {"sha": "6cbbcf14c9171e735bd2625017727bde04c56621", "filename": "gcc/testsuite/gnat.dg/wide_boolean.adb", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean.adb?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do run }\n+\n+with Wide_Boolean_Pkg; use Wide_Boolean_Pkg;\n+\n+procedure Wide_Boolean is\n+\n+   R : TREC;\n+   LB_TEST_BOOL : TBOOL;\n+\n+begin\n+\n+   R.B := FALSE;\n+   LB_TEST_BOOL := FALSE;\n+\n+   Modify (R.H, R.B);\n+   if (R.B /= TRUE) then\n+     raise Program_Error;\n+   end if;\n+\n+   Modify (R.H, LB_TEST_BOOL);\n+   R.B := LB_TEST_BOOL;\n+   if (R.B /= TRUE) then\n+     raise Program_Error;\n+   end if;\n+\n+end;"}, {"sha": "c61efca5705ff85cbfd3d9cb16a1c52ab7036714", "filename": "gcc/testsuite/gnat.dg/wide_boolean_pkg.adb", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.adb?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -0,0 +1,9 @@\n+package body Wide_Boolean_Pkg is\n+\n+   procedure Modify (LH : in out TUINT32; LB : in out TBOOL) is\n+   begin\n+      LH := 16#12345678#;\n+      LB := TRUE;\n+   end;\n+\n+end Wide_Boolean_Pkg;"}, {"sha": "2dda1abb70397262d017846627be69ef54fe2889", "filename": "gcc/testsuite/gnat.dg/wide_boolean_pkg.ads", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/169afcb99f761eddccf83acad755c50d997247c8/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwide_boolean_pkg.ads?ref=169afcb99f761eddccf83acad755c50d997247c8", "patch": "@@ -0,0 +1,24 @@\n+package Wide_Boolean_Pkg is\n+\n+   type TBOOL is new BOOLEAN;\n+   for  TBOOL use (FALSE => 0, TRUE => 1);\n+   for  TBOOL'SIZE use 8;\n+\n+   type TUINT32 is mod (2 ** 32);\n+   for  TUINT32'SIZE use 32;\n+\n+   type TREC is\n+      record\n+         H : TUINT32;\n+         B : TBOOL;\n+      end record;\n+   for TREC use\n+      record\n+         H at 0 range 0..31;\n+         B at 4 range 0..31;\n+      end record;\n+\n+   procedure Modify (LH : in out TUINT32; LB : in out TBOOL);\n+   pragma export(C, Modify, \"Modify\");\n+\n+end Wide_Boolean_Pkg;"}]}