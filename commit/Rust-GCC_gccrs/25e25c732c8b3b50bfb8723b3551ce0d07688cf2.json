{"sha": "25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlMjVjNzMyYzhiM2I1MGJmYjg3MjNiMzU1MWNlMGQwNzY4OGNmMg==", "commit": {"author": {"name": "Dehao Chen", "email": "dehao@google.com", "date": "2013-05-24T15:04:09Z"}, "committer": {"name": "Dehao Chen", "email": "dehao@gcc.gnu.org", "date": "2013-05-24T15:04:09Z"}, "message": "Change the discriminator assignment algorithm to make it more robust.\n\n2013-05-24  Dehao Chen  <dehao@google.com>\n\n\t* gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c: New Testcase.\n\t* gcc/tree-cfg.c (locus_descrim_hasher::hash): Change discrminator\n\thash function.\n\t(locus_descrim_hasher::equal): Likewise.\n\t(build_gimple_cfg): New discrminator assignmnet algorithm\n\t(make_edges): Likewise.\n\t(next_discriminator_for_locus): Likewise.\n\t(same_line_p): Likewise.\n\t(assign_discriminators): Likewise.\n\t(make_cond_expr_edges): Likewise.\n\t(make_gimple_switch_edges): Likewise.\n\t(make_goto_expr_edges): Likewise.\n\t(make_gimple_asm_edges): Likewise.\n\nFrom-SVN: r199295", "tree": {"sha": "6f0955f1b454bbe3c182be036de20ee646ce268b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f0955f1b454bbe3c182be036de20ee646ce268b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/comments", "author": {"login": "danielcdh", "id": 694263, "node_id": "MDQ6VXNlcjY5NDI2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/694263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielcdh", "html_url": "https://github.com/danielcdh", "followers_url": "https://api.github.com/users/danielcdh/followers", "following_url": "https://api.github.com/users/danielcdh/following{/other_user}", "gists_url": "https://api.github.com/users/danielcdh/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielcdh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielcdh/subscriptions", "organizations_url": "https://api.github.com/users/danielcdh/orgs", "repos_url": "https://api.github.com/users/danielcdh/repos", "events_url": "https://api.github.com/users/danielcdh/events{/privacy}", "received_events_url": "https://api.github.com/users/danielcdh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06d50e2171f742c192a195afaf1f7eac000633a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d50e2171f742c192a195afaf1f7eac000633a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d50e2171f742c192a195afaf1f7eac000633a9"}], "stats": {"total": 101, "additions": 66, "deletions": 35}, "files": [{"sha": "f5675d9e32eab49c4fb61381c52e6f581066e766", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "patch": "@@ -1,3 +1,19 @@\n+2013-05-24  Dehao Chen  <dehao@google.com>\n+\n+\t* gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c: New Testcase.\n+\t* gcc/tree-cfg.c (locus_descrim_hasher::hash): Change discrminator\n+\thash function.\n+\t(locus_descrim_hasher::equal): Likewise.\n+\t(build_gimple_cfg): New discrminator assignmnet algorithm\n+\t(make_edges): Likewise.\n+\t(next_discriminator_for_locus): Likewise.\n+\t(same_line_p): Likewise.\n+\t(assign_discriminators): Likewise.\n+\t(make_cond_expr_edges): Likewise.\n+\t(make_gimple_switch_edges): Likewise.\n+\t(make_goto_expr_edges): Likewise.\n+\t(make_gimple_asm_edges): Likewise.\n+\n 2013-05-24  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_print_operand): Change the"}, {"sha": "64434d2801e1fcfcdbbf1769af454c0a53b58f73", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdiscriminator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdiscriminator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdiscriminator.c?ref=25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-O0 -gdwarf-2\" } */\n+/* { dg-final { scan-assembler \"loc \\[0-9] 9 \\[0-9]( is_stmt \\[0-9])?\\n\" } } */\n+/* { dg-final { scan-assembler \"loc \\[0-9] 9 \\[0-9]( is_stmt \\[0-9])? discriminator 2\\n\" } } */\n+/* { dg-final { scan-assembler \"loc \\[0-9] 9 \\[0-9]( is_stmt \\[0-9])? discriminator 1\\n\" } } */\n+\n+int foo(int n) {\n+  int i, ret = 0;\n+  for (i = 0; i < n; i++) {\n+    if (i % 10 == 1)\n+      ret++;\n+    else\n+      ret--;\n+  }\n+  return ret;\n+}"}, {"sha": "c3b4a827c68ac62187a7253ef598b3501f46f2af", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e25c732c8b3b50bfb8723b3551ce0d07688cf2/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=25e25c732c8b3b50bfb8723b3551ce0d07688cf2", "patch": "@@ -105,7 +105,7 @@ struct locus_descrim_hasher : typed_free_remove <locus_discrim_map>\n inline hashval_t\n locus_descrim_hasher::hash (const value_type *item)\n {\n-  return item->locus;\n+  return LOCATION_LINE (item->locus);\n }\n \n /* Equality function for the locus-to-discriminator map.  A and B\n@@ -114,7 +114,7 @@ locus_descrim_hasher::hash (const value_type *item)\n inline bool\n locus_descrim_hasher::equal (const value_type *a, const compare_type *b)\n {\n-  return a->locus == b->locus;\n+  return LOCATION_LINE (a->locus) == LOCATION_LINE (b->locus);\n }\n \n static hash_table <locus_descrim_hasher> discriminator_per_locus;\n@@ -125,11 +125,11 @@ static void factor_computed_gotos (void);\n \n /* Edges.  */\n static void make_edges (void);\n+static void assign_discriminators (void);\n static void make_cond_expr_edges (basic_block);\n static void make_gimple_switch_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n static void make_gimple_asm_edges (basic_block);\n-static void assign_discriminator (location_t, basic_block);\n static edge gimple_redirect_edge_and_branch (edge, basic_block);\n static edge gimple_try_redirect_by_replacing_jump (edge, basic_block);\n static unsigned int split_critical_edges (void);\n@@ -231,6 +231,7 @@ build_gimple_cfg (gimple_seq seq)\n   /* Create the edges of the flowgraph.  */\n   discriminator_per_locus.create (13);\n   make_edges ();\n+  assign_discriminators ();\n   cleanup_dead_labels ();\n   discriminator_per_locus.dispose ();\n }\n@@ -690,11 +691,7 @@ make_edges (void)\n \tfallthru = true;\n \n       if (fallthru)\n-        {\n-\t  make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n-\t  if (last)\n-            assign_discriminator (gimple_location (last), bb->next_bb);\n-\t}\n+\tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n   if (root_omp_region)\n@@ -717,7 +714,8 @@ next_discriminator_for_locus (location_t locus)\n \n   item.locus = locus;\n   item.discriminator = 0;\n-  slot = discriminator_per_locus.find_slot_with_hash (&item, locus, INSERT);\n+  slot = discriminator_per_locus.find_slot_with_hash (\n+      &item, LOCATION_LINE (locus), INSERT);\n   gcc_assert (slot);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     {\n@@ -752,22 +750,37 @@ same_line_p (location_t locus1, location_t locus2)\n           && filename_cmp (from.file, to.file) == 0);\n }\n \n-/* Assign a unique discriminator value to block BB if it begins at the same\n-   LOCUS as its predecessor block.  */\n+/* Assign discriminators to each basic block.  */\n \n static void\n-assign_discriminator (location_t locus, basic_block bb)\n+assign_discriminators (void)\n {\n-  gimple first_in_to_bb, last_in_to_bb;\n+  basic_block bb;\n \n-  if (locus == 0 || bb->discriminator != 0)\n-    return;\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      gimple last = last_stmt (bb);\n+      location_t locus = last ? gimple_location (last) : UNKNOWN_LOCATION;\n+\n+      if (locus == UNKNOWN_LOCATION)\n+\tcontinue;\n \n-  first_in_to_bb = first_non_label_stmt (bb);\n-  last_in_to_bb = last_stmt (bb);\n-  if ((first_in_to_bb && same_line_p (locus, gimple_location (first_in_to_bb)))\n-      || (last_in_to_bb && same_line_p (locus, gimple_location (last_in_to_bb))))\n-    bb->discriminator = next_discriminator_for_locus (locus);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  gimple first = first_non_label_stmt (e->dest);\n+\t  gimple last = last_stmt (e->dest);\n+\t  if ((first && same_line_p (locus, gimple_location (first)))\n+\t      || (last && same_line_p (locus, gimple_location (last))))\n+\t    {\n+\t      if (e->dest->discriminator != 0 && bb->discriminator == 0)\n+\t\tbb->discriminator = next_discriminator_for_locus (locus);\n+\t      else\n+\t\te->dest->discriminator = next_discriminator_for_locus (locus);\n+\t    }\n+\t}\n+    }\n }\n \n /* Create the edges for a GIMPLE_COND starting at block BB.  */\n@@ -780,13 +793,10 @@ make_cond_expr_edges (basic_block bb)\n   basic_block then_bb, else_bb;\n   tree then_label, else_label;\n   edge e;\n-  location_t entry_locus;\n \n   gcc_assert (entry);\n   gcc_assert (gimple_code (entry) == GIMPLE_COND);\n \n-  entry_locus = gimple_location (entry);\n-\n   /* Entry basic blocks for each component.  */\n   then_label = gimple_cond_true_label (entry);\n   else_label = gimple_cond_false_label (entry);\n@@ -796,14 +806,10 @@ make_cond_expr_edges (basic_block bb)\n   else_stmt = first_stmt (else_bb);\n \n   e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n-  assign_discriminator (entry_locus, then_bb);\n   e->goto_locus = gimple_location (then_stmt);\n   e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n   if (e)\n-    {\n-      assign_discriminator (entry_locus, else_bb);\n-      e->goto_locus = gimple_location (else_stmt);\n-    }\n+    e->goto_locus = gimple_location (else_stmt);\n \n   /* We do not need the labels anymore.  */\n   gimple_cond_set_true_label (entry, NULL_TREE);\n@@ -923,19 +929,15 @@ static void\n make_gimple_switch_edges (basic_block bb)\n {\n   gimple entry = last_stmt (bb);\n-  location_t entry_locus;\n   size_t i, n;\n \n-  entry_locus = gimple_location (entry);\n-\n   n = gimple_switch_num_labels (entry);\n \n   for (i = 0; i < n; ++i)\n     {\n       tree lab = CASE_LABEL (gimple_switch_label (entry, i));\n       basic_block label_bb = label_to_block (lab);\n       make_edge (bb, label_bb, 0);\n-      assign_discriminator (entry_locus, label_bb);\n     }\n }\n \n@@ -1020,7 +1022,6 @@ make_goto_expr_edges (basic_block bb)\n       basic_block label_bb = label_to_block (dest);\n       edge e = make_edge (bb, label_bb, EDGE_FALLTHRU);\n       e->goto_locus = gimple_location (goto_t);\n-      assign_discriminator (e->goto_locus, label_bb);\n       gsi_remove (&last, true);\n       return;\n     }\n@@ -1035,15 +1036,13 @@ static void\n make_gimple_asm_edges (basic_block bb)\n {\n   gimple stmt = last_stmt (bb);\n-  location_t stmt_loc = gimple_location (stmt);\n   int i, n = gimple_asm_nlabels (stmt);\n \n   for (i = 0; i < n; ++i)\n     {\n       tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));\n       basic_block label_bb = label_to_block (label);\n       make_edge (bb, label_bb, 0);\n-      assign_discriminator (stmt_loc, label_bb);\n     }\n }\n "}]}