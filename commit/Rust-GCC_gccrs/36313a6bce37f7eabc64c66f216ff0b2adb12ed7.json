{"sha": "36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzMTNhNmJjZTM3ZjdlYWJjNjRjNjZmMjE2ZmYwYjJhZGIxMmVkNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-12-18T15:52:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-12-18T15:52:33Z"}, "message": "LWG 2936: update path::compare logic and optimize string comparisons\n\nThe resolution for LWG 2936 defines the comparison more precisely, which\nthis patch implements. The patch also defines comparisons with strings\nto work without constructing a temporary path object (so avoids any\nmemory allocations).\n\n\t* include/bits/fs_path.h (path::compare(const string_type&))\n\t(path::compare(const value_type*)): Add noexcept and construct a\n\tstring view to compare to instead of a path.\n\t(path::compare(basic_string_view<value_type>)): Add noexcept. Remove\n\tinline definition.\n\t* src/filesystem/std-path.cc (path::_Parser): Track last type read\n\tfrom input.\n\t(path::_Parser::next()): Return a final empty component when the\n\tinput ends in a non-root directory separator.\n\t(path::_M_append(basic_string_view<value_type>)): Remove special cases\n\tfor trailing non-root directory separator.\n\t(path::_M_concat(basic_string_view<value_type>)): Likewise.\n\t(path::compare(const path&)): Implement LWG 2936.\n\t(path::compare(basic_string_view<value_type>)): Define in terms of\n\tcomponents returned by parser, consistent with LWG 2936.\n\t* testsuite/27_io/filesystem/path/compare/lwg2936.cc: New.\n\t* testsuite/27_io/filesystem/path/compare/path.cc: Test more cases.\n\t* testsuite/27_io/filesystem/path/compare/strings.cc: Likewise.\n\nFrom-SVN: r267235", "tree": {"sha": "6bfdee3d10c2cddd259f3e27e75aa615b7fd5170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bfdee3d10c2cddd259f3e27e75aa615b7fd5170"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49cefcf3f084dabc327914269e5787bac8b20f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49cefcf3f084dabc327914269e5787bac8b20f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49cefcf3f084dabc327914269e5787bac8b20f46"}], "stats": {"total": 379, "additions": 300, "deletions": 79}, "files": [{"sha": "d61d4ccad4de766b239da51e2844ef262fe501d5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -1,5 +1,24 @@\n 2018-12-18  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/fs_path.h (path::compare(const string_type&))\n+\t(path::compare(const value_type*)): Add noexcept and construct a\n+\tstring view to compare to instead of a path.\n+\t(path::compare(basic_string_view<value_type>)): Add noexcept. Remove\n+\tinline definition.\n+\t* src/filesystem/std-path.cc (path::_Parser): Track last type read\n+\tfrom input.\n+\t(path::_Parser::next()): Return a final empty component when the\n+\tinput ends in a non-root directory separator.\n+\t(path::_M_append(basic_string_view<value_type>)): Remove special cases\n+\tfor trailing non-root directory separator.\n+\t(path::_M_concat(basic_string_view<value_type>)): Likewise.\n+\t(path::compare(const path&)): Implement LWG 2936.\n+\t(path::compare(basic_string_view<value_type>)): Define in terms of\n+\tcomponents returned by parser, consistent with LWG 2936.\n+\t* testsuite/27_io/filesystem/path/compare/lwg2936.cc: New.\n+\t* testsuite/27_io/filesystem/path/compare/path.cc: Test more cases.\n+\t* testsuite/27_io/filesystem/path/compare/strings.cc: Likewise.\n+\n \t* include/std/string_view [__cplusplus > 201703L]\n \t(basic_string_view::starts_with(basic_string_view)): Implement\n \tproposed resolution of LWG 3040 to avoid redundant length check."}, {"sha": "b827d85965eef8c321a369a3f17a8c62ddfbab75", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -341,9 +341,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     // compare\n \n     int compare(const path& __p) const noexcept;\n-    int compare(const string_type& __s) const;\n-    int compare(const value_type* __s) const;\n-    int compare(const basic_string_view<value_type> __s) const;\n+    int compare(const string_type& __s) const noexcept;\n+    int compare(const value_type* __s) const noexcept;\n+    int compare(basic_string_view<value_type> __s) const noexcept;\n \n     // decomposition\n \n@@ -1067,14 +1067,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   { return generic_string<char32_t>(); }\n \n   inline int\n-  path::compare(const string_type& __s) const { return compare(path(__s)); }\n+  path::compare(const string_type& __s) const noexcept\n+  { return compare(basic_string_view<value_type>(__s)); }\n \n   inline int\n-  path::compare(const value_type* __s) const { return compare(path(__s)); }\n-\n-  inline int\n-  path::compare(basic_string_view<value_type> __s) const\n-  { return compare(path(__s)); }\n+  path::compare(const value_type* __s) const noexcept\n+  { return compare(basic_string_view<value_type>(__s)); }\n \n   inline path\n   path::filename() const"}, {"sha": "5b0318c1f586fadab1295c6ecd182d952bb1bcd8", "filename": "libstdc++-v3/src/filesystem/std-path.cc", "status": "modified", "additions": 172, "deletions": 70, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -62,6 +62,7 @@ struct path::_Parser\n   string_view_type input;\n   string_view_type::size_type pos = 0;\n   size_t origin;\n+  _Type last_type = _Type::_Multi;\n \n   _Parser(string_view_type s, size_t o = 0) : input(s), origin(o) { }\n \n@@ -129,6 +130,12 @@ struct path::_Parser\n \tpos = input.find_first_not_of(L\"/\\\\\", 2);\n       }\n #endif\n+\n+    if (root.second.valid())\n+      last_type = root.second.type;\n+    else\n+      last_type = root.first.type;\n+\n     return root;\n   }\n \n@@ -140,15 +147,30 @@ struct path::_Parser\n     char sep = '/';\n #endif\n \n+    const int last_pos = pos;\n+\n     cmpt f;\n-    pos = input.find_first_not_of(sep, pos);\n     if (pos != input.npos)\n       {\n-\tconst auto end = input.find_first_of(sep, pos);\n-\tf.str = input.substr(pos, end - pos);\n-\tf.type = _Type::_Filename;\n-\tpos = end;\n+\tpos = input.find_first_not_of(sep, pos);\n+\tif (pos != input.npos)\n+\t  {\n+\t    const auto end = input.find_first_of(sep, pos);\n+\t    f.str = input.substr(pos, end - pos);\n+\t    f.type = _Type::_Filename;\n+\t    pos = end;\n+\t  }\n+\telse if (last_type == _Type::_Filename\n+\t    || (last_pos == 0 && !input.empty()))\n+\t  {\n+\t    // [fs.path.itr]/4 An empty element, if trailing non-root\n+\t    // directory-separator present.\n+\t    __glibcxx_assert(is_dir_sep(input.back()));\n+\t    f.str = input.substr(input.length(), 0);\n+\t    f.type = _Type::_Filename;\n+\t  }\n       }\n+    last_type = f.type;\n     return f;\n   }\n \n@@ -733,9 +755,6 @@ path::_M_append(basic_string_view<value_type> s)\n \t  while (parser2.next().valid())\n \t    ++capacity;\n \t}\n-\n-      if (s.back() == '/')\n-\t++capacity;\n     }\n   else if (!sep.empty())\n     ++capacity;\n@@ -787,12 +806,6 @@ path::_M_append(basic_string_view<value_type> s)\n \t      ++_M_cmpts._M_impl->_M_size;\n \t      cmpt = parser.next();\n \t    }\n-\n-\t  if (s.back() == '/')\n-\t    {\n-\t      ::new(output++) _Cmpt({}, _Type::_Filename, _M_pathname.length());\n-\t      ++_M_cmpts._M_impl->_M_size;\n-\t    }\n \t}\n       else if (!sep.empty())\n \t{\n@@ -1107,8 +1120,6 @@ path::_M_concat(basic_string_view<value_type> s)\n       while (parser2.next().valid())\n \t++capacity;\n     }\n-  if (is_dir_sep(s.back()))\n-    ++capacity;\n \n #if SLASHSLASH_IS_ROOTNAME\n   if (orig_type == _Type::_Root_name)\n@@ -1165,13 +1176,6 @@ path::_M_concat(basic_string_view<value_type> s)\n \t      cmpt = parser.next();\n \t    }\n \t}\n-\n-      if (is_dir_sep(s.back()))\n-\t{\n-\t  // Empty filename at the end:\n-\t  ::new(output++) _Cmpt({}, _Type::_Filename, _M_pathname.length());\n-\t  ++_M_cmpts._M_impl->_M_size;\n-\t}\n     }\n   __catch (...)\n     {\n@@ -1266,58 +1270,168 @@ path::replace_extension(const path& replacement)\n   return *this;\n }\n \n-namespace\n+int\n+path::compare(const path& p) const noexcept\n {\n-  template<typename Iter1, typename Iter2>\n-    int do_compare(Iter1 begin1, Iter1 end1, Iter2 begin2, Iter2 end2)\n+  if (_M_pathname == p._M_pathname)\n+    return 0;\n+\n+  basic_string_view<value_type> lroot, rroot;\n+  if (_M_type() == _Type::_Root_name)\n+    lroot = _M_pathname;\n+  else if (_M_type() == _Type::_Multi\n+      && _M_cmpts.front()._M_type() == _Type::_Root_name)\n+    lroot = _M_cmpts.front()._M_pathname;\n+  if (p._M_type() == _Type::_Root_name)\n+    rroot = p._M_pathname;\n+  else if (p._M_type() == _Type::_Multi\n+      && p._M_cmpts.front()._M_type() == _Type::_Root_name)\n+    rroot = p._M_cmpts.front()._M_pathname;\n+  if (int rootNameComparison = lroot.compare(rroot))\n+    return rootNameComparison;\n+\n+  if (!this->has_root_directory() && p.has_root_directory())\n+    return -1;\n+  else if (this->has_root_directory() && !p.has_root_directory())\n+    return +1;\n+\n+  using Iterator = const _Cmpt*;\n+  Iterator begin1, end1, begin2, end2;\n+  if (_M_type() == _Type::_Multi)\n     {\n-      int cmpt = 1;\n-      while (begin1 != end1 && begin2 != end2)\n+      begin1 = _M_cmpts.begin();\n+      end1 = _M_cmpts.end();\n+      // Find start of this->relative_path()\n+      while (begin1 != end1 && begin1->_M_type() != _Type::_Filename)\n+\t++begin1;\n+    }\n+  else\n+    begin1 = end1 = nullptr;\n+\n+  if (p._M_type() == _Type::_Multi)\n+    {\n+      begin2 = p._M_cmpts.begin();\n+      end2 = p._M_cmpts.end();\n+      // Find start of p.relative_path()\n+      while (begin2 != end2 && begin2->_M_type() != _Type::_Filename)\n+\t++begin2;\n+    }\n+  else\n+    begin2 = end2 = nullptr;\n+\n+  if (_M_type() == _Type::_Filename)\n+    {\n+      if (p._M_type() == _Type::_Filename)\n+\treturn native().compare(p.native());\n+      else if (begin2 != end2)\n \t{\n-\t  if (begin1->native() < begin2->native())\n-\t    return -cmpt;\n-\t  if (begin1->native() > begin2->native())\n-\t    return +cmpt;\n-\t  ++begin1;\n-\t  ++begin2;\n-\t  ++cmpt;\n+\t  if (int ret = native().compare(begin2->native()))\n+\t    return ret;\n+\t  else\n+\t    return ++begin2 == end2 ? 0 : -1;\n \t}\n-      if (begin1 == end1)\n+      else\n+\treturn +1;\n+    }\n+  else if (p._M_type() == _Type::_Filename)\n+    {\n+      if (begin1 != end1)\n \t{\n-\t  if (begin2 == end2)\n-\t    return 0;\n-\t  return -cmpt;\n+\t  if (int ret = begin1->native().compare(p.native()))\n+\t    return ret;\n+\t  else\n+\t    return ++begin1 == end1 ? 0 : +1;\n \t}\n-      return +cmpt;\n+      else\n+\treturn -1;\n+    }\n+\n+  int count = 1;\n+  while (begin1 != end1 && begin2 != end2)\n+    {\n+      if (int i = begin1->native().compare(begin2->native()))\n+\treturn i;\n+      ++begin1;\n+      ++begin2;\n+      ++count;\n     }\n+  if (begin1 == end1)\n+    {\n+      if (begin2 == end2)\n+\treturn 0;\n+      return -count;\n+    }\n+  return count;\n }\n \n int\n-path::compare(const path& p) const noexcept\n+path::compare(basic_string_view<value_type> s) const noexcept\n {\n-  struct CmptRef\n-  {\n-    const path* ptr;\n-    const string_type& native() const noexcept { return ptr->native(); }\n-  };\n-\n-  if (empty() && p.empty())\n+  if (_M_pathname == s)\n     return 0;\n-  else if (_M_type() == _Type::_Multi && p._M_type() == _Type::_Multi)\n-    return do_compare(_M_cmpts.begin(), _M_cmpts.end(),\n-\t\t      p._M_cmpts.begin(), p._M_cmpts.end());\n-  else if (_M_type() == _Type::_Multi)\n+\n+  _Parser parser(s);\n+\n+  basic_string_view<value_type> lroot, rroot;\n+  if (_M_type() == _Type::_Root_name)\n+    lroot = _M_pathname;\n+  else if (_M_type() == _Type::_Multi\n+      && _M_cmpts.front()._M_type() == _Type::_Root_name)\n+    lroot = _M_cmpts.front()._M_pathname;\n+  auto root_path = parser.root_path();\n+  if (root_path.first.type == _Type::_Root_name)\n+    rroot = root_path.first.str;\n+  if (int rootNameComparison = lroot.compare(rroot))\n+    return rootNameComparison;\n+\n+  const bool has_root_dir = root_path.first.type == _Type::_Root_dir\n+    || root_path.second.type == _Type::_Root_dir;\n+  if (!this->has_root_directory() && has_root_dir)\n+    return -1;\n+  else if (this->has_root_directory() && !has_root_dir)\n+    return +1;\n+\n+  using Iterator = const _Cmpt*;\n+  Iterator begin1, end1;\n+  if (_M_type() == _Type::_Filename)\n     {\n-      CmptRef c[1] = { { &p } };\n-      return do_compare(_M_cmpts.begin(), _M_cmpts.end(), c, c+1);\n+      auto cmpt = parser.next();\n+      if (cmpt.valid())\n+\t{\n+\t  if (int ret = this->native().compare(cmpt.str))\n+\t    return ret;\n+\t  return parser.next().valid() ? -1 : 0;\n+\t}\n+      else\n+\treturn +1;\n     }\n-  else if (p._M_type() == _Type::_Multi)\n+  else if (_M_type() == _Type::_Multi)\n     {\n-      CmptRef c[1] = { { this } };\n-      return do_compare(c, c+1, p._M_cmpts.begin(), p._M_cmpts.end());\n+      begin1 = _M_cmpts.begin();\n+      end1 = _M_cmpts.end();\n+      while (begin1 != end1 && begin1->_M_type() != _Type::_Filename)\n+\t++begin1;\n     }\n   else\n-    return _M_pathname.compare(p._M_pathname);\n+    begin1 = end1 = nullptr;\n+\n+  int count = 1;\n+  auto cmpt = parser.next();\n+  while (begin1 != end1 && cmpt.valid())\n+    {\n+      if (int i = begin1->native().compare(cmpt.str))\n+\treturn i;\n+      ++begin1;\n+      cmpt = parser.next();\n+      ++count;\n+    }\n+  if (begin1 == end1)\n+    {\n+      if (!cmpt.valid())\n+\treturn 0;\n+      return -count;\n+    }\n+  return +count;\n }\n \n path\n@@ -1718,12 +1832,9 @@ path::_M_split_cmpts()\n \t*next++ = root_path.second;\n     }\n \n-  bool got_at_least_one_filename = false;\n-\n   auto cmpt = parser.next();\n   while (cmpt.valid())\n     {\n-      got_at_least_one_filename = true;\n       do\n \t{\n \t  *next++ = cmpt;\n@@ -1746,15 +1857,6 @@ path::_M_split_cmpts()\n \t}\n     }\n \n-  // [fs.path.itr]/4\n-  // An empty element, if trailing non-root directory-separator present.\n-  if (got_at_least_one_filename && is_dir_sep(_M_pathname.back()))\n-    {\n-      next->str = { _M_pathname.data() + _M_pathname.length(), 0 };\n-      next->type = _Type::_Filename;\n-      ++next;\n-    }\n-\n   if (auto n = next - buf.begin())\n     {\n       if (n == 1 && _M_cmpts.empty())"}, {"sha": "8a11043f1430d5cfc4ea92979b68b4debfeaf513", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/lwg2936.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Flwg2936.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Flwg2936.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Flwg2936.cc?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++17 -lstdc++fs\" }\n+// { dg-do run { target c++17 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// Copyright (C) 2014-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.4.8 path compare [path.compare]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+#include <testsuite_fs.h>\n+\n+using std::filesystem::path;\n+\n+int norm(int i)\n+{\n+  if (i < 0)\n+    return -1;\n+  else if (i > 0)\n+    return +1;\n+  else\n+    return 0;\n+}\n+\n+void\n+check(const path& lhs, const path& rhs, int sense)\n+{\n+  VERIFY( lhs.compare(lhs) == 0 );\n+  VERIFY( rhs.compare(rhs) == 0 );\n+\n+  VERIFY( norm(lhs.compare(rhs)) == sense );\n+  VERIFY( norm(lhs.compare(rhs.c_str())) == sense );\n+\n+  VERIFY( norm(rhs.compare(lhs)) == -sense );\n+  VERIFY( norm(rhs.compare(lhs.c_str())) == -sense );\n+}\n+\n+void\n+test01()\n+{\n+  check(\"\", \"\", 0);\n+\n+  // These are root names on Windows (just relative paths elsewhere)\n+  check(\"\", \"c:\", -1);\n+  check(\"c:\", \"d:\", -1);\n+  check(\"c:\", \"c:/\", -1);\n+  check(\"d:\", \"c:/\", +1);\n+  check(\"c:/a/b\", \"c:a/b\", -1);\n+\n+  // These are root names on Cygwin (just relative paths elsewhere)\n+  check(\"\", \"//c\", -1);\n+  check(\"//c\", \"//d\", -1);\n+  check(\"//c\", \"//c/\", -1);\n+  check(\"//d\", \"//c/\", +1);\n+\n+  check(\"/a\", \"/b\", -1);\n+  check(\"a\", \"/b\", -1);\n+  check(\"/b\", \"b\", +1);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "159a96c6597c8f39fc9491c483add5765318cf65", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/path.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fpath.cc?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -44,8 +44,19 @@ test01()\n   }\n }\n \n+void\n+test02()\n+{\n+  VERIFY( path(\"/\").compare(path(\"////\")) == 0 );\n+  VERIFY( path(\"/a\").compare(path(\"/\")) > 0 );\n+  VERIFY( path(\"/\").compare(path(\"/a\")) < 0 );\n+  VERIFY( path(\"/ab\").compare(path(\"/a\")) > 0 );\n+  VERIFY( path(\"/ab\").compare(path(\"/a/b\")) > 0 );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}, {"sha": "a3fcb800dbf3c345528cc404d0b41d130fb7dfa4", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/compare/strings.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36313a6bce37f7eabc64c66f216ff0b2adb12ed7/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fcompare%2Fstrings.cc?ref=36313a6bce37f7eabc64c66f216ff0b2adb12ed7", "patch": "@@ -42,8 +42,19 @@ test01()\n   }\n }\n \n+void\n+test02()\n+{\n+  VERIFY( path(\"/\").compare(\"////\") == 0 );\n+  VERIFY( path(\"/a\").compare(\"/\") > 0 );\n+  VERIFY( path(\"/\").compare(\"/a\") < 0 );\n+  VERIFY( path(\"/ab\").compare(\"/a\") > 0 );\n+  VERIFY( path(\"/ab\").compare(\"/a/b\") > 0 );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}]}