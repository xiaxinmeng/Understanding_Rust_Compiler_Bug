{"sha": "73367f92ad4316a6a149d40e076f6a2d5cd9a022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMzNjdmOTJhZDQzMTZhNmExNDlkNDBlMDc2ZjZhMmQ1Y2Q5YTAyMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-10-09T13:10:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-10-09T13:10:37Z"}, "message": "loop-unroll.c (unroll_loop_constant_iterations): Add update of loop->nb_iterations_upper_bound I missed in my previous commit...\n\n\n\t* loop-unroll.c (unroll_loop_constant_iterations): Add\n\tupdate of loop->nb_iterations_upper_bound I missed in my previous\n\tcommit; use TRUNC_DIV_EXPR instead of FLOOR_DIV_EXPR to divide\n\titeration count.\n\t(decide_unroll_runtime_iterations): Avoid overflow.\n\t(unroll_loop_runtime_iterations): Use TRUNC_DIV_EXPR instead of\n\tFLOOR_DIV_EXPR to update iteration bounds.\n\t(decide_peel_simple): Avoid integer overflow when deciding\n\ton number of peelings.\n\t(decide_unroll_stupid): Likewise.\n\nFrom-SVN: r192251", "tree": {"sha": "7114ec1f703170ac8194de328dfe6af33d100a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7114ec1f703170ac8194de328dfe6af33d100a7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73367f92ad4316a6a149d40e076f6a2d5cd9a022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73367f92ad4316a6a149d40e076f6a2d5cd9a022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73367f92ad4316a6a149d40e076f6a2d5cd9a022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73367f92ad4316a6a149d40e076f6a2d5cd9a022/comments", "author": null, "committer": null, "parents": [{"sha": "0b8c30f9aaae52859e12efef359060b8246d6273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b8c30f9aaae52859e12efef359060b8246d6273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b8c30f9aaae52859e12efef359060b8246d6273"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "67e4a64fec6bbc7a4f715b825a89431047694b8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73367f92ad4316a6a149d40e076f6a2d5cd9a022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73367f92ad4316a6a149d40e076f6a2d5cd9a022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73367f92ad4316a6a149d40e076f6a2d5cd9a022", "patch": "@@ -1,3 +1,16 @@\n+2012-10-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop-unroll.c (unroll_loop_constant_iterations): Add\n+\tupdate of loop->nb_iterations_upper_bound I missed in my previous\n+\tcommit; use TRUNC_DIV_EXPR instead of FLOOR_DIV_EXPR to divide\n+\titeration count.\n+\t(decide_unroll_runtime_iterations): Avoid overflow.\n+\t(unroll_loop_runtime_iterations): Use TRUNC_DIV_EXPR instead of\n+\tFLOOR_DIV_EXPR to update iteration bounds.\n+\t(decide_peel_simple): Avoid integer overflow when deciding\n+\ton number of peelings.\n+\t(decide_unroll_stupid): Likewise.\n+\n 2012-10-09  Tobias Burnus  <burnus@net-b.de>\n \n \t* lto-cgraph.c (input_node_opt_summary): Remove unused code."}, {"sha": "b6dace030c1e668dfec0e58c90a15746bb583c8f", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73367f92ad4316a6a149d40e076f6a2d5cd9a022/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73367f92ad4316a6a149d40e076f6a2d5cd9a022/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=73367f92ad4316a6a149d40e076f6a2d5cd9a022", "patch": "@@ -740,6 +740,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n   \t    apply_opt_in_copies (opt_info, exit_mod + 1, false, false);\n \n \t  desc->niter -= exit_mod + 1;\n+\t  loop->nb_iterations_upper_bound -= double_int::from_uhwi (exit_mod + 1);\n \t  if (loop->any_estimate\n \t      && double_int::from_uhwi (exit_mod + 1).ule\n \t           (loop->nb_iterations_estimate))\n@@ -795,14 +796,14 @@ unroll_loop_constant_iterations (struct loop *loop)\n \n   desc->niter /= max_unroll + 1;\n   loop->nb_iterations_upper_bound\n-    = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (exit_mod\n+    = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (max_unroll\n \t\t\t\t\t\t\t\t   + 1),\n-\t\t\t\t\t    FLOOR_DIV_EXPR);\n+\t\t\t\t\t    TRUNC_DIV_EXPR);\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n-      = loop->nb_iterations_estimate.udiv (double_int::from_uhwi (exit_mod\n+      = loop->nb_iterations_estimate.udiv (double_int::from_uhwi (max_unroll\n \t\t\t\t\t\t\t          + 1),\n-\t\t\t\t           FLOOR_DIV_EXPR);\n+\t\t\t\t           TRUNC_DIV_EXPR);\n   desc->niter_expr = GEN_INT (desc->niter);\n \n   /* Remove the edges.  */\n@@ -876,11 +877,10 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)\n       return;\n     }\n \n-  /* If we have profile feedback, check whether the loop rolls.  */\n+  /* Check whether the loop rolls.  */\n   if ((estimated_loop_iterations (loop, &iterations)\n        || max_loop_iterations (loop, &iterations))\n-      && iterations.fits_shwi ()\n-      && iterations.to_shwi () <= 2 * nunroll)\n+      && iterations.ult (double_int::from_shwi (2 * nunroll)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");\n@@ -1199,12 +1199,12 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   loop->nb_iterations_upper_bound\n     = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (max_unroll\n \t\t\t\t\t\t\t\t   + 1),\n-\t\t\t\t\t    FLOOR_DIV_EXPR);\n+\t\t\t\t\t    TRUNC_DIV_EXPR);\n   if (loop->any_estimate)\n     loop->nb_iterations_estimate\n       = loop->nb_iterations_estimate.udiv (double_int::from_uhwi (max_unroll\n \t\t\t\t\t\t\t          + 1),\n-\t\t\t\t           FLOOR_DIV_EXPR);\n+\t\t\t\t           TRUNC_DIV_EXPR);\n   if (exit_at_end)\n     {\n       desc->niter_expr =\n@@ -1280,8 +1280,7 @@ decide_peel_simple (struct loop *loop, int flags)\n   /* If we have realistic estimate on number of iterations, use it.  */\n   if (estimated_loop_iterations (loop, &iterations))\n     {\n-      if (!iterations.fits_shwi ()\n-\t  || iterations.to_shwi () + 1 > npeel)\n+      if (double_int::from_shwi (npeel).ule (iterations))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1298,8 +1297,7 @@ decide_peel_simple (struct loop *loop, int flags)\n   /* If we have small enough bound on iterations, we can still peel (completely\n      unroll).  */\n   else if (max_loop_iterations (loop, &iterations)\n-           && iterations.fits_shwi ()\n-           && iterations.to_shwi () + 1 <= npeel)\n+           && iterations.ult (double_int::from_shwi (npeel)))\n     npeel = iterations.to_shwi () + 1;\n   else\n     {\n@@ -1446,11 +1444,10 @@ decide_unroll_stupid (struct loop *loop, int flags)\n       return;\n     }\n \n-  /* If we have profile feedback, check whether the loop rolls.  */\n+  /* Check whether the loop rolls.  */\n   if ((estimated_loop_iterations (loop, &iterations)\n        || max_loop_iterations (loop, &iterations))\n-      && iterations.fits_shwi ()\n-      && iterations.to_shwi () <= 2 * nunroll)\n+      && iterations.ult (double_int::from_shwi (2 * nunroll)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unrolling loop, doesn't roll\\n\");"}]}