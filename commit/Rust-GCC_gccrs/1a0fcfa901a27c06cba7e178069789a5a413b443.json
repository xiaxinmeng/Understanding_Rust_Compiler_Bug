{"sha": "1a0fcfa901a27c06cba7e178069789a5a413b443", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwZmNmYTkwMWEyN2MwNmNiYTdlMTc4MDY5Nzg5YTVhNDEzYjQ0Mw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-15T14:32:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-15T14:32:12Z"}, "message": "tree-vrp.c (value_range_nonnegative_p): Fix anti-range case.\n\n2011-08-15  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (value_range_nonnegative_p): Fix anti-range case.\n\t(extract_range_from_unary_expr_1): Restructure.\n\nFrom-SVN: r177761", "tree": {"sha": "fa31d91bf8859612ab2132ce5dd31211fc390da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa31d91bf8859612ab2132ce5dd31211fc390da6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a0fcfa901a27c06cba7e178069789a5a413b443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0fcfa901a27c06cba7e178069789a5a413b443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a0fcfa901a27c06cba7e178069789a5a413b443", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0fcfa901a27c06cba7e178069789a5a413b443/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f9dbaaae8b46290b40ec43e56fdfc10dfd477b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f9dbaaae8b46290b40ec43e56fdfc10dfd477b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f9dbaaae8b46290b40ec43e56fdfc10dfd477b0"}], "stats": {"total": 198, "additions": 77, "deletions": 121}, "files": [{"sha": "de1298c4fb4006f792407a80116d1d76fa1f02ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0fcfa901a27c06cba7e178069789a5a413b443/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0fcfa901a27c06cba7e178069789a5a413b443/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a0fcfa901a27c06cba7e178069789a5a413b443", "patch": "@@ -1,3 +1,8 @@\n+2011-08-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (value_range_nonnegative_p): Fix anti-range case.\n+\t(extract_range_from_unary_expr_1): Restructure.\n+\n 2011-08-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50058"}, {"sha": "adf5a53b54430ca21d54c2d0d1178960fd6c7e6c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 72, "deletions": 121, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0fcfa901a27c06cba7e178069789a5a413b443/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0fcfa901a27c06cba7e178069789a5a413b443/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1a0fcfa901a27c06cba7e178069789a5a413b443", "patch": "@@ -1398,16 +1398,14 @@ range_includes_zero_p (value_range_t *vr)\n static inline bool\n value_range_nonnegative_p (value_range_t *vr)\n {\n+  /* Testing for VR_ANTI_RANGE is not useful here as any anti-range\n+     which would return a useful value should be encoded as a \n+     VR_RANGE.  */\n   if (vr->type == VR_RANGE)\n     {\n       int result = compare_values (vr->min, integer_zero_node);\n       return (result == 0 || result == 1);\n     }\n-  else if (vr->type == VR_ANTI_RANGE)\n-    {\n-      int result = compare_values (vr->max, integer_zero_node);\n-      return result == -1;\n-    }\n \n   return false;\n }\n@@ -2826,61 +2824,51 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t\t\t\t value_range_t *vr0_, tree op0_type)\n {\n   value_range_t vr0 = *vr0_;\n-  tree min, max;\n-  int cmp;\n-\n-  /* If VR0 is UNDEFINED, so is the result.  */\n-  if (vr0.type == VR_UNDEFINED)\n-    {\n-      set_value_range_to_undefined (vr);\n-      return;\n-    }\n \n-  /* Refuse to operate on certain unary expressions for which we\n-     cannot easily determine a resulting range.  */\n-  if (code == FIX_TRUNC_EXPR\n-      || code == FLOAT_EXPR\n-      || code == CONJ_EXPR)\n+  /* VRP only operates on integral and pointer types.  */\n+  if (!(INTEGRAL_TYPE_P (op0_type)\n+\t|| POINTER_TYPE_P (op0_type))\n+      || !(INTEGRAL_TYPE_P (type)\n+\t   || POINTER_TYPE_P (type)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n \n-  /* Refuse to operate on symbolic ranges, or if neither operand is\n-     a pointer or integral type.  */\n-  if ((!INTEGRAL_TYPE_P (op0_type)\n-       && !POINTER_TYPE_P (op0_type))\n-      || (vr0.type != VR_VARYING\n-\t  && symbolic_range_p (&vr0)))\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-\n-  /* If the expression involves pointers, we are only interested in\n-     determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n-  if (POINTER_TYPE_P (type) || POINTER_TYPE_P (op0_type))\n+  /* If VR0 is UNDEFINED, so is the result.  */\n+  if (vr0.type == VR_UNDEFINED)\n     {\n-      if (range_is_nonnull (&vr0))\n-\tset_value_range_to_nonnull (vr, type);\n-      else if (range_is_null (&vr0))\n-\tset_value_range_to_null (vr, type);\n-      else\n-\tset_value_range_to_varying (vr);\n+      set_value_range_to_undefined (vr);\n       return;\n     }\n \n-  /* Handle unary expressions on integer ranges.  */\n-  if (CONVERT_EXPR_CODE_P (code)\n-      && INTEGRAL_TYPE_P (type)\n-      && INTEGRAL_TYPE_P (op0_type))\n+  if (CONVERT_EXPR_CODE_P (code))\n     {\n       tree inner_type = op0_type;\n       tree outer_type = type;\n \n+      /* If the expression evaluates to a pointer, we are only interested in\n+\t determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  if (CONVERT_EXPR_CODE_P (code))\n+\t    {\n+\t      if (range_is_nonnull (&vr0))\n+\t\tset_value_range_to_nonnull (vr, type);\n+\t      else if (range_is_null (&vr0))\n+\t\tset_value_range_to_null (vr, type);\n+\t      else\n+\t\tset_value_range_to_varying (vr);\n+\t    }\n+\t  else\n+\t    set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n       /* If VR0 is varying and we increase the type precision, assume\n \t a full range for the following transformation.  */\n       if (vr0.type == VR_VARYING\n+\t  && INTEGRAL_TYPE_P (inner_type)\n \t  && TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type))\n \t{\n \t  vr0.type = VR_RANGE;\n@@ -2933,20 +2921,7 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n       set_value_range_to_varying (vr);\n       return;\n     }\n-\n-  /* Conversion of a VR_VARYING value to a wider type can result\n-     in a usable range.  So wait until after we've handled conversions\n-     before dropping the result to VR_VARYING if we had a source\n-     operand that is VR_VARYING.  */\n-  if (vr0.type == VR_VARYING)\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-\n-  /* Apply the operation to each end of the range and see what we end\n-     up with.  */\n-  if (code == NEGATE_EXPR)\n+  else if (code == NEGATE_EXPR)\n     {\n       /* -X is simply 0 - X, so re-use existing code that also handles\n          anti-ranges fine.  */\n@@ -2955,17 +2930,35 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n       extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &zero, &vr0);\n       return;\n     }\n-  else if (code == ABS_EXPR\n-           && !TYPE_UNSIGNED (type))\n+  else if (code == ABS_EXPR)\n     {\n+      tree min, max;\n+      int cmp;\n+\n+      /* Pass through vr0 in the easy cases.  */\n+      if (TYPE_UNSIGNED (type)\n+\t  || value_range_nonnegative_p (&vr0))\n+\t{\n+\t  copy_value_range (vr, &vr0);\n+\t  return;\n+\t}\n+\n+      /* For the remaining varying or symbolic ranges we can't do anything\n+\t useful.  */\n+      if (vr0.type == VR_VARYING\n+\t  || symbolic_range_p (&vr0))\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+\n       /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n          useful range.  */\n       if (!TYPE_OVERFLOW_UNDEFINED (type)\n \t  && ((vr0.type == VR_RANGE\n \t       && vrp_val_is_min (vr0.min))\n \t      || (vr0.type == VR_ANTI_RANGE\n-\t\t  && !vrp_val_is_min (vr0.min)\n-\t\t  && !range_includes_zero_p (&vr0))))\n+\t\t  && !vrp_val_is_min (vr0.min))))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n@@ -3077,6 +3070,18 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t      max = t;\n \t    }\n \t}\n+\n+      cmp = compare_values (min, max);\n+      if (cmp == -2 || cmp == 1)\n+\t{\n+\t  /* If the new range has its limits swapped around (MIN > MAX),\n+\t     then the operation caused one of them to wrap around, mark\n+\t     the new range VARYING.  */\n+\t  set_value_range_to_varying (vr);\n+\t}\n+      else\n+\tset_value_range (vr, vr0.type, min, max, NULL);\n+      return;\n     }\n   else if (code == BIT_NOT_EXPR)\n     {\n@@ -3088,69 +3093,15 @@ extract_range_from_unary_expr_1 (value_range_t *vr,\n \t\t\t\t\ttype, &minusone, &vr0);\n       return;\n     }\n-  else\n+  else if (code == PAREN_EXPR)\n     {\n-      /* Otherwise, operate on each end of the range.  */\n-      min = fold_unary_to_constant (code, type, vr0.min);\n-      max = fold_unary_to_constant (code, type, vr0.max);\n-\n-      if (needs_overflow_infinity (type))\n-\t{\n-\t  gcc_assert (code != NEGATE_EXPR && code != ABS_EXPR);\n-\n-\t  /* If both sides have overflowed, we don't know\n-\t     anything.  */\n-\t  if ((is_overflow_infinity (vr0.min)\n-\t       || TREE_OVERFLOW (min))\n-\t      && (is_overflow_infinity (vr0.max)\n-\t\t  || TREE_OVERFLOW (max)))\n-\t    {\n-\t      set_value_range_to_varying (vr);\n-\t      return;\n-\t    }\n-\n-\t  if (is_overflow_infinity (vr0.min))\n-\t    min = vr0.min;\n-\t  else if (TREE_OVERFLOW (min))\n-\t    {\n-\t      if (supports_overflow_infinity (type))\n-\t\tmin = (tree_int_cst_sgn (min) >= 0\n-\t\t       ? positive_overflow_infinity (TREE_TYPE (min))\n-\t\t       : negative_overflow_infinity (TREE_TYPE (min)));\n-\t      else\n-\t\t{\n-\t\t  set_value_range_to_varying (vr);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\n-\t  if (is_overflow_infinity (vr0.max))\n-\t    max = vr0.max;\n-\t  else if (TREE_OVERFLOW (max))\n-\t    {\n-\t      if (supports_overflow_infinity (type))\n-\t\tmax = (tree_int_cst_sgn (max) >= 0\n-\t\t       ? positive_overflow_infinity (TREE_TYPE (max))\n-\t\t       : negative_overflow_infinity (TREE_TYPE (max)));\n-\t      else\n-\t\t{\n-\t\t  set_value_range_to_varying (vr);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t}\n+      copy_value_range (vr, &vr0);\n+      return;\n     }\n \n-  cmp = compare_values (min, max);\n-  if (cmp == -2 || cmp == 1)\n-    {\n-      /* If the new range has its limits swapped around (MIN > MAX),\n-\t then the operation caused one of them to wrap around, mark\n-\t the new range VARYING.  */\n-      set_value_range_to_varying (vr);\n-    }\n-  else\n-    set_value_range (vr, vr0.type, min, max, NULL);\n+  /* For unhandled operations fall back to varying.  */\n+  set_value_range_to_varying (vr);\n+  return;\n }\n \n "}]}