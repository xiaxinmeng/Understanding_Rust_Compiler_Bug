{"sha": "daa94de24b9afdf21c636532e53561aa3713910b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFhOTRkZTI0YjlhZmRmMjFjNjM2NTMyZTUzNTYxYWEzNzEzOTEwYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-10-04T21:29:41Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-10-04T21:29:41Z"}, "message": "PR middle-end/91977 - missing -Wstringop-overflow on memcpy into a pointer plus offset\n\ngcc/ChangeLog:\n\n\tPR middle-end/91977\n\t* tree-ssa-strlen.c (count_nonzero_bytes): Handle assignments with\n\tMEM_REF right operand.  Avoid failing for MEM_REF assignments from\n\tuninitialized objects.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91977\n\t* gcc.dg/Wstringop-overflow-18.c: New test.\n\nFrom-SVN: r276603", "tree": {"sha": "2b436d826209685743534b45bd63da62094c0b70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b436d826209685743534b45bd63da62094c0b70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daa94de24b9afdf21c636532e53561aa3713910b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa94de24b9afdf21c636532e53561aa3713910b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daa94de24b9afdf21c636532e53561aa3713910b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa94de24b9afdf21c636532e53561aa3713910b/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28a5fa54aa47877b6d254430adbf3ca0377beeaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28a5fa54aa47877b6d254430adbf3ca0377beeaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28a5fa54aa47877b6d254430adbf3ca0377beeaa"}], "stats": {"total": 328, "additions": 297, "deletions": 31}, "files": [{"sha": "18b4f89bb2816ec0a9626bbe540f6038301bac1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=daa94de24b9afdf21c636532e53561aa3713910b", "patch": "@@ -1,3 +1,10 @@\n+2019-10-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91977\n+\t* tree-ssa-strlen.c (count_nonzero_bytes): Handle assignments with\n+\tMEM_REF right operand.  Avoid failing for MEM_REF assignments from\n+\tuninitialized objects.\n+\n 2019-10-04  Martin Sebor  <msebor@redhat.com>\n \n \t* builtins.c (compute_objsize): Add an argument."}, {"sha": "d8987cabc3dc6f0379f7e57d17f5f059383eae34", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=daa94de24b9afdf21c636532e53561aa3713910b", "patch": "@@ -1,3 +1,8 @@\n+2019-10-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91977\n+\t* gcc.dg/Wstringop-overflow-18.c: New test.\n+\n 2019-10-04  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc.dg/Wstringop-overflow-17.c: New test."}, {"sha": "092363aea31c8537a23423acb2e4f84e6341149b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-18.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-18.c?ref=daa94de24b9afdf21c636532e53561aa3713910b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Warray-bounds\" } */\n+/* { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow\" } */\n \n typedef struct\n {"}, {"sha": "7866b585b841ae3b9559259fd31e790d31275152", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-18.c", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-18.c?ref=daa94de24b9afdf21c636532e53561aa3713910b", "patch": "@@ -0,0 +1,239 @@\n+/* PR middle-end/91977 - missing -Wstringop-overflow on memcpy into\n+   a pointer plus offset\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#define NOIPA          __attribute__ ((noipa))\n+#define CONCAT(a, b)   a ## b\n+#define CAT(a, b)      CONCAT (a, b)\n+\n+#define S3 \"123\"\n+#define S4 \"1234\"\n+\n+char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8];\n+char b1[1], b2[2], b3[3], b4[4], b5[5], b6[6], b7[7], b8[8];\n+\n+#define T(dst, src, off, n)\t\t\t\t\t\\\n+  NOIPA void CAT (test_on_line_, __LINE__) (const void *s)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    __builtin_memcpy (dst + off, src, n);\t\t\t\\\n+  } typedef void dummy_type\n+\n+T (a4, s, 0, 1);\n+T (a4, s, 1, 1);\n+T (a4, s, 2, 1);\n+T (a4, s, 3, 1);\n+T (a4, s, 4, 1);    // { dg-warning \"writing 1 byte into a region of size 0\" }\n+\n+T (a4, s, 0, 2);\n+T (a4, s, 1, 2);\n+T (a4, s, 2, 2);\n+T (a4, s, 3, 2);    // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+T (a4, s, 4, 2);    // { dg-warning \"writing 2 bytes into a region of size 0\" }\n+\n+T (a4, s, 0, 3);\n+T (a4, s, 1, 3);\n+T (a4, s, 2, 3);    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+T (a4, s, 3, 3);    // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+T (a4, s, 4, 3);    // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+\n+T (a4, s, 0, 4);\n+T (a4, s, 1, 4);    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+T (a4, s, 2, 4);    // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+T (a4, s, 3, 4);    // { dg-warning \"writing 4 bytes into a region of size 1\" }\n+T (a4, s, 4, 4);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+\n+T (a7, s, 3, 3);\n+T (a7, s, 4, 3);\n+T (a7, s, 5, 3);    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+T (a7, s, 6, 3);    // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+T (a7, s, 7, 3);    // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+\n+T (a7, s, 3, 4);\n+T (a7, s, 4, 4);    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+T (a7, s, 5, 4);    // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+T (a7, s, 6, 4);    // { dg-warning \"writing 4 bytes into a region of size 1\" }\n+T (a7, s, 7, 4);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+\n+T (a7, s, 1, 6);\n+T (a7, s, 2, 6);    // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+T (a7, s, 3, 6);    // { dg-warning \"writing 6 bytes into a region of size 4\" }\n+T (a7, s, 4, 6);    // { dg-warning \"writing 6 bytes into a region of size 3\" }\n+T (a7, s, 5, 6);    // { dg-warning \"writing 6 bytes into a region of size 2\" }\n+T (a7, s, 6, 6);    // { dg-warning \"writing 6 bytes into a region of size 1\" }\n+T (a7, s, 7, 6);    // { dg-warning \"writing 6 bytes into a region of size 0\" }\n+\n+T (a8, s, 1, 7);\n+T (a8, s, 2, 7);    // { dg-warning \"writing 7 bytes into a region of size 6\" }\n+T (a8, s, 3, 7);    // { dg-warning \"writing 7 bytes into a region of size 5\" }\n+T (a8, s, 4, 7);    // { dg-warning \"writing 7 bytes into a region of size 4\" }\n+T (a8, s, 5, 7);    // { dg-warning \"writing 7 bytes into a region of size 3\" }\n+T (a8, s, 6, 7);    // { dg-warning \"writing 7 bytes into a region of size 2\" }\n+T (a8, s, 7, 7);    // { dg-warning \"writing 7 bytes into a region of size 1\" }\n+T (a8, s, 8, 7);    // { dg-warning \"writing 7 bytes into a region of size 0\" }\n+\n+#undef T\n+#define T(dst, src, off, n)\t\t\t\t\t\\\n+  NOIPA void CAT (test_on_line_, __LINE__) (const void *s)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    char *d = dst + off;\t\t\t\t\t\\\n+    __builtin_memcpy (d, src, n);\t\t\t\t\\\n+  } typedef void dummy_type\n+\n+T (a4, s, 0, 1);\n+T (a4, s, 1, 1);\n+T (a4, s, 2, 1);\n+T (a4, s, 3, 1);\n+T (a4, s, 4, 1);    // { dg-warning \"writing 1 byte into a region of size 0\" }\n+\n+T (a4, s, 0, 2);\n+T (a4, s, 1, 2);\n+T (a4, s, 2, 2);\n+T (a4, s, 3, 2);    // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+T (a4, s, 4, 2);    // { dg-warning \"writing 2 bytes into a region of size 0\" }\n+\n+T (a4, s, 0, 3);\n+T (a4, s, 1, 3);\n+T (a4, s, 2, 3);    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+T (a4, s, 3, 3);    // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+T (a4, s, 4, 3);    // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+\n+T (a4, s, 0, 4);\n+T (a4, s, 1, 4);    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+T (a4, s, 2, 4);    // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+T (a4, s, 3, 4);    // { dg-warning \"writing 4 bytes into a region of size 1\" }\n+T (a4, s, 4, 4);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+\n+T (a7, s, 3, 3);\n+T (a7, s, 4, 3);\n+T (a7, s, 5, 3);    // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+T (a7, s, 6, 3);    // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+T (a7, s, 7, 3);    // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+\n+T (a7, s, 3, 4);\n+T (a7, s, 4, 4);    // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+T (a7, s, 5, 4);    // { dg-warning \"writing 4 bytes into a region of size 2\" }\n+T (a7, s, 6, 4);    // { dg-warning \"writing 4 bytes into a region of size 1\" }\n+T (a7, s, 7, 4);    // { dg-warning \"writing 4 bytes into a region of size 0\" }\n+\n+T (a7, s, 1, 6);\n+T (a7, s, 2, 6);    // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+T (a7, s, 3, 6);    // { dg-warning \"writing 6 bytes into a region of size 4\" }\n+T (a7, s, 4, 6);    // { dg-warning \"writing 6 bytes into a region of size 3\" }\n+T (a7, s, 5, 6);    // { dg-warning \"writing 6 bytes into a region of size 2\" }\n+T (a7, s, 6, 6);    // { dg-warning \"writing 6 bytes into a region of size 1\" }\n+T (a7, s, 7, 6);    // { dg-warning \"writing 6 bytes into a region of size 0\" }\n+\n+#undef T\n+#define T(dst, src, init, off, n)\t\t\t\\\n+  NOIPA void CAT (test_on_line_, __LINE__) (void)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    __builtin_strcpy (src, init);\t\t\t\\\n+    char *d = dst + off;\t\t\t\t\\\n+    __builtin_memcpy (d, src, n);\t\t\t\\\n+  } typedef void dummy_type\n+\n+\n+T (a6, b6, S4, 0, 4);\n+T (a6, b6, S4, 1, 4);\n+T (a6, b6, S4, 2, 4);\n+T (a6, b6, S4, 3, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a6, b6, S4, 4, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a6, b6, S4, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a6, b6, S4, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a7, b7, S4, 0, 4);\n+T (a7, b7, S4, 1, 4);\n+T (a7, b7, S4, 2, 4);\n+T (a7, b7, S4, 3, 4);\n+T (a7, b7, S4, 4, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a7, b7, S4, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a7, b7, S4, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a7, b7, S4, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a8, b4, S3, 0, 4);\n+T (a8, b4, S3, 1, 4);\n+T (a8, b4, S3, 2, 4);\n+T (a8, b4, S3, 3, 4);\n+T (a8, b4, S3, 4, 4);\n+T (a8, b4, S3, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a8, b4, S3, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a8, b4, S3, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a8, b4, S3, 8, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a8, b8, S3, 0, 4);\n+T (a8, b8, S3, 1, 4);\n+T (a8, b8, S3, 2, 4);\n+T (a8, b8, S3, 3, 4);\n+T (a8, b8, S3, 4, 4);\n+T (a8, b8, S3, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a8, b8, S3, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a8, b8, S3, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a8, b8, S3, 8, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a8, b8, S4, 0, 4);\n+T (a8, b8, S4, 1, 4);\n+T (a8, b8, S4, 2, 4);\n+T (a8, b8, S4, 3, 4);\n+T (a8, b8, S4, 4, 4);\n+T (a8, b8, S4, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a8, b8, S4, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a8, b8, S4, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a8, b8, S4, 8, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a8, b8, S4, 0, 5);\n+T (a8, b8, S4, 1, 5);\n+T (a8, b8, S4, 2, 5);\n+T (a8, b8, S4, 3, 5);\n+T (a8, b8, S4, 4, 5);   // { dg-warning \"writing 5 bytes into a region of size 4\" } */\n+T (a8, b8, S4, 5, 5);   // { dg-warning \"writing 5 bytes into a region of size 3\" } */\n+T (a8, b8, S4, 6, 5);   // { dg-warning \"writing 5 bytes into a region of size 2\" } */\n+T (a8, b8, S4, 7, 5);   // { dg-warning \"writing 5 bytes into a region of size 1\" } */\n+T (a8, b8, S4, 8, 5);   // { dg-warning \"writing 5 bytes into a region of size 0\" } */\n+\n+T (a8, b8, S4, 0, 6);\n+T (a8, b8, S4, 1, 6);\n+T (a8, b8, S4, 2, 6);\n+T (a8, b8, S4, 3, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" } */\n+T (a8, b8, S4, 4, 6);   // { dg-warning \"writing 6 bytes into a region of size 4\" } */\n+T (a8, b8, S4, 5, 6);   // { dg-warning \"writing 6 bytes into a region of size 3\" } */\n+T (a8, b8, S4, 6, 6);   // { dg-warning \"writing 6 bytes into a region of size 2\" } */\n+T (a8, b8, S4, 7, 6);   // { dg-warning \"writing 6 bytes into a region of size 1\" } */\n+T (a8, b8, S4, 8, 6);   // { dg-warning \"writing 6 bytes into a region of size 0\" } */\n+\n+\n+#undef T\n+#define T(dst, init, off, n)\t\t\t\t\\\n+  NOIPA void CAT (test_on_line_, __LINE__) (char *src)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    __builtin_strcpy (src, init);\t\t\t\\\n+    char *d = dst + off;\t\t\t\t\\\n+    __builtin_memcpy (d, src, n);\t\t\t\\\n+  } typedef void dummy_type\n+\n+T (a6, S4, 0, 4);\n+T (a6, S4, 1, 4);\n+T (a6, S4, 2, 4);\n+T (a6, S4, 3, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a6, S4, 4, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a6, S4, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a6, S4, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a7, S4, 0, 4);\n+T (a7, S4, 1, 4);\n+T (a7, S4, 2, 4);\n+T (a7, S4, 3, 4);\n+T (a7, S4, 4, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a7, S4, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a7, S4, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a7, S4, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */\n+\n+T (a8, S3, 0, 4);\n+T (a8, S3, 1, 4);\n+T (a8, S3, 2, 4);\n+T (a8, S3, 3, 4);\n+T (a8, S3, 4, 4);\n+T (a8, S3, 5, 4);   // { dg-warning \"writing 4 bytes into a region of size 3\" } */\n+T (a8, S3, 6, 4);   // { dg-warning \"writing 4 bytes into a region of size 2\" } */\n+T (a8, S3, 7, 4);   // { dg-warning \"writing 4 bytes into a region of size 1\" } */\n+T (a8, S3, 8, 4);   // { dg-warning \"writing 4 bytes into a region of size 0\" } */"}, {"sha": "d68df19aa821d55c6455ce1c961513be56a1ac2a", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa94de24b9afdf21c636532e53561aa3713910b/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=daa94de24b9afdf21c636532e53561aa3713910b", "patch": "@@ -3801,40 +3801,44 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       tree type = TREE_TYPE (exp);\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n-\t  && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node))\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node)\n+\t  && tree_expr_nonzero_p (exp))\n \t{\n-\t  /* Determine if the character EXP is known to be non-zero\n-\t     (even if its exact value is not known) and if so, recurse\n-\t     once to set the range, etc.  */\n-\t  if (tree_expr_nonzero_p (exp))\n-\t    return count_nonzero_bytes (build_int_cst (type, 1),\n-\t\t\t\t\toffset, nbytes, lenrange,\n-\t\t\t\t\tnulterm, allnul, allnonnul, snlim);\n-\t  /* Don't know whether EXP is or isn't nonzero.  */\n-\t  return false;\n+\t  /* If the character EXP is known to be non-zero (even if its\n+\t     exact value is not known) recurse once to set the range\n+\t     for an arbitrary constant.  */\n+\t  exp = build_int_cst (type, 1);\n+\t  return count_nonzero_bytes (exp, offset, 1, lenrange,\n+\t\t\t\t      nulterm, allnul, allnonnul, snlim);\n \t}\n \n       gimple *stmt = SSA_NAME_DEF_STMT (exp);\n-      if (gimple_code (stmt) != GIMPLE_PHI)\n-\treturn false;\n-\n-      /* Avoid processing an SSA_NAME that has already been visited\n-\t or if an SSA_NAME limit has been reached.  Indicate success\n-\t if the former and failure if the latter.  */\n-      if (int res = snlim.next_ssa_name (exp))\n-\treturn res > 0;\n-\n-      /* Determine the minimum and maximum from the PHI arguments.  */\n-      unsigned int n = gimple_phi_num_args (stmt);\n-      for (unsigned i = 0; i != n; i++)\n+      if (gimple_assign_single_p (stmt))\n \t{\n-\t  tree def = gimple_phi_arg_def (stmt, i);\n-\t  if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n-\t\t\t\t    allnul, allnonnul, snlim))\n+\t  exp = gimple_assign_rhs1 (stmt);\n+\t  if (TREE_CODE (exp) != MEM_REF)\n \t    return false;\n \t}\n+      else if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  /* Avoid processing an SSA_NAME that has already been visited\n+\t     or if an SSA_NAME limit has been reached.  Indicate success\n+\t     if the former and failure if the latter.  */\n+\t  if (int res = snlim.next_ssa_name (exp))\n+\t    return res > 0;\n+\n+\t  /* Determine the minimum and maximum from the PHI arguments.  */\n+\t  unsigned int n = gimple_phi_num_args (stmt);\n+\t  for (unsigned i = 0; i != n; i++)\n+\t    {\n+\t      tree def = gimple_phi_arg_def (stmt, i);\n+\t      if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n+\t\t\t\t\tallnul, allnonnul, snlim))\n+\t\treturn false;\n+\t    }\n \n-      return true;\n+\t  return true;\n+\t}\n     }\n \n   if (TREE_CODE (exp) == MEM_REF)\n@@ -3897,14 +3901,25 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n       prep = reinterpret_cast <char *>(buf);\n       /* Try to extract the representation of the constant object\n \t or expression starting from the offset.  */\n-      nbytes = native_encode_expr (exp, buf, sizeof buf, offset);\n-      if (!nbytes)\n-\treturn false;\n+      unsigned repsize = native_encode_expr (exp, buf, sizeof buf, offset);\n+      if (repsize < nbytes)\n+\t{\n+\t  /* This should only happen when REPSIZE is zero because EXP\n+\t     doesn't denote an object with a known initializer, except\n+\t     perhaps when the reference reads past its end.  */\n+\t  lenrange[0] = 0;\n+\t  prep = NULL;\n+\t}\n+      else\n+\tnbytes = repsize;\n     }\n \n+  if (!nbytes)\n+    return false;\n+\n   /* Compute the number of leading nonzero bytes in the representation\n      and update the minimum and maximum.  */\n-  unsigned n = strnlen (prep, nbytes);\n+  unsigned n = prep ? strnlen (prep, nbytes) : nbytes;\n \n   if (n < lenrange[0])\n     lenrange[0] = n;"}]}