{"sha": "7b7b1813daa8b65c1528025e3fd9e459690b72c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I3YjE4MTNkYWE4YjY1YzE1MjgwMjVlM2ZkOWU0NTk2OTBiNzJjNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-10-24T14:24:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-10-24T14:24:36Z"}, "message": "tree-vect-stmts.c (vect_get_vec_def_for_operand): Convert constants to vector element type.\n\n2011-10-24  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vect-stmts.c (vect_get_vec_def_for_operand): Convert constants\n\tto vector element type.\n\t(vectorizable_assignment): Bail out for non-mode-precision operations.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_type_demotion): Likewise.\n\t(vectorizable_type_promotion): Likewise.\n\t(vectorizable_store): Handle non-mode-precision stores.\n\t(vectorizable_load): Handle non-mode-precision loads.\n\t(get_vectype_for_scalar_type_and_size): Return a vector type\n\tfor non-mode-precision integers.\n\t* tree-vect-loop.c (vectorizable_reduction): Bail out for\n\tnon-mode-precision reductions.\n\n\t* gcc.dg/vect/vect-bool-1.c: New testcase.\n\nFrom-SVN: r180384", "tree": {"sha": "7e7f20eb45a94a6b7cee99303e10a1078d06bc27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e7f20eb45a94a6b7cee99303e10a1078d06bc27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b7b1813daa8b65c1528025e3fd9e459690b72c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b7b1813daa8b65c1528025e3fd9e459690b72c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b7b1813daa8b65c1528025e3fd9e459690b72c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b7b1813daa8b65c1528025e3fd9e459690b72c4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "695074beca1441d103d7da374ae4eb6b8f3b4be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695074beca1441d103d7da374ae4eb6b8f3b4be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695074beca1441d103d7da374ae4eb6b8f3b4be5"}], "stats": {"total": 148, "additions": 118, "deletions": 30}, "files": [{"sha": "a4887889af4c43167a6fd134fe522b9f669c6a25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b7b1813daa8b65c1528025e3fd9e459690b72c4", "patch": "@@ -1,3 +1,19 @@\n+2011-10-24  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vect-stmts.c (vect_get_vec_def_for_operand): Convert constants\n+\tto vector element type.\n+\t(vectorizable_assignment): Bail out for non-mode-precision operations.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Likewise.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_store): Handle non-mode-precision stores.\n+\t(vectorizable_load): Handle non-mode-precision loads.\n+\t(get_vectype_for_scalar_type_and_size): Return a vector type\n+\tfor non-mode-precision integers.\n+\t* tree-vect-loop.c (vectorizable_reduction): Bail out for\n+\tnon-mode-precision reductions.\n+\n 2011-10-24  Julian Brown  <julian@codesourcery.com>\n \n \t* config/m68k/m68k.c (notice_update_cc): Tighten condition for"}, {"sha": "77b1cc8143280ca2d45ff10893b9119679eb9252", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b7b1813daa8b65c1528025e3fd9e459690b72c4", "patch": "@@ -1,3 +1,7 @@\n+2011-10-24  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/vect-bool-1.c: New testcase.\n+\n 2011-10-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50838"}, {"sha": "fd12f5c77a3a4e660fa0460cc8784f71be59c893", "filename": "gcc/testsuite/gcc.dg/vect/vect-bool-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-bool-1.c?ref=7b7b1813daa8b65c1528025e3fd9e459690b72c4", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+_Bool a[1024];\n+_Bool b[1024];\n+_Bool c[1024];\n+void foo (void)\n+{\n+  unsigned i;\n+  for (i = 0; i < 1024; ++i)\n+    a[i] = b[i] | c[i];\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a04099fc06ae97eea6c604e76304b97ba8b62758", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7b7b1813daa8b65c1528025e3fd9e459690b72c4", "patch": "@@ -4422,6 +4422,11 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       && !SCALAR_FLOAT_TYPE_P (scalar_type))\n     return false;\n \n+  /* Do not try to vectorize bit-precision reductions.  */\n+  if ((TYPE_PRECISION (scalar_type)\n+       != GET_MODE_PRECISION (TYPE_MODE (scalar_type))))\n+    return false;\n+\n   /* All uses but the last are expected to be defined in the loop.\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the"}, {"sha": "fd1cd19f7b3ffc959c20f29e423b22723aed026a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 78, "deletions": 30, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b7b1813daa8b65c1528025e3fd9e459690b72c4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7b7b1813daa8b65c1528025e3fd9e459690b72c4", "patch": "@@ -1204,7 +1204,9 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"Create vector_cst. nunits = %d\", nunits);\n \n-        vec_cst = build_vector_from_val (vector_type, op);\n+        vec_cst = build_vector_from_val (vector_type,\n+\t\t\t\t\t fold_convert (TREE_TYPE (vector_type),\n+\t\t\t\t\t\t       op));\n         return vect_init_vector (stmt, vec_cst, vector_type, NULL);\n       }\n \n@@ -2173,6 +2175,25 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n \t      != GET_MODE_SIZE (TYPE_MODE (vectype_in)))))\n     return false;\n \n+  /* We do not handle bit-precision changes.  */\n+  if ((CONVERT_EXPR_CODE_P (code)\n+       || code == VIEW_CONVERT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+      && ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+\t   != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+\t  || ((TYPE_PRECISION (TREE_TYPE (op))\n+\t       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (op))))))\n+      /* But a conversion that does not change the bit-pattern is ok.  */\n+      && !((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+\t    > TYPE_PRECISION (TREE_TYPE (op)))\n+\t   && TYPE_UNSIGNED (TREE_TYPE (op))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"type conversion to/from bit-precision \"\n+\t\t \"unsupported.\");\n+      return false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n@@ -2326,6 +2347,13 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \n   scalar_dest = gimple_assign_lhs (stmt);\n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+  if (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+      != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"bit-precision shifts not supported.\");\n+      return false;\n+    }\n \n   op0 = gimple_assign_rhs1 (stmt);\n   if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n@@ -2660,6 +2688,20 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   scalar_dest = gimple_assign_lhs (stmt);\n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n \n+  /* Most operations cannot handle bit-precision types without extra\n+     truncations.  */\n+  if ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+      /* Exception are bitwise binary operations.  */\n+      && code != BIT_IOR_EXPR\n+      && code != BIT_XOR_EXPR\n+      && code != BIT_AND_EXPR)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"bit-precision arithmetic not supported.\");\n+      return false;\n+    }\n+\n   op0 = gimple_assign_rhs1 (stmt);\n   if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype))\n@@ -3082,9 +3124,20 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n \t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n-\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n-\t     && CONVERT_EXPR_CODE_P (code))))\n+\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0)))))\n     return false;\n+\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+      && ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+\t   != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+\t  || ((TYPE_PRECISION (TREE_TYPE (op0))\n+\t       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (op0)))))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"type demotion to/from bit-precision unsupported.\");\n+      return false;\n+    }\n+\n   if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n@@ -3365,6 +3418,19 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n \t     && CONVERT_EXPR_CODE_P (code))))\n     return false;\n+\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+      && ((TYPE_PRECISION (TREE_TYPE (scalar_dest))\n+\t   != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n+\t  || ((TYPE_PRECISION (TREE_TYPE (op0))\n+\t       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (op0)))))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"type promotion to/from bit-precision \"\n+\t\t \"unsupported.\");\n+      return false;\n+    }\n+\n   if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n@@ -3673,17 +3739,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  /* The scalar rhs type needs to be trivially convertible to the vector\n-     component type.  This should always be the case.  */\n   elem_type = TREE_TYPE (vectype);\n-  if (!useless_type_conversion_p (elem_type, TREE_TYPE (op)))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"???  operands of different types\");\n-      return false;\n-    }\n-\n   vec_mode = TYPE_MODE (vectype);\n+\n   /* FORNOW. In some cases can vectorize even if data-type not supported\n      (e.g. - array initialization with 0).  */\n   if (optab_handler (mov_optab, vec_mode) == CODE_FOR_nothing)\n@@ -4117,7 +4175,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool strided_load = false;\n   bool load_lanes_p = false;\n   gimple first_stmt;\n-  tree scalar_type;\n   bool inv_p;\n   bool negative;\n   bool compute_in_loop = false;\n@@ -4192,7 +4249,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  scalar_type = TREE_TYPE (DR_REF (dr));\n+  elem_type = TREE_TYPE (vectype);\n   mode = TYPE_MODE (vectype);\n \n   /* FORNOW. In some cases can vectorize even if data-type not supported\n@@ -4204,16 +4261,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  /* The vector component type needs to be trivially convertible to the\n-     scalar lhs.  This should always be the case.  */\n-  elem_type = TREE_TYPE (vectype);\n-  if (!useless_type_conversion_p (TREE_TYPE (scalar_dest), elem_type))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"???  operands of different types\");\n-      return false;\n-    }\n-\n   /* Check if the load is a part of an interleaving chain.  */\n   if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n@@ -4560,7 +4607,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t    msq = new_temp;\n \n \t\t    bump = size_binop (MULT_EXPR, vs_minus_1,\n-\t\t\t\t       TYPE_SIZE_UNIT (scalar_type));\n+\t\t\t\t       TYPE_SIZE_UNIT (elem_type));\n \t\t    ptr = bump_vector_ptr (dataref_ptr, NULL, gsi, stmt, bump);\n \t\t    new_stmt = gimple_build_assign_with_ops\n \t\t\t\t (BIT_AND_EXPR, NULL_TREE, ptr,\n@@ -5441,13 +5488,14 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n   if (nbytes < TYPE_ALIGN_UNIT (scalar_type))\n     return NULL_TREE;\n \n-  /* If we'd build a vector type of elements whose mode precision doesn't\n-     match their types precision we'll get mismatched types on vector\n-     extracts via BIT_FIELD_REFs.  This effectively means we disable\n-     vectorization of bool and/or enum types in some languages.  */\n+  /* For vector types of elements whose mode precision doesn't\n+     match their types precision we use a element type of mode\n+     precision.  The vectorization routines will have to make sure\n+     they support the proper result truncation/extension.  */\n   if (INTEGRAL_TYPE_P (scalar_type)\n       && GET_MODE_BITSIZE (inner_mode) != TYPE_PRECISION (scalar_type))\n-    return NULL_TREE;\n+    scalar_type = build_nonstandard_integer_type (GET_MODE_BITSIZE (inner_mode),\n+\t\t\t\t\t\t  TYPE_UNSIGNED (scalar_type));\n \n   if (GET_MODE_CLASS (inner_mode) != MODE_INT\n       && GET_MODE_CLASS (inner_mode) != MODE_FLOAT)"}]}