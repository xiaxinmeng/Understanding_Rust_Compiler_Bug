{"sha": "6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3YWU4YzU2ZjkzNDFmMTgwZTA5N2Q1ZWI3YmEwNWNiOGVlYzQxMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-05-24T21:31:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-24T21:31:59Z"}, "message": "tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__CONDTEMP_.\n\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__CONDTEMP_.\n\t* tree.h (OMP_CLAUSE_DECL): Use OMP_CLAUSE__CONDTEMP_ instead of\n\tOMP_CLAUSE__REDUCTEMP_.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n\tOMP_CLAUSE__CONDTEMP_.\n\t(walk_tree_1): Handle OMP_CLAUSE__CONDTEMP_.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Likewise.\n\t* gimplify.c (enum gimplify_omp_var_data): Use hexadecimal constants\n\tinstead of decimal.  Add GOVD_LASTPRIVATE_CONDITIONAL.\n\t(gimplify_scan_omp_clauses): Don't reject lastprivate conditional\n\ton OMP_FOR.\n\t(gimplify_omp_for): Warn and disable conditional modifier from\n\tlastprivate on loop iterators.\n\t* omp-general.h (struct omp_for_data): Add lastprivate_conditional\n\tmember.\n\t* omp-general.c (omp_extract_for_data): Initialize it.\n\t* omp-low.c (struct omp_context): Add lastprivate_conditional_map\n\tmember.\n\t(delete_omp_context): Delete it.\n\t(lower_lastprivate_conditional_clauses): New function.\n\t(lower_lastprivate_clauses): Add BODY_P and CSTMT_LIST arguments,\n\thandle lastprivate conditional clauses.\n\t(lower_reduction_clauses): Add CLIST argument, emit it into\n\tthe critical section if any.\n\t(lower_omp_sections): Adjust lower_lastprivate_clauses and\n\tlower_reduction_clauses callers.\n\t(lower_omp_for_lastprivate): Add CLIST argument, pass it through\n\tto lower_lastprivate_clauses.\n\t(lower_omp_for): Call lower_lastprivate_conditional_clauses, adjust\n\tlower_omp_for_lastprivate and lower_reduction_clauses callers, emit\n\tclist into a critical section if not emitted there already by\n\tlower_reduction_clauses.\n\t(lower_omp_taskreg, lower_omp_teams): Adjust lower_reduction_clauses\n\tcallers.\n\t(lower_omp_1): Handle GIMPLE_ASSIGNs storing into lastprivate\n\tconditional variables.\n\t* omp-expand.c (determine_parallel_type): Punt if OMP_CLAUSE__CONDTEMP_\n\tclause is present.\n\t(expand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk): Handle lastprivate conditional.\n\t(expand_omp_for): Handle fd.lastprivate_conditional like\n\tfd.have_reductemp.\ngcc/testsuite/\n\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n\tsorry for omp for.\n\t* c-c++-common/gomp/lastprivate-conditional-3.c: New test.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c: New test.\n\nFrom-SVN: r271610", "tree": {"sha": "425965042d935027e8cc7045b383f6b7b6f714f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/425965042d935027e8cc7045b383f6b7b6f714f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09b4000c7c5b359ec62b5d621daf6ab95233ce10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b4000c7c5b359ec62b5d621daf6ab95233ce10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b4000c7c5b359ec62b5d621daf6ab95233ce10"}], "stats": {"total": 1006, "additions": 915, "deletions": 91}, "files": [{"sha": "93ba0f23592dc3a5234a8c15b25b07339e65384e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -1,3 +1,50 @@\n+2019-05-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__CONDTEMP_.\n+\t* tree.h (OMP_CLAUSE_DECL): Use OMP_CLAUSE__CONDTEMP_ instead of\n+\tOMP_CLAUSE__REDUCTEMP_.\n+\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add\n+\tOMP_CLAUSE__CONDTEMP_.\n+\t(walk_tree_1): Handle OMP_CLAUSE__CONDTEMP_.\n+\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Likewise.\n+\t* gimplify.c (enum gimplify_omp_var_data): Use hexadecimal constants\n+\tinstead of decimal.  Add GOVD_LASTPRIVATE_CONDITIONAL.\n+\t(gimplify_scan_omp_clauses): Don't reject lastprivate conditional\n+\ton OMP_FOR.\n+\t(gimplify_omp_for): Warn and disable conditional modifier from\n+\tlastprivate on loop iterators.\n+\t* omp-general.h (struct omp_for_data): Add lastprivate_conditional\n+\tmember.\n+\t* omp-general.c (omp_extract_for_data): Initialize it.\n+\t* omp-low.c (struct omp_context): Add lastprivate_conditional_map\n+\tmember.\n+\t(delete_omp_context): Delete it.\n+\t(lower_lastprivate_conditional_clauses): New function.\n+\t(lower_lastprivate_clauses): Add BODY_P and CSTMT_LIST arguments,\n+\thandle lastprivate conditional clauses.\n+\t(lower_reduction_clauses): Add CLIST argument, emit it into\n+\tthe critical section if any.\n+\t(lower_omp_sections): Adjust lower_lastprivate_clauses and\n+\tlower_reduction_clauses callers.\n+\t(lower_omp_for_lastprivate): Add CLIST argument, pass it through\n+\tto lower_lastprivate_clauses.\n+\t(lower_omp_for): Call lower_lastprivate_conditional_clauses, adjust\n+\tlower_omp_for_lastprivate and lower_reduction_clauses callers, emit\n+\tclist into a critical section if not emitted there already by\n+\tlower_reduction_clauses.\n+\t(lower_omp_taskreg, lower_omp_teams): Adjust lower_reduction_clauses\n+\tcallers.\n+\t(lower_omp_1): Handle GIMPLE_ASSIGNs storing into lastprivate\n+\tconditional variables.\n+\t* omp-expand.c (determine_parallel_type): Punt if OMP_CLAUSE__CONDTEMP_\n+\tclause is present.\n+\t(expand_omp_for_generic, expand_omp_for_static_nochunk,\n+\texpand_omp_for_static_chunk): Handle lastprivate conditional.\n+\t(expand_omp_for): Handle fd.lastprivate_conditional like\n+\tfd.have_reductemp.\n+\n 2019-05-24  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-run.c (main): Set a non-zero return value if the"}, {"sha": "b8b7e803990a71fdacf37f9a09d8121b40173d97", "filename": "gcc/gimplify.c", "status": "modified", "additions": 71, "deletions": 28, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -71,47 +71,50 @@ static hash_set<tree> *asan_poisoned_variables = NULL;\n \n enum gimplify_omp_var_data\n {\n-  GOVD_SEEN = 1,\n-  GOVD_EXPLICIT = 2,\n-  GOVD_SHARED = 4,\n-  GOVD_PRIVATE = 8,\n-  GOVD_FIRSTPRIVATE = 16,\n-  GOVD_LASTPRIVATE = 32,\n-  GOVD_REDUCTION = 64,\n-  GOVD_LOCAL = 128,\n-  GOVD_MAP = 256,\n-  GOVD_DEBUG_PRIVATE = 512,\n-  GOVD_PRIVATE_OUTER_REF = 1024,\n-  GOVD_LINEAR = 2048,\n-  GOVD_ALIGNED = 4096,\n+  GOVD_SEEN = 0x000001,\n+  GOVD_EXPLICIT = 0x000002,\n+  GOVD_SHARED = 0x000004,\n+  GOVD_PRIVATE = 0x000008,\n+  GOVD_FIRSTPRIVATE = 0x000010,\n+  GOVD_LASTPRIVATE = 0x000020,\n+  GOVD_REDUCTION = 0x000040,\n+  GOVD_LOCAL = 0x00080,\n+  GOVD_MAP = 0x000100,\n+  GOVD_DEBUG_PRIVATE = 0x000200,\n+  GOVD_PRIVATE_OUTER_REF = 0x000400,\n+  GOVD_LINEAR = 0x000800,\n+  GOVD_ALIGNED = 0x001000,\n \n   /* Flag for GOVD_MAP: don't copy back.  */\n-  GOVD_MAP_TO_ONLY = 8192,\n+  GOVD_MAP_TO_ONLY = 0x002000,\n \n   /* Flag for GOVD_LINEAR or GOVD_LASTPRIVATE: no outer reference.  */\n-  GOVD_LINEAR_LASTPRIVATE_NO_OUTER = 16384,\n+  GOVD_LINEAR_LASTPRIVATE_NO_OUTER = 0x004000,\n \n-  GOVD_MAP_0LEN_ARRAY = 32768,\n+  GOVD_MAP_0LEN_ARRAY = 0x008000,\n \n   /* Flag for GOVD_MAP, if it is always, to or always, tofrom mapping.  */\n-  GOVD_MAP_ALWAYS_TO = 65536,\n+  GOVD_MAP_ALWAYS_TO = 0x010000,\n \n   /* Flag for shared vars that are or might be stored to in the region.  */\n-  GOVD_WRITTEN = 131072,\n+  GOVD_WRITTEN = 0x020000,\n \n   /* Flag for GOVD_MAP, if it is a forced mapping.  */\n-  GOVD_MAP_FORCE = 262144,\n+  GOVD_MAP_FORCE = 0x040000,\n \n   /* Flag for GOVD_MAP: must be present already.  */\n-  GOVD_MAP_FORCE_PRESENT = 524288,\n+  GOVD_MAP_FORCE_PRESENT = 0x080000,\n \n   /* Flag for GOVD_MAP: only allocate.  */\n-  GOVD_MAP_ALLOC_ONLY = 1048576,\n+  GOVD_MAP_ALLOC_ONLY = 0x100000,\n \n   /* Flag for GOVD_MAP: only copy back.  */\n-  GOVD_MAP_FROM_ONLY = 2097152,\n+  GOVD_MAP_FROM_ONLY = 0x200000,\n \n-  GOVD_NONTEMPORAL = 4194304,\n+  GOVD_NONTEMPORAL = 0x400000,\n+\n+  /* Flag for GOVD_LASTPRIVATE: conditional modifier.  */\n+  GOVD_LASTPRIVATE_CONDITIONAL = 0x800000,\n \n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n@@ -8139,9 +8142,17 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n \t    }\n \t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n-\t    sorry_at (OMP_CLAUSE_LOCATION (c),\n-\t\t      \"%<conditional%> modifier on %<lastprivate%> clause \"\n-\t\t      \"not supported yet\");\n+\t    {\n+\t      if (code == OMP_FOR)\n+\t\tflags |= GOVD_LASTPRIVATE_CONDITIONAL;\n+\t      else\n+\t\t{\n+\t\t  sorry_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<conditional%> modifier on %<lastprivate%> \"\n+\t\t\t    \"clause not supported yet\");\n+\t\t  OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n+\t\t}\n+\t    }\n \t  if (outer_ctx\n \t      && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n \t\t  || ((outer_ctx->region_type & ORT_COMBINED_TEAMS)\n@@ -10770,7 +10781,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t\t  1 + (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n \t\t\t       != 1));\n \t  if (n != NULL && (n->value & GOVD_DATA_SHARE_CLASS) != 0)\n-\t    omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+\t    {\n+\t      omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+\t      if (n->value & GOVD_LASTPRIVATE_CONDITIONAL)\n+\t\tfor (tree c3 = omp_find_clause (OMP_FOR_CLAUSES (for_stmt),\n+\t\t\t\t\t\tOMP_CLAUSE_LASTPRIVATE);\n+\t\t     c3; c3 = omp_find_clause (OMP_CLAUSE_CHAIN (c3),\n+\t\t\t\t\t       OMP_CLAUSE_LASTPRIVATE))\n+\t\t  if (OMP_CLAUSE_DECL (c3) == decl)\n+\t\t    {\n+\t\t      warning_at (OMP_CLAUSE_LOCATION (c3), 0,\n+\t\t\t\t  \"conditional %<lastprivate%> on loop \"\n+\t\t\t\t  \"iterator %qD ignored\", decl);\n+\t\t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c3) = 0;\n+\t\t      n->value &= ~GOVD_LASTPRIVATE_CONDITIONAL;\n+\t\t    }\n+\t    }\n \t  else if (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n \t    {\n \t      c = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n@@ -11005,7 +11031,24 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t}\n       else if (omp_is_private (gimplify_omp_ctxp, decl, 0))\n-\tomp_notice_variable (gimplify_omp_ctxp, decl, true);\n+\t{\n+\t  omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+\t  splay_tree_node n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n+\t\t\t\t\t\t (splay_tree_key) decl);\n+\t  if (n && (n->value & GOVD_LASTPRIVATE_CONDITIONAL))\n+\t    for (tree c3 = omp_find_clause (OMP_FOR_CLAUSES (for_stmt),\n+\t\t\t\t\t    OMP_CLAUSE_LASTPRIVATE);\n+\t\t c3; c3 = omp_find_clause (OMP_CLAUSE_CHAIN (c3),\n+\t\t\t\t\t   OMP_CLAUSE_LASTPRIVATE))\n+\t      if (OMP_CLAUSE_DECL (c3) == decl)\n+\t\t{\n+\t\t  warning_at (OMP_CLAUSE_LOCATION (c3), 0,\n+\t\t\t      \"conditional %<lastprivate%> on loop \"\n+\t\t\t      \"iterator %qD ignored\", decl);\n+\t\t  OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c3) = 0;\n+\t\t  n->value &= ~GOVD_LASTPRIVATE_CONDITIONAL;\n+\t\t}\n+\t}\n       else\n \tomp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n "}, {"sha": "dfac4b075e5bdc25653476f97912b1b59170d4b2", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 260, "deletions": 40, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -345,7 +345,8 @@ determine_parallel_type (struct omp_region *region)\n \t      || ((OMP_CLAUSE_SCHEDULE_KIND (c) & OMP_CLAUSE_SCHEDULE_MASK)\n \t\t  == OMP_CLAUSE_SCHEDULE_STATIC)\n \t      || omp_find_clause (clauses, OMP_CLAUSE_ORDERED)\n-\t      || omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_))\n+\t      || omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_)\n+\t      || omp_find_clause (clauses, OMP_CLAUSE__CONDTEMP_))\n \t    return;\n \t}\n       else if (region->inner->type == GIMPLE_OMP_SECTIONS\n@@ -2679,16 +2680,17 @@ expand_omp_for_generic (struct omp_region *region,\n \n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   if (fd->ordered\n-      && omp_find_clause (gimple_omp_for_clauses (gsi_stmt (gsi)),\n+      && omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t  OMP_CLAUSE_LASTPRIVATE))\n     ordered_lastprivate = false;\n   tree reductions = NULL_TREE;\n-  tree mem = NULL_TREE;\n+  tree mem = NULL_TREE, cond_var = NULL_TREE, condtemp = NULL_TREE;\n+  tree memv = NULL_TREE;\n   if (sched_arg)\n     {\n       if (fd->have_reductemp)\n \t{\n-\t  tree c = omp_find_clause (gimple_omp_for_clauses (gsi_stmt (gsi)),\n+\t  tree c = omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n \t\t\t\t    OMP_CLAUSE__REDUCTEMP_);\n \t  reductions = OMP_CLAUSE_DECL (c);\n \t  gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n@@ -2703,8 +2705,25 @@ expand_omp_for_generic (struct omp_region *region,\n \t}\n       else\n \treductions = null_pointer_node;\n-      /* For now.  */\n-      mem = null_pointer_node;\n+      if (fd->lastprivate_conditional)\n+\t{\n+\t  tree c = omp_find_clause (gimple_omp_for_clauses (fd->for_stmt),\n+\t\t\t\t    OMP_CLAUSE__CONDTEMP_);\n+\t  condtemp = OMP_CLAUSE_DECL (c);\n+\t  c = omp_find_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE__CONDTEMP_);\n+\t  cond_var = OMP_CLAUSE_DECL (c);\n+\t  tree type = TREE_TYPE (condtemp);\n+\t  memv = create_tmp_var (type);\n+\t  TREE_ADDRESSABLE (memv) = 1;\n+\t  unsigned HOST_WIDE_INT sz\n+\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t  sz *= fd->lastprivate_conditional;\n+\t  expand_omp_build_assign (&gsi, memv, build_int_cst (type, sz),\n+\t\t\t\t   false);\n+\t  mem = build_fold_addr_expr (memv);\n+\t}\n+      else\n+\tmem = null_pointer_node;\n     }\n   if (fd->collapse > 1 || fd->ordered)\n     {\n@@ -2959,6 +2978,8 @@ expand_omp_for_generic (struct omp_region *region,\n       gsi_insert_before (&gsi, gimple_build_assign (arr, clobber),\n \t\t\t GSI_SAME_STMT);\n     }\n+  if (fd->lastprivate_conditional)\n+    expand_omp_build_assign (&gsi, condtemp, memv, false);\n   if (fd->have_reductemp)\n     {\n       gimple *g = gsi_stmt (gsi);\n@@ -3029,6 +3050,35 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n   assign_stmt = gimple_build_assign (startvar, t);\n   gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+  if (cond_var)\n+    {\n+      tree itype = TREE_TYPE (cond_var);\n+      /* For lastprivate(conditional:) itervar, we need some iteration\n+\t counter that starts at unsigned non-zero and increases.\n+\t Prefer as few IVs as possible, so if we can use startvar\n+\t itself, use that, or startvar + constant (those would be\n+\t incremented with step), and as last resort use the s0 + 1\n+\t incremented by 1.  */\n+      if ((fd->ordered && fd->collapse == 1)\n+\t  || bias\n+\t  || POINTER_TYPE_P (type)\n+\t  || TREE_CODE (fd->loop.n1) != INTEGER_CST\n+\t  || fd->loop.cond_code != LT_EXPR)\n+\tt = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, istart0),\n+\t\t\t build_int_cst (itype, 1));\n+      else if (tree_int_cst_sgn (fd->loop.n1) == 1)\n+\tt = fold_convert (itype, t);\n+      else\n+\t{\n+\t  tree c = fold_convert (itype, fd->loop.n1);\n+\t  c = fold_build2 (MINUS_EXPR, itype, build_int_cst (itype, 1), c);\n+\t  t = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, t), c);\n+\t}\n+      t = force_gimple_operand_gsi (&gsi, t, false,\n+\t\t\t\t    NULL_TREE, false, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (cond_var, t);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+    }\n \n   t = iend0;\n   if (fd->ordered && fd->collapse == 1)\n@@ -3213,6 +3263,25 @@ expand_omp_for_generic (struct omp_region *region,\n \t  assign_stmt = gimple_build_assign (vback, t);\n \t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n+\t  if (cond_var)\n+\t    {\n+\t      tree itype = TREE_TYPE (cond_var);\n+\t      tree t2;\n+\t      if ((fd->ordered && fd->collapse == 1)\n+\t\t  || bias\n+\t\t  || POINTER_TYPE_P (type)\n+\t\t  || TREE_CODE (fd->loop.n1) != INTEGER_CST\n+\t\t  || fd->loop.cond_code != LT_EXPR)\n+\t\tt2 = build_int_cst (itype, 1);\n+\t      else\n+\t\tt2 = fold_convert (itype, fd->loop.step);\n+\t      t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n+\t      t2 = force_gimple_operand_gsi (&gsi, t2, false,\n+\t\t\t\t\t     NULL_TREE, true, GSI_SAME_STMT);\n+\t      assign_stmt = gimple_build_assign (cond_var, t2);\n+\t      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t    }\n+\n \t  if (fd->ordered && counts[fd->collapse - 1] == NULL_TREE)\n \t    {\n \t      tree tem;\n@@ -3465,12 +3534,13 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   basic_block entry_bb, second_bb, third_bb, exit_bb, seq_start_bb;\n   basic_block body_bb, cont_bb, collapse_bb = NULL;\n   basic_block fin_bb;\n-  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator gsi, gsip;\n   edge ep;\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n   tree reductions = NULL_TREE;\n+  tree cond_var = NULL_TREE;\n \n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n@@ -3495,6 +3565,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   /* Iteration space partitioning goes in ENTRY_BB.  */\n   gsi = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+  gsip = gsi;\n+  gsi_prev (&gsip);\n \n   if (fd->collapse > 1)\n     {\n@@ -3524,7 +3596,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n       gcond *cond_stmt = gimple_build_cond (fd->loop.cond_code, n1, n2,\n-\t\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t\t\t\t\t    NULL_TREE, NULL_TREE);\n       gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n       if (walk_tree (gimple_cond_lhs_ptr (cond_stmt),\n \t\t     expand_omp_regimplify_p, NULL, NULL)\n@@ -3554,28 +3626,64 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n-  if (fd->have_reductemp)\n+  if (fd->have_reductemp || fd->lastprivate_conditional)\n     {\n       tree t1 = build_int_cst (long_integer_type_node, 0);\n       tree t2 = build_int_cst (long_integer_type_node, 1);\n       tree t3 = build_int_cstu (long_integer_type_node,\n \t\t\t\t(HOST_WIDE_INT_1U << 31) + 1);\n       tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n-      clauses = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n-      reductions = OMP_CLAUSE_DECL (clauses);\n-      gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n-      gimple *g = SSA_NAME_DEF_STMT (reductions);\n-      reductions = gimple_assign_rhs1 (g);\n-      OMP_CLAUSE_DECL (clauses) = reductions;\n-      gimple_stmt_iterator gsi2 = gsi_for_stmt (g);\n+      gimple_stmt_iterator gsi2 = gsi_none ();\n+      gimple *g = NULL;\n+      tree mem = null_pointer_node, memv = NULL_TREE;\n+      tree condtemp = NULL_TREE;\n+      if (fd->have_reductemp)\n+\t{\n+\t  tree c = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+\t  reductions = OMP_CLAUSE_DECL (c);\n+\t  gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+\t  g = SSA_NAME_DEF_STMT (reductions);\n+\t  reductions = gimple_assign_rhs1 (g);\n+\t  OMP_CLAUSE_DECL (c) = reductions;\n+\t  gsi2 = gsi_for_stmt (g);\n+\t}\n+      else\n+\t{\n+\t  if (gsi_end_p (gsip))\n+\t    gsi2 = gsi_after_labels (region->entry);\n+\t  else\n+\t    gsi2 = gsip;\n+\t  reductions = null_pointer_node;\n+\t}\n+      if (fd->lastprivate_conditional)\n+\t{\n+\t  tree c = omp_find_clause (clauses, OMP_CLAUSE__CONDTEMP_);\n+\t  condtemp = OMP_CLAUSE_DECL (c);\n+\t  c = omp_find_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE__CONDTEMP_);\n+\t  cond_var = OMP_CLAUSE_DECL (c);\n+\t  tree type = TREE_TYPE (condtemp);\n+\t  memv = create_tmp_var (type);\n+\t  TREE_ADDRESSABLE (memv) = 1;\n+\t  unsigned HOST_WIDE_INT sz\n+\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t  sz *= fd->lastprivate_conditional;\n+\t  expand_omp_build_assign (&gsi2, memv, build_int_cst (type, sz),\n+\t\t\t\t   false);\n+\t  mem = build_fold_addr_expr (memv);\n+\t}\n       tree t\n \t= build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_LOOP_START),\n \t\t\t   9, t1, t2, t2, t3, t1, null_pointer_node,\n-\t\t\t   null_pointer_node, reductions, null_pointer_node);\n+\t\t\t   null_pointer_node, reductions, mem);\n       force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\ttrue, GSI_SAME_STMT);\n-      gsi_remove (&gsi2, true);\n-      release_ssa_name (gimple_assign_lhs (g));\n+      if (fd->lastprivate_conditional)\n+\texpand_omp_build_assign (&gsi2, condtemp, memv, false);\n+      if (fd->have_reductemp)\n+\t{\n+\t  gsi_remove (&gsi2, true);\n+\t  release_ssa_name (gimple_assign_lhs (g));\n+\t}\n     }\n   switch (gimple_omp_for_kind (fd->for_stmt))\n     {\n@@ -3735,6 +3843,33 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n   assign_stmt = gimple_build_assign (startvar, t);\n   gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+  if (cond_var)\n+    {\n+      tree itype = TREE_TYPE (cond_var);\n+      /* For lastprivate(conditional:) itervar, we need some iteration\n+\t counter that starts at unsigned non-zero and increases.\n+\t Prefer as few IVs as possible, so if we can use startvar\n+\t itself, use that, or startvar + constant (those would be\n+\t incremented with step), and as last resort use the s0 + 1\n+\t incremented by 1.  */\n+      if (POINTER_TYPE_P (type)\n+\t  || TREE_CODE (n1) != INTEGER_CST\n+\t  || fd->loop.cond_code != LT_EXPR)\n+\tt = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, s0),\n+\t\t\t build_int_cst (itype, 1));\n+      else if (tree_int_cst_sgn (n1) == 1)\n+\tt = fold_convert (itype, t);\n+      else\n+\t{\n+\t  tree c = fold_convert (itype, n1);\n+\t  c = fold_build2 (MINUS_EXPR, itype, build_int_cst (itype, 1), c);\n+\t  t = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, t), c);\n+\t}\n+      t = force_gimple_operand_gsi (&gsi, t, false,\n+\t\t\t\t    NULL_TREE, false, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (cond_var, t);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+    }\n \n   t = fold_convert (itype, e0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -3829,6 +3964,23 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t  assign_stmt = gimple_build_assign (vback, t);\n \t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n+\t  if (cond_var)\n+\t    {\n+\t      tree itype = TREE_TYPE (cond_var);\n+\t      tree t2;\n+\t      if (POINTER_TYPE_P (type)\n+\t\t  || TREE_CODE (n1) != INTEGER_CST\n+\t\t  || fd->loop.cond_code != LT_EXPR)\n+\t\tt2 = build_int_cst (itype, 1);\n+\t      else\n+\t\tt2 = fold_convert (itype, step);\n+\t      t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n+\t      t2 = force_gimple_operand_gsi (&gsi, t2, false,\n+\t\t\t\t\t     NULL_TREE, true, GSI_SAME_STMT);\n+\t      assign_stmt = gimple_build_assign (cond_var, t2);\n+\t      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t    }\n+\n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n \t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback)\n \t\t      ? t : vback, e);\n@@ -3847,7 +3999,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      if (fd->have_reductemp)\n+      if (fd->have_reductemp || fd->lastprivate_conditional)\n \t{\n \t  tree fn;\n \t  if (t)\n@@ -3858,9 +4010,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t  if (t)\n \t    {\n \t      gimple_call_set_lhs (g, t);\n-\t      gsi_insert_after (&gsi, gimple_build_assign (reductions,\n-\t\t\t\t\t\t\t   NOP_EXPR, t),\n-\t\t\t\tGSI_SAME_STMT);\n+\t      if (fd->have_reductemp)\n+\t\tgsi_insert_after (&gsi, gimple_build_assign (reductions,\n+\t\t\t\t\t\t\t     NOP_EXPR, t),\n+\t\t\t\t  GSI_SAME_STMT);\n \t    }\n \t  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n \t}\n@@ -3997,12 +4150,13 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   tree type, itype, vmain, vback, vextra;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n   basic_block trip_update_bb = NULL, cont_bb, collapse_bb = NULL, fin_bb;\n-  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator gsi, gsip;\n   edge se;\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n   tree reductions = NULL_TREE;\n+  tree cond_var = NULL_TREE;\n \n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n@@ -4031,6 +4185,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n   gsi = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+  gsip = gsi;\n+  gsi_prev (&gsip);\n \n   if (fd->collapse > 1)\n     {\n@@ -4090,28 +4246,64 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n-  if (fd->have_reductemp)\n+  if (fd->have_reductemp || fd->lastprivate_conditional)\n     {\n       tree t1 = build_int_cst (long_integer_type_node, 0);\n       tree t2 = build_int_cst (long_integer_type_node, 1);\n       tree t3 = build_int_cstu (long_integer_type_node,\n \t\t\t\t(HOST_WIDE_INT_1U << 31) + 1);\n       tree clauses = gimple_omp_for_clauses (fd->for_stmt);\n-      clauses = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n-      reductions = OMP_CLAUSE_DECL (clauses);\n-      gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n-      gimple *g = SSA_NAME_DEF_STMT (reductions);\n-      reductions = gimple_assign_rhs1 (g);\n-      OMP_CLAUSE_DECL (clauses) = reductions;\n-      gimple_stmt_iterator gsi2 = gsi_for_stmt (g);\n+      gimple_stmt_iterator gsi2 = gsi_none ();\n+      gimple *g = NULL;\n+      tree mem = null_pointer_node, memv = NULL_TREE;\n+      tree condtemp = NULL_TREE;\n+      if (fd->have_reductemp)\n+\t{\n+\t  tree c = omp_find_clause (clauses, OMP_CLAUSE__REDUCTEMP_);\n+\t  reductions = OMP_CLAUSE_DECL (c);\n+\t  gcc_assert (TREE_CODE (reductions) == SSA_NAME);\n+\t  g = SSA_NAME_DEF_STMT (reductions);\n+\t  reductions = gimple_assign_rhs1 (g);\n+\t  OMP_CLAUSE_DECL (c) = reductions;\n+\t  gsi2 = gsi_for_stmt (g);\n+\t}\n+      else\n+\t{\n+\t  if (gsi_end_p (gsip))\n+\t    gsi2 = gsi_after_labels (region->entry);\n+\t  else\n+\t    gsi2 = gsip;\n+\t  reductions = null_pointer_node;\n+\t}\n+      if (fd->lastprivate_conditional)\n+\t{\n+\t  tree c = omp_find_clause (clauses, OMP_CLAUSE__CONDTEMP_);\n+\t  condtemp = OMP_CLAUSE_DECL (c);\n+\t  c = omp_find_clause (OMP_CLAUSE_CHAIN (c), OMP_CLAUSE__CONDTEMP_);\n+\t  cond_var = OMP_CLAUSE_DECL (c);\n+\t  tree type = TREE_TYPE (condtemp);\n+\t  memv = create_tmp_var (type);\n+\t  TREE_ADDRESSABLE (memv) = 1;\n+\t  unsigned HOST_WIDE_INT sz\n+\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t  sz *= fd->lastprivate_conditional;\n+\t  expand_omp_build_assign (&gsi2, memv, build_int_cst (type, sz),\n+\t\t\t\t   false);\n+\t  mem = build_fold_addr_expr (memv);\n+\t}\n       tree t\n \t= build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_LOOP_START),\n \t\t\t   9, t1, t2, t2, t3, t1, null_pointer_node,\n-\t\t\t   null_pointer_node, reductions, null_pointer_node);\n+\t\t\t   null_pointer_node, reductions, mem);\n       force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n \t\t\t\ttrue, GSI_SAME_STMT);\n-      gsi_remove (&gsi2, true);\n-      release_ssa_name (gimple_assign_lhs (g));\n+      if (fd->lastprivate_conditional)\n+\texpand_omp_build_assign (&gsi2, condtemp, memv, false);\n+      if (fd->have_reductemp)\n+\t{\n+\t  gsi_remove (&gsi2, true);\n+\t  release_ssa_name (gimple_assign_lhs (g));\n+\t}\n     }\n   switch (gimple_omp_for_kind (fd->for_stmt))\n     {\n@@ -4286,6 +4478,33 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n   assign_stmt = gimple_build_assign (startvar, t);\n   gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+  if (cond_var)\n+    {\n+      tree itype = TREE_TYPE (cond_var);\n+      /* For lastprivate(conditional:) itervar, we need some iteration\n+\t counter that starts at unsigned non-zero and increases.\n+\t Prefer as few IVs as possible, so if we can use startvar\n+\t itself, use that, or startvar + constant (those would be\n+\t incremented with step), and as last resort use the s0 + 1\n+\t incremented by 1.  */\n+      if (POINTER_TYPE_P (type)\n+\t  || TREE_CODE (n1) != INTEGER_CST\n+\t  || fd->loop.cond_code != LT_EXPR)\n+\tt = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, s0),\n+\t\t\t build_int_cst (itype, 1));\n+      else if (tree_int_cst_sgn (n1) == 1)\n+\tt = fold_convert (itype, t);\n+      else\n+\t{\n+\t  tree c = fold_convert (itype, n1);\n+\t  c = fold_build2 (MINUS_EXPR, itype, build_int_cst (itype, 1), c);\n+\t  t = fold_build2 (PLUS_EXPR, itype, fold_convert (itype, t), c);\n+\t}\n+      t = force_gimple_operand_gsi (&gsi, t, false,\n+\t\t\t\t    NULL_TREE, false, GSI_CONTINUE_LINKING);\n+      assign_stmt = gimple_build_assign (cond_var, t);\n+      gsi_insert_after (&gsi, assign_stmt, GSI_CONTINUE_LINKING);\n+    }\n \n   t = fold_convert (itype, e0);\n   t = fold_build2 (MULT_EXPR, itype, t, step);\n@@ -4416,7 +4635,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      if (fd->have_reductemp)\n+      if (fd->have_reductemp || fd->lastprivate_conditional)\n \t{\n \t  tree fn;\n \t  if (t)\n@@ -4427,9 +4646,10 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t  if (t)\n \t    {\n \t      gimple_call_set_lhs (g, t);\n-\t      gsi_insert_after (&gsi, gimple_build_assign (reductions,\n-\t\t\t\t\t\t\t   NOP_EXPR, t),\n-\t\t\t\tGSI_SAME_STMT);\n+\t      if (fd->have_reductemp)\n+\t\tgsi_insert_after (&gsi, gimple_build_assign (reductions,\n+\t\t\t\t\t\t\t     NOP_EXPR, t),\n+\t\t\t\t  GSI_SAME_STMT);\n \t    }\n \t  gsi_insert_after (&gsi, g, GSI_SAME_STMT);\n \t}\n@@ -6043,7 +6263,7 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n       else\n \tstart_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_START) + fn_index;\n       next_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_NEXT) + fn_index;\n-      if (fd.have_reductemp)\n+      if (fd.have_reductemp || fd.lastprivate_conditional)\n \t{\n \t  if (fd.ordered)\n \t    start_ix = (int)BUILT_IN_GOMP_LOOP_DOACROSS_START;"}, {"sha": "baab7619135004dcecc025cb41cbba9e1e6bc9ba", "filename": "gcc/omp-general.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -168,6 +168,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->have_nowait = distribute || simd;\n   fd->have_ordered = false;\n   fd->have_reductemp = false;\n+  fd->lastprivate_conditional = 0;\n   fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n   fd->ordered = 0;\n@@ -220,6 +221,11 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \tbreak;\n       case OMP_CLAUSE__REDUCTEMP_:\n \tfd->have_reductemp = true;\n+\tbreak;\n+      case OMP_CLAUSE_LASTPRIVATE:\n+\tif (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (t))\n+\t  fd->lastprivate_conditional++;\n+\tbreak;\n       default:\n \tbreak;\n       }"}, {"sha": "b89c13170a2c8729c2f51d117f9874b6a04e872d", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -63,6 +63,7 @@ struct omp_for_data\n   int collapse;  /* Collapsed loops, 1 for a non-collapsed loop.  */\n   int ordered;\n   bool have_nowait, have_ordered, simd_schedule, have_reductemp;\n+  int lastprivate_conditional;\n   unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;\n   struct omp_for_data_loop *loops;"}, {"sha": "faab5d3842800bafc9dab04f4d8154f9ba127f49", "filename": "gcc/omp-low.c", "status": "modified", "additions": 167, "deletions": 21, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -119,10 +119,14 @@ struct omp_context\n      and then offsets (if constant, otherwise NULL) for each entry.  */\n   vec<tree> task_reductions;\n \n-  /* And a hash map from the reduction clauses to the registered array\n+  /* A hash map from the reduction clauses to the registered array\n      elts.  */\n   hash_map<tree, unsigned> *task_reduction_map;\n \n+  /* And a hash map from the lastprivate(conditional:) variables to their\n+     corresponding tracking loop iteration variables.  */\n+  hash_map<tree, tree> *lastprivate_conditional_map;\n+\n   /* Nesting depth of this context.  Used to beautify error messages re\n      invalid gotos.  The outermost ctx is depth 1, with depth 0 being\n      reserved for the main body of the function.  */\n@@ -955,6 +959,8 @@ delete_omp_context (splay_tree_value value)\n       delete ctx->task_reduction_map;\n     }\n \n+  delete ctx->lastprivate_conditional_map;\n+\n   XDELETE (ctx);\n }\n \n@@ -5358,18 +5364,72 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n     }\n }\n \n+/* Create temporary variables for lastprivate(conditional:) implementation\n+   in context CTX with CLAUSES.  */\n+\n+static void\n+lower_lastprivate_conditional_clauses (tree *clauses, omp_context *ctx)\n+{\n+  struct omp_for_data fd;\n+  tree iter_type = NULL_TREE;\n+  tree cond_ptr = NULL_TREE;\n+  tree iter_var = NULL_TREE;\n+  for (tree c = *clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t&& OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+      {\n+\tif (iter_type == NULL)\n+\t  {\n+\t    omp_extract_for_data (as_a <gomp_for *> (ctx->stmt), &fd, NULL);\n+\t    iter_type = unsigned_type_for (fd.iter_type);\n+\t    cond_ptr = create_tmp_var_raw (build_pointer_type (iter_type));\n+\t    DECL_CONTEXT (cond_ptr) = current_function_decl;\n+\t    DECL_SEEN_IN_BIND_EXPR_P (cond_ptr) = 1;\n+\t    DECL_CHAIN (cond_ptr) = ctx->block_vars;\n+\t    ctx->block_vars = cond_ptr;\n+\t    iter_var = create_tmp_var_raw (iter_type);\n+\t    DECL_CONTEXT (iter_var) = current_function_decl;\n+\t    DECL_SEEN_IN_BIND_EXPR_P (iter_var) = 1;\n+\t    DECL_CHAIN (iter_var) = ctx->block_vars;\n+\t    ctx->block_vars = iter_var;\n+\t    tree c2\n+\t      = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__CONDTEMP_);\n+\t    tree c3\n+\t      = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__CONDTEMP_);\n+\t    OMP_CLAUSE_DECL (c2) = cond_ptr;\n+\t    OMP_CLAUSE_DECL (c3) = iter_var;\n+\t    OMP_CLAUSE_CHAIN (c2) = c3;\n+\t    OMP_CLAUSE_CHAIN (c3) = *clauses;\n+\t    *clauses = c2;\n+\t    ctx->lastprivate_conditional_map = new hash_map<tree, tree>;\n+\t  }\n+\ttree v = create_tmp_var_raw (iter_type);\n+\tDECL_CONTEXT (v) = current_function_decl;\n+\tDECL_SEEN_IN_BIND_EXPR_P (v) = 1;\n+\tDECL_CHAIN (v) = ctx->block_vars;\n+\tctx->block_vars = v;\n+\ttree o = lookup_decl (OMP_CLAUSE_DECL (c), ctx);\n+\tctx->lastprivate_conditional_map->put (o, v);\n+      }\n+}\n+\n \n /* Generate code to implement the LASTPRIVATE clauses.  This is used for\n    both parallel and workshare constructs.  PREDICATE may be NULL if it's\n-   always true.   */\n+   always true.  BODY_P is the sequence to insert early initialization\n+   if needed, STMT_LIST is where the non-conditional lastprivate handling\n+   goes into and CSTMT_LIST is a sequence that needs to be run in a critical\n+   section.  */\n \n static void\n-lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n+lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n+\t\t\t   gimple_seq *stmt_list, gimple_seq *cstmt_list,\n \t\t\t   omp_context *ctx)\n {\n   tree x, c, label = NULL, orig_clauses = clauses;\n   bool par_clauses = false;\n   tree simduid = NULL, lastlane = NULL, simtcond = NULL, simtlast = NULL;\n+  unsigned HOST_WIDE_INT conditional_off = 0;\n \n   /* Early exit if there are no lastprivate or linear clauses.  */\n   for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n@@ -5448,10 +5508,43 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n       gimple_seq_add_stmt (stmt_list, gimple_build_label (label_true));\n     }\n \n+  tree cond_ptr = NULL_TREE;\n   for (c = clauses; c ;)\n     {\n       tree var, new_var;\n       location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n+      gimple_seq *this_stmt_list = stmt_list;\n+      tree lab2 = NULL_TREE;\n+\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t  && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t{\n+\t  gcc_assert (body_p && ctx->lastprivate_conditional_map);\n+\t  if (cond_ptr == NULL_TREE)\n+\t    {\n+\t      cond_ptr = omp_find_clause (orig_clauses, OMP_CLAUSE__CONDTEMP_);\n+\t      cond_ptr = OMP_CLAUSE_DECL (cond_ptr);\n+\t    }\n+\t  tree type = TREE_TYPE (TREE_TYPE (cond_ptr));\n+\t  tree o = lookup_decl (OMP_CLAUSE_DECL (c), ctx);\n+\t  tree v = *ctx->lastprivate_conditional_map->get (o);\n+\t  gimplify_assign (v, build_zero_cst (type), body_p);\n+\t  this_stmt_list = cstmt_list;\n+\t  tree mem = build2 (MEM_REF, type, cond_ptr,\n+\t\t\t     build_int_cst (TREE_TYPE (cond_ptr),\n+\t\t\t\t\t    conditional_off));\n+\t  tree mem2 = copy_node (mem);\n+\t  conditional_off += tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+\t  gimple_seq seq = NULL;\n+\t  mem = force_gimple_operand (mem, &seq, true, NULL_TREE);\n+\t  gimple_seq_add_seq (this_stmt_list, seq);\n+\t  tree lab1 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  lab2 = create_artificial_label (UNKNOWN_LOCATION);\n+\t  gimple *g = gimple_build_cond (GT_EXPR, v, mem, lab1, lab2);\n+\t  gimple_seq_add_stmt (this_stmt_list, g);\n+\t  gimple_seq_add_stmt (this_stmt_list, gimple_build_label (lab1));\n+\t  gimplify_assign (mem2, v, this_stmt_list);\n+\t}\n \n       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t  || (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n@@ -5493,7 +5586,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t\t\t\t\t      2, simduid,\n \t\t\t\t\t\t      TREE_OPERAND (val, 1));\n \t\t      gimple_call_set_lhs (g, lastlane);\n-\t\t      gimple_seq_add_stmt (stmt_list, g);\n+\t\t      gimple_seq_add_stmt (this_stmt_list, g);\n \t\t    }\n \t\t  new_var = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t    TREE_OPERAND (val, 0), lastlane,\n@@ -5511,29 +5604,29 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t  gcall *g = gimple_build_call_internal\n \t\t    (IFN_GOMP_SIMT_LAST_LANE, 1, simtcond);\n \t\t  gimple_call_set_lhs (g, simtlast);\n-\t\t  gimple_seq_add_stmt (stmt_list, g);\n+\t\t  gimple_seq_add_stmt (this_stmt_list, g);\n \t\t}\n \t      x = build_call_expr_internal_loc\n \t\t(UNKNOWN_LOCATION, IFN_GOMP_SIMT_XCHG_IDX,\n \t\t TREE_TYPE (val), 2, val, simtlast);\n \t      new_var = unshare_expr (new_var);\n-\t      gimplify_assign (new_var, x, stmt_list);\n+\t      gimplify_assign (new_var, x, this_stmt_list);\n \t      new_var = unshare_expr (new_var);\n \t    }\n \n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t      && OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c))\n \t    {\n \t      lower_omp (&OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c), ctx);\n-\t      gimple_seq_add_seq (stmt_list,\n+\t      gimple_seq_add_seq (this_stmt_list,\n \t\t\t\t  OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c));\n \t      OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c) = NULL;\n \t    }\n \t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n \t\t   && OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c))\n \t    {\n \t      lower_omp (&OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c), ctx);\n-\t      gimple_seq_add_seq (stmt_list,\n+\t      gimple_seq_add_seq (this_stmt_list,\n \t\t\t\t  OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c));\n \t      OMP_CLAUSE_LINEAR_GIMPLE_SEQ (c) = NULL;\n \t    }\n@@ -5553,8 +5646,12 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t  if (omp_is_reference (var))\n \t    new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t  x = lang_hooks.decls.omp_clause_assign_op (c, x, new_var);\n-\t  gimplify_and_add (x, stmt_list);\n+\t  gimplify_and_add (x, this_stmt_list);\n+\n+\t  if (lab2)\n+\t    gimple_seq_add_stmt (this_stmt_list, gimple_build_label (lab2));\n \t}\n+\n       c = OMP_CLAUSE_CHAIN (c);\n       if (c == NULL && !par_clauses)\n \t{\n@@ -5802,10 +5899,15 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n   gimple_seq_add_seq (join_seq, after_join);\n }\n \n-/* Generate code to implement the REDUCTION clauses.  */\n+/* Generate code to implement the REDUCTION clauses, append it\n+   to STMT_SEQP.  CLIST if non-NULL is a pointer to a sequence\n+   that should be emitted also inside of the critical section,\n+   in that case clear *CLIST afterwards, otherwise leave it as is\n+   and let the caller emit it itself.  */\n \n static void\n-lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n+lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp,\n+\t\t\t gimple_seq *clist, omp_context *ctx)\n {\n   gimple_seq sub_seq = NULL;\n   gimple *stmt;\n@@ -6047,6 +6149,12 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \n   gimple_seq_add_seq (stmt_seqp, sub_seq);\n \n+  if (clist)\n+    {\n+      gimple_seq_add_seq (stmt_seqp, *clist);\n+      *clist = NULL;\n+    }\n+\n   stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END),\n \t\t\t    0);\n   gimple_seq_add_stmt (stmt_seqp, stmt);\n@@ -6684,7 +6792,7 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t{\n \t  gimple_seq l = NULL;\n \t  lower_lastprivate_clauses (gimple_omp_sections_clauses (stmt), NULL,\n-\t\t\t\t     &l, ctx);\n+\t\t\t\t     NULL, &l, NULL, ctx);\n \t  gsi_insert_seq_after (&tgsi, l, GSI_CONTINUE_LINKING);\n \t  gimple_omp_section_set_last (sec_start);\n \t}\n@@ -6697,7 +6805,8 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   bind = gimple_build_bind (NULL, new_body, block);\n \n   olist = NULL;\n-  lower_reduction_clauses (gimple_omp_sections_clauses (stmt), &olist, ctx);\n+  lower_reduction_clauses (gimple_omp_sections_clauses (stmt), &olist,\n+\t\t\t   NULL, ctx);\n \n   block = make_node (BLOCK);\n   new_stmt = gimple_build_bind (NULL, NULL, block);\n@@ -8074,11 +8183,13 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n    for a lastprivate clause.  Given a loop control predicate of (V\n    cond N2), we gate the clause on (!(V cond N2)).  The lowered form\n    is appended to *DLIST, iterator initialization is appended to\n-   *BODY_P.  */\n+   *BODY_P.  *CLIST is for lastprivate(conditional:) code that needs\n+   to be emitted in a critical section.  */\n \n static void\n lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n-\t\t\t   gimple_seq *dlist, struct omp_context *ctx)\n+\t\t\t   gimple_seq *dlist, gimple_seq *clist,\n+\t\t\t   struct omp_context *ctx)\n {\n   tree clauses, cond, vinit;\n   enum tree_code cond_code;\n@@ -8158,7 +8269,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \n   clauses = gimple_omp_for_clauses (fd->for_stmt);\n   stmts = NULL;\n-  lower_lastprivate_clauses (clauses, cond, &stmts, ctx);\n+  lower_lastprivate_clauses (clauses, cond, body_p, &stmts, clist, ctx);\n   if (!gimple_seq_empty_p (stmts))\n     {\n       gimple_seq_add_seq (&stmts, *dlist);\n@@ -8190,7 +8301,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gomp_for *stmt = as_a <gomp_for *> (gsi_stmt (*gsi_p));\n   gbind *new_stmt;\n   gimple_seq omp_for_body, body, dlist, tred_ilist = NULL, tred_dlist = NULL;\n-  gimple_seq cnt_list = NULL;\n+  gimple_seq cnt_list = NULL, clist = NULL;\n   gimple_seq oacc_head = NULL, oacc_tail = NULL;\n   size_t i;\n \n@@ -8308,6 +8419,9 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_seq_add_seq (rclauses ? &tred_ilist : &body,\n \t\t      gimple_omp_for_pre_body (stmt));\n \n+  lower_lastprivate_conditional_clauses (gimple_omp_for_clauses_ptr (stmt),\n+\t\t\t\t\t ctx);\n+\n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n   /* Lower the header expressions.  At this point, we can assume that\n@@ -8353,7 +8467,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   if (oacc_head)\n     gimple_seq_add_seq (&body, oacc_head);\n \n-  lower_omp_for_lastprivate (&fd, &body, &dlist, ctx);\n+  lower_omp_for_lastprivate (&fd, &body, &dlist, &clist, ctx);\n \n   if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR)\n     for (tree c = gimple_omp_for_clauses (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n@@ -8378,7 +8492,18 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t\t\t\t   fd.loop.v));\n \n   /* After the loop, add exit clauses.  */\n-  lower_reduction_clauses (gimple_omp_for_clauses (stmt), &body, ctx);\n+  lower_reduction_clauses (gimple_omp_for_clauses (stmt), &body, &clist, ctx);\n+\n+  if (clist)\n+    {\n+      tree fndecl = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START);\n+      gcall *g = gimple_build_call (fndecl, 0);\n+      gimple_seq_add_stmt (&body, g);\n+      gimple_seq_add_seq (&body, clist);\n+      fndecl = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END);\n+      g = gimple_build_call (fndecl, 0);\n+      gimple_seq_add_stmt (&body, g);\n+    }\n \n   if (ctx->cancellable)\n     gimple_seq_add_stmt (&body, gimple_build_label (ctx->cancel_label));\n@@ -9000,7 +9125,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx, NULL);\n   lower_omp (&par_body, ctx);\n   if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL)\n-    lower_reduction_clauses (clauses, &par_rlist, ctx);\n+    lower_reduction_clauses (clauses, &par_rlist, NULL, ctx);\n \n   /* Declare all the variables created by mapping and the variables\n      declared in the scope of the parallel body.  */\n@@ -10189,7 +10314,8 @@ lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   lower_rec_input_clauses (gimple_omp_teams_clauses (teams_stmt),\n \t\t\t   &bind_body, &dlist, ctx, NULL);\n   lower_omp (gimple_omp_body_ptr (teams_stmt), ctx);\n-  lower_reduction_clauses (gimple_omp_teams_clauses (teams_stmt), &olist, ctx);\n+  lower_reduction_clauses (gimple_omp_teams_clauses (teams_stmt), &olist,\n+\t\t\t   NULL, ctx);\n   if (!gimple_omp_teams_grid_phony (teams_stmt))\n     {\n       gimple_seq_add_stmt (&bind_body, teams_stmt);\n@@ -10498,8 +10624,28 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  default:\n \t    break;\n \t  }\n+      goto regimplify;\n+\n+    case GIMPLE_ASSIGN:\n+      if (ctx && ctx->lastprivate_conditional_map)\n+\t{\n+\t  tree lhs = get_base_address (gimple_assign_lhs (stmt));\n+\t  if (DECL_P (lhs))\n+\t    if (tree *v = ctx->lastprivate_conditional_map->get (lhs))\n+\t      {\n+\t\ttree clauses\n+\t\t  = gimple_omp_for_clauses (as_a <gomp_for *> (ctx->stmt));\n+\t\ttree c = omp_find_clause (clauses, OMP_CLAUSE__CONDTEMP_);\n+\t\tc = omp_find_clause (OMP_CLAUSE_CHAIN (c),\n+\t\t\t\t     OMP_CLAUSE__CONDTEMP_);\n+\t\tgimple *g = gimple_build_assign (*v, OMP_CLAUSE_DECL (c));\n+\t\tgsi_insert_after (gsi_p, g, GSI_SAME_STMT);\n+\t      }\n+\t}\n       /* FALLTHRU */\n+\n     default:\n+    regimplify:\n       if ((ctx || task_shared_vars)\n \t  && walk_gimple_op (stmt, lower_omp_regimplify_p,\n \t\t\t     ctx ? NULL : &wi))"}, {"sha": "a0cff00b6210f49d2e57fefda0f2a1ebf9fd4ead", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -1,3 +1,9 @@\n+2019-05-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n+\tsorry for omp for.\n+\t* c-c++-common/gomp/lastprivate-conditional-3.c: New test.\n+\n 2019-05-24  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/90607"}, {"sha": "34c7e12287b4ec64df83d789b40e0317216a9831", "filename": "gcc/testsuite/c-c++-common/gomp/lastprivate-conditional-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -4,7 +4,7 @@ foo (int *p)\n   int a = -1, b = -1, c = -1, d = -1, e = -1, f = -1, g = -1, h = -1;\n   int i;\n   #pragma omp parallel\n-  #pragma omp for lastprivate (conditional: a) /* { dg-message \"not supported yet\" } */\n+  #pragma omp for lastprivate (conditional: a)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       a = i;"}, {"sha": "bf413ec8d9b4f0cfa51be5b4e474dcabdb697750", "filename": "gcc/testsuite/c-c++-common/gomp/lastprivate-conditional-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-3.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -0,0 +1,26 @@\n+void\n+foo (int *p)\n+{\n+  int i, j, k;\n+  #pragma omp parallel\n+  {\n+    #pragma omp for lastprivate (conditional: i)\t/* { dg-warning \"conditional 'lastprivate' on loop iterator 'i' ignored\" } */\n+    for (i = 0; i < 32; i++)\n+      ;\n+    #pragma omp for collapse (3) lastprivate (conditional: i)\t/* { dg-warning \"conditional 'lastprivate' on loop iterator 'i' ignored\" } */\n+    for (i = 0; i < 32; i++)\n+      for (j = 0; j < 32; ++j)\n+\tfor (k = 0; k < 2; ++k)\n+\t  ;\n+    #pragma omp for collapse (3) lastprivate (conditional: j)\t/* { dg-warning \"conditional 'lastprivate' on loop iterator 'j' ignored\" } */\n+    for (i = 0; i < 32; i++)\n+      for (j = 0; j < 32; ++j)\n+\tfor (k = 0; k < 2; ++k)\n+\t  ;\n+    #pragma omp for collapse (3) lastprivate (conditional: k)\t/* { dg-warning \"conditional 'lastprivate' on loop iterator 'k' ignored\" } */\n+    for (i = 0; i < 32; i++)\n+      for (j = 0; j < 32; ++j)\n+\tfor (k = 0; k < 2; ++k)\n+\t  ;\n+  }\n+}"}, {"sha": "26cfa7ea19f1d1bc03c12924e5cdced1a4eec182", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -343,6 +343,9 @@ enum omp_clause_code {\n   /* Internal clause: temporary for task reductions.  */\n   OMP_CLAUSE__REDUCTEMP_,\n \n+  /* Internal clause: temporary for lastprivate(conditional:).  */\n+  OMP_CLAUSE__CONDTEMP_,\n+\n   /* OpenACC/OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n "}, {"sha": "cdffb2e14951f9e72d64919b7380563608a812e7", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -1369,6 +1369,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t     function decomposition happens before that.  */\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n+\tcase OMP_CLAUSE__CONDTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:\n@@ -2096,6 +2097,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t     function decomposition happens before that.  */\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n+\tcase OMP_CLAUSE__CONDTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \tcase OMP_CLAUSE__GRIDDIM_:\n \tcase OMP_CLAUSE__SIMT_:"}, {"sha": "4ba9170ddd32e7b8cdd1243eb9b0ac5ef209343b", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -466,6 +466,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n     case OMP_CLAUSE__REDUCTEMP_:\n       name = \"_reductemp_\";\n       goto print_remap;\n+    case OMP_CLAUSE__CONDTEMP_:\n+      name = \"_condtemp_\";\n+      goto print_remap;\n     case OMP_CLAUSE_TO_DECLARE:\n       name = \"to\";\n       goto print_remap;"}, {"sha": "9a8f5e567429d065629fbe3a16c0dbd23120bba2", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -308,6 +308,7 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_SEQ  */\n   1, /* OMP_CLAUSE__LOOPTEMP_  */\n   1, /* OMP_CLAUSE__REDUCTEMP_  */\n+  1, /* OMP_CLAUSE__CONDTEMP_  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n@@ -385,6 +386,7 @@ const char * const omp_clause_code_name[] =\n   \"seq\",\n   \"_looptemp_\",\n   \"_reductemp_\",\n+  \"_condtemp_\",\n   \"if\",\n   \"num_threads\",\n   \"schedule\",\n@@ -12304,6 +12306,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE__LOOPTEMP_:\n \tcase OMP_CLAUSE__REDUCTEMP_:\n+\tcase OMP_CLAUSE__CONDTEMP_:\n \tcase OMP_CLAUSE__SIMDUID_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */"}, {"sha": "72544b63d79c16402c440e645900c85094b2b5bd", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -1439,7 +1439,7 @@ class auto_suppress_location_wrappers\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n-\t\t\t\t\t      OMP_CLAUSE__REDUCTEMP_), 0)\n+\t\t\t\t\t      OMP_CLAUSE__CONDTEMP_), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)\t\t\\\n   != UNKNOWN_LOCATION)"}, {"sha": "f88e06abf68c1d6472e7d0e1785c9a9dc89bb5b3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -1,5 +1,8 @@\n 2019-05-24  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c: New test.\n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c: New test.\n+\n \tPR libgomp/90585\n \t* plugin/plugin-hsa.c: Include gstdint.h.  Include inttypes.h only if\n \tHAVE_INTTYPES_H is defined."}, {"sha": "a7e9f90c5a89dca192452216c671c742054c1728", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-1.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-1.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -0,0 +1,144 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target tls_runtime } */\n+/* { dg-additional-options \"-std=gnu99\" {target c } } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int r, s, u, v, r2, s2, u2, v2, r3, s3, u3, v3;\n+long long w, w2, w3, p, p2, p3;\n+int *x, *x2, *x3;\n+short y, y2, y3;\n+int z;\n+int thr1, thr2;\n+#pragma omp threadprivate (thr1, thr2)\n+\n+void\n+foo (int *a, long long int b, long long int c)\n+{\n+  int i;\n+  long long j;\n+  #pragma omp for lastprivate (conditional: u, x) nowait\n+  for (i = 15; i < 64; i++)\n+    {\n+      if ((a[i] % 5) == 3)\n+\tu = i;\n+      if ((a[i] % 7) == 2)\n+\tx = &a[i];\n+    }\n+  #pragma omp for nowait lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s;\n+      if ((a[i + 4] % 11) == 9)\n+\tv = i;\n+      else\n+\t++r;\n+    }\n+  #pragma omp for schedule (monotonic: static) lastprivate (conditional: w) nowait\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    if ((a[j] % 13) == 5)\n+      w = j * 2;\n+  #pragma omp for schedule (auto) lastprivate (conditional: p) collapse(3)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t  p = i * 10000 + j * 100 + k;\n+\n+  #pragma omp for schedule (nonmonotonic: static, 2) nowait lastprivate (conditional: u2, x2)\n+  for (i = 15; i < 64; i++)\n+    {\n+      if ((a[i] % 5) == 3)\n+\tu2 = i;\n+      if ((a[i] % 7) == 2)\n+\tx2 = &a[i];\n+    }\n+  #pragma omp for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s2;\n+      if ((a[i + 4] % 11) == 9)\n+\tv2 = i;\n+      else\n+\t++r2;\n+    }\n+  #pragma omp for lastprivate (conditional: w2) schedule (static, 1) nowait\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    if ((a[j] % 13) == 5)\n+      w2 = j * 2;\n+  #pragma omp for schedule (static, 3) collapse (3) lastprivate (conditional: p2)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t  p2 = i * 10000 + j * 100 + k;\n+\n+  #pragma omp for lastprivate (conditional: u3, x3) nowait schedule (runtime)\n+  for (i = 15; i < 64; i++)\n+    {\n+      if ((a[i] % 5) == 3)\n+\tu3 = i;\n+      if ((a[i] % 7) == 2)\n+\tx3 = &a[i];\n+    }\n+  #pragma omp for nowait lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s3;\n+      if ((a[i + 4] % 11) == 9)\n+\tv3 = i;\n+      else\n+\t++r3;\n+    }\n+  #pragma omp for schedule (monotonic: guided, 3) lastprivate (conditional: w3) nowait\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    if ((a[j] % 13) == 5)\n+      w3 = j * 2;\n+  #pragma omp for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\tif (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t  p3 = i * 10000 + j * 100 + k;\n+\n+  /* Nasty testcase, verify that even a no-op assignment is accounted\n+     for in lastprivate(conditional:).  */\n+  #pragma omp for schedule (monotonic: static, 2) firstprivate (z) \\\n+\t\t  lastprivate (conditional: z)\n+  for (int k = -2000; k < 8000; ++k)\n+    {\n+      if (k < 3000 && (k & 3) == 1)\n+\t{\n+\t  z = k;\n+\t  thr1 = k;\n+\t}\n+      else if (k == 7931)\n+\t{\n+\t  z = z;\n+\t  thr2 = 1;\n+\t}\n+    }\n+\n+  if (thr2 && z != thr1)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], i;\n+  volatile int j = 0;\n+  for (i = 0; i < 128; i++)\n+    a[i] = i;\n+  w = 1234;\n+  #pragma omp parallel\n+  foo (a, j, j + 1);\n+  if (u != 63 || v != 115 || w != 140 || x != &a[58] || r != 55 || s != 61 || p != 30104)\n+    abort ();\n+  if (u2 != 63 || v2 != 115 || w2 != 140 || x2 != &a[58] || r2 != 55 || s2 != 61 || p2 != 30104)\n+    abort ();\n+  if (u3 != 63 || v3 != 115 || w3 != 140 || x3 != &a[58] || r3 != 55 || s3 != 61 || p3 != 30104)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "f252206f5b372edb11d5a54c9ce3a66ae9466259", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-2.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7ae8c56f9341f180e097d5eb7ba05cb8eec413/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-2.c?ref=6c7ae8c56f9341f180e097d5eb7ba05cb8eec413", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target tls_runtime } */\n+/* { dg-additional-options \"-std=gnu99\" {target c } } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int r, s, u, v, r2, s2, u2, v2, r3, s3, u3, v3, t;\n+long long w, w2, w3, p, p2, p3;\n+int *x, *x2, *x3;\n+short y, y2, y3;\n+int z;\n+int thr1, thr2;\n+#pragma omp threadprivate (thr1, thr2)\n+\n+void\n+foo (int *a, long long int b, long long int c)\n+{\n+  int i;\n+  long long j;\n+  #pragma omp for lastprivate (conditional: u, x) reduction (task, +: t)\n+  for (i = 15; i < 64; i++)\n+    {\n+      ++t;\n+      if ((a[i] % 5) == 3)\n+\tu = i;\n+      if ((a[i] % 7) == 2)\n+\tx = &a[i];\n+    }\n+  #pragma omp for lastprivate (conditional: v) reduction (+:r, s) schedule (nonmonotonic: static) reduction (task, +: t)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s;\n+      ++t;\n+      if ((a[i + 4] % 11) == 9)\n+\tv = i;\n+      else\n+\t++r;\n+    }\n+  #pragma omp for schedule (monotonic: static) lastprivate (conditional: w) reduction (task, +: t)\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    {\n+      if ((a[j] % 13) == 5)\n+\tw = j * 2;\n+      ++t;\n+    }\n+  #pragma omp for schedule (auto) lastprivate (conditional: p) collapse(3) reduction (task, +: t)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\t{\n+\t  ++t;\n+\t  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t    p = i * 10000 + j * 100 + k;\n+\t}\n+\n+  #pragma omp for schedule (nonmonotonic: static, 2)  reduction (task, +: t) lastprivate (conditional: u2, x2)\n+  for (i = 15; i < 64; i++)\n+    {\n+      if ((a[i] % 5) == 3)\n+\tu2 = i;\n+      if ((a[i] % 7) == 2)\n+\tx2 = &a[i];\n+      t++;\n+    }\n+  #pragma omp for schedule (static, 3) lastprivate (conditional: v2) reduction (+:r2, s2) reduction (task, +: t)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s2;\n+      if ((a[i + 4] % 11) == 9)\n+\tv2 = i;\n+      else\n+\t++r2;\n+      t++;\n+    }\n+  #pragma omp for lastprivate (conditional: w2) schedule (static, 1) reduction (task, +: t)\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    {\n+      if ((a[j] % 13) == 5)\n+\tw2 = j * 2;\n+      t += 1;\n+    }\n+  #pragma omp for schedule (static, 3) collapse (3) reduction (task, +: t) lastprivate (conditional: p2)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\t{\n+\t  ++t;\n+\t  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t    p2 = i * 10000 + j * 100 + k;\n+\t}\n+\n+  #pragma omp for lastprivate (conditional: u3, x3) reduction (task, +: t) schedule (runtime)\n+  for (i = 15; i < 64; i++)\n+    {\n+      t = t + 1;\n+      if ((a[i] % 5) == 3)\n+\tu3 = i;\n+      if ((a[i] % 7) == 2)\n+\tx3 = &a[i];\n+    }\n+  #pragma omp for reduction (task, +: t) lastprivate (conditional: v3) reduction (+:r3, s3) schedule (nonmonotonic: dynamic)\n+  for (i = -3; i < 119; i += 2)\n+    {\n+      ++s3;\n+      if ((a[i + 4] % 11) == 9)\n+\tv3 = i;\n+      else\n+\t++r3;\n+      ++t;\n+    }\n+  #pragma omp for schedule (monotonic: guided, 3) lastprivate (conditional: w3) reduction (task, +: t)\n+  for (j = b; j < b + 115 * c; j += (b & 3) + 7)\n+    {\n+      if ((a[j] % 13) == 5)\n+\tw3 = j * 2;\n+      t++;\n+    }\n+  #pragma omp for schedule (dynamic, 4) lastprivate (conditional: p3) collapse(3) reduction (task, +: t)\n+  for (i = -5; i < (int) (b + 5); i += 2)\n+    for (j = b + 12 + c; j > b; --j)\n+      for (int k = 0; k < 5; k += c)\n+\t{\n+\t  ++t;\n+\t  if (((((i + 5) * 13 + (13 - j)) * 5 + k) % 17) == 6)\n+\t    p3 = i * 10000 + j * 100 + k;\n+\t}\n+\n+  /* Nasty testcase, verify that even a no-op assignment is accounted\n+     for in lastprivate(conditional:).  */\n+  #pragma omp for schedule (monotonic: static, 2) firstprivate (z) \\\n+\t\t  lastprivate (conditional: z) reduction (task, +: t)\n+  for (int k = -2000; k < 8000; ++k)\n+    {\n+      t++;\n+      if (k < 3000 && (k & 3) == 1)\n+\t{\n+\t  z = k;\n+\t  thr1 = k;\n+\t}\n+      else if (k == 7931)\n+\t{\n+\t  z = z;\n+\t  thr2 = 1;\n+\t}\n+    }\n+\n+  if (thr2 && z != thr1)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], i;\n+  volatile int j = 0;\n+  for (i = 0; i < 128; i++)\n+    a[i] = i;\n+  w = 1234;\n+  #pragma omp parallel\n+  foo (a, j, j + 1);\n+  if (u != 63 || v != 115 || w != 140 || x != &a[58] || r != 55 || s != 61 || p != 30104)\n+    abort ();\n+  if (u2 != 63 || v2 != 115 || w2 != 140 || x2 != &a[58] || r2 != 55 || s2 != 61 || p2 != 30104)\n+    abort ();\n+  if (u3 != 63 || v3 != 115 || w3 != 140 || x3 != &a[58] || r3 != 55 || s3 != 61 || p3 != 30104)\n+    abort ();\n+  if (t != 11356)\n+    abort ();\n+  return 0;\n+}"}]}