{"sha": "50d1b7a1166c5208498a8884229c8c3a08e3eb05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkMWI3YTExNjZjNTIwODQ5OGE4ODg0MjI5YzhjM2EwOGUzZWIwNQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-20T19:27:33Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-01-20T19:27:33Z"}, "message": "stmt.c (expand_cleanups): Add 4th argument to indicate if code needs to be expanded for the cleanup.\n\n        * stmt.c (expand_cleanups): Add 4th argument to indicate if code\n        needs to be expanded for the cleanup.\n        (expand_goto_internal): Ditto.\n        (bc_expand_goto_internal): Ditto.\n        (fixup_gotos): Ditto.\n        (expand_end_bindings): Ditto.  We now always call expand_cleanups,\n        even after BARRIERs, so that the call to the exception handling\n        routines is always done.\n\nFrom-SVN: r8776", "tree": {"sha": "462c72b7e6dc0c53d6033df90062f2db9a7ee1bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/462c72b7e6dc0c53d6033df90062f2db9a7ee1bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50d1b7a1166c5208498a8884229c8c3a08e3eb05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d1b7a1166c5208498a8884229c8c3a08e3eb05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d1b7a1166c5208498a8884229c8c3a08e3eb05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d1b7a1166c5208498a8884229c8c3a08e3eb05/comments", "author": null, "committer": null, "parents": [{"sha": "28ed46164618631d07f5ddee9a9743c378d6cbcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ed46164618631d07f5ddee9a9743c378d6cbcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ed46164618631d07f5ddee9a9743c378d6cbcc"}], "stats": {"total": 87, "additions": 47, "deletions": 40}, "files": [{"sha": "4d850e75686f4edd02302788b4e4713b42e5f9a9", "filename": "gcc/stmt.c", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d1b7a1166c5208498a8884229c8c3a08e3eb05/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d1b7a1166c5208498a8884229c8c3a08e3eb05/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=50d1b7a1166c5208498a8884229c8c3a08e3eb05", "patch": "@@ -449,7 +449,7 @@ static void bc_expand_variable_local_init PROTO((tree));\n static void bc_expand_decl_init\t\tPROTO((tree));\n static void expand_null_return_1\tPROTO((rtx, int));\n static int tail_recursion_args\t\tPROTO((tree, tree));\n-static void expand_cleanups\t\tPROTO((tree, tree, int));\n+static void expand_cleanups\t\tPROTO((tree, tree, int, int));\n static void bc_expand_start_case\tPROTO((struct nesting *, tree,\n \t\t\t\t\t       tree, char *));\n static int bc_pushcase\t\t\tPROTO((tree, tree));\n@@ -804,7 +804,7 @@ expand_goto_internal (body, label, last_insn)\n \t  /* Execute the cleanups for blocks we are exiting.  */\n \t  if (block->data.block.cleanups != 0)\n \t    {\n-\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1);\n+\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1, 1);\n \t      do_pending_stack_adjust ();\n \t    }\n \t}\n@@ -868,7 +868,7 @@ bc_expand_goto_internal (opcode, label, body)\n \t  /* Execute the cleanups for blocks we are exiting.  */\n \t  if (block->data.block.cleanups != 0)\n \t    {\n-\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1);\n+\t      expand_cleanups (block->data.block.cleanups, NULL_TREE, 1, 1);\n \t      do_pending_stack_adjust ();\n \t    }\n \t}\n@@ -1181,7 +1181,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t\tif (TREE_ADDRESSABLE (lists)\n \t\t    && TREE_VALUE (lists) != 0)\n \t\t  {\n-\t\t    expand_cleanups (TREE_VALUE (lists), NULL_TREE, 1);\n+\t\t    expand_cleanups (TREE_VALUE (lists), NULL_TREE, 1, 1);\n \t\t    /* Pop any pushes done in the cleanups,\n \t\t       in case function is about to return.  */\n \t\t    do_pending_stack_adjust ();\n@@ -3093,32 +3093,32 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       || thisblock->data.block.cleanups != 0)\n     {\n       /* Only clean up here if this point can actually be reached.  */\n-      if (GET_CODE (get_last_insn ()) != BARRIER)\n-\t{\n-\t  /* Don't let cleanups affect ({...}) constructs.  */\n-\t  int old_expr_stmts_for_value = expr_stmts_for_value;\n-\t  rtx old_last_expr_value = last_expr_value;\n-\t  tree old_last_expr_type = last_expr_type;\n-\t  expr_stmts_for_value = 0;\n-\n-\t  /* Do the cleanups.  */\n-\t  expand_cleanups (thisblock->data.block.cleanups, NULL_TREE, 0);\n-\t  do_pending_stack_adjust ();\n+      int reachable = GET_CODE (get_last_insn ()) != BARRIER;\n+\n+      /* Don't let cleanups affect ({...}) constructs.  */\n+      int old_expr_stmts_for_value = expr_stmts_for_value;\n+      rtx old_last_expr_value = last_expr_value;\n+      tree old_last_expr_type = last_expr_type;\n+      expr_stmts_for_value = 0;\n \n-\t  expr_stmts_for_value = old_expr_stmts_for_value;\n-\t  last_expr_value = old_last_expr_value;\n-\t  last_expr_type = old_last_expr_type;\n+      /* Do the cleanups.  */\n+      expand_cleanups (thisblock->data.block.cleanups, NULL_TREE, 0, reachable);\n+      if (reachable)\n+\tdo_pending_stack_adjust ();\n \n-\t  /* Restore the stack level.  */\n+      expr_stmts_for_value = old_expr_stmts_for_value;\n+      last_expr_value = old_last_expr_value;\n+      last_expr_type = old_last_expr_type;\n \n-\t  if (thisblock->data.block.stack_level != 0)\n-\t    {\n-\t      emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n-\t\t\t\t  thisblock->data.block.stack_level, NULL_RTX);\n-\t      if (nonlocal_goto_handler_slot != 0)\n-\t\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level,\n-\t\t\t\t NULL_RTX);\n-\t    }\n+      /* Restore the stack level.  */\n+\n+      if (reachable && thisblock->data.block.stack_level != 0)\n+\t{\n+\t  emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n+\t\t\t      thisblock->data.block.stack_level, NULL_RTX);\n+\t  if (nonlocal_goto_handler_slot != 0)\n+\t    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level,\n+\t\t\t     NULL_RTX);\n \t}\n \n       /* Any gotos out of this block must also do these things.\n@@ -3684,35 +3684,42 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n    a value that is being returned out of the scope.\n \n    If IN_FIXUP is non-zero, we are generating this cleanup for a fixup\n-   goto and handle protection regions specially in that case.  */\n+   goto and handle protection regions specially in that case.\n+\n+   If REACHABLE, we emit code, otherwise just inform the exception handling\n+   code about this finalization.  */\n \n static void\n-expand_cleanups (list, dont_do, in_fixup)\n+expand_cleanups (list, dont_do, in_fixup, reachable)\n      tree list;\n      tree dont_do;\n      int in_fixup;\n+     int reachable;\n {\n   tree tail;\n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     if (dont_do == 0 || TREE_PURPOSE (tail) != dont_do)\n       {\n \tif (TREE_CODE (TREE_VALUE (tail)) == TREE_LIST)\n-\t  expand_cleanups (TREE_VALUE (tail), dont_do, in_fixup);\n+\t  expand_cleanups (TREE_VALUE (tail), dont_do, in_fixup, reachable);\n \telse\n \t  {\n \t    if (! in_fixup)\n \t      (*interim_eh_hook) (TREE_VALUE (tail));\n \n-\t    /* Cleanups may be run multiple times.  For example,\n-\t       when exiting a binding contour, we expand the\n-\t       cleanups associated with that contour.  When a goto\n-\t       within that binding contour has a target outside that\n-\t       contour, it will expand all cleanups from its scope to\n-\t       the target.  Though the cleanups are expanded multiple\n-\t       times, the control paths are non-overlapping so the\n-\t       cleanups will not be executed twice.  */\n-\t    expand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n-\t    free_temp_slots ();\n+\t    if (reachable)\n+\t      {\n+\t\t/* Cleanups may be run multiple times.  For example,\n+\t\t   when exiting a binding contour, we expand the\n+\t\t   cleanups associated with that contour.  When a goto\n+\t\t   within that binding contour has a target outside that\n+\t\t   contour, it will expand all cleanups from its scope to\n+\t\t   the target.  Though the cleanups are expanded multiple\n+\t\t   times, the control paths are non-overlapping so the\n+\t\t   cleanups will not be executed twice.  */\n+\t\texpand_expr (TREE_VALUE (tail), const0_rtx, VOIDmode, 0);\n+\t\tfree_temp_slots ();\n+\t      }\n \t  }\n       }\n }"}]}