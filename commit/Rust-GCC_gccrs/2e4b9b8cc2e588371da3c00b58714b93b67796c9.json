{"sha": "2e4b9b8cc2e588371da3c00b58714b93b67796c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0YjliOGNjMmU1ODgzNzFkYTNjMDBiNTg3MTRiOTNiNjc3OTZjOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-03T02:17:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-03T02:17:07Z"}, "message": "Makefile.in (OBJS): Add dwarf2asm.o.\n\n\t* Makefile.in (OBJS): Add dwarf2asm.o.\n\t* dwarf2asm.c, dwarf2asm.h: New files.\n\t* dwarf2out.c (*): Use them.\n\t(size_of_uleb128, size_of_sleb128): Remove.\n\t(output_uleb128, output_sleb128): Remove.\n\t(UNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP): Remove.\n\t(UNALIGNED_DOUBLE_INT_ASM_OP, ASM_BYTE_OP): Remove.\n\t(UNALIGNED_OFFSET_ASM_OP, UNALIGNED_WORD_ASM_OP): Remove.\n\t(FDE_LABEL, LINE_NUMBER_BEGIN_LABEL, LINE_NUMBER_END_LABEL): New.\n\t(ASM_OUTPUT_DWARF_DATA1, ASM_OUTPUT_DWARF_DELTA1): Remove.\n\t(ASM_OUTPUT_DWARF_DATA2, ASM_OUTPUT_DWARF_DELTA2): Remove.\n\t(ASM_OUTPUT_DWARF_DATA4, ASM_OUTPUT_DWARF_DELTA4): Remove.\n\t(ASM_OUTPUT_DWARF_DATA, ASM_OUTPUT_DWARF_DELTA): Remove.\n\t(ASM_OUTPUT_DWARF_ADDR, ASM_OUTPUT_DWARF_ADDR_DATA): Remove.\n\t(ASM_OUTPUT_DWARF_ADDR_DELTA, ASM_OUTPUT_DWARF_ADDR_CONST): Remove.\n\t(ASM_OUTPUT_DWARF_OFFSET4, ASM_OUTPUT_DWARF_OFFSET): Remove.\n\t(ASM_OUTPUT_DWARF_CONST_DOUBLE): Remove.\n\t(ASM_OUTPUT_DWARF_NSTRING, ASM_OUTPUT_DWARF_STRING): Remove.\n\t(dwarf2out_frame_debug): Remove unused variables.\n\t(output_loc_operands): Don't abort on 8 byte constants if\n\thost integers are wide enough.\n\t(output_symbolic_ref): Remove.\n\t(size_of_die): Don't assume 4 byte host integers.\n\t(output_line_info): Use ASM_GENERATE_INTERNAL_LABEL for begin\n\tand end labels.\n\t(add_const_value_attribute) [CONST_INT]: Verify we're not doing\n\tsomething stupid with HOST_WIDE_INT to long truncation.\n\t[CONST_DOUBLE]: Likewise.\n\n\t* config/arm/conix-elf.h (UNALIGNED_WORD_ASM_OP): Remove.\n\t(ASM_OUTPUT_DWARF2_ADDR_CONST, ASM_OUTPUT_DWARF_ADDR_CONST): Remove.\n\t* config/arm/unknown-elf.h: Likewise.\n\t* config/rs6000/aix.h (UNALIGNED_SHORT_ASM_OP): New.\n\t(UNALIGNED_INT_ASM_OP, UNALIGNED_DOUBLE_INT_ASM_OP): New.\n\t(ASM_OUTPUT_DWARF_ADDR_VAR, ASM_OUTPUT_DWARF_DELTA_VAR): Remove.\n\t(ASM_OUTPUT_DWARF_DELTA2, ASM_OUTPUT_DWARF_DELTA4): Remove.\n\t(ASM_OUTPUT_DWARF_DELTA, ASM_OUTPUT_DWARF_ADDR_DELTA): Remove.\n\t(ASM_OUTPUT_DWARF_ADDR, ASM_OUTPUT_DWARF_DATA4): Remove.\n\t(ASM_OUTPUT_DWARF_DATA2, ASM_OUTPUT_DWARF_OFFSET4): Remove.\n\t(ASM_OUTPUT_DWARF_OFFSET): Remove.\n\t* config/rs6000/sysv4.h (ASM_OUTPUT_DWARF_ADDR): Remove.\n\t* config/sparc/sp64-elf.h (UNALIGNED_DOUBLE_INT_ASM_OP): New.\n\t(UNALIGNED_LONGLONG_ASM_OP, ASM_OUTPUT_DWARF_ADDR): Remove.\n\t(ASM_OUTPUT_DWARF_ADDR_CONST, ASM_OUTPUT_DWARF_REF): Remove.\n\nFrom-SVN: r40197", "tree": {"sha": "ab3f6c2c5328b768cf2cdd0f5fc4571ffeaa90b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab3f6c2c5328b768cf2cdd0f5fc4571ffeaa90b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e4b9b8cc2e588371da3c00b58714b93b67796c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4b9b8cc2e588371da3c00b58714b93b67796c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4b9b8cc2e588371da3c00b58714b93b67796c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4b9b8cc2e588371da3c00b58714b93b67796c9/comments", "author": null, "committer": null, "parents": [{"sha": "dc76f41ca633e9094e1c2d43b58bbab69a10f973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc76f41ca633e9094e1c2d43b58bbab69a10f973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc76f41ca633e9094e1c2d43b58bbab69a10f973"}], "stats": {"total": 2353, "additions": 1061, "deletions": 1292}, "files": [{"sha": "47f2d24bce5e4313f1bcedbff869fc92abf74dff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -1,3 +1,50 @@\n+2001-03-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add dwarf2asm.o.\n+\t* dwarf2asm.c, dwarf2asm.h: New files.\n+\t* dwarf2out.c (*): Use them.\n+\t(size_of_uleb128, size_of_sleb128): Remove.\n+\t(output_uleb128, output_sleb128): Remove.\n+\t(UNALIGNED_SHORT_ASM_OP, UNALIGNED_INT_ASM_OP): Remove.\n+\t(UNALIGNED_DOUBLE_INT_ASM_OP, ASM_BYTE_OP): Remove.\n+\t(UNALIGNED_OFFSET_ASM_OP, UNALIGNED_WORD_ASM_OP): Remove.\n+\t(FDE_LABEL, LINE_NUMBER_BEGIN_LABEL, LINE_NUMBER_END_LABEL): New.\n+\t(ASM_OUTPUT_DWARF_DATA1, ASM_OUTPUT_DWARF_DELTA1): Remove.\n+\t(ASM_OUTPUT_DWARF_DATA2, ASM_OUTPUT_DWARF_DELTA2): Remove.\n+\t(ASM_OUTPUT_DWARF_DATA4, ASM_OUTPUT_DWARF_DELTA4): Remove.\n+\t(ASM_OUTPUT_DWARF_DATA, ASM_OUTPUT_DWARF_DELTA): Remove.\n+\t(ASM_OUTPUT_DWARF_ADDR, ASM_OUTPUT_DWARF_ADDR_DATA): Remove.\n+\t(ASM_OUTPUT_DWARF_ADDR_DELTA, ASM_OUTPUT_DWARF_ADDR_CONST): Remove.\n+\t(ASM_OUTPUT_DWARF_OFFSET4, ASM_OUTPUT_DWARF_OFFSET): Remove.\n+\t(ASM_OUTPUT_DWARF_CONST_DOUBLE): Remove.\n+\t(ASM_OUTPUT_DWARF_NSTRING, ASM_OUTPUT_DWARF_STRING): Remove.\n+\t(dwarf2out_frame_debug): Remove unused variables.\n+\t(output_loc_operands): Don't abort on 8 byte constants if\n+\thost integers are wide enough.\n+\t(output_symbolic_ref): Remove.\n+\t(size_of_die): Don't assume 4 byte host integers.\n+\t(output_line_info): Use ASM_GENERATE_INTERNAL_LABEL for begin\n+\tand end labels.\n+\t(add_const_value_attribute) [CONST_INT]: Verify we're not doing\n+\tsomething stupid with HOST_WIDE_INT to long truncation.\n+\t[CONST_DOUBLE]: Likewise.\n+\n+\t* config/arm/conix-elf.h (UNALIGNED_WORD_ASM_OP): Remove.\n+\t(ASM_OUTPUT_DWARF2_ADDR_CONST, ASM_OUTPUT_DWARF_ADDR_CONST): Remove.\n+\t* config/arm/unknown-elf.h: Likewise.\n+\t* config/rs6000/aix.h (UNALIGNED_SHORT_ASM_OP): New.\n+\t(UNALIGNED_INT_ASM_OP, UNALIGNED_DOUBLE_INT_ASM_OP): New.\n+\t(ASM_OUTPUT_DWARF_ADDR_VAR, ASM_OUTPUT_DWARF_DELTA_VAR): Remove.\n+\t(ASM_OUTPUT_DWARF_DELTA2, ASM_OUTPUT_DWARF_DELTA4): Remove.\n+\t(ASM_OUTPUT_DWARF_DELTA, ASM_OUTPUT_DWARF_ADDR_DELTA): Remove.\n+\t(ASM_OUTPUT_DWARF_ADDR, ASM_OUTPUT_DWARF_DATA4): Remove.\n+\t(ASM_OUTPUT_DWARF_DATA2, ASM_OUTPUT_DWARF_OFFSET4): Remove.\n+\t(ASM_OUTPUT_DWARF_OFFSET): Remove.\n+\t* config/rs6000/sysv4.h (ASM_OUTPUT_DWARF_ADDR): Remove.\n+\t* config/sparc/sp64-elf.h (UNALIGNED_DOUBLE_INT_ASM_OP): New.\n+\t(UNALIGNED_LONGLONG_ASM_OP, ASM_OUTPUT_DWARF_ADDR): Remove.\n+\t(ASM_OUTPUT_DWARF_ADDR_CONST, ASM_OUTPUT_DWARF_REF): Remove.\n+\n 2001-03-02  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* cselib.c (hash_rtx): Cast enums to unsigned int."}, {"sha": "9f3bb5248be87e7b62fc042390bf4dd5d41dfe1f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -733,19 +733,22 @@ C_OBJS = c-parse.o c-lang.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n \n-OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n- function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o \\\n- builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o  \\\n- dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n- integrate.o jump.o cse.o loop.o doloop.o unroll.o flow.o combine.o varray.o \\\n- regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o\\\n- insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o regrename.o   \\\n- insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o   \\\n- profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t     \\\n- mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t     \\\n- lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o  \\\n- sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o \\\n- sched-vis.o sched-deps.o sched-rgn.o sched-ebb.o hashtab.o cselib.o params.o\n+OBJS =\t\t\t\t\t\t\t\t\t\\\n+ alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\t\\\n+ combine.o conflict.o convert.o cse.o cselib.o dbxout.o dce.o\t\t\\\n+ dependence.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o\t\\\n+ dwarfout.o emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o\t\\\n+ fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o\t\\\n+ haifa-sched.o hash.o hashtab.o ifcvt.o insn-attrtab.o insn-emit.o\t\\\n+ insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t\\\n+ integrate.o intl.o jump.o lcm.o lists.o local-alloc.o loop.o mbchar.o\t\\\n+ optabs.o params.o predict.o print-rtl.o print-tree.o profile.o real.o\t\\\n+ recog.o reg-stack.o regclass.o regmove.o regrename.o reload.o\t\t\\\n+ reload1.o reorg.o resource.o rtl.o rtlanal.o sbitmap.o sched-deps.o\t\\\n+ sched-ebb.o sched-rgn.o sched-vis.o sdbout.o sibcall.o simplify-rtx.o\t\\\n+ splay-tree.o ssa.o stmt.o stor-layout.o stringpool.o timevar.o tree.o\t\\\n+ unroll.o varasm.o varray.o version.o xcoffout.o\t\t\t\\\n+ $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1397,7 +1400,9 @@ dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n    flags.h insn-config.h reload.h output.h \\\n    hard-reg-set.h $(REGS_H) $(EXPR_H) toplev.h dwarf2out.h varray.h \\\n-   $(GGC_H) except.h\n+   $(GGC_H) except.h dwarf2asm.h\n+dwarf2asm.o : dwarf2asm.c $(CONFIG_H) system.h flags.h $(RTL_H) output.h \\\n+   dwarf2asm.h\n xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h $(GGC_H)\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\"}, {"sha": "a626af88fd89ebdab814fb023d9dd1f828a6778b", "filename": "gcc/config/arm/conix-elf.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Farm%2Fconix-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Farm%2Fconix-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconix-elf.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -99,23 +99,6 @@ func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Don't know how to order these.  UNALIGNED_WORD_ASM_OP is in\n-   dwarf2.out.  */ \n-#define UNALIGNED_WORD_ASM_OP \"\\t.4byte\\t\"\n-\n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)                  \\\n-     fprintf ((FILE), \"%s%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n-\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)       \t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t    \t\t\\\n-      fprintf ((FILE), \"%s\", UNALIGNED_WORD_ASM_OP);\t\t\\\n-      output_addr_const ((FILE), (RTX));\t\t    \t\\\n-      fputc ('\\n', (FILE));\t\t\t\t    \t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n /* The ARM development system defines __main.  */\n #define NAME__MAIN \"__gccmain\"\n #define SYMBOL__MAIN __gccmain"}, {"sha": "fab8155f1ef18624f060714d639e869633aa635b", "filename": "gcc/config/arm/unknown-elf.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Farm%2Funknown-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Farm%2Funknown-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -103,23 +103,6 @@ rdata_section ()\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Don't know how to order these.  UNALIGNED_WORD_ASM_OP is in\n-   dwarf2.out. */ \n-#define UNALIGNED_WORD_ASM_OP \"\\t.4byte\\t\"\n-\n-#define ASM_OUTPUT_DWARF2_ADDR_CONST(FILE,ADDR)                  \\\n- fprintf ((FILE), \"%s%s\", UNALIGNED_WORD_ASM_OP, ADDR)\n-\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"%s\", UNALIGNED_WORD_ASM_OP);\t\t\\\n-      output_addr_const ((FILE), (RTX));\t\t\t\\\n-      fputc ('\\n', (FILE));\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n /* The ARM development system defines __main.  */\n #define NAME__MAIN \"__gccmain\"\n #define SYMBOL__MAIN __gccmain"}, {"sha": "cb5db356d07aec25db13bff016f76559c7ababa7", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 3, "deletions": 42, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -561,48 +561,9 @@ toc_section ()\t\t\t\t\t\t\\\n    use '.long' or '.word', but that aligns to a 4-byte boundary which\n    is not what is required.  So we define a million macros...  */\n \n-#define ASM_OUTPUT_DWARF_ADDR_VAR(FILE, LABEL, LENGTH)\t\\\n- do {   fprintf ((FILE), \"\\t.vbyte\\t%d,\", LENGTH);\t\\\n-        assemble_name (FILE, LABEL);\t\t\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_DWARF_DELTA_VAR(FILE, LABEL1, LABEL2, LENGTH)\t\\\n- do {   fprintf ((FILE), \"\\t.vbyte\\t%d,\", LENGTH);\t\t\t\\\n-        assemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-        assemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_DWARF_DELTA2(FILE, LABEL1, LABEL2)\t\\\n- ASM_OUTPUT_DWARF_DELTA_VAR (FILE, LABEL1, LABEL2, 2)\n-\n-#define ASM_OUTPUT_DWARF_DELTA4(FILE, LABEL1, LABEL2)\t\\\n- ASM_OUTPUT_DWARF_DELTA_VAR (FILE, LABEL1, LABEL2, 4)\n-\n-#define ASM_OUTPUT_DWARF_DELTA(FILE, LABEL1, LABEL2)\t\t\t\\\n- ASM_OUTPUT_DWARF_DELTA_VAR (FILE, LABEL1, LABEL2, DWARF_OFFSET_SIZE)\n-\n-#define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE, LABEL1, LABEL2)\t\\\n- ASM_OUTPUT_DWARF_DELTA_VAR (FILE, LABEL1, LABEL2,\t\t\\\n-\t\t\t     POINTER_SIZE / BITS_PER_UNIT)\n-\n-#define ASM_OUTPUT_DWARF_ADDR(FILE, LABEL)\t\t\t\t\\\n- ASM_OUTPUT_DWARF_ADDR_VAR (FILE, LABEL, POINTER_SIZE / BITS_PER_UNIT)\n-\n-#define ASM_OUTPUT_DWARF_DATA4(FILE, VALUE)\t\t\t\\\n-  fprintf ((FILE), \"\\t.vbyte\\t4,0x%x\", (unsigned) (VALUE))\n-\n-#define ASM_OUTPUT_DWARF_DATA2(FILE, VALUE)\t\t\t\\\n-  fprintf ((FILE), \"\\t.vbyte\\t2,0x%x\", (unsigned) (VALUE))\n-\n-#define ASM_OUTPUT_DWARF_OFFSET4(FILE, LABEL)\t\\\n-  ASM_OUTPUT_DWARF_ADDR_VAR (FILE, LABEL, 4)\n-\n-#define ASM_OUTPUT_DWARF_OFFSET(FILE, LABEL)\t\t\t\\\n-  ASM_OUTPUT_DWARF_ADDR_VAR (FILE, LABEL, DWARF_OFFSET_SIZE)\n-\n-/* dwarf2out keys off this, but we don't have to have a real definition.  */\n-#define UNALIGNED_INT_ASM_OP bite_me\n+#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.vbyte\\t2,\"\n+#define UNALIGNED_INT_ASM_OP\t\t\"\\t.vbyte\\t4,\"\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.vbyte\\t8,\"\n \n /* Output before instructions.  */\n #define TEXT_SECTION_ASM_OP \"\\t.csect .text[PR]\""}, {"sha": "6cf6379805da9a012f0ab63cc14b9286c2f96ecd", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -871,36 +871,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n-/* This is how to output an assembler line defining an address \n-   constant for the dwarf call unwinding information.\n-   For -mrelocatable, we mark all addresses that need to be fixed up\n-   in the .fixup section.  */\n-\n-#define\tASM_OUTPUT_DWARF_ADDR(FILE,LABEL)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_RELOCATABLE)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      char buf[256];\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCP\", fixuplabelno);\t\t\\\n-      fixuplabelno++;\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL (FILE, buf);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.%dbyte\\t\", POINTER_SIZE / BITS_PER_UNIT);\t\\\n-      assemble_name (FILE, LABEL);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section \\\".fixup\\\",\\\"aw\\\"\\n\");\t\t\t\\\n-      ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.long\\t\");\t\t\t\t\t\\\n-      assemble_name (FILE, buf);\t\t\t\t\t\\\n-      fprintf (FILE, \"\\n\\t.previous\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.%dbyte\\t\", POINTER_SIZE / BITS_PER_UNIT);\t\\\n-      assemble_name (FILE, LABEL);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is the end of what might become sysv4.h.  */\n \n /* Allow stabs and dwarf, for now, make stabs the default debugging type,"}, {"sha": "1a7623b591cb0aa4640cab05f2ccdf6d74a700d4", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -124,33 +124,6 @@ crtbegin.o%s \\\n #undef ASM_IDENTIFY_GCC\n #define ASM_IDENTIFY_GCC(FILE)\n \n-/* Define the names of various pseudo-ops used by the Sparc/svr4 assembler.\n-   ??? If ints are 64 bits then UNALIGNED_INT_ASM_OP (defined elsewhere) is\n-   misnamed.  These should all refer to explicit sizes (half/word/xword?),\n-   anything other than short/int/long/etc.  */\n-\n-#define UNALIGNED_LONGLONG_ASM_OP\t\"\\t.uaxword\\t\"\n-\n-/* DWARF stuff.  */\n-\n-#define ASM_OUTPUT_DWARF_ADDR(FILE, LABEL) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s\", UNALIGNED_LONGLONG_ASM_OP);\t\t\\\n-  assemble_name ((FILE), (LABEL));\t\t\t\t\\\n-  fprintf ((FILE), \"\\n\");\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE, RTX) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s\", UNALIGNED_LONGLONG_ASM_OP);\t\t\\\n-  output_addr_const ((FILE), (RTX));\t\t\t\t\\\n-  fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* ??? Not sure if this should be 4 or 8 bytes.  4 works for now.  */\n-#define ASM_OUTPUT_DWARF_REF(FILE, LABEL) \\\n-do {\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-  assemble_name ((FILE), (LABEL));\t\t\t\t\\\n-  fprintf ((FILE), \"\\n\");\t\t\t\t\t\\\n-} while (0)\n+/* Define the names of various pseudo-ops used by the Sparc/svr4 assembler.  */\n+\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.uaxword\\t\""}, {"sha": "132d83cae254d6d1988cb8f696a0b7c8d1c25cd0", "filename": "gcc/dwarf2asm.c", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -0,0 +1,585 @@\n+/* Dwarf2 assembler output helper routines.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"dwarf2asm.h\"\n+#include \"tm_p.h\"\n+\n+\n+/* How to start an assembler comment.  */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \";#\"\n+#endif\n+\n+/* Definitions of defaults for assembler-dependent names of various\n+   pseudo-ops and section names.  These may be overridden in the tm.h\n+   file (if necessary) for a particular assembler.  */\n+\n+#ifdef OBJECT_FORMAT_ELF\n+#ifndef UNALIGNED_SHORT_ASM_OP\n+#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.2byte\\t\"\n+#endif\n+#ifndef UNALIGNED_INT_ASM_OP\n+#define UNALIGNED_INT_ASM_OP\t\t\"\\t.4byte\\t\"\n+#endif\n+#ifndef UNALIGNED_DOUBLE_INT_ASM_OP\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.8byte\\t\"\n+#endif\n+#endif /* OBJECT_FORMAT_ELF */\n+\n+#ifndef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\t\t\"\\t.byte\\t\"\n+#endif\n+\n+/* We don't have unaligned support, let's hope the normal output works for\n+   .debug_frame.  But we know it won't work for .debug_info.  */\n+#if !defined(UNALIGNED_INT_ASM_OP) && defined(DWARF2_DEBUGGING_INFO)\n+ #error DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.\n+#endif\n+\n+\f\n+#ifdef UNALIGNED_INT_ASM_OP\n+static const char * unaligned_integer_asm_op  PARAMS ((int));\n+\n+static inline const char *\n+unaligned_integer_asm_op (size)\n+     int size;\n+{\n+  const char *op;\n+  switch (size)\n+    {\n+    case 1:\n+      op = ASM_BYTE_OP;\n+      break;\n+    case 2:\n+      op = UNALIGNED_SHORT_ASM_OP;\n+      break;\n+    case 4:\n+      op = UNALIGNED_INT_ASM_OP;\n+      break;\n+    case 8:\n+#ifdef UNALIGNED_DOUBLE_INT_ASM_OP\n+      op = UNALIGNED_DOUBLE_INT_ASM_OP;\n+      break;\n+#endif\n+    default:\n+      abort ();\n+    }\n+  return op;\n+}\n+#endif /* UNALIGNED_INT_ASM_OP */\n+\n+void\n+dw2_asm_output_data VPARAMS ((int size, unsigned HOST_WIDE_INT value,\n+\t\t\t      const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int size;\n+  unsigned HOST_WIDE_INT value;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  size = va_arg (ap, int);\n+  value = va_arg (ap, unsigned HOST_WIDE_INT);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, value);\n+#else\n+  assemble_integer (GEN_INT (value), size, 1);\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_delta VPARAMS ((int size, const char *lab1, const char *lab2,\n+\t\t\t       const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int size;\n+  const char *lab1, *lab2;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  size = va_arg (ap, int);\n+  lab1 = va_arg (ap, const char *);\n+  lab2 = va_arg (ap, const char *);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+  assemble_name (asm_out_file, lab1);\n+  fputc ('-', asm_out_file);\n+  assemble_name (asm_out_file, lab2);\n+#else\n+  assemble_integer (gen_rtx_MINUS (smallest_mode_for_size (size, MODE_INT, 0),\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, lab1),\n+\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, lab2)),\n+\t\t    size, 1);\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_offset VPARAMS ((int size, const char *label,\n+\t\t\t       const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int size;\n+  const char *label;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  size = va_arg (ap, int);\n+  label = va_arg (ap, const char *);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+  assemble_name (asm_out_file, label);\n+#else\n+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, label), size, 1);\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_pcrel VPARAMS ((int size, const char *label,\n+\t\t\t       const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int size;\n+  const char *label;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  size = va_arg (ap, int);\n+  label = va_arg (ap, const char *);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+\n+  /* ??? This needs target conditionalization.  E.g. the solaris\n+     assembler uses %r_disp32(label).  Others don't like \".\" and\n+     we need to generate a temporary label here.  */\n+  assemble_name (asm_out_file, label);\n+  fputc ('-', asm_out_file);\n+  fputc ('.', asm_out_file);\n+#else\n+  abort ();\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_addr_rtx VPARAMS ((int size, rtx addr,\n+\t\t\t\t  const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  int size;\n+  rtx addr;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  size = va_arg (ap, int);\n+  addr = va_arg (ap, rtx);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef UNALIGNED_INT_ASM_OP\n+  fputs (unaligned_integer_asm_op (size), asm_out_file);\n+  output_addr_const (asm_out_file, addr);\n+#else\n+  assemble_integer (addr, size, 1);\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_nstring VPARAMS ((const char *str, size_t orig_len,\n+\t\t\t\t const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *str;\n+  size_t orig_len;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+  size_t i, len = orig_len;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  str = va_arg (ap, const char *);\n+  len = va_arg (ap, size_t);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+  if (len == (size_t) -1)\n+    len = strlen (str);\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fputs (\"\\t.ascii \\\"\", asm_out_file);\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  int c = str[i];\n+\t  if (c == '\\\"' || c == '\\\\')\n+\t    fputc ('\\\\', asm_out_file);\n+\t  if (ISPRINT(c))\n+\t    fputc (c, asm_out_file);\n+\t  else\n+\t    fprintf (asm_out_file, \"\\\\%o\", c);\n+\t}\n+      fprintf (asm_out_file, \"\\\\0\\\"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+      fputc ('\\n', asm_out_file);\n+    }\n+  else\n+    {\n+      /* If an explicit length was given, we can't assume there\n+\t is a null termination in the string buffer.  */\n+      if (orig_len == (size_t) -1)\n+\tlen += 1;\n+      ASM_OUTPUT_ASCII (asm_out_file, str, len);\n+      if (orig_len != (size_t) -1)\n+\tfprintf (asm_out_file, \"%s0\\n\", ASM_BYTE_OP);\n+    }\n+\n+  va_end (ap);\n+}\n+\f\n+\n+/* Return the size of an unsigned LEB128 quantity.  */\n+\n+int\n+size_of_uleb128 (value)\n+     unsigned HOST_WIDE_INT value;\n+{\n+  int size = 0, byte;\n+\n+  do\n+    {\n+      byte = (value & 0x7f);\n+      value >>= 7;\n+      size += 1;\n+    }\n+  while (value != 0);\n+\n+  return size;\n+}\n+\n+/* Return the size of a signed LEB128 quantity.  */\n+\n+int\n+size_of_sleb128 (value)\n+     HOST_WIDE_INT value;\n+{\n+  int size = 0, byte;\n+\n+  do\n+    {\n+      byte = (value & 0x7f);\n+      value >>= 7;\n+      size += 1;\n+    }\n+  while (!((value == 0 && (byte & 0x40) == 0)\n+\t   || (value == -1 && (byte & 0x40) != 0)));\n+\n+  return size;\n+}\n+\n+/* Output an unsigned LEB128 quantity.  */\n+\n+void\n+dw2_asm_output_data_uleb128 VPARAMS ((unsigned HOST_WIDE_INT value,\n+\t\t\t\t      const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  unsigned HOST_WIDE_INT value;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  value = va_arg (ap, unsigned HOST_WIDE_INT);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef HAVE_AS_LEB128\n+  fputs (\"\\t.uleb128\\t\", asm_out_file);\n+  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, value);\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+#else\n+  {\n+    unsigned HOST_WIDE_INT work = value;\n+\n+    fputs (ASM_BYTE_OP, asm_out_file);\n+    do\n+      {\n+\tint byte = (work & 0x7f);\n+\twork >>= 7;\n+\tif (work != 0)\n+\t  /* More bytes to follow.  */\n+\t  byte |= 0x80;\n+\n+\tfprintf (asm_out_file, \"0x%x\", byte);\n+\tif (work != 0)\n+\t  fputc (',', asm_out_file);\n+      }\n+    while (work != 0);\n+\n+  if (flag_debug_asm)\n+    {\n+      fprintf (asm_out_file, \"\\t%s uleb128 \", ASM_COMMENT_START);\n+      fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, value);\n+      if (comment)\n+\t{\n+\t  fputs (\"; \", asm_out_file);\n+\t  vfprintf (asm_out_file, comment, ap);\n+\t}\n+    }\n+  }\n+#endif\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+/* Output an signed LEB128 quantity.  */\n+\n+void\n+dw2_asm_output_data_sleb128 VPARAMS ((HOST_WIDE_INT value,\n+\t\t\t\t      const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  HOST_WIDE_INT value;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  value = va_arg (ap, HOST_WIDE_INT);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef HAVE_AS_LEB128\n+  fputs (\"\\t.sleb128\\t\", asm_out_file);\n+  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX, value);\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+#else\n+  {\n+    HOST_WIDE_INT work = value;\n+    int more, byte;\n+\n+    fputs (ASM_BYTE_OP, asm_out_file);\n+    do\n+      {\n+\tbyte = (work & 0x7f);\n+\t/* arithmetic shift */\n+\twork >>= 7;\n+\tmore = !((work == 0 && (byte & 0x40) == 0)\n+\t\t || (work == -1 && (byte & 0x40) != 0));\n+\tif (more)\n+\t  byte |= 0x80;\n+\n+\tfprintf (asm_out_file, \"0x%x\", byte);\n+\tif (more)\n+\t  fputc (',', asm_out_file);\n+      }\n+    while (more);\n+\n+  if (flag_debug_asm)\n+    {\n+      fprintf (asm_out_file, \"\\t%s sleb128 \", ASM_COMMENT_START);\n+      fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, value);\n+      if (comment)\n+\t{\n+\t  fputs (\"; \", asm_out_file);\n+\t  vfprintf (asm_out_file, comment, ap);\n+\t}\n+    }\n+  }\n+#endif\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_delta_uleb128 VPARAMS ((const char *lab1 ATTRIBUTE_UNUSED,\n+\t\t\t\t       const char *lab2 ATTRIBUTE_UNUSED,\n+\t\t\t\t       const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *lab1, *lab2;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  lab1 = va_arg (ap, const char *);\n+  lab2 = va_arg (ap, const char *);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef HAVE_AS_LEB128\n+  fputs (\"\\t.uleb128\\t\", asm_out_file);\n+  assemble_name (asm_out_file, lab1);\n+  fputc ('-', asm_out_file);\n+  assemble_name (asm_out_file, lab2);\n+#else\n+  abort ();\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}\n+\n+void\n+dw2_asm_output_delta_sleb128 VPARAMS ((const char *lab1 ATTRIBUTE_UNUSED,\n+\t\t\t\t       const char *lab2 ATTRIBUTE_UNUSED,\n+\t\t\t\t       const char *comment, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *lab1, *lab2;\n+  const char *comment;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, comment);\n+\n+#ifndef ANSI_PROTOTYPES\n+  lab1 = va_arg (ap, const char *);\n+  lab2 = va_arg (ap, const char *);\n+  comment = va_arg (ap, const char *);\n+#endif\n+\n+#ifdef HAVE_AS_LEB128\n+  fputs (\"\\t.sleb128\\t\", asm_out_file);\n+  assemble_name (asm_out_file, lab1);\n+  fputc ('-', asm_out_file);\n+  assemble_name (asm_out_file, lab2);\n+#else\n+  abort ();\n+#endif\n+\n+  if (flag_debug_asm && comment)\n+    {\n+      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      vfprintf (asm_out_file, comment, ap);\n+    }\n+  fputc ('\\n', asm_out_file);\n+\n+  va_end (ap);\n+}"}, {"sha": "a1a2ae984e6a66ed75c1f8963587ea214ce5e0fa", "filename": "gcc/dwarf2asm.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -0,0 +1,68 @@\n+/* Dwarf2 assembler output helper routines.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* ??? Format checking yields \"null format string\" warnings, which is\n+   the way these routines are signaled that there is no associated\n+   debug information.  So the attributes are commented out.  */\n+\n+extern void dw2_asm_output_data\t\tPARAMS ((int, unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_delta\tPARAMS ((int, const char *,\n+\t\t\t\t\t\t const char *,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_4 */;\n+\n+extern void dw2_asm_output_offset\tPARAMS ((int, const char *,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_pcrel\tPARAMS ((int, const char *,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_addr_rtx\tPARAMS ((int, rtx,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_nstring\tPARAMS ((const char *, size_t,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_data_uleb128\tPARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_2 */;\n+\n+extern void dw2_asm_output_data_sleb128\tPARAMS ((HOST_WIDE_INT,\n+\t\t\t\t\t\t const char *, ...))\n+     /* ATTRIBUTE_PRINTF_2 */;\n+\n+extern void dw2_asm_output_delta_uleb128 PARAMS ((const char *, const char *,\n+\t\t\t\t\t\t  const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern void dw2_asm_output_delta_sleb128 PARAMS ((const char *, const char *,\n+\t\t\t\t\t\t  const char *, ...))\n+     /* ATTRIBUTE_PRINTF_3 */;\n+\n+extern int size_of_uleb128\t\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern int size_of_sleb128\t\tPARAMS ((HOST_WIDE_INT));"}, {"sha": "48777feb2e3d204e6a100c6c9679dac3f5f96a7f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 336, "deletions": 1142, "changes": 1478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4b9b8cc2e588371da3c00b58714b93b67796c9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2e4b9b8cc2e588371da3c00b58714b93b67796c9", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"dwarf2.h\"\n #include \"dwarf2out.h\"\n+#include \"dwarf2asm.h\"\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"ggc.h\"\n@@ -230,10 +231,6 @@ static char *stripattributes\t\tPARAMS ((const char *));\n static const char *dwarf_cfi_name\tPARAMS ((unsigned));\n static dw_cfi_ref new_cfi\t\tPARAMS ((void));\n static void add_cfi\t\t\tPARAMS ((dw_cfi_ref *, dw_cfi_ref));\n-static unsigned long size_of_uleb128\tPARAMS ((unsigned long));\n-static unsigned long size_of_sleb128\tPARAMS ((long));\n-static void output_uleb128\t\tPARAMS ((unsigned long));\n-static void output_sleb128\t\tPARAMS ((long));\n static void add_fde_cfi\t\t\tPARAMS ((const char *, dw_cfi_ref));\n static void lookup_cfa_1\t\tPARAMS ((dw_cfi_ref, dw_cfa_location *));\n static void lookup_cfa\t\t\tPARAMS ((dw_cfa_location *));\n@@ -254,25 +251,9 @@ static struct dw_loc_descr_struct *build_cfa_loc\n \t\t\t\t\tPARAMS ((dw_cfa_location *));\n static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n \n-/* Definitions of defaults for assembler-dependent names of various\n-   pseudo-ops and section names.\n-   Theses may be overridden in the tm.h file (if necessary) for a particular\n-   assembler.  */\n-\n-#ifdef OBJECT_FORMAT_ELF\n-#ifndef UNALIGNED_SHORT_ASM_OP\n-#define UNALIGNED_SHORT_ASM_OP\t\"\\t.2byte\\t\"\n-#endif\n-#ifndef UNALIGNED_INT_ASM_OP\n-#define UNALIGNED_INT_ASM_OP\t\"\\t.4byte\\t\"\n-#endif\n-#ifndef UNALIGNED_DOUBLE_INT_ASM_OP\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.8byte\\t\"\n-#endif\n-#endif /* OBJECT_FORMAT_ELF */\n-\n-#ifndef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\t\"\\t.byte\\t\"\n+/* How to start an assembler comment.  */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \";#\"\n #endif\n \n /* Data and reference forms for relocatable data.  */\n@@ -309,9 +290,12 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n #define CIE_AFTER_SIZE_LABEL\t\"LSCIE\"\n #define CIE_END_LABEL\t\t\"LECIE\"\n #define CIE_LENGTH_LABEL\t\"LLCIE\"\n-#define FDE_AFTER_SIZE_LABEL\t\"LSFDE\"\n+#define FDE_LABEL\t\t\"LSFDE\"\n+#define FDE_AFTER_SIZE_LABEL\t\"LASFDE\"\n #define FDE_END_LABEL\t\t\"LEFDE\"\n #define FDE_LENGTH_LABEL\t\"LLFDE\"\n+#define LINE_NUMBER_BEGIN_LABEL\t\"LTSTART\"\n+#define LINE_NUMBER_END_LABEL\t\"LTEND\"\n #define DIE_LABEL_PREFIX\t\"DW\"\n \n /* Definitions of defaults for various types of primitive assembly language\n@@ -323,212 +307,6 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n   fprintf ((FILE), SECTION_FORMAT, SECTION_ASM_OP, SECTION)\n #endif\n \n-#ifndef ASM_OUTPUT_DWARF_DATA1\n-#define ASM_OUTPUT_DWARF_DATA1(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\", ASM_BYTE_OP, (unsigned) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA1\n-#define ASM_OUTPUT_DWARF_DELTA1(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", ASM_BYTE_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifdef UNALIGNED_INT_ASM_OP\n-\n-#ifndef UNALIGNED_OFFSET_ASM_OP\n-#define UNALIGNED_OFFSET_ASM_OP \\\n-  (DWARF_OFFSET_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)\n-#endif\n-\n-#ifndef UNALIGNED_WORD_ASM_OP\n-#define UNALIGNED_WORD_ASM_OP\t\t\t\t\t\t\\\n-  ((DWARF2_ADDR_SIZE) == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP\t\t\\\n-   : (DWARF2_ADDR_SIZE) == 2 ? UNALIGNED_SHORT_ASM_OP\t\t\t\\\n-   : UNALIGNED_INT_ASM_OP)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA2\n-#define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_SHORT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA4\n-#define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA\n-#define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_OFFSET_ASM_OP);\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR_DELTA\n-#define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_WORD_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR\n-#define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_WORD_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"%s\", UNALIGNED_WORD_ASM_OP);\t\t\t\\\n-    output_addr_const ((FILE), (RTX));\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_OFFSET4\n-#define ASM_OUTPUT_DWARF_OFFSET4(FILE,LABEL) \\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_INT_ASM_OP);\t\t\t\\\n-\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_OFFSET\n-#define ASM_OUTPUT_DWARF_OFFSET(FILE,LABEL)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"%s\", UNALIGNED_OFFSET_ASM_OP);\t\t\\\n-\tassemble_name (FILE, LABEL);\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA2\n-#define ASM_OUTPUT_DWARF_DATA2(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\", UNALIGNED_SHORT_ASM_OP, (unsigned) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA4\n-#define ASM_OUTPUT_DWARF_DATA4(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%x\", UNALIGNED_INT_ASM_OP, (unsigned) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA8\n-#define ASM_OUTPUT_DWARF_DATA8(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%lx\", UNALIGNED_DOUBLE_INT_ASM_OP, \\\n-\t   (unsigned long) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA\n-#define ASM_OUTPUT_DWARF_DATA(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%lx\", UNALIGNED_OFFSET_ASM_OP, \\\n-\t   (unsigned long) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR_DATA\n-#define ASM_OUTPUT_DWARF_ADDR_DATA(FILE,VALUE) \\\n-  fprintf ((FILE), \"%s0x%lx\", UNALIGNED_WORD_ASM_OP, \\\n-\t   (unsigned long) (VALUE))\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_CONST_DOUBLE\n-#define ASM_OUTPUT_DWARF_CONST_DOUBLE(FILE,HIGH_VALUE,LOW_VALUE)\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (WORDS_BIG_ENDIAN)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"%s0x%lx\\n\", UNALIGNED_INT_ASM_OP, (HIGH_VALUE));\\\n-\tfprintf ((FILE), \"%s0x%lx\", UNALIGNED_INT_ASM_OP, (LOW_VALUE));\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"%s0x%lx\\n\", UNALIGNED_INT_ASM_OP, (LOW_VALUE)); \\\n-\tfprintf ((FILE), \"%s0x%lx\", UNALIGNED_INT_ASM_OP, (HIGH_VALUE)); \\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-#endif\n-\n-#else /* UNALIGNED_INT_ASM_OP */\n-\n-/* We don't have unaligned support, let's hope the normal output works for\n-   .debug_frame.  But we know it won't work for .debug_info.  */\n-\n-#ifdef DWARF2_DEBUGGING_INFO\n- #error DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR\n-#define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL) \\\n-  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, LABEL), DWARF2_ADDR_SIZE, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR_CONST\n-#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE,RTX) ASM_OUTPUT_DWARF_ADDR (FILE,RTX)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_OFFSET4\n-#define ASM_OUTPUT_DWARF_OFFSET4(FILE,LABEL) \\\n-  assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_OFFSET\n-#define ASM_OUTPUT_DWARF_OFFSET(FILE,LABEL) \\\n-  assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA2\n-#define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx_MINUS (HImode,\t\t\t      \t\\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),  \\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n-\t\t    2, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA4\n-#define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx_MINUS (SImode,\t\t\t      \t\\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),  \\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n-\t\t    4, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_ADDR_DELTA\n-#define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx_MINUS (Pmode,\t\t\t\t\\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL1),\t\\\n-\t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n-\t\t    DWARF2_ADDR_SIZE, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DELTA\n-#define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2) \\\n-  ASM_OUTPUT_DWARF_DELTA4 (FILE,LABEL1,LABEL2)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA2\n-#define ASM_OUTPUT_DWARF_DATA2(FILE,VALUE) \\\n-  assemble_integer (GEN_INT (VALUE), 2, 1)\n-#endif\n-\n-#ifndef ASM_OUTPUT_DWARF_DATA4\n-#define ASM_OUTPUT_DWARF_DATA4(FILE,VALUE) \\\n-  assemble_integer (GEN_INT (VALUE), 4, 1)\n-#endif\n-\n-#endif /* UNALIGNED_INT_ASM_OP */\n-\n #ifdef SET_ASM_OP\n #ifndef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n #define ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL(FILE, SY, HI, LO)    \t\\\n@@ -543,35 +321,6 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n #endif\n #endif /* SET_ASM_OP */\n \n-/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing\n-   newline is produced.  When flag_debug_asm is asserted, we add commentary\n-   at the end of the line, so we must avoid output of a newline here.  */\n-#ifndef ASM_OUTPUT_DWARF_NSTRING\n-#define ASM_OUTPUT_DWARF_NSTRING(FILE,P,SLEN) \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    register int slen = (SLEN);                                               \\\n-    register const char *p = (P);  \t                                      \\\n-    register int i;\t\t\t\t\t                      \\\n-    fprintf (FILE, \"\\t.ascii \\\"\");\t\t\t\t              \\\n-    for (i = 0; i < slen; i++)\t\t\t\t\t              \\\n-      {\t\t\t\t\t\t\t\t              \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n-\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n-\t    putc ('\\\\', FILE);\t\t\t\t\t              \\\n-\t  if (ISPRINT(c)) \t\t\t\t\t\t      \\\n-\t    putc (c, FILE);\t\t\t\t\t              \\\n-\t  else\t\t\t\t\t\t\t\t      \\\n-\t    {\t\t\t\t\t\t\t\t      \\\n-\t      fprintf (FILE, \"\\\\%o\", c);\t\t\t              \\\n-\t    }\t\t\t\t\t\t\t \t      \\\n-      }\t\t\t\t\t\t\t\t              \\\n-    fprintf (FILE, \"\\\\0\\\"\");\t\t\t\t\t              \\\n-  }\t\t\t\t\t\t\t\t\t      \\\n-  while (0)\n-#endif\n-#define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n-  ASM_OUTPUT_DWARF_NSTRING (FILE, P, strlen (P))\n-\n /* The DWARF 2 CFA column which tracks the return address.  Normally this\n    is the column for PC, or the first column after all of the hard\n    registers.  */\n@@ -1732,9 +1481,6 @@ dwarf2out_frame_debug (insn)\n \n   if (insn == NULL_RTX)\n     {\n-      rtx insn;\n-      int n_alternate_entry_points;\n-\n       /* Set up state for generating call frame debug info.  */\n       lookup_cfa (&cfa);\n       if (cfa.reg != (unsigned long) DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM))\n@@ -1763,105 +1509,6 @@ dwarf2out_frame_debug (insn)\n   dwarf2out_frame_debug_expr (insn, label);\n }\n \n-/* Return the size of an unsigned LEB128 quantity.  */\n-\n-static inline unsigned long\n-size_of_uleb128 (value)\n-     register unsigned long value;\n-{\n-  register unsigned long size = 0;\n-  register unsigned byte;\n-\n-  do\n-    {\n-      byte = (value & 0x7f);\n-      value >>= 7;\n-      size += 1;\n-    }\n-  while (value != 0);\n-\n-  return size;\n-}\n-\n-/* Return the size of a signed LEB128 quantity.  */\n-\n-static inline unsigned long\n-size_of_sleb128 (value)\n-     register long value;\n-{\n-  register unsigned long size = 0;\n-  register unsigned byte;\n-\n-  do\n-    {\n-      byte = (value & 0x7f);\n-      value >>= 7;\n-      size += 1;\n-    }\n-  while (!(((value == 0) && ((byte & 0x40) == 0))\n-\t   || ((value == -1) && ((byte & 0x40) != 0))));\n-\n-  return size;\n-}\n-\n-/* Output an unsigned LEB128 quantity.  */\n-\n-static void\n-output_uleb128 (value)\n-     register unsigned long value;\n-{\n-  unsigned long save_value = value;\n-\n-  fprintf (asm_out_file, \"%s\", ASM_BYTE_OP);\n-  do\n-    {\n-      register unsigned byte = (value & 0x7f);\n-      value >>= 7;\n-      if (value != 0)\n-\t/* More bytes to follow.  */\n-\tbyte |= 0x80;\n-\n-      fprintf (asm_out_file, \"0x%x\", byte);\n-      if (value != 0)\n-\tfprintf (asm_out_file, \",\");\n-    }\n-  while (value != 0);\n-\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s ULEB128 0x%lx\", ASM_COMMENT_START, save_value);\n-}\n-\n-/* Output an signed LEB128 quantity.  */\n-\n-static void\n-output_sleb128 (value)\n-     register long value;\n-{\n-  register int more;\n-  register unsigned byte;\n-  long save_value = value;\n-\n-  fprintf (asm_out_file, \"%s\", ASM_BYTE_OP);\n-  do\n-    {\n-      byte = (value & 0x7f);\n-      /* arithmetic shift */\n-      value >>= 7;\n-      more = !((((value == 0) && ((byte & 0x40) == 0))\n-\t\t|| ((value == -1) && ((byte & 0x40) != 0))));\n-      if (more)\n-\tbyte |= 0x80;\n-\n-      fprintf (asm_out_file, \"0x%x\", byte);\n-      if (more)\n-\tfprintf (asm_out_file, \",\");\n-    }\n-\n-  while (more);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s SLEB128 %ld\", ASM_COMMENT_START, save_value);\n-}\n-\n /* Output a Call Frame Information opcode and its operand(s).  */\n \n static void\n@@ -1871,114 +1518,79 @@ output_cfi (cfi, fde)\n {\n   if (cfi->dw_cfi_opc == DW_CFA_advance_loc)\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t      cfi->dw_cfi_opc\n-\t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_offset & 0x3f));\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_CFA_advance_loc 0x%lx\",\n-\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, (cfi->dw_cfi_opc\n+\t\t\t       | (cfi->dw_cfi_oprnd1.dw_cfi_offset & 0x3f)),\n+\t\t\t   \"DW_CFA_advance_loc 0x%lx\",\n+\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_offset);\n     }\n-\n   else if (cfi->dw_cfi_opc == DW_CFA_offset)\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t      cfi->dw_cfi_opc\n-\t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f));\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_CFA_offset, column 0x%lx\",\n-\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\n-      fputc ('\\n', asm_out_file);\n-      output_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, (cfi->dw_cfi_opc\n+\t\t\t       | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f)),\n+\t\t\t   \"DW_CFA_offset, column 0x%lx\",\n+\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n+      dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset, NULL);\n     }\n   else if (cfi->dw_cfi_opc == DW_CFA_restore)\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t      cfi->dw_cfi_opc\n-\t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f));\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_CFA_restore, column 0x%lx\",\n-\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, (cfi->dw_cfi_opc\n+\t\t\t       | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f)),\n+\t\t\t   \"DW_CFA_restore, column 0x%lx\",\n+\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n     }\n   else\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, cfi->dw_cfi_opc);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START,\n-\t\t dwarf_cfi_name (cfi->dw_cfi_opc));\n+      dw2_asm_output_data (1, cfi->dw_cfi_opc,\n+\t\t\t   \"%s\", dwarf_cfi_name (cfi->dw_cfi_opc));\n \n-      fputc ('\\n', asm_out_file);\n       switch (cfi->dw_cfi_opc)\n \t{\n \tcase DW_CFA_set_loc:\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, cfi->dw_cfi_oprnd1.dw_cfi_addr);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_offset (DWARF2_ADDR_SIZE, \n+\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr, NULL);\n \t  break;\n \tcase DW_CFA_advance_loc1:\n-\t  ASM_OUTPUT_DWARF_DELTA1 (asm_out_file,\n-\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\t   fde->dw_fde_current_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_delta (1, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n \tcase DW_CFA_advance_loc2:\n-\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file,\n-\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\t   fde->dw_fde_current_label);\n-          fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_delta (2, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n \tcase DW_CFA_advance_loc4:\n-\t  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n-\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-\t\t\t\t   fde->dw_fde_current_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_delta (4, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n-#ifdef MIPS_DEBUGGING_INFO\n \tcase DW_CFA_MIPS_advance_loc8:\n-\t  /* TODO: not currently implemented.  */\n-\t  abort ();\n+\t  dw2_asm_output_delta (8, cfi->dw_cfi_oprnd1.dw_cfi_addr,\n+\t\t\t\tfde->dw_fde_current_label, NULL);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n-#endif\n \tcase DW_CFA_offset_extended:\n \tcase DW_CFA_GNU_negative_offset_extended:\n \tcase DW_CFA_def_cfa:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, NULL);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset, NULL);\n \t  break;\n \tcase DW_CFA_restore_extended:\n \tcase DW_CFA_undefined:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\t  fputc ('\\n', asm_out_file);\n-\t  break;\n \tcase DW_CFA_same_value:\n \tcase DW_CFA_def_cfa_register:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, NULL);\n \t  break;\n \tcase DW_CFA_register:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_reg_num);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num, NULL);\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_reg_num, NULL);\n \t  break;\n \tcase DW_CFA_def_cfa_offset:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t  fputc ('\\n', asm_out_file);\n+\tcase DW_CFA_GNU_args_size:\n+\t  dw2_asm_output_data_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset, NULL);\n \t  break;\n \tcase DW_CFA_GNU_window_save:\n \t  break;\n-\tcase DW_CFA_GNU_args_size:\n-\t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-\t  fputc ('\\n', asm_out_file);\n-\t  break;\n \tcase DW_CFA_def_cfa_expression:\n \t  output_cfa_loc (cfi);\n \t  break;\n@@ -2018,8 +1630,6 @@ output_call_frame_info (for_eh)\n     found:;\n     }\n \n-  fputc ('\\n', asm_out_file);\n-\n   /* We're going to be generating comments, so turn on app.  */\n   if (flag_debug_asm)\n     app_enable ();\n@@ -2046,91 +1656,43 @@ output_call_frame_info (for_eh)\n   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n #ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n   ASM_GENERATE_INTERNAL_LABEL (ld, CIE_LENGTH_LABEL, for_eh);\n-  if (for_eh)\n-    ASM_OUTPUT_DWARF_OFFSET4 (asm_out_file, ld);\n-  else\n-    ASM_OUTPUT_DWARF_OFFSET (asm_out_file, ld);\n+  dw2_asm_output_offset (for_eh ? 4 : DWARF_OFFSET_SIZE, ld,\n+\t\t\t\"Length of Common Information Entry\");\n #else\n-  if (for_eh)\n-    ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, l2, l1);\n-  else\n-    ASM_OUTPUT_DWARF_DELTA (asm_out_file, l2, l1);\n+  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t\"Length of Common Information Entry\");\n #endif\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Length of Common Information Entry\",\n-\t     ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  if (for_eh)\n-    /* Now that the CIE pointer is PC-relative for EH,\n-       use 0 to identify the CIE.  */\n-    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n-  else\n-    ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n-\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s CIE Identifier Tag\", ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n-  if (! for_eh && DWARF_OFFSET_SIZE == 8)\n-    {\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, DW_CIE_ID);\n-      fputc ('\\n', asm_out_file);\n-    }\n+  /* Now that the CIE pointer is PC-relative for EH,\n+     use 0 to identify the CIE.  */\n+  dw2_asm_output_data ((for_eh ? 4 : DWARF_OFFSET_SIZE),\n+\t\t       (for_eh ? 0 : DW_CIE_ID),\n+\t\t       \"CIE Identifier Tag\");\n \n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_CIE_VERSION);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s CIE Version\", ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DW_CIE_VERSION, \"CIE Version\");\n \n-  fputc ('\\n', asm_out_file);\n   if (eh_ptr)\n     {\n       /* The CIE contains a pointer to the exception region info for the\n          frame.  Make the augmentation string three bytes (including the\n          trailing null) so the pointer is 4-byte aligned.  The Solaris ld\n          can't handle unaligned relocs.  */\n-      if (flag_debug_asm)\n-\t{\n-\t  ASM_OUTPUT_DWARF_STRING (asm_out_file, \"eh\");\n-\t  fprintf (asm_out_file, \"\\t%s CIE Augmentation\", ASM_COMMENT_START);\n-\t}\n-      else\n-\t{\n-\t  ASM_OUTPUT_ASCII (asm_out_file, \"eh\", 3);\n-\t}\n-      fputc ('\\n', asm_out_file);\n-\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, \"__EXCEPTION_TABLE__\");\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s pointer to exception region info\",\n-\t\t ASM_COMMENT_START);\n+      dw2_asm_output_nstring (\"eh\", 3, \"CIE Augmentation\");\n+      dw2_asm_output_offset (DWARF2_ADDR_SIZE, \"__EXCEPTION_TABLE__\",\n+\t\t\t     \"pointer to exception region info\");\n     }\n   else\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s CIE Augmentation (none)\",\n-\t\t ASM_COMMENT_START);\n+      dw2_asm_output_data (1, 0, \"CIE Augmentation (none)\");\n     }\n \n-  fputc ('\\n', asm_out_file);\n-  output_uleb128 (1);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \" (CIE Code Alignment Factor)\");\n+  dw2_asm_output_data_uleb128 (1, \"CIE Code Alignment Factor\");\n \n-  fputc ('\\n', asm_out_file);\n-  output_sleb128 (DWARF_CIE_DATA_ALIGNMENT);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \" (CIE Data Alignment Factor)\");\n-\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF_FRAME_RETURN_COLUMN);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s CIE RA Column\", ASM_COMMENT_START);\n+  dw2_asm_output_data_sleb128 (DWARF_CIE_DATA_ALIGNMENT,\n+\t\t\t       \"CIE Data Alignment Factor\");\n \n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (1, DWARF_FRAME_RETURN_COLUMN, \"CIE RA Column\");\n \n   for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n     output_cfi (cfi, NULL);\n@@ -2154,23 +1716,16 @@ output_call_frame_info (for_eh)\n       if (for_eh && fde->nothrow)\n \tcontinue;\n \n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, FDE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n #ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n       ASM_GENERATE_INTERNAL_LABEL (ld, FDE_LENGTH_LABEL, for_eh + i * 2);\n-      if (for_eh)\n-\tASM_OUTPUT_DWARF_OFFSET4 (asm_out_file, ld);\n-      else\n-\tASM_OUTPUT_DWARF_OFFSET (asm_out_file, ld);\n+      dw2_asm_output_offset (for_eh ? 4 : DWARF_OFFSET_SIZE, ld, \"FDE Length\");\n #else\n-      if (for_eh)\n-\tASM_OUTPUT_DWARF_DELTA4 (asm_out_file, l2, l1);\n-      else\n-\tASM_OUTPUT_DWARF_DELTA (asm_out_file, l2, l1);\n+      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t    \"FDE Length\");\n #endif\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s FDE Length\", ASM_COMMENT_START);\n-      fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n       /* ??? This always emits a 4 byte offset when for_eh is true, but it\n@@ -2182,24 +1737,17 @@ output_call_frame_info (for_eh)\n \t If the for_eh case is changed, then the struct in frame.c has\n \t to be adjusted appropriately.  */\n       if (for_eh)\n-\tASM_OUTPUT_DWARF_DELTA4 (asm_out_file, l1, \"__FRAME_BEGIN__\");\n+\tdw2_asm_output_delta (4, l1, \"__FRAME_BEGIN__\", \"FDE CIE offset\");\n       else\n-\tASM_OUTPUT_DWARF_OFFSET (asm_out_file, stripattributes (FRAME_SECTION));\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s FDE CIE offset\", ASM_COMMENT_START);\n+\tdw2_asm_output_offset (DWARF_OFFSET_SIZE,\n+\t\t\t       stripattributes (FRAME_SECTION),\n+\t\t\t       \"FDE CIE offset\");\n \n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, fde->dw_fde_begin);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s FDE initial location\", ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file,\n-\t\t\t\t   fde->dw_fde_end, fde->dw_fde_begin);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s FDE address range\", ASM_COMMENT_START);\n+      dw2_asm_output_offset (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n+\t\t\t     \"FDE initial location\");\n \n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde->dw_fde_end,\n+\t\t\t    fde->dw_fde_begin, \"FDE address range\");\n \n       /* Loop through the Call Frame Instructions associated with\n \t this FDE.  */\n@@ -2217,13 +1765,10 @@ output_call_frame_info (for_eh)\n       fputc ('\\n', asm_out_file);\n #endif\n     }\n+\n #ifndef EH_FRAME_SECTION\n   if (for_eh)\n-    {\n-      /* Emit terminating zero for table.  */\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n-      fputc ('\\n', asm_out_file);\n-    }\n+    dw2_asm_output_data (4, 0, \"End of Table\");\n #endif\n #ifdef MIPS_DEBUGGING_INFO\n   /* Work around Irix 6 assembler bug whereby labels at the end of a section\n@@ -2902,23 +2447,21 @@ output_loc_operands (loc)\n     {\n #ifdef DWARF2_DEBUGGING_INFO\n     case DW_OP_addr:\n-      ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file, val1->v.val_addr);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, val1->v.val_addr, NULL);\n       break;\n     case DW_OP_const2u:\n     case DW_OP_const2s:\n-      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (2, val1->v.val_int, NULL);\n       break;\n     case DW_OP_const4u:\n     case DW_OP_const4s:\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (4, val1->v.val_int, NULL);\n       break;\n     case DW_OP_const8u:\n     case DW_OP_const8s:\n-      abort ();\n-      fputc ('\\n', asm_out_file);\n+      if (HOST_BITS_PER_LONG < 64)\n+\tabort ();\n+      dw2_asm_output_data (8, val1->v.val_int, NULL);\n       break;\n     case DW_OP_skip:\n     case DW_OP_bra:\n@@ -2930,8 +2473,7 @@ output_loc_operands (loc)\n \telse\n \t  abort ();\n \n-\tASM_OUTPUT_DWARF_DATA2 (asm_out_file, offset);\n-\tfputc ('\\n', asm_out_file);\n+\tdw2_asm_output_data (2, offset, NULL);\n       }\n       break;\n #else\n@@ -2952,24 +2494,19 @@ output_loc_operands (loc)\n #endif\n     case DW_OP_const1u:\n     case DW_OP_const1s:\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, val1->v.val_flag);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, val1->v.val_int, NULL);\n       break;\n     case DW_OP_constu:\n-      output_uleb128 (val1->v.val_unsigned);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n       break;\n     case DW_OP_consts:\n-      output_sleb128 (val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);\n       break;\n     case DW_OP_pick:\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, val1->v.val_int, NULL);\n       break;\n     case DW_OP_plus_uconst:\n-      output_uleb128 (val1->v.val_unsigned);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n       break;\n     case DW_OP_breg0:\n     case DW_OP_breg1:\n@@ -3003,31 +2540,24 @@ output_loc_operands (loc)\n     case DW_OP_breg29:\n     case DW_OP_breg30:\n     case DW_OP_breg31:\n-      output_sleb128 (val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);\n       break;\n     case DW_OP_regx:\n-      output_uleb128 (val1->v.val_unsigned);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n       break;\n     case DW_OP_fbreg:\n-      output_sleb128 (val1->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_sleb128 (val1->v.val_int, NULL);\n       break;\n     case DW_OP_bregx:\n-      output_uleb128 (val1->v.val_unsigned);\n-      fputc ('\\n', asm_out_file);\n-      output_sleb128 (val2->v.val_int);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n+      dw2_asm_output_data_sleb128 (val2->v.val_int, NULL);\n       break;\n     case DW_OP_piece:\n-      output_uleb128 (val1->v.val_unsigned);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n       break;\n     case DW_OP_deref_size:\n     case DW_OP_xderef_size:\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, val1->v.val_flag);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, val1->v.val_int, NULL);\n       break;\n     default:\n       /* Other codes have no operands.  */\n@@ -3044,12 +2574,8 @@ output_loc_sequence (loc)\n   for (; loc != NULL; loc = loc->dw_loc_next)\n     {\n       /* Output the opcode.  */\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, loc->dw_loc_opc);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START,\n-\t\t dwarf_stack_op_name (loc->dw_loc_opc));\n-\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, loc->dw_loc_opc,\n+\t\t\t   \"%s\", dwarf_stack_op_name (loc->dw_loc_opc));\n \n       /* Output the operand(s) (if any).  */\n       output_loc_operands (loc);\n@@ -3069,8 +2595,7 @@ output_cfa_loc (cfi)\n   /* Output the size of the block.  */\n   loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n   size = size_of_locs (loc);\n-  output_uleb128 (size);\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data_uleb128 (size, NULL);\n \n   /* Now output the operations themselves.  */\n   output_loc_sequence (loc);\n@@ -3665,7 +3190,6 @@ static enum dwarf_form value_format\tPARAMS ((dw_attr_ref));\n static void output_value_format\t\tPARAMS ((dw_attr_ref));\n static void output_abbrev_section\tPARAMS ((void));\n static void output_die_symbol\t\tPARAMS ((dw_die_ref));\n-static void output_symbolic_ref\t\tPARAMS ((dw_die_ref));\n static void output_die\t\t\tPARAMS ((dw_die_ref));\n static void output_compilation_unit_header PARAMS ((void));\n static void output_comp_unit\t\tPARAMS ((dw_die_ref));\n@@ -5799,7 +5323,7 @@ size_of_die (die)\n \t  size += constant_size (AT_unsigned (a));\n \t  break;\n \tcase dw_val_class_long_long:\n-\t  size += 1 + 8; /* block */\n+\t  size += 1 + 2*HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR; /* block */\n \t  break;\n \tcase dw_val_class_float:\n \t  size += 1 + a->dw_attr_val.v.val_float.length * 4; /* block */\n@@ -6023,12 +5547,7 @@ output_value_format (a)\n      dw_attr_ref a;\n {\n   enum dwarf_form form = value_format (a);\n-\n-  output_uleb128 (form);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \" (%s)\", dwarf_form_name (form));\n-\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data_uleb128 (form, \"(%s)\", dwarf_form_name (form));\n }\n \n /* Output the .debug_abbrev section which defines the DIE abbreviation\n@@ -6044,45 +5563,30 @@ output_abbrev_section ()\n     {\n       register dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n \n-      output_uleb128 (abbrev_id);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \" (abbrev code)\");\n+      dw2_asm_output_data_uleb128 (abbrev_id, \"(abbrev code)\");\n \n-      fputc ('\\n', asm_out_file);\n-      output_uleb128 (abbrev->die_tag);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \" (TAG: %s)\",\n-\t\t dwarf_tag_name (abbrev->die_tag));\n+      dw2_asm_output_data_uleb128 (abbrev->die_tag, \"(TAG: %s)\",\n+\t\t\t\t   dwarf_tag_name (abbrev->die_tag));\n \n-      fputc ('\\n', asm_out_file);\n-      fprintf (asm_out_file, \"%s0x%x\", ASM_BYTE_OP,\n-\t       abbrev->die_child != NULL ? DW_children_yes : DW_children_no);\n-\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s %s\",\n-\t\t ASM_COMMENT_START,\n-\t\t (abbrev->die_child != NULL\n-\t\t  ? \"DW_children_yes\" : \"DW_children_no\"));\n-\n-      fputc ('\\n', asm_out_file);\n+      if (abbrev->die_child != NULL)\n+\tdw2_asm_output_data (1, DW_children_yes, \"DW_children_yes\");\n+      else\n+\tdw2_asm_output_data (1, DW_children_no, \"DW_children_no\");\n \n       for (a_attr = abbrev->die_attr; a_attr != NULL;\n \t   a_attr = a_attr->dw_attr_next)\n \t{\n-\t  output_uleb128 (a_attr->dw_attr);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \" (%s)\",\n-\t\t     dwarf_attr_name (a_attr->dw_attr));\n-\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data_uleb128 (a_attr->dw_attr, \"(%s)\",\n+\t\t\t\t       dwarf_attr_name (a_attr->dw_attr));\n \t  output_value_format (a_attr);\n \t}\n \n-      fprintf (asm_out_file, \"%s0,0\\n\", ASM_BYTE_OP);\n+      dw2_asm_output_data (1, 0, NULL);\n+      dw2_asm_output_data (1, 0, NULL);\n     }\n \n   /* Terminate the table.  */\n-  fprintf (asm_out_file, \"%s0\\n\", ASM_BYTE_OP);\n+  dw2_asm_output_data (1, 0, NULL);\n }\n \n /* Output a symbol we can use to refer to this DIE from another CU.  */\n@@ -6104,20 +5608,6 @@ output_die_symbol (die)\n   ASM_OUTPUT_LABEL (asm_out_file, sym);\n }\n \n-/* Output a symbolic (i.e. FORM_ref_addr) reference to TARGET_DIE.  */\n-\n-static inline void\n-output_symbolic_ref (target_die)\n-     dw_die_ref target_die;\n-{\n-  char *sym = target_die->die_symbol;\n-\n-  if (sym == 0)\n-    abort ();\n-\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, sym);\n-}\n-\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -6134,42 +5624,24 @@ output_die (die)\n   if (die->die_symbol)\n     output_die_symbol (die);\n \n-  output_uleb128 (die->die_abbrev);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \" (DIE (0x%lx) %s)\",\n-\t     die->die_offset, dwarf_tag_name (die->die_tag));\n-\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data_uleb128 (die->die_abbrev, \"(DIE (0x%lx) %s)\",\n+\t\t\t       die->die_offset, dwarf_tag_name (die->die_tag));\n \n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n     {\n+      const char *name = dwarf_attr_name (a->dw_attr);\n+\n       switch (AT_class (a))\n \t{\n \tcase dw_val_class_addr:\n-\t  ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file, AT_addr (a));\n+\t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_loc:\n \t  size = size_of_locs (AT_loc (a));\n \n \t  /* Output the block length for this list of location operations.  */\n-\t  switch (constant_size (size))\n-\t    {\n-\t    case 1:\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, size);\n-\t      break;\n-\t    case 2:\n-\t      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, size);\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n-\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (constant_size (size), size, \"%s\", name);\n \n \t  output_loc_sequence (AT_loc (a));\n \t  break;\n@@ -6178,123 +5650,94 @@ output_die (die)\n \t  /* ??? It would be slightly more efficient to use a scheme like is\n \t     used for unsigned constants below, but gdb 4.x does not sign\n \t     extend.  Gdb 5.x does sign extend.  */\n-\t  output_sleb128 (AT_int (a));\n+\t  dw2_asm_output_data_sleb128 (AT_int (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_unsigned_const:\n-\t  switch (constant_size (AT_unsigned (a)))\n-\t    {\n-\t    case 1:\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, AT_unsigned (a));\n-\t      break;\n-\t    case 2:\n-\t      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, AT_unsigned (a));\n-\t      break;\n-\t    case 4:\n-\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, AT_unsigned (a));\n-\t      break;\n-\t    case 8:\n-\t      ASM_OUTPUT_DWARF_DATA8 (asm_out_file, AT_unsigned (a));\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n+\t  dw2_asm_output_data (constant_size (AT_unsigned (a)),\n+\t\t\t       AT_unsigned (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_long_long:\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 8);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_CONST_DOUBLE (asm_out_file,\n-\t\t\t\t\t a->dw_attr_val.v.val_long_long.hi,\n-\t\t\t\t\t a->dw_attr_val.v.val_long_long.low);\n+\t  {\n+\t    unsigned HOST_WIDE_INT first, second;\n \n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file,\n-\t\t     \"\\t%s long long constant\", ASM_COMMENT_START);\n+\t    dw2_asm_output_data (1, 2*HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR,\n+\t\t\t         \"%s\", name);\n \n-\t  fputc ('\\n', asm_out_file);\n+\t    if (WORDS_BIG_ENDIAN)\n+\t      {\n+\t\tfirst = a->dw_attr_val.v.val_long_long.hi;\n+\t\tsecond = a->dw_attr_val.v.val_long_long.low;\n+\t      }\n+\t    else\n+\t      {\n+\t\tfirst = a->dw_attr_val.v.val_long_long.low;\n+\t\tsecond = a->dw_attr_val.v.val_long_long.hi;\n+\t      }\n+\t    dw2_asm_output_data (HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR,\n+\t\t\t\t first, \"long long constant\");\n+\t    dw2_asm_output_data (HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR,\n+\t\t\t\t second, NULL);\n+\t  }\n \t  break;\n \n \tcase dw_val_class_float:\n \t  {\n \t    register unsigned int i;\n-\t    ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t    a->dw_attr_val.v.val_float.length * 4);\n-\t    if (flag_debug_asm)\n-\t      fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t       ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n \n-\t    fputc ('\\n', asm_out_file);\n-\t    for (i = 0; i < a->dw_attr_val.v.val_float.length; ++i)\n-\t      {\n-\t\tASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t\t\ta->dw_attr_val.v.val_float.array[i]);\n-\t\tif (flag_debug_asm)\n-\t\t  fprintf (asm_out_file, \"\\t%s fp constant word %u\",\n-\t\t\t   ASM_COMMENT_START, i);\n+\t    dw2_asm_output_data (1, a->dw_attr_val.v.val_float.length * 4,\n+\t\t\t         \"%s\", name);\n \n-\t\tfputc ('\\n', asm_out_file);\n-\t      }\n+\t    for (i = 0; i < a->dw_attr_val.v.val_float.length; ++i)\n+\t      dw2_asm_output_data (4, a->dw_attr_val.v.val_float.array[i],\n+\t\t\t\t   \"fp constant word %u\", i);\n \t    break;\n \t  }\n \n \tcase dw_val_class_flag:\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, AT_flag (a));\n+\t  dw2_asm_output_data (1, AT_flag (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n-\t    output_symbolic_ref (AT_ref (a));\n+\t    {\n+\t      char *sym = AT_ref (a)->die_symbol;\n+\t      if (sym == 0)\n+\t\tabort ();\n+\t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, sym, \"%s\", name);\n+\t    }\n \t  else if (AT_ref (a)->die_offset == 0)\n \t    abort ();\n \t  else\n-\t    ASM_OUTPUT_DWARF_DATA (asm_out_file, AT_ref (a)->die_offset);\n+\t    dw2_asm_output_data (DWARF_OFFSET_SIZE, AT_ref (a)->die_offset,\n+\t\t\t\t \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_fde_ref:\n \t  {\n \t    char l1[20];\n-\t    ASM_GENERATE_INTERNAL_LABEL\n-\t      (l1, FDE_AFTER_SIZE_LABEL, a->dw_attr_val.v.val_fde_index * 2);\n-\t    ASM_OUTPUT_DWARF_OFFSET (asm_out_file, l1);\n-\t    fprintf (asm_out_file, \" - %d\", DWARF_OFFSET_SIZE);\n+\t    ASM_GENERATE_INTERNAL_LABEL (l1, FDE_LABEL,\n+\t\t\t\t\t a->dw_attr_val.v.val_fde_index * 2);\n+\t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, l1, \"%s\", name);\n \t  }\n \t  break;\n \n \tcase dw_val_class_lbl_id:\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, AT_lbl (a));\n+\t  dw2_asm_output_offset (DWARF2_ADDR_SIZE, AT_lbl (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_lbl_offset:\n-\t  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, AT_lbl (a));\n+\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a), \"%s\", name);\n \t  break;\n \n \tcase dw_val_class_str:\n-\t  if (flag_debug_asm)\n-\t    ASM_OUTPUT_DWARF_STRING (asm_out_file, AT_string (a));\n-\t  else\n-\t    ASM_OUTPUT_ASCII (asm_out_file, AT_string (a),\n-\t\t\t      (int) strlen (AT_string (a)) + 1);\n+\t  dw2_asm_output_nstring (AT_string (a), -1, \"%s\", name);\n \t  break;\n \n \tdefault:\n \t  abort ();\n \t}\n-\n-      if (AT_class (a) != dw_val_class_loc\n-\t  && AT_class (a) != dw_val_class_long_long\n-\t  && AT_class (a) != dw_val_class_float)\n-\t{\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n     }\n \n   for (c = die->die_child; c != NULL; c = c->die_sib)\n@@ -6303,12 +5746,8 @@ output_die (die)\n   if (die->die_child != NULL)\n     {\n       /* Add null byte to terminate sibling list.  */\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s end of children of DIE 0x%lx\",\n-\t\t ASM_COMMENT_START, die->die_offset);\n-\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, 0, \"end of children of DIE 0x%lx\",\n+\t\t\t   die->die_offset);\n     }\n }\n \n@@ -6318,28 +5757,15 @@ output_die (die)\n static void\n output_compilation_unit_header ()\n {\n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_die_offset - DWARF_OFFSET_SIZE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Length of Compilation Unit Info.\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset - DWARF_OFFSET_SIZE,\n+\t\t       \"Length of Compilation Unit Info\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DWARF version number\", ASM_COMMENT_START);\n+  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF version number\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, abbrev_section_label);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Offset Into Abbrev. Section\",\n-\t     ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF2_ADDR_SIZE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Pointer Size (in bytes)\", ASM_COMMENT_START);\n+  dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n+\t\t\t \"Offset Into Abbrev. Section\");\n \n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n }\n \n /* Output the compilation unit DIE and its children.  */\n@@ -6373,7 +5799,6 @@ output_comp_unit (die)\n     secname = (const char *) DEBUG_INFO_SECTION;\n \n   /* Output debugging information.  */\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, secname);\n   output_compilation_unit_header ();\n   output_die (die);\n@@ -6431,30 +5856,17 @@ output_pubnames ()\n   register unsigned i;\n   register unsigned long pubnames_length = size_of_pubnames ();\n \n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, pubnames_length);\n-\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Length of Public Names Info.\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n+\t\t       \"Length of Public Names Info\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n-\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n+  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, debug_info_section_label);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+\t\t\t \"Offset of Compilation Unit Info\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_die_offset);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Compilation Unit Length\", ASM_COMMENT_START);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n+\t\t       \"Compilation Unit Length\");\n \n-  fputc ('\\n', asm_out_file);\n   for (i = 0; i < pubname_table_in_use; ++i)\n     {\n       register pubname_ref pub = &pubname_table[i];\n@@ -6463,28 +5875,13 @@ output_pubnames ()\n       if (pub->die->die_mark == 0)\n \tabort ();\n \n-      ASM_OUTPUT_DWARF_DATA (asm_out_file, pub->die->die_offset);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DIE offset\", ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n-\n-      if (flag_debug_asm)\n-\t{\n-\t  ASM_OUTPUT_DWARF_STRING (asm_out_file, pub->name);\n-\t  fprintf (asm_out_file, \"%s external name\", ASM_COMMENT_START);\n-\t}\n-      else\n-\t{\n-\t  ASM_OUTPUT_ASCII (asm_out_file, pub->name,\n-\t\t\t    (int) strlen (pub->name) + 1);\n-\t}\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE, pub->die->die_offset,\n+\t\t\t   \"DIE offset\");\n \n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_nstring (pub->name, -1, \"external name\");\n     }\n \n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, 0);\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);\n }\n \n /* Add a new entry to .debug_aranges if appropriate.  */\n@@ -6518,60 +5915,33 @@ output_aranges ()\n   register unsigned i;\n   register unsigned long aranges_length = size_of_aranges ();\n \n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, aranges_length);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Length of Address Ranges Info.\",\n-\t     ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n+\t\t       \"Length of Address Ranges Info\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_OFFSET (asm_out_file, debug_info_section_label);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Offset of Compilation Unit Info.\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF2_ADDR_SIZE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Size of Address\", ASM_COMMENT_START);\n+  dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n+\t\t\t \"Offset of Compilation Unit Info\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Size of Segment Descriptor\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Size of Address\");\n \n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (1, 0, \"Size of Segment Descriptor\");\n \n   /* We need to align to twice the pointer size here.  */\n   if (DWARF_ARANGES_PAD_SIZE)\n     {\n-      /* Pad using a 2 bytes word so that padding is correct\n-         for any pointer size.  */\n-      ASM_OUTPUT_DWARF_DATA2 (asm_out_file, 0);\n+      /* Pad using a 2 byte words so that padding is correct for any\n+         pointer size.  */\n+      dw2_asm_output_data (2, 0, \"Pad to %d byte boundary\",\n+\t\t\t   2 * DWARF2_ADDR_SIZE);\n       for (i = 2; i < (unsigned) DWARF_ARANGES_PAD_SIZE; i += 2)\n-\tfprintf (asm_out_file, \",0\");\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s Pad to %d byte boundary\",\n-\t\t ASM_COMMENT_START, 2 * DWARF2_ADDR_SIZE);\n+\tdw2_asm_output_data (2, 0, NULL);\n     }\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR (asm_out_file, text_section_label);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n+  dw2_asm_output_offset (DWARF2_ADDR_SIZE, text_section_label, \"Address\");\n+  dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\ttext_section_label, \"Length\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, text_end_label,\n-\t\t\t       text_section_label);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n   for (i = 0; i < arange_table_in_use; ++i)\n     {\n       dw_die_ref die = arange_table[i];\n@@ -6581,7 +5951,12 @@ output_aranges ()\n \tabort ();\n \n       if (die->die_tag == DW_TAG_subprogram)\n-\tASM_OUTPUT_DWARF_ADDR (asm_out_file, get_AT_low_pc (die));\n+\t{\n+\t  dw2_asm_output_offset (DWARF2_ADDR_SIZE, get_AT_low_pc (die),\n+\t\t\t\t \"Address\");\n+\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, get_AT_hi_pc (die),\n+\t\t\t\tget_AT_low_pc (die), \"Length\");\n+\t}\n       else\n \t{\n \t  /* A static variable; extract the symbol from DW_AT_location.\n@@ -6597,32 +5972,17 @@ output_aranges ()\n \t  if (loc->dw_loc_opc != DW_OP_addr)\n \t    abort ();\n \n-\t  ASM_OUTPUT_DWARF_ADDR_CONST (asm_out_file,\n-\t\t\t\t       loc->dw_loc_oprnd1.v.val_addr);\n+\t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE,\n+\t\t\t\t   loc->dw_loc_oprnd1.v.val_addr, \"Address\");\n+\t  dw2_asm_output_data (DWARF2_ADDR_SIZE,\n+\t\t\t       get_AT_unsigned (die, DW_AT_byte_size),\n+\t\t\t       \"Length\");\n \t}\n-\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s Address\", ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n-      if (die->die_tag == DW_TAG_subprogram)\n-\tASM_OUTPUT_DWARF_ADDR_DELTA (asm_out_file, get_AT_hi_pc (die),\n-\t\t\t\t     get_AT_low_pc (die));\n-      else\n-\tASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file,\n-\t\t\t\t    get_AT_unsigned (die, DW_AT_byte_size));\n-\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"%s Length\", ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n     }\n \n   /* Output the terminator words.  */\n-  ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_ADDR_DATA (asm_out_file, 0);\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n+  dw2_asm_output_data (DWARF2_ADDR_SIZE, 0, NULL);\n }\n \n \n@@ -6930,69 +6290,35 @@ output_file_names ()\n     if (dirs[i].used != 0)\n       {\n \tdirs[i].used = idx++;\n-\n-\tif (flag_debug_asm)\n-\t  {\n-\t    ASM_OUTPUT_DWARF_NSTRING (asm_out_file,\n-\t\t\t\t      dirs[i].path, dirs[i].length - 1);\n-\t    fprintf (asm_out_file, \"%s Directory Entry: 0x%x\\n\",\n-\t\t     ASM_COMMENT_START, dirs[i].used);\n-\t  }\n-\telse\n-\t  {\n-\t    ASM_OUTPUT_ASCII (asm_out_file, dirs[i].path, dirs[i].length - 1);\n-\t    ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t    fputc ('\\n', asm_out_file);\n-\t  }\n+\tdw2_asm_output_nstring (dirs[i].path, dirs[i].length - 1,\n+\t\t\t\t\"Directory Entry: 0x%x\", dirs[i].used);\n       }\n+  dw2_asm_output_data (1, 0, \"End directory table\");\n+\n   /* Correct the index for the current working directory entry if it\n      exists.  */\n   if (idx_offset == 0)\n     dirs[0].used = 0;\n-  /* Terminate the directory name array.  */\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s End directory table\", ASM_COMMENT_START);\n-  fputc ('\\n', asm_out_file);\n \n   /* Now write all the file names.  */\n   for (i = 1; i < (int) line_file_table.in_use; ++i)\n     {\n       int file_idx = backmap[i];\n       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n \n-      if (flag_debug_asm)\n-\t{\n-\t  ASM_OUTPUT_DWARF_STRING (asm_out_file,\n-\t\t\t\t   files[file_idx].path\n-\t\t\t\t   + dirs[dir_idx].length);\n-\t  fprintf (asm_out_file, \"%s File Entry: 0x%x\\n\",\n-\t\t   ASM_COMMENT_START, i);\n-\t}\n-      else\n-\tASM_OUTPUT_ASCII (asm_out_file,\n-\t\t\t  files[file_idx].path + dirs[dir_idx].length,\n-\t\t\t  (files[file_idx].length\n-\t\t\t   - dirs[dir_idx].length) + 1);\n+      dw2_asm_output_nstring (files[file_idx].path + dirs[dir_idx].length, -1,\n+\t\t\t      \"File Entry: 0x%x\", i);\n \n       /* Include directory index.  */\n-      output_uleb128 (dirs[dir_idx].used);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (dirs[dir_idx].used, NULL);\n \n       /* Modification time.  */\n-      output_uleb128 (0);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (0, NULL);\n \n       /* File length in bytes.  */\n-      output_uleb128 (0);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data_uleb128 (0, NULL);\n     }\n-\n-  /* Terminate the file name table */\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s End file name table\", ASM_COMMENT_START);\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (1, 0, \"End file name table\");\n }\n \n \n@@ -7002,6 +6328,7 @@ output_file_names ()\n static void\n output_line_info ()\n {\n+  char l1[20], l2[20];\n   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register unsigned opc;\n@@ -7013,52 +6340,33 @@ output_line_info ()\n   register unsigned long current_file;\n   register unsigned long function;\n \n-  ASM_OUTPUT_DWARF_DELTA (asm_out_file, \".LTEND\", \".LTSTART\");\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Length of Source Line Info.\",\n-\t     ASM_COMMENT_START);\n+  ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_LABEL (asm_out_file, \".LTSTART\");\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, DWARF_VERSION);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DWARF Version\", ASM_COMMENT_START);\n+  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t\"Length of Source Line Info\");\n+  ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, size_of_line_prolog ());\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Prolog Length\", ASM_COMMENT_START);\n+  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF_LINE_MIN_INSTR_LENGTH);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Minimum Instruction Length\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, size_of_line_prolog (),\n+\t\t       \"Prolog Length\");\n \n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DWARF_LINE_DEFAULT_IS_STMT_START);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Default is_stmt_start flag\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DWARF_LINE_MIN_INSTR_LENGTH,\n+\t\t       \"Minimum Instruction Length\");\n \n-  fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"%s%d\", ASM_BYTE_OP, DWARF_LINE_BASE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Line Base Value (Special Opcodes)\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DWARF_LINE_DEFAULT_IS_STMT_START,\n+\t\t       \"Default is_stmt_start flag\");\n \n-  fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"%s%u\", ASM_BYTE_OP, DWARF_LINE_RANGE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Line Range Value (Special Opcodes)\",\n-\t     ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DWARF_LINE_BASE,\n+\t\t       \"Line Base Value (Special Opcodes)\");\n \n-  fputc ('\\n', asm_out_file);\n-  fprintf (asm_out_file, \"%s%u\", ASM_BYTE_OP, DWARF_LINE_OPCODE_BASE);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s Special Opcode Base\", ASM_COMMENT_START);\n+  dw2_asm_output_data (1, DWARF_LINE_RANGE,\n+\t\t       \"Line Range Value (Special Opcodes)\");\n+\n+  dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE,\n+\t\t       \"Special Opcode Base\");\n \n-  fputc ('\\n', asm_out_file);\n   for (opc = 1; opc < DWARF_LINE_OPCODE_BASE; ++opc)\n     {\n       switch (opc)\n@@ -7074,11 +6382,9 @@ output_line_info ()\n \t  n_op_args = 0;\n \t  break;\n \t}\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, n_op_args);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s opcode: 0x%x has %d args\",\n-\t\t ASM_COMMENT_START, opc, n_op_args);\n-      fputc ('\\n', asm_out_file);\n+\n+      dw2_asm_output_data (1, n_op_args, \"opcode: 0x%x has %d args\",\n+\t\t\t   opc, n_op_args);\n     }\n \n   /* Write out the information about the files we use.  */\n@@ -7110,44 +6416,31 @@ output_line_info ()\n \tcontinue;\n #endif\n \n-      /* Emit debug info for the address of the current line, choosing\n-\t the encoding that uses the least amount of space.  */\n-      /* ??? Unfortunately, we have little choice here currently, and must\n-\t always use the most general form.  Gcc does not know the address\n-\t delta itself, so we can't use DW_LNS_advance_pc.  There are no known\n-\t dwarf2 aware assemblers at this time, so we can't use any special\n-\t pseudo ops that would allow the assembler to optimally encode this for\n-\t us.  Many ports do have length attributes which will give an upper\n-\t bound on the address range.  We could perhaps use length attributes\n-\t to determine when it is safe to use DW_LNS_fixed_advance_pc.  */\n+      /* Emit debug info for the address of the current line.\n+\n+\t Unfortunately, we have little choice here currently, and must always\n+\t use the most general form.  Gcc does not know the address delta\n+\t itself, so we can't use DW_LNS_advance_pc.  Many ports do have length\n+\t attributes which will give an upper bound on the address range.  We\n+\t could perhaps use length attributes to determine when it is safe to\n+\t use DW_LNS_fixed_advance_pc.  */\n+\n       ASM_GENERATE_INTERNAL_LABEL (line_label, LINE_CODE_LABEL, lt_index);\n       if (0)\n \t{\n \t  /* This can handle deltas up to 0xffff.  This takes 3 bytes.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t     ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n+\t\t\t       \"DW_LNS_fixed_advance_pc\");\n+\t  dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n \t}\n       else\n \t{\n \t  /* This can handle any delta.  This takes\n              4+DWARF2_ADDR_SIZE bytes.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n-\t\t     ASM_COMMENT_START);\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (1 + DWARF2_ADDR_SIZE);\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n+\t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+\t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+\t  dw2_asm_output_offset (DWARF2_ADDR_SIZE, line_label, NULL);\n \t}\n       strcpy (prev_line_label, line_label);\n \n@@ -7156,17 +6449,9 @@ output_line_info ()\n       if (line_info->dw_file_num != current_file)\n \t{\n \t  current_file = line_info->dw_file_num;\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_set_file);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_set_file\", ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (current_file);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \" (\\\"%s\\\")\",\n-\t\t     line_file_table.table[current_file]);\n-\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n+\t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n+\t\t\t\t       line_file_table.table[current_file]);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -7181,77 +6466,44 @@ output_line_info ()\n \t      /* This can handle deltas from -10 to 234, using the current\n \t\t definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This\n \t\t takes 1 byte.  */\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t      DWARF_LINE_OPCODE_BASE + line_delta);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file,\n-\t\t\t \"\\t%s line %ld\", ASM_COMMENT_START, current_line);\n-\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,\n+\t\t\t\t   \"line %lu\", current_line);\n \t    }\n \t  else\n \t    {\n \t      /* This can handle any delta.  This takes at least 4 bytes,\n \t\t depending on the value being encoded.  */\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s advance to line %ld\",\n-\t\t\t ASM_COMMENT_START, current_line);\n-\n-\t      fputc ('\\n', asm_out_file);\n-\t      output_sleb128 (line_offset);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, DW_LNS_advance_line,\n+\t\t\t\t   \"advance to line %lu\", current_line);\n+\t      dw2_asm_output_data_sleb128 (line_offset, NULL);\n+\t      dw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n \t    }\n \t}\n       else\n \t{\n \t  /* We still need to start a new row, so output a copy insn.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n \t}\n     }\n \n   /* Emit debug info for the address of the end of the function.  */\n   if (0)\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t ASM_COMMENT_START);\n-\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, text_end_label, prev_line_label);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n+\t\t\t   \"DW_LNS_fixed_advance_pc\");\n+      dw2_asm_output_delta (2, text_end_label, prev_line_label, NULL);\n     }\n   else\n     {\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-      if (flag_debug_asm)\n-\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\", ASM_COMMENT_START);\n-      fputc ('\\n', asm_out_file);\n-      output_uleb128 (1 + DWARF2_ADDR_SIZE);\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, text_end_label);\n-      fputc ('\\n', asm_out_file);\n+      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n+      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+      dw2_asm_output_offset (DWARF2_ADDR_SIZE, text_end_label, NULL);\n     }\n \n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-  if (flag_debug_asm)\n-    fprintf (asm_out_file, \"\\t%s DW_LNE_end_sequence\", ASM_COMMENT_START);\n-\n-  fputc ('\\n', asm_out_file);\n-  output_uleb128 (1);\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_end_sequence);\n-  fputc ('\\n', asm_out_file);\n+  dw2_asm_output_data (1, 0, \"DW_LNE_end_sequence\");\n+  dw2_asm_output_data_uleb128 (1, NULL);\n+  dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);\n \n   function = 0;\n   current_file = 1;\n@@ -7279,47 +6531,26 @@ output_line_info ()\n \t  function = line_info->function;\n \n \t  /* Set the address register to the first line in the function */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n-\t\t     ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (1 + DWARF2_ADDR_SIZE);\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n+\t  dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+\t  dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+\t  dw2_asm_output_offset (DWARF2_ADDR_SIZE, line_label, NULL);\n \t}\n       else\n \t{\n \t  /* ??? See the DW_LNS_advance_pc comment above.  */\n \t  if (0)\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t\t ASM_COMMENT_START);\n-\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label,\n-\t\t\t\t       prev_line_label);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n+\t\t\t\t   \"DW_LNS_fixed_advance_pc\");\n+\t      dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n \t    }\n \t  else\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n-\t\t\t ASM_COMMENT_START);\n-\t      fputc ('\\n', asm_out_file);\n-\t      output_uleb128 (1 + DWARF2_ADDR_SIZE);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n+\t      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+\t      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+\t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, line_label, NULL);\n \t    }\n \t}\n       strcpy (prev_line_label, line_label);\n@@ -7329,17 +6560,9 @@ output_line_info ()\n       if (line_info->dw_file_num != current_file)\n \t{\n \t  current_file = line_info->dw_file_num;\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_set_file);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_set_file\", ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (current_file);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \" (\\\"%s\\\")\",\n-\t\t     line_file_table.table[current_file]);\n-\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n+\t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n+\t\t\t\t       line_file_table.table[current_file]);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -7350,39 +6573,18 @@ output_line_info ()\n \t  line_delta = line_offset - DWARF_LINE_BASE;\n \t  current_line = line_info->dw_line_num;\n \t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n-\t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t      DWARF_LINE_OPCODE_BASE + line_delta);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file,\n-\t\t\t \"\\t%s line %ld\", ASM_COMMENT_START, current_line);\n-\n-\t      fputc ('\\n', asm_out_file);\n-\t    }\n+\t    dw2_asm_output_data (1, DWARF_LINE_OPCODE_BASE + line_delta,\n+\t\t\t\t \"line %lu\", current_line);\n \t  else\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s advance to line %ld\",\n-\t\t\t ASM_COMMENT_START, current_line);\n-\n-\t      fputc ('\\n', asm_out_file);\n-\t      output_sleb128 (line_offset);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, DW_LNS_advance_line,\n+\t\t\t\t   \"advance to line %lu\", current_line);\n+\t      dw2_asm_output_data_sleb128 (line_offset, NULL);\n+\t      dw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We still need to start a new row, so output a copy insn.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNS_copy\", ASM_COMMENT_START);\n-\t  fputc ('\\n', asm_out_file);\n-\t}\n+\tdw2_asm_output_data (1, DW_LNS_copy, \"DW_LNS_copy\");\n \n #if 0\n     cont:\n@@ -7400,47 +6602,27 @@ output_line_info ()\n \t  ASM_GENERATE_INTERNAL_LABEL (line_label, FUNC_END_LABEL, function);\n \t  if (0)\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n-\t\t\t ASM_COMMENT_START);\n-\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label,\n-\t\t\t\t       prev_line_label);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, DW_LNS_fixed_advance_pc,\n+\t\t\t\t   \"DW_LNS_fixed_advance_pc\");\n+\t      dw2_asm_output_delta (2, line_label, prev_line_label, NULL);\n \t    }\n \t  else\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t      if (flag_debug_asm)\n-\t\tfprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n-\t\t\t ASM_COMMENT_START);\n-\t      fputc ('\\n', asm_out_file);\n-\t      output_uleb128 (1 + DWARF2_ADDR_SIZE);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n-\t      fputc ('\\n', asm_out_file);\n+\t      dw2_asm_output_data (1, 0, \"DW_LNE_set_address\");\n+\t      dw2_asm_output_data_uleb128 (1 + DWARF2_ADDR_SIZE, NULL);\n+\t      dw2_asm_output_data (1, DW_LNE_set_address, NULL);\n+\t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, line_label, NULL);\n \t    }\n \n \t  /* Output the marker for the end of this sequence.  */\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n-\t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s DW_LNE_end_sequence\",\n-\t\t     ASM_COMMENT_START);\n-\n-\t  fputc ('\\n', asm_out_file);\n-\t  output_uleb128 (1);\n-\t  fputc ('\\n', asm_out_file);\n-\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_end_sequence);\n-\t  fputc ('\\n', asm_out_file);\n+\t  dw2_asm_output_data (1, 0, \"DW_LNE_end_sequence\");\n+\t  dw2_asm_output_data_uleb128 (1, NULL);\n+\t  dw2_asm_output_data (1, DW_LNE_end_sequence, NULL);\n \t}\n     }\n \n   /* Output the marker for the end of the line number info.  */\n-  ASM_OUTPUT_LABEL (asm_out_file, \".LTEND\");\n+  ASM_OUTPUT_LABEL (asm_out_file, l2);\n }\n \f\n /* Given a pointer to a tree node for some base type, return a pointer to\n@@ -8617,12 +7799,28 @@ add_const_value_attribute (die, rtl)\n   switch (GET_CODE (rtl))\n     {\n     case CONST_INT:\n-      /* Note that a CONST_INT rtx could represent either an integer or a\n-         floating-point constant.  A CONST_INT is used whenever the constant\n-         will fit into a single word.  In all such cases, the original mode\n-         of the constant value is wiped out, and the CONST_INT rtx is\n-         assigned VOIDmode.  */\n-      add_AT_unsigned (die, DW_AT_const_value, (unsigned) INTVAL (rtl));\n+      /* Note that a CONST_INT rtx could represent either an integer\n+\t or a floating-point constant.  A CONST_INT is used whenever\n+\t the constant will fit into a single word.  In all such\n+\t cases, the original mode of the constant value is wiped\n+\t out, and the CONST_INT rtx is assigned VOIDmode.  */\n+      {\n+\tHOST_WIDE_INT val = INTVAL (rtl);\n+\t\n+\t/* ??? We really should be using HOST_WIDE_INT throughout.  */\n+\tif (val < 0)\n+\t  {\n+\t    if ((long) val != val)\n+\t      abort ();\n+\t    add_AT_int (die, DW_AT_const_value, (long) val);\n+\t  }\n+\telse\n+\t  {\n+\t    if ((unsigned long) val != (unsigned HOST_WIDE_INT) val)\n+\t      abort ();\n+\t    add_AT_int (die, DW_AT_const_value, (unsigned long) val);\n+\t  }\n+      }\n       break;\n \n     case CONST_DOUBLE:\n@@ -8662,8 +7860,13 @@ add_const_value_attribute (die, rtl)\n \t    add_AT_float (die, DW_AT_const_value, length, array);\n \t  }\n \telse\n-\t  add_AT_long_long (die, DW_AT_const_value,\n-\t\t\t    CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n+\t  {\n+\t    /* ??? We really should be using HOST_WIDE_INT throughout.  */\n+\t    if (HOST_BITS_PER_LONG != HOST_BITS_PER_WIDE_INT)\n+\t      abort ();\n+\t    add_AT_long_long (die, DW_AT_const_value,\n+\t\t\t      CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n+\t  }\n       }\n       break;\n \n@@ -11692,9 +10895,8 @@ dwarf2out_line (filename, line)\n \t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n \t\t\t\t     separate_line_info_table_in_use);\n \t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s %s:%d\", ASM_COMMENT_START,\n+\t    fprintf (asm_out_file, \"\\t%s %s:%d\\n\", ASM_COMMENT_START,\n \t\t     filename, line);\n-\t  fputc ('\\n', asm_out_file);\n \n \t  /* expand the line info table if necessary */\n \t  if (separate_line_info_table_in_use\n@@ -11722,9 +10924,8 @@ dwarf2out_line (filename, line)\n \t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, LINE_CODE_LABEL,\n \t\t\t\t     line_info_table_in_use);\n \t  if (flag_debug_asm)\n-\t    fprintf (asm_out_file, \"\\t%s %s:%d\", ASM_COMMENT_START,\n+\t    fprintf (asm_out_file, \"\\t%s %s:%d\\n\", ASM_COMMENT_START,\n \t\t     filename, line);\n-\t  fputc ('\\n', asm_out_file);\n \n \t  /* Expand the line info table if necessary.  */\n \t  if (line_info_table_in_use == line_info_table_allocated)\n@@ -11929,18 +11130,15 @@ dwarf2out_finish ()\n     add_sibling_attributes (node->die);\n \n   /* Output a terminator label for the .text section.  */\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, TEXT_SECTION);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, TEXT_END_LABEL, 0);\n \n #if 0\n   /* Output a terminator label for the .data section.  */\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, DATA_SECTION);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, DATA_END_LABEL, 0);\n \n   /* Output a terminator label for the .bss section.  */\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BSS_END_LABEL, 0);\n #endif\n@@ -11950,7 +11148,6 @@ dwarf2out_finish ()\n     {\n       if (! DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n-\t  fputc ('\\n', asm_out_file);\n \t  ASM_OUTPUT_SECTION (asm_out_file, DEBUG_LINE_SECTION);\n \t  output_line_info ();\n \t}\n@@ -11979,14 +11176,12 @@ dwarf2out_finish ()\n   output_comp_unit (comp_unit_die);\n \n   /* Output the abbreviation table.  */\n-  fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);\n   output_abbrev_section ();\n \n   if (pubname_table_in_use)\n     {\n       /* Output public names table.  */\n-      fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, PUBNAMES_SECTION);\n       output_pubnames ();\n     }\n@@ -11996,7 +11191,6 @@ dwarf2out_finish ()\n   if (fde_table_in_use)\n     {\n       /* Output the address range information.  */\n-      fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, ARANGES_SECTION);\n       output_aranges ();\n     }"}]}