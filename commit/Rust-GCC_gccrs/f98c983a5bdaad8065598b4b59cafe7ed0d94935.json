{"sha": "f98c983a5bdaad8065598b4b59cafe7ed0d94935", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4Yzk4M2E1YmRhYWQ4MDY1NTk4YjRiNTljYWZlN2VkMGQ5NDkzNQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-09-27T03:26:45Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-09-27T03:26:45Z"}, "message": "2008-09-26  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tRevert:\n        2008-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n\t* ira-lives.c:...\n\t* doc/rtl.texi:...\n\nFrom-SVN: r140721", "tree": {"sha": "afb85fe2bf8cbb187cc08f2ce895b5947c3cb8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afb85fe2bf8cbb187cc08f2ce895b5947c3cb8b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f98c983a5bdaad8065598b4b59cafe7ed0d94935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98c983a5bdaad8065598b4b59cafe7ed0d94935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98c983a5bdaad8065598b4b59cafe7ed0d94935", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98c983a5bdaad8065598b4b59cafe7ed0d94935/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54930c27fa77dd2ead771f3dcdd7676802f85e27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54930c27fa77dd2ead771f3dcdd7676802f85e27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54930c27fa77dd2ead771f3dcdd7676802f85e27"}], "stats": {"total": 145, "additions": 51, "deletions": 94}, "files": [{"sha": "9b32387518dea2a237001fde897d696a50054997", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f98c983a5bdaad8065598b4b59cafe7ed0d94935", "patch": "@@ -1,3 +1,10 @@\n+2008-09-26  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tRevert:\n+        2008-09-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\t* ira-lives.c:...\n+\t* doc/rtl.texi:...\n+\n 2008-09-26  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* config/mips/mips.h (ISA_HAS_DMUL3, ISA_HAS_BADDU, ISA_HAS_BBIT,"}, {"sha": "148e19ddc9a17bd5a0ff54e23c41ce71e50590e7", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=f98c983a5bdaad8065598b4b59cafe7ed0d94935", "patch": "@@ -2930,13 +2930,12 @@ constituent instructions might not.\n When a @code{clobber} expression for a register appears inside a\n @code{parallel} with other side effects, the register allocator\n guarantees that the register is unoccupied both before and after that\n-insn if the @samp{&} constraint is specified for at least one\n-alternative (@pxref{Modifiers}) of the clobber.  However, the reload\n-phase may allocate a register used for one of the inputs unless the\n-@samp{&} constraint is specified for the selected alternative.  You\n-can clobber either a specific hard register, a pseudo register, or a\n-@code{scratch} expression; in the latter two cases, GCC will allocate\n-a hard register that is available there for use as a temporary.\n+insn.  However, the reload phase may allocate a register used for one of\n+the inputs unless the @samp{&} constraint is specified for the selected\n+alternative (@pxref{Modifiers}).  You can clobber either a specific hard\n+register, a pseudo register, or a @code{scratch} expression; in the\n+latter two cases, GCC will allocate a hard register that is available\n+there for use as a temporary.\n \n For instructions that require a temporary register, you should use\n @code{scratch} instead of a pseudo-register because this will allow the"}, {"sha": "609708e9069546c7e7abaaa2aa8641e083cc678d", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 38, "deletions": 87, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98c983a5bdaad8065598b4b59cafe7ed0d94935/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=f98c983a5bdaad8065598b4b59cafe7ed0d94935", "patch": "@@ -209,15 +209,20 @@ clear_allocno_live (ira_allocno_t a)\n   sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n-/* Mark the register REG as live.  Store a 1 in hard_regs_live or\n-   allocnos_live for this register or the corresponding allocno,\n-   record how many consecutive hardware registers it actually\n-   needs.  */\n+/* Mark the register referenced by use or def REF as live\n+   Store a 1 in hard_regs_live or allocnos_live for this register or\n+   the corresponding allocno, record how many consecutive hardware\n+   registers it actually needs.  */\n+\n static void\n-mark_reg_live (rtx reg)\n+mark_ref_live (struct df_ref *ref)\n {\n+  rtx reg;\n   int regno;\n \n+  reg = DF_REF_REG (ref);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -264,25 +269,32 @@ mark_reg_live (rtx reg)\n     }\n }\n \n-/* Mark the register referenced by use or def REF as live.  */\n-static void\n-mark_ref_live (struct df_ref *ref)\n+/* Return true if the definition described by DEF conflicts with the\n+   instruction's inputs.  */\n+static bool\n+def_conflicts_with_inputs_p (struct df_ref *def)\n {\n-  rtx reg;\n-\n-  reg = DF_REF_REG (ref);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-  mark_reg_live (reg);\n+  /* Conservatively assume that the condition is true for all clobbers.  */\n+  return DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER);\n }\n \n-/* Mark the register REG as dead.  Store a 0 in hard_regs_live or\n+/* Mark the register referenced by definition DEF as dead, if the\n+   definition is a total one.  Store a 0 in hard_regs_live or\n    allocnos_live for the register.  */\n static void\n-mark_reg_dead (rtx reg)\n+mark_ref_dead (struct df_ref *def)\n {\n+  unsigned int i;\n+  rtx reg;\n   int regno;\n \n+  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n+      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n+    return;\n+\n+  reg = DF_REF_REG (def);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n \n@@ -300,7 +312,6 @@ mark_reg_dead (rtx reg)\n     }\n   else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n-      unsigned int i;\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n       enum reg_class cover_class;\n \n@@ -332,71 +343,6 @@ mark_reg_dead (rtx reg)\n     }\n }\n \n-/* Mark the register referenced by definition DEF as dead, if the\n-   definition is a total one.  */\n-static void\n-mark_ref_dead (struct df_ref *def)\n-{\n-  rtx reg;\n-\n-  if (DF_REF_FLAGS_IS_SET (def, DF_REF_PARTIAL)\n-      || DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL))\n-    return;\n-\n-  reg = DF_REF_REG (def);\n-  if (GET_CODE (reg) == SUBREG)\n-    reg = SUBREG_REG (reg);\n-  mark_reg_dead (reg);\n-}\n-\n-/* Mark early clobber registers of the current INSN as live (if\n-   LIVE_P) or dead.  Return true if there are such registers.  */\n-static bool\n-mark_early_clobbers (rtx insn, bool live_p)\n-{\n-  int alt;\n-  int def;\n-  struct df_ref **def_rec;\n-  bool set_p = false;\n-  bool asm_p = asm_noperands (PATTERN (insn)) >= 0;\n-\n-  if (asm_p)\n-    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n-      if (DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MUST_CLOBBER))\n-\t{\n-\t  if (live_p)\n-\t    mark_ref_live (*def_rec);\n-\t  else\n-\t    mark_ref_dead (*def_rec);\n-\t  set_p = true;\n-\t}\n-\n-  for (def = 0; def < recog_data.n_operands; def++)\n-    {\n-      rtx dreg = recog_data.operand[def];\n-      \n-      if (GET_CODE (dreg) == SUBREG)\n-\tdreg = SUBREG_REG (dreg);\n-      if (! REG_P (dreg))\n-\tcontinue;\n-\n-      for (alt = 0; alt < recog_data.n_alternatives; alt++)\n-\tif ((recog_op_alt[def][alt].earlyclobber)\n-\t    && (recog_op_alt[def][alt].cl != NO_REGS))\n-\t  break;\n-\n-      if (alt >= recog_data.n_alternatives)\n-\tcontinue;\n-\n-      if (live_p)\n-\tmark_reg_live (dreg);\n-      else\n-\tmark_reg_dead (dreg);\n-      set_p = true;\n-    }\n-  return set_p;\n-}\n-\n /* Checks that CONSTRAINTS permits to use only one hard register.  If\n    it is so, the function returns the class of the hard register.\n    Otherwise it returns NO_REGS.  */\n@@ -634,7 +580,6 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n   bitmap_iterator bi;\n   bitmap reg_live_out;\n   unsigned int px;\n-  bool set_p;\n \n   bb = loop_tree_node->bb;\n   if (bb != NULL)\n@@ -753,7 +698,6 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      }\n \t  \n \t  extract_insn (insn);\n-\t  preprocess_constraints ();\n \t  process_single_reg_class_operands (false, freq);\n \t  \n \t  /* See which defined values die here.  */\n@@ -789,12 +733,19 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n \t    mark_ref_live (*use_rec);\n \n-\t  set_p = mark_early_clobbers (insn, true);\n+\t  /* If any defined values conflict with the inputs, mark those\n+\t     defined values as live.  */\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (def_conflicts_with_inputs_p (*def_rec))\n+\t      mark_ref_live (*def_rec);\n \n \t  process_single_reg_class_operands (true, freq);\n \t  \n-\t  if (set_p)\n-\t    mark_early_clobbers (insn, false);\n+\t  /* See which of the defined values we marked as live are dead\n+\t     before the instruction.  */\n+\t  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t    if (def_conflicts_with_inputs_p (*def_rec))\n+\t      mark_ref_dead (*def_rec);\n \n \t  curr_point++;\n \t}"}]}