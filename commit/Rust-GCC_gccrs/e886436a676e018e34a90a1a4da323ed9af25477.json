{"sha": "e886436a676e018e34a90a1a4da323ed9af25477", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg4NjQzNmE2NzZlMDE4ZTM0YTkwYTFhNGRhMzIzZWQ5YWYyNTQ3Nw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2008-05-26T13:12:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-05-26T13:12:35Z"}, "message": "exp_ch4.adb (Expand_Concatenate_Other): Add explicit constraint checks on the upper bound if...\n\n2008-05-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate_Other): Add explicit constraint\n\tchecks on the upper bound if the index type is a modular type, to\n\tprevent wrap-around computations when size is close to upper bound of\n\ttype.\n\nFrom-SVN: r135918", "tree": {"sha": "738ec625d7b4f862f8a375567d6c4552506297ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/738ec625d7b4f862f8a375567d6c4552506297ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e886436a676e018e34a90a1a4da323ed9af25477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e886436a676e018e34a90a1a4da323ed9af25477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e886436a676e018e34a90a1a4da323ed9af25477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e886436a676e018e34a90a1a4da323ed9af25477/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "39281edfdca8b401baab27dad7e5e205184541dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39281edfdca8b401baab27dad7e5e205184541dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39281edfdca8b401baab27dad7e5e205184541dc"}], "stats": {"total": 62, "additions": 58, "deletions": 4}, "files": [{"sha": "f009f00923bc1847148a7193aad7f86dd10da8ac", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e886436a676e018e34a90a1a4da323ed9af25477/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e886436a676e018e34a90a1a4da323ed9af25477/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e886436a676e018e34a90a1a4da323ed9af25477", "patch": "@@ -2230,6 +2230,7 @@ package body Exp_Ch4 is\n       Declare_Stmts : List_Id;\n \n       H_Decl   : Node_Id;\n+      I_Decl   : Node_Id;\n       H_Init   : Node_Id;\n       P_Decl   : Node_Id;\n       R_Decl   : Node_Id;\n@@ -2427,6 +2428,7 @@ package body Exp_Ch4 is\n            or else Root_Type (Ind_Typ) = Standard_Integer\n            or else Root_Type (Ind_Typ) = Standard_Short_Integer\n            or else Root_Type (Ind_Typ) = Standard_Short_Short_Integer\n+           or else Is_Modular_Integer_Type (Ind_Typ)\n          then\n             Target_Type := Standard_Integer;\n          else\n@@ -2609,7 +2611,37 @@ package body Exp_Ch4 is\n       for I in 2 .. Nb_Opnds loop\n          H_Init := Make_Op_Add (Loc, H_Init, S_Length (I));\n       end loop;\n-      H_Init := Ind_Val (Make_Op_Add (Loc, H_Init, L_Pos));\n+\n+      --  If the index type is small modular type, we need to perform an\n+      --  additional check that the upper bound fits in the index type.\n+      --  Otherwise the computation of the upper bound can wrap around\n+      --  and yield meaningless results. The constraint check has to be\n+      --  explicit in the code, because the generated function is compiled\n+      --  with checks disabled, for efficiency.\n+\n+      if Is_Modular_Integer_Type (Ind_Typ)\n+        and then Esize (Ind_Typ) < Esize (Standard_Integer)\n+      then\n+         I_Decl :=\n+            Make_Object_Declaration (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_uI),\n+             Object_Definition   => New_Reference_To (Standard_Integer, Loc),\n+             Expression          =>\n+               Make_Type_Conversion (Loc,\n+                  New_Reference_To (Standard_Integer, Loc),\n+                  Make_Op_Add (Loc, H_Init, L_Pos)));\n+\n+         H_Init :=\n+           Ind_Val (\n+             Make_Type_Conversion (Loc,\n+               New_Reference_To (Ind_Typ, Loc),\n+               New_Reference_To (Defining_Identifier (I_Decl), Loc)));\n+\n+      --  For other index types, computation is safe.\n+\n+      else\n+         H_Init := Ind_Val (Make_Op_Add (Loc, H_Init, L_Pos));\n+      end if;\n \n       H_Decl :=\n         Make_Object_Declaration (Loc,\n@@ -2636,6 +2668,28 @@ package body Exp_Ch4 is\n \n       Declare_Decls := New_List (P_Decl, H_Decl, R_Decl);\n \n+      --  Add constraint check for the modular index case.\n+\n+      if Is_Modular_Integer_Type (Ind_Typ)\n+        and then Esize (Ind_Typ) < Esize (Standard_Integer)\n+      then\n+         Insert_After (P_Decl, I_Decl);\n+\n+         Insert_After (I_Decl,\n+            Make_Raise_Constraint_Error (Loc,\n+               Condition =>\n+                  Make_Op_Gt (Loc,\n+                     Left_Opnd =>\n+                       New_Reference_To (Defining_Identifier (I_Decl), Loc),\n+                     Right_Opnd =>\n+                       Make_Type_Conversion (Loc,\n+                          New_Reference_To (Standard_Integer, Loc),\n+                          Make_Attribute_Reference (Loc,\n+                             Prefix => New_Reference_To (Ind_Typ, Loc),\n+                             Attribute_Name => Name_Last))),\n+                Reason => CE_Range_Check_Failed));\n+      end if;\n+\n       --  Construct list of statements for the declare block\n \n       Declare_Stmts := New_List;\n@@ -7679,13 +7733,13 @@ package body Exp_Ch4 is\n \n                if Nkind (Parent (N)) = Sinfo.N_Return_Statement then\n                   declare\n-                     Func     : Entity_Id := Current_Scope;\n+                     Func     : Entity_Id;\n                      Func_Typ : Entity_Id;\n \n                   begin\n-                     --  Climb the scope stack looking for the enclosing\n-                     --  function.\n+                     --  Climb scope stack looking for the enclosing function\n \n+                     Func := Current_Scope;\n                      while Present (Func)\n                        and then Ekind (Func) /= E_Function\n                      loop"}]}