{"sha": "b88fdcc1c3675330031b0cff35ecf14b53616321", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg4ZmRjYzFjMzY3NTMzMDAzMWIwY2ZmMzVlY2YxNGI1MzYxNjMyMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T11:44:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T12:33:19Z"}, "message": "refactor SLP analysis\n\nThis passes down the graph entry kind down to vect_analyze_slp_instance\nwhich simplifies it and makes it a shallow wrapper around\nvect_build_slp_instance.\n\n2020-11-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_analyze_slp): Pass down the\n\tSLP graph entry kind.\n\t(vect_analyze_slp_instance): Simplify.\n\t(vect_build_slp_instance): Adjust.\n\t(vect_slp_check_for_constructors): Perform more\n\teligibility checks here.", "tree": {"sha": "acea41810ab5d63f1e24cafce1d8af30b6c48a62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acea41810ab5d63f1e24cafce1d8af30b6c48a62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b88fdcc1c3675330031b0cff35ecf14b53616321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88fdcc1c3675330031b0cff35ecf14b53616321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b88fdcc1c3675330031b0cff35ecf14b53616321", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88fdcc1c3675330031b0cff35ecf14b53616321/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7144270e2de7ba4954729c75ca389ed3081134ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7144270e2de7ba4954729c75ca389ed3081134ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7144270e2de7ba4954729c75ca389ed3081134ee"}], "stats": {"total": 105, "additions": 45, "deletions": 60}, "files": [{"sha": "88e637e30dc3c596da24393b2ac8a4b6f4e3f392", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88fdcc1c3675330031b0cff35ecf14b53616321/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88fdcc1c3675330031b0cff35ecf14b53616321/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b88fdcc1c3675330031b0cff35ecf14b53616321", "patch": "@@ -2174,7 +2174,8 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n-\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size);\n+\t\t\t   stmt_vec_info stmt_info, slp_instance_kind kind,\n+\t\t\t   unsigned max_tree_size);\n \n /* Analyze an SLP instance starting from SCALAR_STMTS which are a group\n    of KIND.  Return true if successful.  */\n@@ -2375,7 +2376,7 @@ vect_build_slp_instance (vec_info *vinfo,\n \t      stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n \t\t\t\t\t\t\t       group1_size);\n \t      bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n-\t\t\t\t\t\t    max_tree_size);\n+\t\t\t\t\t\t    kind, max_tree_size);\n \t      /* Split the rest at the failure point and possibly\n \t\t re-analyze the remaining matching part if it has\n \t\t at least two lanes.  */\n@@ -2386,14 +2387,14 @@ vect_build_slp_instance (vec_info *vinfo,\n \t\t  stmt_vec_info rest2 = rest;\n \t\t  rest = vect_split_slp_store_group (rest, i - group1_size);\n \t\t  if (i - group1_size > 1)\n-\t\t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n-\t\t\t\t\t\t      rest2, max_tree_size);\n+\t\t    res |= vect_analyze_slp_instance (vinfo, bst_map, rest2,\n+\t\t\t\t\t\t      kind, max_tree_size);\n \t\t}\n \t      /* Re-analyze the non-matching tail if it has at least\n \t\t two lanes.  */\n \t      if (i + 1 < group_size)\n \t\tres |= vect_analyze_slp_instance (vinfo, bst_map,\n-\t\t\t\t\t\t  rest, max_tree_size);\n+\t\t\t\t\t\t  rest, kind, max_tree_size);\n \t      return res;\n \t    }\n \t}\n@@ -2418,10 +2419,10 @@ vect_build_slp_instance (vec_info *vinfo,\n \t  DR_GROUP_GAP (stmt_info) = 0;\n \n \t  bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n-\t\t\t\t\t\tmax_tree_size);\n+\t\t\t\t\t\tkind, max_tree_size);\n \t  if (i + 1 < group_size)\n \t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n-\t\t\t\t\t      rest, max_tree_size);\n+\t\t\t\t\t      rest, kind, max_tree_size);\n \n \t  return res;\n \t}\n@@ -2444,59 +2445,34 @@ vect_build_slp_instance (vec_info *vinfo,\n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n-\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size)\n+\t\t\t   stmt_vec_info stmt_info,\n+\t\t\t   slp_instance_kind kind,\n+\t\t\t   unsigned max_tree_size)\n {\n-  unsigned int group_size;\n   unsigned int i;\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   vec<stmt_vec_info> scalar_stmts;\n-  slp_instance_kind kind;\n \n   if (is_a <bb_vec_info> (vinfo))\n     vect_location = stmt_info->stmt;\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      kind = slp_inst_kind_store;\n-      group_size = DR_GROUP_SIZE (stmt_info);\n-    }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    {\n-      kind = slp_inst_kind_reduc_chain;\n-      gcc_assert (is_a <loop_vec_info> (vinfo));\n-      group_size = REDUC_GROUP_SIZE (stmt_info);\n-    }\n-  else if (is_gimple_assign (stmt_info->stmt)\n-\t    && gimple_assign_rhs_code (stmt_info->stmt) == CONSTRUCTOR)\n-    {\n-      kind = slp_inst_kind_ctor;\n-      group_size = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt_info->stmt));\n-    }\n-  else\n-    {\n-      kind = slp_inst_kind_reduc_group;\n-      gcc_assert (is_a <loop_vec_info> (vinfo));\n-      group_size = as_a <loop_vec_info> (vinfo)->reductions.length ();\n-    }\n \n-  /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n-  scalar_stmts.create (group_size);\n   stmt_vec_info next_info = stmt_info;\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+  if (kind == slp_inst_kind_store)\n     {\n-      /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n+      /* Collect the stores and store them in scalar_stmts.  */\n+      scalar_stmts.create (DR_GROUP_SIZE (stmt_info));\n       while (next_info)\n \t{\n-\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n+\t  scalar_stmts.quick_push (vect_stmt_to_vectorize (next_info));\n \t  next_info = DR_GROUP_NEXT_ELEMENT (next_info);\n \t}\n     }\n-  else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n+  else if (kind == slp_inst_kind_reduc_chain)\n     {\n-      /* Collect the reduction stmts and store them in\n-\t SLP_TREE_SCALAR_STMTS.  */\n+      /* Collect the reduction stmts and store them in scalar_stmts.  */\n+      scalar_stmts.create (REDUC_GROUP_SIZE (stmt_info));\n       while (next_info)\n \t{\n-\t  scalar_stmts.safe_push (vect_stmt_to_vectorize (next_info));\n+\t  scalar_stmts.quick_push (vect_stmt_to_vectorize (next_info));\n \t  next_info = REDUC_GROUP_NEXT_ELEMENT (next_info);\n \t}\n       /* Mark the first element of the reduction chain as reduction to properly\n@@ -2511,30 +2487,23 @@ vect_analyze_slp_instance (vec_info *vinfo,\n     {\n       tree rhs = gimple_assign_rhs1 (stmt_info->stmt);\n       tree val;\n+      scalar_stmts.create (CONSTRUCTOR_NELTS (rhs));\n       FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t{\n-\t  if (TREE_CODE (val) == SSA_NAME)\n-\t    {\n-\t      gimple* def = SSA_NAME_DEF_STMT (val);\n-\t      stmt_vec_info def_info = vinfo->lookup_stmt (def);\n-\t      /* Value is defined in another basic block.  */\n-\t      if (!def_info)\n-\t\treturn false;\n-\t      def_info = vect_stmt_to_vectorize (def_info);\n-\t      scalar_stmts.safe_push (def_info);\n-\t    }\n-\t  else\n-\t    return false;\n+\t  stmt_vec_info def_info = vinfo->lookup_def (val);\n+\t  def_info = vect_stmt_to_vectorize (def_info);\n+\t  scalar_stmts.quick_push (def_info);\n \t}\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Analyzing vectorizable constructor: %G\\n\",\n \t\t\t stmt_info->stmt);\n     }\n-  else\n+  else if (kind == slp_inst_kind_reduc_group)\n     {\n       /* Collect reduction statements.  */\n       vec<stmt_vec_info> reductions = as_a <loop_vec_info> (vinfo)->reductions;\n+      scalar_stmts.create (reductions.length ());\n       for (i = 0; reductions.iterate (i, &next_info); i++)\n \tif (STMT_VINFO_RELEVANT_P (next_info)\n \t    || STMT_VINFO_LIVE_P (next_info))\n@@ -2543,13 +2512,16 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       if (scalar_stmts.length () < 2)\n \treturn false;\n     }\n+  else\n+    gcc_unreachable ();\n \n   /* Build the tree for the SLP instance.  */\n   bool res = vect_build_slp_instance (vinfo, kind, scalar_stmts,\n \t\t\t\t      kind == slp_inst_kind_ctor\n \t\t\t\t      ? stmt_info : NULL,\n-\t\t\t\t      max_tree_size,\n-\t\t\t\t      bst_map, stmt_info);\n+\t\t\t\t      max_tree_size, bst_map,\n+\t\t\t\t      kind == slp_inst_kind_store\n+\t\t\t\t      ? stmt_info : NULL);\n \n   /* ???  If this is slp_inst_kind_store and the above succeeded here's\n      where we should do store group splitting.  */\n@@ -2573,7 +2545,10 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \n   /* Find SLP sequences starting from groups of grouped stores.  */\n   FOR_EACH_VEC_ELT (vinfo->grouped_stores, i, first_element)\n-    vect_analyze_slp_instance (vinfo, bst_map, first_element, max_tree_size);\n+    vect_analyze_slp_instance (vinfo, bst_map, first_element,\n+\t\t\t       STMT_VINFO_GROUPED_ACCESS (first_element)\n+\t\t\t       ? slp_inst_kind_store : slp_inst_kind_ctor,\n+\t\t\t       max_tree_size);\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n@@ -2583,6 +2558,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t    && ! STMT_VINFO_LIVE_P (first_element))\n \t  ;\n \telse if (! vect_analyze_slp_instance (vinfo, bst_map, first_element,\n+\t\t\t\t\t      slp_inst_kind_reduc_chain,\n \t\t\t\t\t      max_tree_size))\n \t  {\n \t    /* Dissolve reduction chain group.  */\n@@ -2604,7 +2580,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n       /* Find SLP sequences starting from groups of reductions.  */\n       if (loop_vinfo->reductions.length () > 1)\n \tvect_analyze_slp_instance (vinfo, bst_map, loop_vinfo->reductions[0],\n-\t\t\t\t   max_tree_size);\n+\t\t\t\t   slp_inst_kind_reduc_group, max_tree_size);\n     }\n \n   /* The map keeps a reference on SLP nodes built, release that.  */\n@@ -4033,6 +4009,15 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n \t  || uniform_vector_p (rhs))\n \tcontinue;\n \n+      unsigned j;\n+      tree val;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), j, val)\n+\tif (TREE_CODE (val) != SSA_NAME\n+\t    || !bb_vinfo->lookup_def (val))\n+\t  break;\n+      if (j != CONSTRUCTOR_NELTS (rhs))\n+\tcontinue;\n+\n       stmt_vec_info stmt_info = bb_vinfo->lookup_stmt (assign);\n       BB_VINFO_GROUPED_STORES (bb_vinfo).safe_push (stmt_info);\n     }"}]}