{"sha": "d93578fe8533ece4c2fe535e865c0c914d28ad11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkzNTc4ZmU4NTMzZWNlNGMyZmU1MzVlODY1YzBjOTE0ZDI4YWQxMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:58:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:58:24Z"}, "message": "Initial revision\n\nFrom-SVN: r8051", "tree": {"sha": "88415f5044c56ac304b2eeacb29130c4d60845ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88415f5044c56ac304b2eeacb29130c4d60845ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d93578fe8533ece4c2fe535e865c0c914d28ad11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93578fe8533ece4c2fe535e865c0c914d28ad11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93578fe8533ece4c2fe535e865c0c914d28ad11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93578fe8533ece4c2fe535e865c0c914d28ad11/comments", "author": null, "committer": null, "parents": [{"sha": "946730d09eb43a80c79a8afe2c6695dc5272d246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946730d09eb43a80c79a8afe2c6695dc5272d246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946730d09eb43a80c79a8afe2c6695dc5272d246"}], "stats": {"total": 2225, "additions": 2225, "deletions": 0}, "files": [{"sha": "255d4b4d406fa4a3e0f8a4d7d87e205ef7a5f6fe", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "added", "additions": 2180, "deletions": 0, "changes": 2180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93578fe8533ece4c2fe535e865c0c914d28ad11/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93578fe8533ece4c2fe535e865c0c914d28ad11/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=d93578fe8533ece4c2fe535e865c0c914d28ad11", "patch": "@@ -0,0 +1,2180 @@\n+;;- Machine description for the AT&T DSP1600 for GNU C compiler\n+;;  Copyright (C) 1994 Free Software Foundation, Inc.\n+;;  Contributed by Michael Collison (collison@world.std.com).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\f\n+;; Attribute specifications\n+\n+; Type of each instruction.  Default is arithmetic.\n+; I'd like to write the list as this, but genattrtab won't accept it.\n+;\n+; \"jump,cond_jump,call,\t\t\t; flow-control instructions\n+;  load_i,load, store, move\t\t; Y space address arithmetic instructions\n+;  malu,special,f3_alu,f3_alu_i\t\t; data arithmetic unit instructions\n+;  shift_i,shift, bfield_i, bfield\t; bit manipulation unit instructions\n+;  arith,\t\t\t\t; integer unit instructions\n+;  nop\n+\n+; Classification of each insn.  Some insns of TYPE_BRANCH are multi-word.\n+(define_attr \"type\"\n+  \"jump,cond_jump,call,load_i,load,move,store,malu,malu_mul,special,f3_alu,f3_alu_i,shift_i,shift,bfield_i,bfield,nop,ld_short_i\"\n+  (const_string \"malu\"))\n+\n+; Length in # of instructions of each insn.  The values are not exact, but\n+; are safe.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"cond_jump,f3_alu_i,shift_i,bfield_i,load_i\")\n+\t (const_int 2)]\n+\t(const_int 1)))\n+\n+\f\n+;;  ....................\n+;;\n+;;  Test against 0 instructions\n+;;\n+;;  ....................\n+\n+(define_expand \"tsthi\"\n+  [(set (cc0)\n+        (match_operand:HI 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  dsp16xx_compare_gen = gen_tst_reg;\n+  dsp16xx_compare_op0 = operands[0];\n+  dsp16xx_compare_op1 = const0_rtx;\n+  DONE;\n+}\")\n+\n+(define_insn \"tsthi_1\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"register_operand\" \"A\"))]\n+  \"\"\n+  \"%0=%0\"\n+  [(set_attr \"type\" \"malu\")])\n+\n+(define_expand \"tstqi\"\n+  [(set (cc0)\n+        (match_operand:QI 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  dsp16xx_compare_gen = gen_tst_reg;\n+  dsp16xx_compare_op0 = operands[0];\n+  dsp16xx_compare_op1 = const0_rtx;\n+  DONE;\n+}\")\n+\n+(define_insn \"tstqi_1\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"register_operand\" \"j,q\"))\n+   (clobber (match_scratch:QI 1 \"=k,u\"))]\n+  \"\"\n+  \"@\n+   %1=0\\;%b0-0\n+   %1=0\\;%b0-0\"\n+  [(set_attr \"type\" \"malu,malu\")])\n+\n+\f\n+;;\n+;;  ....................\n+;;\n+;;  Bit test instructions\n+;;\n+;;  ....................\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(and:HI (match_operand:HI 0 \"register_operand\" \"A,!A,A\")\n+\t\t(match_operand:HI 1 \"nonmemory_operand\" \"Z,A,I\")))]\n+  \"\" \n+  \"*\n+{\n+\tswitch (which_alternative)\n+\t{\n+\t   case 0:\n+\t   case 1:\n+   \t      return \\\"%0&%1\\\";\n+\n+\t   case 2:\n+   \t      return \\\"%0&%H1\\\";\n+         }\n+}\"\n+  [(set_attr \"type\" \"f3_alu,malu,f3_alu_i\")])\n+\n+\n+;;(define_insn \"\"\n+;;  [(set (cc0)\n+;;\t(and:QI (match_operand:QI 0 \"register_operand\" \"h\")\n+;;\t\t(match_operand:QI 1 \"const_int_operand\" \"I\")))]\n+;;  \"\" \n+;;  \"%b0&%H1\"\n+;;  [(set_attr \"type\" \"f3_alu_i\")])\n+\f\n+;;\n+;;\n+;; Compare Instructions\n+;;\n+\n+(define_expand \"cmphi\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare (match_operand:HI 0 \"general_operand\" \"\")\n+\t\t\t    (match_operand:HI 1 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 2 \"\"))\n+\t      (clobber (match_scratch:QI 3 \"\"))\n+\t      (clobber (match_scratch:QI 4 \"\"))\n+\t      (clobber (match_scratch:QI 5 \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    operands[1] = force_reg (HImode, operands[1]);\n+\n+  if (operands[0])\t/* Avoid unused code warning */\n+    {\n+      dsp16xx_compare_gen = gen_compare_reg;\n+      dsp16xx_compare_op0 = operands[0];\n+      dsp16xx_compare_op1 = operands[1];\n+      DONE;\n+    }\n+\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) \n+\t(compare (match_operand:HI 0 \"general_operand\" \"Z*r*m*i\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"Z*r*m*i\")))\n+   (clobber (match_scratch:QI 2 \"=&A\"))\n+   (clobber (match_scratch:QI 3 \"=&A\"))\n+   (clobber (match_scratch:QI 4 \"=&A\"))\n+   (clobber (match_scratch:QI 5 \"=&A\"))]\n+  \"(save_next_cc_user_code = next_cc_user_code (insn)) == GTU \\\n+   || save_next_cc_user_code == GEU \\\n+   || save_next_cc_user_code == LTU \\\n+   || save_next_cc_user_code == LEU\"\n+  \"*\n+{\n+  if (GET_CODE(operands[0]) == REG)\n+    {\n+      if (REGNO (operands[0]) == REG_Y ||\n+\t  REGNO (operands[0]) == REG_PROD)\n+\t{\n+\t  output_asm_insn (\\\"a0=%0\\\", operands);\n+\t}\n+      else if (IS_YBASE_REGISTER_WINDOW (REGNO(operands[0])))\n+\t{\n+\t  output_asm_insn (\\\"a0=%u0\\;a0l=%w0\\\", operands);\n+\t}\n+      else\n+\tfatal (\\\"Illegal register for compare\\\");\n+    }\n+  else if (GET_CODE(operands[0]) == CONST_INT)\n+    {\n+      output_asm_insn (\\\"a0=%U0\\;a0l=%H0\\\", operands);\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      rtx xoperands[2];\n+\n+      xoperands[0] = gen_rtx (REG, HImode, REG_A0);\n+      xoperands[1] = operands[0];\n+      double_reg_from_memory (xoperands);\n+    }\n+\n+  if (GET_CODE(operands[1]) == REG)\n+    {\n+      if (REGNO (operands[1]) == REG_Y ||\n+\t  REGNO (operands[1]) == REG_PROD)\n+\t{\n+\t  output_asm_insn (\\\"a1=%1\\\", operands);\n+\t}\n+      else if (IS_YBASE_REGISTER_WINDOW (REGNO(operands[1])))\n+\t{\n+\t  output_asm_insn (\\\"a1=%u1\\;a1l=%w1\\\", operands);\n+\t}\n+      else\n+\tfatal (\\\"Illegal register for compare\\\");\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx xoperands[2];\n+\n+      xoperands[0] = gen_rtx (REG, HImode, REG_A1);\n+      xoperands[1] = operands[1];\n+      double_reg_from_memory (xoperands);\n+    }\n+  else if (GET_CODE(operands[1]) == CONST_INT)\n+    {\n+      output_asm_insn (\\\"a1=%U1\\;a1l=%H1\\\", operands);\n+    }\n+  \n+  return \\\"psw = 0\\;a0 - a1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand:HI 0 \"register_operand\" \"A,!A\")\n+\t\t       (match_operand:HI 1 \"register_operand\" \"Z,*A\")))]\n+  \"\"\n+  \"@\n+   %0-%1\n+   %0-%1\"\n+  [(set_attr \"type\" \"malu,f3_alu\")])\n+\n+(define_expand \"cmpqi\"\n+  [(parallel [(set (cc0)\n+\t\t   (compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"\")))\n+\t      (clobber (match_operand:QI 2 \"register_operand\" \"\"))\n+\t      (clobber (match_operand:QI 3 \"register_operand\" \"\"))])]\n+  \"\"\n+  \"\n+ {\n+  if (operands[0])\t/* Avoid unused code warning */\n+    {\n+      dsp16xx_compare_gen = gen_compare_reg;\n+      dsp16xx_compare_op0 = operands[0];\n+      dsp16xx_compare_op1 = operands[1];\n+      DONE;\n+    }\n+ }\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"k,k,!k,k,u,u,!u,u\")\n+                       (match_operand:QI 1 \"nonmemory_operand\" \"w,z,u,i,w,z,k,i\")))\n+\t(clobber (match_scratch:QI 2 \"=j,j,j,j,q,q,q,q\"))\n+\t(clobber (match_scratch:QI 3 \"=v,y,q,X,v,y,j,X\"))]\n+  \"(save_next_cc_user_code = next_cc_user_code (insn)) == GTU \\\n+   || save_next_cc_user_code == GEU \\\n+   || save_next_cc_user_code == LTU \\\n+   || save_next_cc_user_code == LEU\"\n+  \"@\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%0-%H1\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%3=0\\;%2-%3\n+   %2=0\\;%0-%H1\")\n+\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"register_operand\"  \"j,j,!j,j,q,q,!q,q\")\n+                       (match_operand:QI 1 \"nonmemory_operand\" \"v,y,q,i,v,y,j,i\")))\n+\t(clobber (match_scratch:QI 2 \"=k,k,k,k,u,u,u,u\"))\n+\t(clobber (match_scratch:QI 3 \"=w,z,u,X,w,z,k,X\"))]\n+  \"\"\n+  \"@\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%b0-%H1\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%3=0\\;%0-%1\n+   %2=0\\;%b0-%H1\")\n+\n+\n+(define_expand \"cmphf\"\n+  [(set (cc0)\n+\t(compare (match_operand:HF 0 \"register_operand\" \"\")\n+\t\t (match_operand:HF 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_cmphf3_libcall)\n+    dsp16xx_cmphf3_libcall = gen_rtx (SYMBOL_REF, Pmode, CMPHF3_LIBCALL);\n+\n+   dsp16xx_compare_gen = gen_compare_reg;\n+   dsp16xx_compare_op0 = operands[0];\n+   dsp16xx_compare_op1 = operands[1];\n+   emit_library_call (dsp16xx_cmphf3_libcall, 1, HImode, 2,\n+\t\t      operands[0], HFmode,\n+\t\t      operands[1], HFmode);\n+   emit_insn (gen_tsthi_1 (copy_to_reg(hard_libcall_value (HImode))));\n+   DONE;\n+}\")\n+\n+\f\n+;;  ....................\n+;;\n+;;  Add instructions\n+;;\n+;;  ....................\n+\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%A,A,A\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,i\")))]\n+  \"\"\n+  \"@\n+   %0=%1+%2\n+   %0=%1+%2\n+   %0=%w1+%H2\\;%0=%b0+%U2\"\n+  [(set_attr \"type\" \"malu,malu,f3_alu_i\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,!k,!u\")\n+\t(plus:QI (plus:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk\")\n+\t\t\t  (match_operand:QI 2 \"register_operand\" \"wz,wz,uk,uk\"))\n+\t\t (match_operand:QI 3 \"immediate_operand\" \"i,i,i,i\")))\n+   (clobber (match_scratch:QI 4 \"=j,q,j,q\"))]\n+  \"\"\n+  \"@\n+   %m0=%m1+%m2\\;%m0=%0+%H3\n+   %m0=%m1+%m2\\;%m0=%0+%H3\n+   %m0=%m1+%m2\\;%m0=%0+%H3\n+   %m0=%m1+%m2\\;%m0=%0+%H3\")\n+\n+(define_expand \"addqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (plus:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (match_scratch:QI 3 \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (reload_in_progress)\n+    {\n+      if (REG_P (operands[1]) && \n+\t  (REGNO(operands[1]) == STACK_POINTER_REGNUM ||\n+\t   REGNO(operands[1]) == FRAME_POINTER_REGNUM) &&\n+\t  GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  if (REG_P (operands[0]) && IS_ACCUM_REG(REGNO(operands[0])))\n+\t    emit_move_insn (operands[0], operands[1]);\n+\n+\t  operands[1] = operands[0];\n+\t}\n+    }\n+}\")\n+\n+\t\n+(define_insn \"match_addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=!a,!a,k,u,!k,!u,h,!a\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"0,0,uk,uk,uk,uk,h,0\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"W,N,wzi,wzi,uk,uk,i,n\")))\n+\t(clobber (match_scratch:QI 3 \"=X,X,j,q,j,q,X,W\"))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"*%0++%2\\\";\n+\n+    case 1:\n+      switch (INTVAL (operands[2]))\n+\t{\n+\tcase -1:\n+\t  return \\\"*%0--\\\";\n+\n+\tcase 1:\n+\t  return \\\"*%0++\\\";\n+\n+\tcase -2:\n+\t  return \\\"*%0--\\;*%0--\\\";\n+\n+\tcase 2:\n+\t  return \\\"*%0++\\;*%0++\\\";\n+\t}\n+\n+    case 2:\n+    case 3:\n+      if (!CONSTANT_P(operands[2]))\n+        return \\\"%m0=%m1+%m2\\\";\n+      else\n+        return \\\"%m0=%1+%H2\\\";\n+\n+    case 4:\n+    case 5:\n+      return \\\"%m0=%m1+%m2\\\";\n+\n+    case 6:\n+      return \\\"%0=%b1+%H2\\\";\n+\n+    case 7:\n+      return \\\"%3=%2\\;*%0++%3\\\";\n+    }\n+}\")\n+\n+(define_expand \"addhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(plus:HF (match_operand:HF 1 \"register_operand\" \"\")\n+\t\t (match_operand:HF 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_addhf3_libcall)\n+    dsp16xx_addhf3_libcall = gen_rtx (SYMBOL_REF, Pmode, ADDHF3_LIBCALL);\n+\n+   emit_library_call (dsp16xx_addhf3_libcall, 1, HFmode, 2,\n+\t\t      operands[1], HFmode,\n+\t\t      operands[2], HFmode);\n+   emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+   DONE;\n+}\")\n+\t\t      \n+\f\n+;;\n+;;  ....................\n+;;\n+;;  Subtract instructions\n+;;\n+;;  ....................\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"A,A,A\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"Z,d,i\")))]\n+  \"\"\n+  \"@\n+   %0=%1-%2\n+   %0=%1-%2\n+   %0=%w1-%H2\\;%0=%b0-%U2\"\n+  [(set_attr \"type\" \"malu,malu,f3_alu_i\")])\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=?*a,k,u,!k,!u\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,uk,uk,uk,uk\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"n,wzi,wzi,uk,uk\")))\n+\t(clobber (match_scratch:QI 3 \"=W,j,q,j,q\"))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      switch (INTVAL (operands[2]))\n+\t{\n+\tcase 0:\n+\t  return \\\"\\\";\n+\t  \n+\tcase 1:\n+\t  return \\\"*%0--\\\";\n+\t  \n+\tcase -1:\n+\t  return \\\"*%0++\\\";\n+\t  \n+\tdefault:\n+\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n+\t  \n+\t  if (SHORT_IMMEDIATE(operands[2]))\n+\t    return \\\"set %3=%H2\\;*%0++%3\\\";\n+\t  else\n+\t    return \\\"%3=%H2\\;*%0++%3\\\";\n+\t}\n+      \n+    case 1:\n+    case 2:\n+      if (!CONSTANT_P(operands[2]))\n+        return \\\"%m0=%m1-%m2\\\";\n+      else\n+        return \\\"%m0=%1-%H2\\\";\n+\n+    case 3:\n+    case 4:\n+      return \\\"%m0=%m1-%m2\\\";\n+    }\n+}\")\n+\n+(define_expand \"subhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(minus:HF (match_operand:HF 1 \"register_operand\" \"\")\n+\t\t (match_operand:HF 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_subhf3_libcall)\n+    dsp16xx_subhf3_libcall = gen_rtx (SYMBOL_REF, Pmode, SUBHF3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_subhf3_libcall, 1, HFmode, 2,\n+\t\t     operands[1], HFmode,\n+\t\t     operands[2], HFmode);\n+  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+  DONE;\n+}\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (neg:HI (match_operand:HI 1 \"register_operand\" \"A\")))]\n+  \"\"\n+  \"%0=-%1\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_expand \"neghf2\"\n+  [(set (match_operand:HF 0 \"general_operand\" \"\")\n+\t(neg:HF (match_operand:HF 1 \"general_operand\" \"\")))]\n+  \"\"\n+\"\n+{\n+  if (!dsp16xx_neghf2_libcall)\n+    dsp16xx_neghf2_libcall = gen_rtx (SYMBOL_REF, Pmode, NEGHF2_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_neghf2_libcall, 1, HFmode, 1,\n+\t\t     operands[1], HFmode);\n+  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+  DONE;\n+}\")\n+\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;  Multiply instructions\n+;;\n+\n+(define_expand \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_mulhi3_libcall)\n+    dsp16xx_mulhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, MULHI3_LIBCALL);\n+\n+   emit_library_call (dsp16xx_mulhi3_libcall, 1, HImode, 2,\n+\t\t      operands[1], HImode,\n+\t\t      operands[2], HImode);\n+   emit_move_insn (operands[0], hard_libcall_value(HImode));\n+   DONE;\n+}\")\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=w\")\n+        (mult:HI (match_operand:QI 1 \"register_operand\" \"%x\")\n+                 (match_operand:QI 2 \"register_operand\" \"y\")))\n+   (clobber (match_scratch:QI 3 \"=v\"))]\n+  \"\"\n+  \"%m0=%1*%2\"\n+  [(set_attr \"type\" \"malu_mul\")])\n+\n+(define_insn \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=t\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%x\"))\n+                 (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"y\"))))]\n+  \"\"\n+  \"%0=%1*%2\"\n+  [(set_attr \"type\" \"malu_mul\")])\n+\n+(define_insn \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=t\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%x\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"y\"))))]\n+  \"\"\n+  \"%0=%1*%2\"\n+  [(set_attr \"type\" \"malu_mul\")])\n+\n+(define_expand \"mulhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(mult:HF (match_operand:HF 1 \"register_operand\" \"\")\n+\t\t (match_operand:HF 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_mulhf3_libcall)\n+    dsp16xx_mulhf3_libcall = gen_rtx (SYMBOL_REF, Pmode, MULHF3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_mulhf3_libcall, 1, HFmode, 2,\n+\t\t     operands[1], HFmode,\n+\t\t     operands[2], HFmode);\n+  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+  DONE;\n+}\")\n+\n+\f\n+\n+;;\n+;; *******************\n+;;\n+;; Divide Instructions\n+;;\n+\n+(define_expand \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_divhi3_libcall)\n+    dsp16xx_divhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, DIVHI3_LIBCALL);\n+\n+   emit_library_call (dsp16xx_divhi3_libcall, 1, HImode, 2,\n+\t\t      operands[1], HImode,\n+\t\t      operands[2], HImode);\n+   emit_move_insn (operands[0], hard_libcall_value(HImode));\n+   DONE;\n+}\")\n+\n+(define_expand \"udivhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(udiv:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_udivhi3_libcall)\n+    dsp16xx_udivhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, UDIVHI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_udivhi3_libcall, 1, HImode, 2,\n+\t\t     operands[1], HImode,\n+\t\t     operands[2], HImode);\n+  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"divqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(div:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_divqi3_libcall)\n+    dsp16xx_divqi3_libcall = gen_rtx (SYMBOL_REF, Pmode, DIVQI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_divqi3_libcall, 1, QImode, 2,\n+\t\t     operands[1], QImode,\n+\t\t     operands[2], QImode);\n+  emit_move_insn (operands[0], hard_libcall_value(QImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"udivqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(udiv:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_udivqi3_libcall)\n+    dsp16xx_udivqi3_libcall = gen_rtx (SYMBOL_REF, Pmode, UDIVQI3_LIBCALL);\n+\n+   emit_library_call (dsp16xx_udivqi3_libcall, 1, QImode, 2,\n+\t\t      operands[1], QImode,\n+\t\t      operands[2], QImode);\n+   emit_move_insn (operands[0], hard_libcall_value(QImode));\n+   DONE;\n+}\")\n+\f\n+;;\n+;;  ....................\n+;;\n+;;  Modulo instructions\n+;;\n+;;  ....................\n+\n+(define_expand \"modhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mod:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_modhi3_libcall)\n+    dsp16xx_modhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, MODHI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_modhi3_libcall, 1, HImode, 2,\n+\t\t     operands[1], HImode,\n+\t\t     operands[2], HImode);\n+  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"umodhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(umod:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_umodhi3_libcall)\n+    dsp16xx_umodhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, UMODHI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_umodhi3_libcall, 1, HImode, 2,\n+\t\t     operands[1], HImode,\n+\t\t     operands[2], HImode);\n+  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"modqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(mod:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_modqi3_libcall)\n+    dsp16xx_modqi3_libcall = gen_rtx (SYMBOL_REF, Pmode, MODQI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_modqi3_libcall, 1, QImode, 2,\n+\t\t     operands[1], QImode,\n+\t\t     operands[2], QImode);\n+  emit_move_insn (operands[0], hard_libcall_value(QImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"umodqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(umod:QI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_umodqi3_libcall)\n+    dsp16xx_umodqi3_libcall = gen_rtx (SYMBOL_REF, Pmode, UMODQI3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_umodqi3_libcall, 1, QImode, 2,\n+\t\t     operands[1], QImode,\n+\t\t     operands[2], QImode);\n+  emit_move_insn (operands[0], hard_libcall_value(QImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"divhf3\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(div:HF (match_operand:HF 1 \"register_operand\" \"\")\n+\t\t(match_operand:HF 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_divhf3_libcall)\n+    dsp16xx_divhf3_libcall = gen_rtx (SYMBOL_REF, Pmode, DIVHF3_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_divhf3_libcall, 1, HFmode, 2,\n+\t\t     operands[1], HFmode,\n+\t\t     operands[2], HFmode);\n+  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+  DONE;\n+}\")\n+\n+\f\n+\n+;;\n+;; ********************\n+;;\n+;; Logical Instructions\n+;;\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,?A\")\n+        (and:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,i\")))]\n+  \"\"\n+  \"@\n+   %0=%1&%2\n+   %0=%1&%2\n+   %0=%w1&%H2\\;%0=%b0&%U2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i\")])\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n+\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n+   \"\"\n+   \"@\n+    %m0=%m1&%m2\n+    %m0=%m1&%m2\n+    %m0=%1&%H2\n+    %m0=%m1&%m2\n+    %m0=%m1&%m2\n+    %m0=%m1&%m2\n+    %m0=%m1&%m2\n+    %m0=%b1&%H2\n+    %m0=%m1&%m2\n+    %m0=%m1&%m2\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,?A\")\n+        (ior:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,i\")))]\n+ \"\"\n+ \"@\n+   %0=%u1|%u2\n+   %0=%u1|%u2\n+   %0=%w1|%H2\n+   %0=%w1|%H2\\;%0=%b0|%U2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i\")])\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n+\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n+   \"\"\n+   \"@\n+    %m0=%m1|%m2\n+    %m0=%m1|%m2\n+    %m0=%1|%H2\n+    %m0=%m1|%m2\n+    %m0=%m1|%m2\n+    %m0=%m1|%m2\n+    %m0=%m1|%m2\n+    %m0=%b1|%H2\n+    %m0=%m1|%m2\n+    %m0=%m1|%m2\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A,?A\")\n+        (xor:HI (match_operand:HI 1 \"register_operand\" \"%A,!A,A,A\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"Z,A,I,i\")))]\n+  \"\"\n+  \"@\n+   %0=%1^%2\n+   %0=%1^%2\n+   %0=%w1^%H2\n+   %0=%w1^%H2\\;%0=%b0^%U2\"\n+  [(set_attr \"type\" \"f3_alu,f3_alu,f3_alu_i,f3_alu_i\")])\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=k,u,uk,!k,!u,j,q,jq,!j,!q\")\n+\t(xor:QI (match_operand:QI 1 \"register_operand\" \"uk,uk,uk,uk,uk,jq,jq,jq,jq,jq\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"wz,wz,i,uk,uk,yv,yv,i,jq,jq\")))\n+\t(clobber (match_scratch:QI 3 \"=j,q,X,j,q,k,u,X,k,u\"))]\n+   \"\"\n+   \"@\n+    %m0=%m1^%m2\n+    %m0=%m1^%m2\n+    %m0=%1^%H2\n+    %m0=%m1^%m2\n+    %m0=%m1^%m2\n+    %m0=%m1^%m2\n+    %m0=%m1^%m2\n+    %m0=%b1^%H2\n+    %m0=%m1^%m2\n+    %m0=%m1^%m2\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (not:HI (match_operand:HI 1 \"register_operand\" \"A\")))]\n+  \"\"\n+  \"%0= ~%1\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=ku,jq\")\n+        (not:QI (match_operand:QI 1 \"register_operand\" \"ku,jq\")))]\n+  \"\"\n+  \"@\n+   %m0= %1 ^ 0xffff\n+   %m0= %b1 ^ 0xffff\"\n+  [(set_attr \"type\" \"special\")])\n+\n+\f\n+;;\n+;; MOVE INSTRUCTIONS\n+;;\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+\n+(define_insn \"match_movhi1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\"  \"=A,Z,A,d,d,m,?d,*Y,t,f\")\n+\t(match_operand:HI 1 \"general_operand\"        \"d,A,K,i,m,d,*Y,?d,t,f\"))]\n+  \"register_operand(operands[0], HImode)\n+   || register_operand(operands[1], HImode)\"\n+  \"*\n+{\n+\tswitch (which_alternative)\n+        {\n+\t\t/* register to accumulator */\n+\t\tcase 0:\n+ \t\t   return \\\"%0=%1\\\";\n+\t\tcase 1:\n+\t\t   return \\\"%u0=%u1\\;%w0=%w1\\\";\n+\t        case 2:\n+\t           return \\\"%0=%0^%0\\\";\n+\t\tcase 3:\n+\t\t     return \\\"%u0=%U1\\;%w0=%H1\\\";\n+\t\tcase 4:\n+\t\t   double_reg_from_memory(operands);\n+\t\t   return \\\"\\\";\n+\t\tcase 5:\n+\t\t   double_reg_to_memory(operands);\n+\t\t   return \\\"\\\";\n+\t\tcase 6:\n+\t\tcase 7:\n+\t\t   return \\\"%u0=%u1\\;%w0=%w1\\\";\n+\t\tcase 8:\n+\t\tcase 9:\n+\t\t   return \\\"\\\";\n+        }\n+}\"\n+[(set_attr \"type\" \"move,move,load_i,load_i,load,store,load,store,move,move\")])\n+\n+\n+;; NOTE: It is cheaper to do 'y = *r0', than 'r0 = *r0'.\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+;; The movqi pattern with the parallel is used for addqi insns (which have a parallel)\n+;; that are turned into moveqi insns by the flow phase. This happens when a auto-increment\n+;; is detected.\n+\n+(define_insn \"match_movqi1\"\n+  [(parallel [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=A,r,aW,c,?D,m<>,e,Y,r,xyz,m<>\")\n+\t\t   (match_operand:QI 1 \"general_operand\"       \"r,A,J,i,m<>,D,Y,e,0,m<>,xyz\"))\n+\t      (clobber (match_scratch:QI 2 \"=X,X,X,X,X,X,X,X,X,X,X\"))])]\n+  \"register_operand(operands[0], QImode)\n+   || register_operand(operands[1], QImode)\"\n+  \"*\n+{\n+\tswitch (which_alternative)\n+\t{\n+\t\tcase 0:\n+\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n+\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumualtor\n+\t\t      , which we don't want */\n+\t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n+\t\t\t|| IS_ACCUM_REG(REGNO(operands[1])))\n+\t\t       return \\\"move %0=%1\\\";\n+\t\t   else\n+\t\t       return \\\"%0=%1\\\";\n+\n+\t\tcase 1:\n+ \t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 2:\n+\t\t   return \\\"set %0=%H1\\\";\n+\n+\t\tcase 3:\n+                   return \\\"%0=%H1\\\";\n+\n+\t\tcase 4:\n+\t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 5:\n+\t\tcase 6:\n+                   return \\\"%0=%1\\\";\n+\n+\t\tcase 7:\n+\t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 8:\n+\t\t   return \\\"\\\";\n+\n+                case 9: case 10:\n+\t\t   return \\\"%0=%1\\\";\n+\t}\n+}\")\n+\n+(define_insn \"match_movqi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=A,r,aW,c,?D,m<>,e,Y,r,xyz,m<>\")\n+\t(match_operand:QI 1 \"general_operand\"       \"r,A,J,i,m<>,D,Y,e,0,m<>,xyz\"))]\n+  \"register_operand(operands[0], QImode)\n+   || register_operand(operands[1], QImode)\"\n+  \"*\n+{\n+\tswitch (which_alternative)\n+\t{\n+\t\tcase 0:\n+\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n+\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumualtor\n+\t\t      , which we don't want */\n+\t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n+\t\t\t|| IS_ACCUM_REG(REGNO(operands[1])))\n+\t\t       return \\\"move %0=%1\\\";\n+\t\t   else\n+\t\t       return \\\"%0=%1\\\";\n+\n+\t\tcase 1:\n+ \t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 2:\n+\t\t   return \\\"set %0=%H1\\\";\n+\n+\t\tcase 3:\n+                   return \\\"%0=%H1\\\";\n+\n+\t\tcase 4:\n+\t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 5:\n+\t\tcase 6:\n+                   return \\\"%0=%1\\\";\n+\n+\t\tcase 7:\n+\t\t   return \\\"%0=%1\\\";\n+\n+\t\tcase 8:\n+\t\t   return \\\"\\\";\n+\n+                case 9: case 10:\n+\t\t   return \\\"%0=%1\\\";\n+\t}\n+}\")\n+\n+(define_expand \"reload_inqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=u\")\n+        (match_operand:QI 1 \"sp_operand\" \"\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&q\"))]\n+  \"\"\n+  \"\n+{\n+  rtx addr_reg = XEXP (operands[1], 0);\n+  rtx offset = XEXP (operands[1], 1);\n+\n+  /* First, move the frame or stack pointer to the accumulator */\n+  emit_move_insn (operands[0], addr_reg);\n+\n+  /* Then generate the add insn */\n+  emit_insn (gen_rtx (PARALLEL, VOIDmode, \n+\t\t      gen_rtvec (2,\n+\t\t\t\t gen_rtx (SET, VOIDmode, operands[0], \n+\t\t\t\t\t  gen_rtx (PLUS, QImode, operands[0], offset)),\n+\t\t\t\t gen_rtx (CLOBBER, VOIDmode, operands[2]))));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_inhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&h\"))]\n+  \"\"\n+  \"\n+{\n+  /* Check for an overlap of operand 2 (an accumulator) with\n+     the msw of operand 0. If we have an overlap we must reverse\n+     the order of the moves. */\n+\n+  if (REGNO(operands[2]) == REGNO(operands[0]))\n+    {\n+      emit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HImode));\n+      emit_move_insn (operand_subword (operands[0], 1, 0, HImode), operands[2]);\n+      emit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HImode));\n+      emit_move_insn (operand_subword (operands[0], 0, 0, HImode), operands[2]);\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HImode));\n+      emit_move_insn (operand_subword (operands[0], 0, 0, HImode), operands[2]);\n+      emit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HImode));\n+      emit_move_insn (operand_subword (operands[0], 1, 0, HImode), operands[2]);\n+    }\n+\n+  DONE;\n+}\")\n+\n+\n+(define_expand \"reload_outhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&h\"))]\n+  \"\"\n+  \"\n+{\n+\temit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HImode));\n+\temit_move_insn (operand_subword (operands[0], 0, 0, HImode), operands[2]);\n+\temit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HImode));\n+\temit_move_insn (operand_subword (operands[0], 1, 0, HImode), operands[2]);\n+\tDONE;\n+}\")\n+\n+(define_expand \"movstrqi\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n+\t      (use (match_operand:QI 2 \"const_int_operand\" \"\"))\n+\t      (use (match_operand:QI 3 \"const_int_operand\" \"\"))\n+\t      (clobber (match_scratch:QI 4 \"\"))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (match_dup 6))])]\n+  \"\"\n+  \"\n+{\n+  rtx addr0, addr1;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  if (INTVAL(operands[2]) > 127)\n+    FAIL;\n+\n+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+\n+  operands[5] = addr0;\n+  operands[6] = addr1;\n+\n+  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+  operands[1] = gen_rtx (MEM, BLKmode, addr1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:QI 0 \"register_operand\" \"a\"))\n+\t(mem:BLK (match_operand:QI 1 \"register_operand\" \"a\")))\n+   (use (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+   (use (match_operand:QI 3 \"immediate_operand\" \"i\"))\n+   (clobber (match_scratch:QI 4 \"=x\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"*\n+{ return output_block_move (operands); }\")\n+\n+\f\n+;; Floating point move insns\n+\n+\n+(define_expand \"movhf\"\n+  [(set (match_operand:HF 0 \"general_operand\" \"\")\n+\t(match_operand:HF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"match_movhf\"\n+  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=A,Z,d,d,m,d,Y\")\n+\t(match_operand:HF 1 \"general_operand\"       \"d,A,F,m,d,Y,d\"))]\n+  \"\"\n+  \"*\n+{\n+\t/* NOTE: When loading the register 16 bits at a time we\n+\t   MUST load the high half FIRST (because the 1610 zeros\n+\t   the low half) and then load the low half */\n+\n+\tswitch (which_alternative)\n+        {\n+\t\t/* register to accumulator */\n+\t\tcase 0:\n+ \t\t   return \\\"%0=%1\\\";\n+\t\tcase 1:\n+\t\t   return \\\"%u0=%u1\\;%w0=%w1\\\";\n+\t\tcase 2:\n+\t\t   output_dsp16xx_float_const(operands);\n+\t\t   return \\\"\\\";\n+\t\tcase 3:\n+\t\t   double_reg_from_memory(operands);\n+\t\t   return \\\"\\\";\n+\t\tcase 4:\n+\t\t   double_reg_to_memory(operands);\n+\t\t   return \\\"\\\";\n+\t\tcase 5:\n+\t\tcase 6:\n+\t\t   return \\\"%u0=%u1\\;%w0=%w1\\\";\n+        }\n+}\"\n+[(set_attr \"type\" \"move,move,load_i,load,store,load,store\")])\n+\n+\n+\n+(define_expand \"reload_inhf\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n+        (match_operand:HF 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&h\"))]\n+  \"\"\n+  \"\n+{\n+  /* Check for an overlap of operand 2 (an accumulator) with\n+     the msw of operand 0. If we have an overlap we must reverse\n+     the order of the moves. */\n+\n+  if (REGNO(operands[2]) == REGNO(operands[0]))\n+    {\n+      emit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HFmode));\n+      emit_move_insn (operand_subword (operands[0], 1, 0, HFmode), operands[2]);\n+      emit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HFmode));\n+      emit_move_insn (operand_subword (operands[0], 0, 0, HFmode), operands[2]);\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HFmode));\n+      emit_move_insn (operand_subword (operands[0], 0, 0, HFmode), operands[2]);\n+      emit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HFmode));\n+      emit_move_insn (operand_subword (operands[0], 1, 0, HFmode), operands[2]);\n+    }\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outhf\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n+        (match_operand:HF 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&h\"))]\n+  \"\"\n+  \"\n+{\n+\temit_move_insn (operands[2], operand_subword (operands[1], 0, 0, HFmode));\n+\temit_move_insn (operand_subword (operands[0], 0, 0, HFmode), operands[2]);\n+\temit_move_insn (operands[2], operand_subword (operands[1], 1, 0, HFmode));\n+\temit_move_insn (operand_subword (operands[0], 1, 0, HFmode), operands[2]);\n+\tDONE;\n+}\")\n+\n+\f\n+;;\n+;; CONVERSION INSTRUCTIONS\n+;;\n+\n+(define_expand \"extendqihi2\"\n+  [(clobber (match_dup 2))\n+   (set (match_dup 3) (match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashift:HI (match_dup 2)\n+\t\t   (const_int 16)))\n+   (set (match_dup 0)\n+\t(ashiftrt:HI (match_dup 0) (const_int 16)))]\n+  \"\"\n+  \"\n+{\n+\toperands[2] = gen_reg_rtx (HImode);\n+\toperands[3] = gen_rtx (SUBREG, QImode, operands[2], 1);\n+}\")\n+\n+;;(define_insn \"extendqihi2\"\n+;;  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+;;        (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"h\")))]\n+;;  \"\"\n+;;  \"%0 = %1 >> 16\")\n+\n+;;(define_insn \"zero_extendqihi2\"\n+;;  [(set (match_operand:HI 0 \"register_operand\" \"=t,f,A,?d,?A\")\n+;;        (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"w,z,ku,A,r\")))]\n+;;  \"\"\n+;;  \"*\n+;; {\n+;;  switch (which_alternative)\n+;;    {\n+;;    case 0:\n+;;    case 1:\n+;;      return \\\"%0=0\\\";\n+;;\n+;;    case 2:\n+;;      if (REGNO(operands[1]) == (REGNO(operands[0]) + 1))\n+;;        return \\\"%0=0\\\";\n+;;      else\n+;;\treturn \\\"%w0=%1\\;%0=0\\\";\n+;;    case 3:\n+;;      return \\\"%w0=%1\\;%0=0\\\";\n+;;\n+;;    case 4:\n+;;      if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n+;;\t  || IS_ACCUM_REG(REGNO(operands[1])))\n+;;\treturn \\\"move %w0=%1\\;%0=0\\\";\n+;;      else\n+;;\treturn \\\"%w0=%1\\;%0=0\\\";\n+;;    }\n+;; }\")\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(clobber (match_dup 2))\n+   (set (match_dup 3) (match_operand:QI 1 \"register_operand\" \"\"))\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashift:HI (match_dup 2)\n+\t\t   (const_int 16)))\n+   (set (match_dup 0)\n+\t(lshiftrt:HI (match_dup 0) (const_int 16)))]\n+  \"\"\n+  \"\n+{\n+\toperands[2] = gen_reg_rtx (HImode);\n+\toperands[3] = gen_rtx (SUBREG, QImode, operands[2], 1);\n+}\")\n+\n+\n+(define_expand \"floathihf2\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"\")\n+\t(float:HF (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_floathihf2_libcall)\n+    dsp16xx_floathihf2_libcall = gen_rtx (SYMBOL_REF, Pmode, FLOATHIHF2_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_floathihf2_libcall, 1, HFmode, 1,\n+\t\t     operands[1], HImode);\n+  emit_move_insn (operands[0], hard_libcall_value(HFmode));\n+  DONE;\n+}\")\n+\n+(define_expand \"fix_trunchfhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(fix:HI (match_operand:HF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!dsp16xx_fixhfhi2_libcall)\n+    dsp16xx_fixhfhi2_libcall = gen_rtx (SYMBOL_REF, Pmode, FIXHFHI2_LIBCALL);\n+  \n+  emit_library_call (dsp16xx_fixhfhi2_libcall, 1, HImode, 1,\n+\t\t     operands[1], HFmode);\n+  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+  DONE;\n+}\")\n+\n+(define_expand \"fixuns_trunchfhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:HI (match_operand:HF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx reg1 = gen_reg_rtx (HFmode);\n+  rtx reg2 = gen_reg_rtx (HFmode);\n+  rtx reg3 = gen_reg_rtx (HImode);\n+  rtx label1 = gen_label_rtx ();\n+  rtx label2 = gen_label_rtx ();\n+  REAL_VALUE_TYPE offset = REAL_VALUE_LDEXP (1.0, 31);\n+\n+  if (reg1)\t\t\t/* turn off complaints about unreached code */\n+    {\n+      emit_move_insn (reg1, immed_real_const_1 (offset, HFmode));\n+      do_pending_stack_adjust ();\n+\n+      emit_insn (gen_cmphf (operands[1], reg1));\n+      emit_jump_insn (gen_bge (label1));\n+\n+      emit_insn (gen_fix_trunchfhi2 (operands[0], operands[1]));\n+      emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx (LABEL_REF, VOIDmode, label2)));\n+      emit_barrier ();\n+\n+      emit_label (label1);\n+      emit_insn (gen_subhf3 (reg2, operands[1], reg1));\n+      emit_move_insn (reg3, GEN_INT (0x80000000));;\n+\n+      emit_insn (gen_fix_trunchfhi2 (operands[0], reg2));\n+      emit_insn (gen_iorhi3 (operands[0], operands[0], reg3));\n+\n+      emit_label (label2);\n+\n+      /* allow REG_NOTES to be set on last insn (labels don't have enough\n+\t fields, and can't be used for REG_NOTES anyway).  */\n+      emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n+      DONE;\n+    }\n+}\")\n+\n+;;\n+;; SHIFT INSTRUCTIONS\n+;;\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 1)))]\n+  \"\"\n+  \"%0=%1>>1\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 4)))]\n+  \"\"\n+  \"%0=%1>>4\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 8)))]\n+  \"\"\n+  \"%0=%1>>8\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 16)))]\n+  \"\"\n+  \"%0=%1>>16\"\n+  [(set_attr \"type\" \"special\")])\n+\f\n+;;\n+;; Arithmetic Right shift\n+\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+                     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_BMU)\n+  {\n+      /* If we are shifting by a constant we can do it in 1 or more\n+\t 1600 core shift instructions. The core instructions can\n+\t shift by 1, 4, 8, or 16. */\n+      \n+      if (GET_CODE(operands[2]) == CONST_INT)\n+\t;\n+      else\n+      {\n+\trtx label1 = gen_label_rtx ();\n+\trtx label2 = gen_label_rtx ();\n+\n+#if 0\n+\tif (!dsp16xx_ashrhi3_libcall)\n+\t  dsp16xx_ashrhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, ASHRHI3_LIBCALL);\n+\n+\t  emit_library_call (dsp16xx_ashrhi3_libcall, 1, HImode, 2,\n+\t\t\t     operands[1], HImode,\n+\t\t\t     operands[2], QImode);\n+\t  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+\t  DONE;\n+#else\n+\tdo_pending_stack_adjust ();\n+\temit_insn (gen_tstqi (operands[2]));\n+\temit_jump_insn (gen_bne (label1));\n+\temit_move_insn (operands[0], operands[1]);\n+\temit_jump_insn (gen_jump (label2));\n+\temit_barrier ();\n+\temit_label (label1);\n+\n+\tif (GET_CODE(operands[2]) != MEM)\n+\t  {\n+\t    rtx stack_slot;\n+\t    \n+\t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n+\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t    emit_move_insn (stack_slot, operands[2]);\n+\t    operands[2] = stack_slot;\n+\t  }\n+\n+\temit_insn (gen_match_ashrhi3_nobmu (operands[0], operands[1], operands[2]));\n+\temit_label (label2);\n+\tDONE;\n+#endif\n+      }\n+  }\n+}\")\n+\n+(define_insn \"match_ashrhi3_bmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A,A,!A\")\n+                     (match_operand:QI 2 \"nonmemory_operand\" \"B,I,h\")))]\n+  \"TARGET_BMU\"\n+  \"@\n+   %0=%1>>%2\n+   %0=%1>>%H2\n+   %0=%1>>%2\"\n+  [(set_attr \"type\" \"shift,shift_i,shift\")])\n+\n+(define_insn \"match_ashrhi3_nobmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"A,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"n,m\")))]\n+  \"!TARGET_BMU\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      emit_1600_core_shift (ASHIFTRT, operands, INTVAL(operands[2]));\n+      return \\\"\\\";\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"cloop=%2\\\", operands);\n+      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"%0=%0>>1\\\", operands);\n+      return \\\"\\}\\\";\n+    }\n+}\")\n+\t\t   \n+\n+\f\n+;;\n+;; Logical Right Shift\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 1)))]\n+  \"\"\n+  \"%0=%1>>1\\;%0=%b0&0x7fff\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 4)))]\n+  \"\"\n+  \"%0=%1>>4\\;%0=%b0&0x0fff\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 8)))]\n+  \"\"\n+  \"%0=%1>>8\\;%0=%b0&0x00ff\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                     (const_int 16)))]\n+  \"\"\n+  \"%0=%1>>16\\;%0=%b0&0x0000\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+                     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_BMU)\n+    {\n+      /* If we are shifting by a constant we can do it in 1 or more\n+\t 1600 core shift instructions. The core instructions can\n+\t shift by 1, 4, 8, or 16. */\n+      \n+      if (GET_CODE(operands[2]) == CONST_INT)\n+\temit_insn (gen_match_lshrhi3_nobmu (operands[0], operands[1], operands[2]));\t\n+      else\n+\t{\n+\t  rtx label1 = gen_label_rtx ();\n+\t  rtx label2 = gen_label_rtx ();\n+#if 0\n+\t  if (!dsp16xx_lshrhi3_libcall)\n+\t    dsp16xx_lshrhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, LSHRHI3_LIBCALL);\n+\t  \n+\t  emit_library_call (dsp16xx_lshrhi3_libcall, 1, HImode, 2,\n+\t\t\t     operands[1], HImode,\n+\t\t\t     operands[2], QImode);\n+\t  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+\t  DONE;\n+#else\n+\t  do_pending_stack_adjust ();\n+\t  emit_insn (gen_tstqi (operands[2]));\n+\t  emit_jump_insn (gen_bne (label1));\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  emit_jump_insn (gen_jump (label2));\n+\t  emit_barrier ();\n+\t  emit_label (label1);\n+\n+\t  if (GET_CODE(operands[2]) != MEM)\n+\t    {\n+\t      rtx stack_slot;\n+\t    \n+\t      stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n+\t      stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t      emit_move_insn (stack_slot, operands[2]);\n+\t      operands[2] = stack_slot;\n+\t    }\n+\n+\t  emit_insn (gen_match_lshrhi3_nobmu (operands[0], operands[1], operands[2]));\n+\t  emit_label (label2);\n+\t  DONE;\n+#endif\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"match_lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A,A,!A\")\n+                     (match_operand:QI 2 \"nonmemory_operand\" \"B,I,h\")))]\n+  \"TARGET_BMU\"\n+  \"@\n+   %0=%1>>>%2\n+   %0=%1>>>%H2\n+   %0=%1>>>%2\"\n+  [(set_attr \"type\" \"shift,shift_i,shift\")])\n+\n+(define_insn \"match_lshrhi3_nobmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"A,0\")\n+                     (match_operand:QI 2 \"general_operand\" \"n,m\")))\n+   (clobber (match_scratch:QI 3 \"=X,Y\"))]\n+  \"!TARGET_BMU\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      emit_1600_core_shift (LSHIFTRT, operands, INTVAL(operands[2]));\n+      return \\\"\\\";\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"%3=psw\\;psw=0\\\",operands);\n+      output_asm_insn (\\\"cloop=%2\\\", operands);\n+      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"%0=%0>>1\\\", operands);\n+      output_asm_insn (\\\"\\}\\\", operands);\n+      return \\\"psw=%3\\\";\n+    }\n+}\")\n+\n+\f\n+;;\n+;; Arithmetic Left shift\n+\n+;; Start off with special case arithmetic left shift by 1,4,8 or 16.\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                   (const_int 1)))]\n+  \"\"\n+  \"%0=%1<<1\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                   (const_int 4)))]\n+  \"\"\n+  \"%0=%1<<4\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+                   (const_int 8)))]\n+  \"\"\n+  \"%0=%1<<8\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+\t(ashift:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"A\"))\n+\t\t   (const_int 16)))]\n+  \"\"\n+  \"%0=%1<<16\"\n+  [(set_attr \"type\" \"special\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+        (ashift:HI (match_operand:HI 1 \"general_operand\" \"A\")\n+                   (const_int 16)))]\n+  \"\"\n+  \"%0=%1<<16\"\n+  [(set_attr \"type\" \"special\")])\n+\n+\n+\f\n+;; Normal Arithmetic Shift Left\n+\n+\n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n+                   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_BMU)\n+  {\n+      /* If we are shifting by a constant we can do it in 1 or more\n+\t 1600 core shift instructions. The core instructions can\n+\t shift by 1, 4, 8, or 16. */\n+      \n+      if (GET_CODE(operands[2]) == CONST_INT)\n+\t;\n+      else\n+      {\n+\trtx label1 = gen_label_rtx ();\n+\trtx label2 = gen_label_rtx ();\n+#if 0\n+\tif (!dsp16xx_ashlhi3_libcall)\n+\t  dsp16xx_ashlhi3_libcall = gen_rtx (SYMBOL_REF, Pmode, ASHLHI3_LIBCALL);\n+\n+\t  emit_library_call (dsp16xx_ashlhi3_libcall, 1, HImode, 2,\n+\t\t\t     operands[1], HImode,\n+\t\t\t     operands[2], QImode);\n+\t  emit_move_insn (operands[0], hard_libcall_value(HImode));\n+\t  DONE;\n+#else\n+\tdo_pending_stack_adjust ();\n+\temit_insn (gen_tstqi (operands[2]));\n+\temit_jump_insn (gen_bne (label1));\n+\temit_move_insn (operands[0], operands[1]);\n+\temit_jump_insn (gen_jump (label2));\n+\temit_barrier ();\n+\temit_label (label1);\n+\n+\tif (GET_CODE(operands[2]) != MEM)\n+\t  {\n+\t    rtx stack_slot;\n+\t    \n+\t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n+\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t    emit_move_insn (stack_slot, operands[2]);\n+\t    operands[2] = stack_slot;\n+\t  }\n+\temit_insn (gen_match_ashlhi3_nobmu (operands[0], operands[1], operands[2]));\n+\temit_label (label2);\n+\tDONE;\n+#endif\n+      }\n+  }\n+}\")\n+\n+(define_insn \"match_ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A,A\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"A,A,A\")\n+                   (match_operand:QI 2 \"nonmemory_operand\" \"B,I,!h\")))]\n+  \"TARGET_BMU\"\n+  \"@\n+   %0=%1<<%2\\;move %u0=%u0\n+   %0=%1<<%H2\\;move %u0=%u0\n+   %0=%1<<%2\\;move %u0=%u0\"\n+  [(set_attr \"type\" \"shift,shift_i,shift\")])\n+\n+(define_insn \"match_ashlhi3_nobmu\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A,A\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\" \"A,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"n,m\")))]\n+  \"!TARGET_BMU\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      emit_1600_core_shift (ASHIFT, operands, INTVAL(operands[2]));\n+      return \\\"\\\";\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"cloop=%2\\\", operands);\n+      output_asm_insn (\\\"do 0 \\{\\\", operands);\n+      output_asm_insn (\\\"%0=%0<<1\\\", operands);\n+      return \\\"\\}\\\";\n+    }\n+}\")\n+\n+\f\n+\n+;;\n+;; Jump Instructions\n+;;\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1)\n+\t                  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(EQ, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(NE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1)\n+\t                  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GT, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1)\n+\t                  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1)\n+\t                  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LT, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1)\n+\t                  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LE, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1)\n+\t                   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GTU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1)\n+\t                   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(GEU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1)\n+\t                   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LTU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1)\n+\t                   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ \n+   if (dsp16xx_compare_gen == gen_compare_reg)\n+     operands[1] = (*dsp16xx_compare_gen)(LEU, dsp16xx_compare_op0, dsp16xx_compare_op1);\n+   else\n+     operands[1] = (*dsp16xx_compare_gen)(dsp16xx_compare_op0);\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l0\\;if %C1 goto pt\"\n+  [(set_attr \"type\" \"cond_jump\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_NEAR_JUMP\"\n+  \"if %C1 goto %l0\"\n+  [(set_attr \"type\" \"cond_jump\")])\n+\f\n+;;\n+;; Negated conditional jump instructions.\n+;; These are necessary because jump optimization can turn\n+;; direct-conditional branches into reverse-conditional\n+;; branches.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t              (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"!TARGET_NEAR_JUMP\"\n+  \"pt=%l0\\;if %I1 goto pt\"\n+  [(set_attr \"type\" \"cond_jump\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\" \n+                                      [(cc0) (const_int 0)])\n+\t              (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"TARGET_NEAR_JUMP\"\n+  \"if %I1 goto %l0\"\n+  [(set_attr \"type\" \"cond_jump\")])\n+\n+\n+;;\n+;; JUMPS\n+;;\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+        (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+   {\n+\tif (TARGET_NEAR_JUMP)\n+\t    return \\\"goto %l0\\\";\n+        else\n+\t    return \\\"pt=%l0\\;goto pt\\\";\n+   }\"\n+   [(set_attr \"type\" \"jump\")])\n+\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:QI 0 \"register_operand\" \"A\"))]\n+  \"\"\n+  \"pt=%0\\;goto pt\"\n+   [(set_attr \"type\" \"jump\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:QI 0 \"register_operand\" \"A\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"pt=%0\\;goto pt\"\n+   [(set_attr \"type\" \"jump\")])\n+\f\n+;;\n+;; FUNCTION CALLS\n+;;\n+\n+;; Call subroutine with no return value.\n+\n+\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand:QI 0 \"\" \"\")\n+\t            (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:QI 24))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! call_address_operand (XEXP (operands[0], 0), QImode))\n+    operands[0] = gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[0], 0)));\n+}\")\n+\n+(define_insn \"\"\n+  [(parallel [(call (mem:QI (match_operand:QI 0 \"call_address_operand\" \"hR\"))\n+\t                    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:QI 24))])]\n+  \"\"\n+  \"*\n+{\n+    if (GET_CODE (operands[0]) == REG || \n+\t(GET_CODE(operands[0]) == SYMBOL_REF && !TARGET_NEAR_CALL))\n+\treturn \\\"pt=%0\\;call pt\\\";\n+    else\n+        return \\\"call %0\\\";\n+}\"\n+[(set_attr \"type\" \"call\")])\n+\n+;; Call subroutine with return value.\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=f\")\n+\t\t  (call (match_operand:QI 1 \"call_address_operand\" \"hR\")\n+\t                (match_operand:QI 2 \"\" \"\")))\n+\t      (clobber (reg:QI 24))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && ! call_address_operand (XEXP (operands[1], 0), QImode))\n+    operands[1] = gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t\t   force_reg (Pmode, XEXP (operands[1], 0)));\n+}\")\n+\n+(define_insn \"\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=f\")\n+\t\t  (call (mem:QI (match_operand:QI 1 \"call_address_operand\" \"hR\"))\n+\t                        (match_operand:QI 2 \"\" \"\")))\n+\t      (clobber (reg:QI 24))])]\n+  \"\"\n+  \"*\n+{\n+    if (GET_CODE (operands[1]) == REG ||\n+\t(GET_CODE(operands[1]) == SYMBOL_REF && !TARGET_NEAR_CALL))\n+\treturn \\\"pt=%1\\;call pt\\\";\n+    else\n+        return \\\"call %1\\\";\n+}\"\n+[(set_attr \"type\" \"call\")])\n+\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\"     \"nop\")])\n+\f\n+;;\n+;; PEEPHOLE PATTERNS\n+;;\n+\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"=A\")\n+        (reg:QI 16))\n+   (call (mem:QI (match_dup 0))\n+\t (match_operand 1 \"\" \"i\"))]\n+   \"\"\n+   \"call pt\")\n+\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"=A\")\n+        (reg:QI 16))\n+   (set (match_operand 1 \"\" \"\")\n+        (call (mem:QI (match_dup 0))\n+\t      (match_operand 2 \"\" \"i\")))]\n+   \"\"\n+   \"call pt\")\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+\t\t   (const_int 16)))\n+   (set (match_operand:HI 2 \"register_operand\" \"\")\n+\t(match_dup 0))\n+   (set (match_dup 0)\n+\t(ashiftrt:HI (match_dup 0) (const_int 16)))\n+   (set (match_dup 2)\n+\t(match_dup 0))]\n+  \"\"\n+  \"%0=%1<<16\\;%0=%0>>16\\;%u2=%u0\\;%w2=%w0\")\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"register_operand\" \"=A\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"A\")\n+\t\t   (const_int 16)))\n+   (set (match_operand:HI 2 \"register_operand\" \"\")\n+\t(match_dup 0))\n+   (set (match_dup 0)\n+\t(lshiftrt:HI (match_dup 0) (const_int 16)))\n+   (set (match_dup 2)\n+\t(match_dup 0))]\n+  \"\"\n+  \"%0=%1<<16\\;%0=%0>>16\\;%0=%b0&0x0000\\;%u2=%u0\\;%w2=%w0\")"}, {"sha": "45e7d370a4b75a2ab2841e516948d3f52d63d0a9", "filename": "gcc/config/dsp16xx/xm-dsp16xx.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d93578fe8533ece4c2fe535e865c0c914d28ad11/gcc%2Fconfig%2Fdsp16xx%2Fxm-dsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d93578fe8533ece4c2fe535e865c0c914d28ad11/gcc%2Fconfig%2Fdsp16xx%2Fxm-dsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fxm-dsp16xx.h?ref=d93578fe8533ece4c2fe535e865c0c914d28ad11", "patch": "@@ -0,0 +1,45 @@\n+/* Configuration file for GNU CC for AT&T DSP1600.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Contributed by Michael Collison (collison@world.std.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 16\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* If compiled with GNU C, use the built-in alloca */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#else\n+#define USE_C_ALLOCA\n+#endif\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\""}]}