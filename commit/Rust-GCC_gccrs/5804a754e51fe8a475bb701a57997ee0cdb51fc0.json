{"sha": "5804a754e51fe8a475bb701a57997ee0cdb51fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwNGE3NTRlNTFmZThhNDc1YmI3MDFhNTc5OTdlZTBjZGI1MWZjMA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-08-21T19:38:35Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-08-21T19:38:35Z"}, "message": "c-common.c (init_dollar_format_checking, [...]): New functions.\n\n\t* c-common.c (init_dollar_format_checking,\n\tmaybe_read_dollar_number, finish_dollar_format_checking): New\n\tfunctions.\n\t(dollar_arguments_used, dollar_arguments_count,\n\tdollar_first_arg_num, dollar_max_arg_used, dollar_format_warned):\n\tNew variables.\n\t(check_format_info): Support $ formats for scanf and printf width\n\tand precision.  Always increment format_chars to advance past the\n\t'*' of precision, not just when the format parameters are\n\tavailable to check.\n\ntestsuite:\n\t* gcc.dg/c90-printf-3.c, gcc.dg/c90-scanf-2.c,\n\tgcc.dg/c90-scanf-3.c, gcc.dg/c90-scanf-4.c,\n\tgcc.dg/c90-strftime-1.c, gcc.dg/c99-printf-3.c,\n\tgcc.dg/c99-scanf-1.c, gcc.dg/c99-scanf-2.c, gcc.dg/c99-scanf-3.c,\n\tgcc.dg/format-xopen-1.c: New tests.\n\nFrom-SVN: r35856", "tree": {"sha": "8730d3f18920ed07d8b2808ade31db763a22f512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8730d3f18920ed07d8b2808ade31db763a22f512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5804a754e51fe8a475bb701a57997ee0cdb51fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5804a754e51fe8a475bb701a57997ee0cdb51fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5804a754e51fe8a475bb701a57997ee0cdb51fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5804a754e51fe8a475bb701a57997ee0cdb51fc0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95adab8e110925c9f13fb4ff16afb942a62c2af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95adab8e110925c9f13fb4ff16afb942a62c2af6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95adab8e110925c9f13fb4ff16afb942a62c2af6"}], "stats": {"total": 896, "additions": 864, "deletions": 32}, "files": [{"sha": "a800469bff0c55681bc81cb5e8be9ca5b34b6a5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -1,3 +1,16 @@\n+2000-08-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (init_dollar_format_checking,\n+\tmaybe_read_dollar_number, finish_dollar_format_checking): New\n+\tfunctions.\n+\t(dollar_arguments_used, dollar_arguments_count,\n+\tdollar_first_arg_num, dollar_max_arg_used, dollar_format_warned):\n+\tNew variables.\n+\t(check_format_info): Support $ formats for scanf and printf width\n+\tand precision.  Always increment format_chars to advance past the\n+\t'*' of precision, not just when the format parameters are\n+\tavailable to check.\n+\n 2000-08-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips.c (block_move_loop, expand_block_move,"}, {"sha": "5e46af0c1c8dfbd11b39e4e1aa564b0b581f964f", "filename": "gcc/c-common.c", "status": "modified", "additions": 236, "deletions": 32, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -1324,6 +1324,11 @@ static international_format_info *international_format_list = NULL;\n \n static void check_format_info\tPARAMS ((function_format_info *, tree));\n \n+static void init_dollar_format_checking\t\tPARAMS ((int, tree));\n+static int maybe_read_dollar_number\t\tPARAMS ((const char **, int,\n+\t\t\t\t\t\t\t tree, tree *));\n+static void finish_dollar_format_checking\tPARAMS ((void));\n+\n /* Initialize the table of functions to perform format checking on.\n    The ISO C functions are always checked (whether <stdio.h> is\n    included or not), since it is common to call printf without\n@@ -1501,6 +1506,169 @@ check_function_format (name, assembler_name, params)\n     }\n }\n \n+\n+/* Variables used by the checking of $ operand number formats.  */\n+static char *dollar_arguments_used = NULL;\n+static int dollar_arguments_alloc = 0;\n+static int dollar_arguments_count;\n+static int dollar_first_arg_num;\n+static int dollar_max_arg_used;\n+static int dollar_format_warned;\n+\n+/* Initialize the checking for a format string that may contain $\n+   parameter number specifications; we will need to keep track of whether\n+   each parameter has been used.  FIRST_ARG_NUM is the number of the first\n+   argument that is a parameter to the format, or 0 for a vprintf-style\n+   function; PARAMS is the list of arguments starting at this argument.  */\n+\n+static void\n+init_dollar_format_checking (first_arg_num, params)\n+     int first_arg_num;\n+     tree params;\n+{\n+  dollar_first_arg_num = first_arg_num;\n+  dollar_arguments_count = 0;\n+  dollar_max_arg_used = 0;\n+  dollar_format_warned = 0;\n+  if (first_arg_num > 0)\n+    {\n+      while (params)\n+\t{\n+\t  dollar_arguments_count++;\n+\t  params = TREE_CHAIN (params);\n+\t}\n+    }\n+  if (dollar_arguments_alloc < dollar_arguments_count)\n+    {\n+      if (dollar_arguments_used)\n+\tfree (dollar_arguments_used);\n+      dollar_arguments_alloc = dollar_arguments_count;\n+      dollar_arguments_used = xmalloc (dollar_arguments_alloc);\n+    }\n+  if (dollar_arguments_alloc)\n+    memset (dollar_arguments_used, 0, dollar_arguments_alloc);\n+}\n+\n+\n+/* Look for a decimal number followed by a $ in *FORMAT.  If DOLLAR_NEEDED\n+   is set, it is an error if one is not found; otherwise, it is OK.  If\n+   such a number is found, check whether it is within range and mark that\n+   numbered operand as being used for later checking.  Returns the operand\n+   number if found and within range, zero if no such number was found and\n+   this is OK, or -1 on error.  PARAMS points to the first operand of the\n+   format; PARAM_PTR is made to point to the parameter referred to.  If\n+   a $ format is found, *FORMAT is updated to point just after it.  */\n+\n+static int\n+maybe_read_dollar_number (format, dollar_needed, params, param_ptr)\n+     const char **format;\n+     int dollar_needed;\n+     tree params;\n+     tree *param_ptr;\n+{\n+  int argnum;\n+  int overflow_flag;\n+  const char *fcp = *format;\n+  if (*fcp < '0' || *fcp > '9')\n+    {\n+      if (dollar_needed)\n+\t{\n+\t  warning (\"missing $ operand number in format\");\n+\t  return -1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  argnum = 0;\n+  overflow_flag = 0;\n+  while (*fcp >= '0' && *fcp <= '9')\n+    {\n+      int nargnum;\n+      nargnum = 10 * argnum + (*fcp - '0');\n+      if (nargnum < 0 || nargnum / 10 != argnum)\n+\toverflow_flag = 1;\n+      argnum = nargnum;\n+      fcp++;\n+    }\n+  if (*fcp != '$')\n+    {\n+      if (dollar_needed)\n+\t{\n+\t  warning (\"missing $ operand number in format\");\n+\t  return -1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  *format = fcp + 1;\n+  if (pedantic && !dollar_format_warned)\n+    {\n+      warning (\"ISO C does not support %%n$ operand number formats\");\n+      dollar_format_warned = 1;\n+    }\n+  if (overflow_flag || argnum == 0\n+      || (dollar_first_arg_num && argnum > dollar_arguments_count))\n+    {\n+      warning (\"operand number out of range in format\");\n+      return -1;\n+    }\n+  if (argnum > dollar_max_arg_used)\n+    dollar_max_arg_used = argnum;\n+  /* For vprintf-style functions we may need to allocate more memory to\n+     track which arguments are used.  */\n+  while (dollar_arguments_alloc < dollar_max_arg_used)\n+    {\n+      int nalloc;\n+      nalloc = 2 * dollar_arguments_alloc + 16;\n+      dollar_arguments_used = xrealloc (dollar_arguments_used, nalloc);\n+      memset (dollar_arguments_used + dollar_arguments_alloc, 0,\n+\t      nalloc - dollar_arguments_alloc);\n+      dollar_arguments_alloc = nalloc;\n+    }\n+  dollar_arguments_used[argnum - 1] = 1;\n+  if (dollar_first_arg_num)\n+    {\n+      int i;\n+      *param_ptr = params;\n+      for (i = 1; i < argnum && *param_ptr != 0; i++)\n+\t*param_ptr = TREE_CHAIN (*param_ptr);\n+\n+      if (*param_ptr == 0)\n+\t{\n+\t  /* This case shouldn't be caught here.  */\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    *param_ptr = 0;\n+  return argnum;\n+}\n+\n+\n+/* Finish the checking for a format string that used $ operand number formats\n+   instead of non-$ formats.  We check for unused operands before used ones\n+   (a serious error, since the implementation of the format function\n+   can't know what types to pass to va_arg to find the later arguments).\n+   and for unused operands at the end of the format (if we know how many\n+   arguments the format had, so not for vprintf).  If there were operand\n+   numbers out of range on a non-vprintf-style format, we won't have reached\n+   here.  */\n+\n+static void\n+finish_dollar_format_checking ()\n+{\n+  int i;\n+  for (i = 0; i < dollar_max_arg_used; i++)\n+    {\n+      if (!dollar_arguments_used[i])\n+\twarning (\"format argument %d unused before used argument %d in $-style format\",\n+\t\t i + 1, dollar_max_arg_used);\n+    }\n+  if (dollar_first_arg_num && dollar_max_arg_used < dollar_arguments_count)\n+    warning (\"unused arguments in $-style format\");\n+}\n+\n+\n /* Check the argument list of a call to printf, scanf, etc.\n    INFO points to the function_format_info structure.\n    PARAMS is the list of argument values.  */\n@@ -1524,7 +1692,9 @@ check_format_info (info, params)\n   const char *format_chars;\n   format_char_info *fci = NULL;\n   char flag_chars[8];\n-  int has_operand_number = 0;\n+  /* -1 if no conversions taking an operand have been found; 0 if one has\n+     and it didn't use $; 1 if $ formats are in use.  */\n+  int has_operand_number = -1;\n \n   /* Skip to format argument.  If the argument isn't available, there's\n      no work for us to do; prototype checking will catch the problem.  */\n@@ -1624,6 +1794,7 @@ check_format_info (info, params)\n     }\n \n   first_fillin_param = params;\n+  init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n   while (1)\n     {\n       int aflag;\n@@ -1633,8 +1804,11 @@ check_format_info (info, params)\n \t{\n \t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n \t    warning (\"embedded `\\\\0' in format\");\n-\t  if (info->first_arg_num != 0 && params != 0 && ! has_operand_number)\n+\t  if (info->first_arg_num != 0 && params != 0\n+\t      && has_operand_number <= 0)\n \t    warning (\"too many arguments for format\");\n+\t  if (has_operand_number > 0)\n+\t    finish_dollar_format_checking ();\n \t  return;\n \t}\n       if (*format_chars++ != '%')\n@@ -1657,6 +1831,22 @@ check_format_info (info, params)\n \t  suppressed = *format_chars == '*';\n \t  if (suppressed)\n \t    ++format_chars;\n+\t  else if (has_operand_number != 0)\n+\t    {\n+\t      int opnum;\n+\t      opnum = maybe_read_dollar_number (&format_chars,\n+\t\t\t\t\t\thas_operand_number == 1,\n+\t\t\t\t\t\tfirst_fillin_param, &params);\n+\t      if (opnum == -1)\n+\t\treturn;\n+\t      else if (opnum > 0)\n+\t\t{\n+\t\t  has_operand_number = 1;\n+\t\t  arg_num = opnum + info->first_arg_num - 1;\n+\t\t}\n+\t      else\n+\t\thas_operand_number = 0;\n+\t    }\n \t  while (ISDIGIT (*format_chars))\n \t    {\n \t      wide = TRUE;\n@@ -1709,35 +1899,21 @@ check_format_info (info, params)\n \t}\n       else if (info->format_type == printf_format_type)\n \t{\n-\t  /* See if we have a number followed by a dollar sign.  If we do,\n-\t     it is an operand number, so set PARAMS to that operand.  */\n-\t  if (*format_chars >= '0' && *format_chars <= '9')\n+\t  if (has_operand_number != 0)\n \t    {\n-\t      const char *p = format_chars;\n-\n-\t      while (*p >= '0' && *p++ <= '9')\n-\t\t;\n-\n-\t      if (*p == '$')\n+\t      int opnum;\n+\t      opnum = maybe_read_dollar_number (&format_chars,\n+\t\t\t\t\t\thas_operand_number == 1,\n+\t\t\t\t\t\tfirst_fillin_param, &params);\n+\t      if (opnum == -1)\n+\t\treturn;\n+\t      else if (opnum > 0)\n \t\t{\n-\t\t  int opnum = atoi (format_chars);\n-\n-\t\t  if (pedantic)\n-\t\t    warning (\"ISO C does not support printf %%n$\");\n-\n-\t\t  params = first_fillin_param;\n-\t\t  format_chars = p + 1;\n \t\t  has_operand_number = 1;\n-\n-\t\t  for (i = 1; i < opnum && params != 0; i++)\n-\t\t    params = TREE_CHAIN (params);\n-\n-\t\t  if (opnum == 0 || params == 0)\n-\t\t    {\n-\t\t      warning (\"operand number out of range in format\");\n-\t\t      return;\n-\t\t    }\n+\t\t  arg_num = opnum + info->first_arg_num - 1;\n \t\t}\n+\t      else\n+\t\thas_operand_number = 0;\n \t    }\n \n \t  while (*format_chars != 0 && index (\" +#0-'\", *format_chars) != 0)\n@@ -1774,11 +1950,25 @@ check_format_info (info, params)\n \t\t  tfaff ();\n \t\t  return;\n \t\t}\n+\t      if (has_operand_number > 0)\n+\t\t{\n+\t\t  int opnum;\n+\t\t  opnum = maybe_read_dollar_number (&format_chars, 1,\n+\t\t\t\t\t\t    first_fillin_param,\n+\t\t\t\t\t\t    &params);\n+\t\t  if (opnum <= 0)\n+\t\t    return;\n+\t\t  else\n+\t\t    arg_num = opnum + info->first_arg_num - 1;\n+\t\t}\n \t      if (info->first_arg_num != 0)\n \t\t{\n \t\t  cur_param = TREE_VALUE (params);\n-\t\t  params = TREE_CHAIN (params);\n-\t\t  ++arg_num;\n+\t\t  if (has_operand_number <= 0)\n+\t\t    {\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t    }\n \t\t  /* size_t is generally not valid here.\n \t\t     It will work on most machines, because size_t and int\n \t\t     have the same mode.  But might as well warn anyway,\n@@ -1807,17 +1997,31 @@ check_format_info (info, params)\n \t\t In this case, an int argument supplies the...precision.\"  */\n \t      if (*format_chars == '*')\n \t\t{\n+\t\t  ++format_chars;\n+\t\t  if (has_operand_number > 0)\n+\t\t    {\n+\t\t      int opnum;\n+\t\t      opnum = maybe_read_dollar_number (&format_chars, 1,\n+\t\t\t\t\t\t\tfirst_fillin_param,\n+\t\t\t\t\t\t\t&params);\n+\t\t      if (opnum <= 0)\n+\t\t\treturn;\n+\t\t      else\n+\t\t\targ_num = opnum + info->first_arg_num - 1;\n+\t\t    }\n \t\t  if (info->first_arg_num != 0)\n \t\t    {\n-\t\t      ++format_chars;\n \t\t      if (params == 0)\n \t\t        {\n \t\t\t  tfaff ();\n \t\t\t  return;\n \t\t\t}\n \t\t      cur_param = TREE_VALUE (params);\n-\t\t      params = TREE_CHAIN (params);\n-\t\t      ++arg_num;\n+\t\t      if (has_operand_number <= 0)\n+\t\t\t{\n+\t\t\t  params = TREE_CHAIN (params);\n+\t\t\t  ++arg_num;\n+\t\t\t}\n \t\t      if ((TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n \t\t\t   != integer_type_node)\n \t\t\t  &&"}, {"sha": "1293a6c4c646ea59d760d05e2e65211a3b7ffa8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -1,3 +1,11 @@\n+2000-08-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/c90-printf-3.c, gcc.dg/c90-scanf-2.c,\n+\tgcc.dg/c90-scanf-3.c, gcc.dg/c90-scanf-4.c,\n+\tgcc.dg/c90-strftime-1.c, gcc.dg/c99-printf-3.c,\n+\tgcc.dg/c99-scanf-1.c, gcc.dg/c99-scanf-2.c, gcc.dg/c99-scanf-3.c,\n+\tgcc.dg/format-xopen-1.c: New tests.\n+\n 2000-08-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.dg/c90-scanf-1.c, gcc.dg/c94-scanf-1.c: New tests."}, {"sha": "119cdeeffff815014649f064de098216d7393de9", "filename": "gcc/testsuite/gcc.dg/c90-printf-3.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-printf-3.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,60 @@\n+/* Test for printf formats.  Test that the C90 functions get their default\n+   attributes in strict C90 mode, but the C99 and gettext functions\n+   do not.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic -Wformat\" } */\n+\n+/* This may not be correct in the particular case, but allows the\n+   prototypes to be declared, and we don't try to link.\n+*/\n+typedef struct _FILE FILE;\n+extern FILE *stdout;\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __builtin_va_list va_list;\n+\n+extern int fprintf (FILE *, const char *, ...);\n+extern int printf (const char *, ...);\n+extern int sprintf (char *, const char *, ...);\n+extern int vfprintf (FILE *, const char *, va_list);\n+extern int vprintf (const char *, va_list);\n+extern int vsprintf (char *, const char *, va_list);\n+\n+extern int snprintf (char *, size_t, const char *, ...);\n+extern int vsnprintf (char *, size_t, const char *, va_list);\n+\n+extern char *gettext (const char *);\n+extern char *dgettext (const char *, const char *);\n+extern char *dcgettext (const char *, const char *, int);\n+\n+void\n+foo (int i, char *s, size_t n, va_list v0, va_list v1, va_list v2, va_list v3,\n+     va_list v4, va_list v5, va_list v6, va_list v7, va_list v8)\n+{\n+  fprintf (stdout, \"%d\", i);\n+  fprintf (stdout, \"%ld\", i); /* { dg-warning \"format\" \"fprintf\" } */\n+  printf (\"%d\", i);\n+  printf (\"%ld\", i); /* { dg-warning \"format\" \"printf\" } */\n+  sprintf (s, \"%d\", i);\n+  sprintf (s, \"%ld\", i); /* { dg-warning \"format\" \"sprintf\" } */\n+  vfprintf (stdout, \"%d\", v0);\n+  vfprintf (stdout, \"%Y\", v1); /* { dg-warning \"format\" \"vfprintf\" } */\n+  vprintf (\"%d\", v2);\n+  vprintf (\"%Y\", v3); /* { dg-warning \"format\" \"vprintf\" } */\n+  /* The following used to give a bogus warning.  */\n+  vprintf (\"%*.*d\", v8);\n+  vsprintf (s, \"%d\", v4);\n+  vsprintf (s, \"%Y\", v5); /* { dg-warning \"format\" \"vsprintf\" } */\n+  snprintf (s, n, \"%d\", i);\n+  snprintf (s, n, \"%ld\", i);\n+  vsnprintf (s, n, \"%d\", v6);\n+  vsnprintf (s, n, \"%Y\", v7);\n+  printf (gettext (\"%d\"), i);\n+  printf (gettext (\"%ld\"), i);\n+  printf (dgettext (\"\", \"%d\"), i);\n+  printf (dgettext (\"\", \"%ld\"), i);\n+  printf (dcgettext (\"\", \"%d\", 0), i);\n+  printf (dcgettext (\"\", \"%ld\", 0), i);\n+}"}, {"sha": "c0a7a702664296d6c92766262f08cb92ed7ef88f", "filename": "gcc/testsuite/gcc.dg/c90-scanf-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-2.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,37 @@\n+/* Test for scanf formats.  Formats using C99 features should be rejected\n+   outside of C99 mode.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic -Wformat\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+__extension__ typedef long long int llong;\n+\n+/* This next definition is broken.  When GCC has a <stdint.h> and\n+   an internal understanding of intmax_t, it should be\n+   replaced by an include of <stdint.h> or by a definition for internal\n+   macros or typedefs.\n+*/\n+__extension__ typedef long long int intmax_t;\n+\n+extern int scanf (const char *, ...);\n+\n+void\n+foo (signed char *hhp, float *fp, llong *llp, intmax_t *jp,\n+     size_t *zp, ptrdiff_t *tp)\n+{\n+  /* Some tests already in c90-scanf-1.c.  */\n+  /* The widths hh, ll, j, z, t are new.  */\n+  scanf (\"%hhd\", hhp); /* { dg-warning \"length character|C\" \"%hh in C90\" } */\n+  scanf (\"%lld\", llp); /* { dg-warning \"length character|C\" \"%ll in C90\" } */\n+  scanf (\"%jd\", jp); /* { dg-warning \"length character|C\" \"%j in C90\" } */\n+  scanf (\"%zu\", zp); /* { dg-warning \"length character|C\" \"%z in C90\" } */\n+  scanf (\"%td\", tp); /* { dg-warning \"length character|C\" \"%t in C90\" } */\n+  /* The formats F, a, A are new.  */\n+  scanf (\"%F\", fp); /* { dg-warning \"C\" \"%F in C90\" } */\n+  scanf (\"%a\", fp); /* { dg-warning \"C\" \"%a in C90\" } */\n+  scanf (\"%A\", fp); /* { dg-warning \"C\" \"%A in C90\" } */\n+}"}, {"sha": "147a22254f66897a82fc18e2692c7b92569560fe", "filename": "gcc/testsuite/gcc.dg/c90-scanf-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-3.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,21 @@\n+/* Test for scanf formats.  Formats using extensions to the standard\n+   should be rejected in strict pedantic mode.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic -Wformat\" } */\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern int scanf (const char *, ...);\n+\n+void\n+foo (char **sp, wchar_t **lsp)\n+{\n+  /* %a formats for allocation, only recognised in C90 mode, are a\n+     GNU extension.\n+  */\n+  scanf (\"%as\", sp); /* { dg-warning \"C\" \"%as\" } */\n+  scanf (\"%aS\", lsp); /* { dg-warning \"C\" \"%aS\" } */\n+  scanf (\"%a[bcd]\", sp); /* { dg-warning \"C\" \"%a[]\" } */\n+}"}, {"sha": "3bbe66e598baad79e51ba57122b91e2d85cf9489", "filename": "gcc/testsuite/gcc.dg/c90-scanf-4.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-scanf-4.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,51 @@\n+/* Test for scanf formats.  Test that the C90 functions get their default\n+   attributes in strict C90 mode, but the C99 and gettext functions\n+   do not.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic -Wformat\" } */\n+\n+/* This may not be correct in the particular case, but allows the\n+   prototypes to be declared, and we don't try to link.\n+*/\n+typedef struct _FILE FILE;\n+extern FILE *stdin;\n+\n+typedef __builtin_va_list va_list;\n+\n+extern int fscanf (FILE *, const char *, ...);\n+extern int scanf (const char *, ...);\n+extern int sscanf (const char *, const char *, ...);\n+\n+extern int vfscanf (FILE *, const char *, va_list);\n+extern int vscanf (const char *, va_list);\n+extern int vsscanf (const char *, const char *, va_list);\n+\n+extern char *gettext (const char *);\n+extern char *dgettext (const char *, const char *);\n+extern char *dcgettext (const char *, const char *, int);\n+\n+void\n+foo (int *ip, char *s, va_list v0, va_list v1, va_list v2, va_list v3,\n+     va_list v4, va_list v5)\n+{\n+  fscanf (stdin, \"%d\", ip);\n+  fscanf (stdin, \"%ld\", ip); /* { dg-warning \"format\" \"fscanf\" } */\n+  scanf (\"%d\", ip);\n+  scanf (\"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  sscanf (s, \"%d\", ip);\n+  sscanf (s, \"%ld\", ip); /* { dg-warning \"format\" \"sscanf\" } */\n+  vfscanf (stdin, \"%d\", v0);\n+  vfscanf (stdin, \"%Y\", v1);\n+  vscanf (\"%d\", v2);\n+  vscanf (\"%Y\", v3);\n+  vsscanf (s, \"%d\", v4);\n+  vsscanf (s, \"%Y\", v5);\n+  scanf (gettext (\"%d\"), ip);\n+  scanf (gettext (\"%ld\"), ip);\n+  scanf (dgettext (\"\", \"%d\"), ip);\n+  scanf (dgettext (\"\", \"%ld\"), ip);\n+  scanf (dcgettext (\"\", \"%d\", 0), ip);\n+  scanf (dcgettext (\"\", \"%ld\", 0), ip);\n+}"}, {"sha": "6a13d5e321e6382611b7b8c2a82d5fb052a6e03a", "filename": "gcc/testsuite/gcc.dg/c90-strftime-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-strftime-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-strftime-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-strftime-1.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,23 @@\n+/* Test for strftime formats.  Formats using C90 features.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic -Wformat\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+struct tm;\n+\n+extern size_t strftime (char *, size_t, const char *, const struct tm *);\n+\n+void\n+foo (char *s, size_t m, const struct tm *tp)\n+{\n+  /* See ISO/IEC 9899:1990 (E) subclause 7.12.3.5 (pages 174-175).  */\n+  /* Formats which are Y2K-compliant (no 2-digit years).  */\n+  strftime (s, m, \"%a%A%b%B%d%H%I%j%m%M%p%S%U%w%W%X%Y%Z%%\", tp);\n+  /* Formats with 2-digit years.  */\n+  strftime (s, m, \"%y\", tp); /* { dg-warning \"only last 2\" \"2-digit year\" } */\n+  /* Formats with 2-digit years in some locales.  */\n+  strftime (s, m, \"%c\", tp); /* { dg-warning \"some locales\" \"2-digit year\" } */\n+  strftime (s, m, \"%x\", tp); /* { dg-warning \"some locales\" \"2-digit year\" } */\n+}"}, {"sha": "26f76d7f830f09af71298d212d94ad5cdab426cb", "filename": "gcc/testsuite/gcc.dg/c99-printf-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-printf-3.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,56 @@\n+/* Test for printf formats.  Test that the C99 functions get their default\n+   attributes in strict C99 mode, but the gettext functions do not.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic -Wformat\" } */\n+\n+/* This may not be correct in the particular case, but allows the\n+   prototypes to be declared, and we don't try to link.\n+*/\n+typedef struct _FILE FILE;\n+extern FILE *stdout;\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __builtin_va_list va_list;\n+\n+extern int fprintf (FILE *restrict, const char *restrict, ...);\n+extern int printf (const char *restrict, ...);\n+extern int sprintf (char *restrict, const char *restrict, ...);\n+extern int vfprintf (FILE *restrict, const char *restrict, va_list);\n+extern int vprintf (const char *restrict, va_list);\n+extern int vsprintf (char *restrict, const char *restrict, va_list);\n+extern int snprintf (char *restrict, size_t, const char *restrict, ...);\n+extern int vsnprintf (char *restrict, size_t, const char *restrict, va_list);\n+\n+extern char *gettext (const char *);\n+extern char *dgettext (const char *, const char *);\n+extern char *dcgettext (const char *, const char *, int);\n+\n+void\n+foo (int i, char *s, size_t n, va_list v0, va_list v1, va_list v2, va_list v3,\n+     va_list v4, va_list v5, va_list v6, va_list v7)\n+{\n+  fprintf (stdout, \"%d\", i);\n+  fprintf (stdout, \"%ld\", i); /* { dg-warning \"format\" \"fprintf\" } */\n+  printf (\"%d\", i);\n+  printf (\"%ld\", i); /* { dg-warning \"format\" \"printf\" } */\n+  sprintf (s, \"%d\", i);\n+  sprintf (s, \"%ld\", i); /* { dg-warning \"format\" \"sprintf\" } */\n+  snprintf (s, n, \"%d\", i);\n+  snprintf (s, n, \"%ld\", i); /* { dg-warning \"format\" \"snprintf\" } */\n+  vfprintf (stdout, \"%d\", v0);\n+  vfprintf (stdout, \"%Y\", v1); /* { dg-warning \"format\" \"vfprintf\" } */\n+  vprintf (\"%d\", v0);\n+  vprintf (\"%Y\", v1); /* { dg-warning \"format\" \"vprintf\" } */\n+  vsprintf (s, \"%d\", v0);\n+  vsprintf (s, \"%Y\", v1); /* { dg-warning \"format\" \"vsprintf\" } */\n+  vsnprintf (s, n, \"%d\", v0);\n+  vsnprintf (s, n, \"%Y\", v1); /* { dg-warning \"format\" \"vsnprintf\" } */\n+  printf (gettext (\"%d\"), i);\n+  printf (gettext (\"%ld\"), i);\n+  printf (dgettext (\"\", \"%d\"), i);\n+  printf (dgettext (\"\", \"%ld\"), i);\n+  printf (dcgettext (\"\", \"%d\", 0), i);\n+  printf (dcgettext (\"\", \"%ld\", 0), i);\n+}"}, {"sha": "c0b4c14428ea077085d87af42cafe268da042ce1", "filename": "gcc/testsuite/gcc.dg/c99-scanf-1.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-1.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,165 @@\n+/* Test for scanf formats.  Formats using C99 features, including cases\n+   where C99 specifies some aspect of the format to be ignored or where\n+   the behaviour is undefined.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic -Wformat\" } */\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+typedef __SIZE_TYPE__ size_t;\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+/* Kludges to get types corresponding to size_t and ptrdiff_t.  */\n+#define unsigned signed\n+typedef __SIZE_TYPE__ signed_size_t;\n+#undef unsigned\n+#define signed /* Type might or might not have explicit 'signed'.  */\n+typedef unsigned __PTRDIFF_TYPE__ unsigned_ptrdiff_t;\n+#undef signed\n+\n+/* These next definitions are broken.  When GCC has a <stdint.h> and\n+   an internal understanding of intmax_t and uintmax_t, they should be\n+   replaced by an include of <stdint.h> or by definitions for internal\n+   macros or typedefs, and the corresponding xfails removed.\n+*/\n+typedef long long int intmax_t;\n+typedef unsigned long long int uintmax_t;\n+\n+extern int scanf (const char *, ...);\n+\n+void\n+foo (int *ip, unsigned int *uip, short int *hp, unsigned short int *uhp,\n+     signed char *hhp, unsigned char *uhhp, long int *lp,\n+     unsigned long int *ulp, float *fp, double *dp, long double *ldp, char *s,\n+     void **pp, int *n, long long *llp, unsigned long long *ullp, wchar_t *ls,\n+     short int *hn, signed char *hhn, long int *ln, long long int *lln,\n+     intmax_t *jp, uintmax_t *ujp, intmax_t *jn, size_t *zp,\n+     signed_size_t *szp, signed_size_t *zn, ptrdiff_t *tp,\n+     unsigned_ptrdiff_t *utp, ptrdiff_t *tn)\n+{\n+  /* See ISO/IEC 9899:1999 (E) subclause 7.19.6.2 (pages 281-288).\n+     We do not repeat here most of the checks for correct C90 formats\n+     or completely broken formats.\n+  */\n+  /* Valid, invalid and silly assignment-suppression\n+     and width constructions.\n+  */\n+  scanf (\"%*d%*i%*o%*u%*x%*X%*a%*A%*e%*E%*f%*F%*g%*G%*s%*[abc]%*c%*p\");\n+  scanf (\"%*2d%*8s%*3c\");\n+  scanf (\"%*n\"); /* { dg-warning \"suppress\" \"suppression of %n\" } */\n+  scanf (\"%*hd\"); /* { dg-warning \"together\" \"suppression with length\" } */\n+  scanf (\"%2d%3i%4o%5u%6x%7X%8a%9A%10e%11E%12f%13F%14g%15G%16s%3[abc]%4c%5p\",\n+\t ip, ip, uip, uip, uip, uip, fp, fp, fp, fp, fp, fp, fp, fp,\n+\t s, s, s, pp);\n+  scanf (\"%0d\", ip); /* { dg-warning \"width\" \"warning for zero width\" } */\n+  scanf (\"%3n\", n); /* { dg-warning \"width\" \"width with %n\" } */\n+  /* Valid and invalid %h, %hh, %l, %ll, %j, %z, %t, %L constructions.  */\n+  scanf (\"%hd%hi%ho%hu%hx%hX%hn\", hp, hp, uhp, uhp, uhp, uhp, hn);\n+  scanf (\"%ha\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hA\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%he\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hE\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hf\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hF\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hg\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hG\", fp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hs\", s); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%h[ac]\", s); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hc\", s); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hp\", pp); /* { dg-warning \"length character\" \"bad use of %h\" } */\n+  scanf (\"%hhd%hhi%hho%hhu%hhx%hhX%hhn\", hhp, hhp, uhhp, uhhp, uhhp, uhhp,\n+\t hhn);\n+  scanf (\"%hha\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhA\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhe\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhE\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhf\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhF\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhg\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhG\", fp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhs\", s); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hh[ac]\", s); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhc\", s); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%hhp\", pp); /* { dg-warning \"length character\" \"bad use of %hh\" } */\n+  scanf (\"%ld%li%lo%lu%lx%lX%ln\", lp, lp, ulp, ulp, ulp, ulp, ln);\n+  scanf (\"%la%lA%le%lE%lf%lF%lg%lG\", dp, dp, dp, dp, dp, dp, dp, dp);\n+  scanf (\"%lp\", pp); /* { dg-warning \"length character\" \"bad use of %l\" } */\n+  scanf (\"%ls\", ls);\n+  scanf (\"%l[ac]\", ls);\n+  scanf (\"%lc\", ls);\n+  scanf (\"%lld%lli%llo%llu%llx%llX%lln\", llp, llp, ullp, ullp, ullp, ullp,\n+\t lln);\n+  scanf (\"%lla\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llA\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%lle\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llE\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llf\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llF\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llg\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llG\", fp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%lls\", s); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%ll[ac]\", s); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llc\", s); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%llp\", pp); /* { dg-warning \"length character\" \"bad use of %ll\" } */\n+  scanf (\"%jd%ji%jo%ju%jx%jX%jn\", jp, jp, ujp, ujp, ujp, ujp, jn); /* { dg-bogus \"length character\" \"bogus %j warning\" { xfail *-*-* } } */\n+  scanf (\"%ja\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jA\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%je\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jE\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jf\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jF\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jg\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jG\", fp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%js\", s); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%j[ac]\", s); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jc\", s); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%jp\", pp); /* { dg-warning \"length character\" \"bad use of %j\" } */\n+  scanf (\"%zd%zi%zo%zu%zx%zX%zn\", szp, szp, zp, zp, zp, zp, zn);\n+  scanf (\"%za\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zA\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%ze\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zE\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zf\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zF\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zg\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zG\", fp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zs\", s); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%z[ac]\", s); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zc\", s); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%zp\", pp); /* { dg-warning \"length character\" \"bad use of %z\" } */\n+  scanf (\"%td%ti%to%tu%tx%tX%tn\", tp, tp, utp, utp, utp, utp, tn);\n+  scanf (\"%ta\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tA\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%te\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tE\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tf\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tF\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tg\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tG\", fp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%ts\", s); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%t[ac]\", s); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tc\", s); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%tp\", pp); /* { dg-warning \"length character\" \"bad use of %t\" } */\n+  scanf (\"%La%LA%Le%LE%Lf%LF%Lg%LG\", ldp, ldp, ldp, ldp, ldp, ldp, ldp, ldp);\n+  scanf (\"%Ld\", llp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%Li\", llp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%Lo\", ullp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%Lu\", ullp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%Lx\", ullp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%LX\", ullp); /* { dg-warning \"does not support\" \"bad use of %L\" } */\n+  scanf (\"%Ls\", s); /* { dg-warning \"length character\" \"bad use of %L\" } */\n+  scanf (\"%L[ac]\", s); /* { dg-warning \"length character\" \"bad use of %L\" } */\n+  scanf (\"%Lc\", s); /* { dg-warning \"length character\" \"bad use of %L\" } */\n+  scanf (\"%Lp\", pp); /* { dg-warning \"length character\" \"bad use of %L\" } */\n+  scanf (\"%Ln\", n); /* { dg-warning \"length character\" \"bad use of %L\" } */\n+  /* Valid uses of each bare conversion.  */\n+  scanf (\"%d%i%o%u%x%X%a%A%e%E%f%F%g%G%s%[abc]%c%p%n%%\", ip, ip, uip, uip, uip,\n+         uip, fp, fp, fp, fp, fp, fp, fp, fp, s, s, s, pp, n);\n+  /* Assert that %as is not treated as an extension in C99 mode.  */\n+  scanf (\"%as\", fp);\n+  scanf (\"%a[\", fp);\n+  /* Tests for bad argument types: pointer target sign with %hh.  */\n+  scanf (\"%hhd\", uhhp); /* { dg-warning \"format\" \"%hhd sign\" } */\n+  scanf (\"%hhu\", hhp); /* { dg-warning \"format\" \"%hhu sign\" } */\n+}"}, {"sha": "c769e6d6611d70209dc3635e95863634d1105eb8", "filename": "gcc/testsuite/gcc.dg/c99-scanf-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-2.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,27 @@\n+/* Test for scanf formats.  Formats using extensions to the standard\n+   should be rejected in strict pedantic mode.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic -Wformat\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern int scanf (const char *, ...);\n+\n+void\n+foo (int *ip, long long int *llp, size_t *zp, wchar_t *ls)\n+{\n+  /* The length modifiers q, Z and L as applied to integer formats are\n+     extensions.\n+  */\n+  scanf (\"%qd\", llp); /* { dg-warning \"C\" \"%q length\" } */\n+  scanf (\"%Ld\", llp); /* { dg-warning \"C\" \"%L length\" } */\n+  scanf (\"%Zu\", zp); /* { dg-warning \"C\" \"%Z length\" } */\n+  /* The conversion specifiers C and S are X/Open extensions.  */\n+  scanf (\"%C\", ls); /* { dg-warning \"C\" \"scanf %C\" } */\n+  scanf (\"%S\", ls); /* { dg-warning \"C\" \"scanf %S\" } */\n+  /* The use of operand number $ formats is an X/Open extension.  */\n+  scanf (\"%1$d\", ip); /* { dg-warning \"C\" \"scanf $ format\" } */\n+}"}, {"sha": "df30c05df46c0cf72a328fde84fae6bf75a1a5b2", "filename": "gcc/testsuite/gcc.dg/c99-scanf-3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-scanf-3.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,49 @@\n+/* Test for scanf formats.  Test that the C99 functions get their default\n+   attributes in strict C99 mode, but the gettext functions do not.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic -Wformat\" } */\n+\n+/* This may not be correct in the particular case, but allows the\n+   prototypes to be declared, and we don't try to link.\n+*/\n+typedef struct _FILE FILE;\n+extern FILE *stdin;\n+\n+typedef __builtin_va_list va_list;\n+\n+extern int fscanf (FILE *restrict, const char *restrict, ...);\n+extern int scanf (const char *restrict, ...);\n+extern int sscanf (const char *restrict, const char *restrict, ...);\n+extern int vfscanf (FILE *restrict, const char *restrict, va_list);\n+extern int vscanf (const char *restrict, va_list);\n+extern int vsscanf (const char *restrict, const char *restrict, va_list);\n+\n+extern char *gettext (const char *);\n+extern char *dgettext (const char *, const char *);\n+extern char *dcgettext (const char *, const char *, int);\n+\n+void\n+foo (int *ip, char *s, va_list v0, va_list v1, va_list v2, va_list v3,\n+     va_list v4, va_list v5)\n+{\n+  fscanf (stdin, \"%d\", ip);\n+  fscanf (stdin, \"%ld\", ip); /* { dg-warning \"format\" \"fscanf\" } */\n+  scanf (\"%d\", ip);\n+  scanf (\"%ld\", ip); /* { dg-warning \"format\" \"scanf\" } */\n+  sscanf (s, \"%d\", ip);\n+  sscanf (s, \"%ld\", ip); /* { dg-warning \"format\" \"sscanf\" } */\n+  vfscanf (stdin, \"%d\", v0);\n+  vfscanf (stdin, \"%Y\", v1); /* { dg-warning \"format\" \"vfscanf\" } */\n+  vscanf (\"%d\", v2);\n+  vscanf (\"%Y\", v3); /* { dg-warning \"format\" \"vscanf\" } */\n+  vsscanf (s, \"%d\", v4);\n+  vsscanf (s, \"%Y\", v5); /* { dg-warning \"format\" \"vsscanf\" } */\n+  scanf (gettext (\"%d\"), ip);\n+  scanf (gettext (\"%ld\"), ip);\n+  scanf (dgettext (\"\", \"%d\"), ip);\n+  scanf (dgettext (\"\", \"%ld\"), ip);\n+  scanf (dcgettext (\"\", \"%d\", 0), ip);\n+  scanf (dcgettext (\"\", \"%ld\", 0), ip);\n+}"}, {"sha": "2bfcbfb941a93c9bf0704668f1007a24e2fc3f3c", "filename": "gcc/testsuite/gcc.dg/format-xopen-1.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5804a754e51fe8a475bb701a57997ee0cdb51fc0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-xopen-1.c?ref=5804a754e51fe8a475bb701a57997ee0cdb51fc0", "patch": "@@ -0,0 +1,118 @@\n+/* Test for X/Open format extensions, as found in the\n+   Single Unix Specification and in Austin Group draft 4, subject to some\n+   Aardvark problem reports submitted.\n+*/\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+typedef __WINT_TYPE__ wint_t;\n+typedef __builtin_va_list va_list;\n+\n+extern int printf (const char *, ...);\n+extern int vprintf (const char *, va_list);\n+extern int scanf (const char *, ...);\n+\n+void\n+foo (int i, unsigned int u, wint_t lc, wchar_t *ls, int *ip, double d,\n+     char *s, void *p, int *n, long int l, int i2, float *fp, long int *lp,\n+     va_list va)\n+{\n+  /* The conversion specifiers C and S, for both printf and scanf,\n+     are X/Open extensions.\n+  */\n+  printf (\"%C\", lc);\n+  printf (\"%3C\", lc);\n+  printf (\"%.3C\", lc); /* { dg-warning \"precision\" \"precision with %C\" } */\n+  printf (\"%hC\", lc); /* { dg-warning \"length character\" \"bad %hC\" } */\n+  printf (\"%hhC\", lc); /* { dg-warning \"length character\" \"bad %hhC\" } */\n+  printf (\"%lC\", lc); /* { dg-warning \"length character\" \"bad %lC\" } */\n+  printf (\"%llC\", lc); /* { dg-warning \"length character\" \"bad %llC\" } */\n+  printf (\"%jC\", lc); /* { dg-warning \"length character\" \"bad %jC\" } */\n+  printf (\"%zC\", lc); /* { dg-warning \"length character\" \"bad %zC\" } */\n+  printf (\"%tC\", lc); /* { dg-warning \"length character\" \"bad %tC\" } */\n+  printf (\"%LC\", lc); /* { dg-warning \"length character\" \"bad %LC\" } */\n+  printf (\"%-C\", lc);\n+  printf (\"%+C\", lc); /* { dg-warning \"flag\" \"bad %+C\" } */\n+  printf (\"% C\", lc); /* { dg-warning \"flag\" \"bad % C\" } */\n+  printf (\"%#C\", lc); /* { dg-warning \"flag\" \"bad %#C\" } */\n+  printf (\"%0C\", lc); /* { dg-warning \"flag\" \"bad %0C\" } */\n+  printf (\"%S\", ls);\n+  printf (\"%3S\", ls);\n+  printf (\"%.3S\", ls);\n+  printf (\"%hS\", ls); /* { dg-warning \"length character\" \"bad %hS\" } */\n+  printf (\"%hhS\", ls); /* { dg-warning \"length character\" \"bad %hhS\" } */\n+  printf (\"%lS\", ls); /* { dg-warning \"length character\" \"bad %lS\" } */\n+  printf (\"%llS\", ls); /* { dg-warning \"length character\" \"bad %llS\" } */\n+  printf (\"%jS\", ls); /* { dg-warning \"length character\" \"bad %jS\" } */\n+  printf (\"%zS\", ls); /* { dg-warning \"length character\" \"bad %zS\" } */\n+  printf (\"%tS\", ls); /* { dg-warning \"length character\" \"bad %tS\" } */\n+  printf (\"%LS\", ls); /* { dg-warning \"length character\" \"bad %LS\" } */\n+  printf (\"%-S\", ls);\n+  printf (\"%+S\", ls); /* { dg-warning \"flag\" \"bad %+S\" } */\n+  printf (\"% S\", ls); /* { dg-warning \"flag\" \"bad % S\" } */\n+  printf (\"%#S\", ls); /* { dg-warning \"flag\" \"bad %#S\" } */\n+  printf (\"%0S\", ls); /* { dg-warning \"flag\" \"bad %0S\" } */\n+  scanf (\"%C\", ls);\n+  scanf (\"%S\", ls);\n+  scanf (\"%*C%*S\");\n+  scanf (\"%2C%3S\", ls, ls);\n+  scanf (\"%hC\", ls); /* { dg-warning \"length character\" \"bad %hC\" } */\n+  scanf (\"%hhC\", ls); /* { dg-warning \"length character\" \"bad %hhC\" } */\n+  scanf (\"%lC\", ls); /* { dg-warning \"length character\" \"bad %lC\" } */\n+  scanf (\"%llC\", ls); /* { dg-warning \"length character\" \"bad %llC\" } */\n+  scanf (\"%jC\", ls); /* { dg-warning \"length character\" \"bad %jC\" } */\n+  scanf (\"%zC\", ls); /* { dg-warning \"length character\" \"bad %zC\" } */\n+  scanf (\"%tC\", ls); /* { dg-warning \"length character\" \"bad %tC\" } */\n+  scanf (\"%LC\", ls); /* { dg-warning \"length character\" \"bad %LC\" } */\n+  scanf (\"%hS\", ls); /* { dg-warning \"length character\" \"bad %hS\" } */\n+  scanf (\"%hhS\", ls); /* { dg-warning \"length character\" \"bad %hhS\" } */\n+  scanf (\"%lS\", ls); /* { dg-warning \"length character\" \"bad %lS\" } */\n+  scanf (\"%llS\", ls); /* { dg-warning \"length character\" \"bad %llS\" } */\n+  scanf (\"%jS\", ls); /* { dg-warning \"length character\" \"bad %jS\" } */\n+  scanf (\"%zS\", ls); /* { dg-warning \"length character\" \"bad %zS\" } */\n+  scanf (\"%tS\", ls); /* { dg-warning \"length character\" \"bad %tS\" } */\n+  scanf (\"%LS\", ls); /* { dg-warning \"length character\" \"bad %LS\" } */\n+  /* In C99 mode (even with extensions), %aS is a floating point\n+     format followed by an S.\n+  */\n+  scanf (\"%aS\", fp);\n+  /* The printf flag character ' is an X/Open extension.  */\n+  /* Allowing %'F here presumes acceptance of the corresponding Aardvark\n+     report.\n+  */\n+  printf (\"%'d%'i%'u%'f%'F%'g%'G\", i, i, u, d, d, d, d);\n+  printf (\"%'o\", u); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'x\", u); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'X\", u); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'e\", d); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'E\", d); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'a\", d); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'A\", d); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'c\", i); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'s\", s); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'p\", p); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  printf (\"%'n\", n); /* { dg-warning \"flag\" \"bad use of ' flag\" } */\n+  /* The use of operand number $ formats is an X/Open extension.  */\n+  /* Banning gaps in the arguments used with scanf, and not objecting to\n+     multiple use of an argument with scanf, presumes acceptance of the\n+     corresponding Aardvark reports.\n+  */\n+  scanf (\"%1$d\", ip);\n+  printf (\"%1$d\", i);\n+  printf (\"%3$*2$.*1$d\", i2, i, l);\n+  printf (\"%4$ld%7$ld%5$d%6$d%3$d%1$d%2$d\", i, i, i, l, i, i, l);\n+  scanf (\"%4$ld%7$ld%5$d%6$d%3$d%1$d%2$d\", ip, ip, ip, lp, ip, ip, lp);\n+  printf (\"%1$d%d\", i, i); /* { dg-warning \"missing\" \"mixing $ and non-$ formats\" } */\n+  printf (\"%%%1$d%%%2$d\", i, i);\n+  printf (\"%d%2$d\", i); /* { dg-warning \"type character\" \"mixing $ and non-$ formats\" } */\n+  printf (\"%1$*d\", i, i); /* { dg-warning \"missing\" \"mixing $ and non-$ formats\" } */\n+  scanf (\"%1$d%d\", ip, ip); /* { dg-warning \"missing\" \"mixing $ and non-$ formats\" } */\n+  scanf (\"%*f%%%1$d%%%2$d\", ip, ip);\n+  printf (\"%2$d\", i); /* { dg-warning \"operand\" \"$ number too large\" } */\n+  printf (\"%0$d\", i); /* { dg-warning \"operand\" \"$ number too small\" } */\n+  printf (\"%3$d%1$d\", i, i, i); /* { dg-warning \"before used\" \"unused $ operand\" } */\n+  printf (\"%2$d%1$d\", i, i, i); /* { dg-warning \"unused\" \"unused $ operand\" } */\n+  vprintf (\"%3$d%1$d\", va); /* { dg-warning \"before used\" \"unused $ operand\" } */\n+}"}]}