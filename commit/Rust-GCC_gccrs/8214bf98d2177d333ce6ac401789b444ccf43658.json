{"sha": "8214bf98d2177d333ce6ac401789b444ccf43658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIxNGJmOThkMjE3N2QzMzNjZTZhYzQwMTc4OWI0NDRjY2Y0MzY1OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-07-17T09:24:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-07-17T09:24:08Z"}, "message": "mips-protos.h (mips_sign_extend): Declare.\n\n\t* config/mips/mips-protos.h (mips_sign_extend): Declare.\n\t* config/mips/mips.h (MASK_DEBUG_H, TARGET_DEBUG_H_MODE): Remove.\n\t(TARGET_SWITCHES): Remove debugh.\n\t(ISA_HAS_TRUNC_W): New macro.\n\t(CLASS_CANNOT_CHANGE_MODE): Include FP_REGS if TARGET_FLOAT64.\n\t(PREDICATE_CODES): Remove se_nonimmediate_operand.\n\t* config/mips/mips.c (movdi_operand): Allow sign-extensions of\n\tany SImode move_operand.\n\t(se_nonimmediate_operand): Remove.\n\t(mips_sign_extend): New.\n\t(mips_move_2words): Use it for sign-extended source operands.\n\t(override_options): Allow integers to be put into single FPRs.\n\t(mips_secondary_reload_class): Handle integers in float registers.\n\t* config/mips/mips.md (extendsidi2): Turn into a define_expand.\n\t(fix_truncsfsi2, fix_truncdfsi2): Likewise.\n\t(fix_truncdfsi2_insn, fix_truncdfsi2_macro): New.\n\t(fix_truncsfsi2_insn, fix_truncsfsi2_macro): New.\n\t(fix_truncdfdi2): Provide only a single alternative, in which the\n\tinteger is in a float register.  Depend on TARGET_FLOAT64 rather\n\tthan TARGET_64BIT.\n\t(fix_truncsfdi2, floatdidf2, floatdisf2): Likewise.\n\t(floatsidf2, floatsisf2): Likewise, but no TARGET_FLOAT64 dependency.\n\t(movdi_internal2): Don't allow the source operand to be sign-extended.\n\tAdd alternatives for float registers.\n\t(*movdi_internal2_extend): New.  Version of movdi_internal2 that\n\tallows sign-extension.\n\t(*movdi_internal2_mips16): Name the existing mips16 movdi pattern.\n\t(movsi_internal2): Rename to movsi_internal.  Add alternatives for\n\tfloat registers.  Remove TARGET_DEBUG_H_MODE test.\n\t(movhi_internal1): Rename to movhi_internal.  Don't check\n\tTARGET_DEBUG_H_MODE.  Fix transposed *d and *f source constraints.\n\t(movqi_internal1): Rename to movqi_internal and remove\n\tTARGET_DEBUG_H_MODE dependency.\n\t(movsi_internal1, movhi_internal2, movqi_internal2): Remove.\n\nFrom-SVN: r55514", "tree": {"sha": "d6efa314e85f244662bb350a1403c5f41878c06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6efa314e85f244662bb350a1403c5f41878c06b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8214bf98d2177d333ce6ac401789b444ccf43658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8214bf98d2177d333ce6ac401789b444ccf43658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8214bf98d2177d333ce6ac401789b444ccf43658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8214bf98d2177d333ce6ac401789b444ccf43658/comments", "author": null, "committer": null, "parents": [{"sha": "5fc5be15222493c4325d413f5abe7026b5038e63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fc5be15222493c4325d413f5abe7026b5038e63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fc5be15222493c4325d413f5abe7026b5038e63"}], "stats": {"total": 514, "additions": 262, "deletions": 252}, "files": [{"sha": "b23d59d32bc5aae3a2ca5cb9c6b9f863d4dd4d64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8214bf98d2177d333ce6ac401789b444ccf43658", "patch": "@@ -1,3 +1,40 @@\n+2002-07-17  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_sign_extend): Declare.\n+\t* config/mips/mips.h (MASK_DEBUG_H, TARGET_DEBUG_H_MODE): Remove.\n+\t(TARGET_SWITCHES): Remove debugh.\n+\t(ISA_HAS_TRUNC_W): New macro.\n+\t(CLASS_CANNOT_CHANGE_MODE): Include FP_REGS if TARGET_FLOAT64.\n+\t(PREDICATE_CODES): Remove se_nonimmediate_operand.\n+\t* config/mips/mips.c (movdi_operand): Allow sign-extensions of\n+\tany SImode move_operand.\n+\t(se_nonimmediate_operand): Remove.\n+\t(mips_sign_extend): New.\n+\t(mips_move_2words): Use it for sign-extended source operands.\n+\t(override_options): Allow integers to be put into single FPRs.\n+\t(mips_secondary_reload_class): Handle integers in float registers.\n+\t* config/mips/mips.md (extendsidi2): Turn into a define_expand.\n+\t(fix_truncsfsi2, fix_truncdfsi2): Likewise.\n+\t(fix_truncdfsi2_insn, fix_truncdfsi2_macro): New.\n+\t(fix_truncsfsi2_insn, fix_truncsfsi2_macro): New.\n+\t(fix_truncdfdi2): Provide only a single alternative, in which the\n+\tinteger is in a float register.  Depend on TARGET_FLOAT64 rather\n+\tthan TARGET_64BIT.\n+\t(fix_truncsfdi2, floatdidf2, floatdisf2): Likewise.\n+\t(floatsidf2, floatsisf2): Likewise, but no TARGET_FLOAT64 dependency.\n+\t(movdi_internal2): Don't allow the source operand to be sign-extended.\n+\tAdd alternatives for float registers.\n+\t(*movdi_internal2_extend): New.  Version of movdi_internal2 that\n+\tallows sign-extension.\n+\t(*movdi_internal2_mips16): Name the existing mips16 movdi pattern.\n+\t(movsi_internal2): Rename to movsi_internal.  Add alternatives for\n+\tfloat registers.  Remove TARGET_DEBUG_H_MODE test.\n+\t(movhi_internal1): Rename to movhi_internal.  Don't check\n+\tTARGET_DEBUG_H_MODE.  Fix transposed *d and *f source constraints.\n+\t(movqi_internal1): Rename to movqi_internal and remove\n+\tTARGET_DEBUG_H_MODE dependency.\n+\t(movsi_internal1, movhi_internal2, movqi_internal2): Remove.\n+\n 2002-07-16  Jim Wilson  <wilson@redhat.com>\n \n \t* toplev.c (lang_dependent_init): Create function context for"}, {"sha": "01bd254bc13612b5899657cd9fae97ccb53ae16d", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=8214bf98d2177d333ce6ac401789b444ccf43658", "patch": "@@ -98,6 +98,7 @@ extern const char      *mips_fill_delay_slot PARAMS ((const char *,\n \t\t\t\t\t\t      rtx));\n extern const char      *mips_move_1word PARAMS ((rtx *, rtx, int));\n extern const char      *mips_move_2words PARAMS ((rtx *, rtx));\n+extern const char      *mips_sign_extend PARAMS ((rtx, rtx, rtx));\n extern const char      *mips_emit_prefetch PARAMS ((rtx *));\n extern const char      *mips_restore_gp PARAMS ((rtx *, rtx));\n extern const char      *output_block_move PARAMS ((rtx, rtx *, int,"}, {"sha": "56225f4e9e239f9836390d9710fffe8e6030a7b4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 84, "deletions": 48, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8214bf98d2177d333ce6ac401789b444ccf43658", "patch": "@@ -1200,9 +1200,11 @@ move_operand (op, mode)\n \n /* Return nonzero if OPERAND is valid as a source operand for movdi.\n    This accepts not only general_operand, but also sign extended\n-   constants and registers.  We need to accept sign extended constants\n+   move_operands.  Note that we need to accept sign extended constants\n    in case a sign extended register which is used in an expression,\n-   and is equivalent to a constant, is spilled.  */\n+   and is equivalent to a constant, is spilled.  We need to accept\n+   sign-extended memory in order to reload registers from stack slots,\n+   and so that we generate efficient code for extendsidi2.  */\n \n int\n movdi_operand (op, mode)\n@@ -1213,11 +1215,7 @@ movdi_operand (op, mode)\n       && mode == DImode\n       && GET_CODE (op) == SIGN_EXTEND\n       && GET_MODE (op) == DImode\n-      && (GET_MODE (XEXP (op, 0)) == SImode\n-\t  || (GET_CODE (XEXP (op, 0)) == CONST_INT\n-\t      && GET_MODE (XEXP (op, 0)) == VOIDmode))\n-      && (register_operand (XEXP (op, 0), SImode)\n-\t  || immediate_operand (XEXP (op, 0), SImode)))\n+      && move_operand (XEXP (op, 0), SImode))\n     return 1;\n \n   return (general_operand (op, mode)\n@@ -1326,26 +1324,6 @@ se_nonmemory_operand (op, mode)\n   return nonmemory_operand (op, mode);\n }\n \n-/* Like nonimmediate_operand, but when in 64 bit mode also accept a\n-   sign extend of a 32 bit register, since the value is known to be\n-   already sign extended.  */\n-\n-int\n-se_nonimmediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (TARGET_64BIT\n-      && mode == DImode\n-      && GET_CODE (op) == SIGN_EXTEND\n-      && GET_MODE (op) == DImode\n-      && GET_MODE (XEXP (op, 0)) == SImode\n-      && register_operand (XEXP (op, 0), SImode))\n-    return 1;\n-\n-  return nonimmediate_operand (op, mode);\n-}\n-\n /* Accept any operand that can appear in a mips16 constant table\n    instruction.  We can't use any of the standard operand functions\n    because for these instructions we accept values that are not\n@@ -2464,6 +2442,33 @@ mips_restore_gp (operands, insn)\n   return mips_move_1word (operands, insn, 0);\n }\n \f\n+/* Return an instruction to sign-extend SImode value SRC and store it\n+   in DImode value DEST.  INSN is the original extendsidi2-type insn.  */\n+\n+const char *\n+mips_sign_extend (insn, dest, src)\n+     rtx insn, dest, src;\n+{\n+  rtx operands[MAX_RECOG_OPERANDS];\n+\n+  if ((register_operand (src, SImode) && FP_REG_P (true_regnum (src)))\n+      || memory_operand (src, SImode))\n+    {\n+      /* If the source is a floating-point register, we need to use a\n+\t 32-bit move, since the float register is not kept sign-extended.\n+\t If the source is in memory, we need a 32-bit load.  */\n+      operands[0] = gen_lowpart_SUBREG (SImode, dest);\n+      operands[1] = src;\n+      return mips_move_1word (operands, insn, false);\n+    }\n+  else\n+    {\n+      operands[0] = dest;\n+      operands[1] = src;\n+      return mips_move_2words (operands, insn);\n+    }\n+}\n+\f\n /* Return the appropriate instructions to move 2 words */\n \n const char *\n@@ -2480,6 +2485,9 @@ mips_move_2words (operands, insn)\n   int subreg_offset1 = 0;\n   enum delay_type delay = DELAY_NONE;\n \n+  if (code1 == SIGN_EXTEND)\n+    return mips_sign_extend (insn, op0, XEXP (op1, 0));\n+\n   while (code0 == SUBREG)\n     {\n       subreg_offset0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),\n@@ -2490,12 +2498,6 @@ mips_move_2words (operands, insn)\n       code0 = GET_CODE (op0);\n     }\n \n-  if (code1 == SIGN_EXTEND)\n-    {\n-      op1 = XEXP (op1, 0);\n-      code1 = GET_CODE (op1);\n-    }\n-\n   while (code1 == SUBREG)\n     {\n       subreg_offset1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),\n@@ -2506,17 +2508,6 @@ mips_move_2words (operands, insn)\n       code1 = GET_CODE (op1);\n     }\n \n-  /* Sanity check.  */\n-  if (GET_CODE (operands[1]) == SIGN_EXTEND\n-      && code1 != REG\n-      && code1 != CONST_INT\n-      /* The following three can happen as the result of a questionable\n-\t cast.  */\n-      && code1 != LABEL_REF\n-      && code1 != SYMBOL_REF\n-      && code1 != CONST)\n-    abort ();\n-\n   if (code0 == REG)\n     {\n       int regno0 = REGNO (op0) + subreg_offset0;\n@@ -5406,10 +5397,12 @@ override_options ()\n                         the value, not about whether math works on the\n                         register.  */\n                      || (mips_abi == ABI_MEABI && size <= 4))\n-\t\t    && (class == MODE_FLOAT\n-\t\t\t|| class == MODE_COMPLEX_FLOAT\n-\t\t\t|| (TARGET_DEBUG_H_MODE && class == MODE_INT))\n-\t\t    && size <= UNITS_PER_FPVALUE);\n+\t\t    && (((class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+\t\t\t && size <= UNITS_PER_FPVALUE)\n+\t\t\t/* Allow integer modes that fit into a single\n+\t\t\t   register.  We need to put integers into FPRs\n+\t\t\t   when using instructions like cvt and trunc.  */\n+\t\t\t|| (class == MODE_INT && size <= UNITS_PER_FPREG)));\n \n \t  else if (MD_REG_P (regno))\n \t    temp = (class == MODE_INT\n@@ -8319,6 +8312,18 @@ mips_secondary_reload_class (class, mode, x, in_p)\n \t  if (GET_CODE (x) == REG)\n \t    regno = REGNO (x) + off;\n \t}\n+\n+      /* 64-bit floating-point registers don't store 32-bit values\n+\t in sign-extended form.  The only way we can reload\n+\t (sign_extend:DI (reg:SI $f0)) is by moving $f0 into\n+\t an integer register using a 32-bit move.  */\n+      if (FP_REG_P (regno))\n+\treturn (class == GR_REGS ? NO_REGS : GR_REGS);\n+\n+      /* For the same reason, we can only reload (sign_extend:DI FOO) into\n+\t a floating-point register when FOO is an integer register. */\n+      if (class == FP_REGS)\n+\treturn (GP_REG_P (regno) ? NO_REGS : GR_REGS);\n     }\n \n   else if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n@@ -8378,6 +8383,37 @@ mips_secondary_reload_class (class, mode, x, in_p)\n       return class == GR_REGS ? NO_REGS : GR_REGS;\n     }\n \n+  if (class == FP_REGS)\n+    {\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  /* In this case we can use lwc1, swc1, ldc1 or sdc1. */\n+\t  return NO_REGS;\n+\t}\n+      else if (CONSTANT_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t{\n+\t  /* We can use the l.s and l.d macros to load floating-point\n+\t     constants.  ??? For l.s, we could probably get better\n+\t     code by returning GR_REGS here.  */\n+\t  return NO_REGS;\n+\t}\n+      else if (GP_REG_P (regno) || x == CONST0_RTX (mode))\n+\t{\n+\t  /* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n+\t  return NO_REGS;\n+\t}\n+      else if (FP_REG_P (regno))\n+\t{\n+\t  /* In this case we can use mov.s or mov.d.  */\n+\t  return NO_REGS;\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we need to reload through an integer register.  */\n+\t  return GR_REGS;\n+\t}\n+    }\n+\n   /* In mips16 mode, going between memory and anything but M16_REGS\n      requires an M16_REG.  */\n   if (TARGET_MIPS16)"}, {"sha": "238f2b79b0f5a0c21bc18edf9649877fe09c5080", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8214bf98d2177d333ce6ac401789b444ccf43658", "patch": "@@ -225,7 +225,6 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MASK_DEBUG_E\t0\t\t/* function_arg debug */\n #define MASK_DEBUG_F\t0\t\t/* ??? */\n #define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n-#define MASK_DEBUG_H\t0               /* allow ints in FP registers */\n #define MASK_DEBUG_I\t0\t\t/* unused */\n \n \t\t\t\t\t/* Dummy switches used only in specs */\n@@ -253,7 +252,6 @@ extern void\t\tsbss_section PARAMS ((void));\n #define TARGET_DEBUG_E_MODE\t(target_flags & MASK_DEBUG_E)\n #define TARGET_DEBUG_F_MODE\t(target_flags & MASK_DEBUG_F)\n #define TARGET_DEBUG_G_MODE\t(target_flags & MASK_DEBUG_G)\n-#define TARGET_DEBUG_H_MODE\t(target_flags & MASK_DEBUG_H)\n #define TARGET_DEBUG_I_MODE\t(target_flags & MASK_DEBUG_I)\n \n \t\t\t\t\t/* Reg. Naming in .s ($21 vs. $a0) */\n@@ -585,8 +583,6 @@ extern void\t\tsbss_section PARAMS ((void));\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugg\",\t\t  MASK_DEBUG_G,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debugh\",\t\t  MASK_DEBUG_H,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugi\",\t\t  MASK_DEBUG_I,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"\",\t\t\t  (TARGET_DEFAULT\t\t\t\t\\\n@@ -783,6 +779,11 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t  || ISA_MIPS64)\t       \t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n+/* True if trunc.w.s and trunc.w.d are real (not synthetic)\n+   instructions.  Both require TARGET_HARD_FLOAT, and trunc.w.d\n+   also requires TARGET_DOUBLE_FLOAT.  */\n+#define ISA_HAS_TRUNC_W\t\t(!ISA_MIPS1)\n+\n /* CC1_SPEC causes -mips3 and -mips4 to set -mfp64 and -mgp64; -mips1 or\n    -mips2 sets -mfp32 and -mgp32.  This can be overridden by an explicit\n    -mfp32, -mfp64, -mgp32 or -mgp64.  -mfp64 sets MASK_FLOAT64 in\n@@ -2243,17 +2244,20 @@ extern enum reg_class mips_char_to_class[256];\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.\n-   When FP regs are larger than integer regs... Er, anyone remember what\n-   goes wrong?\n \n    In little-endian mode, the hi-lo registers are numbered backwards,\n    so (subreg:SI (reg:DI hi) 0) gets the high word instead of the low\n-   word as intended.  */\n+   word as intended.\n+\n+   Also, loading a 32-bit value into a 64-bit floating-point register\n+   will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n+   We can't allow 64-bit float registers to change from a 32-bit\n+   mode to a 64-bit mode.  */\n \n #define CLASS_CANNOT_CHANGE_MODE\t\t\t\t\t\\\n   (TARGET_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? (TARGET_FLOAT64 && ! TARGET_64BIT ? FP_REGS : NO_REGS)\t\t\\\n-   : (TARGET_FLOAT64 && ! TARGET_64BIT ? HI_AND_FP_REGS : HI_REG))\n+   ? (TARGET_FLOAT64 ? FP_REGS : NO_REGS)\t\t\t\t\\\n+   : (TARGET_FLOAT64 ? HI_AND_FP_REGS : HI_REG))\n \n /* Defines illegal mode changes for CLASS_CANNOT_CHANGE_MODE.  */\n \n@@ -3677,7 +3681,6 @@ typedef struct mips_args {\n   {\"se_nonmemory_operand\",\t{ CONST_INT, CONST_DOUBLE, CONST,\t\\\n \t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG,\t\\\n \t\t\t\t  REG, SIGN_EXTEND }},\t\t\t\\\n-  {\"se_nonimmediate_operand\",   { SUBREG, REG, MEM, SIGN_EXTEND }},\t\\\n   {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n \t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n   {\"extend_operator\",           { SIGN_EXTEND, ZERO_EXTEND }},          \\"}, {"sha": "c8328781c6eb5f37486bf90e52d994a7e9186614", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 127, "deletions": 194, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8214bf98d2177d333ce6ac401789b444ccf43658/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=8214bf98d2177d333ce6ac401789b444ccf43658", "patch": "@@ -4122,16 +4122,14 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; In 64 bit mode, 32 bit values in general registers are always\n ;; correctly sign extended.  That means that if the target is a\n ;; general register, we can sign extend from SImode to DImode just by\n-;; doing a move.\n+;; doing a move.  The matching define_insns are *movdi_internal2_extend\n+;; and *movdi_internal2_mips16.\n \n-(define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,y,d,*d,d,d\")\n-\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,d,y,*x,R,m\")))]\n+(define_expand \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_64BIT\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,move,move,hilo,load,load\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,4,4,4,4,8\")])\n+  \"\")\n \n ;; These patterns originally accepted general_operands, however, slightly\n ;; better code is generated by only accepting register_operands, and then\n@@ -4307,65 +4305,67 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\n ;;  ....................\n \n-;; The SImode scratch register can not be shared with address regs used for\n-;; operand zero, because then the address in the move instruction will be\n-;; clobbered.  We mark the scratch register as early clobbered to prevent this.\n-\n-;; We need the ?X in alternative 1 so that it will be chosen only if the\n-;; destination is a floating point register.  Otherwise, alternative 1 can\n-;; have lower cost than alternative 0 (because there is one less loser), and\n-;; can be chosen when it won't work (because integral reloads into FP\n-;; registers are not supported).\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,*f,R,To\")\n-\t(fix:SI (match_operand:DF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_scratch:SI 2 \"=d,*d,&d,&d\"))\n-   (clobber (match_scratch:DF 3 \"=f,?*X,f,f\"))]\n+(define_expand \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n {\n-  rtx xoperands[10];\n-\n-  if (which_alternative == 1)\n-    return \\\"trunc.w.d %0,%1,%2\\\";\n-\n-  output_asm_insn (\\\"trunc.w.d %3,%1,%2\\\", operands);\n+  if (!ISA_HAS_TRUNC_W)\n+    {\n+      emit_insn (gen_fix_truncdfsi2_macro (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n \n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[3];\n-  output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-  return \\\"\\\";\n-}\"\n+(define_insn \"fix_truncdfsi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && ISA_HAS_TRUNC_W\"\n+  \"trunc.w.d %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"44,36,40,44\")])\n-\n+   (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"fix_truncdfsi2_macro\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:DF 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !ISA_HAS_TRUNC_W\"\n+  \"trunc.w.d %0,%1,%2\"\n+  [(set_attr \"type\"\t\"fcvt\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"36\")])\n \n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,*f,R,To\")\n-\t(fix:SI (match_operand:SF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_scratch:SI 2 \"=d,*d,&d,&d\"))\n-   (clobber (match_scratch:SF 3 \"=f,?*X,f,f\"))]\n+(define_expand \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n {\n-  rtx xoperands[10];\n-\n-  if (which_alternative == 1)\n-    return \\\"trunc.w.s %0,%1,%2\\\";\n-\n-  output_asm_insn (\\\"trunc.w.s %3,%1,%2\\\", operands);\n+  if (!ISA_HAS_TRUNC_W)\n+    {\n+      emit_insn (gen_fix_truncsfsi2_macro (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n \n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[3];\n-  output_asm_insn (mips_move_1word (xoperands, insn, FALSE), xoperands);\n-  return \\\"\\\";\n-}\"\n+(define_insn \"fix_truncsfsi2_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && ISA_HAS_TRUNC_W\"\n+  \"trunc.w.s %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"44,36,40,44\")])\n-\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"fix_truncsfsi2_macro\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:SF 2 \"=d\"))]\n+  \"TARGET_HARD_FLOAT && !ISA_HAS_TRUNC_W\"\n+  \"trunc.w.s %0,%1,%2\"\n+  [(set_attr \"type\"\t\"fcvt\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"36\")])\n \n ;;; ??? trunc.l.d is mentioned in the appendix of the 1993 r4000/r4600 manuals\n ;;; but not in the chapter that describes the FPU.  It is not mentioned at all\n@@ -4377,122 +4377,66 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;; If this is disabled, then fixuns_truncdfdi2 must be disabled also.\n \n (define_insn \"fix_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,*f,R,To\")\n-\t(fix:DI (match_operand:DF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_scratch:DF 2 \"=f,?*X,f,f\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  if (which_alternative == 1)\n-    return \\\"trunc.l.d %0,%1\\\";\n-\n-  output_asm_insn (\\\"trunc.l.d %2,%1\\\", operands);\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[2];\n-  output_asm_insn (mips_move_2words (xoperands, insn), xoperands);\n-  return \\\"\\\";\n-}\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT\"\n+  \"trunc.l.d %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"8,4,8,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n ;;; ??? trunc.l.s is mentioned in the appendix of the 1993 r4000/r4600 manuals\n ;;; but not in the chapter that describes the FPU.  It is not mentioned at all\n ;;; in the 1991 manuals.  The r4000 at Cygnus does not have this instruction.\n (define_insn \"fix_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,*f,R,To\")\n-\t(fix:DI (match_operand:SF 1 \"register_operand\" \"f,*f,f,f\")))\n-   (clobber (match_scratch:DF 2 \"=f,?*X,f,f\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  rtx xoperands[10];\n-\n-  if (which_alternative == 1)\n-    return \\\"trunc.l.s %0,%1\\\";\n-\n-  output_asm_insn (\\\"trunc.l.s %2,%1\\\", operands);\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[2];\n-  output_asm_insn (mips_move_2words (xoperands, insn), xoperands);\n-  return \\\"\\\";\n-}\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT\"\n+  \"trunc.l.s %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"8,4,8,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n (define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  dslots_load_total++;\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"l.s\\\\t%0,%1%#\\;cvt.d.w\\\\t%0,%0\\\";\n-\n-  return \\\"mtc1\\\\t%1,%0%#\\;cvt.d.w\\\\t%0,%0\\\";\n-}\"\n+  \"cvt.d.w\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"12,16,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n (define_insn \"floatdidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n-\t(float:DF (match_operand:DI 1 \"se_nonimmediate_operand\" \"d,R,m\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  dslots_load_total++;\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"l.d\\\\t%0,%1%#\\;cvt.d.l\\\\t%0,%0\\\";\n-\n-  return \\\"dmtc1\\\\t%1,%0%#\\;cvt.d.l\\\\t%0,%0\\\";\n-}\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:DI 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT\"\n+  \"cvt.d.l\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"12,16,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n (define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n-\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"d,R,m\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n-  \"*\n-{\n-  dslots_load_total++;\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"l.s\\\\t%0,%1%#\\;cvt.s.w\\\\t%0,%0\\\";\n-\n-  return \\\"mtc1\\\\t%1,%0%#\\;cvt.s.w\\\\t%0,%0\\\";\n-}\"\n+  \"cvt.s.w\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"12,16,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n (define_insn \"floatdisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n-\t(float:SF (match_operand:DI 1 \"se_nonimmediate_operand\" \"d,R,m\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT\"\n-  \"*\n-{\n-  dslots_load_total++;\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"l.d\\\\t%0,%1%#\\;cvt.s.l\\\\t%0,%0\\\";\n-\n-  return \\\"dmtc1\\\\t%1,%0%#\\;cvt.s.l\\\\t%0,%0\\\";\n-}\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:DI 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT\"\n+  \"cvt.s.l\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"12,16,12\")])\n+   (set_attr \"length\"\t\"4\")])\n \n \n (define_expand \"fixuns_truncdfsi2\"\n@@ -5140,19 +5084,44 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\")\n \n (define_insn \"movdi_internal2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:DI 1 \"movdi_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*f,*f,*f,*f,*d,*R,*m,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*f,*d*J,*R,*m,*f,*f,*f,*J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n-       || se_register_operand (operands[1], DImode)\n+       || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,move,xfer,load,load,xfer,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,8,8,8,8,8,8,8\")])\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,8,4,4,8,4,4,4,8,8,8,8,8,8,8\")])\n \n-(define_insn \"\"\n+;; Sign-extended operands are reloaded using this instruction, so the\n+;; constraints must handle every SImode source operand X and destination\n+;; register R for which:\n+;;\n+;;     mips_secondary_reload_class (CLASS_OF (R), DImode, true,\n+;;\t\t\t\t    gen_rtx_SIGN_EXTEND (DImode, X))\n+;;\n+;; returns NO_REGS.  Also handle memory destinations, where allowed.\n+;;\n+;; This pattern is essentially a trimmed-down version of movdi_internal2.\n+;; The main difference is that dJ -> f and f -> d are the only constraints\n+;; involving float registers.  See mips_secondary_reload_class for details.\n+(define_insn \"*movdi_internal2_extend\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*d,*f,*x,*d,*x,*a,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(sign_extend:DI (match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*f,*d*J,*J,*x,*d,*J,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\")))]\n+  \"TARGET_64BIT && !TARGET_MIPS16\n+   && (register_operand (operands[0], DImode)\n+       || register_operand (operands[1], DImode)\n+       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n+       || operands[1] == CONST0_RTX (DImode))\"\n+  \"* return mips_sign_extend (insn, operands[0], operands[1]);\"\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+   (set_attr \"mode\"\t\"DI\")\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,4,4,8,8,8,8,8,8,8\")])\n+\n+(define_insn \"*movdi_internal2_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,R,m,*d\")\n \t(match_operand:DI 1 \"movdi_operand\" \"d,d,y,K,N,s,R,m,d,d,*x\"))]\n   \"TARGET_64BIT && TARGET_MIPS16\n@@ -5535,29 +5504,17 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; The difference between these two is whether or not ints are allowed\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n-(define_insn \"movsi_internal1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,J,*d,*x,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n-  \"TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,4,8,4,8,4,4,4,4,4,4,8,4,4,8\")])\n-\n-(define_insn \"movsi_internal2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*z,*d,J,*x,*d,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n-  \"!TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n+(define_insn \"movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,m,*f,*f,*f,?*f,*d,*R,*m,*d,*z,*x,*d,*x,*d,*B*C*D,*B*C*D,*B*C*D,*d,*m,*R\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,IKL,Mnis,R,m,dJ,dJ,*f,*d*J,*R,*m,*f,*f,*f,*z,*d,J,*x,*d,*a,*d,*m,*R,*B*C*D,*B*C*D,*B*C*D\"))]\n+  \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n+  [(set_attr \"type\"\t\"move,arith,arith,load,load,store,store,move,xfer,load,load,xfer,store,store,xfer,xfer,hilo,hilo,hilo,hilo,xfer,load,load,xfer,store,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,4,4,4,4,4,8,4,4,8\")])\n+   (set_attr \"length\"\t\"4,4,8,4,8,4,8,4,4,4,8,4,4,8,4,4,4,4,4,4,4,4,8,4,4,8\")])\n \n ;; This is the mips16 movsi instruction.  We accept a small integer as\n ;; the source if the destination is a GP memory reference.  This is\n@@ -6041,10 +5998,10 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; The difference between these two is whether or not ints are allowed\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n-(define_insn \"movhi_internal1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f,*f*z,*x,*d\")\n+(define_insn \"movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f*z,*f,*x,*d\")\n \t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*f*z,*d,*f,*d,*x\"))]\n-  \"TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n+  \"!TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n@@ -6053,18 +6010,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"HI\")\n    (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4,4\")])\n \n-(define_insn \"movhi_internal2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n-\t(match_operand:HI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n-  \"!TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n-  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n-   (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,R,m,*d\")\n \t(match_operand:HI 1 \"general_operand\"      \"d,d,y,K,N,R,m,d,d,*x\"))]\n@@ -6163,10 +6108,10 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; The difference between these two is whether or not ints are allowed\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n-(define_insn \"movqi_internal1\"\n+(define_insn \"movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*f*z,*f,*x,*d\")\n \t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*f*z,*d,*f,*d,*x\"))]\n-  \"TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n+  \"!TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n@@ -6175,18 +6120,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"QI\")\n    (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4,4\")])\n \n-(define_insn \"movqi_internal2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,m,*d,*z,*x,*d\")\n-\t(match_operand:QI 1 \"general_operand\"       \"d,IK,R,m,dJ,dJ,*z,*d,*d,*x\"))]\n-  \"!TARGET_DEBUG_H_MODE && !TARGET_MIPS16\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode)\n-       || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n-  \"* return mips_move_1word (operands, insn, TRUE);\"\n-  [(set_attr \"type\"\t\"move,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n-   (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,4,8,4,8,4,4,4,4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,R,m,*d\")\n \t(match_operand:QI 1 \"general_operand\"      \"d,d,y,K,N,R,m,d,d,*x\"))]"}]}