{"sha": "eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhZmIzMTk1N2E0MzgyYTk0MWU5OGE3OWQzZTNmZjFiNWNhOTdhMQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-12-01T18:23:37Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-12-01T18:23:37Z"}, "message": "PR jit/64020: Fixes to handling of builtins\n\n\tPR jit/64020\n\t* docs/topics/types.rst (Standard types) Add new enum values to\n\tthe table of enum gcc_jit_types: GCC_JIT_TYPE_COMPLEX_FLOAT,\n\tGCC_JIT_TYPE_COMPLEX_DOUBLE, GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE.\n\tWiden the left-hand column so that\n\tGCC_JIT_TYPE_COMPLEX_LONG_DOUBLE will fit.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\n\t* jit-builtins.c: Include stringpool.h and jit-playback.h.\n\tMove everything out of the gcc::jit::recording namespace into\n\tjust gcc::jit.\n\t(struct builtin_data): Add fields \"fnclass\", \"attr\", and\n\t\"implicit_p\".\n\t(DEF_BUILTIN): Update macro so populate the new fields.\n\t(builtins_manager::builtins_manager): Update for move out of\n\trecording namespace.  Initialize the m_attributes array.\n\t(builtins_manager::get_builtin_function): Likewise.\n\t(builtins_manager::get_builtin_function_by_id): New function.\n\t(builtins_manager::make_builtin_function): Update for move out of\n\trecording namespace.  Add fix for PR jit/64020 by detecting\n\tspecific builtin ids and having them ensure that builtins for\n\tother ids are created as necessary.\n\t(builtins_manager::get_type): Update for move out of recording\n\tnamespace.\n\t(builtins_manager::make_type): Likewise.  Add some missing\n\t#undefs.\n\t(builtins_manager::make_primitive_type): Update for move out of\n\trecording namespace.  Implement the three BT_COMPLEX_ cases and\n\tBT_DOUBLE_PTR.\n\t(builtins_manager::make_fn_type): Update for move out of recording\n\tnamespace.\n\t(builtins_manager::make_ptr_type): Likewise.\n\t(builtins_manager::finish_playback): New function.\n\t(builtins_manager::get_class): New function.\n\t(builtins_manager::implicit_p): New function.\n\t(builtins_manager::get_attrs_tree): Two new functions.\n\t(builtins_manager::make_attrs_tree): New function.\n\n\t* jit-builtins.h: Move everything out of the gcc::jit::recording\n\tnamespace into just gcc::jit.\n\t(enum built_in_attribute): New.\n\t(builtins_manager::builtins_manager): Update decl for namespace\n\tchange.\n\t(builtins_manager::get_builtin_function): Likewise.\n\t(builtins_manager::get_class): New.\n\t(builtins_manager::implicit_p): New.\n\t(builtins_manager::get_attrs_tree): Two new functions.\n\t(builtins_manager::make_attrs_tree): New function.\n\t(builtins_manager::finish_playback): New.\n\t(builtins_manager::get_builtin_function_by_id): New.\n\t(builtins_manager::make_builtin_function): Update decl for\n\tnamespace change.\n\t(builtins_manager::get_type): Likewise.\n\t(builtins_manager::make_type): Likewise.\n\t(builtins_manager::make_primitive_type): Likewise.\n\t(builtins_manager::make_fn_type): Likewise.\n\t(builtins_manager::make_ptr_type): Likewise.\n\t(builtins_manager): Likewise for fields.  Add new field\n\t\"m_attributes\".\n\n\t* jit-common.h (NUM_GCC_JIT_TYPES): Update.\n\t(builtins_manager): Update forward decl to reflect namespace\n\tchange.\n\n\t* jit-playback.c: Include attribs.h and jit-builtins.h.\n\t(gcc::jit::playback::context::get_tree_node_for_type): Add cases\n\tfor the new COMPLEX_ types.\n\t(gcc::jit::playback::context::new_function): If creating a\n\tbuiltin, set the DECL_BUILT_IN_CLASS and attributes on the fndecl,\n\tand call set_builtin_decl.\n\t(gcc::jit::playback::context::replay): If we have a\n\tbuiltins_manager, call its finish_playback method when we're done.\n\n\t* jit-playback.h:\n\t(gcc::jit::playback::context::get_builtins_manager): New function.\n\n\t* jit-recording.c\n\t(gcc::jit::recording::context::get_builtins_manager): New function.\n\t(gcc::jit::recording::get_builtin_function): Use\n\tget_builtins_manager, in case we're a child context.\n\t(gcc::jit::recording::memento_of_get_type::dereference): Add the\n\tCOMPLEX_ types.\n\t(gcc::jit::recording::memento_of_get_type::is_int): Likewise.\n\t(gcc::jit::recording::memento_of_get_type::is_float): Likewise.\n\t(gcc::jit::recording::memento_of_get_type::is_bool): Likewise.\n\t(get_type_strings): Likewise.\n\n\t* jit-recording.h\n\t(gcc::jit::recording::context::get_builtins_manager): New.\n\n\t* libgccjit.h (enum gcc_jit_types): Add\n\tGCC_JIT_TYPE_COMPLEX_FLOAT, GCC_JIT_TYPE_COMPLEX_DOUBLE,\n\tGCC_JIT_TYPE_COMPLEX_LONG_DOUBLE.\n\nFrom-SVN: r218240", "tree": {"sha": "42a906c1ce5855a27ab1a975ddae3a7e2763a59e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a906c1ce5855a27ab1a975ddae3a7e2763a59e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23844fd7306763ee07f27acd6883fd47bc858ec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23844fd7306763ee07f27acd6883fd47bc858ec3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23844fd7306763ee07f27acd6883fd47bc858ec3"}], "stats": {"total": 1076, "additions": 822, "deletions": 254}, "files": [{"sha": "5bc149d63dd89881c1f244596378f0b7233a1167", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -1,3 +1,99 @@\n+2014-12-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR jit/64020\n+\t* docs/topics/types.rst (Standard types) Add new enum values to\n+\tthe table of enum gcc_jit_types: GCC_JIT_TYPE_COMPLEX_FLOAT,\n+\tGCC_JIT_TYPE_COMPLEX_DOUBLE, GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE.\n+\tWiden the left-hand column so that\n+\tGCC_JIT_TYPE_COMPLEX_LONG_DOUBLE will fit.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\n+\t* jit-builtins.c: Include stringpool.h and jit-playback.h.\n+\tMove everything out of the gcc::jit::recording namespace into\n+\tjust gcc::jit.\n+\t(struct builtin_data): Add fields \"fnclass\", \"attr\", and\n+\t\"implicit_p\".\n+\t(DEF_BUILTIN): Update macro so populate the new fields.\n+\t(builtins_manager::builtins_manager): Update for move out of\n+\trecording namespace.  Initialize the m_attributes array.\n+\t(builtins_manager::get_builtin_function): Likewise.\n+\t(builtins_manager::get_builtin_function_by_id): New function.\n+\t(builtins_manager::make_builtin_function): Update for move out of\n+\trecording namespace.  Add fix for PR jit/64020 by detecting\n+\tspecific builtin ids and having them ensure that builtins for\n+\tother ids are created as necessary.\n+\t(builtins_manager::get_type): Update for move out of recording\n+\tnamespace.\n+\t(builtins_manager::make_type): Likewise.  Add some missing\n+\t#undefs.\n+\t(builtins_manager::make_primitive_type): Update for move out of\n+\trecording namespace.  Implement the three BT_COMPLEX_ cases and\n+\tBT_DOUBLE_PTR.\n+\t(builtins_manager::make_fn_type): Update for move out of recording\n+\tnamespace.\n+\t(builtins_manager::make_ptr_type): Likewise.\n+\t(builtins_manager::finish_playback): New function.\n+\t(builtins_manager::get_class): New function.\n+\t(builtins_manager::implicit_p): New function.\n+\t(builtins_manager::get_attrs_tree): Two new functions.\n+\t(builtins_manager::make_attrs_tree): New function.\n+\n+\t* jit-builtins.h: Move everything out of the gcc::jit::recording\n+\tnamespace into just gcc::jit.\n+\t(enum built_in_attribute): New.\n+\t(builtins_manager::builtins_manager): Update decl for namespace\n+\tchange.\n+\t(builtins_manager::get_builtin_function): Likewise.\n+\t(builtins_manager::get_class): New.\n+\t(builtins_manager::implicit_p): New.\n+\t(builtins_manager::get_attrs_tree): Two new functions.\n+\t(builtins_manager::make_attrs_tree): New function.\n+\t(builtins_manager::finish_playback): New.\n+\t(builtins_manager::get_builtin_function_by_id): New.\n+\t(builtins_manager::make_builtin_function): Update decl for\n+\tnamespace change.\n+\t(builtins_manager::get_type): Likewise.\n+\t(builtins_manager::make_type): Likewise.\n+\t(builtins_manager::make_primitive_type): Likewise.\n+\t(builtins_manager::make_fn_type): Likewise.\n+\t(builtins_manager::make_ptr_type): Likewise.\n+\t(builtins_manager): Likewise for fields.  Add new field\n+\t\"m_attributes\".\n+\n+\t* jit-common.h (NUM_GCC_JIT_TYPES): Update.\n+\t(builtins_manager): Update forward decl to reflect namespace\n+\tchange.\n+\n+\t* jit-playback.c: Include attribs.h and jit-builtins.h.\n+\t(gcc::jit::playback::context::get_tree_node_for_type): Add cases\n+\tfor the new COMPLEX_ types.\n+\t(gcc::jit::playback::context::new_function): If creating a\n+\tbuiltin, set the DECL_BUILT_IN_CLASS and attributes on the fndecl,\n+\tand call set_builtin_decl.\n+\t(gcc::jit::playback::context::replay): If we have a\n+\tbuiltins_manager, call its finish_playback method when we're done.\n+\n+\t* jit-playback.h:\n+\t(gcc::jit::playback::context::get_builtins_manager): New function.\n+\n+\t* jit-recording.c\n+\t(gcc::jit::recording::context::get_builtins_manager): New function.\n+\t(gcc::jit::recording::get_builtin_function): Use\n+\tget_builtins_manager, in case we're a child context.\n+\t(gcc::jit::recording::memento_of_get_type::dereference): Add the\n+\tCOMPLEX_ types.\n+\t(gcc::jit::recording::memento_of_get_type::is_int): Likewise.\n+\t(gcc::jit::recording::memento_of_get_type::is_float): Likewise.\n+\t(gcc::jit::recording::memento_of_get_type::is_bool): Likewise.\n+\t(get_type_strings): Likewise.\n+\n+\t* jit-recording.h\n+\t(gcc::jit::recording::context::get_builtins_manager): New.\n+\n+\t* libgccjit.h (enum gcc_jit_types): Add\n+\tGCC_JIT_TYPE_COMPLEX_FLOAT, GCC_JIT_TYPE_COMPLEX_DOUBLE,\n+\tGCC_JIT_TYPE_COMPLEX_LONG_DOUBLE.\n+\n 2014-12-01  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit-builtins.c"}, {"sha": "d651aa4681a802828f123c7a6d9419755a8aca88", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 378, "deletions": 172, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-libgccjit 5.0.0 (experimental 20141110), November 10, 2014\n+libgccjit 5.0.0 (experimental 20141201), December 01, 2014\n \n David Malcolm\n \n@@ -2046,7 +2046,27 @@ then directly executed in-process:\n @quotation\n \n @example\n-typedef int (*toyvm_compiled_func) (int);\n+typedef int (*toyvm_compiled_code) (int);\n+\n+\n+@end example\n+\n+@noindent\n+@end quotation\n+\n+The lifetime of the code is tied to that of a @pxref{16,,gcc_jit_result *}.\n+We'll handle this by bundling them up in a structure, so that we can\n+clean them up together by calling @pxref{37,,gcc_jit_result_release()}:\n+\n+@quotation\n+\n+@example\n+\n+struct toyvm_compiled_function\n+@{\n+  gcc_jit_result *cf_jit_result;\n+  toyvm_compiled_code cf_code;\n+@};\n \n \n @end example\n@@ -2118,7 +2138,7 @@ struct compilation_state\n @end quotation\n \n @node Setting things up,Populating the function,Compiling to machine code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 setting-things-up}@anchor{37}\n+@anchor{intro/tutorial04 setting-things-up}@anchor{38}\n @subsection Setting things up\n \n \n@@ -2224,7 +2244,7 @@ add_pop (compilation_state *state,\n @end quotation\n \n We will support single-stepping through the generated code in the\n-debugger, so we need to create @pxref{38,,gcc_jit_location} instances, one\n+debugger, so we need to create @pxref{39,,gcc_jit_location} instances, one\n per operation in the source code.  These will reference the lines of\n e.g. @code{factorial.toy}.\n \n@@ -2295,7 +2315,7 @@ We create the locals within the function.\n @end quotation\n \n @node Populating the function,Verifying the control flow graph,Setting things up,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 populating-the-function}@anchor{39}\n+@anchor{intro/tutorial04 populating-the-function}@anchor{3a}\n @subsection Populating the function\n \n \n@@ -2427,7 +2447,7 @@ stack into @code{y} instead erroneously assigned it to @code{x}, leaving @code{y\n uninitialized.\n \n To track this kind of thing down, we can use\n-@pxref{3a,,gcc_jit_block_add_comment()} to add descriptive comments\n+@pxref{3b,,gcc_jit_block_add_comment()} to add descriptive comments\n to the internal representation.  This is invaluable when looking through\n the generated IR for, say @code{factorial}:\n \n@@ -2601,7 +2621,7 @@ to the next block.\n This is analogous to simply incrementing the program counter.\n \n @node Verifying the control flow graph,Compiling the context,Populating the function,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 verifying-the-control-flow-graph}@anchor{3b}\n+@anchor{intro/tutorial04 verifying-the-control-flow-graph}@anchor{3c}\n @subsection Verifying the control flow graph\n \n \n@@ -2632,7 +2652,7 @@ errors in our compiler.\n @end quotation\n \n @node Compiling the context,Single-stepping through the generated code,Verifying the control flow graph,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 compiling-the-context}@anchor{3c}\n+@anchor{intro/tutorial04 compiling-the-context}@anchor{3d}\n @subsection Compiling the context\n \n \n@@ -2644,11 +2664,168 @@ We can now compile it, and extract machine code from the result:\n @quotation\n \n @example\n-  gcc_jit_result *result = gcc_jit_context_compile (state.ctxt);\n+  gcc_jit_result *jit_result = gcc_jit_context_compile (state.ctxt);\n   gcc_jit_context_release (state.ctxt);\n \n-  return (toyvm_compiled_func)gcc_jit_result_get_code (result,\n-\t\t\t\t\t\t       funcname);\n+  toyvm_compiled_function *toyvm_result =\n+    (toyvm_compiled_function *)calloc (1, sizeof (toyvm_compiled_function));\n+  if (!toyvm_result)\n+    @{\n+      fprintf (stderr, \"out of memory allocating toyvm_compiled_function\\n\");\n+      gcc_jit_result_release (jit_result);\n+      return NULL;\n+    @}\n+\n+  toyvm_result->cf_jit_result = jit_result;\n+  toyvm_result->cf_code =\n+    (toyvm_compiled_code)gcc_jit_result_get_code (jit_result,\n+\t\t\t\t\t\t  funcname);\n+\n+  free (funcname);\n+\n+  return toyvm_result;\n+@}\n+\n+char test[1024];\n+\n+#define CHECK_NON_NULL(PTR) \\\n+  do @{                                       \\\n+    if ((PTR) != NULL)                       \\\n+      @{                                      \\\n+\tpass (\"%s: %s is non-null\", test, #PTR); \\\n+      @}                                      \\\n+    else                                     \\\n+      @{                                      \\\n+\tfail (\"%s: %s is NULL\", test, #PTR); \\\n+\tabort ();                            \\\n+    @}                                        \\\n+  @} while (0)\n+\n+#define CHECK_VALUE(ACTUAL, EXPECTED) \\\n+  do @{                                       \\\n+    if ((ACTUAL) == (EXPECTED))              \\\n+      @{                                      \\\n+\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+      @}                                      \\\n+    else                                     \\\n+      @{                                        \\\n+\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+\tfprintf (stderr, \"incorrect value\\n\"); \\\n+\tabort ();                              \\\n+    @}                                        \\\n+  @} while (0)\n+\n+static void\n+test_script (const char *scripts_dir, const char *script_name, int input,\n+\t     int expected_result)\n+@{\n+  char *script_path;\n+  toyvm_function *fn;\n+  int interpreted_result;\n+  toyvm_compiled_function *compiled_fn;\n+  toyvm_compiled_code code;\n+  int compiled_result;\n+\n+  snprintf (test, sizeof (test), \"toyvm.c: %s\", script_name);\n+\n+  script_path = (char *)malloc (strlen (scripts_dir)\n+\t\t\t\t+ strlen (script_name) + 1);\n+  CHECK_NON_NULL (script_path);\n+  sprintf (script_path, \"%s%s\", scripts_dir, script_name);\n+\n+  fn = toyvm_function_parse (script_path, script_name);\n+  CHECK_NON_NULL (fn);\n+\n+  interpreted_result = toyvm_function_interpret (fn, input, NULL);\n+  CHECK_VALUE (interpreted_result, expected_result);\n+\n+  compiled_fn = toyvm_function_compile (fn);\n+  CHECK_NON_NULL (compiled_fn);\n+\n+  code = (toyvm_compiled_code)compiled_fn->cf_code;\n+  CHECK_NON_NULL (code);\n+\n+  compiled_result = code (input);\n+  CHECK_VALUE (compiled_result, expected_result);\n+\n+  gcc_jit_result_release (compiled_fn->cf_jit_result);\n+  free (compiled_fn);\n+  free (fn);\n+  free (script_path);\n+@}\n+\n+#define PATH_TO_SCRIPTS  (\"/jit/docs/examples/tut04-toyvm/\")\n+\n+static void\n+test_suite (void)\n+@{\n+  const char *srcdir;\n+  char *scripts_dir;\n+\n+  snprintf (test, sizeof (test), \"toyvm.c\");\n+\n+  /* We need to locate the test scripts.\n+     Rely on \"srcdir\" being set in the environment.  */\n+\n+  srcdir = getenv (\"srcdir\");\n+  CHECK_NON_NULL (srcdir);\n+\n+  scripts_dir = (char *)malloc (strlen (srcdir) + strlen(PATH_TO_SCRIPTS)\n+\t\t\t\t+ 1);\n+  CHECK_NON_NULL (scripts_dir);\n+  sprintf (scripts_dir, \"%s%s\", srcdir, PATH_TO_SCRIPTS);\n+\n+  test_script (scripts_dir, \"factorial.toy\", 10, 3628800);\n+  test_script (scripts_dir, \"fibonacci.toy\", 10, 55);\n+\n+  free (scripts_dir);\n+@}\n+\n+int\n+main (int argc, char **argv)\n+@{\n+  const char *filename = NULL;\n+  toyvm_function *fn = NULL;\n+\n+  /* If called with no args, assume we're being run by the test suite.  */\n+  if (argc < 3)\n+    @{\n+      test_suite ();\n+      return 0;\n+    @}\n+\n+  if (argc != 3)\n+    @{\n+      fprintf (stdout,\n+\t\"%s FILENAME INPUT: Parse and run a .toy file\\n\",\n+\targv[0]);\n+      exit (1);\n+    @}\n+\n+  filename = argv[1];\n+  fn = toyvm_function_parse (filename, filename);\n+  if (!fn)\n+    exit (1);\n+\n+  if (0)\n+    toyvm_function_disassemble (fn, stdout);\n+\n+  printf (\"interpreter result: %d\\n\",\n+\t  toyvm_function_interpret (fn, atoi (argv[2]), NULL));\n+\n+  /* JIT-compilation.  */\n+  toyvm_compiled_function *compiled_fn\n+    = toyvm_function_compile (fn);\n+\n+  toyvm_compiled_code code = compiled_fn->cf_code;\n+  printf (\"compiler result: %d\\n\",\n+\t  code (atoi (argv[2])));\n+\n+  gcc_jit_result_release (compiled_fn->cf_jit_result);\n+  free (compiled_fn);\n+\n+ return 0;\n+@}\n \n @end example\n \n@@ -2660,18 +2837,24 @@ We can now run the result:\n @quotation\n \n @example\n-  toyvm_compiled_func code = toyvm_function_compile (fn);\n+  toyvm_compiled_function *compiled_fn\n+    = toyvm_function_compile (fn);\n+\n+  toyvm_compiled_code code = compiled_fn->cf_code;\n   printf (\"compiler result: %d\\n\",\n \t  code (atoi (argv[2])));\n \n+  gcc_jit_result_release (compiled_fn->cf_jit_result);\n+  free (compiled_fn);\n+\n \n @end example\n \n @noindent\n @end quotation\n \n @node Single-stepping through the generated code,Examining the generated code,Compiling the context,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 single-stepping-through-the-generated-code}@anchor{3d}\n+@anchor{intro/tutorial04 single-stepping-through-the-generated-code}@anchor{3e}\n @subsection Single-stepping through the generated code\n \n \n@@ -2685,12 +2868,12 @@ It's possible to debug the generated code.  To do this we need to both:\n @item \n Set up source code locations for our statements, so that we can\n meaningfully step through the code.  We did this above by\n-calling @pxref{3e,,gcc_jit_context_new_location()} and using the\n+calling @pxref{3f,,gcc_jit_context_new_location()} and using the\n results.\n \n @item \n Enable the generation of debugging information, by setting\n-@pxref{3f,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n+@pxref{40,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n @pxref{8,,gcc_jit_context} via\n @pxref{19,,gcc_jit_context_set_bool_option()}:\n \n@@ -2767,7 +2950,7 @@ optimization level in a regular compiler.\n @end cartouche\n \n @node Examining the generated code,Putting it all together,Single-stepping through the generated code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 examining-the-generated-code}@anchor{40}\n+@anchor{intro/tutorial04 examining-the-generated-code}@anchor{41}\n @subsection Examining the generated code\n \n \n@@ -2967,7 +3150,7 @@ Note that the stack pushing and popping have been eliminated, as has the\n recursive call (in favor of an iteration).\n \n @node Putting it all together,Behind the curtain How does our code get optimized?,Examining the generated code,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 putting-it-all-together}@anchor{41}\n+@anchor{intro/tutorial04 putting-it-all-together}@anchor{42}\n @subsection Putting it all together\n \n \n@@ -3000,7 +3183,7 @@ compiler result: 55\n @noindent\n \n @node Behind the curtain How does our code get optimized?,,Putting it all together,Tutorial part 4 Adding JIT-compilation to a toy interpreter\n-@anchor{intro/tutorial04 behind-the-curtain-how-does-our-code-get-optimized}@anchor{42}\n+@anchor{intro/tutorial04 behind-the-curtain-how-does-our-code-get-optimized}@anchor{43}\n @subsection Behind the curtain: How does our code get optimized?\n \n \n@@ -3098,7 +3281,7 @@ initial:\n @noindent\n \n We can perhaps better see the code by turning off\n-@pxref{3f,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to suppress all those @code{DEBUG}\n+@pxref{40,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to suppress all those @code{DEBUG}\n statements, giving:\n \n @example\n@@ -3205,7 +3388,7 @@ representation: @code{initial}, @code{instr4} and @code{instr9}.\n @end menu\n \n @node Optimizing away stack manipulation,Elimination of tail recursion,,Behind the curtain How does our code get optimized?\n-@anchor{intro/tutorial04 optimizing-away-stack-manipulation}@anchor{43}\n+@anchor{intro/tutorial04 optimizing-away-stack-manipulation}@anchor{44}\n @subsubsection Optimizing away stack manipulation\n \n \n@@ -3485,7 +3668,7 @@ instr9:\n @noindent\n \n @node Elimination of tail recursion,,Optimizing away stack manipulation,Behind the curtain How does our code get optimized?\n-@anchor{intro/tutorial04 elimination-of-tail-recursion}@anchor{44}\n+@anchor{intro/tutorial04 elimination-of-tail-recursion}@anchor{45}\n @subsubsection Elimination of tail recursion\n \n \n@@ -3572,7 +3755,7 @@ instr9:\n @c <http://www.gnu.org/licenses/>.\n \n @node Topic Reference,Internals,Tutorial,Top\n-@anchor{topics/index doc}@anchor{45}@anchor{topics/index topic-reference}@anchor{46}\n+@anchor{topics/index doc}@anchor{46}@anchor{topics/index topic-reference}@anchor{47}\n @chapter Topic Reference\n \n \n@@ -3656,7 +3839,7 @@ Source Locations\n \n \n @node Compilation contexts,Objects,,Topic Reference\n-@anchor{topics/contexts compilation-contexts}@anchor{47}@anchor{topics/contexts doc}@anchor{48}\n+@anchor{topics/contexts compilation-contexts}@anchor{48}@anchor{topics/contexts doc}@anchor{49}\n @section Compilation contexts\n \n \n@@ -3684,7 +3867,7 @@ Invoking @pxref{15,,gcc_jit_context_compile()} on it gives you a\n @end menu\n \n @node Lifetime-management,Thread-safety,,Compilation contexts\n-@anchor{topics/contexts lifetime-management}@anchor{49}\n+@anchor{topics/contexts lifetime-management}@anchor{4a}\n @subsection Lifetime-management\n \n \n@@ -3721,7 +3904,7 @@ gcc_jit_context_release (ctxt);\n @end deffn\n \n @geindex gcc_jit_context_new_child_context (C function)\n-@anchor{topics/contexts gcc_jit_context_new_child_context}@anchor{4a}\n+@anchor{topics/contexts gcc_jit_context_new_child_context}@anchor{4b}\n @deffn {C Function} gcc_jit_context * gcc_jit_context_new_child_context (gcc_jit_context@w{ }*parent_ctxt)\n \n Given an existing JIT context, create a child context.\n@@ -3753,7 +3936,7 @@ there will likely be a performance hit for such nesting.\n @end deffn\n \n @node Thread-safety,Error-handling,Lifetime-management,Compilation contexts\n-@anchor{topics/contexts thread-safety}@anchor{4b}\n+@anchor{topics/contexts thread-safety}@anchor{4c}\n @subsection Thread-safety\n \n \n@@ -3762,15 +3945,15 @@ Instances of @pxref{e,,gcc_jit_object *} created via\n only one thread may use a given context at once, but multiple threads\n could each have their own contexts without needing locks.\n \n-Contexts created via @pxref{4a,,gcc_jit_context_new_child_context()} are\n+Contexts created via @pxref{4b,,gcc_jit_context_new_child_context()} are\n related to their parent context.  They can be partitioned by their\n ultimate ancestor into independent \"family trees\".   Only one thread\n within a process may use a given \"family tree\" of such contexts at once,\n and if you're using multiple threads you should provide your own locking\n around entire such context partitions.\n \n @node Error-handling,Debugging,Thread-safety,Compilation contexts\n-@anchor{topics/contexts error-handling}@anchor{4c}\n+@anchor{topics/contexts error-handling}@anchor{4d}\n @subsection Error-handling\n \n \n@@ -3781,10 +3964,10 @@ NULL.  You don't have to check everywhere for NULL results, since the\n API gracefully handles a NULL being passed in for any argument.\n \n Errors are printed on stderr and can be queried using\n-@pxref{4d,,gcc_jit_context_get_first_error()}.\n+@pxref{4e,,gcc_jit_context_get_first_error()}.\n \n @geindex gcc_jit_context_get_first_error (C function)\n-@anchor{topics/contexts gcc_jit_context_get_first_error}@anchor{4d}\n+@anchor{topics/contexts gcc_jit_context_get_first_error}@anchor{4e}\n @deffn {C Function} const char *           gcc_jit_context_get_first_error (gcc_jit_context@w{ }*ctxt)\n \n Returns the first error message that occurred on the context.\n@@ -3796,26 +3979,26 @@ If no errors occurred, this will be NULL.\n @end deffn\n \n @node Debugging,Options<2>,Error-handling,Compilation contexts\n-@anchor{topics/contexts debugging}@anchor{4e}\n+@anchor{topics/contexts debugging}@anchor{4f}\n @subsection Debugging\n \n \n @geindex gcc_jit_context_dump_to_file (C function)\n-@anchor{topics/contexts gcc_jit_context_dump_to_file}@anchor{4f}\n+@anchor{topics/contexts gcc_jit_context_dump_to_file}@anchor{50}\n @deffn {C Function} void           gcc_jit_context_dump_to_file (gcc_jit_context@w{ }*ctxt, const char@w{ }*path, int@w{ }update_locations)\n \n To help with debugging: dump a C-like representation to the given path,\n describing what's been set up on the context.\n \n-If \"update_locations\" is true, then also set up @pxref{38,,gcc_jit_location}\n+If \"update_locations\" is true, then also set up @pxref{39,,gcc_jit_location}\n information throughout the context, pointing at the dump file as if it\n were a source file.  This may be of use in conjunction with\n-@pxref{3f,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to allow stepping through the\n+@pxref{40,,GCC_JIT_BOOL_OPTION_DEBUGINFO} to allow stepping through the\n code in a debugger.\n @end deffn\n \n @node Options<2>,,Debugging,Compilation contexts\n-@anchor{topics/contexts options}@anchor{50}\n+@anchor{topics/contexts options}@anchor{51}\n @subsection Options\n \n \n@@ -3827,25 +4010,25 @@ code in a debugger.\n @end menu\n \n @node String Options,Boolean options,,Options<2>\n-@anchor{topics/contexts string-options}@anchor{51}\n+@anchor{topics/contexts string-options}@anchor{52}\n @subsubsection String Options\n \n \n @geindex gcc_jit_context_set_str_option (C function)\n-@anchor{topics/contexts gcc_jit_context_set_str_option}@anchor{52}\n+@anchor{topics/contexts gcc_jit_context_set_str_option}@anchor{53}\n @deffn {C Function} void gcc_jit_context_set_str_option (gcc_jit_context@w{ }*ctxt, enum gcc_jit_str_option@w{ }opt, const char@w{ }*value)\n \n Set a string option of the context.\n \n @geindex gcc_jit_str_option (C type)\n-@anchor{topics/contexts gcc_jit_str_option}@anchor{53}\n+@anchor{topics/contexts gcc_jit_str_option}@anchor{54}\n @deffn {C Type} enum gcc_jit_str_option\n @end deffn\n \n There is currently just one string option:\n \n @geindex GCC_JIT_STR_OPTION_PROGNAME (C macro)\n-@anchor{topics/contexts GCC_JIT_STR_OPTION_PROGNAME}@anchor{54}\n+@anchor{topics/contexts GCC_JIT_STR_OPTION_PROGNAME}@anchor{55}\n @deffn {C Macro} GCC_JIT_STR_OPTION_PROGNAME\n \n The name of the program, for use as a prefix when printing error\n@@ -3854,7 +4037,7 @@ messages to stderr.  If @cite{NULL}, or default, \"libgccjit.so\" is used.\n @end deffn\n \n @node Boolean options,Integer options,String Options,Options<2>\n-@anchor{topics/contexts boolean-options}@anchor{55}\n+@anchor{topics/contexts boolean-options}@anchor{56}\n @subsubsection Boolean options\n \n \n@@ -3866,12 +4049,12 @@ Set a boolean option of the context.\n Zero is \"false\" (the default), non-zero is \"true\".\n \n @geindex gcc_jit_bool_option (C type)\n-@anchor{topics/contexts gcc_jit_bool_option}@anchor{56}\n+@anchor{topics/contexts gcc_jit_bool_option}@anchor{57}\n @deffn {C Type} enum gcc_jit_bool_option\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_DEBUGINFO (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DEBUGINFO}@anchor{3f}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DEBUGINFO}@anchor{40}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_DEBUGINFO\n \n If true, @pxref{15,,gcc_jit_context_compile()} will attempt to do the right\n@@ -3880,11 +4063,11 @@ be able to inspect variables and step through your code.\n \n Note that you can't step through code unless you set up source\n location information for the code (by creating and passing in\n-@pxref{38,,gcc_jit_location} instances).\n+@pxref{39,,gcc_jit_location} instances).\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}@anchor{57}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}@anchor{58}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE\n \n If true, @pxref{15,,gcc_jit_context_compile()} will dump its initial\n@@ -3981,7 +4164,7 @@ square:\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_DUMP_SUMMARY (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_SUMMARY}@anchor{58}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_SUMMARY}@anchor{59}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_SUMMARY\n \n If true, @pxref{15,,gcc_jit_context_compile()} will print information to stderr\n@@ -3990,19 +4173,19 @@ the time taken and memory usage of each phase.\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING}@anchor{59}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING}@anchor{5a}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING\n \n If true, @pxref{15,,gcc_jit_context_compile()} will dump copious\n amount of information on what it's doing to various\n files within a temporary directory.  Use\n-@pxref{5a,,GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES} (see below) to\n+@pxref{5b,,GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES} (see below) to\n see the results.  The files are intended to be human-readable,\n but the exact files and their formats are subject to change.\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_SELFCHECK_GC (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_SELFCHECK_GC}@anchor{5b}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_SELFCHECK_GC}@anchor{5c}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_SELFCHECK_GC\n \n If true, libgccjit will aggressively run its garbage collector, to\n@@ -4012,7 +4195,7 @@ used when running the selftest suite.\n @end deffn\n \n @geindex GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES (C macro)\n-@anchor{topics/contexts GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES}@anchor{5a}\n+@anchor{topics/contexts GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES}@anchor{5b}\n @deffn {C Macro} GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES\n \n If true, the @pxref{8,,gcc_jit_context} will not clean up intermediate files\n@@ -4021,7 +4204,7 @@ written to the filesystem, and will display their location on stderr.\n @end deffn\n \n @node Integer options,,Boolean options,Options<2>\n-@anchor{topics/contexts integer-options}@anchor{5c}\n+@anchor{topics/contexts integer-options}@anchor{5d}\n @subsubsection Integer options\n \n \n@@ -4032,7 +4215,7 @@ written to the filesystem, and will display their location on stderr.\n Set an integer option of the context.\n \n @geindex gcc_jit_int_option (C type)\n-@anchor{topics/contexts gcc_jit_int_option}@anchor{5d}\n+@anchor{topics/contexts gcc_jit_int_option}@anchor{5e}\n @deffn {C Type} enum gcc_jit_int_option\n @end deffn\n \n@@ -4069,7 +4252,7 @@ The default value is 0 (unoptimized).\n @c <http://www.gnu.org/licenses/>.\n \n @node Objects,Types,Compilation contexts,Topic Reference\n-@anchor{topics/objects objects}@anchor{5e}@anchor{topics/objects doc}@anchor{5f}\n+@anchor{topics/objects objects}@anchor{5f}@anchor{topics/objects doc}@anchor{60}\n @section Objects\n \n \n@@ -4129,7 +4312,7 @@ gcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n The object \"base class\" has the following operations:\n \n @geindex gcc_jit_object_get_context (C function)\n-@anchor{topics/objects gcc_jit_object_get_context}@anchor{60}\n+@anchor{topics/objects gcc_jit_object_get_context}@anchor{61}\n @deffn {C Function} gcc_jit_context *gcc_jit_object_get_context (gcc_jit_object@w{ }*obj)\n \n Which context is \"obj\" within?\n@@ -4185,7 +4368,7 @@ object's context is released.\n @c <http://www.gnu.org/licenses/>.\n \n @node Types,Expressions,Objects,Topic Reference\n-@anchor{topics/types doc}@anchor{61}@anchor{topics/types types}@anchor{62}\n+@anchor{topics/types doc}@anchor{62}@anchor{topics/types types}@anchor{63}\n @section Types\n \n \n@@ -4222,7 +4405,7 @@ See @pxref{b,,gcc_jit_context_get_type()} for the available types.\n \n @item \n derived types can be accessed by using functions such as\n-@pxref{63,,gcc_jit_type_get_pointer()} and @pxref{64,,gcc_jit_type_get_const()}:\n+@pxref{64,,gcc_jit_type_get_pointer()} and @pxref{65,,gcc_jit_type_get_const()}:\n \n @example\n gcc_jit_type *const_int_star = gcc_jit_type_get_pointer (gcc_jit_type_get_const (int_type));\n@@ -4243,7 +4426,7 @@ by creating structures (see below).\n @end menu\n \n @node Standard types,Pointers const and volatile,,Types\n-@anchor{topics/types standard-types}@anchor{65}\n+@anchor{topics/types standard-types}@anchor{66}\n @subsection Standard types\n \n \n@@ -4254,7 +4437,7 @@ by creating structures (see below).\n Access a specific type.  The available types are:\n \n \n-@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} \n+@multitable {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} \n @headitem\n \n @cite{enum gcc_jit_types} value\n@@ -4419,71 +4602,95 @@ C's @code{size_t} type\n \n C type: @code{(FILE *)}\n \n+@item\n+\n+@code{GCC_JIT_TYPE_COMPLEX_FLOAT}\n+\n+@tab\n+\n+C99's @code{_Complex float}\n+\n+@item\n+\n+@code{GCC_JIT_TYPE_COMPLEX_DOUBLE}\n+\n+@tab\n+\n+C99's @code{_Complex double}\n+\n+@item\n+\n+@code{GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE}\n+\n+@tab\n+\n+C99's @code{_Complex long double}\n+\n @end multitable\n \n @end deffn\n \n @geindex gcc_jit_context_get_int_type (C function)\n-@anchor{topics/types gcc_jit_context_get_int_type}@anchor{66}\n+@anchor{topics/types gcc_jit_context_get_int_type}@anchor{67}\n @deffn {C Function} gcc_jit_type *           gcc_jit_context_get_int_type (gcc_jit_context@w{ }*ctxt, int@w{ }num_bytes, int@w{ }is_signed)\n \n Access the integer type of the given size.\n @end deffn\n \n @node Pointers const and volatile,Structures and unions,Standard types,Types\n-@anchor{topics/types pointers-const-and-volatile}@anchor{67}\n+@anchor{topics/types pointers-const-and-volatile}@anchor{68}\n @subsection Pointers, @cite{const}, and @cite{volatile}\n \n \n @geindex gcc_jit_type_get_pointer (C function)\n-@anchor{topics/types gcc_jit_type_get_pointer}@anchor{63}\n+@anchor{topics/types gcc_jit_type_get_pointer}@anchor{64}\n @deffn {C Function} gcc_jit_type *gcc_jit_type_get_pointer (gcc_jit_type@w{ }*type)\n \n Given type \"T\", get type \"T*\".\n @end deffn\n \n @geindex gcc_jit_type_get_const (C function)\n-@anchor{topics/types gcc_jit_type_get_const}@anchor{64}\n+@anchor{topics/types gcc_jit_type_get_const}@anchor{65}\n @deffn {C Function} gcc_jit_type *gcc_jit_type_get_const (gcc_jit_type@w{ }*type)\n \n Given type \"T\", get type \"const T\".\n @end deffn\n \n @geindex gcc_jit_type_get_volatile (C function)\n-@anchor{topics/types gcc_jit_type_get_volatile}@anchor{68}\n+@anchor{topics/types gcc_jit_type_get_volatile}@anchor{69}\n @deffn {C Function} gcc_jit_type *gcc_jit_type_get_volatile (gcc_jit_type@w{ }*type)\n \n Given type \"T\", get type \"volatile T\".\n @end deffn\n \n @geindex gcc_jit_context_new_array_type (C function)\n-@anchor{topics/types gcc_jit_context_new_array_type}@anchor{69}\n+@anchor{topics/types gcc_jit_context_new_array_type}@anchor{6a}\n @deffn {C Function} gcc_jit_type *            gcc_jit_context_new_array_type (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*element_type, int@w{ }num_elements)\n \n Given type \"T\", get type \"T[N]\" (for a constant N).\n @end deffn\n \n @node Structures and unions,,Pointers const and volatile,Types\n-@anchor{topics/types structures-and-unions}@anchor{6a}\n+@anchor{topics/types structures-and-unions}@anchor{6b}\n @subsection Structures and unions\n \n \n @geindex gcc_jit_struct (C type)\n-@anchor{topics/types gcc_jit_struct}@anchor{6b}\n+@anchor{topics/types gcc_jit_struct}@anchor{6c}\n @deffn {C Type} gcc_jit_struct\n @end deffn\n \n A compound type analagous to a C @cite{struct}.\n \n @geindex gcc_jit_field (C type)\n-@anchor{topics/types gcc_jit_field}@anchor{6c}\n+@anchor{topics/types gcc_jit_field}@anchor{6d}\n @deffn {C Type} gcc_jit_field\n @end deffn\n \n-A field within a @pxref{6b,,gcc_jit_struct}.\n+A field within a @pxref{6c,,gcc_jit_struct}.\n \n-You can model C @cite{struct} types by creating @pxref{6b,,gcc_jit_struct *} and\n-@pxref{6c,,gcc_jit_field} instances, in either order:\n+You can model C @cite{struct} types by creating @pxref{6c,,gcc_jit_struct *} and\n+@pxref{6d,,gcc_jit_field} instances, in either order:\n \n \n @itemize *\n@@ -4540,21 +4747,21 @@ gcc_jit_struct_set_fields (node, NULL, 2, fields);\n @end itemize\n \n @geindex gcc_jit_context_new_field (C function)\n-@anchor{topics/types gcc_jit_context_new_field}@anchor{6d}\n+@anchor{topics/types gcc_jit_context_new_field}@anchor{6e}\n @deffn {C Function} gcc_jit_field *           gcc_jit_context_new_field (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n \n Construct a new field, with the given type and name.\n @end deffn\n \n @geindex gcc_jit_field_as_object (C function)\n-@anchor{topics/types gcc_jit_field_as_object}@anchor{6e}\n+@anchor{topics/types gcc_jit_field_as_object}@anchor{6f}\n @deffn {C Function} gcc_jit_object *           gcc_jit_field_as_object (gcc_jit_field@w{ }*field)\n \n Upcast from field to object.\n @end deffn\n \n @geindex gcc_jit_context_new_struct_type (C function)\n-@anchor{topics/types gcc_jit_context_new_struct_type}@anchor{6f}\n+@anchor{topics/types gcc_jit_context_new_struct_type}@anchor{70}\n @deffn {C Function} gcc_jit_struct *gcc_jit_context_new_struct_type (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, const char@w{ }*name, int@w{ }num_fields, gcc_jit_field@w{ }**fields)\n \n @quotation\n@@ -4564,24 +4771,24 @@ Construct a new struct type, with the given name and fields.\n @end deffn\n \n @geindex gcc_jit_context_new_opaque_struct (C function)\n-@anchor{topics/types gcc_jit_context_new_opaque_struct}@anchor{70}\n+@anchor{topics/types gcc_jit_context_new_opaque_struct}@anchor{71}\n @deffn {C Function} gcc_jit_struct *         gcc_jit_context_new_opaque_struct (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, const char@w{ }*name)\n \n Construct a new struct type, with the given name, but without\n specifying the fields.   The fields can be omitted (in which case the\n size of the struct is not known), or later specified using\n-@pxref{71,,gcc_jit_struct_set_fields()}.\n+@pxref{72,,gcc_jit_struct_set_fields()}.\n @end deffn\n \n @geindex gcc_jit_struct_as_type (C function)\n-@anchor{topics/types gcc_jit_struct_as_type}@anchor{72}\n+@anchor{topics/types gcc_jit_struct_as_type}@anchor{73}\n @deffn {C Function} gcc_jit_type *           gcc_jit_struct_as_type (gcc_jit_struct@w{ }*struct_type)\n \n Upcast from struct to type.\n @end deffn\n \n @geindex gcc_jit_struct_set_fields (C function)\n-@anchor{topics/types gcc_jit_struct_set_fields}@anchor{71}\n+@anchor{topics/types gcc_jit_struct_set_fields}@anchor{72}\n @deffn {C Function} void           gcc_jit_struct_set_fields (gcc_jit_struct@w{ }*struct_type, gcc_jit_location@w{ }*loc, int@w{ }num_fields, gcc_jit_field@w{ }**fields)\n \n Populate the fields of a formerly-opaque struct type.\n@@ -4607,7 +4814,7 @@ This can only be called once on a given struct type.\n @c <http://www.gnu.org/licenses/>.\n \n @node Expressions,Creating and using functions,Types,Topic Reference\n-@anchor{topics/expressions expressions}@anchor{73}@anchor{topics/expressions doc}@anchor{74}\n+@anchor{topics/expressions expressions}@anchor{74}@anchor{topics/expressions doc}@anchor{75}\n @section Expressions\n \n \n@@ -4633,7 +4840,7 @@ Lvalues\n \n \n @node Rvalues,Lvalues,,Expressions\n-@anchor{topics/expressions rvalues}@anchor{75}\n+@anchor{topics/expressions rvalues}@anchor{76}\n @subsection Rvalues\n \n \n@@ -4687,7 +4894,7 @@ Every rvalue has an associated type, and the API will check to ensure\n that types match up correctly (otherwise the context will emit an error).\n \n @geindex gcc_jit_rvalue_get_type (C function)\n-@anchor{topics/expressions gcc_jit_rvalue_get_type}@anchor{76}\n+@anchor{topics/expressions gcc_jit_rvalue_get_type}@anchor{77}\n @deffn {C Function} gcc_jit_type *gcc_jit_rvalue_get_type (gcc_jit_rvalue@w{ }*rvalue)\n \n Get the type of this rvalue.\n@@ -4711,7 +4918,7 @@ Upcast the given rvalue to be an object.\n @end menu\n \n @node Simple expressions,Unary Operations,,Rvalues\n-@anchor{topics/expressions simple-expressions}@anchor{77}\n+@anchor{topics/expressions simple-expressions}@anchor{78}\n @subsubsection Simple expressions\n \n \n@@ -4760,14 +4967,14 @@ the given constant value.\n @end deffn\n \n @geindex gcc_jit_context_new_rvalue_from_ptr (C function)\n-@anchor{topics/expressions gcc_jit_context_new_rvalue_from_ptr}@anchor{78}\n+@anchor{topics/expressions gcc_jit_context_new_rvalue_from_ptr}@anchor{79}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_rvalue_from_ptr (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*pointer_type, void@w{ }*value)\n \n Given a pointer type, build an rvalue for the given address.\n @end deffn\n \n @geindex gcc_jit_context_null (C function)\n-@anchor{topics/expressions gcc_jit_context_null}@anchor{79}\n+@anchor{topics/expressions gcc_jit_context_null}@anchor{7a}\n @deffn {C Function} gcc_jit_rvalue *gcc_jit_context_null (gcc_jit_context@w{ }*ctxt, gcc_jit_type@w{ }*pointer_type)\n \n Given a pointer type, build an rvalue for @code{NULL}.  Essentially this\n@@ -4781,27 +4988,27 @@ gcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL)\n @end deffn\n \n @geindex gcc_jit_context_new_string_literal (C function)\n-@anchor{topics/expressions gcc_jit_context_new_string_literal}@anchor{7a}\n+@anchor{topics/expressions gcc_jit_context_new_string_literal}@anchor{7b}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_string_literal (gcc_jit_context@w{ }*ctxt, const char@w{ }*value)\n \n Generate an rvalue for the given NIL-terminated string, of type\n @code{GCC_JIT_TYPE_CONST_CHAR_PTR}.\n @end deffn\n \n @node Unary Operations,Binary Operations,Simple expressions,Rvalues\n-@anchor{topics/expressions unary-operations}@anchor{7b}\n+@anchor{topics/expressions unary-operations}@anchor{7c}\n @subsubsection Unary Operations\n \n \n @geindex gcc_jit_context_new_unary_op (C function)\n-@anchor{topics/expressions gcc_jit_context_new_unary_op}@anchor{7c}\n+@anchor{topics/expressions gcc_jit_context_new_unary_op}@anchor{7d}\n @deffn {C Function} gcc_jit_rvalue *            gcc_jit_context_new_unary_op (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, enum gcc_jit_unary_op@w{ }op, gcc_jit_type@w{ }*result_type, gcc_jit_rvalue@w{ }*rvalue)\n \n Build a unary operation out of an input rvalue.\n @end deffn\n \n @geindex gcc_jit_unary_op (C type)\n-@anchor{topics/expressions gcc_jit_unary_op}@anchor{7d}\n+@anchor{topics/expressions gcc_jit_unary_op}@anchor{7e}\n @deffn {C Type} enum gcc_jit_unary_op\n @end deffn\n \n@@ -4819,23 +5026,23 @@ C equivalent\n \n @item\n \n-@pxref{7e,,GCC_JIT_UNARY_OP_MINUS}\n+@pxref{7f,,GCC_JIT_UNARY_OP_MINUS}\n \n @tab\n \n @cite{-(EXPR)}\n \n @item\n \n-@pxref{7f,,GCC_JIT_UNARY_OP_BITWISE_NEGATE}\n+@pxref{80,,GCC_JIT_UNARY_OP_BITWISE_NEGATE}\n \n @tab\n \n @cite{~(EXPR)}\n \n @item\n \n-@pxref{80,,GCC_JIT_UNARY_OP_LOGICAL_NEGATE}\n+@pxref{81,,GCC_JIT_UNARY_OP_LOGICAL_NEGATE}\n \n @tab\n \n@@ -4845,7 +5052,7 @@ C equivalent\n \n \n @geindex GCC_JIT_UNARY_OP_MINUS (C macro)\n-@anchor{topics/expressions GCC_JIT_UNARY_OP_MINUS}@anchor{7e}\n+@anchor{topics/expressions GCC_JIT_UNARY_OP_MINUS}@anchor{7f}\n @deffn {C Macro} GCC_JIT_UNARY_OP_MINUS\n \n Negate an arithmetic value; analogous to:\n@@ -4860,7 +5067,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_UNARY_OP_BITWISE_NEGATE (C macro)\n-@anchor{topics/expressions GCC_JIT_UNARY_OP_BITWISE_NEGATE}@anchor{7f}\n+@anchor{topics/expressions GCC_JIT_UNARY_OP_BITWISE_NEGATE}@anchor{80}\n @deffn {C Macro} GCC_JIT_UNARY_OP_BITWISE_NEGATE\n \n Bitwise negation of an integer value (one's complement); analogous\n@@ -4876,7 +5083,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_UNARY_OP_LOGICAL_NEGATE (C macro)\n-@anchor{topics/expressions GCC_JIT_UNARY_OP_LOGICAL_NEGATE}@anchor{80}\n+@anchor{topics/expressions GCC_JIT_UNARY_OP_LOGICAL_NEGATE}@anchor{81}\n @deffn {C Macro} GCC_JIT_UNARY_OP_LOGICAL_NEGATE\n \n Logical negation of an arithmetic or pointer value; analogous to:\n@@ -4891,7 +5098,7 @@ in C.\n @end deffn\n \n @node Binary Operations,Comparisons,Unary Operations,Rvalues\n-@anchor{topics/expressions binary-operations}@anchor{81}\n+@anchor{topics/expressions binary-operations}@anchor{82}\n @subsubsection Binary Operations\n \n \n@@ -4903,7 +5110,7 @@ Build a binary operation out of two constituent rvalues.\n @end deffn\n \n @geindex gcc_jit_binary_op (C type)\n-@anchor{topics/expressions gcc_jit_binary_op}@anchor{82}\n+@anchor{topics/expressions gcc_jit_binary_op}@anchor{83}\n @deffn {C Type} enum gcc_jit_binary_op\n @end deffn\n \n@@ -4921,7 +5128,7 @@ C equivalent\n \n @item\n \n-@pxref{83,,GCC_JIT_BINARY_OP_PLUS}\n+@pxref{84,,GCC_JIT_BINARY_OP_PLUS}\n \n @tab\n \n@@ -4937,79 +5144,79 @@ C equivalent\n \n @item\n \n-@pxref{84,,GCC_JIT_BINARY_OP_MULT}\n+@pxref{85,,GCC_JIT_BINARY_OP_MULT}\n \n @tab\n \n @cite{x * y}\n \n @item\n \n-@pxref{85,,GCC_JIT_BINARY_OP_DIVIDE}\n+@pxref{86,,GCC_JIT_BINARY_OP_DIVIDE}\n \n @tab\n \n @cite{x / y}\n \n @item\n \n-@pxref{86,,GCC_JIT_BINARY_OP_MODULO}\n+@pxref{87,,GCC_JIT_BINARY_OP_MODULO}\n \n @tab\n \n @cite{x % y}\n \n @item\n \n-@pxref{87,,GCC_JIT_BINARY_OP_BITWISE_AND}\n+@pxref{88,,GCC_JIT_BINARY_OP_BITWISE_AND}\n \n @tab\n \n @cite{x & y}\n \n @item\n \n-@pxref{88,,GCC_JIT_BINARY_OP_BITWISE_XOR}\n+@pxref{89,,GCC_JIT_BINARY_OP_BITWISE_XOR}\n \n @tab\n \n @cite{x ^ y}\n \n @item\n \n-@pxref{89,,GCC_JIT_BINARY_OP_BITWISE_OR}\n+@pxref{8a,,GCC_JIT_BINARY_OP_BITWISE_OR}\n \n @tab\n \n @cite{x | y}\n \n @item\n \n-@pxref{8a,,GCC_JIT_BINARY_OP_LOGICAL_AND}\n+@pxref{8b,,GCC_JIT_BINARY_OP_LOGICAL_AND}\n \n @tab\n \n @cite{x && y}\n \n @item\n \n-@pxref{8b,,GCC_JIT_BINARY_OP_LOGICAL_OR}\n+@pxref{8c,,GCC_JIT_BINARY_OP_LOGICAL_OR}\n \n @tab\n \n @cite{x || y}\n \n @item\n \n-@pxref{8c,,GCC_JIT_BINARY_OP_LSHIFT}\n+@pxref{8d,,GCC_JIT_BINARY_OP_LSHIFT}\n \n @tab\n \n @cite{x << y}\n \n @item\n \n-@pxref{8d,,GCC_JIT_BINARY_OP_RSHIFT}\n+@pxref{8e,,GCC_JIT_BINARY_OP_RSHIFT}\n \n @tab\n \n@@ -5019,7 +5226,7 @@ C equivalent\n \n \n @geindex GCC_JIT_BINARY_OP_PLUS (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_PLUS}@anchor{83}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_PLUS}@anchor{84}\n @deffn {C Macro} GCC_JIT_BINARY_OP_PLUS\n \n Addition of arithmetic values; analogous to:\n@@ -5032,7 +5239,7 @@ Addition of arithmetic values; analogous to:\n \n in C.\n \n-For pointer addition, use @pxref{8e,,gcc_jit_context_new_array_access()}.\n+For pointer addition, use @pxref{8f,,gcc_jit_context_new_array_access()}.\n @end deffn\n \n \n@@ -5050,7 +5257,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_MULT (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_MULT}@anchor{84}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_MULT}@anchor{85}\n @deffn {C Macro} GCC_JIT_BINARY_OP_MULT\n \n Multiplication of a pair of arithmetic values; analogous to:\n@@ -5065,7 +5272,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_DIVIDE (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_DIVIDE}@anchor{85}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_DIVIDE}@anchor{86}\n @deffn {C Macro} GCC_JIT_BINARY_OP_DIVIDE\n \n Quotient of division of arithmetic values; analogous to:\n@@ -5084,7 +5291,7 @@ a floating-point result type indicates floating-point division.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_MODULO (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_MODULO}@anchor{86}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_MODULO}@anchor{87}\n @deffn {C Macro} GCC_JIT_BINARY_OP_MODULO\n \n Remainder of division of arithmetic values; analogous to:\n@@ -5099,7 +5306,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_BITWISE_AND (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_AND}@anchor{87}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_AND}@anchor{88}\n @deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_AND\n \n Bitwise AND; analogous to:\n@@ -5114,7 +5321,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_BITWISE_XOR (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_XOR}@anchor{88}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_XOR}@anchor{89}\n @deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_XOR\n \n Bitwise exclusive OR; analogous to:\n@@ -5129,7 +5336,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_BITWISE_OR (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_OR}@anchor{89}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_BITWISE_OR}@anchor{8a}\n @deffn {C Macro} GCC_JIT_BINARY_OP_BITWISE_OR\n \n Bitwise inclusive OR; analogous to:\n@@ -5144,7 +5351,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_LOGICAL_AND (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_AND}@anchor{8a}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_AND}@anchor{8b}\n @deffn {C Macro} GCC_JIT_BINARY_OP_LOGICAL_AND\n \n Logical AND; analogous to:\n@@ -5159,7 +5366,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_LOGICAL_OR (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_OR}@anchor{8b}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_LOGICAL_OR}@anchor{8c}\n @deffn {C Macro} GCC_JIT_BINARY_OP_LOGICAL_OR\n \n Logical OR; analogous to:\n@@ -5174,7 +5381,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_LSHIFT (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_LSHIFT}@anchor{8c}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_LSHIFT}@anchor{8d}\n @deffn {C Macro} GCC_JIT_BINARY_OP_LSHIFT\n \n Left shift; analogous to:\n@@ -5189,7 +5396,7 @@ in C.\n @end deffn\n \n @geindex GCC_JIT_BINARY_OP_RSHIFT (C macro)\n-@anchor{topics/expressions GCC_JIT_BINARY_OP_RSHIFT}@anchor{8d}\n+@anchor{topics/expressions GCC_JIT_BINARY_OP_RSHIFT}@anchor{8e}\n @deffn {C Macro} GCC_JIT_BINARY_OP_RSHIFT\n \n Right shift; analogous to:\n@@ -5204,7 +5411,7 @@ in C.\n @end deffn\n \n @node Comparisons,Function calls,Binary Operations,Rvalues\n-@anchor{topics/expressions comparisons}@anchor{8f}\n+@anchor{topics/expressions comparisons}@anchor{90}\n @subsubsection Comparisons\n \n \n@@ -5216,7 +5423,7 @@ Build a boolean rvalue out of the comparison of two other rvalues.\n @end deffn\n \n @geindex gcc_jit_comparison (C type)\n-@anchor{topics/expressions gcc_jit_comparison}@anchor{90}\n+@anchor{topics/expressions gcc_jit_comparison}@anchor{91}\n @deffn {C Type} enum gcc_jit_comparison\n @end deffn\n \n@@ -5282,28 +5489,28 @@ C equivalent\n \n \n @node Function calls,Type-coercion,Comparisons,Rvalues\n-@anchor{topics/expressions function-calls}@anchor{91}\n+@anchor{topics/expressions function-calls}@anchor{92}\n @subsubsection Function calls\n \n \n @geindex gcc_jit_context_new_call (C function)\n-@anchor{topics/expressions gcc_jit_context_new_call}@anchor{92}\n+@anchor{topics/expressions gcc_jit_context_new_call}@anchor{93}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_call (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_function@w{ }*func, int@w{ }numargs, gcc_jit_rvalue@w{ }**args)\n \n Given a function and the given table of argument rvalues, construct a\n call to the function, with the result as an rvalue.\n \n @cartouche\n @quotation Note \n-@pxref{92,,gcc_jit_context_new_call()} merely builds a\n+@pxref{93,,gcc_jit_context_new_call()} merely builds a\n @pxref{13,,gcc_jit_rvalue} i.e. an expression that can be evaluated,\n perhaps as part of a more complicated expression.\n The call @emph{won't} happen unless you add a statement to a function\n that evaluates the expression.\n \n For example, if you want to call a function and discard the result\n (or to call a function with @code{void} return type), use\n-@pxref{93,,gcc_jit_block_add_eval()}:\n+@pxref{94,,gcc_jit_block_add_eval()}:\n \n @example\n /* Add \"(void)printf (arg0, arg1);\".  */\n@@ -5322,12 +5529,12 @@ gcc_jit_block_add_eval (\n @end deffn\n \n @node Type-coercion,,Function calls,Rvalues\n-@anchor{topics/expressions type-coercion}@anchor{94}\n+@anchor{topics/expressions type-coercion}@anchor{95}\n @subsubsection Type-coercion\n \n \n @geindex gcc_jit_context_new_cast (C function)\n-@anchor{topics/expressions gcc_jit_context_new_cast}@anchor{95}\n+@anchor{topics/expressions gcc_jit_context_new_cast}@anchor{96}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_context_new_cast (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue, gcc_jit_type@w{ }*type)\n \n Given an rvalue of T, construct another rvalue of another type.\n@@ -5352,7 +5559,7 @@ P*  <-> Q*, for pointer types P and Q\n @end deffn\n \n @node Lvalues,Working with pointers structs and unions,Rvalues,Expressions\n-@anchor{topics/expressions lvalues}@anchor{96}\n+@anchor{topics/expressions lvalues}@anchor{97}\n @subsection Lvalues\n \n \n@@ -5366,21 +5573,21 @@ a storage area (such as a variable).  It is also usable as an rvalue,\n where the rvalue is computed by reading from the storage area.\n \n @geindex gcc_jit_lvalue_as_object (C function)\n-@anchor{topics/expressions gcc_jit_lvalue_as_object}@anchor{97}\n+@anchor{topics/expressions gcc_jit_lvalue_as_object}@anchor{98}\n @deffn {C Function} gcc_jit_object *           gcc_jit_lvalue_as_object (gcc_jit_lvalue@w{ }*lvalue)\n \n Upcast an lvalue to be an object.\n @end deffn\n \n @geindex gcc_jit_lvalue_as_rvalue (C function)\n-@anchor{topics/expressions gcc_jit_lvalue_as_rvalue}@anchor{98}\n+@anchor{topics/expressions gcc_jit_lvalue_as_rvalue}@anchor{99}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_lvalue_as_rvalue (gcc_jit_lvalue@w{ }*lvalue)\n \n Upcast an lvalue to be an rvalue.\n @end deffn\n \n @geindex gcc_jit_lvalue_get_address (C function)\n-@anchor{topics/expressions gcc_jit_lvalue_get_address}@anchor{99}\n+@anchor{topics/expressions gcc_jit_lvalue_get_address}@anchor{9a}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_lvalue_get_address (gcc_jit_lvalue@w{ }*lvalue, gcc_jit_location@w{ }*loc)\n \n Take the address of an lvalue; analogous to:\n@@ -5400,24 +5607,24 @@ in C.\n @end menu\n \n @node Global variables,,,Lvalues\n-@anchor{topics/expressions global-variables}@anchor{9a}\n+@anchor{topics/expressions global-variables}@anchor{9b}\n @subsubsection Global variables\n \n \n @geindex gcc_jit_context_new_global (C function)\n-@anchor{topics/expressions gcc_jit_context_new_global}@anchor{9b}\n+@anchor{topics/expressions gcc_jit_context_new_global}@anchor{9c}\n @deffn {C Function} gcc_jit_lvalue *           gcc_jit_context_new_global (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n \n Add a new global variable of the given type and name to the context.\n @end deffn\n \n @node Working with pointers structs and unions,,Lvalues,Expressions\n-@anchor{topics/expressions working-with-pointers-structs-and-unions}@anchor{9c}\n+@anchor{topics/expressions working-with-pointers-structs-and-unions}@anchor{9d}\n @subsection Working with pointers, structs and unions\n \n \n @geindex gcc_jit_rvalue_dereference (C function)\n-@anchor{topics/expressions gcc_jit_rvalue_dereference}@anchor{9d}\n+@anchor{topics/expressions gcc_jit_rvalue_dereference}@anchor{9e}\n @deffn {C Function} gcc_jit_lvalue *           gcc_jit_rvalue_dereference (gcc_jit_rvalue@w{ }*rvalue, gcc_jit_location@w{ }*loc)\n \n Given an rvalue of pointer type @code{T *}, dereferencing the pointer,\n@@ -5435,7 +5642,7 @@ in C.\n Field access is provided separately for both lvalues and rvalues.\n \n @geindex gcc_jit_lvalue_access_field (C function)\n-@anchor{topics/expressions gcc_jit_lvalue_access_field}@anchor{9e}\n+@anchor{topics/expressions gcc_jit_lvalue_access_field}@anchor{9f}\n @deffn {C Function} gcc_jit_lvalue *           gcc_jit_lvalue_access_field (gcc_jit_lvalue@w{ }*struct_, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n \n Given an lvalue of struct or union type, access the given field,\n@@ -5451,7 +5658,7 @@ in C.\n @end deffn\n \n @geindex gcc_jit_rvalue_access_field (C function)\n-@anchor{topics/expressions gcc_jit_rvalue_access_field}@anchor{9f}\n+@anchor{topics/expressions gcc_jit_rvalue_access_field}@anchor{a0}\n @deffn {C Function} gcc_jit_rvalue *           gcc_jit_rvalue_access_field (gcc_jit_rvalue@w{ }*struct_, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n \n Given an rvalue of struct or union type, access the given field\n@@ -5467,7 +5674,7 @@ in C.\n @end deffn\n \n @geindex gcc_jit_rvalue_dereference_field (C function)\n-@anchor{topics/expressions gcc_jit_rvalue_dereference_field}@anchor{a0}\n+@anchor{topics/expressions gcc_jit_rvalue_dereference_field}@anchor{a1}\n @deffn {C Function} gcc_jit_lvalue *           gcc_jit_rvalue_dereference_field (gcc_jit_rvalue@w{ }*ptr, gcc_jit_location@w{ }*loc, gcc_jit_field@w{ }*field)\n \n Given an rvalue of pointer type @code{T *} where T is of struct or union\n@@ -5483,7 +5690,7 @@ in C, itself equivalent to @code{(*EXPR).FIELD}.\n @end deffn\n \n @geindex gcc_jit_context_new_array_access (C function)\n-@anchor{topics/expressions gcc_jit_context_new_array_access}@anchor{8e}\n+@anchor{topics/expressions gcc_jit_context_new_array_access}@anchor{8f}\n @deffn {C Function} gcc_jit_lvalue *           gcc_jit_context_new_array_access (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*ptr, gcc_jit_rvalue@w{ }*index)\n \n Given an rvalue of pointer type @code{T *}, get at the element @cite{T} at\n@@ -5518,7 +5725,7 @@ in C (or, indeed, to @code{PTR + INDEX}).\n @c <http://www.gnu.org/licenses/>.\n \n @node Creating and using functions,Source Locations,Expressions,Topic Reference\n-@anchor{topics/functions doc}@anchor{a1}@anchor{topics/functions creating-and-using-functions}@anchor{a2}\n+@anchor{topics/functions doc}@anchor{a2}@anchor{topics/functions creating-and-using-functions}@anchor{a3}\n @section Creating and using functions\n \n \n@@ -5531,7 +5738,7 @@ in C (or, indeed, to @code{PTR + INDEX}).\n @end menu\n \n @node Params,Functions,,Creating and using functions\n-@anchor{topics/functions params}@anchor{a3}\n+@anchor{topics/functions params}@anchor{a4}\n @subsection Params\n \n \n@@ -5554,28 +5761,28 @@ Parameters are lvalues, and thus are also rvalues (and objects), so the\n following upcasts are available:\n \n @geindex gcc_jit_param_as_lvalue (C function)\n-@anchor{topics/functions gcc_jit_param_as_lvalue}@anchor{a4}\n+@anchor{topics/functions gcc_jit_param_as_lvalue}@anchor{a5}\n @deffn {C Function} gcc_jit_lvalue *            gcc_jit_param_as_lvalue (gcc_jit_param@w{ }*param)\n \n Upcasting from param to lvalue.\n @end deffn\n \n @geindex gcc_jit_param_as_rvalue (C function)\n-@anchor{topics/functions gcc_jit_param_as_rvalue}@anchor{a5}\n+@anchor{topics/functions gcc_jit_param_as_rvalue}@anchor{a6}\n @deffn {C Function} gcc_jit_rvalue *            gcc_jit_param_as_rvalue (gcc_jit_param@w{ }*param)\n \n Upcasting from param to rvalue.\n @end deffn\n \n @geindex gcc_jit_param_as_object (C function)\n-@anchor{topics/functions gcc_jit_param_as_object}@anchor{a6}\n+@anchor{topics/functions gcc_jit_param_as_object}@anchor{a7}\n @deffn {C Function} gcc_jit_object *            gcc_jit_param_as_object (gcc_jit_param@w{ }*param)\n \n Upcasting from param to object.\n @end deffn\n \n @node Functions,Blocks,Params,Creating and using functions\n-@anchor{topics/functions functions}@anchor{a7}\n+@anchor{topics/functions functions}@anchor{a8}\n @subsection Functions\n \n \n@@ -5594,7 +5801,7 @@ creating ourselves, or one that we're referencing.\n Create a gcc_jit_function with the given name and parameters.\n \n @geindex gcc_jit_function_kind (C type)\n-@anchor{topics/functions gcc_jit_function_kind}@anchor{a8}\n+@anchor{topics/functions gcc_jit_function_kind}@anchor{a9}\n @deffn {C Type} enum gcc_jit_function_kind\n @end deffn\n \n@@ -5604,23 +5811,23 @@ values:\n @quotation\n \n @geindex GCC_JIT_FUNCTION_EXPORTED (C macro)\n-@anchor{topics/functions GCC_JIT_FUNCTION_EXPORTED}@anchor{a9}\n+@anchor{topics/functions GCC_JIT_FUNCTION_EXPORTED}@anchor{aa}\n @deffn {C Macro} GCC_JIT_FUNCTION_EXPORTED\n \n Function is defined by the client code and visible\n by name outside of the JIT.\n @end deffn\n \n @geindex GCC_JIT_FUNCTION_INTERNAL (C macro)\n-@anchor{topics/functions GCC_JIT_FUNCTION_INTERNAL}@anchor{aa}\n+@anchor{topics/functions GCC_JIT_FUNCTION_INTERNAL}@anchor{ab}\n @deffn {C Macro} GCC_JIT_FUNCTION_INTERNAL\n \n Function is defined by the client code, but is invisible\n outside of the JIT.  Analogous to a \"static\" function.\n @end deffn\n \n @geindex GCC_JIT_FUNCTION_IMPORTED (C macro)\n-@anchor{topics/functions GCC_JIT_FUNCTION_IMPORTED}@anchor{ab}\n+@anchor{topics/functions GCC_JIT_FUNCTION_IMPORTED}@anchor{ac}\n @deffn {C Macro} GCC_JIT_FUNCTION_IMPORTED\n \n Function is not defined by the client code; we're merely\n@@ -5629,7 +5836,7 @@ header file.\n @end deffn\n \n @geindex GCC_JIT_FUNCTION_ALWAYS_INLINE (C macro)\n-@anchor{topics/functions GCC_JIT_FUNCTION_ALWAYS_INLINE}@anchor{ac}\n+@anchor{topics/functions GCC_JIT_FUNCTION_ALWAYS_INLINE}@anchor{ad}\n @deffn {C Macro} GCC_JIT_FUNCTION_ALWAYS_INLINE\n \n Function is only ever inlined into other functions, and is\n@@ -5646,19 +5853,19 @@ same as GCC_JIT_FUNCTION_INTERNAL.\n @end deffn\n \n @geindex gcc_jit_context_get_builtin_function (C function)\n-@anchor{topics/functions gcc_jit_context_get_builtin_function}@anchor{ad}\n+@anchor{topics/functions gcc_jit_context_get_builtin_function}@anchor{ae}\n @deffn {C Function} gcc_jit_function *gcc_jit_context_get_builtin_function (gcc_jit_context@w{ }*ctxt, const char@w{ }*name)\n @end deffn\n \n @geindex gcc_jit_function_as_object (C function)\n-@anchor{topics/functions gcc_jit_function_as_object}@anchor{ae}\n+@anchor{topics/functions gcc_jit_function_as_object}@anchor{af}\n @deffn {C Function} gcc_jit_object *           gcc_jit_function_as_object (gcc_jit_function@w{ }*func)\n \n Upcasting from function to object.\n @end deffn\n \n @geindex gcc_jit_function_get_param (C function)\n-@anchor{topics/functions gcc_jit_function_get_param}@anchor{af}\n+@anchor{topics/functions gcc_jit_function_get_param}@anchor{b0}\n @deffn {C Function} gcc_jit_param *            gcc_jit_function_get_param (gcc_jit_function@w{ }*func, int@w{ }index)\n \n Get the param of the given index (0-based).\n@@ -5680,7 +5887,7 @@ name.\n @end deffn\n \n @node Blocks,Statements,Functions,Creating and using functions\n-@anchor{topics/functions blocks}@anchor{b0}\n+@anchor{topics/functions blocks}@anchor{b1}\n @subsection Blocks\n \n \n@@ -5703,7 +5910,7 @@ one function.\n @end deffn\n \n @geindex gcc_jit_function_new_block (C function)\n-@anchor{topics/functions gcc_jit_function_new_block}@anchor{b1}\n+@anchor{topics/functions gcc_jit_function_new_block}@anchor{b2}\n @deffn {C Function} gcc_jit_block *            gcc_jit_function_new_block (gcc_jit_function@w{ }*func, const char@w{ }*name)\n \n Create a basic block of the given name.  The name may be NULL, but\n@@ -5713,26 +5920,26 @@ messages.\n @end deffn\n \n @geindex gcc_jit_block_as_object (C function)\n-@anchor{topics/functions gcc_jit_block_as_object}@anchor{b2}\n+@anchor{topics/functions gcc_jit_block_as_object}@anchor{b3}\n @deffn {C Function} gcc_jit_object *            gcc_jit_block_as_object (gcc_jit_block@w{ }*block)\n \n Upcast from block to object.\n @end deffn\n \n @geindex gcc_jit_block_get_function (C function)\n-@anchor{topics/functions gcc_jit_block_get_function}@anchor{b3}\n+@anchor{topics/functions gcc_jit_block_get_function}@anchor{b4}\n @deffn {C Function} gcc_jit_function *            gcc_jit_block_get_function (gcc_jit_block@w{ }*block)\n \n Which function is this block within?\n @end deffn\n \n @node Statements,,Blocks,Creating and using functions\n-@anchor{topics/functions statements}@anchor{b4}\n+@anchor{topics/functions statements}@anchor{b5}\n @subsection Statements\n \n \n @geindex gcc_jit_block_add_eval (C function)\n-@anchor{topics/functions gcc_jit_block_add_eval}@anchor{93}\n+@anchor{topics/functions gcc_jit_block_add_eval}@anchor{94}\n @deffn {C Function} void           gcc_jit_block_add_eval (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue)\n \n Add evaluation of an rvalue, discarding the result\n@@ -5795,12 +6002,12 @@ gcc_jit_block_add_assignment_op (\n @end deffn\n \n @geindex gcc_jit_block_add_comment (C function)\n-@anchor{topics/functions gcc_jit_block_add_comment}@anchor{3a}\n+@anchor{topics/functions gcc_jit_block_add_comment}@anchor{3b}\n @deffn {C Function} void           gcc_jit_block_add_comment (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, const char@w{ }*text)\n \n Add a no-op textual comment to the internal representation of the\n code.  It will be optimized away, but will be visible in the dumps\n-seen via @pxref{57,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}\n+seen via @pxref{58,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}\n and @pxref{1a,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE},\n and thus may be of use when debugging how your project's internal\n representation gets converted to the libgccjit IR.\n@@ -5828,7 +6035,7 @@ block, boolval, on_true, and on_false must be non-NULL.\n @end deffn\n \n @geindex gcc_jit_block_end_with_jump (C function)\n-@anchor{topics/functions gcc_jit_block_end_with_jump}@anchor{b5}\n+@anchor{topics/functions gcc_jit_block_end_with_jump}@anchor{b6}\n @deffn {C Function} void           gcc_jit_block_end_with_jump (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_block@w{ }*target)\n \n Terminate a block by adding a jump to the given target block.\n@@ -5843,7 +6050,7 @@ goto target;\n @end deffn\n \n @geindex gcc_jit_block_end_with_return (C function)\n-@anchor{topics/functions gcc_jit_block_end_with_return}@anchor{b6}\n+@anchor{topics/functions gcc_jit_block_end_with_return}@anchor{b7}\n @deffn {C Function} void           gcc_jit_block_end_with_return (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc, gcc_jit_rvalue@w{ }*rvalue)\n \n Terminate a block by adding evaluation of an rvalue, returning the value.\n@@ -5858,7 +6065,7 @@ return expression;\n @end deffn\n \n @geindex gcc_jit_block_end_with_void_return (C function)\n-@anchor{topics/functions gcc_jit_block_end_with_void_return}@anchor{b7}\n+@anchor{topics/functions gcc_jit_block_end_with_void_return}@anchor{b8}\n @deffn {C Function} void           gcc_jit_block_end_with_void_return (gcc_jit_block@w{ }*block, gcc_jit_location@w{ }*loc)\n \n Terminate a block by adding a valueless return, for use within a function\n@@ -5891,12 +6098,12 @@ return;\n @c <http://www.gnu.org/licenses/>.\n \n @node Source Locations,Compilation results,Creating and using functions,Topic Reference\n-@anchor{topics/locations source-locations}@anchor{b8}@anchor{topics/locations doc}@anchor{b9}\n+@anchor{topics/locations source-locations}@anchor{b9}@anchor{topics/locations doc}@anchor{ba}\n @section Source Locations\n \n \n @geindex gcc_jit_location (C type)\n-@anchor{topics/locations gcc_jit_location}@anchor{38}\n+@anchor{topics/locations gcc_jit_location}@anchor{39}\n @deffn {C Type} gcc_jit_location\n \n A @cite{gcc_jit_location} encapsulates a source code location, so that\n@@ -5907,9 +6114,9 @@ single-step through your language.\n @cite{gcc_jit_location} instances are optional: you can always pass NULL to\n any API entrypoint accepting one.\n \n-You can construct them using @pxref{3e,,gcc_jit_context_new_location()}.\n+You can construct them using @pxref{3f,,gcc_jit_context_new_location()}.\n \n-You need to enable @pxref{3f,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n+You need to enable @pxref{40,,GCC_JIT_BOOL_OPTION_DEBUGINFO} on the\n @pxref{8,,gcc_jit_context} for these locations to actually be usable by\n the debugger:\n \n@@ -5924,7 +6131,7 @@ gcc_jit_context_set_bool_option (\n @end deffn\n \n @geindex gcc_jit_context_new_location (C function)\n-@anchor{topics/locations gcc_jit_context_new_location}@anchor{3e}\n+@anchor{topics/locations gcc_jit_context_new_location}@anchor{3f}\n @deffn {C Function} gcc_jit_location *           gcc_jit_context_new_location (gcc_jit_context@w{ }*ctxt, const char@w{ }*filename, int@w{ }line, int@w{ }column)\n \n Create a @cite{gcc_jit_location} instance representing the given source\n@@ -5937,13 +6144,13 @@ location.\n @end menu\n \n @node Faking it,,,Source Locations\n-@anchor{topics/locations faking-it}@anchor{ba}\n+@anchor{topics/locations faking-it}@anchor{bb}\n @subsection Faking it\n \n \n If you don't have source code for your internal representation, but need\n to debug, you can generate a C-like representation of the functions in\n-your context using @pxref{4f,,gcc_jit_context_dump_to_file()}:\n+your context using @pxref{50,,gcc_jit_context_dump_to_file()}:\n \n @example\n gcc_jit_context_dump_to_file (ctxt, \"/tmp/something.c\",\n@@ -5975,7 +6182,7 @@ file, giving you @emph{something} you can step through in the debugger.\n @c <http://www.gnu.org/licenses/>.\n \n @node Compilation results,,Source Locations,Topic Reference\n-@anchor{topics/results compilation-results}@anchor{bb}@anchor{topics/results doc}@anchor{bc}\n+@anchor{topics/results compilation-results}@anchor{bc}@anchor{topics/results doc}@anchor{bd}\n @section Compilation results\n \n \n@@ -6004,7 +6211,7 @@ correct type before it can be called.\n @end deffn\n \n @geindex gcc_jit_result_release (C function)\n-@anchor{topics/results gcc_jit_result_release}@anchor{bd}\n+@anchor{topics/results gcc_jit_result_release}@anchor{37}\n @deffn {C Function} void           gcc_jit_result_release (gcc_jit_result@w{ }*result)\n \n Once we're done with the code, this unloads the built .so file.\n@@ -6283,7 +6490,6 @@ The gcc::jit::recording classes (within @code{jit-recording.c} and\n \n   /* Indentation indicates inheritance: */\n   class context;\n-  class builtins_manager; // declared within jit-builtins.h\n   class memento;\n     class string;\n     class location;"}, {"sha": "2824c96b6bb8ff880564aac539a32b3c35880f43", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -57,32 +57,35 @@ Standard types\n \n    Access a specific type.  The available types are:\n \n-   =========================================  ================================\n-   `enum gcc_jit_types` value                 Meaning\n-   =========================================  ================================\n-   :c:data:`GCC_JIT_TYPE_VOID`                C's ``void`` type.\n-   :c:data:`GCC_JIT_TYPE_VOID_PTR`            C's ``void *``.\n-   :c:data:`GCC_JIT_TYPE_BOOL`                C++'s ``bool`` type; also C99's\n-                                              ``_Bool`` type, aka ``bool`` if\n-                                              using stdbool.h.\n-   :c:data:`GCC_JIT_TYPE_CHAR`                C's ``char`` (of some signedness)\n-   :c:data:`GCC_JIT_TYPE_SIGNED_CHAR`         C's ``signed char``\n-   :c:data:`GCC_JIT_TYPE_UNSIGNED_CHAR`       C's ``unsigned char``\n-   :c:data:`GCC_JIT_TYPE_SHORT`               C's ``short`` (signed)\n-   :c:data:`GCC_JIT_TYPE_UNSIGNED_SHORT`      C's ``unsigned short``\n-   :c:data:`GCC_JIT_TYPE_INT`                 C's ``int`` (signed)\n-   :c:data:`GCC_JIT_TYPE_UNSIGNED_INT`        C's ``unsigned int``\n-   :c:data:`GCC_JIT_TYPE_LONG`                C's ``long`` (signed)\n-   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG`       C's ``unsigned long``\n-   :c:data:`GCC_JIT_TYPE_LONG_LONG`           C99's ``long long`` (signed)\n-   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG_LONG`  C99's ``unsigned long long``\n+   ==========================================  ================================\n+   `enum gcc_jit_types` value                  Meaning\n+   ==========================================  ================================\n+   :c:data:`GCC_JIT_TYPE_VOID`                 C's ``void`` type.\n+   :c:data:`GCC_JIT_TYPE_VOID_PTR`             C's ``void *``.\n+   :c:data:`GCC_JIT_TYPE_BOOL`                 C++'s ``bool`` type; also C99's\n+                                               ``_Bool`` type, aka ``bool`` if\n+                                               using stdbool.h.\n+   :c:data:`GCC_JIT_TYPE_CHAR`                 C's ``char`` (of some signedness)\n+   :c:data:`GCC_JIT_TYPE_SIGNED_CHAR`          C's ``signed char``\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_CHAR`        C's ``unsigned char``\n+   :c:data:`GCC_JIT_TYPE_SHORT`                C's ``short`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_SHORT`       C's ``unsigned short``\n+   :c:data:`GCC_JIT_TYPE_INT`                  C's ``int`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_INT`         C's ``unsigned int``\n+   :c:data:`GCC_JIT_TYPE_LONG`                 C's ``long`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG`        C's ``unsigned long``\n+   :c:data:`GCC_JIT_TYPE_LONG_LONG`            C99's ``long long`` (signed)\n+   :c:data:`GCC_JIT_TYPE_UNSIGNED_LONG_LONG`   C99's ``unsigned long long``\n    :c:data:`GCC_JIT_TYPE_FLOAT`\n    :c:data:`GCC_JIT_TYPE_DOUBLE`\n    :c:data:`GCC_JIT_TYPE_LONG_DOUBLE`\n-   :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR`      C type: ``(const char *)``\n-   :c:data:`GCC_JIT_TYPE_SIZE_T`              C's ``size_t`` type\n-   :c:data:`GCC_JIT_TYPE_FILE_PTR`            C type: ``(FILE *)``\n-   =========================================  ================================\n+   :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR`       C type: ``(const char *)``\n+   :c:data:`GCC_JIT_TYPE_SIZE_T`               C's ``size_t`` type\n+   :c:data:`GCC_JIT_TYPE_FILE_PTR`             C type: ``(FILE *)``\n+   :c:data:`GCC_JIT_TYPE_COMPLEX_FLOAT`        C99's ``_Complex float``\n+   :c:data:`GCC_JIT_TYPE_COMPLEX_DOUBLE`       C99's ``_Complex double``\n+   :c:data:`GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE`  C99's ``_Complex long double``\n+   ==========================================  ================================\n \n .. function:: gcc_jit_type *\\\n               gcc_jit_context_get_int_type (gcc_jit_context *ctxt, \\"}, {"sha": "eabf4e4d04a291153e3e17c3075b54c5b6d1d21f", "filename": "gcc/jit/jit-builtins.c", "status": "modified", "additions": 172, "deletions": 37, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.c?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -23,27 +23,30 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"tree.h\"\n #include \"target.h\"\n+#include \"stringpool.h\"\n \n #include \"jit-common.h\"\n #include \"jit-builtins.h\"\n #include \"jit-recording.h\"\n+#include \"jit-playback.h\"\n \n namespace gcc {\n \n namespace jit {\n \n-namespace recording {\n-\n const char *const prefix = \"__builtin_\";\n const size_t prefix_len = strlen (prefix);\n \n /* Create \"builtin_data\", a const table of the data within builtins.def.  */\n struct builtin_data\n {\n   const char *name;\n+  enum built_in_class fnclass;\n   enum jit_builtin_type type;\n   bool both_p;\n   bool fallback_p;\n+  enum built_in_attribute attr;\n+  bool implicit_p;\n \n   const char *get_asm_name () const\n   {\n@@ -54,8 +57,9 @@ struct builtin_data\n   }\n };\n \n-#define DEF_BUILTIN(X, NAME, C, TYPE, LT, BOTH_P, FALLBACK_P, NA, AT, IM, COND)\\\n-  {NAME, TYPE, BOTH_P, FALLBACK_P},\n+#define DEF_BUILTIN(X, NAME, CLASS, TYPE, LT, BOTH_P, FALLBACK_P, \\\n+\t\t    NONANSI_P, ATTRS, IMPLICIT, COND)\t\t  \\\n+  {NAME, CLASS, TYPE, BOTH_P, FALLBACK_P, ATTRS, IMPLICIT},\n static const struct builtin_data builtin_data[] =\n {\n #include \"builtins.def\"\n@@ -130,20 +134,21 @@ find_builtin_by_name (const char *in_name,\n \n // class builtins_manager\n \n-/* Constructor for gcc::jit::recording::builtins_manager.  */\n+/* Constructor for gcc::jit::builtins_manager.  */\n \n-builtins_manager::builtins_manager (context *ctxt)\n+builtins_manager::builtins_manager (recording::context *ctxt)\n   : m_ctxt (ctxt)\n {\n   memset (m_types, 0, sizeof (m_types));\n   memset (m_builtin_functions, 0, sizeof (m_builtin_functions));\n+  memset (m_attributes, 0, sizeof (m_attributes));\n }\n \n /* Locate a builtin function by name.\n    Create a recording::function of the appropriate type, reusing them\n    if they've already been seen.  */\n \n-function *\n+recording::function *\n builtins_manager::get_builtin_function (const char *name)\n {\n   enum built_in_function builtin_id;\n@@ -153,14 +158,24 @@ builtins_manager::get_builtin_function (const char *name)\n       return NULL;\n     }\n \n+  return get_builtin_function_by_id (builtin_id);\n+}\n+\n+/* Locate a builtin function by id.\n+   Create a recording::function of the appropriate type, reusing them\n+   if they've already been seen.  */\n+\n+recording::function *\n+builtins_manager::get_builtin_function_by_id (enum built_in_function builtin_id)\n+{\n   gcc_assert (builtin_id >= 0);\n   gcc_assert (builtin_id < END_BUILTINS);\n \n   /* Lazily build the functions, caching them so that repeated calls for\n      the same id on a context give back the same object.  */\n   if (!m_builtin_functions[builtin_id])\n     {\n-      function *fn = make_builtin_function (builtin_id);\n+      recording::function *fn = make_builtin_function (builtin_id);\n       if (fn)\n \t{\n \t  m_builtin_functions[builtin_id] = fn;\n@@ -173,23 +188,23 @@ builtins_manager::get_builtin_function (const char *name)\n \n /* Create the recording::function for a given builtin function, by ID.  */\n \n-function *\n+recording::function *\n builtins_manager::make_builtin_function (enum built_in_function builtin_id)\n {\n   const struct builtin_data& bd = builtin_data[builtin_id];\n   enum jit_builtin_type type_id = bd.type;\n-  type *t = get_type (type_id);\n+  recording::type *t = get_type (type_id);\n   if (!t)\n     return NULL;\n-  function_type *func_type = t->as_a_function_type ();\n+  recording::function_type *func_type = t->as_a_function_type ();\n   if (!func_type)\n     return NULL;\n \n-  vec<type *> param_types = func_type->get_param_types ();\n+  vec<recording::type *> param_types = func_type->get_param_types ();\n   recording::param **params = new recording::param *[param_types.length ()];\n \n   int i;\n-  type *param_type;\n+  recording::type *param_type;\n   FOR_EACH_VEC_ELT (param_types, i, param_type)\n     {\n       char buf[16];\n@@ -199,24 +214,47 @@ builtins_manager::make_builtin_function (enum built_in_function builtin_id)\n \t\t\t\t     buf);\n     }\n   const char *asm_name = bd.get_asm_name ();\n-  function *result =\n-    new function (m_ctxt,\n-\t\t  NULL,\n-\t\t  GCC_JIT_FUNCTION_IMPORTED, // FIXME\n-\t\t  func_type->get_return_type (),\n-\t\t  m_ctxt->new_string (asm_name),\n-\t\t  param_types.length (),\n-\t\t  params,\n-\t\t  func_type->is_variadic (),\n-\t\t  builtin_id);\n+  recording::function *result =\n+    new recording::function (m_ctxt,\n+\t\t\t     NULL,\n+\t\t\t     GCC_JIT_FUNCTION_IMPORTED, // FIXME\n+\t\t\t     func_type->get_return_type (),\n+\t\t\t     m_ctxt->new_string (asm_name),\n+\t\t\t     param_types.length (),\n+\t\t\t     params,\n+\t\t\t     func_type->is_variadic (),\n+\t\t\t     builtin_id);\n   delete[] params;\n+\n+  /* PR/64020 - If the client code is using builtin cos or sin,\n+     tree-ssa-math-opt.c's execute_cse_sincos_1 may attempt\n+     to optimize them to use __builtin_cexpi; for this,\n+     BUILT_IN_CEXPI needs to exist.\n+\n+     Hence query the cache for BUILT_IN_CEXPI to ensure it gets\n+     built.  */\n+  if (builtin_id == BUILT_IN_COS || builtin_id == BUILT_IN_SIN)\n+    (void)get_builtin_function_by_id (BUILT_IN_CEXPI);\n+\n+  /* builtins.c:expand_builtin_cexpi can optimize the various\n+     CEXP builtins to SINCOS builtins, and hence we may require\n+     SINCOS builtins latter.\n+\n+     Ensure the appropriate SINCOS builtin exists.  */\n+  if (builtin_id == BUILT_IN_CEXPIF)\n+    (void)get_builtin_function_by_id (BUILT_IN_SINCOSF);\n+  else if (builtin_id == BUILT_IN_CEXPI)\n+    (void)get_builtin_function_by_id (BUILT_IN_SINCOS);\n+  else if (builtin_id == BUILT_IN_CEXPIL)\n+    (void)get_builtin_function_by_id (BUILT_IN_SINCOSL);\n+\n   return result;\n }\n \n /* Get the recording::type for a given type of builtin function,\n    by ID, creating it if it doesn't already exist.  */\n \n-type *\n+recording::type *\n builtins_manager::get_type (enum jit_builtin_type type_id)\n {\n   if (!m_types[type_id])\n@@ -226,7 +264,7 @@ builtins_manager::get_type (enum jit_builtin_type type_id)\n \n /* Create the recording::type for a given type of builtin function.  */\n \n-type *\n+recording::type *\n builtins_manager::make_type (enum jit_builtin_type type_id)\n {\n   /* Use builtin-types.def to construct a switch statement, with each\n@@ -283,12 +321,15 @@ builtins_manager::make_type (enum jit_builtin_type type_id)\n #include \"builtin-types.def\"\n \n #undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n #undef DEF_FUNCTION_TYPE_1\n #undef DEF_FUNCTION_TYPE_2\n #undef DEF_FUNCTION_TYPE_3\n #undef DEF_FUNCTION_TYPE_4\n #undef DEF_FUNCTION_TYPE_5\n #undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n@@ -307,7 +348,7 @@ builtins_manager::make_type (enum jit_builtin_type type_id)\n \n    Only some types are currently supported.  */\n \n-type*\n+recording::type*\n builtins_manager::make_primitive_type (enum jit_builtin_type type_id)\n {\n   switch (type_id)\n@@ -339,9 +380,12 @@ builtins_manager::make_primitive_type (enum jit_builtin_type type_id)\n     case BT_FLOAT: return m_ctxt->get_type (GCC_JIT_TYPE_FLOAT);\n     case BT_DOUBLE: return m_ctxt->get_type (GCC_JIT_TYPE_DOUBLE);\n     case BT_LONGDOUBLE: return m_ctxt->get_type (GCC_JIT_TYPE_LONG_DOUBLE);\n-    // case BT_COMPLEX_FLOAT:\n-    // case BT_COMPLEX_DOUBLE:\n-    // case BT_COMPLEX_LONGDOUBLE:\n+    case BT_COMPLEX_FLOAT:\n+      return m_ctxt->get_type (GCC_JIT_TYPE_COMPLEX_FLOAT);\n+    case BT_COMPLEX_DOUBLE:\n+      return m_ctxt->get_type (GCC_JIT_TYPE_COMPLEX_DOUBLE);\n+    case BT_COMPLEX_LONGDOUBLE:\n+      return m_ctxt->get_type (GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE);\n     case BT_PTR: return m_ctxt->get_type (GCC_JIT_TYPE_VOID_PTR);\n     case BT_FILEPTR: return m_ctxt->get_type (GCC_JIT_TYPE_FILE_PTR);\n     // case BT_CONST:\n@@ -350,7 +394,8 @@ builtins_manager::make_primitive_type (enum jit_builtin_type type_id)\n     // case BT_PTRMODE:\n     // case BT_INT_PTR:\n     // case BT_FLOAT_PTR:\n-    // case BT_DOUBLE_PTR:\n+    case BT_DOUBLE_PTR:\n+      return m_ctxt->get_type (GCC_JIT_TYPE_DOUBLE)->get_pointer ();\n     // case BT_CONST_DOUBLE_PTR:\n     // case BT_LONGDOUBLE_PTR:\n     // case BT_PID:\n@@ -378,17 +423,17 @@ builtins_manager::make_primitive_type (enum jit_builtin_type type_id)\n /* Create the recording::function_type for a given function type\n    signature.  */\n \n-function_type *\n+recording::function_type *\n builtins_manager::make_fn_type (enum jit_builtin_type,\n \t\t\t\tenum jit_builtin_type return_type_id,\n \t\t\t\tbool is_variadic,\n \t\t\t\tint num_args, ...)\n {\n   va_list list;\n   int i;\n-  type **param_types = new type *[num_args];\n-  type *return_type = NULL;\n-  function_type *result = NULL;\n+  recording::type **param_types = new recording::type *[num_args];\n+  recording::type *return_type = NULL;\n+  recording::function_type *result = NULL;\n \n   va_start (list, num_args);\n   for (i = 0; i < num_args; ++i)\n@@ -417,14 +462,104 @@ builtins_manager::make_fn_type (enum jit_builtin_type,\n \n /* Handler for DEF_POINTER_TYPE within builtins_manager::make_type.  */\n \n-type *\n+recording::type *\n builtins_manager::make_ptr_type (enum jit_builtin_type,\n \t\t\t\t enum jit_builtin_type other_type_id)\n {\n-  type *base_type = get_type (other_type_id);\n+  recording::type *base_type = get_type (other_type_id);\n   return base_type->get_pointer ();\n }\n \n-} // namespace recording\n+/* Playback support.  */\n+\n+/* A builtins_manager is associated with a recording::context\n+   and might be reused for multiple compiles on various\n+   playback::contexts, perhaps with different options.\n+\n+   Purge any playback state.  Currently this is just the table of\n+   attributes.  */\n+\n+void\n+builtins_manager::finish_playback (void)\n+{\n+  memset (m_attributes, 0, sizeof (m_attributes));\n+}\n+\n+/* Get the enum built_in_class for BUILTIN_ID.  */\n+\n+enum built_in_class\n+builtins_manager::get_class (enum built_in_function builtin_id)\n+{\n+  return builtin_data[builtin_id].fnclass;\n+}\n+\n+/* Is BUILTIN_ID implicit?  */\n+\n+bool\n+builtins_manager::implicit_p (enum built_in_function builtin_id)\n+{\n+  return builtin_data[builtin_id].implicit_p;\n+}\n+\n+/* Get any attributes (in tree form) for the function declaration\n+   for BUILTIN_ID.\n+\n+   These are created on-demand, and cached within the m_attributes\n+   array, until finish_playback.  */\n+\n+tree\n+builtins_manager::get_attrs_tree (enum built_in_function builtin_id)\n+{\n+  enum built_in_attribute attr = builtin_data[builtin_id].attr;\n+  return get_attrs_tree (attr);\n+}\n+\n+/* As above, but for an enum built_in_attribute.  */\n+\n+tree\n+builtins_manager::get_attrs_tree (enum built_in_attribute attr)\n+{\n+  gcc_assert (attr < ATTR_LAST);\n+  if (!m_attributes [attr])\n+    m_attributes [attr] = make_attrs_tree (attr);\n+  return m_attributes [attr];\n+}\n+\n+/* Handle a cache-miss within the m_attributes array by\n+   generating the attributes for enum built_in_attribute\n+   in tree form.  */\n+\n+tree\n+builtins_manager::make_attrs_tree (enum built_in_attribute attr)\n+{\n+  switch (attr)\n+    {\n+      /* Generate cases from builtin-attrs.def.  */\n+#define DEF_ATTR_NULL_TREE(ENUM)\t\t\t\t\\\n+      case ENUM: return NULL_TREE;\n+#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n+      case ENUM: return build_int_cst (integer_type_node, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n+      case ENUM: return build_string (strlen (VALUE), VALUE);\n+#define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n+      case ENUM: return get_identifier (STRING);\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n+      case ENUM: return tree_cons (get_attrs_tree (PURPOSE),\t\\\n+\t\t\t\t   get_attrs_tree (VALUE),\t\\\n+\t\t\t\t   get_attrs_tree (CHAIN));\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+\n+    default:\n+      /* We somehow got a value not covered by the autogenerated\n+\t cases.  */\n+      gcc_unreachable ();\n+      return NULL;\n+    }\n+}\n+\n } // namespace jit\n } // namespace gcc"}, {"sha": "abc204d9992c315b48ca6198b680c162d9565b70", "filename": "gcc/jit/jit-builtins.h", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-builtins.h?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -26,8 +26,6 @@ namespace gcc {\n \n namespace jit {\n \n-namespace recording {\n-\n /* Create an enum of the builtin types.  */\n \n enum jit_builtin_type\n@@ -71,43 +69,91 @@ enum jit_builtin_type\n   BT_LAST\n }; /* enum jit_builtin_type */\n \n+/* Create an enum of the attributes that can be present on builtins.  */\n+\n+enum built_in_attribute\n+{\n+#define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n+#define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n+#define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n+#include \"builtin-attrs.def\"\n+#undef DEF_ATTR_NULL_TREE\n+#undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n+#undef DEF_ATTR_IDENT\n+#undef DEF_ATTR_TREE_LIST\n+  ATTR_LAST\n+};\n+\n /***********************************************************************/\n \n class builtins_manager\n {\n public:\n-  builtins_manager (context *ctxt);\n+  builtins_manager (recording::context *ctxt);\n \n-  function *\n+  recording::function *\n   get_builtin_function (const char *name);\n \n+  static enum built_in_class\n+  get_class (enum built_in_function builtin_id);\n+\n+  static bool\n+  implicit_p (enum built_in_function builtin_id);\n+\n+  tree\n+  get_attrs_tree (enum built_in_function builtin_id);\n+\n+  tree\n+  get_attrs_tree (enum built_in_attribute attr);\n+\n+  void\n+  finish_playback (void);\n+\n private:\n-  function *make_builtin_function (enum built_in_function builtin_id);\n+  recording::function *\n+  get_builtin_function_by_id (enum built_in_function builtin_id);\n+\n+  recording::function *\n+  make_builtin_function (enum built_in_function builtin_id);\n \n-  type *get_type (enum jit_builtin_type type_id);\n+  recording::type *\n+  get_type (enum jit_builtin_type type_id);\n \n-  type *make_type (enum jit_builtin_type type_id);\n+  recording::type *\n+  make_type (enum jit_builtin_type type_id);\n \n-  type*\n+  recording::type*\n   make_primitive_type (enum jit_builtin_type type_id);\n \n-  function_type*\n+  recording::function_type*\n   make_fn_type (enum jit_builtin_type type_id,\n \t\tenum jit_builtin_type return_type_id,\n \t\tbool is_variadic,\n \t\tint num_args, ...);\n \n-  type*\n+  recording::type*\n   make_ptr_type (enum jit_builtin_type type_id,\n \t\t enum jit_builtin_type other_type_id);\n \n+  tree\n+  make_attrs_tree (enum built_in_attribute attr);\n+\n private:\n-  context *m_ctxt;\n-  type *m_types[BT_LAST];\n-  function *m_builtin_functions[END_BUILTINS];\n+  /* Recording fields.  */\n+  recording::context *m_ctxt;\n+  recording::type *m_types[BT_LAST];\n+  recording::function *m_builtin_functions[END_BUILTINS];\n+\n+  /* Playback fields.  */\n+  /* m_attributes is not GTY-marked, but is only ever used from within\n+     the region of playback::context::replay () in which a GC can't\n+     happen.  */\n+  tree m_attributes[ATTR_LAST];\n };\n \n-} // namespace recording\n } // namespace jit\n } // namespace gcc\n "}, {"sha": "c9dde3e63e2cc0fb91bfdbe53272202993247d05", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n #endif\n \n-const int NUM_GCC_JIT_TYPES = GCC_JIT_TYPE_FILE_PTR + 1;\n+const int NUM_GCC_JIT_TYPES = GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE + 1;\n \n /* This comment is included by the docs.\n \n@@ -97,14 +97,14 @@ namespace jit {\n \n class result;\n class dump;\n+class builtins_manager; // declared within jit-builtins.h\n \n namespace recording {\n \n   /* Recording types.  */\n \n   /* Indentation indicates inheritance: */\n   class context;\n-  class builtins_manager; // declared within jit-builtins.h\n   class memento;\n     class string;\n     class location;"}, {"sha": "ecdae80553c754c179998ef0792259cdb3c2d3db", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -46,10 +46,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"print-tree.h\"\n #include \"gimplify.h\"\n #include \"gcc-driver-name.h\"\n+#include \"attribs.h\"\n \n #include \"jit-common.h\"\n #include \"jit-playback.h\"\n #include \"jit-result.h\"\n+#include \"jit-builtins.h\"\n \n \n /* gcc::jit::playback::context::build_cast uses the convert.h API,\n@@ -198,6 +200,13 @@ get_tree_node_for_type (enum gcc_jit_types type_)\n \n     case GCC_JIT_TYPE_FILE_PTR:\n       return fileptr_type_node;\n+\n+    case GCC_JIT_TYPE_COMPLEX_FLOAT:\n+      return complex_float_type_node;\n+    case GCC_JIT_TYPE_COMPLEX_DOUBLE:\n+      return complex_double_type_node;\n+    case GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE:\n+      return complex_long_double_type_node;\n     }\n \n   return NULL;\n@@ -399,10 +408,21 @@ new_function (location *loc,\n \n   if (builtin_id)\n     {\n-      DECL_BUILT_IN_CLASS (fndecl) = BUILT_IN_NORMAL;\n       DECL_FUNCTION_CODE (fndecl) = builtin_id;\n       gcc_assert (loc == NULL);\n       DECL_SOURCE_LOCATION (fndecl) = BUILTINS_LOCATION;\n+\n+      DECL_BUILT_IN_CLASS (fndecl) =\n+\tbuiltins_manager::get_class (builtin_id);\n+      set_builtin_decl (builtin_id, fndecl,\n+\t\t\tbuiltins_manager::implicit_p (builtin_id));\n+\n+      builtins_manager *bm = get_builtins_manager ();\n+      tree attrs = bm->get_attrs_tree (builtin_id);\n+      if (attrs)\n+\tdecl_attributes (&fndecl, attrs, ATTR_FLAG_BUILT_IN);\n+      else\n+\tdecl_attributes (&fndecl, NULL_TREE, 0);\n     }\n \n   if (kind != GCC_JIT_FUNCTION_IMPORTED)\n@@ -1795,6 +1815,14 @@ replay ()\n      refs.  Hence we must stop using them before the GC can run.  */\n   m_recording_ctxt->disassociate_from_playback ();\n \n+  /* The builtins_manager, if any, is associated with the recording::context\n+     and might be reused for future compiles on other playback::contexts,\n+     but its m_attributes array is not GTY-labeled and hence will become\n+     nonsense if the GC runs.  Purge this state.  */\n+  builtins_manager *bm = get_builtins_manager ();\n+  if (bm)\n+    bm->finish_playback ();\n+\n   timevar_pop (TV_JIT_REPLAY);\n \n   if (!errors_occurred ())"}, {"sha": "02f08babe71297568a498abbce7c4e9028dfc167", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -175,6 +175,11 @@ class context\n     return m_recording_ctxt->get_bool_option (opt);\n   }\n \n+  builtins_manager *get_builtins_manager () const\n+  {\n+    return m_recording_ctxt->get_builtins_manager ();\n+  }\n+\n   result *\n   compile ();\n "}, {"sha": "82ec399f0b8faf81b118edd3e9f0955265264d8a", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -580,6 +580,25 @@ recording::context::new_function (recording::location *loc,\n   return result;\n }\n \n+/* Locate the builtins_manager (if any) for this family of contexts,\n+   creating it if it doesn't exist already.\n+\n+   All of the recording contexts in a family share one builtins_manager:\n+   if we have a child context, follow the parent links to get the\n+   ultimate ancestor context, and look for it/store it there.  */\n+\n+builtins_manager *\n+recording::context::get_builtins_manager ()\n+{\n+  if (m_parent_ctxt)\n+    return m_parent_ctxt->get_builtins_manager ();\n+\n+  if (!m_builtins_manager)\n+    m_builtins_manager = new builtins_manager (this);\n+\n+  return m_builtins_manager;\n+}\n+\n /* Get a recording::function instance, which is lazily-created and added\n    to the context's lists of mementos.\n \n@@ -589,9 +608,8 @@ recording::context::new_function (recording::location *loc,\n recording::function *\n recording::context::get_builtin_function (const char *name)\n {\n-  if (!m_builtins_manager)\n-    m_builtins_manager = new builtins_manager (this);\n-  return m_builtins_manager->get_builtin_function (name);\n+  builtins_manager *bm = get_builtins_manager ();\n+  return bm->get_builtin_function (name);\n }\n \n /* Create a recording::global instance and add it to this context's list\n@@ -1248,6 +1266,9 @@ recording::memento_of_get_type::dereference ()\n     case GCC_JIT_TYPE_FLOAT:\n     case GCC_JIT_TYPE_DOUBLE:\n     case GCC_JIT_TYPE_LONG_DOUBLE:\n+    case GCC_JIT_TYPE_COMPLEX_FLOAT:\n+    case GCC_JIT_TYPE_COMPLEX_DOUBLE:\n+    case GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE:\n       /* Not a pointer: */\n       return NULL;\n \n@@ -1309,6 +1330,11 @@ recording::memento_of_get_type::is_int () const\n \n     case GCC_JIT_TYPE_FILE_PTR:\n       return false;\n+\n+    case GCC_JIT_TYPE_COMPLEX_FLOAT:\n+    case GCC_JIT_TYPE_COMPLEX_DOUBLE:\n+    case GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE:\n+      return false;\n     }\n }\n \n@@ -1357,6 +1383,11 @@ recording::memento_of_get_type::is_float () const\n \n     case GCC_JIT_TYPE_FILE_PTR:\n       return false;\n+\n+    case GCC_JIT_TYPE_COMPLEX_FLOAT:\n+    case GCC_JIT_TYPE_COMPLEX_DOUBLE:\n+    case GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE:\n+      return true;\n     }\n }\n \n@@ -1405,6 +1436,11 @@ recording::memento_of_get_type::is_bool () const\n \n     case GCC_JIT_TYPE_FILE_PTR:\n       return false;\n+\n+    case GCC_JIT_TYPE_COMPLEX_FLOAT:\n+    case GCC_JIT_TYPE_COMPLEX_DOUBLE:\n+    case GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE:\n+      return false;\n     }\n }\n \n@@ -1451,7 +1487,11 @@ static const char * const get_type_strings[] = {\n \n   \"size_t\",  /* GCC_JIT_TYPE_SIZE_T */\n \n-  \"FILE *\"  /* GCC_JIT_TYPE_FILE_PTR */\n+  \"FILE *\",  /* GCC_JIT_TYPE_FILE_PTR */\n+\n+  \"complex float\", /* GCC_JIT_TYPE_COMPLEX_FLOAT */\n+  \"complex double\", /* GCC_JIT_TYPE_COMPLEX_DOUBLE */\n+  \"complex long double\"  /* GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE */\n \n };\n "}, {"sha": "31fb304b3ddb319607be42e8a6207d2c52d0e4f9", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -52,6 +52,9 @@ class context\n   context (context *parent_ctxt);\n   ~context ();\n \n+  builtins_manager *\n+  get_builtins_manager ();\n+\n   void record (memento *m);\n   void replay_into (replayer *r);\n   void disassociate_from_playback ();"}, {"sha": "ed6390e6408cad7a70c59dfb560e0f4f77ecc35f", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "patch": "@@ -382,7 +382,13 @@ enum gcc_jit_types\n   GCC_JIT_TYPE_SIZE_T,\n \n  /* C type: (FILE *)  */\n-  GCC_JIT_TYPE_FILE_PTR\n+  GCC_JIT_TYPE_FILE_PTR,\n+\n+  /* Complex numbers.  */\n+  GCC_JIT_TYPE_COMPLEX_FLOAT,\n+  GCC_JIT_TYPE_COMPLEX_DOUBLE,\n+  GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE\n+\n };\n \n extern gcc_jit_type *"}]}