{"sha": "a0df6910e34c090ba174fd705c5dc300e3141214", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkZjY5MTBlMzRjMDkwYmExNzRmZDcwNWM1ZGMzMDBlMzE0MTIxNA==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-15T22:33:30Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-15T22:33:30Z"}, "message": "m68hc11.md (\"tstqi_1\"): Try to use ldab instead of tst.\n\n\t* config/m68hc11/m68hc11.md (\"tstqi_1\"): Try to use ldab instead of tst.\n\t(\"tstqi\" split): Avoid using memory for tstqi on address register.\n\t(splits): Remove constraints.\n\t(\"cmphi_1_hc12\"): New from \"cmphi_1\" and tuned for 68HC12.\n\t(\"cmpdf\", \"cmpsf\"): Remove since not used.\n\t(\"*tbeq\", \"*tbne\", \"*tbeq8\", \"*tbne8\"): Also look in cc_status.value2.\n\t(peephole2): New peepholes to optimize tstqi and pre inc/dec addressing.\n\nFrom-SVN: r50849", "tree": {"sha": "55af93c5d9d5626aaf21b32da752c81376b9e1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55af93c5d9d5626aaf21b32da752c81376b9e1d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0df6910e34c090ba174fd705c5dc300e3141214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0df6910e34c090ba174fd705c5dc300e3141214", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0df6910e34c090ba174fd705c5dc300e3141214", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0df6910e34c090ba174fd705c5dc300e3141214/comments", "author": null, "committer": null, "parents": [{"sha": "015a2e5904023a35c76bdef9451d86878157240e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015a2e5904023a35c76bdef9451d86878157240e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015a2e5904023a35c76bdef9451d86878157240e"}], "stats": {"total": 196, "additions": 137, "deletions": 59}, "files": [{"sha": "1f10b0c936513be9f0d09b40fb1e552f7b36ff55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0df6910e34c090ba174fd705c5dc300e3141214/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0df6910e34c090ba174fd705c5dc300e3141214/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0df6910e34c090ba174fd705c5dc300e3141214", "patch": "@@ -1,3 +1,13 @@\n+2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md (\"tstqi_1\"): Try to use ldab instead of tst.\n+\t(\"tstqi\" split): Avoid using memory for tstqi on address register.\n+\t(splits): Remove constraints.\n+\t(\"cmphi_1_hc12\"): New from \"cmphi_1\" and tuned for 68HC12.\n+\t(\"cmpdf\", \"cmpsf\"): Remove since not used.\n+\t(\"*tbeq\", \"*tbne\", \"*tbeq8\", \"*tbne8\"): Also look in cc_status.value2.\n+\t(peephole2): New peepholes to optimize tstqi and pre inc/dec addressing.\n+\n 2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.md (\"negsi2\"): Optimize inline case."}, {"sha": "0d09b8cb9e6a95ab67b608522debcc91c2076c6e", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 127, "deletions": 59, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0df6910e34c090ba174fd705c5dc300e3141214/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0df6910e34c090ba174fd705c5dc300e3141214/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=a0df6910e34c090ba174fd705c5dc300e3141214", "patch": "@@ -204,27 +204,36 @@\n \n ;;\n ;; Split pattern for (tst:QI) on an address register.\n-;; The value is saved in memory and we test the low part only.\n ;;\n (define_split\n   [(set (cc0)\n-\t(match_operand:QI 0 \"hard_addr_reg_operand\" \"xy\"))]\n+\t(match_operand:QI 0 \"hard_addr_reg_operand\" \"\"))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\"\n-  [(set (match_dup 3) (match_dup 2))\n-   (set (cc0) (match_dup 4))]\n-  \"operands[2] = gen_rtx (REG, HImode, REGNO (operands[0]));\n-   operands[3] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n-   operands[4] = gen_rtx (REG, QImode, SOFT_TMP_REGNUM);\")\n+  [(parallel [(set (reg:HI D_REGNUM) (match_dup 1))\n+\t      (set (match_dup 1) (reg:HI D_REGNUM))])\n+   (set (cc0) (reg:QI D_REGNUM))\n+   (parallel [(set (reg:HI D_REGNUM) (match_dup 1))\n+\t      (set (match_dup 1) (reg:HI D_REGNUM))])]\n+  \"operands[1] = gen_rtx (REG, HImode, REGNO (operands[0]));\")\n \n (define_insn \"tstqi_1\"\n   [(set (cc0)\n \t(match_operand:QI 0 \"tst_operand\" \"m,d,*A,!u\"))]\n   \"\"\n-  \"@\n-   tst\\\\t%0\n-   tstb\n-   #\n-   tst\\\\t%b0\")\n+  \"*\n+{\n+  if (A_REG_P (operands[0]))\n+    return \\\"#\\\";\n+\n+  else if (D_REG_P (operands[0]))\n+    return \\\"tstb\\\";\n+\n+  else if (dead_register_here (insn, d_reg))\n+    return \\\"ldab\\\\t%b0\\\";\n+\n+  else\n+    return \\\"tst\\\\t%b0\\\";\n+}\")\n \n ;;\n ;; tstqi_z_used, cmpqi_z_used and cmphi_z_used are patterns generated \n@@ -247,8 +256,8 @@\n \n (define_split /* \"tstqi_z_used\" */\n   [(set (cc0)\n-\t(match_operand:QI 0 \"tst_operand\" \"m\"))\n-   (use (match_operand:HI 1 \"hard_reg_operand\" \"dxy\"))\n+\t(match_operand:QI 0 \"tst_operand\" \"\"))\n+   (use (match_operand:HI 1 \"hard_reg_operand\" \"\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 1))\n@@ -288,8 +297,8 @@\n ;;\n (define_split\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"hard_reg_operand\" \"dxy\")\n-\t\t (match_operand:HI 1 \"hard_reg_operand\" \"Aw\")))]\n+\t(compare (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t\t (match_operand:HI 1 \"hard_reg_operand\" \"\")))]\n   \"reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (cc0)\n@@ -311,13 +320,33 @@\n   DONE;\n }\")\n \n-(define_insn \"cmphi_1\"\n+(define_insn \"cmphi_1_hc12\"\n   [(set (cc0)\n \t(compare (match_operand:HI 0 \"tst_operand\" \n-\t\t\t\t\"x,dy,xyd,?xy,d,m,!u,dxy,dxy\")\n+\t\t\t\t\"d,?xy,xyd,?xy,d,m,!u,dxy,dxy\")\n \t\t (match_operand:HI 1 \"cmp_operand\"\n \t\t\t\t\"i,i,!u,m,m,dxy,dxy,?*d*A,!*w\")))]\n-  \"\"\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  if (H_REG_P (operands[1]) && !H_REG_P (operands[0]))\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      return \\\"cp%1\\\\t%0\\\";\n+    }\n+  else if (H_REG_P (operands[1]))\n+    return \\\"#\\\";\n+  else\n+    return \\\"cp%0\\\\t%1\\\";\n+}\")\n+\n+(define_insn \"cmphi_1_hc11\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"tst_operand\" \n+\t\t\t\t\"dx,y,xyd,?xy,d,m,!u,dxy,dxy\")\n+\t\t (match_operand:HI 1 \"cmp_operand\"\n+\t\t\t\t\"i,i,!u,m,m,dxy,dxy,?*d*A,!*w\")))]\n+  \"TARGET_M6811\"\n   \"*\n {\n   if (H_REG_P (operands[1]) && !H_REG_P (operands[0]))\n@@ -342,9 +371,9 @@\n   \n (define_split /* \"cmphi_z_used\" */\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"tst_operand\" \"dxy,m\")\n-\t\t (match_operand:HI 1 \"cmp_operand\" \"m,dxy\")))\n-   (use (match_operand:HI 2 \"hard_reg_operand\" \"dxy,dxy\"))\n+\t(compare (match_operand:HI 0 \"tst_operand\" \"\")\n+\t\t (match_operand:HI 1 \"cmp_operand\" \"\")))\n+   (use (match_operand:HI 2 \"hard_reg_operand\" \"\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n   [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))\n@@ -361,8 +390,8 @@\n ;;\n (define_split\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"hard_addr_reg_operand\" \"xy\")\n-\t\t (match_operand:QI 1 \"cmp_operand\" \"uimA\")))]\n+\t(compare (match_operand:QI 0 \"hard_addr_reg_operand\" \"\")\n+\t\t (match_operand:QI 1 \"cmp_operand\" \"\")))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\"\n   [(parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n               (set (match_dup 3) (reg:HI D_REGNUM))])\n@@ -374,8 +403,8 @@\n \n (define_split\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"hard_reg_operand\" \"dxy\")\n-\t\t (match_operand:QI 1 \"hard_reg_operand\" \"dxy\")))]\n+\t(compare (match_operand:QI 0 \"hard_reg_operand\" \"\")\n+\t\t (match_operand:QI 1 \"hard_reg_operand\" \"\")))]\n   \"reload_completed\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (cc0)\n@@ -413,8 +442,8 @@\n \n (define_split /* \"bitcmpqi\" */\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"tst_operand\" \"d\")\n-\t\t(match_operand:QI 1 \"hard_addr_reg_operand\" \"xy\")))]\n+\t(and:QI (match_operand:QI 0 \"tst_operand\" \"\")\n+\t\t(match_operand:QI 1 \"hard_addr_reg_operand\" \"\")))]\n   \"z_replacement_completed == 2 && GET_MODE (operands[0]) == QImode\"\n   [(set (match_dup 3) (match_dup 2))\n    (set (cc0) (and:QI (match_dup 0) (match_dup 4)))]\n@@ -433,9 +462,9 @@\n   \n (define_split /* \"bitcmpqi_z_used\" */\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"tst_operand\" \"d,m\")\n-\t\t(match_operand:QI 1 \"cmp_operand\" \"m,d\")))\n-   (use (match_operand:HI 2 \"hard_reg_operand\" \"xy,xy\"))\n+\t(and:QI (match_operand:QI 0 \"tst_operand\" \"\")\n+\t\t(match_operand:QI 1 \"cmp_operand\" \"\")))\n+   (use (match_operand:HI 2 \"hard_reg_operand\" \"\"))\n    (use (reg:HI 11))]\n   \"z_replacement_completed == 2\"\n   [(set (mem:HI (pre_dec:HI (reg:HI 3))) (match_dup 2))\n@@ -534,30 +563,6 @@\n    (set (match_dup 2) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n   \"operands[3] = gen_rtx (REG, HImode, SOFT_Z_REGNUM);\")\n \n-(define_expand \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"0\"\n-  \"\n-{\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"\")))]\n-  \"0\"\n-  \"\n-{\n-  m68hc11_compare_op0 = operands[0];\n-  m68hc11_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n ;;--------------------------------------------------------------------\n ;;-  Move strict_low_part\n ;;--------------------------------------------------------------------\n@@ -5909,7 +5914,8 @@\n       smaller and a little bit faster.  This happens quite often due\n       to reloading of operands[0].  In that case, flags are set correctly\n       due to the load instruction.  */\n-  if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+  if ((cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+      || (cc_status.value2 && rtx_equal_p (cc_status.value2, operands[0])))\n     return \\\"beq\\\\t%l1\\\";\n   else\n     return \\\"tbeq\\\\t%0,%l1\\\";\n@@ -5924,7 +5930,8 @@\n   \"TARGET_M6812\"\n   \"*\n {\n-   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+   if ((cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+       || (cc_status.value2 && rtx_equal_p (cc_status.value2, operands[0])))\n      return \\\"bne\\\\t%l1\\\";\n    else\n      return \\\"tbne\\\\t%0,%l1\\\";\n@@ -5942,7 +5949,8 @@\n   \"TARGET_M6812\"\n   \"*\n {\n-   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+   if ((cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+       || (cc_status.value2 && rtx_equal_p (cc_status.value2, operands[0])))\n      return \\\"beq\\\\t%l1\\\";\n    else\n      return \\\"tbeq\\\\tb,%l1\\\";\n@@ -5957,7 +5965,8 @@\n   \"TARGET_M6812\"\n   \"*\n {\n-   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+   if ((cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+       || (cc_status.value2 && rtx_equal_p (cc_status.value2, operands[0])))\n      return \\\"bne\\\\t%l1\\\";\n    else\n      return \\\"tbne\\\\tb,%l1\\\";\n@@ -6425,6 +6434,65 @@\n    (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n   \"\")\n \n+;;\n+;; Remove a possible move before a compare instruction when that\n+;; move will go in a dead register.  Compare with the source then.\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"hard_reg_operand\" \"\"))\n+   (set (cc0)\n+\t(compare (match_dup 0)\n+\t         (match_operand:HI 2 \"cmp_operand\" \"\")))]\n+  \"(X_REG_P (operands[1]) || Y_REG_P (operands[1]))\n+   && peep2_reg_dead_p (2, operands[0])\n+   && !reg_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0) (compare (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+;;\n+;; Optimize an address register increment and a compare to use\n+;; a PRE_INC or PRE_DEC addressing mode (disabled on the compare insn\n+;; before reload, but can be enabled after).\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (cc0)\n+\t(compare (match_operand:QI 2 \"hard_reg_operand\" \"\")\n+\t\t (match_operand:QI 3 \"memory_operand\" \"\")))]\n+  \"TARGET_AUTO_INC_DEC\n+   && (INTVAL (operands[1]) == -1 || INTVAL (operands[1]) == 1)\n+   && reg_mentioned_p (operands[0], operands[3])\"\n+  [(set (cc0) (compare (match_dup 2) (match_dup 4)))]\n+  \"if (INTVAL (operands[1]) == 1)\n+     operands[4] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+   else\n+     operands[4] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+  \")\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (cc0)\n+\t(compare (match_operand:QI 2 \"memory_operand\" \"\")\n+\t\t (match_operand:QI 3 \"hard_reg_operand\" \"\")))]\n+  \"TARGET_AUTO_INC_DEC\n+   && (INTVAL (operands[1]) == -1 || INTVAL (operands[1]) == 1)\n+   && reg_mentioned_p (operands[0], operands[2])\"\n+  [(set (cc0) (compare (match_dup 4) (match_dup 3)))]\n+  \"if (INTVAL (operands[1]) == 1)\n+     operands[4] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_INC, HImode, operands[0]));\n+   else\n+     operands[4] = gen_rtx (MEM, QImode,\n+\t\t\t    gen_rtx (PRE_DEC, HImode, operands[0]));\n+  \")\n+\n ;;\n ;; This peephole catches the address computations generated by the reload\n ;; pass. "}]}