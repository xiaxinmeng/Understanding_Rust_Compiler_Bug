{"sha": "b1079a6189a278abe0766971ea9c3c5b95dc57c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEwNzlhNjE4OWEyNzhhYmUwNzY2OTcxZWE5YzNjNWI5NWRjNTdjMQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2005-04-28T20:25:43Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-28T20:25:43Z"}, "message": "Timer.java: Reordered all fields and methods, Added more javadocs.\n\n2005-04-28  Michael Koch  <konqueror@gmx.de>\n\n\t* javax/swing/Timer.java: Reordered all fields and methods,\n\tAdded more javadocs.\n\nFrom-SVN: r98936", "tree": {"sha": "7a3623fddc9c9b28c7b634d6a6042916d56f6491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a3623fddc9c9b28c7b634d6a6042916d56f6491"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1079a6189a278abe0766971ea9c3c5b95dc57c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1079a6189a278abe0766971ea9c3c5b95dc57c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1079a6189a278abe0766971ea9c3c5b95dc57c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1079a6189a278abe0766971ea9c3c5b95dc57c1/comments", "author": null, "committer": null, "parents": [{"sha": "0ffcc9e7dd97465087bdd9d6c6ac53b414dfeb13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffcc9e7dd97465087bdd9d6c6ac53b414dfeb13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffcc9e7dd97465087bdd9d6c6ac53b414dfeb13"}], "stats": {"total": 362, "additions": 202, "deletions": 160}, "files": [{"sha": "c9bd0ca3a42b19488f5eb50b80bd2df6c1e29bfe", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1079a6189a278abe0766971ea9c3c5b95dc57c1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1079a6189a278abe0766971ea9c3c5b95dc57c1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b1079a6189a278abe0766971ea9c3c5b95dc57c1", "patch": "@@ -1,3 +1,8 @@\n+2005-04-28  Michael Koch  <konqueror@gmx.de>\n+\n+\t* javax/swing/Timer.java: Reordered all fields and methods,\n+\tAdded more javadocs.\n+\n 2005-04-28  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/Timer.java: Javadocs merged"}, {"sha": "eac5832a381be05ba24661b9485811392d48fcf0", "filename": "libjava/javax/swing/Timer.java", "status": "modified", "additions": 197, "deletions": 160, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1079a6189a278abe0766971ea9c3c5b95dc57c1/libjava%2Fjavax%2Fswing%2FTimer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1079a6189a278abe0766971ea9c3c5b95dc57c1/libjava%2Fjavax%2Fswing%2FTimer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FTimer.java?ref=b1079a6189a278abe0766971ea9c3c5b95dc57c1", "patch": "@@ -54,29 +54,58 @@\n public class Timer\n   implements Serializable\n {\n-  /** DOCUMENT ME! */\n-  private static final long serialVersionUID = -1116180831621385484L;\n-\n-  /** DOCUMENT ME! */\n-  protected EventListenerList listenerList = new EventListenerList();\n-\n-  // This object manages a \"queue\" of virtual actionEvents, maintained as a\n-  // simple long counter. When the timer expires, a new event is queued,\n-  // and a dispatcher object is pushed into the system event queue. When\n-  // the system thread runs the dispatcher, it will fire as many\n-  // ActionEvents as have been queued, unless the timer is set to\n-  // coalescing mode, in which case it will fire only one ActionEvent.\n-\n-  /** DOCUMENT ME! */\n-  private long queue;\n-\n-  /** DOCUMENT ME! */\n-  private Object queueLock = new Object();\n+  /**\n+   * The timer thread\n+   */\n+  private class Waker\n+    extends Thread\n+  {\n+    /**\n+     * Fires events, pausing for required intervals.\n+     */\n+    public void run()\n+    {\n+      running = true;\n+      try\n+        {\n+          sleep(initialDelay);\n+\n+          while (running)\n+            {\n+              try\n+                {\n+                  sleep(delay);\n+                }\n+              catch (InterruptedException e)\n+                {\n+                  return;\n+                }\n+              queueEvent();\n+\n+              if (logTimers)\n+                System.out.println(\"javax.swing.Timer -> clocktick\");\n+\n+              if ( ! repeats)\n+                break;\n+            }\n+          running = false;\n+        }\n+      catch (Exception e)\n+        {\n+        }\n+    }\n+  }\n \n-  /** DOCUMENT ME! */\n-  private Waker waker;\n+  /**\n+   * Use serialVersionUID for interoperability.\n+   */\n+  private static final long serialVersionUID = -1116180831621385484L;\n \n-  private Runnable drainer = new Runnable() \n+  /**\n+   * The encloding class, used with {@link SwingUtilities#invokeLater}\n+   * to invoke the {@link #drainEvents()}.\n+   */\n+  private Runnable drainer = new Runnable()\n     {\n       public void run()\n       {\n@@ -85,45 +114,15 @@ public void run()\n     };\n \n   /**\n-   * DOCUMENT ME!\n-   * Package-private to avoid an accessor method.\n+   * If <code>true</code>, the timer prints a message to\n+   * {@link System#out} when firing each event.\n    */\n-  private void queueEvent()\n-  {\n-    synchronized (queueLock)\n-      {\n-\tqueue++;\n-\tif (queue == 1)\n-\t  SwingUtilities.invokeLater(drainer);\n-      }\n-  }\n+  static boolean logTimers;\n \n   /**\n-   * DOCUMENT ME!\n-   * This is package-private to avoid an accessor method.\n+   * A field to store all listeners who are listening to this timer.\n    */\n-  void drainEvents()\n-  {\n-    synchronized (queueLock)\n-      {\n-\tif (isCoalesce())\n-\t  {\n-\t    if (queue > 0)\n-\t      fireActionPerformed();\n-\t  }\n-\telse\n-\t  {\n-\t    while (queue > 0)\n-\t      {\n-\t\tfireActionPerformed();\n-\t\tqueue--;\n-\t      }\n-\t  }\n-\tqueue = 0;\n-      }\n-  }\n-\n-  static boolean logTimers;\n+  protected EventListenerList listenerList = new EventListenerList();\n \n   /**\n    * <code>true</code> if the timer coalesces events.\n@@ -141,9 +140,6 @@ void drainEvents()\n    */\n   boolean running;\n \n-  /** DOCUMENT ME! */\n-  int ticks;\n-\n   /**\n    * The delay between subsequent repetetive events.\n    */\n@@ -155,46 +151,33 @@ void drainEvents()\n   int initialDelay;\n \n   /**\n-   * DOCUMENT ME!\n+   * The number of events that have been already fired by this timer.\n+   * This is used as a numeric identifier for the next event that would\n+   * be fired.\n    */\n-  private class Waker extends Thread\n-  {\n-    /**\n-     * DOCUMENT ME!\n-     */\n-    public void run()\n-    {\n-      running = true;\n-      try\n-        {\n-\t  sleep(initialDelay);\n-\n-\t  while (running)\n-\t    {\n-\t      try\n-\t        {\n-\t\t  sleep(delay);\n-\t        }\n-\t      catch (InterruptedException e)\n-\t        {\n-\t\t  return;\n-\t        }\n-\t      queueEvent();\n-\n-\t      if (logTimers)\n-\t\tSystem.out.println(\"javax.swing.Timer -> clocktick\");\n-\n-\t      if (! repeats)\n-\t\tbreak;\n-\t    }\n-\t  running = false;\n-        }\n-      catch (Exception e)\n-        {\n-//\t  System.out.println(\"swing.Timer::\" + e);\n-        }\n-    }\n-  }\n+  int ticks;\n+\n+  /**\n+   * Stores the thread that posts events to the queue at required time\n+   * intervals.\n+   */\n+  private Waker waker;\n+\n+  /**\n+   * This object manages a \"queue\" of virtual actionEvents, maintained as a\n+   * simple long counter. When the timer expires, a new event is queued,\n+   * and a dispatcher object is pushed into the system event queue. When\n+   * the system thread runs the dispatcher, it will fire as many\n+   * ActionEvents as have been queued, unless the timer is set to\n+   * coalescing mode, in which case it will fire only one ActionEvent.\n+   */\n+  private long queue;\n+\n+  /**\n+   * <code>synchronized(queueLock)</code> replaces\n+   * <code>synchronized(queue)</code> that is not supported by this language.\n+   */\n+  private Object queueLock = new Object();\n \n   /**\n    * Creates a new Timer object.\n@@ -212,43 +195,44 @@ public Timer(int d, ActionListener listener)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Get the array of action listeners.\n    *\n-   * @param c DOCUMENT ME!\n-   */\n-  public void setCoalesce(boolean c)\n-  {\n-    coalesce = c;\n-  }\n-\n-  /**\n-   * DOCUMENT ME!\n+   * @return the array of action listeners that are listening for the events,\n+   * fired by this timer\n    *\n-   * @return DOCUMENT ME!\n+   * @since 1.4\n    */\n-  public boolean isCoalesce()\n+  public ActionListener[] getActionListeners()\n   {\n-    return coalesce;\n+    return (ActionListener[]) listenerList.getListeners(ActionListener.class);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Sets whether the Timer coalesces multiple pending event firings.\n+   * If the coalescing is enabled, the multiple events that have not been\n+   * fired on time are replaced by the single event. The events may not\n+   * be fired on time if the application is busy.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @param c <code>true</code> (default) to enable the event coalescing,\n+   * <code>false</code> otherwise\n    */\n-  public void addActionListener(ActionListener listener)\n+  public void setCoalesce(boolean c)\n   {\n-    listenerList.add(ActionListener.class, listener);\n+    coalesce = c;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Checks if the Timer coalesces multiple pending event firings.\n+   * If the coalescing is enabled, the multiple events that have not been\n+   * fired on time are replaced by the single event. The events may not\n+   * be fired on time if the application is busy.\n    *\n-   * @param listener DOCUMENT ME!\n+   * @return <code>true</code> if the coalescing is enabled,\n+   * <code>false</code> otherwise\n    */\n-  public void removeActionListener(ActionListener listener)\n+  public boolean isCoalesce()\n   {\n-    listenerList.remove(ActionListener.class, listener);\n+    return coalesce;\n   }\n \n   /**\n@@ -266,39 +250,6 @@ public EventListener[] getListeners(Class listenerType)\n     return listenerList.getListeners(listenerType);\n   }\n \n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @return DOCUMENT ME!\n-   *\n-   * @since 1.4\n-   */\n-  public ActionListener[] getActionListeners()\n-  {\n-    return (ActionListener[]) listenerList.getListeners(ActionListener.class);\n-  }\n-\n-  /**\n-   * DOCUMENT ME!\n-   *\n-   * @param event DOCUMENT ME!\n-   */\n-  protected void fireActionPerformed(ActionEvent event)\n-  {\n-    ActionListener[] listeners = getActionListeners();\n-\n-    for (int i = 0; i < listeners.length; i++)\n-      listeners[i].actionPerformed(event);\n-  }\n-\n-  /**\n-   * DOCUMENT ME!\n-   */\n-  void fireActionPerformed()\n-  {\n-    fireActionPerformed(new ActionEvent(this, ticks++, \"Timer\"));\n-  }\n-\n   /**\n    * Set the timer logging state. If it is set to <code>true</code>, the\n    * timer prints a message to {@link System#out} when firing each\n@@ -408,18 +359,28 @@ public boolean isRunning()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Add the action listener\n+   *\n+   * @param listener the action listener to add\n    */\n-  public void start()\n+  public void addActionListener(ActionListener listener)\n   {\n-    if (isRunning())\n-      return;\n-    waker = new Waker();\n-    waker.start();\n+    listenerList.add(ActionListener.class, listener);\n+  }\n+\n+  /**\n+   * Remove the action listener.\n+   *\n+   * @param listener the action listener to remove\n+   */\n+  public void removeActionListener(ActionListener listener)\n+  {\n+    listenerList.remove(ActionListener.class, listener);\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Cancel all pending tasks and fire the first event after the initial\n+   * delay.\n    */\n   public void restart()\n   {\n@@ -428,7 +389,18 @@ public void restart()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Start firing the action events.\n+   */\n+  public void start()\n+  {\n+    if (isRunning())\n+      return;\n+    waker = new Waker();\n+    waker.start();\n+  }\n+\n+  /**\n+   * Stop firing the action events.\n    */\n   public void stop()\n   {\n@@ -440,4 +412,69 @@ public void stop()\n         queue = 0;\n       }\n   }\n+\n+  /**\n+   * Fire the given action event to the action listeners.\n+   *\n+   * @param event the event to fire\n+   */\n+  protected void fireActionPerformed(ActionEvent event)\n+  {\n+    ActionListener[] listeners = getActionListeners();\n+\n+    for (int i = 0; i < listeners.length; i++)\n+      listeners [ i ].actionPerformed(event);\n+  }\n+\n+  /**\n+   * Fire the action event, named \"Timer\" and having the numeric\n+   * identifier, equal to the numer of events that have been\n+   * already fired before.\n+   */\n+  void fireActionPerformed()\n+  {\n+    fireActionPerformed(new ActionEvent(this, ticks++, \"Timer\"));\n+  }\n+\n+  /**\n+   * Fire the queued action events.\n+   * In the coalescing mode, a single event is fired as a replacement\n+   * for all queued events. In non coalescing mode, a series of\n+   * all queued events is fired.\n+   * This is package-private to avoid an accessor method.\n+   */\n+  void drainEvents()\n+  {\n+    synchronized (queueLock)\n+      {\n+        if (isCoalesce())\n+          {\n+            if (queue > 0)\n+              fireActionPerformed();\n+          }\n+        else\n+          {\n+            while (queue > 0)\n+              {\n+                fireActionPerformed();\n+                queue--;\n+              }\n+          }\n+        queue = 0;\n+      }\n+  }\n+\n+  /**\n+  * Post a scheduled event to the event queue.\n+  * Package-private to avoid an accessor method.\n+  */\n+  private void queueEvent()\n+  {\n+    synchronized (queueLock)\n+      {\n+        queue++;\n+        if (queue == 1)\n+          SwingUtilities.invokeLater(drainer);\n+      }\n+  }\n }"}]}