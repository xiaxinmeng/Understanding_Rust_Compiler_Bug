{"sha": "f64edc8b7d5759c0813135cd950d58ebef968a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY0ZWRjOGI3ZDU3NTljMDgxMzEzNWNkOTUwZDU4ZWJlZjk2OGEyZg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-07-09T14:07:03Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-07-09T14:07:03Z"}, "message": "re PR fortran/40646 ([F03] array-valued procedure pointer components)\n\n2009-07-09  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40646\n\t* dump-parse-tree.c (show_expr): Renamed 'is_proc_ptr_comp'.\n\t* expr.c (is_proc_ptr_comp): Renamed to 'gfc_is_proc_ptr_comp'.\n\t(gfc_check_pointer_assign): Renamed 'is_proc_ptr_comp'.\n\t(replace_comp,gfc_expr_replace_comp): New functions, analogous\n\tto 'replace_symbol' and 'gfc_expr_replace_symbol', just with components\n\tinstead of symbols.\n\t* gfortran.h (gfc_expr_replace_comp): New prototype.\n\t(is_proc_ptr_comp): Renamed to 'gfc_is_proc_ptr_comp'.\n\t* interface.c (compare_actual_formal): Renamed 'is_proc_ptr_comp'.\n\t* match.c (gfc_match_pointer_assignment): Ditto.\n\t* primary.c (gfc_match_varspec): Handle array-valued procedure pointers\n\tand procedure pointer components. Renamed 'is_proc_ptr_comp'.\n\t* resolve.c (resolve_fl_derived): Correctly handle interfaces with\n\tRESULT statement, and handle array-valued procedure pointer components.\n\t(resolve_actual_arglist,resolve_ppc_call,resolve_expr_ppc): Renamed\n\t'is_proc_ptr_comp'.\n\t* trans-array.c (gfc_walk_function_expr): Ditto.\n\t* trans-decl.c (gfc_get_symbol_decl): Security check for presence of\n\tns->proc_name.\n\t* trans-expr.c (gfc_conv_procedure_call): Handle array-valued procedure\n\tpointer components. Renamed 'is_proc_ptr_comp'.\n\t(conv_function_val,gfc_trans_arrayfunc_assign): Renamed\n\t'is_proc_ptr_comp'.\n\t(gfc_get_proc_ptr_comp): Do not modify the argument 'e', but instead\n\tmake a copy of it.\n\t* trans-io.c (gfc_trans_transfer): Handle array-valued procedure\n\tpointer components.\n\n\n2009-07-09  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/40646\n\t* gfortran.dg/proc_ptr_22.f90: New.\n\t* gfortran.dg/proc_ptr_comp_12.f90: New.\n\nFrom-SVN: r149419", "tree": {"sha": "e889c8687de1ae1b8ea0b8141f9f5e2d63759d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e889c8687de1ae1b8ea0b8141f9f5e2d63759d31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f64edc8b7d5759c0813135cd950d58ebef968a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f64edc8b7d5759c0813135cd950d58ebef968a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f64edc8b7d5759c0813135cd950d58ebef968a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f64edc8b7d5759c0813135cd950d58ebef968a2f/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9da76de89731a1f9be1d256157dfec4cdf5d323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9da76de89731a1f9be1d256157dfec4cdf5d323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9da76de89731a1f9be1d256157dfec4cdf5d323"}], "stats": {"total": 251, "additions": 212, "deletions": 39}, "files": [{"sha": "ceabd6053ba98184021d8f5cccf60e7ba933838b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1,3 +1,34 @@\n+2009-07-09  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40646\n+\t* dump-parse-tree.c (show_expr): Renamed 'is_proc_ptr_comp'.\n+\t* expr.c (is_proc_ptr_comp): Renamed to 'gfc_is_proc_ptr_comp'.\n+\t(gfc_check_pointer_assign): Renamed 'is_proc_ptr_comp'.\n+\t(replace_comp,gfc_expr_replace_comp): New functions, analogous\n+\tto 'replace_symbol' and 'gfc_expr_replace_symbol', just with components\n+\tinstead of symbols.\n+\t* gfortran.h (gfc_expr_replace_comp): New prototype.\n+\t(is_proc_ptr_comp): Renamed to 'gfc_is_proc_ptr_comp'.\n+\t* interface.c (compare_actual_formal): Renamed 'is_proc_ptr_comp'.\n+\t* match.c (gfc_match_pointer_assignment): Ditto.\n+\t* primary.c (gfc_match_varspec): Handle array-valued procedure pointers\n+\tand procedure pointer components. Renamed 'is_proc_ptr_comp'.\n+\t* resolve.c (resolve_fl_derived): Correctly handle interfaces with\n+\tRESULT statement, and handle array-valued procedure pointer components.\n+\t(resolve_actual_arglist,resolve_ppc_call,resolve_expr_ppc): Renamed\n+\t'is_proc_ptr_comp'.\n+\t* trans-array.c (gfc_walk_function_expr): Ditto.\n+\t* trans-decl.c (gfc_get_symbol_decl): Security check for presence of\n+\tns->proc_name.\n+\t* trans-expr.c (gfc_conv_procedure_call): Handle array-valued procedure\n+\tpointer components. Renamed 'is_proc_ptr_comp'.\n+\t(conv_function_val,gfc_trans_arrayfunc_assign): Renamed\n+\t'is_proc_ptr_comp'.\n+\t(gfc_get_proc_ptr_comp): Do not modify the argument 'e', but instead\n+\tmake a copy of it.\n+\t* trans-io.c (gfc_trans_transfer): Handle array-valued procedure\n+\tpointer components.\n+\n 2009-07-09  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40604"}, {"sha": "2a411d48ad7a93ee082aabcb431fdd9dd66e3576", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -544,7 +544,7 @@ show_expr (gfc_expr *p)\n       if (p->value.function.name == NULL)\n \t{\n \t  fprintf (dumpfile, \"%s\", p->symtree->n.sym->name);\n-\t  if (is_proc_ptr_comp (p, NULL))\n+\t  if (gfc_is_proc_ptr_comp (p, NULL))\n \t    show_ref (p->ref);\n \t  fputc ('[', dumpfile);\n \t  show_actual_arglist (p->value.function.actual);\n@@ -553,7 +553,7 @@ show_expr (gfc_expr *p)\n       else\n \t{\n \t  fprintf (dumpfile, \"%s\", p->value.function.name);\n-\t  if (is_proc_ptr_comp (p, NULL))\n+\t  if (gfc_is_proc_ptr_comp (p, NULL))\n \t    show_ref (p->ref);\n \t  fputc ('[', dumpfile);\n \t  fputc ('[', dumpfile);"}, {"sha": "a8f9f6a213e82d2833ebf9a0098bcf24084a68b3", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -3213,7 +3213,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t}\n \n       /* TODO: Enable interface check for PPCs.  */\n-      if (is_proc_ptr_comp (rvalue, NULL))\n+      if (gfc_is_proc_ptr_comp (rvalue, NULL))\n \treturn SUCCESS;\n       if ((rvalue->expr_type == EXPR_VARIABLE\n \t   && !gfc_compare_interfaces (lvalue->symtree->n.sym,\n@@ -3558,7 +3558,7 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n    provided).  */\n \n bool\n-is_proc_ptr_comp (gfc_expr *expr, gfc_component **comp)\n+gfc_is_proc_ptr_comp (gfc_expr *expr, gfc_component **comp)\n {\n   gfc_ref *ref;\n   bool ppc = false;\n@@ -3672,3 +3672,39 @@ gfc_expr_replace_symbols (gfc_expr *expr, gfc_symbol *dest)\n {\n   gfc_traverse_expr (expr, dest, &replace_symbol, 0);\n }\n+\n+/* The following is analogous to 'replace_symbol', and needed for copying\n+   interfaces for procedure pointer components. The argument 'sym' must formally\n+   be a gfc_symbol, so that the function can be passed to gfc_traverse_expr.\n+   However, it gets actually passed a gfc_component (i.e. the procedure pointer\n+   component in whose formal_ns the arguments have to be).  */\n+\n+static bool\n+replace_comp (gfc_expr *expr, gfc_symbol *sym, int *i ATTRIBUTE_UNUSED)\n+{\n+  gfc_component *comp;\n+  comp = (gfc_component *)sym;\n+  if ((expr->expr_type == EXPR_VARIABLE \n+       || (expr->expr_type == EXPR_FUNCTION\n+\t   && !gfc_is_intrinsic (expr->symtree->n.sym, 0, expr->where)))\n+      && expr->symtree->n.sym->ns == comp->ts.interface->formal_ns)\n+    {\n+      gfc_symtree *stree;\n+      gfc_namespace *ns = comp->formal_ns;\n+      /* Don't use gfc_get_symtree as we prefer to fail badly if we don't find\n+\t the symtree rather than create a new one (and probably fail later).  */\n+      stree = gfc_find_symtree (ns ? ns->sym_root : gfc_current_ns->sym_root,\n+\t\t      \t\texpr->symtree->n.sym->name);\n+      gcc_assert (stree);\n+      stree->n.sym->attr = expr->symtree->n.sym->attr;\n+      expr->symtree = stree;\n+    }\n+  return false;\n+}\n+\n+void\n+gfc_expr_replace_comp (gfc_expr *expr, gfc_component *dest)\n+{\n+  gfc_traverse_expr (expr, (gfc_symbol *)dest, &replace_comp, 0);\n+}\n+"}, {"sha": "5e3f80fa82246ad2a5bb897609442c1b248a9992", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -2539,8 +2539,9 @@ bool gfc_traverse_expr (gfc_expr *, gfc_symbol *,\n void gfc_expr_set_symbols_referenced (gfc_expr *);\n gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n void gfc_expr_replace_symbols (gfc_expr *, gfc_symbol *);\n+void gfc_expr_replace_comp (gfc_expr *, gfc_component *);\n \n-bool is_proc_ptr_comp (gfc_expr *, gfc_component **);\n+bool gfc_is_proc_ptr_comp (gfc_expr *, gfc_component **);\n \n /* st.c */\n extern gfc_code new_st;"}, {"sha": "cedca457f0cb55e769c8d73547cefd53fae47219", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1915,7 +1915,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t&& a->expr->symtree->n.sym->attr.proc_pointer)\n \t       || (a->expr->expr_type == EXPR_FUNCTION\n \t\t   && a->expr->symtree->n.sym->result->attr.proc_pointer)\n-\t       || is_proc_ptr_comp (a->expr, NULL)))\n+\t       || gfc_is_proc_ptr_comp (a->expr, NULL)))\n \t{\n \t  if (where)\n \t    gfc_error (\"Expected a procedure pointer for argument '%s' at %L\",\n@@ -1925,7 +1925,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n       /* Satisfy 12.4.1.2 by ensuring that a procedure actual argument is\n \t provided for a procedure formal argument.  */\n-      if (a->expr->ts.type != BT_PROCEDURE && !is_proc_ptr_comp (a->expr, NULL)\n+      if (a->expr->ts.type != BT_PROCEDURE && !gfc_is_proc_ptr_comp (a->expr, NULL)\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && f->sym->attr.flavor == FL_PROCEDURE)\n \t{"}, {"sha": "9de4da25b7bfc0c2d3a62a073d0e3879d08c7fcd", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1337,7 +1337,7 @@ gfc_match_pointer_assignment (void)\n     }\n \n   if (lvalue->symtree->n.sym->attr.proc_pointer\n-      || is_proc_ptr_comp (lvalue, NULL))\n+      || gfc_is_proc_ptr_comp (lvalue, NULL))\n     gfc_matching_procptr_assignment = 1;\n \n   m = gfc_match (\" %e%t\", &rvalue);"}, {"sha": "4a84aedbc30b86a1379f8d2ff1381620e89f549a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1727,7 +1727,10 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   gfc_gobble_whitespace ();\n   if ((equiv_flag && gfc_peek_ascii_char () == '(')\n-      || (sym->attr.dimension && !sym->attr.proc_pointer))\n+      || (sym->attr.dimension && !sym->attr.proc_pointer\n+\t  && !gfc_is_proc_ptr_comp (primary, NULL)\n+\t  && !(gfc_matching_procptr_assignment\n+\t       && sym->attr.flavor == FL_PROCEDURE)))\n     {\n       /* In EQUIVALENCE, we don't know yet whether we are seeing\n \t an array, character variable or array of character"}, {"sha": "e3aba1a1af2278325f82e0e40670f63283a3fc91", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1236,7 +1236,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  continue;\n \t}\n \n-      if (is_proc_ptr_comp (e, &comp))\n+      if (gfc_is_proc_ptr_comp (e, &comp))\n \t{\n \t  e->ts = comp->ts;\n \t  e->expr_type = EXPR_VARIABLE;\n@@ -4834,7 +4834,7 @@ static gfc_try\n resolve_ppc_call (gfc_code* c)\n {\n   gfc_component *comp;\n-  gcc_assert (is_proc_ptr_comp (c->expr1, &comp));\n+  gcc_assert (gfc_is_proc_ptr_comp (c->expr1, &comp));\n \n   c->resolved_sym = c->expr1->symtree->n.sym;\n   c->expr1->expr_type = EXPR_VARIABLE;\n@@ -4862,7 +4862,7 @@ static gfc_try\n resolve_expr_ppc (gfc_expr* e)\n {\n   gfc_component *comp;\n-  gcc_assert (is_proc_ptr_comp (e, &comp));\n+  gcc_assert (gfc_is_proc_ptr_comp (e, &comp));\n \n   /* Convert to EXPR_FUNCTION.  */\n   e->expr_type = EXPR_FUNCTION;\n@@ -9034,32 +9034,40 @@ resolve_fl_derived (gfc_symbol *sym)\n \t\tresolve_intrinsic (ifc, &ifc->declared_at);\n \n \t      if (ifc->result)\n-\t\tc->ts = ifc->result->ts;\n-\t      else   \n-\t\tc->ts = ifc->ts;\n+\t\t{\n+\t\t  c->ts = ifc->result->ts;\n+\t\t  c->attr.allocatable = ifc->result->attr.allocatable;\n+\t\t  c->attr.pointer = ifc->result->attr.pointer;\n+\t\t  c->attr.dimension = ifc->result->attr.dimension;\n+\t\t  c->as = gfc_copy_array_spec (ifc->result->as);\n+\t\t}\n+\t      else\n+\t\t{   \n+\t\t  c->ts = ifc->ts;\n+\t\t  c->attr.allocatable = ifc->attr.allocatable;\n+\t\t  c->attr.pointer = ifc->attr.pointer;\n+\t\t  c->attr.dimension = ifc->attr.dimension;\n+\t\t  c->as = gfc_copy_array_spec (ifc->as);\n+\t\t}\n \t      c->ts.interface = ifc;\n \t      c->attr.function = ifc->attr.function;\n \t      c->attr.subroutine = ifc->attr.subroutine;\n \t      gfc_copy_formal_args_ppc (c, ifc);\n \n-\t      c->attr.allocatable = ifc->attr.allocatable;\n-\t      c->attr.pointer = ifc->attr.pointer;\n \t      c->attr.pure = ifc->attr.pure;\n \t      c->attr.elemental = ifc->attr.elemental;\n-\t      c->attr.dimension = ifc->attr.dimension;\n \t      c->attr.recursive = ifc->attr.recursive;\n \t      c->attr.always_explicit = ifc->attr.always_explicit;\n-\t      /* Copy array spec.  */\n-\t      c->as = gfc_copy_array_spec (ifc->as);\n-\t      /* TODO: if (c->as)\n+\t      /* Replace symbols in array spec.  */\n+\t      if (c->as)\n \t\t{\n \t\t  int i;\n \t\t  for (i = 0; i < c->as->rank; i++)\n \t\t    {\n-\t\t      gfc_expr_replace_symbols (c->as->lower[i], c);\n-\t\t      gfc_expr_replace_symbols (c->as->upper[i], c);\n+\t\t      gfc_expr_replace_comp (c->as->lower[i], c);\n+\t\t      gfc_expr_replace_comp (c->as->upper[i], c);\n \t\t    }\n-\t        }*/\n+\t        }\n \t      /* Copy char length.  */\n \t      if (ifc->ts.cl)\n \t\t{"}, {"sha": "32858a7abcd1fbae9a2100eb84fdb990dbde01d5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -6366,7 +6366,7 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n       sym = expr->symtree->n.sym;\n \n   /* A function that returns arrays.  */\n-  is_proc_ptr_comp (expr, &comp);\n+  gfc_is_proc_ptr_comp (expr, &comp);\n   if ((!comp && gfc_return_by_reference (sym) && sym->result->attr.dimension)\n       || (comp && comp->attr.dimension))\n     {"}, {"sha": "0d6dc6de975c28b12ade1ab379094e4447409d4d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1015,7 +1015,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t\t|| sym->attr.use_assoc\n \t\t|| sym->ns->proc_name->attr.if_source == IFSRC_IFBODY);\n \n-  if (sym->ns && sym->ns->proc_name->attr.function)\n+  if (sym->ns && sym->ns->proc_name && sym->ns->proc_name->attr.function)\n     byref = gfc_return_by_reference (sym->ns->proc_name);\n   else\n     byref = 0;"}, {"sha": "b6a825a81257218ee3affd6b5cc45e8bb584dd26", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1492,7 +1492,7 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n   tree tmp;\n \n-  if (is_proc_ptr_comp (expr, NULL))\n+  if (gfc_is_proc_ptr_comp (expr, NULL))\n     tmp = gfc_get_proc_ptr_comp (se, expr);\n   else if (sym->attr.dummy)\n     {\n@@ -2463,14 +2463,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  gfc_init_se (&fptrse, NULL);\n \t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t      || is_proc_ptr_comp (arg->next->expr, NULL))\n+\t      || gfc_is_proc_ptr_comp (arg->next->expr, NULL))\n \t    fptrse.want_pointer = 1;\n \n \t  gfc_conv_expr (&fptrse, arg->next->expr);\n \t  gfc_add_block_to_block (&se->pre, &fptrse.pre);\n \t  gfc_add_block_to_block (&se->post, &fptrse.post);\n \n-\t  if (is_proc_ptr_comp (arg->next->expr, NULL))\n+\t  if (gfc_is_proc_ptr_comp (arg->next->expr, NULL))\n \t    tmp = gfc_get_ppc_type (arg->next->expr->ref->u.c.component);\n \t  else\n \t    tmp = TREE_TYPE (arg->next->expr->symtree->n.sym->backend_decl);\n@@ -2526,16 +2526,19 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  return 0;\n \t}\n     }\n-  \n+\n+  gfc_is_proc_ptr_comp (expr, &comp);\n+\n   if (se->ss != NULL)\n     {\n       if (!sym->attr.elemental)\n \t{\n \t  gcc_assert (se->ss->type == GFC_SS_FUNCTION);\n           if (se->ss->useflags)\n             {\n-              gcc_assert (gfc_return_by_reference (sym)\n-                      && sym->result->attr.dimension);\n+\t      gcc_assert ((!comp && gfc_return_by_reference (sym)\n+\t\t\t   && sym->result->attr.dimension)\n+\t\t\t  || (comp && comp->attr.dimension));\n               gcc_assert (se->loop != NULL);\n \n               /* Access the previously obtained result.  */\n@@ -2551,7 +2554,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n   gfc_init_block (&post);\n   gfc_init_interface_mapping (&mapping);\n-  is_proc_ptr_comp (expr, &comp);\n   need_interface_mapping = ((sym->ts.type == BT_CHARACTER\n \t\t\t\t  && sym->ts.cl->length\n \t\t\t\t  && sym->ts.cl->length->expr_type\n@@ -2947,6 +2949,30 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  retargs = gfc_chainon_list (retargs, se->expr);\n \t}\n+      else if (comp && comp->attr.dimension)\n+\t{\n+\t  gcc_assert (se->loop && info);\n+\n+\t  /* Set the type of the array.  */\n+\t  tmp = gfc_typenode_for_spec (&comp->ts);\n+\t  info->dimen = se->loop->dimen;\n+\n+\t  /* Evaluate the bounds of the result, if known.  */\n+\t  gfc_set_loop_bounds_from_array_spec (&mapping, se, comp->as);\n+\n+\t  /* Create a temporary to store the result.  In case the function\n+\t     returns a pointer, the temporary will be a shallow copy and\n+\t     mustn't be deallocated.  */\n+\t  callee_alloc = comp->attr.allocatable || comp->attr.pointer;\n+\t  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop, info, tmp,\n+\t\t\t\t       NULL_TREE, false, !comp->attr.pointer,\n+\t\t\t\t       callee_alloc, &se->ss->expr->where);\n+\n+\t  /* Pass the temporary as the first argument.  */\n+\t  tmp = info->descriptor;\n+\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t  retargs = gfc_chainon_list (retargs, tmp);\n+\t}\n       else if (sym->result->attr.dimension)\n \t{\n \t  gcc_assert (se->loop && info);\n@@ -3046,7 +3072,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n         x = f()\n      where f is pointer valued, we have to dereference the result.  */\n   if (!se->want_pointer && !byref && sym->attr.pointer\n-      && !is_proc_ptr_comp (expr, NULL))\n+      && !gfc_is_proc_ptr_comp (expr, NULL))\n     se->expr = build_fold_indirect_ref (se->expr);\n \n   /* f2c calling conventions require a scalar default real function to\n@@ -3074,7 +3100,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n       if (!se->direct_byref)\n \t{\n-\t  if (sym->attr.dimension)\n+\t  if (sym->attr.dimension || (comp && comp->attr.dimension))\n \t    {\n \t      if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n \t\t{\n@@ -3431,9 +3457,11 @@ tree\n gfc_get_proc_ptr_comp (gfc_se *se, gfc_expr *e)\n {\n   gfc_se comp_se;\n+  gfc_expr *e2;\n   gfc_init_se (&comp_se, NULL);\n-  e->expr_type = EXPR_VARIABLE;\n-  gfc_conv_expr (&comp_se, e);\n+  e2 = gfc_copy_expr (e);\n+  e2->expr_type = EXPR_VARIABLE;\n+  gfc_conv_expr (&comp_se, e2);\n   comp_se.expr = build_fold_addr_expr (comp_se.expr);\n   return gfc_evaluate_now (comp_se.expr, &se->pre);  \n }\n@@ -4466,7 +4494,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic\n      functions.  */\n   gcc_assert (expr2->value.function.isym\n-\t      || (is_proc_ptr_comp (expr2, &comp)\n+\t      || (gfc_is_proc_ptr_comp (expr2, &comp)\n \t\t  && comp && comp->attr.dimension)\n \t      || (!comp && gfc_return_by_reference (expr2->value.function.esym)\n \t\t  && expr2->value.function.esym->result->attr.dimension));"}, {"sha": "5263a67b754e228ab3025bf07f7642107fa9d856", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -2165,7 +2165,7 @@ gfc_trans_transfer (gfc_code * code)\n       /* Transfer an array. If it is an array of an intrinsic\n \t type, pass the descriptor to the library.  Otherwise\n \t scalarize the transfer.  */\n-      if (expr->ref)\n+      if (expr->ref && !gfc_is_proc_ptr_comp (expr, NULL))\n \t{\n \t  for (ref = expr->ref; ref && ref->type != REF_ARRAY;\n \t\t ref = ref->next);"}, {"sha": "6dc3393175446f87e61e057e39698872830a0dce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -1,3 +1,9 @@\n+2009-07-09  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/40646\n+\t* gfortran.dg/proc_ptr_22.f90: New.\n+\t* gfortran.dg/proc_ptr_comp_12.f90: New.\n+\n 2009-07-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/40692"}, {"sha": "6dfa1f23899d1936ccdc0b7c24fb6cf0592c1c3f", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_22.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_22.f90?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+!\n+! PR 40646: [F03] array-valued procedure pointer components\n+!\n+! Original test case by Charlie Sharpsteen <chuck@sharpsteen.net>\n+! Modified by Janus Weil <janus@gcc.gnu.org>\n+\n+module bugTestMod\n+  implicit none\n+contains\n+  function returnMat( a, b ) result( mat )\n+    integer:: a, b\n+    double precision, dimension(a,b):: mat \n+    mat = 1d0\n+  end function returnMat\n+end module bugTestMod\n+\n+program bugTest\n+  use bugTestMod\n+  implicit none\n+  procedure(returnMat), pointer :: pp\n+  pp => returnMat\n+  if (sum(pp(2,2))/=4) call abort()\n+end program bugTest\n+\n+! { dg-final { cleanup-modules \"bugTestMod\" } }\n+"}, {"sha": "314bcf8253b9593e79e68d91e8d7b38fcf464f65", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_12.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f64edc8b7d5759c0813135cd950d58ebef968a2f/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_12.f90?ref=f64edc8b7d5759c0813135cd950d58ebef968a2f", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! PR 40646: [F03] array-valued procedure pointer components\n+!\n+! Original test case by Charlie Sharpsteen <chuck@sharpsteen.net>\n+! Modified by Janus Weil <janus@gcc.gnu.org>\n+\n+module bugTestMod\n+  implicit none\n+  type:: boundTest\n+    procedure(returnMat), pointer, nopass:: test\n+  end type boundTest\n+contains\n+  function returnMat( a, b ) result( mat )\n+    integer:: a, b\n+    double precision, dimension(a,b):: mat \n+    mat = 1d0\n+  end function returnMat\n+end module bugTestMod\n+\n+program bugTest\n+  use bugTestMod\n+  implicit none\n+  type( boundTest ):: testObj\n+  double precision, dimension(2,2):: testCatch\n+  testObj%test => returnMat\n+  testCatch = testObj%test(2,2)\n+  print *,testCatch\n+  if (sum(testCatch)/=4) call abort()\n+end program bugTest\n+\n+! { dg-final { cleanup-modules \"bugTestMod\" } }\n+"}]}