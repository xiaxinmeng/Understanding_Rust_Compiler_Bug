{"sha": "2df34974748c2d55cd28d5bf137f943bbdee0c71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRmMzQ5NzQ3NDhjMmQ1NWNkMjhkNWJmMTM3Zjk0M2JiZGVlMGM3MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-05T09:08:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-05T09:08:32Z"}, "message": "(convert_for_assignment): Allow conversion to union type\nfor pointer if the pointer could convert to the union member.\n\nFrom-SVN: r4634", "tree": {"sha": "201282ea3d78e55af01134045127bd79792b1d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/201282ea3d78e55af01134045127bd79792b1d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2df34974748c2d55cd28d5bf137f943bbdee0c71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df34974748c2d55cd28d5bf137f943bbdee0c71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df34974748c2d55cd28d5bf137f943bbdee0c71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df34974748c2d55cd28d5bf137f943bbdee0c71/comments", "author": null, "committer": null, "parents": [{"sha": "49ba557ea204dae80f6a847a0c9b5a276dd7d66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ba557ea204dae80f6a847a0c9b5a276dd7d66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ba557ea204dae80f6a847a0c9b5a276dd7d66e"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "d7bd4ad521d656dbeaa7728635ab3d533d106247", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2df34974748c2d55cd28d5bf137f943bbdee0c71/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2df34974748c2d55cd28d5bf137f943bbdee0c71/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2df34974748c2d55cd28d5bf137f943bbdee0c71", "patch": "@@ -4173,6 +4173,51 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\tpedwarn (\"ANSI C prohibits argument conversion to union type\");\n \t      return build1 (NOP_EXPR, type, rhs);\n \t    }\n+\t  else if (coder == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (memb_types)) == POINTER_TYPE)\n+\t    {\n+\t      tree memb_type = TREE_TYPE (memb_types);\n+\t      register tree ttl = TREE_TYPE (memb_type);\n+\t      register tree ttr = TREE_TYPE (rhstype);\n+\n+\t      /* Any non-function converts to a [const][volatile] void *\n+\t\t and vice versa; otherwise, targets must be the same.\n+\t\t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n+\t      if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n+\t\t  || TYPE_MAIN_VARIANT (ttr) == void_type_node\n+\t\t  || comp_target_types (memb_type, rhstype))\n+\t\t{\n+\t\t  /* Const and volatile mean something different for function types,\n+\t\t     so the usual warnings are not appropriate.  */\n+\t\t  if (TREE_CODE (ttr) != FUNCTION_TYPE\n+\t\t      || TREE_CODE (ttl) != FUNCTION_TYPE)\n+\t\t    {\n+\t\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t\t\twarn_for_assignment (\"%s discards `const' from pointer target type\",\n+\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t      if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t\t\twarn_for_assignment (\"%s discards `volatile' from pointer target type\",\n+\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Because const and volatile on functions are restrictions\n+\t\t\t that say the function will not do certain things,\n+\t\t\t it is okay to use a const or volatile function\n+\t\t\t where an ordinary one is wanted, but not vice-versa.  */\n+\t\t      if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n+\t\t\twarn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n+\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t      if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n+\t\t\twarn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n+\t\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t    }\n+\t\t  if (pedantic\n+\t\t      && !(fundecl != 0 && DECL_IN_SYSTEM_HEADER (fundecl)))\n+\t\t    pedwarn (\"ANSI C prohibits argument conversion to union type\");\n+\t\t  return build1 (NOP_EXPR, type, rhs);\n+\t\t}\n+\t    }\n \t}\n     }\n   /* Conversions among pointers */"}]}