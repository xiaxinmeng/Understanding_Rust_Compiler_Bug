{"sha": "d72372e46ac06b4db61143f91367a777089cc6f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcyMzcyZTQ2YWMwNmI0ZGI2MTE0M2Y5MTM2N2E3NzcwODljYzZmNg==", "commit": {"author": {"name": "Mostafa Hagog", "email": "mustafa@il.ibm.com", "date": "2004-08-08T21:35:53Z"}, "committer": {"name": "Mostafa Hagog", "email": "hagog@gcc.gnu.org", "date": "2004-08-08T21:35:53Z"}, "message": "common.opt (freschedule-modulo-scheduled-loops): New flag.\n\n2004-08-08  Mostafa Hagog  <mustafa@il.ibm.com>\n\tAyal Zaks <zaks@il.ibm.com>\n\n\t* common.opt (freschedule-modulo-scheduled-loops): New flag.\n\t* final.c (final_scan_insn): Handle NOTE_DISABLE_SCHED_OF_BLOCK.\n\t* modulo-sched.c (sms_schedule): Emit a note to disable scheduling\n\twhen -freschedule-modulo-scheduled-loops flag is not specified.\n\t(sms_schedule_by_order, ps_insn_advance_column, add_node_to_ps,\n\tadd_node_to_ps, ps_has_conflicts, ps_add_node_check_conflicts):\n\tMore accurate placing of insn in row of partial schedule.\n\t(ps_insn_find_column): New function.\n\t* rtl.h (NOTE_DISABLE_SCHED_OF_BLOCK): New note.\n\t* sched-rgn.c (sched_is_disabled_for_current_region_p): New.\n\t(schedule_region): Use sched_is_disabled_for_current_region_p.\n\t* docs/invoke.texi: Document -freschedule-modulo-scheduled-loops.\n\nCo-Authored-By: Ayal Zaks <zaks@il.ibm.com>\n\nFrom-SVN: r85696", "tree": {"sha": "d4a4dc1d2fd739eff16c75b3bbf87780df96f926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4a4dc1d2fd739eff16c75b3bbf87780df96f926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d72372e46ac06b4db61143f91367a777089cc6f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72372e46ac06b4db61143f91367a777089cc6f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72372e46ac06b4db61143f91367a777089cc6f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72372e46ac06b4db61143f91367a777089cc6f6/comments", "author": null, "committer": null, "parents": [{"sha": "94538bd12ae8ffa02164399a616ef806e77f797b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94538bd12ae8ffa02164399a616ef806e77f797b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94538bd12ae8ffa02164399a616ef806e77f797b"}], "stats": {"total": 267, "additions": 212, "deletions": 55}, "files": [{"sha": "d5efb3426e750291f15cfcc60d60bbe92062f6df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -1,3 +1,19 @@\n+2004-08-08  Mostafa Hagog  <mustafa@il.ibm.com>\n+\tAyal Zaks <zaks@il.ibm.com>\n+\n+\t* common.opt (freschedule-modulo-scheduled-loops): New flag.\n+\t* final.c (final_scan_insn): Handle NOTE_DISABLE_SCHED_OF_BLOCK.\n+\t* modulo-sched.c (sms_schedule): Emit a note to disable scheduling\n+\twhen -freschedule-modulo-scheduled-loops flag is not specified.\n+\t(sms_schedule_by_order, ps_insn_advance_column, add_node_to_ps,\n+\tadd_node_to_ps, ps_has_conflicts, ps_add_node_check_conflicts):\n+\tMore accurate placing of insn in row of partial schedule.\n+\t(ps_insn_find_column): New function.\n+\t* rtl.h (NOTE_DISABLE_SCHED_OF_BLOCK): New note.\n+\t* sched-rgn.c (sched_is_disabled_for_current_region_p): New.\n+\t(schedule_region): Use sched_is_disabled_for_current_region_p.\n+\t* docs/invoke.texi: Document -freschedule-modulo-scheduled-loops.\n+\n 2004-08-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_expand_clrmem): Revert the last"}, {"sha": "7694df121c67bb51db2002b9597c06b26a55dc00", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -543,6 +543,10 @@ fnew-ra\n Common Report Var(flag_new_regalloc)\n Use graph-coloring register allocation\n \n+freschedule-modulo-scheduled-loops\n+Common Report Var(flag_resched_modulo_sched)\n+Enable/Disable the traditional scheduling in loops that already passed modulo scheduling\n+\n fnon-call-exceptions\n Common Report Var(flag_non_call_exceptions)\n Support synchronous non-call exceptions"}, {"sha": "0018fc601837b4fbca27c449d7d21bd769278611", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -308,8 +308,8 @@ in the following sections.\n -fsched-spec-load-dangerous  @gol\n -fsched-stalled-insns=@var{n} -sched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n--fsched2-use-traces  -fsignaling-nans @gol\n--fsingle-precision-constant  @gol\n+-fsched2-use-traces -freschedule-modulo-scheduled-loops @gol\n+-fsignaling-nans -fsingle-precision-constant  @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n@@ -4393,6 +4393,12 @@ reality and hurt the performance.  This only makes\n sense when scheduling after register allocation, i.e.@: with\n @option{-fschedule-insns2} or at @option{-O2} or higher.\n \n+@item -freschedule-modulo-scheduled-loops\n+@opindex fscheduling-in-modulo-scheduled-loops\n+The modulo scheduling comes before the traditional scheduling, if a loop was modulo scheduled\n+we may want to prevent the later scheduling passes from changing its schedule, we use this\n+option to control that.\n+\n @item -fcaller-saves\n @opindex fcaller-saves\n Enable values to be allocated in registers that will be clobbered by"}, {"sha": "90311bc53716b75834a3eaae367ab599675a1765", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -1704,6 +1704,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_FUNCTION_END:\n \tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n \tcase NOTE_INSN_EXPECTED_VALUE:\n+\tcase NOTE_DISABLE_SCHED_OF_BLOCK:\n \t  break;\n \n \tcase NOTE_INSN_UNLIKELY_EXECUTED_CODE:"}, {"sha": "86e0f8c46406fbb5753570ae5d096415408c5d12", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 140, "deletions": 53, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -152,7 +152,9 @@ void free_partial_schedule (partial_schedule_ptr);\n void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n void print_partial_schedule (partial_schedule_ptr, FILE *);\n ps_insn_ptr ps_add_node_check_conflicts (partial_schedule_ptr,\n-\t\t\t\t\t ddg_node_ptr node, int cycle);\n+\t\t\t\t\t ddg_node_ptr node, int cycle,\n+\t\t\t\t\t sbitmap must_precede,\n+\t\t\t\t\t sbitmap must_follow);\n void rotate_partial_schedule (partial_schedule_ptr, int);\n void set_row_column_for_ps (partial_schedule_ptr);\n \n@@ -874,7 +876,7 @@ sms_schedule (FILE *dump_file)\n \tcontinue;\n \n       /* For debugging.  */\n-      if (passes++ > MAX_SMS_LOOP_NUMBER && MAX_SMS_LOOP_NUMBER != -1)\n+      if ((passes++ > MAX_SMS_LOOP_NUMBER) && (MAX_SMS_LOOP_NUMBER != -1))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"SMS reached MAX_PASSES... \\n\");\n@@ -1086,8 +1088,8 @@ sms_schedule (FILE *dump_file)\n \t      int i;\n \n               start_sequence ();\n-\t      /* Copy the original loop code before modifying it - so we can use\n-\t\t it later.  */\n+\t      /* Copy the original loop code before modifying it -\n+\t \t so we can use it later.  */\n \t      for (i = 0; i < ps->g->num_nodes; i++)\n \t\tduplicate_insn_chain (ps->g->nodes[i].first_note,\n \t\t\t\t      ps->g->nodes[i].insn);\n@@ -1106,6 +1108,13 @@ sms_schedule (FILE *dump_file)\n \t  set_columns_for_ps (ps);\n \n \t  permute_partial_schedule (ps, g->closing_branch->first_note);\n+\n+          /* Mark this loop as software pipelined so the later\n+\t     scheduling passes doesn't touch it.  */\n+\t  if (! flag_resched_modulo_sched)\n+\t    emit_note_before (NOTE_DISABLE_SCHED_OF_BLOCK,\n+\t     \t\t      g->closing_branch->insn);\n+\n \t  generate_reg_moves (ps);\n \t  if (dump_file)\n \t    print_node_sched_params (dump_file, g->num_nodes);\n@@ -1217,6 +1226,9 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n   sbitmap sched_nodes = sbitmap_alloc (num_nodes);\n   sbitmap psp = sbitmap_alloc (num_nodes);\n   sbitmap pss = sbitmap_alloc (num_nodes);\n+  sbitmap must_precede = sbitmap_alloc (num_nodes);\n+  sbitmap must_follow = sbitmap_alloc (num_nodes);\n+\n   partial_schedule_ptr ps = create_partial_schedule (ii, g, DFA_HISTORY);\n \n   while (try_again_with_larger_ii && ii < maxii)\n@@ -1258,9 +1270,11 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n \t\t  ddg_node_ptr v_node = e->src;\n \t\t  if (TEST_BIT (sched_nodes, v_node->cuid))\n \t\t    {\n-\t\t      early_start = MAX (early_start,\n-\t\t\t\t\t SCHED_TIME (v_node)\n-\t\t\t\t\t + e->latency - (e->distance * ii));\n+                      int node_st = SCHED_TIME (v_node)\n+\t\t      \t\t    + e->latency - (e->distance * ii);\n+\n+\t\t      early_start = MAX (early_start, node_st);\n+\n \t\t      if (e->data_type == MEM_DEP)\n \t\t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n \t\t    }\n@@ -1341,11 +1355,31 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n \t    fprintf(dump_file, \"Trying to schedule node %d in (%d .. %d) step %d\\n\",\n \t\t    u, start, end, step);\n \n+          /* use must_follow & must_precede bitmaps to determine order\n+\t     of nodes within the cycle.  */\n+          sbitmap_zero (must_precede);\n+          sbitmap_zero (must_follow);\n+      \t  for (e = u_node->in; e != 0; e = e->next_in)\n+            if (TEST_BIT (sched_nodes, e->src->cuid)\n+\t        && e->latency == (ii * e->distance)\n+\t\t&& start == SCHED_TIME (e->src))\n+             SET_BIT (must_precede, e->src->cuid);\n+\n+\t  for (e = u_node->out; e != 0; e = e->next_out)\n+            if (TEST_BIT (sched_nodes, e->dest->cuid)\n+\t        && e->latency == (ii * e->distance)\n+\t\t&& end == SCHED_TIME (e->dest))\n+             SET_BIT (must_follow, e->dest->cuid);\n+\n \t  success = 0;\n \t  if ((step > 0 && start < end) ||  (step < 0 && start > end))\n \t    for (c = start; c != end; c += step)\n \t      {\n-\t\tps_insn_ptr psi = ps_add_node_check_conflicts (ps, u_node, c);\n+\t\tps_insn_ptr psi;\n+\n+\t\tpsi = ps_add_node_check_conflicts (ps, u_node, c,\n+\t\t\t\t\t\t   must_precede,\n+\t\t\t\t\t\t   must_follow);\n \n   \t\tif (psi)\n \t\t  {\n@@ -1884,13 +1918,80 @@ remove_node_from_ps (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n   return true;\n }\n \n+/* Unlike what literature describes for modulo scheduling (which focuses\n+   on VLIW machines) the order of the instructions inside a cycle is\n+   important.  Given the bitmaps MUST_FOLLOW and MUST_PRECEDE we know\n+   where the current instruction should go relative to the already\n+   scheduled instructions in the given cycle.  Go over these\n+   instructions and find the first possible column to put it in.  */\n+static bool\n+ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n+\t\t     sbitmap must_precede, sbitmap must_follow)\n+{\n+  ps_insn_ptr next_ps_i;\n+  ps_insn_ptr first_must_follow = NULL;\n+  ps_insn_ptr last_must_precede = NULL;\n+  int row;\n+\n+  if (! ps_i)\n+    return false;\n+\n+  row = SMODULO (ps_i->cycle, ps->ii);\n+\n+  /* Find the first must follow and the last must precede\n+     and insert the node immediatly after the must precede\n+     but make sure that it there is no must follow after it.   */\n+  for (next_ps_i = ps->rows[row];\n+       next_ps_i;\n+       next_ps_i = next_ps_i->next_in_row)\n+    {\n+      if (TEST_BIT (must_follow, next_ps_i->node->cuid)\n+\t  && ! first_must_follow)\n+        first_must_follow = next_ps_i;\n+      if (TEST_BIT (must_precede, next_ps_i->node->cuid))\n+        {\n+          /* If we have already met a node that must follow, then\n+\t     there is no possible column.  */\n+  \t  if (first_must_follow)\n+            return false;\n+\t  else\n+            last_must_precede = next_ps_i;\n+        }\n+    }\n+\n+  /* Now insert the node after INSERT_AFTER_PSI.  */\n+\n+  if (! last_must_precede)\n+    {\n+      ps_i->next_in_row = ps->rows[row];\n+      ps_i->prev_in_row = NULL;\n+      if (ps_i->next_in_row)\n+    \tps_i->next_in_row->prev_in_row = ps_i;\n+      ps->rows[row] = ps_i;\n+    }\n+  else\n+    {\n+      ps_i->next_in_row = last_must_precede->next_in_row;\n+      last_must_precede->next_in_row = ps_i;\n+      ps_i->prev_in_row = last_must_precede;\n+      if (ps_i->next_in_row)\n+        ps_i->next_in_row->prev_in_row = ps_i;\n+    }\n+\n+  return true;\n+}\n+\n /* Advances the PS_INSN one column in its current row; returns false\n-   in failure and true in success.  */\n+   in failure and true in success.  Bit N is set in MUST_FOLLOW if \n+   the node with cuid N must be come after the node pointed to by \n+   PS_I when scheduled in the same cycle.  */\n static int\n-ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n+ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n+\t\t\tsbitmap must_follow)\n {\n   ps_insn_ptr prev, next;\n   int row;\n+  ddg_node_ptr next_node;\n \n   if (!ps || !ps_i)\n     return false;\n@@ -1900,17 +2001,12 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n   if (! ps_i->next_in_row)\n     return false;\n \n+  next_node = ps_i->next_in_row->node;\n+\n   /* Check if next_in_row is dependent on ps_i, both having same sched\n      times (typically ANTI_DEP).  If so, ps_i cannot skip over it.  */\n-  if (ps_i->cycle == ps_i->next_in_row->cycle)\n-    {\n-      ddg_edge_ptr e;\n-      ddg_node_ptr next_node = ps_i->next_in_row->node;\n-\n-      for (e = ps_i->node->out; e; e = e->next_out)\n-\tif (e->dest == next_node)\n-\t  return false;\n-    }\n+  if (TEST_BIT (must_follow, next_node->cuid))\n+    return false;\n \n   /* Advace PS_I over its next_in_row in the doubly linked list.  */\n   prev = ps_i->prev_in_row;\n@@ -1935,14 +2031,17 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i)\n }\n \n /* Inserts a DDG_NODE to the given partial schedule at the given cycle.\n-   Returns 0 if this is not possible and a PS_INSN otherwise.  */\n+   Returns 0 if this is not possible and a PS_INSN otherwise.  Bit N is \n+   set in MUST_PRECEDE/MUST_FOLLOW if the node with cuid N must be come \n+   before/after (respectively) the node pointed to by PS_I when scheduled \n+   in the same cycle.  */\n static ps_insn_ptr\n-add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle)\n+add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle,\n+\t\tsbitmap must_precede, sbitmap must_follow)\n {\n-  ps_insn_ptr ps_i, next_ps_i, advance_after;\n+  ps_insn_ptr ps_i;\n   int rest_count = 1;\n   int row = SMODULO (cycle, ps->ii);\n-  ddg_edge_ptr e;\n \n   if (ps->rows[row]\n       && ps->rows[row]->row_rest_count >= issue_rate)\n@@ -1952,30 +2051,14 @@ add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle)\n     rest_count += ps->rows[row]->row_rest_count;\n \n   ps_i = create_ps_insn (node, rest_count, cycle);\n-  ps_i->next_in_row = ps->rows[row];\n-  ps_i->prev_in_row = NULL;\n-  if (ps_i->next_in_row)\n-    ps_i->next_in_row->prev_in_row = ps_i;\n-  ps->rows[row] = ps_i;\n-\n-  /* Check if n is dependent on an insn already in row, having same cycle\n-     (typically ANTI_DEP).  If so, n must skip over it.  */\n-  advance_after = NULL;\n-  for (next_ps_i = ps_i->next_in_row;\n-       next_ps_i;\n-       next_ps_i = next_ps_i->next_in_row)\n-    if (next_ps_i->cycle == cycle)\n-      for (e = node->in; e; e = e->next_in)\n-\tif (e->src == next_ps_i->node)\n-\t  advance_after = next_ps_i;\n-\n-  if (advance_after)\n-    while (ps_i->prev_in_row != advance_after)\n-      if (!ps_insn_advance_column (ps, ps_i))\n-\t{\n-\t  remove_node_from_ps (ps, ps_i);\n-\t  return NULL;\n-\t}\n+\n+  /* Finds and inserts PS_I according to MUST_FOLLOW and\n+     MUST_PRECEDE.  */\n+  if (! ps_insn_find_column (ps, ps_i, must_precede, must_follow))\n+    {\n+      free (ps_i);\n+      return NULL;\n+    }\n \n   return ps_i;\n }\n@@ -2049,16 +2132,20 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n \n /* Checks if the given node causes resource conflicts when added to PS at\n    cycle C.  If not the node is added to PS and returned; otherwise zero\n-   is returned.  */\n+   is returned.  Bit N is set in MUST_PRECEDE/MUST_FOLLOW if the node with \n+   cuid N must be come before/after (respectively) the node pointed to by \n+   PS_I when scheduled in the same cycle.  */\n ps_insn_ptr\n-ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n, int c)\n+ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n+   \t\t\t     int c, sbitmap must_precede,\n+\t\t\t     sbitmap must_follow)\n {\n   int has_conflicts = 0;\n   ps_insn_ptr ps_i;\n \n-  /* First add the node to the PS, if this succeeds check for conflicts,\n-     trying different issue slots in the same row.  */\n-  if (! (ps_i = add_node_to_ps (ps, n, c)))\n+  /* First add the node to the PS, if this succeeds check for\n+     conflicts, trying different issue slots in the same row.  */\n+  if (! (ps_i = add_node_to_ps (ps, n, c, must_precede, must_follow)))\n     return NULL; /* Failed to insert the node at the given cycle.  */\n \n   has_conflicts = ps_has_conflicts (ps, c, c)\n@@ -2071,7 +2158,7 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n, int c)\n      scheduled in without conflicts.  */\n   while (has_conflicts)\n     {\n-      if (! ps_insn_advance_column (ps, ps_i))\n+      if (! ps_insn_advance_column (ps, ps_i, must_follow))\n \tbreak;\n       has_conflicts = ps_has_conflicts (ps, c, c)\n \t\t      || (ps->history > 0"}, {"sha": "8174b6e3c4a8a8a9fb37a5cacd7f56691c045d4d", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -983,6 +983,12 @@ enum insn_note\n   /* Generated at the start of a duplicated exit test.  */\n   NOTE_INSN_LOOP_VTOP,\n \n+  /* Mark that a block shouldn't be scheduled.  This is currently\n+     used in modulo scheduling. Modulo scheduling  adds this note\n+     to the blocks of the modulo-scheduled loops to disable scheduling\n+     them in the later traditional scheduling passes.  */\n+  NOTE_DISABLE_SCHED_OF_BLOCK,\n+\n   /* This kind of note is generated at the end of the function body,\n      just before the return insn or return label.  In an optimizing\n      compilation it is deleted by the first jump optimization, after"}, {"sha": "62d2f2343b7a6f95d491ba8c82cdeadc3fd84001", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72372e46ac06b4db61143f91367a777089cc6f6/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d72372e46ac06b4db61143f91367a777089cc6f6", "patch": "@@ -117,6 +117,7 @@ static int *out_edges;\n static int is_cfg_nonregular (void);\n static int build_control_flow (struct edge_list *);\n static void new_edge (int, int);\n+static bool sched_is_disabled_for_current_region_p (void);\n \n /* A region is the main entity for interblock scheduling: insns\n    are allowed to move between blocks in the same region, along\n@@ -2332,6 +2333,37 @@ debug_dependencies (void)\n   fprintf (sched_dump, \"\\n\");\n }\n \f\n+/* Returns true if all the basic blocks of the current region have\n+   NOTE_DISABLE_SCHED_OF_BLOCK which means not to schedule that region.  */\n+static bool\n+sched_is_disabled_for_current_region_p (void)\n+{\n+  rtx first_bb_insn, last_bb_insn, insn;\n+  int bb;\n+\n+  for (bb = 0; bb < current_nr_blocks; bb++)\n+    {\n+      bool disable_sched = false;\n+      /* Searching for NOTE_DISABLE_SCHED_OF_BLOCK note between the\n+         start and end of the basic block. */\n+      get_block_head_tail (BB_TO_BLOCK (bb), &first_bb_insn,\n+\t\t\t   &last_bb_insn);\n+      for (insn = last_bb_insn; insn != NULL && insn != first_bb_insn;\n+           insn = PREV_INSN (insn))\n+      \tif (GET_CODE (insn) == NOTE\n+\t    && (NOTE_LINE_NUMBER (insn)\n+\t        == NOTE_DISABLE_SCHED_OF_BLOCK))\n+          {\n+              disable_sched = true;\n+\t      break;\n+          }\n+      if (! disable_sched)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Schedule a region.  A region is either an inner loop, a loop-free\n    subroutine, or a single basic block.  Each bb in the region is\n    scheduled after its flow predecessors.  */\n@@ -2347,6 +2379,11 @@ schedule_region (int rgn)\n   current_nr_blocks = RGN_NR_BLOCKS (rgn);\n   current_blocks = RGN_BLOCKS (rgn);\n \n+  /* Don't schedule region that is marked by\n+     NOTE_DISABLE_SCHED_OF_BLOCK.  */\n+  if (sched_is_disabled_for_current_region_p ())\n+    return;\n+\n   init_deps_global ();\n \n   /* Initializations for region data dependence analysis.  */"}]}