{"sha": "7c62b943baf5ef56622033f55a8eb9458e3d18be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M2MmI5NDNiYWY1ZWY1NjYyMjAzM2Y1NWE4ZWI5NDU4ZTNkMThiZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-03-16T10:35:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2007-03-16T10:35:16Z"}, "message": "[multiple changes]\n\n\n\n2007-03-16  Benjamin Kosnik  <bkoz@redhat.com>\n\t\n\t* testsuite/lib/dg-options.exp (dg-require-c-std): New.\n\t* testsuite/lib/libstdc++.exp (check_v3_target_c_std): New. Check to\n\tsee if _GLIBCXX_USE_C99_MATH is active. \n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t08_cyl_bessel_i/check_nan.cc: Use dg-require-c-std.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t17_hyperg/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t13_ellint_2/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t01_assoc_laguerre/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t02_assoc_legendre/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t22_sph_legendre/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t10_cyl_bessel_k/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t09_cyl_bessel_j/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t21_sph_bessel/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t07_conf_hyperg/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t16_hermite/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t12_ellint_1/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t05_comp_ellint_2/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t18_laguerre/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t14_ellint_3/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t04_comp_ellint_1/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t06_comp_ellint_3/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t19_legendre/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t03_beta/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t11_cyl_neumann/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t15_expint/check_nan.cc: Same.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t23_sph_neumann/check_nan.cc: Same.\n\n\t* include/tr1/poly_laguerre.tcc (__poly_laguerre): Don't check if\n\tunsigned int can be a NaN.\n\n2007-03-16  Edward M. Smith-Rowland  <3dw4rd@verizon.net>\n\n\t* docs/html/ext/tr1.html : Marked tr1 math special functions done.\n\t* docs/html/faq/index.html : Ditto.\n\t* include/Makefile.in : Added new special function header files.\n\t* include/Makefile.am : Ditto.\t\n\t* include/tr1/common.h : Added type promotion routines for three\n\tand four args.\n\n\t* include/tr1/special_function_util.h: New.\n\t* include/tr1/bessel_function.tcc: New.\n\t* include/tr1/beta_function.tcc: New.\n\t* include/tr1/ell_integral.tcc: New.\n\t* include/tr1/exp_integral.tcc: New.\n\t* include/tr1/gamma.tcc: New.\n\t* include/tr1/hypergeometric.tcc: New.\n\t* include/tr1/legendre_function.tcc: New.\n\t* include/tr1/modified_bessel_func.tcc: New.\n\t* include/tr1/poly_hermite.tcc: New.\n\t* include/tr1/poly_laguerre.tcc: New.\n\t* include/tr1/riemann_zeta.tcc: New.\n\t* include/tr1/cmath : Included tr1 math special functions.\n\t* include/tr1/math.h : Ditto.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\ttestcase.h: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t01_assoc_laguerre/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t01_assoc_laguerre/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t01_assoc_laguerre/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t01_assoc_laguerre/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t02_assoc_legendre/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t02_assoc_legendre/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t02_assoc_legendre/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t02_assoc_legendre/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t04_comp_ellint_1/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t04_comp_ellint_1/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t04_comp_ellint_1/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t04_comp_ellint_1/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t05_comp_ellint_2/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t05_comp_ellint_2/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t05_comp_ellint_2/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t05_comp_ellint_2/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t06_comp_ellint_3/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t06_comp_ellint_3/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t06_comp_ellint_3/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t06_comp_ellint_3/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t07_conf_hyperg/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t07_conf_hyperg/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t07_conf_hyperg/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t07_conf_hyperg/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t08_cyl_bessel_i/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t08_cyl_bessel_i/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t08_cyl_bessel_i/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t08_cyl_bessel_i/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t09_cyl_bessel_j/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t09_cyl_bessel_j/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t09_cyl_bessel_j/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t09_cyl_bessel_j/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t10_cyl_bessel_k/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t10_cyl_bessel_k/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t10_cyl_bessel_k/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t10_cyl_bessel_k/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t11_cyl_neumann/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t11_cyl_neumann/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t11_cyl_neumann/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t11_cyl_neumann/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n\tcheck_value_neg.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n\tcheck_value_pos.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n\tcompile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n\tcheck_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n\tcheck_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n\tcompile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/check_value_neg.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t20_riemann_zeta/check_value_pos.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t21_sph_bessel/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t21_sph_bessel/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t21_sph_bessel/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t21_sph_bessel/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t22_sph_legendre/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t22_sph_legendre/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t22_sph_legendre/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t22_sph_legendre/compile_2.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t23_sph_neumann/compile.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t23_sph_neumann/check_nan.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t23_sph_neumann/check_value.cc: New.\n\t* testsuite/tr1/5_numerical_facilities/special_functions/\n\t23_sph_neumann/ compile_2.cc: New.\n\nFrom-SVN: r122986", "tree": {"sha": "decac71c7af454edb119868a1763aff3b7c70e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/decac71c7af454edb119868a1763aff3b7c70e56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c62b943baf5ef56622033f55a8eb9458e3d18be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c62b943baf5ef56622033f55a8eb9458e3d18be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c62b943baf5ef56622033f55a8eb9458e3d18be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c62b943baf5ef56622033f55a8eb9458e3d18be/comments", "author": null, "committer": null, "parents": [{"sha": "7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1737d07a6b869120d7fca9bd755c9e426a0bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1737d07a6b869120d7fca9bd755c9e426a0bfe"}], "stats": {"total": 60167, "additions": 60128, "deletions": 39}, "files": [{"sha": "22107cd83dcbe25eaab70f8ee9f8adc6c49af2f7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 273, "deletions": 3, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -1,3 +1,270 @@\n+2007-03-16  Benjamin Kosnik  <bkoz@redhat.com>\n+\t\n+\t* testsuite/lib/dg-options.exp (dg-require-c-std): New.\n+\t* testsuite/lib/libstdc++.exp (check_v3_target_c_std): New. Check to\n+\tsee if _GLIBCXX_USE_C99_MATH is active. \n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t08_cyl_bessel_i/check_nan.cc: Use dg-require-c-std.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t17_hyperg/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t13_ellint_2/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t01_assoc_laguerre/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t02_assoc_legendre/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t22_sph_legendre/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t10_cyl_bessel_k/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t09_cyl_bessel_j/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t21_sph_bessel/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t07_conf_hyperg/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t16_hermite/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t12_ellint_1/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t05_comp_ellint_2/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t18_laguerre/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t14_ellint_3/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t04_comp_ellint_1/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t06_comp_ellint_3/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t19_legendre/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t03_beta/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t11_cyl_neumann/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t15_expint/check_nan.cc: Same.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t23_sph_neumann/check_nan.cc: Same.\n+\n+\t* include/tr1/poly_laguerre.tcc (__poly_laguerre): Don't check if\n+\tunsigned int can be a NaN.\n+\n+2007-03-16  Edward M. Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\t* docs/html/ext/tr1.html : Marked tr1 math special functions done.\n+\t* docs/html/faq/index.html : Ditto.\n+\t* include/Makefile.in : Added new special function header files.\n+\t* include/Makefile.am : Ditto.\t\n+\t* include/tr1/common.h : Added type promotion routines for three\n+\tand four args.\n+\n+\t* include/tr1/special_function_util.h: New.\n+\t* include/tr1/bessel_function.tcc: New.\n+\t* include/tr1/beta_function.tcc: New.\n+\t* include/tr1/ell_integral.tcc: New.\n+\t* include/tr1/exp_integral.tcc: New.\n+\t* include/tr1/gamma.tcc: New.\n+\t* include/tr1/hypergeometric.tcc: New.\n+\t* include/tr1/legendre_function.tcc: New.\n+\t* include/tr1/modified_bessel_func.tcc: New.\n+\t* include/tr1/poly_hermite.tcc: New.\n+\t* include/tr1/poly_laguerre.tcc: New.\n+\t* include/tr1/riemann_zeta.tcc: New.\n+\t* include/tr1/cmath : Included tr1 math special functions.\n+\t* include/tr1/math.h : Ditto.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\ttestcase.h: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t01_assoc_laguerre/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t01_assoc_laguerre/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t01_assoc_laguerre/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t01_assoc_laguerre/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t02_assoc_legendre/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t02_assoc_legendre/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t02_assoc_legendre/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t02_assoc_legendre/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/03_beta/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t04_comp_ellint_1/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t04_comp_ellint_1/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t04_comp_ellint_1/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t04_comp_ellint_1/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t05_comp_ellint_2/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t05_comp_ellint_2/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t05_comp_ellint_2/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t05_comp_ellint_2/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t06_comp_ellint_3/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t06_comp_ellint_3/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t06_comp_ellint_3/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t06_comp_ellint_3/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t07_conf_hyperg/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t07_conf_hyperg/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t07_conf_hyperg/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t07_conf_hyperg/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t08_cyl_bessel_i/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t08_cyl_bessel_i/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t08_cyl_bessel_i/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t08_cyl_bessel_i/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t09_cyl_bessel_j/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t09_cyl_bessel_j/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t09_cyl_bessel_j/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t09_cyl_bessel_j/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t10_cyl_bessel_k/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t10_cyl_bessel_k/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t10_cyl_bessel_k/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t10_cyl_bessel_k/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t11_cyl_neumann/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t11_cyl_neumann/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t11_cyl_neumann/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t11_cyl_neumann/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n+\tcheck_value_neg.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/\n+\tcheck_value_pos.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n+\tcompile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n+\tcheck_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n+\tcheck_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/\n+\tcompile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/check_value_neg.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t20_riemann_zeta/check_value_pos.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t21_sph_bessel/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t21_sph_bessel/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t21_sph_bessel/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t21_sph_bessel/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t22_sph_legendre/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t22_sph_legendre/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t22_sph_legendre/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t22_sph_legendre/compile_2.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t23_sph_neumann/compile.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t23_sph_neumann/check_nan.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t23_sph_neumann/check_value.cc: New.\n+\t* testsuite/tr1/5_numerical_facilities/special_functions/\n+\t23_sph_neumann/ compile_2.cc: New.\n+\t\n 2007-03-15  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* testsuite/lib/libstdc++.exp (v3-build_support) <ar>: If it\n@@ -145,9 +412,12 @@\n \t* testsuite/27_io/basic_filebuf/sputn/char/9339.cc: Use it.\n \t* testsuite/27_io/basic_filebuf/pbackfail/char/9761.cc: Use it.\n \t* testsuite/27_io/basic_filebuf/sync/char/9182-1.cc: Use it.\n-\t* testsuite/21_strings/basic_string/inserters_extractors/char/10.cc: Use it.\n-\t* testsuite/21_strings/basic_string/inserters_extractors/char/11.cc: Use it.\n-\t* testsuite/21_strings/basic_string/inserters_extractors/char/5.cc: Use it.\n+\t* testsuite/21_strings/basic_string/inserters_extractors/\n+\tchar/10.cc: Use it.\n+\t* testsuite/21_strings/basic_string/inserters_extractors/\n+\tchar/11.cc: Use it.\n+\t* testsuite/21_strings/basic_string/inserters_extractors/\n+\tchar/5.cc: Use it.\n \n 2007-03-13  Paolo Carlini  <pcarlini@suse.de>\n "}, {"sha": "4a021df09a670d7ae77a7f09ad4d039239ef3df7", "filename": "libstdc++-v3/docs/html/ext/tr1.html", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Ftr1.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Ftr1.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Ftr1.html?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -807,209 +807,209 @@ <h1 align=\"center\">\n     <tr>\n       <td>5.2</td>\n       <td>Mathematical special functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1</td>\n       <td>Additions to header <code>&lt;cmath&gt;</code> synopsis</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.1</td>\n       <td>associated Laguerre polynomials</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.2</td>\n       <td>associated Legendre functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.3</td>\n       <td>beta function</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.4</td>\n       <td>(complete) elliptic integral of the first kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.5</td>\n       <td>(complete) elliptic integral of the second kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.6</td>\n       <td>(complete) elliptic integral of the third kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.7</td>\n       <td>confluent hypergeometric functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.8</td>\n       <td>regular modified cylindrical Bessel functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.9</td>\n       <td>cylindrical Bessel functions (of the first kind)</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.10</td>\n       <td>irregular modified cylindrical Bessel functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.11</td>\n       <td>cylindrical Neumann functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.12</td>\n       <td>(incomplete) elliptic integral of the first kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.13</td>\n       <td>(incomplete) elliptic integral of the second kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.14</td>\n       <td>(incomplete) elliptic integral of the third kind</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.15</td>\n       <td>exponential integral</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.16</td>\n       <td>Hermite polynomials</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.17</td>\n       <td>hypergeometric functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.18</td>\n       <td>Laguerre polynomials</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.19</td>\n       <td>Legendre polynomials</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.20</td>\n       <td>Riemann zeta function</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.21</td>\n       <td>spherical Bessel functions (of the first kind)</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.22</td>\n       <td>spherical associated Legendre functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.1.23</td>\n       <td>spherical Neumann functions</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>\n       <td>5.2.2</td>\n       <td>Additions to header <code>&lt;math.h&gt;</code> synopsis</td>\n+      <td>done</td>\n       <td></td>\n       <td></td>\n-      <td>missing</td>\n       <td></td>\n     </tr>\n     <tr>"}, {"sha": "298ae37cdb61e3c90cfbddbae1b64404e57bee60", "filename": "libstdc++-v3/docs/html/faq/index.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -1047,7 +1047,7 @@ <h2><a name=\"5_5\">5.5 Does libstdc++ support TR1?</a></h2>\n \t and the C++ languages.\n       </p>\n \n-      <p><strong>Special functions - Under construction - </strong>\n+      <p><strong>Special functions - Complete - </strong>\n          Twenty-three mathematical functions familiar to physicists and\n \t engineers are included:  cylindrical and spherical Bessel and Neumann\n \t functions, hypergeometric functions, Laguerre polynomials, Legendre"}, {"sha": "e3ca800a27e3bca66fc42dc3581cb7a406dba6e1", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -533,6 +533,8 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/bessel_function.tcc \\\n+\t${tr1_srcdir}/beta_function.tcc \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n@@ -554,19 +556,29 @@ tr1_headers = \\\n \t${tr1_srcdir}/ctype.h \\\n \t${tr1_srcdir}/cwchar \\\n \t${tr1_srcdir}/cwctype \\\n+\t${tr1_srcdir}/ell_integral.tcc \\\n+\t${tr1_srcdir}/exp_integral.tcc \\\n \t${tr1_srcdir}/fenv.h \\\n \t${tr1_srcdir}/float.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n+\t${tr1_srcdir}/gamma.tcc \\\n \t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/hypergeometric.tcc \\\n \t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n \t${tr1_srcdir}/memory \\\n+\t${tr1_srcdir}/modified_bessel_func.tcc \\\n+\t${tr1_srcdir}/poly_hermite.tcc \\\n+\t${tr1_srcdir}/poly_laguerre.tcc \\\n+\t${tr1_srcdir}/legendre_function.tcc \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/regex \\\n+\t${tr1_srcdir}/riemann_zeta.tcc \\\n+\t${tr1_srcdir}/special_function_util.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n \t${tr1_srcdir}/stdint.h \\"}, {"sha": "02de25c272fde410ca587cb4e00db621d5083059", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -763,6 +763,8 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/bessel_function.tcc \\\n+\t${tr1_srcdir}/beta_function.tcc \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n@@ -784,19 +786,29 @@ tr1_headers = \\\n \t${tr1_srcdir}/ctype.h \\\n \t${tr1_srcdir}/cwchar \\\n \t${tr1_srcdir}/cwctype \\\n+\t${tr1_srcdir}/ell_integral.tcc \\\n+\t${tr1_srcdir}/exp_integral.tcc \\\n \t${tr1_srcdir}/fenv.h \\\n \t${tr1_srcdir}/float.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n+\t${tr1_srcdir}/gamma.tcc \\\n \t${tr1_srcdir}/hashtable \\\n+\t${tr1_srcdir}/hypergeometric.tcc \\\n \t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n \t${tr1_srcdir}/memory \\\n+\t${tr1_srcdir}/modified_bessel_func.tcc \\\n+\t${tr1_srcdir}/poly_hermite.tcc \\\n+\t${tr1_srcdir}/poly_laguerre.tcc \\\n+\t${tr1_srcdir}/legendre_function.tcc \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/regex \\\n+\t${tr1_srcdir}/riemann_zeta.tcc \\\n+\t${tr1_srcdir}/special_function_util.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n \t${tr1_srcdir}/stdint.h \\"}, {"sha": "68ca9a31703bce3a0cee9e37930da040bdea959f", "filename": "libstdc++-v3/include/tr1/bessel_function.tcc", "status": "added", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbessel_function.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,641 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/bessel_function.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland.\n+//\n+// References:\n+//   (1) Handbook of Mathematical Functions,\n+//       ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 9, pp. 355-434, Section 10 pp. 435-478\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 240-245\n+\n+#ifndef _TR1_BESSEL_FUNCTION_TCC\n+#define _TR1_BESSEL_FUNCTION_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief Compute the gamma functions required by the Temme series\n+     *          expansions of @f$ N_\\nu(x) @f$ and @f$ K_\\nu(x) @f$.\n+     *   @f[\n+     *     \\Gamma_1 = \\frac{1}{2\\mu}\n+     *                [\\frac{1}{\\Gamma(1 - \\mu)} - \\frac{1}{\\Gamma(1 + \\mu)}]\n+     *   @f]\n+     *   and\n+     *   @f[\n+     *     \\Gamma_2 = \\frac{1}{2}\n+     *                [\\frac{1}{\\Gamma(1 - \\mu)} + \\frac{1}{\\Gamma(1 + \\mu)}]\n+     *   @f]\n+     *   where @f$ -1/2 <= \\mu <= 1/2 @f$ is @f$ \\mu = \\nu - N @f$ and @f$ N @f$.\n+     *   is the nearest integer to @f$ \\nu @f$.\n+     *   The values of \\f$ \\Gamma(1 + \\mu) \\f$ and \\f$ \\Gamma(1 - \\mu) \\f$\n+     *   are returned as well.\n+     * \n+     *   The accuracy requirements on this are exquisite.\n+     *\n+     *   @param __mu     The input parameter of the gamma functions.\n+     *   @param __gam1   The output function \\f$ \\Gamma_1(\\mu) \\f$\n+     *   @param __gam2   The output function \\f$ \\Gamma_2(\\mu) \\f$\n+     *   @param __gampl  The output function \\f$ \\Gamma(1 + \\mu) \\f$\n+     *   @param __gammi  The output function \\f$ \\Gamma(1 - \\mu) \\f$\n+     */\n+    template <typename _Tp>\n+    void\n+    __gamma_temme(const _Tp __mu,\n+                   _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)\n+    {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      __gampl = _Tp(1) / std::_GLIBCXX_TR1::tgamma(_Tp(1) + __mu);\n+      __gammi = _Tp(1) / std::_GLIBCXX_TR1::tgamma(_Tp(1) - __mu);\n+#else\n+      __gampl = _Tp(1) / __gamma(_Tp(1) + __mu);\n+      __gammi = _Tp(1) / __gamma(_Tp(1) - __mu);\n+#endif\n+\n+      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())\n+        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());\n+      else\n+        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);\n+\n+      __gam2 = (__gammi + __gampl) / (_Tp(2));\n+\n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief  Compute the Bessel @f$ J_\\nu(x) @f$ and Neumann\n+     *           @f$ N_\\nu(x) @f$ functions and their first derivatives\n+     *           @f$ J'_\\nu(x) @f$ and @f$ N'_\\nu(x) @f$ respectively.\n+     *           These four functions are computed together for numerical\n+     *           stability.\n+     *\n+     *   @param  __nu  The order of the Bessel functions.\n+     *   @param  __x   The argument of the Bessel functions.\n+     *   @param  __Jnu  The output Bessel function of the first kind.\n+     *   @param  __Nnu  The output Neumann function (Bessel fuction of the second kind).\n+     *   @param  __Jpnu  The output derivative of the Bessel function of the first kind.\n+     *   @param  __Npnu  The output derivative of the Neumann function.\n+     */\n+    template <typename _Tp>\n+    void\n+    __bessel_jn(const _Tp __nu, const _Tp __x,\n+                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)\n+    {\n+      if (__x == _Tp(0))\n+        {\n+          if (__nu == _Tp(0))\n+            {\n+              __Jnu = _Tp(1);\n+              __Jpnu = _Tp(0);\n+            }\n+          else if (__nu == _Tp(1))\n+            {\n+              __Jnu = _Tp(0);\n+              __Jpnu = _Tp(0.5L);\n+            }\n+          else\n+            {\n+              __Jnu = _Tp(0);\n+              __Jpnu = _Tp(0);\n+            }\n+          __Nnu = -std::numeric_limits<_Tp>::infinity();\n+          __Npnu = std::numeric_limits<_Tp>::infinity();\n+          return;\n+        }\n+\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      //  When the multiplier is N i.e.\n+      //  fp_min = N * min()\n+      //  Then J_0 and N_0 tank at x = 8 * N (J_0 = 0 and N_0 = nan)!\n+      //const _Tp __fp_min = _Tp(20) * std::numeric_limits<_Tp>::min();\n+      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());\n+      const int __max_iter = 15000;\n+      const _Tp __x_min = _Tp(2);\n+\n+      const int __nl = (__x < __x_min\n+                    ? static_cast<int>(__nu + _Tp(0.5L))\n+                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));\n+\n+      const _Tp __mu = __nu - __nl;\n+      const _Tp __mu2 = __mu * __mu;\n+      const _Tp __xi = _Tp(1) / __x;\n+      const _Tp __xi2 = _Tp(2) * __xi;\n+      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();\n+      int __isign = 1;\n+      _Tp __h = __nu * __xi;\n+      if (__h < __fp_min)\n+        __h = __fp_min;\n+      _Tp __b = __xi2 * __nu;\n+      _Tp __d = _Tp(0);\n+      _Tp __c = __h;\n+      int __i;\n+      for (__i = 1; __i <= __max_iter; ++__i)\n+        {\n+          __b += __xi2;\n+          __d = __b - __d;\n+          if (std::abs(__d) < __fp_min)\n+            __d = __fp_min;\n+          __c = __b - _Tp(1) / __c;\n+          if (std::abs(__c) < __fp_min)\n+            __c = __fp_min;\n+          __d = _Tp(1) / __d;\n+          const _Tp __del = __c * __d;\n+          __h *= __del;\n+          if (__d < _Tp(0))\n+            __isign = -__isign;\n+          if (std::abs(__del - _Tp(1)) < __eps)\n+            break;\n+        }\n+      if (__i > __max_iter)\n+        std::__throw_runtime_error(__N(\"Argument x too large in __bessel_jn; \"\n+                                       \"try asymptotic expansion.\"));\n+      _Tp __Jnul = __isign * __fp_min;\n+      _Tp __Jpnul = __h * __Jnul;\n+      _Tp __Jnul1 = __Jnul;\n+      _Tp __Jpnu1 = __Jpnul;\n+      _Tp __fact = __nu * __xi;\n+      for ( int __l = __nl; __l >= 1; --__l )\n+        {\n+          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;\n+          __fact -= __xi;\n+          __Jpnul = __fact * __Jnutemp - __Jnul;\n+          __Jnul = __Jnutemp;\n+        }\n+      if (__Jnul == _Tp(0))\n+        __Jnul = __eps;\n+      _Tp __f= __Jpnul / __Jnul;\n+      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;\n+      if (__x < __x_min)\n+        {\n+          const _Tp __x2 = __x / _Tp(2);\n+          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;\n+          _Tp __fact = (std::abs(__pimu) < __eps\n+                      ? _Tp(1) : __pimu / std::sin(__pimu));\n+          _Tp __d = -std::log(__x2);\n+          _Tp __e = __mu * __d;\n+          _Tp __fact2 = (std::abs(__e) < __eps\n+                       ? _Tp(1) : std::sinh(__e) / __e);\n+          _Tp __gam1, __gam2, __gampl, __gammi;\n+          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);\n+          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())\n+                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);\n+          __e = std::exp(__e);\n+          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);\n+          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);\n+          const _Tp __pimu2 = __pimu / _Tp(2);\n+          _Tp __fact3 = (std::abs(__pimu2) < __eps\n+                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );\n+          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;\n+          _Tp __c = _Tp(1);\n+          __d = -__x2 * __x2;\n+          _Tp __sum = __ff + __r * __q;\n+          _Tp __sum1 = __p;\n+          for (__i = 1; __i <= __max_iter; ++__i)\n+            {\n+              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);\n+              __c *= __d / _Tp(__i);\n+              __p /= _Tp(__i) - __mu;\n+              __q /= _Tp(__i) + __mu;\n+              const _Tp __del = __c * (__ff + __r * __q);\n+              __sum += __del; \n+              const _Tp __del1 = __c * __p - __i * __del;\n+              __sum1 += __del1;\n+              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )\n+                break;\n+            }\n+          if ( __i > __max_iter )\n+            std::__throw_runtime_error(__N(\"Bessel y series failed to converge \"\n+                                           \"in __bessel_jn.\"));\n+          __Nmu = -__sum;\n+          __Nnu1 = -__sum1 * __xi2;\n+          __Npmu = __mu * __xi * __Nmu - __Nnu1;\n+          __Jmu = __w / (__Npmu - __f * __Nmu);\n+        }\n+      else\n+        {\n+          _Tp __a = _Tp(0.25L) - __mu2;\n+          _Tp __q = _Tp(1);\n+          _Tp __p = -__xi / _Tp(2);\n+          _Tp __br = _Tp(2) * __x;\n+          _Tp __bi = _Tp(2);\n+          _Tp __fact = __a * __xi / (__p * __p + __q * __q);\n+          _Tp __cr = __br + __q * __fact;\n+          _Tp __ci = __bi + __p * __fact;\n+          _Tp __den = __br * __br + __bi * __bi;\n+          _Tp __dr = __br / __den;\n+          _Tp __di = -__bi / __den;\n+          _Tp __dlr = __cr * __dr - __ci * __di;\n+          _Tp __dli = __cr * __di + __ci * __dr;\n+          _Tp __temp = __p * __dlr - __q * __dli;\n+          __q = __p * __dli + __q * __dlr;\n+          __p = __temp;\n+          int __i;\n+          for (__i = 2; __i <= __max_iter; ++__i)\n+            {\n+              __a += _Tp(2 * (__i - 1));\n+              __bi += _Tp(2);\n+              __dr = __a * __dr + __br;\n+              __di = __a * __di + __bi;\n+              if (std::abs(__dr) + std::abs(__di) < __fp_min)\n+                __dr = __fp_min;\n+              __fact = __a / (__cr * __cr + __ci * __ci);\n+              __cr = __br + __cr * __fact;\n+              __ci = __bi - __ci * __fact;\n+              if (std::abs(__cr) + std::abs(__ci) < __fp_min)\n+                __cr = __fp_min;\n+              __den = __dr * __dr + __di * __di;\n+              __dr /= __den;\n+              __di /= -__den;\n+              __dlr = __cr * __dr - __ci * __di;\n+              __dli = __cr * __di + __ci * __dr;\n+              __temp = __p * __dlr - __q * __dli;\n+              __q = __p * __dli + __q * __dlr;\n+              __p = __temp;\n+              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)\n+                break;\n+          }\n+          if (__i > __max_iter)\n+            std::__throw_runtime_error(__N(\"Lentz's method failed \"\n+                                           \"in __bessel_jn.\"));\n+          const _Tp __gam = (__p - __f) / __q;\n+          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+          __Jmu = std::_GLIBCXX_TR1::copysign(__Jmu, __Jnul);\n+#else\n+          if (__Jmu * __Jnul < _Tp(0))\n+            __Jmu = -__Jmu;\n+#endif\n+          __Nmu = __gam * __Jmu;\n+          __Npmu = (__p + __q / __gam) * __Nmu;\n+          __Nnu1 = __mu * __xi * __Nmu - __Npmu;\n+      }\n+      __fact = __Jmu / __Jnul;\n+      __Jnu = __fact * __Jnul1;\n+      __Jpnu = __fact * __Jpnu1;\n+      for (__i = 1; __i <= __nl; ++__i)\n+        {\n+          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;\n+          __Nmu = __Nnu1;\n+          __Nnu1 = __Nnutemp;\n+        }\n+      __Nnu = __Nmu;\n+      __Npnu = __nu * __xi * __Nmu - __Nnu1;\n+\n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief This routine computes the asyptotic cylindrical Bessel\n+     *          and Neumann functions of order nu: \\f$ J_{\\nu} \\f$,\n+     *          \\f$ N_{\\nu} \\f$.\n+     *\n+     *   References:\n+     *    (1) Handbook of Mathematical Functions,\n+     *        ed. Milton Abramowitz and Irene A. Stegun,\n+     *        Dover Publications,\n+     *        Section 9 p. 364, Equations 9.2.5-9.2.10\n+     *\n+     *   @param  __nu  The order of the Bessel functions.\n+     *   @param  __x   The argument of the Bessel functions.\n+     *   @param  __Jnu  The output Bessel function of the first kind.\n+     *   @param  __Nnu  The output Neumann function (Bessel fuction of the second kind).\n+     */\n+    template <typename _Tp>\n+    void\n+    __cyl_bessel_jn_asymp(const _Tp __nu, const _Tp __x,\n+                          _Tp & __Jnu, _Tp & __Nnu)\n+    {\n+      const _Tp __coef = std::sqrt(_Tp(2)\n+                             / (__numeric_constants<_Tp>::__pi() * __x));\n+      const _Tp __mu   = _Tp(4) * __nu * __nu;\n+      const _Tp __mum1 = __mu - _Tp(1);\n+      const _Tp __mum9 = __mu - _Tp(9);\n+      const _Tp __mum25 = __mu - _Tp(25);\n+      const _Tp __mum49 = __mu - _Tp(49);\n+      const _Tp __xx = _Tp(64) * __x * __x;\n+      const _Tp __P = _Tp(1) - __mum1 * __mum9 / (_Tp(2) * __xx)\n+                    * (_Tp(1) - __mum25 * __mum49 / (_Tp(12) * __xx));\n+      const _Tp __Q = __mum1 / (_Tp(8) * __x)\n+                    * (_Tp(1) - __mum9 * __mum25 / (_Tp(6) * __xx));\n+\n+      const _Tp __chi = __x - (__nu + _Tp(0.5L))\n+                            * __numeric_constants<_Tp>::__pi_2();\n+      const _Tp __c = std::cos(__chi);\n+      const _Tp __s = std::sin(__chi);\n+\n+      __Jnu = __coef * (__c * __P - __s * __Q);\n+      __Nnu = __coef * (__s * __P + __c * __Q);\n+\n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the cylindrical Bessel functions\n+     *          of order \\f$ \\nu \\f$: \\f$ J_{\\nu} \\f$ or \\f$ I_{\\nu} \\f$\n+     *          by series expansion.\n+     *\n+     *   The modified cylindrical Bessel function is:\n+     *   @f[\n+     *    Z_{\\nu}(x) = \\sum_{k=0}^{\\infty}\n+     *              \\frac{\\sigma^k (x/2)^{\\nu + 2k}}{k!\\Gamma(\\nu+k+1)}\n+     *   @f]\n+     *   where \\f$ \\sigma = +1 \\f$ or\\f$  -1 \\f$ for\n+     *   \\f$ Z = I \\f$ or \\f$ J \\f$ respecively. \n+     * \n+     *   See Abramowitz & Stegun, 9.1.10\n+     *       Abramowitz & Stegun, 9.6.7\n+     *    (1) Handbook of Mathematical Functions,\n+     *        ed. Milton Abramowitz and Irene A. Stegun,\n+     *        Dover Publications,\n+     *        Equation 9.1.10 p. 360 and Equation 9.6.10 p. 375\n+     *\n+     *   @param  __nu  The order of the Bessel function.\n+     *   @param  __x   The argument of the Bessel function.\n+     *   @param  __sgn  The sign of the alternate terms\n+     *                  -1 for the Bessel function of the first kind.\n+     *                  +1 for the modified Bessel function of the first kind.\n+     *   @return  The output Bessel function.\n+     */\n+    template <typename _Tp>\n+    _Tp\n+    __cyl_bessel_ij_series(const _Tp __nu, const _Tp __x, const _Tp __sgn,\n+                           const unsigned int __max_iter)\n+    {\n+\n+      const _Tp __x2 = __x / _Tp(2);\n+      _Tp __fact = __nu * std::log(__x2);\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      __fact -= std::_GLIBCXX_TR1::lgamma(__nu + _Tp(1));\n+#else\n+      __fact -= __log_gamma(__nu + _Tp(1));\n+#endif\n+      __fact = std::exp(__fact);\n+      const _Tp __xx4 = __sgn * __x2 * __x2;\n+      _Tp __Jn = _Tp(1);\n+      _Tp __term = _Tp(1);\n+\n+      for (unsigned int __i = 1; __i < __max_iter; ++__i)\n+        {\n+          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));\n+          __Jn += __term;\n+          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+        }\n+\n+      return __fact * __Jn;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Bessel function of order \\f$ \\nu \\f$:\n+     *           \\f$ J_{\\nu}(x) \\f$.\n+     *\n+     *   The cylindrical Bessel function is:\n+     *   @f[\n+     *    J_{\\nu}(x) = \\sum_{k=0}^{\\infty}\n+     *              \\frac{(-1)^k (x/2)^{\\nu + 2k}}{k!\\Gamma(\\nu+k+1)}\n+     *   @f]\n+     *\n+     *   @param  __nu  The order of the Bessel function.\n+     *   @param  __x   The argument of the Bessel function.\n+     *   @return  The output Bessel function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __cyl_bessel_j(const _Tp __nu, const _Tp __x)\n+    {\n+      if (__nu < _Tp(0) || __x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __cyl_bessel_j.\"));\n+      else if (__isnan(__nu) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))\n+        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);\n+      else if (__x > _Tp(1000))\n+        {\n+          _Tp __J_nu, __N_nu;\n+          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);\n+          return __J_nu;\n+        }\n+      else\n+        {\n+          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;\n+          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);\n+          return __J_nu;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Neunamm function of order \\f$ \\nu \\f$:\n+     *           \\f$ N_{\\nu}(x) \\f$.\n+     *\n+     *   The Neumann function is defined by:\n+     *   @f[\n+     *      N_{\\nu}(x) = \\frac{J_{\\nu}(x) \\cos \\nu\\pi - J_{-\\nu}(x)}\n+     *                        {\\sin \\nu\\pi}\n+     *   @f]\n+     *   where for integral \\f$ \\nu = n \\f$ a limit is taken:\n+     *   \\f$ lim_{\\nu \\to n} \\f$.\n+     *\n+     *   @param  __nu  The order of the Neumann function.\n+     *   @param  __x   The argument of the Neumann function.\n+     *   @return  The output Neumann function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __cyl_neumann_n(const _Tp __nu, const _Tp __x)\n+    {\n+      if (__nu < _Tp(0) || __x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __cyl_neumann_n.\"));\n+      else if (__isnan(__nu) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x > _Tp(1000))\n+        {\n+          _Tp __J_nu, __N_nu;\n+          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);\n+          return __N_nu;\n+        }\n+      else\n+        {\n+          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;\n+          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);\n+          return __N_nu;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Compute the spherical Bessel @f$ j_n(x) @f$\n+     *           and Neumann @f$ n_n(x) @f$ functions and their first\n+     *           derivatives @f$ j'_n(x) @f$ and @f$ n'_n(x) @f$\n+     *           respectively.\n+     *\n+     *   @param  __n  The order of the spherical Bessel function.\n+     *   @param  __x  The argument of the spherical Bessel function.\n+     *   @param  __j_n  The output spherical Bessel function.\n+     *   @param  __n_n  The output spherical Neumann function.\n+     *   @param  __jp_n  The output derivative of the spherical Bessel function.\n+     *   @param  __np_n  The output derivative of the spherical Neumann function.\n+     */\n+    template <typename _Tp>\n+    void\n+    __sph_bessel_jn(const unsigned int __n, const _Tp __x,\n+                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)\n+    {\n+      const _Tp __nu = _Tp(__n) + _Tp(0.5L);\n+\n+      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;\n+      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);\n+\n+      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()\n+                         / std::sqrt(__x);\n+\n+      __j_n = __factor * __J_nu;\n+      __n_n = __factor * __N_nu;\n+      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);\n+      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);\n+\n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the spherical Bessel function\n+     *           @f$ j_n(x) @f$ of order n.\n+     *\n+     *   The spherical Bessel function is defined by:\n+     *   @f[\n+     *    j_n(x) = \\left( \\frac{\\pi}{2x} \\right) ^{1/2} J_{n+1/2}(x)\n+     *   @f]\n+     *\n+     *   @param  __n  The order of the spherical Bessel function.\n+     *   @param  __x  The argument of the spherical Bessel function.\n+     *   @return  The output spherical Bessel function.\n+     */\n+    template <typename _Tp>\n+    _Tp\n+    __sph_bessel(const unsigned int __n, const _Tp __x)\n+    {\n+      if (__x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __sph_bessel.\"));\n+      else if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x == _Tp(0))\n+        {\n+          if (__n == 0)\n+            return _Tp(1);\n+          else\n+            return _Tp(0);\n+        }\n+      else\n+        {\n+          _Tp __j_n, __n_n, __jp_n, __np_n;\n+          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);\n+          return __j_n;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the spherical Neumann function\n+     *           @f$ n_n(x) @f$.\n+     *\n+     *   The spherical Neumann function is defined by:\n+     *   @f[\n+     *    n_n(x) = \\left( \\frac{\\pi}{2x} \\right) ^{1/2} N_{n+1/2}(x)\n+     *   @f]\n+     *\n+     *   @param  __n  The order of the spherical Neumann function.\n+     *   @param  __x  The argument of the spherical Neumann function.\n+     *   @return  The output spherical Neumann function.\n+     */\n+    template <typename _Tp>\n+    _Tp\n+    __sph_neumann(const unsigned int __n, const _Tp __x)\n+    {\n+      if (__x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __sph_neumann.\"));\n+      else if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x == _Tp(0))\n+        return -std::numeric_limits<_Tp>::infinity();\n+      else\n+        {\n+          _Tp __j_n, __n_n, __jp_n, __np_n;\n+          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);\n+          return __n_n;\n+        }\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_BESSEL_FUNCTION_TCC"}, {"sha": "a46011708f1368c5822afd92852291f823e40490", "filename": "libstdc++-v3/include/tr1/beta_function.tcc", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbeta_function.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,211 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/beta_function.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 6, pp. 253-266\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 213-216\n+//   (4) Gamma, Exploring Euler's Constant, Julian Havil,\n+//       Princeton, 2003.\n+\n+#ifndef _TR1_BETA_FUNCTION_TCC\n+#define _TR1_BETA_FUNCTION_TCC 1\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief  Return the beta function: \\f$B(x,y)\\f$.\n+     * \n+     *   The beta function is defined by\n+     *   @f[\n+     *     B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}\n+     *   @f]\n+     *\n+     *   @param __x The first argument of the beta function.\n+     *   @param __y The second argument of the beta function.\n+     *   @return  The beta function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __beta_gamma(_Tp __x, _Tp __y)\n+    {\n+\n+      _Tp __bet;\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      if (__x > __y)\n+        {\n+          __bet = std::_GLIBCXX_TR1::tgamma(__x)\n+                / std::_GLIBCXX_TR1::tgamma(__x + __y);\n+          __bet *= std::_GLIBCXX_TR1::tgamma(__y);\n+        }\n+      else\n+        {\n+          __bet = std::_GLIBCXX_TR1::tgamma(__y)\n+                / std::_GLIBCXX_TR1::tgamma(__x + __y);\n+          __bet *= std::_GLIBCXX_TR1::tgamma(__x);\n+        }\n+#else\n+      if (__x > __y)\n+        {\n+          __bet = __gamma(__x) / __gamma(__x + __y);\n+          __bet *= __gamma(__y);\n+        }\n+      else\n+        {\n+          __bet = __gamma(__y) / __gamma(__x + __y);\n+          __bet *= __gamma(__x);\n+        }\n+#endif\n+\n+      return __bet;\n+    }\n+\n+    /**\n+     *   @brief  Return the beta function \\f$B(x,y)\\f$ using\n+     *           the log gamma functions.\n+     * \n+     *   The beta function is defined by\n+     *   @f[\n+     *     B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}\n+     *   @f]\n+     *\n+     *   @param __x The first argument of the beta function.\n+     *   @param __y The second argument of the beta function.\n+     *   @return  The beta function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __beta_lgamma(_Tp __x, _Tp __y)\n+    {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      _Tp __bet = std::_GLIBCXX_TR1::lgamma(__x)\n+                + std::_GLIBCXX_TR1::lgamma(__y)\n+                - std::_GLIBCXX_TR1::lgamma(__x + __y);\n+#else\n+      _Tp __bet = __log_gamma(__x)\n+                + __log_gamma(__y)\n+                - __log_gamma(__x + __y);\n+#endif\n+      __bet = std::exp(__bet);\n+      return __bet;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the beta function \\f$B(x,y)\\f$ using\n+     *           the product form.\n+     * \n+     *   The beta function is defined by\n+     *   @f[\n+     *     B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}\n+     *   @f]\n+     *\n+     *   @param __x The first argument of the beta function.\n+     *   @param __y The second argument of the beta function.\n+     *   @return  The beta function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __beta_product(_Tp __x, _Tp __y)\n+    {\n+\n+      _Tp __bet = (__x + __y) / (__x * __y);\n+\n+      unsigned int __max_iter = 1000000;\n+      for (unsigned int __k = 1; __k < __max_iter; ++__k)\n+        {\n+          _Tp __term = (_Tp(1) + (__x + __y) / __k)\n+                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));\n+          __bet *= __term;\n+        }\n+\n+      return __bet;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the beta function \\f$ B(x,y) \\f$.\n+     * \n+     *   The beta function is defined by\n+     *   @f[\n+     *     B(x,y) = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}\n+     *   @f]\n+     *\n+     *   @param __x The first argument of the beta function.\n+     *   @param __y The second argument of the beta function.\n+     *   @return  The beta function.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __beta(_Tp __x, _Tp __y)\n+    {\n+      if (__isnan(__x) || __isnan(__y))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        return __beta_lgamma(__x, __y);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_BETA_FUNCTION_TCC"}, {"sha": "b07add26156a4efe9af45948e60b3e29220c4216", "filename": "libstdc++-v3/include/tr1/cmath", "status": "modified", "additions": 468, "deletions": 1, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcmath?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -1,6 +1,6 @@\n // TR1 cmath -*- C++ -*-\n \n-// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -35,6 +35,7 @@\n #define _TR1_CMATH 1\n \n #include <bits/c++config.h>\n+#include <algorithm>\n #include <cmath>\n #include <tr1/common.h>\n \n@@ -937,6 +938,472 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n #endif\n \n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+  /**\n+   * @defgroup tr1_math_spec_func Mathematical Special Functions\n+   * A collection of advanced mathematical special functions.\n+   * @{\n+   */\n+\n+#include <tr1/gamma.tcc>\n+#include <tr1/bessel_function.tcc>\n+#include <tr1/beta_function.tcc>\n+#include <tr1/ell_integral.tcc>\n+#include <tr1/exp_integral.tcc>\n+#include <tr1/hypergeometric.tcc>\n+#include <tr1/legendre_function.tcc>\n+#include <tr1/modified_bessel_func.tcc>\n+#include <tr1/poly_hermite.tcc>\n+#include <tr1/poly_laguerre.tcc>\n+#include <tr1/riemann_zeta.tcc>\n+\n+// namespace std::tr1\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  //  5.2.1.1  Associated Laguerre polynomials.\n+\n+  inline float\n+  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)\n+  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }\n+\n+  inline long double\n+  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)\n+  {\n+    return __detail::__assoc_laguerre<long double>(__n, __m, __x);\n+  }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__assoc_laguerre<__type>(__n, __m, __x);\n+    }\n+\n+\n+  //  5.2.1.2  Associated Legendre functions.\n+\n+  inline float\n+  assoc_legendref(unsigned int __l, unsigned int __m, float __x)\n+  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }\n+\n+  inline long double\n+  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)\n+  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);\n+    }\n+\n+\n+  //  5.2.1.3  Beta functions.\n+\n+  inline float\n+  betaf(float __x, float __y)\n+  { return __detail::__beta<float>(__x, __y); }\n+\n+  inline long double\n+  betal(long double __x, long double __y)\n+  { return __detail::__beta<long double>(__x, __y); }\n+\n+  template<typename _Tpx, typename _Tpy>\n+    inline typename __promote_2<_Tpx, _Tpy>::__type\n+    beta(_Tpx __x, _Tpy __y)\n+    {\n+      typedef typename __promote_2<_Tpx, _Tpy>::__type __type;\n+      return __detail::__beta<__type>(__x, __y);\n+    }\n+\n+\n+  //  5.2.1.4  Complete elliptic interals of the first kind.\n+\n+  inline float\n+  comp_ellint_1f(float __k)\n+  { return __detail::__comp_ellint_1<float>(__k); }\n+\n+  inline long double\n+  comp_ellint_1l(long double __k)\n+  { return __detail::__comp_ellint_1<long double>(__k); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    comp_ellint_1(_Tp __k)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__comp_ellint_1<__type>(__k);\n+    }\n+\n+\n+  //  5.2.1.5  Complete elliptic interals of the second kind.\n+\n+  inline float\n+  comp_ellint_2f(float __k)\n+  { return __detail::__comp_ellint_2<float>(__k); }\n+\n+  inline long double\n+  comp_ellint_2l(long double __k)\n+  { return __detail::__comp_ellint_2<long double>(__k); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    comp_ellint_2(_Tp __k)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__comp_ellint_2<__type>(__k);\n+    }\n+\n+\n+  //  5.2.1.6  Complete elliptic interals of the third kind.\n+\n+  inline float\n+  comp_ellint_3f(float __k, float __nu)\n+  { return __detail::__comp_ellint_3<float>(__k, __nu); }\n+\n+  inline long double\n+  comp_ellint_3l(long double __k, long double __nu)\n+  { return __detail::__comp_ellint_3<long double>(__k, __nu); }\n+\n+  template<typename _Tp, typename _Tpn>\n+    inline typename __promote_2<_Tp, _Tpn>::__type\n+    comp_ellint_3(_Tp __k, _Tpn __nu)\n+    {\n+      typedef typename __promote_2<_Tp, _Tpn>::__type __type;\n+      return __detail::__comp_ellint_3<__type>(__k, __nu);\n+    }\n+\n+\n+  //  5.2.1.7  Confluent hypergeometric functions.\n+\n+  inline float\n+  conf_hypergf(float __a, float __c, float __x)\n+  { return __detail::__conf_hyperg<float>(__a, __c, __x); }\n+\n+  inline long double\n+  conf_hypergl(long double __a, long double __c, long double __x)\n+  { return __detail::__conf_hyperg<long double>(__a, __c, __x); }\n+\n+  template<typename _Tpa, typename _Tpc, typename _Tp>\n+    inline typename __promote_3<_Tpa, _Tpc, _Tp>::__type\n+    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)\n+    {\n+      typedef typename __promote_3<_Tpa, _Tpc, _Tp>::__type __type;\n+      return __detail::__conf_hyperg<__type>(__a, __c, __x);\n+    }\n+\n+\n+  //  5.2.1.8  Regular modified cylindrical Bessel functions.\n+\n+  inline float\n+  cyl_bessel_if(float __nu, float __x)\n+  { return __detail::__cyl_bessel_i<float>(__nu, __x); }\n+\n+  inline long double\n+  cyl_bessel_il(long double __nu, long double __x)\n+  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }\n+\n+  template<typename _Tpnu, typename _Tp>\n+    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    cyl_bessel_i(_Tpnu __nu, _Tp __x)\n+    {\n+      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      return __detail::__cyl_bessel_i<__type>(__nu, __x);\n+    }\n+\n+\n+  //  5.2.1.9  Cylindrical Bessel functions (of the first kind).\n+\n+  inline float\n+  cyl_bessel_jf(float __nu, float __x)\n+  { return __detail::__cyl_bessel_j<float>(__nu, __x); }\n+\n+  inline long double\n+  cyl_bessel_jl(long double __nu, long double __x)\n+  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }\n+\n+  template<typename _Tpnu, typename _Tp>\n+    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    cyl_bessel_j(_Tpnu __nu, _Tp __x)\n+    {\n+      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      return __detail::__cyl_bessel_j<__type>(__nu, __x);\n+    }\n+\n+\n+  //  5.2.1.10  Irregular modified cylindrical Bessel functions.\n+\n+  inline float\n+  cyl_bessel_kf(float __nu, float __x)\n+  { return __detail::__cyl_bessel_k<float>(__nu, __x); }\n+\n+  inline long double\n+  cyl_bessel_kl(long double __nu, long double __x)\n+  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }\n+\n+  template<typename _Tpnu, typename _Tp>\n+    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    cyl_bessel_k(_Tpnu __nu, _Tp __x)\n+    {\n+      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      return __detail::__cyl_bessel_k<__type>(__nu, __x);\n+    }\n+\n+\n+  //  5.2.1.11  Cylindrical Neumann functions.\n+\n+  inline float\n+  cyl_neumannf(float __nu, float __x)\n+  { return __detail::__cyl_neumann_n<float>(__nu, __x); }\n+\n+  inline long double\n+  cyl_neumannl(long double __nu, long double __x)\n+  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }\n+\n+  template<typename _Tpnu, typename _Tp>\n+    inline typename __promote_2<_Tpnu, _Tp>::__type\n+    cyl_neumann(_Tpnu __nu, _Tp __x)\n+    {\n+      typedef typename __promote_2<_Tpnu, _Tp>::__type __type;\n+      return __detail::__cyl_neumann_n<__type>(__nu, __x);\n+    }\n+\n+\n+  //  5.2.1.12  Incomplete elliptic interals of the first kind.\n+\n+  inline float\n+  ellint_1f(float __k, float __phi)\n+  { return __detail::__ellint_1<float>(__k, __phi); }\n+\n+  inline long double\n+  ellint_1l(long double __k, long double __phi)\n+  { return __detail::__ellint_1<long double>(__k, __phi); }\n+\n+  template<typename _Tp, typename _Tpp>\n+    inline typename __promote_2<_Tp, _Tpp>::__type\n+    ellint_1(_Tp __k, _Tpp __phi)\n+    {\n+      typedef typename __promote_2<_Tp, _Tpp>::__type __type;\n+      return __detail::__ellint_1<__type>(__k, __phi);\n+    }\n+\n+\n+  //  5.2.1.13  Incomplete elliptic interals of the second kind.\n+\n+  inline float\n+  ellint_2f(float __k, float __phi)\n+  { return __detail::__ellint_2<float>(__k, __phi); }\n+\n+  inline long double\n+  ellint_2l(long double __k, long double __phi)\n+  { return __detail::__ellint_2<long double>(__k, __phi); }\n+\n+  template<typename _Tp, typename _Tpp>\n+    inline typename __promote_2<_Tp, _Tpp>::__type\n+    ellint_2(_Tp __k, _Tpp __phi)\n+    {\n+      typedef typename __promote_2<_Tp, _Tpp>::__type __type;\n+      return __detail::__ellint_2<__type>(__k, __phi);\n+    }\n+\n+\n+  //  5.2.1.14  Incomplete elliptic interals of the third kind.\n+\n+  inline float\n+  ellint_3f(float __k, float __nu, float __phi)\n+  { return __detail::__ellint_3<float>(__k, __nu, __phi); }\n+\n+  inline long double\n+  ellint_3l(long double __k, long double __nu, long double __phi)\n+  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }\n+\n+  template<typename _Tp, typename _Tpn, typename _Tpp>\n+    inline typename __promote_3<_Tp, _Tpn, _Tpp>::__type\n+    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)\n+    {\n+      typedef typename __promote_3<_Tp, _Tpn, _Tpp>::__type __type;\n+      return __detail::__ellint_3<__type>(__k, __nu, __phi);\n+    }\n+\n+\n+  //  5.2.1.15  Exponential integrals.\n+\n+  inline float\n+  expintf(float __x)\n+  { return __detail::__expint<float>(__x); }\n+\n+  inline long double\n+  expintl(long double __x)\n+  { return __detail::__expint<long double>(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    expint(_Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__expint<__type>(__x);\n+    }\n+\n+\n+  //  5.2.1.16  Hermite polynomials.\n+\n+  inline float\n+  hermitef(unsigned int __n, float __x)\n+  { return __detail::__poly_hermite<float>(__n, __x); }\n+\n+  inline long double\n+  hermitel(unsigned int __n, long double __x)\n+  { return __detail::__poly_hermite<long double>(__n, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    hermite(unsigned int __n, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__poly_hermite<__type>(__n, __x);\n+    }\n+\n+\n+  //  5.2.1.17  Hypergeometric functions.\n+\n+  inline float\n+  hypergf(float __a, float __b, float __c, float __x)\n+  { return __detail::__hyperg<float>(__a, __b, __c, __x); }\n+\n+  inline long double\n+  hypergl(long double __a, long double __b, long double __c, long double __x)\n+  { return __detail::__hyperg<long double>(__a, __b, __c, __x); }\n+\n+  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>\n+    inline typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type\n+    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)\n+    {\n+      typedef typename __promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type __type;\n+      return __detail::__hyperg<__type>(__a, __b, __c, __x);\n+    }\n+\n+\n+  //  5.2.1.18  Laguerre polynomials.\n+\n+  inline float\n+  laguerref(unsigned int __n, float __x)\n+  { return __detail::__laguerre<float>(__n, __x); }\n+\n+  inline long double\n+  laguerrel(unsigned int __n, long double __x)\n+  { return __detail::__laguerre<long double>(__n, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    laguerre(unsigned int __n, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__laguerre<__type>(__n, __x);\n+    }\n+\n+\n+  //  5.2.1.19  Legendre polynomials.\n+\n+  inline float\n+  legendref(unsigned int __n, float __x)\n+  { return __detail::__poly_legendre_p<float>(__n, __x); }\n+\n+  inline long double\n+  legendrel(unsigned int __n, long double __x)\n+  { return __detail::__poly_legendre_p<long double>(__n, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    legendre(unsigned int __n, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__poly_legendre_p<__type>(__n, __x);\n+    }\n+\n+\n+  //  5.2.1.20  Riemann zeta function.\n+\n+  inline float\n+  riemann_zetaf(float __x)\n+  { return __detail::__riemann_zeta<float>(__x); }\n+\n+  inline long double\n+  riemann_zetal(long double __x)\n+  { return __detail::__riemann_zeta<long double>(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    riemann_zeta(_Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__riemann_zeta<__type>(__x);\n+    }\n+\n+\n+  //  5.2.1.21  Spherical Bessel functions.\n+\n+  inline float\n+  sph_besself(unsigned int __n, float __x)\n+  { return __detail::__sph_bessel<float>(__n, __x); }\n+\n+  inline long double\n+  sph_bessell(unsigned int __n, long double __x)\n+  { return __detail::__sph_bessel<long double>(__n, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    sph_bessel(unsigned int __n, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__sph_bessel<__type>(__n, __x);\n+    }\n+\n+\n+  //  5.2.1.22  Spherical associated Legendre functions.\n+\n+  inline float\n+  sph_legendref(unsigned int __l, unsigned int __m, float __theta)\n+  { return __detail::__sph_legendre<float>(__l, __m, __theta); }\n+\n+  inline long double\n+  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)\n+  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__sph_legendre<__type>(__l, __m, __theta);\n+    }\n+\n+\n+  //  5.2.1.23  Spherical Neumann functions.\n+\n+  inline float\n+  sph_neumannf(unsigned int __n, float __x)\n+  { return __detail::__sph_neumann<float>(__n, __x); }\n+\n+  inline long double\n+  sph_neumannl(unsigned int __n, long double __x)\n+  { return __detail::__sph_neumann<long double>(__n, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __promote<_Tp>::__type\n+    sph_neumann(unsigned int __n, _Tp __x)\n+    {\n+      typedef typename __promote<_Tp>::__type __type;\n+      return __detail::__sph_neumann<__type>(__n, __x);\n+    }\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n _GLIBCXX_END_NAMESPACE\n }\n "}, {"sha": "d26fdd6da5ce46f23686f1ba6d2ad48fbe4bdf9a", "filename": "libstdc++-v3/include/tr1/common.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fcommon.h?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -72,6 +72,19 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       typedef __typeof__(__type1() + __type2() + __type3()) __type;\n     };\n \n+  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>\n+    struct __promote_4\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+      typedef typename __promote<_Vp>::__type __type3;\n+      typedef typename __promote<_Wp>::__type __type4;\n+\n+    public:\n+      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;\n+    };\n+\n _GLIBCXX_END_NAMESPACE\n } // namespace std\n "}, {"sha": "2f2da376bf14fafb98c7ea50cf15c481b5cd994f", "filename": "libstdc++-v3/include/tr1/ell_integral.tcc", "status": "added", "additions": 762, "deletions": 0, "changes": 762, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fell_integral.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,762 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/ell_integral.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1)  B. C. Carlson Numer. Math. 33, 1 (1979)\n+//   (2)  B. C. Carlson, Special Functions of Applied Mathematics (1977)\n+//   (3)  The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (4)  Numerical Recipes in C, 2nd ed, by W. H. Press, S. A. Teukolsky,\n+//        W. T. Vetterling, B. P. Flannery, Cambridge University Press\n+//        (1992), pp. 261-269\n+\n+#ifndef _TR1_ELL_INTEGRAL_TCC\n+#define _TR1_ELL_INTEGRAL_TCC 1\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief Return the Carlson elliptic function @f$ R_F(x,y,z) @f$\n+     *          of the first kind.\n+     * \n+     *   The Carlson elliptic function of the first kind is defined by:\n+     *   @f[\n+     *       R_F(x,y,z) = \\frac{1}{2} \\int_0^\\infty\n+     *                 \\frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}}\n+     *   @f]\n+     *\n+     *   @param  __x  The first of three symmetric arguments.\n+     *   @param  __y  The second of three symmetric arguments.\n+     *   @param  __z  The third of three symmetric arguments.\n+     *   @return  The Carlson elliptic function of the first kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_rf(const _Tp __x, const _Tp __y, const _Tp __z)\n+    {\n+      const _Tp __min = std::numeric_limits<_Tp>::min();\n+      const _Tp __max = std::numeric_limits<_Tp>::max();\n+      const _Tp __lolim = _Tp(5) * __min;\n+      const _Tp __uplim = __max / _Tp(5);\n+\n+      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))\n+        std::__throw_domain_error(__N(\"Argument less than zero \"\n+                                      \"in __ellint_rf.\"));\n+      else if (__x + __y < __lolim || __x + __z < __lolim\n+            || __y + __z < __lolim)\n+        std::__throw_domain_error(__N(\"Argument too small in __ellint_rf\"));\n+      else\n+        {\n+          const _Tp __c0 = _Tp(1) / _Tp(4);\n+          const _Tp __c1 = _Tp(1) / _Tp(24);\n+          const _Tp __c2 = _Tp(1) / _Tp(10);\n+          const _Tp __c3 = _Tp(3) / _Tp(44);\n+          const _Tp __c4 = _Tp(1) / _Tp(14);\n+\n+          _Tp __xn = __x;\n+          _Tp __yn = __y;\n+          _Tp __zn = __z;\n+\n+          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));\n+          _Tp __mu;\n+          _Tp __xndev, __yndev, __zndev;\n+\n+          const unsigned int __max_iter = 100;\n+          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)\n+            {\n+              __mu = (__xn + __yn + __zn) / _Tp(3);\n+              __xndev = 2 - (__mu + __xn) / __mu;\n+              __yndev = 2 - (__mu + __yn) / __mu;\n+              __zndev = 2 - (__mu + __zn) / __mu;\n+              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));\n+              __epsilon = std::max(__epsilon, std::abs(__zndev));\n+              if (__epsilon < __errtol)\n+                break;\n+              const _Tp __xnroot = std::sqrt(__xn);\n+              const _Tp __ynroot = std::sqrt(__yn);\n+              const _Tp __znroot = std::sqrt(__zn);\n+              const _Tp __lambda = __xnroot * (__ynroot + __znroot)\n+                                 + __ynroot * __znroot;\n+              __xn = __c0 * (__xn + __lambda);\n+              __yn = __c0 * (__yn + __lambda);\n+              __zn = __c0 * (__zn + __lambda);\n+            }\n+\n+          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;\n+          const _Tp __e3 = __xndev * __yndev * __zndev;\n+          const _Tp __s  = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2\n+                   + __c4 * __e3;\n+\n+          return __s / std::sqrt(__mu);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the complete elliptic integral of the first kind\n+     *          @f$ K(k) @f$ by series expansion.\n+     * \n+     *   The complete elliptic integral of the first kind is defined as\n+     *   @f[\n+     *     K(k) = F(k,\\pi/2) = \\int_0^{\\pi/2}\\frac{d\\theta}\n+     *                              {\\sqrt{1 - k^2sin^2\\theta}}\n+     *   @f]\n+     * \n+     *   This routine is not bad as long as |k| is somewhat smaller than 1\n+     *   but is not is good as the Carlson elliptic integral formulation.\n+     * \n+     *   @param  __k  The argument of the complete elliptic function.\n+     *   @return  The complete elliptic function of the first kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __comp_ellint_1_series(const _Tp __k)\n+    {\n+\n+      const _Tp __kk = __k * __k;\n+\n+      _Tp __term = __kk / _Tp(4);\n+      _Tp __sum = _Tp(1) + __term;\n+\n+      const unsigned int __max_iter = 1000;\n+      for (unsigned int __i = 2; __i < __max_iter; ++__i)\n+        {\n+          __term *= (2 * __i - 1) * __kk / (2 * __i);\n+          if (__term < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __sum += __term;\n+        }\n+\n+      return __numeric_constants<_Tp>::__pi_2() * __sum;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the complete elliptic integral of the first kind\n+     *           @f$ K(k) @f$ using the Carlson formulation.\n+     * \n+     *   The complete elliptic integral of the first kind is defined as\n+     *   @f[\n+     *     K(k) = F(k,\\pi/2) = \\int_0^{\\pi/2}\\frac{d\\theta}\n+     *                                           {\\sqrt{1 - k^2 sin^2\\theta}}\n+     *   @f]\n+     *   where @f$ F(k,\\phi) @f$ is the incomplete elliptic integral of the\n+     *   first kind.\n+     * \n+     *   @param  __k  The argument of the complete elliptic function.\n+     *   @return  The complete elliptic function of the first kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __comp_ellint_1(const _Tp __k)\n+    {\n+\n+      if (__isnan(__k))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (std::abs(__k) >= _Tp(1))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the incomplete elliptic integral of the first kind\n+     *           @f$ F(k,\\phi) @f$ using the Carlson formulation.\n+     * \n+     *   The incomplete elliptic integral of the first kind is defined as\n+     *   @f[\n+     *     F(k,\\phi) = \\int_0^{\\phi}\\frac{d\\theta}\n+     *                                   {\\sqrt{1 - k^2 sin^2\\theta}}\n+     *   @f]\n+     * \n+     *   @param  __k  The argument of the elliptic function.\n+     *   @param  __phi  The integral limit argument of the elliptic function.\n+     *   @return  The elliptic function of the first kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_1(const _Tp __k, const _Tp __phi)\n+    {\n+\n+      if (__isnan(__k) || __isnan(__phi))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (std::abs(__k) > _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in __ellint_1.\"));\n+      else\n+        {\n+          //  Reduce phi to -pi/2 < phi < +pi/2.\n+          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()\n+                                   + _Tp(0.5L));\n+          const _Tp __phi_red = __phi\n+                              - __n * __numeric_constants<_Tp>::__pi();\n+\n+          const _Tp __s = std::sin(__phi_red);\n+          const _Tp __c = std::cos(__phi_red);\n+\n+          const _Tp __F = __s\n+                        * __ellint_rf(__c * __c,\n+                                _Tp(1) - __k * __k * __s * __s, _Tp(1));\n+\n+          if (__n == 0)\n+            return __F;\n+          else\n+            return __F + _Tp(2) * __n * __comp_ellint_1(__k);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the complete elliptic integral of the second kind\n+     *          @f$ E(k) @f$ by series expansion.\n+     * \n+     *   The complete elliptic integral of the second kind is defined as\n+     *   @f[\n+     *     E(k,\\pi/2) = \\int_0^{\\pi/2}\\sqrt{1 - k^2 sin^2\\theta}\n+     *   @f]\n+     * \n+     *   This routine is not bad as long as |k| is somewhat smaller than 1\n+     *   but is not is good as the Carlson elliptic integral formulation.\n+     * \n+     *   @param  __k  The argument of the complete elliptic function.\n+     *   @return  The complete elliptic function of the second kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __comp_ellint_2_series(const _Tp __k)\n+    {\n+\n+      const _Tp __kk = __k * __k;\n+\n+      _Tp __term = __kk;\n+      _Tp __sum = __term;\n+\n+      const unsigned int __max_iter = 1000;\n+      for (unsigned int __i = 2; __i < __max_iter; ++__i)\n+        {\n+          const _Tp __i2m = 2 * __i - 1;\n+          const _Tp __i2 = 2 * __i;\n+          __term *= __i2m * __i2m * __kk / (__i2 * __i2);\n+          if (__term < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __sum += __term / __i2m;\n+        }\n+\n+      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Carlson elliptic function of the second kind\n+     *           @f$ R_D(x,y,z) = R_J(x,y,z,z) @f$ where\n+     *           @f$ R_J(x,y,z,p) @f$ is the Carlson elliptic function\n+     *           of the third kind.\n+     * \n+     *   The Carlson elliptic function of the second kind is defined by:\n+     *   @f[\n+     *       R_D(x,y,z) = \\frac{3}{2} \\int_0^\\infty\n+     *                 \\frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{3/2}}\n+     *   @f]\n+     *\n+     *   Based on Carlson's algorithms:\n+     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)\n+     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)\n+     *   -  Nunerical Recipes in C, 2nd ed, pp. 261-269,\n+     *      by Press, Teukolsky, Vetterling, Flannery (1992)\n+     *\n+     *   @param  __x  The first of two symmetric arguments.\n+     *   @param  __y  The second of two symmetric arguments.\n+     *   @param  __z  The third argument.\n+     *   @return  The Carlson elliptic function of the second kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_rd(const _Tp __x, const _Tp __y, const _Tp __z)\n+    {\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));\n+      const _Tp __min = std::numeric_limits<_Tp>::min();\n+      const _Tp __max = std::numeric_limits<_Tp>::max();\n+      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));\n+      const _Tp __uplim = std::pow(_Tp(0.1L) * __errtol / __min, _Tp(2) / _Tp(3));\n+\n+      if (__x < _Tp(0) || __y < _Tp(0))\n+        std::__throw_domain_error(__N(\"Argument less than zero \"\n+                                      \"in __ellint_rd.\"));\n+      else if (__x + __y < __lolim || __z < __lolim)\n+        std::__throw_domain_error(__N(\"Argument too small \"\n+                                      \"in __ellint_rd.\"));\n+      else\n+        {\n+          const _Tp __c0 = _Tp(1) / _Tp(4);\n+          const _Tp __c1 = _Tp(3) / _Tp(14);\n+          const _Tp __c2 = _Tp(1) / _Tp(6);\n+          const _Tp __c3 = _Tp(9) / _Tp(22);\n+          const _Tp __c4 = _Tp(3) / _Tp(26);\n+\n+          _Tp __xn = __x;\n+          _Tp __yn = __y;\n+          _Tp __zn = __z;\n+          _Tp __sigma = _Tp(0);\n+          _Tp __power4 = _Tp(1);\n+\n+          _Tp __mu;\n+          _Tp __xndev, __yndev, __zndev;\n+\n+          const unsigned int __max_iter = 100;\n+          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)\n+            {\n+              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);\n+              __xndev = (__mu - __xn) / __mu;\n+              __yndev = (__mu - __yn) / __mu;\n+              __zndev = (__mu - __zn) / __mu;\n+              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));\n+              __epsilon = std::max(__epsilon, std::abs(__zndev));\n+              if (__epsilon < __errtol)\n+                break;\n+              _Tp __xnroot = std::sqrt(__xn);\n+              _Tp __ynroot = std::sqrt(__yn);\n+              _Tp __znroot = std::sqrt(__zn);\n+              _Tp __lambda = __xnroot * (__ynroot + __znroot)\n+                           + __ynroot * __znroot;\n+              __sigma += __power4 / (__znroot * (__zn + __lambda));\n+              __power4 *= __c0;\n+              __xn = __c0 * (__xn + __lambda);\n+              __yn = __c0 * (__yn + __lambda);\n+              __zn = __c0 * (__zn + __lambda);\n+            }\n+\n+          _Tp __ea = __xndev * __yndev;\n+          _Tp __eb = __zndev * __zndev;\n+          _Tp __ec = __ea - __eb;\n+          _Tp __ed = __ea - _Tp(6) * __eb;\n+          _Tp __ef = __ed + __ec + __ec;\n+          _Tp __s1 = __ed * (-__c1 + __c3 * __ed\n+                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef\n+                                   / _Tp(2));\n+          _Tp __s2 = __zndev\n+                   * (__c2 * __ef\n+                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));\n+\n+          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)\n+                                        / (__mu * std::sqrt(__mu));\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the complete elliptic integral of the second kind\n+     *           @f$ E(k) @f$ using the Carlson formulation.\n+     * \n+     *   The complete elliptic integral of the second kind is defined as\n+     *   @f[\n+     *     E(k,\\pi/2) = \\int_0^{\\pi/2}\\sqrt{1 - k^2 sin^2\\theta}\n+     *   @f]\n+     * \n+     *   @param  __k  The argument of the complete elliptic function.\n+     *   @return  The complete elliptic function of the second kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __comp_ellint_2(const _Tp __k)\n+    {\n+\n+      if (__isnan(__k))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (std::abs(__k) == 1)\n+        return _Tp(1);\n+      else if (std::abs(__k) > _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in __comp_ellint_2.\"));\n+      else\n+        {\n+          const _Tp __kk = __k * __k;\n+\n+          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))\n+               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the incomplete elliptic integral of the second kind\n+     *           @f$ E(k,\\phi) @f$ using the Carlson formulation.\n+     * \n+     *   The incomplete elliptic integral of the second kind is defined as\n+     *   @f[\n+     *     E(k,\\phi) = \\int_0^{\\phi} \\sqrt{1 - k^2 sin^2\\theta}\n+     *   @f]\n+     * \n+     *   @param  __k  The argument of the elliptic function.\n+     *   @param  __phi  The integral limit argument of the elliptic function.\n+     *   @return  The elliptic function of the second kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_2(const _Tp __k, const _Tp __phi)\n+    {\n+\n+      if (__isnan(__k) || __isnan(__phi))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (std::abs(__k) > _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in __ellint_2.\"));\n+      else\n+        {\n+          //  Reduce phi to -pi/2 < phi < +pi/2.\n+          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()\n+                                   + _Tp(0.5L));\n+          const _Tp __phi_red = __phi\n+                              - __n * __numeric_constants<_Tp>::__pi();\n+\n+          const _Tp __kk = __k * __k;\n+          const _Tp __s = std::sin(__phi_red);\n+          const _Tp __ss = __s * __s;\n+          const _Tp __sss = __ss * __s;\n+          const _Tp __c = std::cos(__phi_red);\n+          const _Tp __cc = __c * __c;\n+\n+          const _Tp __E = __s\n+                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))\n+                        - __kk * __sss\n+                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))\n+                        / _Tp(3);\n+\n+          if (__n == 0)\n+            return __E;\n+          else\n+            return __E + _Tp(2) * __n * __comp_ellint_2(__k);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Carlson elliptic function\n+     *           @f$ R_C(x,y) = R_F(x,y,y) @f$ where @f$ R_F(x,y,z) @f$\n+     *           is the Carlson elliptic function of the first kind.\n+     * \n+     *   The Carlson elliptic function is defined by:\n+     *   @f[\n+     *       R_C(x,y) = \\frac{1}{2} \\int_0^\\infty\n+     *                 \\frac{dt}{(t + x)^{1/2}(t + y)}\n+     *   @f]\n+     *\n+     *   Based on Carlson's algorithms:\n+     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)\n+     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)\n+     *   -  Nunerical Recipes in C, 2nd ed, pp. 261-269,\n+     *      by Press, Teukolsky, Vetterling, Flannery (1992)\n+     *\n+     *   @param  __x  The first argument.\n+     *   @param  __y  The second argument.\n+     *   @return  The Carlson elliptic function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_rc(const _Tp __x, const _Tp __y)\n+    {\n+      const _Tp __min = std::numeric_limits<_Tp>::min();\n+      const _Tp __max = std::numeric_limits<_Tp>::max();\n+      const _Tp __lolim = _Tp(5) * __min;\n+      const _Tp __uplim = __max / _Tp(5);\n+\n+      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)\n+        std::__throw_domain_error(__N(\"Argument less than zero \"\n+                                      \"in __ellint_rc.\"));\n+      else\n+        {\n+          const _Tp __c0 = _Tp(1) / _Tp(4);\n+          const _Tp __c1 = _Tp(1) / _Tp(7);\n+          const _Tp __c2 = _Tp(9) / _Tp(22);\n+          const _Tp __c3 = _Tp(3) / _Tp(10);\n+          const _Tp __c4 = _Tp(3) / _Tp(8);\n+\n+          _Tp __xn = __x;\n+          _Tp __yn = __y;\n+\n+          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));\n+          _Tp __mu;\n+          _Tp __sn;\n+\n+          const unsigned int __max_iter = 100;\n+          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)\n+            {\n+              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);\n+              __sn = (__yn + __mu) / __mu - _Tp(2);\n+              if (std::abs(__sn) < __errtol)\n+                break;\n+              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)\n+                             + __yn;\n+              __xn = __c0 * (__xn + __lambda);\n+              __yn = __c0 * (__yn + __lambda);\n+            }\n+\n+          _Tp __s = __sn * __sn\n+                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));\n+\n+          return (_Tp(1) + __s) / std::sqrt(__mu);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Carlson elliptic function @f$ R_J(x,y,z,p) @f$\n+     *           of the third kind.\n+     * \n+     *   The Carlson elliptic function of the third kind is defined by:\n+     *   @f[\n+     *       R_J(x,y,z,p) = \\frac{3}{2} \\int_0^\\infty\n+     *       \\frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}(t + p)}\n+     *   @f]\n+     *\n+     *   Based on Carlson's algorithms:\n+     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)\n+     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)\n+     *   -  Nunerical Recipes in C, 2nd ed, pp. 261-269,\n+     *      by Press, Teukolsky, Vetterling, Flannery (1992)\n+     *\n+     *   @param  __x  The first of three symmetric arguments.\n+     *   @param  __y  The second of three symmetric arguments.\n+     *   @param  __z  The third of three symmetric arguments.\n+     *   @param  __p  The fourth argument.\n+     *   @return  The Carlson elliptic function of the fourth kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_rj(const _Tp __x, const _Tp __y, const _Tp __z, const _Tp __p)\n+    {\n+      const _Tp __min = std::numeric_limits<_Tp>::min();\n+      const _Tp __max = std::numeric_limits<_Tp>::max();\n+      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));\n+      const _Tp __uplim = _Tp(0.3L)\n+                        * std::pow(_Tp(0.2L) * __max, _Tp(1)/_Tp(3));\n+\n+      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))\n+        std::__throw_domain_error(__N(\"Argument less than zero \"\n+                                      \"in __ellint_rj.\"));\n+      else if (__x + __y < __lolim || __x + __z < __lolim\n+            || __y + __z < __lolim || __p < __lolim)\n+        std::__throw_domain_error(__N(\"Argument too small \"\n+                                      \"in __ellint_rj\"));\n+      else\n+        {\n+          const _Tp __c0 = _Tp(1) / _Tp(4);\n+          const _Tp __c1 = _Tp(3) / _Tp(14);\n+          const _Tp __c2 = _Tp(1) / _Tp(3);\n+          const _Tp __c3 = _Tp(3) / _Tp(22);\n+          const _Tp __c4 = _Tp(3) / _Tp(26);\n+\n+          _Tp __xn = __x;\n+          _Tp __yn = __y;\n+          _Tp __zn = __z;\n+          _Tp __pn = __p;\n+          _Tp __sigma = _Tp(0);\n+          _Tp __power4 = _Tp(1);\n+\n+          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));\n+\n+          _Tp __lambda, __mu;\n+          _Tp __xndev, __yndev, __zndev, __pndev;\n+\n+          const unsigned int __max_iter = 100;\n+          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)\n+            {\n+              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);\n+              __xndev = (__mu - __xn) / __mu;\n+              __yndev = (__mu - __yn) / __mu;\n+              __zndev = (__mu - __zn) / __mu;\n+              __pndev = (__mu - __pn) / __mu;\n+              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));\n+              __epsilon = std::max(__epsilon, std::abs(__zndev));\n+              __epsilon = std::max(__epsilon, std::abs(__pndev));\n+              if (__epsilon < __errtol)\n+                break;\n+              const _Tp __xnroot = std::sqrt(__xn);\n+              const _Tp __ynroot = std::sqrt(__yn);\n+              const _Tp __znroot = std::sqrt(__zn);\n+              const _Tp __lambda = __xnroot * (__ynroot + __znroot)\n+                                 + __ynroot * __znroot;\n+              const _Tp __alpha = __pn * (__xnroot + __ynroot + __znroot)\n+                                + __xnroot * __ynroot * __znroot;\n+              const _Tp __alpha2 = __alpha * __alpha;\n+              const _Tp __beta = __pn * (__pn + __lambda)\n+                                      * (__pn + __lambda);\n+              __sigma += __power4 * __ellint_rc(__alpha2, __beta);\n+              __power4 *= __c0;\n+              __xn = __c0 * (__xn + __lambda);\n+              __yn = __c0 * (__yn + __lambda);\n+              __zn = __c0 * (__zn + __lambda);\n+              __pn = __c0 * (__pn + __lambda);\n+            }\n+\n+          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;\n+          _Tp __eb = __xndev * __yndev * __zndev;\n+          _Tp __ec = __pndev * __pndev;\n+          _Tp __e2 = __ea - _Tp(3) * __ec;\n+          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);\n+          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)\n+                            - _Tp(3) * __c4 * __e3 / _Tp(2));\n+          _Tp __s2 = __eb * (__c2 / _Tp(2)\n+                   + __pndev * (-__c3 - __c3 + __pndev * __c4));\n+          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)\n+                   - __c2 * __pndev * __ec;\n+\n+          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)\n+                                             / (__mu * std::sqrt(__mu));\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the complete elliptic integral of the third kind\n+     *          @f$ \\Pi(k,\\nu) = \\Pi(k,\\nu,\\pi/2) @f$ using the\n+     *          Carlson formulation.\n+     * \n+     *   The complete elliptic integral of the third kind is defined as\n+     *   @f[\n+     *     \\Pi(k,\\nu) = \\int_0^{\\pi/2}\n+     *                   \\frac{d\\theta}\n+     *                 {(1 - \\nu \\sin^2\\theta)\\sqrt{1 - k^2 \\sin^2\\theta}}\n+     *   @f]\n+     * \n+     *   @param  __k  The argument of the elliptic function.\n+     *   @param  __nu  The second argument of the elliptic function.\n+     *   @return  The complete elliptic function of the third kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __comp_ellint_3(const _Tp __k, const _Tp __nu)\n+    {\n+\n+      if (__isnan(__k) || __isnan(__nu))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__nu == _Tp(1))\n+        return std::numeric_limits<_Tp>::infinity();\n+      else if (std::abs(__k) > _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in __comp_ellint_3.\"));\n+      else\n+        {\n+          const _Tp __kk = __k * __k;\n+\n+          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))\n+               - __nu\n+               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) + __nu)\n+               / _Tp(3);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the incomplete elliptic integral of the third kind\n+     *          @f$ \\Pi(k,\\nu,\\phi) @f$ using the Carlson formulation.\n+     * \n+     *   The incomplete elliptic integral of the third kind is defined as\n+     *   @f[\n+     *     \\Pi(k,\\nu,\\phi) = \\int_0^{\\phi}\n+     *                       \\frac{d\\theta}\n+     *                            {(1 - \\nu \\sin^2\\theta)\n+     *                             \\sqrt{1 - k^2 \\sin^2\\theta}}\n+     *   @f]\n+     * \n+     *   @param  __k  The argument of the elliptic function.\n+     *   @param  __nu  The second argument of the elliptic function.\n+     *   @param  __phi  The integral limit argument of the elliptic function.\n+     *   @return  The elliptic function of the third kind.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __ellint_3(const _Tp __k, const _Tp __nu, const _Tp __phi)\n+    {\n+\n+      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (std::abs(__k) > _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in __ellint_3.\"));\n+      else\n+        {\n+          //  Reduce phi to -pi/2 < phi < +pi/2.\n+          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()\n+                                   + _Tp(0.5L));\n+          const _Tp __phi_red = __phi\n+                              - __n * __numeric_constants<_Tp>::__pi();\n+\n+          const _Tp __kk = __k * __k;\n+          const _Tp __s = std::sin(__phi_red);\n+          const _Tp __ss = __s * __s;\n+          const _Tp __sss = __ss * __s;\n+          const _Tp __c = std::cos(__phi_red);\n+          const _Tp __cc = __c * __c;\n+\n+          const _Tp __Pi = __s\n+                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))\n+                         - __nu * __sss\n+                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),\n+                                       _Tp(1) + __nu * __ss) / _Tp(3);\n+\n+          if (__n == 0)\n+            return __Pi;\n+          else\n+            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);\n+        }\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_ELL_INTEGRAL_TCC\n+"}, {"sha": "d6acc72dba1635ac149f682b3f382c65f9b44889", "filename": "libstdc++-v3/include/tr1/exp_integral.tcc", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fexp_integral.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,538 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/exp_integral.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+//  Written by Edward Smith-Rowland based on:\n+//\n+//   (1) Handbook of Mathematical Functions,\n+//       Ed. by Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications, New-York, Section 5, pp. 228-251.\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 222-225.\n+//\n+\n+#ifndef _TR1_EXP_INTEGRAL_TCC\n+#define _TR1_EXP_INTEGRAL_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_1(x) @f$\n+     *          by series summation.  This should be good\n+     *          for @f$ x < 1 @f$.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_1(x) = \\int_{1}^{\\infty} \\frac{e^{-xt}}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_E1_series(const _Tp __x)\n+    {\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      _Tp __term = _Tp(1);\n+      _Tp __esum = _Tp(0);\n+      _Tp __osum = _Tp(0);\n+      const unsigned int __max_iter = 100;\n+      for (unsigned int __i = 1; __i < __max_iter; ++__i)\n+        {\n+          __term *= - __x / __i;\n+          if (std::abs(__term) < __eps)\n+            break;\n+          if (__term >= _Tp(0))\n+            __esum += __term / __i;\n+          else\n+            __osum += __term / __i;\n+        }\n+\n+      return - __esum - __osum\n+             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_1(x) @f$\n+     *          by asymptotic expansion.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_1(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_E1_asymp(const _Tp __x)\n+    {\n+      _Tp __term = _Tp(1);\n+      _Tp __esum = _Tp(1);\n+      _Tp __osum = _Tp(0);\n+      const unsigned int __max_iter = 1000;\n+      for (unsigned int __i = 1; __i < __max_iter; ++__i)\n+        {\n+          _Tp __prev = __term;\n+          __term *= - __i / __x;\n+          if (std::abs(__term) > std::abs(__prev))\n+            break;\n+          if (__term >= _Tp(0))\n+            __esum += __term;\n+          else\n+            __osum += __term;\n+        }\n+\n+      return std::exp(- __x) * (__esum + __osum) / __x;\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$\n+     *          by series summation.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_En_series(const unsigned int __n, const _Tp __x)\n+    {\n+      const unsigned int __max_iter = 100;\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const int __nm1 = __n - 1;\n+      _Tp __ans = (__nm1 != 0\n+                ? _Tp(1) / __nm1 : -std::log(__x)\n+                                   - __numeric_constants<_Tp>::__gamma_e());\n+      _Tp __fact = _Tp(1);\n+      for (int __i = 1; __i <= __max_iter; ++__i)\n+        {\n+          __fact *= -__x / _Tp(__i);\n+          _Tp __del;\n+          if ( __i != __nm1 )\n+            __del = -__fact / _Tp(__i - __nm1);\n+          else\n+            {\n+              _Tp __psi = -_TR1_GAMMA_TCC;\n+              for (int __ii = 1; __ii <= __nm1; ++__ii)\n+                __psi += _Tp(1) / _Tp(__ii);\n+              __del = __fact * (__psi - std::log(__x)); \n+            }\n+          __ans += __del;\n+          if (std::abs(__del) < __eps * std::abs(__ans))\n+            return __ans;\n+        }\n+      std::__throw_runtime_error(__N(\"Series summation failed \"\n+                                     \"in __expint_En_series.\"));\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$\n+     *          by continued fractions.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_En_cont_frac(const unsigned int __n, const _Tp __x)\n+    {\n+      const unsigned int __max_iter = 100;\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __fp_min = std::numeric_limits<_Tp>::min();\n+      const int __nm1 = __n - 1;\n+      _Tp __b = __x + _Tp(__n);\n+      _Tp __c = _Tp(1) / __fp_min;\n+      _Tp __d = _Tp(1) / __b;\n+      _Tp __h = __d;\n+      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )\n+        {\n+          _Tp __a = -_Tp(__i * (__nm1 + __i));\n+          __b += _Tp(2);\n+          __d = _Tp(1) / (__a * __d + __b);\n+          __c = __b + __a / __c;\n+          const _Tp __del = __c * __d;\n+          __h *= __del;\n+          if (std::abs(__del - _Tp(1)) < __eps)\n+            {\n+              const _Tp __ans = __h * std::exp(-__x);\n+              return __ans;\n+            }\n+        }\n+      std::__throw_runtime_error(__N(\"Continued fraction failed \"\n+                                     \"in __expint_En_cont_frac.\"));\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$\n+     *          by recursion.  Use upward recursion for @f$ x < n @f$\n+     *          and downward recursion (Miller's algorithm) otherwise.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_En_recursion(const unsigned int __n, const _Tp __x)\n+    {\n+      _Tp __En;\n+      _Tp __E1 = __expint_E1(__x);\n+      if (__x < _Tp(__n))\n+        {\n+          //  Forward recursion is stable only for n < x.\n+          __En = __E1;\n+          for (unsigned int __j = 2; __j < __n; ++__j)\n+            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);\n+        }\n+      else\n+        {\n+          //  Backward recursion is stable only for n >= x.\n+          __En = _Tp(1);\n+          const int __N = __n + 20;  //  TODO: Check this starting number.\n+          _Tp __save = _Tp(0);\n+          for (int __j = __N; __j > 0; --__j)\n+            {\n+              __En = (std::exp(-__x) - __j * __En) / __x;\n+              if (__j == __n)\n+                __save = __En;\n+            }\n+            _Tp __norm = __En / __E1;\n+            __En /= __norm;\n+        }\n+\n+      return __En;\n+    }\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ Ei(x) @f$\n+     *          by series summation.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            Ei(x) = -\\int_{-x}^\\infty \\frac{e^t}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_Ei_series(const _Tp __x)\n+    {\n+      _Tp __term = _Tp(1);\n+      _Tp __sum = _Tp(0);\n+      const unsigned int __max_iter = 1000;\n+      for (unsigned int __i = 1; __i < __max_iter; ++__i)\n+        {\n+          __term *= __x / __i;\n+          __sum += __term / __i;\n+          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)\n+            break;\n+        }\n+\n+      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ Ei(x) @f$\n+     *          by asymptotic expansion.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            Ei(x) = -\\int_{-x}^\\infty \\frac{e^t}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_Ei_asymp(const _Tp __x)\n+    {\n+      _Tp __term = _Tp(1);\n+      _Tp __sum = _Tp(1);\n+      const unsigned int __max_iter = 1000;\n+      for (unsigned int __i = 1; __i < __max_iter; ++__i)\n+        {\n+          _Tp __prev = __term;\n+          __term *= __i / __x;\n+          if (__term < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          if (__term >= __prev)\n+            break;\n+          __sum += __term;\n+        }\n+\n+      return std::exp(__x) * __sum / __x;\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ Ei(x) @f$.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            Ei(x) = -\\int_{-x}^\\infty \\frac{e^t}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_Ei(const _Tp __x)\n+    {\n+      if (__x < _Tp(0))\n+        return -__expint_E1(-__x);\n+      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))\n+        return __expint_Ei_series(__x);\n+      else\n+        return __expint_Ei_asymp(__x);\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_1(x) @f$.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_1(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t} dt\n+     *          \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_E1(const _Tp __x)\n+    {\n+      if (__x < _Tp(0))\n+        return -__expint_Ei(-__x);\n+      else if (__x < _Tp(1))\n+        return __expint_E1_series(__x);\n+      else if (__x < _Tp(100))  //  TODO: Find a good asymptotic switch point.\n+        return __expint_En_cont_frac(1, __x);\n+      else\n+        return __expint_E1_asymp(__x);\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$\n+     *          for large argument.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     * \n+     *   This is something of an extension.\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_asymp(const unsigned int __n, const _Tp __x)\n+    {\n+      _Tp __term = _Tp(1);\n+      _Tp __sum = _Tp(1);\n+      for (unsigned int __i = 1; __i <= __n; ++__i)\n+        {\n+          _Tp __prev = __term;\n+          __term *= -(__n - __i + 1) / __x;\n+          if (std::abs(__term) > std::abs(__prev))\n+            break;\n+          __sum += __term;\n+        }\n+\n+      return std::exp(-__x) * __sum / __x;\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$\n+     *          for large order.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     *        \n+     *   This is something of an extension.\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint_large_n(const unsigned int __n, const _Tp __x)\n+    {\n+      const _Tp __xpn = __x + __n;\n+      const _Tp __xpn2 = __xpn * __xpn;\n+      _Tp __term = _Tp(1);\n+      _Tp __sum = _Tp(1);\n+      for (unsigned int __i = 1; __i <= __n; ++__i)\n+        {\n+          _Tp __prev = __term;\n+          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;\n+          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __sum += __term;\n+        }\n+\n+      return std::exp(-__x) * __sum / __xpn;\n+    }\n+\n+\n+    /**\n+     *   @brief Return the exponential integral @f$ E_n(x) @f$.\n+     * \n+     *   The exponential integral is given by\n+     *          \\f[\n+     *            E_n(x) = \\int_{1}^\\infty \\frac{e^{-xt}}{t^n} dt\n+     *          \\f]\n+     *   This is something of an extension.\n+     * \n+     *   @param  __n  The order of the exponential integral function.\n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __expint(const unsigned int __n, const _Tp __x)\n+    {\n+      //  Return NaN on NaN input.\n+      if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__n <= 1 && __x == _Tp(0))\n+        return std::numeric_limits<_Tp>::infinity();\n+      else\n+        {\n+          _Tp __E0 = std::exp(__x) / __x;\n+          if (__n == 0)\n+            return __E0;\n+\n+          _Tp __E1 = __expint_E1(__x);\n+          if (__n == 1)\n+            return __E1;\n+\n+          if (__x == _Tp(0))\n+            return _Tp(1) / static_cast<_Tp>(__n - 1);\n+\n+          _Tp __En = __expint_En_recursion(__n, __x);\n+\n+          return __En;\n+        }\n+    }\n+\n+\n+    /**\n+     *   The exponential integral @f$ Ei(x) @f$.\n+     * \n+     *   The exponential integral is given by\n+     *   \\f[\n+     *     Ei(x) = -\\int_{-x}^\\infty \\frac{e^t}{t} dt\n+     *   \\f]\n+     * \n+     *   @param  __x  The argument of the exponential integral function.\n+     *   @return  The exponential integral.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __expint(const _Tp __x)\n+    {\n+      if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        return __expint_Ei(__x);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_EXP_INTEGRAL_TCC"}, {"sha": "407bafcaf9c9ea210f045f533ed7dc5b2a825b9a", "filename": "libstdc++-v3/include/tr1/gamma.tcc", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fgamma.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,486 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/gamma.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 6, pp. 253-266\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 213-216\n+//   (4) Gamma, Exploring Euler's Constant, Julian Havil,\n+//       Princeton, 2003.\n+\n+#ifndef _TR1_GAMMA_TCC\n+#define _TR1_GAMMA_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief This returns Bernoulli numbers from a table or by summation\n+     *          for larger values.\n+     *\n+     *   Recursion is unstable.\n+     *\n+     *   @param __n the order n of the Bernoulli number.\n+     *   @return  The Bernoulli number of order n.\n+     */\n+    template <typename _Tp>\n+    _Tp __bernoulli_series(unsigned int __n)\n+    {\n+\n+      static const _Tp __num[28] = {\n+        _Tp(1UL),                        -_Tp(1UL) / _Tp(2UL),\n+        _Tp(1UL) / _Tp(6UL),             _Tp(0UL),\n+        -_Tp(1UL) / _Tp(30UL),           _Tp(0UL),\n+        _Tp(1UL) / _Tp(42UL),            _Tp(0UL),\n+        -_Tp(1UL) / _Tp(30UL),           _Tp(0UL),\n+        _Tp(5UL) / _Tp(66UL),            _Tp(0UL),\n+        -_Tp(691UL) / _Tp(2730UL),       _Tp(0UL),\n+        _Tp(7UL) / _Tp(6UL),             _Tp(0UL),\n+        -_Tp(3617UL) / _Tp(510UL),       _Tp(0UL),\n+        _Tp(43867UL) / _Tp(798UL),       _Tp(0UL),\n+        -_Tp(174611) / _Tp(330UL),       _Tp(0UL),\n+        _Tp(854513UL) / _Tp(138UL),      _Tp(0UL),\n+        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),\n+        _Tp(8553103UL) / _Tp(6UL),       _Tp(0UL)\n+      };\n+\n+      if (__n == 0)\n+        return _Tp(1);\n+\n+      if (__n == 1)\n+        return -_Tp(1) / _Tp(2);\n+\n+      //  Take care of the rest of the odd ones.\n+      if (__n % 2 == 1)\n+        return _Tp(0);\n+\n+      //  Take care of some small evens that are painful for the series.\n+      if (__n < 28)\n+        return __num[__n];\n+\n+\n+      _Tp __fact = _Tp(1);\n+      if ((__n / 2) % 2 == 0)\n+        __fact *= _Tp(-1);\n+      for (unsigned int __k = 1; __k <= __n; ++__k)\n+        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());\n+      __fact *= _Tp(2);\n+\n+      _Tp __sum = _Tp(0);\n+      for (unsigned int __i = 1; __i < 1000; ++__i)\n+        {\n+          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));\n+          if (__term < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __sum += __term;\n+        }\n+\n+      return __fact * __sum;\n+    }\n+\n+\n+    /**\n+     *   @brief This returns Bernoulli number \\f$B_n\\f$.\n+     *\n+     *   @param __n the order n of the Bernoulli number.\n+     *   @return  The Bernoulli number of order n.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __bernoulli(const int __n)\n+    {\n+      return __bernoulli_series<_Tp>(__n);\n+    }\n+\n+\n+    /**\n+     *   @brief Return \\f$log(\\Gamma(x))\\f$ by asymptotic expansion\n+     *          with Bernoulli number coefficients.  This is like\n+     *          Sterling's approximation.\n+     *\n+     *   @param __x The argument of the log of the gamma function.\n+     *   @return  The logarithm of the gamma function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __log_gamma_bernoulli(const _Tp __x)\n+    {\n+      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x\n+               + _Tp(0.5L) * std::log(_Tp(2)\n+               * __numeric_constants<_Tp>::__pi());\n+\n+      const _Tp __xx = __x * __x;\n+      _Tp __help = _Tp(1) / __x;\n+      for ( unsigned int __i = 1; __i < 20; ++__i )\n+        {\n+          const _Tp __2i = _Tp(2 * __i);\n+          __help /= __2i * (__2i - _Tp(1)) * __xx;\n+          __lg += __bernoulli<_Tp>(2 * __i) * __help;\n+        }\n+\n+      return __lg;\n+    }\n+\n+\n+    /**\n+     *   @brief Return \\f$log(\\Gamma(x))\\f$ by the Lanczos method.\n+     *          This method dominates all others on the positive axis I think.\n+     *\n+     *   @param __x The argument of the log of the gamma function.\n+     *   @return  The logarithm of the gamma function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __log_gamma_lanczos(const _Tp __x)\n+    {\n+      const _Tp __xm1 = __x - _Tp(1);\n+\n+      static const _Tp __lanczos_cheb_7[9] = {\n+       _Tp( 0.99999999999980993227684700473478L),\n+       _Tp( 676.520368121885098567009190444019L),\n+       _Tp(-1259.13921672240287047156078755283L),\n+       _Tp( 771.3234287776530788486528258894L),\n+       _Tp(-176.61502916214059906584551354L),\n+       _Tp( 12.507343278686904814458936853L),\n+       _Tp(-0.13857109526572011689554707L),\n+       _Tp( 9.984369578019570859563e-6L),\n+       _Tp( 1.50563273514931155834e-7L)\n+      };\n+\n+      static const _Tp __LOGROOT2PI\n+          = _Tp(0.9189385332046727417803297364056176L);\n+\n+      _Tp __sum = __lanczos_cheb_7[0];\n+      for(unsigned int __k = 1; __k < 9; ++__k)\n+        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);\n+\n+      const _Tp __term1 = (__xm1 + _Tp(0.5L))\n+                        * std::log((__xm1 + _Tp(7.5L))\n+                       / __numeric_constants<_Tp>::__euler());\n+      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);\n+      const _Tp __result = __term1 + (__term2 - _Tp(7));\n+\n+      return __result;\n+    }\n+\n+\n+    /**\n+     *   @brief Return \\f$ log(|\\Gamma(x)|) \\f$.\n+     *          This will return values even for \\f$ x < 0 \\f$.\n+     *          To recover the sign of \\f$ \\Gamma(x) \\f$ for\n+     *          any argument use @a __log_gamma_sign.\n+     *\n+     *   @param __x The argument of the log of the gamma function.\n+     *   @return  The logarithm of the gamma function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __log_gamma(const _Tp __x)\n+    {\n+      if (__x > _Tp(0.5L))\n+        return __log_gamma_lanczos(__x);\n+      else\n+        {\n+          const _Tp __sin_fact\n+                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));\n+          if (__sin_fact == _Tp(0))\n+            std::__throw_domain_error(__N(\"Argument is nonpositive integer \"\n+                                          \"in __log_gamma\"));\n+          return __numeric_constants<_Tp>::__lnpi()\n+                     - std::log(__sin_fact)\n+                     - __log_gamma_lanczos(_Tp(1) - __x);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the sign of \\f$ \\Gamma(x) \\f$.\n+     *          At nonpositive integers zero is returned.\n+     *\n+     *   @param __x The argument of the gamma function.\n+     *   @return  The sign of the gamma function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __log_gamma_sign(const _Tp __x)\n+    {\n+      if (__x > _Tp(0))\n+        return _Tp(1);\n+      else\n+        {\n+          const _Tp __sin_fact\n+                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);\n+          if (__sin_fact > _Tp(0))\n+            return (1);\n+          else if (__sin_fact < _Tp(0))\n+            return -_Tp(1);\n+          else\n+            return _Tp(0);\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief Return the logarithm of the binomial coefficient.\n+     *   The binomial coefficient is given by:\n+     *   @f[\n+     *   \\left(  \\right) = \\frac{n!}{(n-k)! k!}\n+     *   @f]\n+     *\n+     *   @param __n The first argument of the binomial coefficient.\n+     *   @param __k The second argument of the binomial coefficient.\n+     *   @return  The binomial coefficient.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __log_bincoef(const unsigned int __n, const unsigned int __k)\n+    {\n+      //  Max e exponent before overflow.\n+      static const _Tp __max_bincoeff\n+                      = std::numeric_limits<_Tp>::max_exponent10\n+                      * std::log(_Tp(10)) - _Tp(1);\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      _Tp __coeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __n))\n+                  - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __k))\n+                  - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __n - __k));\n+#else\n+      _Tp __coeff =  __log_gamma(_Tp(1 + __n))\n+                  - __log_gamma(_Tp(1 + __k))\n+                  - __log_gamma(_Tp(1 + __n - __k));\n+#endif\n+    }\n+\n+\n+    /**\n+     *   @brief Return the binomial coefficient.\n+     *   The binomial coefficient is given by:\n+     *   @f[\n+     *   \\left(  \\right) = \\frac{n!}{(n-k)! k!}\n+     *   @f]\n+     *\n+     *   @param __n The first argument of the binomial coefficient.\n+     *   @param __k The second argument of the binomial coefficient.\n+     *   @return  The binomial coefficient.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __bincoef(const unsigned int __n, const unsigned int __k)\n+    {\n+      //  Max e exponent before overflow.\n+      static const _Tp __max_bincoeff\n+                      = std::numeric_limits<_Tp>::max_exponent10\n+                      * std::log(_Tp(10)) - _Tp(1);\n+\n+      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);\n+      if (__log_coeff > __max_bincoeff)\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        return std::exp(__log_coeff);\n+    }\n+\n+\n+    /**\n+     *   @brief Return \\f$ \\Gamma(x) \\f$.\n+     *\n+     *   @param __x The argument of the gamma function.\n+     *   @return  The gamma function.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __gamma(const _Tp __x)\n+    {\n+      return std::exp(__log_gamma(__x));\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the digamma function by series expansion.\n+     *   The digamma or @f$ \\psi(x) @f$ function is defined by\n+     *   @f[\n+     *     \\psi(x) = \\frac{\\Gamma'(x)}{\\Gamma(x)}\n+     *   @f]\n+     *\n+     *   The series is given by:\n+     *   @f[\n+     *     \\psi(x) = -\\gamma_E - \\frac{1}{x}\n+     *              \\sum_{k=1}^{\\infty} \\frac{x}{k(x + k)}\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __psi_series(const _Tp __x)\n+    {\n+      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;\n+      const unsigned int __max_iter = 100000;\n+      for (unsigned int __k = 1; __k < __max_iter; ++__k)\n+        {\n+          const _Tp __term = __x / (__k * (__k + __x));\n+          __sum += __term;\n+          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+        }\n+      return __sum;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the digamma function for large argument.\n+     *   The digamma or @f$ \\psi(x) @f$ function is defined by\n+     *   @f[\n+     *     \\psi(x) = \\frac{Gamma'(x)}{\\Gamma(x)}\n+     *   @f]\n+     *\n+     *   The asymptotic series is given by:\n+     *   @f[\n+     *     \\psi(x) = \\ln(x) - \\frac{1}{2x}\n+     *             - \\sum_{n=1}^{\\infty} \\frac{B_{2n}}{2 n x^{2n}}\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __psi_asymp(const _Tp __x)\n+    {\n+      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;\n+      const _Tp __xx = __x * __x;\n+      _Tp __xp = __xx;\n+      const unsigned int __max_iter = 100;\n+      for (unsigned int __k = 1; __k < __max_iter; ++__k)\n+        {\n+          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);\n+          __sum -= __term;\n+          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __xp *= __xx;\n+        }\n+      return __sum;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the digamma function.\n+     *   The digamma or @f$ \\psi(x) @f$ function is defined by\n+     *   @f[\n+     *     \\psi(x) = \\frac{Gamma'(x)}{\\Gamma(x)}\n+     *   @f]\n+     *   For negative argument the reflection formula is used:\n+     *   @f[\n+     *     \\psi(x) = \\psi(1-x) - \\pi \\cot(\\pi x)\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __psi(const _Tp __x)\n+    {\n+      const int __n = static_cast<int>(__x + 0.5L);\n+      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();\n+      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x < _Tp(0))\n+        {\n+          const _Tp __pi = __numeric_constants<_Tp>::__pi();\n+          return __psi(_Tp(1) - __x)\n+               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);\n+        }\n+      else if (__x > _Tp(100))\n+        return __psi_asymp(__x);\n+      else\n+        return __psi_series(__x);\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the polygamma function @f$ \\psi^{(n)}(x) @f$.\n+     * \n+     *   The polygamma function is related to the Hurwitz zeta function:\n+     *   @f[\n+     *     \\psi^{(n)}(x) = (-1)^{n+1} m! \\zeta(m+1,x)\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __psi(const unsigned int __n, const _Tp __x)\n+    {\n+      if (__x <= _Tp(0))\n+        std::__throw_domain_error(__N(\"Argument out of range \"\n+                                      \"in __psi\"));\n+      else if (__n == 0)\n+        return __psi(__x);\n+      else\n+        {\n+          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+          const _Tp __ln_nfact = std::_GLIBCXX_TR1::lgamma(_Tp(__n + 1));\n+#else\n+          const _Tp __ln_nfact = __log_gamma(_Tp(__n + 1));\n+#endif\n+          _Tp __result = std::exp(__ln_nfact) * __hzeta;\n+          if (__n % 2 == 1)\n+            __result = -__result;\n+          return __result;\n+        }\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_GAMMA_TCC\n+"}, {"sha": "d54e6fecde33a71ba3dcb4ad1c7a49ea9306a9d5", "filename": "libstdc++-v3/include/tr1/hypergeometric.tcc", "status": "added", "additions": 788, "deletions": 0, "changes": 788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhypergeometric.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,788 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/hypergeometric.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based:\n+//   (1) Handbook of Mathematical Functions,\n+//       ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 6, pp. 555-566\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+\n+#ifndef _TR1_HYPERGEOMETRIC_TCC\n+#define _TR1_HYPERGEOMETRIC_TCC 1\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief This routine returns the confluent hypereometric function\n+     *          by series expansion.\n+     * \n+     *   @f[\n+     *     _1F_1(a;c;x) = \\frac{\\Gamma(c)}{\\Gamma(a)}\n+     *                      \\sum_{n=0}^{\\infty}\n+     *                      \\frac{\\Gamma(a+n)}{\\Gamma(c+n)}\n+     *                      \\frac{x^n}{n!}\n+     *   @f]\n+     * \n+     *   If a and b are integers and a < 0 and either b > 0 or b < a then the\n+     *   series is a polynomial with a finite number of terms.  If b is an integer\n+     *   and b <= 0 the the confluent hypergeometric function is undefined.\n+     *\n+     *   @param  __a  The \"numerator\" parameter.\n+     *   @param  __c  The \"denominator\" parameter.\n+     *   @param  __x  The argument of the confluent hypergeometric function.\n+     *   @return  The confluent hypergeometric function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __conf_hyperg_series(const _Tp __a, const _Tp __c, const _Tp __x)\n+    {\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+\n+      _Tp __term = _Tp(1);\n+      _Tp __Fac = _Tp(1);\n+      const unsigned int __max_iter = 100000;\n+      unsigned int __i;\n+      for (__i = 0; __i < __max_iter; ++__i)\n+        {\n+          __term *= (__a + _Tp(__i)) * __x\n+                  / ((__c + _Tp(__i)) * _Tp(1 + __i));\n+          if (std::abs(__term) < __eps)\n+            {\n+              break;\n+            }\n+          __Fac += __term;\n+        }\n+      if (__i == __max_iter)\n+        std::__throw_runtime_error(__N(\"Series failed to converge \"\n+                                       \"in __conf_hyperg_series.\"));\n+\n+      return __Fac;\n+    }\n+\n+\n+    /**\n+     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$\n+     *          by an iterative procedure described in\n+     *          Luke, Algorithms for the Computation of Mathematical Functions.\n+     *\n+     *  Like the case of the 2F1 rational approximations, these are \n+     *  probably guaranteed to converge for x < 0, barring gross    \n+     *  numerical instability in the pre-asymptotic regime.         \n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __conf_hyperg_luke(const _Tp __a, const _Tp __c, const _Tp __xin)\n+    {\n+      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));\n+      const int __nmax = 20000;\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __x  = -__xin;\n+      const _Tp __x3 = __x * __x * __x;\n+      const _Tp __t0 = __a / __c;\n+      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);\n+      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));\n+      _Tp __F = _Tp(1);\n+      _Tp __prec;\n+\n+      _Tp __Bnm3 = _Tp(1);\n+      _Tp __Bnm2 = _Tp(1) + __t1 * __x;\n+      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);\n+\n+      _Tp __Anm3 = _Tp(1);\n+      _Tp __Anm2 = __Bnm2 - __t0 * __x;\n+      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x\n+                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;\n+\n+      int __n = 3;\n+      while(1)\n+        {\n+          _Tp __npam1 = _Tp(__n - 1) + __a;\n+          _Tp __npcm1 = _Tp(__n - 1) + __c;\n+          _Tp __npam2 = _Tp(__n - 2) + __a;\n+          _Tp __npcm2 = _Tp(__n - 2) + __c;\n+          _Tp __tnm1  = _Tp(2 * __n - 1);\n+          _Tp __tnm3  = _Tp(2 * __n - 3);\n+          _Tp __tnm5  = _Tp(2 * __n - 5);\n+          _Tp __F1 =  (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);\n+          _Tp __F2 =  (_Tp(__n) + __a) * __npam1\n+                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);\n+          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)\n+                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5\n+                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);\n+          _Tp __E  = -__npam1 * (_Tp(__n - 1) - __c)\n+                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);\n+\n+          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1\n+                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;\n+          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1\n+                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;\n+          _Tp __r = __An / __Bn;\n+\n+          __prec = std::abs((__F - __r) / __F);\n+          __F = __r;\n+\n+          if (__prec < __eps || __n > __nmax)\n+            break;\n+\n+          if (std::abs(__An) > __big || std::abs(__Bn) > __big)\n+            {\n+              __An   /= __big;\n+              __Bn   /= __big;\n+              __Anm1 /= __big;\n+              __Bnm1 /= __big;\n+              __Anm2 /= __big;\n+              __Bnm2 /= __big;\n+              __Anm3 /= __big;\n+              __Bnm3 /= __big;\n+            }\n+          else if (std::abs(__An) < _Tp(1) / __big\n+                || std::abs(__Bn) < _Tp(1) / __big)\n+            {\n+              __An   *= __big;\n+              __Bn   *= __big;\n+              __Anm1 *= __big;\n+              __Bnm1 *= __big;\n+              __Anm2 *= __big;\n+              __Bnm2 *= __big;\n+              __Anm3 *= __big;\n+              __Bnm3 *= __big;\n+            }\n+\n+          ++__n;\n+          __Bnm3 = __Bnm2;\n+          __Bnm2 = __Bnm1;\n+          __Bnm1 = __Bn;\n+          __Anm3 = __Anm2;\n+          __Anm2 = __Anm1;\n+          __Anm1 = __An;\n+        }\n+\n+      if (__n >= __nmax)\n+        std::__throw_runtime_error(__N(\"Iteration failed to converge \"\n+                                       \"in __conf_hyperg_luke.\"));\n+\n+      return __F;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the confluent hypogeometric function\n+     *           @f$ _1F_1(a;c;x) @f$.\n+     * \n+     *   @todo  Handle b == nonpositive integer blowup - return NaN.\n+     *\n+     *   @param  __a  The \"numerator\" parameter.\n+     *   @param  __c  The \"denominator\" parameter.\n+     *   @param  __x  The argument of the confluent hypergeometric function.\n+     *   @return  The confluent hypergeometric function.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __conf_hyperg(const _Tp __a, const _Tp __c, const _Tp __x)\n+    {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      const _Tp __c_nint = std::_GLIBCXX_TR1::nearbyint(__c);\n+#else\n+      const _Tp __c_nint = static_cast<int>(__c + _Tp(0.5L));\n+#endif\n+      if (__isnan(__a) || __isnan(__c) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__c_nint == __c && __c_nint <= 0)\n+        return std::numeric_limits<_Tp>::infinity();\n+      else if (__a == _Tp(0))\n+        return _Tp(1);\n+      else if (__c == __a)\n+        return std::exp(__x);\n+      else if (__x < _Tp(0))\n+        return __conf_hyperg_luke(__a, __c, __x);\n+      else\n+        return __conf_hyperg_series(__a, __c, __x);\n+    }\n+\n+\n+    /**\n+     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$\n+     *   by series expansion.\n+     * \n+     *   The hypogeometric function is defined by\n+     *   @f[\n+     *     _2F_1(a,b;c;x) = \\frac{\\Gamma(c)}{\\Gamma(a)\\Gamma(b)}\n+     *                      \\sum_{n=0}^{\\infty}\n+     *                      \\frac{\\Gamma(a+n)\\Gamma(b+n)}{\\Gamma(c+n)}\n+     *                      \\frac{x^n}{n!}\n+     *   @f]\n+     * \n+     *   This works and it's pretty fast.\n+     *\n+     *   @param  __a  The first \"numerator\" parameter.\n+     *   @param  __a  The second \"numerator\" parameter.\n+     *   @param  __c  The \"denominator\" parameter.\n+     *   @param  __x  The argument of the confluent hypergeometric function.\n+     *   @return  The confluent hypergeometric function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __hyperg_series(const _Tp __a, const _Tp __b,\n+                    const _Tp __c, const _Tp __x)\n+    {\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+\n+      _Tp __term = _Tp(1);\n+      _Tp __Fabc = _Tp(1);\n+      const unsigned int __max_iter = 100000;\n+      unsigned int __i;\n+      for (__i = 0; __i < __max_iter; ++__i)\n+        {\n+          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x\n+                  / ((__c + _Tp(__i)) * _Tp(1 + __i));\n+          if (std::abs(__term) < __eps)\n+            {\n+              break;\n+            }\n+          __Fabc += __term;\n+        }\n+      if (__i == __max_iter)\n+        std::__throw_runtime_error(__N(\"Series failed to converge \"\n+                                       \"in __hyperg_series.\"));\n+\n+      return __Fabc;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$\n+     *           by an iterative procedure described in\n+     *           Luke, Algorithms for the Computation of Mathematical Functions.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __hyperg_luke(const _Tp __a, const _Tp __b, const _Tp __c,\n+                  const _Tp __xin)\n+    {\n+      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));\n+      const int __nmax = 20000;\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __x  = -__xin;\n+      const _Tp __x3 = __x * __x * __x;\n+      const _Tp __t0 = __a * __b / __c;\n+      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);\n+      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))\n+                     / (_Tp(2) * (__c + _Tp(1)));\n+\n+      _Tp __F = _Tp(1);\n+\n+      _Tp __Bnm3 = _Tp(1);\n+      _Tp __Bnm2 = _Tp(1) + __t1 * __x;\n+      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);\n+\n+      _Tp __Anm3 = _Tp(1);\n+      _Tp __Anm2 = __Bnm2 - __t0 * __x;\n+      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x\n+                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;\n+\n+      int __n = 3;\n+      while (1)\n+        {\n+          const _Tp __npam1 = _Tp(__n - 1) + __a;\n+          const _Tp __npbm1 = _Tp(__n - 1) + __b;\n+          const _Tp __npcm1 = _Tp(__n - 1) + __c;\n+          const _Tp __npam2 = _Tp(__n - 2) + __a;\n+          const _Tp __npbm2 = _Tp(__n - 2) + __b;\n+          const _Tp __npcm2 = _Tp(__n - 2) + __c;\n+          const _Tp __tnm1  = _Tp(2 * __n - 1);\n+          const _Tp __tnm3  = _Tp(2 * __n - 3);\n+          const _Tp __tnm5  = _Tp(2 * __n - 5);\n+          const _Tp __n2 = __n * __n;\n+          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n\n+                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))\n+                         / (_Tp(2) * __tnm3 * __npcm1);\n+          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n\n+                         + _Tp(2) - __a * __b) * __npam1 * __npbm1\n+                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);\n+          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1\n+                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))\n+                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5\n+                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);\n+          const _Tp __E  = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)\n+                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);\n+\n+          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1\n+                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;\n+          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1\n+                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;\n+          const _Tp __r = __An / __Bn;\n+\n+          const _Tp __prec = std::abs((__F - __r) / __F);\n+          __F = __r;\n+\n+          if (__prec < __eps || __n > __nmax)\n+            break;\n+\n+          if (std::abs(__An) > __big || std::abs(__Bn) > __big)\n+            {\n+              __An   /= __big;\n+              __Bn   /= __big;\n+              __Anm1 /= __big;\n+              __Bnm1 /= __big;\n+              __Anm2 /= __big;\n+              __Bnm2 /= __big;\n+              __Anm3 /= __big;\n+              __Bnm3 /= __big;\n+            }\n+          else if (std::abs(__An) < _Tp(1) / __big\n+                || std::abs(__Bn) < _Tp(1) / __big)\n+            {\n+              __An   *= __big;\n+              __Bn   *= __big;\n+              __Anm1 *= __big;\n+              __Bnm1 *= __big;\n+              __Anm2 *= __big;\n+              __Bnm2 *= __big;\n+              __Anm3 *= __big;\n+              __Bnm3 *= __big;\n+            }\n+\n+          ++__n;\n+          __Bnm3 = __Bnm2;\n+          __Bnm2 = __Bnm1;\n+          __Bnm1 = __Bn;\n+          __Anm3 = __Anm2;\n+          __Anm2 = __Anm1;\n+          __Anm1 = __An;\n+        }\n+\n+      if (__n >= __nmax)\n+        std::__throw_runtime_error(__N(\"Iteration failed to converge \"\n+                                       \"in __hyperg_luke.\"));\n+\n+      return __F;\n+    }\n+\n+\n+    /**\n+     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$ by the reflection\n+     *          formulae in Abramowitz & Stegun formula 15.3.6 for d = c - a - b not integral\n+     *          and formula 15.3.11 for d = c - a - b integral.\n+     *          This assumes a, b, c != negative integer.\n+     *\n+     *   The hypogeometric function is defined by\n+     *   @f[\n+     *     _2F_1(a,b;c;x) = \\frac{\\Gamma(c)}{\\Gamma(a)\\Gamma(b)}\n+     *                      \\sum_{n=0}^{\\infty}\n+     *                      \\frac{\\Gamma(a+n)\\Gamma(b+n)}{\\Gamma(c+n)}\n+     *                      \\frac{x^n}{n!}\n+     *   @f]\n+     *\n+     *   The reflection formula for nonintegral @f$ d = c - a - b @f$ is:\n+     *   @f[\n+     *     _2F_1(a,b;c;x) = \\frac{\\Gamma(c)\\Gamma(d)}{\\Gamma(c-a)\\Gamma(c-b)}\n+     *                            _2F_1(a,b;1-d;1-x)\n+     *                    + \\frac{\\Gamma(c)\\Gamma(-d)}{\\Gamma(a)\\Gamma(b)}\n+     *                            _2F_1(c-a,c-b;1+d;1-x)\n+     *   @f]\n+     *\n+     *   The reflection formula for integral @f$ m = c - a - b @f$ is:\n+     *   @f[\n+     *     _2F_1(a,b;a+b+m;x) = \\frac{\\Gamma(m)\\Gamma(a+b+m)}{\\Gamma(a+m)\\Gamma(b+m)}\n+     *                        \\sum_{k=0}^{m-1} \\frac{(m+a)_k(m+b)_k}{k!(1-m)_k}\n+     *                      - \n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __hyperg_reflect(const _Tp __a, const _Tp __b, const _Tp __c,\n+                     const _Tp __x)\n+    {\n+      const _Tp __d = __c - __a - __b;\n+      const int __intd  = std::floor(__d + _Tp(0.5L));\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __toler = _Tp(1000) * __eps;\n+      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());\n+      const bool __d_integer = (std::abs(__d - __intd) < __toler);\n+\n+      if (__d_integer)\n+        {\n+          const _Tp __ln_omx = std::log(_Tp(1) - __x);\n+          const _Tp __ad = std::abs(__d);\n+          _Tp __F1, __F2;\n+\n+          _Tp __d1, __d2;\n+          if (__d >= _Tp(0))\n+            {\n+              __d1 = __d;\n+              __d2 = _Tp(0);\n+            }\n+          else\n+            {\n+              __d1 = _Tp(0);\n+              __d2 = __d;\n+            }\n+\n+          const _Tp __lng_c = __log_gamma(__c);\n+\n+          //  Evaluate F1.\n+          if (__ad < __eps)\n+            {\n+              //  d = c - a - b = 0.\n+              __F1 = _Tp(0);\n+            }\n+          else\n+            {\n+\n+              bool __ok_d1 = true;\n+              _Tp __lng_ad, __lng_ad1, __lng_bd1;\n+              try\n+                {\n+                  __lng_ad = __log_gamma(__ad);\n+                  __lng_ad1 = __log_gamma(__a + __d1);\n+                  __lng_bd1 = __log_gamma(__b + __d1);\n+                }\n+              catch(...)\n+                {\n+                  __ok_d1 = false;\n+                }\n+\n+              if (__ok_d1)\n+                {\n+                  /* Gamma functions in the denominator are ok.\n+                   * Proceed with evaluation.\n+                   */\n+                  _Tp __sum1 = _Tp(1);\n+                  _Tp __term = _Tp(1);\n+                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx\n+                                - __lng_ad1 - __lng_bd1;\n+\n+                  /* Do F1 sum.\n+                   */\n+                  for (int __i = 1; __i < __ad; ++__i)\n+                    {\n+                      const int __j = __i - 1;\n+                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)\n+                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);\n+                      __sum1 += __term;\n+                    }\n+\n+                  if (__ln_pre1 > __log_max)\n+                    std::__throw_runtime_error(__N(\"Overflow of gamma functions \"\n+                                                   \"in __hyperg_luke.\"));\n+                  else\n+                    __F1 = std::exp(__ln_pre1) * __sum1;\n+                }\n+              else\n+                {\n+                  //  Gamma functions in the denominator were not ok.\n+                  //  So the F1 term is zero.\n+                  __F1 = _Tp(0);\n+                }\n+            } // end F1 evaluation\n+\n+          // Evaluate F2.\n+          bool __ok_d2 = true;\n+          _Tp __lng_ad2, __lng_bd2;\n+          try\n+            {\n+              __lng_ad2 = __log_gamma(__a + __d2);\n+              __lng_bd2 = __log_gamma(__b + __d2);\n+            }\n+          catch(...)\n+            {\n+              __ok_d2 = false;\n+            }\n+\n+          if (__ok_d2)\n+            {\n+              //  Gamma functions in the denominator are ok.\n+              //  Proceed with evaluation.\n+              const int __maxiter = 2000;\n+              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();\n+              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);\n+              const _Tp __psi_apd1 = __psi(__a + __d1);\n+              const _Tp __psi_bpd1 = __psi(__b + __d1);\n+\n+              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1\n+                             - __psi_bpd1 - __ln_omx;\n+              _Tp __fact = _Tp(1);\n+              _Tp __sum2 = __psi_term;\n+              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx\n+                            - __lng_ad2 - __lng_bd2;\n+\n+              // Do F2 sum.\n+              int __j;\n+              for (__j = 1; __j < __maxiter; ++__j)\n+                {\n+                  //  Values for psi functions use recurrence; Abramowitz & Stegun 6.3.5\n+                  const _Tp __term1 = _Tp(1) / _Tp(__j)\n+                                    + _Tp(1) / (__ad + __j);\n+                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))\n+                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));\n+                  __psi_term += __term1 - __term2;\n+                  __fact *= (__a + __d1 + _Tp(__j - 1))\n+                          * (__b + __d1 + _Tp(__j - 1))\n+                          / ((__ad + __j) * __j) * (_Tp(1) - __x);\n+                  const _Tp __delta = __fact * __psi_term;\n+                  __sum2 += __delta;\n+                  if (std::abs(__delta) < __eps * std::abs(__sum2))\n+                    break;\n+                }\n+              if (__j == __maxiter)\n+                std::__throw_runtime_error(__N(\"Sum F2 failed to converge \"\n+                                               \"in __hyperg_reflect\"));\n+\n+              if (__sum2 == _Tp(0))\n+                __F2 = _Tp(0);\n+              else\n+                __F2 = std::exp(__ln_pre2) * __sum2;\n+            }\n+          else\n+            {\n+              // Gamma functions in the denominator not ok.\n+              // So the F2 term is zero.\n+              __F2 = _Tp(0);\n+            } // end F2 evaluation\n+\n+          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));\n+          const _Tp __F = __F1 + __sgn_2 * __F2;\n+\n+          return __F;\n+        }\n+      else\n+        {\n+          //  d = c - a - b not an integer.\n+\n+          //  These gamma functions appear in the denominator, so we\n+          //  catch their harmless domain errors and set the terms to zero.\n+          bool __ok1 = true;\n+          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);\n+          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);\n+          try\n+            {\n+              __sgn_g1ca = __log_gamma_sign(__c - __a);\n+              __ln_g1ca = __log_gamma(__c - __a);\n+              __sgn_g1cb = __log_gamma_sign(__c - __b);\n+              __ln_g1cb = __log_gamma(__c - __b);\n+            }\n+          catch (...)\n+            {\n+              __ok1 = false;\n+            }\n+\n+          bool __ok2 = true;\n+          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);\n+          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);\n+          try\n+            {\n+              __sgn_g2a = __log_gamma_sign(__a);\n+              __ln_g2a = __log_gamma(__a);\n+              __sgn_g2b = __log_gamma_sign(__b);\n+              __ln_g2b = __log_gamma(__b);\n+            }\n+          catch (...)\n+            {\n+              __ok2 = false;\n+            }\n+\n+          const _Tp __sgn_gc = __log_gamma_sign(__c);\n+          const _Tp __ln_gc = __log_gamma(__c);\n+          const _Tp __sgn_gd = __log_gamma_sign(__d);\n+          const _Tp __ln_gd = __log_gamma(__d);\n+          const _Tp __sgn_gmd = __log_gamma_sign(-__d);\n+          const _Tp __ln_gmd = __log_gamma(-__d);\n+\n+          const _Tp __sgn1 = __sgn_gc * __sgn_gd  * __sgn_g1ca * __sgn_g1cb;\n+          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a  * __sgn_g2b;\n+\n+          _Tp __pre1, __pre2;\n+          if (__ok1 && __ok2)\n+            {\n+              _Tp __ln_pre1 = __ln_gc + __ln_gd  - __ln_g1ca - __ln_g1cb;\n+              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a  - __ln_g2b\n+                            + __d * std::log(_Tp(1) - __x);\n+              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)\n+                {\n+                  __pre1 = std::exp(__ln_pre1);\n+                  __pre2 = std::exp(__ln_pre2);\n+                  __pre1 *= __sgn1;\n+                  __pre2 *= __sgn2;\n+                }\n+              else\n+                {\n+                  std::__throw_runtime_error(__N(\"Overflow of gamma functions \"\n+                                                 \"in __hyperg_reflect\"));\n+                }\n+            }\n+          else if (__ok1 && !__ok2)\n+            {\n+              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;\n+              if (__ln_pre1 < __log_max)\n+                {\n+                  __pre1 = std::exp(__ln_pre1);\n+                  __pre1 *= __sgn1;\n+                  __pre2 = _Tp(0);\n+                }\n+              else\n+                {\n+                  std::__throw_runtime_error(__N(\"Overflow of gamma functions \"\n+                                                 \"in __hyperg_reflect\"));\n+                }\n+            }\n+          else if (!__ok1 && __ok2)\n+            {\n+              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b\n+                            + __d * std::log(_Tp(1) - __x);\n+              if (__ln_pre2 < __log_max)\n+                {\n+                  __pre1 = _Tp(0);\n+                  __pre2 = std::exp(__ln_pre2);\n+                  __pre2 *= __sgn2;\n+                }\n+              else\n+                {\n+                  std::__throw_runtime_error(__N(\"Overflow of gamma functions \"\n+                                                 \"in __hyperg_reflect\"));\n+                }\n+            }\n+          else\n+            {\n+              __pre1 = _Tp(0);\n+              __pre2 = _Tp(0);\n+              std::__throw_runtime_error(__N(\"Underflow of gamma functions \"\n+                                             \"in __hyperg_reflect\"));\n+            }\n+\n+          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,\n+                                           _Tp(1) - __x);\n+          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,\n+                                           _Tp(1) - __x);\n+\n+          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;\n+\n+          return __F;\n+        }\n+    }\n+\n+\n+    /*\n+     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$.\n+     *\n+     *   The hypogeometric function is defined by\n+     *   @f[\n+     *     _2F_1(a,b;c;x) = \\frac{\\Gamma(c)}{\\Gamma(a)\\Gamma(b)}\n+     *                      \\sum_{n=0}^{\\infty}\n+     *                      \\frac{\\Gamma(a+n)\\Gamma(b+n)}{\\Gamma(c+n)}\n+     *                      \\frac{x^n}{n!}\n+     *   @f]\n+     *\n+     *   @param  __a  The first \"numerator\" parameter.\n+     *   @param  __a  The second \"numerator\" parameter.\n+     *   @param  __c  The \"denominator\" parameter.\n+     *   @param  __x  The argument of the confluent hypergeometric function.\n+     *   @return  The confluent hypergeometric function.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __hyperg(const _Tp __a, const _Tp __b, const _Tp __c, const _Tp __x)\n+    {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      const _Tp __a_nint = std::_GLIBCXX_TR1::nearbyint(__a);\n+      const _Tp __b_nint = std::_GLIBCXX_TR1::nearbyint(__b);\n+      const _Tp __c_nint = std::_GLIBCXX_TR1::nearbyint(__c);\n+#else\n+      const _Tp __a_nint = static_cast<int>(__a + _Tp(0.5L));\n+      const _Tp __b_nint = static_cast<int>(__b + _Tp(0.5L));\n+      const _Tp __c_nint = static_cast<int>(__c + _Tp(0.5L));\n+#endif\n+      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();\n+      if (std::abs(__x) >= _Tp(1))\n+        std::__throw_domain_error(__N(\"Argument outside unit circle \"\n+                                      \"in __hyperg.\"));\n+      else if (__isnan(__a) || __isnan(__b)\n+            || __isnan(__c) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__c_nint == __c && __c_nint <= _Tp(0))\n+        return std::numeric_limits<_Tp>::infinity();\n+      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)\n+        return std::pow(_Tp(1) - __x, __c - __a - __b);\n+      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)\n+            && __x >= _Tp(0) && __x < _Tp(0.995L))\n+        return __hyperg_series(__a, __b, __c, __x);\n+      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))\n+        {\n+          //  For integer a and b the hypergeometric function is a finite polynomial.\n+          if (__a < _Tp(0)  &&  std::abs(__a - __a_nint) < __toler)\n+            return __hyperg_series(__a_nint, __b, __c, __x);\n+          else if (__b < _Tp(0)  &&  std::abs(__b - __b_nint) < __toler)\n+            return __hyperg_series(__a, __b_nint, __c, __x);\n+          else if (__x < -_Tp(0.25L))\n+            return __hyperg_luke(__a, __b, __c, __x);\n+          else if (__x < _Tp(0.5L))\n+            return __hyperg_series(__a, __b, __c, __x);\n+          else\n+            if (std::abs(__c) > _Tp(10))\n+              return __hyperg_series(__a, __b, __c, __x);\n+            else\n+              return __hyperg_reflect(__a, __b, __c, __x);\n+        }\n+      else\n+        return __hyperg_luke(__a, __b, __c, __x);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_HYPERGEOMETRIC_TCC"}, {"sha": "323bd18861c1cb0b160c4a7f053c9b259c8bae62", "filename": "libstdc++-v3/include/tr1/legendre_function.tcc", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Flegendre_function.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,318 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/legendre_function.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 8, pp. 331-341\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 252-254\n+\n+#ifndef _TR1_LEGENDRE_FUNCTION_TCC\n+#define _TR1_LEGENDRE_FUNCTION_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief  Return the Legendre polynomial by recursion on order\n+     *           @f$ l @f$.\n+     * \n+     *   The Legendre function of @f$ l @f$ and @f$ x @f$,\n+     *   @f$ P_l(x) @f$, is defined by:\n+     *   @f[\n+     *     P_l(x) = \\frac{1}{2^l l!}\\frac{d^l}{dx^l}(x^2 - 1)^{l}\n+     *   @f]\n+     * \n+     *   @param  l  The order of the Legendre polynomial.  @f$l >= 0@f$.\n+     *   @param  x  The argument of the Legendre polynomial.  @f$|x| <= 1@f$.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __poly_legendre_p(const unsigned int __l, const _Tp __x)\n+    {\n+\n+      if ((__x < _Tp(-1)) || (__x > _Tp(+1)))\n+        std::__throw_domain_error(__N(\"Argument out of range\"\n+                                      \" in __poly_legendre_p.\"));\n+      else if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x == +_Tp(1))\n+        return +_Tp(1);\n+      else if (__x == -_Tp(1))\n+        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));\n+      else\n+        {\n+          _Tp __p_lm2 = _Tp(1);\n+          if (__l == 0)\n+            return __p_lm2;\n+\n+          _Tp __p_lm1 = __x;\n+          if (__l == 1)\n+            return __p_lm1;\n+\n+          _Tp __p_l = 0;\n+          for (unsigned int __ll = 2; __ll <= __l; ++__ll)\n+            {\n+              //  This arrangement is supposed to be better for roundoff\n+              //  protection, Arfken, 2nd Ed, Eq 12.17a.\n+              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2\n+                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);\n+              __p_lm2 = __p_lm1;\n+              __p_lm1 = __p_l;\n+            }\n+\n+          return __p_l;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the associated Legendre function by recursion\n+     *           on @f$ l @f$.\n+     * \n+     *   The associated Legendre function is derived from the Legendre function\n+     *   @f$ P_l(x) @f$ by the Rodruigez formula:\n+     *   @f[\n+     *     P_l^m(x) = (1 - x^2)^{m/2}\\frac{d^m}{dx^m}P_l(x)\n+     *   @f]\n+     * \n+     *   @param  l  The order of the associated Legendre function.\n+     *              @f$ l >= 0 @f$.\n+     *   @param  m  The order of the associated Legendre function.\n+     *              @f$ m <= l @f$.\n+     *   @param  x  The argument of the associated Legendre function.\n+     *              @f$ |x| <= 1 @f$.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __assoc_legendre_p(const unsigned int __l, const unsigned int __m,\n+                       const _Tp __x)\n+    {\n+\n+      if (__x < _Tp(-1) || __x > _Tp(+1))\n+        std::__throw_domain_error(__N(\"Argument out of range\"\n+                                      \" in __assoc_legendre_p.\"));\n+      else if (__m > __l)\n+        std::__throw_domain_error(__N(\"Degree out of range\"\n+                                      \" in __assoc_legendre_p.\"));\n+      else if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__m == 0)\n+        return __poly_legendre_p(__l, __x);\n+      else\n+        {\n+          _Tp __p_mm = _Tp(1);\n+          if (__m > 0)\n+            {\n+              //  Two square roots seem more accurate more of the time than just one.\n+              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);\n+              _Tp __fact = _Tp(1);\n+              for (unsigned int __i = 1; __i <= __m; ++__i)\n+                {\n+                  __p_mm *= -__fact * __root;\n+                  __fact += _Tp(2);\n+                }\n+            }\n+          if (__l == __m)\n+            return __p_mm;\n+\n+          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;\n+          if (__l == __m + 1)\n+            return __p_mp1m;\n+\n+          _Tp __p_lm2m = __p_mm;\n+          _Tp __P_lm1m = __p_mp1m;\n+          _Tp __p_lm = _Tp(0);\n+          for (unsigned int __j = __m + 2; __j <= __l; ++__j)\n+            {\n+              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m\n+                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);\n+              __p_lm2m = __P_lm1m;\n+              __P_lm1m = __p_lm;\n+            }\n+\n+          return __p_lm;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the spherical associated Legendre function.\n+     * \n+     *   The spherical associated Legendre function of @f$ l @f$, @f$ m @f$,\n+     *   and @f$ \\theta @f$ is defined as @f$ Y_l^m(\\theta,0) @f$ where\n+     *   @f[\n+     *      Y_l^m(\\theta,\\phi) = (-1)^m[\\frac{(2l+1)}{4\\pi}\n+     *                                  \\frac{(l-m)!}{(l+m)!}]\n+     *                     P_l^m(\\cos\\theta) \\exp^{im\\phi}\n+     *   @f]\n+     *   is the spherical harmonic function and @f$ P_l^m(x) @f$ is the\n+     *   associated Legendre function.\n+     * \n+     *   This function differs from the associated Legendre function by\n+     *   argument (@f$x = \\cos(\\theta)@f$) and by a normalization factor\n+     *   but this factor is rather large for large @f$ l @f$ and @f$ m @f$\n+     *   and so this function is stable for larger differences of @f$ l @f$\n+     *   and @f$ m @f$.\n+     * \n+     *   @param  l  The order of the spherical associated Legendre function.\n+     *              @f$ l >= 0 @f$.\n+     *   @param  m  The order of the spherical associated Legendre function.\n+     *              @f$ m <= l @f$.\n+     *   @param  theta  The radian angle argument of the spherical associated\n+     *                  Legendre function.\n+     */\n+    template <typename _Tp>\n+    _Tp\n+    __sph_legendre(const unsigned int __l, const unsigned int __m,\n+                   const _Tp __theta)\n+    {\n+      if (__isnan(__theta))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+\n+      const _Tp __x = std::cos(__theta);\n+\n+      if (__l < __m)\n+        {\n+          std::__throw_domain_error(__N(\"Bad argument \"\n+                                        \"in __sph_legendre.\"));\n+        }\n+      else if (__m == 0)\n+        {\n+          _Tp __P = __poly_legendre_p(__l, __x);\n+          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)\n+                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));\n+          __P *= __fact;\n+          return __P;\n+        }\n+      else if (__x == _Tp(1) || __x == -_Tp(1))\n+        {\n+          //  m > 0 here\n+          return _Tp(0);\n+        }\n+      else\n+        {\n+          // m > 0 and |x| < 1 here\n+\n+          // Starting value for recursion.\n+          // Y_m^m(x) = sqrt( (2m+1)/(4pi m) gamma(m+1/2)/gamma(m) )\n+          //             (-1)^m (1-x^2)^(m/2) / pi^(1/4)\n+          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));\n+          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+          const _Tp __lncirc = std::_GLIBCXX_TR1::log1p(-__x * __x);\n+#else\n+          const _Tp __lncirc = std::log(_Tp(1) - __x * __x);\n+#endif\n+          //  Gamma(m+1/2) / Gamma(m)\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+          const _Tp __lnpoch = std::_GLIBCXX_TR1::lgamma(_Tp(__m + _Tp(0.5L)))\n+                             - std::_GLIBCXX_TR1::lgamma(_Tp(__m));\n+#else\n+          const _Tp __lnpoch = __log_gamma(_Tp(__m + _Tp(0.5L)))\n+                             - __log_gamma(_Tp(__m));\n+#endif\n+          const _Tp __lnpre_val =\n+                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()\n+                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);\n+          _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)\n+                   / (_Tp(4) * __numeric_constants<_Tp>::__pi()));\n+          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);\n+          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;\n+\n+          if (__l == __m)\n+            {\n+              return __y_mm;\n+            }\n+          else if (__l == __m + 1)\n+            {\n+              return __y_mp1m;\n+            }\n+          else\n+            {\n+              _Tp __y_lm = _Tp(0);\n+\n+              // Compute Y_l^m, l > m+1, upward recursion on l.\n+              for ( int __ll = __m + 2; __ll <= __l; ++__ll)\n+                {\n+                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);\n+                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);\n+                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)\n+                                                       * _Tp(2 * __ll - 1));\n+                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)\n+                                                                / _Tp(2 * __ll - 3));\n+                  __y_lm = (__x * __y_mp1m * __fact1\n+                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);\n+                  __y_mm = __y_mp1m;\n+                  __y_mp1m = __y_lm;\n+                }\n+\n+              return __y_lm;\n+            }\n+        }\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_LEGENDRE_FUNCTION_TCC"}, {"sha": "0698cb2df9c32d5db10fde26fa42206ec053913c", "filename": "libstdc++-v3/include/tr1/math.h", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmath.h?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -96,4 +96,96 @@ using std::_GLIBCXX_TR1::trunc;\n \n #endif\n \n+using std::_GLIBCXX_TR1::assoc_laguerref;\n+using std::_GLIBCXX_TR1::assoc_laguerre;\n+using std::_GLIBCXX_TR1::assoc_laguerrel;\n+\n+using std::_GLIBCXX_TR1::assoc_legendref;\n+using std::_GLIBCXX_TR1::assoc_legendre;\n+using std::_GLIBCXX_TR1::assoc_legendrel;\n+\n+using std::_GLIBCXX_TR1::betaf;\n+using std::_GLIBCXX_TR1::beta;\n+using std::_GLIBCXX_TR1::betal;\n+\n+using std::_GLIBCXX_TR1::comp_ellint_1f;\n+using std::_GLIBCXX_TR1::comp_ellint_1;\n+using std::_GLIBCXX_TR1::comp_ellint_1l;\n+\n+using std::_GLIBCXX_TR1::comp_ellint_2f;\n+using std::_GLIBCXX_TR1::comp_ellint_2;\n+using std::_GLIBCXX_TR1::comp_ellint_2l;\n+\n+using std::_GLIBCXX_TR1::comp_ellint_3f;\n+using std::_GLIBCXX_TR1::comp_ellint_3;\n+using std::_GLIBCXX_TR1::comp_ellint_3l;\n+\n+using std::_GLIBCXX_TR1::conf_hypergf;\n+using std::_GLIBCXX_TR1::conf_hyperg;\n+using std::_GLIBCXX_TR1::conf_hypergl;\n+\n+using std::_GLIBCXX_TR1::cyl_bessel_if;\n+using std::_GLIBCXX_TR1::cyl_bessel_i;\n+using std::_GLIBCXX_TR1::cyl_bessel_il;\n+\n+using std::_GLIBCXX_TR1::cyl_bessel_jf;\n+using std::_GLIBCXX_TR1::cyl_bessel_j;\n+using std::_GLIBCXX_TR1::cyl_bessel_jl;\n+\n+using std::_GLIBCXX_TR1::cyl_bessel_kf;\n+using std::_GLIBCXX_TR1::cyl_bessel_k;\n+using std::_GLIBCXX_TR1::cyl_bessel_kl;\n+\n+using std::_GLIBCXX_TR1::cyl_neumannf;\n+using std::_GLIBCXX_TR1::cyl_neumann;\n+using std::_GLIBCXX_TR1::cyl_neumannl;\n+\n+using std::_GLIBCXX_TR1::ellint_1f;\n+using std::_GLIBCXX_TR1::ellint_1;\n+using std::_GLIBCXX_TR1::ellint_1l;\n+\n+using std::_GLIBCXX_TR1::ellint_2f;\n+using std::_GLIBCXX_TR1::ellint_2;\n+using std::_GLIBCXX_TR1::ellint_2l;\n+\n+using std::_GLIBCXX_TR1::ellint_3f;\n+using std::_GLIBCXX_TR1::ellint_3;\n+using std::_GLIBCXX_TR1::ellint_3l;\n+\n+using std::_GLIBCXX_TR1::expintf;\n+using std::_GLIBCXX_TR1::expint;\n+using std::_GLIBCXX_TR1::expintl;\n+\n+using std::_GLIBCXX_TR1::hermitef;\n+using std::_GLIBCXX_TR1::hermite;\n+using std::_GLIBCXX_TR1::hermitel;\n+\n+using std::_GLIBCXX_TR1::hypergf;\n+using std::_GLIBCXX_TR1::hyperg;\n+using std::_GLIBCXX_TR1::hypergl;\n+\n+using std::_GLIBCXX_TR1::laguerref;\n+using std::_GLIBCXX_TR1::laguerre;\n+using std::_GLIBCXX_TR1::laguerrel;\n+\n+using std::_GLIBCXX_TR1::legendref;\n+using std::_GLIBCXX_TR1::legendre;\n+using std::_GLIBCXX_TR1::legendrel;\n+\n+using std::_GLIBCXX_TR1::riemann_zetaf;\n+using std::_GLIBCXX_TR1::riemann_zeta;\n+using std::_GLIBCXX_TR1::riemann_zetal;\n+\n+using std::_GLIBCXX_TR1::sph_besself;\n+using std::_GLIBCXX_TR1::sph_bessel;\n+using std::_GLIBCXX_TR1::sph_bessell;\n+\n+using std::_GLIBCXX_TR1::sph_legendref;\n+using std::_GLIBCXX_TR1::sph_legendre;\n+using std::_GLIBCXX_TR1::sph_legendrel;\n+\n+using std::_GLIBCXX_TR1::sph_neumannf;\n+using std::_GLIBCXX_TR1::sph_neumann;\n+using std::_GLIBCXX_TR1::sph_neumannl;\n+\n #endif"}, {"sha": "c7065a2251eae3fe636aaaf90229bea4b86eb456", "filename": "libstdc++-v3/include/tr1/modified_bessel_func.tcc", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmodified_bessel_func.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,450 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/modified_bessel_func.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland.\n+//\n+// References:\n+//   (1) Handbook of Mathematical Functions,\n+//       Ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 9, pp. 355-434, Section 10 pp. 435-478\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,\n+//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),\n+//       2nd ed, pp. 246-249.\n+\n+#ifndef _TR1_MODIFIED_BESSEL_FUNC_TCC\n+#define _TR1_MODIFIED_BESSEL_FUNC_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief  Compute the modified Bessel functions @f$ I_\\nu(x) @f$ and\n+     *           @f$ K_\\nu(x) @f$ and their first derivatives\n+     *           @f$ I'_\\nu(x) @f$ and @f$ K'_\\nu(x) @f$ respectively.\n+     *           These four functions are computed together for numerical\n+     *           stability.\n+     *\n+     *   @param  __nu  The order of the Bessel functions.\n+     *   @param  __x   The argument of the Bessel functions.\n+     *   @param  __Inu  The output regular modified Bessel function.\n+     *   @param  __Knu  The output irregular modified Bessel function.\n+     *   @param  __Ipnu  The output derivative of the regular\n+     *                   modified Bessel function.\n+     *   @param  __Kpnu  The output derivative of the irregular\n+     *                   modified Bessel function.\n+     */\n+    template <typename _Tp>\n+    void\n+    __bessel_ik(const _Tp __nu, const _Tp __x,\n+                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)\n+    {\n+      if (__x == _Tp(0))\n+        {\n+          if (__nu == _Tp(0))\n+            {\n+              __Inu = _Tp(1);\n+              __Ipnu = _Tp(0);\n+            }\n+          else if (__nu == _Tp(1))\n+            {\n+              __Inu = _Tp(0);\n+              __Ipnu = _Tp(0.5L);\n+            }\n+          else\n+            {\n+              __Inu = _Tp(0);\n+              __Ipnu = _Tp(0);\n+            }\n+          __Knu = std::numeric_limits<_Tp>::infinity();\n+          __Kpnu = -std::numeric_limits<_Tp>::infinity();\n+          return;\n+        }\n+\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();\n+      const int __max_iter = 15000;\n+      const _Tp __x_min = _Tp(2);\n+\n+      const int __nl = static_cast<int>(__nu + _Tp(0.5L));\n+\n+      const _Tp __mu = __nu - __nl;\n+      const _Tp __mu2 = __mu * __mu;\n+      const _Tp __xi = _Tp(1) / __x;\n+      const _Tp __xi2 = _Tp(2) * __xi;\n+      _Tp __h = __nu * __xi;\n+      if ( __h < __fp_min )\n+        __h = __fp_min;\n+      _Tp __b = __xi2 * __nu;\n+      _Tp __d = _Tp(0);\n+      _Tp __c = __h;\n+      int __i;\n+      for ( __i = 1; __i <= __max_iter; ++__i )\n+        {\n+          __b += __xi2;\n+          __d = _Tp(1) / (__b + __d);\n+          __c = __b + _Tp(1) / __c;\n+          const _Tp __del = __c * __d;\n+          __h *= __del;\n+          if (std::abs(__del - _Tp(1)) < __eps)\n+            break;\n+        }\n+      if (__i > __max_iter)\n+        std::__throw_runtime_error(__N(\"Argument x too large \"\n+                                       \"in __bessel_jn; \"\n+                                       \"try asymptotic expansion.\"));\n+      _Tp __Inul = __fp_min;\n+      _Tp __Ipnul = __h * __Inul;\n+      _Tp __Inul1 = __Inul;\n+      _Tp __Ipnu1 = __Ipnul;\n+      _Tp __fact = __nu * __xi;\n+      for (int __l = __nl; __l >= 1; --__l)\n+        {\n+          const _Tp __Inutemp = __fact * __Inul + __Ipnul;\n+          __fact -= __xi;\n+          __Ipnul = __fact * __Inutemp + __Inul;\n+          __Inul = __Inutemp;\n+        }\n+      _Tp __f = __Ipnul / __Inul;\n+      _Tp __Kmu, __Knu1;\n+      if (__x < __x_min)\n+        {\n+          const _Tp __x2 = __x / _Tp(2);\n+          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;\n+          const _Tp __fact = (std::abs(__pimu) < __eps\n+                            ? _Tp(1) : __pimu / std::sin(__pimu));\n+          _Tp __d = -std::log(__x2);\n+          _Tp __e = __mu * __d;\n+          const _Tp __fact2 = (std::abs(__e) < __eps\n+                            ? _Tp(1) : std::sinh(__e) / __e);\n+          _Tp __gam1, __gam2, __gampl, __gammi;\n+          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);\n+          _Tp __ff = __fact\n+                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);\n+          _Tp __sum = __ff;\n+          __e = std::exp(__e);\n+          _Tp __p = __e / (_Tp(2) * __gampl);\n+          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);\n+          _Tp __c = _Tp(1);\n+          __d = __x2 * __x2;\n+          _Tp __sum1 = __p;\n+          int __i;\n+          for (__i = 1; __i <= __max_iter; ++__i)\n+            {\n+              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);\n+              __c *= __d / __i;\n+              __p /= __i - __mu;\n+              __q /= __i + __mu;\n+              const _Tp __del = __c * __ff;\n+              __sum += __del; \n+              const _Tp __del1 = __c * (__p - __i * __ff);\n+              __sum1 += __del1;\n+              if (std::abs(__del) < __eps * std::abs(__sum))\n+                break;\n+            }\n+          if (__i > __max_iter)\n+            std::__throw_runtime_error(__N(\"Bessel k series failed to converge \"\n+                                           \"in __bessel_jn.\"));\n+          __Kmu = __sum;\n+          __Knu1 = __sum1 * __xi2;\n+        }\n+      else\n+        {\n+          _Tp __b = _Tp(2) * (_Tp(1) + __x);\n+          _Tp __d = _Tp(1) / __b;\n+          _Tp __delh = __d;\n+          _Tp __h = __delh;\n+          _Tp __q1 = _Tp(0);\n+          _Tp __q2 = _Tp(1);\n+          _Tp __a1 = _Tp(0.25L) - __mu2;\n+          _Tp __q = __c = __a1;\n+          _Tp __a = -__a1;\n+          _Tp __s = _Tp(1) + __q * __delh;\n+          int __i;\n+          for (__i = 2; __i <= __max_iter; ++__i)\n+            {\n+              __a -= 2 * (__i - 1);\n+              __c = -__a * __c / __i;\n+              const _Tp __qnew = (__q1 - __b * __q2) / __a;\n+              __q1 = __q2;\n+              __q2 = __qnew;\n+              __q += __c * __qnew;\n+              __b += _Tp(2);\n+              __d = _Tp(1) / (__b + __a * __d);\n+              __delh = (__b * __d - _Tp(1)) * __delh;\n+              __h += __delh;\n+              const _Tp __dels = __q * __delh;\n+              __s += __dels;\n+              if ( std::abs(__dels / __s) < __eps )\n+                break;\n+            }\n+          if (__i > __max_iter)\n+            std::__throw_runtime_error(__N(\"Steed's method failed \"\n+                                           \"in __bessel_jn.\"));\n+          __h = __a1 * __h;\n+          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))\n+                * std::exp(-__x) / __s;\n+          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;\n+        }\n+\n+      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;\n+      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);\n+      __Inu = __Inumu * __Inul1 / __Inul;\n+      __Ipnu = __Inumu * __Ipnu1 / __Inul;\n+      for ( __i = 1; __i <= __nl; ++__i )\n+        {\n+          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;\n+          __Kmu = __Knu1;\n+          __Knu1 = __Knutemp;\n+        }\n+      __Knu = __Kmu;\n+      __Kpnu = __nu * __xi * __Kmu - __Knu1;\n+  \n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the regular modified Bessel function of order\n+     *           \\f$ \\nu \\f$: \\f$ I_{\\nu}(x) \\f$.\n+     *\n+     *   The regular modified cylindrical Bessel function is:\n+     *   @f[\n+     *    I_{\\nu}(x) = \\sum_{k=0}^{\\infty}\n+     *              \\frac{(x/2)^{\\nu + 2k}}{k!\\Gamma(\\nu+k+1)}\n+     *   @f]\n+     *\n+     *   @param  __nu  The order of the regular modified Bessel function.\n+     *   @param  __x   The argument of the regular modified Bessel function.\n+     *   @return  The output regular modified Bessel function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __cyl_bessel_i(const _Tp __nu, const _Tp __x)\n+    {\n+      if (__nu < _Tp(0) || __x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __cyl_bessel_i.\"));\n+      else if (__isnan(__nu) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))\n+        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);\n+      else\n+        {\n+          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;\n+          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);\n+          return __I_nu;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the irregular modified Bessel function\n+     *           \\f$ K_{\\nu}(x) \\f$ of order \\f$ \\nu \\f$.\n+     *\n+     *   The irregular modified Bessel function is defined by:\n+     *   @f[\n+     *      K_{\\nu}(x) = \\frac{\\pi}{2}\n+     *                   \\frac{I_{-\\nu}(x) - I_{\\nu}(x)}{\\sin \\nu\\pi}\n+     *   @f]\n+     *   where for integral \\f$ \\nu = n \\f$ a limit is taken:\n+     *   \\f$ lim_{\\nu \\to n} \\f$.\n+     *\n+     *   @param  __nu  The order of the irregular modified Bessel function.\n+     *   @param  __x   The argument of the irregular modified Bessel function.\n+     *   @return  The output irregular modified Bessel function.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __cyl_bessel_k(const _Tp __nu, const _Tp __x)\n+    {\n+      if (__nu < _Tp(0) || __x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Bad argument \"\n+                                      \"in __cyl_bessel_k.\"));\n+      else if (__isnan(__nu) || __isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        {\n+          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;\n+          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);\n+          return __K_nu;\n+        }\n+    }\n+\n+\n+    /**\n+     *   @brief  Compute the spherical modified Bessel functions\n+     *           @f$ i_n(x) @f$ and @f$ k_n(x) @f$ and their first\n+     *           derivatives @f$ i'_n(x) @f$ and @f$ k'_n(x) @f$\n+     *           respectively.\n+     *\n+     *   @param  __n  The order of the modified spherical Bessel function.\n+     *   @param  __x  The argument of the modified spherical Bessel function.\n+     *   @param  __i_n  The output regular modified spherical Bessel function.\n+     *   @param  __k_n  The output irregular modified spherical\n+     *                  Bessel function.\n+     *   @param  __ip_n  The output derivative of the regular modified\n+     *                   spherical Bessel function.\n+     *   @param  __kp_n  The output derivative of the irregular modified\n+     *                   spherical Bessel function.\n+     */\n+    template <typename _Tp>\n+    void\n+    __sph_bessel_ik(const unsigned int __n, const _Tp __x,\n+                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)\n+    {\n+      const _Tp __nu = _Tp(__n) + _Tp(0.5L);\n+\n+      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;\n+      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);\n+\n+      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()\n+                         / std::sqrt(__x);\n+\n+      __i_n = __factor * __I_nu;\n+      __k_n = __factor * __K_nu;\n+      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);\n+      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);\n+\n+      return;\n+    }\n+\n+\n+    /**\n+     *   @brief  Compute the Airy functions\n+     *           @f$ Ai(x) @f$ and @f$ Bi(x) @f$ and their first\n+     *           derivatives @f$ Ai'(x) @f$ and @f$ Bi(x) @f$\n+     *           respectively.\n+     *\n+     *   @param  __n  The order of the Airy functions.\n+     *   @param  __x  The argument of the Airy functions.\n+     *   @param  __i_n  The output Airy function.\n+     *   @param  __k_n  The output Airy function.\n+     *   @param  __ip_n  The output derivative of the Airy function.\n+     *   @param  __kp_n  The output derivative of the Airy function.\n+     */\n+    template <typename _Tp>\n+    void\n+    __airy(const _Tp __x,\n+           _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)\n+    {\n+      const _Tp __absx = std::abs(__x);\n+      const _Tp __rootx = std::sqrt(__absx);\n+      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);\n+\n+      if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__x > _Tp(0))\n+        {\n+          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;\n+\n+          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);\n+          __Ai = __rootx * __K_nu\n+               / (__numeric_constants<_Tp>::__sqrt3()\n+                * __numeric_constants<_Tp>::__pi());\n+          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()\n+                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());\n+\n+          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);\n+          __Aip = -__x * __K_nu\n+                / (__numeric_constants<_Tp>::__sqrt3()\n+                 * __numeric_constants<_Tp>::__pi());\n+          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()\n+                      + _Tp(2) * __I_nu\n+                      / __numeric_constants<_Tp>::__sqrt3());\n+        }\n+      else if (__x < _Tp(0))\n+        {\n+          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;\n+\n+          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);\n+          __Ai = __rootx * (__J_nu\n+                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);\n+          __Bi = -__rootx * (__N_nu\n+                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);\n+\n+          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);\n+          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()\n+                          + __J_nu) / _Tp(2);\n+          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()\n+                          - __N_nu) / _Tp(2);\n+        }\n+      else\n+        {\n+          //  Reference:\n+          //    Abramowitz & Stegun, page 446 section 10.4.4 on Airy functions.\n+          //  The number is Ai(0) = 3^{-2/3}/\\Gamma(2/3).\n+          __Ai = _Tp(0.35502805388781723926L);\n+          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();\n+\n+          //  Reference:\n+          //    Abramowitz & Stegun, page 446 section 10.4.5 on Airy functions.\n+          //  The number is Ai'(0) = -3^{-1/3}/\\Gamma(1/3).\n+          __Aip = -_Tp(0.25881940379280679840L);\n+          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();\n+        }\n+\n+      return;\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_MODIFIED_BESSEL_FUNC_TCC"}, {"sha": "3a7bf9218338eec59588eccc9016a05686dd9f54", "filename": "libstdc++-v3/include/tr1/poly_hermite.tcc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_hermite.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,138 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/poly_hermite.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       Ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications, Section 22 pp. 773-802\n+\n+#ifndef _TR1_POLY_HERMITE_TCC\n+#define _TR1_POLY_HERMITE_TCC 1\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief This routine returns the Hermite polynomial\n+     *          of order n: \\f$ H_n(x) \\f$ by recursion on n.\n+     * \n+     *   The Hermite polynomial is defined by:\n+     *   @f[\n+     *     H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2}\n+     *   @f]\n+     *\n+     *   @param __n The order of the Hermite polynomial.\n+     *   @param __x The argument of the Hermite polynomial.\n+     *   @return The value of the Hermite polynomial of order n\n+     *           and argument x.\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __poly_hermite_recursion(const unsigned int __n, const _Tp __x)\n+    {\n+      //  Compute H_0.\n+      _Tp __H_0 = 1;\n+      if (__n == 0)\n+        return __H_0;\n+\n+      //  Compute H_1.\n+      _Tp __H_1 = 2 * __x;\n+      if (__n == 1)\n+        return __H_1;\n+\n+      //  Compute H_n.\n+      _Tp __H_n, __H_nm1, __H_nm2;\n+      unsigned int __i;\n+      for  (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)\n+        {\n+          __H_n = 2 * (__x * __H_nm1 + (__i - 1) * __H_nm2);\n+          __H_nm2 = __H_nm1;\n+          __H_nm1 = __H_n;\n+        }\n+\n+      return __H_n;\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the Hermite polynomial\n+     *          of order n: \\f$ H_n(x) \\f$.\n+     * \n+     *   The Hermite polynomial is defined by:\n+     *   @f[\n+     *     H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2}\n+     *   @f]\n+     *\n+     *   @param __n The order of the Hermite polynomial.\n+     *   @param __x The argument of the Hermite polynomial.\n+     *   @return The value of the Hermite polynomial of order n\n+     *           and argument x.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __poly_hermite(const unsigned int __n, const _Tp __x)\n+    {\n+      if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else\n+        return __poly_hermite_recursion(__n, __x);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_POLY_HERMITE_TCC"}, {"sha": "5200cab79c092db1f86934d7d76bcd82b850a32e", "filename": "libstdc++-v3/include/tr1/poly_laguerre.tcc", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fpoly_laguerre.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,342 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/poly_laguerre.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       Ed. Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications,\n+//       Section 13, pp. 509-510, Section 22 pp. 773-802\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+\n+#ifndef _TR1_POLY_LAGUERRE_TCC\n+#define _TR1_POLY_LAGUERRE_TCC 1\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+\n+    /**\n+     *   @brief This routine returns the associated Laguerre polynomial \n+     *          of order @f$ n @f$, degree @f$ \\alpha @f$ for large n.\n+     *   Abramowitz & Stegun, 13.5.21\n+     *\n+     *   @param __n The order of the Laguerre function.\n+     *   @param __alpha The degree of the Laguerre function.\n+     *   @param __x The argument of the Laguerre function.\n+     *   @return The value of the Laguerre function of order n,\n+     *           degree @f$ \\alpha @f$, and argument x.\n+     *\n+     *  This is from the GNU Scientific Library.\n+     */\n+    template<typename _Tpa, typename _Tp>\n+    _Tp\n+    __poly_laguerre_large_n(const unsigned __n, const _Tpa __alpha,\n+                            const _Tp __x)\n+    {\n+      const _Tp __a = -_Tp(__n);\n+      const _Tp __b = _Tp(__alpha) + _Tp(1);\n+      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;\n+      const _Tp __cos2th = __x / __eta;\n+      const _Tp __sin2th = _Tp(1) - __cos2th;\n+      const _Tp __th = std::acos(std::sqrt(__cos2th));\n+      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()\n+                        * __numeric_constants<_Tp>::__pi_2()\n+                        * __eta * __eta * __cos2th * __sin2th;\n+\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+      const _Tp __lg_b = std::_GLIBCXX_TR1::lgamma(_Tp(__n) + __b);\n+      const _Tp __lnfact = std::_GLIBCXX_TR1::lgamma(_Tp(__n + 1));\n+#else\n+      const _Tp __lg_b = __log_gamma(_Tp(__n) + __b);\n+      const _Tp __lnfact = __log_gamma(_Tp(__n + 1));\n+#endif\n+\n+      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)\n+                      * std::log(_Tp(0.25L) * __x * __eta);\n+      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);\n+      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x\n+                      + __pre_term1 - __pre_term2;\n+      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());\n+      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta\n+                              * (_Tp(2) * __th\n+                               - std::sin(_Tp(2) * __th))\n+                               + __numeric_constants<_Tp>::__pi_4());\n+      _Tp __ser = __ser_term1 + __ser_term2;\n+\n+      return std::exp(__lnpre) * __ser;\n+    }\n+\n+\n+    /**\n+     *  @brief  Evaluate the polynomial based on the confluent hypergeometric\n+     *          function in a safe way, with no restriction on the arguments.\n+     *\n+     *   The associated Laguerre function is defined by\n+     *   @f[\n+     *       L_n^\\alpha(x) = \\frac{(\\alpha + 1)_n}{n!}\n+     *                       _1F_1(-n; \\alpha + 1; x)\n+     *   @f]\n+     *   where @f$ (\\alpha)_n @f$ is the Pochhammer symbol and\n+     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.\n+     *\n+     *  This function assumes x != 0.\n+     *\n+     *  This is from the GNU Scientific Library.\n+     */\n+    template<typename _Tpa, typename _Tp>\n+    _Tp\n+    __poly_laguerre_hyperg(const unsigned int __n, const _Tpa __alpha, const _Tp __x)\n+    {\n+      const _Tp __b = _Tp(__alpha) + _Tp(1);\n+      const _Tp __mx = -__x;\n+      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)\n+                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));\n+      //  Get |x|^n/n!\n+      _Tp __tc = _Tp(1);\n+      const _Tp __ax = std::abs(__x);\n+      for (unsigned int __k = 1; __k <= __n; ++__k)\n+        __tc *= (__ax / __k);\n+\n+      _Tp __term = __tc * __tc_sgn;\n+      _Tp __sum = __term;\n+      for (int __k = int(__n) - 1; __k >= 0; --__k)\n+        {\n+          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))\n+                  * _Tp(__k + 1) / __mx;\n+          __sum += __term;\n+        }\n+\n+      return __sum;\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the associated Laguerre polynomial \n+     *          of order @f$ n @f$, degree @f$ \\alpha @f$: @f$ L_n^\\alpha(x) @f$\n+     *          by recursion.\n+     *\n+     *   The associated Laguerre function is defined by\n+     *   @f[\n+     *       L_n^\\alpha(x) = \\frac{(\\alpha + 1)_n}{n!}\n+     *                       _1F_1(-n; \\alpha + 1; x)\n+     *   @f]\n+     *   where @f$ (\\alpha)_n @f$ is the Pochhammer symbol and\n+     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.\n+     *\n+     *   The associated Laguerre polynomial is defined for integral\n+     *   @f$ \\alpha = m @f$ by:\n+     *   @f[\n+     *       L_n^m(x) = (-1)^m \\frac{d^m}{dx^m} L_{n + m}(x)\n+     *   @f]\n+     *   where the Laguerre polynomial is defined by:\n+     *   @f[\n+     *       L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+     *   @f]\n+     *\n+     *   @param __n The order of the Laguerre function.\n+     *   @param __alpha The degree of the Laguerre function.\n+     *   @param __x The argument of the Laguerre function.\n+     *   @return The value of the Laguerre function of order n,\n+     *           degree @f$ \\alpha @f$, and argument x.\n+     */\n+    template<typename _Tpa, typename _Tp>\n+    _Tp\n+    __poly_laguerre_recursion(const unsigned int __n,\n+                              const _Tpa __alpha, const _Tp __x)\n+    {\n+      //   Compute l_0.\n+      _Tp __l_0 = _Tp(1);\n+      if  (__n == 0)\n+        return __l_0;\n+\n+      //  Compute l_1^alpha.\n+      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha);\n+      if  (__n == 1)\n+        return __l_1;\n+\n+      //  Compute l_n^alpha by recursion on n.\n+      _Tp __l_n2 = __l_0;\n+      _Tp __l_n1 = __l_1;\n+      _Tp __l_n = _Tp(0);\n+      for  (unsigned int __nn = 2; __nn <= __n; ++__nn)\n+        {\n+            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha) - __x)\n+                  * __l_n1 / _Tp(__nn)\n+                  - (_Tp(__nn - 1) + _Tp(__alpha)) * __l_n2 / _Tp(__nn);\n+            __l_n2 = __l_n1;\n+            __l_n1 = __l_n;\n+        }\n+\n+      return __l_n;\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the associated Laguerre polynomial\n+     *          of order n, degree @f$ \\alpha @f$: @f$ L_n^alpha(x) @f$.\n+     *\n+     *   The associated Laguerre function is defined by\n+     *   @f[\n+     *       L_n^\\alpha(x) = \\frac{(\\alpha + 1)_n}{n!}\n+     *                       _1F_1(-n; \\alpha + 1; x)\n+     *   @f]\n+     *   where @f$ (\\alpha)_n @f$ is the Pochhammer symbol and\n+     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.\n+     *\n+     *   The associated Laguerre polynomial is defined for integral\n+     *   @f$ \\alpha = m @f$ by:\n+     *   @f[\n+     *       L_n^m(x) = (-1)^m \\frac{d^m}{dx^m} L_{n + m}(x)\n+     *   @f]\n+     *   where the Laguerre polynomial is defined by:\n+     *   @f[\n+     *       L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+     *   @f]\n+     *\n+     *   @param __n The order of the Laguerre function.\n+     *   @param __alpha The degree of the Laguerre function.\n+     *   @param __x The argument of the Laguerre function.\n+     *   @return The value of the Laguerre function of order n,\n+     *           degree @f$ \\alpha @f$, and argument x.\n+     */\n+    template<typename _Tpa, typename _Tp>\n+    inline _Tp\n+    __poly_laguerre(const unsigned int __n, const _Tpa __alpha,\n+                    const _Tp __x)\n+    {\n+      if (__x < _Tp(0))\n+        std::__throw_domain_error(__N(\"Negative argument \"\n+                                      \"in __poly_laguerre.\"));\n+      //  Return NaN on NaN input.\n+      else if (__isnan(__x))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__n == 0)\n+        return _Tp(1);\n+      else if (__n == 1)\n+        return _Tp(1) + _Tp(__alpha) - __x;\n+      else if (__x == _Tp(0))\n+        {\n+          _Tp __prod = _Tp(__alpha) + _Tp(1);\n+          for (unsigned int __k = 2; __k <= __n; ++__k)\n+            __prod *= (_Tp(__alpha) + _Tp(__k)) / _Tp(__k);\n+          return __prod;\n+        }\n+      else if (__n > 10000000 && _Tp(__alpha) > -_Tp(1)\n+            && __x < _Tp(2) * (_Tp(__alpha) + _Tp(1)) + _Tp(4 * __n))\n+        return __poly_laguerre_large_n(__n, __alpha, __x);\n+      else if (_Tp(__alpha) >= _Tp(0)\n+           || (__x > _Tp(0) && _Tp(__alpha) < -_Tp(__n + 1)))\n+        return __poly_laguerre_recursion(__n, __alpha, __x);\n+      else\n+        return __poly_laguerre_hyperg(__n, __alpha, __x);\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the associated Laguerre polynomial\n+     *          of order n, degree m: @f$ L_n^m @f$.\n+     *\n+     *   The associated Laguerre polynomial is defined for integral\n+     *   @f$ \\alpha = m @f$ by:\n+     *   @f[\n+     *       L_n^m(x) = (-1)^m \\frac{d^m}{dx^m} L_{n + m}(x)\n+     *   @f]\n+     *   where the Laguerre polynomial is defined by:\n+     *   @f[\n+     *       L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+     *   @f]\n+     *\n+     *   @param __n The order of the Laguerre polynomial.\n+     *   @param __m The degree of the Laguerre polynomial.\n+     *   @param __x The argument of the Laguerre polynomial.\n+     *   @return The value of the associated Laguerre polynomial of order n,\n+     *           degree m, and argument x.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __assoc_laguerre(const unsigned int __n, const unsigned int __m,\n+                     const _Tp __x)\n+    {\n+      return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x);\n+    }\n+\n+\n+    /**\n+     *   @brief This routine returns the associated Laguerre polynomial\n+     *          of order n: @f$ L_n(x) @f$.\n+     *\n+     *   The Laguerre polynomial is defined by:\n+     *   @f[\n+     *       L_n(x) = \\frac{e^x}{n!} \\frac{d^n}{dx^n} (x^ne^{-x})\n+     *   @f]\n+     *\n+     *   @param __n The order of the Laguerre polynomial.\n+     *   @param __x The argument of the Laguerre polynomial.\n+     *   @return The value of the Laguerre polynomial of order n\n+     *           and argument x.\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __laguerre(const unsigned int __n, const _Tp __x)\n+    {\n+      return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_POLY_LAGUERRE_TCC"}, {"sha": "598d73e64112dc088e6dcb9a97f552ce490c3c9e", "filename": "libstdc++-v3/include/tr1/riemann_zeta.tcc", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Friemann_zeta.tcc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,449 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006-2007\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/riemann_zeta.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on:\n+//   (1) Handbook of Mathematical Functions,\n+//       Ed. by Milton Abramowitz and Irene A. Stegun,\n+//       Dover Publications, New-York, Section 5, pp. 807-808.\n+//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl\n+//   (3) Gamma, Exploring Euler's Constant, Julian Havil,\n+//       Princeton, 2003.\n+\n+#ifndef _TR1_RIEMANN_ZETA_TCC\n+#define _TR1_RIEMANN_ZETA_TCC 1\n+\n+#include \"special_function_util.h\"\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  // [5.2] Special functions\n+\n+  /**\n+   * @ingroup tr1_math_spec_func\n+   * @{\n+   */\n+\n+  //\n+  // Implementation-space details.\n+  //\n+  namespace __detail\n+  {\n+\n+    /**\n+     *   @brief  Compute the Riemann zeta function @f$ \\zeta(s) @f$\n+     *           by summation for s > 1.\n+     * \n+     *   The Riemann zeta function is defined by:\n+     *    \\f[\n+     *      \\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{k^{s}} for s > 1\n+     *    \\f]\n+     *   For s < 1 use the reflection formula:\n+     *    \\f[\n+     *      \\zeta(s) = 2^s \\pi^{s-1} \\Gamma(1-s) \\zeta(1-s)\n+     *    \\f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __riemann_zeta_sum(const _Tp __s)\n+    {\n+      //  A user shouldn't get to this.\n+      if (__s < _Tp(1))\n+        std::__throw_domain_error(__N(\"Bad argument in zeta sum.\"));\n+\n+      const unsigned int max_iter = 10000;\n+      _Tp __zeta = _Tp(0);\n+      for (unsigned int __k = 1; __k < max_iter; ++__k)\n+        {\n+          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);\n+          if (__term < std::numeric_limits<_Tp>::epsilon())\n+            {\n+              break;\n+            }\n+          __zeta += __term;\n+        }\n+\n+      return __zeta;\n+    }\n+\n+\n+    /**\n+     *   @brief  Evaluate the Riemann zeta function @f$ \\zeta(s) @f$\n+     *           by an alternate series for s > 0.\n+     * \n+     *   The Riemann zeta function is defined by:\n+     *    \\f[\n+     *      \\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{k^{s}} for s > 1\n+     *    \\f]\n+     *   For s < 1 use the reflection formula:\n+     *    \\f[\n+     *      \\zeta(s) = 2^s \\pi^{s-1} \\Gamma(1-s) \\zeta(1-s)\n+     *    \\f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __riemann_zeta_alt(const _Tp __s)\n+    {\n+      _Tp __sgn = _Tp(1);\n+      _Tp __zeta = _Tp(0);\n+      for (unsigned int __i = 1; __i < 10000000; ++__i)\n+        {\n+          _Tp __term = __sgn / std::pow(__i, __s);\n+          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+          __zeta += __term;\n+          __sgn *= _Tp(-1);\n+        }\n+      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);\n+\n+      return __zeta;\n+    }\n+\n+\n+    /**\n+     *   @brief  Evaluate the Riemann zeta function by series for all s != 1.\n+     *           Convergence is great until largish negative numbers.\n+     *           Then the convergence of the > 0 sum gets better.\n+     *\n+     *   The series is:\n+     *    \\f[\n+     *      \\zeta(s) = \\frac{1}{1-2^{1-s}}\n+     *                 \\sum_{n=0}^{\\infty} \\frac{1}{2^{n+1}}\n+     *                 \\sum_{k=0}^{n} (-1)^k \\frac{n!}{(n-k)!k!} (k+1)^{-s}\n+     *    \\f]\n+     *   Havil 2003, p. 206.\n+     *\n+     *   The Riemann zeta function is defined by:\n+     *    \\f[\n+     *      \\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{k^{s}} for s > 1\n+     *    \\f]\n+     *   For s < 1 use the reflection formula:\n+     *    \\f[\n+     *      \\zeta(s) = 2^s \\pi^{s-1} \\Gamma(1-s) \\zeta(1-s)\n+     *    \\f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __riemann_zeta_glob(const _Tp __s)\n+    {\n+      _Tp __zeta = _Tp(0);\n+\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      //  Max e exponent before overflow.\n+      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10\n+                               * std::log(_Tp(10)) - _Tp(1);\n+\n+      //  This series works until the binomial coefficient blows up\n+      //  so use reflection.\n+      if (__s < _Tp(0))\n+        {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+          if (std::_GLIBCXX_TR1::fmod(__s,_Tp(2)) == _Tp(0))\n+            return _Tp(0);\n+          else\n+#endif\n+            {\n+              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);\n+              __zeta *= std::pow(_Tp(2)\n+                     * __numeric_constants<_Tp>::__pi(), __s)\n+                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+                     * std::exp(std::_GLIBCXX_TR1::lgamma(_Tp(1) - __s))\n+#else\n+                     * std::exp(__log_gamma(_Tp(1) - __s))\n+#endif\n+                     / __numeric_constants<_Tp>::__pi();\n+              return __zeta;\n+            }\n+        }\n+\n+      _Tp __num = _Tp(0.5L);\n+      const unsigned int __maxit = 10000;\n+      for (unsigned int __i = 0; __i < __maxit; ++__i)\n+        {\n+          bool __punt = false;\n+          _Tp __sgn = _Tp(1);\n+          _Tp __term = _Tp(0);\n+          for (unsigned int __j = 0; __j <= __i; ++__j)\n+            {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+              _Tp __bincoeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i))\n+                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __j))\n+                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i - __j));\n+#else\n+              _Tp __bincoeff =  __log_gamma(_Tp(1 + __i))\n+                              - __log_gamma(_Tp(1 + __j))\n+                              - __log_gamma(_Tp(1 + __i - __j));\n+#endif\n+              if (__bincoeff > __max_bincoeff)\n+                {\n+                  //  This only gets hit for x << 0.\n+                  __punt = true;\n+                  break;\n+                }\n+              __bincoeff = std::exp(__bincoeff);\n+              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);\n+              __sgn *= _Tp(-1);\n+            }\n+          if (__punt)\n+            break;\n+          __term *= __num;\n+          __zeta += __term;\n+          if (std::abs(__term/__zeta) < __eps)\n+            break;\n+          __num *= _Tp(0.5L);\n+        }\n+\n+      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);\n+\n+      return __zeta;\n+    }\n+\n+\n+    /**\n+     *   @brief  Compute the Riemann zeta function @f$ \\zeta(s) @f$\n+     *           using the product over prime factors.\n+     *    \\f[\n+     *      \\zeta(s) = \\Pi_{i=1}^\\infty \\frac{1}{1 - p_i^{-s}}\n+     *    \\f]\n+     *    where @f$ {p_i} @f$ are the prime numbers.\n+     * \n+     *   The Riemann zeta function is defined by:\n+     *    \\f[\n+     *      \\zeta(s) = \\sum_{k=1}^{\\infty} \\frac{1}{k^{s}} for s > 1\n+     *    \\f]\n+     *   For s < 1 use the reflection formula:\n+     *    \\f[\n+     *      \\zeta(s) = 2^s \\pi^{s-1} \\Gamma(1-s) \\zeta(1-s)\n+     *    \\f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __riemann_zeta_product(const _Tp __s)\n+    {\n+      static const _Tp __prime[] = {\n+        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),\n+        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),\n+        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),\n+        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)\n+      };\n+      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);\n+\n+      _Tp __zeta = _Tp(1);\n+      for (unsigned int __i = 0; __i < __num_primes; ++__i)\n+        {\n+          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);\n+          __zeta *= __fact;\n+          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())\n+            break;\n+        }\n+\n+      __zeta = _Tp(1) / __zeta;\n+\n+      return __zeta;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Riemann zeta function @f$ \\zeta(s) @f$.\n+     * \n+     *   The Riemann zeta function is defined by:\n+     *    \\f[\n+     *      \\zeta(s) = \\sum_{k=1}^{\\infty} k^{-s} for s > 1\n+     *                 \\frac{(2\\pi)^s}{pi} sin(\\frac{\\pi s}{2})\n+     *                 \\Gamma (1 - s) \\zeta (1 - s) for s < 1\n+     *    \\f]\n+     *   For s < 1 use the reflection formula:\n+     *    \\f[\n+     *      \\zeta(s) = 2^s \\pi^{s-1} \\Gamma(1-s) \\zeta(1-s)\n+     *    \\f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __riemann_zeta(const _Tp __s)\n+    {\n+      if (__isnan(__s))\n+        return std::numeric_limits<_Tp>::quiet_NaN();\n+      else if (__s == _Tp(1))\n+        return std::numeric_limits<_Tp>::infinity();\n+      else if (__s < -_Tp(19))\n+        {\n+          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);\n+          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)\n+                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+                 * std::exp(std::_GLIBCXX_TR1::lgamma(_Tp(1) - __s))\n+#else\n+                 * std::exp(__log_gamma(_Tp(1) - __s))\n+#endif\n+                 / __numeric_constants<_Tp>::__pi();\n+          return __zeta;\n+        }\n+      else if (__s < _Tp(20))\n+        {\n+          //  Global double sum or McLaurin?\n+          bool __glob = true;\n+          if (__glob)\n+            return __riemann_zeta_glob(__s);\n+          else\n+            {\n+              if (__s > _Tp(1))\n+                return __riemann_zeta_sum(__s);\n+              else\n+                {\n+                  _Tp __zeta = std::pow(_Tp(2)\n+                                * __numeric_constants<_Tp>::__pi(), __s)\n+                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+                             * std::_GLIBCXX_TR1::tgamma(_Tp(1) - __s)\n+#else\n+                             * std::exp(__log_gamma(_Tp(1) - __s))\n+#endif\n+                             * __riemann_zeta_sum(_Tp(1) - __s);\n+                  return __zeta;\n+                }\n+            }\n+        }\n+      else\n+        return __riemann_zeta_product(__s);\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Hurwitz zeta function @f$ \\zeta(x,s) @f$\n+     *           for all s != 1 and x > -1.\n+     * \n+     *   The Hurwitz zeta function is defined by:\n+     *   @f[\n+     *     \\zeta(x,s) = \\sum_{n=0}^{\\infty} \\frac{1}{(n + x)^s}\n+     *   @f]\n+     *   The Riemann zeta function is a special case:\n+     *   @f[\n+     *     \\zeta(s) = \\zeta(1,s)\n+     *   @f]\n+     * \n+     *   This functions uses the double sum that converges for s != 1\n+     *   and x > -1:\n+     *   @f[\n+     *     \\zeta(x,s) = \\frac{1}{s-1}\n+     *                \\sum_{n=0}^{\\infty} \\frac{1}{n + 1}\n+     *                \\sum_{k=0}^{n} (-1)^k \\frac{n!}{(n-k)!k!} (x+k)^{-s}\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    _Tp\n+    __hurwitz_zeta_glob(const _Tp __a, const _Tp __s)\n+    {\n+      _Tp __zeta = _Tp(0);\n+\n+      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();\n+      //  Max e exponent before overflow.\n+      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10\n+                               * std::log(_Tp(10)) - _Tp(1);\n+\n+      const unsigned int __maxit = 10000;\n+      for (unsigned int __i = 0; __i < __maxit; ++__i)\n+        {\n+          bool __punt = false;\n+          _Tp __sgn = _Tp(1);\n+          _Tp __term = _Tp(0);\n+          for (unsigned int __j = 0; __j <= __i; ++__j)\n+            {\n+#if _GLIBCXX_USE_C99_MATH_TR1\n+              _Tp __bincoeff =  std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i))\n+                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __j))\n+                              - std::_GLIBCXX_TR1::lgamma(_Tp(1 + __i - __j));\n+#else\n+              _Tp __bincoeff =  __log_gamma(_Tp(1 + __i))\n+                              - __log_gamma(_Tp(1 + __j))\n+                              - __log_gamma(_Tp(1 + __i - __j));\n+#endif\n+              if (__bincoeff > __max_bincoeff)\n+                {\n+                  //  This only gets hit for x << 0.\n+                  __punt = true;\n+                  break;\n+                }\n+              __bincoeff = std::exp(__bincoeff);\n+              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);\n+              __sgn *= _Tp(-1);\n+            }\n+          if (__punt)\n+            break;\n+          __term /= _Tp(__i + 1);\n+          if (std::abs(__term / __zeta) < __eps)\n+            break;\n+          __zeta += __term;\n+        }\n+\n+      __zeta /= __s - _Tp(1);\n+\n+      return __zeta;\n+    }\n+\n+\n+    /**\n+     *   @brief  Return the Hurwitz zeta function @f$ \\zeta(x,s) @f$\n+     *           for all s != 1 and x > -1.\n+     * \n+     *   The Hurwitz zeta function is defined by:\n+     *   @f[\n+     *     \\zeta(x,s) = \\sum_{n=0}^{\\infty} \\frac{1}{(n + x)^s}\n+     *   @f]\n+     *   The Riemann zeta function is a special case:\n+     *   @f[\n+     *     \\zeta(s) = \\zeta(1,s)\n+     *   @f]\n+     */\n+    template<typename _Tp>\n+    inline _Tp\n+    __hurwitz_zeta(const _Tp __a, const _Tp __s)\n+    {\n+      return __hurwitz_zeta_glob(__a, __s);\n+    }\n+\n+  } // namespace std::tr1::__detail\n+\n+  /* @} */ // group tr1_math_spec_func\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_RIEMANN_ZETA_TCC"}, {"sha": "ac55165b164553ce97b4f19fd32b4b9a006f82b4", "filename": "libstdc++-v3/include/tr1/special_function_util.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fspecial_function_util.h?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,155 @@\n+// Special functions -*- C++ -*-\n+\n+// Copyright (C) 2006\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file tr1/special_function_util.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+//\n+// ISO C++ 14882 TR1: 5.2  Special functions\n+//\n+\n+// Written by Edward Smith-Rowland based on numerous mathematics books.\n+\n+#ifndef _TR1_SPECIAL_FUNCTION_UTIL_H\n+#define _TR1_SPECIAL_FUNCTION_UTIL_H 1\n+\n+// namespace std::tr1\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+  namespace __detail\n+  {\n+\n+    ///\n+    ///  @brief  A class to encapsulate type dependent floating point\n+    ///          constants.  Not everything will be able to be expressed\n+    ///          as type logic.\n+    ///\n+    template <typename _Tp>\n+    struct __floating_point_constant\n+    {\n+      static const _Tp __value;\n+    };\n+\n+\n+    ///\n+    ///  @brief  A structure for numeric constants.\n+    ///\n+    template<typename _Tp>\n+      struct __numeric_constants\n+      {\n+        ///  Constant @f$ \\pi @f$.\n+        static _Tp __pi() throw()\n+        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }\n+        ///  Constant @f$ \\pi / 2 @f$.\n+        static _Tp __pi_2() throw()\n+        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }\n+        ///  Constant @f$ \\pi / 3 @f$.\n+        static _Tp __pi_3() throw()\n+        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }\n+        ///  Constant @f$ \\pi / 4 @f$.\n+        static _Tp __pi_4() throw()\n+        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }\n+        ///  Constant @f$ 1 / \\pi @f$.\n+        static _Tp __1_pi() throw()\n+        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }\n+        ///  Constant @f$ 2 / \\sqrt(\\pi) @f$.\n+        static _Tp __2_sqrtpi() throw()\n+        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }\n+        ///  Constant @f$ \\sqrt(2) @f$.\n+        static _Tp __sqrt2() throw()\n+        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }\n+        ///  Constant @f$ \\sqrt(3) @f$.\n+        static _Tp __sqrt3() throw()\n+        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }\n+        ///  Constant @f$ \\sqrt(\\pi/2) @f$.\n+        static _Tp __sqrtpio2() throw()\n+        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }\n+        ///  Constant @f$ 1 / sqrt(2) @f$.\n+        static _Tp __sqrt1_2() throw()\n+        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }\n+        ///  Constant @f$ \\log(\\pi) @f$.\n+        static _Tp __lnpi() throw()\n+        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }\n+        ///  Constant Euler's constant @f$ \\gamma_E @f$.\n+        static _Tp __gamma_e() throw()\n+        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }\n+        ///  Constant Euler-Mascheroni @f$ e @f$\n+        static _Tp __euler() throw()\n+        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }\n+      };\n+\n+\n+    ///\n+    ///  @brief  This is a wrapper for the isnan function.\n+    ///          Otherwise, for NaN, all comparisons result in false.\n+    ///          If/when we build a std::isnan out of intrinsics, this\n+    ///          will disappear completely in favor of std::isnan.\n+    ///\n+#if _GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n+\n+    template <typename _Tp>\n+    inline bool __isnan(const _Tp __x)\n+    {\n+      return std::isnan(__x);\n+    }\n+\n+#else\n+\n+    template <typename _Tp>\n+    inline bool __isnan(const _Tp __x)\n+    {\n+      return __builtin_isnan(__x);\n+    }\n+\n+    template <>\n+    inline bool __isnan<float>(const float __x)\n+    {\n+      return __builtin_isnanf(__x);\n+    }\n+\n+    template <>\n+    inline bool __isnan<long double>(const long double __x)\n+    {\n+      return __builtin_isnanl(__x);\n+    }\n+\n+#endif\n+\n+  } // namespace __detail\n+\n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_SPECIAL_FUNCTION_UTIL_H\n+"}, {"sha": "29943ce2a6b1faf1883871b82e80ac58b575253c", "filename": "libstdc++-v3/testsuite/lib/dg-options.exp", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fdg-options.exp?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -1,6 +1,6 @@\n # Handlers for additional dg-xxx keywords in tests.\n \n-# Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+# Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n #\n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -14,11 +14,20 @@\n # \n # You should have received a copy of the GNU General Public License\n # along with this program; if not, write to the Free Software\n-# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n \n+proc dg-require-c-std { args } {\n+    if { ![ check_v3_target_c_std ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+\treturn\n+    }\n+    return\n+}\n \n-proc dg-require-namedlocale { args } {\n-    if { ![ check_v3_target_namedlocale ] } {\n+proc dg-require-debug-mode { args } {\n+    if { ![ check_v3_target_debug_mode ] } {\n \tupvar dg-do-what dg-do-what\n \tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n \treturn\n@@ -35,8 +44,8 @@ proc dg-require-fileio { args } {\n     return\n }\n \n-proc dg-require-time { args } {\n-    if { ![ check_v3_target_time ] } {\n+proc dg-require-namedlocale { args } {\n+    if { ![ check_v3_target_namedlocale ] } {\n \tupvar dg-do-what dg-do-what\n \tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n \treturn\n@@ -53,8 +62,8 @@ proc dg-require-sharedlib { args } {\n     return\n }\n \n-proc dg-require-debug-mode { args } {\n-    if { ![ check_v3_target_debug_mode ] } {\n+proc dg-require-time { args } {\n+    if { ![ check_v3_target_time ] } {\n \tupvar dg-do-what dg-do-what\n \tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n \treturn"}, {"sha": "a8e8a31d9557015aaf499fc7213c22c3f906182a", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -579,6 +579,67 @@ proc check_v3_target_fileio { } {\n     return $et_fileio_saved\n }\n \n+proc check_v3_target_c_std { } {\n+    global et_c_std_saved\n+    global et_c_std_target_name\n+    global tool\t\n+\n+    if { ![info exists et_c_std_target_name] } {\n+\tset et_c_std_target_name \"\"\n+    }\n+\n+    # If the target has changed since we set the cached value, clear it.\n+    set current_target [current_target_name]\n+    if { $current_target != $et_c_std_target_name } {\n+\tverbose \"check_v3_target_c_std: `$et_c_std_target_name'\" 2\n+\tset et_c_std_target_name $current_target\n+\tif [info exists et_c_std_saved] {\n+\t    verbose \"check_v3_target_c_std: removing cached result\" 2\n+\t    unset et_c_std_saved\n+\t}\n+    }\n+\n+    if [info exists et_c_std_saved] {\n+\tverbose \"check_v3_target_c_std: using cached result\" 2\n+    } else {\n+\tset et_c_std_saved 0\n+\n+\t# Set up, compile, and execute a C++ test program that tries to use\n+\t# C99 functionality.\n+\tset src fileio[pid].cc\n+\tset exe fileio[pid].x\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <tr1/cmath>\"\n+\tputs $f \"int main ()\"\n+\tputs $f \"{\"\n+\tputs $f \"  float f = 45.55;\"\n+\tputs $f \"  int i = std::tr1::isnan(f);\"\n+\tputs $f \"  return 0;\"\n+\tputs $f \"}\" \n+\tclose $f\n+\n+\tset lines [v3_target_compile $src $exe executable \"\"]\n+\tfile delete $src\n+\n+\tif [string match \"\" $lines] {\n+\t    # No error message, compilation succeeded.\n+\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n+\t    set status [lindex $result 0]\n+\t    remote_file build delete $exe\n+\n+\t    verbose \"check_v3_target_c_std: status is <$status>\" 2\n+\n+\t    if { $status == \"pass\" } {\n+\t\tset et_c_std_saved 1\n+\t    }\n+\t} else {\n+\t    verbose \"check_v3_target_c_std: compilation failed\" 2\n+\t}\n+    }\n+    return $et_c_std_saved\n+}\n+\n proc check_v3_target_sharedlib { } {\n     global v3-sharedlib\n     return ${v3-sharedlib}"}, {"sha": "98f174fa7b1e18fe3107fec906b83d2777f8a5b9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/01_assoc_laguerre/check_nan.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,57 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.1 assoc_laguerre\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+  unsigned int n = 2, m = 1;\n+\n+  float a = std::tr1::assoc_laguerre(n, m, xf);\n+  float b = std::tr1::assoc_laguerref(n, m, xf);\n+  double c = std::tr1::assoc_laguerre(n, m, xd);\n+  long double d = std::tr1::assoc_laguerre(n, m, xl);\n+  long double e = std::tr1::assoc_laguerrel(n, m, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "b79b5c1fac02938891df3a6610ef5fc422ba2e34", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/01_assoc_laguerre/check_value.cc", "status": "added", "additions": 3566, "deletions": 0, "changes": 3566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "3beffc10ee3879dcc0edd586bacb6f19e4ea7d66", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/01_assoc_laguerre/compile.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.1 assoc_laguerre\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+  unsigned int n = 2, m = 1;\n+\n+  float a = std::tr1::assoc_laguerre(n, m, xf);\n+  float b = std::tr1::assoc_laguerref(n, m, xf);\n+  double c = std::tr1::assoc_laguerre(n, m, xd);\n+  long double d = std::tr1::assoc_laguerre(n, m, xl);\n+  long double e = std::tr1::assoc_laguerrel(n, m, xl);\n+\n+  return;\n+}\n+"}, {"sha": "59cf17a332f9d116f00d33eb2e0a7bd6db1377b9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/01_assoc_laguerre/compile_2.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F01_assoc_laguerre%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.1 assoc_laguerre\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+  unsigned int n = 2, m = 1;\n+\n+  assoc_laguerre(n, m, xf);\n+  assoc_laguerref(n, m, xf);\n+  assoc_laguerre(n, m, xd);\n+  assoc_laguerre(n, m, xl);\n+  assoc_laguerrel(n, m, xl);\n+\n+  return;\n+}\n+"}, {"sha": "174a43c791ceda93172eae2c68ad98297fea0b71", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/02_assoc_legendre/check_nan.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,59 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.2 assoc_legendre\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  unsigned int l = 2, m = 1;\n+\n+  float a = std::tr1::assoc_legendre(l, m, xf);\n+  float b = std::tr1::assoc_legendref(l, m, xf);\n+  double c = std::tr1::assoc_legendre(l, m, xd);\n+  long double d = std::tr1::assoc_legendre(l, m, xl);\n+  long double e = std::tr1::assoc_legendrel(l, m, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "8265137be22d42a0189fc65a5147cd679f2d76ad", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/02_assoc_legendre/check_value.cc", "status": "added", "additions": 2746, "deletions": 0, "changes": 2746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,2746 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  assoc_legendre\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for l=0, m=0.\n+testcase_assoc_legendre<double> data001[] = {\n+  { 1.0000000000000000, 0, 0, \n+          -1.0000000000000000 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.90000000000000002 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.80000000000000004 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.69999999999999996 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.59999999999999998 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.50000000000000000 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.40000000000000002 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.30000000000000004 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.19999999999999996 },\n+  { 1.0000000000000000, 0, 0, \n+          -0.099999999999999978 },\n+  { 1.0000000000000000, 0, 0, \n+          0.0000000000000000 },\n+  { 1.0000000000000000, 0, 0, \n+          0.10000000000000009 },\n+  { 1.0000000000000000, 0, 0, \n+          0.19999999999999996 },\n+  { 1.0000000000000000, 0, 0, \n+          0.30000000000000004 },\n+  { 1.0000000000000000, 0, 0, \n+          0.39999999999999991 },\n+  { 1.0000000000000000, 0, 0, \n+          0.50000000000000000 },\n+  { 1.0000000000000000, 0, 0, \n+          0.60000000000000009 },\n+  { 1.0000000000000000, 0, 0, \n+          0.69999999999999996 },\n+  { 1.0000000000000000, 0, 0, \n+          0.80000000000000004 },\n+  { 1.0000000000000000, 0, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 0, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=0, m=0.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data001[i].l), Tp(data001[i].m),\n+                   Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=1, m=0.\n+testcase_assoc_legendre<double> data002[] = {\n+  { -1.0000000000000000, 1, 0, \n+          -1.0000000000000000 },\n+  { -0.90000000000000002, 1, 0, \n+          -0.90000000000000002 },\n+  { -0.80000000000000004, 1, 0, \n+          -0.80000000000000004 },\n+  { -0.69999999999999996, 1, 0, \n+          -0.69999999999999996 },\n+  { -0.59999999999999998, 1, 0, \n+          -0.59999999999999998 },\n+  { -0.50000000000000000, 1, 0, \n+          -0.50000000000000000 },\n+  { -0.40000000000000002, 1, 0, \n+          -0.40000000000000002 },\n+  { -0.30000000000000004, 1, 0, \n+          -0.30000000000000004 },\n+  { -0.19999999999999996, 1, 0, \n+          -0.19999999999999996 },\n+  { -0.099999999999999978, 1, 0, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 1, 0, \n+          0.0000000000000000 },\n+  { 0.10000000000000009, 1, 0, \n+          0.10000000000000009 },\n+  { 0.19999999999999996, 1, 0, \n+          0.19999999999999996 },\n+  { 0.30000000000000004, 1, 0, \n+          0.30000000000000004 },\n+  { 0.39999999999999991, 1, 0, \n+          0.39999999999999991 },\n+  { 0.50000000000000000, 1, 0, \n+          0.50000000000000000 },\n+  { 0.60000000000000009, 1, 0, \n+          0.60000000000000009 },\n+  { 0.69999999999999996, 1, 0, \n+          0.69999999999999996 },\n+  { 0.80000000000000004, 1, 0, \n+          0.80000000000000004 },\n+  { 0.89999999999999991, 1, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 1, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=1, m=0.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data002[i].l), Tp(data002[i].m),\n+                   Tp(data002[i].x));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=1, m=1.\n+testcase_assoc_legendre<double> data003[] = {\n+  { -0.0000000000000000, 1, 1, \n+          -1.0000000000000000 },\n+  { -0.43588989435406728, 1, 1, \n+          -0.90000000000000002 },\n+  { -0.59999999999999987, 1, 1, \n+          -0.80000000000000004 },\n+  { -0.71414284285428509, 1, 1, \n+          -0.69999999999999996 },\n+  { -0.80000000000000004, 1, 1, \n+          -0.59999999999999998 },\n+  { -0.86602540378443860, 1, 1, \n+          -0.50000000000000000 },\n+  { -0.91651513899116799, 1, 1, \n+          -0.40000000000000002 },\n+  { -0.95393920141694577, 1, 1, \n+          -0.30000000000000004 },\n+  { -0.97979589711327120, 1, 1, \n+          -0.19999999999999996 },\n+  { -0.99498743710661997, 1, 1, \n+          -0.099999999999999978 },\n+  { -1.0000000000000000, 1, 1, \n+          0.0000000000000000 },\n+  { -0.99498743710661997, 1, 1, \n+          0.10000000000000009 },\n+  { -0.97979589711327120, 1, 1, \n+          0.19999999999999996 },\n+  { -0.95393920141694577, 1, 1, \n+          0.30000000000000004 },\n+  { -0.91651513899116799, 1, 1, \n+          0.39999999999999991 },\n+  { -0.86602540378443860, 1, 1, \n+          0.50000000000000000 },\n+  { -0.79999999999999993, 1, 1, \n+          0.60000000000000009 },\n+  { -0.71414284285428509, 1, 1, \n+          0.69999999999999996 },\n+  { -0.59999999999999987, 1, 1, \n+          0.80000000000000004 },\n+  { -0.43588989435406750, 1, 1, \n+          0.89999999999999991 },\n+  { -0.0000000000000000, 1, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=1, m=1.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data003[i].l), Tp(data003[i].m),\n+                   Tp(data003[i].x));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=2, m=0.\n+testcase_assoc_legendre<double> data004[] = {\n+  { 1.0000000000000000, 2, 0, \n+          -1.0000000000000000 },\n+  { 0.71500000000000008, 2, 0, \n+          -0.90000000000000002 },\n+  { 0.46000000000000019, 2, 0, \n+          -0.80000000000000004 },\n+  { 0.23499999999999982, 2, 0, \n+          -0.69999999999999996 },\n+  { 0.039999999999999925, 2, 0, \n+          -0.59999999999999998 },\n+  { -0.12500000000000000, 2, 0, \n+          -0.50000000000000000 },\n+  { -0.25999999999999995, 2, 0, \n+          -0.40000000000000002 },\n+  { -0.36499999999999994, 2, 0, \n+          -0.30000000000000004 },\n+  { -0.44000000000000000, 2, 0, \n+          -0.19999999999999996 },\n+  { -0.48499999999999999, 2, 0, \n+          -0.099999999999999978 },\n+  { -0.50000000000000000, 2, 0, \n+          0.0000000000000000 },\n+  { -0.48499999999999999, 2, 0, \n+          0.10000000000000009 },\n+  { -0.44000000000000000, 2, 0, \n+          0.19999999999999996 },\n+  { -0.36499999999999994, 2, 0, \n+          0.30000000000000004 },\n+  { -0.26000000000000012, 2, 0, \n+          0.39999999999999991 },\n+  { -0.12500000000000000, 2, 0, \n+          0.50000000000000000 },\n+  { 0.040000000000000160, 2, 0, \n+          0.60000000000000009 },\n+  { 0.23499999999999982, 2, 0, \n+          0.69999999999999996 },\n+  { 0.46000000000000019, 2, 0, \n+          0.80000000000000004 },\n+  { 0.71499999999999975, 2, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 2, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=2, m=0.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data004[i].l), Tp(data004[i].m),\n+                   Tp(data004[i].x));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=2, m=1.\n+testcase_assoc_legendre<double> data005[] = {\n+  { 0.0000000000000000, 2, 1, \n+          -1.0000000000000000 },\n+  { 1.1769027147559816, 2, 1, \n+          -0.90000000000000002 },\n+  { 1.4399999999999999, 2, 1, \n+          -0.80000000000000004 },\n+  { 1.4996999699939983, 2, 1, \n+          -0.69999999999999996 },\n+  { 1.4399999999999999, 2, 1, \n+          -0.59999999999999998 },\n+  { 1.2990381056766580, 2, 1, \n+          -0.50000000000000000 },\n+  { 1.0998181667894018, 2, 1, \n+          -0.40000000000000002 },\n+  { 0.85854528127525132, 2, 1, \n+          -0.30000000000000004 },\n+  { 0.58787753826796263, 2, 1, \n+          -0.19999999999999996 },\n+  { 0.29849623113198592, 2, 1, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 2, 1, \n+          0.0000000000000000 },\n+  { -0.29849623113198626, 2, 1, \n+          0.10000000000000009 },\n+  { -0.58787753826796263, 2, 1, \n+          0.19999999999999996 },\n+  { -0.85854528127525132, 2, 1, \n+          0.30000000000000004 },\n+  { -1.0998181667894014, 2, 1, \n+          0.39999999999999991 },\n+  { -1.2990381056766580, 2, 1, \n+          0.50000000000000000 },\n+  { -1.4400000000000002, 2, 1, \n+          0.60000000000000009 },\n+  { -1.4996999699939983, 2, 1, \n+          0.69999999999999996 },\n+  { -1.4399999999999999, 2, 1, \n+          0.80000000000000004 },\n+  { -1.1769027147559821, 2, 1, \n+          0.89999999999999991 },\n+  { -0.0000000000000000, 2, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=2, m=1.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data005[i].l), Tp(data005[i].m),\n+                   Tp(data005[i].x));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=2, m=2.\n+testcase_assoc_legendre<double> data006[] = {\n+  { 0.0000000000000000, 2, 2, \n+          -1.0000000000000000 },\n+  { 0.56999999999999984, 2, 2, \n+          -0.90000000000000002 },\n+  { 1.0799999999999996, 2, 2, \n+          -0.80000000000000004 },\n+  { 1.5300000000000005, 2, 2, \n+          -0.69999999999999996 },\n+  { 1.9200000000000004, 2, 2, \n+          -0.59999999999999998 },\n+  { 2.2500000000000000, 2, 2, \n+          -0.50000000000000000 },\n+  { 2.5200000000000000, 2, 2, \n+          -0.40000000000000002 },\n+  { 2.7300000000000004, 2, 2, \n+          -0.30000000000000004 },\n+  { 2.8799999999999999, 2, 2, \n+          -0.19999999999999996 },\n+  { 2.9700000000000002, 2, 2, \n+          -0.099999999999999978 },\n+  { 3.0000000000000000, 2, 2, \n+          0.0000000000000000 },\n+  { 2.9700000000000002, 2, 2, \n+          0.10000000000000009 },\n+  { 2.8799999999999999, 2, 2, \n+          0.19999999999999996 },\n+  { 2.7300000000000004, 2, 2, \n+          0.30000000000000004 },\n+  { 2.5200000000000000, 2, 2, \n+          0.39999999999999991 },\n+  { 2.2500000000000000, 2, 2, \n+          0.50000000000000000 },\n+  { 1.9199999999999997, 2, 2, \n+          0.60000000000000009 },\n+  { 1.5300000000000005, 2, 2, \n+          0.69999999999999996 },\n+  { 1.0799999999999996, 2, 2, \n+          0.80000000000000004 },\n+  { 0.57000000000000040, 2, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 2, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=2, m=2.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data006[i].l), Tp(data006[i].m),\n+                   Tp(data006[i].x));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=5, m=0.\n+testcase_assoc_legendre<double> data007[] = {\n+  { -1.0000000000000000, 5, 0, \n+          -1.0000000000000000 },\n+  { 0.041141249999999997, 5, 0, \n+          -0.90000000000000002 },\n+  { 0.39951999999999993, 5, 0, \n+          -0.80000000000000004 },\n+  { 0.36519874999999991, 5, 0, \n+          -0.69999999999999996 },\n+  { 0.15263999999999994, 5, 0, \n+          -0.59999999999999998 },\n+  { -0.089843750000000000, 5, 0, \n+          -0.50000000000000000 },\n+  { -0.27063999999999988, 5, 0, \n+          -0.40000000000000002 },\n+  { -0.34538624999999995, 5, 0, \n+          -0.30000000000000004 },\n+  { -0.30751999999999996, 5, 0, \n+          -0.19999999999999996 },\n+  { -0.17882874999999995, 5, 0, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 5, 0, \n+          0.0000000000000000 },\n+  { 0.17882875000000015, 5, 0, \n+          0.10000000000000009 },\n+  { 0.30751999999999996, 5, 0, \n+          0.19999999999999996 },\n+  { 0.34538624999999995, 5, 0, \n+          0.30000000000000004 },\n+  { 0.27064000000000010, 5, 0, \n+          0.39999999999999991 },\n+  { 0.089843750000000000, 5, 0, \n+          0.50000000000000000 },\n+  { -0.15264000000000022, 5, 0, \n+          0.60000000000000009 },\n+  { -0.36519874999999991, 5, 0, \n+          0.69999999999999996 },\n+  { -0.39951999999999993, 5, 0, \n+          0.80000000000000004 },\n+  { -0.041141250000000407, 5, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 5, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=5, m=0.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data007[i].l), Tp(data007[i].m),\n+                   Tp(data007[i].x));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=5, m=1.\n+testcase_assoc_legendre<double> data008[] = {\n+  { 0.0000000000000000, 5, 1, \n+          -1.0000000000000000 },\n+  { -2.8099369608350973, 5, 1, \n+          -0.90000000000000002 },\n+  { -0.72180000000000089, 5, 1, \n+          -0.80000000000000004 },\n+  { 1.0951826834447254, 5, 1, \n+          -0.69999999999999996 },\n+  { 1.9775999999999998, 5, 1, \n+          -0.59999999999999998 },\n+  { 1.9282596881137892, 5, 1, \n+          -0.50000000000000000 },\n+  { 1.2070504380513685, 5, 1, \n+          -0.40000000000000002 },\n+  { 0.16079837663884430, 5, 1, \n+          -0.30000000000000004 },\n+  { -0.87005875663658538, 5, 1, \n+          -0.19999999999999996 },\n+  { -1.6083350053680323, 5, 1, \n+          -0.099999999999999978 },\n+  { -1.8750000000000000, 5, 1, \n+          0.0000000000000000 },\n+  { -1.6083350053680314, 5, 1, \n+          0.10000000000000009 },\n+  { -0.87005875663658538, 5, 1, \n+          0.19999999999999996 },\n+  { 0.16079837663884430, 5, 1, \n+          0.30000000000000004 },\n+  { 1.2070504380513674, 5, 1, \n+          0.39999999999999991 },\n+  { 1.9282596881137892, 5, 1, \n+          0.50000000000000000 },\n+  { 1.9775999999999996, 5, 1, \n+          0.60000000000000009 },\n+  { 1.0951826834447254, 5, 1, \n+          0.69999999999999996 },\n+  { -0.72180000000000089, 5, 1, \n+          0.80000000000000004 },\n+  { -2.8099369608350959, 5, 1, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 5, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=5, m=1.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data008[i].l), Tp(data008[i].m),\n+                   Tp(data008[i].x));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=5, m=2.\n+testcase_assoc_legendre<double> data009[] = {\n+  { 0.0000000000000000, 5, 2, \n+          -1.0000000000000000 },\n+  { -12.837824999999995, 5, 2, \n+          -0.90000000000000002 },\n+  { -13.910399999999997, 5, 2, \n+          -0.80000000000000004 },\n+  { -8.8089749999999984, 5, 2, \n+          -0.69999999999999996 },\n+  { -1.6128000000000009, 5, 2, \n+          -0.59999999999999998 },\n+  { 4.9218750000000000, 5, 2, \n+          -0.50000000000000000 },\n+  { 9.1728000000000005, 5, 2, \n+          -0.40000000000000002 },\n+  { 10.462725000000001, 5, 2, \n+          -0.30000000000000004 },\n+  { 8.8703999999999983, 5, 2, \n+          -0.19999999999999996 },\n+  { 5.0415749999999999, 5, 2, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 5, 2, \n+          0.0000000000000000 },\n+  { -5.0415750000000044, 5, 2, \n+          0.10000000000000009 },\n+  { -8.8703999999999983, 5, 2, \n+          0.19999999999999996 },\n+  { -10.462725000000001, 5, 2, \n+          0.30000000000000004 },\n+  { -9.1728000000000005, 5, 2, \n+          0.39999999999999991 },\n+  { -4.9218750000000000, 5, 2, \n+          0.50000000000000000 },\n+  { 1.6128000000000071, 5, 2, \n+          0.60000000000000009 },\n+  { 8.8089749999999984, 5, 2, \n+          0.69999999999999996 },\n+  { 13.910399999999997, 5, 2, \n+          0.80000000000000004 },\n+  { 12.837825000000004, 5, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 5, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=5, m=2.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data009[i].l), Tp(data009[i].m),\n+                   Tp(data009[i].x));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=5, m=5.\n+testcase_assoc_legendre<double> data010[] = {\n+  { -0.0000000000000000, 5, 5, \n+          -1.0000000000000000 },\n+  { -14.870165800941818, 5, 5, \n+          -0.90000000000000002 },\n+  { -73.483199999999925, 5, 5, \n+          -0.80000000000000004 },\n+  { -175.53238298794764, 5, 5, \n+          -0.69999999999999996 },\n+  { -309.65760000000006, 5, 5, \n+          -0.59999999999999998 },\n+  { -460.34662869916559, 5, 5, \n+          -0.50000000000000000 },\n+  { -611.12496255819883, 5, 5, \n+          -0.40000000000000002 },\n+  { -746.50941479523760, 5, 5, \n+          -0.30000000000000004 },\n+  { -853.31600434671316, 5, 5, \n+          -0.19999999999999996 },\n+  { -921.55189181724734, 5, 5, \n+          -0.099999999999999978 },\n+  { -945.00000000000000, 5, 5, \n+          0.0000000000000000 },\n+  { -921.55189181724734, 5, 5, \n+          0.10000000000000009 },\n+  { -853.31600434671316, 5, 5, \n+          0.19999999999999996 },\n+  { -746.50941479523760, 5, 5, \n+          0.30000000000000004 },\n+  { -611.12496255819883, 5, 5, \n+          0.39999999999999991 },\n+  { -460.34662869916559, 5, 5, \n+          0.50000000000000000 },\n+  { -309.65759999999989, 5, 5, \n+          0.60000000000000009 },\n+  { -175.53238298794764, 5, 5, \n+          0.69999999999999996 },\n+  { -73.483199999999925, 5, 5, \n+          0.80000000000000004 },\n+  { -14.870165800941855, 5, 5, \n+          0.89999999999999991 },\n+  { -0.0000000000000000, 5, 5, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=5, m=5.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data010[i].l), Tp(data010[i].m),\n+                   Tp(data010[i].x));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=10, m=0.\n+testcase_assoc_legendre<double> data011[] = {\n+  { 1.0000000000000000, 10, 0, \n+          -1.0000000000000000 },\n+  { -0.26314561785585977, 10, 0, \n+          -0.90000000000000002 },\n+  { 0.30052979559999998, 10, 0, \n+          -0.80000000000000004 },\n+  { 0.085805795531640333, 10, 0, \n+          -0.69999999999999996 },\n+  { -0.24366274560000006, 10, 0, \n+          -0.59999999999999998 },\n+  { -0.18822860717773438, 10, 0, \n+          -0.50000000000000000 },\n+  { 0.096839064399999869, 10, 0, \n+          -0.40000000000000002 },\n+  { 0.25147634951601561, 10, 0, \n+          -0.30000000000000004 },\n+  { 0.12907202559999989, 10, 0, \n+          -0.19999999999999996 },\n+  { -0.12212499738710947, 10, 0, \n+          -0.099999999999999978 },\n+  { -0.24609375000000000, 10, 0, \n+          0.0000000000000000 },\n+  { -0.12212499738710922, 10, 0, \n+          0.10000000000000009 },\n+  { 0.12907202559999989, 10, 0, \n+          0.19999999999999996 },\n+  { 0.25147634951601561, 10, 0, \n+          0.30000000000000004 },\n+  { 0.096839064400000258, 10, 0, \n+          0.39999999999999991 },\n+  { -0.18822860717773438, 10, 0, \n+          0.50000000000000000 },\n+  { -0.24366274559999987, 10, 0, \n+          0.60000000000000009 },\n+  { 0.085805795531640333, 10, 0, \n+          0.69999999999999996 },\n+  { 0.30052979559999998, 10, 0, \n+          0.80000000000000004 },\n+  { -0.26314561785585888, 10, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 10, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=10, m=0.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data011[i].l), Tp(data011[i].m),\n+                   Tp(data011[i].x));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=10, m=1.\n+testcase_assoc_legendre<double> data012[] = {\n+  { -0.0000000000000000, 10, 1, \n+          -1.0000000000000000 },\n+  { -3.0438748781479061, 10, 1, \n+          -0.90000000000000002 },\n+  { -0.87614260800000199, 10, 1, \n+          -0.80000000000000004 },\n+  { 2.9685359952934522, 10, 1, \n+          -0.69999999999999996 },\n+  { 1.2511825919999990, 10, 1, \n+          -0.59999999999999998 },\n+  { -2.0066877394361260, 10, 1, \n+          -0.50000000000000000 },\n+  { -2.4822196173476661, 10, 1, \n+          -0.40000000000000002 },\n+  { -0.12309508907433941, 10, 1, \n+          -0.30000000000000004 },\n+  { 2.2468221751958408, 10, 1, \n+          -0.19999999999999996 },\n+  { 2.2472659777983512, 10, 1, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 10, 1, \n+          0.0000000000000000 },\n+  { -2.2472659777983530, 10, 1, \n+          0.10000000000000009 },\n+  { -2.2468221751958408, 10, 1, \n+          0.19999999999999996 },\n+  { 0.12309508907433941, 10, 1, \n+          0.30000000000000004 },\n+  { 2.4822196173476643, 10, 1, \n+          0.39999999999999991 },\n+  { 2.0066877394361260, 10, 1, \n+          0.50000000000000000 },\n+  { -1.2511825920000037, 10, 1, \n+          0.60000000000000009 },\n+  { -2.9685359952934522, 10, 1, \n+          0.69999999999999996 },\n+  { 0.87614260800000199, 10, 1, \n+          0.80000000000000004 },\n+  { 3.0438748781479110, 10, 1, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 10, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=10, m=1.\n+template <typename Tp>\n+void test012()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data012)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data012[i].l), Tp(data012[i].m),\n+                   Tp(data012[i].x));\n+      const Tp f0 = data012[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=10, m=2.\n+testcase_assoc_legendre<double> data013[] = {\n+  { 0.0000000000000000, 10, 2, \n+          -1.0000000000000000 },\n+  { 16.376387762496122, 10, 2, \n+          -0.90000000000000002 },\n+  { -35.394657803999991, 10, 2, \n+          -0.80000000000000004 },\n+  { -3.6191429423788892, 10, 2, \n+          -0.69999999999999996 },\n+  { 28.679675904000010, 10, 2, \n+          -0.59999999999999998 },\n+  { 18.388023376464844, 10, 2, \n+          -0.50000000000000000 },\n+  { -12.818955995999996, 10, 2, \n+          -0.40000000000000002 },\n+  { -27.739821675972660, 10, 2, \n+          -0.30000000000000004 },\n+  { -13.280661503999987, 10, 2, \n+          -0.19999999999999996 },\n+  { 13.885467170308596, 10, 2, \n+          -0.099999999999999978 },\n+  { 27.070312500000000, 10, 2, \n+          0.0000000000000000 },\n+  { 13.885467170308573, 10, 2, \n+          0.10000000000000009 },\n+  { -13.280661503999987, 10, 2, \n+          0.19999999999999996 },\n+  { -27.739821675972660, 10, 2, \n+          0.30000000000000004 },\n+  { -12.818955996000019, 10, 2, \n+          0.39999999999999991 },\n+  { 18.388023376464844, 10, 2, \n+          0.50000000000000000 },\n+  { 28.679675903999982, 10, 2, \n+          0.60000000000000009 },\n+  { -3.6191429423788892, 10, 2, \n+          0.69999999999999996 },\n+  { -35.394657803999991, 10, 2, \n+          0.80000000000000004 },\n+  { 16.376387762495984, 10, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 10, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=10, m=2.\n+template <typename Tp>\n+void test013()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data013)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data013[i].l), Tp(data013[i].m),\n+                   Tp(data013[i].x));\n+      const Tp f0 = data013[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for l=10, m=5.\n+testcase_assoc_legendre<double> data014[] = {\n+  { 0.0000000000000000, 10, 5, \n+          -1.0000000000000000 },\n+  { 21343.618518164669, 10, 5, \n+          -0.90000000000000002 },\n+  { 40457.016407807983, 10, 5, \n+          -0.80000000000000004 },\n+  { 20321.279317331318, 10, 5, \n+          -0.69999999999999996 },\n+  { -14410.820616192013, 10, 5, \n+          -0.59999999999999998 },\n+  { -30086.169706116176, 10, 5, \n+          -0.50000000000000000 },\n+  { -17177.549337582859, 10, 5, \n+          -0.40000000000000002 },\n+  { 9272.5119495412346, 10, 5, \n+          -0.30000000000000004 },\n+  { 26591.511184414714, 10, 5, \n+          -0.19999999999999996 },\n+  { 21961.951238504211, 10, 5, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 10, 5, \n+          0.0000000000000000 },\n+  { -21961.951238504229, 10, 5, \n+          0.10000000000000009 },\n+  { -26591.511184414714, 10, 5, \n+          0.19999999999999996 },\n+  { -9272.5119495412346, 10, 5, \n+          0.30000000000000004 },\n+  { 17177.549337582830, 10, 5, \n+          0.39999999999999991 },\n+  { 30086.169706116176, 10, 5, \n+          0.50000000000000000 },\n+  { 14410.820616191975, 10, 5, \n+          0.60000000000000009 },\n+  { -20321.279317331318, 10, 5, \n+          0.69999999999999996 },\n+  { -40457.016407807983, 10, 5, \n+          0.80000000000000004 },\n+  { -21343.618518164698, 10, 5, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 10, 5, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=10, m=5.\n+template <typename Tp>\n+void test014()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data014)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data014[i].l), Tp(data014[i].m),\n+                   Tp(data014[i].x));\n+      const Tp f0 = data014[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=10, m=10.\n+testcase_assoc_legendre<double> data015[] = {\n+  { 0.0000000000000000, 10, 10, \n+          -1.0000000000000000 },\n+  { 162117.40078784220, 10, 10, \n+          -0.90000000000000002 },\n+  { 3958896.3481267113, 10, 10, \n+          -0.80000000000000004 },\n+  { 22589806.343887307, 10, 10, \n+          -0.69999999999999996 },\n+  { 70300999.121633321, 10, 10, \n+          -0.59999999999999998 },\n+  { 155370278.54003900, 10, 10, \n+          -0.50000000000000000 },\n+  { 273815518.20150518, 10, 10, \n+          -0.40000000000000002 },\n+  { 408571989.13158917, 10, 10, \n+          -0.30000000000000004 },\n+  { 533848212.07990247, 10, 10, \n+          -0.19999999999999996 },\n+  { 622640835.70523083, 10, 10, \n+          -0.099999999999999978 },\n+  { 654729075.00000000, 10, 10, \n+          0.0000000000000000 },\n+  { 622640835.70523083, 10, 10, \n+          0.10000000000000009 },\n+  { 533848212.07990247, 10, 10, \n+          0.19999999999999996 },\n+  { 408571989.13158917, 10, 10, \n+          0.30000000000000004 },\n+  { 273815518.20150518, 10, 10, \n+          0.39999999999999991 },\n+  { 155370278.54003900, 10, 10, \n+          0.50000000000000000 },\n+  { 70300999.121633217, 10, 10, \n+          0.60000000000000009 },\n+  { 22589806.343887307, 10, 10, \n+          0.69999999999999996 },\n+  { 3958896.3481267113, 10, 10, \n+          0.80000000000000004 },\n+  { 162117.40078784304, 10, 10, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 10, 10, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=10, m=10.\n+template <typename Tp>\n+void test015()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data015)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data015[i].l), Tp(data015[i].m),\n+                   Tp(data015[i].x));\n+      const Tp f0 = data015[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=20, m=0.\n+testcase_assoc_legendre<double> data016[] = {\n+  { 1.0000000000000000, 20, 0, \n+          -1.0000000000000000 },\n+  { -0.14930823530984821, 20, 0, \n+          -0.90000000000000002 },\n+  { 0.22420460541741344, 20, 0, \n+          -0.80000000000000004 },\n+  { -0.20457394463834172, 20, 0, \n+          -0.69999999999999996 },\n+  { 0.15916752910098114, 20, 0, \n+          -0.59999999999999998 },\n+  { -0.048358381067373557, 20, 0, \n+          -0.50000000000000000 },\n+  { -0.10159261558628156, 20, 0, \n+          -0.40000000000000002 },\n+  { 0.18028715947998047, 20, 0, \n+          -0.30000000000000004 },\n+  { -0.098042194344594741, 20, 0, \n+          -0.19999999999999996 },\n+  { -0.082077130944527649, 20, 0, \n+          -0.099999999999999978 },\n+  { 0.17619705200195312, 20, 0, \n+          0.0000000000000000 },\n+  { -0.082077130944528037, 20, 0, \n+          0.10000000000000009 },\n+  { -0.098042194344594741, 20, 0, \n+          0.19999999999999996 },\n+  { 0.18028715947998047, 20, 0, \n+          0.30000000000000004 },\n+  { -0.10159261558628112, 20, 0, \n+          0.39999999999999991 },\n+  { -0.048358381067373557, 20, 0, \n+          0.50000000000000000 },\n+  { 0.15916752910098084, 20, 0, \n+          0.60000000000000009 },\n+  { -0.20457394463834172, 20, 0, \n+          0.69999999999999996 },\n+  { 0.22420460541741344, 20, 0, \n+          0.80000000000000004 },\n+  { -0.14930823530984949, 20, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 20, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=0.\n+template <typename Tp>\n+void test016()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data016)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data016[i].l), Tp(data016[i].m),\n+                   Tp(data016[i].x));\n+      const Tp f0 = data016[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=20, m=1.\n+testcase_assoc_legendre<double> data017[] = {\n+  { 0.0000000000000000, 20, 1, \n+          -1.0000000000000000 },\n+  { 4.3838334818220490, 20, 1, \n+          -0.90000000000000002 },\n+  { -0.63138296146340556, 20, 1, \n+          -0.80000000000000004 },\n+  { 0.72274871413391228, 20, 1, \n+          -0.69999999999999996 },\n+  { -2.3203528743824893, 20, 1, \n+          -0.59999999999999998 },\n+  { 3.7399919228791405, 20, 1, \n+          -0.50000000000000000 },\n+  { -3.1692202279270028, 20, 1, \n+          -0.40000000000000002 },\n+  { 0.15804468835344049, 20, 1, \n+          -0.30000000000000004 },\n+  { 3.0366182393271162, 20, 1, \n+          -0.19999999999999996 },\n+  { -3.2115523815580209, 20, 1, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 20, 1, \n+          0.0000000000000000 },\n+  { 3.2115523815580160, 20, 1, \n+          0.10000000000000009 },\n+  { -3.0366182393271162, 20, 1, \n+          0.19999999999999996 },\n+  { -0.15804468835344049, 20, 1, \n+          0.30000000000000004 },\n+  { 3.1692202279270076, 20, 1, \n+          0.39999999999999991 },\n+  { -3.7399919228791405, 20, 1, \n+          0.50000000000000000 },\n+  { 2.3203528743825008, 20, 1, \n+          0.60000000000000009 },\n+  { -0.72274871413391228, 20, 1, \n+          0.69999999999999996 },\n+  { 0.63138296146340556, 20, 1, \n+          0.80000000000000004 },\n+  { -4.3838334818220304, 20, 1, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 20, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=1.\n+template <typename Tp>\n+void test017()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data017)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data017[i].l), Tp(data017[i].m),\n+                   Tp(data017[i].x));\n+      const Tp f0 = data017[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for l=20, m=2.\n+testcase_assoc_legendre<double> data018[] = {\n+  { 0.0000000000000000, 20, 2, \n+          -1.0000000000000000 },\n+  { 80.812425587310116, 20, 2, \n+          -0.90000000000000002 },\n+  { -95.849622172549317, 20, 2, \n+          -0.80000000000000004 },\n+  { 87.337927630325510, 20, 2, \n+          -0.69999999999999996 },\n+  { -70.330891533985834, 20, 2, \n+          -0.59999999999999998 },\n+  { 24.629090735179489, 20, 2, \n+          -0.50000000000000000 },\n+  { 39.902576338912418, 20, 2, \n+          -0.40000000000000002 },\n+  { -75.621201471396589, 20, 2, \n+          -0.30000000000000004 },\n+  { 42.417415829726487, 20, 2, \n+          -0.19999999999999996 },\n+  { 33.826848678871301, 20, 2, \n+          -0.099999999999999978 },\n+  { -74.002761840820312, 20, 2, \n+          0.0000000000000000 },\n+  { 33.826848678871457, 20, 2, \n+          0.10000000000000009 },\n+  { 42.417415829726487, 20, 2, \n+          0.19999999999999996 },\n+  { -75.621201471396589, 20, 2, \n+          0.30000000000000004 },\n+  { 39.902576338912240, 20, 2, \n+          0.39999999999999991 },\n+  { 24.629090735179489, 20, 2, \n+          0.50000000000000000 },\n+  { -70.330891533985664, 20, 2, \n+          0.60000000000000009 },\n+  { 87.337927630325510, 20, 2, \n+          0.69999999999999996 },\n+  { -95.849622172549317, 20, 2, \n+          0.80000000000000004 },\n+  { 80.812425587310585, 20, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 20, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=2.\n+template <typename Tp>\n+void test018()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data018)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data018[i].l), Tp(data018[i].m),\n+                   Tp(data018[i].x));\n+      const Tp f0 = data018[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=20, m=5.\n+testcase_assoc_legendre<double> data019[] = {\n+  { -0.0000000000000000, 20, 5, \n+          -1.0000000000000000 },\n+  { -315702.32715134107, 20, 5, \n+          -0.90000000000000002 },\n+  { 503060.91484852595, 20, 5, \n+          -0.80000000000000004 },\n+  { -298127.28360361949, 20, 5, \n+          -0.69999999999999996 },\n+  { -114444.61447464002, 20, 5, \n+          -0.59999999999999998 },\n+  { 543428.40914592857, 20, 5, \n+          -0.50000000000000000 },\n+  { -613842.07728185481, 20, 5, \n+          -0.40000000000000002 },\n+  { 143765.42411270953, 20, 5, \n+          -0.30000000000000004 },\n+  { 472600.45321372297, 20, 5, \n+          -0.19999999999999996 },\n+  { -563861.76771496492, 20, 5, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 20, 5, \n+          0.0000000000000000 },\n+  { 563861.76771496458, 20, 5, \n+          0.10000000000000009 },\n+  { -472600.45321372297, 20, 5, \n+          0.19999999999999996 },\n+  { -143765.42411270953, 20, 5, \n+          0.30000000000000004 },\n+  { 613842.07728185505, 20, 5, \n+          0.39999999999999991 },\n+  { -543428.40914592857, 20, 5, \n+          0.50000000000000000 },\n+  { 114444.61447464184, 20, 5, \n+          0.60000000000000009 },\n+  { 298127.28360361949, 20, 5, \n+          0.69999999999999996 },\n+  { -503060.91484852595, 20, 5, \n+          0.80000000000000004 },\n+  { 315702.32715134590, 20, 5, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 20, 5, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=5.\n+template <typename Tp>\n+void test019()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data019)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data019[i].l), Tp(data019[i].m),\n+                   Tp(data019[i].x));\n+      const Tp f0 = data019[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=20, m=10.\n+testcase_assoc_legendre<double> data020[] = {\n+  { -0.0000000000000000, 20, 10, \n+          -1.0000000000000000 },\n+  { 990017476694.99084, 20, 10, \n+          -0.90000000000000002 },\n+  { 2392757933281.0503, 20, 10, \n+          -0.80000000000000004 },\n+  { -1548364524949.5808, 20, 10, \n+          -0.69999999999999996 },\n+  { -424471915195.05609, 20, 10, \n+          -0.59999999999999998 },\n+  { 1744502295946.2065, 20, 10, \n+          -0.50000000000000000 },\n+  { -899973487310.55212, 20, 10, \n+          -0.40000000000000002 },\n+  { -1092420454297.7164, 20, 10, \n+          -0.30000000000000004 },\n+  { 1466609267659.8816, 20, 10, \n+          -0.19999999999999996 },\n+  { 356041756390.71661, 20, 10, \n+          -0.099999999999999978 },\n+  { -1612052956674.3164, 20, 10, \n+          0.0000000000000000 },\n+  { 356041756390.71985, 20, 10, \n+          0.10000000000000009 },\n+  { 1466609267659.8816, 20, 10, \n+          0.19999999999999996 },\n+  { -1092420454297.7164, 20, 10, \n+          0.30000000000000004 },\n+  { -899973487310.55469, 20, 10, \n+          0.39999999999999991 },\n+  { 1744502295946.2065, 20, 10, \n+          0.50000000000000000 },\n+  { -424471915195.05914, 20, 10, \n+          0.60000000000000009 },\n+  { -1548364524949.5808, 20, 10, \n+          0.69999999999999996 },\n+  { 2392757933281.0503, 20, 10, \n+          0.80000000000000004 },\n+  { 990017476694.99353, 20, 10, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 20, 10, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=10.\n+template <typename Tp>\n+void test020()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data020)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data020[i].l), Tp(data020[i].m),\n+                   Tp(data020[i].x));\n+      const Tp f0 = data020[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=20, m=20.\n+testcase_assoc_legendre<double> data021[] = {\n+  { 0.0000000000000000, 20, 20, \n+          -1.0000000000000000 },\n+  { 19609049712023808., 20, 20, \n+          -0.90000000000000002 },\n+  { 1.1693527616833221e+19, 20, 20, \n+          -0.80000000000000004 },\n+  { 3.8073455880620691e+20, 20, 20, \n+          -0.69999999999999996 },\n+  { 3.6874002249007927e+21, 20, 20, \n+          -0.59999999999999998 },\n+  { 1.8010806978179592e+22, 20, 20, \n+          -0.50000000000000000 },\n+  { 5.5938832584012466e+22, 20, 20, \n+          -0.40000000000000002 },\n+  { 1.2454734132297811e+23, 20, 20, \n+          -0.30000000000000004 },\n+  { 2.1263407800797497e+23, 20, 20, \n+          -0.19999999999999996 },\n+  { 2.8924941146976873e+23, 20, 20, \n+          -0.099999999999999978 },\n+  { 3.1983098677287775e+23, 20, 20, \n+          0.0000000000000000 },\n+  { 2.8924941146976873e+23, 20, 20, \n+          0.10000000000000009 },\n+  { 2.1263407800797497e+23, 20, 20, \n+          0.19999999999999996 },\n+  { 1.2454734132297811e+23, 20, 20, \n+          0.30000000000000004 },\n+  { 5.5938832584012466e+22, 20, 20, \n+          0.39999999999999991 },\n+  { 1.8010806978179592e+22, 20, 20, \n+          0.50000000000000000 },\n+  { 3.6874002249007807e+21, 20, 20, \n+          0.60000000000000009 },\n+  { 3.8073455880620691e+20, 20, 20, \n+          0.69999999999999996 },\n+  { 1.1693527616833221e+19, 20, 20, \n+          0.80000000000000004 },\n+  { 19609049712024020., 20, 20, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 20, 20, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=20, m=20.\n+template <typename Tp>\n+void test021()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data021)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data021[i].l), Tp(data021[i].m),\n+                   Tp(data021[i].x));\n+      const Tp f0 = data021[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=50, m=0.\n+testcase_assoc_legendre<double> data022[] = {\n+  { 1.0000000000000000, 50, 0, \n+          -1.0000000000000000 },\n+  { -0.17003765994383685, 50, 0, \n+          -0.90000000000000002 },\n+  { 0.13879737345093118, 50, 0, \n+          -0.80000000000000004 },\n+  { -0.014572731645892805, 50, 0, \n+          -0.69999999999999996 },\n+  { -0.058860798844002173, 50, 0, \n+          -0.59999999999999998 },\n+  { -0.031059099239609828, 50, 0, \n+          -0.50000000000000000 },\n+  { 0.041569033381825368, 50, 0, \n+          -0.40000000000000002 },\n+  { 0.10911051574714808, 50, 0, \n+          -0.30000000000000004 },\n+  { 0.083432272204197466, 50, 0, \n+          -0.19999999999999996 },\n+  { -0.038205812661313579, 50, 0, \n+          -0.099999999999999978 },\n+  { -0.11227517265921705, 50, 0, \n+          0.0000000000000000 },\n+  { -0.038205812661314169, 50, 0, \n+          0.10000000000000009 },\n+  { 0.083432272204197466, 50, 0, \n+          0.19999999999999996 },\n+  { 0.10911051574714808, 50, 0, \n+          0.30000000000000004 },\n+  { 0.041569033381824647, 50, 0, \n+          0.39999999999999991 },\n+  { -0.031059099239609828, 50, 0, \n+          0.50000000000000000 },\n+  { -0.058860798844001430, 50, 0, \n+          0.60000000000000009 },\n+  { -0.014572731645892805, 50, 0, \n+          0.69999999999999996 },\n+  { 0.13879737345093118, 50, 0, \n+          0.80000000000000004 },\n+  { -0.17003765994383663, 50, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 50, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=0.\n+template <typename Tp>\n+void test022()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data022)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data022[i].l), Tp(data022[i].m),\n+                   Tp(data022[i].x));\n+      const Tp f0 = data022[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=50, m=1.\n+testcase_assoc_legendre<double> data023[] = {\n+  { 0.0000000000000000, 50, 1, \n+          -1.0000000000000000 },\n+  { -0.13424149984450387, 50, 1, \n+          -0.90000000000000002 },\n+  { 2.2011219672413085, 50, 1, \n+          -0.80000000000000004 },\n+  { 6.6622414993232013, 50, 1, \n+          -0.69999999999999996 },\n+  { 5.5772846936919231, 50, 1, \n+          -0.59999999999999998 },\n+  { 5.8787148815607617, 50, 1, \n+          -0.50000000000000000 },\n+  { 5.5473459458634000, 50, 1, \n+          -0.40000000000000002 },\n+  { 1.8444956647619912, 50, 1, \n+          -0.30000000000000004 },\n+  { -3.8722014306642150, 50, 1, \n+          -0.19999999999999996 },\n+  { -5.3488751322285593, 50, 1, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 50, 1, \n+          0.0000000000000000 },\n+  { 5.3488751322285459, 50, 1, \n+          0.10000000000000009 },\n+  { 3.8722014306642150, 50, 1, \n+          0.19999999999999996 },\n+  { -1.8444956647619912, 50, 1, \n+          0.30000000000000004 },\n+  { -5.5473459458634098, 50, 1, \n+          0.39999999999999991 },\n+  { -5.8787148815607617, 50, 1, \n+          0.50000000000000000 },\n+  { -5.5772846936919489, 50, 1, \n+          0.60000000000000009 },\n+  { -6.6622414993232013, 50, 1, \n+          0.69999999999999996 },\n+  { -2.2011219672413085, 50, 1, \n+          0.80000000000000004 },\n+  { 0.13424149984460862, 50, 1, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=1.\n+template <typename Tp>\n+void test023()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data023)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data023[i].l), Tp(data023[i].m),\n+                   Tp(data023[i].x));\n+      const Tp f0 = data023[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+// Test data for l=50, m=2.\n+testcase_assoc_legendre<double> data024[] = {\n+  { 0.0000000000000000, 50, 2, \n+          -1.0000000000000000 },\n+  { 433.04168483713448, 50, 2, \n+          -0.90000000000000002 },\n+  { -348.06364372056390, 50, 2, \n+          -0.80000000000000004 },\n+  { 50.221071418108465, 50, 2, \n+          -0.69999999999999996 },\n+  { 158.46096409274341, 50, 2, \n+          -0.59999999999999998 },\n+  { 85.988858299721414, 50, 2, \n+          -0.50000000000000000 },\n+  { -101.15891460879277, 50, 2, \n+          -0.40000000000000002 },\n+  { -277.07168105316612, 50, 2, \n+          -0.30000000000000004 },\n+  { -214.33311373510401, 50, 2, \n+          -0.19999999999999996 },\n+  { 96.349657930951722, 50, 2, \n+          -0.099999999999999978 },\n+  { 286.30169028100346, 50, 2, \n+          0.0000000000000000 },\n+  { 96.349657930953285, 50, 2, \n+          0.10000000000000009 },\n+  { -214.33311373510401, 50, 2, \n+          0.19999999999999996 },\n+  { -277.07168105316612, 50, 2, \n+          0.30000000000000004 },\n+  { -101.15891460879106, 50, 2, \n+          0.39999999999999991 },\n+  { 85.988858299721414, 50, 2, \n+          0.50000000000000000 },\n+  { 158.46096409274131, 50, 2, \n+          0.60000000000000009 },\n+  { 50.221071418108465, 50, 2, \n+          0.69999999999999996 },\n+  { -348.06364372056390, 50, 2, \n+          0.80000000000000004 },\n+  { 433.04168483713414, 50, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=2.\n+template <typename Tp>\n+void test024()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data024)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data024[i].l), Tp(data024[i].m),\n+                   Tp(data024[i].x));\n+      const Tp f0 = data024[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=50, m=5.\n+testcase_assoc_legendre<double> data025[] = {\n+  { -0.0000000000000000, 50, 5, \n+          -1.0000000000000000 },\n+  { -27340473.952132788, 50, 5, \n+          -0.90000000000000002 },\n+  { 27753716.768532373, 50, 5, \n+          -0.80000000000000004 },\n+  { 40808153.913493626, 50, 5, \n+          -0.69999999999999996 },\n+  { 32071189.035790101, 50, 5, \n+          -0.59999999999999998 },\n+  { 36265736.218529105, 50, 5, \n+          -0.50000000000000000 },\n+  { 37089596.700204894, 50, 5, \n+          -0.40000000000000002 },\n+  { 14562029.629244510, 50, 5, \n+          -0.30000000000000004 },\n+  { -23686895.217517227, 50, 5, \n+          -0.19999999999999996 },\n+  { -34878992.965676002, 50, 5, \n+          -0.099999999999999978 },\n+  { -0.0000000000000000, 50, 5, \n+          0.0000000000000000 },\n+  { 34878992.965675950, 50, 5, \n+          0.10000000000000009 },\n+  { 23686895.217517227, 50, 5, \n+          0.19999999999999996 },\n+  { -14562029.629244510, 50, 5, \n+          0.30000000000000004 },\n+  { -37089596.700204931, 50, 5, \n+          0.39999999999999991 },\n+  { -36265736.218529105, 50, 5, \n+          0.50000000000000000 },\n+  { -32071189.035790265, 50, 5, \n+          0.60000000000000009 },\n+  { -40808153.913493626, 50, 5, \n+          0.69999999999999996 },\n+  { -27753716.768532373, 50, 5, \n+          0.80000000000000004 },\n+  { 27340473.952133406, 50, 5, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 5, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=5.\n+template <typename Tp>\n+void test025()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data025)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data025[i].l), Tp(data025[i].m),\n+                   Tp(data025[i].x));\n+      const Tp f0 = data025[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=50, m=10.\n+testcase_assoc_legendre<double> data026[] = {\n+  { -0.0000000000000000, 50, 10, \n+          -1.0000000000000000 },\n+  { -8994661710093158.0, 50, 10, \n+          -0.90000000000000002 },\n+  { 932311375306557.00, 50, 10, \n+          -0.80000000000000004 },\n+  { 12153535011507012., 50, 10, \n+          -0.69999999999999996 },\n+  { 12176690755542244., 50, 10, \n+          -0.59999999999999998 },\n+  { 9180035388465752.0, 50, 10, \n+          -0.50000000000000000 },\n+  { 889201701866911.12, 50, 10, \n+          -0.40000000000000002 },\n+  { -9451384032851600.0, 50, 10, \n+          -0.30000000000000004 },\n+  { -9926439446673564.0, 50, 10, \n+          -0.19999999999999996 },\n+  { 2794368162749970.5, 50, 10, \n+          -0.099999999999999978 },\n+  { 11452238249246346., 50, 10, \n+          0.0000000000000000 },\n+  { 2794368162750031.0, 50, 10, \n+          0.10000000000000009 },\n+  { -9926439446673564.0, 50, 10, \n+          0.19999999999999996 },\n+  { -9451384032851600.0, 50, 10, \n+          0.30000000000000004 },\n+  { 889201701866976.25, 50, 10, \n+          0.39999999999999991 },\n+  { 9180035388465752.0, 50, 10, \n+          0.50000000000000000 },\n+  { 12176690755542216., 50, 10, \n+          0.60000000000000009 },\n+  { 12153535011507012., 50, 10, \n+          0.69999999999999996 },\n+  { 932311375306557.00, 50, 10, \n+          0.80000000000000004 },\n+  { -8994661710093322.0, 50, 10, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 10, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=10.\n+template <typename Tp>\n+void test026()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data026)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data026[i].l), Tp(data026[i].m),\n+                   Tp(data026[i].x));\n+      const Tp f0 = data026[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for l=50, m=20.\n+testcase_assoc_legendre<double> data027[] = {\n+  { 0.0000000000000000, 50, 20, \n+          -1.0000000000000000 },\n+  { 1.6630925158645460e+33, 50, 20, \n+          -0.90000000000000002 },\n+  { 1.0622676657892043e+33, 50, 20, \n+          -0.80000000000000004 },\n+  { 8.6022521164717170e+32, 50, 20, \n+          -0.69999999999999996 },\n+  { 4.0860128756808430e+32, 50, 20, \n+          -0.59999999999999998 },\n+  { -4.0169860814274409e+32, 50, 20, \n+          -0.50000000000000000 },\n+  { -8.2324325279774008e+32, 50, 20, \n+          -0.40000000000000002 },\n+  { -4.0054067236243299e+31, 50, 20, \n+          -0.30000000000000004 },\n+  { 7.9309266056434309e+32, 50, 20, \n+          -0.19999999999999996 },\n+  { 5.4151358290899148e+31, 50, 20, \n+          -0.099999999999999978 },\n+  { -7.8735935697332210e+32, 50, 20, \n+          0.0000000000000000 },\n+  { 5.4151358290895032e+31, 50, 20, \n+          0.10000000000000009 },\n+  { 7.9309266056434309e+32, 50, 20, \n+          0.19999999999999996 },\n+  { -4.0054067236243299e+31, 50, 20, \n+          0.30000000000000004 },\n+  { -8.2324325279773965e+32, 50, 20, \n+          0.39999999999999991 },\n+  { -4.0169860814274409e+32, 50, 20, \n+          0.50000000000000000 },\n+  { 4.0860128756807882e+32, 50, 20, \n+          0.60000000000000009 },\n+  { 8.6022521164717170e+32, 50, 20, \n+          0.69999999999999996 },\n+  { 1.0622676657892043e+33, 50, 20, \n+          0.80000000000000004 },\n+  { 1.6630925158645483e+33, 50, 20, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 20, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=20.\n+template <typename Tp>\n+void test027()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data027)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data027[i].l), Tp(data027[i].m),\n+                   Tp(data027[i].x));\n+      const Tp f0 = data027[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for l=50, m=50.\n+testcase_assoc_legendre<double> data028[] = {\n+  { 0.0000000000000000, 50, 50, \n+          -1.0000000000000000 },\n+  { 2.5366994974431341e+60, 50, 50, \n+          -0.90000000000000002 },\n+  { 2.2028834403101213e+67, 50, 50, \n+          -0.80000000000000004 },\n+  { 1.3325496559566651e+71, 50, 50, \n+          -0.69999999999999996 },\n+  { 3.8898096431781969e+73, 50, 50, \n+          -0.59999999999999998 },\n+  { 2.0509760257037188e+75, 50, 50, \n+          -0.50000000000000000 },\n+  { 3.4866724533443283e+76, 50, 50, \n+          -0.40000000000000002 },\n+  { 2.5790740224150207e+77, 50, 50, \n+          -0.30000000000000004 },\n+  { 9.8222237931680989e+77, 50, 50, \n+          -0.19999999999999996 },\n+  { 2.1198682190366617e+78, 50, 50, \n+          -0.099999999999999978 },\n+  { 2.7253921397507295e+78, 50, 50, \n+          0.0000000000000000 },\n+  { 2.1198682190366617e+78, 50, 50, \n+          0.10000000000000009 },\n+  { 9.8222237931680989e+77, 50, 50, \n+          0.19999999999999996 },\n+  { 2.5790740224150207e+77, 50, 50, \n+          0.30000000000000004 },\n+  { 3.4866724533443283e+76, 50, 50, \n+          0.39999999999999991 },\n+  { 2.0509760257037188e+75, 50, 50, \n+          0.50000000000000000 },\n+  { 3.8898096431781724e+73, 50, 50, \n+          0.60000000000000009 },\n+  { 1.3325496559566651e+71, 50, 50, \n+          0.69999999999999996 },\n+  { 2.2028834403101213e+67, 50, 50, \n+          0.80000000000000004 },\n+  { 2.5366994974431990e+60, 50, 50, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 50, 50, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=50, m=50.\n+template <typename Tp>\n+void test028()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data028)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data028[i].l), Tp(data028[i].m),\n+                   Tp(data028[i].x));\n+      const Tp f0 = data028[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=100, m=0.\n+testcase_assoc_legendre<double> data029[] = {\n+  { 1.0000000000000000, 100, 0, \n+          -1.0000000000000000 },\n+  { 0.10226582055871908, 100, 0, \n+          -0.90000000000000002 },\n+  { 0.050861167913584124, 100, 0, \n+          -0.80000000000000004 },\n+  { -0.077132507199778780, 100, 0, \n+          -0.69999999999999996 },\n+  { -0.023747023905133110, 100, 0, \n+          -0.59999999999999998 },\n+  { -0.060518025961861198, 100, 0, \n+          -0.50000000000000000 },\n+  { -0.072258202125684429, 100, 0, \n+          -0.40000000000000002 },\n+  { 0.057127392202801719, 100, 0, \n+          -0.30000000000000004 },\n+  { 0.014681835355659636, 100, 0, \n+          -0.19999999999999996 },\n+  { -0.063895098434750303, 100, 0, \n+          -0.099999999999999978 },\n+  { 0.079589237387178727, 100, 0, \n+          0.0000000000000000 },\n+  { -0.063895098434749775, 100, 0, \n+          0.10000000000000009 },\n+  { 0.014681835355659636, 100, 0, \n+          0.19999999999999996 },\n+  { 0.057127392202801719, 100, 0, \n+          0.30000000000000004 },\n+  { -0.072258202125685012, 100, 0, \n+          0.39999999999999991 },\n+  { -0.060518025961861198, 100, 0, \n+          0.50000000000000000 },\n+  { -0.023747023905134217, 100, 0, \n+          0.60000000000000009 },\n+  { -0.077132507199778780, 100, 0, \n+          0.69999999999999996 },\n+  { 0.050861167913584124, 100, 0, \n+          0.80000000000000004 },\n+  { 0.10226582055871723, 100, 0, \n+          0.89999999999999991 },\n+  { 1.0000000000000000, 100, 0, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=0.\n+template <typename Tp>\n+void test029()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data029)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data029[i].l), Tp(data029[i].m),\n+                   Tp(data029[i].x));\n+      const Tp f0 = data029[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=100, m=1.\n+testcase_assoc_legendre<double> data030[] = {\n+  { -0.0000000000000000, 100, 1, \n+          -1.0000000000000000 },\n+  { 6.5200167187780309, 100, 1, \n+          -0.90000000000000002 },\n+  { 9.0065170007027540, 100, 1, \n+          -0.80000000000000004 },\n+  { -5.4690908541181056, 100, 1, \n+          -0.69999999999999996 },\n+  { -8.6275439170430861, 100, 1, \n+          -0.59999999999999998 },\n+  { -6.0909031663448499, 100, 1, \n+          -0.50000000000000000 },\n+  { 4.1160338699561265, 100, 1, \n+          -0.40000000000000002 },\n+  { 5.8491043010758004, 100, 1, \n+          -0.30000000000000004 },\n+  { -7.9435138723089826, 100, 1, \n+          -0.19999999999999996 },\n+  { 4.7996285823989346, 100, 1, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 100, 1, \n+          0.0000000000000000 },\n+  { -4.7996285823990057, 100, 1, \n+          0.10000000000000009 },\n+  { 7.9435138723089826, 100, 1, \n+          0.19999999999999996 },\n+  { -5.8491043010758004, 100, 1, \n+          0.30000000000000004 },\n+  { -4.1160338699560359, 100, 1, \n+          0.39999999999999991 },\n+  { 6.0909031663448499, 100, 1, \n+          0.50000000000000000 },\n+  { 8.6275439170430559, 100, 1, \n+          0.60000000000000009 },\n+  { 5.4690908541181056, 100, 1, \n+          0.69999999999999996 },\n+  { -9.0065170007027540, 100, 1, \n+          0.80000000000000004 },\n+  { -6.5200167187783133, 100, 1, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 1, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=1.\n+template <typename Tp>\n+void test030()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data030)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data030[i].l), Tp(data030[i].m),\n+                   Tp(data030[i].x));\n+      const Tp f0 = data030[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for l=100, m=2.\n+testcase_assoc_legendre<double> data031[] = {\n+  { 0.0000000000000000, 100, 2, \n+          -1.0000000000000000 },\n+  { -1005.9604880761007, 100, 2, \n+          -0.90000000000000002 },\n+  { -489.68041725865896, 100, 2, \n+          -0.80000000000000004 },\n+  { 768.31676011669970, 100, 2, \n+          -0.69999999999999996 },\n+  { 226.90362556628003, 100, 2, \n+          -0.59999999999999998 },\n+  { 604.19889304940330, 100, 2, \n+          -0.50000000000000000 },\n+  { 733.40061037838029, 100, 2, \n+          -0.40000000000000002 },\n+  { -573.30774483996402, 100, 2, \n+          -0.30000000000000004 },\n+  { -151.52946305080897, 100, 2, \n+          -0.19999999999999996 },\n+  { 646.30525583588019, 100, 2, \n+          -0.099999999999999978 },\n+  { -803.85129761050518, 100, 2, \n+          0.0000000000000000 },\n+  { 646.30525583587439, 100, 2, \n+          0.10000000000000009 },\n+  { -151.52946305080897, 100, 2, \n+          0.19999999999999996 },\n+  { -573.30774483996402, 100, 2, \n+          0.30000000000000004 },\n+  { 733.40061037838507, 100, 2, \n+          0.39999999999999991 },\n+  { 604.19889304940330, 100, 2, \n+          0.50000000000000000 },\n+  { 226.90362556629168, 100, 2, \n+          0.60000000000000009 },\n+  { 768.31676011669970, 100, 2, \n+          0.69999999999999996 },\n+  { -489.68041725865896, 100, 2, \n+          0.80000000000000004 },\n+  { -1005.9604880760811, 100, 2, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 2, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=2.\n+template <typename Tp>\n+void test031()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data031)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data031[i].l), Tp(data031[i].m),\n+                   Tp(data031[i].x));\n+      const Tp f0 = data031[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=100, m=5.\n+testcase_assoc_legendre<double> data032[] = {\n+  { 0.0000000000000000, 100, 5, \n+          -1.0000000000000000 },\n+  { 900551126.09653592, 100, 5, \n+          -0.90000000000000002 },\n+  { 988567431.55756044, 100, 5, \n+          -0.80000000000000004 },\n+  { -645646451.90344620, 100, 5, \n+          -0.69999999999999996 },\n+  { -897114585.29920745, 100, 5, \n+          -0.59999999999999998 },\n+  { -661710744.42483830, 100, 5, \n+          -0.50000000000000000 },\n+  { 380163158.51425594, 100, 5, \n+          -0.40000000000000002 },\n+  { 617391071.36632609, 100, 5, \n+          -0.30000000000000004 },\n+  { -805288801.85509181, 100, 5, \n+          -0.19999999999999996 },\n+  { 481041740.16728652, 100, 5, \n+          -0.099999999999999978 },\n+  { 0.0000000000000000, 100, 5, \n+          0.0000000000000000 },\n+  { -481041740.16729414, 100, 5, \n+          0.10000000000000009 },\n+  { 805288801.85509181, 100, 5, \n+          0.19999999999999996 },\n+  { -617391071.36632609, 100, 5, \n+          0.30000000000000004 },\n+  { -380163158.51424748, 100, 5, \n+          0.39999999999999991 },\n+  { 661710744.42483830, 100, 5, \n+          0.50000000000000000 },\n+  { 897114585.29920506, 100, 5, \n+          0.60000000000000009 },\n+  { 645646451.90344620, 100, 5, \n+          0.69999999999999996 },\n+  { -988567431.55756044, 100, 5, \n+          0.80000000000000004 },\n+  { -900551126.09655809, 100, 5, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 5, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=5.\n+template <typename Tp>\n+void test032()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data032)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data032[i].l), Tp(data032[i].m),\n+                   Tp(data032[i].x));\n+      const Tp f0 = data032[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for l=100, m=10.\n+testcase_assoc_legendre<double> data033[] = {\n+  { 0.0000000000000000, 100, 10, \n+          -1.0000000000000000 },\n+  { 2.5643395957658915e+17, 100, 10, \n+          -0.90000000000000002 },\n+  { 1.5778673545673316e+18, 100, 10, \n+          -0.80000000000000004 },\n+  { 4.4355048487496776e+18, 100, 10, \n+          -0.69999999999999996 },\n+  { -9.5936111659124493e+17, 100, 10, \n+          -0.59999999999999998 },\n+  { 4.2387123021963372e+18, 100, 10, \n+          -0.50000000000000000 },\n+  { 8.2370834618426563e+18, 100, 10, \n+          -0.40000000000000002 },\n+  { -4.9089358388052890e+18, 100, 10, \n+          -0.30000000000000004 },\n+  { -2.3468810358091279e+18, 100, 10, \n+          -0.19999999999999996 },\n+  { 6.8627855225034568e+18, 100, 10, \n+          -0.099999999999999978 },\n+  { -8.2494597181670380e+18, 100, 10, \n+          0.0000000000000000 },\n+  { 6.8627855225034056e+18, 100, 10, \n+          0.10000000000000009 },\n+  { -2.3468810358091279e+18, 100, 10, \n+          0.19999999999999996 },\n+  { -4.9089358388052890e+18, 100, 10, \n+          0.30000000000000004 },\n+  { 8.2370834618426747e+18, 100, 10, \n+          0.39999999999999991 },\n+  { 4.2387123021963372e+18, 100, 10, \n+          0.50000000000000000 },\n+  { -9.5936111659112115e+17, 100, 10, \n+          0.60000000000000009 },\n+  { 4.4355048487496776e+18, 100, 10, \n+          0.69999999999999996 },\n+  { 1.5778673545673316e+18, 100, 10, \n+          0.80000000000000004 },\n+  { 2.5643395957690282e+17, 100, 10, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 10, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=10.\n+template <typename Tp>\n+void test033()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data033)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data033[i].l), Tp(data033[i].m),\n+                   Tp(data033[i].x));\n+      const Tp f0 = data033[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for l=100, m=20.\n+testcase_assoc_legendre<double> data034[] = {\n+  { 0.0000000000000000, 100, 20, \n+          -1.0000000000000000 },\n+  { 7.1604344878778576e+37, 100, 20, \n+          -0.90000000000000002 },\n+  { -8.3963895116962035e+38, 100, 20, \n+          -0.80000000000000004 },\n+  { 7.9022236853110024e+38, 100, 20, \n+          -0.69999999999999996 },\n+  { 8.2680005574120908e+38, 100, 20, \n+          -0.59999999999999998 },\n+  { 3.0750497039999469e+38, 100, 20, \n+          -0.50000000000000000 },\n+  { -7.6120586043843874e+38, 100, 20, \n+          -0.40000000000000002 },\n+  { 1.1474496891901873e+38, 100, 20, \n+          -0.30000000000000004 },\n+  { 4.3966251307444218e+38, 100, 20, \n+          -0.19999999999999996 },\n+  { -7.0503266451702621e+38, 100, 20, \n+          -0.099999999999999978 },\n+  { 7.7727439836159581e+38, 100, 20, \n+          0.0000000000000000 },\n+  { -7.0503266451702213e+38, 100, 20, \n+          0.10000000000000009 },\n+  { 4.3966251307444218e+38, 100, 20, \n+          0.19999999999999996 },\n+  { 1.1474496891901873e+38, 100, 20, \n+          0.30000000000000004 },\n+  { -7.6120586043843511e+38, 100, 20, \n+          0.39999999999999991 },\n+  { 3.0750497039999469e+38, 100, 20, \n+          0.50000000000000000 },\n+  { 8.2680005574120424e+38, 100, 20, \n+          0.60000000000000009 },\n+  { 7.9022236853110024e+38, 100, 20, \n+          0.69999999999999996 },\n+  { -8.3963895116962035e+38, 100, 20, \n+          0.80000000000000004 },\n+  { 7.1604344878809460e+37, 100, 20, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 20, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=20.\n+template <typename Tp>\n+void test034()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data034)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data034[i].l), Tp(data034[i].m),\n+                   Tp(data034[i].x));\n+      const Tp f0 = data034[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000015e-12));\n+}\n+\n+// Test data for l=100, m=50.\n+testcase_assoc_legendre<double> data035[] = {\n+  { 0.0000000000000000, 100, 50, \n+          -1.0000000000000000 },\n+  { 9.3231278516893773e+96, 100, 50, \n+          -0.90000000000000002 },\n+  { -1.1029797977454331e+98, 100, 50, \n+          -0.80000000000000004 },\n+  { 1.8089333903465883e+97, 100, 50, \n+          -0.69999999999999996 },\n+  { 5.9364045925669389e+97, 100, 50, \n+          -0.59999999999999998 },\n+  { -8.2252620339727163e+97, 100, 50, \n+          -0.50000000000000000 },\n+  { 7.1431385093739848e+97, 100, 50, \n+          -0.40000000000000002 },\n+  { -3.3520602067479374e+97, 100, 50, \n+          -0.30000000000000004 },\n+  { -2.7791149588121386e+97, 100, 50, \n+          -0.19999999999999996 },\n+  { 9.0119338550180433e+97, 100, 50, \n+          -0.099999999999999978 },\n+  { -1.1712145031578381e+98, 100, 50, \n+          0.0000000000000000 },\n+  { 9.0119338550181176e+97, 100, 50, \n+          0.10000000000000009 },\n+  { -2.7791149588121386e+97, 100, 50, \n+          0.19999999999999996 },\n+  { -3.3520602067479374e+97, 100, 50, \n+          0.30000000000000004 },\n+  { 7.1431385093740728e+97, 100, 50, \n+          0.39999999999999991 },\n+  { -8.2252620339727163e+97, 100, 50, \n+          0.50000000000000000 },\n+  { 5.9364045925668061e+97, 100, 50, \n+          0.60000000000000009 },\n+  { 1.8089333903465883e+97, 100, 50, \n+          0.69999999999999996 },\n+  { -1.1029797977454331e+98, 100, 50, \n+          0.80000000000000004 },\n+  { 9.3231278516894892e+96, 100, 50, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 50, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=50.\n+template <typename Tp>\n+void test035()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data035)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data035[i].l), Tp(data035[i].m),\n+                   Tp(data035[i].x));\n+      const Tp f0 = data035[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for l=100, m=100.\n+testcase_assoc_legendre<double> data036[] = {\n+  { 0.0000000000000000, 100, 100, \n+          -1.0000000000000000 },\n+  { 5.7751792255758316e+150, 100, 100, \n+          -0.90000000000000002 },\n+  { 4.3552236041585515e+164, 100, 100, \n+          -0.80000000000000004 },\n+  { 1.5936546850595123e+172, 100, 100, \n+          -0.69999999999999996 },\n+  { 1.3579510590289176e+177, 100, 100, \n+          -0.59999999999999998 },\n+  { 3.7752749682889513e+180, 100, 100, \n+          -0.50000000000000000 },\n+  { 1.0910627330458913e+183, 100, 100, \n+          -0.40000000000000002 },\n+  { 5.9697347526822483e+184, 100, 100, \n+          -0.30000000000000004 },\n+  { 8.6585879147526714e+185, 100, 100, \n+          -0.19999999999999996 },\n+  { 4.0331571908057011e+186, 100, 100, \n+          -0.099999999999999978 },\n+  { 6.6663086700729543e+186, 100, 100, \n+          0.0000000000000000 },\n+  { 4.0331571908057011e+186, 100, 100, \n+          0.10000000000000009 },\n+  { 8.6585879147526714e+185, 100, 100, \n+          0.19999999999999996 },\n+  { 5.9697347526822483e+184, 100, 100, \n+          0.30000000000000004 },\n+  { 1.0910627330458913e+183, 100, 100, \n+          0.39999999999999991 },\n+  { 3.7752749682889513e+180, 100, 100, \n+          0.50000000000000000 },\n+  { 1.3579510590289000e+177, 100, 100, \n+          0.60000000000000009 },\n+  { 1.5936546850595123e+172, 100, 100, \n+          0.69999999999999996 },\n+  { 4.3552236041585515e+164, 100, 100, \n+          0.80000000000000004 },\n+  { 5.7751792255761289e+150, 100, 100, \n+          0.89999999999999991 },\n+  { 0.0000000000000000, 100, 100, \n+          1.0000000000000000 },\n+};\n+\n+// Test function for l=100, m=100.\n+template <typename Tp>\n+void test036()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data036)\n+                         / sizeof(testcase_assoc_legendre<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::assoc_legendre(Tp(data036[i].l), Tp(data036[i].m),\n+                   Tp(data036[i].x));\n+      const Tp f0 = data036[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  test012<double>();\n+  test013<double>();\n+  test014<double>();\n+  test015<double>();\n+  test016<double>();\n+  test017<double>();\n+  test018<double>();\n+  test019<double>();\n+  test020<double>();\n+  test021<double>();\n+  test022<double>();\n+  test023<double>();\n+  test024<double>();\n+  test025<double>();\n+  test026<double>();\n+  test027<double>();\n+  test028<double>();\n+  test029<double>();\n+  test030<double>();\n+  test031<double>();\n+  test032<double>();\n+  test033<double>();\n+  test034<double>();\n+  test035<double>();\n+  test036<double>();\n+  return 0;\n+}"}, {"sha": "a18b05f74a76f946238e30be4e81944a92a24014", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/02_assoc_legendre/compile.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.2 assoc_legendre\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+  unsigned int l = 2, m = 1;\n+\n+  std::tr1::assoc_legendre(l, m, xf);\n+  std::tr1::assoc_legendref(l, m, xf);\n+  std::tr1::assoc_legendre(l, m, xd);\n+  std::tr1::assoc_legendre(l, m, xl);\n+  std::tr1::assoc_legendrel(l, m, xl);\n+\n+  return;\n+}\n+"}, {"sha": "2fe173022d75098fdb89406f75164008b6ca9b55", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/02_assoc_legendre/compile_2.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F02_assoc_legendre%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.2 assoc_legendre\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+  unsigned int l = 2, m = 1;\n+\n+  assoc_legendre(l, m, xf);\n+  assoc_legendref(l, m, xf);\n+  assoc_legendre(l, m, xd);\n+  assoc_legendre(l, m, xl);\n+  assoc_legendrel(l, m, xl);\n+\n+  return;\n+}\n+"}, {"sha": "ca8246c4e72dce338b850c9c0130be09390db4ef", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/03_beta/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.3 beta\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float yf = 0.0F;\n+  double yd = 0.0;\n+  long double yl = 0.0L;\n+\n+  float a = std::tr1::beta(xf, yf);\n+  float b = std::tr1::betaf(xf, yf);\n+  double c = std::tr1::beta(xd, yd);\n+  long double d = std::tr1::beta(xl, yl);\n+  long double e = std::tr1::betal(xl, yl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float xf = 1.0F;\n+  double xd = 1.0;\n+  long double xl = 1.0L;\n+\n+  float yf = std::numeric_limits<float>::quiet_NaN();\n+  double yd = std::numeric_limits<double>::quiet_NaN();\n+  long double yl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::beta(xf, yf);\n+  float b = std::tr1::betaf(xf, yf);\n+  double c = std::tr1::beta(xd, yd);\n+  long double d = std::tr1::beta(xl, yl);\n+  long double e = std::tr1::betal(xl, yl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "8f8a4a74a78f23dec0611c09e416293de7072a35", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/03_beta/check_value.cc", "status": "added", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,466 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  beta\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for x=10.000000000000000.\n+testcase_beta<double> data001[] = {\n+  { 1.0825088224469029e-06, 10.000000000000000, 10.000000000000000 },\n+  { 4.9925087406346778e-09, 10.000000000000000, 20.000000000000000 },\n+  { 1.5729567312509485e-10, 10.000000000000000, 30.000000000000000 },\n+  { 1.2168673582561288e-11, 10.000000000000000, 40.000000000000000 },\n+  { 1.5916380099863291e-12, 10.000000000000000, 50.000000000000000 },\n+  { 2.9408957938463963e-13, 10.000000000000000, 60.000000000000000 },\n+  { 6.9411637980691676e-14, 10.000000000000000, 70.000000000000000 },\n+  { 1.9665612972502651e-14, 10.000000000000000, 80.000000000000000 },\n+  { 6.4187824828154399e-15, 10.000000000000000, 90.000000000000000 },\n+  { 2.3455339739604842e-15, 10.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=10.000000000000000.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data001[i].x), Tp(data001[i].y));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+// Test data for x=20.000000000000000.\n+testcase_beta<double> data002[] = {\n+  { 4.9925087406346778e-09, 20.000000000000000, 10.000000000000000 },\n+  { 7.2544445519248436e-13, 20.000000000000000, 20.000000000000000 },\n+  { 1.7681885473062028e-15, 20.000000000000000, 30.000000000000000 },\n+  { 1.7891885039182335e-17, 20.000000000000000, 40.000000000000000 },\n+  { 4.3240677875623635e-19, 20.000000000000000, 50.000000000000000 },\n+  { 1.8857342309689050e-20, 20.000000000000000, 60.000000000000000 },\n+  { 1.2609804003539998e-21, 20.000000000000000, 70.000000000000000 },\n+  { 1.1660809542079041e-22, 20.000000000000000, 80.000000000000000 },\n+  { 1.3907944279729071e-23, 20.000000000000000, 90.000000000000000 },\n+  { 2.0365059099917614e-24, 20.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=20.000000000000000.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data002[i].x), Tp(data002[i].y));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for x=30.000000000000000.\n+testcase_beta<double> data003[] = {\n+  { 1.5729567312509485e-10, 30.000000000000000, 10.000000000000000 },\n+  { 1.7681885473062028e-15, 30.000000000000000, 20.000000000000000 },\n+  { 5.6370779640482451e-19, 30.000000000000000, 30.000000000000000 },\n+  { 1.0539424603796547e-21, 30.000000000000000, 40.000000000000000 },\n+  { 6.0118197777273836e-24, 30.000000000000000, 50.000000000000000 },\n+  { 7.4279528553260165e-26, 30.000000000000000, 60.000000000000000 },\n+  { 1.6212207780604767e-27, 30.000000000000000, 70.000000000000000 },\n+  { 5.4783729715317616e-29, 30.000000000000000, 80.000000000000000 },\n+  { 2.6183005659681346e-30, 30.000000000000000, 90.000000000000000 },\n+  { 1.6587948222122229e-31, 30.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=30.000000000000000.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data003[i].x), Tp(data003[i].y));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for x=40.000000000000000.\n+testcase_beta<double> data004[] = {\n+  { 1.2168673582561288e-11, 40.000000000000000, 10.000000000000000 },\n+  { 1.7891885039182335e-17, 40.000000000000000, 20.000000000000000 },\n+  { 1.0539424603796547e-21, 40.000000000000000, 30.000000000000000 },\n+  { 4.6508509140090659e-25, 40.000000000000000, 40.000000000000000 },\n+  { 7.5161712118557719e-28, 40.000000000000000, 50.000000000000000 },\n+  { 3.0311331979886071e-30, 40.000000000000000, 60.000000000000000 },\n+  { 2.4175035070466313e-32, 40.000000000000000, 70.000000000000000 },\n+  { 3.2734839142758369e-34, 40.000000000000000, 80.000000000000000 },\n+  { 6.7690629601315579e-36, 40.000000000000000, 90.000000000000000 },\n+  { 1.9797337118812366e-37, 40.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=40.000000000000000.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data004[i].x), Tp(data004[i].y));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000015e-12));\n+}\n+\n+// Test data for x=50.000000000000000.\n+testcase_beta<double> data005[] = {\n+  { 1.5916380099863291e-12, 50.000000000000000, 10.000000000000000 },\n+  { 4.3240677875623635e-19, 50.000000000000000, 20.000000000000000 },\n+  { 6.0118197777273836e-24, 50.000000000000000, 30.000000000000000 },\n+  { 7.5161712118557719e-28, 50.000000000000000, 40.000000000000000 },\n+  { 3.9646612085674138e-31, 50.000000000000000, 50.000000000000000 },\n+  { 5.8425643906418403e-34, 50.000000000000000, 60.000000000000000 },\n+  { 1.8672362180783552e-36, 50.000000000000000, 70.000000000000000 },\n+  { 1.0939382296458962e-38, 50.000000000000000, 80.000000000000000 },\n+  { 1.0442781609881063e-40, 50.000000000000000, 90.000000000000000 },\n+  { 1.4904121110954370e-42, 50.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=50.000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data005[i].x), Tp(data005[i].y));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for x=60.000000000000000.\n+testcase_beta<double> data006[] = {\n+  { 2.9408957938463963e-13, 60.000000000000000, 10.000000000000000 },\n+  { 1.8857342309689050e-20, 60.000000000000000, 20.000000000000000 },\n+  { 7.4279528553260165e-26, 60.000000000000000, 30.000000000000000 },\n+  { 3.0311331979886071e-30, 60.000000000000000, 40.000000000000000 },\n+  { 5.8425643906418403e-34, 60.000000000000000, 50.000000000000000 },\n+  { 3.4501231469782229e-37, 60.000000000000000, 60.000000000000000 },\n+  { 4.7706855386086599e-40, 60.000000000000000, 70.000000000000000 },\n+  { 1.2902663809722593e-42, 60.000000000000000, 80.000000000000000 },\n+  { 6.0105571058570508e-45, 60.000000000000000, 90.000000000000000 },\n+  { 4.3922898898347209e-47, 60.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=60.000000000000000.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data006[i].x), Tp(data006[i].y));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for x=70.000000000000000.\n+testcase_beta<double> data007[] = {\n+  { 6.9411637980691676e-14, 70.000000000000000, 10.000000000000000 },\n+  { 1.2609804003539998e-21, 70.000000000000000, 20.000000000000000 },\n+  { 1.6212207780604767e-27, 70.000000000000000, 30.000000000000000 },\n+  { 2.4175035070466313e-32, 70.000000000000000, 40.000000000000000 },\n+  { 1.8672362180783552e-36, 70.000000000000000, 50.000000000000000 },\n+  { 4.7706855386086599e-40, 70.000000000000000, 60.000000000000000 },\n+  { 3.0453137143486369e-43, 70.000000000000000, 70.000000000000000 },\n+  { 4.0192274082013779e-46, 70.000000000000000, 80.000000000000000 },\n+  { 9.5865870063501807e-49, 70.000000000000000, 90.000000000000000 },\n+  { 3.7409127305819802e-51, 70.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=70.000000000000000.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data007[i].x), Tp(data007[i].y));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for x=80.000000000000000.\n+testcase_beta<double> data008[] = {\n+  { 1.9665612972502651e-14, 80.000000000000000, 10.000000000000000 },\n+  { 1.1660809542079041e-22, 80.000000000000000, 20.000000000000000 },\n+  { 5.4783729715317616e-29, 80.000000000000000, 30.000000000000000 },\n+  { 3.2734839142758369e-34, 80.000000000000000, 40.000000000000000 },\n+  { 1.0939382296458962e-38, 80.000000000000000, 50.000000000000000 },\n+  { 1.2902663809722593e-42, 80.000000000000000, 60.000000000000000 },\n+  { 4.0192274082013779e-46, 80.000000000000000, 70.000000000000000 },\n+  { 2.7160590828669411e-49, 80.000000000000000, 80.000000000000000 },\n+  { 3.4593773902125368e-52, 80.000000000000000, 90.000000000000000 },\n+  { 7.4807039968503468e-55, 80.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=80.000000000000000.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data008[i].x), Tp(data008[i].y));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+// Test data for x=90.000000000000000.\n+testcase_beta<double> data009[] = {\n+  { 6.4187824828154399e-15, 90.000000000000000, 10.000000000000000 },\n+  { 1.3907944279729071e-23, 90.000000000000000, 20.000000000000000 },\n+  { 2.6183005659681346e-30, 90.000000000000000, 30.000000000000000 },\n+  { 6.7690629601315579e-36, 90.000000000000000, 40.000000000000000 },\n+  { 1.0442781609881063e-40, 90.000000000000000, 50.000000000000000 },\n+  { 6.0105571058570508e-45, 90.000000000000000, 60.000000000000000 },\n+  { 9.5865870063501807e-49, 90.000000000000000, 70.000000000000000 },\n+  { 3.4593773902125368e-52, 90.000000000000000, 80.000000000000000 },\n+  { 2.4416737907558032e-55, 90.000000000000000, 90.000000000000000 },\n+  { 3.0238531916564246e-58, 90.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=90.000000000000000.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data009[i].x), Tp(data009[i].y));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for x=100.00000000000000.\n+testcase_beta<double> data010[] = {\n+  { 2.3455339739604842e-15, 100.00000000000000, 10.000000000000000 },\n+  { 2.0365059099917614e-24, 100.00000000000000, 20.000000000000000 },\n+  { 1.6587948222122229e-31, 100.00000000000000, 30.000000000000000 },\n+  { 1.9797337118812366e-37, 100.00000000000000, 40.000000000000000 },\n+  { 1.4904121110954370e-42, 100.00000000000000, 50.000000000000000 },\n+  { 4.3922898898347209e-47, 100.00000000000000, 60.000000000000000 },\n+  { 3.7409127305819802e-51, 100.00000000000000, 70.000000000000000 },\n+  { 7.4807039968503468e-55, 100.00000000000000, 80.000000000000000 },\n+  { 3.0238531916564246e-58, 100.00000000000000, 90.000000000000000 },\n+  { 2.2087606931991853e-61, 100.00000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for x=100.00000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_beta<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::beta(Tp(data010[i].x), Tp(data010[i].y));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  return 0;\n+}"}, {"sha": "a689c95a4aa05e81cee89631ec6c917f0a7c1942", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/03_beta/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.3 beta\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F, yf = 0.5F;\n+  double xd = 0.5, yd = 0.5;\n+  long double xl = 0.5L, yl = 0.5L;\n+\n+  std::tr1::beta(xf, yf);\n+  std::tr1::betaf(xf, yf);\n+  std::tr1::beta(xd, yd);\n+  std::tr1::beta(xl, yl);\n+  std::tr1::betal(xl, yl);\n+\n+  return;\n+}\n+"}, {"sha": "68d5b20cfb3542da2155c066c494187e4aef2584", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/03_beta/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F03_beta%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.3 beta\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = 0.5F, yf = 0.5F;\n+  double xd = 0.5, yd = 0.5;\n+  long double xl = 0.5L, yl = 0.5L;\n+\n+  beta(xf, yf);\n+  betaf(xf, yf);\n+  beta(xd, yd);\n+  beta(xl, yl);\n+  betal(xl, yl);\n+\n+  return;\n+}\n+"}, {"sha": "f5a0e9b74ca9eace90e6f51d0e2fed1ff86886fe", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/04_comp_ellint_1/check_nan.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,57 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.4 comp_ellint_1\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::comp_ellint_1(kf);\n+  float b = std::tr1::comp_ellint_1f(kf);\n+  double c = std::tr1::comp_ellint_1(kd);\n+  long double d = std::tr1::comp_ellint_1(kl);\n+  long double e = std::tr1::comp_ellint_1l(kl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "7fda191f00df537952c452c34655be647eb13ec7", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/04_comp_ellint_1/check_value.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,97 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  comp_ellint_1\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data.\n+testcase_comp_ellint_1<double> data001[] = {\n+  { 2.2805491384227703, -0.90000000000000002 },\n+  { 1.9953027776647296, -0.80000000000000004 },\n+  { 1.8456939983747236, -0.69999999999999996 },\n+  { 1.7507538029157526, -0.59999999999999998 },\n+  { 1.6857503548125963, -0.50000000000000000 },\n+  { 1.6399998658645112, -0.40000000000000002 },\n+  { 1.6080486199305126, -0.30000000000000004 },\n+  { 1.5868678474541664, -0.19999999999999996 },\n+  { 1.5747455615173562, -0.099999999999999978 },\n+  { 1.5707963267948966, 0.0000000000000000 },\n+  { 1.5747455615173562, 0.10000000000000009 },\n+  { 1.5868678474541664, 0.19999999999999996 },\n+  { 1.6080486199305126, 0.30000000000000004 },\n+  { 1.6399998658645112, 0.39999999999999991 },\n+  { 1.6857503548125963, 0.50000000000000000 },\n+  { 1.7507538029157526, 0.60000000000000009 },\n+  { 1.8456939983747236, 0.69999999999999996 },\n+  { 1.9953027776647296, 0.80000000000000004 },\n+  { 2.2805491384227699, 0.89999999999999991 },\n+};\n+\n+// Test function.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_comp_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_1(Tp(data001[i].k));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  return 0;\n+}"}, {"sha": "b72f5b64f836d050d24852b75ca617cc2fe70aa9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/04_comp_ellint_1/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.4 comp_ellint_1\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  std::tr1::comp_ellint_1(kf);\n+  std::tr1::comp_ellint_1f(kf);\n+  std::tr1::comp_ellint_1(kd);\n+  std::tr1::comp_ellint_1(kl);\n+  std::tr1::comp_ellint_1l(kl);\n+\n+  return;\n+}\n+"}, {"sha": "ec52fcb019e16877115ec6084f4b28918a34c7e9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/04_comp_ellint_1/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F04_comp_ellint_1%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.4 comp_ellint_1\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  comp_ellint_1(kf);\n+  comp_ellint_1f(kf);\n+  comp_ellint_1(kd);\n+  comp_ellint_1(kl);\n+  comp_ellint_1l(kl);\n+\n+  return;\n+}\n+"}, {"sha": "b30c77a75552933cf6b44680c11dd09bfe78fa61", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/05_comp_ellint_2/check_nan.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,57 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.5 comp_ellint_2\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::comp_ellint_2(kf);\n+  float b = std::tr1::comp_ellint_2f(kf);\n+  double c = std::tr1::comp_ellint_2(kd);\n+  long double d = std::tr1::comp_ellint_2(kl);\n+  long double e = std::tr1::comp_ellint_2l(kl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "9fd6a06b665c940575d3a31d26985429fff2bdce", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/05_comp_ellint_2/check_value.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,97 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  comp_ellint_2\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data.\n+testcase_comp_ellint_2<double> data001[] = {\n+  { 1.1716970527816140, -0.90000000000000002 },\n+  { 1.2763499431699066, -0.80000000000000004 },\n+  { 1.3556611355719557, -0.69999999999999996 },\n+  { 1.4180833944487243, -0.59999999999999998 },\n+  { 1.4674622093394274, -0.50000000000000000 },\n+  { 1.5059416123600402, -0.40000000000000002 },\n+  { 1.5348334649232489, -0.30000000000000004 },\n+  { 1.5549685462425296, -0.19999999999999996 },\n+  { 1.5668619420216685, -0.099999999999999978 },\n+  { 1.5707963267948966, 0.0000000000000000 },\n+  { 1.5668619420216685, 0.10000000000000009 },\n+  { 1.5549685462425296, 0.19999999999999996 },\n+  { 1.5348334649232489, 0.30000000000000004 },\n+  { 1.5059416123600404, 0.39999999999999991 },\n+  { 1.4674622093394274, 0.50000000000000000 },\n+  { 1.4180833944487241, 0.60000000000000009 },\n+  { 1.3556611355719557, 0.69999999999999996 },\n+  { 1.2763499431699066, 0.80000000000000004 },\n+  { 1.1716970527816142, 0.89999999999999991 },\n+};\n+\n+// Test function.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_comp_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_2(Tp(data001[i].k));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  return 0;\n+}"}, {"sha": "5ac3d2bf3c9783262dadc486fe93a262ed06d157", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/05_comp_ellint_2/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.5 comp_ellint_2\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  std::tr1::comp_ellint_2(kf);\n+  std::tr1::comp_ellint_2f(kf);\n+  std::tr1::comp_ellint_2(kd);\n+  std::tr1::comp_ellint_2(kl);\n+  std::tr1::comp_ellint_2l(kl);\n+\n+  return;\n+}\n+"}, {"sha": "7f2c0b8d03ebcc284ae7beb1486517a8e5e6d6ef", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/05_comp_ellint_2/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F05_comp_ellint_2%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.4 comp_ellint_2\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  comp_ellint_2(kf);\n+  comp_ellint_2f(kf);\n+  comp_ellint_2(kd);\n+  comp_ellint_2(kl);\n+  comp_ellint_2l(kl);\n+\n+  return;\n+}\n+"}, {"sha": "b928eab7642c3f2cb3285d9088fa7aa2ae0b26a1", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.6 comp_ellint_3\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.0F;\n+  double nud = 0.0;\n+  long double nul = 0.0L;\n+\n+  float a = std::tr1::comp_ellint_3(kf, nuf);\n+  float b = std::tr1::comp_ellint_3f(kf, nuf);\n+  double c = std::tr1::comp_ellint_3(kd, nud);\n+  long double d = std::tr1::comp_ellint_3(kl, nul);\n+  long double e = std::tr1::comp_ellint_3l(kl, nul);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float kf = 1.0F;\n+  double kd = 1.0;\n+  long double kl = 1.0L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::comp_ellint_3(kf, nuf);\n+  float b = std::tr1::comp_ellint_3f(kf, nuf);\n+  double c = std::tr1::comp_ellint_3(kd, nud);\n+  long double d = std::tr1::comp_ellint_3(kl, nul);\n+  long double e = std::tr1::comp_ellint_3l(kl, nul);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "4d4e78be662adc3816ac3886dd8dfc2683b9f177", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,844 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  comp_ellint_3\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for k=-0.90000000000000002.\n+testcase_comp_ellint_3<double> data001[] = {\n+  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },\n+  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },\n+  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },\n+  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },\n+  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },\n+  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },\n+  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },\n+  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996 },\n+  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004 },\n+  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.90000000000000002.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data001[i].k), Tp(data001[i].nu));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.80000000000000004.\n+testcase_comp_ellint_3<double> data002[] = {\n+  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },\n+  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },\n+  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },\n+  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },\n+  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },\n+  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },\n+  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },\n+  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },\n+  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004 },\n+  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.80000000000000004.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data002[i].k), Tp(data002[i].nu));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.69999999999999996.\n+testcase_comp_ellint_3<double> data003[] = {\n+  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },\n+  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },\n+  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001 },\n+  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },\n+  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },\n+  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },\n+  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },\n+  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },\n+  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004 },\n+  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.69999999999999996.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data003[i].k), Tp(data003[i].nu));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.59999999999999998.\n+testcase_comp_ellint_3<double> data004[] = {\n+  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },\n+  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },\n+  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },\n+  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },\n+  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },\n+  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },\n+  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },\n+  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996 },\n+  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },\n+  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.59999999999999998.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data004[i].k), Tp(data004[i].nu));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.50000000000000000.\n+testcase_comp_ellint_3<double> data005[] = {\n+  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },\n+  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },\n+  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },\n+  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },\n+  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },\n+  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },\n+  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },\n+  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },\n+  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },\n+  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.50000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data005[i].k), Tp(data005[i].nu));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.40000000000000002.\n+testcase_comp_ellint_3<double> data006[] = {\n+  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },\n+  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },\n+  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },\n+  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },\n+  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },\n+  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },\n+  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },\n+  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },\n+  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },\n+  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.40000000000000002.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data006[i].k), Tp(data006[i].nu));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.30000000000000004.\n+testcase_comp_ellint_3<double> data007[] = {\n+  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000 },\n+  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001 },\n+  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001 },\n+  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999 },\n+  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002 },\n+  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000 },\n+  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998 },\n+  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996 },\n+  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004 },\n+  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.30000000000000004.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data007[i].k), Tp(data007[i].nu));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.19999999999999996.\n+testcase_comp_ellint_3<double> data008[] = {\n+  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000 },\n+  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001 },\n+  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001 },\n+  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999 },\n+  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002 },\n+  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000 },\n+  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998 },\n+  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996 },\n+  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004 },\n+  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.19999999999999996.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data008[i].k), Tp(data008[i].nu));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.099999999999999978.\n+testcase_comp_ellint_3<double> data009[] = {\n+  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },\n+  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },\n+  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },\n+  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },\n+  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },\n+  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },\n+  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },\n+  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996 },\n+  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },\n+  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },\n+};\n+\n+// Test function for k=-0.099999999999999978.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data009[i].k), Tp(data009[i].nu));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.0000000000000000.\n+testcase_comp_ellint_3<double> data010[] = {\n+  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },\n+  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },\n+  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },\n+  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },\n+  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002 },\n+  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },\n+  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },\n+  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },\n+  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },\n+  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.0000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data010[i].k), Tp(data010[i].nu));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.10000000000000009.\n+testcase_comp_ellint_3<double> data011[] = {\n+  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },\n+  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },\n+  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },\n+  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },\n+  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },\n+  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },\n+  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },\n+  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996 },\n+  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },\n+  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.10000000000000009.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data011[i].k), Tp(data011[i].nu));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.19999999999999996.\n+testcase_comp_ellint_3<double> data012[] = {\n+  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000 },\n+  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001 },\n+  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001 },\n+  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999 },\n+  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002 },\n+  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000 },\n+  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998 },\n+  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996 },\n+  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004 },\n+  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.19999999999999996.\n+template <typename Tp>\n+void test012()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data012)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data012[i].k), Tp(data012[i].nu));\n+      const Tp f0 = data012[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.30000000000000004.\n+testcase_comp_ellint_3<double> data013[] = {\n+  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000 },\n+  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001 },\n+  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001 },\n+  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999 },\n+  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002 },\n+  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000 },\n+  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998 },\n+  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996 },\n+  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004 },\n+  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.30000000000000004.\n+template <typename Tp>\n+void test013()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data013)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data013[i].k), Tp(data013[i].nu));\n+      const Tp f0 = data013[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.39999999999999991.\n+testcase_comp_ellint_3<double> data014[] = {\n+  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },\n+  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },\n+  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },\n+  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },\n+  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },\n+  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },\n+  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },\n+  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },\n+  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },\n+  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.39999999999999991.\n+template <typename Tp>\n+void test014()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data014)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data014[i].k), Tp(data014[i].nu));\n+      const Tp f0 = data014[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.50000000000000000.\n+testcase_comp_ellint_3<double> data015[] = {\n+  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },\n+  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },\n+  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },\n+  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },\n+  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },\n+  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },\n+  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },\n+  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },\n+  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },\n+  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.50000000000000000.\n+template <typename Tp>\n+void test015()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data015)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data015[i].k), Tp(data015[i].nu));\n+      const Tp f0 = data015[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.60000000000000009.\n+testcase_comp_ellint_3<double> data016[] = {\n+  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },\n+  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },\n+  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },\n+  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },\n+  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },\n+  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },\n+  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },\n+  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996 },\n+  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },\n+  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.60000000000000009.\n+template <typename Tp>\n+void test016()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data016)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data016[i].k), Tp(data016[i].nu));\n+      const Tp f0 = data016[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.69999999999999996.\n+testcase_comp_ellint_3<double> data017[] = {\n+  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },\n+  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },\n+  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001 },\n+  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },\n+  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },\n+  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },\n+  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },\n+  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },\n+  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004 },\n+  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.69999999999999996.\n+template <typename Tp>\n+void test017()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data017)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data017[i].k), Tp(data017[i].nu));\n+      const Tp f0 = data017[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.80000000000000004.\n+testcase_comp_ellint_3<double> data018[] = {\n+  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },\n+  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },\n+  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },\n+  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },\n+  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },\n+  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },\n+  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },\n+  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },\n+  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004 },\n+  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.80000000000000004.\n+template <typename Tp>\n+void test018()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data018)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data018[i].k), Tp(data018[i].nu));\n+      const Tp f0 = data018[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.89999999999999991.\n+testcase_comp_ellint_3<double> data019[] = {\n+  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000 },\n+  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001 },\n+  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001 },\n+  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999 },\n+  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002 },\n+  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000 },\n+  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998 },\n+  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996 },\n+  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004 },\n+  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002 },\n+};\n+\n+// Test function for k=0.89999999999999991.\n+template <typename Tp>\n+void test019()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data019)\n+                         / sizeof(testcase_comp_ellint_3<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::comp_ellint_3(Tp(data019[i].k), Tp(data019[i].nu));\n+      const Tp f0 = data019[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  test012<double>();\n+  test013<double>();\n+  test014<double>();\n+  test015<double>();\n+  test016<double>();\n+  test017<double>();\n+  test018<double>();\n+  test019<double>();\n+  return 0;\n+}"}, {"sha": "a4bbcb88b76a1b3f7f436c1937a62b771a98a9eb", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.6 comp_ellint_3\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F, nuf = 0.5F;\n+  double kd = 0.5, nud = 0.5;\n+  long double kl = 0.5L, nul = 0.5L;\n+\n+  std::tr1::comp_ellint_3(kf, nuf);\n+  std::tr1::comp_ellint_3f(kf, nuf);\n+  std::tr1::comp_ellint_3(kd, nud);\n+  std::tr1::comp_ellint_3(kl, nul);\n+  std::tr1::comp_ellint_3l(kl, nul);\n+\n+  return;\n+}\n+"}, {"sha": "56319e537c37343ee80105661eecafb269957d2d", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F06_comp_ellint_3%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.6 comp_ellint_3\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float kf = 0.5F, nuf = 0.5F;\n+  double kd = 0.5, nud = 0.5;\n+  long double kl = 0.5L, nul = 0.5L;\n+\n+  comp_ellint_3(kf, nuf);\n+  comp_ellint_3f(kf, nuf);\n+  comp_ellint_3(kd, nud);\n+  comp_ellint_3(kl, nul);\n+  comp_ellint_3l(kl, nul);\n+\n+  return;\n+}\n+"}, {"sha": "1f2bb40bd0c6b3de57654f66c1f2402eab5940ba", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/07_conf_hyperg/check_nan.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,126 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.7 conf_hyperg\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float af = std::numeric_limits<float>::quiet_NaN();\n+  double ad = std::numeric_limits<double>::quiet_NaN();\n+  long double al = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float cf = 3.0F;\n+  double cd = 3.0;\n+  long double cl = 3.0L;\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  float a = std::tr1::conf_hyperg(af, cf, xf);\n+  float b = std::tr1::conf_hypergf(af, cf, xf);\n+  double c = std::tr1::conf_hyperg(ad, cd, xd);\n+  long double d = std::tr1::conf_hyperg(al, cl, xl);\n+  long double e = std::tr1::conf_hypergl(al, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float af = 2.0F;\n+  double ad = 2.0;\n+  long double al = 2.0L;\n+\n+  float cf = std::numeric_limits<float>::quiet_NaN();\n+  double cd = std::numeric_limits<double>::quiet_NaN();\n+  long double cl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  float a = std::tr1::conf_hyperg(af, cf, xf);\n+  float b = std::tr1::conf_hypergf(af, cf, xf);\n+  double c = std::tr1::conf_hyperg(ad, cd, xd);\n+  long double d = std::tr1::conf_hyperg(al, cl, xl);\n+  long double e = std::tr1::conf_hypergl(al, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test03()\n+{\n+  float af = 2.0F;\n+  double ad = 2.0;\n+  long double al = 2.0L;\n+\n+  float cf = 3.0F;\n+  double cd = 3.0;\n+  long double cl = 3.0L;\n+\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::conf_hyperg(af, cf, xf);\n+  float b = std::tr1::conf_hypergf(af, cf, xf);\n+  double c = std::tr1::conf_hyperg(ad, cd, xd);\n+  long double d = std::tr1::conf_hyperg(al, cl, xl);\n+  long double e = std::tr1::conf_hypergl(al, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}\n+"}, {"sha": "a751448459c41f380d1bf56688e19421c8a88408", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/07_conf_hyperg/check_value.cc", "status": "added", "additions": 5294, "deletions": 0, "changes": 5294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "1085952d7da3156ba906029a3f875ee6b6a22441", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/07_conf_hyperg/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.7 conf_hyperg\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float af = 2.0F, cf = 3.0F, xf = 0.5F;\n+  double ad = 2.0, cd = 3.0, xd = 0.5;\n+  long double al = 2.0L, cl = 3.0L, xl = 0.5L;\n+\n+  std::tr1::conf_hyperg(af, cf, xf);\n+  std::tr1::conf_hypergf(af, cf, xf);\n+  std::tr1::conf_hyperg(ad, cd, xd);\n+  std::tr1::conf_hyperg(al, cl, xl);\n+  std::tr1::conf_hypergl(al, cl, xl);\n+\n+  return;\n+}\n+"}, {"sha": "654bdf903169abb09f08d78f11a8a189bf28240d", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/07_conf_hyperg/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F07_conf_hyperg%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.7 conf_hyperg\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+\n+  float af = 2.0F, cf = 3.0F, xf = 0.5F;\n+  double ad = 2.0, cd = 3.0, xd = 0.5;\n+  long double al = 2.0L, cl = 3.0L, xl = 0.5L;\n+\n+  conf_hyperg(af, cf, xf);\n+  conf_hypergf(af, cf, xf);\n+  conf_hyperg(ad, cd, xd);\n+  conf_hyperg(al, cl, xl);\n+  conf_hypergl(al, cl, xl);\n+\n+  return;\n+}\n+"}, {"sha": "4220f0236d555e2fa2517941703af355db9bc3d9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/08_cyl_bessel_i/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.8 cyl_bessel_i\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.0F;\n+  double nud = 0.0;\n+  long double nul = 0.0L;\n+\n+  float a = std::tr1::cyl_bessel_i(nuf, xf);\n+  float b = std::tr1::cyl_bessel_if(nuf, xf);\n+  double c = std::tr1::cyl_bessel_i(nud, xd);\n+  long double d = std::tr1::cyl_bessel_i(nul, xl);\n+  long double e = std::tr1::cyl_bessel_il(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float xf = 1.0F;\n+  double xd = 1.0;\n+  long double xl = 1.0L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::cyl_bessel_i(nuf, xf);\n+  float b = std::tr1::cyl_bessel_if(nuf, xf);\n+  double c = std::tr1::cyl_bessel_i(nud, xd);\n+  long double d = std::tr1::cyl_bessel_i(nul, xl);\n+  long double e = std::tr1::cyl_bessel_il(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "32f8af1c26aca4a7333af231406e95418f75a717", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/08_cyl_bessel_i/check_value.cc", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,629 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  cyl_bessel_i\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for nu=0.0000000000000000.\n+testcase_cyl_bessel_i<double> data001[] = {\n+  { 1.0000000000000000, 0.0000000000000000, 0.0000000000000000 },\n+  { 27.239871823604439, 0.0000000000000000, 5.0000000000000000 },\n+  { 2815.7166284662558, 0.0000000000000000, 10.000000000000000 },\n+  { 339649.37329791381, 0.0000000000000000, 15.000000000000000 },\n+  { 43558282.559553474, 0.0000000000000000, 20.000000000000000 },\n+  { 5774560606.4663124, 0.0000000000000000, 25.000000000000000 },\n+  { 781672297823.97925, 0.0000000000000000, 30.000000000000000 },\n+  { 107338818494514.42, 0.0000000000000000, 35.000000000000000 },\n+  { 14894774793419918., 0.0000000000000000, 40.000000000000000 },\n+  { 2.0834140751773158e+18, 0.0000000000000000, 45.000000000000000 },\n+  { 2.9325537838493463e+20, 0.0000000000000000, 50.000000000000000 },\n+  { 4.1487895607332160e+22, 0.0000000000000000, 55.000000000000000 },\n+  { 5.8940770556098216e+24, 0.0000000000000000, 60.000000000000000 },\n+  { 8.4030398456255610e+26, 0.0000000000000000, 65.000000000000000 },\n+  { 1.2015889579125422e+29, 0.0000000000000000, 70.000000000000000 },\n+  { 1.7226390780357971e+31, 0.0000000000000000, 75.000000000000000 },\n+  { 2.4751784043341670e+33, 0.0000000000000000, 80.000000000000000 },\n+  { 3.5634776304081418e+35, 0.0000000000000000, 85.000000000000000 },\n+  { 5.1392383455086475e+37, 0.0000000000000000, 90.000000000000000 },\n+  { 7.4233258618752096e+39, 0.0000000000000000, 95.000000000000000 },\n+  { 1.0737517071310986e+42, 0.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.0000000000000000.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data001[i].nu), Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000015e-12));\n+}\n+\n+// Test data for nu=0.33333333333333331.\n+testcase_cyl_bessel_i<double> data002[] = {\n+  { 0.0000000000000000, 0.33333333333333331, 0.0000000000000000 },\n+  { 26.897553069268362, 0.33333333333333331, 5.0000000000000000 },\n+  { 2799.2396097056790, 0.33333333333333331, 10.000000000000000 },\n+  { 338348.63146593655, 0.33333333333333331, 15.000000000000000 },\n+  { 43434263.927938439, 0.33333333333333331, 20.000000000000000 },\n+  { 5761474759.6213636, 0.33333333333333331, 25.000000000000000 },\n+  { 780201111830.30225, 0.33333333333333331, 30.000000000000000 },\n+  { 107166066959051.92, 0.33333333333333331, 35.000000000000000 },\n+  { 14873836574083760., 0.33333333333333331, 40.000000000000000 },\n+  { 2.0808143020217085e+18, 0.33333333333333331, 45.000000000000000 },\n+  { 2.9292639365644229e+20, 0.33333333333333331, 50.000000000000000 },\n+  { 4.1445621624120489e+22, 0.33333333333333331, 55.000000000000000 },\n+  { 5.8885758374365916e+24, 0.33333333333333331, 60.000000000000000 },\n+  { 8.3958047021083955e+26, 0.33333333333333331, 65.000000000000000 },\n+  { 1.2006287819446431e+29, 0.33333333333333331, 70.000000000000000 },\n+  { 1.7213548977150022e+31, 0.33333333333333331, 75.000000000000000 },\n+  { 2.4734492458444449e+33, 0.33333333333333331, 80.000000000000000 },\n+  { 3.5611354547857122e+35, 0.33333333333333331, 85.000000000000000 },\n+  { 5.1360491295551829e+37, 0.33333333333333331, 90.000000000000000 },\n+  { 7.4189629097600431e+39, 0.33333333333333331, 95.000000000000000 },\n+  { 1.0731523308358370e+42, 0.33333333333333331, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.33333333333333331.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data002[i].nu), Tp(data002[i].x));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for nu=0.50000000000000000.\n+testcase_cyl_bessel_i<double> data003[] = {\n+  { 0.0000000000000000, 0.50000000000000000, 0.0000000000000000 },\n+  { 26.477547497559065, 0.50000000000000000, 5.0000000000000000 },\n+  { 2778.7846038745711, 0.50000000000000000, 10.000000000000000 },\n+  { 336729.88718706399, 0.50000000000000000, 15.000000000000000 },\n+  { 43279746.272428922, 0.50000000000000000, 20.000000000000000 },\n+  { 5745159748.3464680, 0.50000000000000000, 25.000000000000000 },\n+  { 778366068840.44580, 0.50000000000000000, 30.000000000000000 },\n+  { 106950522408567.66, 0.50000000000000000, 35.000000000000000 },\n+  { 14847705549021962., 0.50000000000000000, 40.000000000000000 },\n+  { 2.0775691824625661e+18, 0.50000000000000000, 45.000000000000000 },\n+  { 2.9251568529912988e+20, 0.50000000000000000, 50.000000000000000 },\n+  { 4.1392840094781220e+22, 0.50000000000000000, 55.000000000000000 },\n+  { 5.8817065760751945e+24, 0.50000000000000000, 60.000000000000000 },\n+  { 8.3867695787277231e+26, 0.50000000000000000, 65.000000000000000 },\n+  { 1.1994296461653203e+29, 0.50000000000000000, 70.000000000000000 },\n+  { 1.7197510246063332e+31, 0.50000000000000000, 75.000000000000000 },\n+  { 2.4712895036230794e+33, 0.50000000000000000, 80.000000000000000 },\n+  { 3.5582099086757769e+35, 0.50000000000000000, 85.000000000000000 },\n+  { 5.1320654031231090e+37, 0.50000000000000000, 90.000000000000000 },\n+  { 7.4135128383495227e+39, 0.50000000000000000, 95.000000000000000 },\n+  { 1.0724035825423179e+42, 0.50000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.50000000000000000.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data003[i].nu), Tp(data003[i].x));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for nu=0.66666666666666663.\n+testcase_cyl_bessel_i<double> data004[] = {\n+  { 0.0000000000000000, 0.66666666666666663, 0.0000000000000000 },\n+  { 25.902310583215122, 0.66666666666666663, 5.0000000000000000 },\n+  { 2750.4090423459315, 0.66666666666666663, 10.000000000000000 },\n+  { 334476.98138574383, 0.66666666666666663, 15.000000000000000 },\n+  { 43064361.686912313, 0.66666666666666663, 20.000000000000000 },\n+  { 5722397441.9603882, 0.66666666666666663, 25.000000000000000 },\n+  { 775804343498.02661, 0.66666666666666663, 30.000000000000000 },\n+  { 106649495512800.89, 0.66666666666666663, 35.000000000000000 },\n+  { 14811199896983756., 0.66666666666666663, 40.000000000000000 },\n+  { 2.0730345814356961e+18, 0.66666666666666663, 45.000000000000000 },\n+  { 2.9194166755257467e+20, 0.66666666666666663, 50.000000000000000 },\n+  { 4.1319059569935366e+22, 0.66666666666666663, 55.000000000000000 },\n+  { 5.8721031476386222e+24, 0.66666666666666663, 60.000000000000000 },\n+  { 8.3741368248217830e+26, 0.66666666666666663, 65.000000000000000 },\n+  { 1.1977528777008688e+29, 0.66666666666666663, 70.000000000000000 },\n+  { 1.7175081240014333e+31, 0.66666666666666663, 75.000000000000000 },\n+  { 2.4682690458513916e+33, 0.66666666666666663, 80.000000000000000 },\n+  { 3.5541181975850724e+35, 0.66666666666666663, 85.000000000000000 },\n+  { 5.1264933963228864e+37, 0.66666666666666663, 90.000000000000000 },\n+  { 7.4058894880134064e+39, 0.66666666666666663, 95.000000000000000 },\n+  { 1.0713562154788124e+42, 0.66666666666666663, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.66666666666666663.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data004[i].nu), Tp(data004[i].x));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for nu=1.0000000000000000.\n+testcase_cyl_bessel_i<double> data005[] = {\n+  { 0.0000000000000000, 1.0000000000000000, 0.0000000000000000 },\n+  { 24.335642142450524, 1.0000000000000000, 5.0000000000000000 },\n+  { 2670.9883037012560, 1.0000000000000000, 10.000000000000000 },\n+  { 328124.92197020649, 1.0000000000000000, 15.000000000000000 },\n+  { 42454973.385127775, 1.0000000000000000, 20.000000000000000 },\n+  { 5657865129.8787022, 1.0000000000000000, 25.000000000000000 },\n+  { 768532038938.95667, 1.0000000000000000, 30.000000000000000 },\n+  { 105794126051896.17, 1.0000000000000000, 35.000000000000000 },\n+  { 14707396163259354., 1.0000000000000000, 40.000000000000000 },\n+  { 2.0601334620815775e+18, 1.0000000000000000, 45.000000000000000 },\n+  { 2.9030785901035635e+20, 1.0000000000000000, 50.000000000000000 },\n+  { 4.1108986452992812e+22, 1.0000000000000000, 55.000000000000000 },\n+  { 5.8447515883904527e+24, 1.0000000000000000, 60.000000000000000 },\n+  { 8.3381485471501302e+26, 1.0000000000000000, 65.000000000000000 },\n+  { 1.1929750788892366e+29, 1.0000000000000000, 70.000000000000000 },\n+  { 1.7111160152965384e+31, 1.0000000000000000, 75.000000000000000 },\n+  { 2.4596595795675343e+33, 1.0000000000000000, 80.000000000000000 },\n+  { 3.5424536064404024e+35, 1.0000000000000000, 85.000000000000000 },\n+  { 5.1106068152566129e+37, 1.0000000000000000, 90.000000000000000 },\n+  { 7.3841518091360157e+39, 1.0000000000000000, 95.000000000000000 },\n+  { 1.0683693903381569e+42, 1.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=1.0000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data005[i].nu), Tp(data005[i].x));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for nu=2.0000000000000000.\n+testcase_cyl_bessel_i<double> data006[] = {\n+  { 0.0000000000000000, 2.0000000000000000, 0.0000000000000000 },\n+  { 17.505614966624233, 2.0000000000000000, 5.0000000000000000 },\n+  { 2281.5189677260046, 2.0000000000000000, 10.000000000000000 },\n+  { 295899.38370188634, 2.0000000000000000, 15.000000000000000 },\n+  { 39312785.221040756, 2.0000000000000000, 20.000000000000000 },\n+  { 5321931396.0760136, 2.0000000000000000, 25.000000000000000 },\n+  { 730436828561.38013, 2.0000000000000000, 30.000000000000000 },\n+  { 101293439862977.19, 2.0000000000000000, 35.000000000000000 },\n+  { 14159404985256920., 2.0000000000000000, 40.000000000000000 },\n+  { 1.9918525879736883e+18, 2.0000000000000000, 45.000000000000000 },\n+  { 2.8164306402451938e+20, 2.0000000000000000, 50.000000000000000 },\n+  { 3.9993023372677515e+22, 2.0000000000000000, 55.000000000000000 },\n+  { 5.6992520026634433e+24, 2.0000000000000000, 60.000000000000000 },\n+  { 8.1464814287900378e+26, 2.0000000000000000, 65.000000000000000 },\n+  { 1.1675039556585663e+29, 2.0000000000000000, 70.000000000000000 },\n+  { 1.6770093176278926e+31, 2.0000000000000000, 75.000000000000000 },\n+  { 2.4136869148449879e+33, 2.0000000000000000, 80.000000000000000 },\n+  { 3.4801257808448186e+35, 2.0000000000000000, 85.000000000000000 },\n+  { 5.0256693051696307e+37, 2.0000000000000000, 90.000000000000000 },\n+  { 7.2678700343145842e+39, 2.0000000000000000, 95.000000000000000 },\n+  { 1.0523843193243042e+42, 2.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=2.0000000000000000.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data006[i].nu), Tp(data006[i].x));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for nu=5.0000000000000000.\n+testcase_cyl_bessel_i<double> data007[] = {\n+  { 0.0000000000000000, 5.0000000000000000, 0.0000000000000000 },\n+  { 2.1579745473225476, 5.0000000000000000, 5.0000000000000000 },\n+  { 777.18828640326012, 5.0000000000000000, 10.000000000000000 },\n+  { 144572.01120063406, 5.0000000000000000, 15.000000000000000 },\n+  { 23018392.213413671, 5.0000000000000000, 20.000000000000000 },\n+  { 3472466208.7419176, 5.0000000000000000, 25.000000000000000 },\n+  { 512151465476.93494, 5.0000000000000000, 30.000000000000000 },\n+  { 74756743552251.531, 5.0000000000000000, 35.000000000000000 },\n+  { 10858318337624276., 5.0000000000000000, 40.000000000000000 },\n+  { 1.5736087399245906e+18, 5.0000000000000000, 45.000000000000000 },\n+  { 2.2785483079112829e+20, 5.0000000000000000, 50.000000000000000 },\n+  { 3.2989391052963687e+22, 5.0000000000000000, 55.000000000000000 },\n+  { 4.7777652072561742e+24, 5.0000000000000000, 60.000000000000000 },\n+  { 6.9232165147172671e+26, 5.0000000000000000, 65.000000000000000 },\n+  { 1.0038643002095153e+29, 5.0000000000000000, 70.000000000000000 },\n+  { 1.4566328222327068e+31, 5.0000000000000000, 75.000000000000000 },\n+  { 2.1151488565944838e+33, 5.0000000000000000, 80.000000000000000 },\n+  { 3.0735883450768236e+35, 5.0000000000000000, 85.000000000000000 },\n+  { 4.4694790189230327e+37, 5.0000000000000000, 90.000000000000000 },\n+  { 6.5037505570430971e+39, 5.0000000000000000, 95.000000000000000 },\n+  { 9.4700938730355882e+41, 5.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=5.0000000000000000.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data007[i].nu), Tp(data007[i].x));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=10.000000000000000.\n+testcase_cyl_bessel_i<double> data008[] = {\n+  { 0.0000000000000000, 10.000000000000000, 0.0000000000000000 },\n+  { 0.0045800444191760525, 10.000000000000000, 5.0000000000000000 },\n+  { 21.891706163723381, 10.000000000000000, 10.000000000000000 },\n+  { 12267.475049806462, 10.000000000000000, 15.000000000000000 },\n+  { 3540200.2090195213, 10.000000000000000, 20.000000000000000 },\n+  { 771298871.17072666, 10.000000000000000, 25.000000000000000 },\n+  { 145831809975.96713, 10.000000000000000, 30.000000000000000 },\n+  { 25449470018534.785, 10.000000000000000, 35.000000000000000 },\n+  { 4228469210516757.5, 10.000000000000000, 40.000000000000000 },\n+  { 6.8049404557505152e+17, 10.000000000000000, 45.000000000000000 },\n+  { 1.0715971594776370e+20, 10.000000000000000, 50.000000000000000 },\n+  { 1.6618215752886714e+22, 10.000000000000000, 55.000000000000000 },\n+  { 2.5486246072566784e+24, 10.000000000000000, 60.000000000000000 },\n+  { 3.8764628702155481e+26, 10.000000000000000, 65.000000000000000 },\n+  { 5.8592538145409686e+28, 10.000000000000000, 70.000000000000000 },\n+  { 8.8135370711317444e+30, 10.000000000000000, 75.000000000000000 },\n+  { 1.3207418268325279e+33, 10.000000000000000, 80.000000000000000 },\n+  { 1.9732791360862186e+35, 10.000000000000000, 85.000000000000000 },\n+  { 2.9411893748384672e+37, 10.000000000000000, 90.000000000000000 },\n+  { 4.3754494922439990e+39, 10.000000000000000, 95.000000000000000 },\n+  { 6.4989755247201446e+41, 10.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=10.000000000000000.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data008[i].nu), Tp(data008[i].x));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=20.000000000000000.\n+testcase_cyl_bessel_i<double> data009[] = {\n+  { 0.0000000000000000, 20.000000000000000, 0.0000000000000000 },\n+  { 5.0242393579718066e-11, 20.000000000000000, 5.0000000000000000 },\n+  { 0.00012507997356449481, 20.000000000000000, 10.000000000000000 },\n+  { 1.6470152535015834, 20.000000000000000, 15.000000000000000 },\n+  { 3188.7503288536154, 20.000000000000000, 20.000000000000000 },\n+  { 2449840.5422952301, 20.000000000000000, 25.000000000000000 },\n+  { 1126985104.4483771, 20.000000000000000, 30.000000000000000 },\n+  { 379617876611.88586, 20.000000000000000, 35.000000000000000 },\n+  { 104459633129479.89, 20.000000000000000, 40.000000000000000 },\n+  { 25039579987216504., 20.000000000000000, 45.000000000000000 },\n+  { 5.4420084027529964e+18, 20.000000000000000, 50.000000000000000 },\n+  { 1.1007498584335492e+21, 20.000000000000000, 55.000000000000000 },\n+  { 2.1091734863057236e+23, 20.000000000000000, 60.000000000000000 },\n+  { 3.8763618091286899e+25, 20.000000000000000, 65.000000000000000 },\n+  { 6.8946130527930859e+27, 20.000000000000000, 70.000000000000000 },\n+  { 1.1946319948836447e+30, 20.000000000000000, 75.000000000000000 },\n+  { 2.0265314377577580e+32, 20.000000000000000, 80.000000000000000 },\n+  { 3.3784665214179971e+34, 20.000000000000000, 85.000000000000000 },\n+  { 5.5516089411796670e+36, 20.000000000000000, 90.000000000000000 },\n+  { 9.0129310795305151e+38, 20.000000000000000, 95.000000000000000 },\n+  { 1.4483461256427176e+41, 20.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=20.000000000000000.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data009[i].nu), Tp(data009[i].x));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=50.000000000000000.\n+testcase_cyl_bessel_i<double> data010[] = {\n+  { 0.0000000000000000, 50.000000000000000, 0.0000000000000000 },\n+  { 2.9314696468108517e-45, 50.000000000000000, 5.0000000000000000 },\n+  { 4.7568945607268442e-30, 50.000000000000000, 10.000000000000000 },\n+  { 5.5468372730667069e-21, 50.000000000000000, 15.000000000000000 },\n+  { 2.2551205757604056e-14, 50.000000000000000, 20.000000000000000 },\n+  { 4.5344251866130282e-09, 50.000000000000000, 25.000000000000000 },\n+  { 0.00014590106916468937, 50.000000000000000, 30.000000000000000 },\n+  { 1.3965549457254878, 50.000000000000000, 35.000000000000000 },\n+  { 5726.8656631289878, 50.000000000000000, 40.000000000000000 },\n+  { 12672593.113027776, 50.000000000000000, 45.000000000000000 },\n+  { 17650802430.016705, 50.000000000000000, 50.000000000000000 },\n+  { 17220231607789.926, 50.000000000000000, 55.000000000000000 },\n+  { 12704607933652172., 50.000000000000000, 60.000000000000000 },\n+  { 7.4989491942193766e+18, 50.000000000000000, 65.000000000000000 },\n+  { 3.6944034898904901e+21, 50.000000000000000, 70.000000000000000 },\n+  { 1.5691634774370194e+24, 50.000000000000000, 75.000000000000000 },\n+  { 5.8927749458163587e+26, 50.000000000000000, 80.000000000000000 },\n+  { 1.9958849054749339e+29, 50.000000000000000, 85.000000000000000 },\n+  { 6.1946050361781518e+31, 50.000000000000000, 90.000000000000000 },\n+  { 1.7845429728697110e+34, 50.000000000000000, 95.000000000000000 },\n+  { 4.8219580855940813e+36, 50.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=50.000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data010[i].nu), Tp(data010[i].x));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+// Test data for nu=100.00000000000000.\n+testcase_cyl_bessel_i<double> data011[] = {\n+  { 0.0000000000000000, 100.00000000000000, 0.0000000000000000 },\n+  { 7.0935514885313123e-119, 100.00000000000000, 5.0000000000000000 },\n+  { 1.0823442017492018e-88, 100.00000000000000, 10.000000000000000 },\n+  { 5.9887888536468904e-71, 100.00000000000000, 15.000000000000000 },\n+  { 2.8703193216428771e-58, 100.00000000000000, 20.000000000000000 },\n+  { 2.4426896913122370e-48, 100.00000000000000, 25.000000000000000 },\n+  { 3.9476420053334271e-40, 100.00000000000000, 30.000000000000000 },\n+  { 4.2836596180818801e-33, 100.00000000000000, 35.000000000000000 },\n+  { 6.6249380222596129e-27, 100.00000000000000, 40.000000000000000 },\n+  { 2.3702587262788881e-21, 100.00000000000000, 45.000000000000000 },\n+  { 2.7278879470966907e-16, 100.00000000000000, 50.000000000000000 },\n+  { 1.2763258878228088e-11, 100.00000000000000, 55.000000000000000 },\n+  { 2.8832770906491951e-07, 100.00000000000000, 60.000000000000000 },\n+  { 0.0035805902717061240, 100.00000000000000, 65.000000000000000 },\n+  { 27.017219102595398, 100.00000000000000, 70.000000000000000 },\n+  { 134001.44891209516, 100.00000000000000, 75.000000000000000 },\n+  { 465194832.85061038, 100.00000000000000, 80.000000000000000 },\n+  { 1189280653119.4819, 100.00000000000000, 85.000000000000000 },\n+  { 2334119331258731.0, 100.00000000000000, 90.000000000000000 },\n+  { 3.6399223078502380e+18, 100.00000000000000, 95.000000000000000 },\n+  { 4.6415349416161989e+21, 100.00000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=100.00000000000000.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_cyl_bessel_i<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_i(Tp(data011[i].nu), Tp(data011[i].x));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  return 0;\n+}"}, {"sha": "31d77980cd0c45a3f5fcf24bfc8a7616a8aa3247", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/08_cyl_bessel_i/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.8 cyl_bessel_i\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  std::tr1::cyl_bessel_i(nuf, xf);\n+  std::tr1::cyl_bessel_if(nuf, xf);\n+  std::tr1::cyl_bessel_i(nud, xd);\n+  std::tr1::cyl_bessel_i(nul, xl);\n+  std::tr1::cyl_bessel_il(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "374d7ac41fb683f025471cb4c9ffca885bbdd82c", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/08_cyl_bessel_i/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F08_cyl_bessel_i%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.8 cyl_bessel_i\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  cyl_bessel_i(nuf, xf);\n+  cyl_bessel_if(nuf, xf);\n+  cyl_bessel_i(nud, xd);\n+  cyl_bessel_i(nul, xl);\n+  cyl_bessel_il(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "606697a00b432a7f5d86b16bf6d0ba36bac9056d", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/09_cyl_bessel_j/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.9 cyl_bessel_j\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.0F;\n+  double nud = 0.0;\n+  long double nul = 0.0L;\n+\n+  float a = std::tr1::cyl_bessel_j(nuf, xf);\n+  float b = std::tr1::cyl_bessel_jf(nuf, xf);\n+  double c = std::tr1::cyl_bessel_j(nud, xd);\n+  long double d = std::tr1::cyl_bessel_j(nul, xl);\n+  long double e = std::tr1::cyl_bessel_jl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float xf = 1.0F;\n+  double xd = 1.0;\n+  long double xl = 1.0L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::cyl_bessel_j(nuf, xf);\n+  float b = std::tr1::cyl_bessel_jf(nuf, xf);\n+  double c = std::tr1::cyl_bessel_j(nud, xd);\n+  long double d = std::tr1::cyl_bessel_j(nul, xl);\n+  long double e = std::tr1::cyl_bessel_jl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "5fa6e0cb4d0798783d7705cd737d943798a68ea1", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/09_cyl_bessel_j/check_value.cc", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,629 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  cyl_bessel_j\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for nu=0.0000000000000000.\n+testcase_cyl_bessel_j<double> data001[] = {\n+  { 1.0000000000000000, 0.0000000000000000, 0.0000000000000000 },\n+  { -0.17759677131433835, 0.0000000000000000, 5.0000000000000000 },\n+  { -0.24593576445134832, 0.0000000000000000, 10.000000000000000 },\n+  { -0.014224472826780788, 0.0000000000000000, 15.000000000000000 },\n+  { 0.16702466434058319, 0.0000000000000000, 20.000000000000000 },\n+  { 0.096266783275958140, 0.0000000000000000, 25.000000000000000 },\n+  { -0.086367983581040184, 0.0000000000000000, 30.000000000000000 },\n+  { -0.12684568275631256, 0.0000000000000000, 35.000000000000000 },\n+  { 0.0073668905842372914, 0.0000000000000000, 40.000000000000000 },\n+  { 0.11581867067325630, 0.0000000000000000, 45.000000000000000 },\n+  { 0.055812327669251746, 0.0000000000000000, 50.000000000000000 },\n+  { -0.074548302648236808, 0.0000000000000000, 55.000000000000000 },\n+  { -0.091471804089061873, 0.0000000000000000, 60.000000000000000 },\n+  { 0.018687343227677920, 0.0000000000000000, 65.000000000000000 },\n+  { 0.094908726483013517, 0.0000000000000000, 70.000000000000000 },\n+  { 0.034643913805097029, 0.0000000000000000, 75.000000000000000 },\n+  { -0.069742165512210061, 0.0000000000000000, 80.000000000000000 },\n+  { -0.070940394796273301, 0.0000000000000000, 85.000000000000000 },\n+  { 0.026630016699969568, 0.0000000000000000, 90.000000000000000 },\n+  { 0.081811967783384149, 0.0000000000000000, 95.000000000000000 },\n+  { 0.019985850304223264, 0.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.0000000000000000.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data001[i].nu), Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=0.33333333333333331.\n+testcase_cyl_bessel_j<double> data002[] = {\n+  { 0.0000000000000000, 0.33333333333333331, 0.0000000000000000 },\n+  { -0.30642046380026405, 0.33333333333333331, 5.0000000000000000 },\n+  { -0.18614516704869569, 0.33333333333333331, 10.000000000000000 },\n+  { 0.089740004221152581, 0.33333333333333331, 15.000000000000000 },\n+  { 0.17606058001293898, 0.33333333333333331, 20.000000000000000 },\n+  { 0.020097162141383202, 0.33333333333333331, 25.000000000000000 },\n+  { -0.13334053387426156, 0.33333333333333331, 30.000000000000000 },\n+  { -0.087118009397765442, 0.33333333333333331, 35.000000000000000 },\n+  { 0.069202942818858165, 0.33333333333333331, 40.000000000000000 },\n+  { 0.11387616964518317, 0.33333333333333331, 45.000000000000000 },\n+  { -0.00057226680771807741, 0.33333333333333331, 50.000000000000000 },\n+  { -0.10331600929280821, 0.33333333333333331, 55.000000000000000 },\n+  { -0.055618147270528023, 0.33333333333333331, 60.000000000000000 },\n+  { 0.064711954014113920, 0.33333333333333331, 65.000000000000000 },\n+  { 0.086879926462481619, 0.33333333333333331, 70.000000000000000 },\n+  { -0.012614484229891070, 0.33333333333333331, 75.000000000000000 },\n+  { -0.088199784400034537, 0.33333333333333331, 80.000000000000000 },\n+  { -0.036703611076564557, 0.33333333333333331, 85.000000000000000 },\n+  { 0.062916286828779533, 0.33333333333333331, 90.000000000000000 },\n+  { 0.069465244416806071, 0.33333333333333331, 95.000000000000000 },\n+  { -0.021271244853702295, 0.33333333333333331, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.33333333333333331.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data002[i].nu), Tp(data002[i].x));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));\n+}\n+\n+// Test data for nu=0.50000000000000000.\n+testcase_cyl_bessel_j<double> data003[] = {\n+  { 0.0000000000000000, 0.50000000000000000, 0.0000000000000000 },\n+  { -0.34216798479816180, 0.50000000000000000, 5.0000000000000000 },\n+  { -0.13726373575505049, 0.50000000000000000, 10.000000000000000 },\n+  { 0.13396768882243942, 0.50000000000000000, 15.000000000000000 },\n+  { 0.16288076385502981, 0.50000000000000000, 20.000000000000000 },\n+  { -0.021120283599650416, 0.50000000000000000, 25.000000000000000 },\n+  { -0.14392965337039987, 0.50000000000000000, 30.000000000000000 },\n+  { -0.057747757589458860, 0.50000000000000000, 35.000000000000000 },\n+  { 0.094000962389533579, 0.50000000000000000, 40.000000000000000 },\n+  { 0.10120783324271412, 0.50000000000000000, 45.000000000000000 },\n+  { -0.029605831888924662, 0.50000000000000000, 50.000000000000000 },\n+  { -0.10756039213265806, 0.50000000000000000, 55.000000000000000 },\n+  { -0.031397461182520445, 0.50000000000000000, 60.000000000000000 },\n+  { 0.081827430775628568, 0.50000000000000000, 65.000000000000000 },\n+  { 0.073802429539054637, 0.50000000000000000, 70.000000000000000 },\n+  { -0.035727009681702594, 0.50000000000000000, 75.000000000000000 },\n+  { -0.088661035811765446, 0.50000000000000000, 80.000000000000000 },\n+  { -0.015238065106312407, 0.50000000000000000, 85.000000000000000 },\n+  { 0.075189068550269425, 0.50000000000000000, 90.000000000000000 },\n+  { 0.055932643481494140, 0.50000000000000000, 95.000000000000000 },\n+  { -0.040402132716252113, 0.50000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.50000000000000000.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data003[i].nu), Tp(data003[i].x));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=0.66666666666666663.\n+testcase_cyl_bessel_j<double> data004[] = {\n+  { 0.0000000000000000, 0.66666666666666663, 0.0000000000000000 },\n+  { -0.35712533549168879, 0.66666666666666663, 5.0000000000000000 },\n+  { -0.080149603304315822, 0.66666666666666663, 10.000000000000000 },\n+  { 0.16918875175798076, 0.66666666666666663, 15.000000000000000 },\n+  { 0.13904826122116526, 0.66666666666666663, 20.000000000000000 },\n+  { -0.060770629698497579, 0.66666666666666663, 25.000000000000000 },\n+  { -0.14489851974205059, 0.66666666666666663, 30.000000000000000 },\n+  { -0.024604880159644467, 0.66666666666666663, 35.000000000000000 },\n+  { 0.11243936464912015, 0.66666666666666663, 40.000000000000000 },\n+  { 0.081776275512525379, 0.66666666666666663, 45.000000000000000 },\n+  { -0.056589908749367770, 0.66666666666666663, 50.000000000000000 },\n+  { -0.10455814523765933, 0.66666666666666663, 55.000000000000000 },\n+  { -0.0051030148548608109, 0.66666666666666663, 60.000000000000000 },\n+  { 0.093398227061639250, 0.66666666666666663, 65.000000000000000 },\n+  { 0.055763883611864899, 0.66666666666666663, 70.000000000000000 },\n+  { -0.056395322915757343, 0.66666666666666663, 75.000000000000000 },\n+  { -0.083131347805783087, 0.66666666666666663, 80.000000000000000 },\n+  { 0.0072315397874096309, 0.66666666666666663, 85.000000000000000 },\n+  { 0.082362798520905264, 0.66666666666666663, 90.000000000000000 },\n+  { 0.038630504403446168, 0.66666666666666663, 95.000000000000000 },\n+  { -0.056778819380529706, 0.66666666666666663, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.66666666666666663.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data004[i].nu), Tp(data004[i].x));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=1.0000000000000000.\n+testcase_cyl_bessel_j<double> data005[] = {\n+  { 0.0000000000000000, 1.0000000000000000, 0.0000000000000000 },\n+  { -0.32757913759146523, 1.0000000000000000, 5.0000000000000000 },\n+  { 0.043472746168861369, 1.0000000000000000, 10.000000000000000 },\n+  { 0.20510403861352278, 1.0000000000000000, 15.000000000000000 },\n+  { 0.066833124175850092, 1.0000000000000000, 20.000000000000000 },\n+  { -0.12535024958028987, 1.0000000000000000, 25.000000000000000 },\n+  { -0.11875106261662292, 1.0000000000000000, 30.000000000000000 },\n+  { 0.043990942179625556, 1.0000000000000000, 35.000000000000000 },\n+  { 0.12603831803758497, 1.0000000000000000, 40.000000000000000 },\n+  { 0.028348854376424548, 1.0000000000000000, 45.000000000000000 },\n+  { -0.097511828125175157, 1.0000000000000000, 50.000000000000000 },\n+  { -0.078250038308684655, 1.0000000000000000, 55.000000000000000 },\n+  { 0.046598383758166398, 1.0000000000000000, 60.000000000000000 },\n+  { 0.097330172226126929, 1.0000000000000000, 65.000000000000000 },\n+  { 0.0099877887848384625, 1.0000000000000000, 70.000000000000000 },\n+  { -0.085139995044829109, 1.0000000000000000, 75.000000000000000 },\n+  { -0.056057296675712610, 1.0000000000000000, 80.000000000000000 },\n+  { 0.049151460334891116, 1.0000000000000000, 85.000000000000000 },\n+  { 0.079925646708868064, 1.0000000000000000, 90.000000000000000 },\n+  { -0.0023925612997268684, 1.0000000000000000, 95.000000000000000 },\n+  { -0.077145352014112142, 1.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=1.0000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data005[i].nu), Tp(data005[i].x));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=2.0000000000000000.\n+testcase_cyl_bessel_j<double> data006[] = {\n+  { 0.0000000000000000, 2.0000000000000000, 0.0000000000000000 },\n+  { 0.046565116277751971, 2.0000000000000000, 5.0000000000000000 },\n+  { 0.25463031368512062, 2.0000000000000000, 10.000000000000000 },\n+  { 0.041571677975250479, 2.0000000000000000, 15.000000000000000 },\n+  { -0.16034135192299817, 2.0000000000000000, 20.000000000000000 },\n+  { -0.10629480324238134, 2.0000000000000000, 25.000000000000000 },\n+  { 0.078451246073265340, 2.0000000000000000, 30.000000000000000 },\n+  { 0.12935945088086262, 2.0000000000000000, 35.000000000000000 },\n+  { -0.0010649746823580893, 2.0000000000000000, 40.000000000000000 },\n+  { -0.11455872158985966, 2.0000000000000000, 45.000000000000000 },\n+  { -0.059712800794258801, 2.0000000000000000, 50.000000000000000 },\n+  { 0.071702846709739212, 2.0000000000000000, 55.000000000000000 },\n+  { 0.093025083547667448, 2.0000000000000000, 60.000000000000000 },\n+  { -0.015692568697643280, 2.0000000000000000, 65.000000000000000 },\n+  { -0.094623361089160987, 2.0000000000000000, 70.000000000000000 },\n+  { -0.036914313672959186, 2.0000000000000000, 75.000000000000000 },\n+  { 0.068340733095317227, 2.0000000000000000, 80.000000000000000 },\n+  { 0.072096899745329499, 2.0000000000000000, 85.000000000000000 },\n+  { -0.024853891217550262, 2.0000000000000000, 90.000000000000000 },\n+  { -0.081862337494957346, 2.0000000000000000, 95.000000000000000 },\n+  { -0.021528757344505392, 2.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=2.0000000000000000.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data006[i].nu), Tp(data006[i].x));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=5.0000000000000000.\n+testcase_cyl_bessel_j<double> data007[] = {\n+  { 0.0000000000000000, 5.0000000000000000, 0.0000000000000000 },\n+  { 0.26114054612017007, 5.0000000000000000, 5.0000000000000000 },\n+  { -0.23406152818679365, 5.0000000000000000, 10.000000000000000 },\n+  { 0.13045613456502966, 5.0000000000000000, 15.000000000000000 },\n+  { 0.15116976798239504, 5.0000000000000000, 20.000000000000000 },\n+  { -0.066007995398423044, 5.0000000000000000, 25.000000000000000 },\n+  { -0.14324029551207709, 5.0000000000000000, 30.000000000000000 },\n+  { -0.0015053072953907080, 5.0000000000000000, 35.000000000000000 },\n+  { 0.12257346597711774, 5.0000000000000000, 40.000000000000000 },\n+  { 0.057984499200954144, 5.0000000000000000, 45.000000000000000 },\n+  { -0.081400247696569658, 5.0000000000000000, 50.000000000000000 },\n+  { -0.092569895786432710, 5.0000000000000000, 55.000000000000000 },\n+  { 0.027454744228344184, 5.0000000000000000, 60.000000000000000 },\n+  { 0.099110527701539039, 5.0000000000000000, 65.000000000000000 },\n+  { 0.026058129823895274, 5.0000000000000000, 70.000000000000000 },\n+  { -0.078523977013751398, 5.0000000000000000, 75.000000000000000 },\n+  { -0.065862349140031654, 5.0000000000000000, 80.000000000000000 },\n+  { 0.038669072284680923, 5.0000000000000000, 85.000000000000000 },\n+  { 0.082759319528415129, 5.0000000000000000, 90.000000000000000 },\n+  { 0.0079423372702472905, 5.0000000000000000, 95.000000000000000 },\n+  { -0.074195736964513911, 5.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=5.0000000000000000.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data007[i].nu), Tp(data007[i].x));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000028e-11));\n+}\n+\n+// Test data for nu=10.000000000000000.\n+testcase_cyl_bessel_j<double> data008[] = {\n+  { 0.0000000000000000, 10.000000000000000, 0.0000000000000000 },\n+  { 0.0014678026473104744, 10.000000000000000, 5.0000000000000000 },\n+  { 0.20748610663335865, 10.000000000000000, 10.000000000000000 },\n+  { -0.090071811047659045, 10.000000000000000, 15.000000000000000 },\n+  { 0.18648255802394512, 10.000000000000000, 20.000000000000000 },\n+  { -0.075179843948523270, 10.000000000000000, 25.000000000000000 },\n+  { -0.12987689399858882, 10.000000000000000, 30.000000000000000 },\n+  { 0.063546391343962852, 10.000000000000000, 35.000000000000000 },\n+  { 0.11938336278226093, 10.000000000000000, 40.000000000000000 },\n+  { -0.026971402475010734, 10.000000000000000, 45.000000000000000 },\n+  { -0.11384784914946940, 10.000000000000000, 50.000000000000000 },\n+  { -0.015773790303746010, 10.000000000000000, 55.000000000000000 },\n+  { 0.097177143328071106, 10.000000000000000, 60.000000000000000 },\n+  { 0.054617389951112157, 10.000000000000000, 65.000000000000000 },\n+  { -0.065870338561951874, 10.000000000000000, 70.000000000000000 },\n+  { -0.080417867891894437, 10.000000000000000, 75.000000000000000 },\n+  { 0.024043850978184754, 10.000000000000000, 80.000000000000000 },\n+  { 0.086824832700067869, 10.000000000000000, 85.000000000000000 },\n+  { 0.019554748856312278, 10.000000000000000, 90.000000000000000 },\n+  { -0.072341598669443757, 10.000000000000000, 95.000000000000000 },\n+  { -0.054732176935472103, 10.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=10.000000000000000.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data008[i].nu), Tp(data008[i].x));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=20.000000000000000.\n+testcase_cyl_bessel_j<double> data009[] = {\n+  { 0.0000000000000000, 20.000000000000000, 0.0000000000000000 },\n+  { 2.7703300521289426e-11, 20.000000000000000, 5.0000000000000000 },\n+  { 1.1513369247813403e-05, 20.000000000000000, 10.000000000000000 },\n+  { 0.0073602340792234882, 20.000000000000000, 15.000000000000000 },\n+  { 0.16474777377532657, 20.000000000000000, 20.000000000000000 },\n+  { 0.051994049228303287, 20.000000000000000, 25.000000000000000 },\n+  { 0.0048310199934041105, 20.000000000000000, 30.000000000000000 },\n+  { -0.10927417397178038, 20.000000000000000, 35.000000000000000 },\n+  { 0.12779393355084886, 20.000000000000000, 40.000000000000000 },\n+  { 0.0047633437900312841, 20.000000000000000, 45.000000000000000 },\n+  { -0.11670435275957974, 20.000000000000000, 50.000000000000000 },\n+  { 0.025389204574566695, 20.000000000000000, 55.000000000000000 },\n+  { 0.10266020557876331, 20.000000000000000, 60.000000000000000 },\n+  { -0.023138582263434168, 20.000000000000000, 65.000000000000000 },\n+  { -0.096058573489952323, 20.000000000000000, 70.000000000000000 },\n+  { 0.0068961047221522270, 20.000000000000000, 75.000000000000000 },\n+  { 0.090565405489918357, 20.000000000000000, 80.000000000000000 },\n+  { 0.015985497599497155, 20.000000000000000, 85.000000000000000 },\n+  { -0.080345344044422506, 20.000000000000000, 90.000000000000000 },\n+  { -0.040253075701614051, 20.000000000000000, 95.000000000000000 },\n+  { 0.062217458498338679, 20.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=20.000000000000000.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data009[i].nu), Tp(data009[i].x));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=50.000000000000000.\n+testcase_cyl_bessel_j<double> data010[] = {\n+  { 0.0000000000000000, 50.000000000000000, 0.0000000000000000 },\n+  { 2.2942476159525415e-45, 50.000000000000000, 5.0000000000000000 },\n+  { 1.7845136078715964e-30, 50.000000000000000, 10.000000000000000 },\n+  { 6.1060519495338733e-22, 50.000000000000000, 15.000000000000000 },\n+  { 4.4510392847006872e-16, 50.000000000000000, 20.000000000000000 },\n+  { 9.7561594280229727e-12, 50.000000000000000, 25.000000000000000 },\n+  { 2.0581656631564181e-08, 50.000000000000000, 30.000000000000000 },\n+  { 7.6069951699272926e-06, 50.000000000000000, 35.000000000000000 },\n+  { 0.00068185243531768255, 50.000000000000000, 40.000000000000000 },\n+  { 0.017284343240791228, 50.000000000000000, 45.000000000000000 },\n+  { 0.12140902189761522, 50.000000000000000, 50.000000000000000 },\n+  { 0.13594720957176004, 50.000000000000000, 55.000000000000000 },\n+  { -0.13798273148535209, 50.000000000000000, 60.000000000000000 },\n+  { 0.12116217746619408, 50.000000000000000, 65.000000000000000 },\n+  { -0.11394866738787141, 50.000000000000000, 70.000000000000000 },\n+  { 0.094076799581573417, 50.000000000000000, 75.000000000000000 },\n+  { -0.039457764590251236, 50.000000000000000, 80.000000000000000 },\n+  { -0.040412060734136369, 50.000000000000000, 85.000000000000000 },\n+  { 0.090802099838032252, 50.000000000000000, 90.000000000000000 },\n+  { -0.055979156267280269, 50.000000000000000, 95.000000000000000 },\n+  { -0.038698339728525460, 50.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=50.000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data010[i].nu), Tp(data010[i].x));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-11));\n+}\n+\n+// Test data for nu=100.00000000000000.\n+testcase_cyl_bessel_j<double> data011[] = {\n+  { 0.0000000000000000, 100.00000000000000, 0.0000000000000000 },\n+  { 6.2677893955418763e-119, 100.00000000000000, 5.0000000000000000 },\n+  { 6.5973160641553816e-89, 100.00000000000000, 10.000000000000000 },\n+  { 1.9660095611249536e-71, 100.00000000000000, 15.000000000000000 },\n+  { 3.9617550943362524e-59, 100.00000000000000, 20.000000000000000 },\n+  { 1.1064482655301687e-49, 100.00000000000000, 25.000000000000000 },\n+  { 4.5788015281752354e-42, 100.00000000000000, 30.000000000000000 },\n+  { 9.9210206714732606e-36, 100.00000000000000, 35.000000000000000 },\n+  { 2.3866062996027414e-30, 100.00000000000000, 40.000000000000000 },\n+  { 1.0329791804565538e-25, 100.00000000000000, 45.000000000000000 },\n+  { 1.1159273690838340e-21, 100.00000000000000, 50.000000000000000 },\n+  { 3.7899753451900682e-18, 100.00000000000000, 55.000000000000000 },\n+  { 4.7832744078781205e-15, 100.00000000000000, 60.000000000000000 },\n+  { 2.5375564579490517e-12, 100.00000000000000, 65.000000000000000 },\n+  { 6.1982452141641260e-10, 100.00000000000000, 70.000000000000000 },\n+  { 7.4479005905904457e-08, 100.00000000000000, 75.000000000000000 },\n+  { 4.6065530648234948e-06, 100.00000000000000, 80.000000000000000 },\n+  { 0.00015043869999501605, 100.00000000000000, 85.000000000000000 },\n+  { 0.0026021305819963472, 100.00000000000000, 90.000000000000000 },\n+  { 0.023150768009428162, 100.00000000000000, 95.000000000000000 },\n+  { 0.096366673295861571, 100.00000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=100.00000000000000.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_cyl_bessel_j<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_j(Tp(data011[i].nu), Tp(data011[i].x));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-11));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  return 0;\n+}"}, {"sha": "c4054ebbe5414d6d3a0e6a6af146f6434818cb51", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/09_cyl_bessel_j/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.9 cyl_bessel_j\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  std::tr1::cyl_bessel_j(nuf, xf);\n+  std::tr1::cyl_bessel_jf(nuf, xf);\n+  std::tr1::cyl_bessel_j(nud, xd);\n+  std::tr1::cyl_bessel_j(nul, xl);\n+  std::tr1::cyl_bessel_jl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "21589cf022508e10f38dcf67ff5a92f8d86c4fc1", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/09_cyl_bessel_j/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F09_cyl_bessel_j%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.9 cyl_bessel_j\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  cyl_bessel_j(nuf, xf);\n+  cyl_bessel_jf(nuf, xf);\n+  cyl_bessel_j(nud, xd);\n+  cyl_bessel_j(nul, xl);\n+  cyl_bessel_jl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "72754a7dacdb441c1b8cc6e19309fe71fe102755", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/10_cyl_bessel_k/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.10 cyl_bessel_k\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.0F;\n+  double nud = 0.0;\n+  long double nul = 0.0L;\n+\n+  float a = std::tr1::cyl_bessel_k(nuf, xf);\n+  float b = std::tr1::cyl_bessel_kf(nuf, xf);\n+  double c = std::tr1::cyl_bessel_k(nud, xd);\n+  long double d = std::tr1::cyl_bessel_k(nul, xl);\n+  long double e = std::tr1::cyl_bessel_kl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float xf = 1.0F;\n+  double xd = 1.0;\n+  long double xl = 1.0L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::cyl_bessel_k(nuf, xf);\n+  float b = std::tr1::cyl_bessel_kf(nuf, xf);\n+  double c = std::tr1::cyl_bessel_k(nud, xd);\n+  long double d = std::tr1::cyl_bessel_k(nul, xl);\n+  long double e = std::tr1::cyl_bessel_kl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "19405d0be4d37f73b0962747b7c828954e13ece6", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/10_cyl_bessel_k/check_value.cc", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,618 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  cyl_bessel_k\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for nu=0.0000000000000000.\n+testcase_cyl_bessel_k<double> data001[] = {\n+  { 0.0036910983340425947, 0.0000000000000000, 5.0000000000000000 },\n+  { 1.7780062316167650e-05, 0.0000000000000000, 10.000000000000000 },\n+  { 9.8195364823964333e-08, 0.0000000000000000, 15.000000000000000 },\n+  { 5.7412378153365238e-10, 0.0000000000000000, 20.000000000000000 },\n+  { 3.4641615622131151e-12, 0.0000000000000000, 25.000000000000000 },\n+  { 2.1324774964630566e-14, 0.0000000000000000, 30.000000000000000 },\n+  { 1.3310351491429464e-16, 0.0000000000000000, 35.000000000000000 },\n+  { 8.3928611000995700e-19, 0.0000000000000000, 40.000000000000000 },\n+  { 5.3334561226187255e-21, 0.0000000000000000, 45.000000000000000 },\n+  { 3.4101677497894956e-23, 0.0000000000000000, 50.000000000000000 },\n+  { 2.1913102183534147e-25, 0.0000000000000000, 55.000000000000000 },\n+  { 1.4138978405591074e-27, 0.0000000000000000, 60.000000000000000 },\n+  { 9.1544673210030045e-30, 0.0000000000000000, 65.000000000000000 },\n+  { 5.9446613372925013e-32, 0.0000000000000000, 70.000000000000000 },\n+  { 3.8701170455869113e-34, 0.0000000000000000, 75.000000000000000 },\n+  { 2.5251198425054723e-36, 0.0000000000000000, 80.000000000000000 },\n+  { 1.6507623579783908e-38, 0.0000000000000000, 85.000000000000000 },\n+  { 1.0810242556984256e-40, 0.0000000000000000, 90.000000000000000 },\n+  { 7.0901249699001278e-43, 0.0000000000000000, 95.000000000000000 },\n+  { 4.6566282291759032e-45, 0.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.0000000000000000.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data001[i].nu), Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=0.33333333333333331.\n+testcase_cyl_bessel_k<double> data002[] = {\n+  { 0.0037288750960535887, 0.33333333333333331, 5.0000000000000000 },\n+  { 1.7874608271055339e-05, 0.33333333333333331, 10.000000000000000 },\n+  { 9.8548341568798317e-08, 0.33333333333333331, 15.000000000000000 },\n+  { 5.7568278247790865e-10, 0.33333333333333331, 20.000000000000000 },\n+  { 3.4717201424907059e-12, 0.33333333333333331, 25.000000000000000 },\n+  { 2.1363664736611189e-14, 0.33333333333333331, 30.000000000000000 },\n+  { 1.3331202314165813e-16, 0.33333333333333331, 35.000000000000000 },\n+  { 8.4043837769480934e-19, 0.33333333333333331, 40.000000000000000 },\n+  { 5.3399731261024948e-21, 0.33333333333333331, 45.000000000000000 },\n+  { 3.4139217813583632e-23, 0.33333333333333331, 50.000000000000000 },\n+  { 2.1935050179185627e-25, 0.33333333333333331, 55.000000000000000 },\n+  { 1.4151968805623662e-27, 0.33333333333333331, 60.000000000000000 },\n+  { 9.1622357217019043e-30, 0.33333333333333331, 65.000000000000000 },\n+  { 5.9493479703461315e-32, 0.33333333333333331, 70.000000000000000 },\n+  { 3.8729660011055947e-34, 0.33333333333333331, 75.000000000000000 },\n+  { 2.5268631828013877e-36, 0.33333333333333331, 80.000000000000000 },\n+  { 1.6518353676138867e-38, 0.33333333333333331, 85.000000000000000 },\n+  { 1.0816880942511496e-40, 0.33333333333333331, 90.000000000000000 },\n+  { 7.0942508599231512e-43, 0.33333333333333331, 95.000000000000000 },\n+  { 4.6592031570213454e-45, 0.33333333333333331, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.33333333333333331.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data002[i].nu), Tp(data002[i].x));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=0.50000000000000000.\n+testcase_cyl_bessel_k<double> data003[] = {\n+  { 0.0037766133746428825, 0.50000000000000000, 5.0000000000000000 },\n+  { 1.7993478093705181e-05, 0.50000000000000000, 10.000000000000000 },\n+  { 9.8991312032877236e-08, 0.50000000000000000, 15.000000000000000 },\n+  { 5.7763739747074450e-10, 0.50000000000000000, 20.000000000000000 },\n+  { 3.4811912768406949e-12, 0.50000000000000000, 25.000000000000000 },\n+  { 2.1412375659560111e-14, 0.50000000000000000, 30.000000000000000 },\n+  { 1.3357311366035824e-16, 0.50000000000000000, 35.000000000000000 },\n+  { 8.4188091949489049e-19, 0.50000000000000000, 40.000000000000000 },\n+  { 5.3481305002517408e-21, 0.50000000000000000, 45.000000000000000 },\n+  { 3.4186200954570754e-23, 0.50000000000000000, 50.000000000000000 },\n+  { 2.1962515908772453e-25, 0.50000000000000000, 55.000000000000000 },\n+  { 1.4168223500353693e-27, 0.50000000000000000, 60.000000000000000 },\n+  { 9.1719554473256892e-30, 0.50000000000000000, 65.000000000000000 },\n+  { 5.9552114337788932e-32, 0.50000000000000000, 70.000000000000000 },\n+  { 3.8765301321409432e-34, 0.50000000000000000, 75.000000000000000 },\n+  { 2.5290440439442910e-36, 0.50000000000000000, 80.000000000000000 },\n+  { 1.6531776067605980e-38, 0.50000000000000000, 85.000000000000000 },\n+  { 1.0825184636529955e-40, 0.50000000000000000, 90.000000000000000 },\n+  { 7.0994115873258822e-43, 0.50000000000000000, 95.000000000000000 },\n+  { 4.6624238126346715e-45, 0.50000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.50000000000000000.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data003[i].nu), Tp(data003[i].x));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=0.66666666666666663.\n+testcase_cyl_bessel_k<double> data004[] = {\n+  { 0.0038444246344968226, 0.66666666666666663, 5.0000000000000000 },\n+  { 1.8161187569530204e-05, 0.66666666666666663, 10.000000000000000 },\n+  { 9.9614751542305571e-08, 0.66666666666666663, 15.000000000000000 },\n+  { 5.8038484271925811e-10, 0.66666666666666663, 20.000000000000000 },\n+  { 3.4944937498488603e-12, 0.66666666666666663, 25.000000000000000 },\n+  { 2.1480755645577720e-14, 0.66666666666666663, 30.000000000000000 },\n+  { 1.3393949190152161e-16, 0.66666666666666663, 35.000000000000000 },\n+  { 8.4390460553642992e-19, 0.66666666666666663, 40.000000000000000 },\n+  { 5.3595716143622089e-21, 0.66666666666666663, 45.000000000000000 },\n+  { 3.4252085301433749e-23, 0.66666666666666663, 50.000000000000000 },\n+  { 2.2001025377982308e-25, 0.66666666666666663, 55.000000000000000 },\n+  { 1.4191011274172078e-27, 0.66666666666666663, 60.000000000000000 },\n+  { 9.1855803020269763e-30, 0.66666666666666663, 65.000000000000000 },\n+  { 5.9634299472578764e-32, 0.66666666666666663, 70.000000000000000 },\n+  { 3.8815254026478500e-34, 0.66666666666666663, 75.000000000000000 },\n+  { 2.5321003991943851e-36, 0.66666666666666663, 80.000000000000000 },\n+  { 1.6550585670593067e-38, 0.66666666666666663, 85.000000000000000 },\n+  { 1.0836820479428609e-40, 0.66666666666666663, 90.000000000000000 },\n+  { 7.1066428916285356e-43, 0.66666666666666663, 95.000000000000000 },\n+  { 4.6669364587280465e-45, 0.66666666666666663, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.66666666666666663.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data004[i].nu), Tp(data004[i].x));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=1.0000000000000000.\n+testcase_cyl_bessel_k<double> data005[] = {\n+  { 0.0040446134454521655, 1.0000000000000000, 5.0000000000000000 },\n+  { 1.8648773453825582e-05, 1.0000000000000000, 10.000000000000000 },\n+  { 1.0141729369762091e-07, 1.0000000000000000, 15.000000000000000 },\n+  { 5.8830579695570384e-10, 1.0000000000000000, 20.000000000000000 },\n+  { 3.5327780731999345e-12, 1.0000000000000000, 25.000000000000000 },\n+  { 2.1677320018915498e-14, 1.0000000000000000, 30.000000000000000 },\n+  { 1.3499178340011053e-16, 1.0000000000000000, 35.000000000000000 },\n+  { 8.4971319548610435e-19, 1.0000000000000000, 40.000000000000000 },\n+  { 5.3923945937225050e-21, 1.0000000000000000, 45.000000000000000 },\n+  { 3.4441022267175555e-23, 1.0000000000000000, 50.000000000000000 },\n+  { 2.2111422716117463e-25, 1.0000000000000000, 55.000000000000000 },\n+  { 1.4256320265171041e-27, 1.0000000000000000, 60.000000000000000 },\n+  { 9.2246195278906156e-30, 1.0000000000000000, 65.000000000000000 },\n+  { 5.9869736739138550e-32, 1.0000000000000000, 70.000000000000000 },\n+  { 3.8958329467421912e-34, 1.0000000000000000, 75.000000000000000 },\n+  { 2.5408531275211708e-36, 1.0000000000000000, 80.000000000000000 },\n+  { 1.6604444948567571e-38, 1.0000000000000000, 85.000000000000000 },\n+  { 1.0870134457498335e-40, 1.0000000000000000, 90.000000000000000 },\n+  { 7.1273442329907240e-43, 1.0000000000000000, 95.000000000000000 },\n+  { 4.6798537356369101e-45, 1.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=1.0000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data005[i].nu), Tp(data005[i].x));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=2.0000000000000000.\n+testcase_cyl_bessel_k<double> data006[] = {\n+  { 0.0053089437122234608, 2.0000000000000000, 5.0000000000000000 },\n+  { 2.1509817006932767e-05, 2.0000000000000000, 10.000000000000000 },\n+  { 1.1171767065031378e-07, 2.0000000000000000, 15.000000000000000 },\n+  { 6.3295436122922281e-10, 2.0000000000000000, 20.000000000000000 },\n+  { 3.7467838080691102e-12, 2.0000000000000000, 25.000000000000000 },\n+  { 2.2769929632558265e-14, 2.0000000000000000, 30.000000000000000 },\n+  { 1.4081733110858665e-16, 2.0000000000000000, 35.000000000000000 },\n+  { 8.8177176978426223e-19, 2.0000000000000000, 40.000000000000000 },\n+  { 5.5731181045619477e-21, 2.0000000000000000, 45.000000000000000 },\n+  { 3.5479318388581979e-23, 2.0000000000000000, 50.000000000000000 },\n+  { 2.2717153918665688e-25, 2.0000000000000000, 55.000000000000000 },\n+  { 1.4614189081096777e-27, 2.0000000000000000, 60.000000000000000 },\n+  { 9.4383017680150234e-30, 2.0000000000000000, 65.000000000000000 },\n+  { 6.1157177279757537e-32, 2.0000000000000000, 70.000000000000000 },\n+  { 3.9740059241667034e-34, 2.0000000000000000, 75.000000000000000 },\n+  { 2.5886411706935015e-36, 2.0000000000000000, 80.000000000000000 },\n+  { 1.6898316402103145e-38, 2.0000000000000000, 85.000000000000000 },\n+  { 1.1051801100484218e-40, 2.0000000000000000, 90.000000000000000 },\n+  { 7.2401743221736176e-43, 2.0000000000000000, 95.000000000000000 },\n+  { 4.7502253038886413e-45, 2.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=2.0000000000000000.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data006[i].nu), Tp(data006[i].x));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=5.0000000000000000.\n+testcase_cyl_bessel_k<double> data007[] = {\n+  { 0.032706273712031865, 5.0000000000000000, 5.0000000000000000 },\n+  { 5.7541849985312275e-05, 5.0000000000000000, 10.000000000000000 },\n+  { 2.1878261369258224e-07, 5.0000000000000000, 15.000000000000000 },\n+  { 1.0538660139974233e-09, 5.0000000000000000, 20.000000000000000 },\n+  { 5.6485921365284157e-12, 5.0000000000000000, 25.000000000000000 },\n+  { 3.2103335105890266e-14, 5.0000000000000000, 30.000000000000000 },\n+  { 1.8919208406439644e-16, 5.0000000000000000, 35.000000000000000 },\n+  { 1.1423814375953188e-18, 5.0000000000000000, 40.000000000000000 },\n+  { 7.0181216822204116e-21, 5.0000000000000000, 45.000000000000000 },\n+  { 4.3671822541009859e-23, 5.0000000000000000, 50.000000000000000 },\n+  { 2.7444967640357869e-25, 5.0000000000000000, 55.000000000000000 },\n+  { 1.7382232741886986e-27, 5.0000000000000000, 60.000000000000000 },\n+  { 1.1078474298959669e-29, 5.0000000000000000, 65.000000000000000 },\n+  { 7.0974537081794416e-32, 5.0000000000000000, 70.000000000000000 },\n+  { 4.5667269500061064e-34, 5.0000000000000000, 75.000000000000000 },\n+  { 2.9491764420206150e-36, 5.0000000000000000, 80.000000000000000 },\n+  { 1.9105685973117463e-38, 5.0000000000000000, 85.000000000000000 },\n+  { 1.2411034311592645e-40, 5.0000000000000000, 90.000000000000000 },\n+  { 8.0814211331379146e-43, 5.0000000000000000, 95.000000000000000 },\n+  { 5.2732561132929509e-45, 5.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=5.0000000000000000.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data007[i].nu), Tp(data007[i].x));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=10.000000000000000.\n+testcase_cyl_bessel_k<double> data008[] = {\n+  { 9.7585628291778121, 10.000000000000000, 5.0000000000000000 },\n+  { 0.0016142553003906700, 10.000000000000000, 10.000000000000000 },\n+  { 2.2605303776606440e-06, 10.000000000000000, 15.000000000000000 },\n+  { 6.3162145283215787e-09, 10.000000000000000, 20.000000000000000 },\n+  { 2.4076769602801230e-11, 10.000000000000000, 25.000000000000000 },\n+  { 1.0842816942222975e-13, 10.000000000000000, 30.000000000000000 },\n+  { 5.3976770429777191e-16, 10.000000000000000, 35.000000000000000 },\n+  { 2.8680293113671932e-18, 10.000000000000000, 40.000000000000000 },\n+  { 1.5939871900169603e-20, 10.000000000000000, 45.000000000000000 },\n+  { 9.1509882099879962e-23, 10.000000000000000, 50.000000000000000 },\n+  { 5.3823846249592858e-25, 10.000000000000000, 55.000000000000000 },\n+  { 3.2253408700563144e-27, 10.000000000000000, 60.000000000000000 },\n+  { 1.9613367530075138e-29, 10.000000000000000, 65.000000000000000 },\n+  { 1.2068471495933484e-31, 10.000000000000000, 70.000000000000000 },\n+  { 7.4979152649449644e-34, 10.000000000000000, 75.000000000000000 },\n+  { 4.6957285830490538e-36, 10.000000000000000, 80.000000000000000 },\n+  { 2.9606323347034084e-38, 10.000000000000000, 85.000000000000000 },\n+  { 1.8773542561131613e-40, 10.000000000000000, 90.000000000000000 },\n+  { 1.1962899527846350e-42, 10.000000000000000, 95.000000000000000 },\n+  { 7.6554279773881018e-45, 10.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=10.000000000000000.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data008[i].nu), Tp(data008[i].x));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=20.000000000000000.\n+testcase_cyl_bessel_k<double> data009[] = {\n+  { 482700052.06214869, 20.000000000000000, 5.0000000000000000 },\n+  { 178.74427820770549, 20.000000000000000, 10.000000000000000 },\n+  { 0.012141257729731146, 20.000000000000000, 15.000000000000000 },\n+  { 5.5431116361258155e-06, 20.000000000000000, 20.000000000000000 },\n+  { 6.3744029330352105e-09, 20.000000000000000, 25.000000000000000 },\n+  { 1.2304516475442478e-11, 20.000000000000000, 30.000000000000000 },\n+  { 3.2673136479809012e-14, 20.000000000000000, 35.000000000000000 },\n+  { 1.0703023799997383e-16, 20.000000000000000, 40.000000000000000 },\n+  { 4.0549953175660486e-19, 20.000000000000000, 45.000000000000000 },\n+  { 1.7061483797220352e-21, 20.000000000000000, 50.000000000000000 },\n+  { 7.7617008115659413e-24, 20.000000000000000, 55.000000000000000 },\n+  { 3.7482954006874725e-26, 20.000000000000000, 60.000000000000000 },\n+  { 1.8966880763956578e-28, 20.000000000000000, 65.000000000000000 },\n+  { 9.9615763479998882e-31, 20.000000000000000, 70.000000000000000 },\n+  { 5.3921623063091066e-33, 20.000000000000000, 75.000000000000000 },\n+  { 2.9920407657642272e-35, 20.000000000000000, 80.000000000000000 },\n+  { 1.6948662723618263e-37, 20.000000000000000, 85.000000000000000 },\n+  { 9.7689149642963025e-40, 20.000000000000000, 90.000000000000000 },\n+  { 5.7143603019220823e-42, 20.000000000000000, 95.000000000000000 },\n+  { 3.3852054148901700e-44, 20.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=20.000000000000000.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data009[i].nu), Tp(data009[i].x));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=50.000000000000000.\n+testcase_cyl_bessel_k<double> data010[] = {\n+  { 3.3943222434301628e+42, 50.000000000000000, 5.0000000000000000 },\n+  { 2.0613737753892579e+27, 50.000000000000000, 10.000000000000000 },\n+  { 1.7267736974519191e+18, 50.000000000000000, 15.000000000000000 },\n+  { 411711209122.01794, 50.000000000000000, 20.000000000000000 },\n+  { 1972478.7419813862, 50.000000000000000, 25.000000000000000 },\n+  { 58.770686258007267, 50.000000000000000, 30.000000000000000 },\n+  { 0.0058659391182535195, 50.000000000000000, 35.000000000000000 },\n+  { 1.3634854128794103e-06, 50.000000000000000, 40.000000000000000 },\n+  { 5.8652396362160840e-10, 50.000000000000000, 45.000000000000000 },\n+  { 4.0060134766400903e-13, 50.000000000000000, 50.000000000000000 },\n+  { 3.9062324485711016e-16, 50.000000000000000, 55.000000000000000 },\n+  { 5.0389298085176520e-19, 50.000000000000000, 60.000000000000000 },\n+  { 8.1305344250110396e-22, 50.000000000000000, 65.000000000000000 },\n+  { 1.5732816234949002e-24, 50.000000000000000, 70.000000000000000 },\n+  { 3.5349854993874397e-27, 50.000000000000000, 75.000000000000000 },\n+  { 8.9940101003189485e-30, 50.000000000000000, 80.000000000000000 },\n+  { 2.5403205503080723e-32, 50.000000000000000, 85.000000000000000 },\n+  { 7.8397596486715711e-35, 50.000000000000000, 90.000000000000000 },\n+  { 2.6098900651329550e-37, 50.000000000000000, 95.000000000000000 },\n+  { 9.2745226536133274e-40, 50.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=50.000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data010[i].nu), Tp(data010[i].x));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for nu=100.00000000000000.\n+testcase_cyl_bessel_k<double> data011[] = {\n+  { 7.0398601930616797e+115, 100.00000000000000, 5.0000000000000000 },\n+  { 4.5966740842695286e+85, 100.00000000000000, 10.000000000000000 },\n+  { 8.2565552242653898e+67, 100.00000000000000, 15.000000000000000 },\n+  { 1.7081356456876038e+55, 100.00000000000000, 20.000000000000000 },\n+  { 1.9858028128780595e+45, 100.00000000000000, 25.000000000000000 },\n+  { 1.2131584253026677e+37, 100.00000000000000, 30.000000000000000 },\n+  { 1.1016916354696684e+30, 100.00000000000000, 35.000000000000000 },\n+  { 7.0074023297775712e+23, 100.00000000000000, 40.000000000000000 },\n+  { 1.9236643958470909e+18, 100.00000000000000, 45.000000000000000 },\n+  { 16394035276269.254, 100.00000000000000, 50.000000000000000 },\n+  { 343254952.89495456, 100.00000000000000, 55.000000000000000 },\n+  { 14870.012754946305, 100.00000000000000, 60.000000000000000 },\n+  { 1.1708099078572209, 100.00000000000000, 65.000000000000000 },\n+  { 0.00015161193930722305, 100.00000000000000, 70.000000000000000 },\n+  { 2.9850234381623436e-08, 100.00000000000000, 75.000000000000000 },\n+  { 8.3928710724649065e-12, 100.00000000000000, 80.000000000000000 },\n+  { 3.2033435630927728e-15, 100.00000000000000, 85.000000000000000 },\n+  { 1.5922281431788077e-18, 100.00000000000000, 90.000000000000000 },\n+  { 9.9589454577674300e-22, 100.00000000000000, 95.000000000000000 },\n+  { 7.6171296304940858e-25, 100.00000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=100.00000000000000.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_cyl_bessel_k<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_bessel_k(Tp(data011[i].nu), Tp(data011[i].x));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  return 0;\n+}"}, {"sha": "03d6a0c5140ff24d632f01d2a264b44fa0a1079c", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/10_cyl_bessel_k/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.10 cyl_bessel_k\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  std::tr1::cyl_bessel_k(nuf, xf);\n+  std::tr1::cyl_bessel_kf(nuf, xf);\n+  std::tr1::cyl_bessel_k(nud, xd);\n+  std::tr1::cyl_bessel_k(nul, xl);\n+  std::tr1::cyl_bessel_kl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "5be103f0fe2ce9ccb574f470f222a9249de2636e", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/10_cyl_bessel_k/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F10_cyl_bessel_k%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.10 cyl_bessel_k\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  cyl_bessel_k(nuf, xf);\n+  cyl_bessel_kf(nuf, xf);\n+  cyl_bessel_k(nud, xd);\n+  cyl_bessel_k(nul, xl);\n+  cyl_bessel_kl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "6d631086928aaa53e0379895f9127e2cc8de5a18", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/11_cyl_neumann/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.11 cyl_neumann\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.0F;\n+  double nud = 0.0;\n+  long double nul = 0.0L;\n+\n+  float a = std::tr1::cyl_neumann(nuf, xf);\n+  float b = std::tr1::cyl_neumannf(nuf, xf);\n+  double c = std::tr1::cyl_neumann(nud, xd);\n+  long double d = std::tr1::cyl_neumann(nul, xl);\n+  long double e = std::tr1::cyl_neumannl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float xf = 1.0F;\n+  double xd = 1.0;\n+  long double xl = 1.0L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::cyl_neumann(nuf, xf);\n+  float b = std::tr1::cyl_neumannf(nuf, xf);\n+  double c = std::tr1::cyl_neumann(nud, xd);\n+  long double d = std::tr1::cyl_neumann(nul, xl);\n+  long double e = std::tr1::cyl_neumannl(nul, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "494f9893096e683e8f58be7ac2e91a3a48cccec1", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/11_cyl_neumann/check_value.cc", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,618 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  cyl_neumann\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for nu=0.0000000000000000.\n+testcase_cyl_neumann<double> data001[] = {\n+  { -0.30851762524903376, 0.0000000000000000, 5.0000000000000000 },\n+  { 0.055671167283599395, 0.0000000000000000, 10.000000000000000 },\n+  { 0.20546429603891825, 0.0000000000000000, 15.000000000000000 },\n+  { 0.062640596809383955, 0.0000000000000000, 20.000000000000000 },\n+  { -0.12724943226800620, 0.0000000000000000, 25.000000000000000 },\n+  { -0.11729573168666411, 0.0000000000000000, 30.000000000000000 },\n+  { 0.045797987195155640, 0.0000000000000000, 35.000000000000000 },\n+  { 0.12593641705826095, 0.0000000000000000, 40.000000000000000 },\n+  { 0.027060469763313322, 0.0000000000000000, 45.000000000000000 },\n+  { -0.098064995470077104, 0.0000000000000000, 50.000000000000000 },\n+  { -0.077569178730412622, 0.0000000000000000, 55.000000000000000 },\n+  { 0.047358952209449412, 0.0000000000000000, 60.000000000000000 },\n+  { 0.097183557740181933, 0.0000000000000000, 65.000000000000000 },\n+  { 0.0093096664589410131, 0.0000000000000000, 70.000000000000000 },\n+  { -0.085369047647775642, 0.0000000000000000, 75.000000000000000 },\n+  { -0.055620339089769981, 0.0000000000000000, 80.000000000000000 },\n+  { 0.049567884951494258, 0.0000000000000000, 85.000000000000000 },\n+  { 0.079776475854877765, 0.0000000000000000, 90.000000000000000 },\n+  { -0.0028230995861232323, 0.0000000000000000, 95.000000000000000 },\n+  { -0.077244313365083112, 0.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.0000000000000000.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data001[i].nu), Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=0.33333333333333331.\n+testcase_cyl_neumann<double> data002[] = {\n+  { -0.18192321129343830, 0.33333333333333331, 5.0000000000000000 },\n+  { 0.17020111788268769, 0.33333333333333331, 10.000000000000000 },\n+  { 0.18540507541540799, 0.33333333333333331, 15.000000000000000 },\n+  { -0.028777707635715091, 0.33333333333333331, 20.000000000000000 },\n+  { -0.15829741864944166, 0.33333333333333331, 25.000000000000000 },\n+  { -0.058645772316705216, 0.33333333333333331, 30.000000000000000 },\n+  { 0.10294930308870620, 0.33333333333333331, 35.000000000000000 },\n+  { 0.10547870367098920, 0.33333333333333331, 40.000000000000000 },\n+  { -0.034334228816010864, 0.33333333333333331, 45.000000000000000 },\n+  { -0.11283489933031278, 0.33333333333333331, 50.000000000000000 },\n+  { -0.030007358986895123, 0.33333333333333331, 55.000000000000000 },\n+  { 0.086699173295718093, 0.33333333333333331, 60.000000000000000 },\n+  { 0.074875579668878672, 0.33333333333333331, 65.000000000000000 },\n+  { -0.039323246374552645, 0.33333333333333331, 70.000000000000000 },\n+  { -0.091263539574475222, 0.33333333333333331, 75.000000000000000 },\n+  { -0.013358849535984282, 0.33333333333333331, 80.000000000000000 },\n+  { 0.078373575537830184, 0.33333333333333331, 85.000000000000000 },\n+  { 0.055812482883955974, 0.33333333333333331, 90.000000000000000 },\n+  { -0.043310380106990579, 0.33333333333333331, 95.000000000000000 },\n+  { -0.076900504962136587, 0.33333333333333331, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.33333333333333331.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data002[i].nu), Tp(data002[i].x));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=0.50000000000000000.\n+testcase_cyl_neumann<double> data003[] = {\n+  { -0.10121770918510843, 0.50000000000000000, 5.0000000000000000 },\n+  { 0.21170886633139813, 0.50000000000000000, 10.000000000000000 },\n+  { 0.15650551590730860, 0.50000000000000000, 15.000000000000000 },\n+  { -0.072806904785061841, 0.50000000000000000, 20.000000000000000 },\n+  { -0.15817308404205055, 0.50000000000000000, 25.000000000000000 },\n+  { -0.022470290598831121, 0.50000000000000000, 30.000000000000000 },\n+  { 0.12187835265849536, 0.50000000000000000, 35.000000000000000 },\n+  { 0.084138655676395432, 0.50000000000000000, 40.000000000000000 },\n+  { -0.062482641933003132, 0.50000000000000000, 45.000000000000000 },\n+  { -0.10888475635053953, 0.50000000000000000, 50.000000000000000 },\n+  { -0.0023805454010948804, 0.50000000000000000, 55.000000000000000 },\n+  { 0.098104683735037904, 0.50000000000000000, 60.000000000000000 },\n+  { 0.055663470218594434, 0.50000000000000000, 65.000000000000000 },\n+  { -0.060396767883824809, 0.50000000000000000, 70.000000000000000 },\n+  { -0.084922578922046868, 0.50000000000000000, 75.000000000000000 },\n+  { 0.0098472271924441215, 0.50000000000000000, 80.000000000000000 },\n+  { 0.085190643574343639, 0.50000000000000000, 85.000000000000000 },\n+  { 0.037684970437156261, 0.50000000000000000, 90.000000000000000 },\n+  { -0.059772904856097479, 0.50000000000000000, 95.000000000000000 },\n+  { -0.068803091468728053, 0.50000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.50000000000000000.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data003[i].nu), Tp(data003[i].x));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000028e-11));\n+}\n+\n+// Test data for nu=0.66666666666666663.\n+testcase_cyl_neumann<double> data004[] = {\n+  { -0.016050662643389616, 0.66666666666666663, 5.0000000000000000 },\n+  { 0.23937232657540730, 0.66666666666666663, 10.000000000000000 },\n+  { 0.11762106604241242, 0.66666666666666663, 15.000000000000000 },\n+  { -0.11182254014899563, 0.66666666666666663, 20.000000000000000 },\n+  { -0.14756582982938804, 0.66666666666666663, 25.000000000000000 },\n+  { 0.015078692908077665, 0.66666666666666663, 30.000000000000000 },\n+  { 0.13260911815705798, 0.66666666666666663, 35.000000000000000 },\n+  { 0.057217565989652795, 0.66666666666666663, 40.000000000000000 },\n+  { -0.086373755152382048, 0.66666666666666663, 45.000000000000000 },\n+  { -0.097624139208051630, 0.66666666666666663, 50.000000000000000 },\n+  { 0.025354902147023434, 0.66666666666666663, 55.000000000000000 },\n+  { 0.10288136476351209, 0.66666666666666663, 60.000000000000000 },\n+  { 0.032728379560128203, 0.66666666666666663, 65.000000000000000 },\n+  { -0.077363672735747777, 0.66666666666666663, 70.000000000000000 },\n+  { -0.072855870458293975, 0.66666666666666663, 75.000000000000000 },\n+  { 0.032358106046953494, 0.66666666666666663, 80.000000000000000 },\n+  { 0.086240651537394228, 0.66666666666666663, 85.000000000000000 },\n+  { 0.017029601697285159, 0.66666666666666663, 90.000000000000000 },\n+  { -0.072173520560584709, 0.66666666666666663, 95.000000000000000 },\n+  { -0.056057339204073985, 0.66666666666666663, 100.00000000000000 },\n+};\n+\n+// Test function for nu=0.66666666666666663.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data004[i].nu), Tp(data004[i].x));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=1.0000000000000000.\n+testcase_cyl_neumann<double> data005[] = {\n+  { 0.14786314339122689, 1.0000000000000000, 5.0000000000000000 },\n+  { 0.24901542420695388, 1.0000000000000000, 10.000000000000000 },\n+  { 0.021073628036873546, 1.0000000000000000, 15.000000000000000 },\n+  { -0.16551161436252118, 1.0000000000000000, 20.000000000000000 },\n+  { -0.098829964783237384, 1.0000000000000000, 25.000000000000000 },\n+  { 0.084425570661747149, 1.0000000000000000, 30.000000000000000 },\n+  { 0.12751273354559012, 1.0000000000000000, 35.000000000000000 },\n+  { -0.0057935058215496330, 1.0000000000000000, 40.000000000000000 },\n+  { -0.11552517964639945, 1.0000000000000000, 45.000000000000000 },\n+  { -0.056795668562014713, 1.0000000000000000, 50.000000000000000 },\n+  { 0.073846265432577940, 1.0000000000000000, 55.000000000000000 },\n+  { 0.091869609369866906, 1.0000000000000000, 60.000000000000000 },\n+  { -0.017940374275377303, 1.0000000000000000, 65.000000000000000 },\n+  { -0.094844652625716244, 1.0000000000000000, 70.000000000000000 },\n+  { -0.035213785160580456, 1.0000000000000000, 75.000000000000000 },\n+  { 0.069395913784588051, 1.0000000000000000, 80.000000000000000 },\n+  { 0.071233187582749782, 1.0000000000000000, 85.000000000000000 },\n+  { -0.026187238607768282, 1.0000000000000000, 90.000000000000000 },\n+  { -0.081827958724501229, 1.0000000000000000, 95.000000000000000 },\n+  { -0.020372312002759942, 1.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=1.0000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data005[i].nu), Tp(data005[i].x));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000014e-11));\n+}\n+\n+// Test data for nu=2.0000000000000000.\n+testcase_cyl_neumann<double> data006[] = {\n+  { 0.36766288260552449, 2.0000000000000000, 5.0000000000000000 },\n+  { -0.0058680824422086154, 2.0000000000000000, 10.000000000000000 },\n+  { -0.20265447896733510, 2.0000000000000000, 15.000000000000000 },\n+  { -0.079191758245636068, 2.0000000000000000, 20.000000000000000 },\n+  { 0.11934303508534720, 2.0000000000000000, 25.000000000000000 },\n+  { 0.12292410306411393, 2.0000000000000000, 30.000000000000000 },\n+  { -0.038511545278264774, 2.0000000000000000, 35.000000000000000 },\n+  { -0.12622609234933843, 2.0000000000000000, 40.000000000000000 },\n+  { -0.032194922192042189, 2.0000000000000000, 45.000000000000000 },\n+  { 0.095793168727596509, 2.0000000000000000, 50.000000000000000 },\n+  { 0.080254497473415454, 2.0000000000000000, 55.000000000000000 },\n+  { -0.044296631897120513, 2.0000000000000000, 60.000000000000000 },\n+  { -0.097735569256347382, 2.0000000000000000, 65.000000000000000 },\n+  { -0.012019513676818619, 2.0000000000000000, 70.000000000000000 },\n+  { 0.084430013376826832, 2.0000000000000000, 75.000000000000000 },\n+  { 0.057355236934384685, 2.0000000000000000, 80.000000000000000 },\n+  { -0.047891809949547205, 2.0000000000000000, 85.000000000000000 },\n+  { -0.080358414490605948, 2.0000000000000000, 90.000000000000000 },\n+  { 0.0011004057182389959, 2.0000000000000000, 95.000000000000000 },\n+  { 0.076836867125027908, 2.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=2.0000000000000000.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data006[i].nu), Tp(data006[i].x));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));\n+}\n+\n+// Test data for nu=5.0000000000000000.\n+testcase_cyl_neumann<double> data007[] = {\n+  { -0.45369482249110188, 5.0000000000000000, 5.0000000000000000 },\n+  { 0.13540304768936232, 5.0000000000000000, 10.000000000000000 },\n+  { 0.16717271575940021, 5.0000000000000000, 15.000000000000000 },\n+  { -0.10003576788953225, 5.0000000000000000, 20.000000000000000 },\n+  { -0.14705799311372267, 5.0000000000000000, 25.000000000000000 },\n+  { 0.031627359289264322, 5.0000000000000000, 30.000000000000000 },\n+  { 0.13554781474770031, 5.0000000000000000, 35.000000000000000 },\n+  { 0.031869448780850372, 5.0000000000000000, 40.000000000000000 },\n+  { -0.10426932700176872, 5.0000000000000000, 45.000000000000000 },\n+  { -0.078548413913081608, 5.0000000000000000, 50.000000000000000 },\n+  { 0.055257033062858382, 5.0000000000000000, 55.000000000000000 },\n+  { 0.099464632840450901, 5.0000000000000000, 60.000000000000000 },\n+  { 0.00023860469499600970, 5.0000000000000000, 65.000000000000000 },\n+  { -0.091861802216406066, 5.0000000000000000, 70.000000000000000 },\n+  { -0.048383671296970077, 5.0000000000000000, 75.000000000000000 },\n+  { 0.060293667104896330, 5.0000000000000000, 80.000000000000000 },\n+  { 0.077506166682734010, 5.0000000000000000, 85.000000000000000 },\n+  { -0.015338764062239803, 5.0000000000000000, 90.000000000000000 },\n+  { -0.081531504045514375, 5.0000000000000000, 95.000000000000000 },\n+  { -0.029480196281662041, 5.0000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=5.0000000000000000.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data007[i].nu), Tp(data007[i].x));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000013e-09));\n+}\n+\n+// Test data for nu=10.000000000000000.\n+testcase_cyl_neumann<double> data008[] = {\n+  { -25.129110095610098, 10.000000000000000, 5.0000000000000000 },\n+  { -0.35981415218340279, 10.000000000000000, 10.000000000000000 },\n+  { 0.21997141360195582, 10.000000000000000, 15.000000000000000 },\n+  { -0.043894653515658202, 10.000000000000000, 20.000000000000000 },\n+  { -0.14871839049980651, 10.000000000000000, 25.000000000000000 },\n+  { 0.075056702122397012, 10.000000000000000, 30.000000000000000 },\n+  { 0.12222473135000553, 10.000000000000000, 35.000000000000000 },\n+  { -0.046723877232677867, 10.000000000000000, 40.000000000000000 },\n+  { -0.11739339009322178, 10.000000000000000, 45.000000000000000 },\n+  { 0.0057238971820535740, 10.000000000000000, 50.000000000000000 },\n+  { 0.10733910125831635, 10.000000000000000, 55.000000000000000 },\n+  { 0.036290350559545506, 10.000000000000000, 60.000000000000000 },\n+  { -0.083239127691715639, 10.000000000000000, 65.000000000000000 },\n+  { -0.069639384138314872, 10.000000000000000, 70.000000000000000 },\n+  { 0.045798335061325038, 10.000000000000000, 75.000000000000000 },\n+  { 0.086269195064844428, 10.000000000000000, 80.000000000000000 },\n+  { -0.0018234674126248629, 10.000000000000000, 85.000000000000000 },\n+  { -0.082067762371231298, 10.000000000000000, 90.000000000000000 },\n+  { -0.038798074754578075, 10.000000000000000, 95.000000000000000 },\n+  { 0.058331574236414815, 10.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=10.000000000000000.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data008[i].nu), Tp(data008[i].x));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));\n+}\n+\n+// Test data for nu=20.000000000000000.\n+testcase_cyl_neumann<double> data009[] = {\n+  { -593396529.69143212, 20.000000000000000, 5.0000000000000000 },\n+  { -1597.4838482696264, 20.000000000000000, 10.000000000000000 },\n+  { -3.3087330924737630, 20.000000000000000, 15.000000000000000 },\n+  { -0.28548945860020319, 20.000000000000000, 20.000000000000000 },\n+  { 0.19804074776289243, 20.000000000000000, 25.000000000000000 },\n+  { -0.16848153948742675, 20.000000000000000, 30.000000000000000 },\n+  { 0.10102784152594022, 20.000000000000000, 35.000000000000000 },\n+  { 0.045161820565805928, 20.000000000000000, 40.000000000000000 },\n+  { -0.12556489308015448, 20.000000000000000, 45.000000000000000 },\n+  { 0.016442633948115841, 20.000000000000000, 50.000000000000000 },\n+  { 0.10853448778255187, 20.000000000000000, 55.000000000000000 },\n+  { -0.026721408520664677, 20.000000000000000, 60.000000000000000 },\n+  { -0.098780425256324203, 20.000000000000000, 65.000000000000000 },\n+  { 0.016201957786018205, 20.000000000000000, 70.000000000000000 },\n+  { 0.093591198265063735, 20.000000000000000, 75.000000000000000 },\n+  { 0.0040484400737295740, 20.000000000000000, 80.000000000000000 },\n+  { -0.086314929459920503, 20.000000000000000, 85.000000000000000 },\n+  { -0.028274110097231495, 20.000000000000000, 90.000000000000000 },\n+  { 0.072349520791638755, 20.000000000000000, 95.000000000000000 },\n+  { 0.051247973076188565, 20.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=20.000000000000000.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data009[i].nu), Tp(data009[i].x));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-10));\n+}\n+\n+// Test data for nu=50.000000000000000.\n+testcase_cyl_neumann<double> data010[] = {\n+  { -2.7888370175838943e+42, 50.000000000000000, 5.0000000000000000 },\n+  { -3.6410665018007421e+27, 50.000000000000000, 10.000000000000000 },\n+  { -1.0929732912175405e+19, 50.000000000000000, 15.000000000000000 },\n+  { -15606426801663.732, 50.000000000000000, 20.000000000000000 },\n+  { -753573251.44662631, 50.000000000000000, 25.000000000000000 },\n+  { -386759.32602734747, 50.000000000000000, 30.000000000000000 },\n+  { -1172.8690492895341, 50.000000000000000, 35.000000000000000 },\n+  { -15.615608873419953, 50.000000000000000, 40.000000000000000 },\n+  { -0.87058346204176951, 50.000000000000000, 45.000000000000000 },\n+  { -0.21031655464397736, 50.000000000000000, 50.000000000000000 },\n+  { 0.093048240412999375, 50.000000000000000, 55.000000000000000 },\n+  { 0.0086417699626745066, 50.000000000000000, 60.000000000000000 },\n+  { -0.025019788459221974, 50.000000000000000, 65.000000000000000 },\n+  { -0.0014815155191908913, 50.000000000000000, 70.000000000000000 },\n+  { 0.050335774732164155, 50.000000000000000, 75.000000000000000 },\n+  { -0.092924250967987204, 50.000000000000000, 80.000000000000000 },\n+  { 0.087332463030205670, 50.000000000000000, 85.000000000000000 },\n+  { -0.016164237701651891, 50.000000000000000, 90.000000000000000 },\n+  { -0.068897613820457920, 50.000000000000000, 95.000000000000000 },\n+  { 0.076505263944802962, 50.000000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=50.000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data010[i].nu), Tp(data010[i].x));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000017e-10));\n+}\n+\n+// Test data for nu=100.00000000000000.\n+testcase_cyl_neumann<double> data011[] = {\n+  { -5.0848639160196196e+115, 100.00000000000000, 5.0000000000000000 },\n+  { -4.8491482711800245e+85, 100.00000000000000, 10.000000000000000 },\n+  { -1.6375955323195320e+68, 100.00000000000000, 15.000000000000000 },\n+  { -8.2002648144679137e+55, 100.00000000000000, 20.000000000000000 },\n+  { -2.9712216432562373e+46, 100.00000000000000, 25.000000000000000 },\n+  { -7.2875284708240766e+38, 100.00000000000000, 30.000000000000000 },\n+  { -3.4251079902108953e+32, 100.00000000000000, 35.000000000000000 },\n+  { -1.4552439438101799e+27, 100.00000000000000, 40.000000000000000 },\n+  { -3.4506612476220073e+22, 100.00000000000000, 45.000000000000000 },\n+  { -3.2938001882025948e+18, 100.00000000000000, 50.000000000000000 },\n+  { -1005686182055527.4, 100.00000000000000, 55.000000000000000 },\n+  { -831892881402.11377, 100.00000000000000, 60.000000000000000 },\n+  { -1650863778.0598330, 100.00000000000000, 65.000000000000000 },\n+  { -7192614.1976097804, 100.00000000000000, 70.000000000000000 },\n+  { -64639.072261231602, 100.00000000000000, 75.000000000000000 },\n+  { -1152.5905185698464, 100.00000000000000, 80.000000000000000 },\n+  { -40.250761402102000, 100.00000000000000, 85.000000000000000 },\n+  { -2.8307771387185459, 100.00000000000000, 90.000000000000000 },\n+  { -0.45762200495904559, 100.00000000000000, 95.000000000000000 },\n+  { -0.16692141141757649, 100.00000000000000, 100.00000000000000 },\n+};\n+\n+// Test function for nu=100.00000000000000.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_cyl_neumann<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::cyl_neumann(Tp(data011[i].nu), Tp(data011[i].x));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000006e-11));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  return 0;\n+}"}, {"sha": "0d9486555131524a2d4cea09ffc4d1a1a8114660", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/11_cyl_neumann/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.11 cyl_neumann\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  std::tr1::cyl_neumann(nuf, xf);\n+  std::tr1::cyl_neumannf(nuf, xf);\n+  std::tr1::cyl_neumann(nud, xd);\n+  std::tr1::cyl_neumann(nul, xl);\n+  std::tr1::cyl_neumannl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "39e0cac7ea5409cfe7866e009e208d238049c787", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/11_cyl_neumann/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F11_cyl_neumann%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.11 cyl_neumann\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float nuf = 1.0F / 3.0F, xf = 0.5F;\n+  double nud = 1.0 / 3.0, xd = 0.5;\n+  long double nul = 1.0L / 3.0L, xl = 0.5L;\n+\n+  cyl_neumann(nuf, xf);\n+  cyl_neumannf(nuf, xf);\n+  cyl_neumann(nud, xd);\n+  cyl_neumann(nul, xl);\n+  cyl_neumannl(nul, xl);\n+\n+  return;\n+}\n+"}, {"sha": "d86c5b40f54f5eda0fda3d7b4cd76b8248d1a04c", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.12 ellint_1\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float phif = std::atan2(1.0F, 1.0F);\n+  double phid = std::atan2(1.0, 1.0);\n+  long double phil = std::atan2(1.0L, 1.0L);\n+\n+  float a = std::tr1::ellint_1(kf, phif);\n+  float b = std::tr1::ellint_1f(kf, phif);\n+  double c = std::tr1::ellint_1(kd, phid);\n+  long double d = std::tr1::ellint_1(kl, phil);\n+  long double e = std::tr1::ellint_1l(kl, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  float phif = std::numeric_limits<float>::quiet_NaN();\n+  double phid = std::numeric_limits<double>::quiet_NaN();\n+  long double phil = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::ellint_1(kf, phif);\n+  float b = std::tr1::ellint_1f(kf, phif);\n+  double c = std::tr1::ellint_1(kd, phid);\n+  long double d = std::tr1::ellint_1(kl, phil);\n+  long double e = std::tr1::ellint_1l(kl, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "8df6df02f30bc12075160f5376dc7f24dcc47f77", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/check_value.cc", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,844 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  ellint_1\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for k=-0.90000000000000002.\n+testcase_ellint_1<double> data001[] = {\n+  { -0.0000000000000000, -0.90000000000000002, 0.0000000000000000 },\n+  { 0.17525427376115027, -0.90000000000000002, 0.17453292519943295 },\n+  { 0.35492464591297446, -0.90000000000000002, 0.34906585039886590 },\n+  { 0.54388221416157134, -0.90000000000000002, 0.52359877559829882 },\n+  { 0.74797400423532523, -0.90000000000000002, 0.69813170079773179 },\n+  { 0.97463898451966458, -0.90000000000000002, 0.87266462599716477 },\n+  { 1.2334463254523440, -0.90000000000000002, 1.0471975511965976 },\n+  { 1.5355247765594910, -0.90000000000000002, 1.2217304763960306 },\n+  { 1.8882928567775124, -0.90000000000000002, 1.3962634015954636 },\n+  { 2.2805491384227703, -0.90000000000000002, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.90000000000000002.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data001[i].k), Tp(data001[i].phi));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.80000000000000004.\n+testcase_ellint_1<double> data002[] = {\n+  { -0.0000000000000000, -0.80000000000000004, 0.0000000000000000 },\n+  { 0.17510154241338902, -0.80000000000000004, 0.17453292519943295 },\n+  { 0.35365068839779390, -0.80000000000000004, 0.34906585039886590 },\n+  { 0.53926804409084561, -0.80000000000000004, 0.52359877559829882 },\n+  { 0.73587926028070383, -0.80000000000000004, 0.69813170079773179 },\n+  { 0.94770942970071170, -0.80000000000000004, 0.87266462599716477 },\n+  { 1.1789022995388239, -0.80000000000000004, 1.0471975511965976 },\n+  { 1.4323027881876009, -0.80000000000000004, 1.2217304763960306 },\n+  { 1.7069629739121674, -0.80000000000000004, 1.3962634015954636 },\n+  { 1.9953027776647296, -0.80000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.80000000000000004.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data002[i].k), Tp(data002[i].phi));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.69999999999999996.\n+testcase_ellint_1<double> data003[] = {\n+  { -0.0000000000000000, -0.69999999999999996, 0.0000000000000000 },\n+  { 0.17496737466916720, -0.69999999999999996, 0.17453292519943295 },\n+  { 0.35254687535677925, -0.69999999999999996, 0.34906585039886590 },\n+  { 0.53536740275997130, -0.69999999999999996, 0.52359877559829882 },\n+  { 0.72603797651684465, -0.69999999999999996, 0.69813170079773179 },\n+  { 0.92698296348313458, -0.69999999999999996, 0.87266462599716477 },\n+  { 1.1400447527693316, -0.69999999999999996, 1.0471975511965976 },\n+  { 1.3657668117194071, -0.69999999999999996, 1.2217304763960306 },\n+  { 1.6024686895959159, -0.69999999999999996, 1.3962634015954636 },\n+  { 1.8456939983747236, -0.69999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.69999999999999996.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data003[i].k), Tp(data003[i].phi));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.59999999999999998.\n+testcase_ellint_1<double> data004[] = {\n+  { -0.0000000000000000, -0.59999999999999998, 0.0000000000000000 },\n+  { 0.17485154362988362, -0.59999999999999998, 0.17453292519943295 },\n+  { 0.35160509865544326, -0.59999999999999998, 0.34906585039886590 },\n+  { 0.53210652578446160, -0.59999999999999998, 0.52359877559829882 },\n+  { 0.71805304664485670, -0.59999999999999998, 0.69813170079773179 },\n+  { 0.91082759030195970, -0.59999999999999998, 0.87266462599716477 },\n+  { 1.1112333229323361, -0.59999999999999998, 1.0471975511965976 },\n+  { 1.3191461190365270, -0.59999999999999998, 1.2217304763960306 },\n+  { 1.5332022105084773, -0.59999999999999998, 1.3962634015954636 },\n+  { 1.7507538029157526, -0.59999999999999998, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.59999999999999998.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data004[i].k), Tp(data004[i].phi));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.50000000000000000.\n+testcase_ellint_1<double> data005[] = {\n+  { -0.0000000000000000, -0.50000000000000000, 0.0000000000000000 },\n+  { 0.17475385514035785, -0.50000000000000000, 0.17453292519943295 },\n+  { 0.35081868470101585, -0.50000000000000000, 0.34906585039886590 },\n+  { 0.52942862705190585, -0.50000000000000000, 0.52359877559829882 },\n+  { 0.71164727562630326, -0.50000000000000000, 0.69813170079773179 },\n+  { 0.89824523594227768, -0.50000000000000000, 0.87266462599716477 },\n+  { 1.0895506700518851, -0.50000000000000000, 1.0471975511965976 },\n+  { 1.2853005857432933, -0.50000000000000000, 1.2217304763960306 },\n+  { 1.4845545520549484, -0.50000000000000000, 1.3962634015954636 },\n+  { 1.6857503548125963, -0.50000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.50000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data005[i].k), Tp(data005[i].phi));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.40000000000000002.\n+testcase_ellint_1<double> data006[] = {\n+  { -0.0000000000000000, -0.40000000000000002, 0.0000000000000000 },\n+  { 0.17467414669441531, -0.40000000000000002, 0.17453292519943295 },\n+  { 0.35018222772483443, -0.40000000000000002, 0.34906585039886590 },\n+  { 0.52729015917508748, -0.40000000000000002, 0.52359877559829882 },\n+  { 0.70662374407341255, -0.40000000000000002, 0.69813170079773179 },\n+  { 0.88859210497602170, -0.40000000000000002, 0.87266462599716477 },\n+  { 1.0733136290471379, -0.40000000000000002, 1.0471975511965976 },\n+  { 1.2605612170157061, -0.40000000000000002, 1.2217304763960306 },\n+  { 1.4497513956433437, -0.40000000000000002, 1.3962634015954636 },\n+  { 1.6399998658645112, -0.40000000000000002, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.40000000000000002.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data006[i].k), Tp(data006[i].phi));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.30000000000000004.\n+testcase_ellint_1<double> data007[] = {\n+  { -0.0000000000000000, -0.30000000000000004, 0.0000000000000000 },\n+  { 0.17461228653000102, -0.30000000000000004, 0.17453292519943295 },\n+  { 0.34969146102798415, -0.30000000000000004, 0.34906585039886590 },\n+  { 0.52565822873726320, -0.30000000000000004, 0.52359877559829882 },\n+  { 0.70284226512408532, -0.30000000000000004, 0.69813170079773179 },\n+  { 0.88144139195111182, -0.30000000000000004, 0.87266462599716477 },\n+  { 1.0614897067260523, -0.30000000000000004, 1.0471975511965976 },\n+  { 1.2428416824174218, -0.30000000000000004, 1.2217304763960306 },\n+  { 1.4251795877015925, -0.30000000000000004, 1.3962634015954636 },\n+  { 1.6080486199305126, -0.30000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.30000000000000004.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data007[i].k), Tp(data007[i].phi));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.19999999999999996.\n+testcase_ellint_1<double> data008[] = {\n+  { -0.0000000000000000, -0.19999999999999996, 0.0000000000000000 },\n+  { 0.17456817290292811, -0.19999999999999996, 0.17453292519943295 },\n+  { 0.34934315932086801, -0.19999999999999996, 0.34906585039886590 },\n+  { 0.52450880529443988, -0.19999999999999996, 0.52359877559829882 },\n+  { 0.70020491009844910, -0.19999999999999996, 0.69813170079773179 },\n+  { 0.87651006649967955, -0.19999999999999996, 0.87266462599716477 },\n+  { 1.0534305870298994, -0.19999999999999996, 1.0471975511965976 },\n+  { 1.2308975521670784, -0.19999999999999996, 1.2217304763960306 },\n+  { 1.4087733584990738, -0.19999999999999996, 1.3962634015954636 },\n+  { 1.5868678474541664, -0.19999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.19999999999999996.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data008[i].k), Tp(data008[i].phi));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.099999999999999978.\n+testcase_ellint_1<double> data009[] = {\n+  { -0.0000000000000000, -0.099999999999999978, 0.0000000000000000 },\n+  { 0.17454173353063665, -0.099999999999999978, 0.17453292519943295 },\n+  { 0.34913506721468085, -0.099999999999999978, 0.34906585039886590 },\n+  { 0.52382550016538953, -0.099999999999999978, 0.52359877559829882 },\n+  { 0.69864700854177031, -0.099999999999999978, 0.69813170079773179 },\n+  { 0.87361792586964870, -0.099999999999999978, 0.87266462599716477 },\n+  { 1.0487386319621685, -0.099999999999999978, 1.0471975511965976 },\n+  { 1.2239913752078757, -0.099999999999999978, 1.2217304763960306 },\n+  { 1.3993423113684049, -0.099999999999999978, 1.3962634015954636 },\n+  { 1.5747455615173562, -0.099999999999999978, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.099999999999999978.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data009[i].k), Tp(data009[i].phi));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.0000000000000000.\n+testcase_ellint_1<double> data010[] = {\n+  { -0.0000000000000000, 0.0000000000000000, 0.0000000000000000 },\n+  { 0.17453292519943295, 0.0000000000000000, 0.17453292519943295 },\n+  { 0.34906585039886584, 0.0000000000000000, 0.34906585039886590 },\n+  { 0.52359877559829882, 0.0000000000000000, 0.52359877559829882 },\n+  { 0.69813170079773179, 0.0000000000000000, 0.69813170079773179 },\n+  { 0.87266462599716477, 0.0000000000000000, 0.87266462599716477 },\n+  { 1.0471975511965976, 0.0000000000000000, 1.0471975511965976 },\n+  { 1.2217304763960304, 0.0000000000000000, 1.2217304763960306 },\n+  { 1.3962634015954631, 0.0000000000000000, 1.3962634015954636 },\n+  { 1.5707963267948966, 0.0000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.0000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data010[i].k), Tp(data010[i].phi));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.10000000000000009.\n+testcase_ellint_1<double> data011[] = {\n+  { -0.0000000000000000, 0.10000000000000009, 0.0000000000000000 },\n+  { 0.17454173353063665, 0.10000000000000009, 0.17453292519943295 },\n+  { 0.34913506721468085, 0.10000000000000009, 0.34906585039886590 },\n+  { 0.52382550016538953, 0.10000000000000009, 0.52359877559829882 },\n+  { 0.69864700854177031, 0.10000000000000009, 0.69813170079773179 },\n+  { 0.87361792586964870, 0.10000000000000009, 0.87266462599716477 },\n+  { 1.0487386319621685, 0.10000000000000009, 1.0471975511965976 },\n+  { 1.2239913752078757, 0.10000000000000009, 1.2217304763960306 },\n+  { 1.3993423113684049, 0.10000000000000009, 1.3962634015954636 },\n+  { 1.5747455615173562, 0.10000000000000009, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.10000000000000009.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data011[i].k), Tp(data011[i].phi));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.19999999999999996.\n+testcase_ellint_1<double> data012[] = {\n+  { -0.0000000000000000, 0.19999999999999996, 0.0000000000000000 },\n+  { 0.17456817290292811, 0.19999999999999996, 0.17453292519943295 },\n+  { 0.34934315932086801, 0.19999999999999996, 0.34906585039886590 },\n+  { 0.52450880529443988, 0.19999999999999996, 0.52359877559829882 },\n+  { 0.70020491009844910, 0.19999999999999996, 0.69813170079773179 },\n+  { 0.87651006649967955, 0.19999999999999996, 0.87266462599716477 },\n+  { 1.0534305870298994, 0.19999999999999996, 1.0471975511965976 },\n+  { 1.2308975521670784, 0.19999999999999996, 1.2217304763960306 },\n+  { 1.4087733584990738, 0.19999999999999996, 1.3962634015954636 },\n+  { 1.5868678474541664, 0.19999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.19999999999999996.\n+template <typename Tp>\n+void test012()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data012)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data012[i].k), Tp(data012[i].phi));\n+      const Tp f0 = data012[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.30000000000000004.\n+testcase_ellint_1<double> data013[] = {\n+  { -0.0000000000000000, 0.30000000000000004, 0.0000000000000000 },\n+  { 0.17461228653000102, 0.30000000000000004, 0.17453292519943295 },\n+  { 0.34969146102798415, 0.30000000000000004, 0.34906585039886590 },\n+  { 0.52565822873726320, 0.30000000000000004, 0.52359877559829882 },\n+  { 0.70284226512408532, 0.30000000000000004, 0.69813170079773179 },\n+  { 0.88144139195111182, 0.30000000000000004, 0.87266462599716477 },\n+  { 1.0614897067260523, 0.30000000000000004, 1.0471975511965976 },\n+  { 1.2428416824174218, 0.30000000000000004, 1.2217304763960306 },\n+  { 1.4251795877015925, 0.30000000000000004, 1.3962634015954636 },\n+  { 1.6080486199305126, 0.30000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.30000000000000004.\n+template <typename Tp>\n+void test013()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data013)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data013[i].k), Tp(data013[i].phi));\n+      const Tp f0 = data013[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.39999999999999991.\n+testcase_ellint_1<double> data014[] = {\n+  { -0.0000000000000000, 0.39999999999999991, 0.0000000000000000 },\n+  { 0.17467414669441531, 0.39999999999999991, 0.17453292519943295 },\n+  { 0.35018222772483443, 0.39999999999999991, 0.34906585039886590 },\n+  { 0.52729015917508748, 0.39999999999999991, 0.52359877559829882 },\n+  { 0.70662374407341255, 0.39999999999999991, 0.69813170079773179 },\n+  { 0.88859210497602170, 0.39999999999999991, 0.87266462599716477 },\n+  { 1.0733136290471379, 0.39999999999999991, 1.0471975511965976 },\n+  { 1.2605612170157061, 0.39999999999999991, 1.2217304763960306 },\n+  { 1.4497513956433437, 0.39999999999999991, 1.3962634015954636 },\n+  { 1.6399998658645112, 0.39999999999999991, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.39999999999999991.\n+template <typename Tp>\n+void test014()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data014)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data014[i].k), Tp(data014[i].phi));\n+      const Tp f0 = data014[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.50000000000000000.\n+testcase_ellint_1<double> data015[] = {\n+  { -0.0000000000000000, 0.50000000000000000, 0.0000000000000000 },\n+  { 0.17475385514035785, 0.50000000000000000, 0.17453292519943295 },\n+  { 0.35081868470101585, 0.50000000000000000, 0.34906585039886590 },\n+  { 0.52942862705190585, 0.50000000000000000, 0.52359877559829882 },\n+  { 0.71164727562630326, 0.50000000000000000, 0.69813170079773179 },\n+  { 0.89824523594227768, 0.50000000000000000, 0.87266462599716477 },\n+  { 1.0895506700518851, 0.50000000000000000, 1.0471975511965976 },\n+  { 1.2853005857432933, 0.50000000000000000, 1.2217304763960306 },\n+  { 1.4845545520549484, 0.50000000000000000, 1.3962634015954636 },\n+  { 1.6857503548125963, 0.50000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.50000000000000000.\n+template <typename Tp>\n+void test015()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data015)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data015[i].k), Tp(data015[i].phi));\n+      const Tp f0 = data015[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.60000000000000009.\n+testcase_ellint_1<double> data016[] = {\n+  { -0.0000000000000000, 0.60000000000000009, 0.0000000000000000 },\n+  { 0.17485154362988362, 0.60000000000000009, 0.17453292519943295 },\n+  { 0.35160509865544326, 0.60000000000000009, 0.34906585039886590 },\n+  { 0.53210652578446160, 0.60000000000000009, 0.52359877559829882 },\n+  { 0.71805304664485670, 0.60000000000000009, 0.69813170079773179 },\n+  { 0.91082759030195970, 0.60000000000000009, 0.87266462599716477 },\n+  { 1.1112333229323366, 0.60000000000000009, 1.0471975511965976 },\n+  { 1.3191461190365270, 0.60000000000000009, 1.2217304763960306 },\n+  { 1.5332022105084775, 0.60000000000000009, 1.3962634015954636 },\n+  { 1.7507538029157526, 0.60000000000000009, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.60000000000000009.\n+template <typename Tp>\n+void test016()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data016)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data016[i].k), Tp(data016[i].phi));\n+      const Tp f0 = data016[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.69999999999999996.\n+testcase_ellint_1<double> data017[] = {\n+  { -0.0000000000000000, 0.69999999999999996, 0.0000000000000000 },\n+  { 0.17496737466916720, 0.69999999999999996, 0.17453292519943295 },\n+  { 0.35254687535677925, 0.69999999999999996, 0.34906585039886590 },\n+  { 0.53536740275997130, 0.69999999999999996, 0.52359877559829882 },\n+  { 0.72603797651684465, 0.69999999999999996, 0.69813170079773179 },\n+  { 0.92698296348313458, 0.69999999999999996, 0.87266462599716477 },\n+  { 1.1400447527693316, 0.69999999999999996, 1.0471975511965976 },\n+  { 1.3657668117194071, 0.69999999999999996, 1.2217304763960306 },\n+  { 1.6024686895959159, 0.69999999999999996, 1.3962634015954636 },\n+  { 1.8456939983747236, 0.69999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.69999999999999996.\n+template <typename Tp>\n+void test017()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data017)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data017[i].k), Tp(data017[i].phi));\n+      const Tp f0 = data017[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.80000000000000004.\n+testcase_ellint_1<double> data018[] = {\n+  { -0.0000000000000000, 0.80000000000000004, 0.0000000000000000 },\n+  { 0.17510154241338902, 0.80000000000000004, 0.17453292519943295 },\n+  { 0.35365068839779390, 0.80000000000000004, 0.34906585039886590 },\n+  { 0.53926804409084561, 0.80000000000000004, 0.52359877559829882 },\n+  { 0.73587926028070383, 0.80000000000000004, 0.69813170079773179 },\n+  { 0.94770942970071170, 0.80000000000000004, 0.87266462599716477 },\n+  { 1.1789022995388239, 0.80000000000000004, 1.0471975511965976 },\n+  { 1.4323027881876009, 0.80000000000000004, 1.2217304763960306 },\n+  { 1.7069629739121674, 0.80000000000000004, 1.3962634015954636 },\n+  { 1.9953027776647296, 0.80000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.80000000000000004.\n+template <typename Tp>\n+void test018()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data018)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data018[i].k), Tp(data018[i].phi));\n+      const Tp f0 = data018[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.89999999999999991.\n+testcase_ellint_1<double> data019[] = {\n+  { -0.0000000000000000, 0.89999999999999991, 0.0000000000000000 },\n+  { 0.17525427376115027, 0.89999999999999991, 0.17453292519943295 },\n+  { 0.35492464591297446, 0.89999999999999991, 0.34906585039886590 },\n+  { 0.54388221416157123, 0.89999999999999991, 0.52359877559829882 },\n+  { 0.74797400423532501, 0.89999999999999991, 0.69813170079773179 },\n+  { 0.97463898451966458, 0.89999999999999991, 0.87266462599716477 },\n+  { 1.2334463254523438, 0.89999999999999991, 1.0471975511965976 },\n+  { 1.5355247765594910, 0.89999999999999991, 1.2217304763960306 },\n+  { 1.8882928567775117, 0.89999999999999991, 1.3962634015954636 },\n+  { 2.2805491384227699, 0.89999999999999991, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.89999999999999991.\n+template <typename Tp>\n+void test019()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data019)\n+                         / sizeof(testcase_ellint_1<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_1(Tp(data019[i].k), Tp(data019[i].phi));\n+      const Tp f0 = data019[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  test012<double>();\n+  test013<double>();\n+  test014<double>();\n+  test015<double>();\n+  test016<double>();\n+  test017<double>();\n+  test018<double>();\n+  test019<double>();\n+  return 0;\n+}"}, {"sha": "d925f82da6d4842068a919c52bc574a1c6097afb", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.12 ellint_1\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, phil = std::atan2(1.0L, 1.0L);\n+\n+  std::tr1::ellint_1(kf, phif);\n+  std::tr1::ellint_1f(kf, phif);\n+  std::tr1::ellint_1(kd, phid);\n+  std::tr1::ellint_1(kl, phil);\n+  std::tr1::ellint_1l(kl, phil);\n+\n+  return;\n+}\n+"}, {"sha": "38119b6f866a49b3374e8a30b3f44f958ca122cb", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/12_ellint_1/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F12_ellint_1%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.12 ellint_1\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, phil = std::atan2(1.0L, 1.0L);\n+\n+  ellint_1(kf, phif);\n+  ellint_1f(kf, phif);\n+  ellint_1(kd, phid);\n+  ellint_1(kl, phil);\n+  ellint_1l(kl, phil);\n+\n+  return;\n+}\n+"}, {"sha": "9e1775e57499f72631c0b66005184482dcf4019b", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/check_nan.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,87 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.13 ellint_2\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float phif = std::atan2(1.0F, 1.0F);\n+  double phid = std::atan2(1.0, 1.0);\n+  long double phil = std::atan2(1.0L, 1.0L);\n+\n+  float a = std::tr1::ellint_2(kf, phif);\n+  float b = std::tr1::ellint_2f(kf, phif);\n+  double c = std::tr1::ellint_2(kd, phid);\n+  long double d = std::tr1::ellint_2(kl, phil);\n+  long double e = std::tr1::ellint_2l(kl, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  float phif = std::numeric_limits<float>::quiet_NaN();\n+  double phid = std::numeric_limits<double>::quiet_NaN();\n+  long double phil = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::ellint_2(kf, phif);\n+  float b = std::tr1::ellint_2f(kf, phif);\n+  double c = std::tr1::ellint_2(kd, phid);\n+  long double d = std::tr1::ellint_2(kl, phil);\n+  long double e = std::tr1::ellint_2l(kl, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+"}, {"sha": "fa9e4d3a0a94b10891b9f789af811554def28e8e", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/check_value.cc", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,844 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  ellint_2\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data for k=-0.90000000000000002.\n+testcase_ellint_2<double> data001[] = {\n+  { -0.0000000000000000, -0.90000000000000002, 0.0000000000000000 },\n+  { 0.17381690606167963, -0.90000000000000002, 0.17453292519943295 },\n+  { 0.34337919186972055, -0.90000000000000002, 0.34906585039886590 },\n+  { 0.50464268659856337, -0.90000000000000002, 0.52359877559829882 },\n+  { 0.65400003842368593, -0.90000000000000002, 0.69813170079773179 },\n+  { 0.78854928419904657, -0.90000000000000002, 0.87266462599716477 },\n+  { 0.90645698626315407, -0.90000000000000002, 1.0471975511965976 },\n+  { 1.0075154899135925, -0.90000000000000002, 1.2217304763960306 },\n+  { 1.0940135583194071, -0.90000000000000002, 1.3962634015954636 },\n+  { 1.1716970527816140, -0.90000000000000002, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.90000000000000002.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data001[i].k), Tp(data001[i].phi));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+// Test data for k=-0.80000000000000004.\n+testcase_ellint_2<double> data002[] = {\n+  { -0.0000000000000000, -0.80000000000000004, 0.0000000000000000 },\n+  { 0.17396762274534808, -0.80000000000000004, 0.17453292519943295 },\n+  { 0.34458685226969316, -0.80000000000000004, 0.34906585039886590 },\n+  { 0.50872923654502444, -0.80000000000000004, 0.52359877559829882 },\n+  { 0.66372016539176237, -0.80000000000000004, 0.69813170079773179 },\n+  { 0.80760344410167406, -0.80000000000000004, 0.87266462599716477 },\n+  { 0.93945480372495072, -0.80000000000000004, 1.0471975511965976 },\n+  { 1.0597473310395036, -0.80000000000000004, 1.2217304763960306 },\n+  { 1.1706981862452361, -0.80000000000000004, 1.3962634015954636 },\n+  { 1.2763499431699066, -0.80000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.80000000000000004.\n+template <typename Tp>\n+void test002()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data002)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data002[i].k), Tp(data002[i].phi));\n+      const Tp f0 = data002[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for k=-0.69999999999999996.\n+testcase_ellint_2<double> data003[] = {\n+  { -0.0000000000000000, -0.69999999999999996, 0.0000000000000000 },\n+  { 0.17410041242702540, -0.69999999999999996, 0.17453292519943295 },\n+  { 0.34564605085764760, -0.69999999999999996, 0.34906585039886590 },\n+  { 0.51228495693314657, -0.69999999999999996, 0.52359877559829882 },\n+  { 0.67207654098799530, -0.69999999999999996, 0.69813170079773179 },\n+  { 0.82370932631556515, -0.69999999999999996, 0.87266462599716477 },\n+  { 0.96672313309452795, -0.69999999999999996, 1.0471975511965976 },\n+  { 1.1017090644949503, -0.69999999999999996, 1.2217304763960306 },\n+  { 1.2304180097292916, -0.69999999999999996, 1.3962634015954636 },\n+  { 1.3556611355719557, -0.69999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.69999999999999996.\n+template <typename Tp>\n+void test003()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data003)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data003[i].k), Tp(data003[i].phi));\n+      const Tp f0 = data003[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for k=-0.59999999999999998.\n+testcase_ellint_2<double> data004[] = {\n+  { -0.0000000000000000, -0.59999999999999998, 0.0000000000000000 },\n+  { 0.17421534919599130, -0.59999999999999998, 0.17453292519943295 },\n+  { 0.34655927787174101, -0.59999999999999998, 0.34906585039886590 },\n+  { 0.51533034538432165, -0.59999999999999998, 0.52359877559829882 },\n+  { 0.67916550597453029, -0.59999999999999998, 0.69813170079773179 },\n+  { 0.83720218180349870, -0.59999999999999998, 0.87266462599716477 },\n+  { 0.98922159354937755, -0.59999999999999998, 1.0471975511965976 },\n+  { 1.1357478470419360, -0.59999999999999998, 1.2217304763960306 },\n+  { 1.2780617372844056, -0.59999999999999998, 1.3962634015954636 },\n+  { 1.4180833944487243, -0.59999999999999998, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.59999999999999998.\n+template <typename Tp>\n+void test004()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data004)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data004[i].k), Tp(data004[i].phi));\n+      const Tp f0 = data004[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for k=-0.50000000000000000.\n+testcase_ellint_2<double> data005[] = {\n+  { -0.0000000000000000, -0.50000000000000000, 0.0000000000000000 },\n+  { 0.17431249677315910, -0.50000000000000000, 0.17453292519943295 },\n+  { 0.34732862537770803, -0.50000000000000000, 0.34906585039886590 },\n+  { 0.51788193485993805, -0.50000000000000000, 0.52359877559829882 },\n+  { 0.68506022954164536, -0.50000000000000000, 0.69813170079773179 },\n+  { 0.84831662803347196, -0.50000000000000000, 0.87266462599716477 },\n+  { 1.0075555551444717, -0.50000000000000000, 1.0471975511965976 },\n+  { 1.1631768599287302, -0.50000000000000000, 1.2217304763960306 },\n+  { 1.3160584048772543, -0.50000000000000000, 1.3962634015954636 },\n+  { 1.4674622093394274, -0.50000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.50000000000000000.\n+template <typename Tp>\n+void test005()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data005)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data005[i].k), Tp(data005[i].phi));\n+      const Tp f0 = data005[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.40000000000000002.\n+testcase_ellint_2<double> data006[] = {\n+  { -0.0000000000000000, -0.40000000000000002, 0.0000000000000000 },\n+  { 0.17439190872481269, -0.40000000000000002, 0.17453292519943295 },\n+  { 0.34795581767099210, -0.40000000000000002, 0.34906585039886590 },\n+  { 0.51995290683804474, -0.40000000000000002, 0.52359877559829882 },\n+  { 0.68981638464431549, -0.40000000000000002, 0.69813170079773179 },\n+  { 0.85722088859936041, -0.40000000000000002, 0.87266462599716477 },\n+  { 1.0221301327876993, -0.40000000000000002, 1.0471975511965976 },\n+  { 1.1848138019818371, -0.40000000000000002, 1.2217304763960306 },\n+  { 1.3458259266501531, -0.40000000000000002, 1.3962634015954636 },\n+  { 1.5059416123600402, -0.40000000000000002, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.40000000000000002.\n+template <typename Tp>\n+void test006()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data006)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data006[i].k), Tp(data006[i].phi));\n+      const Tp f0 = data006[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.30000000000000004.\n+testcase_ellint_2<double> data007[] = {\n+  { -0.0000000000000000, -0.30000000000000004, 0.0000000000000000 },\n+  { 0.17445362864048916, -0.30000000000000004, 0.17453292519943295 },\n+  { 0.34844223535713464, -0.30000000000000004, 0.34906585039886590 },\n+  { 0.52155353877411770, -0.30000000000000004, 0.52359877559829882 },\n+  { 0.69347584418369879, -0.30000000000000004, 0.69813170079773179 },\n+  { 0.86403609928237668, -0.30000000000000004, 0.87266462599716477 },\n+  { 1.0332234514065410, -0.30000000000000004, 1.0471975511965976 },\n+  { 1.2011943182068923, -0.30000000000000004, 1.2217304763960306 },\n+  { 1.3682566113689620, -0.30000000000000004, 1.3962634015954636 },\n+  { 1.5348334649232489, -0.30000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.30000000000000004.\n+template <typename Tp>\n+void test007()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data007)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data007[i].k), Tp(data007[i].phi));\n+      const Tp f0 = data007[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.19999999999999996.\n+testcase_ellint_2<double> data008[] = {\n+  { -0.0000000000000000, -0.19999999999999996, 0.0000000000000000 },\n+  { 0.17449769027652814, -0.19999999999999996, 0.17453292519943295 },\n+  { 0.34878893400762095, -0.19999999999999996, 0.34906585039886590 },\n+  { 0.52269152856057410, -0.19999999999999996, 0.52359877559829882 },\n+  { 0.69606913360157596, -0.19999999999999996, 0.69813170079773179 },\n+  { 0.86884782374863356, -0.19999999999999996, 0.87266462599716477 },\n+  { 1.0410255369689567, -0.19999999999999996, 1.0471975511965976 },\n+  { 1.2126730391631360, -0.19999999999999996, 1.2217304763960306 },\n+  { 1.3839259540325153, -0.19999999999999996, 1.3962634015954636 },\n+  { 1.5549685462425296, -0.19999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.19999999999999996.\n+template <typename Tp>\n+void test008()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data008)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data008[i].k), Tp(data008[i].phi));\n+      const Tp f0 = data008[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=-0.099999999999999978.\n+testcase_ellint_2<double> data009[] = {\n+  { -0.0000000000000000, -0.099999999999999978, 0.0000000000000000 },\n+  { 0.17452411766649945, -0.099999999999999978, 0.17453292519943295 },\n+  { 0.34899665805442398, -0.099999999999999978, 0.34906585039886590 },\n+  { 0.52337222400508787, -0.099999999999999978, 0.52359877559829882 },\n+  { 0.69761705217284875, -0.099999999999999978, 0.69813170079773179 },\n+  { 0.87171309273007491, -0.099999999999999978, 0.87266462599716477 },\n+  { 1.0456602197056328, -0.099999999999999978, 1.0471975511965976 },\n+  { 1.2194762899272025, -0.099999999999999978, 1.2217304763960306 },\n+  { 1.3931950229892744, -0.099999999999999978, 1.3962634015954636 },\n+  { 1.5668619420216685, -0.099999999999999978, 1.5707963267948966 },\n+};\n+\n+// Test function for k=-0.099999999999999978.\n+template <typename Tp>\n+void test009()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data009)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data009[i].k), Tp(data009[i].phi));\n+      const Tp f0 = data009[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.0000000000000000.\n+testcase_ellint_2<double> data010[] = {\n+  { -0.0000000000000000, 0.0000000000000000, 0.0000000000000000 },\n+  { 0.17453292519943295, 0.0000000000000000, 0.17453292519943295 },\n+  { 0.34906585039886584, 0.0000000000000000, 0.34906585039886590 },\n+  { 0.52359877559829882, 0.0000000000000000, 0.52359877559829882 },\n+  { 0.69813170079773179, 0.0000000000000000, 0.69813170079773179 },\n+  { 0.87266462599716477, 0.0000000000000000, 0.87266462599716477 },\n+  { 1.0471975511965976, 0.0000000000000000, 1.0471975511965976 },\n+  { 1.2217304763960304, 0.0000000000000000, 1.2217304763960306 },\n+  { 1.3962634015954631, 0.0000000000000000, 1.3962634015954636 },\n+  { 1.5707963267948966, 0.0000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.0000000000000000.\n+template <typename Tp>\n+void test010()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data010)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data010[i].k), Tp(data010[i].phi));\n+      const Tp f0 = data010[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.10000000000000009.\n+testcase_ellint_2<double> data011[] = {\n+  { -0.0000000000000000, 0.10000000000000009, 0.0000000000000000 },\n+  { 0.17452411766649945, 0.10000000000000009, 0.17453292519943295 },\n+  { 0.34899665805442398, 0.10000000000000009, 0.34906585039886590 },\n+  { 0.52337222400508787, 0.10000000000000009, 0.52359877559829882 },\n+  { 0.69761705217284875, 0.10000000000000009, 0.69813170079773179 },\n+  { 0.87171309273007491, 0.10000000000000009, 0.87266462599716477 },\n+  { 1.0456602197056328, 0.10000000000000009, 1.0471975511965976 },\n+  { 1.2194762899272025, 0.10000000000000009, 1.2217304763960306 },\n+  { 1.3931950229892744, 0.10000000000000009, 1.3962634015954636 },\n+  { 1.5668619420216685, 0.10000000000000009, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.10000000000000009.\n+template <typename Tp>\n+void test011()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data011)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data011[i].k), Tp(data011[i].phi));\n+      const Tp f0 = data011[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.19999999999999996.\n+testcase_ellint_2<double> data012[] = {\n+  { -0.0000000000000000, 0.19999999999999996, 0.0000000000000000 },\n+  { 0.17449769027652814, 0.19999999999999996, 0.17453292519943295 },\n+  { 0.34878893400762095, 0.19999999999999996, 0.34906585039886590 },\n+  { 0.52269152856057410, 0.19999999999999996, 0.52359877559829882 },\n+  { 0.69606913360157596, 0.19999999999999996, 0.69813170079773179 },\n+  { 0.86884782374863356, 0.19999999999999996, 0.87266462599716477 },\n+  { 1.0410255369689567, 0.19999999999999996, 1.0471975511965976 },\n+  { 1.2126730391631360, 0.19999999999999996, 1.2217304763960306 },\n+  { 1.3839259540325153, 0.19999999999999996, 1.3962634015954636 },\n+  { 1.5549685462425296, 0.19999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.19999999999999996.\n+template <typename Tp>\n+void test012()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data012)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data012[i].k), Tp(data012[i].phi));\n+      const Tp f0 = data012[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.30000000000000004.\n+testcase_ellint_2<double> data013[] = {\n+  { -0.0000000000000000, 0.30000000000000004, 0.0000000000000000 },\n+  { 0.17445362864048916, 0.30000000000000004, 0.17453292519943295 },\n+  { 0.34844223535713464, 0.30000000000000004, 0.34906585039886590 },\n+  { 0.52155353877411770, 0.30000000000000004, 0.52359877559829882 },\n+  { 0.69347584418369879, 0.30000000000000004, 0.69813170079773179 },\n+  { 0.86403609928237668, 0.30000000000000004, 0.87266462599716477 },\n+  { 1.0332234514065410, 0.30000000000000004, 1.0471975511965976 },\n+  { 1.2011943182068923, 0.30000000000000004, 1.2217304763960306 },\n+  { 1.3682566113689620, 0.30000000000000004, 1.3962634015954636 },\n+  { 1.5348334649232489, 0.30000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.30000000000000004.\n+template <typename Tp>\n+void test013()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data013)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data013[i].k), Tp(data013[i].phi));\n+      const Tp f0 = data013[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.39999999999999991.\n+testcase_ellint_2<double> data014[] = {\n+  { -0.0000000000000000, 0.39999999999999991, 0.0000000000000000 },\n+  { 0.17439190872481269, 0.39999999999999991, 0.17453292519943295 },\n+  { 0.34795581767099210, 0.39999999999999991, 0.34906585039886590 },\n+  { 0.51995290683804474, 0.39999999999999991, 0.52359877559829882 },\n+  { 0.68981638464431549, 0.39999999999999991, 0.69813170079773179 },\n+  { 0.85722088859936041, 0.39999999999999991, 0.87266462599716477 },\n+  { 1.0221301327876993, 0.39999999999999991, 1.0471975511965976 },\n+  { 1.1848138019818373, 0.39999999999999991, 1.2217304763960306 },\n+  { 1.3458259266501531, 0.39999999999999991, 1.3962634015954636 },\n+  { 1.5059416123600404, 0.39999999999999991, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.39999999999999991.\n+template <typename Tp>\n+void test014()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data014)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data014[i].k), Tp(data014[i].phi));\n+      const Tp f0 = data014[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.50000000000000000.\n+testcase_ellint_2<double> data015[] = {\n+  { -0.0000000000000000, 0.50000000000000000, 0.0000000000000000 },\n+  { 0.17431249677315910, 0.50000000000000000, 0.17453292519943295 },\n+  { 0.34732862537770803, 0.50000000000000000, 0.34906585039886590 },\n+  { 0.51788193485993805, 0.50000000000000000, 0.52359877559829882 },\n+  { 0.68506022954164536, 0.50000000000000000, 0.69813170079773179 },\n+  { 0.84831662803347196, 0.50000000000000000, 0.87266462599716477 },\n+  { 1.0075555551444717, 0.50000000000000000, 1.0471975511965976 },\n+  { 1.1631768599287302, 0.50000000000000000, 1.2217304763960306 },\n+  { 1.3160584048772543, 0.50000000000000000, 1.3962634015954636 },\n+  { 1.4674622093394274, 0.50000000000000000, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.50000000000000000.\n+template <typename Tp>\n+void test015()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data015)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data015[i].k), Tp(data015[i].phi));\n+      const Tp f0 = data015[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+// Test data for k=0.60000000000000009.\n+testcase_ellint_2<double> data016[] = {\n+  { -0.0000000000000000, 0.60000000000000009, 0.0000000000000000 },\n+  { 0.17421534919599130, 0.60000000000000009, 0.17453292519943295 },\n+  { 0.34655927787174101, 0.60000000000000009, 0.34906585039886590 },\n+  { 0.51533034538432165, 0.60000000000000009, 0.52359877559829882 },\n+  { 0.67916550597453029, 0.60000000000000009, 0.69813170079773179 },\n+  { 0.83720218180349870, 0.60000000000000009, 0.87266462599716477 },\n+  { 0.98922159354937789, 0.60000000000000009, 1.0471975511965976 },\n+  { 1.1357478470419360, 0.60000000000000009, 1.2217304763960306 },\n+  { 1.2780617372844056, 0.60000000000000009, 1.3962634015954636 },\n+  { 1.4180833944487241, 0.60000000000000009, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.60000000000000009.\n+template <typename Tp>\n+void test016()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data016)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data016[i].k), Tp(data016[i].phi));\n+      const Tp f0 = data016[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for k=0.69999999999999996.\n+testcase_ellint_2<double> data017[] = {\n+  { -0.0000000000000000, 0.69999999999999996, 0.0000000000000000 },\n+  { 0.17410041242702540, 0.69999999999999996, 0.17453292519943295 },\n+  { 0.34564605085764760, 0.69999999999999996, 0.34906585039886590 },\n+  { 0.51228495693314657, 0.69999999999999996, 0.52359877559829882 },\n+  { 0.67207654098799530, 0.69999999999999996, 0.69813170079773179 },\n+  { 0.82370932631556515, 0.69999999999999996, 0.87266462599716477 },\n+  { 0.96672313309452795, 0.69999999999999996, 1.0471975511965976 },\n+  { 1.1017090644949503, 0.69999999999999996, 1.2217304763960306 },\n+  { 1.2304180097292916, 0.69999999999999996, 1.3962634015954636 },\n+  { 1.3556611355719557, 0.69999999999999996, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.69999999999999996.\n+template <typename Tp>\n+void test017()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data017)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data017[i].k), Tp(data017[i].phi));\n+      const Tp f0 = data017[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000039e-13));\n+}\n+\n+// Test data for k=0.80000000000000004.\n+testcase_ellint_2<double> data018[] = {\n+  { -0.0000000000000000, 0.80000000000000004, 0.0000000000000000 },\n+  { 0.17396762274534808, 0.80000000000000004, 0.17453292519943295 },\n+  { 0.34458685226969316, 0.80000000000000004, 0.34906585039886590 },\n+  { 0.50872923654502444, 0.80000000000000004, 0.52359877559829882 },\n+  { 0.66372016539176237, 0.80000000000000004, 0.69813170079773179 },\n+  { 0.80760344410167406, 0.80000000000000004, 0.87266462599716477 },\n+  { 0.93945480372495072, 0.80000000000000004, 1.0471975511965976 },\n+  { 1.0597473310395036, 0.80000000000000004, 1.2217304763960306 },\n+  { 1.1706981862452361, 0.80000000000000004, 1.3962634015954636 },\n+  { 1.2763499431699066, 0.80000000000000004, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.80000000000000004.\n+template <typename Tp>\n+void test018()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data018)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data018[i].k), Tp(data018[i].phi));\n+      const Tp f0 = data018[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(1.0000000000000008e-12));\n+}\n+\n+// Test data for k=0.89999999999999991.\n+testcase_ellint_2<double> data019[] = {\n+  { -0.0000000000000000, 0.89999999999999991, 0.0000000000000000 },\n+  { 0.17381690606167963, 0.89999999999999991, 0.17453292519943295 },\n+  { 0.34337919186972055, 0.89999999999999991, 0.34906585039886590 },\n+  { 0.50464268659856337, 0.89999999999999991, 0.52359877559829882 },\n+  { 0.65400003842368581, 0.89999999999999991, 0.69813170079773179 },\n+  { 0.78854928419904657, 0.89999999999999991, 0.87266462599716477 },\n+  { 0.90645698626315385, 0.89999999999999991, 1.0471975511965976 },\n+  { 1.0075154899135930, 0.89999999999999991, 1.2217304763960306 },\n+  { 1.0940135583194071, 0.89999999999999991, 1.3962634015954636 },\n+  { 1.1716970527816142, 0.89999999999999991, 1.5707963267948966 },\n+};\n+\n+// Test function for k=0.89999999999999991.\n+template <typename Tp>\n+void test019()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data019)\n+                         / sizeof(testcase_ellint_2<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::ellint_2(Tp(data019[i].k), Tp(data019[i].phi));\n+      const Tp f0 = data019[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(5.0000000000000029e-12));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  test002<double>();\n+  test003<double>();\n+  test004<double>();\n+  test005<double>();\n+  test006<double>();\n+  test007<double>();\n+  test008<double>();\n+  test009<double>();\n+  test010<double>();\n+  test011<double>();\n+  test012<double>();\n+  test013<double>();\n+  test014<double>();\n+  test015<double>();\n+  test016<double>();\n+  test017<double>();\n+  test018<double>();\n+  test019<double>();\n+  return 0;\n+}"}, {"sha": "0f4cf9793cb4e98b5934983ded5661e9dbfc1bd7", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.13 ellint_2\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, phil = std::atan2(1.0L, 1.0L);\n+\n+  std::tr1::ellint_2(kf, phif);\n+  std::tr1::ellint_2f(kf, phif);\n+  std::tr1::ellint_2(kd, phid);\n+  std::tr1::ellint_2(kl, phil);\n+  std::tr1::ellint_2l(kl, phil);\n+\n+  return;\n+}\n+"}, {"sha": "27dd739bc00215b0cfdad7c00d262810bef357e4", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/13_ellint_2/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F13_ellint_2%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.13 ellint_2\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, phil = std::atan2(1.0L, 1.0L);\n+\n+  ellint_2(kf, phif);\n+  ellint_2f(kf, phif);\n+  ellint_2(kd, phid);\n+  ellint_2(kl, phil);\n+  ellint_2l(kl, phil);\n+\n+  return;\n+}\n+"}, {"sha": "fcf2f680d941cd15293e4b1664dcff02ae4fc040", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_nan.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,126 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.13 ellint_3\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float kf = std::numeric_limits<float>::quiet_NaN();\n+  double kd = std::numeric_limits<double>::quiet_NaN();\n+  long double kl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float nuf = 0.2F;\n+  double nud = 0.2;\n+  long double nul = 0.2L;\n+\n+  float phif = std::atan2(1.0F, 1.0F);\n+  double phid = std::atan2(1.0, 1.0);\n+  long double phil = std::atan2(1.0L, 1.0L);\n+\n+  float a = std::tr1::ellint_3(kf, nuf, phif);\n+  float b = std::tr1::ellint_3f(kf, nuf, phif);\n+  double c = std::tr1::ellint_3(kd, nud, phid);\n+  long double d = std::tr1::ellint_3(kl, nul, phil);\n+  long double e = std::tr1::ellint_3l(kl, nul, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  float nuf = std::numeric_limits<float>::quiet_NaN();\n+  double nud = std::numeric_limits<double>::quiet_NaN();\n+  long double nul = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float phif = std::atan2(1.0F, 1.0F);\n+  double phid = std::atan2(1.0, 1.0);\n+  long double phil = std::atan2(1.0L, 1.0L);\n+\n+  float a = std::tr1::ellint_3(kf, nuf, phif);\n+  float b = std::tr1::ellint_3f(kf, nuf, phif);\n+  double c = std::tr1::ellint_3(kd, nud, phid);\n+  long double d = std::tr1::ellint_3(kl, nul, phil);\n+  long double e = std::tr1::ellint_3l(kl, nul, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test03()\n+{\n+  float kf = 0.5F;\n+  double kd = 0.5;\n+  long double kl = 0.5L;\n+\n+  float nuf = 0.2F;\n+  double nud = 0.2;\n+  long double nul = 0.2L;\n+\n+  float phif = std::numeric_limits<float>::quiet_NaN();\n+  double phid = std::numeric_limits<double>::quiet_NaN();\n+  long double phil = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::ellint_3(kf, nuf, phif);\n+  float b = std::tr1::ellint_3f(kf, nuf, phif);\n+  double c = std::tr1::ellint_3(kd, nud, phid);\n+  long double d = std::tr1::ellint_3(kl, nul, phil);\n+  long double e = std::tr1::ellint_3l(kl, nul, phil);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}\n+"}, {"sha": "a86771b3173487d4330f83f496cea524bde6df67", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc", "status": "added", "additions": 10116, "deletions": 0, "changes": 10116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "f988eaa081c66a82b1c8a869bc0edde741cf91d6", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.14 ellint_3\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, nuf = 0.2F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, nud = 0.2, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, nul = 0.2L, phil = std::atan2(1.0L, 1.0L);\n+\n+  std::tr1::ellint_3(kf, nuf, phif);\n+  std::tr1::ellint_3f(kf, nuf, phif);\n+  std::tr1::ellint_3(kd, nud, phid);\n+  std::tr1::ellint_3(kl, nul, phil);\n+  std::tr1::ellint_3l(kl, nul, phil);\n+\n+  return;\n+}\n+"}, {"sha": "49f0a70339c030630b12f2c225723d231923f03a", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F14_ellint_3%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.14 ellint_3\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float kf = 0.5F, nuf = 0.2F, phif = std::atan2(1.0F, 1.0F);\n+  double kd = 0.5, nud = 0.2, phid = std::atan2(1.0, 1.0);\n+  long double kl = 0.5L, nul = 0.2L, phil = std::atan2(1.0L, 1.0L);\n+\n+  ellint_3(kf, nuf, phif);\n+  ellint_3f(kf, nuf, phif);\n+  ellint_3(kd, nud, phid);\n+  ellint_3(kl, nul, phil);\n+  ellint_3l(kl, nul, phil);\n+\n+  return;\n+}\n+"}, {"sha": "f01caa05144b4bf0875c78ce998dcfbec082fb89", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/check_nan.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,57 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.15 expint\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::expint(xf);\n+  float b = std::tr1::expintf(xf);\n+  double c = std::tr1::expint(xd);\n+  long double d = std::tr1::expint(xl);\n+  long double e = std::tr1::expintl(xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "3aa239e15af714b257c7b615ded21740598182cb", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/check_value_neg.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_neg.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,128 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  expint\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data.\n+testcase_expint<double> data001[] = {\n+  { -3.7832640295504591e-24, -50.000000000000000 },\n+  { -1.0489811642368024e-23, -49.000000000000000 },\n+  { -2.9096641904058423e-23, -48.000000000000000 },\n+  { -8.0741978427258127e-23, -47.000000000000000 },\n+  { -2.2415317597442998e-22, -46.000000000000000 },\n+  { -6.2256908094623838e-22, -45.000000000000000 },\n+  { -1.7299598742816476e-21, -44.000000000000000 },\n+  { -4.8094965569500181e-21, -43.000000000000000 },\n+  { -1.3377908810011775e-20, -42.000000000000000 },\n+  { -3.7231667764599780e-20, -41.000000000000000 },\n+  { -1.0367732614516570e-19, -40.000000000000000 },\n+  { -2.8887793015227007e-19, -39.000000000000000 },\n+  { -8.0541069142907499e-19, -38.000000000000000 },\n+  { -2.2470206975885714e-18, -37.000000000000000 },\n+  { -6.2733390097622421e-18, -36.000000000000000 },\n+  { -1.7527059389947371e-17, -35.000000000000000 },\n+  { -4.9006761183927874e-17, -34.000000000000000 },\n+  { -1.3713843484487468e-16, -33.000000000000000 },\n+  { -3.8409618012250666e-16, -32.000000000000000 },\n+  { -1.0767670386162383e-15, -31.000000000000000 },\n+  { -3.0215520106888128e-15, -30.000000000000000 },\n+  { -8.4877597783535618e-15, -29.000000000000000 },\n+  { -2.3869415119337330e-14, -28.000000000000000 },\n+  { -6.7206374352620390e-14, -27.000000000000000 },\n+  { -1.8946858856749785e-13, -26.000000000000000 },\n+  { -5.3488997553402167e-13, -25.000000000000000 },\n+  { -1.5123058939997059e-12, -24.000000000000000 },\n+  { -4.2826847956656722e-12, -23.000000000000000 },\n+  { -1.2149378956204371e-11, -22.000000000000000 },\n+  { -3.4532012671467559e-11, -21.000000000000000 },\n+  { -9.8355252906498815e-11, -20.000000000000000 },\n+  { -2.8078290970607954e-10, -19.000000000000000 },\n+  { -8.0360903448286769e-10, -18.000000000000000 },\n+  { -2.3064319898216547e-09, -17.000000000000000 },\n+  { -6.6404872494410427e-09, -16.000000000000000 },\n+  { -1.9186278921478670e-08, -15.000000000000000 },\n+  { -5.5656311111451816e-08, -14.000000000000000 },\n+  { -1.6218662188014328e-07, -13.000000000000000 },\n+  { -4.7510818246724931e-07, -12.000000000000000 },\n+  { -1.4003003042474418e-06, -11.000000000000000 },\n+  { -4.1569689296853246e-06, -10.000000000000000 },\n+  { -1.2447354178006272e-05, -9.0000000000000000 },\n+  { -3.7665622843924906e-05, -8.0000000000000000 },\n+  { -0.00011548173161033820, -7.0000000000000000 },\n+  { -0.00036008245216265867, -6.0000000000000000 },\n+  { -0.0011482955912753257, -5.0000000000000000 },\n+  { -0.0037793524098489058, -4.0000000000000000 },\n+  { -0.013048381094197037, -3.0000000000000000 },\n+  { -0.048900510708061125, -2.0000000000000000 },\n+  { -0.21938393439552029, -1.0000000000000000 },\n+};\n+\n+// Test function.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_expint<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::expint(Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  return 0;\n+}"}, {"sha": "1b9e7fba2d0daf3cbb2a1bcce8ae3e009c99585e", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/check_value_pos.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_pos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_pos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcheck_value_pos.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,128 @@\n+// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+//  expint\n+\n+\n+//  Compare against values generated by the GNU Scientific Library.\n+//  The GSL can be found on the web: http://www.gnu.org/software/gsl/\n+\n+#include <tr1/cmath>\n+#if defined(__TEST_DEBUG)\n+#include <iostream>\n+#define VERIFY(A) \\\n+if (!(A)) \\\n+  { \\\n+    std::cout << \"line \" << __LINE__ \\\n+      << \"  max_abs_frac = \" << max_abs_frac \\\n+      << std::endl; \\\n+  }\n+#else\n+#include <testsuite_hooks.h>\n+#endif\n+#include \"../testcase.h\"\n+\n+\n+// Test data.\n+testcase_expint<double> data001[] = {\n+  { 1.8951178163559366, 1.0000000000000000 },\n+  { 4.9542343560018907, 2.0000000000000000 },\n+  { 9.9338325706254160, 3.0000000000000000 },\n+  { 19.630874470056217, 4.0000000000000000 },\n+  { 40.185275355803178, 5.0000000000000000 },\n+  { 85.989762142439204, 6.0000000000000000 },\n+  { 191.50474333550139, 7.0000000000000000 },\n+  { 440.37989953483827, 8.0000000000000000 },\n+  { 1037.8782907170896, 9.0000000000000000 },\n+  { 2492.2289762418782, 10.000000000000000 },\n+  { 6071.4063740986112, 11.000000000000000 },\n+  { 14959.532666397527, 12.000000000000000 },\n+  { 37197.688490689041, 13.000000000000000 },\n+  { 93192.513633965369, 14.000000000000000 },\n+  { 234955.85249076830, 15.000000000000000 },\n+  { 595560.99867083703, 16.000000000000000 },\n+  { 1516637.8940425171, 17.000000000000000 },\n+  { 3877904.3305974435, 18.000000000000000 },\n+  { 9950907.2510468438, 19.000000000000000 },\n+  { 25615652.664056588, 20.000000000000000 },\n+  { 66127186.355484918, 21.000000000000000 },\n+  { 171144671.30036369, 22.000000000000000 },\n+  { 443966369.83027118, 23.000000000000000 },\n+  { 1154115391.8491828, 24.000000000000000 },\n+  { 3005950906.5255489, 25.000000000000000 },\n+  { 7842940991.8981876, 26.000000000000000 },\n+  { 20496497119.880810, 27.000000000000000 },\n+  { 53645118592.314682, 28.000000000000000 },\n+  { 140599195758.40689, 29.000000000000000 },\n+  { 368973209407.27423, 30.000000000000000 },\n+  { 969455575968.39392, 31.000000000000000 },\n+  { 2550043566357.7866, 32.000000000000000 },\n+  { 6714640184076.4980, 33.000000000000000 },\n+  { 17698037244116.266, 34.000000000000000 },\n+  { 46690550144661.594, 35.000000000000000 },\n+  { 123285207991209.75, 36.000000000000000 },\n+  { 325798899867226.44, 37.000000000000000 },\n+  { 861638819996578.62, 38.000000000000000 },\n+  { 2280446200301902.5, 39.000000000000000 },\n+  { 6039718263611242.0, 40.000000000000000 },\n+  { 16006649143245042., 41.000000000000000 },\n+  { 42447960921368504., 42.000000000000000 },\n+  { 1.1263482901669667e+17, 43.000000000000000 },\n+  { 2.9904447186323366e+17, 44.000000000000000 },\n+  { 7.9439160357044531e+17, 45.000000000000000 },\n+  { 2.1113423886478239e+18, 46.000000000000000 },\n+  { 5.6143296808103434e+18, 47.000000000000000 },\n+  { 1.4936302131129930e+19, 48.000000000000000 },\n+  { 3.9754427479037444e+19, 49.000000000000000 },\n+  { 1.0585636897131690e+20, 50.000000000000000 },\n+};\n+\n+// Test function.\n+template <typename Tp>\n+void test001()\n+{\n+  const Tp eps = std::numeric_limits<Tp>::epsilon();\n+  Tp max_abs_diff = -Tp(1);\n+  Tp max_abs_frac = -Tp(1);\n+  unsigned int num_datum = sizeof(data001)\n+                         / sizeof(testcase_expint<double>);\n+  for (unsigned int i = 0; i < num_datum; ++i)\n+    {\n+      const Tp f = std::tr1::expint(Tp(data001[i].x));\n+      const Tp f0 = data001[i].f0;\n+      const Tp diff = f - f0;\n+      if (std::abs(diff) > max_abs_diff)\n+        max_abs_diff = std::abs(diff);\n+      if (std::abs(f0) > Tp(10) * eps\n+       && std::abs(f) > Tp(10) * eps)\n+        {\n+          const Tp frac = diff / f0;\n+          if (std::abs(frac) > max_abs_frac)\n+            max_abs_frac = std::abs(frac);\n+        }\n+    }\n+  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));\n+}\n+\n+int main(int, char**)\n+{\n+  test001<double>();\n+  return 0;\n+}"}, {"sha": "17f5a76649bf7eb82e30d4c3978d220f6c6c25bf", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.15 expint\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  std::tr1::expint(xf);\n+  std::tr1::expintf(xf);\n+  std::tr1::expint(xd);\n+  std::tr1::expint(xl);\n+  std::tr1::expintl(xl);\n+\n+  return;\n+}\n+"}, {"sha": "901aa9fbc765b5ee0479b637205763852ace1e26", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F15_expint%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.15 expint\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  expint(xf);\n+  expintf(xf);\n+  expint(xd);\n+  expint(xl);\n+  expintl(xl);\n+\n+  return;\n+}\n+"}, {"sha": "8d06a964d793f8c94eaa4087248d7003db57df01", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/check_nan.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,59 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.4 hermite\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  unsigned int n = 5;\n+\n+  float a = std::tr1::hermite(n, xf);\n+  float b = std::tr1::hermitef(n, xf);\n+  double c = std::tr1::hermite(n, xd);\n+  long double d = std::tr1::hermite(n, xl);\n+  long double e = std::tr1::hermitel(n, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+"}, {"sha": "ac6484ba8d19075faecf5f4aa53d3ee336ef8e56", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/compile.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.16 hermite\n+\n+#include <tr1/cmath>\n+\n+void\n+test01()\n+{\n+  float xf = 2.5F;\n+  double xd = 2.5;\n+  long double xl = 2.5L;\n+\n+  unsigned int n = 5;\n+\n+  std::tr1::hermite(n, xf);\n+  std::tr1::hermitef(n, xf);\n+  std::tr1::hermite(n, xd);\n+  std::tr1::hermite(n, xl);\n+  std::tr1::hermitel(n, xl);\n+\n+  return;\n+}\n+"}, {"sha": "301b5df8d930796c4292e91e53e89def748d6cab", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/16_hermite/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F16_hermite%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+\n+// 2006-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2006-2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.16 hermite\n+\n+#include <tr1/math.h>\n+\n+void\n+test01()\n+{\n+  float xf = 2.5F;\n+  double xd = 2.5;\n+  long double xl = 2.5L;\n+  unsigned int n = 5;\n+\n+  hermite(n, xf);\n+  hermitef(n, xf);\n+  hermite(n, xd);\n+  hermite(n, xl);\n+  hermitel(n, xl);\n+\n+  return;\n+}\n+"}, {"sha": "e120e520355924d081acdf4a090be66551eea456", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/check_nan.cc", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be", "patch": "@@ -0,0 +1,173 @@\n+// { dg-require-c-std \"\" }\n+\n+// 2007-01-10  Edward Smith-Rowland <3dw4rd@verizon.net>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 5.2.1.17 hyperg\n+\n+#include <tr1/cmath>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  float af = std::numeric_limits<float>::quiet_NaN();\n+  double ad = std::numeric_limits<double>::quiet_NaN();\n+  long double al = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float bf = 10.0F;\n+  double bd = 10.0;\n+  long double bl = 10.0L;\n+\n+  float cf = 3.0F;\n+  double cd = 3.0;\n+  long double cl = 3.0L;\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  float a = std::tr1::hyperg(af, bf, cf, xf);\n+  float b = std::tr1::hypergf(af, bf, cf, xf);\n+  double c = std::tr1::hyperg(ad, bd, cd, xd);\n+  long double d = std::tr1::hyperg(al, bl, cl, xl);\n+  long double e = std::tr1::hypergl(al, bl, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test02()\n+{\n+  float af = 2.0F;\n+  double ad = 2.0;\n+  long double al = 2.0L;\n+\n+  float bf = std::numeric_limits<float>::quiet_NaN();\n+  double bd = std::numeric_limits<double>::quiet_NaN();\n+  long double bl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float cf = 3.0F;\n+  double cd = 3.0;\n+  long double cl = 3.0L;\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  float a = std::tr1::hyperg(af, bf, cf, xf);\n+  float b = std::tr1::hypergf(af, bf, cf, xf);\n+  double c = std::tr1::hyperg(ad, bd, cd, xd);\n+  long double d = std::tr1::hyperg(al, bl, cl, xl);\n+  long double e = std::tr1::hypergl(al, bl, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test03()\n+{\n+  float af = 2.0F;\n+  double ad = 2.0;\n+  long double al = 2.0L;\n+\n+  float bf = 10.0F;\n+  double bd = 10.0;\n+  long double bl = 10.0L;\n+\n+  float cf = std::numeric_limits<float>::quiet_NaN();\n+  double cd = std::numeric_limits<double>::quiet_NaN();\n+  long double cl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float xf = 0.5F;\n+  double xd = 0.5;\n+  long double xl = 0.5L;\n+\n+  float a = std::tr1::hyperg(af, bf, cf, xf);\n+  float b = std::tr1::hypergf(af, bf, cf, xf);\n+  double c = std::tr1::hyperg(ad, bd, cd, xd);\n+  long double d = std::tr1::hyperg(al, bl, cl, xl);\n+  long double e = std::tr1::hypergl(al, bl, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+void\n+test04()\n+{\n+  float af = 2.0F;\n+  double ad = 2.0;\n+  long double al = 2.0L;\n+\n+  float bf = 10.0F;\n+  double bd = 10.0;\n+  long double bl = 10.0L;\n+\n+  float cf = 3.0F;\n+  double cd = 3.0;\n+  long double cl = 3.0L;\n+\n+  float xf = std::numeric_limits<float>::quiet_NaN();\n+  double xd = std::numeric_limits<double>::quiet_NaN();\n+  long double xl = std::numeric_limits<long double>::quiet_NaN();\n+\n+  float a = std::tr1::hyperg(af, bf, cf, xf);\n+  float b = std::tr1::hypergf(af, bf, cf, xf);\n+  double c = std::tr1::hyperg(ad, bd, cd, xd);\n+  long double d = std::tr1::hyperg(al, bl, cl, xl);\n+  long double e = std::tr1::hypergl(al, bl, cl, xl);\n+\n+  VERIFY(std::tr1::isnan<float>(a));\n+  VERIFY(std::tr1::isnan<float>(b));\n+  VERIFY(std::tr1::isnan<double>(c));\n+  VERIFY(std::tr1::isnan<long double>(d));\n+  VERIFY(std::tr1::isnan<long double>(e));\n+\n+  return;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}\n+"}, {"sha": "d453b19b8e04ed9dd6506f7a5de20023704e43a5", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/check_value.cc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "3c322af3e1f0953b64fc1ea5dc4900b4f8fae33f", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "fe51de72ce7ce1a10e9256e9232171a834c906c4", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/17_hyperg/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F17_hyperg%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "121a4528d06d5ab844a39c7e17a430e431d02d4c", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/check_nan.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "ceef9d17119439df586a39a04fa3f61596450bb8", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/check_value.cc", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "750724cf0d0cef75719b0865a6981b356ae676c3", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/compile.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "157cc29649cafbbd5e628994426b368f3131c7e4", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/18_laguerre/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F18_laguerre%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "e051b3cadffcae234fd364d10a62653210df9ae4", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/check_nan.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "dd70e0bd73695097a10832cd48951738615e8ad9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/check_value.cc", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "c00cca67361f4aa065c48fa8c96901bcee6c1649", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/compile.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "f69dfa32543ae9d84c38c52f501e7e8badfe90c9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/19_legendre/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F19_legendre%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "bdfa2e9af18afd3976dfcf0facf68549b44185c8", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/20_riemann_zeta/check_nan.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "2a86846ea4ae6d69fac39eab79b34209a21e06a0", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/20_riemann_zeta/check_value_neg.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_neg.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "3188c334f5bf50c3a089008dcbb2a4526f614a69", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/20_riemann_zeta/check_value_pos.cc", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_pos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_pos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcheck_value_pos.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "9e39e03468be61fff5ac68f0b27709c206a09d54", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/20_riemann_zeta/compile.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "60e2667b1ec410e1782a767353ee8f3349e18cd3", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/20_riemann_zeta/compile_2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F20_riemann_zeta%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "2b856742d0ec8713cbc175fcac0de71c6a0b71fd", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/21_sph_bessel/check_nan.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "939d641a3bf0e079c60daa5cd39eea8003933ec2", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/21_sph_bessel/check_value.cc", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "fdc66905f262162fe63cbe83c42be4aff29962b1", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/21_sph_bessel/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "c98dee75746bc1b5acdf5c80bc486520fac062f9", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/21_sph_bessel/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F21_sph_bessel%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "e8bbfff188fea05cd6471e63b008b8aa73e8244f", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/22_sph_legendre/check_nan.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "40433666e4cf50bd4d7c07ee059015edef413d21", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/22_sph_legendre/check_value.cc", "status": "added", "additions": 2746, "deletions": 0, "changes": 2746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "9e6be450dff6a98febd53356bc313f10fc7e831c", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/22_sph_legendre/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "177e6205b1c10ab47c61779c6bb8d901cad8600f", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/22_sph_legendre/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F22_sph_legendre%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "17f8ca6b0acb115971acf6df9ab48914332916a8", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/23_sph_neumann/check_nan.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_nan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_nan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_nan.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "e399323f1a772bebe7e1f71cba94a8a073c8cefa", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/23_sph_neumann/check_value.cc", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcheck_value.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "7a26872203e3f21b1419acf5b8b76b5502384536", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/23_sph_neumann/compile.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "f9428c256e3e4d95f2f41909ab9c62789f312559", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/23_sph_neumann/compile_2.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2F23_sph_neumann%2Fcompile_2.cc?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}, {"sha": "8c5aa829946014c961396e659f6fa7019fa2ad56", "filename": "libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/testcase.h", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2Ftestcase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c62b943baf5ef56622033f55a8eb9458e3d18be/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2Ftestcase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F5_numerical_facilities%2Fspecial_functions%2Ftestcase.h?ref=7c62b943baf5ef56622033f55a8eb9458e3d18be"}]}