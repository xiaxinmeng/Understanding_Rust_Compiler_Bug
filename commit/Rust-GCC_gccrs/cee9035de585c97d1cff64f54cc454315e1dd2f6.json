{"sha": "cee9035de585c97d1cff64f54cc454315e1dd2f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlOTAzNWRlNTg1Yzk3ZDFjZmY2NGY1NGNjNDU0MzE1ZTFkZDJmNg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-01-14T13:00:21Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-01-14T13:00:21Z"}, "message": "re PR c++/37862 (Parenthesised indirection alters class member access)\n\n        PR c++/37862\n        * parser.c: Pass cp_id_kind computed in\n        cp_parser_postfix_dot_deref_expression to\n        cp_parser_primary_expression.\n\n        * g++.cp/parse/pr37862.C: New test.\n\nFrom-SVN: r143369", "tree": {"sha": "b6a98eb8122abe24e77e3961c271a00b815aa8c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6a98eb8122abe24e77e3961c271a00b815aa8c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee9035de585c97d1cff64f54cc454315e1dd2f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee9035de585c97d1cff64f54cc454315e1dd2f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee9035de585c97d1cff64f54cc454315e1dd2f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee9035de585c97d1cff64f54cc454315e1dd2f6/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e04a57df1b19e2ae511f354a09552ac5e170a9a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04a57df1b19e2ae511f354a09552ac5e170a9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04a57df1b19e2ae511f354a09552ac5e170a9a3"}], "stats": {"total": 172, "additions": 110, "deletions": 62}, "files": [{"sha": "da52022eea1cec624be1dfb1fe8a928162446bb4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cee9035de585c97d1cff64f54cc454315e1dd2f6", "patch": "@@ -1,3 +1,10 @@\n+2009-01-14  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR c++/37862\n+\t* parser.c: Pass cp_id_kind computed in\n+\tcp_parser_postfix_dot_deref_expression to\n+\tcp_parser_primary_expression.\n+\n 2009-01-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/38795"}, {"sha": "526a9a3acefbf3895a75484f790fd2344eccd1a6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cee9035de585c97d1cff64f54cc454315e1dd2f6", "patch": "@@ -1586,7 +1586,7 @@ static tree cp_parser_nested_name_specifier\n static tree cp_parser_qualifying_entity\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n-  (cp_parser *, bool, bool, bool);\n+  (cp_parser *, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n@@ -1596,7 +1596,7 @@ static tree cp_parser_parenthesized_expression_list\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, cp_id_kind *);\n static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n static tree cp_parser_new_expression\n@@ -1614,17 +1614,17 @@ static tree cp_parser_new_initializer\n static tree cp_parser_delete_expression\n   (cp_parser *);\n static tree cp_parser_cast_expression\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, cp_id_kind *);\n static tree cp_parser_binary_expression\n-  (cp_parser *, bool, enum cp_parser_prec);\n+  (cp_parser *, bool, enum cp_parser_prec, cp_id_kind *);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, cp_id_kind *);\n static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n static tree cp_parser_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, cp_id_kind *);\n static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n static tree cp_parser_builtin_offsetof\n@@ -3251,7 +3251,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \telse\n \t  {\n \t    /* Parse the parenthesized expression.  */\n-\t    expr = cp_parser_expression (parser, cast_p);\n+\t    expr = cp_parser_expression (parser, cast_p, idk);\n \t    /* Let the front end know that this expression was\n \t       enclosed in parentheses. This matters in case, for\n \t       example, the expression is of the form `A::B', since\n@@ -3354,7 +3354,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t    /* Now, parse the assignment-expression.  */\n \t    expression = cp_parser_assignment_expression (parser,\n-\t\t\t\t\t\t\t  /*cast_p=*/false);\n+\t\t\t\t\t\t\t  /*cast_p=*/false, NULL);\n \t    /* Look for the `,'.  */\n \t    cp_parser_require (parser, CPP_COMMA, \"%<,%>\");\n \t    /* Parse the type-id.  */\n@@ -4399,7 +4399,8 @@ cp_parser_qualifying_entity (cp_parser *parser,\n \n static tree\n cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n-                              bool member_access_only_p)\n+                              bool member_access_only_p,\n+\t\t\t      cp_id_kind * pidk_return)\n {\n   cp_token *token;\n   enum rid keyword;\n@@ -4443,7 +4444,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n \t/* And the expression which is being cast.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n-\texpression = cp_parser_expression (parser, /*cast_p=*/true);\n+\texpression = cp_parser_expression (parser, /*cast_p=*/true, & idk);\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n \t/* Only type conversions to integral or enumeration types\n@@ -4515,7 +4516,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    tree expression;\n \n \t    /* Look for an expression.  */\n-\t    expression = cp_parser_expression (parser, /*cast_p=*/false);\n+\t    expression = cp_parser_expression (parser, /*cast_p=*/false, & idk);\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression);\n \t    /* Look for the `)' token.  */\n@@ -4767,13 +4768,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t  }\n \n \t\tif (BASELINK_P (fn))\n+\t\t  {\n \t\t  postfix_expression\n \t\t    = (build_new_method_call\n \t\t       (instance, fn, args, NULL_TREE,\n \t\t\t(idk == CP_ID_KIND_QUALIFIED\n \t\t\t ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL),\n \t\t\t/*fn_p=*/NULL,\n \t\t\ttf_warning_or_error));\n+\t\t  }\n \t\telse\n \t\t  postfix_expression\n \t\t    = finish_call_expr (postfix_expression, args,\n@@ -4862,6 +4865,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  break;\n \n \tdefault:\n+\t  if (pidk_return != NULL)\n+\t    * pidk_return = idk;\n           if (member_access_only_p)\n             return is_member_access? postfix_expression : error_mark_node;\n           else\n@@ -4903,7 +4908,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n   if (for_offsetof)\n     index = cp_parser_constant_expression (parser, false, NULL);\n   else\n-    index = cp_parser_expression (parser, /*cast_p=*/false);\n+    index = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \n   /* Look for the closing `]'.  */\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, \"%<]%>\");\n@@ -4956,6 +4961,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n   parser->qualifying_scope = NULL_TREE;\n   parser->object_scope = NULL_TREE;\n   *idk = CP_ID_KIND_NONE;\n+\n   /* Enter the scope corresponding to the type of the object\n      given by the POSTFIX_EXPRESSION.  */\n   if (!dependent_p && TREE_TYPE (postfix_expression) != NULL_TREE)\n@@ -5185,7 +5191,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t  *non_constant_p = true;\n \t      }\n \t    else\n-\t      expr = cp_parser_assignment_expression (parser, cast_p);\n+\t      expr = cp_parser_assignment_expression (parser, cast_p, NULL);\n \n \t    if (fold_expr_p)\n \t      expr = fold_non_dependent_expr (expr);\n@@ -5369,7 +5375,8 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n+cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n+\t\t\t    cp_id_kind * pidk)\n {\n   cp_token *token;\n   enum tree_code unary_operator;\n@@ -5506,7 +5513,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n       cast_expression\n \t= cp_parser_cast_expression (parser,\n \t\t\t\t     unary_operator == ADDR_EXPR,\n-\t\t\t\t     /*cast_p=*/false);\n+\t\t\t\t     /*cast_p=*/false, pidk);\n       /* Now, build an appropriate representation.  */\n       switch (unary_operator)\n \t{\n@@ -5548,7 +5555,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n     }\n \n   return cp_parser_postfix_expression (parser, address_p, cast_p,\n-                                       /*member_access_only_p=*/false);\n+                                       /*member_access_only_p=*/false,\n+\t\t\t\t       pidk);\n }\n \n /* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a\n@@ -5813,7 +5821,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       if (!declarator)\n \t{\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n+\t  expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \t  /* The standard requires that the expression have integral\n \t     type.  DR 74 adds enumeration types.  We believe that the\n \t     real intent is that these expressions be handled like the\n@@ -6001,7 +6009,8 @@ cp_parser_token_starts_cast_expression (cp_token *token)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n+cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n+\t\t\t   cp_id_kind * pidk)\n {\n   /* If it's a `(', then we might be looking at a cast.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -6076,7 +6085,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t  cp_parser_parse_definitely (parser);\n \t  expr = cp_parser_cast_expression (parser,\n \t\t\t\t\t    /*address_p=*/false,\n-\t\t\t\t\t    /*cast_p=*/true);\n+\t\t\t\t\t    /*cast_p=*/true, pidk);\n \n \t  /* Warn about old-style casts, if so requested.  */\n \t  if (warn_old_style_cast\n@@ -6104,7 +6113,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \n   /* If we get here, then it's not a cast, so it must be a\n      unary-expression.  */\n-  return cp_parser_unary_expression (parser, address_p, cast_p);\n+  return cp_parser_unary_expression (parser, address_p, cast_p, pidk);\n }\n \n /* Parse a binary expression of the general form:\n@@ -6188,7 +6197,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \n static tree\n cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n-\t\t\t     enum cp_parser_prec prec)\n+\t\t\t     enum cp_parser_prec prec,\n+\t\t\t     cp_id_kind * pidk)\n {\n   cp_parser_expression_stack stack;\n   cp_parser_expression_stack_entry *sp = &stack[0];\n@@ -6199,7 +6209,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n   bool overloaded_p;\n \n   /* Parse the first expression.  */\n-  lhs = cp_parser_cast_expression (parser, /*address_p=*/false, cast_p);\n+  lhs = cp_parser_cast_expression (parser, /*address_p=*/false, cast_p, pidk);\n   lhs_type = ERROR_MARK;\n \n   for (;;)\n@@ -6340,12 +6350,12 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n     expr = NULL_TREE;\n   else\n     /* Parse the expression.  */\n-    expr = cp_parser_expression (parser, /*cast_p=*/false);\n+    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \n   /* The next token should be a `:'.  */\n   cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n   /* Parse the assignment-expression.  */\n-  assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n+  assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n \n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (logical_or_expr,\n@@ -6366,7 +6376,8 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n    Returns a representation for the expression.  */\n \n static tree\n-cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n+cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n+\t\t\t\t cp_id_kind * pidk)\n {\n   tree expr;\n \n@@ -6379,7 +6390,7 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n   else\n     {\n       /* Parse the binary expressions (logical-or-expression).  */\n-      expr = cp_parser_binary_expression (parser, cast_p, PREC_NOT_OPERATOR);\n+      expr = cp_parser_binary_expression (parser, cast_p, PREC_NOT_OPERATOR, pidk);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n@@ -6514,7 +6525,7 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_expression (cp_parser* parser, bool cast_p)\n+cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n {\n   tree expression = NULL_TREE;\n \n@@ -6524,7 +6535,7 @@ cp_parser_expression (cp_parser* parser, bool cast_p)\n \n       /* Parse the next assignment-expression.  */\n       assignment_expression\n-\t= cp_parser_assignment_expression (parser, cast_p);\n+\t= cp_parser_assignment_expression (parser, cast_p, pidk);\n       /* If this is the first assignment-expression, we can just\n \t save it away.  */\n       if (!expression)\n@@ -6603,7 +6614,7 @@ cp_parser_constant_expression (cp_parser* parser,\n      For example, cp_parser_initializer_clauses uses this function to\n      determine whether a particular assignment-expression is in fact\n      constant.  */\n-  expression = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n+  expression = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n   /* Restore the old settings.  */\n   parser->integral_constant_expression_p\n     = saved_integral_constant_expression_p;\n@@ -7086,7 +7097,7 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n   /* If the next token is a ';', then there is no expression\n      statement.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    statement = cp_parser_expression (parser, /*cast_p=*/false);\n+    statement = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \n   /* Consume the final `;'.  */\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n@@ -7454,7 +7465,7 @@ cp_parser_condition (cp_parser* parser)\n     cp_parser_abort_tentative_parse (parser);\n \n   /* Otherwise, we are looking at an expression.  */\n-  return cp_parser_expression (parser, /*cast_p=*/false);\n+  return cp_parser_expression (parser, /*cast_p=*/false, NULL);\n }\n \n /* Parse an iteration-statement.\n@@ -7526,7 +7537,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Look for the `('.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n \t/* Parse the expression.  */\n-\texpression = cp_parser_expression (parser, /*cast_p=*/false);\n+\texpression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement);\n \t/* Look for the `)'.  */\n@@ -7558,7 +7569,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \n \t/* If there's an expression, process it.  */\n \tif (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n+\t  expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \tfinish_for_expr (expression, statement);\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n@@ -7699,7 +7710,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t    expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n \t  }\n \telse if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t  expr = cp_parser_expression (parser, /*cast_p=*/false);\n+\t  expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \telse\n \t  /* If the next token is a `;', then there is no\n \t     expression.  */\n@@ -7720,7 +7731,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n-\t  finish_goto_stmt (cp_parser_expression (parser, /*cast_p=*/false));\n+\t  finish_goto_stmt (cp_parser_expression (parser, /*cast_p=*/false, NULL));\n \t}\n       else\n \tfinish_goto_stmt (cp_parser_identifier (parser));\n@@ -8857,7 +8868,7 @@ cp_parser_decltype (cp_parser *parser)\n       /* Parse a class member access.  */\n       expr = cp_parser_postfix_expression (parser, /*address_p=*/false,\n                                            /*cast_p=*/false,\n-                                           /*member_access_only_p=*/true);\n+                                           /*member_access_only_p=*/true, NULL);\n \n       if (expr \n           && expr != error_mark_node\n@@ -8876,7 +8887,7 @@ cp_parser_decltype (cp_parser *parser)\n       cp_parser_abort_tentative_parse (parser);\n \n       /* Parse a full expression.  */\n-      expr = cp_parser_expression (parser, /*cast_p=*/false);\n+      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n     }\n \n   /* Go back to evaluating expressions.  */\n@@ -14424,7 +14435,7 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n   if (template_parm_p)\n     push_deferring_access_checks (dk_no_deferred);\n   default_argument\n-    = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n+    = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n   if (template_parm_p)\n     pop_deferring_access_checks ();\n   /* Restore saved state.  */\n@@ -16512,7 +16523,7 @@ cp_parser_throw_expression (cp_parser* parser)\n     expression = NULL_TREE;\n   else\n     expression = cp_parser_assignment_expression (parser,\n-\t\t\t\t\t\t  /*cast_p=*/false);\n+\t\t\t\t\t\t  /*cast_p=*/false, NULL);\n \n   return build_throw (expression);\n }\n@@ -16604,7 +16615,7 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       /* Look for the `('.  */\n       cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n       /* Parse the expression.  */\n-      expression = cp_parser_expression (parser, /*cast_p=*/false);\n+      expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n       /* Look for the `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n@@ -17875,7 +17886,7 @@ static tree\n cp_parser_simple_cast_expression (cp_parser *parser)\n {\n   return cp_parser_cast_expression (parser, /*address_p=*/false,\n-\t\t\t\t    /*cast_p=*/false);\n+\t\t\t\t    /*cast_p=*/false, NULL);\n }\n \n /* Parse a functional cast to TYPE.  Returns an expression\n@@ -18241,7 +18252,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       cp_parser_push_lexer_for_tokens (parser, tokens);\n \n       /* Parse the assignment-expression.  */\n-      parsed_arg = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n+      parsed_arg = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n \n       if (!processing_template_decl)\n \tparsed_arg = check_default_argument (TREE_VALUE (parm), parsed_arg);\n@@ -18362,7 +18373,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n      looking at the unary-expression production.  */\n   if (!expr)\n     expr = cp_parser_unary_expression (parser, /*address_p=*/false,\n-\t\t\t\t       /*cast_p=*/false);\n+\t\t\t\t       /*cast_p=*/false, NULL);\n \n   if (pack_expansion_p)\n     /* Build a pack expansion. */\n@@ -19090,7 +19101,7 @@ cp_parser_objc_message_receiver (cp_parser* parser)\n   /* An Objective-C message receiver may be either (1) a type\n      or (2) an expression.  */\n   cp_parser_parse_tentatively (parser);\n-  rcv = cp_parser_expression (parser, false);\n+  rcv = cp_parser_expression (parser, false, NULL);\n \n   if (cp_parser_parse_definitely (parser))\n     return rcv;\n@@ -19142,7 +19153,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n \n       maybe_unary_selector_p = false;\n       cp_parser_require (parser, CPP_COLON, \"%<:%>\");\n-      arg = cp_parser_assignment_expression (parser, false);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n \n       sel_args\n \t= chainon (sel_args,\n@@ -19157,7 +19168,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n       tree arg;\n \n       cp_lexer_consume_token (parser->lexer);\n-      arg = cp_parser_assignment_expression (parser, false);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n \n       addl_args\n \t= chainon (addl_args,\n@@ -20057,7 +20068,7 @@ cp_parser_objc_synchronized_statement (cp_parser *parser) {\n \n   location = cp_lexer_peek_token (parser->lexer)->location;\n   cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n-  lock = cp_parser_expression (parser, false);\n+  lock = cp_parser_expression (parser, false, NULL);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n@@ -20082,7 +20093,7 @@ cp_parser_objc_throw_statement (cp_parser *parser) {\n   cp_parser_require_keyword (parser, RID_AT_THROW, \"%<@throw%>\");\n \n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    expr = cp_parser_assignment_expression (parser, false);\n+    expr = cp_parser_assignment_expression (parser, false, NULL);\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n@@ -20439,7 +20450,7 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n \n-  t = cp_parser_expression (parser, false);\n+  t = cp_parser_expression (parser, false, NULL);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n@@ -20596,7 +20607,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n       cp_lexer_consume_token (parser->lexer);\n \n       token = cp_lexer_peek_token (parser->lexer);\n-      t = cp_parser_assignment_expression (parser, false);\n+      t = cp_parser_assignment_expression (parser, false, NULL);\n \n       if (t == error_mark_node)\n \tgoto resync_fail;\n@@ -20825,7 +20836,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n   lhs = cp_parser_unary_expression (parser, /*address_p=*/false,\n-\t\t\t\t    /*cast_p=*/false);\n+\t\t\t\t    /*cast_p=*/false, NULL);\n   switch (TREE_CODE (lhs))\n     {\n     case ERROR_MARK:\n@@ -20882,7 +20893,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n \t}\n       cp_lexer_consume_token (parser->lexer);\n \n-      rhs = cp_parser_expression (parser, false);\n+      rhs = cp_parser_expression (parser, false, NULL);\n       if (rhs == error_mark_node)\n \tgoto saw_error;\n       break;\n@@ -20956,7 +20967,7 @@ cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n static tree\n cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n {\n-  tree lhs = cp_parser_cast_expression (parser, false, false), rhs;\n+  tree lhs = cp_parser_cast_expression (parser, false, false, NULL), rhs;\n   enum tree_code op;\n   cp_token *token;\n \n@@ -20982,7 +20993,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n \n   cp_lexer_consume_token (parser->lexer);\n   rhs = cp_parser_binary_expression (parser, false,\n-\t\t\t\t     PREC_RELATIONAL_EXPRESSION);\n+\t\t\t\t     PREC_RELATIONAL_EXPRESSION, NULL);\n   if (rhs == error_mark_node\n       || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n@@ -21009,7 +21020,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n       op = (token->type == CPP_PLUS_PLUS\n \t    ? PREINCREMENT_EXPR : PREDECREMENT_EXPR);\n       cp_lexer_consume_token (parser->lexer);\n-      lhs = cp_parser_cast_expression (parser, false, false);\n+      lhs = cp_parser_cast_expression (parser, false, false, NULL);\n       if (lhs != decl)\n \treturn error_mark_node;\n       return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);\n@@ -21034,13 +21045,13 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \n   if (op != NOP_EXPR)\n     {\n-      rhs = cp_parser_assignment_expression (parser, false);\n+      rhs = cp_parser_assignment_expression (parser, false, NULL);\n       rhs = build2 (op, TREE_TYPE (decl), decl, rhs);\n       return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n     }\n \n   lhs = cp_parser_binary_expression (parser, false,\n-\t\t\t\t     PREC_ADDITIVE_EXPRESSION);\n+\t\t\t\t     PREC_ADDITIVE_EXPRESSION, NULL);\n   token = cp_lexer_peek_token (parser->lexer);\n   decl_first = lhs == decl;\n   if (decl_first)\n@@ -21054,7 +21065,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n       op = token->type == CPP_PLUS ? PLUS_EXPR : MINUS_EXPR;\n       cp_lexer_consume_token (parser->lexer);\n       rhs = cp_parser_binary_expression (parser, false,\n-\t\t\t\t\t PREC_ADDITIVE_EXPRESSION);\n+\t\t\t\t\t PREC_ADDITIVE_EXPRESSION, NULL);\n       token = cp_lexer_peek_token (parser->lexer);\n       if (token->type == CPP_PLUS || token->type == CPP_MINUS || decl_first)\n \t{\n@@ -21224,7 +21235,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t    {\n \t\t      /* Consume '='.  */\n \t\t      cp_lexer_consume_token (parser->lexer);\n-\t\t      init = cp_parser_assignment_expression (parser, false);\n+\t\t      init = cp_parser_assignment_expression (parser, false, NULL);\n \n \t\t    non_class:\n \t\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n@@ -21257,7 +21268,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \n \t\t  cp_parser_parse_definitely (parser);\n \t\t  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n-\t\t  rhs = cp_parser_assignment_expression (parser, false);\n+\t\t  rhs = cp_parser_assignment_expression (parser, false, NULL);\n \t\t  finish_expr_stmt (build_x_modify_expr (decl, NOP_EXPR,\n \t\t\t\t\t\t\t rhs,\n \t\t\t\t\t\t\t tf_warning_or_error));\n@@ -21267,7 +21278,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t{\n \t\t  decl = NULL;\n \t\t  cp_parser_abort_tentative_parse (parser);\n-\t\t  init = cp_parser_expression (parser, false);\n+\t\t  init = cp_parser_expression (parser, false, NULL);\n \t\t  if (init)\n \t\t    {\n \t\t      if (TREE_CODE (init) == MODIFY_EXPR\n@@ -21384,7 +21395,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n \t    incr = cp_parser_omp_for_incr (parser, decl);\n \t  else\n-\t    incr = cp_parser_expression (parser, false);\n+\t    incr = cp_parser_expression (parser, false, NULL);\n \t}\n \n       if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))"}, {"sha": "4184300b7d173f45611bea7293ae51f8f8466951", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cee9035de585c97d1cff64f54cc454315e1dd2f6", "patch": "@@ -1,3 +1,8 @@\n+2009-01-14  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR c++/37862\n+\t* g++.cp/parse/pr37862.C: New test.\n+\n 2009-01-14  Julian Brown  <julian@codesourcery.com>\n \n \t* gcc.target/arm/eabi1.c (__eabi_uread4, __eabi_uwrite4)"}, {"sha": "89b4b69947517038c91aca15b382bcdc6763be06", "filename": "gcc/testsuite/g++.dg/parse/pr37862.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr37862.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee9035de585c97d1cff64f54cc454315e1dd2f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr37862.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr37862.C?ref=cee9035de585c97d1cff64f54cc454315e1dd2f6", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run }\n+#include <stdlib.h>\n+\n+class A {\n+public:\n+  virtual void get (void) { }\n+};\n+\n+class B : public A {\n+public:\n+  void get (void) { abort (); }\n+};\n+\n+class C : public B { };\n+\n+int main (void)\n+{\n+  C   c;\n+  C * p = &c;\n+\n+  p->A::get ();\t\n+  (p->A::get) ();\t// The C++ parser used to resolve this to B::get()\n+\n+  return 0;\n+}"}]}