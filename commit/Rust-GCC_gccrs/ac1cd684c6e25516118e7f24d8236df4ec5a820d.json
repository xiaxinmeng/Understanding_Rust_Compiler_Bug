{"sha": "ac1cd684c6e25516118e7f24d8236df4ec5a820d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxY2Q2ODRjNmUyNTUxNjExOGU3ZjI0ZDgyMzZkZjRlYzVhODIwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-02-10T14:33:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-02-10T14:33:01Z"}, "message": "(movcnt_regno_adjust): Corrected.\n\n(mov_memory_operand, zero_operand): Added.\n(b_mode_operand): Corrected.\n(simple_memory_operand, add_1_to_mem): Added.\n(print_operand_address): Corrected case of 'Q' output modifier.\n\nFrom-SVN: r11198", "tree": {"sha": "09bc3080cb4cce1504cfc5b6e502f3211431eb75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09bc3080cb4cce1504cfc5b6e502f3211431eb75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac1cd684c6e25516118e7f24d8236df4ec5a820d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1cd684c6e25516118e7f24d8236df4ec5a820d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1cd684c6e25516118e7f24d8236df4ec5a820d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1cd684c6e25516118e7f24d8236df4ec5a820d/comments", "author": null, "committer": null, "parents": [{"sha": "27383dfc6c2c9d0e2bb842c8bf9e627bbac21af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27383dfc6c2c9d0e2bb842c8bf9e627bbac21af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27383dfc6c2c9d0e2bb842c8bf9e627bbac21af0"}], "stats": {"total": 162, "additions": 144, "deletions": 18}, "files": [{"sha": "dfd1ef129827770d93f0899ef9f49b554bc60ee2", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 144, "deletions": 18, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1cd684c6e25516118e7f24d8236df4ec5a820d/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1cd684c6e25516118e7f24d8236df4ec5a820d/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=ac1cd684c6e25516118e7f24d8236df4ec5a820d", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for MIL-STD-1750.\n-   Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by O.M.Kellogg, DASA (kellogg@space.otn.dasa.de)\n \n This file is part of GNU CC.\n@@ -111,7 +111,6 @@ function_arg (cum, mode, type, named)\n      int named;\n {\n   int size;\n-  rtx result;\n \n   if (MUST_PASS_IN_STACK (mode, type))\n     return (rtx) 0;\n@@ -187,21 +186,30 @@ char *\n movcnt_regno_adjust (op)\n      rtx *op;\n {\n-  static char outstr[40];\n-  int cntreg = REGNO (op[2]), cntreg_1750 = REGNO (op[0]) + 1;\n-  int dstreg = REGNO (op[0]), srcreg = REGNO (op[1]);\n+  static char outstr[80];\n+  int op0r = REGNO (op[0]), op1r = REGNO (op[1]), op2r = REGNO (op[2]);\n+#define dstreg op0r\n+#define srcreg op1r\n+#define cntreg op2r\n+#define cntreg_1750 (op0r + 1)\n \n   if (cntreg == cntreg_1750)\n-    sprintf (outstr, \"mov r%%0,r%%1\");\n-  else if (dstreg + 1 == srcreg && srcreg == cntreg + 2)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", cntreg, dstreg);\n-  else if (dstreg + 1 == srcreg && srcreg < cntreg)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", srcreg, cntreg);\n-  else if (srcreg + 1 == cntreg && dstreg > cntreg)\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,r%%1\", srcreg, dstreg);\n+    sprintf (outstr, \"mov r%d,r%d\", op0r, op1r);\n+  else if (dstreg + 1 == srcreg && cntreg > srcreg)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op2r, op1r, op0r, op2r);\n+  else if (dstreg == cntreg + 1)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op0r, op2r, op2r, op1r);\n+  else if (dstreg == srcreg + 1)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\txwr r%d,r%d\\n\\tmov r%d,r%d\",\n+\t     op0r, op1r, op0r, op2r, op1r, op2r);\n+  else if (cntreg + 1 == srcreg)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\txwr r%d,r%d\\n\\tmov r%d,r%d\",\n+\t     op2r, op1r, op0r, op2r, op2r, op0r);\n+  else if (cntreg == srcreg + 1)\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,r%d\", op0r, op1r, op1r, op0r);\n   else\n-    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%%0,%%1\\n\\txwr r%d,r%d\",\n-\t     cntreg, cntreg_1750, cntreg_1750, cntreg);\n+    sprintf (outstr, \"xwr r%d,r%d\\n\\tmov r%d,%d\\n\\txwr r%d,r%d\",\n+\t     op2r, cntreg_1750, op0r, op1r, op2r, cntreg_1750);\n   return outstr;\n }\n \n@@ -280,6 +288,15 @@ nonindirect_operand (op, mode)\n   return 1;\n }\n \n+/* predicate for the MOV instruction: */\n+int\n+mov_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG);\n+}\n+\n /* predicate for the STC instruction: */\n int\n small_nonneg_const (op, mode)\n@@ -291,6 +308,15 @@ small_nonneg_const (op, mode)\n   return 0;\n }\n \n+/* predicate for constant zero: */\n+int\n+zero_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return op == CONST0_RTX (mode);\n+}\n+\n \n /* predicate for 1750 `B' addressing mode (Base Register with Offset)\n    memory operand */\n@@ -301,6 +327,8 @@ b_mode_operand (op)\n   if (GET_CODE (op) == MEM)\n     {\n       rtx inner = XEXP (op, 0);\n+      if (GET_CODE (inner) == REG && REG_OK_FOR_INDEX_P (inner))\n+\treturn 1;\n       if (GET_CODE (inner) == PLUS)\n \t{\n \t  rtx plus_op0 = XEXP (inner, 0);\n@@ -317,6 +345,92 @@ b_mode_operand (op)\n   return 0;\n }\n \n+/* predicate needed for adding 1 to mem (short before output) */\n+int\n+simple_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx inner;\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  inner = XEXP (op, 0);\n+  switch (GET_CODE (inner))\n+    {\n+    case REG:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case PLUS:\n+      if (GET_CODE (XEXP (inner, 1)) != CONST_INT)\n+        return 0;\n+      inner = (XEXP (inner, 0));\n+      switch (GET_CODE (inner))\n+\t{\n+\tcase REG:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  return 1;\n+\tcase PLUS:\n+\t  if (GET_CODE (XEXP (inner, 1)) != CONST_INT)\n+            return 0;\n+\t  switch (GET_CODE (XEXP (inner, 0)))\n+\t    {\n+\t    case SYMBOL_REF:\n+\t    case LABEL_REF:\n+\t      return 1;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* destructively add one to memory address */\n+add_1_to_mem (opnd)\t/* returns 1 for success, 0 for failure */\n+     rtx opnd;\t\t/* OPND must be a MEM rtx */\n+{\n+  rtx inner = XEXP (opnd, 0);\n+\n+  if (GET_CODE (opnd) != MEM)\n+    return 0;  /* failure */\n+first:\n+  switch (GET_CODE (inner))\n+    {\n+    case CONST:\n+      inner = XEXP (inner, 0);\n+      goto first;\n+    case REG:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      inner = gen_rtx (PLUS, Pmode, inner, const1_rtx);\n+      return 1;\n+    case PLUS:\n+      inner = XEXP (inner, 1);\n+second:\n+      switch (GET_CODE (inner))\n+\t{\n+\tcase CONST:\n+\t  inner = XEXP (inner, 0);\n+\t  goto second;\n+\tcase CONST_INT:\n+\t  INTVAL (inner) += 1;\n+\t  return 1;\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  inner = gen_rtx (PLUS, Pmode, inner, const1_rtx);\n+\t  return 1;\n+\tcase PLUS:\n+\t  inner = XEXP (inner, 1);\n+\t  if (GET_CODE (inner) != CONST_INT)\n+\t    return 0;\n+\t  INTVAL (inner) += 1;\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n /* Decide whether to output a conditional jump as a \"Jump Conditional\"\n    or as a \"Branch Conditional\": */\n \n@@ -411,9 +525,21 @@ print_operand (file, x, kode)\n     case CONST:\n     case MEM:\n       if (kode == 'Q')\n-\tfprintf (file, \"r%d,%d\",\n-\t\t REGNO (XEXP (XEXP (x, 0), 0)),\n-\t\t INTVAL (XEXP (XEXP (x, 0), 1)));\n+\t{\n+\t  rtx inner = XEXP (x, 0);\n+\t  switch (GET_CODE (inner))\n+\t    {\n+\t    case REG:\n+\t      fprintf (file, \"r%d,0\", REGNO (inner));\n+\t      break;\n+\t    case PLUS:\n+\t      fprintf (file, \"r%d,%d\", REGNO (XEXP (inner, 0)),\n+\t\t       INTVAL (XEXP (inner, 1)));\n+\t      break;\n+\t    default:\n+\t      fprintf (file, \"[ill Q code=%d]\", GET_CODE (inner));\n+\t    }\n+\t}\n       else\n         output_address (XEXP (x, 0));\n       break;\n@@ -496,7 +622,7 @@ print_operand (file, x, kode)\n \t  switch (op0code)\n \t    {\n \t    case REG:\n-\t      fprintf (file, \"%d,r%d  ; p_o_PLUS for REG and CONST\",\n+\t      fprintf (file, \"%d,r%d  ; p_o_PLUS for REG and CONST_INT\",\n \t\t       INTVAL (op1), REGNO (op0));\n \t      break;\n \t    case SYMBOL_REF:"}]}