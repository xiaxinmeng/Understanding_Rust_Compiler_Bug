{"sha": "c610adec5615b94a7267335d5bd8a823ec653c9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYxMGFkZWM1NjE1Yjk0YTcyNjczMzVkNWJkOGE4MjNlYzY1M2M5ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-18T21:39:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-06-18T21:39:37Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1219", "tree": {"sha": "2b0a538edc62ca7ef3c5dfe304299a00152284a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0a538edc62ca7ef3c5dfe304299a00152284a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c610adec5615b94a7267335d5bd8a823ec653c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c610adec5615b94a7267335d5bd8a823ec653c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c610adec5615b94a7267335d5bd8a823ec653c9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c610adec5615b94a7267335d5bd8a823ec653c9d/comments", "author": null, "committer": null, "parents": [{"sha": "460286d7d3d4f28b26ee347a9a01bfe84f9e0871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460286d7d3d4f28b26ee347a9a01bfe84f9e0871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460286d7d3d4f28b26ee347a9a01bfe84f9e0871"}], "stats": {"total": 101, "additions": 81, "deletions": 20}, "files": [{"sha": "d3a89d2fca91112fb28922a33d18a273cf00f31a", "filename": "gcc/cse.c", "status": "modified", "additions": 81, "deletions": 20, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c610adec5615b94a7267335d5bd8a823ec653c9d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c610adec5615b94a7267335d5bd8a823ec653c9d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c610adec5615b94a7267335d5bd8a823ec653c9d", "patch": "@@ -929,6 +929,20 @@ insert_regs (x, classp, modified)\n \t  return 1;\n \t}\n     }\n+\n+  /* If X is a SUBREG, we will likely be inserting the inner register in the\n+     table.  If that register doesn't have an assigned quantity number at\n+     this point but does later, the insertion that we will be doing now will\n+     not be accessible because its hash code will have changed.  So assign\n+     a quantity number now.  */\n+\n+  else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n+\t   && ! REGNO_QTY_VALID_P (REGNO (SUBREG_REG (x))))\n+    {\n+      insert_regs (SUBREG_REG (x), 0, 0);\n+      mention_regs (SUBREG_REG (x));\n+      return 1;\n+    }\n   else\n     return mention_regs (x);\n }\n@@ -2549,9 +2563,23 @@ find_comparison_args (code, parg1, parg2)\n \n       else if (GET_RTX_CLASS (GET_CODE (arg1)) == '<')\n \t{\n-\t  if (code == NE || (code == LT && STORE_FLAG_VALUE == -1))\n+\t  if (code == NE\n+\t      || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_INT\n+\t\t  && code == LT && STORE_FLAG_VALUE == -1)\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t      || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_FLOAT\n+\t\t  && FLOAT_STORE_FLAG_VALUE < 0)\n+#endif\n+\t      )\n \t    x = arg1;\n-\t  else if (code == EQ || (code == GE && STORE_FLAG_VALUE == -1))\n+\t  else if (code == EQ\n+\t\t   || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_INT\n+\t\t       && code == GE && STORE_FLAG_VALUE == -1)\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t\t   || (GET_MODE_CLASS (GET_MODE (arg1)) == MODE_FLOAT\n+\t\t       && FLOAT_STORE_FLAG_VALUE < 0)\n+#endif\n+\t\t   )\n \t    x = arg1, reverse_code = 1;\n \t}\n \n@@ -2586,21 +2614,33 @@ find_comparison_args (code, parg1, parg2)\n \t\t for STORE_FLAG_VALUE, also look at LT and GE operations.  */\n \t      || ((code == NE\n \t\t   || (code == LT\n-\t\t       && inner_mode != VOIDmode\n+\t\t       && GET_MODE_CLASS (inner_mode) == MODE_INT\n \t\t       && GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n \t\t       && (STORE_FLAG_VALUE\n-\t\t\t   & (1 << (GET_MODE_BITSIZE (inner_mode) - 1)))))\n+\t\t\t   & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t\t   || (code == LT\n+\t\t       && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t       && FLOAT_STORE_FLAG_VALUE < 0)\n+#endif\n+\t\t   )\n \t\t  && GET_RTX_CLASS (GET_CODE (p->exp)) == '<'))\n \t    {\n \t      x = p->exp;\n \t      break;\n \t    }\n \t  else if ((code == EQ\n \t\t    || (code == GE\n-\t\t\t&& inner_mode != VOIDmode\n+\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_INT\n \t\t\t&& GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_INT\n \t\t\t&& (STORE_FLAG_VALUE\n-\t\t\t    & (1 << (GET_MODE_BITSIZE (inner_mode) - 1)))))\n+\t\t\t    & (1 << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t\t    || (code == GE\n+\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t\t&& FLOAT_STORE_FLAG_VALUE < 0)\n+#endif\n+\t\t    )\n \t\t   && GET_RTX_CLASS (GET_CODE (p->exp)) == '<')\n \t    {\n \t      reverse_code = 1;\n@@ -4175,11 +4215,9 @@ fold_rtx (x, insn)\n       break;\n \n     case SUBREG:\n-      /* If this is a single word of a multi-word value, see if we previously\n-\t assigned a value to that word.  */\n-      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t  && (new = lookup_as_function (x, CONST_INT)) != 0)\n+      /* See if we previously assigned a constant value to this SUBREG.  */\n+      if ((new = lookup_as_function (x, CONST_INT)) != 0\n+\t  || (new = lookup_as_function (x, CONST_DOUBLE)) != 0)\n \treturn new;\n \n       /* If this is a paradoxical SUBREG, we can't do anything with\n@@ -4598,6 +4636,15 @@ fold_rtx (x, insn)\n       if (const_arg0 == 0 || const_arg1 == 0)\n \t{\n \t  struct table_elt *p0, *p1;\n+\t  rtx true = const_true_rtx, false = const0_rtx;\n+\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  if (GET_MODE_CLASS (mode))\n+\t    {\n+\t      true = immed_real_const_1 (FLOAT_STORE_FLAG_VALUE, mode);\n+\t      false = CONST0_RTX (mode);\n+\t    }\n+#endif\n \n \t  code = find_comparison_args (code, &folded_arg0, &folded_arg1);\n \t  const_arg0 = equiv_constant (folded_arg0);\n@@ -4636,9 +4683,9 @@ fold_rtx (x, insn)\n \t\t      || GET_CODE (folded_arg0) == CONST))\n \t\t{\n \t\t  if (code == EQ)\n-\t\t    return const0_rtx;\n+\t\t    return false;\n \t\t  else if (code == NE)\n-\t\t    return const_true_rtx;\n+\t\t    return true;\n \t\t}\n \n \t      /* See if the two operands are the same.  We don't do this\n@@ -4661,7 +4708,7 @@ fold_rtx (x, insn)\n \t\t\t  && p0->first_same_value == p1->first_same_value)))\n \t\treturn ((code == EQ || code == LE || code == GE\n \t\t\t || code == LEU || code == GEU)\n-\t\t\t? const_true_rtx : const0_rtx);\n+\t\t\t? true : false);\n \n \t      /* If FOLDED_ARG0 is a register, see if the comparison we are\n \t\t doing now is either the same as we did before or the reverse\n@@ -4684,7 +4731,7 @@ fold_rtx (x, insn)\n \t\t\t\t  == qty_comparison_qty[qty]))))\n \t\t    return (comparison_dominates_p (qty_comparison_code[qty],\n \t\t\t\t\t\t    code)\n-\t\t\t    ? const_true_rtx : const0_rtx);\n+\t\t\t    ? true : false);\n \t\t}\n \t    }\n \t}\n@@ -4706,20 +4753,29 @@ fold_rtx (x, insn)\n \t      int sign_bitnum = GET_MODE_BITSIZE (mode_arg0) - 1;\n \t      int has_sign = (HOST_BITS_PER_INT >= sign_bitnum\n \t\t\t      && (INTVAL (inner_const) & (1 << sign_bitnum)));\n+\t      rtx true = const_true_rtx, false = const0_rtx;\n+\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t      if (GET_MODE_CLASS (mode))\n+\t\t{\n+\t\t  true = immed_real_const_1 (FLOAT_STORE_FLAG_VALUE, mode);\n+\t\t  false = CONST0_RTX (mode);\n+\t\t}\n+#endif\n \n \t      switch (code)\n \t\t{\n \t\tcase EQ:\n-\t\t  return const0_rtx;\n+\t\t  return false;\n \t\tcase NE:\n-\t\t  return const_true_rtx;\n+\t\t  return true;\n \t\tcase LT:  case LE:\n \t\t  if (has_sign)\n-\t\t    return const_true_rtx;\n+\t\t    return true;\n \t\t  break;\n \t\tcase GT:  case GE:\n \t\t  if (has_sign)\n-\t\t    return const0_rtx;\n+\t\t    return false;\n \t\t  break;\n \t\t}\n \t    }\n@@ -4728,6 +4784,11 @@ fold_rtx (x, insn)\n       new = simplify_relational_operation (code, mode_arg0,\n \t\t\t\t\t   const_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t\t   const_arg1 ? const_arg1 : folded_arg1);\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+      if (new != 0 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\tnew = ((new == const0_rtx) ? CONST0_RTX (mode)\n+\t       : immed_real_const_1 (FLOAT_STORE_FLAG_VALUE, mode));\n+#endif\n       break;\n \n     case '2':\n@@ -6323,7 +6384,7 @@ cse_insn (insn, in_libcall_block)\n \tif (GET_CODE (dest) == STRICT_LOW_PART)\n \t  dest = SUBREG_REG (XEXP (dest, 0));\n \n-\tif (GET_CODE (dest) == REG)\n+\tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n \t  /* Registers must also be inserted into chains for quantities.  */\n \t  if (insert_regs (dest, sets[i].src_elt, 1))\n \t    /* If `insert_regs' changes something, the hash code must be"}]}