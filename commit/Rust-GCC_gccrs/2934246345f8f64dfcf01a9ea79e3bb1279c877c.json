{"sha": "2934246345f8f64dfcf01a9ea79e3bb1279c877c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkzNDI0NjM0NWY4ZjY0ZGZjZjAxYTllYTc5ZTNiYjEyNzljODc3Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2003-11-18T08:21:38Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-11-18T08:21:38Z"}, "message": "re PR libstdc++/12868 (basic_filebuf::imbue fails too easily)\n\n2003-11-18  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/12868\n\t* include/bits/fstream.tcc (imbue): For encodings != -1 it's\n\talways ok to imbue a new locale, provided seekoff(0, cur, ...)\n\tdoesn't fail, of course.\n\t(underflow): In order for the above to work, deal gracefully\n\twith _M_codecvt->in returning codecvt_base::error while\n\t(__ilen = __iend - this->eback()) > 0: it just means __ilen\n\tcorrectly converted internal characters before an error.\n\t* testsuite/27_io/basic_filebuf/imbue/wchar_t/12868.cc: New.\n\nFrom-SVN: r73697", "tree": {"sha": "daa2ff7e839fcb7ddd139eef47a4d6daedfcfab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daa2ff7e839fcb7ddd139eef47a4d6daedfcfab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2934246345f8f64dfcf01a9ea79e3bb1279c877c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2934246345f8f64dfcf01a9ea79e3bb1279c877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2934246345f8f64dfcf01a9ea79e3bb1279c877c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2934246345f8f64dfcf01a9ea79e3bb1279c877c/comments", "author": null, "committer": null, "parents": [{"sha": "0ec5fef2187bc6f4f962e3afe1b2d829b7474d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec5fef2187bc6f4f962e3afe1b2d829b7474d80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec5fef2187bc6f4f962e3afe1b2d829b7474d80"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "88079fd01b30cc1afd45acfbaa3e94dfa5287df9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2934246345f8f64dfcf01a9ea79e3bb1279c877c", "patch": "@@ -1,3 +1,15 @@\n+2003-11-18  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/12868\n+\t* include/bits/fstream.tcc (imbue): For encodings != -1 it's\n+\talways ok to imbue a new locale, provided seekoff(0, cur, ...)\n+\tdoesn't fail, of course.\n+\t(underflow): In order for the above to work, deal gracefully\n+\twith _M_codecvt->in returning codecvt_base::error while \n+\t(__ilen = __iend - this->eback()) > 0: it just means __ilen\n+\tcorrectly converted internal characters before an error.\t\n+\t* testsuite/27_io/basic_filebuf/imbue/wchar_t/12868.cc: New.\n+\n 2003-11-17  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc: Fix typo in comment."}, {"sha": "0e1e36d3e4c6a9673f5ef138d9c3fd8c34df8e9a", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=2934246345f8f64dfcf01a9ea79e3bb1279c877c", "patch": "@@ -269,21 +269,23 @@ namespace std\n \t\t  __r = _M_codecvt->in(_M_state_cur, _M_ext_next,\n \t\t\t\t       _M_ext_end, _M_ext_next, this->eback(), \n \t\t\t\t       this->eback() + __buflen, __iend);\n-\t\t  if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n-\t\t    __ilen = __iend - this->eback();\n-\t\t  else if (__r == codecvt_base::noconv)\n+\t\t  if (__r == codecvt_base::noconv)\n \t\t    {\n \t\t      size_t __avail = _M_ext_end - _M_ext_buf;\n \t\t      __ilen = std::min(__avail, __buflen);\n \t\t      traits_type::copy(this->eback(),\n \t\t\t\t\treinterpret_cast<char_type*>(_M_ext_buf), __ilen);\n \t\t      _M_ext_next = _M_ext_buf + __ilen;\n \t\t    }\n-\t\t  else \n-\t\t    {\n-\t\t      __ilen = 0;\n-\t\t      break;\n-\t\t    }\n+\t\t  else\n+\t\t    __ilen = __iend - this->eback();\n+\t\t  \n+\t\t  // _M_codecvt->in may return error while __ilen > 0: this is\n+\t\t  // ok, and actually occurs in case of mixed encodings (e.g.,\n+\t\t  // XML files).\n+\t\t  if (__r == codecvt_base::error)\n+\t\t    break;\n+\n \t\t  __rlen = 1;\n \t\t}\n \t      while (!__got_eof && __ilen == 0);\n@@ -747,13 +749,13 @@ namespace std\n \t  bool __testfail = false;\n \t  if (this->is_open())\n \t    {\n-\t      const bool __testbeg =\n+\t      const bool __testseek =\n \t\tthis->seekoff(0, ios_base::cur, this->_M_mode) ==\n-\t\tpos_type(off_type(0));\n+\t\tpos_type(off_type(-1));\n \t      const bool __teststate =\n \t\t__check_facet(_M_codecvt).encoding() == -1;\n \n-\t      __testfail = !__testbeg || __teststate;\n+\t      __testfail = __testseek || __teststate;\n \t    }\n \n \t  if (!__testfail)\n@@ -762,13 +764,6 @@ namespace std\n \t\t_M_codecvt = &use_facet<__codecvt_type>(__loc);\n \t      else\n \t\t_M_codecvt = 0;\n-\n-\t      // NB This may require the reconversion of previously\n-\t      // converted chars. This in turn may cause the\n-\t      // reconstruction of the original file. YIKES!!  This\n-\t      // implementation interprets this requirement as requiring\n-\t      // the file position be at the beginning, and a stateless\n-\t      // encoding, or that the filebuf be closed. Opinions may differ.\n \t    }\n \t}\n     }"}, {"sha": "8e4484b1472320e80ea60a4d8330ad17db16a7c9", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/imbue/wchar_t/12868.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fimbue%2Fwchar_t%2F12868.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934246345f8f64dfcf01a9ea79e3bb1279c877c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fimbue%2Fwchar_t%2F12868.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fimbue%2Fwchar_t%2F12868.cc?ref=2934246345f8f64dfcf01a9ea79e3bb1279c877c", "patch": "@@ -0,0 +1,60 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.4 Overridden virtual functions\n+\n+#include <ostream>\n+#include <fstream>\n+#include <locale>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/12868\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  locale loc_is(__gnu_test::try_named_locale(\"is_IS\"));\n+  \n+  {\n+    wofstream out(\"tmp_12868\");\n+    out << L\"<? xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\";\n+    out.imbue(loc_is);\n+    VERIFY( out.rdbuf()->getloc() == loc_is );\n+    out << L\"<greeting>Hall\\u00f3 heimur</greeting>\\n\";\n+  }\n+\n+  {\n+    wifstream in(\"tmp_12868\");\n+    wstring str;\n+    getline(in, str);\n+    if (str.find(L\"encoding=\\\"UTF-8\\\"\") != wstring::npos)\n+      {\n+\tin.imbue(loc_is);\n+\tVERIFY( in.rdbuf()->getloc() == loc_is );\n+      }\n+    getline(in, str);\n+    VERIFY( str == L\"<greeting>Hall\\u00f3 heimur</greeting>\" );\n+  }\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}