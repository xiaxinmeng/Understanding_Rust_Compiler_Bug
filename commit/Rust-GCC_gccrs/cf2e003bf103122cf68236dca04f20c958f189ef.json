{"sha": "cf2e003bf103122cf68236dca04f20c958f189ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyZTAwM2JmMTAzMTIyY2Y2ODIzNmRjYTA0ZjIwYzk1OGYxODllZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-21T17:01:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-21T17:01:22Z"}, "message": "cp-tree.h (struct lang_type): Remove search_slot.\n\n\t* cp-tree.h (struct lang_type): Remove search_slot.\n\t(CLASSTYPE_SEARCH_SLOT): Remove.\n\t(emit_base_init): Change prototype.\n\t(initialize_vtbl_ptrs): Likewise.\n\t(expand_indirect_vtbls_init): Likewise.\n\t(clear_search_slots): Remove.\n\t* decl.c (lang_mark_tree): Don't mark search_slot.\n\t* init.c (initialize_vtbl_ptrs): Simplify.\n\t(emit_base_init): Likewise.\n\t* search.c (struct vbase_info): Document decl_ptr.\n\t(convert_pointer_to_single_level): Remove.\n\t(dfs_find_vbases): Remove.\n\t(dfs_init_base_pointers): Simplify.\n\t(dfs_clear_vbase_slots): Remove.\n\t(dfs_vtable_path_unmark): New function.\n\t(init_vbase_pointers): Simplify.\n\t(expand_upcast_fixups): Don't rely on CLASSTYPE_SEARCH_SLOT.\n\t(expand_indirect_vtbls_init): Simplify.  Don't call\n\tmark_all_temps_used.\n\t* semantics.c (setup_vtbl_ptr): Adjust calls to emit_base_init and\n\tinitialize_vtbl_ptrs.\n\nFrom-SVN: r34067", "tree": {"sha": "6897a36d9ca4ed4a5e2599cf0ad643d75448e354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6897a36d9ca4ed4a5e2599cf0ad643d75448e354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf2e003bf103122cf68236dca04f20c958f189ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2e003bf103122cf68236dca04f20c958f189ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf2e003bf103122cf68236dca04f20c958f189ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf2e003bf103122cf68236dca04f20c958f189ef/comments", "author": null, "committer": null, "parents": [{"sha": "bf5df909a9bfd487f96a871f8997a696e3848043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf5df909a9bfd487f96a871f8997a696e3848043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf5df909a9bfd487f96a871f8997a696e3848043"}], "stats": {"total": 243, "additions": 86, "deletions": 157}, "files": [{"sha": "1f621b3c5881cd0aa7a66d0c2a9caca1ad0ecb8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -1,3 +1,27 @@\n+2000-05-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (struct lang_type): Remove search_slot.\n+\t(CLASSTYPE_SEARCH_SLOT): Remove.\n+\t(emit_base_init): Change prototype.\n+\t(initialize_vtbl_ptrs): Likewise.\n+\t(expand_indirect_vtbls_init): Likewise.\n+\t(clear_search_slots): Remove.\n+\t* decl.c (lang_mark_tree): Don't mark search_slot.\n+\t* init.c (initialize_vtbl_ptrs): Simplify.\n+\t(emit_base_init): Likewise.\n+\t* search.c (struct vbase_info): Document decl_ptr.\n+\t(convert_pointer_to_single_level): Remove.\n+\t(dfs_find_vbases): Remove.\n+\t(dfs_init_base_pointers): Simplify.\n+\t(dfs_clear_vbase_slots): Remove.\n+\t(dfs_vtable_path_unmark): New function.\n+\t(init_vbase_pointers): Simplify.\n+\t(expand_upcast_fixups): Don't rely on CLASSTYPE_SEARCH_SLOT.\n+\t(expand_indirect_vtbls_init): Simplify.  Don't call\n+\tmark_all_temps_used.\n+\t* semantics.c (setup_vtbl_ptr): Adjust calls to emit_base_init and\n+\tinitialize_vtbl_ptrs.\n+\n 2000-05-20  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* except.c: Add static prototypes."}, {"sha": "711f614d4d35195562bb793a56e567211af65b88", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -1395,7 +1395,6 @@ struct lang_type\n   tree vfields;\n   tree vbases;\n   tree tags;\n-  tree search_slot;\n   tree size;\n   tree size_unit;\n   tree pure_virtuals;\n@@ -1613,10 +1612,6 @@ struct lang_type\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n \n-/* Used for keeping search-specific information.  Any search routine\n-   which uses this must define what exactly this slot is used for.  */\n-#define CLASSTYPE_SEARCH_SLOT(NODE) (TYPE_LANG_SPECIFIC(NODE)->search_slot)\n-\n /* These are the size and alignment of the type without its virtual\n    base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n@@ -4098,7 +4093,7 @@ extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_fl\n \n /* in init.c */\n extern void init_init_processing\t\tPARAMS ((void));\n-extern void emit_base_init\t\t\tPARAMS ((tree));\n+extern void emit_base_init\t\t\tPARAMS ((void));\n extern void expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_aggr_init\t\t\tPARAMS ((tree, tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n@@ -4117,7 +4112,7 @@ extern tree build_vec_delete\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree create_temporary_var                PARAMS ((tree));\n extern void begin_init_stmts                    PARAMS ((tree *, tree *));\n extern tree finish_init_stmts                   PARAMS ((tree, tree));\n-extern void initialize_vtbl_ptrs                PARAMS ((tree, tree));\n+extern void initialize_vtbl_ptrs                PARAMS ((tree));\n extern tree build_java_class_ref                PARAMS ((tree));\n \n /* in input.c */\n@@ -4291,8 +4286,7 @@ extern tree lookup_nested_tag\t\t\tPARAMS ((tree, tree));\n extern tree get_matching_virtual\t\tPARAMS ((tree, tree, int));\n extern void get_pure_virtuals\t\t        PARAMS ((tree));\n extern tree init_vbase_pointers\t\t\tPARAMS ((tree, tree));\n-extern void expand_indirect_vtbls_init\t\tPARAMS ((tree, tree));\n-extern void clear_search_slots\t\t\tPARAMS ((tree));\n+extern void expand_indirect_vtbls_init\t\tPARAMS ((tree));\n extern void get_vbase_types\t\t\tPARAMS ((tree));\n extern void maybe_suppress_debug_info\t\tPARAMS ((tree));\n extern void note_debug_info_needed\t\tPARAMS ((tree));"}, {"sha": "236eb9ed79b6dd87909a79e70a951e2988af9d32", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -14773,7 +14773,6 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (lt->vfields);\n \t  ggc_mark_tree (lt->vbases);\n \t  ggc_mark_tree (lt->tags);\n-\t  ggc_mark_tree (lt->search_slot);\n \t  ggc_mark_tree (lt->size);\n \t  ggc_mark_tree (lt->pure_virtuals);\n \t  ggc_mark_tree (lt->friend_classes);"}, {"sha": "3dbca4b2677e2c6a453d3f0aa1d3ee15921a636d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -151,15 +151,18 @@ dfs_initialize_vtbl_ptrs (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Initialize all the vtable pointers for the hierarchy dominated by\n-   TYPE. */\n+/* Initialize all the vtable pointers in the object pointed to by\n+   ADDR.  */\n \n void\n-initialize_vtbl_ptrs (type, addr)\n-     tree type;\n+initialize_vtbl_ptrs (addr)\n      tree addr;\n {\n-  tree list = build_tree_list (type, addr);\n+  tree list;\n+  tree type;\n+\n+  type = TREE_TYPE (TREE_TYPE (addr));\n+  list = build_tree_list (type, addr);\n \n   /* Walk through the hierarchy, initializing the vptr in each base\n      class.  We do these in pre-order because under the new ABI we\n@@ -169,8 +172,7 @@ initialize_vtbl_ptrs (type, addr)\n \t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n   dfs_walk (TYPE_BINFO (type), dfs_unmark,\n \t    dfs_marked_real_bases_queue_p, type);\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-    expand_indirect_vtbls_init (TYPE_BINFO (type), addr);\n+  expand_indirect_vtbls_init (addr);\n }\n \n /* Subroutine of emit_base_init.  */\n@@ -624,21 +626,16 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    that call with a pushlevel/poplevel pair, since we are technically\n    at the PARM level of scope.\n \n-   Argument IMMEDIATELY, if zero, forces a new sequence to be\n-   generated to contain these new insns, so it can be emitted later.\n-   This sequence is saved in the global variable BASE_INIT_EXPR.\n-   Otherwise, the insns are emitted into the current sequence.\n-\n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n \n void\n-emit_base_init (t)\n-     tree t;\n+emit_base_init ()\n {\n   tree member;\n   tree mem_init_list;\n   tree rbase_init_list, vbase_init_list;\n+  tree t = current_class_type;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i;\n@@ -695,7 +692,7 @@ emit_base_init (t)\n     }\n \n   /* Initialize the vtable pointers for the class.  */\n-  initialize_vtbl_ptrs (t, current_class_ptr);\n+  initialize_vtbl_ptrs (current_class_ptr);\n \n   while (mem_init_list)\n     {"}, {"sha": "4775e482b3ebf466ea7c3fbd01ddf362f45e410c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 45, "deletions": 129, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -80,14 +80,14 @@ struct vbase_info\n {\n   /* The class dominating the hierarchy.  */\n   tree type;\n+  /* A pointer to a complete object of the indicated TYPE.  */\n   tree decl_ptr;\n   tree inits;\n };\n \n static tree next_baselink PARAMS ((tree));\n static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n-static tree convert_pointer_to_single_level PARAMS ((tree, tree));\n static int lookup_fnfields_here PARAMS ((tree, tree));\n static int is_subobject_of_p PARAMS ((tree, tree));\n static int hides PARAMS ((tree, tree));\n@@ -107,8 +107,6 @@ static tree marked_pushdecls_p PARAMS ((tree, void *));\n static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n static tree dfs_debug_unmarkedp PARAMS ((tree, void *));\n static tree dfs_debug_mark PARAMS ((tree, void *));\n-static tree dfs_find_vbases PARAMS ((tree, void *));\n-static tree dfs_clear_vbase_slots PARAMS ((tree, void *));\n static tree dfs_init_vbase_pointers PARAMS ((tree, void *));\n static tree dfs_get_vbase_types PARAMS ((tree, void *));\n static tree dfs_push_type_decls PARAMS ((tree, void *));\n@@ -151,6 +149,7 @@ static tree get_shared_vbase_if_not_primary PARAMS ((tree, void *));\n static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n static tree dfs_get_pure_virtuals PARAMS ((tree, void *));\n static tree dfs_build_inheritance_graph_order PARAMS ((tree, void *));\n+static tree dfs_vtable_path_unmark PARAMS ((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -2369,40 +2368,6 @@ next_baselink (baselink)\n \f\n /* DEPTH-FIRST SEARCH ROUTINES.  */\n \n-/* This routine converts a pointer to be a pointer of an immediate\n-   base class.  The normal convert_pointer_to routine would diagnose\n-   the conversion as ambiguous, under MI code that has the base class\n-   as an ambiguous base class.  */\n-\n-static tree\n-convert_pointer_to_single_level (to_type, expr)\n-     tree to_type, expr;\n-{\n-  tree derived;\n-  tree binfo_of_derived;\n-  int i;\n-\n-  derived = TREE_TYPE (TREE_TYPE (expr));\n-  binfo_of_derived = TYPE_BINFO (derived);\n-  my_friendly_assert (BINFO_INHERITANCE_CHAIN (binfo_of_derived) == NULL_TREE,\n-\t\t      980827);\n-  for (i = CLASSTYPE_N_BASECLASSES (derived) - 1; i >= 0; --i)\n-    {\n-      tree binfo = BINFO_BASETYPE (binfo_of_derived, i);\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (binfo) == binfo_of_derived,\n-\t\t\t  980827);\n-      if (same_type_p (BINFO_TYPE (binfo), to_type))\n-\treturn build_vbase_path (PLUS_EXPR, \n-\t\t\t\t build_pointer_type (to_type), \n-\t\t\t\t expr, binfo, 1);\n-    }\n-\n-  my_friendly_abort (19990607);\n-\n-  /* NOTREACHED */\n-  return NULL_TREE;\n-}\n-\n tree \n markedp (binfo, data) \n      tree binfo;\n@@ -2467,39 +2432,6 @@ dfs_unmark (binfo, data)\n }\n \n \f\n-/*  Attach to the type of the virtual base class, the pointer to the\n-    virtual base class.  */\n-\n-static tree\n-dfs_find_vbases (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  struct vbase_info *vi = (struct vbase_info *) data;\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  for (i = n_baselinks-1; i >= 0; i--)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo)\n-\t  && CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo)) == 0)\n-\t{\n-\t  tree vbase = BINFO_TYPE (base_binfo);\n-\t  tree binfo = binfo_for_vbase (vbase, vi->type);\n-\t  tree ptr_type = build_pointer_type (vbase);\n-\n-\t  CLASSTYPE_SEARCH_SLOT (vbase)\n-\t    = build (PLUS_EXPR, ptr_type, vi->decl_ptr,\n-\t\t     convert (ptr_type, BINFO_OFFSET (binfo)));\n-\t}\n-    }\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-\n-  return NULL_TREE;\n-}\n-\n static tree\n dfs_init_vbase_pointers (binfo, data)\n      tree binfo;\n@@ -2510,18 +2442,15 @@ dfs_init_vbase_pointers (binfo, data)\n   tree fields;\n   tree this_vbase_ptr;\n \n-  if (BINFO_INHERITANCE_CHAIN (binfo))\n-    {\n-      this_vbase_ptr = TREE_CHAIN (BINFO_INHERITANCE_CHAIN (binfo));\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tthis_vbase_ptr = CLASSTYPE_SEARCH_SLOT (type);\n-      else\n-\tthis_vbase_ptr = convert_pointer_to_single_level (type,\n-\t\t\t\t\t\t\t  this_vbase_ptr); \n-      TREE_CHAIN (binfo) = this_vbase_ptr;\n-    }\n-  else\n-    this_vbase_ptr = TREE_CHAIN (binfo);\n+  /* Don't initialize the same base more than once.  */\n+  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n+\n+  /* We know that VI->DECL_PTR points to the complete object.  So,\n+     finding a pointer to this subobject is easy.  */\n+  this_vbase_ptr = build (PLUS_EXPR,\n+\t\t\t  build_pointer_type (type),\n+\t\t\t  vi->decl_ptr,\n+\t\t\t  BINFO_OFFSET (binfo));\n \n   /* We're going to iterate through all the pointers to virtual\n      base-classes.  They come at the beginning of the class.  */\n@@ -2540,10 +2469,18 @@ dfs_init_vbase_pointers (binfo, data)\n     {\n       tree ref = build (COMPONENT_REF, TREE_TYPE (fields),\n \t\t\tbuild_indirect_ref (this_vbase_ptr, NULL_PTR), fields);\n-      tree init = CLASSTYPE_SEARCH_SLOT (TREE_TYPE (TREE_TYPE (fields)));\n+      tree init;\n+      tree vbase_type;\n+      tree vbase_binfo;\n+\n+      vbase_type = TREE_TYPE (TREE_TYPE (fields));\n+      vbase_binfo = binfo_for_vbase (vbase_type, vi->type);\n+      init = build (PLUS_EXPR, \n+\t\t    build_pointer_type (vbase_type),\n+\t\t    vi->decl_ptr,\n+\t\t    BINFO_OFFSET (vbase_binfo));\n       vi->inits \n-\t= tree_cons (binfo_for_vbase (TREE_TYPE (TREE_TYPE (fields)),\n-\t\t\t\t      vi->type),\n+\t= tree_cons (vbase_binfo,\n \t\t     build_modify_expr (ref, NOP_EXPR, init),\n \t\t     vi->inits);\n       fields = TREE_CHAIN (fields);\n@@ -2552,18 +2489,13 @@ dfs_init_vbase_pointers (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Sometimes this needs to clear both VTABLE_PATH and NEW_VTABLE.  Other\n-   times, just NEW_VTABLE, but optimizer should make both with equal\n-   efficiency (though it does not currently).  */\n+/* Call CLEAR_BINFO_VTABLE_PATH_MARKED for BINFO.  */\n \n static tree\n-dfs_clear_vbase_slots (binfo, data)\n+dfs_vtable_path_unmark (binfo, data)\n      tree binfo;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  tree type = BINFO_TYPE (binfo);\n-\n-  CLASSTYPE_SEARCH_SLOT (type) = 0;\n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n   return NULL_TREE;\n }\n@@ -2588,19 +2520,21 @@ init_vbase_pointers (type, decl_ptr)\n       vi.decl_ptr = decl_ptr;\n       vi.inits = NULL_TREE;\n \n-      dfs_walk (binfo, dfs_find_vbases, unmarked_vtable_pathp, &vi);\n-\n       /* Build up a list of the initializers.  */\n       TREE_CHAIN (binfo) = decl_ptr;\n       dfs_walk_real (binfo, \n \t\t     dfs_init_vbase_pointers, 0,\n-\t\t     marked_vtable_pathp,\n+\t\t     unmarked_vtable_pathp,\n \t\t     &vi);\n+      dfs_walk (binfo,\n+\t\tdfs_vtable_path_unmark,\n+\t\tmarked_vtable_pathp,\n+\t\tNULL);\n \n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_vtable_pathp, NULL);\n       flag_this_is_variable = old_flag;\n       return vi.inits;\n     }\n+\n   return 0;\n }\n \n@@ -2664,9 +2598,7 @@ virtual_context (fndecl, t, vbase)\n \n    VBASE_OFFSETS is an association list of virtual bases that contains\n    offset information for the virtual bases, so the offsets are only\n-   calculated once.  The offsets are computed by where we think the\n-   vbase should be (as noted by the CLASSTYPE_SEARCH_SLOT) minus where\n-   the vbase really is.  */\n+   calculated once.  */\n \n static void\n expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n@@ -2688,7 +2620,10 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   delta = purpose_member (vbase, *vbase_offsets);\n   if (! delta)\n     {\n-      delta = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vbase));\n+      delta = build (PLUS_EXPR,\n+\t\t     build_pointer_type (BINFO_TYPE (vbase)),\n+\t\t     orig_addr,\n+\t\t     BINFO_OFFSET (vbase));\n       delta = build (MINUS_EXPR, ptrdiff_type_node, delta, vbase_addr);\n       delta = save_expr (delta);\n       delta = tree_cons (vbase, delta, *vbase_offsets);\n@@ -2767,7 +2702,10 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      if (! vc_delta)\n \t\t{\n \t\t  tree vc_addr = convert_pointer_to_real (vc, orig_addr);\n-\t\t  vc_delta = CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (vc));\n+\t\t  vc_delta = build (PLUS_EXPR,\n+\t\t\t\t    build_pointer_type (BINFO_TYPE (vc)),\n+\t\t\t\t    orig_addr,\n+\t\t\t\t    BINFO_OFFSET (vc));\n \t\t  vc_delta = build (MINUS_EXPR, ptrdiff_type_node,\n \t\t\t\t    vc_delta, vc_addr);\n \t\t  vc_delta = save_expr (vc_delta);\n@@ -2884,41 +2822,19 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n }\n \n /* Generate the code needed to initialize all the virtual function\n-   table slots of all the virtual baseclasses.  BINFO is the binfo\n-   which determines the virtual baseclasses to use.  TRUE_EXP is the\n-   true object we are initializing, and DECL_PTR is the pointer to the\n-   sub-object we are initializing.  */\n+   table slots of all the virtual baseclasses.  ADDR points to the\n+   address of the complete object we are initializing.  */\n \n void\n-expand_indirect_vtbls_init (binfo, decl_ptr)\n-     tree binfo;\n-     tree decl_ptr;\n+expand_indirect_vtbls_init (addr)\n+     tree addr;\n {\n   tree type;\n \n-  type = BINFO_TYPE (binfo);\n-\n-  /* This function executes during the finish_function() segment,\n-     AFTER the auto variables and temporary stack space has been marked\n-     unused...If space is needed for the virtual function tables,\n-     some of them might fit within what the compiler now thinks\n-     are available stack slots... These values are actually initialized at\n-     the beginnning of the function, so when the automatics use their space,\n-     they will overwrite the values that are placed here. Marking all\n-     temporary space as unavailable prevents this from happening. */\n-\n-  mark_all_temps_used();\n+  type = TREE_TYPE (TREE_TYPE (addr));\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-    {\n-      struct vbase_info vi;\n-      vi.type = type;\n-      vi.decl_ptr = decl_ptr;\n-\n-      dfs_walk (binfo, dfs_find_vbases, NULL, &vi);\n-      fixup_all_virtual_upcast_offsets (type, vi.decl_ptr);\n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_vtable_pathp, &vi);\n-    }\n+    fixup_all_virtual_upcast_offsets (type, addr);\n }\n \n /* get virtual base class types."}, {"sha": "8f9a28bdfce05880ffb3e336fa8a2e94064404e7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf2e003bf103122cf68236dca04f20c958f189ef/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cf2e003bf103122cf68236dca04f20c958f189ef", "patch": "@@ -1247,7 +1247,7 @@ setup_vtbl_ptr ()\n \t  add_tree (ctor_stmt);\n \t  \n \t  /* And actually initialize the base-classes and members.  */\n-\t  emit_base_init (current_class_type);\n+\t  emit_base_init ();\n \t}\n     }\n   else if (DECL_DESTRUCTOR_P (current_function_decl)\n@@ -1286,8 +1286,7 @@ setup_vtbl_ptr ()\n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n \t tables.  */\n-      initialize_vtbl_ptrs (current_class_type,\n-\t\t\t    current_class_ptr);\n+      initialize_vtbl_ptrs (current_class_ptr);\n \n       finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n       finish_then_clause (if_stmt);"}]}