{"sha": "390ea488c1753eaf9c747ead8f653c9023058109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwZWE0ODhjMTc1M2VhZjljNzQ3ZWFkOGY2NTNjOTAyMzA1ODEwOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-08T15:40:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-08T15:40:27Z"}, "message": "mips-protos.h (mips_split_symbol): Add a mode and an \"rtx *\" argument.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_split_symbol): Add a mode and\n\tan \"rtx *\" argument.  Return a bool.\n\t* config/mips/mips.c (mips_split_symbol): Accept arbitrary source\n\tvalues and return true if they can be split.  Take the same kind of\n\tmode argument as mips_symbol_insns.  Add a \"lo_sum_out\" parameter\n\tand store the lo_sum there if nonnull.  Use the symbol type to\n\tdetermine whether a $gp or HIGH is needed.\n\t(mips_legitimize_address): Update call to mips_split_symbol and\n\tsimplify accordingly.\n\t(mips_legitimize_const_move): Likewise.\n\t* config/mips/mips.md: In the combine define_split,\n\tcheck mips_split_symbol instead of splittable_symbolic_operand.\n\tUpdate use of mips_split_symbol in the generator code.\n\t* config/mips/predicates.md (splittable_symbolic_operand): Delete.\n\nFrom-SVN: r127298", "tree": {"sha": "3316463566d687eaeaa605c042e7ff6cca105e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3316463566d687eaeaa605c042e7ff6cca105e65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390ea488c1753eaf9c747ead8f653c9023058109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390ea488c1753eaf9c747ead8f653c9023058109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390ea488c1753eaf9c747ead8f653c9023058109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390ea488c1753eaf9c747ead8f653c9023058109/comments", "author": null, "committer": null, "parents": [{"sha": "fbb96ac51d24dd44fb28ce484d8df3630aff6306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb96ac51d24dd44fb28ce484d8df3630aff6306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb96ac51d24dd44fb28ce484d8df3630aff6306"}], "stats": {"total": 108, "additions": 68, "deletions": 40}, "files": [{"sha": "63d49c35a9d0f261bc29908b6fb462b0f5a8fbca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=390ea488c1753eaf9c747ead8f653c9023058109", "patch": "@@ -1,3 +1,20 @@\n+2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips-protos.h (mips_split_symbol): Add a mode and\n+\tan \"rtx *\" argument.  Return a bool.\n+\t* config/mips/mips.c (mips_split_symbol): Accept arbitrary source\n+\tvalues and return true if they can be split.  Take the same kind of\n+\tmode argument as mips_symbol_insns.  Add a \"lo_sum_out\" parameter\n+\tand store the lo_sum there if nonnull.  Use the symbol type to\n+\tdetermine whether a $gp or HIGH is needed.\n+\t(mips_legitimize_address): Update call to mips_split_symbol and\n+\tsimplify accordingly.\n+\t(mips_legitimize_const_move): Likewise.\n+\t* config/mips/mips.md: In the combine define_split,\n+\tcheck mips_split_symbol instead of splittable_symbolic_operand.\n+\tUpdate use of mips_split_symbol in the generator code.\n+\t* config/mips/predicates.md (splittable_symbolic_operand): Delete.\n+\n 2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips.c (mips_symbolic_address_p): Delete."}, {"sha": "d2f501740f0052eee7c01e5fd3c5cfb945482bde", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=390ea488c1753eaf9c747ead8f653c9023058109", "patch": "@@ -171,7 +171,7 @@ extern int mips_idiv_insns (void);\n extern int fp_register_operand (rtx, enum machine_mode);\n extern int lo_operand (rtx, enum machine_mode);\n extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n-extern rtx mips_split_symbol (rtx, rtx);\n+extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);\n extern void mips_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);"}, {"sha": "2b620fbb20ba4606f65fb2556ce92d08772bd371", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=390ea488c1753eaf9c747ead8f653c9023058109", "patch": "@@ -2113,24 +2113,50 @@ mips_force_temporary (rtx dest, rtx value)\n }\n \n \n-/* Return a LO_SUM expression for ADDR.  TEMP is as for mips_force_temporary\n-   and is used to load the high part into a register.  */\n+/* If MODE is MAX_MACHINE_MODE, ADDR appears as a move operand, otherwise\n+   it appears in a MEM of that mode.  Return true if ADDR is a legitimate\n+   constant in that context and can be split into a high part and a LO_SUM.\n+   If so, and if LO_SUM_OUT is nonnull, emit the high part and return\n+   the LO_SUM in *LO_SUM_OUT.  Leave *LO_SUM_OUT unchanged otherwise.\n \n-rtx\n-mips_split_symbol (rtx temp, rtx addr)\n+   TEMP is as for mips_force_temporary and is used to load the high\n+   part into a register.  */\n+\n+bool\n+mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *lo_sum_out)\n {\n+  enum mips_symbol_context context;\n+  enum mips_symbol_type symbol_type;\n   rtx high;\n \n-  if (!TARGET_MIPS16)\n-    high = mips_force_temporary (temp, gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n-  else if (!can_create_pseudo_p ())\n+  context = (mode == MAX_MACHINE_MODE\n+\t     ? SYMBOL_CONTEXT_LEA\n+\t     : SYMBOL_CONTEXT_MEM);\n+  if (!mips_symbolic_constant_p (addr, context, &symbol_type)\n+      || mips_symbol_insns (symbol_type, mode) == 0\n+      || !mips_split_p[symbol_type])\n+    return false;\n+\n+  if (lo_sum_out)\n     {\n-      emit_insn (gen_load_const_gp (copy_rtx (temp)));\n-      high = temp;\n+      if (symbol_type == SYMBOL_GP_RELATIVE)\n+\t{\n+\t  if (!can_create_pseudo_p ())\n+\t    {\n+\t      emit_insn (gen_load_const_gp (copy_rtx (temp)));\n+\t      high = temp;\n+\t    }\n+\t  else\n+\t    high = mips16_gp_pseudo_reg ();\n+\t}\n+      else\n+\t{\n+\t  high = gen_rtx_HIGH (Pmode, copy_rtx (addr));\n+\t  high = mips_force_temporary (temp, high);\n+\t}\n+      *lo_sum_out = gen_rtx_LO_SUM (Pmode, high, addr);\n     }\n-  else\n-    high = mips16_gp_pseudo_reg ();\n-  return gen_rtx_LO_SUM (Pmode, high, addr);\n+  return true;\n }\n \n \n@@ -2321,22 +2347,15 @@ mips_legitimize_tls_address (rtx loc)\n bool\n mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n {\n-  enum mips_symbol_type symbol_type;\n-\n   if (mips_tls_operand_p (*xloc))\n     {\n       *xloc = mips_legitimize_tls_address (*xloc);\n       return true;\n     }\n \n   /* See if the address can split into a high part and a LO_SUM.  */\n-  if (mips_symbolic_constant_p (*xloc, SYMBOL_CONTEXT_MEM, &symbol_type)\n-      && mips_symbol_insns (symbol_type, mode) > 0\n-      && mips_split_p[symbol_type])\n-    {\n-      *xloc = mips_split_symbol (0, *xloc);\n-      return true;\n-    }\n+  if (mips_split_symbol (NULL, *xloc, mode, xloc))\n+    return true;\n \n   if (GET_CODE (*xloc) == PLUS && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n     {\n@@ -2505,9 +2524,9 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n     }\n \n   /* Split moves of symbolic constants into high/low pairs.  */\n-  if (splittable_symbolic_operand (src, mode))\n+  if (mips_split_symbol (dest, src, MAX_MACHINE_MODE, &src))\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, dest, mips_split_symbol (dest, src)));\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n       return;\n     }\n \n@@ -2534,8 +2553,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n \n   /* When using explicit relocs, constant pool references are sometimes\n      not legitimate addresses.  */\n-  if (!memory_operand (src, VOIDmode))\n-    src = replace_equiv_address (src, mips_split_symbol (dest, XEXP (src, 0)));\n+  mips_split_symbol (dest, XEXP (src, 0), mode, &XEXP (src, 0));\n   emit_move_insn (dest, src);\n }\n "}, {"sha": "2e3d52243cfc9377c1ff7bb6aa2b143f1a8e6b93", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=390ea488c1753eaf9c747ead8f653c9023058109", "patch": "@@ -3299,11 +3299,14 @@\n ;; Likewise, for symbolic operands.\n (define_split\n   [(set (match_operand:P 0 \"register_operand\")\n-\t(match_operand:P 1 \"splittable_symbolic_operand\"))\n+\t(match_operand:P 1))\n    (clobber (match_operand:P 2 \"register_operand\"))]\n-  \"\"\n-  [(set (match_dup 0) (match_dup 1))]\n-  { operands[1] = mips_split_symbol (operands[2], operands[1]); })\n+  \"mips_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)\"\n+  [(set (match_dup 0) (match_dup 3))]\n+{\n+  mips_split_symbol (operands[2], operands[1],\n+\t\t     MAX_MACHINE_MODE, &operands[3]);\n+})\n \n ;; 64-bit integer moves\n "}, {"sha": "308dd636f57ccd001315dddf6011f0e884ff52b7", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390ea488c1753eaf9c747ead8f653c9023058109/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=390ea488c1753eaf9c747ead8f653c9023058109", "patch": "@@ -154,16 +154,6 @@\n   return !LUI_INT (op) && !SMALL_INT (op) && !SMALL_INT_UNSIGNED (op);\n })\n \n-;; A legitimate symbolic operand that takes more than one instruction\n-;; to load.\n-(define_predicate \"splittable_symbolic_operand\"\n-  (match_code \"const,symbol_ref,label_ref\")\n-{\n-  enum mips_symbol_type symbol_type;\n-  return (mips_symbolic_constant_p (op, SYMBOL_CONTEXT_LEA, &symbol_type)\n-\t  && mips_split_p[symbol_type]);\n-})\n-\n (define_predicate \"move_operand\"\n   (match_operand 0 \"general_operand\")\n {"}]}