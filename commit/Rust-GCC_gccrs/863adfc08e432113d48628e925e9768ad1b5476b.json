{"sha": "863adfc08e432113d48628e925e9768ad1b5476b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzYWRmYzA4ZTQzMjExM2Q0ODYyOGU5MjVlOTc2OGFkMWI1NDc2Yg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-10T02:58:06Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-05-10T02:58:06Z"}, "message": "69th Cygnus<->FSF merge\n\nFrom-SVN: r9606", "tree": {"sha": "7862fa2b25f79118555ccc1654b75d2f13a854b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7862fa2b25f79118555ccc1654b75d2f13a854b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/863adfc08e432113d48628e925e9768ad1b5476b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/863adfc08e432113d48628e925e9768ad1b5476b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/863adfc08e432113d48628e925e9768ad1b5476b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/863adfc08e432113d48628e925e9768ad1b5476b/comments", "author": null, "committer": null, "parents": [{"sha": "f8e48ed4b86bb7b0aa1aab6412f795bf0014844b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e48ed4b86bb7b0aa1aab6412f795bf0014844b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e48ed4b86bb7b0aa1aab6412f795bf0014844b"}], "stats": {"total": 433, "additions": 237, "deletions": 196}, "files": [{"sha": "93af15dd74e455c3ecc5909ad50ba7df75219f08", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -1,3 +1,69 @@\n+Tue May  9 19:10:33 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c: Add flag_new_for_scope for new -ffor-scope flag.\n+\t* parse.y (FOR): Conditionalize the pushing and poping of scope for\n+\tthe for-init-statement upon the new flag_new_for_scope.\n+\t* parse.y (try_block): Simplify and use compstmt.\n+\n+Mon May  8 12:41:52 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (define_function): Mark function decl artificial.\n+\n+Sun May  7 00:51:28 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (simple_stmt, FOR): Put back push/pop for condition scope.\n+\n+\t* decl2.c (grokclassfn): DECLs don't have cv-qualified types.\n+\t* tree.c (build_cplus_method_type): Ditto.\n+\n+\t* cp-tree.h (SET_DECL_ARTIFICIAL): Just set DECL_ARTIFICIAL to 1.\n+\n+\t* typeck.c (build_function_call_real): If convert_arguments failed,\n+\tjust bail.\n+\t(convert_arguments): If one of the arguments is error_mark_node,\n+\tjust bail.\n+\n+Sat May  6 02:39:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Don't check DECL_NOT_REALLY_EXTERN for\n+\tdecls that don't include it.\n+\n+Fri May  5 14:23:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Decls that have DECL_INTERFACE_KNOWN or\n+\tDECL_NOT_REALLY_EXTERN set aren't extern decls.\n+\n+\t* typeck.c (build_indirect_ref): Don't call default_conversion for a\n+\tparameter of reference_type.\n+\t* cvt.c (convert_from_reference): Just use build_indirect_ref.\n+\n+\t* pt.c (do_type_instantiation): Only instantiate member functions\n+\tthat actually come from templates.\n+\n+Fri May  5 09:46:05 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y: Generalized cleanup of poplevels, and compound statements\n+\tand compound statements in try blocks.  Rewritten `for' rule so that\n+\tthe scope of variables declared in the for clause is shortened to\n+\tspan just to the end of the statement, instead of the whole\n+\tcontaining block.\n+\n+Fri May  5 00:37:14 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (convert_harshness): Handle pointers to members better.\n+\n+Thu May  4 16:00:26 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (delete_sanity): Do access control here.\n+\t* init.c (build_delete): Instead of here.\n+\n+\t* Make-lang.in: Build c++filt.\n+\n+Wed May  3 02:59:53 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (cplus_decl_attributes): If we just modified a TYPE_DECL,\n+\tupdate our IDENTIFIER_TYPE_VALUE.\n+\n Fri Apr 28 07:58:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* lex.c (cons_up_default_function): Fix linkage of #pragma"}, {"sha": "79da7ecdcca5103d3f83f71c6bfa0a45c833c766", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -49,6 +49,8 @@ GXX_INSTALL_NAME = `t='$(program_transform_name)'; echo g++ | sed $$t`\n CXX_CROSS_NAME = `t='$(program_transform_cross_name)'; echo c++ | sed $$t`\n GXX_CROSS_NAME = `t='$(program_transform_cross_name)'; echo g++ | sed $$t`\n \n+# The name to use for the demangler program.\n+DEMANGLER_PROG = c++filt\n \f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n@@ -68,6 +70,17 @@ g++-cross: $(srcdir)/cp/g++.c version.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o g++-cross \\\n \t   -DGCC_NAME=\\\"$(GCC_CROSS_NAME)\\\" $(srcdir)/cp/g++.c version.o $(LIBS)\n \n+cxxmain.o: cplus-dem.c demangle.h\n+\trm -f cxxmain.c\n+\tln -s $(srcdir)/cplus-dem.c cxxmain.c\n+\t$(CC) -c -DMAIN $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -DVERSION='\"$(version)\"' cxxmain.c\n+\trm -f cxxmain.c\n+\n+$(DEMANGLER_PROG): cxxmain.o underscore.o getopt.o getopt1.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $(DEMANGLER_PROG) \\\n+\t  cxxmain.o underscore.o getopt.o getopt1.o\n+\n CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/except.c $(srcdir)/cp/input.c $(srcdir)/cp/pt.c \\\n  $(srcdir)/cp/spew.c $(srcdir)/cp/xref.c $(srcdir)/cp/class.c \\\n@@ -83,10 +96,10 @@ cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \f\n # Build hooks:\n \n-c++.all.build: g++\n-c++.all.cross: g++-cross\n+c++.all.build: g++ $(DEMANGLER_PROG)\n+c++.all.cross: g++-cross $(DEMANGLER_PROG)\n c++.start.encap: g++\n-c++.rest.encap:\n+c++.rest.encap: $(DEMANGLER_PROG)\n \n c++.info:\n c++.dvi:"}, {"sha": "9695968f5f030fc27c5623740065706432cc7aae", "filename": "gcc/cp/call.c", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -172,10 +172,33 @@ convert_harshness (type, parmtype, parm)\n       if (coder != TREE_CODE (type))\n \treturn EVIL_RETURN (h);\n \n+      if (type != parmtype && coder == METHOD_TYPE)\n+\t{\n+\t  tree ttl = TYPE_METHOD_BASETYPE (type);\n+\t  tree ttr = TYPE_METHOD_BASETYPE (parmtype);\n+\n+\t  int b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t  if (b_or_d < 0)\n+\t    {\n+\t      b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t      if (b_or_d < 0)\n+\t\treturn EVIL_RETURN (h);\n+\t      h.distance = -b_or_d;\n+\t    }\n+\t  else\n+\t    h.distance = b_or_d;\n+\t  h.code = STD_CODE;\n+\n+\t  type = build_function_type\n+\t    (TREE_TYPE (type), TREE_CHAIN (TYPE_ARG_TYPES (type)));\n+\t  parmtype = build_function_type\n+\t    (TREE_TYPE (parmtype), TREE_CHAIN (TYPE_ARG_TYPES (parmtype)));\n+\t}\n+\n       /* We allow the default conversion between function type\n \t and pointer-to-function type for free.  */\n       if (type == parmtype)\n-\treturn ZERO_RETURN (h);\n+\treturn h;\n \n       if (pedantic)\n \treturn EVIL_RETURN (h);\n@@ -272,28 +295,34 @@ convert_harshness (type, parmtype, parm)\n     }\n   else if (codel == POINTER_TYPE && coder == OFFSET_TYPE)\n     {\n+      tree ttl, ttr;\n+\n       /* Get to the OFFSET_TYPE that this might be.  */\n       type = TREE_TYPE (type);\n \n       if (coder != TREE_CODE (type))\n \treturn EVIL_RETURN (h);\n \n-      if (TYPE_OFFSET_BASETYPE (type) == TYPE_OFFSET_BASETYPE (parmtype))\n+      ttl = TYPE_OFFSET_BASETYPE (type);\n+      ttr = TYPE_OFFSET_BASETYPE (parmtype);\n+\n+      if (ttl == ttr)\n \th.code = 0;\n-      else if (UNIQUELY_DERIVED_FROM_P (TYPE_OFFSET_BASETYPE (type),\n-\t\t\t       TYPE_OFFSET_BASETYPE (parmtype)))\n-\t{\n-\t  h.code = STD_CODE;\n-\t  h.distance = 1;\n-\t}\n-      else if (UNIQUELY_DERIVED_FROM_P (TYPE_OFFSET_BASETYPE (parmtype),\n-\t\t\t       TYPE_OFFSET_BASETYPE (type)))\n+      else\n \t{\n+\t  int b_or_d = get_base_distance (ttr, ttl, 0, 0);\n+\t  if (b_or_d < 0)\n+\t    {\n+\t      b_or_d = get_base_distance (ttl, ttr, 0, 0);\n+\t      if (b_or_d < 0)\n+\t\treturn EVIL_RETURN (h);\n+\t      h.distance = -b_or_d;\n+\t    }\n+\t  else\n+\t    h.distance = b_or_d;\n \t  h.code = STD_CODE;\n-\t  h.distance = -1;\n \t}\n-      else\n-\treturn EVIL_RETURN (h);\n+\n       /* Now test the OFFSET_TYPE's target compatibility.  */\n       type = TREE_TYPE (type);\n       parmtype = TREE_TYPE (parmtype);"}, {"sha": "828e3f496ddca92b53cce4f0f77bd3db753281ee", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -1141,8 +1141,7 @@ struct lang_decl\n #endif\n \n /* This _DECL represents a compiler-generated entity.  */\n-#define DECL_ARTIFICIAL(NODE) (DECL_SOURCE_LINE (NODE) == 0)\n-#define SET_DECL_ARTIFICIAL(NODE) (DECL_SOURCE_LINE (NODE) = 0)\n+#define SET_DECL_ARTIFICIAL(NODE) (DECL_ARTIFICIAL (NODE) = 1)\n \n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))"}, {"sha": "3bde08dfedca8f558a13197a212a1444250ffea6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -855,30 +855,8 @@ convert_from_reference (val)\n \n   if (TREE_CODE (type) == OFFSET_TYPE)\n     type = TREE_TYPE (type);\n- if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      tree target_type = TREE_TYPE (type);\n-      tree nval;\n-\n-      /* This can happen if we cast to a reference type.  */\n-      if (TREE_CODE (val) == ADDR_EXPR)\n-\t{\n-\t  nval = build1 (NOP_EXPR, build_pointer_type (target_type), val);\n-\t  nval = build_indirect_ref (nval, NULL_PTR);\n-\t  /* The below was missing, are other important flags missing too? */\n-\t  TREE_SIDE_EFFECTS (nval) = TREE_SIDE_EFFECTS (val);\n-\t  return nval;\n-\t}\n-\n-      nval = build1 (INDIRECT_REF, target_type, val);\n-\n-      TREE_THIS_VOLATILE (nval) = TYPE_VOLATILE (target_type);\n-      TREE_SIDE_EFFECTS (nval) = TYPE_VOLATILE (target_type);\n-      TREE_READONLY (nval) = TYPE_READONLY (target_type);\n-      /* The below was missing, are other important flags missing too? */\n-      TREE_SIDE_EFFECTS (nval) |= TREE_SIDE_EFFECTS (val);\n-      return nval;\n-    }\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    return build_indirect_ref (val, NULL_PTR);\n   return val;\n }\n \f"}, {"sha": "2471c1547a9f9165aa39ab49a5d5759acceba1a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -2507,7 +2507,8 @@ duplicate_decls (newdecl, olddecl)\n     }\n \n   /* Merge the storage class information.  */\n-  if (DECL_EXTERNAL (newdecl))\n+  if (DECL_EXTERNAL (newdecl) && ! DECL_INTERFACE_KNOWN (newdecl)\n+      && ! (DECL_LANG_SPECIFIC (newdecl) && DECL_NOT_REALLY_EXTERN (newdecl)))\n     {\n       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n       DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n@@ -5261,6 +5262,7 @@ define_function (name, type, function_code, pfn, library_name)\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   DECL_INTERFACE_KNOWN (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n \n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this"}, {"sha": "5909f87a0c208d0345509af52a03c5350af24a72", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -359,6 +359,11 @@ int flag_operator_names;\n \n int flag_check_new;\n \n+/* Nonzero if we want the new ANSI rules for pushing a new scope for `for'\n+   initialization variables.  Default to on.  */\n+\n+int flag_new_for_scope = 1;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -405,7 +410,8 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"gnu-keywords\", &flag_no_gnu_keywords, 0},\n   {\"operator-names\", &flag_operator_names, 1},\n   {\"check-new\", &flag_check_new, 1},\n-  {\"repo\", &flag_use_repository, 1}\n+  {\"repo\", &flag_use_repository, 1},\n+  {\"for-scope\", &flag_new_for_scope, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -418,7 +424,7 @@ lang_decode_option (p)\n {\n   if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n     flag_traditional = 1, dollars_in_ident = 1, flag_writable_strings = 1,\n-    flag_this_is_variable = 1;\n+    flag_this_is_variable = 1, flag_new_for_scope = 0;\n   /* The +e options are for cfront compatibility.  They come in as\n      `-+eN', to kludge around gcc.c's argument handling.  */\n   else if (p[0] == '-' && p[1] == '+' && p[2] == 'e')\n@@ -872,10 +878,11 @@ grokclassfn (ctype, cname, function, flags, quals)\n       /* Right now we just make this a pointer.  But later\n \t we may wish to make it special.  */\n       tree type = TREE_VALUE (arg_types);\n+      int constp = 1;\n \n       if ((flag_this_is_variable > 0)\n \t  && (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function)))\n-\ttype = TYPE_MAIN_VARIANT (type);\n+\tconstp = 0;\n \n       if (DECL_CONSTRUCTOR_P (function))\n \t{\n@@ -902,7 +909,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n       DECL_REGISTER (parm) = 1;\n-      if (TYPE_READONLY (type))\n+      if (constp)\n \tTREE_READONLY (parm) = 1;\n       TREE_CHAIN (parm) = last_function_parms;\n       last_function_parms = parm;\n@@ -1178,9 +1185,22 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n     return build_vec_delete (t, maxindex, elt_size, integer_one_node,\n \t\t\t     integer_two_node, use_global_delete);\n   else\n-    return build_delete (type, t, integer_three_node,\n-\t\t\t LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE,\n-\t\t\t use_global_delete);\n+    {\n+      if (IS_AGGR_TYPE (TREE_TYPE (type))\n+\t  && TYPE_GETS_REG_DELETE (TREE_TYPE (type)))\n+\t{\n+\t  /* Only do access checking here; we'll be calling op delete\n+\t     from the destructor.  */\n+\t  tree tmp = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, t,\n+\t\t\t\t     size_zero_node, NULL_TREE);\n+\t  if (tmp == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+\n+      return build_delete (type, t, integer_three_node,\n+\t\t\t   LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE,\n+\t\t\t   use_global_delete);\n+    }\n }\n \n /* Sanity check: report error if this function FUNCTION is not\n@@ -1956,6 +1976,9 @@ cplus_decl_attributes (decl, attributes, prefix_attributes)\n     decl = DECL_TEMPLATE_RESULT (decl);\n \n   decl_attributes (decl, attributes, prefix_attributes);\n+\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (decl), TREE_TYPE (decl));\n }\n \f\n /* CONSTRUCTOR_NAME:"}, {"sha": "39db6447fe3445faac8762a0b468cec363a918c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -3626,18 +3626,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t\t\t\t\t    auto_delete, integer_two_node));\n \t}\n       else\n-\t{\n-\t  if (TYPE_GETS_REG_DELETE (type))\n-\t    {\n-\t      /* Only do access checking here; we'll be calling op delete\n-                 from the destructor.  */\n-\t      tree t = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n-\t\t\t\t       size_zero_node, NULL_TREE);\n-\t      if (t == error_mark_node)\n-\t\treturn error_mark_node;\n-\t    }\n-\t  passed_auto_delete = auto_delete;\n-\t}\n+\tpassed_auto_delete = auto_delete;\n \n       if (flags & LOOKUP_PROTECT)\n \t{"}, {"sha": "b66c32a076a0b090cf3bdb87f51c5f9f58618a0b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 62, "deletions": 123, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -233,12 +233,12 @@ empty_parms ()\n %type <ttype> base_class maybe_base_class_list base_class.1\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> component_declarator0\n-%type <ttype> forhead.1 operator_name\n+%type <ttype> operator_name\n %type <ttype> object aggr\n %type <itype> new delete\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr maybe_parmlist\n-%type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n+%type <itype> initdcl0 notype_initdcl0 member_init_list\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm\n %type <ttype> template_type template_arg_list template_arg\n@@ -252,7 +252,7 @@ empty_parms ()\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n %type <ttype> new_initializer new_placement specialization type_specifier_seq\n-%type <ttype> using_decl\n+%type <ttype> using_decl .poplevel\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n@@ -262,8 +262,6 @@ empty_parms ()\n %token NSNAME\n %type <ttype> NSNAME\n \n-%type <strtype> .pushlevel\n-\n /* Used in lex.c for parsing pragmas.  */\n %token END_OF_LINE\n \n@@ -983,12 +981,15 @@ condition:\n \t| expr\n \t;\n \n+compstmtend:\n+\t  '}'\n+\t| maybe_label_decls stmts '}'\n+\t| maybe_label_decls stmts error '}'\n+\t| maybe_label_decls error '}'\n+\t;\n+\n already_scoped_stmt:\n-\t  '{' '}'\n-\t\t{ finish_stmt (); }\n-\t| '{' maybe_label_decls stmts '}'\n-\t\t{ finish_stmt (); }\n-\t| '{' maybe_label_decls error '}'\n+\t  '{' compstmtend\n \t\t{ finish_stmt (); }\n \t| simple_stmt\n \t;\n@@ -3105,6 +3106,12 @@ errstmt:  error ';'\n \t\t  expand_start_bindings (0); }\n \t;\n \n+.poplevel:   /* empty */\n+\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n+\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n+\t\t  pop_momentary (); }\n+\t;\n+\n /* Read zero or more forward-declarations for labels\n    that nested functions can jump to.  */\n maybe_label_decls:\n@@ -3139,22 +3146,8 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt: '{' .pushlevel '}'\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); }\n-\t| '{' .pushlevel maybe_label_decls stmts '}'\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); }\n-\t| '{' .pushlevel maybe_label_decls stmts error '}'\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n-\t\t  pop_momentary (); }\n-\t| '{' .pushlevel maybe_label_decls error '}'\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p(), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0);\n-\t\t  pop_momentary (); }\n+compstmt: '{' .pushlevel compstmtend .poplevel\n+\t\t{ $$ = $4; }\n \t;\n \n simple_if:\n@@ -3169,10 +3162,8 @@ simple_if:\n implicitly_scoped_stmt:\n \t  compstmt\n \t\t{ finish_stmt (); }\n-\t| .pushlevel simple_stmt\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  $$ = poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary (); }\n+\t| .pushlevel simple_stmt .poplevel\n+\t\t{ $$ = $3; }\n \t;\n \n stmt:\n@@ -3201,11 +3192,9 @@ simple_stmt:\n \t| simple_if ELSE\n \t\t{ expand_start_else (); }\n \t  implicitly_scoped_stmt\n-\t\t{ expand_end_cond ();\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  finish_stmt (); }\n+\t\t{ expand_end_cond (); }\n+\t  .poplevel\n+\t\t{ finish_stmt (); }\n \t| simple_if %prec IF\n \t\t{ expand_end_cond ();\n \t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n@@ -3219,11 +3208,8 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"while\"; }\n \t  .pushlevel paren_cond_or_null\n \t\t{ expand_exit_loop_if_false (0, $4); }\n-\t  already_scoped_stmt\n-\t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  expand_end_loop ();\n+\t  already_scoped_stmt .poplevel\n+\t\t{ expand_end_loop ();\n \t\t  finish_stmt (); }\n \t| DO\n \t\t{ emit_nop ();\n@@ -3238,51 +3224,42 @@ simple_stmt:\n \t\t  expand_end_loop ();\n \t\t  clear_momentary ();\n \t\t  finish_stmt (); }\n-\t| forhead.1\n+\t| FOR\n+\t\t{ extern int flag_new_for_scope;\n+\t\t  emit_line_note (input_filename, lineno);\n+\t\t  if (flag_new_for_scope)\n+\t\t    {\n+\t\t      /* Conditionalize .pushlevel */\n+\t\t      pushlevel (0);\n+\t\t      clear_last_expr ();\n+\t\t      push_momentary ();\n+\t\t      expand_start_bindings (0);\n+\t\t    }\n+\t\t}\n+\t  '(' for.init.statement\n \t\t{ emit_nop ();\n \t\t  emit_line_note (input_filename, lineno);\n-\t\t  if ($1) cplus_expand_expr_stmt ($1);\n \t\t  expand_start_loop_continue_elsewhere (1); }\n \t  .pushlevel xcond ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, $4); }\n+\t\t  if ($7) expand_exit_loop_if_false (0, $7); }\n \t  xexpr ')'\n-\t\t/* Don't let the tree nodes for $7 be discarded\n+\t\t/* Don't let the tree nodes for $10 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n \t\t{ push_momentary (); }\n-\t  already_scoped_stmt\n+\t  already_scoped_stmt .poplevel\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n \t\t  expand_loop_continue_here ();\n-\t\t  if ($7) cplus_expand_expr_stmt ($7);\n+\t\t  if ($10) cplus_expand_expr_stmt ($10);\n \t\t  pop_momentary ();\n \t\t  expand_end_loop ();\n+\t\t  if (flag_new_for_scope)\n+\t\t    {\n+\t\t      expand_end_bindings (getdecls (), kept_level_p (), 1);\n+\t\t      poplevel (kept_level_p (), 1, 0);\n+\t\t      pop_momentary ();\n+\t\t    }\n \t\t  finish_stmt (); }\n-\t| forhead.2\n-\t\t{ emit_nop ();\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_start_loop_continue_elsewhere (1); }\n-\t  .pushlevel xcond ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, $4); }\n-\t  xexpr ')'\n-\t\t/* Don't let the tree nodes for $7 be discarded\n-\t\t   by clear_momentary during the parsing of the next stmt.  */\n-\t\t{ push_momentary ();\n-\t\t  $<itype>8 = lineno; }\n-\t  already_scoped_stmt\n-\t\t{ emit_line_note (input_filename, (int) $<itype>8);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($7) cplus_expand_expr_stmt ($7);\n-\t\t  pop_momentary ();\n-\t\t  expand_end_loop ();\n-\t\t  finish_stmt ();\n-\t\t}\n \t| SWITCH .pushlevel '(' condition ')'\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  c_expand_start_case ($4);\n@@ -3293,11 +3270,9 @@ simple_stmt:\n \t  implicitly_scoped_stmt\n \t\t{ expand_end_case ($4);\n \t\t  pop_momentary ();\n-\t\t  pop_switch ();\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n-\t\t  finish_stmt (); }\n+\t\t  pop_switch (); }\n+\t  .poplevel\n+\t\t{ finish_stmt (); }\n \t| CASE expr_no_commas ':'\n \t\t{ register tree value = check_cp_case_value ($2);\n \t\t  register tree label\n@@ -3442,43 +3417,20 @@ simple_stmt:\n \t;\n \n try_block:\n-\t  TRY '{' .pushlevel\n+\t  TRY\n \t\t{ expand_start_try_stmts (); }\n-\t  ansi_try_stmts\n+\t  compstmt\n \t\t{ expand_end_try_stmts ();\n \t\t  expand_start_all_catch (); }\n \t  handler_seq\n \t\t{ expand_end_all_catch (); }\n \t;\n \n-ansi_try_stmts:\n-\t  '}'\n-\t\t/* An empty try block is degenerate, but it's better to\n-\t\t   do extra work here than to do all the special-case work\n-\t\t   everywhere else.  */\n-\t\t{ expand_end_bindings (0,1,1);\n-\t\t  poplevel (2,0,0);\n-\t\t}\n-\t| stmts '}'\n-\t\t{ expand_end_bindings (0,1,1);\n-\t\t  poplevel (2,0,0);\n-\t\t}\n-\t| error '}'\n-\t\t{ expand_end_bindings (0,1,1);\n-\t\t  poplevel (2,0,0);\n-\t\t}\n-\t;\n-\n handler_seq:\n \t  /* empty */\n-\t| handler_seq CATCH\n-\t\t{ emit_line_note (input_filename, lineno); }\n-          .pushlevel handler_args compstmt\n-\t\t{ expand_end_catch_block ();\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n-\t\t}\n+\t| handler_seq CATCH .pushlevel handler_args compstmt\n+\t\t{ expand_end_catch_block (); }\n+\t  .poplevel\n \t;\n \n type_specifier_seq:\n@@ -3518,24 +3470,11 @@ label_colon:\n \t\t{ goto do_label; }\n \t;\n \n-forhead.1:\n-\t  FOR '(' ';'\n-\t\t{ $$ = NULL_TREE; }\n-\t| FOR '(' expr ';'\n-\t\t{ $$ = $3; }\n-\t| FOR '(' '{' '}'\n-\t\t{ $$ = NULL_TREE; }\n-\t;\n-\n-forhead.2:\n-\t  FOR '(' decl\n-\t\t{ $$ = 0; }\n-\t| FOR '(' error ';'\n-\t\t{ $$ = 0; }\n-\t| FOR '(' '{' .pushlevel stmts '}'\n-\t\t{ $$ = 1; }\n-\t| FOR '(' '{' .pushlevel error '}'\n-\t\t{ $$ = -1; }\n+for.init.statement:\n+\t  xexpr ';'\n+\t\t{ if ($1) cplus_expand_expr_stmt ($1); }\n+\t| decl\n+\t| '{' compstmtend\n \t;\n \n /* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */"}, {"sha": "fe47d1cb60a1b2d8570c8d5edfc38e0f9ed8365a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -2648,10 +2648,11 @@ do_type_instantiation (name, storage)\n     /* this should really be done by instantiate_member_templates */\n     tmp = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n     for (; tmp; tmp = TREE_CHAIN (tmp))\n-      {\n-\tmark_function_instantiated (tmp, extern_p);\n-\trepo_template_instantiated (tmp, extern_p);\n-      }\n+      if (DECL_TEMPLATE_INSTANTIATION (tmp))\n+\t{\n+\t  mark_function_instantiated (tmp, extern_p);\n+\t  repo_template_instantiated (tmp, extern_p);\n+\t}\n \n #if 0\n     for (tmp = TYPE_FIELDS (t); tmp; tmp = TREE_CHAIN (tmp))"}, {"sha": "3581348686a0c70a206e871fb38b80e4769a832f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -397,10 +397,8 @@ build_cplus_method_type (basetype, rettype, argtypes)\n \t\t\t\t\t  TYPE_READONLY (basetype),\n \t\t\t\t\t  TYPE_VOLATILE (basetype));\n   else\n-    {\n-      ptype = build_pointer_type (basetype);\n-      ptype = build_type_variant (ptype, 1, 0);\n-    }\n+    ptype = build_pointer_type (basetype);\n+\n   /* The actual arglist for this function includes a \"hidden\" argument\n      which is \"this\".  Put it into the list of argument types.  */\n "}, {"sha": "0bede446074dc8e95eabbbd41eb3dea0c82618d2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/863adfc08e432113d48628e925e9768ad1b5476b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=863adfc08e432113d48628e925e9768ad1b5476b", "patch": "@@ -1823,7 +1823,8 @@ build_indirect_ref (ptr, errorstring)\n      tree ptr;\n      char *errorstring;\n {\n-  register tree pointer = default_conversion (ptr);\n+  register tree pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE ?\n+\t\t\t   ptr : default_conversion (ptr));\n   register tree type = TREE_TYPE (pointer);\n \n   if (ptr == current_class_decl)\n@@ -2427,6 +2428,9 @@ build_function_call_real (function, params, require_complete, flags)\n     coerced_params = convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n \t\t\t\t\tparams, fndecl, 0);\n \n+  if (coerced_params == error_mark_node)\n+    return error_mark_node;\n+\n   /* Check for errors in format strings.  */\n \n   if (warn_format && (name || assembler_name))\n@@ -2541,7 +2545,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       register tree val = TREE_VALUE (valtail);\n \n       if (val == error_mark_node)\n-\tcontinue;\n+\treturn error_mark_node;\n \n       if (type == void_type_node)\n \t{\n@@ -2628,7 +2632,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t}\n \n       if (val == error_mark_node)\n-\tcontinue;\n+\treturn error_mark_node;\n \n       if (type != 0)\n \t{"}]}