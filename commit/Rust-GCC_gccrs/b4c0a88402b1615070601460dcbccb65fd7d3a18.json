{"sha": "b4c0a88402b1615070601460dcbccb65fd7d3a18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjMGE4ODQwMmIxNjE1MDcwNjAxNDYwZGNiY2NiNjVmZDdkM2ExOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-07T20:31:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-07T20:31:37Z"}, "message": "ipa-inline-transform.c (inline_call): Account when program size decreases.\n\n\n\t* ipa-inline-transform.c (inline_call): Account when program size decreases.\n\t* ipa-inline.c (relative_time_benefit): New function.\n\t(edge_badness): Reorganize to be power 2 based; fix\n\tthinko when computing badness for negative growth; update\n\tcomments to match reality; better dumps.\n\nFrom-SVN: r173537", "tree": {"sha": "8a6c02190f64c6038307b9786aa310fc51131c1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a6c02190f64c6038307b9786aa310fc51131c1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c0a88402b1615070601460dcbccb65fd7d3a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c0a88402b1615070601460dcbccb65fd7d3a18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c0a88402b1615070601460dcbccb65fd7d3a18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c0a88402b1615070601460dcbccb65fd7d3a18/comments", "author": null, "committer": null, "parents": [{"sha": "f620bd21a10243179ad6e33d08d78a8148c48129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f620bd21a10243179ad6e33d08d78a8148c48129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f620bd21a10243179ad6e33d08d78a8148c48129"}], "stats": {"total": 147, "additions": 100, "deletions": 47}, "files": [{"sha": "bf01f7bf4681d34376011e79425aecb5afc16782", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4c0a88402b1615070601460dcbccb65fd7d3a18", "patch": "@@ -1,3 +1,11 @@\n+2011-05-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (inline_call): Account when program size decreases.\n+\t* ipa-inline.c (relative_time_benefit): New function.\n+\t(edge_badness): Reorganize to be power 2 based; fix\n+\tthinko when computing badness for negative growth; update\n+\tcomments to match reality; better dumps.\n+\n 2011-05-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* langhooks.h (lang_hooks_for_types): Change global_bindings_p's return"}, {"sha": "cf24a62caf78206ee358fba58a3db66ec6b72fee", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=b4c0a88402b1615070601460dcbccb65fd7d3a18", "patch": "@@ -184,7 +184,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   old_size = inline_summary (to)->size;\n   inline_merge_summary (e);\n   new_size = inline_summary (to)->size;\n-  if (overall_size && new_size > old_size)\n+  if (overall_size)\n     *overall_size += new_size - old_size;\n   ncalls_inlined++;\n "}, {"sha": "fbc6918c12bafc2c8abb044106a6dfc5de172f3c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 91, "deletions": 46, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c0a88402b1615070601460dcbccb65fd7d3a18/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b4c0a88402b1615070601460dcbccb65fd7d3a18", "patch": "@@ -666,6 +666,37 @@ want_inline_function_called_once_p (struct cgraph_node *node)\n    return true;\n }\n \n+\n+/* Return relative time improvement for inlining EDGE in range\n+   1...2^9.  */\n+\n+static inline int\n+relative_time_benefit (struct inline_summary *callee_info,\n+\t\t       struct cgraph_edge *edge,\n+\t\t       int time_growth)\n+{\n+  int relbenefit;\n+  gcov_type uninlined_call_time;\n+\n+  uninlined_call_time =\n+    ((gcov_type)\n+     (callee_info->time\n+      + inline_edge_summary (edge)->call_stmt_time\n+      + CGRAPH_FREQ_BASE / 2) * edge->frequency\n+     / CGRAPH_FREQ_BASE);\n+  /* Compute relative time benefit, i.e. how much the call becomes faster.\n+     ??? perhaps computing how much the caller+calle together become faster\n+     would lead to more realistic results.  */\n+  if (!uninlined_call_time)\n+    uninlined_call_time = 1;\n+  relbenefit =\n+    (uninlined_call_time - time_growth) * 256 / (uninlined_call_time);\n+  relbenefit = MIN (relbenefit, 512);\n+  relbenefit = MAX (relbenefit, 1);\n+  return relbenefit;\n+}\n+\n+\n /* A cost model driving the inlining heuristics in a way so the edges with\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n@@ -690,34 +721,37 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n       fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n \t       cgraph_node_name (edge->caller),\n \t       cgraph_node_name (edge->callee));\n-      fprintf (dump_file, \"      growth size %i, time %i\\n\",\n+      fprintf (dump_file, \"      size growth %i, time growth %i\\n\",\n \t       growth,\n \t       time_growth);\n     }\n \n   /* Always prefer inlining saving code size.  */\n   if (growth <= 0)\n     {\n-      badness = INT_MIN - growth;\n+      badness = INT_MIN / 2 + growth;\n       if (dump)\n-\tfprintf (dump_file, \"      %i: Growth %i < 0\\n\", (int) badness,\n+\tfprintf (dump_file, \"      %i: Growth %i <= 0\\n\", (int) badness,\n \t\t growth);\n     }\n \n-  /* When profiling is available, base priorities -(#calls / growth).\n-     So we optimize for overall number of \"executed\" inlined calls.  */\n+  /* When profiling is available, compute badness as:\n+\n+\t        relative_edge_count * relative_time_benefit\n+     goodness = -------------------------------------------\n+\t\tedge_growth\n+     badness = -goodness  \n+\n+    The fraction is upside down, becuase on edge counts and time beneits\n+    the bounds are known. Edge growth is essentially unlimited.  */\n+\n   else if (max_count)\n     {\n-      int benefitperc;\n-      benefitperc = (((gcov_type)callee_info->time\n-\t\t     * edge->frequency / CGRAPH_FREQ_BASE - time_growth) * 100\n-\t\t     / (callee_info->time + 1) + 1);\n-      benefitperc = MIN (benefitperc, 100);\n-      benefitperc = MAX (benefitperc, 0);\n+      int relbenefit = relative_time_benefit (callee_info, edge, time_growth);\n       badness =\n \t((int)\n-\t ((double) edge->count * INT_MIN / max_count / 100) *\n-\t benefitperc) / growth;\n+\t ((double) edge->count * INT_MIN / 2 / max_count / 512) *\n+\t relative_time_benefit (callee_info, edge, time_growth)) / growth;\n       \n       /* Be sure that insanity of the profile won't lead to increasing counts\n \t in the scalling and thus to overflow in the computation above.  */\n@@ -729,51 +763,62 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" * Relative benefit %f\\n\",\n \t\t   (int) badness, (double) badness / INT_MIN,\n \t\t   (double) edge->count / max_count,\n-\t\t   (double) benefitperc);\n+\t\t   relbenefit * 100 / 256.0);\n \t}\n     }\n \n-  /* When function local profile is available, base priorities on\n-     growth / frequency, so we optimize for overall frequency of inlined\n-     calls.  This is not too accurate since while the call might be frequent\n-     within function, the function itself is infrequent.\n+  /* When function local profile is available. Compute badness as:\n \n-     Other objective to optimize for is number of different calls inlined.\n-     We add the estimated growth after inlining all functions to bias the\n-     priorities slightly in this direction (so fewer times called functions\n-     of the same size gets priority).  */\n+     \n+               growth_of_callee\n+     badness = -------------------------------------- + growth_for-all\n+\t       relative_time_benefit * edge_frequency\n+\n+  */\n   else if (flag_guess_branch_prob)\n     {\n-      int div = edge->frequency * 100 / CGRAPH_FREQ_BASE + 1;\n-      int benefitperc;\n+      int div = edge->frequency * (1<<10) / CGRAPH_FREQ_MAX;\n       int growth_for_all;\n-      badness = growth * 10000;\n-      benefitperc = (((gcov_type)callee_info->time\n-\t\t     * edge->frequency / CGRAPH_FREQ_BASE - time_growth) * 100\n-\t\t     / (callee_info->time + 1) + 1);\n-      benefitperc = MIN (benefitperc, 100);\n-      benefitperc = MAX (benefitperc, 0);\n-      div *= benefitperc;\n \n-      /* Decrease badness if call is nested.  */\n-      /* Compress the range so we don't overflow.  */\n-      if (div > 10000)\n-\tdiv = 10000 + ceil_log2 (div) - 8;\n-      if (div < 1)\n-\tdiv = 1;\n-      if (badness > 0)\n-\tbadness /= div;\n+      div = MAX (div, 1);\n+      gcc_checking_assert (edge->frequency <= CGRAPH_FREQ_MAX);\n+      div *= relative_time_benefit (callee_info, edge, time_growth);\n+\n+      /* frequency is normalized in range 1...2^10.\n+         relbenefit in range 1...2^9\n+\t DIV should be in range 1....2^19.  */\n+      gcc_checking_assert (div >= 1 && div <= (1<<19));\n+\n+      /* Result must be integer in range 0...INT_MAX.\n+\t Set the base of fixed point calculation so we don't lose much of\n+\t precision for small bandesses (those are interesting) yet we don't\n+\t overflow for growths that are still in interesting range.  */\n+      badness = ((gcov_type)growth) * (1<<18);\n+      badness = (badness + div / 2) / div;\n+\n+      /* Overall growth of inlining all calls of function matters: we want to\n+\t inline so offline copy of function is no longer needed.\n+\n+\t Additionally functions that can be fully inlined without much of\n+\t effort are better inline candidates than functions that can be fully\n+\t inlined only after noticeable overall unit growths. The latter\n+\t are better in a sense compressing of code size by factoring out common\n+\t code into separate function shared by multiple code paths.\n+\n+\t We might mix the valud into the fraction by taking into account\n+\t relative growth of the unit, but for now just add the number\n+\t into resulting fraction.  */\n       growth_for_all = estimate_growth (edge->callee);\n       badness += growth_for_all;\n-      if (badness > INT_MAX)\n-\tbadness = INT_MAX;\n+      if (badness > INT_MAX - 1)\n+\tbadness = INT_MAX - 1;\n       if (dump)\n \t{\n \t  fprintf (dump_file,\n-\t\t   \"      %i: guessed profile. frequency %i, overall growth %i,\"\n-\t\t   \" benefit %i%%, divisor %i\\n\",\n-\t\t   (int) badness, edge->frequency, growth_for_all,\n-\t\t   benefitperc, div);\n+\t\t   \"      %i: guessed profile. frequency %f, overall growth %i,\"\n+\t\t   \" benefit %f%%, divisor %i\\n\",\n+\t\t   (int) badness, (double)edge->frequency / CGRAPH_FREQ_BASE, growth_for_all,\n+\t\t   relative_time_benefit (callee_info, edge, time_growth) * 100 / 256.0, div);\n \t}\n     }\n   /* When function local profile is not available or it does not give\n@@ -823,7 +868,6 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t a minimum of heap.  */\n       if (badness < n->key)\n \t{\n-\t  fibheap_replace_key (heap, n, badness);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file,\n@@ -833,6 +877,7 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t\t       (int)n->key,\n \t\t       badness);\n \t    }\n+\t  fibheap_replace_key (heap, n, badness);\n \t  gcc_checking_assert (n->key == badness);\n \t}\n     }"}]}