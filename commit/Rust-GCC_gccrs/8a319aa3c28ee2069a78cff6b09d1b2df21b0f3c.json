{"sha": "8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzMTlhYTNjMjhlZTIwNjlhNzhjZmY2YjA5ZDFiMmRmMjFiMGYzYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-10-30T12:01:25Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T12:01:25Z"}, "message": "Integrate that for IPA ICF.\n\n2019-10-30  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf-gimple.c (func_checker::hash_operand): New.\n\t(func_checker::compare_cst_or_decl): Remove handling\n\tof FIELD_DECL.\n\t(func_checker::compare_operand): Transform to ...\n\t(func_checker::operand_equal_p): ... this.\n\t* ipa-icf-gimple.h (class func_checker): Add\n\toperand_equal_p and hash_operand.\n\t* ipa-icf.c (sem_function::equals_private): Fix\n\tpushing and popping of cfun.\n\nFrom-SVN: r277615", "tree": {"sha": "65ec8ca7e1080eb77d979cd99221befccc0887ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ec8ca7e1080eb77d979cd99221befccc0887ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4a8ee03d404c560dcb75ba684fd57ffbc77e85"}], "stats": {"total": 259, "additions": 107, "deletions": 152}, "files": [{"sha": "a4315789ccdc47b0a14eae34b6864cd8fab86359", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "patch": "@@ -1,3 +1,15 @@\n+2019-10-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf-gimple.c (func_checker::hash_operand): New.\n+\t(func_checker::compare_cst_or_decl): Remove handling\n+\tof FIELD_DECL.\n+\t(func_checker::compare_operand): Transform to ...\n+\t(func_checker::operand_equal_p): ... this.\n+\t* ipa-icf-gimple.h (class func_checker): Add\n+\toperand_equal_p and hash_operand.\n+\t* ipa-icf.c (sem_function::equals_private): Fix\n+\tpushing and popping of cfun.\n+\n 2019-10-30  Martin Liska  <mliska@suse.cz>\n \n \t* fold-const.c (operand_equal_p): Move to ..."}, {"sha": "96e688c129d9c0309c907c47fbe771af5315b025", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 79, "deletions": 149, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "patch": "@@ -324,6 +324,34 @@ func_checker::compare_memory_operand (tree t1, tree t2)\n /* Function compare for equality given trees T1 and T2 which\n    can be either a constant or a declaration type.  */\n \n+void\n+func_checker::hash_operand (const_tree arg, inchash::hash &hstate,\n+\t\t\t    unsigned int flags)\n+{\n+  if (arg == NULL_TREE)\n+    {\n+      hstate.merge_hash (0);\n+      return;\n+    }\n+\n+  switch (TREE_CODE (arg))\n+    {\n+    case FUNCTION_DECL:\n+    case VAR_DECL:\n+    case LABEL_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case CONST_DECL:\n+    case SSA_NAME:\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  return operand_compare::hash_operand (arg, hstate, flags);\n+}\n+\n bool\n func_checker::compare_cst_or_decl (tree t1, tree t2)\n {\n@@ -347,19 +375,6 @@ func_checker::compare_cst_or_decl (tree t1, tree t2)\n       return true;\n     case VAR_DECL:\n       return return_with_debug (compare_variable_decl (t1, t2));\n-    case FIELD_DECL:\n-      {\n-\ttree offset1 = DECL_FIELD_OFFSET (t1);\n-\ttree offset2 = DECL_FIELD_OFFSET (t2);\n-\n-\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n-\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n-\n-\tret = compare_operand (offset1, offset2)\n-\t      && compare_operand (bit_offset1, bit_offset2);\n-\n-\treturn return_with_debug (ret);\n-      }\n     case LABEL_DECL:\n       {\n \tif (t1 == t2)\n@@ -383,165 +398,80 @@ func_checker::compare_cst_or_decl (tree t1, tree t2)\n     }\n }\n \n-/* Function responsible for comparison of various operands T1 and T2.\n-   If these components, from functions FUNC1 and FUNC2, are equal, true\n-   is returned.  */\n-\n bool\n-func_checker::compare_operand (tree t1, tree t2)\n+func_checker::operand_equal_p (const_tree t1, const_tree t2,\n+\t\t\t       unsigned int flags)\n {\n-  tree x1, x2, y1, y2, z1, z2;\n-  bool ret;\n+  bool r;\n+  if (verify_hash_value (t1, t2, flags, &r))\n+    return r;\n \n-  if (!t1 && !t2)\n+  if (t1 == t2)\n     return true;\n   else if (!t1 || !t2)\n     return false;\n \n-  tree tt1 = TREE_TYPE (t1);\n-  tree tt2 = TREE_TYPE (t2);\n-\n-  if (!func_checker::compatible_types_p (tt1, tt2))\n-    return false;\n-\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return return_false ();\n \n+  tree tree1 = (tree)const_cast<tree> (t1);\n+  tree tree2 = (tree)const_cast<tree> (t2);\n+\n   switch (TREE_CODE (t1))\n     {\n-    case CONSTRUCTOR:\n+    case FUNCTION_DECL:\n+      /* All function decls are in the symbol table and known to match\n+\t before we start comparing bodies.  */\n+      return true;\n+    case VAR_DECL:\n+      return return_with_debug (compare_variable_decl (tree1, tree2));\n+    case LABEL_DECL:\n       {\n-\tunsigned length1 = CONSTRUCTOR_NELTS (t1);\n-\tunsigned length2 = CONSTRUCTOR_NELTS (t2);\n-\n-\tif (length1 != length2)\n-\t  return return_false ();\n-\n-\tfor (unsigned i = 0; i < length1; i++)\n-\t  if (!compare_operand (CONSTRUCTOR_ELT (t1, i)->value,\n-\t\t\t\tCONSTRUCTOR_ELT (t2, i)->value))\n-\t    return return_false();\n-\n-\treturn true;\n+\tint *bb1 = m_label_bb_map.get (tree1);\n+\tint *bb2 = m_label_bb_map.get (tree2);\n+\t/* Labels can point to another function (non-local GOTOs).  */\n+\treturn return_with_debug (bb1 != NULL && bb2 != NULL && *bb1 == *bb2);\n       }\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-      /* First argument is the array, second is the index.  */\n-      x1 = TREE_OPERAND (t1, 0);\n-      x2 = TREE_OPERAND (t2, 0);\n-      y1 = TREE_OPERAND (t1, 1);\n-      y2 = TREE_OPERAND (t2, 1);\n-\n-      if (!compare_operand (array_ref_low_bound (t1),\n-\t\t\t    array_ref_low_bound (t2)))\n-\treturn return_false_with_msg (\"\");\n-      if (!compare_operand (array_ref_element_size (t1),\n-\t\t\t    array_ref_element_size (t2)))\n-\treturn return_false_with_msg (\"\");\n-\n-      if (!compare_operand (x1, x2))\n-\treturn return_false_with_msg (\"\");\n-      return compare_operand (y1, y2);\n-    case MEM_REF:\n-      {\n-\tx1 = TREE_OPERAND (t1, 0);\n-\tx2 = TREE_OPERAND (t2, 0);\n-\ty1 = TREE_OPERAND (t1, 1);\n-\ty2 = TREE_OPERAND (t2, 1);\n-\n-\t/* See if operand is an memory access (the test originate from\n-\t gimple_load_p).\n-\n-\tIn this case the alias set of the function being replaced must\n-\tbe subset of the alias set of the other function.  At the moment\n-\twe seek for equivalency classes, so simply require inclussion in\n-\tboth directions.  */\n \n-\tif (!func_checker::compatible_types_p (TREE_TYPE (x1), TREE_TYPE (x2)))\n-\t  return return_false ();\n-\n-\tif (!compare_operand (x1, x2))\n-\t  return return_false_with_msg (\"\");\n-\n-\t/* Type of the offset on MEM_REF does not matter.  */\n-\treturn known_eq (wi::to_poly_offset (y1), wi::to_poly_offset (y2));\n-      }\n-    case COMPONENT_REF:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case CONST_DECL:\n+      return compare_decl (tree1, tree2);\n+    case SSA_NAME:\n+      return compare_ssa_name (tree1, tree2);\n+    case FIELD_DECL:\n       {\n-\tx1 = TREE_OPERAND (t1, 0);\n-\tx2 = TREE_OPERAND (t2, 0);\n-\ty1 = TREE_OPERAND (t1, 1);\n-\ty2 = TREE_OPERAND (t2, 1);\n+\ttree offset1 = DECL_FIELD_OFFSET (t1);\n+\ttree offset2 = DECL_FIELD_OFFSET (t2);\n \n-\tret = compare_operand (x1, x2)\n-\t      && compare_cst_or_decl (y1, y2);\n+\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n+\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n \n+\tbool ret = (compare_operand (offset1, offset2)\n+\t\t    && compare_operand (bit_offset1, bit_offset2));\n \treturn return_with_debug (ret);\n       }\n-    /* Virtual table call.  */\n-    case OBJ_TYPE_REF:\n-      {\n-\tif (!compare_ssa_name (OBJ_TYPE_REF_EXPR (t1), OBJ_TYPE_REF_EXPR (t2)))\n-\t  return return_false ();\n-\tif (opt_for_fn (m_source_func_decl, flag_devirtualize)\n-\t    && virtual_method_call_p (t1))\n-\t  {\n-\t    if (tree_to_uhwi (OBJ_TYPE_REF_TOKEN (t1))\n-\t\t!= tree_to_uhwi (OBJ_TYPE_REF_TOKEN (t2)))\n-\t      return return_false_with_msg (\"OBJ_TYPE_REF token mismatch\");\n-\t    if (!types_same_for_odr (obj_type_ref_class (t1),\n-\t\t\t\t     obj_type_ref_class (t2)))\n-\t      return return_false_with_msg (\"OBJ_TYPE_REF OTR type mismatch\");\n-\t    if (!compare_operand (OBJ_TYPE_REF_OBJECT (t1),\n-\t\t\t\t  OBJ_TYPE_REF_OBJECT (t2)))\n-\t      return return_false_with_msg (\"OBJ_TYPE_REF object mismatch\");\n-\t  }\n-\n-\treturn return_with_debug (true);\n-      }\n-    case IMAGPART_EXPR:\n-    case REALPART_EXPR:\n-    case ADDR_EXPR:\n-      {\n-\tx1 = TREE_OPERAND (t1, 0);\n-\tx2 = TREE_OPERAND (t2, 0);\n+    default:\n+      break;\n+    }\n \n-\tret = compare_operand (x1, x2);\n-\treturn return_with_debug (ret);\n-      }\n-    case BIT_FIELD_REF:\n-      {\n-\tx1 = TREE_OPERAND (t1, 0);\n-\tx2 = TREE_OPERAND (t2, 0);\n-\ty1 = TREE_OPERAND (t1, 1);\n-\ty2 = TREE_OPERAND (t2, 1);\n-\tz1 = TREE_OPERAND (t1, 2);\n-\tz2 = TREE_OPERAND (t2, 2);\n+  return operand_compare::operand_equal_p (t1, t2, flags);\n+}\n \n-\tret = compare_operand (x1, x2)\n-\t      && compare_cst_or_decl (y1, y2)\n-\t      && compare_cst_or_decl (z1, z2);\n+/* Function responsible for comparison of various operands T1 and T2.\n+   If these components, from functions FUNC1 and FUNC2, are equal, true\n+   is returned.  */\n \n-\treturn return_with_debug (ret);\n-      }\n-    case SSA_NAME:\n-\treturn compare_ssa_name (t1, t2);\n-    case INTEGER_CST:\n-    case COMPLEX_CST:\n-    case VECTOR_CST:\n-    case STRING_CST:\n-    case REAL_CST:\n-    case FUNCTION_DECL:\n-    case VAR_DECL:\n-    case FIELD_DECL:\n-    case LABEL_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case CONST_DECL:\n-      return compare_cst_or_decl (t1, t2);\n-    default:\n-      return return_false_with_msg (\"Unknown TREE code reached\");\n-    }\n+bool\n+func_checker::compare_operand (tree t1, tree t2)\n+{\n+  if (!t1 && !t2)\n+    return true;\n+  else if (!t1 || !t2)\n+    return false;\n+  if (operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS))\n+    return true;\n+  return return_false_with_msg (\"operand_equal_p failed\");\n }\n \n bool"}, {"sha": "f56427b13e5cab09fd9683540d99f9025844047b", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "patch": "@@ -118,7 +118,7 @@ class sem_bb\n \n /* A class aggregating all connections and semantic equivalents\n    for a given pair of semantic function candidates.  */\n-class func_checker\n+class func_checker : operand_compare\n {\n public:\n   /* Initialize internal structures for a given SOURCE_FUNC_DECL and\n@@ -134,7 +134,7 @@ class func_checker\n \t\thash_set<symtab_node *> *ignored_target_nodes = NULL);\n \n   /* Memory release routine.  */\n-  ~func_checker();\n+  virtual ~func_checker ();\n \n   /* Function visits all gimple labels and creates corresponding\n      mapping between basic blocks and labels.  */\n@@ -267,6 +267,14 @@ class func_checker\n \n   /* Flag if ignore labels in comparison.  */\n   bool m_ignore_labels;\n+\n+  /* Return true if two operands are equal.  The flags fields can be used\n+     to specify OEP flags described above.  */\n+  virtual bool operand_equal_p (const_tree, const_tree, unsigned int flags);\n+\n+  /* Generate a hash value for an expression.  This can be used iteratively\n+     by passing a previous result as the HSTATE argument.  */\n+  virtual void hash_operand (const_tree, inchash::hash &, unsigned flags);\n };\n \n } // ipa_icf_gimple namespace"}, {"sha": "60aaf35d49cc93ce73ae2147e369d3f9b5f9545e", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=8a319aa3c28ee2069a78cff6b09d1b2df21b0f3c", "patch": "@@ -878,9 +878,14 @@ sem_function::equals_private (sem_item *item)\n     }\n \n   /* Checking all basic blocks.  */\n+  push_cfun (DECL_STRUCT_FUNCTION (decl));\n   for (unsigned i = 0; i < bb_sorted.length (); ++i)\n     if(!m_checker->compare_bb (bb_sorted[i], m_compared_func->bb_sorted[i]))\n-      return return_false();\n+      {\n+\tpop_cfun ();\n+\treturn return_false ();\n+      }\n+  pop_cfun ();\n \n   auto_vec <int> bb_dict;\n "}]}