{"sha": "ae1f91a698022a5600a2d54e48fc90895ea834fd", "node_id": "C_kwDOANBUbNoAKGFlMWY5MWE2OTgwMjJhNTYwMGEyZDU0ZTQ4ZmM5MDg5NWVhODM0ZmQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-18T17:22:08Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-22T10:57:19Z"}, "message": "transcribe: Move substitute_metavar in its own function", "tree": {"sha": "f38ee7ecfb7533735272aaae4237144efce0047b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f38ee7ecfb7533735272aaae4237144efce0047b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae1f91a698022a5600a2d54e48fc90895ea834fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1f91a698022a5600a2d54e48fc90895ea834fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1f91a698022a5600a2d54e48fc90895ea834fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1f91a698022a5600a2d54e48fc90895ea834fd/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "265c223766f1f4525558d086ccc46bd49f7b26e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265c223766f1f4525558d086ccc46bd49f7b26e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265c223766f1f4525558d086ccc46bd49f7b26e0"}], "stats": {"total": 213, "additions": 166, "deletions": 47}, "files": [{"sha": "dfd0b3ef0bc6fc6cc47a1b07edeb492169468011", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=ae1f91a698022a5600a2d54e48fc90895ea834fd", "patch": "@@ -204,6 +204,7 @@ class Token : public TokenTree, public MacroMatch\n   std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n   TokenId get_id () const { return tok_ref->get_id (); }\n+  const std::string &get_str () const { return tok_ref->get_str (); }\n \n   Location get_locus () const { return tok_ref->get_locus (); }\n "}, {"sha": "7dc8f88a7abed3f296b6eeaaa35f41486f374666", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 131, "deletions": 47, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=ae1f91a698022a5600a2d54e48fc90895ea834fd", "patch": "@@ -3754,10 +3754,10 @@ MacroExpander::transcribe_rule (\n     = substitute_tokens (invoc_stream, macro_rule_tokens, matched_fragments);\n \n   // // handy for debugging\n-  // for (auto &tok : substituted_tokens)\n-  //   {\n-  //     rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n-  //   }\n+  for (auto &tok : substituted_tokens)\n+    {\n+      rust_debug (\"tok: [%s]\", tok->as_string ().c_str ());\n+    }\n \n   // parse it to an ASTFragment\n   MacroInvocLexer lex (std::move (substituted_tokens));\n@@ -3874,6 +3874,67 @@ MacroExpander::transcribe_rule (\n   return AST::ASTFragment (std::move (nodes));\n }\n \n+std::vector<std::unique_ptr<AST::Token>>\n+MacroExpander::substitute_metavar (\n+  std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::map<std::string, MatchedFragment> &fragments,\n+  std::unique_ptr<AST::Token> &metavar)\n+{\n+  auto metavar_name = metavar->get_str ();\n+\n+  rust_debug (\"expanding metavar: %s\", metavar_name.c_str ());\n+  std::vector<std::unique_ptr<AST::Token>> expanded;\n+  auto it = fragments.find (metavar_name);\n+  if (it == fragments.end ())\n+    {\n+      // Return a copy of the original token\n+      expanded.push_back (metavar->clone_token ());\n+    }\n+  else\n+    {\n+      // Replace\n+      MatchedFragment &frag = it->second;\n+      for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n+\t   offs++)\n+\t{\n+\t  auto &tok = input.at (offs);\n+\t  expanded.push_back (tok->clone_token ());\n+\t}\n+    }\n+\n+  return expanded;\n+}\n+\n+std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+MacroExpander::substitute_token (\n+  std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::map<std::string, MatchedFragment> &fragments,\n+  std::unique_ptr<AST::Token> &token)\n+{\n+  switch (token->get_id ())\n+    {\n+    case IDENTIFIER:\n+      rust_debug (\"expanding metavar\");\n+      return {substitute_metavar (input, fragments, token), 1};\n+    case LEFT_PAREN:\n+      rust_debug (\"expanding repetition\");\n+      break;\n+      // TODO: We need to check if the $ was alone. In that case, do\n+      // not error out: Simply act as if there was an empty identifier\n+      // with no associated fragment and paste the dollar sign in the\n+      // transcription. Unsure how to do that since we always have at\n+      // least the closing curly brace after an empty $...\n+    default:\n+      rust_error_at (token->get_locus (),\n+\t\t     \"unexpected token in macro transcribe: expected \"\n+\t\t     \"%<(%> or identifier after %<$%>, got %<%s%>\",\n+\t\t     get_token_description (token->get_id ()));\n+    }\n+\n+  // FIXME: gcc_unreachable() error case?\n+  return {std::vector<std::unique_ptr<AST::Token>> (), 0};\n+}\n+\n std::vector<std::unique_ptr<AST::Token>>\n MacroExpander::substitute_tokens (\n   std::vector<std::unique_ptr<AST::Token>> &input,\n@@ -3882,60 +3943,83 @@ MacroExpander::substitute_tokens (\n {\n   std::vector<std::unique_ptr<AST::Token>> replaced_tokens;\n \n+  // for token in macro\n+  // \tif token == ?:\n+  // \t// That's not always true: If it's a left paren, it's repetition\n+  // \t// We probably want to store the matched amount in the fragment so\n+  // \t// we can expand it here\n+  // \t\tid = next_token();\n+  // \t\tfrag = fragment.find(id);\n+\n   for (size_t i = 0; i < macro.size (); i++)\n     {\n       auto &tok = macro.at (i);\n       if (tok->get_id () == DOLLAR_SIGN)\n \t{\n-\t  std::vector<std::unique_ptr<AST::Token>> parsed_toks;\n+\t  auto &next_tok = macro.at (i + 1);\n+\t  // Aaaaah, if only we had C++17 :)\n+\t  // auto [expanded, tok_to_skip] = ...\n+\t  auto p = substitute_token (input, fragments, next_tok);\n+\t  auto expanded = std::move (p.first);\n+\t  auto tok_to_skip = p.second;\n \n-\t  std::string ident;\n-\t  for (size_t offs = i; i < macro.size (); offs++)\n-\t    {\n-\t      auto &tok = macro.at (offs);\n-\t      if (tok->get_id () == DOLLAR_SIGN && offs == i)\n-\t\t{\n-\t\t  parsed_toks.push_back (tok->clone_token ());\n-\t\t}\n-\t      else if (tok->get_id () == IDENTIFIER)\n-\t\t{\n-\t\t  rust_assert (tok->as_string ().size () == 1);\n-\t\t  ident.push_back (tok->as_string ().at (0));\n-\t\t  parsed_toks.push_back (tok->clone_token ());\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  break;\n-\t\t}\n-\t    }\n+\t  i += tok_to_skip;\n \n-\t  // lookup the ident\n-\t  auto it = fragments.find (ident);\n-\t  if (it == fragments.end ())\n-\t    {\n-\t      // just leave the tokens in\n-\t      for (auto &tok : parsed_toks)\n-\t\t{\n-\t\t  replaced_tokens.push_back (tok->clone_token ());\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      // replace\n-\t      MatchedFragment &frag = it->second;\n-\t      for (size_t offs = frag.token_offset_begin;\n-\t\t   offs < frag.token_offset_end; offs++)\n-\t\t{\n-\t\t  auto &tok = input.at (offs);\n-\t\t  replaced_tokens.push_back (tok->clone_token ());\n-\t\t}\n-\t    }\n-\t  i += parsed_toks.size () - 1;\n+\t  for (auto &token : expanded)\n+\t    replaced_tokens.emplace_back (token->clone_token ());\n \t}\n       else\n \t{\n-\t  replaced_tokens.push_back (tok->clone_token ());\n+\t  replaced_tokens.emplace_back (tok->clone_token ());\n \t}\n+\n+      // std::vector<std::unique_ptr<AST::Token>> parsed_toks;\n+\n+      // std::string ident;\n+      // for (size_t offs = i; i < macro.size (); offs++)\n+      //   {\n+      //     auto &tok = macro.at (offs);\n+      //     if (tok->get_id () == DOLLAR_SIGN && offs == i)\n+      //       {\n+      //         parsed_toks.push_back (tok->clone_token ());\n+      //       }\n+      //     else if (tok->get_id () == IDENTIFIER)\n+      //       {\n+      //         rust_assert (tok->as_string ().size () == 1);\n+      //         ident.push_back (tok->as_string ().at (0));\n+      //         parsed_toks.push_back (tok->clone_token ());\n+      //       }\n+      //     else\n+      //       {\n+      //         break;\n+      //       }\n+      //   }\n+\n+      // // lookup the ident\n+      // auto it = fragments.find (ident);\n+      // if (it == fragments.end ())\n+      //   {\n+      //     // just leave the tokens in\n+      //     for (auto &tok : parsed_toks)\n+      //       {\n+      //         replaced_tokens.push_back (tok->clone_token ());\n+      //       }\n+      //   }\n+      // else\n+      //   {\n+      //     // replace\n+      //     MatchedFragment &frag = it->second;\n+      //     for (size_t offs = frag.token_offset_begin;\n+      //          offs < frag.token_offset_end; offs++)\n+      //       {\n+      //         auto &tok = input.at (offs);\n+      //         replaced_tokens.push_back (tok->clone_token ());\n+      //       }\n+      //   }\n+      // i += parsed_toks.size () - 1;\n+      //\n+      // }\n+      // else { replaced_tokens.push_back (tok->clone_token ()); }\n     }\n \n   return replaced_tokens;"}, {"sha": "f77acc707690ef4dfb2fccf1fb9db7dce5be427b", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae1f91a698022a5600a2d54e48fc90895ea834fd/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=ae1f91a698022a5600a2d54e48fc90895ea834fd", "patch": "@@ -183,6 +183,40 @@ struct MacroExpander\n \t\t\tsize_t &match_amount, size_t lo_bound = 0,\n \t\t\tsize_t hi_bound = 0);\n \n+  /**\n+   * Substitute a metavariable by its given fragment in a transcribing context,\n+   * i.e. replacing $var with the associated fragment.\n+   *\n+   * @param input Tokens given to the transcribing context\n+   * @param fragments Fragments given to the macro substitution\n+   * @param metavar Metavariable to try and replace\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated\n+   */\n+  static std::vector<std::unique_ptr<AST::Token>>\n+  substitute_metavar (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t      std::map<std::string, MatchedFragment> &fragments,\n+\t\t      std::unique_ptr<AST::Token> &metavar);\n+\n+  /**\n+   * Substitute a given token by its appropriate representation\n+   *\n+   * @param input Tokens given to the transcribing context\n+   * @param fragments Fragments given to the macro substitution\n+   * @param token Current token to try and substitute\n+   *\n+   * @return A token containing the associated fragment expanded into tokens if\n+   * any, or the cloned token if no fragment was associated, as well as the\n+   * amount of tokens that should be skipped before the next invocation. Since\n+   * this function may consume more than just one token, it is important to skip\n+   * ahead of the input to avoid mis-substitutions\n+   */\n+  static std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n+  substitute_token (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t    std::map<std::string, MatchedFragment> &fragments,\n+\t\t    std::unique_ptr<AST::Token> &token);\n+\n   static std::vector<std::unique_ptr<AST::Token>>\n   substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,\n \t\t     std::vector<std::unique_ptr<AST::Token>> &macro,"}]}