{"sha": "1824c168768592a20fcf9fe41634f9ebecabb52c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgyNGMxNjg3Njg1OTJhMjBmY2Y5ZmU0MTYzNGY5ZWJlY2FiYjUyYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:31:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:31:07Z"}, "message": "[multiple changes]\n\n2013-01-02  Vincent Celier  <celier@adacore.com>\n\n\t* switch-m.adb (Normalize_Compiler_Switches): Record the\n\tcomplete switch -fstack-check=specific instead of its shorter\n\talias -fstack-check.\n\n2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Derive_Subprogram): Enforce RM 6.3.1 (8):\n\tif the derived type is a tagged generic formal type with\n\tunknown discriminants, the inherited operation has convention\n\tIntrinsic. As such, the 'Access attribute cannot be applied to it.\n\n2013-01-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_attr.adb: Minor reformatting.\n\nFrom-SVN: r194780", "tree": {"sha": "d260c536f19e9090be2316aa878f77e6b69f7fa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d260c536f19e9090be2316aa878f77e6b69f7fa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1824c168768592a20fcf9fe41634f9ebecabb52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1824c168768592a20fcf9fe41634f9ebecabb52c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1824c168768592a20fcf9fe41634f9ebecabb52c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1824c168768592a20fcf9fe41634f9ebecabb52c/comments", "author": null, "committer": null, "parents": [{"sha": "db318f46594d4080931db7f56ccb30c7f6f1f949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db318f46594d4080931db7f56ccb30c7f6f1f949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db318f46594d4080931db7f56ccb30c7f6f1f949"}], "stats": {"total": 88, "additions": 64, "deletions": 24}, "files": [{"sha": "66c03a0811268d8543f0766148e3f78fc8504c74", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1824c168768592a20fcf9fe41634f9ebecabb52c", "patch": "@@ -1,3 +1,20 @@\n+2013-01-02  Vincent Celier  <celier@adacore.com>\n+\n+\t* switch-m.adb (Normalize_Compiler_Switches): Record the\n+\tcomplete switch -fstack-check=specific instead of its shorter\n+\talias -fstack-check.\n+\n+2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Derive_Subprogram): Enforce RM 6.3.1 (8):\n+\tif the derived type is a tagged generic formal type with\n+\tunknown discriminants, the inherited operation has convention\n+\tIntrinsic. As such, the 'Access attribute cannot be applied to it.\n+\n+2013-01-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_attr.adb: Minor reformatting.\n+\n 2013-01-02  Thomas Quinot  <quinot@adacore.com>\n \n \t* par_sco.adb: Add SCO generation for S of protected types and"}, {"sha": "963a19f1db8673324f7efbffe72211e354bfd480", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=1824c168768592a20fcf9fe41634f9ebecabb52c", "patch": "@@ -4251,9 +4251,9 @@ package body Sem_Attr is\n \n             Prag := N;\n             while not Nkind_In (Prag, N_Pragma,\n-                                N_Function_Specification,\n-                                N_Procedure_Specification,\n-                                N_Subprogram_Body)\n+                                      N_Function_Specification,\n+                                      N_Procedure_Specification,\n+                                      N_Subprogram_Body)\n             loop\n                Prag := Parent (Prag);\n             end loop;"}, {"sha": "451873a21ae1960be3a4d573f6b3472e63d73c94", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=1824c168768592a20fcf9fe41634f9ebecabb52c", "patch": "@@ -13320,8 +13320,29 @@ package body Sem_Ch3 is\n       --  of the parent subprogram (a requirement of AI-117). Derived\n       --  subprograms of untagged types simply get convention Ada by default.\n \n+      --  If the derived type is a tagged generic formal type with unknown\n+      --  discriminants, its convention is intrinsic (RM 6.3.1 (8)).\n+\n+      --  However, if the type is derived from a generic formal, the further\n+      --  inherited subprogram has the convention of the non-generic ancestor.\n+      --  Otherwise there would be no way to override the operation.\n+      --  (This is subject to forthcoming ARG discussions).\n+\n       if Is_Tagged_Type (Derived_Type) then\n-         Set_Convention (New_Subp, Convention (Parent_Subp));\n+         if Is_Generic_Type (Derived_Type)\n+           and then Has_Unknown_Discriminants (Derived_Type)\n+         then\n+            Set_Convention (New_Subp, Convention_Intrinsic);\n+\n+         else\n+            if Is_Generic_Type (Parent_Type)\n+              and then Has_Unknown_Discriminants (Parent_Type)\n+            then\n+               Set_Convention (New_Subp, Convention (Alias (Parent_Subp)));\n+            else\n+               Set_Convention (New_Subp, Convention (Parent_Subp));\n+            end if;\n+         end if;\n       end if;\n \n       --  Predefined controlled operations retain their name even if the parent\n@@ -13333,9 +13354,9 @@ package body Sem_Ch3 is\n \n       if Is_Controlled (Parent_Type)\n         and then\n-          (Chars (Parent_Subp) = Name_Initialize\n-            or else Chars (Parent_Subp) = Name_Adjust\n-            or else Chars (Parent_Subp) = Name_Finalize)\n+          (Chars (Parent_Subp) = Name_Initialize or else\n+           Chars (Parent_Subp) = Name_Adjust     or else\n+           Chars (Parent_Subp) = Name_Finalize)\n         and then Is_Hidden (Parent_Subp)\n         and then not Is_Visibly_Controlled (Parent_Type)\n       then\n@@ -13377,14 +13398,14 @@ package body Sem_Ch3 is\n       elsif Ada_Version >= Ada_2005\n         and then (Is_Abstract_Subprogram (Alias (New_Subp))\n                    or else (Is_Tagged_Type (Derived_Type)\n-                            and then Etype (New_Subp) = Derived_Type\n-                            and then not Is_Null_Extension (Derived_Type))\n+                             and then Etype (New_Subp) = Derived_Type\n+                             and then not Is_Null_Extension (Derived_Type))\n                    or else (Is_Tagged_Type (Derived_Type)\n-                            and then Ekind (Etype (New_Subp)) =\n+                             and then Ekind (Etype (New_Subp)) =\n                                                        E_Anonymous_Access_Type\n-                            and then Designated_Type (Etype (New_Subp)) =\n-                                                       Derived_Type\n-                            and then not Is_Null_Extension (Derived_Type)))\n+                             and then Designated_Type (Etype (New_Subp)) =\n+                                                        Derived_Type\n+                             and then not Is_Null_Extension (Derived_Type)))\n         and then No (Actual_Subp)\n       then\n          if not Is_Tagged_Type (Derived_Type)\n@@ -13509,9 +13530,7 @@ package body Sem_Ch3 is\n          --  an incomplete type whose full-view is derived type\n \n          E := First_Entity (Scope (Derived_Type));\n-         while Present (E)\n-           and then E /= Derived_Type\n-         loop\n+         while Present (E) and then E /= Derived_Type loop\n             if Ekind (E) = E_Incomplete_Type\n               and then Present (Full_View (E))\n               and then Full_View (E) = Derived_Type\n@@ -13648,8 +13667,7 @@ package body Sem_Ch3 is\n       if not Is_Tagged_Type (Derived_Type)\n         or else (not Has_Interfaces (Derived_Type)\n                   and then not (Present (Generic_Actual)\n-                                  and then\n-                                Has_Interfaces (Generic_Actual)))\n+                                 and then Has_Interfaces (Generic_Actual)))\n       then\n          Elmt := First_Elmt (Op_List);\n          while Present (Elmt) loop\n@@ -13673,9 +13691,10 @@ package body Sem_Ch3 is\n             else\n                pragma Assert (No (Node (Act_Elmt))\n                  or else (Primitive_Names_Match (Subp, Node (Act_Elmt))\n-                            and then\n-                          Type_Conformant (Subp, Node (Act_Elmt),\n-                                           Skip_Controlling_Formals => True)));\n+                           and then\n+                             Type_Conformant\n+                               (Subp, Node (Act_Elmt),\n+                                Skip_Controlling_Formals => True)));\n \n                Derive_Subprogram\n                  (New_Subp, Subp, Derived_Type, Parent_Base, Node (Act_Elmt));\n@@ -14722,9 +14741,7 @@ package body Sem_Ch3 is\n       --  Set Discard_Names if configuration pragma set, or if there is\n       --  a parameterless pragma in the current declarative region\n \n-      if Global_Discard_Names\n-        or else Discard_Names (Scope (T))\n-      then\n+      if Global_Discard_Names or else Discard_Names (Scope (T)) then\n          Set_Discard_Names (T);\n       end if;\n "}, {"sha": "4f18ec11c54fd29a1227a25e135173e90679cef2", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1824c168768592a20fcf9fe41634f9ebecabb52c/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=1824c168768592a20fcf9fe41634f9ebecabb52c", "patch": "@@ -214,6 +214,12 @@ package body Switch.M is\n                then\n                   Add_Switch_Component (Switch_Chars);\n \n+               --  Special case for -fstack-check (alias for\n+               --  -fstack-check=specific)\n+\n+               elsif Switch_Chars = \"-fstack-check\" then\n+                  Add_Switch_Component (\"-fstack-check=specific\");\n+\n                --  Take only into account switches that are transmitted to\n                --  gnat1 by the gcc driver and stored by gnat1 in the ALI file.\n "}]}