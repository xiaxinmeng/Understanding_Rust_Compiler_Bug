{"sha": "ebf6175464768983a2d8c82c2d47771ee89192b8", "node_id": "C_kwDOANBUbNoAKGViZjYxNzU0NjQ3Njg5ODNhMmQ4YzgyYzJkNDc3NzFlZTg5MTkyYjg", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-02-01T22:04:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-02-04T19:51:26Z"}, "message": "libstdc++: Fix filesystem::remove_all races [PR104161]\n\nThis fixes the remaining filesystem::remove_all race condition by using\nPOSIX openat to recurse into sub-directories and using POSIX unlinkat to\nremove files. This avoids the remaining race where the directory being\nremoved is replaced with a symlink after the directory has been opened,\nso that the filesystem::remove(\"subdir/file\") resolves to \"target/file\"\ninstead, because \"subdir\" has been removed and replaced with a symlink.\nThe previous patch only fixed the case where the directory was replaced\nwith a symlink before we tried to open it, but it still used the full\n(potentially compromised) path as an argument to filesystem::remove.\n\nThe first part of the fix is to use openat when recursing into a\nsub-directory with recursive_directory_iterator. This means that opening\n\"dir/subdir\" uses the file descriptor for \"dir\", and so is sure to open\n\"dir/subdir\" and not \"symlink/subdir\". (The previous patch to use\nO_NOFOLLOW already ensured we won't open \"dir/symlink/\" here.)\n\nThe second part of the fix is to use unlinkat for the remove_all\noperation. Previously we used a directory_iterator to get the name of\neach file in a directory and then used filesystem::remove(iter->path())\non that name. This meant that any checks (e.g. O_NOFOLLOW) done by the\niterator could be invalidated before the remove operation on that\npathname. The directory iterator contains an open DIR stream, which we\ncan use to obtain a file descriptor to pass to unlinkat. This ensures\nthat the file being deleted really is contained within the directory\nwe're iterating over, rather than using a pathname that could resolve to\nsome other file.\n\nThe filesystem::remove_all function previously used a (non-recursive)\nfilesystem::directory_iterator for each directory, and called itself\nrecursively for sub-directories. The new implementation uses a single\nfilesystem::recursive_directory_iterator object, and calls a new __erase\nmember function on that iterator. That new __erase member function does\nthe actual work of removing a file (or a directory after its contents\nhave been iterated over and removed) using unlinkat. That means we don't\nneed to expose the DIR stream or its file descriptor to the remove_all\nfunction, it's still encapuslated by the iterator class.\n\nIt would be possible to add a __rewind member to directory iterators\ntoo, to call rewinddir after each modification to the directory. That\nwould make it more likely for filesystem::remove_all to successfully\nremove everything even if files are being written to the directory tree\nwhile removing it. It's unclear if that is actually prefereable, or if\nit's better to fail and report an error at the first opportunity.\n\nThe necessary APIs (openat, unlinkat, fdopendir, dirfd) are defined in\nPOSIX.1-2008, and in Glibc since 2.10. But if the target doesn't provide\nthem, the original code (with race conditions) is still used.\n\nThis also reduces the number of small memory allocations needed for\nstd::filesystem::remove_all, because we do not store the full path to\nevery directory entry that is iterated over. The new filename_only\noption means we only store the filename in the directory entry, as that\nis all we need in order to use openat or unlinkat.\n\nFinally, rather than duplicating everything for the Filesystem TS, the\nstd::experimental::filesystem::remove_all implementation now just calls\nstd::filesystem::remove_all to do the work.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/104161\n\t* acinclude.m4 (GLIBCXX_CHECK_FILESYSTEM_DEPS): Check for dirfd\n\tand unlinkat.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* include/bits/fs_dir.h (recursive_directory_iterator): Declare\n\tremove_all overloads as friends.\n\t(recursive_directory_iterator::__erase): Declare new member\n\tfunction.\n\t* include/bits/fs_fwd.h (remove, remove_all): Declare.\n\t* src/c++17/fs_dir.cc (_Dir): Add filename_only parameter to\n\tconstructor. Pass file descriptor argument to base constructor.\n\t(_Dir::dir_and_pathname, _Dir::open_subdir, _Dir::do_unlink)\n\t(_Dir::unlink, _Dir::rmdir): Define new member functions.\n\t(directory_iterator): Pass filename_only argument to _Dir\n\tconstructor.\n\t(recursive_directory_iterator::_Dir_stack): Adjust constructor\n\tparameters to take a _Dir rvalue instead of creating one.\n\t(_Dir_stack::orig): Add data member for storing original path.\n\t(_Dir_stack::report_error): Define new member function.\n\t(__directory_iterator_nofollow): Move here from dir-common.h and\n\tfix value to be a power of two.\n\t(__directory_iterator_filename_only): Define new constant.\n\t(recursive_directory_iterator): Construct _Dir object and move\n\tinto _M_dirs stack. Pass skip_permission_denied argument to first\n\tadvance call.\n\t(recursive_directory_iterator::increment): Use _Dir::open_subdir.\n\t(recursive_directory_iterator::__erase): Define new member\n\tfunction.\n\t* src/c++17/fs_ops.cc (ErrorReporter, do_remove_all): Remove.\n\t(fs::remove_all): Use new recursive_directory_iterator::__erase\n\tmember function.\n\t* src/filesystem/dir-common.h (_Dir_base): Add int parameter to\n\tconstructor and use openat to implement nofollow semantics.\n\t(_Dir_base::fdcwd, _Dir_base::set_close_on_exec, _Dir_base::openat):\n\tDefine new member functions.\n\t(__directory_iterator_nofollow): Move to fs_dir.cc.\n\t* src/filesystem/dir.cc (_Dir): Pass file descriptor argument to\n\tbase constructor.\n\t(_Dir::dir_and_pathname, _Dir::open_subdir): Define new member\n\tfunctions.\n\t(recursive_directory_iterator::_Dir_stack): Adjust constructor\n\tparameters to take a _Dir rvalue instead of creating one.\n\t(recursive_directory_iterator): Check for new nofollow option.\n\tConstruct _Dir object and move into _M_dirs stack. Pass\n\tskip_permission_denied argument to first advance call.\n\t(recursive_directory_iterator::increment): Use _Dir::open_subdir.\n\t* src/filesystem/ops.cc (fs::remove_all): Use C++17 remove_all.", "tree": {"sha": "e4d327aea589d6426109ca76aadffe144b8433cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4d327aea589d6426109ca76aadffe144b8433cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebf6175464768983a2d8c82c2d47771ee89192b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf6175464768983a2d8c82c2d47771ee89192b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf6175464768983a2d8c82c2d47771ee89192b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf6175464768983a2d8c82c2d47771ee89192b8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b28b92bc008776c8b517841f99ba6a31bf7751d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28b92bc008776c8b517841f99ba6a31bf7751d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28b92bc008776c8b517841f99ba6a31bf7751d2"}], "stats": {"total": 804, "additions": 573, "deletions": 231}, "files": [{"sha": "7cc52f4db962f8d73f78a7d4e327ec7f34e3284a", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -4748,13 +4748,38 @@ dnl\n     glibcxx_cv_fdopendir, [dnl\n     GCC_TRY_COMPILE_OR_LINK(\n       [#include <dirent.h>],\n-      [::fdopendir(1);],\n+      [::DIR* dir = ::fdopendir(1);],\n       [glibcxx_cv_fdopendir=yes],\n       [glibcxx_cv_fdopendir=no])\n   ])\n   if test $glibcxx_cv_fdopendir = yes; then\n     AC_DEFINE(HAVE_FDOPENDIR, 1, [Define if fdopendir is available in <dirent.h>.])\n   fi\n+dnl\n+  AC_CACHE_CHECK([for dirfd],\n+    glibcxx_cv_dirfd, [dnl\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <dirent.h>],\n+      [int fd = ::dirfd((::DIR*)0);],\n+      [glibcxx_cv_dirfd=yes],\n+      [glibcxx_cv_dirfd=no])\n+  ])\n+  if test $glibcxx_cv_dirfd = yes; then\n+    AC_DEFINE(HAVE_DIRFD, 1, [Define if dirfd is available in <dirent.h>.])\n+  fi\n+dnl\n+  AC_CACHE_CHECK([for unlinkat],\n+    glibcxx_cv_unlinkat, [dnl\n+    GCC_TRY_COMPILE_OR_LINK(\n+      [#include <fcntl.h>\n+       #include <unistd.h>],\n+      [::unlinkat(AT_FDCWD, \"\", AT_REMOVEDIR);],\n+      [glibcxx_cv_unlinkat=yes],\n+      [glibcxx_cv_unlinkat=no])\n+  ])\n+  if test $glibcxx_cv_unlinkat = yes; then\n+    AC_DEFINE(HAVE_UNLINKAT, 1, [Define if unlinkat is available in <fcntl.h>.])\n+  fi\n dnl\n   CXXFLAGS=\"$ac_save_CXXFLAGS\"\n   AC_LANG_RESTORE"}, {"sha": "f6212de9268a7dcd67c454dff0e03ae8286b1dc1", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -73,6 +73,9 @@\n /* Define to 1 if you have the <dirent.h> header file. */\n #undef HAVE_DIRENT_H\n \n+/* Define if dirfd is available in <dirent.h>. */\n+#undef HAVE_DIRFD\n+\n /* Define to 1 if you have the <dlfcn.h> header file. */\n #undef HAVE_DLFCN_H\n \n@@ -486,6 +489,9 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define if unlinkat is available in <fcntl.h>. */\n+#undef HAVE_UNLINKAT\n+\n /* Define to 1 if you have the `uselocale' function. */\n #undef HAVE_USELOCALE\n "}, {"sha": "ef80912d0b9ea6561f0f2a7fa8016d59d8ff95a5", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -77077,7 +77077,7 @@ else\n int\n main ()\n {\n-::fdopendir(1);\n+::DIR* dir = ::fdopendir(1);\n   ;\n   return 0;\n }\n@@ -77098,7 +77098,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n int\n main ()\n {\n-::fdopendir(1);\n+::DIR* dir = ::fdopendir(1);\n   ;\n   return 0;\n }\n@@ -77119,6 +77119,118 @@ $as_echo \"$glibcxx_cv_fdopendir\" >&6; }\n \n $as_echo \"#define HAVE_FDOPENDIR 1\" >>confdefs.h\n \n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for dirfd\" >&5\n+$as_echo_n \"checking for dirfd... \" >&6; }\n+if ${glibcxx_cv_dirfd+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <dirent.h>\n+int\n+main ()\n+{\n+int fd = ::dirfd((::DIR*)0);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_dirfd=yes\n+else\n+  glibcxx_cv_dirfd=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error $? \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <dirent.h>\n+int\n+main ()\n+{\n+int fd = ::dirfd((::DIR*)0);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_dirfd=yes\n+else\n+  glibcxx_cv_dirfd=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_dirfd\" >&5\n+$as_echo \"$glibcxx_cv_dirfd\" >&6; }\n+  if test $glibcxx_cv_dirfd = yes; then\n+\n+$as_echo \"#define HAVE_DIRFD 1\" >>confdefs.h\n+\n+  fi\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for unlinkat\" >&5\n+$as_echo_n \"checking for unlinkat... \" >&6; }\n+if ${glibcxx_cv_unlinkat+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+      if test x$gcc_no_link = xyes; then\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <fcntl.h>\n+       #include <unistd.h>\n+int\n+main ()\n+{\n+::unlinkat(AT_FDCWD, \"\", AT_REMOVEDIR);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  glibcxx_cv_unlinkat=yes\n+else\n+  glibcxx_cv_unlinkat=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+else\n+  if test x$gcc_no_link = xyes; then\n+  as_fn_error $? \"Link tests are not allowed after GCC_NO_EXECUTABLES.\" \"$LINENO\" 5\n+fi\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <fcntl.h>\n+       #include <unistd.h>\n+int\n+main ()\n+{\n+::unlinkat(AT_FDCWD, \"\", AT_REMOVEDIR);\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_link \"$LINENO\"; then :\n+  glibcxx_cv_unlinkat=yes\n+else\n+  glibcxx_cv_unlinkat=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_unlinkat\" >&5\n+$as_echo \"$glibcxx_cv_unlinkat\" >&6; }\n+  if test $glibcxx_cv_unlinkat = yes; then\n+\n+$as_echo \"#define HAVE_UNLINKAT 1\" >>confdefs.h\n+\n   fi\n   CXXFLAGS=\"$ac_save_CXXFLAGS\"\n   ac_ext=c"}, {"sha": "ca37952ec17c26c3650595c10f5acc9f34924225", "filename": "libstdc++-v3/include/bits/fs_dir.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_dir.h?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -537,6 +537,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n     struct _Dir_stack;\n     std::__shared_ptr<_Dir_stack> _M_dirs;\n+\n+    recursive_directory_iterator&\n+    __erase(error_code* = nullptr);\n+\n+    friend uintmax_t\n+    filesystem::remove_all(const path&, error_code&);\n+    friend uintmax_t\n+    filesystem::remove_all(const path&);\n   };\n \n   /// @relates std::filesystem::recursive_directory_iterator @{"}, {"sha": "d8cde5e5eba34cbc3ed1fbfe5958b7c67f744ba0", "filename": "libstdc++-v3/include/bits/fs_fwd.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -354,6 +354,10 @@ _GLIBCXX_END_NAMESPACE_CXX11\n   bool is_regular_file(file_status) noexcept;\n   bool is_symlink(file_status) noexcept;\n \n+  bool remove(const path&, error_code&) noexcept;\n+  uintmax_t remove_all(const path&);\n+  uintmax_t remove_all(const path&, error_code&);\n+\n /// @}\n } // namespace filesystem\n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "01b8c0d56938f734d4ce33d937eaa7ea13be40e8", "filename": "libstdc++-v3/src/c++17/fs_dir.cc", "status": "modified", "additions": 218, "deletions": 33, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_dir.cc?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -45,9 +45,14 @@ template class std::__shared_ptr<fs::recursive_directory_iterator::_Dir_stack>;\n struct fs::_Dir : _Dir_base\n {\n   _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,\n-       error_code& ec)\n-  : _Dir_base(p.c_str(), skip_permission_denied, nofollow, ec)\n+       [[maybe_unused]] bool filename_only, error_code& ec)\n+  : _Dir_base(fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)\n   {\n+#if _GLIBCXX_HAVE_DIRFD\n+    if (filename_only)\n+      return; // Do not store path p when we aren't going to use it.\n+#endif\n+\n     if (!ec)\n       path = p;\n   }\n@@ -112,7 +117,63 @@ struct fs::_Dir : _Dir_base\n     return false;\n   }\n \n-  fs::path\t\tpath;\n+  // Return a file descriptor for the directory and current entry's path.\n+  // If dirfd is available, use it and return only the filename.\n+  // Otherwise, return AT_FDCWD and return the full path.\n+  pair<int, const posix::char_type*>\n+  dir_and_pathname() const noexcept\n+  {\n+    const fs::path& p = entry.path();\n+#if _GLIBCXX_HAVE_DIRFD\n+    if (!p.empty())\n+      return {::dirfd(this->dirp), std::prev(p.end())->c_str()};\n+#endif\n+    return {this->fdcwd(), p.c_str()};\n+  }\n+\n+  // Create a new _Dir for the directory this->entry.path().\n+  _Dir\n+  open_subdir(bool skip_permission_denied, bool nofollow,\n+\t      error_code& ec) const noexcept\n+  {\n+    auto [dirfd, pathname] = dir_and_pathname();\n+    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);\n+    // If this->path is empty, the new _Dir should have an empty path too.\n+    const fs::path& p = this->path.empty() ? this->path : this->entry.path();\n+    return _Dir(std::exchange(d.dirp, nullptr), p);\n+  }\n+\n+  bool\n+  do_unlink(bool is_directory, error_code& ec) const noexcept\n+  {\n+#if _GLIBCXX_HAVE_UNLINKAT\n+    auto [dirfd, pathname] = dir_and_pathname();\n+    if (::unlinkat(dirfd, pathname, is_directory ? AT_REMOVEDIR : 0) == -1)\n+      {\n+\tec.assign(errno, std::generic_category());\n+\treturn false;\n+      }\n+    else\n+      {\n+\tec.clear();\n+\treturn true;\n+      }\n+#else\n+    return fs::remove(entry.path(), ec);\n+#endif\n+  }\n+\n+  // Remove the non-directory that this->entry refers to.\n+  bool\n+  unlink(error_code& ec) const noexcept\n+  { return do_unlink(/* is_directory*/ false, ec); }\n+\n+  // Remove the directory that this->entry refers to.\n+  bool\n+  rmdir(error_code& ec) const noexcept\n+  { return do_unlink(/* is_directory*/ true, ec); }\n+\n+  fs::path\t\tpath; // Empty if only using unlinkat with file descr.\n   directory_entry\tentry;\n };\n \n@@ -124,6 +185,20 @@ namespace\n     {\n       return (obj & bits) != Bitmask::none;\n     }\n+\n+// Non-standard directory option flags, currently only for internal use:\n+//\n+// Do not allow directory iterator to open a symlink.\n+// This might seem redundant given directory_options::follow_directory_symlink\n+// but that is only checked for recursing into sub-directories, and we need\n+// something that controls the initial opendir() call in the constructor.\n+constexpr fs::directory_options __directory_iterator_nofollow{64};\n+// Do not store full paths in std::filesystem::recursive_directory_iterator.\n+// When fs::remove_all uses recursive_directory_iterator::__erase and unlinkat\n+// is available in libc, we do not need the parent directory's path, only the\n+// filenames of the directory entries (and a file descriptor for the parent).\n+// This flag avoids allocating memory for full paths that won't be needed.\n+constexpr fs::directory_options __directory_iterator_filename_only{128};\n }\n \n fs::directory_iterator::\n@@ -132,12 +207,11 @@ directory_iterator(const path& p, directory_options options, error_code* ecptr)\n   // Do not report an error for permission denied errors.\n   const bool skip_permission_denied\n     = is_set(options, directory_options::skip_permission_denied);\n-  // Do not allow opening a symlink (used by filesystem::remove_all)\n-  const bool nofollow\n-     = is_set(options, __directory_iterator_nofollow);\n+  // Do not allow opening a symlink.\n+  const bool nofollow = is_set(options, __directory_iterator_nofollow);\n \n   error_code ec;\n-  _Dir dir(p, skip_permission_denied, nofollow, ec);\n+  _Dir dir(p, skip_permission_denied, nofollow, /*filename only*/false, ec);\n \n   if (dir.dirp)\n     {\n@@ -185,48 +259,66 @@ fs::directory_iterator::increment(error_code& ec)\n \n struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n {\n-  _Dir_stack(directory_options opts, posix::DIR* dirp, const path& p)\n+  _Dir_stack(directory_options opts, _Dir&& dir)\n   : options(opts), pending(true)\n   {\n-    this->emplace(dirp, p);\n+    this->push(std::move(dir));\n   }\n \n+  path::string_type orig;\n   const directory_options options;\n   bool pending;\n \n   void clear() { c.clear(); }\n+\n+  path current_path() const\n+  {\n+    path p;\n+    if (top().path.empty())\n+      {\n+\t// Reconstruct path that failed from dir stack.\n+\tp = orig;\n+\tfor (auto& d : this->c)\n+\t  p /= d.entry.path();\n+      }\n+    else\n+      p = top().entry.path();\n+    return p;\n+  }\n };\n \n fs::recursive_directory_iterator::\n recursive_directory_iterator(const path& p, directory_options options,\n                              error_code* ecptr)\n {\n-  if (posix::DIR* dirp = posix::opendir(p.c_str()))\n-    {\n-      if (ecptr)\n-\tecptr->clear();\n-      auto sp = std::__make_shared<_Dir_stack>(options, dirp, p);\n-      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())\n-\t_M_dirs.swap(sp);\n-    }\n-  else\n+  // Do not report an error for permission denied errors.\n+  const bool skip_permission_denied\n+    = is_set(options, directory_options::skip_permission_denied);\n+  // Do not allow opening a symlink as the starting directory.\n+  const bool nofollow = is_set(options, __directory_iterator_nofollow);\n+  // Prefer to store only filenames (not full paths) in directory_entry values.\n+  const bool filename_only\n+     = is_set(options, __directory_iterator_filename_only);\n+\n+  error_code ec;\n+  _Dir dir(p, skip_permission_denied, nofollow, filename_only, ec);\n+\n+  if (dir.dirp)\n     {\n-      const int err = errno;\n-      if (fs::is_permission_denied_error(err)\n-\t  && is_set(options, fs::directory_options::skip_permission_denied))\n+      auto sp = std::__make_shared<_Dir_stack>(options, std::move(dir));\n+      if (ecptr ? sp->top().advance(skip_permission_denied, *ecptr)\n+\t\t: sp->top().advance(skip_permission_denied))\n \t{\n-\t  if (ecptr)\n-\t    ecptr->clear();\n-\t  return;\n+\t  _M_dirs.swap(sp);\n+\t  if (filename_only) // Need to save original path for error reporting.\n+\t    _M_dirs->orig = p.native();\n \t}\n-\n-      if (!ecptr)\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"recursive directory iterator cannot open directory\", p,\n-\t      std::error_code(err, std::generic_category())));\n-\n-      ecptr->assign(err, std::generic_category());\n     }\n+  else if (ecptr)\n+    *ecptr = ec;\n+  else if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n+\t  \"recursive directory iterator cannot open directory\", p, ec));\n }\n \n fs::recursive_directory_iterator::~recursive_directory_iterator() = default;\n@@ -292,14 +384,14 @@ fs::recursive_directory_iterator::increment(error_code& ec)\n \n   if (std::exchange(_M_dirs->pending, true) && top.should_recurse(follow, ec))\n     {\n-      _Dir dir(top.entry.path(), skip_permission_denied, !follow, ec);\n+      _Dir dir = top.open_subdir(skip_permission_denied, !follow, ec);\n       if (ec)\n \t{\n \t  _M_dirs.reset();\n \t  return *this;\n \t}\n       if (dir.dirp)\n-\t  _M_dirs->push(std::move(dir));\n+\t_M_dirs->push(std::move(dir));\n     }\n \n   while (!_M_dirs->top().advance(skip_permission_denied, ec) && !ec)\n@@ -362,3 +454,96 @@ fs::recursive_directory_iterator::disable_recursion_pending() noexcept\n {\n   _M_dirs->pending = false;\n }\n+\n+// Used to implement filesystem::remove_all.\n+fs::recursive_directory_iterator&\n+fs::recursive_directory_iterator::__erase(error_code* ecptr)\n+{\n+  error_code ec;\n+  if (!_M_dirs)\n+    {\n+      ec = std::make_error_code(errc::invalid_argument);\n+      return *this;\n+    }\n+\n+  // We never want to skip permission denied when removing files.\n+  const bool skip_permission_denied = false;\n+  // We never want to follow directory symlinks when removing files.\n+  const bool nofollow = true;\n+\n+  // Loop until we find something we can remove.\n+  while (!ec)\n+    {\n+      auto& top = _M_dirs->top();\n+\n+      if (top.entry._M_type == file_type::directory)\n+\t{\n+\t  _Dir dir = top.open_subdir(skip_permission_denied, nofollow, ec);\n+\t  if (!ec)\n+\t    {\n+\t      __glibcxx_assert(dir.dirp != nullptr);\n+\t      if (dir.advance(skip_permission_denied, ec))\n+\t\t{\n+\t\t  // Non-empty directory, recurse into it.\n+\t\t  _M_dirs->push(std::move(dir));\n+\t\t  continue;\n+\t\t}\n+\t      if (!ec)\n+\t\t{\n+\t\t  // Directory is empty so we can remove it.\n+\t\t  if (top.rmdir(ec))\n+\t\t    break; // Success\n+\t\t}\n+\t    }\n+\t}\n+      else if (top.unlink(ec))\n+\tbreak; // Success\n+      else if (top.entry._M_type == file_type::none)\n+\t{\n+\t  // We did not have a cached type, so it's possible that top.entry\n+\t  // is actually a directory, and that's why the unlink above failed.\n+#ifdef EPERM\n+\t  // POSIX.1-2017 says unlinking a directory returns EPERM,\n+\t  // but LSB allows EISDIR too. Some targets don't even define EPERM.\n+\t  if (ec.value() == EPERM || ec.value() == EISDIR)\n+#else\n+\t  if (ec.value() == EISDIR)\n+#endif\n+\t    {\n+\t      // Retry, treating it as a directory.\n+\t      top.entry._M_type = file_type::directory;\n+\t      ec.clear();\n+\t      continue;\n+\t    }\n+\t}\n+    }\n+\n+  if (!ec)\n+    {\n+      // We successfully removed the current entry, so advance to the next one.\n+      if (_M_dirs->top().advance(skip_permission_denied, ec))\n+\treturn *this;\n+      else if (!ec)\n+\t{\n+\t  // Reached the end of the current directory.\n+\t  _M_dirs->pop();\n+\t  if (_M_dirs->empty())\n+\t    _M_dirs.reset();\n+\t  return *this;\n+\t}\n+    }\n+\n+  // Reset _M_dirs to empty.\n+  auto dirs = std::move(_M_dirs);\n+\n+  // Need to report an error\n+  if (ecptr)\n+    *ecptr = ec;\n+  else\n+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\"cannot remove all\",\n+\t\t\t\t\t\t dirs->orig,\n+\t\t\t\t\t\t dirs->current_path(),\n+\t\t\t\t\t\t ec));\n+\n+  return *this;\n+}"}, {"sha": "ae35b0535b37d0b3ca1cd06fbe5543b5d502e5b9", "filename": "libstdc++-v3/src/c++17/fs_ops.cc", "status": "modified", "additions": 48, "deletions": 91, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -1277,105 +1277,62 @@ fs::remove(const path& p, error_code& ec) noexcept\n   return false;\n }\n \n-namespace std::filesystem\n-{\n-namespace\n-{\n-  struct ErrorReporter\n-  {\n-    explicit\n-    ErrorReporter(error_code& ec) : code(&ec)\n-    { }\n-\n-    explicit\n-    ErrorReporter(const char* s, const path& p)\n-    : code(nullptr), msg(s), path1(&p)\n-    { }\n-\n-    error_code* code;\n-    const char* msg;\n-    const path* path1;\n-\n-    void\n-    report(const error_code& ec) const\n-    {\n-      if (code)\n-\t*code = ec;\n-      else\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));\n-    }\n-\n-    void\n-    report(const error_code& ec, const path& path2) const\n-    {\n-      if (code)\n-\t*code = ec;\n-      else if (path2 != *path1)\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, path2, ec));\n-      else\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));\n-    }\n-  };\n-\n-  uintmax_t\n-  do_remove_all(const path& p, const ErrorReporter& err)\n-  {\n-    error_code ec;\n-    const auto s = symlink_status(p, ec);\n-    if (!status_known(s))\n-      {\n-\tif (ec)\n-\t  err.report(ec, p);\n-\treturn -1;\n-      }\n-\n-    ec.clear();\n-    if (s.type() == file_type::not_found)\n-      return 0;\n-\n-    uintmax_t count = 0;\n-    if (s.type() == file_type::directory)\n-      {\n-\tdirectory_iterator d(p, directory_options{99}, ec), end;\n-\twhile (d != end)\n-\t  {\n-\t    const auto removed = fs::do_remove_all(d->path(), err);\n-\t    if (removed == numeric_limits<uintmax_t>::max())\n-\t      return -1;\n-\t    count += removed;\n-\n-\t    d.increment(ec);\n-\t  }\n-\tif (ec)\n-\t  {\n-\t    err.report(ec, p);\n-\t    return -1;\n-\t  }\n-      }\n-\n-    if (fs::remove(p, ec))\n-      ++count;\n-    if (ec)\n-      {\n-\terr.report(ec, p);\n-\treturn -1;\n-      }\n-    return count;\n-  }\n-}\n-}\n-\n std::uintmax_t\n fs::remove_all(const path& p)\n {\n-  return fs::do_remove_all(p, ErrorReporter{\"cannot remove all\", p});\n+  uintmax_t count = 0;\n+  auto st = filesystem::status(p);\n+  if (!exists(st))\n+    return 0;\n+  if (is_directory(st))\n+    {\n+      recursive_directory_iterator dir(p, directory_options{64|128}), end;\n+      path failed;\n+      while (dir != end)\n+\t{\n+\t  failed = dir->path();\n+\t  dir.__erase();\n+\t  ++count;\n+\t}\n+    }\n+  return count + fs::remove(p);\n }\n \n std::uintmax_t\n fs::remove_all(const path& p, error_code& ec)\n {\n-  ec.clear();\n-  return fs::do_remove_all(p, ErrorReporter{ec});\n+  uintmax_t count = 0;\n+  recursive_directory_iterator dir(p, directory_options{64|128}, ec);\n+  switch (ec.value())\n+  {\n+  case 0:\n+    {\n+      recursive_directory_iterator end;\n+      while (dir != end)\n+\t{\n+\t  dir.__erase(&ec);\n+\t  if (ec)\n+\t    return -1;\n+\t  ++count;\n+\t}\n+    }\n+    break;\n+  case ENOENT:\n+    // Our work here is done.\n+    ec.clear();\n+    return 0;\n+  case ENOTDIR:\n+  case ELOOP:\n+    // Not a directory, will remove below.\n+    break;\n+  default:\n+    // An error occurred.\n+    return -1;\n+  }\n+  // Remove p itself, which is either a non-directory or is now empty.\n+  if (int last = fs::remove(p, ec); !ec)\n+    return count + last;\n+  return -1;\n }\n \n void"}, {"sha": "ee4f33b6bc11a8022b5aec729362734ce3efc30f", "filename": "libstdc++-v3/src/filesystem/dir-common.h", "status": "modified", "additions": 97, "deletions": 48, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir-common.h?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -34,11 +34,11 @@\n # ifdef _GLIBCXX_HAVE_SYS_TYPES_H\n #  include <sys/types.h>\n # endif\n-# include <dirent.h>\n-#endif\n-#ifdef _GLIBCXX_HAVE_FCNTL_H\n-# include <fcntl.h> // O_NOFOLLOW, O_DIRECTORY\n-# include <unistd.h> // close\n+# include <dirent.h> // opendir, readdir, fdopendir, dirfd\n+# ifdef _GLIBCXX_HAVE_FCNTL_H\n+#  include <fcntl.h>  // open, openat, fcntl, AT_FDCWD, O_NOFOLLOW etc.\n+#  include <unistd.h> // close, unlinkat\n+# endif\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -75,42 +75,32 @@ inline int closedir(DIR*) { return -1; }\n \n namespace posix = __gnu_posix;\n \n+inline bool\n+is_permission_denied_error(int e)\n+{\n+  if (e == EACCES)\n+    return true;\n+#ifdef __APPLE__\n+  if (e == EPERM) // See PR 99533\n+    return true;\n+#endif\n+  return false;\n+}\n+\n struct _Dir_base\n {\n   _Dir_base(posix::DIR* dirp = nullptr) : dirp(dirp) { }\n \n   // If no error occurs then dirp is non-null,\n-  // otherwise null (even if an EACCES error is ignored).\n-  _Dir_base(const posix::char_type* pathname, bool skip_permission_denied,\n-\t    [[maybe_unused]] bool nofollow, error_code& ec) noexcept\n-  : dirp(nullptr)\n+  // otherwise null (even if a permission denied error is ignored).\n+  _Dir_base(int fd, const posix::char_type* pathname,\n+\t    bool skip_permission_denied, bool nofollow,\n+\t    error_code& ec) noexcept\n+  : dirp(_Dir_base::openat(fd, pathname, nofollow))\n   {\n-#if defined O_RDONLY && O_NOFOLLOW && defined O_DIRECTORY && defined O_CLOEXEC \\\n-    && defined _GLIBCXX_HAVE_FDOPENDIR && !_GLIBCXX_FILESYSTEM_IS_WINDOWS\n-    if (nofollow)\n-      {\n-\t// Do not allow opening a symlink (used by filesystem::remove_all)\n-\tconst int flags = O_RDONLY | O_NOFOLLOW | O_DIRECTORY | O_CLOEXEC;\n-\tint fd = ::open(pathname, flags);\n-\tif (fd != -1)\n-\t  {\n-\t    if ((dirp = ::fdopendir(fd)))\n-\t      {\n-\t\tec.clear();\n-\t\treturn;\n-\t      }\n-\t  }\n-\tif (errno == EACCES && skip_permission_denied)\n-\t  ec.clear();\n-\telse\n-\t  ec.assign(errno, std::generic_category());\n-\treturn;\n-      }\n-#endif\n-\n-    if ((dirp = posix::opendir(pathname)))\n+    if (dirp)\n       ec.clear();\n-    else if (errno == EACCES && skip_permission_denied)\n+    else if (is_permission_denied_error(errno) && skip_permission_denied)\n       ec.clear();\n     else\n       ec.assign(errno, std::generic_category());\n@@ -153,6 +143,16 @@ struct _Dir_base\n       }\n   }\n \n+  static constexpr int\n+  fdcwd() noexcept\n+  {\n+#ifdef AT_FDCWD\n+    return AT_FDCWD;\n+#else\n+    return -1; // Use invalid fd if AT_FDCWD isn't supported.\n+#endif\n+  }\n+\n   static bool is_dot_or_dotdot(const char* s) noexcept\n   { return !strcmp(s, \".\") || !strcmp(s, \"..\"); }\n \n@@ -161,20 +161,71 @@ struct _Dir_base\n   { return !wcscmp(s, L\".\") || !wcscmp(s, L\"..\"); }\n #endif\n \n-  posix::DIR*\tdirp;\n-};\n-\n-inline bool\n-is_permission_denied_error(int e)\n-{\n-  if (e == EACCES)\n-    return true;\n-#ifdef __APPLE__\n-  if (e == EPERM) // See PR 99533\n+  // Set the close-on-exec flag if not already done via O_CLOEXEC.\n+  static bool\n+  set_close_on_exec([[maybe_unused]] int fd)\n+  {\n+#if ! defined O_CLOEXEC && defined FD_CLOEXEC\n+    int flags = ::fcntl(fd, F_GETFD);\n+    if (flags == -1 || ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)\n+      return false;\n+#endif\n     return true;\n+  }\n+\n+  static ::DIR*\n+  openat(int fd, const posix::char_type* pathname, bool nofollow)\n+  {\n+#if _GLIBCXX_HAVE_FDOPENDIR && defined O_RDONLY && defined O_DIRECTORY \\\n+    && ! _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+\n+    // Any file descriptor we open here should be closed on exec.\n+#ifdef O_CLOEXEC\n+    constexpr int close_on_exec = O_CLOEXEC;\n+#else\n+    constexpr int close_on_exec = 0;\n+#endif\n+\n+    int flags = O_RDONLY | O_DIRECTORY | close_on_exec;\n+\n+    // Directory iterators are vulnerable to race conditions unless O_NOFOLLOW\n+    // is supported, because a directory could be replaced with a symlink after\n+    // checking is_directory(symlink_status(f)). O_NOFOLLOW avoids the race.\n+#ifdef O_NOFOLLOW\n+    if (nofollow)\n+      flags |= O_NOFOLLOW;\n+#else\n+    nofollow = false;\n+#endif\n+\n+\n+#ifdef AT_FDCWD\n+    fd = ::openat(fd, pathname, flags);\n+#else\n+    // If we cannot use openat, there's no benefit to using posix::open unless\n+    // we will use O_NOFOLLOW, so just use the simpler posix::opendir.\n+    if (!nofollow)\n+      return posix::opendir(pathname);\n+\n+    fd = ::open(pathname, flags);\n #endif\n-  return false;\n-}\n+\n+    if (fd == -1)\n+      return nullptr;\n+    if (set_close_on_exec(fd))\n+      if (::DIR* dirp = ::fdopendir(fd))\n+\treturn dirp;\n+    int err = errno;\n+    ::close(fd);\n+    errno = err;\n+    return nullptr;\n+#else\n+    return posix::opendir(pathname);\n+#endif\n+  }\n+\n+  posix::DIR*\tdirp;\n+};\n \n } // namespace filesystem\n \n@@ -211,8 +262,6 @@ get_file_type(const std::filesystem::__gnu_posix::dirent& d [[gnu::unused]])\n #endif\n }\n \n-constexpr directory_options __directory_iterator_nofollow{99};\n-\n _GLIBCXX_END_NAMESPACE_FILESYSTEM\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "e838b4bc6bfb71ebf310e828119f22d275f18c0a", "filename": "libstdc++-v3/src/filesystem/dir.cc", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fdir.cc?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -53,7 +53,7 @@ struct fs::_Dir : std::filesystem::_Dir_base\n {\n   _Dir(const fs::path& p, bool skip_permission_denied, bool nofollow,\n        error_code& ec)\n-  : _Dir_base(p.c_str(), skip_permission_denied, nofollow, ec)\n+  : _Dir_base(this->fdcwd(), p.c_str(), skip_permission_denied, nofollow, ec)\n   {\n     if (!ec)\n       path = p;\n@@ -113,6 +113,29 @@ struct fs::_Dir : std::filesystem::_Dir_base\n     return false;\n   }\n \n+  // Return a file descriptor for the directory and current entry's path.\n+  // If dirfd is available, use it and return only the filename.\n+  // Otherwise, return AT_FDCWD and return the full path.\n+  pair<int, const posix::char_type*>\n+  dir_and_pathname() const noexcept\n+  {\n+    const fs::path& p = entry.path();\n+#if _GLIBCXX_HAVE_DIRFD\n+    return {::dirfd(this->dirp), std::prev(p.end())->c_str()};\n+#endif\n+    return {this->fdcwd(), p.c_str()};\n+  }\n+\n+  // Create a new _Dir for the directory this->entry.path().\n+  _Dir\n+  open_subdir(bool skip_permission_denied, bool nofollow,\n+\t      error_code& ec) noexcept\n+  {\n+    auto [dirfd, pathname] = dir_and_pathname();\n+    _Dir_base d(dirfd, pathname, skip_permission_denied, nofollow, ec);\n+    return _Dir(std::exchange(d.dirp, nullptr), entry.path());\n+  }\n+\n   fs::path\t\tpath;\n   directory_entry\tentry;\n   file_type\t\ttype = file_type::none;\n@@ -134,12 +157,9 @@ directory_iterator(const path& p, directory_options options, error_code* ecptr)\n   // Do not report an error for permission denied errors.\n   const bool skip_permission_denied\n     = is_set(options, directory_options::skip_permission_denied);\n-  // Do not allow opening a symlink (used by filesystem::remove_all)\n-  const bool nofollow\n-     = is_set(options, __directory_iterator_nofollow);\n \n   error_code ec;\n-  _Dir dir(p, skip_permission_denied, nofollow, ec);\n+  _Dir dir(p, skip_permission_denied, /*nofollow*/false, ec);\n \n   if (dir.dirp)\n     {\n@@ -191,6 +211,11 @@ fs::directory_iterator::increment(error_code& ec) noexcept\n \n struct fs::recursive_directory_iterator::_Dir_stack : std::stack<_Dir>\n {\n+  _Dir_stack(_Dir&& dir)\n+  {\n+    this->push(std::move(dir));\n+  }\n+\n   void clear() { c.clear(); }\n };\n \n@@ -199,33 +224,27 @@ recursive_directory_iterator(const path& p, directory_options options,\n                              error_code* ecptr)\n : _M_options(options), _M_pending(true)\n {\n-  if (posix::DIR* dirp = posix::opendir(p.c_str()))\n-    {\n-      if (ecptr)\n-\tecptr->clear();\n-      auto sp = std::make_shared<_Dir_stack>();\n-      sp->push(_Dir{ dirp, p });\n-      if (ecptr ? sp->top().advance(*ecptr) : sp->top().advance())\n-\t_M_dirs.swap(sp);\n-    }\n-  else\n+  // Do not report an error for permission denied errors.\n+  const bool skip_permission_denied\n+    = is_set(options, directory_options::skip_permission_denied);\n+\n+  error_code ec;\n+  _Dir dir(p, skip_permission_denied, /*nofollow*/false, ec);\n+\n+  if (dir.dirp)\n     {\n-      const int err = errno;\n-      if (std::filesystem::is_permission_denied_error(err)\n-\t  && is_set(options, fs::directory_options::skip_permission_denied))\n+      auto sp = std::__make_shared<_Dir_stack>(std::move(dir));\n+      if (ecptr ? sp->top().advance(skip_permission_denied, *ecptr)\n+\t\t: sp->top().advance(skip_permission_denied))\n \t{\n-\t  if (ecptr)\n-\t    ecptr->clear();\n-\t  return;\n+\t  _M_dirs.swap(sp);\n \t}\n-\n-      if (!ecptr)\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"recursive directory iterator cannot open directory\", p,\n-\t      std::error_code(err, std::generic_category())));\n-\n-      ecptr->assign(err, std::generic_category());\n     }\n+  else if (ecptr)\n+    *ecptr = ec;\n+  else if (ec)\n+    _GLIBCXX_THROW_OR_ABORT(fs::filesystem_error(\n+\t  \"recursive directory iterator cannot open directory\", p, ec));\n }\n \n fs::recursive_directory_iterator::~recursive_directory_iterator() = default;\n@@ -279,7 +298,7 @@ fs::recursive_directory_iterator::increment(error_code& ec) noexcept\n \n   if (std::exchange(_M_pending, true) && top.should_recurse(follow, ec))\n     {\n-      _Dir dir(top.entry.path(), skip_permission_denied, !follow, ec);\n+      _Dir dir = top.open_subdir(skip_permission_denied, !follow, ec);\n       if (ec)\n \t{\n \t  _M_dirs.reset();"}, {"sha": "c020f621a88f8f04fbe0276f36b88feff201abe8", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf6175464768983a2d8c82c2d47771ee89192b8/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=ebf6175464768983a2d8c82c2d47771ee89192b8", "patch": "@@ -63,6 +63,8 @@\n #define _GLIBCXX_END_NAMESPACE_FILESYSTEM } }\n #include \"ops-common.h\"\n \n+#include <filesystem> // std::filesystem::remove_all\n+\n namespace fs = std::experimental::filesystem;\n namespace posix = std::filesystem::__gnu_posix;\n \n@@ -1098,33 +1100,8 @@ fs::remove_all(const path& p)\n std::uintmax_t\n fs::remove_all(const path& p, error_code& ec) noexcept\n {\n-  const auto s = symlink_status(p, ec);\n-  if (!status_known(s))\n-    return -1;\n-\n-  ec.clear();\n-  if (s.type() == file_type::not_found)\n-    return 0;\n-\n-  uintmax_t count = 0;\n-  if (s.type() == file_type::directory)\n-    {\n-      directory_iterator d(p, directory_options{99}, ec), end;\n-      while (!ec && d != end)\n-\t{\n-\t  const auto removed = fs::remove_all(d->path(), ec);\n-\t  if (removed == numeric_limits<uintmax_t>::max())\n-\t    return -1;\n-\t  count += removed;\n-\t  d.increment(ec);\n-\t}\n-      if (ec)\n-\treturn -1;\n-    }\n-\n-  if (fs::remove(p, ec))\n-    ++count;\n-  return ec ? -1 : count;\n+  // Use the C++17 implementation.\n+  return std::filesystem::remove_all(p.native(), ec);\n }\n \n void"}]}