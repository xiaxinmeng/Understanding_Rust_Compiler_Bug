{"sha": "e4931540c01b99ec06bbc5fb83f3c68228042221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5MzE1NDBjMDFiOTllYzA2YmJjNWZiODNmM2M2ODIyODA0MjIyMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T13:06:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T13:06:44Z"}, "message": "(define_peephole): Add peepholes to use r0+rN addressing mode for some\naddress reloads.\n\nFrom-SVN: r10184", "tree": {"sha": "5ddc50307db118fb836a21ff02a2f000de4b2956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ddc50307db118fb836a21ff02a2f000de4b2956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4931540c01b99ec06bbc5fb83f3c68228042221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4931540c01b99ec06bbc5fb83f3c68228042221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4931540c01b99ec06bbc5fb83f3c68228042221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4931540c01b99ec06bbc5fb83f3c68228042221/comments", "author": null, "committer": null, "parents": [{"sha": "a55e9d2b21e897007f739cdbe66d5227b35ebba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55e9d2b21e897007f739cdbe66d5227b35ebba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a55e9d2b21e897007f739cdbe66d5227b35ebba3"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "4f49549c9f62171c8ab189c8e8b8a395695bcd68", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4931540c01b99ec06bbc5fb83f3c68228042221/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4931540c01b99ec06bbc5fb83f3c68228042221/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=e4931540c01b99ec06bbc5fb83f3c68228042221", "patch": "@@ -1810,3 +1810,84 @@\n \t       (const_int 0)))]\n   \"TARGET_SH2\"\n   \"dt\t%0\")\n+\n+;; These convert sequences such as `mov #k,r0; add r15,r0; mov.l @r0,rn'\n+;; to `mov #k,r0; mov.l @(r0,r15),rn'.  These sequences are generated by\n+;; reload when the constant is too large for a reg+offset address.\n+\n+;; ??? We would get much better code if this was done in reload.  This would\n+;; require modifying find_reloads_address to recognize that if the constant\n+;; is out-of-range for an immediate add, then we get better code by reloading\n+;; the constant into a register than by reloading the sum into a register,\n+;; since the former is one instruction shorter if the address does not need\n+;; to be offsettable.  Unfortunately this does not work, because there is\n+;; only one register, r0, that can be used as an index register.  This register\n+;; is also the function return value register.  So, if we try to force reload\n+;; to use double-reg addresses, then we end up with some instructions that\n+;; need to use r0 twice.  The only way to fix this is to change the calling\n+;; convention so that r0 is not used to return values.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:SI (match_dup 0))\n+\t(match_operand:SI 2 \"general_movsrc_operand\" \"\"))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.l\t%2,@(%0,%1)\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:SI 2 \"general_movdst_operand\" \"\")\n+\t(mem:SI (match_dup 0)))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.l\t@(%0,%1),%2\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:HI (match_dup 0))\n+\t(match_operand:HI 2 \"general_movsrc_operand\" \"\"))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.w\t%2,@(%0,%1)\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:HI 2 \"general_movdst_operand\" \"\")\n+\t(mem:HI (match_dup 0)))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.w\t@(%0,%1),%2\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:QI (match_dup 0))\n+\t(match_operand:QI 2 \"general_movsrc_operand\" \"\"))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.b\t%2,@(%0,%1)\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:QI 2 \"general_movdst_operand\" \"\")\n+\t(mem:QI (match_dup 0)))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.b\t@(%0,%1),%2\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (mem:SF (match_dup 0))\n+\t(match_operand:SF 2 \"general_movsrc_operand\" \"\"))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.l\t%2,@(%0,%1)\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (match_operand:SF 2 \"general_movdst_operand\" \"\")\n+\n+\t(mem:SF (match_dup 0)))]\n+  \"REGNO (operands[0]) == 0 && reg_unused_after (operands[0], insn)\"\n+  \"mov.l\t@(%0,%1),%2\")"}]}