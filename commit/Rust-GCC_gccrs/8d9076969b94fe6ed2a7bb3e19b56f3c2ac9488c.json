{"sha": "8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ5MDc2OTY5Yjk0ZmU2ZWQyYTdiYjNlMTliNTZmM2MyYWM5NDg4Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-11-03T02:55:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-11-03T02:55:32Z"}, "message": "Add support for ref-qualified functions to std::mem_fn\n\n\tPR libstdc++/57898\n\t* include/std/functional (_Mem_fn_traits_base): New class template.\n\t(_Mem_fn_traits): New class template with specializations for every\n\tcombination of cv-qualified and ref-qualified member function.\n\t(_Mem_fn_base): New class template for all pointer to member function\n\ttypes and partial specialization for pointer to member object types.\n\t(_Mem_fn): Inherit from _Mem_fn_base.\n\t* testsuite/20_util/function_objects/mem_fn/refqual.cc: New.\n\nFrom-SVN: r217024", "tree": {"sha": "ae70857bf8288024edfc24fa8e93d3b1962efda8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae70857bf8288024edfc24fa8e93d3b1962efda8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba89c141dc4e9fa468f812d617f95da59d8007f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba89c141dc4e9fa468f812d617f95da59d8007f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba89c141dc4e9fa468f812d617f95da59d8007f"}], "stats": {"total": 507, "additions": 223, "deletions": 284}, "files": [{"sha": "86bc08fe3cce9122a63b8853170442afa00832ec", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "patch": "@@ -1,3 +1,14 @@\n+2014-11-02  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/57898\n+\t* include/std/functional (_Mem_fn_traits_base): New class template.\n+\t(_Mem_fn_traits): New class template with specializations for every\n+\tcombination of cv-qualified and ref-qualified member function.\n+\t(_Mem_fn_base): New class template for all pointer to member function\n+\ttypes and partial specialization for pointer to member object types.\n+\t(_Mem_fn): Inherit from _Mem_fn_base.\n+\t* testsuite/20_util/function_objects/mem_fn/refqual.cc: New.\n+\n 2014-10-31  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/stl_bvector.h (_Bvector_base): Use allocator_traits."}, {"sha": "ecc5bc98f05ce1e47ac4a43c416f2440fcc0b0dc", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 178, "deletions": 284, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "patch": "@@ -504,344 +504,231 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n     : std::binary_function<_T1, _T2, _Res> { };\n \n-  /// Implementation of @c mem_fn for member function pointers.\n+  template<typename _Signature>\n+    struct _Mem_fn_traits;\n+\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n-    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    struct _Mem_fn_traits_base\n     {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n-\n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_Args&&... __args) const\n-\t{\n-\t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      template<typename... _Args>\n-\tusing _RequireValidArgs\n-\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      // and require _Tp is not _Class, _Class& or _Class*\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs2\n-\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-      // Require each _Args to be convertible to corresponding _ArgTypes\n-      // and require _Tp is _Class or derived from _Class\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs3\n-\t  = _Require<is_base_of<_Class, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-    public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(_Class& __object, _Args&&... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(_Class&& __object, _Args&&... __args) const\n-\t{\n-\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n-\t}\n-\n-      // Handle pointers\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(_Class* __object, _Args&&... __args) const\n-\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n-\t_Res\n-\toperator()(_Tp&& __object, _Args&&... __args) const\n-\t{\n-\t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n-\t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n-\n-    private:\n-      _Functor __pmf;\n+      using __result_type = _Res;\n+      using __class_type =  _Class;\n+      using __arg_types = _Pack<_ArgTypes...>;\n+      using __maybe_type\n+\t= _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;\n     };\n \n-  /// Implementation of @c mem_fn for const member function pointers.\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n-    : public _Maybe_unary_or_binary_function<_Res, const _Class*,\n-\t\t\t\t\t     _ArgTypes...>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)>\n+    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n     {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n-\n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_Args&&... __args) const\n-\t{\n-\t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      template<typename... _Args>\n-\tusing _RequireValidArgs\n-\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs2\n-\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<const _Class*, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs3\n-\t  = _Require<is_base_of<_Class, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n-\n-    public:\n-      typedef _Res result_type;\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...);\n+      using __lvalue = true_type;\n+      using __rvalue = true_type;\n+    };\n \n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const>\n+    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const;\n+      using __lvalue = true_type;\n+      using __rvalue = true_type;\n+    };\n \n-      // Handle objects\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const _Class& __object, _Args&&... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const _Class&& __object, _Args&&... __args) const\n-\t{\n-\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n-\t}\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile>\n+    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile;\n+      using __lvalue = true_type;\n+      using __rvalue = true_type;\n+    };\n \n-      // Handle pointers\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const _Class* __object, _Args&&... __args) const\n-\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile>\n+    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile;\n+      using __lvalue = true_type;\n+      using __rvalue = true_type;\n+    };\n \n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n-\t_Res operator()(_Tp&& __object, _Args&&... __args) const\n-\t{\n-\t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_Args>(__args)...);\n-\t}\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)&>\n+    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...)&;\n+      using __lvalue = true_type;\n+      using __rvalue = false_type;\n+    };\n \n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n-\t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const&>\n+    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const&;\n+      using __lvalue = true_type;\n+      using __rvalue = false_type;\n+    };\n \n-    private:\n-      _Functor __pmf;\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile&>\n+    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile&;\n+      using __lvalue = true_type;\n+      using __rvalue = false_type;\n     };\n \n-  /// Implementation of @c mem_fn for volatile member function pointers.\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,\n-\t\t\t\t\t     _ArgTypes...>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile&>\n+    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n     {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile&;\n+      using __lvalue = true_type;\n+      using __rvalue = false_type;\n+    };\n \n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __object, const volatile _Class *,\n-\t\t_Args&&... __args) const\n-\t{\n-\t  return (std::forward<_Tp>(__object).*__pmf)\n-\t    (std::forward<_Args>(__args)...);\n-\t}\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)&&>\n+    : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...)&&;\n+      using __lvalue = false_type;\n+      using __rvalue = true_type;\n+    };\n \n-      template<typename _Tp, typename... _Args>\n-\t_Res\n-\t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const&&>\n+    : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const&&;\n+      using __lvalue = false_type;\n+      using __rvalue = true_type;\n+    };\n \n-      template<typename... _Args>\n-\tusing _RequireValidArgs\n-\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile&&>\n+    : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) volatile&&;\n+      using __lvalue = false_type;\n+      using __rvalue = true_type;\n+    };\n \n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs2\n-\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<volatile _Class*, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile&&>\n+    : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...>\n+    {\n+      using __pmf_type  = _Res (_Class::*)(_ArgTypes...) const volatile&&;\n+      using __lvalue = false_type;\n+      using __rvalue = true_type;\n+    };\n \n-      template<typename _Tp, typename... _Args>\n-\tusing _RequireValidArgs3\n-\t  = _Require<is_base_of<_Class, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+  template<typename _MemFunPtr,\n+\t   bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>\n+    class _Mem_fn_base\n+    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type\n+    {\n+      using _Traits = _Mem_fn_traits<_MemFunPtr>;\n \n     public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n-\n-      // Handle objects\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(volatile _Class& __object, _Args&&... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(volatile _Class&& __object, _Args&&... __args) const\n-\t{\n-\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n-\t}\n-\n-      // Handle pointers\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(volatile _Class* __object, _Args&&... __args) const\n-\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n-\t_Res\n-\toperator()(_Tp&& __object, _Args&&... __args) const\n-\t{\n-\t  return _M_call(std::forward<_Tp>(__object), &__object,\n-\t      std::forward<_Args>(__args)...);\n-\t}\n-\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n-\t_Res\n-\toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n-\t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n+      using result_type = typename _Traits::__result_type;\n \n     private:\n-      _Functor __pmf;\n-    };\n-\n-  /// Implementation of @c mem_fn for const volatile member function pointers.\n-  template<typename _Res, typename _Class, typename... _ArgTypes>\n-    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,\n-\t\t\t\t\t     _ArgTypes...>\n-    {\n-      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n+      using _Class = typename _Traits::__class_type;\n+      using _ArgTypes = typename _Traits::__arg_types;\n+      using _Pmf = typename _Traits::__pmf_type;\n \n       template<typename _Tp, typename... _Args>\n-\t_Res\n+\tresult_type\n \t_M_call(_Tp&& __object, const volatile _Class *,\n \t\t_Args&&... __args) const\n \t{\n-\t  return (std::forward<_Tp>(__object).*__pmf)\n+\t  return (std::forward<_Tp>(__object).*_M_pmf)\n \t    (std::forward<_Args>(__args)...);\n \t}\n \n       template<typename _Tp, typename... _Args>\n-\t_Res\n+\tresult_type\n \t_M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const\n-\t{ return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }\n+\t{ return ((*__ptr).*_M_pmf)(std::forward<_Args>(__args)...); }\n \n+      // Require each _Args to be convertible to corresponding _ArgTypes\n       template<typename... _Args>\n \tusing _RequireValidArgs\n-\t  = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\t  = _Require<_AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n \n+      // Require each _Args to be convertible to corresponding _ArgTypes\n+      // and require _Tp is not _Class, _Class& or _Class*\n       template<typename _Tp, typename... _Args>\n \tusing _RequireValidArgs2\n-\t  = _Require<_NotSame<_Class, _Tp>,\n-\t\t     _NotSame<const volatile _Class*, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\t  = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+\t\t     _AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n \n+      // Require each _Args to be convertible to corresponding _ArgTypes\n+      // and require _Tp is _Class or derived from _Class\n       template<typename _Tp, typename... _Args>\n \tusing _RequireValidArgs3\n \t  = _Require<is_base_of<_Class, _Tp>,\n-\t\t     _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;\n+\t\t     _AllConvertible<_Pack<_Args...>, _ArgTypes>>;\n \n     public:\n-      typedef _Res result_type;\n-\n-      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+      explicit _Mem_fn_base(_Pmf __pmf) : _M_pmf(__pmf) { }\n \n       // Handle objects\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const volatile _Class& __object, _Args&&... __args) const\n-\t{ return (__object.*__pmf)(std::forward<_Args>(__args)...); }\n-\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const volatile _Class&& __object, _Args&&... __args) const\n+      template<typename... _Args, typename _Req\n+               = _Require<typename _Traits::__lvalue,\n+                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+\tresult_type\n+\toperator()(_Class& __object, _Args&&... __args) const\n+\t{ return (__object.*_M_pmf)(std::forward<_Args>(__args)...); }\n+\n+      template<typename... _Args, typename _Req\n+               = _Require<typename _Traits::__rvalue,\n+                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+\tresult_type\n+\toperator()(_Class&& __object, _Args&&... __args) const\n \t{\n-\t  return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);\n+\t  return (std::move(__object).*_M_pmf)(std::forward<_Args>(__args)...);\n \t}\n \n       // Handle pointers\n-      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>\n-\t_Res\n-\toperator()(const volatile _Class* __object, _Args&&... __args) const\n-\t{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }\n+      template<typename... _Args, typename _Req\n+               = _Require<typename _Traits::__lvalue,\n+                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+\tresult_type\n+\toperator()(_Class* __object, _Args&&... __args) const\n+\t{ return (__object->*_M_pmf)(std::forward<_Args>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs2<_Tp, _Args...>>\n-\t_Res operator()(_Tp&& __object, _Args&&... __args) const\n+      // TODO how to constrain to lvalue/rvalue here? constrain _M_call?\n+      template<typename _Tp, typename... _Args, typename _Req\n+               = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,\n+                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+\tresult_type\n+\toperator()(_Tp&& __object, _Args&&... __args) const\n \t{\n \t  return _M_call(std::forward<_Tp>(__object), &__object,\n \t      std::forward<_Args>(__args)...);\n \t}\n \n-      template<typename _Tp, typename... _Args,\n-\t       typename _Req = _RequireValidArgs3<_Tp, _Args...>>\n-\t_Res\n+      // Handle reference wrappers\n+      template<typename _Tp, typename... _Args, typename _Req\n+               = _Require<is_base_of<_Class, _Tp>,\n+                          typename _Traits::__lvalue,\n+                          _AllConvertible<_Pack<_Args...>, _ArgTypes>>>\n+\tresult_type\n \toperator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const\n \t{ return operator()(__ref.get(), std::forward<_Args>(__args)...); }\n \n     private:\n-      _Functor __pmf;\n-    };\n-\n-\n-  template<typename _Tp, bool>\n-    struct _Mem_fn_const_or_non\n-    {\n-      typedef const _Tp& type;\n-    };\n-\n-  template<typename _Tp>\n-    struct _Mem_fn_const_or_non<_Tp, false>\n-    {\n-      typedef _Tp& type;\n+      _Pmf _M_pmf;\n     };\n \n+  // Partial specialization for member object pointers.\n   template<typename _Res, typename _Class>\n-    class _Mem_fn<_Res _Class::*>\n+    class _Mem_fn_base<_Res _Class::*, false>\n     {\n       using __pm_type = _Res _Class::*;\n \n@@ -852,69 +739,76 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \tauto\n \t_M_call(_Tp&& __object, const _Class *) const noexcept\n \t-> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())\n-\t{ return std::forward<_Tp>(__object).*__pm; }\n+\t{ return std::forward<_Tp>(__object).*_M_pm; }\n \n       template<typename _Tp, typename _Up>\n \tauto\n \t_M_call(_Tp&& __object, _Up * const *) const noexcept\n \t-> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())\n-\t{ return (*std::forward<_Tp>(__object)).*__pm; }\n+\t{ return (*std::forward<_Tp>(__object)).*_M_pm; }\n \n       template<typename _Tp>\n \tauto\n \t_M_call(_Tp&& __ptr, const volatile void*) const\n \tnoexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))\n \t-> decltype((*__ptr).*std::declval<__pm_type&>())\n-\t{ return (*__ptr).*__pm; }\n+\t{ return (*__ptr).*_M_pm; }\n \n     public:\n       explicit\n-      _Mem_fn(_Res _Class::*__pm) noexcept : __pm(__pm) { }\n+      _Mem_fn_base(_Res _Class::*__pm) noexcept : _M_pm(__pm) { }\n \n       // Handle objects\n       _Res&\n       operator()(_Class& __object) const noexcept\n-      { return __object.*__pm; }\n+      { return __object.*_M_pm; }\n \n       const _Res&\n       operator()(const _Class& __object) const noexcept\n-      { return __object.*__pm; }\n+      { return __object.*_M_pm; }\n \n       _Res&&\n       operator()(_Class&& __object) const noexcept\n-      { return std::forward<_Class>(__object).*__pm; }\n+      { return std::forward<_Class>(__object).*_M_pm; }\n \n       const _Res&&\n       operator()(const _Class&& __object) const noexcept\n-      { return std::forward<const _Class>(__object).*__pm; }\n+      { return std::forward<const _Class>(__object).*_M_pm; }\n \n       // Handle pointers\n       _Res&\n       operator()(_Class* __object) const noexcept\n-      { return __object->*__pm; }\n+      { return __object->*_M_pm; }\n \n       const _Res&\n       operator()(const _Class* __object) const noexcept\n-      { return __object->*__pm; }\n+      { return __object->*_M_pm; }\n \n       // Handle smart pointers and derived\n       template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>\n \tauto\n \toperator()(_Tp&& __unknown) const\n-\tnoexcept(noexcept(std::declval<_Mem_fn*>()->_M_call\n+\tnoexcept(noexcept(std::declval<_Mem_fn_base*>()->_M_call\n \t\t\t  (std::forward<_Tp>(__unknown), &__unknown)))\n \t-> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))\n \t{ return _M_call(std::forward<_Tp>(__unknown), &__unknown); }\n \n       template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>\n \tauto\n \toperator()(reference_wrapper<_Tp> __ref) const\n-\tnoexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))\n+\tnoexcept(noexcept(std::declval<_Mem_fn_base&>()(__ref.get())))\n \t-> decltype((*this)(__ref.get()))\n \t{ return (*this)(__ref.get()); }\n \n     private:\n-      _Res _Class::*__pm;\n+      _Res _Class::*_M_pm;\n+    };\n+\n+  template<typename _Res, typename _Class>\n+    struct _Mem_fn<_Res _Class::*>\n+    : _Mem_fn_base<_Res _Class::*>\n+    {\n+      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;\n     };\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS"}, {"sha": "35a66e5541021f0161bf1b03dd11454d6113bf8c", "filename": "libstdc++-v3/testsuite/20_util/function_objects/mem_fn/refqual.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffunction_objects%2Fmem_fn%2Frefqual.cc?ref=8d9076969b94fe6ed2a7bb3e19b56f3c2ac9488c", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+#include <functional>\n+\n+struct Foo\n+{\n+  void r()&& { }\n+  int l() const& { return 0; }\n+};\n+\n+void test01()\n+{\n+  Foo f;\n+  int i = std::mem_fn(&Foo::l)( f );\n+  std::mem_fn(&Foo::r)( std::move(f) );\n+}"}]}