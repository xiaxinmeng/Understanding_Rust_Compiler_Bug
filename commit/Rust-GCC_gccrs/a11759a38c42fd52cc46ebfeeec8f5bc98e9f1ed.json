{"sha": "a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTExNzU5YTM4YzQyZmQ1MmNjNDZlYmZlZWVjOGY1YmM5OGU5ZjFlZA==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-02-17T10:26:44Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-02-17T10:26:44Z"}, "message": "rtl.h (force_line_numbers, [...]): Declare.\n\n\t* rtl.h (force_line_numbers, restore_line_number_status): Declare.\n\t* emit-rtl.c (force_line_numbers, restore_line_number_status):\n\tNew functions.\n\t* stmt.c (struct nesting): Replace seenlabel with line_number_status.\n\t(expand_start_case): Adjust to this change.\n\t(check_seenlabel): New function.\n\t(pushcase, pushcase_range, expand_endcase): Use it.\n\nFrom-SVN: r18031", "tree": {"sha": "7d919ed17c492831b64a4b11a496099612b303e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d919ed17c492831b64a4b11a496099612b303e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/comments", "author": null, "committer": null, "parents": [{"sha": "93f83bd58d196e279df4669628b54dd46b89f036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f83bd58d196e279df4669628b54dd46b89f036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f83bd58d196e279df4669628b54dd46b89f036"}], "stats": {"total": 132, "additions": 72, "deletions": 60}, "files": [{"sha": "3da217ced043c0f6ea30cd325e4b4fba6cda600a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "patch": "@@ -3457,3 +3457,25 @@ init_emit_once (line_numbers)\n   pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n #endif\n }\n+\f\n+/* Query and clear/ restore no_line_numbers.  This is used by the\n+   switch / case handling in stmt.c to give proper line numbers in\n+   warnings about unreachable code.  */\n+\n+int\n+force_line_numbers ()\n+{\n+  int old = no_line_numbers;\n+\n+  no_line_numbers = 0;\n+  if (old)\n+    force_next_line_note ();\n+  return old;\n+}\n+\n+void\n+restore_line_number_status (old_value)\n+     int old_value;\n+{\n+  no_line_numbers = old_value;\n+}"}, {"sha": "810947537925e27295d76562f7c17bcd1ea4e461", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "patch": "@@ -1147,6 +1147,11 @@ extern void reorder_insns_with_line_notes\tPROTO ((rtx, rtx, rtx));\n extern void emit_insn_after_with_line_notes\tPROTO ((rtx, rtx, rtx));\n extern enum rtx_code classify_insn\t\tPROTO ((rtx));\n extern rtx emit\t\t\t\t\tPROTO ((rtx));\n+/* Query and clear/ restore no_line_numbers.  This is used by the\n+   switch / case handling in stmt.c to give proper line numbers in\n+   warnings about unreachable code.  */\n+int force_line_numbers PROTO((void));\n+void restore_line_number_status PROTO((int old_value));\n \n /* In insn-emit.c */\n extern void add_clobbers\t\tPROTO ((rtx, int));"}, {"sha": "57caad79ca9992ff48ad3af7b7779d5a35476c47", "filename": "gcc/stmt.c", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a11759a38c42fd52cc46ebfeeec8f5bc98e9f1ed", "patch": "@@ -316,8 +316,10 @@ struct nesting\n \t  int num_ranges;\n \t  /* Name of this kind of statement, for warnings.  */\n \t  char *printname;\n-\t  /* Nonzero if a case label has been seen in this case stmt.  */\n-\t  char seenlabel;\n+\t  /* Used to save no_line_numbers till we see the first case label.\n+\t     We set this to -1 when we see the first case label in this\n+\t     case statement.  */\n+\t  int line_number_status;\n \t} case_stmt;\n     } data;\n };\n@@ -3759,7 +3761,7 @@ expand_start_case (exit_flag, expr, type, printname)\n   thiscase->data.case_stmt.default_label = 0;\n   thiscase->data.case_stmt.num_ranges = 0;\n   thiscase->data.case_stmt.printname = printname;\n-  thiscase->data.case_stmt.seenlabel = 0;\n+  thiscase->data.case_stmt.line_number_status = force_line_numbers ();\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n \n@@ -3822,6 +3824,41 @@ case_index_expr_type ()\n   return 0;\n }\n \f\n+static void\n+check_seenlabel ()\n+{\n+  /* If this is the first label, warn if any insns have been emitted.  */\n+  if (case_stack->data.case_stmt.line_number_status >= 0)\n+    {\n+      rtx insn;\n+\n+      restore_line_number_status\n+\t(case_stack->data.case_stmt.line_number_status);\n+      case_stack->data.case_stmt.line_number_status = -1;\n+\n+      for (insn = case_stack->data.case_stmt.start;\n+\t   insn;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    break;\n+\t  if (GET_CODE (insn) != NOTE\n+\t      && (GET_CODE (insn) != INSN || GET_CODE (PATTERN (insn)) != USE))\n+\t    {\n+\t      do\n+\t\tinsn = PREV_INSN (insn);\n+\t      while (GET_CODE (insn) != NOTE || NOTE_LINE_NUMBER (insn) < 0);\n+\n+\t      warning_with_file_and_line (NOTE_SOURCE_FILE(insn),\n+\t\t\t\t\t  NOTE_LINE_NUMBER(insn),\n+\t\t\t\t\t  \"unreachable code at beginning of %s\",\n+\t\t\t\t\t  case_stack->data.case_stmt.printname);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Accumulate one case or default label inside a case or switch statement.\n    VALUE is the value of the case (a null pointer, for a default label).\n    The function CONVERTER, when applied to arguments T and V,\n@@ -3858,6 +3895,8 @@ pushcase (value, converter, label, duplicate)\n   index_type = TREE_TYPE (case_stack->data.case_stmt.index_expr);\n   nominal_type = case_stack->data.case_stmt.nominal_type;\n \n+  check_seenlabel ();\n+\n   /* If the index is erroneous, avoid more problems: pretend to succeed.  */\n   if (index_type == error_mark_node)\n     return 0;\n@@ -3866,27 +3905,6 @@ pushcase (value, converter, label, duplicate)\n   if (value != 0)\n     value = (*converter) (nominal_type, value);\n \n-  /* If this is the first label, warn if any insns have been emitted.  */\n-  if (case_stack->data.case_stmt.seenlabel == 0)\n-    {\n-      rtx insn;\n-      for (insn = case_stack->data.case_stmt.start;\n-\t   insn;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n-\t    break;\n-\t  if (GET_CODE (insn) != NOTE\n-\t      && (GET_CODE (insn) != INSN || GET_CODE (PATTERN (insn)) != USE))\n-\t    {\n-\t      warning (\"unreachable code at beginning of %s\",\n-\t\t       case_stack->data.case_stmt.printname);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  case_stack->data.case_stmt.seenlabel = 1;\n-\n   /* Fail if this value is out of range for the actual type of the index\n      (which may be narrower than NOMINAL_TYPE).  */\n   if (value != 0 && ! int_fits_type_p (value, index_type))\n@@ -3943,26 +3961,7 @@ pushcase_range (value1, value2, converter, label, duplicate)\n   if (index_type == error_mark_node)\n     return 0;\n \n-  /* If this is the first label, warn if any insns have been emitted.  */\n-  if (case_stack->data.case_stmt.seenlabel == 0)\n-    {\n-      rtx insn;\n-      for (insn = case_stack->data.case_stmt.start;\n-\t   insn;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n-\t    break;\n-\t  if (GET_CODE (insn) != NOTE\n-\t      && (GET_CODE (insn) != INSN || GET_CODE (PATTERN (insn)) != USE))\n-\t    {\n-\t      warning (\"unreachable code at beginning of %s\",\n-\t\t       case_stack->data.case_stmt.printname);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  case_stack->data.case_stmt.seenlabel = 1;\n+  check_seenlabel ();\n \n   /* Convert VALUEs to type in which the comparisons are nominally done\n      and replace any unspecified value with the corresponding bound.  */\n@@ -4613,6 +4612,8 @@ expand_end_case (orig_index)\n \n   do_pending_stack_adjust ();\n \n+  check_seenlabel ();\n+\n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n@@ -4625,22 +4626,6 @@ expand_end_case (orig_index)\n \t  && TREE_CODE (index_expr) != INTEGER_CST)\n \tcheck_for_full_enumeration_handling (TREE_TYPE (orig_index));\n \n-      /* If this is the first label, warn if any insns have been emitted.  */\n-      if (thiscase->data.case_stmt.seenlabel == 0)\n-\t{\n-\t  rtx insn;\n-\t  for (insn = get_last_insn ();\n-\t       insn != case_stack->data.case_stmt.start;\n-\t       insn = PREV_INSN (insn))\n-\t    if (GET_CODE (insn) != NOTE\n-\t        && (GET_CODE (insn) != INSN || GET_CODE (PATTERN (insn))!= USE))\n-\t      {\n-\t\twarning (\"unreachable code at beginning of %s\",\n-\t\t\t case_stack->data.case_stmt.printname);\n-\t\tbreak;\n-\t      }\n-\t}\n-\n       /* If we don't have a default-label, create one here,\n \t after the body of the switch.  */\n       if (thiscase->data.case_stmt.default_label == 0)"}]}