{"sha": "4745e70151b781ec1013ea417c9eb627c1cf88a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0NWU3MDE1MWI3ODFlYzEwMTNlYTQxN2M5ZWI2MjdjMWNmODhhMw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-05-16T08:50:51Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-05-16T08:50:51Z"}, "message": "[AArch64 costs 5/18] Factor out common MULT cases\n\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_strip_shift_or_extend): Rename\n\tto...\n\t(aarch64_strip_extend): ...this, don't strip shifts, check RTX is\n\twell formed.\n\t(aarch64_rtx_mult_cost): New.\n\t(aarch64_rtx_costs): Use it, refactor as appropriate.\n\n\nCo-Authored-By: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\n\nFrom-SVN: r210497", "tree": {"sha": "e2ce4d5650b11357850a695b1a3b94fd19c54a12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2ce4d5650b11357850a695b1a3b94fd19c54a12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4745e70151b781ec1013ea417c9eb627c1cf88a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4745e70151b781ec1013ea417c9eb627c1cf88a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4745e70151b781ec1013ea417c9eb627c1cf88a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4745e70151b781ec1013ea417c9eb627c1cf88a3/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dfc162c47a8485b032af6af78e3790940a9d210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfc162c47a8485b032af6af78e3790940a9d210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfc162c47a8485b032af6af78e3790940a9d210"}], "stats": {"total": 374, "additions": 264, "deletions": 110}, "files": [{"sha": "e449380a441106d4374998742c4b71e61723564b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4745e70151b781ec1013ea417c9eb627c1cf88a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4745e70151b781ec1013ea417c9eb627c1cf88a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4745e70151b781ec1013ea417c9eb627c1cf88a3", "patch": "@@ -1,3 +1,13 @@\n+2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_strip_shift_or_extend): Rename\n+\tto...\n+\t(aarch64_strip_extend): ...this, don't strip shifts, check RTX is\n+\twell formed.\n+\t(aarch64_rtx_mult_cost): New.\n+\t(aarch64_rtx_costs): Use it, refactor as appropriate.\n+\n 2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n \t    Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>\n "}, {"sha": "2b6479dc17c855ee518c9964d32f93d42315123b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 254, "deletions": 110, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4745e70151b781ec1013ea417c9eb627c1cf88a3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4745e70151b781ec1013ea417c9eb627c1cf88a3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4745e70151b781ec1013ea417c9eb627c1cf88a3", "patch": "@@ -513,7 +513,7 @@ aarch64_is_long_call_p (rtx sym)\n    represent an expression that matches an extend operation.  The\n    operands represent the paramters from\n \n-   (extract (mult (reg) (mult_imm)) (extract_imm) (const_int 0)).  */\n+   (extract:MODE (mult (reg) (MULT_IMM)) (EXTRACT_IMM) (const_int 0)).  */\n bool\n aarch64_is_extend_from_extract (enum machine_mode mode, rtx mult_imm,\n \t\t\t\trtx extract_imm)\n@@ -4578,18 +4578,19 @@ aarch64_strip_shift (rtx x)\n   return x;\n }\n \n-/* Helper function for rtx cost calculation.  Strip a shift or extend\n+/* Helper function for rtx cost calculation.  Strip an extend\n    expression from X.  Returns the inner operand if successful, or the\n    original expression on failure.  We deal with a number of possible\n    canonicalization variations here.  */\n static rtx\n-aarch64_strip_shift_or_extend (rtx x)\n+aarch64_strip_extend (rtx x)\n {\n   rtx op = x;\n \n   /* Zero and sign extraction of a widened value.  */\n   if ((GET_CODE (op) == ZERO_EXTRACT || GET_CODE (op) == SIGN_EXTRACT)\n       && XEXP (op, 2) == const0_rtx\n+      && GET_CODE (XEXP (op, 0)) == MULT\n       && aarch64_is_extend_from_extract (GET_MODE (op), XEXP (XEXP (op, 0), 1),\n \t\t\t\t\t XEXP (op, 1)))\n     return XEXP (XEXP (op, 0), 0);\n@@ -4618,7 +4619,122 @@ aarch64_strip_shift_or_extend (rtx x)\n   if (op != x)\n     return op;\n \n-  return aarch64_strip_shift (x);\n+  return x;\n+}\n+\n+/* Helper function for rtx cost calculation.  Calculate the cost of\n+   a MULT, which may be part of a multiply-accumulate rtx.  Return\n+   the calculated cost of the expression, recursing manually in to\n+   operands where needed.  */\n+\n+static int\n+aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n+{\n+  rtx op0, op1;\n+  const struct cpu_cost_table *extra_cost\n+    = aarch64_tune_params->insn_extra_cost;\n+  int cost = 0;\n+  bool maybe_fma = (outer == PLUS || outer == MINUS);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  gcc_checking_assert (code == MULT);\n+\n+  op0 = XEXP (x, 0);\n+  op1 = XEXP (x, 1);\n+\n+  if (VECTOR_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n+  /* Integer multiply/fma.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      /* The multiply will be canonicalized as a shift, cost it as such.  */\n+      if (CONST_INT_P (op1)\n+\t  && exact_log2 (INTVAL (op1)) > 0)\n+\t{\n+\t  if (speed)\n+\t    {\n+\t      if (maybe_fma)\n+\t\t/* ADD (shifted register).  */\n+\t\tcost += extra_cost->alu.arith_shift;\n+\t      else\n+\t\t/* LSL (immediate).  */\n+\t\tcost += extra_cost->alu.shift;\n+\t    }\n+\n+\t  cost += rtx_cost (op0, GET_CODE (op0), 0, speed);\n+\n+\t  return cost;\n+\t}\n+\n+      /* Integer multiplies or FMAs have zero/sign extending variants.  */\n+      if ((GET_CODE (op0) == ZERO_EXTEND\n+\t   && GET_CODE (op1) == ZERO_EXTEND)\n+\t  || (GET_CODE (op0) == SIGN_EXTEND\n+\t      && GET_CODE (op1) == SIGN_EXTEND))\n+\t{\n+\t  cost += rtx_cost (XEXP (op0, 0), MULT, 0, speed)\n+\t\t  + rtx_cost (XEXP (op1, 0), MULT, 1, speed);\n+\n+\t  if (speed)\n+\t    {\n+\t      if (maybe_fma)\n+\t\t/* MADD/SMADDL/UMADDL.  */\n+\t\tcost += extra_cost->mult[0].extend_add;\n+\t      else\n+\t\t/* MUL/SMULL/UMULL.  */\n+\t\tcost += extra_cost->mult[0].extend;\n+\t    }\n+\n+\t  return cost;\n+\t}\n+\n+      /* This is either an integer multiply or an FMA.  In both cases\n+\t we want to recurse and cost the operands.  */\n+      cost += rtx_cost (op0, MULT, 0, speed)\n+\t      + rtx_cost (op1, MULT, 1, speed);\n+\n+      if (speed)\n+\t{\n+\t  if (maybe_fma)\n+\t    /* MADD.  */\n+\t    cost += extra_cost->mult[mode == DImode].add;\n+\t  else\n+\t    /* MUL.  */\n+\t    cost += extra_cost->mult[mode == DImode].simple;\n+\t}\n+\n+      return cost;\n+    }\n+  else\n+    {\n+      if (speed)\n+\t{\n+\t  /* Floating-point FMA can also support negations of the\n+\t     operands.  */\n+\t  if (GET_CODE (op0) == NEG)\n+\t    {\n+\t      maybe_fma = true;\n+\t      op0 = XEXP (op0, 0);\n+\t    }\n+\t  if (GET_CODE (op1) == NEG)\n+\t    {\n+\t      maybe_fma = true;\n+\t      op1 = XEXP (op1, 0);\n+\t    }\n+\n+\t  if (maybe_fma)\n+\t    /* FMADD/FNMADD/FNMSUB/FMSUB.  */\n+\t    cost += extra_cost->fp[mode == DFmode].fma;\n+\t  else\n+\t    /* FMUL.  */\n+\t    cost += extra_cost->fp[mode == DFmode].mult;\n+\t}\n+\n+      cost += rtx_cost (op0, MULT, 0, speed)\n+\t      + rtx_cost (op1, MULT, 1, speed);\n+      return cost;\n+    }\n }\n \n static int\n@@ -4830,9 +4946,42 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       return true;\n \n     case NEG:\n-      op0 = CONST0_RTX (GET_MODE (x));\n-      op1 = XEXP (x, 0);\n-      goto cost_minus;\n+      op0 = XEXP (x, 0);\n+\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n+       {\n+          if (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE\n+              || GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMM_COMPARE)\n+            {\n+              /* CSETM.  */\n+              *cost += rtx_cost (XEXP (op0, 0), NEG, 0, speed);\n+              return true;\n+            }\n+\n+\t  /* Cost this as SUB wzr, X.  */\n+          op0 = CONST0_RTX (GET_MODE (x));\n+          op1 = XEXP (x, 0);\n+          goto cost_minus;\n+        }\n+\n+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+        {\n+          /* Support (neg(fma...)) as a single instruction only if\n+             sign of zeros is unimportant.  This matches the decision\n+             making in aarch64.md.  */\n+          if (GET_CODE (op0) == FMA && !HONOR_SIGNED_ZEROS (GET_MODE (op0)))\n+            {\n+\t      /* FNMADD.  */\n+              *cost = rtx_cost (op0, NEG, 0, speed);\n+              return true;\n+            }\n+\t  if (speed)\n+\t    /* FNEG.  */\n+\t    *cost += extra_cost->fp[mode == DFmode].neg;\n+          return false;\n+        }\n+\n+      return false;\n \n     case COMPARE:\n       op0 = XEXP (x, 0);\n@@ -4857,82 +5006,110 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       goto cost_minus;\n \n     case MINUS:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n+      {\n+\top0 = XEXP (x, 0);\n+\top1 = XEXP (x, 1);\n+\n+cost_minus:\n+\t/* Detect valid immediates.  */\n+\tif ((GET_MODE_CLASS (mode) == MODE_INT\n+\t     || (GET_MODE_CLASS (mode) == MODE_CC\n+\t\t && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT))\n+\t    && CONST_INT_P (op1)\n+\t    && aarch64_uimm12_shift (INTVAL (op1)))\n+\t  {\n+\t    *cost += rtx_cost (op0, MINUS, 0, speed);\n \n-    cost_minus:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n-\t  || (GET_MODE_CLASS (GET_MODE (x)) == MODE_CC\n-\t      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT))\n-\t{\n-\t  if (op0 != const0_rtx)\n+\t    if (speed)\n+\t      /* SUB(S) (immediate).  */\n+\t      *cost += extra_cost->alu.arith;\n+\t    return true;\n+\n+\t  }\n+\n+\trtx new_op1 = aarch64_strip_extend (op1);\n+\n+\t/* Cost this as an FMA-alike operation.  */\n+\tif ((GET_CODE (new_op1) == MULT\n+\t     || GET_CODE (new_op1) == ASHIFT)\n+\t    && code != COMPARE)\n+\t  {\n+\t    *cost += aarch64_rtx_mult_cost (new_op1, MULT,\n+\t\t\t\t\t    (enum rtx_code) code,\n+\t\t\t\t\t    speed);\n \t    *cost += rtx_cost (op0, MINUS, 0, speed);\n+\t    return true;\n+\t  }\n \n-\t  if (CONST_INT_P (op1))\n-\t    {\n-\t      if (!aarch64_uimm12_shift (INTVAL (op1)))\n-\t\t*cost += rtx_cost (op1, MINUS, 1, speed);\n-\t    }\n-\t  else\n-\t    {\n-\t      op1 = aarch64_strip_shift_or_extend (op1);\n-\t      *cost += rtx_cost (op1, MINUS, 1, speed);\n-\t    }\n-\t  return true;\n-\t}\n+\t*cost += rtx_cost (new_op1, MINUS, 1, speed);\n \n-      return false;\n+\tif (speed)\n+\t  {\n+\t    if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t      /* SUB(S).  */\n+\t      *cost += extra_cost->alu.arith;\n+\t    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t      /* FSUB.  */\n+\t      *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t  }\n+\treturn true;\n+      }\n \n     case PLUS:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n+      {\n+\trtx new_op0;\n \n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t{\n-\t  if (CONST_INT_P (op1) && aarch64_uimm12_shift (INTVAL (op1)))\n-\t    {\n-\t      *cost += rtx_cost (op0, PLUS, 0, speed);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx new_op0 = aarch64_strip_shift_or_extend (op0);\n+\top0 = XEXP (x, 0);\n+\top1 = XEXP (x, 1);\n \n-\t      if (new_op0 == op0\n-\t\t  && GET_CODE (op0) == MULT)\n-\t\t{\n-\t\t  if ((GET_CODE (XEXP (op0, 0)) == ZERO_EXTEND\n-\t\t       && GET_CODE (XEXP (op0, 1)) == ZERO_EXTEND)\n-\t\t      || (GET_CODE (XEXP (op0, 0)) == SIGN_EXTEND\n-\t\t\t  && GET_CODE (XEXP (op0, 1)) == SIGN_EXTEND))\n-\t\t    {\n-\t\t      *cost += (rtx_cost (XEXP (XEXP (op0, 0), 0), MULT, 0,\n-\t\t\t\t\t  speed)\n-\t\t\t\t+ rtx_cost (XEXP (XEXP (op0, 1), 0), MULT, 1,\n-\t\t\t\t\t    speed)\n-\t\t\t\t+ rtx_cost (op1, PLUS, 1, speed));\n-\t\t      if (speed)\n-\t\t\t*cost +=\n-\t\t\t  extra_cost->mult[GET_MODE (x) == DImode].extend_add;\n-\t\t      return true;\n-\t\t    }\n-\n-\t\t  *cost += (rtx_cost (XEXP (op0, 0), MULT, 0, speed)\n-\t\t\t    + rtx_cost (XEXP (op0, 1), MULT, 1, speed)\n-\t\t\t    + rtx_cost (op1, PLUS, 1, speed));\n-\n-\t\t  if (speed)\n-\t\t    *cost += extra_cost->mult[GET_MODE (x) == DImode].add;\n-\n-\t\t  return true;\n-\t\t}\n+\tif (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE\n+\t    || GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMM_COMPARE)\n+\t  {\n+\t    /* CSINC.  */\n+\t    *cost += rtx_cost (XEXP (op0, 0), PLUS, 0, speed);\n+\t    *cost += rtx_cost (op1, PLUS, 1, speed);\n+\t    return true;\n+\t  }\n \n-\t      *cost += (rtx_cost (new_op0, PLUS, 0, speed)\n-\t\t\t+ rtx_cost (op1, PLUS, 1, speed));\n-\t    }\n-\t  return true;\n-\t}\n+\tif (GET_MODE_CLASS (mode) == MODE_INT\n+\t    && CONST_INT_P (op1)\n+\t    && aarch64_uimm12_shift (INTVAL (op1)))\n+\t  {\n+\t    *cost += rtx_cost (op0, PLUS, 0, speed);\n \n-      return false;\n+\t    if (speed)\n+\t      /* ADD (immediate).  */\n+\t      *cost += extra_cost->alu.arith;\n+\t    return true;\n+\t  }\n+\n+\t/* Strip any extend, leave shifts behind as we will\n+\t   cost them through mult_cost.  */\n+\tnew_op0 = aarch64_strip_extend (op0);\n+\n+\tif (GET_CODE (new_op0) == MULT\n+\t    || GET_CODE (new_op0) == ASHIFT)\n+\t  {\n+\t    *cost += aarch64_rtx_mult_cost (new_op0, MULT, PLUS,\n+\t\t\t\t\t    speed);\n+\t    *cost += rtx_cost (op1, PLUS, 1, speed);\n+\t    return true;\n+\t  }\n+\n+\t*cost += (rtx_cost (new_op0, PLUS, 0, speed)\n+\t\t  + rtx_cost (op1, PLUS, 1, speed));\n+\n+\tif (speed)\n+\t  {\n+\t    if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t      /* ADD.  */\n+\t      *cost += extra_cost->alu.arith;\n+\t    else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t      /* FADD.  */\n+\t      *cost += extra_cost->fp[mode == DFmode].addsub;\n+\t  }\n+\treturn true;\n+      }\n \n     case BSWAP:\n       *cost = COSTS_N_INSNS (1);\n@@ -5029,43 +5206,10 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n       return true;\n \n     case MULT:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n-\n-      *cost = COSTS_N_INSNS (1);\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t{\n-\t  if (CONST_INT_P (op1)\n-\t      && exact_log2 (INTVAL (op1)) > 0)\n-\t    {\n-\t      *cost += rtx_cost (op0, ASHIFT, 0, speed);\n-\t      return true;\n-\t    }\n-\n-\t  if ((GET_CODE (op0) == ZERO_EXTEND\n-\t       && GET_CODE (op1) == ZERO_EXTEND)\n-\t      || (GET_CODE (op0) == SIGN_EXTEND\n-\t\t  && GET_CODE (op1) == SIGN_EXTEND))\n-\t    {\n-\t      *cost += (rtx_cost (XEXP (op0, 0), MULT, 0, speed)\n-\t\t\t+ rtx_cost (XEXP (op1, 0), MULT, 1, speed));\n-\t      if (speed)\n-\t\t*cost += extra_cost->mult[GET_MODE (x) == DImode].extend;\n-\t      return true;\n-\t    }\n-\n-\t  if (speed)\n-\t    *cost += extra_cost->mult[GET_MODE (x) == DImode].simple;\n-\t}\n-      else if (speed)\n-\t{\n-\t  if (GET_MODE (x) == DFmode)\n-\t    *cost += extra_cost->fp[1].mult;\n-\t  else if (GET_MODE (x) == SFmode)\n-\t    *cost += extra_cost->fp[0].mult;\n-\t}\n-\n-      return false;  /* All arguments need to be in registers.  */\n+      *cost += aarch64_rtx_mult_cost (x, MULT, 0, speed);\n+      /* aarch64_rtx_mult_cost always handles recursion to its\n+\t operands.  */\n+      return true;\n \n     case MOD:\n     case UMOD:"}]}