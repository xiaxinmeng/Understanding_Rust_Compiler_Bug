{"sha": "3a391adf7a38780f8d01dbac08a2a143fc80b469", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EzOTFhZGY3YTM4NzgwZjhkMDFkYmFjMDhhMmExNDNmYzgwYjQ2OQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-06-10T16:48:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-10T16:48:56Z"}, "message": "libstdc++: Extend memcmp optimization in std::lexicographical_compare\n\nMake the memcmp optimization work for std::deque iterators and safe\niterators.\n\nCo-authored-by: Jonathan Wakely  <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n2020-06-08  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\t* include/bits/deque.tcc (__lex_cmp_dit): New.\n\t(__lexicographical_compare_aux1): Define overloads for deque\n\titerators.\n\t* include/bits/stl_algobase.h (__lexicographical_compare::__3way):\n\tNew static member function.\n\t(__lexicographical_compare<true>::__3way): Likewise.\n\t(__lexicographical_compare<true>::__lc): Use __3way.\n\t(__lexicographical_compare_aux): Rename to\n\t__lexicographical_compare_aux1 and declare overloads for deque\n\titerators.\n\t(__lexicographical_compare_aux): Define new forwarding function\n\tthat calls __lexicographical_compare_aux1 and declare new overloads\n\tfor safe iterators.\n\t(lexicographical_compare): Do not use __niter_base on\n\tparameters.\n\t* include/debug/safe_iterator.tcc\n\t(__lexicographical_compare_aux): Define overloads for safe\n\titerators.\n\t* testsuite/25_algorithms/lexicographical_compare/1.cc: Add\n\tchecks with random access iterators.\n\t* testsuite/25_algorithms/lexicographical_compare/deque_iterators/1.cc:\n\tNew test.", "tree": {"sha": "23d1707474fbf0426ded120821c4cb65276c0824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23d1707474fbf0426ded120821c4cb65276c0824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a391adf7a38780f8d01dbac08a2a143fc80b469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a391adf7a38780f8d01dbac08a2a143fc80b469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a391adf7a38780f8d01dbac08a2a143fc80b469", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a391adf7a38780f8d01dbac08a2a143fc80b469/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "371cc683371bedb0e53ebcee0c0e89604a1e74b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/371cc683371bedb0e53ebcee0c0e89604a1e74b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/371cc683371bedb0e53ebcee0c0e89604a1e74b1"}], "stats": {"total": 624, "additions": 606, "deletions": 18}, "files": [{"sha": "7d1ec86456abcb70374870f2bcb71b888ad3e582", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=3a391adf7a38780f8d01dbac08a2a143fc80b469", "patch": "@@ -1261,6 +1261,109 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n       return true;\n     }\n \n+  template<typename _Tp1, typename _Ref, typename _Ptr, typename _Tp2>\n+    int\n+    __lex_cmp_dit(\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref, _Ptr> __first1,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref, _Ptr> __last1,\n+\tconst _Tp2* __first2, const _Tp2* __last2)\n+    {\n+      const bool __simple =\n+\t(__is_byte<_Tp1>::__value && __is_byte<_Tp2>::__value\n+\t && !__gnu_cxx::__numeric_traits<_Tp1>::__is_signed\n+\t && !__gnu_cxx::__numeric_traits<_Tp2>::__is_signed\n+\t && __is_pointer<_Ptr>::__value\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+\t // For C++20 iterator_traits<volatile T*>::value_type is non-volatile\n+\t // so __is_byte<T> could be true, but we can't use memcmp with\n+\t // volatile data.\n+\t && !is_volatile_v<_Tp1>\n+\t && !is_volatile_v<_Tp2>\n+#endif\n+\t );\n+      typedef std::__lexicographical_compare<__simple> _Lc;\n+\n+      while (__first1._M_node != __last1._M_node)\n+\t{\n+\t  const ptrdiff_t __len1 = __first1._M_last - __first1._M_cur;\n+\t  const ptrdiff_t __len2 = __last2 - __first2;\n+\t  const ptrdiff_t __len = std::min(__len1, __len2);\n+\t  // if __len1 > __len2 this will return a positive value:\n+\t  if (int __ret = _Lc::__3way(__first1._M_cur, __first1._M_last,\n+\t\t\t\t      __first2, __first2 + __len))\n+\t    return __ret;\n+\n+\t  __first1 += __len;\n+\t  __first2 += __len;\n+\t}\n+      return _Lc::__3way(__first1._M_cur, __last1._M_cur,\n+\t\t\t __first2, __last2);\n+    }\n+\n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2>\n+    inline bool\n+    __lexicographical_compare_aux1(\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __first1,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __last1,\n+\t_Tp2* __first2, _Tp2* __last2)\n+    { return std::__lex_cmp_dit(__first1, __last1, __first2, __last2) < 0; }\n+\n+  template<typename _Tp1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    inline  bool\n+    __lexicographical_compare_aux1(_Tp1* __first1, _Tp1* __last1,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __first2,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __last2)\n+    { return std::__lex_cmp_dit(__first2, __last2, __first1, __last1) > 0; }\n+\n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    inline bool\n+    __lexicographical_compare_aux1(\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __first1,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __last1,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __first2,\n+\t\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __last2)\n+    {\n+      const bool __simple =\n+\t(__is_byte<_Tp1>::__value && __is_byte<_Tp2>::__value\n+\t && !__gnu_cxx::__numeric_traits<_Tp1>::__is_signed\n+\t && !__gnu_cxx::__numeric_traits<_Tp2>::__is_signed\n+\t && __is_pointer<_Ptr1>::__value\n+\t && __is_pointer<_Ptr2>::__value\n+#if __cplusplus > 201703L && __cpp_lib_concepts\n+\t // For C++20 iterator_traits<volatile T*>::value_type is non-volatile\n+\t // so __is_byte<T> could be true, but we can't use memcmp with\n+\t // volatile data.\n+\t && !is_volatile_v<_Tp1>\n+\t && !is_volatile_v<_Tp2>\n+#endif\n+\t );\n+      typedef std::__lexicographical_compare<__simple> _Lc;\n+\n+      while (__first1 != __last1)\n+\t{\n+\t  const ptrdiff_t __len2 = __first2._M_node == __last2._M_node\n+\t    ? __last2._M_cur - __first2._M_cur\n+\t    : __first2._M_last - __first2._M_cur;\n+\t  if (__len2 == 0)\n+\t    return false;\n+\t  const ptrdiff_t __len1 = __first1._M_node == __last1._M_node\n+\t    ? __last1._M_cur - __first1._M_cur\n+\t    : __first1._M_last - __first1._M_cur;\n+\t  const ptrdiff_t __len = std::min(__len1, __len2);\n+\t  if (int __ret = _Lc::__3way(__first1._M_cur, __first1._M_cur + __len,\n+\t\t\t\t      __first2._M_cur, __first2._M_cur + __len))\n+\t    return __ret < 0;\n+\n+\t  __first1 += __len;\n+\t  __first2 += __len;\n+\t}\n+\n+      return __last2 != __first2;\n+    }\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "41dd740d34a644bfb5c900d2d940cb003cbeba98", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 93, "deletions": 8, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=3a391adf7a38780f8d01dbac08a2a143fc80b469", "patch": "@@ -1313,6 +1313,25 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \t\t\t\t\t\t     __first2, __last2,\n \t\t\t\t\t\t     __iter_less_iter());\n \t}\n+\n+      template<typename _II1, typename _II2>\n+\t_GLIBCXX20_CONSTEXPR\n+\tstatic int\n+\t__3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+\t{\n+\t  while (__first1 != __last1)\n+\t    {\n+\t      if (__first2 == __last2)\n+\t\treturn +1;\n+\t      if (*__first1 < *__first2)\n+\t\treturn -1;\n+\t      if (*__first2 < *__first1)\n+\t\treturn +1;\n+\t      ++__first1;\n+\t      ++__first2;\n+\t    }\n+\t  return int(__first2 == __last2) - 1;\n+\t}\n     };\n \n   template<>\n@@ -1323,21 +1342,28 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \tstatic bool\n \t__lc(const _Tp* __first1, const _Tp* __last1,\n \t     const _Up* __first2, const _Up* __last2)\n+\t{ return __3way(__first1, __last1, __first2, __last2) < 0; }\n+\n+      template<typename _Tp, typename _Up>\n+\t_GLIBCXX20_CONSTEXPR\n+\tstatic ptrdiff_t\n+\t__3way(const _Tp* __first1, const _Tp* __last1,\n+\t       const _Up* __first2, const _Up* __last2)\n \t{\n \t  const size_t __len1 = __last1 - __first1;\n \t  const size_t __len2 = __last2 - __first2;\n \t  if (const size_t __len = std::min(__len1, __len2))\n \t    if (int __result = std::__memcmp(__first1, __first2, __len))\n-\t      return __result < 0;\n-\t  return __len1 < __len2;\n+\t      return __result;\n+\t  return ptrdiff_t(__len1 - __len2);\n \t}\n     };\n \n   template<typename _II1, typename _II2>\n     _GLIBCXX20_CONSTEXPR\n     inline bool\n-    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,\n-\t\t\t\t  _II2 __first2, _II2 __last2)\n+    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,\n+\t\t\t\t   _II2 __first2, _II2 __last2)\n     {\n       typedef typename iterator_traits<_II1>::value_type _ValueType1;\n       typedef typename iterator_traits<_II2>::value_type _ValueType2;\n@@ -1360,6 +1386,67 @@ _GLIBCXX_END_NAMESPACE_CONTAINER\n \t\t\t\t\t\t\t    __first2, __last2);\n     }\n \n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2>\n+    bool\n+    __lexicographical_compare_aux1(\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t_Tp2*, _Tp2*);\n+\n+  template<typename _Tp1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    bool\n+    __lexicographical_compare_aux1(_Tp1*, _Tp1*,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n+\n+  template<typename _Tp1, typename _Ref1, typename _Ptr1,\n+\t   typename _Tp2, typename _Ref2, typename _Ptr2>\n+    bool\n+    __lexicographical_compare_aux1(\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,\n+\t_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);\n+\n+  template<typename _II1, typename _II2>\n+    _GLIBCXX20_CONSTEXPR\n+    inline bool\n+    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,\n+\t\t\t\t  _II2 __first2, _II2 __last2)\n+    {\n+      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),\n+\t\t\t\t\t\t std::__niter_base(__last1),\n+\t\t\t\t\t\t std::__niter_base(__first2),\n+\t\t\t\t\t\t std::__niter_base(__last2));\n+    }\n+\n+  template<typename _Iter1, typename _Seq1, typename _Cat1,\n+\t   typename _II2>\n+    bool\n+    __lexicographical_compare_aux(\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n+\t\t_II2, _II2);\n+\n+  template<typename _II1,\n+\t   typename _Iter2, typename _Seq2, typename _Cat2>\n+    bool\n+    __lexicographical_compare_aux(\n+\t\t_II1, _II1,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);\n+\n+  template<typename _Iter1, typename _Seq1, typename _Cat1,\n+\t   typename _Iter2, typename _Seq2, typename _Cat2>\n+    bool\n+    __lexicographical_compare_aux(\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,\n+\t\tconst ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);\n+\n   template<typename _ForwardIterator, typename _Tp, typename _Compare>\n     _GLIBCXX20_CONSTEXPR\n     _ForwardIterator\n@@ -1659,10 +1746,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      return std::__lexicographical_compare_aux(std::__niter_base(__first1),\n-\t\t\t\t\t\tstd::__niter_base(__last1),\n-\t\t\t\t\t\tstd::__niter_base(__first2),\n-\t\t\t\t\t\tstd::__niter_base(__last2));\n+      return std::__lexicographical_compare_aux(__first1, __last1,\n+\t\t\t\t\t\t__first2, __last2);\n     }\n \n   /**"}, {"sha": "f694e5142399c8925e4bb0e0f8f31784d7de9636", "filename": "libstdc++-v3/include/debug/safe_iterator.tcc", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc?ref=3a391adf7a38780f8d01dbac08a2a143fc80b469", "patch": "@@ -470,6 +470,80 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __equal_aux1(__first1, __last1, __first2);\n     }\n \n+  template<typename _Ite1, typename _Seq1, typename _Cat1,\n+\t   typename _II2>\n+    bool\n+    __lexicographical_compare_aux(\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite1, _Seq1, _Cat1>& __first1,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite1, _Seq1, _Cat1>& __last1,\n+\t_II2 __first2, _II2 __last2)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_Ite1>::__type __dist1;\n+      __glibcxx_check_valid_range2(__first1, __last1, __dist1);\n+      __glibcxx_check_valid_range(__first2, __last2);\n+\n+      if (__dist1.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__lexicographical_compare_aux(__first1.base(),\n+\t\t\t\t\t\t  __last1.base(),\n+\t\t\t\t\t\t  __first2, __last2);\n+      return std::__lexicographical_compare_aux1(__first1, __last1,\n+\t\t\t\t\t\t __first2, __last2);\n+    }\n+\n+  template<typename _II1,\n+\t   typename _Ite2, typename _Seq2, typename _Cat2>\n+    bool\n+    __lexicographical_compare_aux(\n+\t_II1 __first1, _II1 __last1,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite2, _Seq2, _Cat2>& __first2,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite2, _Seq2, _Cat2>& __last2)\n+    {\n+      __glibcxx_check_valid_range(__first1, __last1);\n+      typename ::__gnu_debug::_Distance_traits<_II1>::__type __dist2;\n+      __glibcxx_check_valid_range2(__first2, __last2, __dist2);\n+\n+      if (__dist2.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__lexicographical_compare_aux(__first1, __last1,\n+\t\t\t\t\t\t  __first2.base(),\n+\t\t\t\t\t\t  __last2.base());\n+      return std::__lexicographical_compare_aux1(__first1, __last1,\n+\t\t\t\t\t\t __first2, __last2);\n+    }\n+\n+  template<typename _Ite1, typename _Seq1, typename _Cat1,\n+\t   typename _Ite2, typename _Seq2, typename _Cat2>\n+    bool\n+    __lexicographical_compare_aux(\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite1, _Seq1, _Cat1>& __first1,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite1, _Seq1, _Cat1>& __last1,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite2, _Seq2, _Cat2>& __first2,\n+\tconst ::__gnu_debug::_Safe_iterator<_Ite2, _Seq2, _Cat2>& __last2)\n+    {\n+      typename ::__gnu_debug::_Distance_traits<_Ite1>::__type __dist1;\n+      __glibcxx_check_valid_range2(__first1, __last1, __dist1);\n+      typename ::__gnu_debug::_Distance_traits<_Ite2>::__type __dist2;\n+      __glibcxx_check_valid_range2(__first2, __last2, __dist2);\n+\n+      if (__dist1.second > ::__gnu_debug::__dp_equality)\n+\t{\n+\t  if (__dist2.second > ::__gnu_debug::__dp_equality)\n+\t    return std::__lexicographical_compare_aux(__first1.base(),\n+\t\t\t\t\t\t      __last1.base(),\n+\t\t\t\t\t\t      __first2.base(),\n+\t\t\t\t\t\t      __last2.base());\n+\t  return std::__lexicographical_compare_aux(__first1.base(),\n+\t\t\t\t\t\t    __last1.base(),\n+\t\t\t\t\t\t    __first2, __last2);\n+\t}\n+\n+      if (__dist2.second > ::__gnu_debug::__dp_equality)\n+\treturn std::__lexicographical_compare_aux(__first1, __last1,\n+\t\t\t\t\t\t  __first2.base(),\n+\t\t\t\t\t\t  __last2.base());\n+      return std::__lexicographical_compare_aux1(__first1, __last1,\n+\t\t\t\t\t\t __first2, __last2);\n+    }\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "9bbc83b7af06fd14ed9c347bdacbd4f1ba370d28", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/1.cc", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F1.cc?ref=3a391adf7a38780f8d01dbac08a2a143fc80b469", "patch": "@@ -29,43 +29,43 @@ int array1[] = {0, 1};\n int array2[] = {1, 0};\n int array3[] = {1, 0, 1};\n \n-void \n+void\n test1()\n {\n   Container con1(array1, array1);\n   Container con2(array2, array2);\n-  VERIFY( !std::lexicographical_compare(con1.begin(), con1.end(), \n+  VERIFY( !std::lexicographical_compare(con1.begin(), con1.end(),\n \t\t\t\t\tcon2.begin(), con2.end()) );\n }\n \n-void \n+void\n test2()\n {\n   Container con1(array1, array1 + 2);\n   Container con2(array2, array2 + 2);\n-  VERIFY( std::lexicographical_compare(con1.begin(), con1.end(), \n+  VERIFY( std::lexicographical_compare(con1.begin(), con1.end(),\n \t\t\t\t       con2.begin(), con2.end()) );\n }\n \n-void \n+void\n test3()\n {\n   Container con1(array1, array1 + 2);\n   Container con2(array2, array2 + 2);\n-  VERIFY( !std::lexicographical_compare(con2.begin(), con2.end(), \n+  VERIFY( !std::lexicographical_compare(con2.begin(), con2.end(),\n \t\t\t\t        con1.begin(), con1.end()) );\n }\n \n-void \n+void\n test4()\n {\n   Container con3(array3, array3 + 3);\n   Container con2(array2, array2 + 2);\n-  VERIFY( std::lexicographical_compare(con2.begin(), con2.end(), \n+  VERIFY( std::lexicographical_compare(con2.begin(), con2.end(),\n \t\t\t\t       con3.begin(), con3.end()) );\n }\n \n-void \n+void\n test5()\n {\n   Container con3(array3, array3 + 3);\n@@ -74,12 +74,37 @@ test5()\n \t\t\t\t\tcon2.begin(), con2.end()) );\n }\n \n-int \n+void\n+test6()\n+{\n+  VERIFY( std::lexicographical_compare(array2, array2 + 2,\n+\t\t\t\t       array3, array3 + 3) );\n+  VERIFY( !std::lexicographical_compare(array3, array3 + 3,\n+\t\t\t\t\tarray2, array2 + 2) );\n+}\n+\n+using __gnu_test::random_access_iterator_wrapper;\n+typedef test_container<int, random_access_iterator_wrapper> RaiContainer;\n+\n+void\n+test7()\n+{\n+  RaiContainer con2(array2, array2 + 2);\n+  RaiContainer con3(array3, array3 + 3);\n+  VERIFY( std::lexicographical_compare(con2.begin(), con2.end(),\n+\t\t\t\t       con3.begin(), con3.end()) );\n+  VERIFY( !std::lexicographical_compare(con3.begin(), con3.end(),\n+\t\t\t\t\tcon2.begin(), con2.end()) );\n+}\n+\n+int\n main()\n {\n   test1();\n   test2();\n   test3();\n   test4();\n   test5();\n+  test6();\n+  test7();\n }"}, {"sha": "14a75358db4681ccbc27624c82f1335543c43179", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/deque_iterators/1.cc", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fdeque_iterators%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a391adf7a38780f8d01dbac08a2a143fc80b469/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fdeque_iterators%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2Fdeque_iterators%2F1.cc?ref=3a391adf7a38780f8d01dbac08a2a143fc80b469", "patch": "@@ -0,0 +1,301 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <deque>\n+\n+#include <ext/new_allocator.h>\n+#include <ext/malloc_allocator.h>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), cd.begin(), cd.end()) );\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), d.begin(), d.end()) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.end(), d.begin(), d.end()) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.end(), cd.begin(), cd.end()) );\n+\n+  const deque<int>::iterator first = d.begin(), last = d.end();\n+  VERIFY( lexicographical_compare(first, last - 1, first, last) );\n+  VERIFY( !lexicographical_compare(first, last, first, last - 1) );\n+  VERIFY( lexicographical_compare(first, last, first + 1, last) );\n+  VERIFY( !lexicographical_compare(first + 1, last, first, last) );\n+}\n+\n+void test02()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 1000; ++i)\n+    d.push_back(i % 10);\n+\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 21, d.begin() + 31) );\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 20, d.begin() + 31) );\n+  VERIFY( ! lexicographical_compare(d.begin() + 1, d.begin() + 10,\n+\t\t\t\t    d.begin() + 21, d.begin() + 30) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t   d.begin() + 20, d.begin() + 30) );\n+  VERIFY( !lexicographical_compare(d.begin() + 1, d.begin() + 10,\n+\t\t\t\t   d.begin() + 1 + 20, d.begin() + 30) );\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 20, d.begin() + 31) );\n+  VERIFY( !lexicographical_compare(d.begin() + 10, d.end() - 10,\n+\t\t\t\t   d.begin(), d.end() - 20) );\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( lexicographical_compare(cd.begin(), cd.begin() + 10,\n+\t\t\t\t  cd.begin() + 21, cd.begin() + 31) );\n+  VERIFY( lexicographical_compare(cd.begin() + 1, cd.begin() + 10,\n+\t\t\t\t  cd.begin() + 21, cd.begin() + 32) );\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.begin() + 10,\n+\t\t\t\t   cd.begin() + 20, cd.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd.begin() + 1, cd.begin() + 10,\n+\t\t\t\t   cd.begin() + 21, cd.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd.begin() + 10, cd.end() - 10,\n+\t\t\t\t   d.begin(), d.end() - 20) );\n+  VERIFY( !lexicographical_compare(d.begin() + 10, d.end() - 10,\n+\t\t\t\t   cd.begin(), cd.end() - 20) );\n+}\n+\n+void test03()\n+{\n+  using namespace std;\n+\n+  deque<int> d1;\n+  for (int i = 0; i != 1000; ++i)\n+    d1.push_back(i % 10);\n+\n+  deque<int> d2(d1);\n+  for (int i = 0; i != 10; ++i)\n+    d2.pop_front();\n+\n+  VERIFY( !lexicographical_compare(d1.begin(), d1.begin() + 10,\n+\t\t\t\t   d2.begin(), d2.begin() + 10) );\n+  VERIFY( !lexicographical_compare(d1.begin() + 10, d1.end() - 10,\n+\t\t\t\t   d2.begin(), d2.end() - 10) );\n+\n+  const deque<int>& cd1 = d1;\n+  const deque<int>& cd2 = d2;\n+\n+  VERIFY( !lexicographical_compare(cd1.begin(), cd1.begin() + 10,\n+\t\t\t\t   cd2.begin() + 20, cd2.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd1.begin() + 10, cd1.end() - 10,\n+\t\t\t\t   d2.begin(), d2.end() - 10) );\n+  VERIFY( lexicographical_compare(cd2.begin() + 10, cd2.end() - 10,\n+\t\t\t\t  cd1.begin(), cd1.end() - 20) );\n+}\n+\n+void test04()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  vector<int> v(d.begin(), d.end());\n+\n+  VERIFY( lexicographical_compare(d.begin() + 5, d.end() - 1, v.begin() + 5, v.end()) );\n+  VERIFY( !lexicographical_compare(v.begin(), v.end(), d.begin(), d.end()) );\n+\n+  const deque<int>& cd = d;\n+\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), v.begin(), v.end()) );\n+  VERIFY( !lexicographical_compare(v.begin(), v.end(), cd.begin(), cd.end()) );\n+}\n+\n+void test05()\n+{\n+  using namespace std;\n+\n+  int a[] = { 0, 1, 2, 3, 4 };\n+  deque<int, __gnu_cxx::new_allocator<int> > d1(a, a + 5);\n+  deque<int, __gnu_cxx::malloc_allocator<int> > d2(a, a + 5);\n+\n+  VERIFY( !lexicographical_compare(d1.begin(), d1.end(), d2.begin(), d2.end()) );\n+}\n+\n+void\n+test06()\n+{\n+  using namespace std;\n+\n+  deque<int> d;\n+  int i = 0;\n+  VERIFY( lexicographical_compare(d.begin(), d.end(), &i, &i + 1) );\n+  VERIFY( !lexicographical_compare(&i, &i + 1, d.begin(), d.end()) );\n+}\n+\n+void test07()\n+{\n+  using namespace std;\n+\n+  deque<unsigned char> d;\n+  for (int i = 0; i != _GLIBCXX_STD_C::__deque_buf_size(sizeof(int)); ++i)\n+    d.push_back(i);\n+\n+  const deque<unsigned char>& cd = d;\n+\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), cd.begin(), cd.end()) );\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), d.begin(), d.end()) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.end(), d.begin(), d.end()) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.end(), cd.begin(), cd.end()) );\n+\n+  const deque<unsigned char>::iterator first = d.begin(), last = d.end();\n+  VERIFY( lexicographical_compare(first, last - 1, first, last) );\n+  VERIFY( !lexicographical_compare(first, last, first, last - 1) );\n+  VERIFY( lexicographical_compare(first, last, first + 1, last) );\n+  VERIFY( !lexicographical_compare(first + 1, last, first, last) );\n+}\n+\n+void test08()\n+{\n+  using namespace std;\n+\n+  deque<unsigned char> d;\n+  for (int i = 0; i != 1000; ++i)\n+    d.push_back(i % 10);\n+\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 21, d.begin() + 31) );\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 20, d.begin() + 31) );\n+  VERIFY( ! lexicographical_compare(d.begin() + 1, d.begin() + 10,\n+\t\t\t\t    d.begin() + 21, d.begin() + 30) );\n+  VERIFY( !lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t   d.begin() + 20, d.begin() + 30) );\n+  VERIFY( !lexicographical_compare(d.begin() + 1, d.begin() + 10,\n+\t\t\t\t   d.begin() + 1 + 20, d.begin() + 30) );\n+  VERIFY( lexicographical_compare(d.begin(), d.begin() + 10,\n+\t\t\t\t  d.begin() + 20, d.begin() + 31) );\n+  VERIFY( !lexicographical_compare(d.begin() + 10, d.end() - 10,\n+\t\t\t\t   d.begin(), d.end() - 20) );\n+\n+  const deque<unsigned char>& cd = d;\n+\n+  VERIFY( lexicographical_compare(cd.begin(), cd.begin() + 10,\n+\t\t\t\t  cd.begin() + 21, cd.begin() + 31) );\n+  VERIFY( lexicographical_compare(cd.begin() + 1, cd.begin() + 10,\n+\t\t\t\t  cd.begin() + 21, cd.begin() + 32) );\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.begin() + 10,\n+\t\t\t\t   cd.begin() + 20, cd.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd.begin() + 1, cd.begin() + 10,\n+\t\t\t\t   cd.begin() + 21, cd.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd.begin() + 10, cd.end() - 10,\n+\t\t\t\t   d.begin(), d.end() - 20) );\n+  VERIFY( !lexicographical_compare(d.begin() + 10, d.end() - 10,\n+\t\t\t\t   cd.begin(), cd.end() - 20) );\n+}\n+\n+void test09()\n+{\n+  using namespace std;\n+\n+  deque<unsigned char> d1;\n+  for (int i = 0; i != 1000; ++i)\n+    d1.push_back(i % 10);\n+\n+  deque<unsigned char> d2(d1);\n+  for (int i = 0; i != 10; ++i)\n+    d2.pop_front();\n+\n+  VERIFY( !lexicographical_compare(d1.begin(), d1.begin() + 10,\n+\t\t\t\t   d2.begin(), d2.begin() + 10) );\n+  VERIFY( !lexicographical_compare(d1.begin() + 10, d1.end() - 10,\n+\t\t\t\t   d2.begin(), d2.end() - 10) );\n+\n+  const deque<unsigned char>& cd1 = d1;\n+  const deque<unsigned char>& cd2 = d2;\n+\n+  VERIFY( !lexicographical_compare(cd1.begin(), cd1.begin() + 10,\n+\t\t\t\t   cd2.begin() + 20, cd2.begin() + 30) );\n+  VERIFY( !lexicographical_compare(cd1.begin() + 10, cd1.end() - 10,\n+\t\t\t\t   d2.begin(), d2.end() - 10) );\n+  VERIFY( lexicographical_compare(cd2.begin() + 10, cd2.end() - 10,\n+\t\t\t\t  cd1.begin(), cd1.end() - 20) );\n+}\n+\n+void test10()\n+{\n+  using namespace std;\n+\n+  deque<unsigned char> d;\n+  for (int i = 0; i != 1024; ++i)\n+    d.push_back(i);\n+\n+  vector<unsigned char> v(d.begin(), d.end());\n+\n+  VERIFY( lexicographical_compare(d.begin() + 5, d.end() - 1, v.begin() + 5, v.end()) );\n+  VERIFY( !lexicographical_compare(v.begin(), v.end(), d.begin(), d.end()) );\n+\n+  const deque<unsigned char>& cd = d;\n+\n+  VERIFY( !lexicographical_compare(cd.begin(), cd.end(), v.begin(), v.end()) );\n+  VERIFY( !lexicographical_compare(v.begin(), v.end(), cd.begin(), cd.end()) );\n+}\n+\n+void test11()\n+{\n+  using namespace std;\n+\n+  int a[] = { 0, 1, 2, 3, 4 };\n+  deque<unsigned char, __gnu_cxx::new_allocator<unsigned char> > d1(a, a + 5);\n+  deque<unsigned char, __gnu_cxx::malloc_allocator<unsigned char> > d2(a, a + 5);\n+\n+  VERIFY( !lexicographical_compare(d1.begin(), d1.end(), d2.begin(), d2.end()) );\n+}\n+\n+void\n+test12()\n+{\n+  using namespace std;\n+\n+  deque<unsigned char> d;\n+  int i = 0;\n+  VERIFY( lexicographical_compare(d.begin(), d.end(), &i, &i + 1) );\n+  VERIFY( !lexicographical_compare(&i, &i + 1, d.begin(), d.end()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+  test10();\n+  test11();\n+  test12();\n+}"}]}