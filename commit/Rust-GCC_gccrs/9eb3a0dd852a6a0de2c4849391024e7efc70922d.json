{"sha": "9eb3a0dd852a6a0de2c4849391024e7efc70922d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViM2EwZGQ4NTJhNmEwZGUyYzQ4NDkzOTEwMjRlN2VmYzcwOTIyZA==", "commit": {"author": {"name": "Naveen.H.S", "email": "naveen.hs@kpitcummins.com", "date": "2008-04-04T23:36:19Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2008-04-04T23:36:19Z"}, "message": "invoke.texi: Document -mbitops for SH.\n\n\t* doc/invoke.texi: Document -mbitops for SH.\n\t* config/sh/constraints.md (K03, K12, Sbv, Sbw): New constraints.\n\t* config/sh/predicates.md (bitwise_memory_operand): New\tpredicate.\n\t* config/sh/sh.c (print_operand): Add %t operand code.\n\t* config/sh/sh.h (GO_IF_LEGITIMATE_INDEX): Add condition for SH2A.\n\t* config/sh/sh.md (*iorsi3_compact): Fix condition for SH2A.\n\t(extendqisi2_compact): Add the alternative for SH2A 4-byte mov.b.\n\t(extendqihi2): Likewise.\n\t(movqi_i): Likewise.\n\t(insv): Use bset, bclr and bst instructions for SH2A if\tpossible.\n\t(extv): Use bld instruction for SH2A if possible.\n\t(extzv): Likewise.\n\t(bclr_m2a, bclrmem_m2a, bset_m2a, bsetmem_m2a, bst_m2a, bld_m2a,\n\tbldsign_m2a, bld_reg, *bld_regqi, band_m2a, bandreg_m2a,\n\tbor_m2a, borreg_m2a, bxor_m2a, bxorreg_m2a): New insns.\n\t(bset.b, bclr.b): Define peepholes.\n\t* config/sh/sh.opt (mbitops): New option.\n\n\t* gcc.target/sh/sh2a-band.c: New test.\n\t* gcc.target/sh/sh2a-bclrmem.c: New test.\n\t* gcc.target/sh/sh2a-bld.c: New test.\n\t* gcc.target/sh/sh2a-bor.c: New test.\n\t* gcc.target/sh/sh2a-bsetmem.c: New test.\n\t* gcc.target/sh/sh2a-bxor.c: New test.\n\nFrom-SVN: r133919", "tree": {"sha": "3cdfd635d78201d5b94a867241c320785815e499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cdfd635d78201d5b94a867241c320785815e499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb3a0dd852a6a0de2c4849391024e7efc70922d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb3a0dd852a6a0de2c4849391024e7efc70922d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb3a0dd852a6a0de2c4849391024e7efc70922d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb3a0dd852a6a0de2c4849391024e7efc70922d/comments", "author": null, "committer": null, "parents": [{"sha": "97db009ce95362bc9c82a73557b79e64efbd0d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97db009ce95362bc9c82a73557b79e64efbd0d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97db009ce95362bc9c82a73557b79e64efbd0d1d"}], "stats": {"total": 837, "additions": 830, "deletions": 7}, "files": [{"sha": "a4fe162f6bd8413c4d7963c3ff442329951cd2fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -1,3 +1,23 @@\n+2008-04-04  Naveen.H.S  <naveen.hs@kpitcummins.com>\n+\n+\t* doc/invoke.texi: Document -mbitops for SH.\n+\t* config/sh/constraints.md (K03, K12, Sbv, Sbw): New constraints.\n+\t* config/sh/predicates.md (bitwise_memory_operand): New\tpredicate.\n+\t* config/sh/sh.c (print_operand): Add %t operand code.\n+\t* config/sh/sh.h (GO_IF_LEGITIMATE_INDEX): Add condition for SH2A.\n+\t* config/sh/sh.md (*iorsi3_compact): Fix condition for SH2A.\n+\t(extendqisi2_compact): Add the alternative for SH2A 4-byte mov.b.\n+\t(extendqihi2): Likewise.\n+\t(movqi_i): Likewise.\n+\t(insv): Use bset, bclr and bst instructions for SH2A if\tpossible.\n+\t(extv): Use bld instruction for SH2A if possible.\n+\t(extzv): Likewise.\n+\t(bclr_m2a, bclrmem_m2a, bset_m2a, bsetmem_m2a, bst_m2a, bld_m2a,\n+\tbldsign_m2a, bld_reg, *bld_regqi, band_m2a, bandreg_m2a,\n+\tbor_m2a, borreg_m2a, bxor_m2a, bxorreg_m2a): New insns.\n+\t(bset.b, bclr.b): Define peepholes.\n+\t* config/sh/sh.opt (mbitops): New option.\n+\n 2008-04-04  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR target/35620"}, {"sha": "2caa1d53a3eb3b9ce1af07ede5e753d976aeeeca", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -125,11 +125,21 @@\n   (and (match_code \"const_int\")\n        (match_test \"CONST_OK_FOR_J16 (ival)\")))\n \n+(define_constraint \"K03\"\n+  \"An unsigned 3-bit constant, as used in SH2A bclr, bset, etc.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 7\")))\n+\n (define_constraint \"K08\"\n   \"An unsigned 8-bit constant, as used in and, or, etc.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 255\")))\n  \n+(define_constraint \"K12\"\n+  \"An unsigned 8-bit constant, as used in SH2A 12-bit display.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 4095\")))\n+\n (define_constraint \"K16\"\n   \"An unsigned 16-bit constant, as used in SHmedia shori.\"\n   (and (match_code \"const_int\")\n@@ -239,3 +249,15 @@\n   \"@internal\"\n   (and (match_test \"memory_operand (op, GET_MODE (op))\")\n        (match_test \"GET_CODE (XEXP (op, 0)) != PLUS\")))\n+\n+(define_memory_constraint \"Sbv\"\n+  \"A memory reference, as used in SH2A bclr.b, bset.b, etc.\"\n+  (and (match_test \"MEM_P (op) && GET_MODE (op) == QImode\")\n+       (match_test \"REG_P (XEXP (op, 0))\")))\n+\n+(define_memory_constraint \"Sbw\"\n+  \"A memory reference, as used in SH2A bclr.b, bset.b, etc.\"\n+  (and (match_test \"MEM_P (op) && GET_MODE (op) == QImode\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n+       (match_test \"REG_P (XEXP (XEXP (op, 0), 0))\")\n+       (match_test \"satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1))\")))"}, {"sha": "ff6a1a2898ac3a6cea53dacc669175fc28c0c7e2", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -789,3 +789,19 @@\n     return 0;\n   return arith_reg_operand (op, mode);\n })\n+\n+(define_predicate \"bitwise_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      if (REG_P (XEXP (op, 0)))\n+\treturn 1;\n+\n+      if (GET_CODE (XEXP (op, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\n+\t  && satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1)))\n+        return 1;\n+    }\n+  return 0;\n+})"}, {"sha": "6013c2a475504413dcc1ab8fb080abbdae389563", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -683,6 +683,7 @@ print_operand_address (FILE *stream, rtx x)\n    'U'  Likewise for {LD,ST}{HI,LO}.\n    'V'  print the position of a single bit set.\n    'W'  print the position of a single bit cleared.\n+   't'  print a memory address which is a register.\n    'u'  prints the lowest 16 bits of CONST_INT, as an unsigned value.\n    'o'  output an operator.  */\n \n@@ -822,6 +823,21 @@ print_operand (FILE *stream, rtx x, int code)\n \t  break;\n \t}\n       break;\n+\n+    case 't':\n+      gcc_assert (GET_CODE (x) == MEM);\n+      x = XEXP (x, 0);\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\tcase SUBREG:\n+\t  print_operand (stream, x, 0);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n     case 'o':\n       switch (GET_CODE (x))\n \t{"}, {"sha": "eb37106348ffe09314d9a5624005d8b445a43ebd", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -2449,6 +2449,12 @@ struct sh_args {\n \t    else\t\t\t\t\t\t\t\\\n \t      break;\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_SH2A)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_MODE_SIZE (MODE) == 1\t\t\t\t\\\n+\t\t&& (unsigned) INTVAL (OP) < 4096)\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \tif (MODE_DISP_OK_4 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n \tif (MODE_DISP_OK_8 ((OP), (MODE)))  goto LABEL;\t\t      \t\\\n       }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "773c34775c148029194d00dd60ad45786fca430d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 306, "deletions": 6, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -3246,7 +3246,8 @@ label:\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,z\")\n \t(ior:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,K08\")))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1\n+   && !(TARGET_SH2A && satisfies_constraint_Pso (operands[2]))\"\n   \"or\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n@@ -4723,7 +4724,12 @@ label:\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2)\n+       (if_then_else\n+\t(ne (symbol_ref \"TARGET_SH2A\") (const_int 0))\n+\t(const_int 4) (const_int 2))])])\n \n (define_insn \"*extendqisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -4761,7 +4767,12 @@ label:\n   \"@\n \texts.b\t%1,%0\n \tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n+  [(set_attr \"type\" \"arith,load\")\n+   (set_attr_alternative \"length\"\n+     [(const_int 2)\n+       (if_then_else\n+\t(ne (symbol_ref \"TARGET_SH2A\") (const_int 0))\n+\t(const_int 4) (const_int 2))])])\n \n /* It would seem useful to combine the truncXi patterns into the movXi\n    patterns, but unary operators are ignored when matching constraints,\n@@ -5309,7 +5320,19 @@ label:\n \tmovt\t%0\n \tsts\t%1,%0\n \tlds\t%1,%0\"\n- [(set_attr \"type\" \"move,movi8,load,store,arith,prget,prset\")])\n+ [(set_attr \"type\" \"move,movi8,load,store,arith,prget,prset\")\n+  (set_attr_alternative \"length\"\n+     [(const_int 2)\n+      (const_int 2)\n+      (if_then_else\n+\t(ne (symbol_ref \"TARGET_SH2A\") (const_int 0))\n+\t(const_int 4) (const_int 2))\n+      (if_then_else\n+\t(ne (symbol_ref \"TARGET_SH2A\") (const_int 0))\n+\t(const_int 4) (const_int 2))\n+      (const_int 2)\n+      (const_int 2)\n+      (const_int 2)])])\n \n (define_insn \"*movqi_media\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m\")\n@@ -11655,6 +11678,36 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   HOST_WIDE_INT bitsize, size, v = 0;\n   rtx x = operands[3];\n \n+  if (TARGET_SH2A && TARGET_BITOPS\n+      && (satisfies_constraint_Sbw (operands[0])\n+\t  || satisfies_constraint_Sbv (operands[0]))\n+      && satisfies_constraint_M (operands[1])\n+      && satisfies_constraint_K03 (operands[2]))\n+    {\n+      if (satisfies_constraint_N (operands[3]))\n+\t{\n+\t  emit_insn (gen_bclr_m2a (operands[0], operands[2]));\n+\t  DONE;\n+\t}\n+      else if (satisfies_constraint_M (operands[3]))\n+\t{\n+\t  emit_insn (gen_bset_m2a (operands[0], operands[2]));\n+\t  DONE;\n+\t}\n+      else if ((REG_P (operands[3]) && REGNO (operands[3]) == T_REG)\n+\t\t&& satisfies_constraint_M (operands[1]))\n+\t{\n+\t  emit_insn (gen_bst_m2a (operands[0], operands[2]));\n+\t  DONE;\n+\t}\n+      else if (REG_P (operands[3])\n+\t       && satisfies_constraint_M (operands[1]))\n+\t{\n+\t  emit_insn (gen_bld_reg (operands[3], const0_rtx));\n+\t  emit_insn (gen_bst_m2a (operands[0], operands[2]));\n+\t  DONE;\n+\t}\n+    }\n   /* ??? expmed doesn't care for non-register predicates.  */\n   if (! memory_operand (operands[0], VOIDmode)\n       || ! immediate_operand (operands[1], VOIDmode)\n@@ -11732,8 +11785,19 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(sign_extract:SI (match_operand:QI 1 \"unaligned_load_operand\" \"\")\n \t\t\t (match_operand 2 \"const_int_operand\" \"\")\n \t\t\t (match_operand 3 \"const_int_operand\" \"\")))]\n-  \"TARGET_SH4A_ARCH\"\n+  \"TARGET_SH4A_ARCH || TARGET_SH2A\"\n {\n+  if (TARGET_SH2A && TARGET_BITOPS\n+      && (satisfies_constraint_Sbw (operands[1])\n+\t  || satisfies_constraint_Sbv (operands[1]))\n+      && satisfies_constraint_M (operands[2])\n+      && satisfies_constraint_K03 (operands[3]))\n+   {\n+      emit_insn (gen_bldsign_m2a (operands[1], operands[3]));\n+      if (REGNO (operands[0]) != T_REG)\n+\temit_insn (gen_movsi (operands[0], gen_rtx_REG (SImode, T_REG)));\n+      DONE;\n+   }\n   if (TARGET_SH4A_ARCH\n       && INTVAL (operands[2]) == 32\n       && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n@@ -11753,8 +11817,19 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(zero_extract:SI (match_operand:QI 1 \"unaligned_load_operand\" \"\")\n \t\t\t (match_operand 2 \"const_int_operand\" \"\")\n \t\t\t (match_operand 3 \"const_int_operand\" \"\")))]\n-  \"TARGET_SH4A_ARCH\"\n+  \"TARGET_SH4A_ARCH || TARGET_SH2A\"\n {\n+  if (TARGET_SH2A && TARGET_BITOPS\n+      && (satisfies_constraint_Sbw (operands[1])\n+\t  || satisfies_constraint_Sbv (operands[1]))\n+      && satisfies_constraint_M (operands[2])\n+      && satisfies_constraint_K03 (operands[3]))\n+    {\n+      emit_insn (gen_bld_m2a (operands[1], operands[3]));\n+      if (REGNO (operands[0]) != T_REG)\n+\temit_insn (gen_movsi (operands[0], gen_rtx_REG (SImode, T_REG)));\n+      DONE;\n+    }\n   if (TARGET_SH4A_ARCH\n       && INTVAL (operands[2]) == 32\n       && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n@@ -11769,10 +11844,235 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   FAIL;\n })\n \n+;; SH2A instructions for bitwise operations.\n+\n+;; Clear a bit in a memory location.\n+(define_insn \"bclr_m2a\"\n+  [(set (match_operand:QI 0 \"bitwise_memory_operand\" \"+Sbw,Sbv\")\n+\t(and:QI\n+\t    (not:QI (ashift:QI (const_int 1)\n+\t\t\t(match_operand:QI 1 \"const_int_operand\" \"K03,K03\")))\n+\t    (match_dup 0)))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbclr.b\\\\t%1,%0\n+\tbclr.b\\\\t%1,@(0,%t0)\"\n+[(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"bclrmem_m2a\"\n+  [(set (match_operand:QI 0 \"bitwise_memory_operand\" \"+Sbw,Sbv\")\n+        (and:QI (match_dup 0)\n+                (match_operand:QI 1 \"const_int_operand\" \"Psz,Psz\")))]\n+  \"TARGET_SH2A && satisfies_constraint_Psz (operands[1]) && TARGET_BITOPS\"\n+  \"@\n+        bclr.b\\\\t%W1,%0\n+        bclr.b\\\\t%W1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+;; Set a bit in a memory location.\n+(define_insn \"bset_m2a\"\n+  [(set (match_operand:QI 0 \"bitwise_memory_operand\" \"+Sbw,Sbv\")\n+\t(ior:QI\n+\t    (ashift:QI (const_int 1)\n+\t\t       (match_operand:QI 1 \"const_int_operand\" \"K03,K03\"))\n+\t    (match_dup 0)))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbset.b\\\\t%1,%0\n+\tbset.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"bsetmem_m2a\"\n+  [(set (match_operand:QI 0 \"bitwise_memory_operand\" \"+Sbw,Sbv\")\n+\t(ior:QI (match_dup 0)\n+\t\t(match_operand:QI 1 \"const_int_operand\" \"Pso,Pso\")))]\n+  \"TARGET_SH2A && satisfies_constraint_Pso (operands[1]) && TARGET_BITOPS\"\n+  \"@\n+        bset.b\\\\t%V1,%0\n+        bset.b\\\\t%V1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+;;; Transfer the contents of the T bit to a specified bit of memory.\n+(define_insn \"bst_m2a\"\n+  [(set (match_operand:QI 0 \"bitwise_memory_operand\" \"+Sbw,m\")\n+\t(if_then_else (eq (reg:SI T_REG) (const_int 0))\n+\t    (and:QI\n+\t\t(not:QI (ashift:QI (const_int 1)\n+\t\t\t(match_operand:QI 1 \"const_int_operand\" \"K03,K03\")))\n+\t\t(match_dup 0))\n+\t    (ior:QI\n+\t\t(ashift:QI (const_int 1) (match_dup 1))\n+\t\t(match_dup 0))))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbst.b\\\\t%1,%0\n+\tbst.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; Store a specified bit of memory in the T bit.\n+(define_insn \"bld_m2a\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI\n+\t    (match_operand:QI 0 \"bitwise_memory_operand\" \"Sbw,Sbv\")\n+\t    (const_int 1)\n+\t    (match_operand 1 \"const_int_operand\" \"K03,K03\")))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbld.b\\\\t%1,%0\n+\tbld.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+;; Store a specified bit of memory in the T bit.\n+(define_insn \"bldsign_m2a\"\n+  [(set (reg:SI T_REG)\n+\t(sign_extract:SI\n+\t    (match_operand:QI 0 \"bitwise_memory_operand\" \"Sbw,m\")\n+\t    (const_int 1)\n+\t    (match_operand 1 \"const_int_operand\" \"K03,K03\")))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbld.b\\\\t%1,%0\n+\tbld.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+;; Store a specified bit of the LSB 8 bits of a register in the T bit.\n+(define_insn \"bld_reg\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_int_operand\" \"K03\")))]\n+  \"TARGET_SH2A\"\n+  \"bld\\\\t%1,%0\")\n+\n+(define_insn \"*bld_regqi\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (match_operand:QI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_int_operand\" \"K03\")))]\n+  \"TARGET_SH2A\"\n+  \"bld\\\\t%1,%0\")\n+\n+;; Take logical and of a specified bit of memory with the T bit and\n+;; store its result in the T bit.\n+(define_insn \"band_m2a\"\n+  [(set (reg:SI T_REG)\n+\t(and:SI (reg:SI T_REG)\n+\t\t(zero_extract:SI\n+\t\t    (match_operand:QI 0 \"bitwise_memory_operand\" \"Sbw,m\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 1 \"const_int_operand\" \"K03,K03\"))))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tband.b\\\\t%1,%0\n+\tband.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"bandreg_m2a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (zero_extract:SI\n+\t\t    (match_operand:QI 1 \"bitwise_memory_operand\" \"Sbw,Sbv\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 2 \"const_int_operand\" \"K03,K03\"))\n+        \t(match_operand:SI 3 \"register_operand\" \"r,r\")))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tband.b\\\\t%2,%1\\;movt\\\\t%0\n+\tband.b\\\\t%2,@(0,%t1)\\;movt\\\\t%0\"\n+  [(set_attr \"length\" \"6,6\")])\n+\n+;; Take logical or of a specified bit of memory with the T bit and\n+;; store its result in the T bit.\n+(define_insn \"bor_m2a\"\n+  [(set (reg:SI T_REG)\n+\t(ior:SI (reg:SI T_REG)\n+\t\t(zero_extract:SI\n+\t\t    (match_operand:QI 0 \"bitwise_memory_operand\" \"Sbw,m\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 1 \"const_int_operand\" \"K03,K03\"))))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbor.b\\\\t%1,%0\n+\tbor.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"borreg_m2a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (zero_extract:SI\n+\t\t    (match_operand:QI 1 \"bitwise_memory_operand\" \"Sbw,Sbv\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 2 \"const_int_operand\" \"K03,K03\"))\n+\t\t(match_operand:SI 3 \"register_operand\" \"=r,r\")))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbor.b\\\\t%2,%1\\;movt\\\\t%0\n+\tbor.b\\\\t%2,@(0,%t1)\\;movt\\\\t%0\"\n+  [(set_attr \"length\" \"6,6\")])\n+\n+;; Take exclusive or of a specified bit of memory with the T bit and\n+;; store its result in the T bit.\n+(define_insn \"bxor_m2a\"\n+  [(set (reg:SI T_REG)\n+\t(xor:SI (reg:SI T_REG)\n+\t\t(zero_extract:SI\n+\t\t    (match_operand:QI 0 \"bitwise_memory_operand\" \"Sbw,m\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 1 \"const_int_operand\" \"K03,K03\"))))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbxor.b\\\\t%1,%0\n+\tbxor.b\\\\t%1,@(0,%t0)\"\n+  [(set_attr \"length\" \"4,4\")])\n+\n+(define_insn \"bxorreg_m2a\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (zero_extract:SI\n+\t\t    (match_operand:QI 1 \"bitwise_memory_operand\" \"Sbw,Sbv\")\n+\t\t    (const_int 1)\n+\t\t    (match_operand 2 \"const_int_operand\" \"K03,K03\"))\n+\t\t(match_operand:SI 3 \"register_operand\" \"=r,r\")))]\n+  \"TARGET_SH2A && TARGET_BITOPS\"\n+  \"@\n+\tbxor.b\\\\t%2,%1\\;movt\\\\t%0\n+\tbxor.b\\\\t%2,@(0,%t1)\\;movt\\\\t%0\"\n+  [(set_attr \"length\" \"6,6\")])\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Peepholes\n ;; -------------------------------------------------------------------------\n+;; This matches cases where the bit in a memory location is set.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"bitwise_memory_operand\" \"Sbw,Sbv\")))\n+   (set (match_dup 0)\n+\t(ior:SI (match_dup 0)\n+\t(match_operand:SI 2 \"const_int_operand\" \"Pso,Pso\")))\n+   (set (match_dup 1)\n+\t(match_operand 3 \"arith_reg_operand\" \"r,r\"))]\n+  \"TARGET_SH2A && TARGET_BITOPS\n+   && satisfies_constraint_Pso (operands[2])\n+   && REGNO (operands[0]) == REGNO (operands[3])\"\n+  [(set (match_dup 1)\n+        (ior:QI (match_dup 1)\n+                (match_dup 2)))]\n+  \"\")\n+\n+;; This matches cases where the bit in a memory location is cleared.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"bitwise_memory_operand\" \"Sbw,Sbv\")))\n+   (set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t(match_operand:SI 2 \"const_int_operand\" \"Psz,Psz\")))\n+   (set (match_dup 1)\n+\t(match_operand 3 \"arith_reg_operand\" \"r,r\"))]\n+  \"TARGET_SH2A && TARGET_BITOPS\n+   && satisfies_constraint_Psz (operands[2])\n+   && REGNO (operands[0]) == REGNO (operands[3])\"\n+  [(set (match_dup 1)\n+        (and:QI (match_dup 1)\n+                (match_dup 2)))]\n+  \"\")\n \n ;; This matches cases where a stack pointer increment at the start of the\n ;; epilogue combines with a stack slot read loading the return value."}, {"sha": "b62530f61003c87395b654cd0be30ddb3ed0c6d6", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -212,6 +212,10 @@ mbigtable\n Target Report RejectNegative Mask(BIGTABLE)\n Generate 32-bit offsets in switch tables\n \n+mbitops\n+Target Report RejectNegative Mask(BITOPS)\n+Generate bit instructions\n+\n mbranch-cost=\n Target RejectNegative Joined UInteger Var(sh_branch_cost) Init(-1)\n Cost to assume for a branch insn"}, {"sha": "5152a153d32f80261ba3ad7df7d93a20fe806ad8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -746,7 +746,7 @@ See RS/6000 and PowerPC Options.\n -m5-compact  -m5-compact-nofpu @gol\n -mb  -ml  -mdalign  -mrelax @gol\n -mbigtable  -mfmovd  -mhitachi -mrenesas -mno-renesas -mnomacsave @gol\n--mieee  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol\n+-mieee  -mbitops  -misize  -minline-ic_invalidate -mpadstruct  -mspace @gol\n -mprefergot  -musermode -multcost=@var{number} -mdiv=@var{strategy} @gol\n -mdivsi3_libfunc=@var{name}  @gol\n -madjust-unroll -mindexed-addressing -mgettrcost=@var{number} -mpt-fixed @gol\n@@ -13910,6 +13910,10 @@ linker option @option{-relax}.\n Use 32-bit offsets in @code{switch} tables.  The default is to use\n 16-bit offsets.\n \n+@item -mbitops\n+@opindex mbitops\n+Enable the use of bit manipulation instructions on SH2A.\n+\n @item -mfmovd\n @opindex mfmovd\n Enable the use of the instruction @code{fmovd}."}, {"sha": "08e354548bb75b15a551f52f39b21e04f79e9118", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -1,3 +1,12 @@\n+2008-04-04  Naveen.H.S  <naveen.hs@kpitcummins.com>\n+\n+\t* gcc.target/sh/sh2a-band.c: New test.\n+\t* gcc.target/sh/sh2a-bclrmem.c: New test.\n+\t* gcc.target/sh/sh2a-bld.c: New test.\n+\t* gcc.target/sh/sh2a-bor.c: New test.\n+\t* gcc.target/sh/sh2a-bsetmem.c: New test.\n+\t* gcc.target/sh/sh2a-bxor.c: New test.\n+\n 2008-04-04  Janis Johnson  <janis187@us.ibm.com>\n \n \t* g++.dg/other/anon5.C: Don't depend on line number for error message."}, {"sha": "34862b7256dc748d9de322da025a1ba411224a06", "filename": "gcc/testsuite/gcc.target/sh/sh2a-band.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-band.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-band.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-band.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,91 @@\n+/* Testcase to check generation of a SH2A specific instruction for\n+   \"BAND.B #imm3, @(disp12, Rn)\".  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O1 -mbitops\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"band.b\"} }  */\n+\n+volatile struct\n+{\n+  union\n+  {\n+    unsigned char BYTE;\n+    struct\n+    {\n+      unsigned char BIT7:1;\n+      unsigned char BIT6:1;\n+      unsigned char BIT5:1;\n+      unsigned char BIT4:1;\n+      unsigned char BIT3:1;\n+      unsigned char BIT2:1;\n+      unsigned char BIT1:1;\n+      unsigned char BIT0:1;\n+    }\n+    BIT;\n+  }\n+  ICR0;\n+}\n+USRSTR;\n+\n+volatile union t_IOR\n+{\n+  unsigned short WORD;\n+  struct\n+  {\n+    unsigned char IOR15:1;\n+    unsigned char IOR14:1;\n+    unsigned char IOR13:1;\n+    unsigned char IOR12:1;\n+    unsigned char IOR11:1;\n+    unsigned char IOR10:1;\n+    unsigned char IOR9:1;\n+    unsigned char IOR8:1;\n+    unsigned char IOR7:1;\n+    unsigned char IOR6:1;\n+    unsigned char IOR5:1;\n+    unsigned char IOR4:1;\n+    unsigned char IOR3:1;\n+    unsigned char IOR2:1;\n+    unsigned char IOR1:1;\n+    unsigned char IOR0:1;\n+  }\n+  BIT;\n+}\n+PORT;\n+\n+int\n+main ()\n+{\n+  volatile unsigned char a;\n+\n+  /* Instruction generated is BAND.B #imm3, @(disp12, Rn)  */\n+  USRSTR.ICR0.BIT.BIT3 = USRSTR.ICR0.BIT.BIT4 & USRSTR.ICR0.BIT.BIT1;\n+  USRSTR.ICR0.BIT.BIT2 = USRSTR.ICR0.BIT.BIT6 & USRSTR.ICR0.BIT.BIT6;\n+  USRSTR.ICR0.BIT.BIT4 = USRSTR.ICR0.BIT.BIT2 & USRSTR.ICR0.BIT.BIT4;\n+  USRSTR.ICR0.BIT.BIT6 = USRSTR.ICR0.BIT.BIT1 & USRSTR.ICR0.BIT.BIT3;\n+\n+  a = USRSTR.ICR0.BIT.BIT0 & USRSTR.ICR0.BIT.BIT1;\n+  a = USRSTR.ICR0.BIT.BIT5 & USRSTR.ICR0.BIT.BIT7;\n+  a = USRSTR.ICR0.BIT.BIT2 & USRSTR.ICR0.BIT.BIT6;\n+\n+  PORT.BIT.IOR13 = PORT.BIT.IOR0  &  USRSTR.ICR0.BIT.BIT7;\n+  PORT.BIT.IOR15 = PORT.BIT.IOR6  &  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR3  = PORT.BIT.IOR2  &  USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR1  = PORT.BIT.IOR13 &  USRSTR.ICR0.BIT.BIT1;\n+\n+  PORT.BIT.IOR1  = PORT.BIT.IOR2  &  USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR11 = PORT.BIT.IOR9  &  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR8  = PORT.BIT.IOR14 &  USRSTR.ICR0.BIT.BIT5;\n+\n+  PORT.BIT.IOR10 &= USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR1  &= USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR5  &= USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR14 &= USRSTR.ICR0.BIT.BIT4;\n+\n+  /* Instruction generated on using size optimization option \"-Os\".  */\n+  a = a & USRSTR.ICR0.BIT.BIT1;\n+  a = a & USRSTR.ICR0.BIT.BIT4;\n+  a = a & USRSTR.ICR0.BIT.BIT0;\n+\n+  return 0;\n+}"}, {"sha": "41cb3bdfedd43eb68f585196418ab085e29276f3", "filename": "gcc/testsuite/gcc.target/sh/sh2a-bclrmem.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bclrmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bclrmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bclrmem.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,55 @@\n+/* Testcase to check generation of a SH2A specific instruction\n+   \"BCLR #imm3,@(disp12,Rn)\".  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O2 -mbitops\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"bclr\"} }  */\n+/* { dg-final { scan-assembler \"bclr.b\"} }  */\n+\n+volatile union un_paddr\n+{\n+  unsigned char BYTE;\n+  struct\n+  {\n+    unsigned char B15:1;\n+    unsigned char B14:1;\n+    unsigned char B13:1;\n+    unsigned char B12:1;\n+    unsigned char B11:1;\n+    unsigned char B10:1;\n+    unsigned char B9:1;\n+    unsigned char B8:1;\n+    unsigned char B7:1;\n+    unsigned char B6:1;\n+    unsigned char B5:1;\n+    unsigned char B4:1;\n+    unsigned char B3:1;\n+    unsigned char B2:1;\n+    unsigned char B1:1;\n+    unsigned char B0:1;\n+  }\n+  BIT;\n+}\n+PADDR;\n+\n+int\n+main ()\n+{\n+  PADDR.BIT.B0 = 0;\n+  PADDR.BIT.B3 = 0;\n+  PADDR.BIT.B6 = 0;\n+\n+  PADDR.BIT.B1 &= 0;\n+  PADDR.BIT.B4 &= 0;\n+  PADDR.BIT.B7 &= 0;\n+\n+  PADDR.BIT.B10 = 0;\n+  PADDR.BIT.B13 = 0;\n+  PADDR.BIT.B15 = 0;\n+\n+  PADDR.BIT.B9 &= 0;\n+  PADDR.BIT.B12 &= 0;\n+  PADDR.BIT.B14 &= 0;\n+\n+  return 0;\n+}"}, {"sha": "1cf56fe271432dfa8f871fdb9d141c08d1dcc4c2", "filename": "gcc/testsuite/gcc.target/sh/sh2a-bld.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bld.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,43 @@\n+/* A testcase to check generation of the following SH2A specific\n+   instructions.\n+\n+    BLD #imm3, Rn\n+    BLD.B #imm3, @(disp12, Rn)\n+ */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-Os -mbitops\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"bld\"} }  */\n+/* { dg-final { scan-assembler \"bld.b\"} }  */\n+\n+volatile struct\n+{\n+  union\n+  {\n+    unsigned char BYTE;\n+    struct\n+    {\n+      unsigned char BIT7:1;\n+      unsigned char BIT6:1;\n+      unsigned char BIT5:1;\n+      unsigned char BIT4:1;\n+      unsigned char BIT3:1;\n+      unsigned char BIT2:1;\n+      unsigned char BIT1:1;\n+      unsigned char BIT0:1;\n+    }\n+    BIT;\n+  }\n+  ICR0;\n+}\n+USRSTR;\n+\n+int\n+main ()\n+{\n+  volatile unsigned char a, b, c;\n+  USRSTR.ICR0.BIT.BIT6 &= a;\n+  USRSTR.ICR0.BIT.BIT5 |= b;\n+  USRSTR.ICR0.BIT.BIT4 ^= c;\n+  return 0;\n+}"}, {"sha": "c3803c6b9ca2bda6a6c0795eff184f66dd66c844", "filename": "gcc/testsuite/gcc.target/sh/sh2a-bor.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bor.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,91 @@\n+/* Testcase to check generation of a SH2A specific instruction for\n+   \"BOR.B #imm3, @(disp12, Rn)\".  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O1 -mbitops\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"bor.b\"} }  */\n+\n+volatile struct\n+{\n+  union\n+  {\n+    unsigned char BYTE;\n+    struct\n+    {\n+      unsigned char BIT7:1;\n+      unsigned char BIT6:1;\n+      unsigned char BIT5:1;\n+      unsigned char BIT4:1;\n+      unsigned char BIT3:1;\n+      unsigned char BIT2:1;\n+      unsigned char BIT1:1;\n+      unsigned char BIT0:1;\n+    }\n+    BIT;\n+  }\n+  ICR0;\n+}\n+USRSTR;\n+\n+volatile union t_IOR\n+{\n+  unsigned short WORD;\n+  struct\n+  {\n+    unsigned char IOR15:1;\n+    unsigned char IOR14:1;\n+    unsigned char IOR13:1;\n+    unsigned char IOR12:1;\n+    unsigned char IOR11:1;\n+    unsigned char IOR10:1;\n+    unsigned char IOR9:1;\n+    unsigned char IOR8:1;\n+    unsigned char IOR7:1;\n+    unsigned char IOR6:1;\n+    unsigned char IOR5:1;\n+    unsigned char IOR4:1;\n+    unsigned char IOR3:1;\n+    unsigned char IOR2:1;\n+    unsigned char IOR1:1;\n+    unsigned char IOR0:1;\n+  }\n+  BIT;\n+}\n+PORT;\n+\n+int\n+main ()\n+{\n+  volatile unsigned char a;\n+\n+  /* Instruction generated is BOR.B #imm3, @(disp12, Rn)  */\n+  USRSTR.ICR0.BIT.BIT3 = USRSTR.ICR0.BIT.BIT4 | USRSTR.ICR0.BIT.BIT1;\n+  USRSTR.ICR0.BIT.BIT2 = USRSTR.ICR0.BIT.BIT6 | USRSTR.ICR0.BIT.BIT6;\n+  USRSTR.ICR0.BIT.BIT4 = USRSTR.ICR0.BIT.BIT2 | USRSTR.ICR0.BIT.BIT4;\n+  USRSTR.ICR0.BIT.BIT6 = USRSTR.ICR0.BIT.BIT1 | USRSTR.ICR0.BIT.BIT3;\n+\n+  a = USRSTR.ICR0.BIT.BIT0 | USRSTR.ICR0.BIT.BIT1;\n+  a = USRSTR.ICR0.BIT.BIT5 | USRSTR.ICR0.BIT.BIT7;\n+  a = USRSTR.ICR0.BIT.BIT2 | USRSTR.ICR0.BIT.BIT6;\n+\n+  PORT.BIT.IOR13 = PORT.BIT.IOR0  |  USRSTR.ICR0.BIT.BIT7;\n+  PORT.BIT.IOR15 = PORT.BIT.IOR6  |  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR3  = PORT.BIT.IOR2  |  USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR1  = PORT.BIT.IOR13 |  USRSTR.ICR0.BIT.BIT1;\n+\n+  PORT.BIT.IOR1  = PORT.BIT.IOR2  |  USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR11 = PORT.BIT.IOR9  |  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR8  = PORT.BIT.IOR14 |  USRSTR.ICR0.BIT.BIT5;\n+\n+  PORT.BIT.IOR10 |= USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR1  |= USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR5  |= USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR14 |= USRSTR.ICR0.BIT.BIT4;\n+\n+  /* Instruction generated on using size optimization option \"-Os\".  */\n+  a = a & USRSTR.ICR0.BIT.BIT1;\n+  a = a & USRSTR.ICR0.BIT.BIT4;\n+  a = a & USRSTR.ICR0.BIT.BIT0;\n+\n+  return 0;\n+}"}, {"sha": "b0ebf0851dcb9a6526857ab04bbbb3e66b960a65", "filename": "gcc/testsuite/gcc.target/sh/sh2a-bsetmem.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bsetmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bsetmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bsetmem.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,55 @@\n+/* Testcase to check generation of a SH2A specific instruction\n+   \"BSET #imm3,@(disp12,Rn)\".  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O2 -mbitops\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"bset\"} }  */\n+/* { dg-final { scan-assembler \"bset.b\"} }  */\n+\n+volatile union un_paddr\n+{\n+  unsigned char BYTE;\n+  struct\n+  {\n+    unsigned char B15:1;\n+    unsigned char B14:1;\n+    unsigned char B13:1;\n+    unsigned char B12:1;\n+    unsigned char B11:1;\n+    unsigned char B10:1;\n+    unsigned char B9:1;\n+    unsigned char B8:1;\n+    unsigned char B7:1;\n+    unsigned char B6:1;\n+    unsigned char B5:1;\n+    unsigned char B4:1;\n+    unsigned char B3:1;\n+    unsigned char B2:1;\n+    unsigned char B1:1;\n+    unsigned char B0:1;\n+  }\n+  BIT;\n+}\n+PADDR;\n+\n+int\n+main ()\n+{\n+  PADDR.BIT.B0 = 1;\n+  PADDR.BIT.B3 = 1;\n+  PADDR.BIT.B6 = 1;\n+\n+  PADDR.BIT.B1 |= 1;\n+  PADDR.BIT.B4 |= 1;\n+  PADDR.BIT.B7 |= 1;\n+\n+  PADDR.BIT.B10 = 1;\n+  PADDR.BIT.B13 = 1;\n+  PADDR.BIT.B15 = 1;\n+\n+  PADDR.BIT.B9  |= 1;\n+  PADDR.BIT.B12 |= 1;\n+  PADDR.BIT.B14 |= 1;\n+\n+  return 0;\n+}"}, {"sha": "afe0a5ec9793c64b892446fffc0bc02c4376317e", "filename": "gcc/testsuite/gcc.target/sh/sh2a-bxor.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bxor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb3a0dd852a6a0de2c4849391024e7efc70922d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bxor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-bxor.c?ref=9eb3a0dd852a6a0de2c4849391024e7efc70922d", "patch": "@@ -0,0 +1,91 @@\n+/* Testcase to check generation of a SH2A specific instruction for\n+   \"BXOR.B #imm3, @(disp12, Rn)\".  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O1 -mbitops\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"bxor.b\"} }  */\n+\n+volatile struct\n+{\n+  union\n+  {\n+    unsigned char BYTE;\n+    struct\n+    {\n+      unsigned char BIT7:1;\n+      unsigned char BIT6:1;\n+      unsigned char BIT5:1;\n+      unsigned char BIT4:1;\n+      unsigned char BIT3:1;\n+      unsigned char BIT2:1;\n+      unsigned char BIT1:1;\n+      unsigned char BIT0:1;\n+    }\n+    BIT;\n+  }\n+  ICR0;\n+}\n+USRSTR;\n+\n+volatile union t_IOR\n+{\n+  unsigned short WORD;\n+  struct\n+  {\n+    unsigned char IOR15:1;\n+    unsigned char IOR14:1;\n+    unsigned char IOR13:1;\n+    unsigned char IOR12:1;\n+    unsigned char IOR11:1;\n+    unsigned char IOR10:1;\n+    unsigned char IOR9:1;\n+    unsigned char IOR8:1;\n+    unsigned char IOR7:1;\n+    unsigned char IOR6:1;\n+    unsigned char IOR5:1;\n+    unsigned char IOR4:1;\n+    unsigned char IOR3:1;\n+    unsigned char IOR2:1;\n+    unsigned char IOR1:1;\n+    unsigned char IOR0:1;\n+  }\n+  BIT;\n+}\n+PORT;\n+\n+int\n+main ()\n+{\n+  volatile unsigned char a;\n+\n+  /* Instruction generated is BXOR.B #imm3, @(disp12, Rn)  */\n+  USRSTR.ICR0.BIT.BIT3 = USRSTR.ICR0.BIT.BIT4 ^ USRSTR.ICR0.BIT.BIT1;\n+  USRSTR.ICR0.BIT.BIT2 = USRSTR.ICR0.BIT.BIT6 ^ USRSTR.ICR0.BIT.BIT6;\n+  USRSTR.ICR0.BIT.BIT4 = USRSTR.ICR0.BIT.BIT2 ^ USRSTR.ICR0.BIT.BIT4;\n+  USRSTR.ICR0.BIT.BIT6 = USRSTR.ICR0.BIT.BIT1 ^ USRSTR.ICR0.BIT.BIT3;\n+\n+  a = USRSTR.ICR0.BIT.BIT0 ^ USRSTR.ICR0.BIT.BIT1;\n+  a = USRSTR.ICR0.BIT.BIT5 ^ USRSTR.ICR0.BIT.BIT7;\n+  a = USRSTR.ICR0.BIT.BIT2 ^ USRSTR.ICR0.BIT.BIT6;\n+\n+  PORT.BIT.IOR13 = PORT.BIT.IOR0  ^  USRSTR.ICR0.BIT.BIT7;\n+  PORT.BIT.IOR15 = PORT.BIT.IOR6  ^  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR3  = PORT.BIT.IOR2  ^  USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR1  = PORT.BIT.IOR13 ^  USRSTR.ICR0.BIT.BIT1;\n+\n+  PORT.BIT.IOR1  = PORT.BIT.IOR2  ^  USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR11 = PORT.BIT.IOR9  ^  USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR8  = PORT.BIT.IOR14 ^  USRSTR.ICR0.BIT.BIT5;\n+\n+  PORT.BIT.IOR10 ^= USRSTR.ICR0.BIT.BIT1;\n+  PORT.BIT.IOR1  ^= USRSTR.ICR0.BIT.BIT2;\n+  PORT.BIT.IOR5  ^= USRSTR.ICR0.BIT.BIT5;\n+  PORT.BIT.IOR14 ^= USRSTR.ICR0.BIT.BIT4;\n+\n+  /* Instruction generated on using size optimization option \"-Os\".  */\n+  a = a ^ USRSTR.ICR0.BIT.BIT1;\n+  a = a ^ USRSTR.ICR0.BIT.BIT4;\n+  a = a ^ USRSTR.ICR0.BIT.BIT0;\n+\n+  return 0;\n+}"}]}