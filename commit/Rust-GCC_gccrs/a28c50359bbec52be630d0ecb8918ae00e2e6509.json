{"sha": "a28c50359bbec52be630d0ecb8918ae00e2e6509", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4YzUwMzU5YmJlYzUyYmU2MzBkMGVjYjg5MThhZTAwZTJlNjUwOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-05-16T22:02:09Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-16T22:02:09Z"}, "message": "cppexp.c (lex): Use NODE_NAME and NODE_LEN.\n\n\t* cppexp.c (lex): Use NODE_NAME and NODE_LEN.\n\t* cpphash.c (_cpp_lookup_with_hash): Similarly.\n\t* cpplex.c (cpp_ideq, parse_identifier, cpp_token_len,\n\tcpp_spell_token, cpp_output_token): Similarly.\n\t* cpplib.c (lex_macro_node, do_undef, do_pragma,\n\tdo_pragma_poison, parse_assertion, do_assert): Similarly.\n\t* cppmacro.c (builtin_macro, parse_args, funlike_invocation_p,\n\tsave_parameter, _cpp_create_definition, check_trad_stringification,\n\tcpp_macro_definition): Similarly.\n\t* cppmain.c (cb_define, cb_undef, dump_macro): Similarly.\n\t* c-lex.c (cb_undef, c_lex): Similarly.\n\t* fix-header.c (recognized_function): Similarly.\n\t* cpplib.h (NODE_LEN, NODE_NAME): New.\n\t(cpp_hashnode): Rename length len.\n\nFrom-SVN: r42174", "tree": {"sha": "c0452482f8196e8f1922c3e67ab111a544d838e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0452482f8196e8f1922c3e67ab111a544d838e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a28c50359bbec52be630d0ecb8918ae00e2e6509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28c50359bbec52be630d0ecb8918ae00e2e6509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28c50359bbec52be630d0ecb8918ae00e2e6509", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28c50359bbec52be630d0ecb8918ae00e2e6509/comments", "author": null, "committer": null, "parents": [{"sha": "a50882dcae3809cfbf09c9135874e5035c178192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50882dcae3809cfbf09c9135874e5035c178192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50882dcae3809cfbf09c9135874e5035c178192"}], "stats": {"total": 134, "additions": 75, "deletions": 59}, "files": [{"sha": "50482cd38f3a0961461cc6b20a4aecd781db8e92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -1,3 +1,20 @@\n+2001-05-16  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (lex): Use NODE_NAME and NODE_LEN.\n+\t* cpphash.c (_cpp_lookup_with_hash): Similarly.\n+\t* cpplex.c (cpp_ideq, parse_identifier, cpp_token_len,\n+\tcpp_spell_token, cpp_output_token): Similarly.\n+\t* cpplib.c (lex_macro_node, do_undef, do_pragma,\n+\tdo_pragma_poison, parse_assertion, do_assert): Similarly.\n+\t* cppmacro.c (builtin_macro, parse_args, funlike_invocation_p,\n+\tsave_parameter, _cpp_create_definition, check_trad_stringification,\n+\tcpp_macro_definition): Similarly.\n+\t* cppmain.c (cb_define, cb_undef, dump_macro): Similarly.\n+\t* c-lex.c (cb_undef, c_lex): Similarly.\n+\t* fix-header.c (recognized_function): Similarly.\n+\t* cpplib.h (NODE_LEN, NODE_NAME): New.\n+\t(cpp_hashnode): Rename length len.\n+\n Wed May 16 13:41:10 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa32-regs.h (HARD_REGNO_MODE_OK): Allow TI/TFmode values in"}, {"sha": "5585a16844de19c594fe6acb4ae523b426483abc", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -347,7 +347,7 @@ cb_undef (pfile, node)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      cpp_hashnode *node;\n {\n-  debug_undef (lineno, (const char *) node->name);\n+  debug_undef (lineno, (const char *) NODE_NAME (node));\n }\n \n /* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence.\n@@ -997,7 +997,7 @@ c_lex (value)\n       goto retry;\n       \n     case CPP_NAME:\n-      *value = get_identifier ((const char *)tok.val.node->name);\n+      *value = get_identifier ((const char *) NODE_NAME (tok.val.node));\n       break;\n \n     case CPP_INT:"}, {"sha": "051551ed231e0898e6822d578e0a08a1d5a84fa6", "filename": "gcc/cppexp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -345,7 +345,7 @@ lex (pfile, skip_evaluation, token)\n \t  if (CPP_PEDANTIC (pfile)\n \t      && ! cpp_defined (pfile, DSC(\"__bool_true_false_are_defined\")))\n \t    cpp_pedwarn (pfile, \"ISO C++ does not permit \\\"%s\\\" in #if\",\n-\t\t\t token->val.node->name);\n+\t\t\t NODE_NAME (token->val.node));\n \t  return op;\n \t}\n       else\n@@ -359,7 +359,8 @@ lex (pfile, skip_evaluation, token)\n \t  op.value = 0;\n \n \t  if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\t    cpp_warning (pfile, \"\\\"%s\\\" is not defined\", token->val.node->name);\n+\t    cpp_warning (pfile, \"\\\"%s\\\" is not defined\",\n+\t\t\t NODE_NAME (token->val.node));\n \t  return op;\n \t}\n "}, {"sha": "a47a635c630b6db2abf1130d341ea10e8d56ede0", "filename": "gcc/cpphash.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -136,8 +136,8 @@ _cpp_lookup_with_hash (pfile, len, hash)\n     {\n       unsigned int hash2;\n \n-      if (entry->hash == hash && entry->length == len\n-\t  && !memcmp (entry->name, name, len))\n+      if (entry->hash == hash && NODE_LEN (entry) == len\n+\t  && !memcmp (NODE_NAME (entry), name, len))\n \treturn entry;\n \n       hash2 = 1 + hash % (size - 2);\n@@ -151,8 +151,8 @@ _cpp_lookup_with_hash (pfile, len, hash)\n \n \t  if (entry == NULL)\n \t    break;\n-\t  if (entry->hash == hash && entry->length == len\n-\t      && !memcmp (entry->name, name, len))\n+\t  if (entry->hash == hash && NODE_LEN (entry) == len\n+\t      && !memcmp (NODE_NAME (entry), name, len))\n \t    return entry;\n \t}\n     }\n@@ -168,9 +168,9 @@ _cpp_lookup_with_hash (pfile, len, hash)\n   entry->flags = 0;\n   entry->directive_index = 0;\n   entry->arg_index = 0;\n-  entry->length = len;\n+  NODE_LEN (entry) = len;\n   entry->hash = hash;\n-  entry->name = name;\n+  NODE_NAME (entry) = name;\n   entry->value.macro = 0;\n \n   pfile->hashtab->nelts++;"}, {"sha": "30f739da66ac41c590c04a3b85cadc7c5a16ebd9", "filename": "gcc/cpplex.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -121,7 +121,7 @@ cpp_ideq (token, string)\n   if (token->type != CPP_NAME)\n     return 0;\n \n-  return !ustrcmp (token->val.node->name, (const U_CHAR *) string);\n+  return !ustrcmp (NODE_NAME (token->val.node), (const U_CHAR *) string);\n }\n \n /* Call when meeting a newline.  Returns the character after the newline\n@@ -535,7 +535,8 @@ parse_identifier (pfile, c)\n     {\n       /* It is allowed to poison the same identifier twice.  */\n       if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n-\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", result->name);\n+\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\",\n+\t\t   NODE_NAME (result));\n \n       /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n \t replacement list of a variadic macro.  */\n@@ -1290,9 +1291,9 @@ cpp_token_len (token)\n \n   switch (TOKEN_SPELL (token))\n     {\n-    default:\t\tlen = 0;\t\t\tbreak;\n-    case SPELL_STRING:\tlen = token->val.str.len;\tbreak;\n-    case SPELL_IDENT:\tlen = token->val.node->length;\tbreak;\n+    default:\t\tlen = 0;\t\t\t\tbreak;\n+    case SPELL_STRING:\tlen = token->val.str.len;\t\tbreak;\n+    case SPELL_IDENT:\tlen = NODE_LEN (token->val.node);\tbreak;\n     }\n   /* 1 for whitespace, 4 for comment delimeters.  */\n   return len + 5;\n@@ -1330,8 +1331,8 @@ cpp_spell_token (pfile, token, buffer)\n \n     case SPELL_IDENT:\n       spell_ident:\n-      memcpy (buffer, token->val.node->name, token->val.node->length);\n-      buffer += token->val.node->length;\n+      memcpy (buffer, NODE_NAME (token->val.node), NODE_LEN (token->val.node));\n+      buffer += NODE_LEN (token->val.node);\n       break;\n \n     case SPELL_STRING:\n@@ -1421,7 +1422,7 @@ cpp_output_token (token, fp)\n \n     spell_ident:\n     case SPELL_IDENT:\n-      ufputs (token->val.node->name, fp);\n+      ufputs (NODE_NAME (token->val.node), fp);\n     break;\n \n     case SPELL_STRING:"}, {"sha": "b5bdd9466007d9ea4d6fe59186b203d76cb4cb1c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -454,7 +454,7 @@ lex_macro_node (pfile)\n       else if (token.flags & NAMED_OP)\n \tcpp_error (pfile,\n \t\t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n-\t\t   token.val.node->name);\n+\t\t   NODE_NAME (token.val.node));\n       else\n \tcpp_error (pfile, \"macro names must be identifiers\");\n     }\n@@ -464,8 +464,9 @@ lex_macro_node (pfile)\n \n       /* In Objective C, some keywords begin with '@', but general\n \t identifiers do not, and you're not allowed to #define them.  */\n-      if (node == pfile->spec_nodes.n_defined || node->name[0] == '@')\n-\tcpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\", node->name);\n+      if (node == pfile->spec_nodes.n_defined || NODE_NAME (node)[0] == '@')\n+\tcpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\",\n+\t\t   NODE_NAME (node));\n       else if (!(node->flags & NODE_POISONED))\n \treturn node;\n     }\n@@ -503,7 +504,7 @@ do_undef (pfile)\n \t(*pfile->cb.undef) (pfile, node);\n \n       if (node->flags & NODE_WARN)\n-\tcpp_warning (pfile, \"undefining \\\"%s\\\"\", node->name);\n+\tcpp_warning (pfile, \"undefining \\\"%s\\\"\", NODE_NAME (node));\n \n       _cpp_free_definition (node);\n     }\n@@ -1031,9 +1032,6 @@ do_pragma (pfile)\n {\n   const struct pragma_entry *p;\n   cpp_token tok;\n-  const cpp_hashnode *node;\n-  const U_CHAR *name;\n-  size_t len;\n   int drop = 0;\n \n   p = pfile->pragmas;\n@@ -1044,9 +1042,10 @@ do_pragma (pfile)\n   cpp_get_token (pfile, &tok);\n   if (tok.type == CPP_NAME)\n     {\n-      node = tok.val.node;\n-      name = node->name;\n-      len = node->length;\n+      const cpp_hashnode *node = tok.val.node;\n+      const U_CHAR *name = NODE_NAME (node);\n+      size_t len = NODE_LEN (node);\n+\n       while (p)\n \t{\n \t  if (strlen (p->name) == len && !memcmp (p->name, name, len))\n@@ -1114,7 +1113,7 @@ do_pragma_poison (pfile)\n \tcontinue;\n \n       if (hp->type == NT_MACRO)\n-\tcpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", hp->name);\n+\tcpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", NODE_NAME (hp));\n       _cpp_free_definition (hp);\n       hp->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n     }\n@@ -1542,12 +1541,12 @@ parse_assertion (pfile, answerp, type)\n     cpp_error (pfile, \"predicate must be an identifier\");\n   else if (parse_answer (pfile, answerp, type) == 0)\n     {\n-      unsigned int len = predicate.val.node->length;\n+      unsigned int len = NODE_LEN (predicate.val.node);\n       unsigned char *sym = alloca (len + 1);\n \n       /* Prefix '#' to get it out of macro namespace.  */\n       sym[0] = '#';\n-      memcpy (sym + 1, predicate.val.node->name, len);\n+      memcpy (sym + 1, NODE_NAME (predicate.val.node), len);\n       result = cpp_lookup (pfile, sym, len + 1);\n     }\n \n@@ -1620,7 +1619,7 @@ do_assert (pfile)\n \t{\n \t  if (*find_answer (node, new_answer))\n \t    {\n-\t      cpp_warning (pfile, \"\\\"%s\\\" re-asserted\", node->name + 1);\n+\t      cpp_warning (pfile, \"\\\"%s\\\" re-asserted\", NODE_NAME (node) + 1);\n \t      return;\n \t    }\n \t  new_answer->next = node->value.answers;"}, {"sha": "7730a24a02a7ad73e31a9901b134fda1bb304f37", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -466,17 +466,14 @@ enum builtin_type\n   BT_STDC\t\t\t/* `__STDC__' */\n };\n \n-/* There is a slot in the hashnode for use by front ends when integrated\n-   with cpplib.  It holds a tree (see tree.h) but we mustn't drag that\n-   header into every user of cpplib.h.  cpplib does not do anything with\n-   this slot except clear it when a new node is created.  */\n-union tree_node;\n+#define NODE_LEN(NODE)\t\t(NODE->len)\n+#define NODE_NAME(NODE)\t\t(NODE->name)\n \n struct cpp_hashnode\n {\n   const unsigned char *name;\t\t/* Null-terminated name.  */\n   unsigned int hash;\t\t\t/* Cached hash value.  */\n-  unsigned short length;\t\t/* Length of name excluding null.  */\n+  unsigned short len;\t\t\t/* Length of name excluding null.  */\n   unsigned short arg_index;\t\t/* Macro argument index.  */\n   unsigned char directive_index;\t/* Index into directive table.  */\n   ENUM_BITFIELD(node_type) type : 8;\t/* Node type.  */"}, {"sha": "1dc902f98b43a6942c1321d591ea5910faa17c22", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -210,7 +210,7 @@ builtin_macro (pfile, token)\n       break;\n \n     default:\n-      cpp_ice (pfile, \"invalid builtin macro \\\"%s\\\"\", node->name);\n+      cpp_ice (pfile, \"invalid builtin macro \\\"%s\\\"\", NODE_NAME (node));\n       break;\n     }\n \n@@ -537,7 +537,7 @@ parse_args (pfile, node)\n   if (type == CPP_EOF)\n     {\n       cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\",\n-\t\t node->name);\n+\t\t NODE_NAME (node));\n       error = 1;\n     }\n   else if (argc < macro->paramc)\n@@ -559,7 +559,7 @@ parse_args (pfile, node)\n \t{\n \t  cpp_error (pfile,\n \t\t     \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n-\t\t     node->name, macro->paramc, argc);\n+\t\t     NODE_NAME (node), macro->paramc, argc);\n \t  error = 1;\n \t}\n     }\n@@ -570,7 +570,7 @@ parse_args (pfile, node)\n \t{\n \t  cpp_error (pfile,\n \t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n-\t\t     node->name, argc, macro->paramc);\n+\t\t     NODE_NAME (node), argc, macro->paramc);\n \t  error = 1;\n \t}\n     }\n@@ -610,7 +610,7 @@ funlike_invocation_p (pfile, node, list)\n   else if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n     cpp_warning (pfile,\n \t \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n-\t\t node->name);\n+\t\t NODE_NAME (node));\n \n   /* Restore original context.  */\n   pfile->context = orig;\n@@ -1233,7 +1233,7 @@ save_parameter (pfile, macro, node)\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n   if (node->arg_index)\n     {\n-      cpp_error (pfile, \"duplicate macro parameter \\\"%s\\\"\", node->name);\n+      cpp_error (pfile, \"duplicate macro parameter \\\"%s\\\"\", NODE_NAME (node));\n       return 1;\n     }\n \n@@ -1475,7 +1475,7 @@ _cpp_create_definition (pfile, node)\n \t{\n \t  cpp_pedwarn_with_line (pfile, pfile->directive_pos.line,\n \t\t\t\t pfile->directive_pos.col,\n-\t\t\t\t \"\\\"%s\\\" redefined\", node->name);\n+\t\t\t\t \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n \t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n \t    cpp_pedwarn_with_file_and_line (pfile,\n@@ -1489,7 +1489,7 @@ _cpp_create_definition (pfile, node)\n   /* Enter definition in hash table.  */\n   node->type = NT_MACRO;\n   node->value.macro = macro;\n-  if (! ustrncmp (node->name, DSC (\"__STDC_\")))\n+  if (! ustrncmp (NODE_NAME (node), DSC (\"__STDC_\")))\n     node->flags |= NODE_WARN;\n \n  cleanup:\n@@ -1536,11 +1536,11 @@ check_trad_stringification (pfile, macro, string)\n \t{\n \t  const cpp_hashnode *node = macro->params[i];\n \n-\t  if (node->length == len && !memcmp (p, node->name, len))\n+\t  if (NODE_LEN (node) == len && !memcmp (p, NODE_NAME (node), len))\n \t    {\n \t      cpp_warning (pfile,\n \t   \"macro argument \\\"%s\\\" would be stringified with -traditional.\",\n-\t\t\t   node->name);\n+\t\t\t   NODE_NAME (node));\n \t      break;\n \t    }\n \t}\n@@ -1573,15 +1573,15 @@ cpp_macro_definition (pfile, node)\n     {\n       len += 3;\t\t/* \"()\" plus possible final \".\" of ellipsis.  */\n       for (i = 0; i < macro->paramc; i++)\n-\tlen += macro->params[i]->length + 2; /* \", \" */\n+\tlen += NODE_LEN (macro->params[i]) + 2; /* \", \" */\n     }\n \n   for (i = 0; i < macro->count; i++)\n     {\n       cpp_token *token = &macro->expansion[i];\n \n       if (token->type == CPP_MACRO_ARG)\n-\tlen += macro->params[token->val.arg_no - 1]->length;\n+\tlen += NODE_LEN (macro->params[token->val.arg_no - 1]);\n       else\n \tlen += cpp_token_len (token); /* Includes room for ' '.  */\n       if (token->flags & STRINGIFY_ARG)\n@@ -1607,8 +1607,8 @@ cpp_macro_definition (pfile, node)\n \n \t  if (param != pfile->spec_nodes.n__VA_ARGS__)\n \t    {\n-\t      memcpy (buffer, param->name, param->length);\n-\t      buffer += param->length;\n+\t      memcpy (buffer, NODE_NAME (param), NODE_LEN (param));\n+\t      buffer += NODE_LEN (param);\n \t    }\n \n \t  if (i + 1 < macro->paramc)\n@@ -1634,8 +1634,9 @@ cpp_macro_definition (pfile, node)\n \n \t  if (token->type == CPP_MACRO_ARG)\n \t    {\n-\t      len = macro->params[token->val.arg_no - 1]->length;\n-\t      memcpy (buffer, macro->params[token->val.arg_no - 1]->name, len);\n+\t      len = NODE_LEN (macro->params[token->val.arg_no - 1]);\n+\t      memcpy (buffer,\n+\t\t      NODE_NAME (macro->params[token->val.arg_no - 1]), len);\n \t      buffer += len;\n \t    }\n \t  else"}, {"sha": "0ae2c676cd725b09135b1b5da52c28985cf7295d", "filename": "gcc/cppmain.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -364,7 +364,7 @@ cb_define (pfile, node)\n      cpp_hashnode *node;\n {\n   maybe_print_line (cpp_get_line (pfile)->output_line);\n-  fprintf (print.outf, \"#define %s\", node->name);\n+  fprintf (print.outf, \"#define %s\", NODE_NAME (node));\n \n   /* -dD command line option.  */\n   if (options->dump_macros == dump_definitions)\n@@ -380,7 +380,7 @@ cb_undef (pfile, node)\n      cpp_hashnode *node;\n {\n   maybe_print_line (cpp_get_line (pfile)->output_line);\n-  fprintf (print.outf, \"#undef %s\\n\", node->name);\n+  fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n   print.lineno++;\n }\n \n@@ -446,7 +446,7 @@ dump_macro (pfile, node, v)\n {\n   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {\n-      fprintf (print.outf, \"#define %s\", node->name);\n+      fprintf (print.outf, \"#define %s\", NODE_NAME (node));\n       fputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n       putc ('\\n', print.outf);\n       print.lineno++;"}, {"sha": "d2e7f788a34236fd2d8303733577f320fec5f187", "filename": "gcc/fix-header.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a28c50359bbec52be630d0ecb8918ae00e2e6509/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=a28c50359bbec52be630d0ecb8918ae00e2e6509", "patch": "@@ -532,8 +532,8 @@ recognized_function (fname, line, kind, have_arg_list)\n     missing_extern_C_count++;\n #endif\n \n-  fn = lookup_std_proto ((const char *)fname->val.node->name,\n-\t\t\t fname->val.node->length);\n+  fn = lookup_std_proto ((const char *) NODE_NAME (fname->val.node),\n+\t\t\t NODE_LEN (fname->val.node));\n \n   /* Remove the function from the list of required function.  */\n   if (fn)"}]}