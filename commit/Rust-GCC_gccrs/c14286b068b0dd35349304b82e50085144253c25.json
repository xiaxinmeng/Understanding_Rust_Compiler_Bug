{"sha": "c14286b068b0dd35349304b82e50085144253c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE0Mjg2YjA2OGIwZGQzNTM0OTMwNGI4MmU1MDA4NTE0NDI1M2MyNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-04T01:20:04Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-04T01:20:04Z"}, "message": "[multiple changes]\n\n\n2000-07-03  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\t* bits/std_memory.h: Revert.\n\n2000-07-03  Brendan Kehoe  <brendan@zen.org>\n\n\t* bits/std_complex.h: Fix parens. Format.\n\nFrom-SVN: r34857", "tree": {"sha": "e715952c506175ef343b06d2784538b4da993895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e715952c506175ef343b06d2784538b4da993895"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c14286b068b0dd35349304b82e50085144253c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14286b068b0dd35349304b82e50085144253c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14286b068b0dd35349304b82e50085144253c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14286b068b0dd35349304b82e50085144253c25/comments", "author": null, "committer": null, "parents": [{"sha": "18fa319d7bcfcad9b2d783c069d660d5b6e44f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fa319d7bcfcad9b2d783c069d660d5b6e44f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fa319d7bcfcad9b2d783c069d660d5b6e44f03"}], "stats": {"total": 1311, "additions": 657, "deletions": 654}, "files": [{"sha": "f7f65d0ba37d35a6bae7d00ae84c1ede00df1ccc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14286b068b0dd35349304b82e50085144253c25/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14286b068b0dd35349304b82e50085144253c25/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c14286b068b0dd35349304b82e50085144253c25", "patch": "@@ -1,3 +1,11 @@\n+2000-07-03  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\n+\t* bits/std_memory.h: Revert.\n+\n+2000-07-03  Brendan Kehoe  <brendan@zen.org>\n+\n+\t* bits/std_complex.h: Fix parens. Format.\n+\t\n 2000-07-01  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \t    Ulrich Drepper  <drepper@purist.soma.redhat.com>\n "}, {"sha": "63f735181daf8ba6496b5f46aec024a87f33db55", "filename": "libstdc++-v3/bits/std_complex.h", "status": "modified", "additions": 649, "deletions": 654, "changes": 1303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14286b068b0dd35349304b82e50085144253c25/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14286b068b0dd35349304b82e50085144253c25/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_complex.h?ref=c14286b068b0dd35349304b82e50085144253c25", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- complex number classes.\n \n-// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -40,904 +40,897 @@\n #include <bits/c++config.h>\n #include <bits/std_iosfwd.h>\n \n-\n namespace std\n {\n-    // Forward declarations\n-    template<typename _Tp> class complex;\n-    template<> class complex<float>;\n-    template<> class complex<double>;\n-    template<> class complex<long double>;\n \n-    template<typename _Tp> _Tp abs(const complex<_Tp>&);\n-    template<typename _Tp>  _Tp arg(const complex<_Tp>&);\n+  // Forward declarations\n+  template<typename _Tp> class complex;\n+  template<> class complex<float>;\n+  template<> class complex<double>;\n+  template<> class complex<long double>;\n+\n+  template<typename _Tp> _Tp abs(const complex<_Tp>&);\n+  template<typename _Tp>  _Tp arg(const complex<_Tp>&);\n \n-    template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp&);\n+  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp&);\n \n     // Transcendentals:\n-    template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n-    template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n-    template<typename _Tp> complex<_Tp> pow (const complex<_Tp>&,\n-                                             const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);\n-    template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n+  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n+  template<typename _Tp> complex<_Tp> pow (const complex<_Tp>&,\n+\t\t\t\t\t   const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n     \n     \n-    //\n-    // 26.2.2  Primary template class complex\n-    //\n-    template <typename _Tp>\n+  //\n+  // 26.2.2  Primary template class complex\n+  //\n+  template <typename _Tp>\n     class complex\n     {\n     public:\n-        typedef _Tp value_type;\n-\n-        complex (const _Tp& = _Tp(), const _Tp & = _Tp());\n-\n-        // Let's the compiler synthetize the copy constructor   \n-        // complex (const complex<_Tp>&);\n-\n-        template <typename _Up>\n-           complex (const complex<_Up>&);\n+      typedef _Tp value_type;\n+      \n+      complex(const _Tp& = _Tp(), const _Tp & = _Tp());\n+\n+      // Let's the compiler synthetize the copy constructor   \n+      // complex (const complex<_Tp>&);\n+      template <typename _Up>\n+        complex(const complex<_Up>&);\n         \n-        _Tp real () const;\n-        _Tp imag () const;\n-\n-        complex<_Tp>& operator= (const _Tp&);\n-        complex<_Tp>& operator+= (const _Tp&);\n-        complex<_Tp>& operator-= (const _Tp&);\n-        complex<_Tp>& operator*= (const _Tp&);\n-        complex<_Tp>& operator/= (const _Tp&);\n-\n-        // Let's the compiler synthetize the\n-        // copy and assignment operator\n-        // complex<_Tp>& operator= (const complex<_Tp>&);\n-\n-        template <typename _Up>\n-           complex<_Tp>& operator= (const complex<_Up>&);\n-        template <typename _Up>\n-           complex<_Tp>& operator+= (const complex<_Up>&);\n-        template <typename _Up>\n-           complex<_Tp>& operator-= (const complex<_Up>&);\n-        template <typename _Up>\n-           complex<_Tp>& operator*= (const complex<_Up>&);\n-        template <typename _Up>\n-           complex<_Tp>& operator/= (const complex<_Up>&);\n+      _Tp real() const;\n+      _Tp imag() const;\n+\n+      complex<_Tp>& operator=(const _Tp&);\n+      complex<_Tp>& operator+=(const _Tp&);\n+      complex<_Tp>& operator-=(const _Tp&);\n+      complex<_Tp>& operator*=(const _Tp&);\n+      complex<_Tp>& operator/=(const _Tp&);\n+\n+      // Let's the compiler synthetize the\n+      // copy and assignment operator\n+      // complex<_Tp>& operator= (const complex<_Tp>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator+=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator-=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator*=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator/=(const complex<_Up>&);\n \n     private:\n-        _Tp _M_real, _M_imag;\n+      _Tp _M_real, _M_imag;\n     };\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline _Tp\n     complex<_Tp>::real() const { return _M_real; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline _Tp\n     complex<_Tp>::imag() const { return _M_imag; }\n \n     \n-    //\n-    // 26.2.3  complex specializations\n-    //\n-\n-    //\n-    // complex<float> specialization\n-    //\n-    template<> class complex<float>\n-    {\n-    public:\n-        typedef float value_type;\n-\n-        complex(float = 0.0f, float = 0.0f);\n+  //\n+  // 26.2.3  complex specializations\n+  //\n+\n+  //\n+  // complex<float> specialization\n+  //\n+  template<> class complex<float>\n+  {\n+  public:\n+    typedef float value_type;\n+    \n+    complex(float = 0.0f, float = 0.0f);\n #ifdef _GLIBCPP_BUGGY_COMPLEX\n-\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-        explicit complex(const complex<double>&);\n-        explicit complex(const complex<long double>&);\n+    explicit complex(const complex<double>&);\n+    explicit complex(const complex<long double>&);\n \n-        float real() const;\n-        float imag() const;\n+    float real() const;\n+    float imag() const;\n \n-        complex<float>& operator= (float);\n-        complex<float>& operator+= (float);\n-        complex<float>& operator-= (float);\n-        complex<float>& operator*= (float);\n-        complex<float>& operator/= (float);\n+    complex<float>& operator=(float);\n+    complex<float>& operator+=(float);\n+    complex<float>& operator-=(float);\n+    complex<float>& operator*=(float);\n+    complex<float>& operator/=(float);\n         \n-        // Let's the compiler synthetize the copy and assignment\n-        // operator.  It always does a pretty good job.\n-        // complex& operator= (const complex&);\n-\n-        template <typename _Tp>\n-           complex<float>&operator= (const complex<_Tp>&);\n-        template <typename _Tp>\n-           complex<float>& operator+= (const complex<_Tp>&);\n-        template <class _Tp>\n-           complex<float>& operator-= (const complex<_Tp>&);\n-        template <class _Tp>\n-           complex<float>& operator*= (const complex<_Tp>&);\n-        template <class _Tp>\n-           complex<float>&operator/= (const complex<_Tp>&);\n-\n-    private:\n-        typedef __complex__ float _ComplexT;\n-        _ComplexT _M_value;\n-\n-        complex(_ComplexT __z) : _M_value(__z) {}\n+    // Let's the compiler synthetize the copy and assignment\n+    // operator.  It always does a pretty good job.\n+    // complex& operator= (const complex&);\n+    template <typename _Tp>\n+      complex<float>&operator=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<float>& operator+=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>& operator-=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>& operator*=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>&operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ float _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n         \n-        friend class complex<double>;\n-        friend class complex<long double>;\n-\n-        friend float abs<>(const complex<float>&);\n-        friend float arg<>(const complex<float>&);\n-\n-        friend complex<float> conj<>(const complex<float>&);\n-\n-        friend complex<float> cos<>(const complex<float>&);\n-        friend complex<float> cosh<>(const complex<float>&);\n-        friend complex<float> exp<>(const complex<float>&);\n-        friend complex<float> log<>(const complex<float>&);\n-        friend complex<float> log10<>(const complex<float>&);\n-        friend complex<float> pow<>(const complex<float>&, int);\n-        friend complex<float> pow<>(const complex<float>&, const float&);\n-        friend complex<float> pow<>(const complex<float>&,\n-                                    const complex<float>&);\n-        friend complex<float> pow<>(const float&, const complex<float>&);\n-        friend complex<float> sin<>(const complex<float>&);\n-        friend complex<float> sinh<>(const complex<float>&);\n-        friend complex<float> sqrt<>(const complex<float>&);\n-        friend complex<float> tan<>(const complex<float>&);\n-        friend complex<float> tanh<>(const complex<float>&);\n+    friend class complex<double>;\n+    friend class complex<long double>;\n+\n+    friend float abs<>(const complex<float>&);\n+    friend float arg<>(const complex<float>&);\n+\n+    friend complex<float> conj<>(const complex<float>&);\n+\n+    friend complex<float> cos<>(const complex<float>&);\n+    friend complex<float> cosh<>(const complex<float>&);\n+    friend complex<float> exp<>(const complex<float>&);\n+    friend complex<float> log<>(const complex<float>&);\n+    friend complex<float> log10<>(const complex<float>&);\n+    friend complex<float> pow<>(const complex<float>&, int);\n+    friend complex<float> pow<>(const complex<float>&, const float&);\n+    friend complex<float> pow<>(const complex<float>&,\n+\t\t\t\tconst complex<float>&);\n+    friend complex<float> pow<>(const float&, const complex<float>&);\n+    friend complex<float> sin<>(const complex<float>&);\n+    friend complex<float> sinh<>(const complex<float>&);\n+    friend complex<float> sqrt<>(const complex<float>&);\n+    friend complex<float> tan<>(const complex<float>&);\n+    friend complex<float> tanh<>(const complex<float>&);\n   };\n \n-    inline float\n-    complex<float>::real() const\n-    { return __real__ _M_value; }\n+  inline float\n+  complex<float>::real() const\n+  { return __real__ _M_value; }\n \n-    inline float\n-    complex<float>::imag() const\n-    { return __imag__ _M_value; }\n+  inline float\n+  complex<float>::imag() const\n+  { return __imag__ _M_value; }\n \n \n-    //\n-    // complex<double> specialization\n-    //\n-    template<> class complex<double>\n-    {\n-    public:\n-        typedef double value_type;\n+  //\n+  // complex<double> specialization\n+  //\n+  template<> class complex<double>\n+  {\n+  public:\n+    typedef double value_type;\n \n-        complex(double  =0.0, double =0.0);\n+    complex(double  =0.0, double =0.0);\n #ifdef _GLIBCPP_BUGGY_COMPLEX\n-\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-        complex(const complex<float>&);\n-        explicit complex(const complex<long double>&);\n+    complex(const complex<float>&);\n+    explicit complex(const complex<long double>&);\n         \n-        double real () const;\n-        double imag () const;\n+    double real() const;\n+    double imag() const;\n         \n-        complex<double>& operator= (double);\n-        complex<double>& operator+= (double);\n-        complex<double>& operator-= (double);\n-        complex<double>& operator*= (double);\n-        complex<double>& operator/= (double);\n-\n-        // The compiler will synthetize this, efficiently.\n-        // complex& operator= (const complex&);\n-\n-        template <typename _Tp>\n-           complex<double>& operator= (const complex<_Tp>&);\n-        template <typename _Tp>\n-           complex<double>& operator+= (const complex<_Tp>&);\n-        template <typename _Tp>\n-           complex<double>& operator-= (const complex<_Tp>&);\n-        template <typename _Tp>\n-           complex<double>& operator*= (const complex<_Tp>&);\n-        template <typename _Tp>\n-        complex<double>& operator/= (const complex<_Tp>&);\n+    complex<double>& operator=(double);\n+    complex<double>& operator+=(double);\n+    complex<double>& operator-=(double);\n+    complex<double>& operator*=(double);\n+    complex<double>& operator/=(double);\n+\n+    // The compiler will synthetize this, efficiently.\n+    // complex& operator= (const complex&);\n+    template <typename _Tp>\n+      complex<double>& operator=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator+=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator-=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator*=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator/=(const complex<_Tp>&);\n \n-    private:\n-        typedef __complex__ double _ComplexT;\n-        _ComplexT _M_value;\n+  private:\n+    typedef __complex__ double _ComplexT;\n+    _ComplexT _M_value;\n \n-        complex(_ComplexT __z) : _M_value(__z) {}\n+    complex(_ComplexT __z) : _M_value(__z) { }\n         \n-        friend class complex<float>;\n-        friend class complex<long double>;\n-\n-        friend double abs<>(const complex<double>&);\n-        friend double arg<>(const complex<double>&);\n-\n-        friend complex<double> conj<>(const complex<double>&);\n-\n-        friend complex<double> cos<>(const complex<double>&);\n-        friend complex<double> cosh<>(const complex<double>&);\n-        friend complex<double> exp<>(const complex<double>&);\n-        friend complex<double> log<>(const complex<double>&);\n-        friend complex<double> log10<>(const complex<double>&);\n-        friend complex<double> pow<>(const complex<double>&, int);\n-        friend complex<double> pow<>(const complex<double>&, const double&);\n-        friend complex<double> pow<>(const complex<double>&,\n-                                    const complex<double>&);\n-        friend complex<double> pow<>(const double&, const complex<double>&);\n-        friend complex<double> sin<>(const complex<double>&);\n-        friend complex<double> sinh<>(const complex<double>&);\n-        friend complex<double> sqrt<>(const complex<double>&);\n-        friend complex<double> tan<>(const complex<double>&);\n-        friend complex<double> tanh<>(const complex<double>&);\n-    };\n+    friend class complex<float>;\n+    friend class complex<long double>;\n+\n+    friend double abs<>(const complex<double>&);\n+    friend double arg<>(const complex<double>&);\n+\n+    friend complex<double> conj<>(const complex<double>&);\n+    friend complex<double> cos<>(const complex<double>&);\n+    friend complex<double> cosh<>(const complex<double>&);\n+    friend complex<double> exp<>(const complex<double>&);\n+    friend complex<double> log<>(const complex<double>&);\n+    friend complex<double> log10<>(const complex<double>&);\n+    friend complex<double> pow<>(const complex<double>&, int);\n+    friend complex<double> pow<>(const complex<double>&, const double&);\n+    friend complex<double> pow<>(const complex<double>&,\n+\t\t\t\t const complex<double>&);\n+    friend complex<double> pow<>(const double&, const complex<double>&);\n+    friend complex<double> sin<>(const complex<double>&);\n+    friend complex<double> sinh<>(const complex<double>&);\n+    friend complex<double> sqrt<>(const complex<double>&);\n+    friend complex<double> tan<>(const complex<double>&);\n+    friend complex<double> tanh<>(const complex<double>&);\n+  };\n \n-    inline double\n-    complex<double>::real() const\n-    { return __real__ _M_value; }\n+  inline double\n+  complex<double>::real() const\n+  { return __real__ _M_value; }\n \n-    inline double\n-    complex<double>::imag() const\n-    { return __imag__ _M_value; }\n+  inline double\n+  complex<double>::imag() const\n+  { return __imag__ _M_value; }\n \n \n-    //\n-    // complex<long double> specialization\n-    //\n-    template<> class complex<long double>\n-    {\n-    public:\n-        typedef long double value_type;\n+  //\n+  // complex<long double> specialization\n+  //\n+  template<> class complex<long double>\n+  {\n+  public:\n+    typedef long double value_type;\n \n-        complex(long double = 0.0L, long double = 0.0L);\n+    complex(long double = 0.0L, long double = 0.0L);\n #ifdef _GLIBCPP_BUGGY_COMPLEX\n-\tcomplex(const complex& __z) : _M_value(__z._M_value) {}\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n #endif\n-        complex(const complex<float>&);\n-        complex(const complex<double>&);\n-\n-        long double real() const;\n-        long double imag() const;\n-\n-        complex<long double>& operator= (long double);\n-        complex<long double>& operator+= (long double);\n-        complex<long double>& operator-= (long double);\n-        complex<long double>& operator*= (long double);\n-        complex<long double>& operator/= (long double);\n-\n-        // The compiler knows how to do this efficiently\n-        // complex& operator= (const complex&);\n-\n-        template<typename _Tp>\n-           complex<long double>& operator= (const complex<_Tp>&);\n-        template<typename _Tp>\n-           complex<long double>& operator+= (const complex<_Tp>&);\n-        template<typename _Tp>\n-           complex<long double>& operator-= (const complex<_Tp>&);\n-        template<typename _Tp>\n-           complex<long double>& operator*= (const complex<_Tp>&);\n-        template<typename _Tp>\n-        complex<long double>& operator/= (const complex<_Tp>&);\n+    complex(const complex<float>&);\n+    complex(const complex<double>&);\n \n-    private:\n-        typedef __complex__ long double _ComplexT;\n-        _ComplexT _M_value;\n-\n-        complex(_ComplexT __z) : _M_value(__z) {}\n-\n-        friend class complex<float>;\n-        friend class complex<double>;\n-\n-        friend long double abs<>(const complex<long double>&);\n-        friend long double arg<>(const complex<long double>&);\n-\n-        friend complex<long double> conj<>(const complex<long double>&);\n-\n-        friend complex<long double> cos<>(const complex<long double>&);\n-        friend complex<long double> cosh<>(const complex<long double>&);\n-        friend complex<long double> exp<>(const complex<long double>&);\n-        friend complex<long double> log<>(const complex<long double>&);\n-        friend complex<long double> log10<>(const complex<long double>&);\n-        friend complex<long double> pow<>(const complex<long double>&, int);\n-        friend complex<long double> pow<>(const complex<long double>&,\n-                                          const long double&);\n-        friend complex<long double> pow<>(const complex<long double>&,\n-                                    const complex<long double>&);\n-        friend complex<long double> pow<>(const long double&,\n-                                          const complex<long double>&);\n-        friend complex<long double> sin<>(const complex<long double>&);\n-        friend complex<long double> sinh<>(const complex<long double>&);\n-        friend complex<long double> sqrt<>(const complex<long double>&);\n-        friend complex<long double> tan<>(const complex<long double>&);\n-        friend complex<long double> tanh<>(const complex<long double>&);\n-    };\n+    long double real() const;\n+    long double imag() const;\n \n-    inline\n-    complex<long double>::complex(long double __r, long double __i)\n-    {\n-        __real__ _M_value = __r;\n-        __imag__ _M_value = __i;\n-    }\n+    complex<long double>& operator= (long double);\n+    complex<long double>& operator+= (long double);\n+    complex<long double>& operator-= (long double);\n+    complex<long double>& operator*= (long double);\n+    complex<long double>& operator/= (long double);\n \n-    inline\n-    complex<long double>::complex(const complex<float>& __z)\n-            : _M_value(_ComplexT(__z._M_value)) {}\n+    // The compiler knows how to do this efficiently\n+    // complex& operator= (const complex&);\n \n-    inline\n-    complex<long double>::complex(const complex<double>& __z)\n-            : _M_value(_ComplexT(__z._M_value)) {}\n+    template<typename _Tp>\n+      complex<long double>& operator=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator+=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator-=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator*=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator/=(const complex<_Tp>&);\n \n-    inline long double\n-    complex<long double>::real() const\n-    { return __real__ _M_value; }\n+  private:\n+    typedef __complex__ long double _ComplexT;\n+    _ComplexT _M_value;\n \n-    inline long double\n-    complex<long double>::imag() const\n-    { return __imag__ _M_value; }\n+    complex(_ComplexT __z) : _M_value(__z) { }\n \n-    inline complex<long double>&\n-    complex<long double>::operator= (long double __r)\n-    {\n-        __real__ _M_value = __r;\n-        __imag__ _M_value = 0.0L;\n-        return *this;\n-    }\n+    friend class complex<float>;\n+    friend class complex<double>;\n \n-    inline complex<long double>&\n-    complex<long double>::operator+= (long double __r)\n-    {\n-        __real__ _M_value += __r;\n-        return *this;\n-    }\n+    friend long double abs<>(const complex<long double>&);\n+    friend long double arg<>(const complex<long double>&);\n \n-    inline complex<long double>&\n-    complex<long double>::operator-= (long double __r)\n-    {\n-        __real__ _M_value -= __r;\n-        return *this;\n-    }\n-\n-    inline complex<long double>&\n-    complex<long double>::operator*= (long double __r)\n-    {\n-        __real__ _M_value *= __r;\n-        return *this;\n-    }\n+    friend complex<long double> conj<>(const complex<long double>&);\n+    friend complex<long double> cos<>(const complex<long double>&);\n+    friend complex<long double> cosh<>(const complex<long double>&);\n+    friend complex<long double> exp<>(const complex<long double>&);\n+    friend complex<long double> log<>(const complex<long double>&);\n+    friend complex<long double> log10<>(const complex<long double>&);\n+    friend complex<long double> pow<>(const complex<long double>&, int);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const long double&);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> pow<>(const long double&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> sin<>(const complex<long double>&);\n+    friend complex<long double> sinh<>(const complex<long double>&);\n+    friend complex<long double> sqrt<>(const complex<long double>&);\n+    friend complex<long double> tan<>(const complex<long double>&);\n+    friend complex<long double> tanh<>(const complex<long double>&);\n+  };\n \n+  inline\n+  complex<long double>::complex(long double __r, long double __i)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = __i;\n+  }\n+\n+  inline\n+  complex<long double>::complex(const complex<float>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<long double>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline long double\n+  complex<long double>::real() const\n+  { return __real__ _M_value; }\n+\n+  inline long double\n+  complex<long double>::imag() const\n+  { return __imag__ _M_value; }\n+\n+  inline complex<long double>&   \n+  complex<long double>::operator=(long double __r)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = 0.0L;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator+=(long double __r)\n+  {\n+    __real__ _M_value += __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator-=(long double __r)\n+  {\n+    __real__ _M_value -= __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator*=(long double __r)\n+  {\n+    __real__ _M_value *= __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator/=(long double __r)\n+  {\n+    __real__ _M_value /= __r;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n     inline complex<long double>&\n-    complex<long double>::operator/= (long double __r)\n+    complex<long double>::operator=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value /= __r;\n-        return *this;\n+      __real__ _M_value = __z.real();\n+      __imag__ _M_value = __z.imag();\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<long double>&\n-    complex<long double>::operator= (const complex<_Tp>& __z)\n+    complex<long double>::operator+=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value = __z.real();\n-        __imag__ _M_value = __z.imag();\n-        return *this;\n+      __real__ _M_value += __z.real();\n+      __imag__ _M_value += __z.imag();\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<long double>&\n-    complex<long double>::operator+= (const complex<_Tp>& __z)\n+    complex<long double>::operator-=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value += __z.real();\n-        __imag__ _M_value += __z.imag();\n-        return *this;\n-    }\n-\n-    template<typename _Tp>\n-    inline complex<long double>&\n-    complex<long double>::operator-= (const complex<_Tp>& __z)\n-    {\n-        __real__ _M_value -= __z.real();\n-        __imag__ _M_value -= __z.imag();\n-        return *this;\n+      __real__ _M_value -= __z.real();\n+      __imag__ _M_value -= __z.imag();\n+      return *this;\n     }\n     \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<long double>&\n-    complex<long double>::operator*= (const complex<_Tp>& __z)\n+    complex<long double>::operator*=(const complex<_Tp>& __z)\n     {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value *= __t;\n-        return *this;\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<long double>&\n-    complex<long double>::operator/= (const complex<_Tp>& __z)\n-    {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value /= __t;\n-        return *this;\n-    }\n-\n-    //\n-    // complex<float> continued.\n-    //\n-    inline\n-    complex<float>::complex(float r, float i)\n-    {\n-        __real__ _M_value = r;\n-        __imag__ _M_value = i;\n-    }\n-\n-    inline\n-    complex<float>::complex(const complex<double>& __z)\n-            : _M_value(_ComplexT(__z._M_value)) {}\n-\n-    inline\n-    complex<float>::complex(const complex<long double>& __z)\n-            : _M_value(_ComplexT(__z._M_value)) {}\n-\n-    inline complex<float>&\n-    complex<float>::operator= (float __f)\n-    {\n-        __real__ _M_value = __f;\n-        __imag__ _M_value = 0.0f;\n-        return *this;\n-    }\n-\n-    inline complex<float>&\n-    complex<float>::operator+= (float __f)\n-    {\n-        __real__ _M_value += __f;\n-        return *this;\n-    }\n-\n-    inline complex<float>&\n-    complex<float>::operator-= (float __f)\n-    {\n-        __real__ _M_value -= __f;\n-        return *this;\n-    }\n-\n-    inline complex<float>&\n-    complex<float>::operator*= (float __f)\n-    {\n-        _M_value *= __f;\n-        return *this;\n-    }\n-\n-    inline complex<float>&\n-    complex<float>::operator/= (float __f)\n-    {\n-        _M_value /= __f;\n-        return *this;\n-    }\n-\n-    template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator= (const complex<_Tp>& __z)\n-    {\n-        __real__ _M_value = __z.real();\n-        __imag__ _M_value = __z.imag();\n-        return *this;\n-    }\n-\n-    template<typename _Tp>\n-    inline complex<float>&\n-    complex<float>::operator+= (const complex<_Tp>& __z)\n-    {\n-        __real__ _M_value += __z.real();\n-        __imag__ _M_value += __z.imag();\n-        return *this;\n-    }\n+    complex<long double>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+  //\n+  // complex<float> continued.\n+  //\n+  inline\n+  complex<float>::complex(float r, float i)\n+  {\n+    __real__ _M_value = r;\n+    __imag__ _M_value = i;\n+  }\n+\n+  inline\n+  complex<float>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<float>::complex(const complex<long double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline complex<float>&\n+  complex<float>::operator=(float __f)\n+  {\n+    __real__ _M_value = __f;\n+    __imag__ _M_value = 0.0f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator+=(float __f)\n+  {\n+    __real__ _M_value += __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator-=(float __f)\n+  {\n+    __real__ _M_value -= __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator*=(float __f)\n+  {\n+    _M_value *= __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator/=(float __f)\n+  {\n+    _M_value /= __f;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+  inline complex<float>&\n+  complex<float>::operator=(const complex<_Tp>& __z)\n+  {\n+    __real__ _M_value = __z.real();\n+    __imag__ _M_value = __z.imag();\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+  inline complex<float>&\n+  complex<float>::operator+=(const complex<_Tp>& __z)\n+  {\n+    __real__ _M_value += __z.real();\n+    __imag__ _M_value += __z.imag();\n+    return *this;\n+  }\n     \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<float>&\n-    complex<float>::operator-= (const complex<_Tp>& __z)\n+    complex<float>::operator-=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value -= __z.real();\n-        __imag__ _M_value -= __z.real();\n-        return *this;\n-    }\n+     __real__ _M_value -= __z.real();\n+     __imag__ _M_value -= __z.real();\n+     return *this;\n+    } \n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<float>&\n-    complex<float>::operator*= (const complex<_Tp>& __z)\n+    complex<float>::operator*=(const complex<_Tp>& __z)\n     {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value *= __t;\n-        return *this;\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<float>&\n-    complex<float>::operator/= (const complex<_Tp>& __z)\n-    {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value /= __t;\n-        return *this;\n-    }\n-\n-\n-    //\n-    // complex<double> continued.\n-    //\n-    inline\n-    complex<double>::complex(double __r, double __i)\n-    {\n-        __real__ _M_value = __r;\n-        __imag__ _M_value = __i;\n-    }\n-\n-    inline\n-    complex<double>::complex(const complex<float>& __z)\n-            : _M_value(_ComplexT(__z._M_value)) {}\n-\n-    inline\n-    complex<double>::complex(const complex<long double>& __z)\n-    {\n-        __real__ _M_value = __z.real();\n-        __imag__ _M_value = __z.imag();\n-    }\n-\n-    inline complex<double>&\n-    complex<double>::operator= (double __d)\n-    {\n-        __real__ _M_value = __d;\n-        __imag__ _M_value = 0.0;\n-        return *this;\n-    }\n-\n-    inline complex<double>&\n-    complex<double>::operator+= (double __d)\n-    {\n-        __real__ _M_value += __d;\n-        return *this;\n-    }\n-\n-    inline complex<double>&\n-    complex<double>::operator-= (double __d)\n-    {\n-        __real__ _M_value -= __d;\n-        return *this;\n-    }\n-\n+    complex<float>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+\n+  //\n+  // complex<double> continued.\n+  //\n+  inline\n+  complex<double>::complex(double __r, double __i)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = __i;\n+  }\n+\n+  inline\n+  complex<double>::complex(const complex<float>& __z) \n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<double>::complex(const complex<long double>& __z)\n+  {\n+    __real__ _M_value = __z.real();\n+    __imag__ _M_value = __z.imag();\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator=(double __d)\n+  {\n+    __real__ _M_value = __d;\n+    __imag__ _M_value = 0.0;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator+=(double __d)\n+  {\n+    __real__ _M_value += __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator-=(double __d)\n+  {\n+    __real__ _M_value -= __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator*=(double __d)\n+  {\n+    _M_value *= __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator/=(double __d)\n+  {\n+    _M_value /= __d;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n     inline complex<double>&\n-    complex<double>::operator*= (double __d)\n+    complex<double>::operator=(const complex<_Tp>& __z)\n     {\n-        _M_value *= __d;\n-        return *this;\n-    }\n-\n-    inline complex<double>&\n-    complex<double>::operator/= (double __d)\n-    {\n-        _M_value /= __d;\n-        return *this;\n-    }\n-\n-    template<typename _Tp>\n-    inline complex<double>&\n-    complex<double>::operator= (const complex<_Tp>& __z)\n-    {\n-        __real__ _M_value = __z.real();\n-        __imag__ _M_value = __z.imag();\n-        return *this;\n+      __real__ _M_value = __z.real();\n+      __imag__ _M_value = __z.imag();\n+      return *this;\n     }\n     \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<double>&\n-    complex<double>::operator+= (const complex<_Tp>& __z)\n+    complex<double>::operator+=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value += __z.real();\n-        __imag__ _M_value += __z.imag();\n-        return *this;\n+      __real__ _M_value += __z.real();\n+      __imag__ _M_value += __z.imag();\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<double>&\n-    complex<double>::operator-= (const complex<_Tp>& __z)\n+    complex<double>::operator-=(const complex<_Tp>& __z)\n     {\n-        __real__ _M_value -= __z.real();\n-        __imag__ _M_value -= __z.imag();\n-        return *this;\n+      __real__ _M_value -= __z.real();\n+      __imag__ _M_value -= __z.imag();\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<double>&\n-    complex<double>::operator*= (const complex<_Tp>& __z)\n+    complex<double>::operator*=(const complex<_Tp>& __z)\n     {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value *= __t;\n-        return *this;\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n     }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<double>&\n-    complex<double>::operator/= (const complex<_Tp>& __z)\n+    complex<double>::operator/=(const complex<_Tp>& __z)\n     {\n-        _ComplexT __t;\n-        __real__ __t = __z.real();\n-        __imag__ __t = __z.imag();\n-        _M_value /= __t;\n-        return *this;\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n     }\n \n-    //\n-    // Primary template class complex continued.\n-    //\n-    // 26.2.4\n-    template<typename _Tp>\n+  //\n+  // Primary template class complex continued.\n+  //\n+  // 26.2.4\n+  template<typename _Tp>\n     inline \n     complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n-            : _M_real(__r), _M_imag(__i) {}\n+    : _M_real(__r), _M_imag(__i) { }\n \n-    template<typename _Tp>\n-       template<typename _Up>\n+  template<typename _Tp>\n+    template<typename _Up>\n     inline \n     complex<_Tp>::complex(const complex<_Up>& __z)\n-            : _M_real(__z.real()), _M_imag(__z.imag()) {}\n+    : _M_real(__z.real()), _M_imag(__z.imag()) { }\n \n-    // 26.2.7/6\n-    template<typename _Tp>\n+  // 26.2.7/6\n+  template<typename _Tp>\n     inline complex<_Tp>\n     conj(const complex<_Tp>& __z)\n     { return complex<_Tp>(__z.real(), -__z.imag()); }\n \n-    // 26.2.7/4\n-    template<typename _Tp>\n+  // 26.2.7/4\n+  template<typename _Tp>\n     inline _Tp\n     norm(const complex<_Tp>& __z)\n     {\n-        // XXX: Grammar school computation\n-        return __z.real() * __z.real() + __z.imag() * __z.imag();\n+      // XXX: Grammar school computation\n+      return __z.real() * __z.real() + __z.imag() * __z.imag();\n     }\n         \n-    template<typename _Tp>\n+  template<typename _Tp>\n     complex<_Tp>&\n-    complex<_Tp>::operator= (const _Tp& __t)\n+    complex<_Tp>::operator=(const _Tp& __t)\n     {\n-        _M_real = __t;\n-        _M_imag = _Tp();\n-        return *this;\n-    }\n+     _M_real = __t;\n+     _M_imag = _Tp();\n+     return *this;\n+    } \n \n-    // 26.2.5/1\n-    template<typename _Tp>\n+  // 26.2.5/1\n+  template<typename _Tp>\n     inline complex<_Tp>&\n-    complex<_Tp>::operator+= (const _Tp& __t)\n+    complex<_Tp>::operator+=(const _Tp& __t)\n     {\n-        _M_real += __t;\n-        return *this;\n+      _M_real += __t;\n+      return *this;\n     }\n \n-    // 26.2.5/3\n-    template<typename _Tp>\n+  // 26.2.5/3\n+  template<typename _Tp>\n     inline complex<_Tp>&\n-    complex<_Tp>::operator-= (const _Tp& __t)\n+    complex<_Tp>::operator-=(const _Tp& __t)\n     {\n-        _M_real -= __t;\n-        return *this;\n+      _M_real -= __t;\n+      return *this;\n     }\n \n-    // 26.2.5/5\n-    template<typename _Tp>\n+  // 26.2.5/5\n+  template<typename _Tp>\n     complex<_Tp>&\n-    complex<_Tp>::operator*= (const _Tp& __t)\n+    complex<_Tp>::operator*=(const _Tp& __t)\n     {\n-        _M_real *= __t;\n-        _M_imag *= __t;\n-        return *this;\n+      _M_real *= __t;\n+      _M_imag *= __t;\n+      return *this;\n     }\n \n-    // 26.2.5/7\n-    template<typename _Tp>\n+  // 26.2.5/7\n+  template<typename _Tp>\n     complex<_Tp>&\n-    complex<_Tp>::operator/= (const _Tp& __t)\n+    complex<_Tp>::operator/=(const _Tp& __t)\n     {\n-        _M_real /= __t;\n-        _M_imag /= __t;\n-        return *this;\n+      _M_real /= __t;\n+      _M_imag /= __t;\n+      return *this;\n     }\n \n-    template<typename _Tp>\n-       template<typename _Up>\n+  template<typename _Tp>\n+    template<typename _Up>\n     complex<_Tp>&\n-    complex<_Tp>::operator= (const complex<_Up>& __z)\n+    complex<_Tp>::operator=(const complex<_Up>& __z)\n     {\n-        _M_real = __z.real();\n-        _M_imag = __z.imag();\n-        return *this;\n+      _M_real = __z.real();\n+      _M_imag = __z.imag();\n+      return *this;\n     }\n \n-    // 26.2.5/9\n-    template<typename _Tp>\n-       template<typename _Up>\n+  // 26.2.5/9\n+  template<typename _Tp>\n+    template<typename _Up>\n     complex<_Tp>&\n-    complex<_Tp>::operator+= (const complex<_Up>& __z)\n+    complex<_Tp>::operator+=(const complex<_Up>& __z)\n     {\n-        _M_real += __z.real();\n-        _M_imag += __z.imag();\n-        return *this;\n+      _M_real += __z.real();\n+      _M_imag += __z.imag();\n+      return *this;\n     }\n \n-    // 26.2.5/11\n-    template<typename _Tp>\n-       template<typename _Up>\n+  // 26.2.5/11\n+  template<typename _Tp>\n+    template<typename _Up>\n     complex<_Tp>&\n-    complex<_Tp>::operator-= (const complex<_Up>& __z)\n+    complex<_Tp>::operator-=(const complex<_Up>& __z)\n     {\n-        _M_real -= __z.real();\n-        _M_imag -= __z.imag();\n-        return *this;\n+      _M_real -= __z.real();\n+      _M_imag -= __z.imag();\n+      return *this;\n     }\n \n-    // 26.2.5/13\n-    // XXX: this is a grammar school implementation.\n-    template<typename _Tp>\n-       template<typename _Up>\n+  // 26.2.5/13\n+  // XXX: this is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n     complex<_Tp>&\n-    complex<_Tp>::operator*= (const complex<_Up>& __z)\n+    complex<_Tp>::operator*=(const complex<_Up>& __z)\n     {\n-        _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n-        _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n-        _M_real = __r;\n-        return *this;\n+      _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n+      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n+      _M_real = __r;\n+      return *this;\n     }\n \n-    // 26.2.5/15\n-    // XXX: this is a grammar school implementation.\n-    template<typename _Tp>\n-       template<typename _Up>\n+  // 26.2.5/15\n+  // XXX: this is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n     complex<_Tp>&\n-    complex<_Tp>::operator/= (const complex<_Up>& __z)\n+    complex<_Tp>::operator/=(const complex<_Up>& __z)\n     {\n-        _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n-        _Tp __n = norm(__z);\n-        _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n-        _M_real = __r / __n;\n-        return *this;\n+      _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n+      _Tp __n = norm(__z);\n+      _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n+      _M_real = __r / __n;\n+      return *this;\n     }\n     \n-\n-    // Operators:\n-    template<typename _Tp>\n+  // Operators:\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) += __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const complex<_Tp>& __x, const _Tp& __y)\n     { return complex<_Tp> (__x) += __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const _Tp& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__y) += __x; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) -= __y; }\n     \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const complex<_Tp>& __x, const _Tp& __y)\n     { return complex<_Tp> (__x) -= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const _Tp& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) -= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) *= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator*(const complex<_Tp>& __x, const _Tp& __y)\n     { return complex<_Tp> (__x) *= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator*(const _Tp& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__y) *= __x; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) /= __y; }\n     \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator/(const complex<_Tp>& __x, const _Tp& __y)\n     { return complex<_Tp> (__x) /= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator/(const _Tp& __x, const complex<_Tp>& __y)\n     { return complex<_Tp> (__x) /= __y; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const complex<_Tp>& __x)\n     { return __x; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const complex<_Tp>& __x)\n     {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n-    { return __x.real() == __y.real() && __x.imag == __y.imag(); }\n+    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator==(const complex<_Tp>& __x, const _Tp& __y)\n     { return __x.real() == __y && __x.imag() == 0; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator==(const _Tp& __x, const complex<_Tp>& __y)\n     { return __x == __y.real() && 0 == __y.imag(); }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     { return __x.real() != __y.real() || __x.imag() != __y.imag(); }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator!=(const complex<_Tp>& __x, const _Tp& __y)\n-    {  return __x.real() != __y || __x.imag() != 0; }\n+    { return __x.real() != __y || __x.imag() != 0; }\n \n-    template<typename _Tp>\n+  template<typename _Tp>\n     inline bool\n     operator!=(const _Tp& __x, const complex<_Tp>& __y)\n     { return __x != __y.real() || 0 != __y.imag(); }\n \n-    template<typename _Tp, typename _CharT, class _Traits>\n+  template<typename _Tp, typename _CharT, class _Traits>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>&, complex<_Tp>&);\n \n-    template<typename _Tp, typename _CharT, class _Traits>\n+  template<typename _Tp, typename _CharT, class _Traits>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>&, const complex<_Tp>&);\n \n \n-    // Values:\n-    template <typename _Tp>\n+  // Values:\n+  template <typename _Tp>\n     inline _Tp\n-    real (const complex<_Tp>& __z)\n+    real(const complex<_Tp>& __z)\n     { return __z.real(); }\n     \n-    template <typename _Tp>\n+  template <typename _Tp>\n     inline _Tp\n-    imag (const complex<_Tp>& __z)\n+    imag(const complex<_Tp>& __z)\n     { return __z.imag(); }\n     \n \n-    // We use here a few more specializations.\n-    template<>\n+  // We use here a few more specializations.\n+  template<>\n     inline complex<float>\n     conj(const complex<float> &__x)\n #ifdef _GLIBCPP_BUGGY_FLOAT_COMPLEX\n@@ -946,21 +939,23 @@ namespace std\n       return __tmpf;\n     }\n #else\n-    { return complex<float>(~__x._M_value); }\n+  { return complex<float>(~__x._M_value); }\n #endif\n \n-    template<>\n+  template<>\n     inline complex<double>\n     conj(const complex<double> &__x)\n     {  return complex<double> (~__x._M_value); }\n \n-    template<>\n+  template<>\n     inline complex<long double>\n     conj(const complex<long double> &__x)\n-    {\n-        return complex<long double> (~__x._M_value);\n-    }\n+    { return complex<long double> (~__x._M_value); }\n \n } // namespace std\n \n #endif\t/* _CPP_COMPLEX */\n+\n+\n+\n+"}]}